- en: 10  Data Aggregation and Group Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 数据聚合和组操作
- en: 原文：[https://wesmckinney.com/book/data-aggregation](https://wesmckinney.com/book/data-aggregation)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://wesmckinney.com/book/data-aggregation](https://wesmckinney.com/book/data-aggregation)
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个*Python数据分析第3版*的开放访问网络版本现在作为[印刷版和数字版](https://amzn.to/3DyLaJc)的伴侣提供。如果您遇到任何勘误，请[在此报告](https://oreilly.com/catalog/0636920519829/errata)。请注意，由Quarto生成的本站的某些方面将与O’Reilly的印刷版和电子书版本的格式不同。'
- en: If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *Categorizing
    a dataset and applying a function to each group, whether an aggregation or transformation,
    can be a critical component of a data analysis workflow. After loading, merging,
    and preparing a dataset, you may need to compute group statistics or possibly
    *pivot tables* for reporting or visualization purposes. pandas provides a versatile
    `groupby` interface, enabling you to slice, dice, and summarize datasets in a
    natural way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现本书的在线版本有用，请考虑[订购纸质版](https://amzn.to/3DyLaJc)或[无DRM的电子书](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)以支持作者。本网站的内容不得复制或再生产。代码示例采用MIT许可，可在GitHub或Gitee上找到。*
    *对数据集进行分类并对每个组应用函数，无论是聚合还是转换，都可能是数据分析工作流程的关键组成部分。加载、合并和准备数据集后，您可能需要计算组统计信息或可能需要为报告或可视化目的计算*数据透视表*。pandas提供了一个多功能的`groupby`接口，使您能够以自然的方式切片、切块和总结数据集。
- en: 'One reason for the popularity of relational databases and SQL (which stands
    for “structured query language”) is the ease with which data can be joined, filtered,
    transformed, and aggregated. However, query languages like SQL impose certain
    limitations on the kinds of group operations that can be performed. As you will
    see, with the expressiveness of Python and pandas, we can perform quite complex
    group operations by expressing them as custom Python functions that manipulate
    the data associated with each group. In this chapter, you will learn how to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库和SQL（结构化查询语言）的流行原因之一是数据可以很容易地进行连接、过滤、转换和聚合。然而，像SQL这样的查询语言对可以执行的组操作类型施加了一定的限制。正如您将看到的，借助Python和pandas的表达力，我们可以通过将它们表达为自定义Python函数来执行相当复杂的组操作，这些函数操作与每个组相关联的数据。在本章中，您将学习如何：
- en: Split a pandas object into pieces using one or more keys (in the form of functions,
    arrays, or DataFrame column names)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个或多个键（以函数、数组或DataFrame列名的形式）将pandas对象分成片段
- en: Calculate group summary statistics, like count, mean, or standard deviation,
    or a user-defined function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算组摘要统计信息，如计数、均值或标准差，或用户定义的函数
- en: Apply within-group transformations or other manipulations, like normalization,
    linear regression, rank, or subset selection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用组内转换或其他操作，如归一化、线性回归、排名或子集选择
- en: Compute pivot tables and cross-tabulations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算数据透视表和交叉制表
- en: Perform quantile analysis and other statistical group analyses
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行分位数分析和其他统计组分析
- en: '*Note* *Time-based aggregation of time series data, a special use case of `groupby`,
    is referred to as *resampling* in this book and will receive separate treatment
    in [Ch 11: Time Series](/book/time-series).*  *As with the rest of the chapters,
    we start by importing NumPy and pandas:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *对时间序列数据进行基于时间的聚合，是`groupby`的一个特殊用例，在本书中被称为*重新采样*，将在[第11章：时间序列](/book/time-series)中单独处理。*与其他章节一样，我们首先导入NumPy和pandas：'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 10.1 How to Think About Group Operations
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 如何思考组操作
- en: Hadley Wickham, an author of many popular packages for the R programming language,
    coined the term *split-apply-combine* for describing group operations. In the
    first stage of the process, data contained in a pandas object, whether a Series,
    DataFrame, or otherwise, is *split* into groups based on one or more *keys* that
    you provide. The splitting is performed on a particular axis of an object. For
    example, a DataFrame can be grouped on its rows (`axis="index"`) or its columns
    (`axis="columns"`). Once this is done, a function is *applied* to each group,
    producing a new value. Finally, the results of all those function applications
    are *combined* into a result object. The form of the resulting object will usually
    depend on what’s being done to the data. See [Figure 10.1](#fig-figure_groupby_agg)
    for a mockup of a simple group aggregation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Hadley Wickham，R编程语言许多流行包的作者，为描述组操作创造了术语*split-apply-combine*。在过程的第一阶段中，包含在pandas对象中的数据，无论是Series、DataFrame还是其他形式，都根据您提供的一个或多个*键*被*分割*成组。分割是在对象的特定轴上执行的。例如，DataFrame可以根据其行（`axis="index"`）或列（`axis="columns"`）进行分组。完成此操作后，将*应用*一个函数到每个组，生成一个新值。最后，所有这些函数应用的结果将*合并*成一个结果对象。结果对象的形式通常取决于对数据的操作。请参见[图10.1](#fig-figure_groupby_agg)以查看简单组聚合的模拟。
- en: 'Each grouping key can take many forms, and the keys do not have to be all of
    the same type:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分组键可以采用多种形式，键不必是相同类型的：
- en: A list or array of values that is the same length as the axis being grouped
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个与被分组的轴长度相同的值列表或数组
- en: A value indicating a column name in a DataFrame
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataFrame中表示列名的值
- en: A dictionary or Series giving a correspondence between the values on the axis
    being grouped and the group names
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字典或Series，给出了被分组的轴上的值与组名之间的对应关系
- en: A function to be invoked on the axis index or the individual labels in the index
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在轴索引或索引中的个别标签上调用的函数
- en: '![](../Images/568aea090be607a174816297616d3b0d.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/568aea090be607a174816297616d3b0d.png)'
- en: 'Figure 10.1: Illustration of a group aggregation'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：组聚合的示例
- en: 'Note that the latter three methods are shortcuts for producing an array of
    values to be used to split up the object. Don’t worry if this all seems abstract.
    Throughout this chapter, I will give many examples of all these methods. To get
    started, here is a small tabular dataset as a DataFrame:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，后三种方法是用于生成用于拆分对象的值数组的快捷方式。如果这一切看起来很抽象，不要担心。在本章中，我将给出所有这些方法的许多示例。为了开始，这里是一个作为
    DataFrame 的小表格数据集：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Suppose you wanted to compute the mean of the `data1` column using the labels
    from `key1`. There are a number of ways to do this. One is to access `data1` and
    call `groupby` with the column (a Series) at `key1`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想使用 `key1` 标签计算 `data1` 列的均值。有多种方法可以做到这一点。一种方法是访问 `data1` 并使用 `key1` 列（一个
    Series）调用 `groupby`：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This `grouped` variable is now a special *"GroupBy"* object. It has not actually
    computed anything yet except for some intermediate data about the group key `df["key1"]`.
    The idea is that this object has all of the information needed to then apply some
    operation to each of the groups. For example, to compute group means we can call
    the GroupBy’s `mean` method:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `grouped` 变量现在是一个特殊的 *"GroupBy"* 对象。除了一些关于组键 `df["key1"]` 的中间数据之外，它实际上还没有计算任何东西。这个对象的想法是它包含了对每个组应用某些操作所需的所有信息。例如，要计算组均值，我们可以调用
    GroupBy 的 `mean` 方法：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Later in [Data Aggregation](#groupby_aggregation), I'll explain more about what
    happens when you call `.mean()`. The important thing here is that the data (a
    Series) has been aggregated by splitting the data on the group key, producing
    a new Series that is now indexed by the unique values in the `key1` column. The
    result index has the name `"key1"` because the DataFrame column `df["key1"]` did.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后在 [数据聚合](#groupby_aggregation) 中，我将更详细地解释当你调用 `.mean()` 时会发生什么。这里重要的是，数据（一个
    Series）已经通过在组键上拆分数据进行聚合，产生了一个新的 Series，现在由 `key1` 列中的唯一值进行索引。结果索引的名称是 `"key1"`，因为
    DataFrame 列 `df["key1"]` 是这样的。
- en: 'If instead we had passed multiple arrays as a list, we''d get something different:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递了多个数组作为列表，将会得到不同的结果：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here we grouped the data using two keys, and the resulting Series now has a
    hierarchical index consisting of the unique pairs of keys observed:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用两个键对数据进行分组，结果 Series 现在具有由观察到的唯一键对组成的分层索引：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, the group keys are all Series, though they could be any arrays
    of the right length:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，组键都是 Series，尽管它们可以是任何正确长度的数组：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Frequently, the grouping information is found in the same DataFrame as the
    data you want to work on. In that case, you can pass column names (whether those
    are strings, numbers, or other Python objects) as the group keys:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，分组信息在与你要处理的数据相同的 DataFrame 中找到。在这种情况下，你可以将列名（无论是字符串、数字还是其他 Python 对象）作为组键传递：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You may notice that in the second case, it is necessary to pass `numeric_only=True`
    because the `key1` column is not numeric and thus cannot be aggregated with `mean()`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在第二种情况下，有必要传递 `numeric_only=True`，因为 `key1` 列不是数值列，因此不能使用 `mean()` 进行聚合。
- en: 'Regardless of the objective in using `groupby`, a generally useful GroupBy
    method is `size`, which returns a Series containing group sizes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用 `groupby` 的目的是什么，一个通常有用的 GroupBy 方法是 `size`，它返回一个包含组大小的 Series：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that any missing values in a group key are excluded from the result by
    default. This behavior can be disabled by passing `dropna=False` to `groupby`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，组键中的任何缺失值都会被排除在结果之外。通过将 `dropna=False` 传递给 `groupby` 可以禁用此行为：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A group function similar in spirit to `size` is count, which computes the number
    of nonnull values in each group:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一种类似于 `size` 的组函数是 count，它计算每个组中的非空值的数量：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Iterating over Groups
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历组
- en: 'The object returned by `groupby` supports iteration, generating a sequence
    of 2-tuples containing the group name along with the chunk of data. Consider the
    following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby` 返回的对象支持迭代，生成一个包含组名和数据块的 2 元组序列。考虑以下内容：'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the case of multiple keys, the first element in the tuple will be a tuple
    of key values:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个键的情况下，元组中的第一个元素将是一个键值的元组：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Of course, you can choose to do whatever you want with the pieces of data.
    A recipe you may find useful is computing a dictionary of the data pieces as a
    one-liner:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以选择对数据块做任何你想做的事情。一个你可能会发现有用的方法是将数据块计算为一个字典：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'By default `groupby` groups on `axis="index"`, but you can group on any of
    the other axes. For example, we could group the columns of our example `df` here
    by whether they start with `"key"` or `"data"`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`groupby` 在 `axis="index"` 上进行分组，但你可以在任何其他轴上进行分组。例如，我们可以按照我们的示例 `df` 的列是否以
    `"key"` 或 `"data"` 开头进行分组：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can print out the groups like so:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以这样打印出组： '
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Selecting a Column or Subset of Columns
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择列或列的子集
- en: 'Indexing a GroupBy object created from a DataFrame with a column name or array
    of column names has the effect of column subsetting for aggregation. This means
    that:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从 DataFrame 创建的 GroupBy 对象进行索引，使用列名或列名数组会对聚合进行列子集操作。这意味着：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'are conveniences for:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 是方便的：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Especially for large datasets, it may be desirable to aggregate only a few
    columns. For example, in the preceding dataset, to compute the means for just
    the `data2` column and get the result as a DataFrame, we could write:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是对于大型数据集，可能只需要聚合几列。例如，在前面的数据集中，仅计算 `data2` 列的均值并将结果作为 DataFrame 获取，我们可以这样写：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The object returned by this indexing operation is a grouped DataFrame if a
    list or array is passed, or a grouped Series if only a single column name is passed
    as a scalar:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种索引操作返回的对象是一个分组的 DataFrame（如果传递了列表或数组），或者是一个分组的 Series（如果只传递了一个列名作为标量）：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Grouping with Dictionaries and Series
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字典和 Series 进行分组
- en: 'Grouping information may exist in a form other than an array. Let’s consider
    another example DataFrame:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 分组信息可能以其他形式存在，而不仅仅是数组。让我们考虑另一个示例 DataFrame：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, suppose I have a group correspondence for the columns and want to sum
    the columns by group:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我有列的分组对应关系，并且想要按组对列求和：
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, you could construct an array from this dictionary to pass to `groupby`,
    but instead we can just pass the dictionary (I included the key `"f"` to highlight
    that unused grouping keys are OK):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从这个字典构造一个数组传递给`groupby`，但我们可以直接传递字典（我包含了键`"f"`来突出显示未使用的分组键是可以的）：
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The same functionality holds for Series, which can be viewed as a fixed-size
    mapping:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的功能也适用于Series，它可以被视为一个固定大小的映射：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Grouping with Functions
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用函数分组
- en: 'Using Python functions is a more generic way of defining a group mapping compared
    with a dictionary or Series. Any function passed as a group key will be called
    once per index value (or once per column value if using `axis="columns"`), with
    the return values being used as the group names. More concretely, consider the
    example DataFrame from the previous section, which has people’s first names as
    index values. Suppose you wanted to group by name length. While you could compute
    an array of string lengths, it''s simpler to just pass the `len` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python函数比使用字典或Series定义分组映射更通用。作为分组键传递的任何函数将针对每个索引值（或者如果使用`axis="columns"`则是每个列值）调用一次，返回值将用作分组名称。更具体地，考虑前一节中的示例DataFrame，其中人们的名字作为索引值。假设您想按名称长度分组。虽然您可以计算一个字符串长度的数组，但更简单的方法是只传递`len`函数：
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Mixing functions with arrays, dictionaries, or Series is not a problem, as
    everything gets converted to arrays internally:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数与数组、字典或Series混合在一起不是问题，因为所有内容在内部都会转换为数组：
- en: '[PRE25]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Grouping by Index Levels
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按索引级别分组
- en: 'A final convenience for hierarchically indexed datasets is the ability to aggregate
    using one of the levels of an axis index. Let''s look at an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有层次索引的数据集，最后一个便利之处是能够使用轴索引的一个级别进行聚合。让我们看一个例子：
- en: '[PRE26]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To group by level, pass the level number or name using the `level` keyword:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要按级别分组，请使用`level`关键字传递级别编号或名称：
- en: '[PRE27]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 10.2 Data Aggregation
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 数据聚合
- en: '*Aggregations* refer to any data transformation that produces scalar values
    from arrays. The preceding examples have used several of them, including `mean`,
    `count`, `min`, and `sum`. You may wonder what is going on when you invoke `mean()`
    on a GroupBy object. Many common aggregations, such as those found in [Table 10.1](#tbl-table_opt_groupby_methods),
    have optimized implementations. However, you are not limited to only this set
    of methods.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*聚合*指的是从数组中产生标量值的任何数据转换。前面的示例中使用了其中几个，包括`mean`、`count`、`min`和`sum`。当您在GroupBy对象上调用`mean()`时，您可能会想知道发生了什么。许多常见的聚合，如[表10.1](#tbl-table_opt_groupby_methods)中找到的那些，都有优化的实现。但是，您不仅限于这组方法。'
- en: 'Table 10.1: Optimized `groupby` methods'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1：优化的`groupby`方法
- en: '| Function name | Description |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 函数名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `any, all` | Return `True` if any (one or more values) or all non-NA values
    are "truthy" |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `any, all` | 如果任何（一个或多个值）或所有非NA值为“真值”则返回`True` |'
- en: '| `count` | Number of non-NA values |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `count` | 非NA值的数量 |'
- en: '| `cummin, cummax` | Cumulative minimum and maximum of non-NA values |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `cummin, cummax` | 非NA值的累积最小值和最大值 |'
- en: '| `cumsum` | Cumulative sum of non-NA values |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `cumsum` | 非NA值的累积和 |'
- en: '| `cumprod` | Cumulative product of non-NA values |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `cumprod` | 非NA值的累积乘积 |'
- en: '| `first, last` | First and last non-NA values |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `first, last` | 首个和最后一个非NA值 |'
- en: '| `mean` | Mean of non-NA values |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `mean` | 非NA值的均值 |'
- en: '| `median` | Arithmetic median of non-NA values |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `median` | 非NA值的算术中位数 |'
- en: '| `min, max` | Minimum and maximum of non-NA values |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `min, max` | 非NA值的最小值和最大值 |'
- en: '| `nth` | Retrieve value that would appear at position `n` with the data in
    sorted order |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `nth` | 检索在排序顺序中出现在位置`n`的值 |'
- en: '| `ohlc` | Compute four "open-high-low-close" statistics for time series-like
    data |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `ohlc` | 为类似时间序列的数据计算四个“开盘-最高-最低-收盘”统计数据 |'
- en: '| `prod` | Product of non-NA values |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `prod` | 非NA值的乘积 |'
- en: '| `quantile` | Compute sample quantile |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `quantile` | 计算样本分位数 |'
- en: '| `rank` | Ordinal ranks of non-NA values, like calling `Series.rank` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `rank` | 非NA值的序数排名，类似于调用`Series.rank` |'
- en: '| `size` | Compute group sizes, returning result as a Series |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `size` | 计算组大小，将结果返回为Series |'
- en: '| `sum` | Sum of non-NA values |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `sum` | 非NA值的总和 |'
- en: '| `std, var` | Sample standard deviation and variance |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `std, var` | 样本标准差和方差 |'
- en: 'You can use aggregations of your own devising and additionally call any method
    that is also defined on the object being grouped. For example, the `nsmallest`
    Series method selects the smallest requested number of values from the data. While
    `nsmallest` is not explicitly implemented for GroupBy, we can still use it with
    a nonoptimized implementation. Internally, GroupBy slices up the Series, calls
    `piece.nsmallest(n)` for each piece, and then assembles those results into the
    result object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用自己设计的聚合，并额外调用任何也在被分组对象上定义的方法。例如，`nsmallest` Series方法从数据中选择请求的最小数量的值。虽然`nsmallest`没有明确为GroupBy实现，但我们仍然可以使用它与非优化的实现。在内部，GroupBy将Series切片，为每个片段调用`piece.nsmallest(n)`，然后将这些结果组装成结果对象：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To use your own aggregation functions, pass any function that aggregates an
    array to the `aggregate` method or its short alias `agg`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用自己的聚合函数，只需将任何聚合数组的函数传递给`aggregate`方法或其简短别名`agg`：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You may notice that some methods, like `describe`, also work, even though they
    are not aggregations, strictly speaking:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到一些方法，比如`describe`，即使严格来说它们不是聚合也可以工作：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'I will explain in more detail what has happened here in [Apply: General split-apply-combine](#groupby_apply).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[应用：通用的分割-应用-合并](#groupby_apply)中更详细地解释这里发生了什么。
- en: '*Note* *Custom aggregation functions are generally much slower than the optimized
    functions found in [Table 10.1](#tbl-table_opt_groupby_methods). This is because
    there is some extra overhead (function calls, data rearrangement) in constructing
    the intermediate group data chunks.*  *### Column-Wise and Multiple Function Application'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *自定义聚合函数通常比在[Table 10.1](#tbl-table_opt_groupby_methods)中找到的优化函数慢得多。这是因为在构建中间组数据块时存在一些额外开销（函数调用，数据重新排列）*###
    按列和多函数应用'
- en: 'Let''s return to the tipping dataset used in the last chapter. After loading
    it with `pandas.read_csv`, we add a tipping percentage column:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到上一章中使用的小费数据集。在使用`pandas.read_csv`加载后，我们添加一个小费百分比列：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now I will add a `tip_pct` column with the tip percentage of the total bill:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将添加一个`tip_pct`列，其中包含总账单的小费百分比：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you’ve already seen, aggregating a Series or all of the columns of a DataFrame
    is a matter of using `aggregate` (or `agg`) with the desired function or calling
    a method like `mean` or `std`. However, you may want to aggregate using a different
    function, depending on the column, or multiple functions at once. Fortunately,
    this is possible to do, which I’ll illustrate through a number of examples. First,
    I’ll group the `tips` by `day` and `smoker`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的，聚合Series或DataFrame的所有列是使用`aggregate`（或`agg`）与所需函数或调用`mean`或`std`方法的问题。但是，您可能希望根据列使用不同的函数进行聚合，或者一次使用多个函数。幸运的是，这是可能的，我将通过一些示例来说明。首先，我将按`day`和`smoker`对`tips`进行分组：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that for descriptive statistics like those in [Table 10.1](#tbl-table_opt_groupby_methods),
    you can pass the name of the function as a string:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于像[Table 10.1](#tbl-table_opt_groupby_methods)中的描述性统计数据，您可以将函数的名称作为字符串传递：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you pass a list of functions or function names instead, you get back a DataFrame
    with column names taken from the functions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您传递的是函数或函数名称的列表，您将获得一个列名从函数中获取的DataFrame：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here we passed a list of aggregation functions to `agg` to evaluate independently
    on the data groups.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将一系列聚合函数传递给`agg`，以独立评估数据组。
- en: 'You don’t need to accept the names that GroupBy gives to the columns; notably,
    `lambda` functions have the name `"<lambda>"`, which makes them hard to identify
    (you can see for yourself by looking at a function’s `__name__` attribute). Thus,
    if you pass a list of `(name, function)` tuples, the first element of each tuple
    will be used as the DataFrame column names (you can think of a list of 2-tuples
    as an ordered mapping):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要接受GroupBy为列提供的名称；特别是，`lambda`函数的名称为`"<lambda>"`，这使得它们难以识别（您可以通过查看函数的`__name__`属性来自行查看）。因此，如果您传递一个`(name,
    function)`元组的列表，每个元组的第一个元素将被用作DataFrame列名（您可以将2元组的列表视为有序映射）：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With a DataFrame you have more options, as you can specify a list of functions
    to apply to all of the columns or different functions per column. To start, suppose
    we wanted to compute the same three statistics for the `tip_pct` and `total_bill`
    columns:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DataFrame，您有更多的选项，因为您可以指定要应用于所有列或不同列的不同函数的函数列表。首先，假设我们想要计算`tip_pct`和`total_bill`列的相同三个统计数据：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see, the resulting DataFrame has hierarchical columns, the same
    as you would get aggregating each column separately and using `concat` to glue
    the results together using the column names as the `keys` argument:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，生成的DataFrame具有分层列，与分别聚合每列并使用列名作为`keys`参数使用`concat`粘合结果时获得的结果相同：
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As before, a list of tuples with custom names can be passed:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，可以传递具有自定义名称的元组列表：
- en: '[PRE39]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, suppose you wanted to apply potentially different functions to one or
    more of the columns. To do this, pass a dictionary to `agg` that contains a mapping
    of column names to any of the function specifications listed so far:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您想要对一个或多个列应用可能不同的函数。为此，请将包含列名到迄今为止列出的任何函数规范的映射的字典传递给`agg`：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: A DataFrame will have hierarchical columns only if multiple functions are applied
    to at least one column.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在至少对一列应用多个函数时，DataFrame才会具有分层列。
- en: Returning Aggregated Data Without Row Indexes
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回不带行索引的聚合数据
- en: 'In all of the examples up until now, the aggregated data comes back with an
    index, potentially hierarchical, composed from the unique group key combinations.
    Since this isn’t always desirable, you can disable this behavior in most cases
    by passing `as_index=False` to `groupby`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的所有示例中，聚合数据都带有一个索引，可能是分层的，由唯一的组键组合组成。由于这并不总是理想的，您可以通过在大多数情况下将`as_index=False`传递给`groupby`来禁用此行为：
- en: '[PRE41]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Of course, it’s always possible to obtain the result in this format by calling
    `reset_index` on the result. Using the `as_index=False` argument avoids some unnecessary
    computations.*  *## 10.3 Apply: General split-apply-combine'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，通过在结果上调用`reset_index`，总是可以以这种格式获得结果。使用`as_index=False`参数可以避免一些不必要的计算。*##
    10.3 应用：通用的分割-应用-合并
- en: The most general-purpose GroupBy method is `apply`, which is the subject of
    this section. `apply` splits the object being manipulated into pieces, invokes
    the passed function on each piece, and then attempts to concatenate the pieces.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最通用的GroupBy方法是`apply`，这是本节的主题。`apply`将被操作的对象分割成片段，对每个片段调用传递的函数，然后尝试连接这些片段。
- en: 'Returning to the tipping dataset from before, suppose you wanted to select
    the top five `tip_pct` values by group. First, write a function that selects the
    rows with the largest values in a particular column:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 回到以前的小费数据集，假设您想要按组选择前五个`tip_pct`值。首先，编写一个函数，该函数选择特定列中最大值的行：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, if we group by `smoker`, say, and call `apply` with this function, we
    get the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们按`smoker`分组，并使用此函数调用`apply`，我们将得到以下结果：
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: What has happened here? First, the `tips` DataFrame is split into groups based
    on the value of `smoker`. Then the `top` function is called on each group, and
    the results of each function call are glued together using `pandas.concat`, labeling
    the pieces with the group names. The result therefore has a hierarchical index
    with an inner level that contains index values from the original DataFrame.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？首先，根据`smoker`的值将`tips` DataFrame分成组。然后在每个组上调用`top`函数，并使用`pandas.concat`将每个函数调用的结果粘合在一起，用组名标记各个部分。因此，结果具有一个具有内部级别的分层索引，该级别包含原始DataFrame的索引值。
- en: 'If you pass a function to `apply` that takes other arguments or keywords, you
    can pass these after the function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将一个接受其他参数或关键字的函数传递给`apply`，则可以在函数之后传递这些参数：
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Beyond these basic usage mechanics, getting the most out of `apply` may require
    some creativity. What occurs inside the function passed is up to you; it must
    either return a pandas object or a scalar value. The rest of this chapter will
    consist mainly of examples showing you how to solve various problems using `groupby`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些基本的使用机制外，要充分利用`apply`可能需要一些创造力。传递的函数内部发生的事情取决于你；它必须返回一个pandas对象或一个标量值。本章的其余部分主要将包含示例，向您展示如何使用`groupby`解决各种问题。
- en: 'For example, you may recall that I earlier called `describe` on a GroupBy object:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能还记得我之前在GroupBy对象上调用`describe`：
- en: '[PRE45]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Inside GroupBy, when you invoke a method like `describe`, it is actually just
    a shortcut for:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在GroupBy中，当你调用像`describe`这样的方法时，实际上只是一个快捷方式：
- en: '[PRE46]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Suppressing the Group Keys
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抑制组键
- en: 'In the preceding examples, you see that the resulting object has a hierarchical
    index formed from the group keys, along with the indexes of each piece of the
    original object. You can disable this by passing `group_keys=False` to `groupby`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您可以看到生成的对象具有从组键形成的分层索引，以及原始对象的每个部分的索引。您可以通过将`group_keys=False`传递给`groupby`来禁用这一点：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Quantile and Bucket Analysis
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分位数和桶分析
- en: 'As you may recall from [Ch 8: Data Wrangling: Join, Combine, and Reshape](/book/data-wrangling),
    pandas has some tools, in particular `pandas.cut` and `pandas.qcut`, for slicing
    data up into buckets with bins of your choosing, or by sample quantiles. Combining
    these functions with `groupby` makes it convenient to perform bucket or quantile
    analysis on a dataset. Consider a simple random dataset and an equal-length bucket
    categorization using `pandas.cut`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能从[第8章：数据整理：连接、合并和重塑](/book/data-wrangling)中记得的那样，pandas有一些工具，特别是`pandas.cut`和`pandas.qcut`，可以将数据切分成您选择的桶或样本分位数。将这些函数与`groupby`结合起来，可以方便地对数据集进行桶或分位数分析。考虑一个简单的随机数据集和使用`pandas.cut`进行等长度桶分类：
- en: '[PRE48]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `Categorical` object returned by `cut` can be passed directly to `groupby`.
    So we could compute a set of group statistics for the quartiles, like so:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`cut`返回的`Categorical`对象可以直接传递给`groupby`。因此，我们可以计算四分位数的一组组统计信息，如下所示：'
- en: '[PRE49]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Keep in mind the same result could have been computed more simply with:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，同样的结果可以更简单地计算为：
- en: '[PRE50]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'These were equal-length buckets; to compute equal-size buckets based on sample
    quantiles, use `pandas.qcut`. We can pass `4` as the number of bucket compute
    sample quartiles, and pass `labels=False` to obtain just the quartile indices
    instead of intervals:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是等长度的桶；要基于样本分位数计算等大小的桶，使用`pandas.qcut`。我们可以将`4`作为桶的数量计算样本四分位数，并传递`labels=False`以仅获取四分位数索引而不是间隔：
- en: '[PRE51]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Example: Filling Missing Values with Group-Specific Values'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：使用组特定值填充缺失值
- en: 'When cleaning up missing data, in some cases you will remove data observations
    using `dropna`, but in others you may want to fill in the null (NA) values using
    a fixed value or some value derived from the data. `fillna` is the right tool
    to use; for example, here I fill in the null values with the mean:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在清理缺失数据时，有些情况下您将使用`dropna`删除数据观察值，但在其他情况下，您可能希望使用固定值或从数据中派生的某个值填充空（NA）值。`fillna`是正确的工具；例如，这里我用均值填充了空值：
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Suppose you need the fill value to vary by group. One way to do this is to
    group the data and use `apply` with a function that calls `fillna` on each data
    chunk. Here is some sample data on US states divided into eastern and western
    regions:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要填充值根据组而变化。一种方法是对数据进行分组，并使用调用`fillna`的函数在每个数据块上使用`apply`。这里是一些关于美国各州的样本数据，分为东部和西部地区：
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s set some values in the data to be missing:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将数据中的一些值设置为缺失：
- en: '[PRE54]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can fill the NA values using the group means, like so:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用组均值填充NA值，如下所示：
- en: '[PRE55]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In another case, you might have predefined fill values in your code that vary
    by group. Since the groups have a `name` attribute set internally, we can use
    that:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一种情况下，您可能在代码中预定义了根据组变化的填充值。由于组内部设置了`name`属性，我们可以使用它：
- en: '[PRE56]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Example: Random Sampling and Permutation'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：随机抽样和排列
- en: Suppose you wanted to draw a random sample (with or without replacement) from
    a large dataset for Monte Carlo simulation purposes or some other application.
    There are a number of ways to perform the “draws”; here we use the `sample` method
    for Series.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要从大型数据集中随机抽取（有或没有替换）用于蒙特卡洛模拟或其他应用。有许多执行“抽取”的方法；在这里，我们使用Series的`sample`方法。
- en: 'To demonstrate, here’s a way to construct a deck of English-style playing cards:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，这里有一种构建一副英式扑克牌的方法：
- en: '[PRE57]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now we have a Series of length 52 whose index contains card names, and values
    are the ones used in blackjack and other games (to keep things simple, I let the
    ace `"A"` be 1):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个长度为52的Series，其索引包含牌名，值是在二十一点和其他游戏中使用的值（为了简单起见，我让ace `"A"`为1）：
- en: '[PRE58]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, based on what I said before, drawing a hand of five cards from the deck
    could be written as:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据我之前说的，从牌组中抽取五张牌可以写成：
- en: '[PRE59]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Suppose you wanted two random cards from each suit. Because the suit is the
    last character of each card name, we can group based on this and use `apply`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要从每种花色中抽取两张随机牌。因为花色是每张牌名称的最后一个字符，我们可以根据这个进行分组，并使用`apply`：
- en: '[PRE60]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Alternatively, we could pass `group_keys=False` to drop the outer suit index,
    leaving in just the selected cards:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以传递`group_keys=False`以删除外部套索索引，只留下所选的卡：
- en: '[PRE61]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Example: Group Weighted Average and Correlation'
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：组加权平均和相关性
- en: 'Under the split-apply-combine paradigm of `groupby`, operations between columns
    in a DataFrame or two Series, such as a group weighted average, are possible.
    As an example, take this dataset containing group keys, values, and some weights:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`groupby`的分割-应用-组合范式下，DataFrame或两个Series中的列之间的操作，例如组加权平均，是可能的。例如，考虑包含组键、值和一些权重的数据集：
- en: '[PRE62]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The weighted average by `category` would then be:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 按`category`加权平均值将是：
- en: '[PRE63]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As another example, consider a financial dataset originally obtained from Yahoo!
    Finance containing end-of-day prices for a few stocks and the S&P 500 index (the
    `SPX` symbol):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，考虑一个最初从Yahoo! Finance获取的金融数据集，其中包含一些股票的日终价格和标准普尔500指数（`SPX`符号）：
- en: '[PRE64]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The DataFrame `info()` method here is a convenient way to get an overview of
    the contents of a DataFrame.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的DataFrame `info()`方法是获取DataFrame内容概述的便捷方式。
- en: 'One task of interest might be to compute a DataFrame consisting of the yearly
    correlations of daily returns (computed from percent changes) with `SPX`. As one
    way to do this, we first create a function that computes the pair-wise correlation
    of each column with the `"SPX"` column:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个感兴趣的任务可能是计算一个由每日收益（从百分比变化计算）与`SPX`的年度相关性组成的DataFrame。作为一种方法，我们首先创建一个函数，计算每列与`"SPX"`列的成对相关性：
- en: '[PRE65]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, we compute percent change on `close_px` using `pct_change`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`pct_change`计算`close_px`的百分比变化：
- en: '[PRE66]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Lastly, we group these percent changes by year, which can be extracted from
    each row label with a one-line function that returns the `year` attribute of each
    `datetime` label:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们按年将这些百分比变化分组，可以使用一个一行函数从每个行标签中提取`datetime`标签的`year`属性：
- en: '[PRE67]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You could also compute intercolumn correlations. Here we compute the annual
    correlation between Apple and Microsoft:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以计算列间的相关性。这里我们计算苹果和微软之间的年度相关性：
- en: '[PRE68]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Example: Group-Wise Linear Regression'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：组内线性回归
- en: 'In the same theme as the previous example, you can use `groupby` to perform
    more complex group-wise statistical analysis, as long as the function returns
    a pandas object or scalar value. For example, I can define the following `regress`
    function (using the `statsmodels` econometrics library), which executes an ordinary
    least squares (OLS) regression on each chunk of data:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例相同，您可以使用`groupby`执行更复杂的组内统计分析，只要函数返回一个pandas对象或标量值。例如，我可以定义以下`regress`函数（使用`statsmodels`计量经济学库），它在每个数据块上执行普通最小二乘（OLS）回归：
- en: '[PRE69]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You can install `statsmodels` with conda if you don''t have it already:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装`statsmodels`，可以使用conda安装它：
- en: '[PRE70]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, to run a yearly linear regression of `AAPL` on `SPX` returns, execute:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要在`AAPL`对`SPX`回报的年度线性回归中执行：
- en: '[PRE71]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 10.4 Group Transforms and "Unwrapped" GroupBys
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 组转换和“展开”的GroupBys
- en: 'In [Apply: General split-apply-combine](#groupby_apply), we looked at the `apply`
    method in grouped operations for performing transformations. There is another
    built-in method called `transform`, which is similar to `apply` but imposes more
    constraints on the kind of function you can use:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '在[Apply: General split-apply-combine](#groupby_apply)中，我们看了一下在分组操作中执行转换的`apply`方法。还有另一个内置方法叫做`transform`，它类似于`apply`，但对您可以使用的函数种类施加了更多的约束：'
- en: It can produce a scalar value to be broadcast to the shape of the group.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以生成一个标量值广播到组的形状。
- en: It can produce an object of the same shape as the input group.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以生成与输入组相同形状的对象。
- en: It must not mutate its input.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能改变其输入。
- en: 'Let''s consider a simple example for illustration:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的例子以说明：
- en: '[PRE72]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here are the group means by key:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是按键的组平均值：
- en: '[PRE73]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Suppose instead we wanted to produce a Series of the same shape as `df[''value'']`
    but with values replaced by the average grouped by `''key''`. We can pass a function
    that computes the mean of a single group to `transform`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要生成一个与`df['value']`相同形状的Series，但值被按`'key'`分组后的平均值替换。我们可以传递一个计算单个组平均值的函数给`transform`：
- en: '[PRE74]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'For built-in aggregation functions, we can pass a string alias as with the
    GroupBy `agg` method:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内置的聚合函数，我们可以像GroupBy `agg`方法一样传递一个字符串别名：
- en: '[PRE75]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Like `apply`, `transform` works with functions that return Series, but the
    result must be the same size as the input. For example, we can multiply each group
    by 2 using a helper function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与`apply`一样，`transform`适用于返回Series的函数，但结果必须与输入的大小相同。例如，我们可以使用一个辅助函数将每个组乘以2：
- en: '[PRE76]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As a more complicated example, we can compute the ranks in descending order
    for each group:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个更复杂的例子，我们可以计算每个组按降序排名：
- en: '[PRE77]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Consider a group transformation function composed from simple aggregations:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个由简单聚合组成的组转换函数：
- en: '[PRE78]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can obtain equivalent results in this case using either `transform` or `apply`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用`transform`或`apply`获得等效的结果：
- en: '[PRE79]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Built-in aggregate functions like `''mean''` or `''sum''` are often much faster
    than a general `apply` function. These also have a "fast path" when used with
    `transform`. This allows us to perform what is called an *unwrapped* group operation:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的聚合函数如`'mean'`或`'sum'`通常比一般的`apply`函数快得多。当与`transform`一起使用时，这些函数也有一个“快速路径”。这使我们能够执行所谓的*展开*组操作：
- en: '[PRE80]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, we are doing arithmetic between the outputs of multiple GroupBy operations
    instead of writing a function and passing it to `groupby(...).apply`. That is
    what is meant by "unwrapped."
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在多个GroupBy操作的输出之间进行算术运算，而不是编写一个函数并将其传递给`groupby(...).apply`。这就是所谓的“展开”。
- en: While an unwrapped group operation may involve multiple group aggregations,
    the overall benefit of vectorized operations often outweighs this.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管展开的组操作可能涉及多个组聚合，但矢量化操作的整体效益通常超过了这一点。
- en: 10.5 Pivot Tables and Cross-Tabulation
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 透视表和交叉制表
- en: A *pivot table* is a data summarization tool frequently found in spreadsheet
    programs and other data analysis software. It aggregates a table of data by one
    or more keys, arranging the data in a rectangle with some of the group keys along
    the rows and some along the columns. Pivot tables in Python with pandas are made
    possible through the `groupby` facility described in this chapter, combined with
    reshape operations utilizing hierarchical indexing. DataFrame also has a `pivot_table`
    method, and there is also a top-level `pandas.pivot_table` function. In addition
    to providing a convenience interface to `groupby`, `pivot_table` can add partial
    totals, also known as *margins*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*透视表*是一种经常在电子表格程序和其他数据分析软件中找到的数据汇总工具。它通过一个或多个键对数据表进行聚合，将数据排列在一个矩形中，其中一些组键沿行排列，另一些沿列排列。在Python中，通过本章描述的`groupby`功能以及利用分层索引进行重塑操作，可以实现使用pandas的透视表。DataFrame还有一个`pivot_table`方法，还有一个顶级的`pandas.pivot_table`函数。除了提供一个方便的`groupby`接口外，`pivot_table`还可以添加部分总计，也称为*边际*。'
- en: 'Returning to the tipping dataset, suppose you wanted to compute a table of
    group means (the default `pivot_table` aggregation type) arranged by `day` and
    `smoker` on the rows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '返回到小费数据集，假设您想要计算按`day`和`smoker`排列的组平均值的表格（默认的`pivot_table`聚合类型）： '
- en: '[PRE81]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This could have been produced with `groupby` directly, using `tips.groupby(["day",
    "smoker"]).mean()`. Now, suppose we want to take the average of only `tip_pct`
    and `size`, and additionally group by `time`. I’ll put `smoker` in the table columns
    and `time` and `day` in the rows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以直接使用`groupby`生成，使用`tips.groupby(["day", "smoker"]).mean()`。现在，假设我们只想计算`tip_pct`和`size`的平均值，并另外按`time`分组。我将`smoker`放在表格列中，`time`和`day`放在行中：
- en: '[PRE82]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We could augment this table to include partial totals by passing `margins=True`.
    This has the effect of adding `All` row and column labels, with corresponding
    values being the group statistics for all the data within a single tier:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过传递`margins=True`来增加此表，以包括部分总计。这将添加`All`行和列标签，相应的值是单个层次内所有数据的组统计信息：
- en: '[PRE83]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Here, the `All` values are means without taking into account smoker versus non-smoker
    (the `All` columns) or any of the two levels of grouping on the rows (the `All`
    row).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`All`值是没有考虑吸烟者与非吸烟者（`All`列）或行中的两个级别分组的平均值（`All`行）。
- en: 'To use an aggregation function other than `mean`, pass it to the `aggfunc`
    keyword argument. For example, `"count"` or `len` will give you a cross-tabulation
    (count or frequency) of group sizes (though `"count"` will exclude null values
    from the count within data groups, while `len` will not):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用除`mean`之外的聚合函数，请将其传递给`aggfunc`关键字参数。例如，`"count"`或`len`将为您提供组大小的交叉制表（计数或频率）（尽管`"count"`将在数据组内排除空值的计数，而`len`不会）：
- en: '[PRE84]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If some combinations are empty (or otherwise NA), you may wish to pass a `fill_value`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些组合为空（或其他NA），您可能希望传递一个`fill_value`：
- en: '[PRE85]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: See [Table 10.2](#tbl-table_pivot_table) for a summary of `pivot_table` options.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[表10.2](#tbl-table_pivot_table)以获取`pivot_table`选项的摘要。
- en: 'Table 10.2: `pivot_table` options'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.2：`pivot_table`选项
- en: '| Argument | Description |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `values` | Column name or names to aggregate; by default, aggregates all
    numeric columns |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `values` | 要聚合的列名；默认情况下，聚合所有数值列 |'
- en: '| `index` | Column names or other group keys to group on the rows of the resulting
    pivot table |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `index` | 要在生成的透视表的行上分组的列名或其他组键 |'
- en: '| `columns` | Column names or other group keys to group on the columns of the
    resulting pivot table |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `columns` | 要在生成的透视表的列上分组的列名或其他组键 |'
- en: '| `aggfunc` | Aggregation function or list of functions (`"mean"` by default);
    can be any function valid in a `groupby` context |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `aggfunc` | 聚合函数或函数列表（默认为`"mean"`）；可以是在`groupby`上下文中有效的任何函数 |'
- en: '| `fill_value` | Replace missing values in the result table |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `fill_value` | 替换结果表中的缺失值 |'
- en: '| `dropna` | If `True`, do not include columns whose entries are all `NA` |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `dropna` | 如果为`True`，则不包括所有条目都为`NA`的列 |'
- en: '| `margins` | Add row/column subtotals and grand total (`False` by default)
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `margins` | 添加行/列小计和总计（默认为`False`） |'
- en: '| `margins_name` | Name to use for the margin row/column labels when passing
    `margins=True`; defaults to `"All"` |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `margins_name` | 在传递`margins=True`时用于边缘行/列标签的名称；默认为`"All"` |'
- en: '| `observed` | With Categorical group keys, if `True`, show only the observed
    category values in the keys rather than all categories |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `observed` | 使用分类组键，如果为`True`，则仅显示键中的观察类别值，而不是所有类别 |'
- en: 'Cross-Tabulations: Crosstab'
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交叉制表：交叉制表
- en: 'A *cross-tabulation* (or *crosstab* for short) is a special case of a pivot
    table that computes group frequencies. Here is an example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*交叉制表*（或简称为*交叉制表*）是计算组频率的透视表的一种特殊情况。这里是一个例子：'
- en: '[PRE86]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'As part of some survey analysis, we might want to summarize this data by nationality
    and handedness. You could use `pivot_table` to do this, but the `pandas.crosstab`
    function can be more convenient:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一些调查分析的一部分，我们可能希望按国籍和惯用手总结这些数据。您可以使用`pivot_table`来做到这一点，但`pandas.crosstab`函数可能更方便：
- en: '[PRE88]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The first two arguments to `crosstab` can each be an array or Series or a list
    of arrays. As in the tips data:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`crosstab`的前两个参数可以是数组、Series或数组列表。就像在小费数据中一样：'
- en: '[PRE89]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 10.6 Conclusion
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 结论
- en: 'Mastering pandas''s data grouping tools can help with data cleaning and modeling
    or statistical analysis work. In [Ch 13: Data Analysis Examples](#data-analysis-examples)
    we will look at several more example use cases for `groupby` on real data.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握pandas的数据分组工具可以帮助数据清洗和建模或统计分析工作。在[Ch 13：数据分析示例](#data-analysis-examples)中，我们将查看几个更多实际数据上使用`groupby`的示例用例。
- en: In the next chapter, we turn our attention to time series data.***
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把注意力转向时间序列数据。***
