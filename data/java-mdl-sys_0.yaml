- en: Part 1
  id: totrans-0
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第一部分
- en: Hello, modules
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 欢迎来到模块化
- en: Java 9 makes modularity a first-class concept. But what are modules? Which problems
    do they solve, and how can you benefit from them? And what does first-class mean?
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 9 将模块化提升为一等概念。但什么是模块？它们解决了哪些问题，你如何从中受益？以及一等概念意味着什么？
- en: The book you’re reading will answer all of these questions and more. It teaches
    you how to define, build, and run modules, what impact they have on existing projects,
    and what benefits they provide.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你正在阅读的这本书将回答所有这些问题以及更多。它教你如何定义、构建和运行模块，它们对现有项目有什么影响，以及它们提供了哪些好处。
- en: All in due time, though. This part of the book starts by explaining what modularity
    means, why it’s direly needed, and what the module system’s goals are (chapter
    1). Chapter 2 throws you into the deep end and shows code that defines, builds,
    and runs modules, before chapters 3–5 explore those three steps in detail. Chapter
    3 is particularly important because it introduces the basic concepts and mechanisms
    underlying the module system.
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有这些都在适当的时候。这本书的这一部分首先解释了模块化的含义，为什么它迫切需要，以及模块系统的目标（第 1 章）。第 2 章将你投入深水区，展示了定义、构建和运行模块的代码，然后第
    3 章到第 5 章详细探讨了这三个步骤。第 3 章尤其重要，因为它介绍了模块系统背后的基本概念和机制。
- en: Part 2 of the book discusses the challenges Java 9 incurs for existing applications,
    and part 3 introduces more-advanced features.
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 书的第二个部分讨论了 Java 9 对现有应用程序带来的挑战，第三部分介绍了更高级的功能。
- en: '1'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '1'
- en: First piece of the puzzle
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 谜团的第一个部分
- en: This chapter covers
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Modularity and how it shapes a system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化及其如何塑造系统
- en: Java’s inability to enforce modularity
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 无法强制执行模块化
- en: How the new module system aims to fix these issues
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的模块系统如何旨在解决这些问题
- en: 'We’ve all been in situations where the software we’ve deployed refuses to work
    the way we want it to. There are myriad possible reasons, but one class of problems
    is so obnoxious that it earned a particularly gracious moniker: JAR hell. Classic
    aspects of JAR hell are misbehaving dependencies: some may be missing but, as
    if to make up for it, others may be present multiple times, likely in different
    versions. This is a surefire way to crash or, worse, subtly corrupt running applications.'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们都遇到过软件部署后拒绝按我们想要的方式工作的情形。可能有无数的可能原因，但有一类问题如此令人讨厌，以至于它获得了一个特别亲切的名字：JAR 地狱。JAR
    地狱的经典方面是行为不端的依赖项：一些可能缺失，但似乎为了弥补这一点，其他可能存在多次，可能在不同版本中。这是导致崩溃或更糟的是，微妙地破坏运行应用程序的可靠方法。
- en: The root problem underpinning JAR hell is that we see JARs as artifacts with
    identities and relationships to one another, whereas Java sees JARs as simple
    class-file containers without any meaningful properties. This difference leads
    to trouble.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JAR 地狱的根本问题是我们将 JAR 视为具有身份和彼此之间关系的工件，而 Java 将 JAR 视为没有任何有意义属性的简单类文件容器。这种差异导致了问题。
- en: 'One example is the lack of meaningful encapsulation across JARs: all public
    types are freely accessible by all code in the same application. This makes it
    easy to inadvertently depend on types in a library that its maintainers considered
    implementation details and never polished for public use. They likely hid the
    types in a package called `internal` or `impl`, but that doesn’t stop us from
    importing them anyway.'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个例子是 JAR 之间缺乏有意义的封装：所有公共类型都可以被同一应用程序中的所有代码自由访问。这使得无意中依赖库中维护者认为是实现细节且从未为公共使用而完善的类型变得容易。他们可能将这些类型隐藏在名为
    `internal` 或 `impl` 的包中，但这并不能阻止我们导入它们。
- en: Then, when the maintainers change these internals, our code breaks. Or, if we
    hold enough sway in the library’s community, the maintainers may be forced to
    leave untouched code they consider internal, preventing refactoring and code evolution.
    Lacking encapsulation leads to reduced maintainability—for libraries as well as
    for applications.
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后，当维护者更改这些内部组件时，我们的代码就会崩溃。或者，如果我们对库的社区有足够的影响力，维护者可能被迫保留他们认为内部且未触及的代码，防止重构和代码演变。缺乏封装导致可维护性降低——不仅对库，也对应用程序。
- en: Less relevant for everyday development, but even worse for the ecosystem as
    a whole, is that it’s hard to manage access to security-critical code. In the
    Java Development Kit (JDK), this led to a number of vulnerabilities, some of which
    contributed to Java 8’s delayed release after Oracle bought Sun.
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于日常开发来说不太相关，但对于整个生态系统来说更糟糕的是，管理对安全关键代码的访问变得困难。在 Java 开发工具包（JDK）中，这导致了一系列漏洞，其中一些在
    Oracle 收购 Sun 后导致了 Java 8 的发布延迟。
- en: 'These and other problems have haunted Java developers for more than 20 years,
    and solutions have been discussed for almost as long. Java 9 was the first version
    to present one that’s built into the language: the Java Platform Module System
    (JPMS), developed since 2008 under the umbrella of Project Jigsaw. It allows developers
    to create modules by attaching metainformation to JARs, thus making them more
    than mere containers. From Java 9 on, the compiler and runtime understand the
    identity of and relationship between modules and can thus address problems like
    missing or duplicate dependencies and the lack of encapsulation.'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些以及其他问题已经困扰Java开发者超过20年，解决方案也讨论了近20年。Java 9是第一个将内置到语言中的版本：自2008年以来在Project
    Jigsaw的框架下开发的Java平台模块系统（JPMS）。它允许开发者通过将元信息附加到JARs上来创建模块，从而使它们不仅仅是容器。从Java 9开始，编译器和运行时理解模块的身份和关系，因此可以解决诸如缺失或重复依赖以及缺乏封装等问题。
- en: But the JPMS is more than just a Band-Aid. It comes with a number of great features
    we can use to develop more beautiful, maintainable software. Maybe the biggest
    benefit is that it brings every individual developer and the community at large
    face-to-face with the essential concept of modularity. More knowledgeable developers,
    more modular libraries, better tool support—we can expect these and more from
    a Java world where modularity is a first-class citizen.
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但JPMS不仅仅是临时修补。它带来了一系列我们可以用它来开发更美观、可维护的软件的出色功能。可能最大的好处是它将每个个体开发者和整个社区直接面对模块化的基本概念。更有知识的开发者、更模块化的库、更好的工具支持——我们可以期待一个将模块化作为一等公民的Java世界带来这些和更多。
- en: I recognize that many developers will skip past multiple versions of Java when
    upgrading. For example, it’s common to go straight from Java 8 to Java 11\. I’ll
    call attention to differences between Java 9, 10, or 11 where they occur. Most
    of the material in the book is the same for all versions of Java, starting with
    Java 9\. In some cases, I write Java 9+ as shorthand for Java 9 or later.
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我认识到许多开发者在升级时可能会跳过多个Java版本。例如，直接从Java 8跳到Java 11是很常见的。我会指出Java 9、10或11之间的差异，当它们出现时。书中大部分内容从Java
    9版本开始对所有Java版本都是相同的。在某些情况下，我用Java 9+作为Java 9或更高版本的简称。
- en: This chapter starts in section 1.1 by exploring what modularity is all about
    and how we commonly perceive a software system’s structure. The crux is that,
    at a specific level of abstraction (JARs), the JVM doesn’t see things like we
    do (section 1.2). Instead, it erases our carefully created structure! This impedance
    mismatch causes real problems, as we’ll discuss in section 1.3\. The module system
    was created to turn artifacts into modules (section 1.4) and solve the issues
    arising from the impedance mismatch (section 1.5).
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这章从第1.1节开始，探讨模块化的本质以及我们通常如何感知软件系统的结构。关键在于，在特定的抽象级别（JARs）上，JVM并不像我们那样看待事物（第1.2节）。相反，它抹去了我们精心创建的结构！这种阻抗不匹配会导致真正的问题，正如我们将在第1.3节中讨论的那样。模块系统被创建出来是为了将工件转换为模块（第1.4节）并解决由阻抗不匹配引起的问题（第1.5节）。
- en: 1.1 What is modularity all about?
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.1 模块化究竟是什么？
- en: How do you think about software? As lines of code? As bits and bytes? UML diagrams?
    Maven POMs?
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你如何看待软件？作为代码行？作为比特和字节？UML图？Maven POMs？
- en: 'I’m not looking for a definition but an intuition. Take a moment and think
    about your favorite project (or one you’re being paid to work on): What does it
    feel like? How do you visualize it?'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我不是在寻找定义，而是在寻找直觉。花点时间想想你最喜欢的项目（或者你被支付去工作的项目）：它感觉如何？你是如何可视化的？
- en: 1.1.1 VISUALIZING SOFTWARE AS GRAPHS
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.1.1 将软件作为图可视化
- en: 'I see code bases I’m working on as systems of interacting parts. (Yes, that
    formal.) Each part has three basic properties: a name, dependencies on other parts,
    and features it provides to other parts.'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我认为我正在工作的代码库是由相互作用的各个部分组成的系统。（是的，这是正式的。）每个部分有三个基本属性：名称、对其他部分的依赖以及它提供给其他部分的功能。
- en: This is true on every level of abstraction. On a very low level, a part maps
    to an individual method, where its name is the method’s name, its dependencies
    are the methods it calls, and its features are the return value or state change
    it triggers. On a very high level, a part corresponds to a service (did anyone
    say micro?) or even a whole application.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这在抽象的每个层面上都是正确的。在非常低的层面上，一个部分映射到一个单独的方法，其中它的名称是方法的名称，它的依赖项是它调用的方法，它的特性是它触发的返回值或状态变化。在非常高的层面上，一个部分对应于一个服务（有人提到微服务吗？）或者甚至是一个完整的应用程序。
- en: 'Imagine a checkout service: as part of an e-shop, it lets users buy the goods
    they picked out. In order to do that, it needs to call the login and shopping
    cart services. Again we have all three properties: a name, dependencies, and features.
    It’s easy to use this information to draw the diagram shown in [figure 1.1](part0014.html#filepos145649).'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 想象一个结账服务：作为电子商务的一部分，它让用户购买他们挑选的商品。为了做到这一点，它需要调用登录和购物车服务。我们再次有三个属性：名称、依赖项和功能。很容易使用这些信息来绘制[图1.1](part0014.html#filepos145649)中所示的图。
- en: '![](../images/00068.jpeg)'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00068.jpeg)'
- en: '[Figure 1.1](part0014.html#filepos145338) If the checkout service and its dependencies
    are jotted down, they naturally form a small graph that shows their names, dependencies,
    and features.'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图1.1](part0014.html#filepos145338) 如果将结账服务及其依赖项记录下来，它们自然形成一个小的图，显示了它们的名称、依赖项和功能。'
- en: We can perceive parts on different levels of abstraction. Between the extremes
    of methods and entire applications, we can map them to classes, packages, and
    JARs. They also have names, dependencies, and features.
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以在不同的抽象级别上感知部分。在方法和整个应用程序的极端之间，我们可以将它们映射到类、包和JAR文件。它们也有名称、依赖项和功能。
- en: What’s interesting about this perspective is how it can be used to visualize
    and analyze a system. If we imagine, or even draw, a node for every part we have
    in mind and then connect them with edges according to their dependencies, we get
    a graph.
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个视角有趣的地方在于它可以用来可视化和分析一个系统。如果我们想象，甚至绘制，每个我们心中所想的部件的节点，然后根据它们的依赖关系用边将它们连接起来，我们就得到了一个图。
- en: This mapping comes so naturally that the e-shop example already did it, and
    you probably didn’t notice. Take a look at other common ways to visualize software
    systems, such as those shown in [figure 1.2](part0014.html#filepos147357), and
    graphs pop up everywhere.
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种映射如此自然，以至于电子商务示例已经做到了这一点，你可能都没有注意到。看看其他常见的软件系统可视化方式，如图[图1.2](part0014.html#filepos147357)所示，图无处不在。
- en: '![](../images/00066.jpeg)'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00066.jpeg)'
- en: '[Figure 1.2](part0014.html#filepos147016) In software development, graphs are
    ubiquitous. They come in all shapes and forms: for example, UML diagrams (left),
    Maven dependency trees (middle), and microservice connectivity graphs (right).'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图1.2](part0014.html#filepos147016) 在软件开发中，图无处不在。它们以各种形状和形式出现：例如，UML图（左），Maven依赖树（中），以及微服务连接图（右）。'
- en: Class diagrams are graphs. Build tools’ dependency output is structured like
    trees (if you use Gradle or Maven, try `gradle dependencies` or `mvn dependency:tree`,
    respectively), which are a special type of graph. Have you ever seen those crazy
    microservice diagrams, where you can’t understand anything? Those are graphs,
    too.
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类图是图。构建工具的依赖输出结构类似于树（如果你使用Gradle或Maven，尝试`gradle dependencies`或`mvn dependency:tree`），这是一种特殊的图。你有没有见过那些疯狂的微服务图，你根本看不懂？那些也是图。
- en: These graphs look different, depending on whether we’re talking about compile-time
    or runtime dependencies, whether we look at only one level of abstraction or mix
    them, whether we examine the system’s entire lifetime or a single moment, and
    many other possible distinctions. Some of the differences will become important
    later, but for now we don’t need to go into that. For now, any of the myriad of
    possible graphs will do—just imagine the one you’re most comfortable with.
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些图看起来不同，取决于我们是在谈论编译时还是运行时依赖，我们是否只看一个抽象级别，或者将它们混合，我们是否检查系统的整个生命周期或一个单一时刻，以及许多其他可能的区分。其中一些差异将在以后变得重要，但现在我们不需要深入探讨。现在，任何无数可能的图都可以——只需想象你最熟悉的那一个。
- en: 1.1.2 THE IMPACT OF DESIGN PRINCIPLES
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.1.2 设计原则的影响
- en: Visualizing a system as a graph is a common way to analyze its architecture.
    Many of the principles of good software design directly impact how it looks.
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将系统作为图来可视化是分析其架构的常见方式。许多良好的软件设计原则直接影响了其外观。
- en: Take, for example, the principle that says to separate concerns. Following it,
    we strive to create software in which each individual part focuses on one task
    (like “log user in” or “draw map”). Often, tasks are made up of smaller tasks
    (like “load user” and “verify password” to log in the user) and the parts implementing
    them should be separated as well. This results in a graph where individual parts
    form small clusters that implement clearly separated tasks.
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以一个原则为例，即分离关注点。遵循它，我们努力创建软件，其中每个部分都专注于一项任务（如“登录用户”或“绘制地图”）。通常，任务由更小的任务组成（如“加载用户”和“验证密码”以登录用户），实现这些任务的组件也应该分离。这导致了一个图表，其中单个部分形成小的集群，执行清晰分离的任务。
- en: Conversely, if concerns are poorly separated, the graph has no clear structure
    and looks like everything connects to everything else. As you can see in [figure
    1.3](part0014.html#filepos150686), it’s easy to distinguish the two cases.
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 相反，如果关注点没有很好地分离，图表将没有明显的结构，看起来一切似乎都连接到其他一切。正如你在[图1.3](part0014.html#filepos150686)中看到的，区分这两种情况很容易。
- en: '![](../images/00029.jpeg)'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00029.jpeg)'
- en: '[Figure 1.3](part0014.html#filepos150333) Two systems’ architectures depicted
    as graphs. Nodes could be JARs or classes, and edges are dependencies between
    them. But the details don’t matter: all it takes is a quick glance to answer the
    question of whether there is good separation of concerns.'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图1.3](part0014.html#filepos150333) 两个系统的架构以图表形式表示。节点可以是JAR文件或类，边是它们之间的依赖关系。但细节并不重要：只需快速浏览就能回答是否存在良好的关注点分离问题。'
- en: 'Another example of a principle that impacts the graph is dependency inversion.
    At run time, high-level code always calls into low-level code, but a properly
    designed system inverts those dependencies at compile time: high-level code depends
    on interfaces and low-level code implements them, thus inverting the dependencies
    upward toward interfaces. Looking at the right variant of the graph (see [figure
    1.4](part0014.html#filepos152137)), you can easily spot these inversions.'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 影响图表的一个原则的另一个例子是依赖倒置。在运行时，高级代码总是调用低级代码，但一个设计得当的系统在编译时反转这些依赖关系：高级代码依赖于接口，而低级代码实现它们，从而将依赖关系向上反转到接口。查看图表的右侧变体（见[图1.4](part0014.html#filepos152137)），你可以轻松地找到这些反转。
- en: '![](../images/00123.jpeg)'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00123.jpeg)'
- en: '[Figure 1.4](part0014.html#filepos151787) A system where high-level code depends
    on low-level code creates a different graph (left) than one where interfaces are
    used to invert dependencies upward (right). This inversion makes it easier to
    identify and understand meaningful components within the system.'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图1.4](part0014.html#filepos151787) 高级代码依赖于低级代码的系统与使用接口来反转依赖关系向上的系统（右侧）创建的图表（左侧）不同。这种反转使得识别和理解系统中的有意义组件变得更加容易。'
- en: The goal of principles like separation of concerns and dependency inversion
    is to disentangle the graph. If we ignore them, the system becomes a mess, where
    nothing can be changed without potentially breaking something seemingly unrelated.
    If we follow them, the system can be organized well.
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关注点分离和依赖倒置等原则的目标是解耦图表。如果我们忽略它们，系统就会变得混乱，没有东西可以改变，而不会潜在地破坏看似无关的东西。如果我们遵循它们，系统就可以很好地组织。
- en: 1.1.3 WHAT MODULARITY IS ALL ABOUT
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.1.3 什么是模块化
- en: The principles of good software design guide us toward disentangled systems.
    Interestingly, although maintainable systems are the goal, most principles lead
    us there on paths that allow us to concentrate on individual parts. The principles
    focus not on the entire code base, but on single elements, because in the end
    their characteristics determine the properties of the systems they constitute.
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 良好软件设计的原则引导我们走向解耦的系统。有趣的是，尽管可维护的系统是目标，但大多数原则都是通过允许我们专注于单个部分的路径来引导我们达到那里。原则关注点不在于整个代码库，而在于单个元素，因为最终它们的特性决定了它们构成的系统的属性。
- en: 'We already glanced at how separation of concerns and dependency inversion provide
    two positive characteristics: focused on a single task and depending on interfaces,
    not implementations. The most desirable traits of a system’s parts can be summarized
    as follows.'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们已经探讨了关注点分离和依赖倒置如何提供两个积极的特性：专注于单一任务和依赖于接口，而不是实现。系统各部分的最理想特性可以总结如下。
- en: ESSENTIAL INFO Each module, what I’ve called a part up to now, has clear responsibilities
    and a well-defined contract it implements. It’s self-contained, it’s opaque to
    its clients, and it can be replaced by a different module as long as that one
    implements the same contract. Its few dependencies are APIs, not implementations.
  id: totrans-50
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**基本信息** 每个模块，我之前称之为部分，都有明确的职责和它所实现的明确合同。它是自包含的，对客户端来说是透明的，并且只要另一个模块实现了相同的合同，就可以用不同的模块替换它。它的少量依赖是API，而不是实现。'
- en: 'Systems built from such modules are more amenable to changes and, depending
    on how dependencies are realized, more flexible at launch and maybe even run time.
    And this is what modularity is all about: achieving maintainability and flexibility
    as emergent properties of well-designed modules.'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由这样的模块构建的系统更容易适应变化，并且根据依赖的实现方式，在启动时甚至运行时可能更加灵活。这正是模块化的全部意义：作为精心设计模块的涌现属性，实现可维护性和灵活性。
- en: 1.2 Module erasure before Java 9
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.2 Java 9之前的模块擦除
- en: You’ve seen how the graph of interacting parts connects to a couple of nice
    properties that are generally summarized as modularity. But in the end, these
    are just ideas—ways to talk about software. The graph is just lines of code that,
    in the case of Java, are eventually compiled to bytecode instructions and executed
    by the Java Virtual Machine (JVM). It would be great if language, compiler, and
    JVM (which I’ll crudely and incorrectly summarize under the term Java) could see
    things like we do.
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你已经看到了交互部分图如何与几个很好的属性相连接，这些属性通常总结为模块化。但最终，这些只是想法——谈论软件的方式。图只是代码行，在Java的情况下，最终会被编译成字节码指令，并由Java虚拟机（JVM）执行。如果语言、编译器和JVM（我将粗略且不正确地总结为Java）能像我们一样看待事物，那将是极好的。
- en: And often, they do! If you design a class or an interface, then the name you
    give it is what Java uses to identify it. The methods you define as its API are
    exactly what other code can call—with the exact method names and parameter types
    you define. Its dependencies are clearly visible, either as import statements
    or fully qualified class names, and the compiler and JVM will use classes with
    those names to fulfill them.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通常情况下，它们确实是这样的！如果你设计一个类或接口，那么你给它起的名字就是Java用来识别它的。你定义为其API的方法正是其他代码可以调用的——使用你定义的确切方法名称和参数类型。它的依赖关系明显可见，要么是导入语句，要么是完全限定的类名，编译器和JVM将使用这些名称的类来满足它们。
- en: 'As an example, let’s look at the interface `Future`, which represents the result
    of a computation that might or might not yet be finished. The type’s functionality
    isn’t important, though, because we’re only interested in its dependencies:'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，让我们看看接口 `Future`，它表示一个可能已完成或尚未完成的计算的结果。类型的功能并不重要，因为我们只对它的依赖感兴趣：
- en: '`public interface Future<V> {  boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled(); boolean isDone(); V get() throws InterruptedException,
    ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException,
    ExecutionException, TimeoutException; }`'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public interface Future<V> {  boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled(); boolean isDone(); V get() throws InterruptedException,
    ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException,
    ExecutionException, TimeoutException; }`'
- en: 'Going through the methods `Future` declares, it’s easy to enumerate the dependencies:'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过查看 `Future` 声明的所有方法，很容易列举出依赖关系：
- en: '`InterruptedException`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InterruptedException`'
- en: '`ExecutionException`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutionException`'
- en: '`TimeUnit`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimeUnit`'
- en: '`TimeoutException`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimeoutException`'
- en: Applying the same analysis to the types just identified, we can create the dependency
    graph in [figure 1.5](part0014.html#filepos159167). The exact form of the graph
    isn’t relevant here. What’s important is that the dependency graph we have in
    mind when we talk about a type and the one Java implicitly creates for it are
    identical.
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将同样的分析应用于刚刚确定类型，我们可以在[图1.5](part0014.html#filepos159167)中创建依赖图。图的精确形式在这里并不重要。重要的是，当我们谈论类型时心中所想的依赖图与Java隐式为它创建的依赖图是相同的。
- en: '![](../images/00078.jpeg)'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00078.jpeg)'
- en: '[Figure 1.5](part0014.html#filepos158657) The dependency graph Java operates
    on for any given type coincides with our perception of the type’s dependencies.
    This graph shows the dependencies of the interface `Future` across the packages
    `java.util.concurrent` and `java.lang`.'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图1.5](part0014.html#filepos158657) Java为任何给定类型操作依赖图与我们对类型依赖的认识相一致。此图显示了接口
    `Future` 在包 `java.util.concurrent` 和 `java.lang` 中的依赖关系。'
- en: Because of Java’s strongly and statically typed nature, it will tell you immediately
    if something breaks. A class’s name is illegal? One of your dependencies is gone?
    A method’s visibility changed, and now callers can’t see it? Java will tell you—the
    compiler during compilation, and the JVM during execution.
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于Java具有强类型和静态类型的特点，它会在立即告诉你如果有什么东西出错了。一个类的名称不合法？你的某个依赖项丢失了？一个方法的可视性改变了，现在调用者看不到它？Java会告诉你——在编译时的编译器，以及在执行时的JVM。
- en: Compile-time checks can be bypassed with reflection (see appendix B for a quick
    introduction). For this reason, it’s considered a sharp, potentially dangerous
    tool, only to be used for special occasions. We’re going to ignore it for now
    but will come back to it in later chapters.
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以通过反射绕过编译时检查（参见附录B以获取快速介绍）。因此，它被认为是一个锋利且可能危险的工具，仅用于特殊场合。我们现在将忽略它，但将在后面的章节中回到它。
- en: 'As an example of where Java’s perception of dependencies and ours diverge,
    let’s look at the service or application level. This is outside Java’s scope:
    it has no idea what an application is called, can’t tell you there’s no “GitHab”
    service or “Oracel” database (oops), and doesn’t know you changed your service’s
    API and broke your clients. It has no constructs that map to the collaboration
    of applications or services. And that’s fine, because Java operates on the level
    of an individual application.'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为Java对我们依赖感知与我们不同的例子，让我们看看服务或应用级别。这超出了Java的范围：它不知道应用程序的名称，不能告诉你没有“GitHab”服务或“Oracel”数据库（哦，不），也不知道你更改了你的服务API并破坏了你的客户端。它没有映射到应用程序或服务的协作的结构。而且这很好，因为Java在单个应用程序的层面上运行。
- en: But one level of abstraction clearly lies within Java’s scope, although before
    Java 9, it was very poorly supported—so poorly that modularization efforts were
    effectively undone, leading to what has been called module erasure. That level
    is the one dealing with artifacts, or JARs in Java’s parlance.
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但一个抽象级别显然在Java的范围内，尽管在Java 9之前，它得到了非常糟糕的支持——糟糕到模块化努力实际上被取消，导致了所谓的模块擦除。这个级别是处理工件，或者用Java的话说是JAR文件。
- en: If an application is modularized on this level, it consists of several JARs.
    Even if it isn’t, it depends on libraries, which might have their own dependencies.
    Jotting these down, you’ll end up with the already familiar graph, but this time
    for JARs, not classes.
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果在这个级别上模块化了应用程序，它由几个JAR文件组成。即使它没有，它也依赖于库，这些库可能有自己的依赖项。将这些记录下来，你将得到已经熟悉的图，但这次是针对JAR文件，而不是类。
- en: 'As an example, let’s consider an application called ServiceMonitor. Without
    going into too much detail, it behaves as follows: it checks availability of other
    services on the network and aggregates statistics. Those are written to a database
    and made available via a REST API.'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个名为ServiceMonitor的应用程序。在不深入细节的情况下，它的行为如下：它检查网络上其他服务的可用性并汇总统计数据。这些数据被写入数据库并通过REST
    API提供。
- en: 'The application’s authors created four JARs:'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应用程序的作者创建了四个JAR文件：
- en: observer—Observes other services and checks availability
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者—观察其他服务并检查可用性
- en: statistics—Creates statistics from availability data
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计学—从可用性数据中创建统计数据
- en: persistence—Reads and writes statistics to the database with hibernate
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化—使用hibernate读取和写入统计数据到数据库
- en: monitor—Triggers data collection and pipes the data through statistics into
    persistence; implements the REST API with spark
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控—触发数据收集，并将数据通过统计管道传输到持久化存储；使用spark实现REST API
- en: Each JAR has its own dependencies, all of which can be seen in [figure 1.6](part0014.html#filepos164823).
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个JAR都有自己的依赖项，所有这些都可以在[图1.6](part0014.html#filepos164823)中看到。
- en: '![](../images/00025.jpeg)'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00025.jpeg)'
- en: '[Figure 1.6](part0014.html#filepos164512) Given any application, you can draw
    a dependency graph for its artifacts. Here the ServiceMonitor application is split
    into four JARs, which have dependencies between them but also on third-party libraries.'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图1.6](part0014.html#filepos164512) 对于任何应用程序，你都可以为其工件绘制一个依赖图。在这里，ServiceMonitor应用程序被拆分为四个JAR文件，它们之间相互依赖，同时也依赖于第三方库。'
- en: 'The graphs include everything we discussed earlier: the JARs have names, they
    depend on each other, and each offers specific features by providing public classes
    and methods that other JARs can call.'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图表包括我们之前讨论的所有内容：JAR文件有名称，它们相互依赖，并且通过提供其他JAR文件可以调用的公共类和方法，每个JAR文件都提供了特定的功能。
- en: 'When starting an application, you must list on the class path all the JARs
    you want to use:'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在启动应用程序时，你必须列出所有你想要使用的JAR文件到类路径上：
- en: '`$ java` `--classpath observer.jar:statistics.jar:persistence.jar:monitor.jar`
    [`①`](part0014.html#filepos166438) `org.codefx.monitor.Monitor`'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java` `--classpath observer.jar:statistics.jar:persistence.jar:monitor.jar`
    [`①`](part0014.html#filepos166438) `org.codefx.monitor.Monitor`'
- en: ①
  id: totrans-82
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Explicitly list required JAR files with the --classpath option (a new alternative
    for -cp and -classpath, which also works with javac).
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用`--classpath`选项明确列出所需的JAR文件（这是`-cp`和`-classpath`的一个新替代方案，也可以与javac一起使用）。
- en: ESSENTIAL INFO And this is where things go awry—at least, before Java 9\. The
    JVM launches without knowledge of your classes. Every time it encounters a reference
    to an unknown class, starting with the main class specified on the command line,
    it goes through all JARs on the class path, looking for a class with that fully
    qualified name. If it finds one, it loads the class into a huge set of all classes
    and is finished. As you can see, there’s no runtime concept in the JVM that corresponds
    to JARs.
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 这就是事情变得糟糕的地方——至少，在Java 9之前。JVM在启动时并不知道你的类。每次它遇到对未知类的引用，从命令行指定的主类开始，它都会遍历类路径上的所有JAR文件，寻找具有该完全限定名称的类。如果找到了，它就会将这个类加载到一个包含所有类的巨大集合中，然后完成。正如你所见，JVM中没有与JAR文件对应的运行时概念。'
- en: Without runtime representation, JARs lose their identity. Although they have
    filenames, the JVM doesn’t much care about them. Wouldn’t it be nice if exception
    messages could point to the JAR the problem occurred in, or if the JVM could name
    a missing dependency?
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 没有运行时表示，JAR文件失去了它们的身份。尽管它们有文件名，但JVM并不太关心它们。如果异常信息能指向发生问题的JAR文件，或者如果JVM能命名一个缺失的依赖项，那岂不是很好？
- en: Talking about dependencies—these become invisible as well. Operating on the
    level of classes, the JVM has no concept for dependencies between JARs. Ignoring
    the artifacts that contained the classes also means encapsulation of those artifacts
    is impossible. And indeed, every public class is visible to all other classes.
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 谈论依赖关系——这些也变得不可见。在类级别上操作，JVM没有关于JAR文件之间依赖的概念。忽略包含类的组件也意味着那些组件的封装是不可能的。确实，每个公共类都对其他所有类可见。
- en: Names, explicit dependencies, clearly defined APIs—neither compiler nor JVM
    cares much about any of the things we value in modules. This erases the modular
    structure and turns that carefully designed graph into a big ball of mud, as shown
    in [figure 1.7](part0014.html#filepos168978). This is not without consequences.
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 名称、显式依赖关系、明确定义的API——编译器或JVM对我们所重视的模块中的任何事物都不太关心。这抹去了模块结构，将那个精心设计的图变成了一个巨大的泥球，如图1.7所示。这并非没有后果。
- en: '![](../images/00009.jpeg)'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00009.jpeg)'
- en: '[Figure 1.7](part0014.html#filepos168633) Neither Java’s compiler nor its virtual
    machine has concepts for artifacts or the dependencies between them. Instead,
    JARs are treated as simple containers, out of which classes are loaded into a
    single namespace. Eventually, the classes end up in a kind of primordial soup,
    where every public type is accessible to every other.'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图1.7](part0014.html#filepos168633) Java的编译器或虚拟机都没有关于组件或它们之间依赖的概念。相反，JAR文件被视为简单的容器，类从这个容器中加载到一个单一的命名空间中。最终，这些类会进入一种原始汤的状态，其中每个公共类型都可以被其他任何类型访问。'
- en: 1.3 Complications before Java 9
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.3 Java 9之前的复杂性
- en: As you’ve seen, Java before version 9 lacked the concepts to properly support
    modularity across artifacts. And although this causes problems, they obviously
    aren’t prohibitive (or we wouldn’t use Java). But when they do rear their ugly
    heads, typically in larger applications, they can be hard or even impossible to
    solve.
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如你所见，Java 9之前的版本缺乏支持跨组件模块化的概念。尽管这会引发问题，但显然它们并不是不可逾越的障碍（否则我们不会使用Java）。但当这些问题出现时，通常是在大型应用程序中，它们可能很难解决，甚至无法解决。
- en: As I mentioned at the beginning of the chapter, the complications that are most
    likely to affect application developers are commonly summarized under the endearing
    term JAR hell; but they aren’t the only ones. Security and maintenance problems,
    more of an issue for JDK and library developers, are also consequences.
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如我在本章开头提到的，最可能影响应用程序开发者的复杂性通常被亲切地称为JAR地狱；但它们并不是唯一的。安全和维护问题，对于JDK和库开发者来说是一个更大的问题，也是其后果。
- en: I’m sure you’ve seen quite a few of these complications yourself, and over the
    course of this section we’ll look at them one by one. Don’t worry if you’re not
    familiar with all of them—quite the opposite, consider yourself lucky that you
    haven’t had to deal with them yet. If you’re familiar with JAR hell and related
    problems, feel free to skip to section 1.4, which introduces the module system.
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我相信你已经看到了很多这些复杂情况，在本节的其余部分，我们将逐一探讨它们。如果你不熟悉所有这些，请不要担心——相反，如果你还没有处理过它们，你应该觉得自己很幸运。如果你熟悉
    JAR 地狱和相关问题，可以自由跳转到第 1.4 节，该节介绍了模块系统。
- en: 'In case you’re getting frustrated with this seemingly endless stream of problems,
    relax—there will be a catharsis: section 1.5 discusses how the module system overcomes
    most of these shortcomings.'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你因为这些问题似乎永无止境而感到沮丧，请放松——会有一种宣泄：第 1.5 节讨论了模块系统如何克服这些缺点的大部分。
- en: 1.3.1 UNEXPRESSED DEPENDENCIES BETWEEN JARS
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1.3.1 JAR 之间的未表达依赖**'
- en: Has an application of yours ever crashed with a `NoClassDefFoundError`? This
    occurs when the JVM can’t find a class on which the code that’s currently being
    executed depends. Finding the depending code is easy (a look at the stack trace
    will reveal it), and identifying the missing dependency usually doesn’t require
    much more work (the missing class’s name often gives it away), but determining
    why the dependency isn’t present can be tough. Considering the artifact dependency
    graph, though, the question arises why we’re only finding out at run time that
    something’s missing.
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你的应用程序是否曾经因为 `NoClassDefFoundError` 而崩溃？当 JVM 无法找到当前正在执行的代码所依赖的类时，就会发生这种情况。找到依赖的代码很容易（查看堆栈跟踪就会揭示它），通常也不需要做更多的工作（缺失类的名称通常会给出线索），但确定依赖项为何不存在可能很困难。然而，考虑到工件依赖图，问题就出现了，为什么我们只在运行时才发现某些东西缺失。
- en: 'ESSENTIAL INFO The reason is simple: a JAR can’t express which other JARs it
    depends on in a way the JVM will understand. An external entity is required to
    identify and fulfill the dependencies.'
  id: totrans-97
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息**：原因很简单：JAR 无法以 JVM 能够理解的方式表达它依赖于哪些其他 JAR。需要一个外部实体来识别和满足这些依赖。'
- en: Before build tools gained the ability to identify and fetch dependencies, that
    external entity was us. We had to scan the documentation for dependencies, find
    the correct projects, download the JARs, and add them to the project. Optional
    dependencies, where a JAR might require another JAR only if we wanted to use certain
    features, further complicated the process.
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在构建工具获得识别和检索依赖的能力之前，那个外部实体就是我们。我们必须扫描文档以查找依赖项，找到正确的项目，下载 JAR 文件，并将它们添加到项目中。可选依赖项进一步复杂了过程，其中
    JAR 可能仅在需要使用某些功能时才需要另一个 JAR。
- en: For an application to work, it might only need a handful of libraries. But each
    of those in turn might need a handful of other libraries, and so on. As the problem
    of unexpressed dependencies is compounded, it becomes exponentially more labor-intensive
    and error-prone.
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了使应用程序工作，它可能只需要几个库。但每个库反过来可能又需要几个其他库，依此类推。随着未表达依赖问题复杂性的增加，它变得指数级地更加费时和容易出错。
- en: ESSENTIAL INFO Build tools like Maven and Gradle largely solved this problem.
    They excel in making dependencies explicit so they can hunt down each required
    JAR along the myriad edges of the transitive dependency tree. Still, having the
    JVM understand the concept of artifact dependencies would increase robustness
    and portability.
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息**：构建工具如 Maven 和 Gradle 大大解决了这个问题。它们擅长使依赖关系明确，以便它们可以沿着传递依赖树的多条边追踪每个所需的
    JAR。然而，让 JVM 理解工件依赖的概念将提高鲁棒性和可移植性。'
- en: 1.3.2 SHADOWING CLASSES WITH THE SAME NAME
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1.3.2 使用相同名称的阴影类**'
- en: 'Sometimes, different JARs on the class path contain classes with the same fully
    qualified name. This can happen for a number of reasons:'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时，类路径上的不同 JAR 包可能包含具有相同完全限定名的类。这可能是由于多种原因：
- en: There may be two different versions of the same library.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能存在同一库的两个不同版本。
- en: A JAR may contain its own dependencies—it’s called a fat JAR or an uber JAR—but
    some of them are also pulled in as standalone JARs because other artifacts depend
    on them.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 JAR 可能包含其自己的依赖项——这被称为胖 JAR 或超级 JAR——但其中一些也作为独立的 JAR 被拉入，因为其他工件依赖于它们。
- en: A library may have been renamed or split, and some of its types are unknowingly
    added to the class path twice.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图书馆可能已被重命名或拆分，其某些类型可能无意中添加到类路径中两次。
- en: 'Definition: Shadow'
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**定义**：阴影'
- en: Because a class will be loaded from the first JAR on the class path that contains
    it, it makes all other classes of the same name unavailable—it’s said to shadow
    them.
  id: totrans-107
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因为类将从类路径上包含它的第一个 JAR 文件中加载，这导致所有同名的其他类不可用——这被称为阴影。
- en: 'If the variants differ semantically, this can lead to anything from too-subtle-to-notice-misbehavior
    to havoc-wreaking errors. Even worse, the form in which the problem manifests
    itself can seem nondeterministic. It depends on the order in which the JARs are
    searched, which may differ across different environments: for example, between
    your IDE (such as IntelliJ, Eclipse, or NetBeans) and the production machine where
    the code will eventually run.'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果变体在语义上不同，这可能导致从几乎察觉不到的异常行为到破坏性的错误。更糟糕的是，问题表现出来的形式可能看起来是非确定性的。它取决于 JAR 文件的搜索顺序，这可能在不同的环境中有所不同：例如，在你的
    IDE（如 IntelliJ、Eclipse 或 NetBeans）和代码最终运行的生成机器之间。
- en: Take the example of Google’s widely used Guava library, which contains a utility
    class `com.google.common.collect.Iterators`. From Guava version 19 to version
    20, the method `emptyIterator()` was removed. As [figure 1.8](part0014.html#filepos178845)
    shows, if both versions end up on the class path and if version 20 comes first,
    then any code that depends on `Iterators` will use the new version, thus ending
    up unable to call 19’s `Iterators::emptyIterator`. Even though a class containing
    the method is on the class path, it’s effectively invisible.
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以 Google 广泛使用的 Guava 库为例，它包含一个实用类 `com.google.common.collect.Iterators`。从 Guava
    版本 19 到版本 20，`emptyIterator()` 方法被删除。如图 1.8 所示，如果两个版本都出现在类路径上，并且版本 20 首先出现，那么任何依赖于
    `Iterators` 的代码都将使用新版本，从而导致无法调用 19 的 `Iterators::emptyIterator`。即使包含该方法的类在类路径上，它实际上也是不可见的。
- en: Shadowing mostly happens by accident. But it’s also possible to purposely use
    this behavior to override specific classes in third-party libraries with handcrafted
    implementations, thus patching the library. Although build tools might reduce
    the chance of this happening accidentally, they generally can’t prevent it.
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 阴影通常是由于意外发生的。但也可以故意使用这种行为来覆盖第三方库中的特定类，从而修补库。尽管构建工具可能会减少意外发生的可能性，但它们通常无法防止这种情况发生。
- en: '![](../images/00055.jpeg)'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00055.jpeg)'
- en: '[Figure 1.8](part0014.html#filepos177488) It’s possible that the class path
    contains the same library in two different versions (top) or two libraries that
    have a set of types in common (bottom). In both cases, some types are present
    more than once. Only the first variant encountered during the class path scan
    is loaded (it shadows all the others), so the order in which the JAR files are
    scanned determines which code runs.'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 1.8](part0014.html#filepos177488) 类路径中可能包含同一库的两个不同版本（顶部）或具有共同类型集合的两个库（底部）。在这两种情况下，某些类型都出现了一次以上。只有类路径扫描期间遇到的第一个变体被加载（它覆盖了所有其他变体），因此
    JAR 文件的扫描顺序决定了哪个代码运行。'
- en: 1.3.3 CONFLICTS BETWEEN DIFFERENT VERSIONS OF THE SAME PROJECT
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.3.3 同一项目的不同版本之间的冲突
- en: Version conflicts are the bane of any large software project. Once the number
    of dependencies is no longer a single digit, the likelihood of conflicts occurring
    converges to 1 with alarming speed.
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 版本冲突是任何大型软件项目的噩梦。一旦依赖项的数量不再是单个数字，冲突发生的可能性会以惊人的速度趋近于 1。
- en: 'Definition: Version conflict'
  id: totrans-115
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：版本冲突
- en: Version conflicts arise when two required libraries depend on different, incompatible
    versions of a third library.
  id: totrans-116
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当两个必需的库依赖于不同、不兼容的第三方库版本时，就会发生版本冲突。
- en: If both versions are present on the class path, the behavior will be unpredictable.
    Because of shadowing, classes that exist in both versions will only be loaded
    from one of them. Worse, if a class that exists in one version but not the other
    is accessed, that class will be loaded as well. Code calling into the library
    may find a mix of both versions.
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果两个版本都存在于类路径上，行为将是不可预测的。由于阴影，存在于两个版本中的类将只从其中一个加载。更糟糕的是，如果访问了存在于一个版本但不在另一个版本中的类，该类也将被加载。调用库的代码可能会发现两个版本的混合。
- en: On the other hand, if one of the versions is missing, the program most likely
    won’t function correctly because both versions are required and by assumption
    not compatible, which means they can’t stand in for each other (see [figure 1.9](part0014.html#filepos181774)).
    As with missing dependencies, this manifests as unexpected behavior or as a `NoClassDefFoundError`.
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一方面，如果其中一个版本缺失，程序很可能无法正确运行，因为需要两个版本，并且假设它们不兼容，这意味着它们不能相互替代（参见[图1.9](part0014.html#filepos181774)）。与缺失的依赖项一样，这表现为意外的行为或`NoClassDefFoundError`。
- en: '![](../images/00101.jpeg)'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00101.jpeg)'
- en: '[Figure 1.9](part0014.html#filepos181259) Transitive dependencies on conflicting
    versions of the same library often aren’t resolvable — one dependency must be
    eliminated. Here, an old version of `RichFaces` depends on a different version
    of Guava than the application wants to use. Unfortunately, Guava 16 removed an
    API that `RichFaces` relies on.'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图1.9](part0014.html#filepos181259) 相同库冲突版本的传递依赖通常无法解决——必须消除一个依赖项。在这里，`RichFaces`的老版本依赖于与应用程序想要使用的Guava不同的版本。不幸的是，Guava
    16删除了`RichFaces`所依赖的API。'
- en: Continuing the Guava example from the section on shadowing, imagine some code
    depends on `com.google.common.io.InputSupplier`, a class that was present in 19
    but removed in 20\. The JVM would first scan Guava 20 and, after not finding the
    class, load it from Guava 19\. Suddenly an amalgam of both Guava versions is running!
    As a finishing move, imagine `InputSupplier` calling `Iterators::emptyIterator`.
    What do you think—how much fun would it be to debug that?
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 继续从关于阴影的章节中的Guava示例，想象一些代码依赖于`com.google.common.io.InputSupplier`，这是一个在19版本中存在但在20版本中删除的类。JVM首先扫描Guava
    20，在找不到该类后，从Guava 19中加载它。突然，两个Guava版本混合在一起运行了！作为一个结束动作，想象`InputSupplier`调用`Iterators::emptyIterator`。你认为——调试那个会有多有趣？
- en: ESSENTIAL INFO There’s no technical solution for this issue that doesn’t involve
    existing module systems or manually fiddling with class loaders. Build tools are
    generally able to detect this scenario. They may warn about it and usually resolve
    it with simple mechanisms like picking the most current version.
  id: totrans-122
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 必要信息 对于这个问题，没有不涉及现有模块系统或手动调整类加载器的技术解决方案。构建工具通常能够检测这种场景。它们可能会发出警告，并且通常通过选择最新版本等简单机制来解决。
- en: 1.3.4 COMPLEX CLASS LOADING
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.3.4 复杂类加载
- en: Our examination of the class-loading mechanism in section 1.2 wasn’t complete.
    The described behavior is the default, where all application classes are loaded
    by the same class loader. But developers are free to add additional class loaders,
    delegating from one to the other to solve some of the problems we’re discussing
    here.
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在第1.2节中对类加载机制的检查并不完整。描述的行为是默认行为，其中所有应用程序类都由同一个类加载器加载。但开发者可以自由地添加额外的类加载器，从一个委托到另一个以解决我们在这里讨论的一些问题。
- en: 'This is typically done by containers like component systems and web servers.
    Ideally this implicit use is hidden from application developers; but as we know,
    all abstractions are leaky. And in some circumstances, developers may explicitly
    add class loaders to implement features: for example, to allow users to extend
    the application by loading new classes, or to be able to use conflicting versions
    of the same dependency.'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这通常是通过容器如组件系统和Web服务器来完成的。理想情况下，这种隐式使用应该对应用程序开发者隐藏；但我们知道，所有抽象都有漏洞。在某些情况下，开发者可能明确添加类加载器来实现功能：例如，允许用户通过加载新类来扩展应用程序，或者能够使用同一依赖项的冲突版本。
- en: Regardless of how multiple class loaders enter the picture, they require you
    to take a deeper dive into this topic. And they can quickly lead to a complex
    delegation mechanism that exhibits unexpected, hard-to-understand behavior.
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论多个类加载器如何进入画面，它们都需要你更深入地研究这个主题。并且它们可以迅速导致一个复杂的委托机制，表现出意外且难以理解的行为。
- en: 1.3.5 WEAK ENCAPSULATION ACROSS JARS
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.3.5 JAR之间的弱封装
- en: 'Java’s visibility modifiers are great to implement encapsulation between classes
    in the same package. But across package boundaries, there’s only one visibility
    for types: `public`.'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java的可见性修饰符非常适合在同一个包中的类之间实现封装。但跨包边界，类型的可见性只有一种：`public`。
- en: As you’ve seen, a class loader folds all loaded packages into one big ball of
    mud —with the consequence that all public classes are visible to all other classes.
    Due to this weak encapsulation, there’s no way to create functionality that’s
    visible throughout an entire JAR but not outside of it.
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如你所见，类加载器将所有加载的包折叠成一个巨大的泥球——结果是所有公共类对所有其他类都是可见的。由于这种弱封装，无法创建在整个 JAR 内部可见但外部不可见的函数。
- en: This makes it difficult to properly modularize a system. If some functionality
    is required by different parts of a module (such as a library or a subproject
    of your system) but shouldn’t be visible outside of it, the only way to achieve
    this is to put them all into one package and use package visibility. In an act
    of preemptive obedience, you erase the code’s structure instead of leaving this
    task to the JVM. Even in cases where package visibility solves this problem, there’s
    still reflection to get around that.
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这使得正确模块化系统变得困难。如果某些功能需要由模块的不同部分（如库或系统的子项目）使用，但不应该对外部可见，唯一的方法是将它们全部放入一个包中并使用包可见性。在一种预防性的服从行为中，你抹去了代码的结构，而不是将这项任务留给
    JVM。即使在包可见性解决了这个问题的情况下，仍然有反射可以绕过它。
- en: Weak encapsulation lets clients of an artifact break into its internals (see
    [figure 1.10](part0014.html#filepos188123)). This can happen accidentally if an
    IDE suggests importing classes from packages that documentation marks as being
    internal. More often, it’s done purposefully to overcome problems that seem to
    have no other solution (which is sometimes the case and sometimes not). But it
    comes at a high price!
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 弱封装允许一个组件的客户突破其内部结构（参见 [图 1.10](part0014.html#filepos188123)）。这可能是意外发生的，如果 IDE
    建议从文档标记为内部包的包中导入类。更常见的是，这是为了克服似乎没有其他解决方案的问题（有时是这样，有时不是）。但代价是高昂的！
- en: '![](../images/00039.jpeg)'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00039.jpeg)'
- en: '[Figure 1.10](part0014.html#filepos187513) The maintainers of Eclipse JGit
    didn’t intend the types in `org.eclipse.jgit.internal` for public consumption.
    Unfortunately, because Java has no concept of JAR internals, there’s nothing the
    maintainers can do to stop any `com.company.Type` from compiling against it. Even
    if it were only package visible, it could still be accessed via reflection.'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 1.10](part0014.html#filepos187513) Eclipse JGit 的维护者并没有打算让 `org.eclipse.jgit.internal`
    中的类型供公共使用。不幸的是，由于 Java 没有关于 JAR 内部的概念，维护者无法阻止任何 `com.company.Type` 编译时与之冲突。即使它只有包可见性，也可以通过反射访问它。'
- en: Now the clients’ code is coupled to the artifact’s implementation details. This
    makes updates risky for the clients and, if the maintainers decide to take this
    coupling into consideration, impedes changing those internals. It can go as far
    as to slow or even prevent meaningful evolution of the artifact.
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，客户端的代码与组件的实现细节耦合在一起。这使得客户端的更新变得风险很大，如果维护者决定考虑这种耦合，将阻碍这些内部组件的更改。这可能会发展到减缓或甚至阻止组件的有意义的发展。
- en: In case this sounds like an edge case, it isn’t. The most notorious example
    is `sun.misc.Unsafe`, a JDK-internal class that lets us do crazy things (by Java
    standards) like directly allocating and freeing memory. Many critical Java libraries
    and frameworks like Netty, PowerMock, Neo4J, Apache Hadoop, and Hazelcast use
    it. And because many applications depend on those libraries, they also depend
    on these internals. That way, `Unsafe` became a critical piece of infrastructure
    even though it was neither intended nor designed to be.
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果这听起来像是一个边缘情况，那就不是了。最臭名昭著的例子是 `sun.misc.Unsafe`，这是一个 JDK 内部类，允许我们做一些疯狂的事情（按照
    Java 标准），比如直接分配和释放内存。许多关键的 Java 库和框架，如 Netty、PowerMock、Neo4J、Apache Hadoop 和 Hazelcast
    都在使用它。由于许多应用程序依赖于这些库，它们也依赖于这些内部组件。因此，尽管 `Unsafe` 并非有意或设计成这样，但它已成为基础设施的一个关键部分。
- en: Another example is JUnit 4\. Many tools, especially IDEs, have all kinds of
    nice features that make testing easier for developers. But because JUnit 4’s API
    isn’t rich enough to implement all these features, tools break into its internals.
    This coupling considerably slowed JUnit 4’s development, eventually becoming an
    important reason to completely start over with JUnit 5.
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个例子是 JUnit 4。许多工具，尤其是 IDE，都有各种使开发者测试更容易的出色功能。但由于 JUnit 4 的 API 不足以实现所有这些功能，工具会突破其内部结构。这种耦合大大减缓了
    JUnit 4 的发展，最终成为完全重新开始使用 JUnit 5 的一个重要原因。
- en: 1.3.6 SECURITY CHECKS HAVE TO BE HANDCRAFTED
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.3.6 安全检查必须手工制作
- en: An immediate consequence of weak encapsulation across package boundaries is
    that security-relevant functionality is exposed to all code running in the same
    environment. This means malicious code can access critical functionality, and
    the only way to combat that is to manually implement security checks on critical
    execution paths.
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在包边界上弱封装的直接后果是，与安全相关的功能暴露给了同一环境中运行的所有代码。这意味着恶意代码可以访问关键功能，而唯一对抗这种做法的方法是在关键执行路径上手动实现安全检查。
- en: Since Java 1.1, this has been done by invoking `SecurityManager::checkPackageAccess`—which
    checks whether the calling code is allowed to access the called package—on every
    code path into security-relevant code. Or rather, it should be invoked on every
    such path. Forgetting these calls led to some of the vulnerabilities that plagued
    Java in the past, particularly during the transition from Java 7 to 8.
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自Java 1.1以来，这是通过在每个进入安全相关代码的代码路径上调用`SecurityManager::checkPackageAccess`（检查调用代码是否允许访问被调用包）来实现的。或者更确切地说，应该在每条这样的路径上调用。忘记这些调用导致了过去困扰Java的一些漏洞，尤其是在从Java
    7过渡到8的过程中。
- en: It can, of course, be argued that security-relevant code should be double, triple,
    or quadruple checked. But to err is human, and requiring us to manually insert
    security checks at module boundaries poses a higher risk than a well-automated
    variant.
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当然，可以争论说，与安全相关的代码应该被双重、三重或四重检查。但人非圣贤，要求我们在模块边界手动插入安全检查反而比一个高度自动化的变体风险更高。
- en: 1.3.7 POOR STARTUP PERFORMANCE
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.3.7 启动性能不佳
- en: Did you ever wonder why many Java applications, particularly web backends that
    use powerful frameworks like Spring, take so long to load?
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你是否曾经想过为什么许多Java应用程序，尤其是使用像Spring这样的强大框架的Web后端，加载时间如此之长？
- en: 'Definition: Slow startup'
  id: totrans-143
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：慢启动
- en: As you saw earlier, the JVM will lazily load classes as they’re required. Most
    commonly, many classes are first accessed immediately during startup (as opposed
    to later when the application has run for a while). And it takes a while for the
    Java runtime to load them all.
  id: totrans-144
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如你之前看到的，JVM会按需懒加载类。最常见的情况是，许多类在启动时立即被访问（而不是在应用程序运行一段时间后），Java运行时加载它们需要一段时间。
- en: One reason is that the class loader has no way to know which JAR a class comes
    from, so it must execute a linear scan of all JARs on the class path. Similarly,
    identifying all occurrences of a specific annotation requires the inspection of
    all classes on the class path.
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个原因是类加载器不知道一个类来自哪个JAR，因此它必须对类路径上的所有JAR进行线性扫描。同样，识别类路径上所有特定注解的出现需要检查所有类。
- en: 1.3.8 RIGID JAVA RUNTIME
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.3.8 刚硬的Java运行时
- en: This isn’t really a consequence of the JVM’s big-ball-of-mud approach, but as
    long as I’m ranting, I’ll get it out there.
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这并不是JVM大杂烩方法的真正后果，但既然我在抱怨，我就把它说出来。
- en: 'Definition: Rigid runtime'
  id: totrans-148
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：刚硬运行时
- en: Before Java 8, there was no way to install a subset of the JRE. All Java installations
    had support for, for example, XML, SQL, and Swing, which many use cases don’t
    require.
  id: totrans-149
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Java 8之前，没有安装JRE子集的方法。所有Java安装都支持XML、SQL和Swing等，而许多用例并不需要这些。
- en: Although this may be of little relevance for medium-sized computing devices
    (such as desktop PCs and laptops), it’s obviously important for the smallest devices
    like routers, TV boxes, cars, and all the other nooks and crannies where Java
    is used. With the current trend of containerization, it also gains relevance on
    servers, where reducing an image’s footprint will reduce costs.
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然这对中等计算设备（如台式电脑和笔记本电脑）可能影响不大，但对于像路由器、机顶盒、汽车以及Java被使用的所有其他角落和缝隙，这显然很重要。随着容器化的当前趋势，它对服务器也变得相关，减少镜像的大小可以降低成本。
- en: Java 8 brought compact profiles, which define three subsets of Java SE. They
    alleviate the problem but don’t solve it. Compact profiles are fixed and hence
    unable to cover all current and future needs for partial JREs.
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 8引入了紧凑配置文件，它定义了Java SE的三个子集。它们缓解了问题，但并没有解决这个问题。紧凑配置文件是固定的，因此无法覆盖所有当前和未来对部分JRE的需求。
- en: 1.4 Bird’s-eye view of the module system
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.4 模块系统的鸟瞰图
- en: We’ve just discussed quite a few problems. How does the Java Platform Module
    System address them? The principal idea is pretty simple!
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们刚刚讨论了很多问题。Java平台模块系统是如何解决这些问题的？主要思想相当简单！
- en: 'ESSENTIAL INFO Modules are the basic building block of the JPMS (surprise).
    Like JARs, they’re containers for types and resources; but unlike JARs, they have
    additional characteristics. These are the most fundamental ones:'
  id: totrans-154
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ESSENTIAL INFO 模块是 JPMS 的基本构建块（惊喜）。像 JAR 一样，它们是类型和资源的容器；但与 JAR 不同，它们具有额外的特性。这些是最基本的特性：
- en: A name, preferably one that’s globally unique
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名称，最好是全局唯一的
- en: Declarations of dependencies on other modules
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对其他模块的依赖声明
- en: A clearly defined API that consists of exported packages
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个明确定义的 API，由导出包组成
- en: 1.4.1 EVERYTHING IS A MODULE
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.4.1 每件事都是模块
- en: There are different kinds of modules, and section 3.1.4 categorizes them, but
    it makes sense to take a quick look at them now. During work on Project Jigsaw,
    the OpenJDK was split up into about 100 modules, the so-called platform modules.
    Roughly 30 of them have names beginning with `java.*`; they’re the standardized
    modules that every JVM must contain ([figure 1.11](part0014.html#filepos198318)
    shows a few of them).
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有不同类型的模块，第 3.1.4 节对它们进行了分类，但现在快速看一下它们是有意义的。在 Project Jigsaw 的工作中，OpenJDK 被拆分成了大约
    100 个模块，所谓的平台模块。其中大约 30 个以 `java.*` 开头；它们是标准化的模块，每个 JVM 必须包含（[图 1.11](part0014.html#filepos198318)
    展示了其中的一些）。
- en: '![](../images/00075.jpeg)'
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00075.jpeg)'
- en: '[Figure 1.11](part0014.html#filepos197985) A selection of platform modules.
    The arrows show their dependencies, but some aren’t depicted to keep the graph
    simpler: The aggregator module java.sedirectly depends on each module, and each
    module directly depends on java.base.'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 1.11](part0014.html#filepos197985) 平台模块的选择。箭头显示它们的依赖关系，但为了使图形更简单，一些依赖关系没有被表示：聚合器模块
    java.se 直接依赖于每个模块，每个模块直接依赖于 java.base。'
- en: 'These are some of the more important ones:'
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些是一些比较重要的模块：
- en: java.base —The module without which no JVM program functions. Contains packages
    like `java.lang` and `java.util`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.base — 没有它就没有 JVM 程序可以运行的模块。包含 `java.lang` 和 `java.util` 等包。
- en: java.desktop —Not only for those brave desktop UI developers out there. Contains
    the Abstract Window Toolkit (AWT; packages `java.awt.*`), Swing (packages `javax.swing.*`),
    and more APIs, among them JavaBeans (package `java.beans.*`).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.desktop — 不仅针对那些勇敢的桌面 UI 开发者。包含抽象窗口工具包 (AWT；包 `java.awt.*`)、Swing（包 `javax.swing.*`）和更多
    API，其中还包括 JavaBeans（包 `java.beans.*`）。
- en: java.logging —Contains the package `java.util.logging`.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.logging — 包含 `java.util.logging` 包。
- en: java.rmi —Remote Method Invocation (RMI).
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.rmi — 远程方法调用 (RMI)。
- en: 'java.xml —Contains most of the XML API word salad: Java API for XML Processing
    (JAXP), Streaming API for XML (StAX), Simple API for XML (SAX), and the document
    object model (DOM).'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.xml — 包含大部分 XML API 的词汇：Java API for XML Processing (JAXP)、Streaming API
    for XML (StAX)、Simple API for XML (SAX) 和文档对象模型 (DOM)。
- en: java.xml.bind —Java Architecture for XML Binding (JAXB).
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.xml.bind — Java Architecture for XML Binding (JAXB)。
- en: java.sql —Java Database Connectivity (JDBC).
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.sql — Java 数据库连接 (JDBC)。
- en: java.sql.rowset —JDBC RowSet API.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.sql.rowset — JDBC RowSet API。
- en: java.se —References the modules making up the core Java SE API. (This is a so-called
    aggregator module; see section 11.1.5.)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.se — 引用组成核心 Java SE API 的模块。（这是一个所谓的聚合器模块；参见第 11.1.5 节。）
- en: java.se.ee —References the modules making up the full Java SE API (another aggregator).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.se.ee — 引用组成完整 Java SE API 的模块（另一个聚合器）。
- en: 'Then there’s JavaFX. A telltale sign that its high-level architecture is superior
    to AWT’s and Swing’s is that not only was it sufficiently decoupled from the rest
    of the JDK to get its own module, it was actually split into seven: bindings,
    graphics, controls, web view, FXML, media, and Swing interop. All of these module
    names begin with javafx.*.'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后是 JavaFX。它的高级架构优于 AWT 和 Swing 的一个明显迹象是，它不仅足够地从 JDK 的其余部分解耦以获得自己的模块，实际上还被分成了七个：绑定、图形、控件、网页视图、FXML、媒体和
    Swing 互操作。所有这些模块名称都以 javafx.* 开头。
- en: 'Finally, there are about 60 modules whose names begin with jdk. They contain
    API implementations, internal utilities, tools (such as the compiler, JAR, Java
    Dependency Analysis Tool [JDeps], and Java Shell Tool [JShell]), and more. They
    may differ across JVM implementations, so using them is akin to using code from
    `sun.` packages: not a future-proof choice but sometimes the only option available.'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，大约有 60 个以 jdk 开头的模块。它们包含 API 实现、内部实用工具、工具（如编译器、JAR、Java 依赖分析工具 [JDeps] 和
    Java Shell 工具 [JShell]）等。它们可能因 JVM 实现而异，因此使用它们类似于使用 `sun.` 包中的代码：不是一个未来证明的选择，但有时是唯一可用的选项。
- en: You can see a list of all modules contained in a JDK or JRE by running `java
    --list-modules`. To get details for a single module, execute `java --describe-module
    ${module-name}.` (`${module-name}` is a placeholder, not valid syntax—replace
    it with your module of choice.)
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以通过运行 `java --list-modules` 来查看包含在 JDK 或 JRE 中的所有模块列表。要获取单个模块的详细信息，请执行 `java
    --describe-module ${module-name}.` （`${module-name}` 是一个占位符，不是有效的语法——请将其替换为您选择的模块。）
- en: 'Platform modules are packed into JMOD files, a new format created specifically
    for this purpose. But code outside the JDK can create modules just as well. In
    that case, they’re modular JARs: plain JARs that contain a new construct, the
    module descriptor, which defines the module’s name, dependencies, and exports.
    Finally, there are modules the module system creates on the fly from JARs that
    weren’t yet transformed into modules.'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 平台模块打包到 JMOD 文件中，这是一个专门为此目的创建的新格式。但 JDK 之外的外部代码也可以创建模块。在这种情况下，它们是模块化 JAR：包含一个新结构，模块描述符，它定义了模块的名称、依赖关系和导出。最后，还有模块系统从尚未转换为模块的
    JAR 文件中动态创建的模块。
- en: 'ESSENTIAL INFO This leads to a fundamental aspect of the module system: everything
    is a module! (Or, more precisely, no matter how types and resources are presented
    to the compiler or the virtual machine, they will end up in a module.) Modules
    are at the heart of the module system and hence of this book. Everything else
    can ultimately be traced back to them and their name, their declaration of dependencies,
    and the API they export.'
  id: totrans-177
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 这导致模块系统的基本方面：一切都是模块！（或者更准确地说，无论类型和资源如何呈现给编译器或虚拟机，它们最终都会进入一个模块。）模块是模块系统的核心，也是本书的核心。其他所有内容最终都可以追溯到它们及其名称、它们的依赖关系声明以及它们导出的
    API。'
- en: 1.5 Your first module
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.5 您的第一个模块
- en: That the JDK was modularized is fine and dandy, but what about your code? How
    does it end up in modules? That’s fairly simple.
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JDK 的模块化是很好，但您的代码呢？它如何最终进入模块中？这相当简单。
- en: 'The only thing you need to do is add a file called `module-info.java`, a module
    declaration, to your source folder and fill it with your module’s name, dependencies
    on other modules, and the packages that make up its public API:'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您唯一需要做的是在源文件夹中添加一个名为 `module-info.java` 的文件，一个模块声明，并填写您的模块名称、对其他模块的依赖关系以及构成其公共
    API 的包：
- en: '`module my.xml.app {` `requires java.base;` [`①`](part0014.html#filepos206814)
    `requires java.xml; exports my.xml.api; }`'
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module my.xml.app {` `requires java.base;` [`①`](part0014.html#filepos206814)
    `requires java.xml; exports my.xml.api; }`'
- en: ①
  id: totrans-182
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: You’ll see later that requiring java.base isn’t actually necessary.
  id: totrans-183
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您将看到，要求 java.base 实际上并不是必需的。
- en: Looks like the my.xml.app module uses the platform modules java.base and java.xml
    and exports a package `com.example.xml`. So far, so good. Now you compile `module-info.java`
    with all other sources to `.class` files and package it into a JAR. (The compiler
    and the `jar` tool will automatically do the right thing.) Et voilà, you’ve created
    your first module.
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 看起来 my.xml.app 模块使用了平台模块 java.base 和 java.xml 并导出一个包 `com.example.xml`。到目前为止，一切顺利。现在，将
    `module-info.java` 与所有其他源文件一起编译成 `.class` 文件，并将其打包到 JAR 中。（编译器和 `jar` 工具将自动完成正确的事情。）Et
    voilà，您已经创建了您的第一个模块。
- en: 1.5.1 THE MODULE SYSTEM IN ACTION
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.5.1 模块系统的作用
- en: 'Let’s launch the XML application and observe the module system in action. To
    do so, fire off the following command:'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们启动 XML 应用程序并观察模块系统的作用。为此，请执行以下命令：
- en: '`java --module-path mods --module my.xml.app`'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`java --module-path mods --module my.xml.app`'
- en: 'The module system picks it up from here. It takes a number of steps to improve
    the situation over the ball of mud you saw in sections 1.2 and 1.3:'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统从这里开始。它采取了许多步骤来改善您在 1.2 和 1.3 节中看到的泥球状结构：
- en: Bootstraps itself
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自举
- en: Verifies that all required modules are present
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证所有必需的模块是否存在
- en: Builds internal representation of application architecture
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序架构的内部表示
- en: Launches the initial module’s `main` method
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动初始模块的 `main` 方法
- en: Stays active while the application is running, to protect the module internals
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序运行期间保持活跃，以保护模块内部
- en: '[Figure 1.12](part0014.html#filepos210256) captures all the steps. But let’s
    not get ahead of ourselves, and study each step in turn.'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 1.12](part0014.html#filepos210256) 捕获了所有步骤。但让我们不要急于求成，依次研究每个步骤。'
- en: '![](../images/00048.jpeg)'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00048.jpeg)'
- en: '[Figure 1.12](part0014.html#filepos209822) The Java Platform Module System
    (JPMS) in action. It does most of its work at launch time: after (1) bootstrapping,
    it (2) makes sure all modules are present while building the module graph, before
    (3) handing control over to the running application. At run time, it (4) enforces
    that each module’s internals are protected.'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 1.12](part0014.html#filepos209822) Java 平台模块系统 (JPMS) 在实际应用中的工作情况。它的大部分工作在启动时完成：在（1）引导启动之后，它（2）确保在构建模块图时所有模块都存在，然后在（3）将控制权交给运行的应用程序之前。在运行时，它（4）强制执行每个模块的内部结构得到保护。'
- en: LOADING THE BASE MODULE
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 加载基础模块
- en: The module system is just code, and you’ve learned that everything is a module,
    so which one contains the JPMS? That would be java.base, the base module. In a
    considerable hen-and-egg mind-boggler, the module system and the base module bootstrap
    each other.
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统只是代码，你已经了解到一切皆模块，那么哪个包含了 JPMS？那就是 java.base，基础模块。在一个相当复杂的鸡生蛋问题中，模块系统和基础模块互相引导启动。
- en: The base module is also the first node in the module graph that the JPMS builds.
    That’s exactly what it does next.
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 基础模块也是 JPMS 构建的模块图中的第一个节点。这正是它接下来要做的。
- en: 'MODULE RESOLUTION: BUILDING A GRAPH THAT REPRESENTS THE APPLICATION'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块解析：构建表示应用程序的图
- en: The command you issued ended with `--module my.xml.app`. This tells the module
    system that my.xml.app is the application’s main module and that dependency resolution
    needs to start there. But where can the JPMS find the module? That’s where `--module-path
    mods` comes in. It tells the module system that it can find application modules
    in the folder `mods`, so the JPMS dutifully looks there for the my.xml.app module.
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你发出的命令以 `--module my.xml.app` 结尾。这告诉模块系统 my.xml.app 是应用程序的主模块，并且依赖关系解析需要从这里开始。但
    JPMS 在哪里可以找到这个模块？这就是 `--module-path mods` 的作用。它告诉模块系统它可以在文件夹 `mods` 中找到应用程序模块，因此
    JPMS 忠实地在那里寻找 my.xml.app 模块。
- en: 'Folders don’t contain modules, though: they contain JARs. So the module system
    scans all JARs in `mods` and looks for their module descriptors. In the example,
    `mods` contains `my.xml.app.jar`, and its descriptor claims it contains a module
    named my.xml.app. Exactly what the module system has been looking for! The JPMS
    creates an internal representation of my.xml.app and adds it to the module graph—so
    far, not connected to anything else.'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 文件夹不包含模块，它们包含 JAR 文件。因此模块系统扫描 `mods` 中的所有 JAR 文件，并查找它们的模块描述符。在示例中，`mods` 包含
    `my.xml.app.jar`，其描述符声称它包含一个名为 my.xml.app 的模块。这正是模块系统一直在寻找的！JPMS 创建 my.xml.app
    的内部表示并将其添加到模块图中——到目前为止，还没有连接到其他任何东西。
- en: The module system found the initial module. What’s next? Searching for its dependencies.
    The descriptor of my.xml.app states that it requires the modules java.base and
    java.xml. Where can the JPMS find those?
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统找到了初始模块。接下来是什么？寻找它的依赖。my.xml.app 的描述符表明它需要模块 java.base 和 java.xml。JPMS 在哪里可以找到这些模块？
- en: The first one, java.base, is already known, so the module system can add a connection
    from my.xml.app to java.base —the first edge in the graph. Next up is java.xml.
    It begins with java, which tells the module system it’s a platform module; so
    the JPMS doesn’t search the module path for it, but instead searches its own module
    storage. The JPMS finds java.xml there and adds it to the graph with a connection
    from my.xml.app to it.
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第一个，java.base，已经为人所知，因此模块系统可以从 my.xml.app 添加一个连接到 java.base ——图中的第一条边。接下来是 java.xml。它以
    java 开头，这告诉模块系统它是一个平台模块；因此 JPMS 不在模块路径中搜索它，而是在其自己的模块存储中搜索。JPMS 在那里找到了 java.xml
    并将其添加到图中，通过 my.xml.app 与其建立连接。
- en: Now you have three nodes in the graph, but only two were resolved. The dependencies
    of java.xml are still unknown, so the JPMS checks them next. It doesn’t have any
    dependencies other than java.base, though, so module resolution concludes. Starting
    with my.xml.app and the omnipresent base module, the process built a small graph
    with three nodes.
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在图中有三个节点，但只有两个被解析。java.xml 的依赖关系仍然未知，因此 JPMS 接下来检查它们。尽管如此，它除了 java.base 之外没有其他依赖，因此模块解析结束。从
    my.xml.app 和无处不在的基础模块开始，这个过程构建了一个包含三个节点的简单图。
- en: If the JPMS can’t find a required module, or if it encounters any ambiguities
    (like two JARs containing modules with the same name), it will quit with an informative
    error message. This means you can discover problems at launch time that would
    otherwise crash the running application at some arbitrary point in the future.
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果JPMS找不到所需的模块，或者遇到任何歧义（例如，两个包含具有相同名称的模块的JAR文件），它将带有一个信息性错误消息退出。这意味着你可以在启动时发现问题，否则这些问题可能会在未来某个任意时刻导致正在运行的应用程序崩溃。
- en: LAUNCHING THE INITIAL MODULE
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 启动初始模块
- en: How did this process start, again? Ah yes, with the command ending in `--module
    my.xml.app`. The module system fulfilled one of its core functions—verifying the
    presence of all required dependencies—and can now hand control over to the application.
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个过程又是如何开始的呢？啊，是的，是通过以`--module my.xml.app`结尾的命令。模块系统完成了其核心功能之一——验证所有必需依赖项的存在——现在可以交出控制权给应用程序。
- en: The initial module my.xml.app is not only the one where module resolution starts,
    it must also contain a `public static void main(String[])` method. But you don’t
    necessarily have to specify the class containing that method when launching the
    app. I skipped past this, but you were diligent when packaging the `.class` files
    into a JAR and specified the main class then. That information was embedded in
    the module descriptor, which is where the JPMS can read it from now.
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 初始模块`my.xml.app`不仅是模块解析开始的模块，它还必须包含一个`public static void main(String[])`方法。但在启动应用程序时，你不必指定包含该方法的类。我跳过了这一步，但你打包`.class`文件到JAR时很勤奋，并在那时指定了主类。这些信息被嵌入到模块描述符中，现在JPMS可以从中读取它。
- en: Because you used `--module my.xml.app` without specifying a main class, the
    module system expects to find that information in the module descriptor. Fortunately
    it does, and it calls `main` on that class. The application launches, but the
    JPMS’s work isn’t over yet!
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于你没有指定主类就使用了`--module my.xml.app`，模块系统期望在模块描述符中找到该信息。幸运的是，它确实找到了，并且在该类上调用`main`方法。应用程序启动了，但JPMS的工作还没有结束！
- en: GUARDING MODULE INTERNALS
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 保护模块内部
- en: 'Even with the application successfully launched, the module system needs to
    stay active to fulfill its second essential function: guarding module internals.
    Remember the line `exports my.xml.api` in my.xml.app’s module declaration? This
    is where it and others like it come into play.'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使应用程序成功启动，模块系统也需要保持活跃以履行其第二个基本功能：保护模块内部。还记得`my.xml.app`模块声明中的`exports my.xml.api`那一行吗？这就是它和其他类似的地方发挥作用的地方。
- en: 'Whenever a module first accesses a type in another module, the JPMS verifies
    that three requirements are met:'
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每当模块首次访问另一个模块中的类型时，JPMS都会验证以下三个要求是否得到满足：
- en: The accessed type needs to be public.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被访问的类型必须是公开的。
- en: The module owning that type must have exported the package containing it.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有该类型的模块必须导出包含它的包。
- en: In the module graph, the accessing module must be connected to the owning one.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块图中，访问模块必须连接到拥有模块。
- en: When my.xml.app first uses `javax.xml.XMLConstants` (for example), the module
    system checks whether `XMLConstants` is public (✔), whether java.xml exports `javax.xml`
    (✔), and whether my.xml.app is connected to java.xml in the module graph (✔).
    Because all three pan out, my.xml.app can do its thing with `XMLConstants`.
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当`my.xml.app`首次使用`javax.xml.XMLConstants`（例如）时，模块系统会检查`XMLConstants`是否是公开的（✔），`java.xml`是否导出`javax.xml`（✔），以及`my.xml.app`是否在模块图中连接到`java.xml`（✔）。由于所有三个条件都满足，`my.xml.app`就可以使用`XMLConstants`进行操作。
- en: 'This behavior fixes a critical deficiency of the ball-of-mud approach Java
    used to take with artifact relationships: that there was no way to distinguish
    code that’s internal to an artifact from code that can be used publicly. With
    `exports` in play, a module can clearly define which parts of its API are public
    and which are internal and can depend on the module system to enforce its decision.'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种行为修复了Java在工件关系上采用泥球方法的一个关键缺陷：无法区分工件内部的代码和可以公开使用的代码。有了`exports`，模块可以清楚地定义其API的哪些部分是公开的，哪些是内部的，并且可以依赖模块系统来执行其决策。
- en: A MORE COMPLEX EXAMPLE
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更复杂的例子
- en: As a less trivial example, [figure 1.13](part0014.html#filepos225812) shows
    the module graph for the ServiceMonitor application introduced in section 1.2\.
    Its four JARs—monitor, observer, statistics, and persistence—as well as its two
    dependencies—spark and hibernate—were turned into modules. JDK modules like java.xml
    and java.base are visible as well, because the application depends on some of
    them, too.
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为一个不那么平凡的例子，[图1.13](part0014.html#filepos225812)展示了在1.2节中引入的ServiceMonitor应用程序的模块图。它的四个JAR文件——monitor、observer、statistics和persistence，以及它的两个依赖项——spark和hibernate——都被转换成了模块。像java.xml和java.base这样的JDK模块也因为应用程序依赖于它们而可见。
- en: I find the comparison with [figure 1.6](part0014.html#filepos164823), which
    depicts the dependencies between ServiceMonitor’s JARs, striking. [Figure 1.6](part0014.html#filepos164823)
    shows our understanding of how the application is organized on an artifact level,
    whereas [figure 1.13](part0014.html#filepos225812) shows how the module system
    sees it. That they’re so similar demonstrates how well the module system can be
    used to express an application’s architecture.
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我发现与[图1.6](part0014.html#filepos164823)的比较很引人注目，该图描述了ServiceMonitor的JAR文件之间的依赖关系。[图1.6](part0014.html#filepos164823)显示了我们在工件级别上组织应用程序的理解，而[图1.13](part0014.html#filepos225812)显示了模块系统如何看待它。它们如此相似证明了模块系统可以很好地用来表达应用程序的架构。
- en: '![](../images/00072.jpeg)'
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00072.jpeg)'
- en: '[Figure 1.13](part0014.html#filepos223100) The module graph for the ServiceMonitor
    application is very similar to the architecture diagram in [figure 1.6](part0014.html#filepos164823).
    The graph shows the four modules containing the application’s code, the two libraries
    it uses to implement its feature set, and the involved modules from the JDK. Arrows
    depict the dependencies between them. Each module lists some of the packages it
    exports.'
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图1.13](part0014.html#filepos223100) ServiceMonitor应用程序的模块图与[图1.6](part0014.html#filepos164823)中的架构图非常相似。该图显示了包含应用程序代码的四个模块、实现其功能集所使用的两个库以及涉及的JDK模块。箭头表示它们之间的依赖关系。每个模块列出了它导出的一些包。'
- en: 1.5.2 YOUR NON-MODULAR PROJECT WILL BE FINE—MOSTLY
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.5.2 您的非模块化项目将大致上运行良好
- en: Developers of existing projects, particularly with large code bases, will be
    interested in migration paths. Although other module systems are usually “in or
    out,” meaning in order to use them, everything must be a module, this isn’t an
    option for the JPMS. To uphold backward compatibility, a regular application running
    from the class path on Java 8 or earlier must do the same on Java 9\. Thus unmodularized
    applications must run on top of the modularized JDK, which implies that the module
    system must handle that case.
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于现有项目，尤其是拥有大型代码库的项目，开发者会对迁移路径感兴趣。尽管其他模块系统通常是“要么在要么不在”，意味着为了使用它们，一切都必须是模块，但这对于JPMS来说并不是一个选项。为了保持向后兼容性，在Java
    8或更早版本上从类路径上运行的应用程序必须在Java 9上做同样的事情。因此，非模块化应用程序必须在模块化的JDK之上运行，这意味着模块系统必须处理这种情况。
- en: And it does. I already mentioned in passing that the module system handles JARs
    that weren’t yet turned into modules. This is the case precisely because of backward
    compatibility. Although migrating to the module system is beneficial, it’s not
    compulsory.
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它确实做到了。我之前已经顺便提到，模块系统处理了尚未转换为模块的JAR文件。这正是由于向后兼容性的原因。尽管迁移到模块系统是有益的，但它不是强制性的。
- en: As a consequence, the class path, used to specify JARs or plain `.class` files
    for the compiler and JVM, works as on Java 8 and before. Even modules on the class
    path behave just like non-modular JARs. The underlying assumption is that the
    class path is in charge of accessing artifacts that want to be turned into the
    ball of mud discussed in section 1.3.
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，用于指定编译器和JVM的JAR文件或普通`.class`文件的类路径，在Java 8和之前的工作方式相同。甚至类路径上的模块表现得就像非模块化JAR文件一样。基本假设是类路径负责访问想要转换为1.3节中讨论的泥球状结构的工件。
- en: 'Parallel to that, a new concept was created: the module path. Here, the underlying
    assumption is that it treats all artifacts as modules. Interestingly, this is
    true even for plain JARs.'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与此同时，一个新的概念被创造出来：模块路径。在这里，基本假设是它将所有工件视为模块。有趣的是，即使是普通的JAR文件也是如此。
- en: ESSENTIAL INFO The coexistence of the class path and the module path and their
    respective treatment of plain and modular artifacts is the key to incremental
    migrations of large applications to the module system. Chapter 8 explores this
    important topic in depth.
  id: totrans-229
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的信息：类路径和模块路径的共存以及它们对普通和模块化工件的处理是大型应用程序逐步迁移到模块系统的关键。第8章将深入探讨这个重要主题。
- en: 'Another aspect of the module system that’s important, particularly to legacy
    projects, is compatibility. The JPMS entails a lot of changes under the hood,
    and although almost all of them are backward-compatible in the strict meaning
    of the word, some interact badly with existing code bases. For example:'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统的一个重要方面，尤其是对遗留项目来说，是兼容性。JPMS在底层进行了许多更改，尽管几乎所有的更改在严格意义上都是向后兼容的，但其中一些与现有代码库的交互非常糟糕。例如：
- en: Dependencies on JDK-internal APIs (for example, those in `sun.*` packages) cause
    compile-time errors and runtime warnings.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于JDK内部API（例如`sun.*`包中的那些）会导致编译时错误和运行时警告。
- en: JEE APIs must be resolved manually.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEE API必须手动解析。
- en: Different artifacts that contain classes in the same package can cause problems.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含相同包中类的不同工件可能会引起问题。
- en: Compact profiles, the extension mechanism, the endorsed-standards-override mechanism,
    and similar features were removed.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧凑配置文件、扩展机制、endorsed-standards-override机制以及类似功能已被移除。
- en: The runtime image layout changed considerably.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时图像布局发生了很大变化。
- en: The application class loader is no longer a `URLClassLoader`.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序类加载器不再是`URLClassLoader`。
- en: In the end, regardless of whether an application is modularized, running on
    Java 9 or later may break it. Chapters 6 and 7 are dedicated to identifying and
    overcoming the most common challenges.
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，无论一个应用程序是否模块化，在Java 9或更高版本上运行可能会破坏它。第6章和第7章专门用于识别和克服最常见的挑战。
- en: 'At this point, you may have questions like these:'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能会有这样的疑问：
- en: Don’t Maven, Gradle, and others already manage dependencies?
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven、Gradle和其他工具不是已经管理依赖项了吗？
- en: What about Open Service Gateway Initiative (OSGi)? Why don’t I just use that?
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于开放服务网关倡议（OSGi），为什么我不直接使用它呢？
- en: Isn’t a module system overkill in times when everybody writes microservices?
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大家都编写微服务的时候，模块系统不是过度了吗？
- en: And you’re right to ask. No technology is an island, and it’s worth looking
    at the Java ecosystem as a whole and examining how existing tools and approaches
    are related to the module system and what their relation might be in the future.
    I do this in section 15.3; you already know everything you need to understand
    it, so if you can’t let those questions go, why not read it now?
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你提出的问题很有道理。没有一项技术是孤立的，值得从整体上审视Java生态系统，并检查现有工具和方法与模块系统的关系以及它们未来的可能关系。我在第15.3节中这样做；你已经知道了解读它所需的一切，所以如果你不能放下这些问题，为什么不现在就读读它呢？
- en: Section 1.5 describes the high-level goals the module system wants to achieve,
    and chapter 2 shows a longer example of what a modular application might look
    like. Chapters 3, 4, and 5 explore in detail how to write, compile, package, and
    run such applications from scratch. Part 2 of this book discusses compatibility
    and migration before part 3 turns to advanced features of the module system.
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第1.5节描述了模块系统想要实现的高级目标，第2章展示了模块化应用程序可能的样子的一个更长的示例。第3章、第4章和第5章详细探讨了从头开始编写、编译、打包和运行此类应用程序的方法。本书的第二部分在第三部分转向模块系统的先进功能之前讨论了兼容性和迁移。
- en: 1.6 Goals of the module system
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.6 模块系统目标
- en: In essence, the Java Platform Module System was developed to teach Java about
    the dependency graph between artifacts. The idea is that if Java stops erasing
    the module structure, most of the ugly consequences of that erasure disappear
    as well.
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从本质上讲，Java平台模块系统是为了教Java了解工件之间的依赖关系图而开发的。想法是，如果Java停止擦除模块结构，那么这种擦除的大部分丑陋后果也会消失。
- en: First and foremost, this should alleviate many of the pain points the current
    state of affairs is causing. But more than that, it introduces capabilities, new
    to most developers who haven’t used other module systems, that can further improve
    the modularization of software. What does this mean on a more concrete level?
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先，这应该会减轻当前状况造成的许多痛点。但不仅如此，它引入了大多数未使用过其他模块系统的开发者所不熟悉的能力，可以进一步提高软件的模块化。这在更具体的意义上意味着什么？
- en: Before we come to that, it’s important to note that not all of the module system’s
    goals are equally important to all kinds of projects. Many predominantly benefit
    large, long-lived projects like the JDK, for which the JPMS was primarily developed.
    Most of the goals won’t have a huge impact on day-to-day coding, unlike, for example,
    lambda expressions in Java 8 or `var` in Java 10\. They will, however, change
    the way projects are developed and deployed—something we all do on a daily basis
    (right?).
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在我们到来之前，重要的是要注意，模块系统的所有目标对各种项目来说并不同等重要。许多主要受益于像JDK这样的大型、长期项目，JPMS主要是为这些项目开发的。大多数目标不会对日常编码产生巨大影响，例如，Java
    8中的lambda表达式或Java 10中的`var`。然而，它们将改变项目开发和部署的方式——这是我们每天都在做的事情（对吗？）。
- en: 'Among the module system’s goals, two stand out as particularly important: reliable
    configuration and strong encapsulation. We’ll look at them more closely than the
    others.'
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在模块系统的目标中，有两个特别重要：可靠配置和强封装。我们将比其他目标更详细地研究它们。
- en: '1.6.1 RELIABLE CONFIGURATION: LEAVING NO JAR BEHIND'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.6.1 可靠配置：不留任何JAR文件
- en: As you saw in section 1.4.3 when observing the module system in action, individual
    modules declare their dependencies on other modules and the JPMS analyzes these
    dependencies. Although we only looked at a JVM launch, the same mechanism is at
    play at compile time and link time (yep, that’s new; see chapter 14). These operations
    can thus fail fast when dependencies are missing or conflicting. The fact that
    dependencies can be found missing at launch time, as opposed to only when the
    first class is needed, is a big win.
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如你在1.4.3节中观察模块系统运行时所见，各个模块声明它们对其他模块的依赖，JPMS分析这些依赖。尽管我们只看了JVM启动，但相同的机制在编译时间和链接时间（是的，这是新的；见第14章）也在发挥作用。因此，当依赖项缺失或冲突时，这些操作可以快速失败。与只有当第一个类需要时才在启动时发现依赖项缺失的事实相比，这是一个很大的优势。
- en: Before Java 9, JARs with the same classes weren’t identified as being in conflict.
    Instead, the runtime would choose an arbitrary class, thus shadowing the others,
    which led to the complications described in section 1.3.2\. Starting with Java
    9, the compiler and JVM recognize this and many other ambiguities that can lead
    to problems early on.
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Java 9之前，具有相同类的JAR文件不会被识别为冲突。相反，运行时会选择一个任意的类，从而覆盖其他类，这导致了1.3.2节中描述的复杂性。从Java
    9开始，编译器和JVM识别这一点以及许多其他可能导致早期问题的歧义。
- en: 'Definition: Reliable configuration'
  id: totrans-252
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：可靠配置
- en: Together, this makes a system’s configuration more reliable than it used to
    be, because only well-formed launch configurations will pass these tests. If they
    do, the JVM can turn the conceptual dependency graph into a module graph, which
    replaces the ball of mud with a structured view of the running system, much like
    we may have it.
  id: totrans-253
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 两者结合，使得系统的配置比以前更加可靠，因为只有良好形成的启动配置才能通过这些测试。如果它们通过了，JVM可以将概念依赖图转换为模块图，用运行系统的结构化视图替换泥球，就像我们可能拥有的那样。
- en: '1.6.2 STRONG ENCAPSULATION: MAKING MODULE-INTERNAL CODE INACCESSIBLE'
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.6.2 强封装：使模块内部代码不可访问
- en: Another key goal of the module system is to enable modules to strongly encapsulate
    their internals and export only specific functionality.
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统的另一个关键目标是使模块能够强封装其内部结构，并仅导出特定的功能。
- en: A class that is private to a module should be private in exactly the same way
    that a private field is private to a class. In other words, module boundaries
    should determine not just the visibility of classes and interfaces but also their
    accessibility.
  id: totrans-256
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个对模块私有的类应该以与私有字段对类私有的相同方式私有。换句话说，模块边界应该不仅决定类和接口的可见性，还决定它们的可访问性。
- en: '—Mark Reinhold, “Project Jigsaw: Bringing the Big Picture into Focus” ([https://mreinhold.org/blog/jigsaw-focus](https://mreinhold.org/blog/jigsaw-focus))'
  id: totrans-257
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——马克·雷诺尔德，《Jigsaw项目：聚焦大局》([https://mreinhold.org/blog/jigsaw-focus](https://mreinhold.org/blog/jigsaw-focus))
- en: 'To achieve this goal, both compiler and JVM enforce strict accessibility rules
    across module boundaries: only access to public members (meaning fields and methods)
    of public types in exported packages is allowed. Other types aren’t accessible
    to code outside the module—not even via reflection. Finally we can strongly encapsulate
    libraries’ internals and be sure applications don’t accidentally depend on implementation
    details.'
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了实现这一目标，编译器和JVM在模块边界上强制执行严格的访问规则：仅允许访问导出包中公共类型（即字段和方法）的公共成员。其他类型对模块外部的代码不可访问——甚至不能通过反射访问。最后，我们可以强封装库的内部实现，并确保应用程序不会意外地依赖于实现细节。
- en: 'This also applies to the JDK, which, as described in the previous section,
    was turned into modules. As a consequence, the module system prevents access to
    JDK-internal APIs, meaning packages starting with `sun.` or `com.sun.`. Unfortunately,
    many widely used frameworks and libraries like Spring, Hibernate, and Mockito
    use such internal APIs, so many applications would break on Java 9 if the module
    system were that strict. To give developers time to migrate, Java is more lenient:
    the compiler and JVM have command-line switches that allow access to internal
    APIs; and, on Java 9 to 11, runtime access is allowed by default (more on that
    in section 7.1).'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这也适用于JDK，如前所述，它已被转换为模块。因此，模块系统阻止了对JDK内部API的访问，这意味着以`sun.`或`com.sun.`开头的包。不幸的是，许多广泛使用的框架和库，如Spring、Hibernate和Mockito，都使用了这样的内部API，因此如果模块系统如此严格，许多应用程序在Java
    9上将会崩溃。为了给开发者迁移时间，Java更加宽容：编译器和JVM有命令行开关允许访问内部API；在Java 9到11中，默认允许运行时访问（更多内容请参阅第7.1节）。
- en: 'To prevent code from accidentally depending on types in indirect dependencies,
    which may change from one run to the next, the situation is even stricter: in
    general, a module can only access types of modules that it requires as a dependency.
    (Some advanced features create deliberate exceptions to that rule.)'
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了防止代码意外地依赖于间接依赖中的类型，这些类型可能会从一个运行到下一个运行而发生变化，情况甚至更为严格：一般来说，一个模块只能访问它作为依赖项所要求的模块的类型。（一些高级特性会故意违反该规则。）
- en: 1.6.3 AUTOMATED SECURITY AND IMPROVED MAINTAINABILITY
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.6.3 自动化安全与改进的可维护性
- en: The strong encapsulation of module-internal APIs can greatly improve security
    and maintainability. It helps with security because critical code is effectively
    hidden from code that doesn’t require its use. It also makes maintenance easier,
    because a module’s public API can more easily be kept small.
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块内部API的强封装可以极大地提高安全性和可维护性。它有助于安全性，因为关键代码有效地隐藏了不需要使用它的代码。它还使维护更容易，因为模块的公共API可以更容易地保持小规模。
- en: Casual use of APIs that are internal to Java SE Platform implementations is
    both a security risk and a maintenance burden. The strong encapsulation provided
    by the proposed specification will allow components that implement the Java SE
    Platform to prevent access to their internal APIs.
  id: totrans-263
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 随意使用Java SE平台实现内部的API既是一个安全风险，也是一个维护负担。所提议的规范提供的强封装将允许实现Java SE平台组件防止对其内部API的访问。
- en: —Java Specification Request (JSR) 376
  id: totrans-264
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——Java规范请求（JSR）376
- en: 1.6.4 IMPROVED STARTUP PERFORMANCE
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.6.4 改进的启动性能
- en: With clearer bounds of where code is used, existing optimization techniques
    can be used more effectively.
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当知道一个类只能引用几个其他特定组件中的类，而不是运行时加载的任何类时，现有的优化技术可以更有效地使用。
- en: Many ahead-of-time, whole-program optimization techniques can be more effective
    when it is known that a class can refer only to classes in a few other specific
    components rather than to any class loaded at run time.
  id: totrans-267
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当知道一个类只能引用几个其他特定组件中的类，而不是运行时加载的任何类时，许多提前时间、整个程序优化技术可以更有效。
- en: —JSR 376
  id: totrans-268
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——JSR 376
- en: It’s also possible to index classes and interfaces by their annotations, so
    that such types can be found without a full class path scan. That wasn’t implemented
    in Java 9 but may come in a future release.
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还可以通过注解来索引类和接口，这样就可以在不进行完整的类路径扫描的情况下找到这些类型。这尚未在Java 9中实现，但可能会在未来的版本中实现。
- en: 1.6.5 SCALABLE JAVA PLATFORM
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.6.5 可扩展的Java平台
- en: A beautiful consequence of modules with clearly defined dependencies is that
    it’s easy to determine running subsets of the JDK. Server applications, for example,
    don’t use AWT, Swing, or JavaFX and can thus run on a JDK without that functionality.
    The new tool `jlink` (see chapter 14) makes it possible to create runtime images
    with exactly the modules an application needs. We can even include library and
    application modules, thereby creating a self-contained program that doesn’t require
    Java to be installed on the host system.
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 明确定义依赖关系的模块的一个美好后果是，可以轻松确定 JDK 的运行子集。例如，服务器应用程序不使用 AWT、Swing 或 JavaFX，因此可以在没有这些功能的情况下运行
    JDK。新的工具 `jlink`（参见第 14 章）使得创建仅包含应用程序所需模块的运行时镜像成为可能。我们甚至可以包括库和应用程序模块，从而创建一个不需要在宿主系统上安装
    Java 的自包含程序。
- en: 'Definition: Scalable platform'
  id: totrans-272
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：可扩展平台
- en: With the JDK being modularized, we can cherry-pick the functionality we need
    and create JREs consisting of only the required modules.
  id: totrans-273
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于 JDK 已经模块化，我们可以挑选所需的特性并创建仅包含所需模块的 JRE。
- en: This will maintain Java’s position as a key player for small devices as well
    as for containers.
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这将保持 Java 在小型设备和容器中的关键玩家地位。
- en: 1.6.6 NON-GOALS
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.6.6 非目标
- en: Unfortunately, the module system is no panacea, and a couple of interesting
    use cases aren’t covered. First, the JPMS has no concept of versions. You can’t
    give a module a version or require versions for dependencies. That said, it’s
    possible to embed such information in the module descriptor and access it using
    the reflection API, but that’s just metainformation for developers and tools—the
    module system doesn’t process it.
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不幸的是，模块系统并非万能的灵丹妙药，一些有趣的用例并未得到覆盖。首先，JPMS 没有版本的概念。你不能给模块指定版本或要求依赖项的版本。话虽如此，将此类信息嵌入模块描述符并使用反射
    API 访问它是可能的，但这只是为开发人员和工具提供的元信息——模块系统不会处理它。
- en: That the JPMS doesn’t “see” versions also means it won’t distinguish two different
    versions of the same module. On the contrary, and in line with the goal of reliable
    configuration, it will perceive this situation as a classic ambiguity—the same
    module present twice—and refuse to compile or launch. For more on module versions,
    see chapter 13.
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JPMS 不“看到”版本也意味着它不会区分同一模块的两个不同版本。相反，并且与可靠配置的目标一致，它将这种情况视为经典的歧义——同一模块出现两次——并拒绝编译或启动。有关模块版本的信息，请参阅第
    13 章。
- en: The JPMS offers no mechanism to search for or download existing modules from
    a centralized repository or to publish new ones. This task is sufficiently covered
    by existing build tools.
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JPMS 没有提供从集中式仓库搜索或下载现有模块或发布新模块的机制。这项任务已经足够由现有的构建工具来覆盖。
- en: 'It’s also not the goal of the JPMS to model a dynamic module graph, where individual
    artifacts can show up or disappear at run time. It’s possible, though, to implement
    such a system on top of one of the advanced features: layers (see section 12.4).'
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JPMS 的目标也不是模拟一个动态模块图，其中单个工件可以在运行时出现或消失。然而，在高级特性之上（参见第 12.4 节），可以实施这样的系统。
- en: 1.7 Skills, old and new
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.7 新旧技能
- en: I’ve described a lot of promises, and the rest of the book explains how the
    Java Platform Module System aims to achieve them. But make no mistake, these benefits
    aren’t free! To build applications on top of the module system, you’ll have to
    think harder than before about artifacts and dependencies, and commit more of
    those thoughts to code. Certain things that used to work will stop doing so on
    Java 9, and using certain frameworks will require a little more effort than before.
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我描述了许多承诺，本书的其余部分解释了 Java 平台模块系统如何旨在实现这些承诺。但不要误解，这些好处并非免费！要在模块系统之上构建应用程序，你将不得不比以前更深入地思考工件和依赖关系，并将更多的这些想法编码到代码中。某些在
    Java 9 中曾经有效的东西将不再有效，使用某些框架将需要比以前更多的努力。
- en: You can view this as similar to how a statically and strongly typed language
    requires more work than a dynamic one—at least, while the code is being written.
    All those types and generics—can’t you just use `Object` and casts everywhere?
    Sure, you could, but would you be willing to give up the safety the type system
    provides, just to save some brain cycles while writing code? I don’t think so.
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以将这看作与静态强类型语言相比，动态语言在编写代码时需要更多的工作——至少在编写代码的时候是这样。所有那些类型和泛型——难道你就不想到处使用 `Object`
    和类型转换吗？当然，你可以这样做，但你愿意为了在编写代码时节省一些脑力而放弃类型系统提供的安全性吗？我不这么认为。
- en: 1.7.1 WHAT YOU’LL LEARN
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.7.1 你将学到什么
- en: New skills are required! Luckily, this book teaches them. When all is said and
    done, and you’ve mastered the mechanisms laid out in the following chapters, neither
    new nor existing applications will defy you.
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 新技能是必需的！幸运的是，这本书教授了这些技能。当一切都说完，你已经掌握了以下章节中阐述的机制时，无论是新应用还是现有应用都不会让你感到困难。
- en: Part 1, particularly chapters 3–5, goes through the basics of the module system.
    In addition to practical skills, they teach underlying mechanisms to give you
    deeper understanding. Afterward, you’ll be able to describe modules and their
    relationships by encapsulating a module’s internals and expressing its dependencies.
    With `javac`, `jar`, and `java`, you’ll compile, package, and run modules and
    the applications they form.
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第一部分，特别是第3章到第5章，介绍了模块系统的基础。除了实用技能外，它们还教授了底层机制，以帮助你更深入地理解。之后，你将能够通过封装模块的内部结构和表达其依赖关系来描述模块及其关系。使用`javac`、`jar`和`java`，你可以编译、打包和运行模块以及它们形成的应用程序。
- en: Part 2 of the book builds on the basics and extends them to cover more complex
    use cases. For existing applications, you’ll be able to analyze possible incompatibilities
    with Java 9 to 11 and create a migration path to the module system using the various
    features it offers for that purpose. Toward that end, and also to implement less
    straightforward module relationships, you can use advanced features like qualified
    exports, open modules, and services as well as the extended reflection API. With
    `jlink`, you’ll create pared-down JREs, optimized for a particular use case, or
    self-contained application images that ship with their own JREs. Finally, you’ll
    see the bigger picture, including how the module system interacts with class loading,
    reflection, and containers.
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 书的第二部分基于基础知识，并将其扩展到涵盖更复杂的使用案例。对于现有应用，你将能够分析与Java 9到11可能存在的兼容性问题，并使用它提供的各种功能创建迁移路径到模块系统。为此，以及实现不那么直接的模块关系，你可以使用高级功能，如限定导出、开放模块和服务以及扩展的反射API。使用`jlink`，你可以创建针对特定用例优化的精简JRE，或者带有自己的JRE的自包含应用程序镜像。最后，你将看到更大的图景，包括模块系统如何与类加载、反射和容器交互。
- en: 1.7.2 WHAT YOU SHOULD KNOW
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.7.2 你应该知道的内容
- en: The JPMS has an interesting character when it comes to skill requirements. Most
    of what it does is brand-new and comes with its own syntax partitioned off in
    the module declaration. Learning that is relatively easy, if you have basic Java
    skills. So if you know that code is organized in types, packages, and ultimately
    JARs; how visibility modifiers, particularly `public`, work across them; and what
    `javac`, `jar`, and `java` do, and have a rough idea of how to use them, then
    you have all it takes to understand part 1 as well as many of the more advanced
    features introduced in part 3.
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当谈到技能要求时，JPMS有一个有趣的特性。它所做的许多事情都是全新的，并且在其模块声明中带有自己的语法分区。如果你有基本的Java技能，学习这一点相对容易。所以如果你知道代码是按类型、包和最终JAR组织；可见性修饰符，尤其是`public`，是如何跨越它们的；以及`javac`、`jar`和`java`的作用，并且对如何使用它们有一个大致的了解，那么你就具备了理解第一部分以及第三部分中介绍的大多数更高级特性的所有知识。
- en: 'But to really understand the problems the module system addresses and to appreciate
    the solutions it proposes requires more than that. Familiarity with the following
    and experience working with large applications make it easier to understand the
    motivation for the module system’s features and their benefits and shortcomings:'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但要真正理解模块系统解决的问题以及欣赏它提出的解决方案，需要的不仅仅是这些。熟悉以下内容以及与大型应用工作的经验，使你更容易理解模块系统特性的动机及其优点和缺点：
- en: How the JVM, and particularly the class loader, operates
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM以及尤其是类加载器是如何运行的
- en: The trouble that mechanism causes (think JAR hell)
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机制带来的麻烦（想想JAR地狱）
- en: More advanced Java APIs like the service loader and reflection API
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高级的Java API，如服务加载器和反射API
- en: Build tools like Maven and Gradle and how they build a project
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建工具如Maven和Gradle以及它们如何构建项目
- en: How to modularize software systems
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何模块化软件系统
- en: But however knowledgeable you are, you may encounter references or explanations
    that don’t connect with something you know. For an ecosystem as gigantic as Java’s,
    that’s natural, and everybody learns something new wherever they turn (believe
    me, I know that first hand). So, never despair! If some fluff doesn’t help, chances
    are you can understand the technicalities purely by looking at the code.
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但无论你多么博学，你可能会遇到一些参考资料或解释，它们与你所知的内容不相关。对于一个像Java这样庞大的生态系统来说，这是很自然的，每个人在转角处都会学到新的东西（相信我，我亲身体验过）。所以，永远不要绝望！如果一些无关紧要的内容没有帮助，那么你很可能仅通过查看代码就能理解技术细节。
- en: With the background colored in, it’s time to get your hands dirty and learn
    the JPMS basics. I recommend you continue with chapter 2, which cuts across the
    rest of part 1 and shows code that defines, builds, and runs modular JARs. It
    also introduces the demo application that appears throughout the rest of the book.
    If you prefer learning the underlying theory first, you can skip to chapter 3,
    which teaches the module system’s fundamental mechanisms. If you’re driven by
    worry about your project’s compatibility with Java 9, chapters 6 and 7 cover that
    in detail, but those chapters will be hard to understand without a good grasp
    of the basics.
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在背景着色完成后，是时候动手学习 JPMS 基础知识了。我建议你继续阅读第 2 章，这一章贯穿了第 1 部分的其余内容，展示了定义、构建和运行模块化 JAR
    的代码。它还介绍了本书其余部分出现的演示应用程序。如果你更愿意先学习底层理论，可以跳到第 3 章，该章节教授模块系统的基本机制。如果你担心你的项目与 Java
    9 的兼容性，第 6 章和第 7 章详细介绍了这一点，但如果没有很好地掌握基础知识，这些章节将难以理解。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: A software system can be visualized as a graph, which often shows (un)desired
    properties of the system.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个软件系统可以被看作是一个图，它通常显示了系统的（不）期望属性。
- en: On the level of JARs, Java used to have no understanding of that graph. This
    led to various problems, among them JAR hell, manual security, and poor maintainability.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JAR级别，Java过去对那个图没有任何理解。这导致了各种问题，其中包括JAR地狱、手动安全性和维护性差。
- en: The Java Platform Module System exists to make Java understand the JAR graph,
    which brings artifact-level modularity to the language. The most important goals
    are reliable configuration and strong encapsulation as well as improved security,
    maintainability, and performance.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java平台模块系统旨在使Java理解JAR图，这为语言带来了工件级别的模块化。最重要的目标包括可靠的配置、强大的封装以及改进的安全性、可维护性和性能。
- en: 'This is achieved by introducing modules: basically, JARs with an additional
    descriptor. The compiler and runtime interpret the described information in order
    to build the graph of artifact dependencies and provide the promised benefits.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是通过引入模块实现的：基本上，是带有额外描述符的 JAR 文件。编译器和运行时将解释描述的信息，以便构建工件依赖关系图并提供承诺的好处。
- en: '2'
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '2'
- en: Anatomy of a modular application
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块化应用程序的结构
- en: This chapter covers
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Laying out a modular application’s source code
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局模块化应用程序的源代码
- en: Creating module declarations
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模块声明
- en: Compiling modules
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译模块
- en: Running a modular application
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行模块化应用程序
- en: This chapter introduces you to the overall workflow of creating modular applications,
    but it doesn’t explain these topics in all detail. Chapters 3, 4, and 5 do that—they
    explore these subjects in depth. But with a topic as encompassing as the module
    system, it can be easy to miss the forest for the trees. That’s why this chapter
    shows you the big picture. It gives you an impression of how the different pieces
    of the puzzle fit together by presenting a simple modular application, how its
    modules are defined and compiled, and how the application is executed.
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章向您介绍了创建模块化应用程序的整体工作流程，但它并没有对这些主题进行详细解释。第3章、第4章和第5章会详细解释这些主题——它们深入探讨了这些主题。但是，对于像模块系统这样包罗万象的主题，很容易只见树木不见森林。这就是为什么本章向您展示了整体图景。它通过展示一个简单的模块化应用程序，如何定义和编译其模块，以及应用程序是如何执行的，给您一个不同部分如何拼凑在一起的印象。
- en: 'That means I make you jump into the deep end: not everything that follows may
    be immediately obvious. But don’t worry if something’s unclear—it will be thoroughly
    explained soon. When you’re done with part 1 of this book, everything in the example
    will make perfect sense. So dog-ear these pages, because you may want to refer
    back to them.'
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这意味着我会让你跳入深水区：接下来的内容可能并不立即明了。但如果你对某些内容感到困惑，请不要担心——它们很快就会被详细解释。当你完成这本书的第一部分后，示例中的所有内容都会变得完全清晰。所以，请折起这些页面，因为你可能需要回头查阅它们。
- en: Section 2.1 explains what the hypothetical application does, what types it consists
    of, and what their responsibilities are. The module system comes into play in
    section 2.2, which discusses how to organize the files and folders, describe the
    modules, and compile and run the application. That brief encounter will demonstrate
    many of the module system’s core mechanisms as well as some instances where basic
    features don’t suffice to modularize a complex application—topics that section
    2.3 discusses. You can find the application online at [www.manning.com/books/the-java-module-system](http://www.manning.com/books/the-java-module-system)
    and [https://github.com/CodeFX-org/demo-jpms-monitor](https://github.com/CodeFX-org/demo-jpms-monitor).
    The master branch contains the variant described in section 2.2.
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.1节解释了假设的应用程序做什么，它由哪些类型组成，以及它们的职责。模块系统在2.2节中发挥作用，讨论了如何组织文件和文件夹，描述模块，以及编译和运行应用程序。这次简短的接触将展示模块系统的许多核心机制，以及一些基本功能不足以模块化复杂应用程序的实例——这些内容将在2.3节中讨论。您可以在[www.manning.com/books/the-java-module-system](http://www.manning.com/books/the-java-module-system)和[https://github.com/CodeFX-org/demo-jpms-monitor](https://github.com/CodeFX-org/demo-jpms-monitor)上找到应用程序。主分支包含2.2节中描述的变体。
- en: 2.1 Introducing ServiceMonitor
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.1 介绍ServiceMonitor
- en: To see the module system in action, you need an example project you can apply
    it to. It isn’t terribly important exactly what the project does, so don’t fret
    over its details.
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要看到模块系统在行动中的样子，你需要一个可以应用它的示例项目。项目具体做什么并不十分重要，所以不必担心它的细节。
- en: Let’s imagine a network of services that cooperate to delight users—maybe a
    social network or a video platform. You want to monitor those services to determine
    how healthy the system is and spot problems when they occur (instead of when customers
    report them). This is where the example application comes in.
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们想象一个由服务组成的网络，这些服务相互协作以取悦用户——可能是一个社交网络或视频平台。您希望监控这些服务以确定系统的健康状况，并在问题发生时及时发现（而不是在客户报告时）。这正是示例应用的作用所在。
- en: The example application is called ServiceMonitor. It contacts individual services,
    collects and aggregates diagnostic data, and makes that data available via REST.
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 示例应用程序被称为ServiceMonitor。它联系单个服务，收集和汇总诊断数据，并通过REST提供这些数据。
- en: NOTE You might recall the application from section 1.2 or [figure 1.10](part0014.html#filepos188123),
    where it’s split into four different JARs. We’ll eventually come to an even more
    detailed modularization, but that’s for section 2.2 to explore. Before doing that,
    let’s think about how you’d implement such a system in a single artifact (let’s
    call that the monolithic approach). Never mind if it doesn’t line up 100% with
    chapter 1—new chapter, new details.
  id: totrans-316
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：您可能还记得1.2节或[图1.10](part0014.html#filepos188123)中的应用程序，当时它被分割成四个不同的JAR文件。我们最终会达到更详细的模块化，但这将在2.2节中探讨。在那样做之前，让我们思考一下如何在单个工件（让我们称其为单体方法）中实现这样一个系统。如果它与第1章的内容不完全一致，请不要在意——新章节，新细节。
- en: As luck would have it, the services already collect the data you want, so all
    ServiceMonitor needs to do is query them periodically. This is the job of the
    `ServiceObserver` implementations. Once you have the diagnostic data in the form
    of `DiagnosticDataPoint`, it can be fed to `Statistician`, which aggregates it
    to `Statistics`. The statistics, in turn, are stored in `StatisticsRepository`
    as well as made available via REST. The `Monitor` class ties everything together.
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 恰好，这些服务已经收集了你想要的数据，所以ServiceMonitor需要做的只是定期查询它们。这是`ServiceObserver`实现的工作。一旦你有了以`DiagnosticDataPoint`形式存在的诊断数据，它就可以被喂给`Statistician`，将其汇总为`Statistics`。这些统计数据随后被存储在`StatisticsRepository`中，并通过REST提供。`Monitor`类将一切联系在一起。
- en: '[Figure 2.1](part0015.html#filepos262836) shows how these types relate to each
    other. To get a better feeling for how this works, let’s look at the code, starting
    with the `ServiceObserver` interface.'
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图2.1](part0015.html#filepos262836)展示了这些类型之间的关系。为了更好地理解这是如何工作的，让我们看看代码，从`ServiceObserver`接口开始。'
- en: Listing 2.1 `ServiceObserver` interface
  id: totrans-319
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表2.1 `ServiceObserver`接口
- en: '`public interface ServiceObserver {  DiagnosticDataPoint gatherDataFromService();  }`'
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public interface ServiceObserver {  DiagnosticDataPoint gatherDataFromService();  }`'
- en: '![](../images/00095.jpeg)'
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00095.jpeg)'
- en: '[Figure 2.1](part0015.html#filepos261687) The classes making up the ServiceMonitor
    application. Two `ServiceObserver` implementations query services with Alpha and
    Beta APIs and return diagnostic data, which `Statistician` aggregates into `Statistics`.
    The statistics are stored and loaded by a repository as well as exposed via a
    REST API. `Monitor` orchestrates all this.'
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 2.1](part0015.html#filepos261687) 构成 ServiceMonitor 应用程序的类。两个 `ServiceObserver`
    实现使用 Alpha 和 Beta API 查询服务并返回诊断数据，这些数据由 `Statistician` 聚合到 `Statistics` 中。统计数据由存储库存储和加载，并通过
    REST API 公开。`Monitor` 协调所有这些。'
- en: 'Looks simple enough, but unfortunately, not all services expose the same REST
    API. Two generations are in use: Alpha and Beta. That’s why `ServiceObserver`
    is an interface with two implementations (see [figure 2.2](part0015.html#filepos265074)):
    each implementation connects to a different API generation and makes sure to expose
    the data to your application via the same interface.'
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 看起来很简单，但不幸的是，并非所有服务都公开相同的 REST API。目前使用了两代：Alpha 和 Beta。这就是为什么 `ServiceObserver`
    是一个具有两个实现的接口（参见 [图 2.2](part0015.html#filepos265074)）：每个实现连接到不同的 API 代，并确保通过相同的接口将数据公开给应用程序。
- en: '![](../images/00030.jpeg)'
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00030.jpeg)'
- en: '[Figure 2.2](part0015.html#filepos264625) The observed services use two different
    API generations to expose the diagnostic data. Accordingly, the `ServiceObserver`
    interface has two implementations.'
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 2.2](part0015.html#filepos264625) 被观察的服务使用两种不同的 API 代来公开诊断数据。相应地，`ServiceObserver`
    接口有两个实现。'
- en: '`Statistician` has no state of its own—it just offers two methods that either
    create a new `Statistics` instance or combine existing statistics and new data
    points into updated statistics.'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Statistician` 没有自己独立的状态——它只提供两种方法，要么创建一个新的 `Statistics` 实例，要么将现有的统计数据和新数据点组合成更新的统计数据。'
- en: Listing 2.2 `Statistician` class
  id: totrans-327
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 2.2 `Statistician` 类
- en: '`public class Statistician {  public Statistics emptyStatistics() { return
    Statistics.empty(); }  public Statistics compute( Statistics currentStats, Iterable<DiagnosticDataPoint>
    dataPoints) { Statistics finalStats = currentStats; for (DiagnosticDataPoint dataPoint
    : dataPoints) finalStats = finalStats.merge(dataPoint); return finalStats; }  }`'
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public class Statistician {  public Statistics emptyStatistics() { return
    Statistics.empty(); }  public Statistics compute( Statistics currentStats, Iterable<DiagnosticDataPoint>
    dataPoints) { Statistics finalStats = currentStats; for (DiagnosticDataPoint dataPoint
    : dataPoints) finalStats = finalStats.merge(dataPoint); return finalStats; }  }`'
- en: '`StatisticsRepository` doesn’t do anything fancy—it loads and stores statistics.
    Whether that’s done via serialization, JSON files, or a backing database is irrelevant
    for this example.'
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`StatisticsRepository` 没有做什么特别的事情——它只加载和存储统计数据。无论是通过序列化、JSON 文件还是后端数据库来完成，对于这个例子来说都是无关紧要的。'
- en: Listing 2.3 `StatisticsRepository` class
  id: totrans-330
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 2.3 `StatisticsRepository` 类
- en: '`public class StatisticsRepository {  public Optional<Statistics> load() {
    /* ... */ }  public void store(Statistics statistics) { /* ... */ }  }`'
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public class StatisticsRepository {  public Optional<Statistics> load() {
    /* ... */ }  public void store(Statistics statistics) { /* ... */ }  }`'
- en: This leaves you with a type that collects data points, another that converts
    them to statistics, and a third that stores stats. What’s missing is a class that
    binds them together by regularly polling data and pushing it through the statistician
    into the repository. That’s what `Monitor` is there for. The following listing
    shows its fields and the `updateStatistics()` method, which implements its core
    responsibility. (The code that makes sure the task is run regularly is omitted.)
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这使得你拥有一个收集数据点的类型，另一个将它们转换为统计数据的类型，以及一个存储统计数据的类型。所缺少的是一个通过定期轮询数据并将其推送到统计学家再推送到存储库来将它们联系在一起的类型。这就是
    `Monitor` 的作用所在。以下列表展示了其字段和 `updateStatistics()` 方法，该方法实现了其核心职责。（确保任务定期运行的代码被省略。）
- en: Listing 2.4 `Monitor` class and its `updateStatistics()` method
  id: totrans-333
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 2.4 `Monitor` 类及其 `updateStatistics()` 方法
- en: '`public class Monitor {  private final List<ServiceObserver> serviceObservers;
    private final Statistician statistician; private final StatisticsRepository repository;
    private Statistics currentStatistics; // [...]  private void updateStatistics()
    { List<DiagnosticDataPoint> newData = serviceObservers .stream() .map(ServiceObserver::gatherDataFromService)
    .collect(toList()); Statistics newStatistics = statistician .compute(currentStatistics,
    newData); currentStatistics = newStatistics; repository.store(newStatistics);
    }  // [...] }`'
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public class Monitor {  private final List<ServiceObserver> serviceObservers;
    private final Statistician statistician; private final StatisticsRepository repository;
    private Statistics currentStatistics; // [...]  private void updateStatistics()
    { List<DiagnosticDataPoint> newData = serviceObservers .stream() .map(ServiceObserver::gatherDataFromService)
    .collect(toList()); Statistics newStatistics = statistician .compute(currentStatistics,
    newData); currentStatistics = newStatistics; repository.store(newStatistics);
    }  // [...] }`'
- en: '`Monitor` stores the most recent statistics in a `currentStatistics` field
    (of type `Statistics`).'
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Monitor`将最新的统计数据存储在`currentStatistics`字段（类型为`Statistics`）中。'
- en: Upon requests, `MonitorServer`, which exposes the REST API, asks the monitor
    to provide the statistical data—either from memory or from persistence—and then
    extracts the requested bits and returns them.
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在请求时，公开REST API的`MonitorServer`会要求监控器提供统计数据——无论是从内存中还是从持久化中——然后提取请求的部分并返回它们。
- en: Listing 2.5 `MonitorServer` class
  id: totrans-337
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表2.5 `MonitorServer`类
- en: '`public class MonitorServer {  private final Supplier<Statistics> statistics;  public
    MonitorServer(Supplier<Statistics> statistics) { this.statistics = statistics;
    }  // [...]  private Statistics getStatistics() { return statistics.get(); }  //
    [...]  }`'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public class MonitorServer {  private final Supplier<Statistics> statistics;  public
    MonitorServer(Supplier<Statistics> statistics) { this.statistics = statistics;
    }  // [...]  private Statistics getStatistics() { return statistics.get(); }  //
    [...]  }`'
- en: 'An interesting detail to note is that although `MonitorServer` calls `Monitor`,
    it doesn’t depend on it. That’s because `MonitorServer` doesn’t get a reference
    to a monitor but rather a supplier for the data that forwards calls to the monitor.
    The reason is pretty simple: `Monitor` orchestrates the entire application, which
    makes it a class with a lot going on inside. I didn’t want to couple the REST
    API to such a heavyweight object just to call a single getter. Before Java 8,
    I might have created a dedicated interface to get the statistics and make `Monitor`
    implement it; but since Java 8, lambda expressions and the existing functional
    interfaces make ad hoc decoupling much easier.'
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个值得注意的细节是，尽管`MonitorServer`调用了`Monitor`，但它并不依赖于它。这是因为`MonitorServer`没有获取到监控器的引用，而是获取到一个数据提供者，该提供者将调用转发给监控器。原因很简单：`Monitor`协调整个应用程序，这使得它成为一个内部有很多操作的类。我不想仅仅为了调用一个getter而将REST
    API与这样一个重量级的对象耦合起来。在Java 8之前，我可能会创建一个专门的接口来获取统计数据并让`Monitor`实现它；但自从Java 8以来，lambda表达式和现有的函数式接口使得临时解耦变得更加容易。
- en: 'All in all, you end up with these types:'
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总的来说，你最终会得到这些类型：
- en: '`DiagnosticDataPoint`—Availability data for a service in a time interval.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DiagnosticDataPoint`—在时间间隔内服务的可用性数据。'
- en: '`ServiceObserver`—Interface for service observation that returns `DiagnosticDataPoint.`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceObserver`—服务观察的接口，返回`DiagnosticDataPoint`。'
- en: '`AlphaServiceObserver` and `BetaServiceObserver`—Each observes a variant of
    services.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlphaServiceObserver`和`BetaServiceObserver`—每个都观察服务的不同变体。'
- en: '`Statistician`—Computes statistics from `DiagnosticDataPoint.`'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Statistician`—从`DiagnosticDataPoint`计算统计数据。'
- en: '`Statistics`—Holds the computed statistics.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Statistics`—保存计算出的统计数据。'
- en: '`StatisticsRepository`—Stores and retrieves statistics.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StatisticsRepository`—存储和检索统计数据。'
- en: '`MonitorServer`—Answers REST calls for the statistics.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MonitorServer`—响应统计数据的REST调用。'
- en: '`Monitor`—Ties everything together.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Monitor`将所有内容串联起来。'
- en: 2.2 Modularizing ServiceMonitor
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.2 服务监控器的模块化
- en: If you were to implement the ServiceMonitor application as it was just described
    as a real-life project, bringing the module system into play with full force would
    be like using a sledgehammer to crack a nut. But it’s just an example, and it’s
    here to show you a modularized project’s anatomy, so you’ll structure it as if
    it were a much larger project.
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你要将服务监控器应用程序按照前面描述的那样作为一个真实的项目来实现，那么充分利用模块系统就像是用大锤砸核桃一样。但这是一个例子，它在这里是为了展示模块化项目的结构，所以你会像处理一个更大的项目一样来构建它。
- en: 'Talking about structure, let’s start by cutting the application into modules
    before discussing how the source code is laid out on the filesystem. Then come
    the most interesting steps: how to declare and compile the modules and run the
    application.'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 谈到结构，我们先从将应用程序切割成模块开始，然后再讨论源代码如何在文件系统中布局。接下来是最有趣的步骤：如何声明和编译模块以及运行应用程序。
- en: 2.3 Cutting ServiceMonitor into modules
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.3 将ServiceMonitor分割成模块
- en: 'The most common way to modularize applications is by a separation of concerns.
    ServiceMonitor has the following, with the related types in parentheses:'
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将应用程序模块化的最常见方式是通过关注点的分离。ServiceMonitor具有以下内容，相关类型在括号中给出：
- en: Collecting data from services (`ServiceObserver`, `DiagnosticDataPoint`)
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务中收集数据（`ServiceObserver`, `DiagnosticDataPoint`）
- en: Aggregating data into statistics (`Statistician`, `Statistics`)
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据聚合到统计信息中（`Statistician`, `Statistics`）
- en: Persisting statistics (`StatisticsRepository`)
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化统计信息（`StatisticsRepository`）
- en: Exposing statistics via a REST API (`MonitorServer`)
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过REST API（`MonitorServer`）公开统计信息
- en: 'But not only the domain logic generates requirements. There are also technical
    ones:'
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但不仅领域逻辑生成需求。还有技术性的需求：
- en: Data collection must be hidden behind an API.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据收集必须隐藏在API之后。
- en: The Alpha and Beta services each require a separate implementation of that API
    (`AlphaServiceObserver` and `BetaServiceObserver`).
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alpha和Beta服务各自需要该API的单独实现（`AlphaServiceObserver`和`BetaServiceObserver`）。
- en: All concerns must be orchestrated (`Monitor`).
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有关注点都必须由（`Monitor`）进行协调。
- en: 'ESSENTIAL INFO This results in the following modules with the mentioned publicly
    visible types:'
  id: totrans-362
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 这导致了以下具有所述公开可见类型的模块：'
- en: monitor.observer (`ServiceObserver`, `DiagnosticDataPoint`)
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: monitor.observer (`ServiceObserver`, `DiagnosticDataPoint`)
- en: monitor.observer.alpha (`AlphaServiceObserver`)
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: monitor.observer.alpha (`AlphaServiceObserver`)
- en: monitor.observer.beta (`BetaServiceObserver`)
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: monitor.observer.beta (`BetaServiceObserver`)
- en: monitor.statistics (`Statistician`, `Statistics`)
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: monitor.statistics (`Statistician`, `Statistics`)
- en: monitor.persistence (`StatisticsRepository`)
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: monitor.persistence (`StatisticsRepository`)
- en: monitor.rest (`MonitorServer`) * monitor (`Monitor`)
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: monitor.rest (`MonitorServer`) * monitor (`Monitor`)
- en: Superimposing these modules over the class diagram in [figure 2.3](part0015.html#filepos280835),
    it’s easy to see the module dependencies emerge.
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将这些模块叠加到[图2.3](part0015.html#filepos280835)中的类图上，很容易看到模块依赖出现。
- en: '![](../images/00045.jpeg)'
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00045.jpeg)'
- en: '[Figure 2.3](part0015.html#filepos280466) The ServiceMonitor application’s
    modules (bold) overlaying the class structure (regular). Note how class dependencies
    across module boundaries determine module dependencies.'
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图2.3](part0015.html#filepos280466) 服务监控应用程序的模块（粗体）覆盖在类结构（常规）之上。注意模块边界之间的类依赖如何确定模块依赖。'
- en: 2.4 Laying out files in a directory structure
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.4 在目录结构中布局文件
- en: '[Figure 2.4](part0015.html#filepos282314) shows the application’s directory
    structure. Each module will be its own project, which means each can have an individual
    directory structure. There’s no reason to complicate things, though, so you’ll
    use the same structure for all. If you’ve been involved in different projects
    or have been using Maven, Gradle, or other build tools, you’ll recognize this
    as the default one.'
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图2.4](part0015.html#filepos282314)显示了应用程序的目录结构。每个模块都将是一个独立的项目，这意味着每个都可以有自己的目录结构。但是，没有必要使事情复杂化，所以你会使用相同的结构。如果你参与过不同的项目或者使用过Maven、Gradle或其他构建工具，你会认出这是默认的结构。'
- en: '![](../images/00097.jpeg)'
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00097.jpeg)'
- en: '[Figure 2.4](part0015.html#filepos281586) Each module of the ServiceMonitor
    application is its own project with the well-known directory structure. New are
    the `mods` folder, which collects the modular JARs once they’re built, and the
    module declarations `module-info.java` file in each project’s root source directory.'
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图2.4](part0015.html#filepos281586) ServiceMonitor应用程序的每个模块都是其自己的项目，具有众所周知的目录结构。新的是`mods`文件夹，它收集构建后的模块JAR文件，以及每个项目的根源目录中的模块声明`module-info.java`文件。'
- en: The first thing to note is the `mods` folder. Later, when you’re creating modules,
    this is where they’ll end up. Section 4.1 goes into more detail about the directory
    structure.
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先要注意的是`mods`文件夹。稍后，当你创建模块时，它们将在这里结束。第4.1节将更详细地介绍目录结构。
- en: Then there’s the slightly unusual `libs` folder, which contains third-party
    dependencies. In a real-life project, you wouldn’t need it, because your build
    tool manages dependencies. But you’re going to compile and launch by hand, and
    having all dependencies in one place greatly simplifies that. So this isn’t a
    recommendation or even a requirement—it’s just a simplification.
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后是稍微不寻常的`libs`文件夹，其中包含第三方依赖项。在实际项目中，你可能不需要它，因为你的构建工具管理依赖项。但你会手动编译和启动，将所有依赖项放在一个地方可以极大地简化这个过程。所以这并不是一个推荐，甚至不是一个要求——这只是简化。
- en: The other uncommon thing is `module-info.java`. It’s called a module declaration
    and is in charge of defining a module’s properties. This puts it right at the
    center of the module system and hence this book, particularly of section 3.1\.
    Nonetheless, we’ll have a quick look at it in the following section.
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个不常见的事情是 `module-info.java`。它被称为模块声明，负责定义模块的属性。这使得它位于模块系统的中心，因此也在本书中，尤其是第3.1节。尽管如此，我们将在下一节快速浏览它。
- en: 2.5 Declaring and describing modules
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.5 声明和描述模块
- en: ESSENTIAL INFO Each module has a module declaration. By convention, this is
    a `module-info.java` file in the project’s root source folder. From this, the
    compiler creates a module descriptor, `module-info.class`. When the compiled code
    is packaged into a JAR, the descriptor must end up in the root folder for the
    module system to recognize and process it.
  id: totrans-380
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的是每个模块都有一个模块声明。按照惯例，这是一个位于项目根源文件夹中的 `module-info.java` 文件。编译器会从这个文件创建一个模块描述符，`module-info.class`。当编译后的代码被打包成JAR文件时，描述符必须位于模块系统的根目录，以便模块系统能够识别和处理它。
- en: As discussed in section 2.2.1, the application consists of seven modules, so
    there must be seven module declarations. [Listing 2.6](part0015.html#filepos287533)
    shows all of them. Even without knowing any details yet, you can glimpse what’s
    going on.
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如第2.2.1节所述，应用程序由七个模块组成，因此必须有七个模块声明。[列表2.6](part0015.html#filepos287533)显示了所有这些声明。即使目前还不知道任何细节，你也能窥见正在进行的事情。
- en: 'A `module the.name { }` block defines a module. The name typically follows
    the package-naming convention: it should be globally unique by reverting a domain
    name, it’s all lowercase, and sections are separated by dots (see section 3.1.3
    for more—I use shorter names only to make them more amenable for this book). Inside
    the module block, `requires` directives express the dependencies between modules,
    and `exports` directives define each module’s public API by naming the packages
    whose public types are to be exported.'
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module the.name { }` 块定义了一个模块。名称通常遵循包命名约定：它应该通过反转域名来保证全局唯一性，全部小写，并且部分之间用点分隔（更多内容请参阅第3.1.3节——我仅使用较短的名称是为了使它们更适合本书）。在模块块内部，`requires`
    指令表达了模块之间的依赖关系，而 `exports` 指令通过命名要导出公共类型的包来定义每个模块的公共API。'
- en: Listing 2.6 Declarations for all ServiceMonitor modules
  id: totrans-383
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表2.6 所有ServiceMonitor模块的声明
- en: '`module monitor.observer { exports monitor.observer; }  module monitor.observer.alpha
    { requires monitor.observer; exports monitor.observer.alpha; }  module monitor.observer.beta
    { requires monitor.observer; exports monitor.observer.beta; }  module monitor.statistics
    { requires monitor.observer; exports monitor.statistics; }  module monitor.persistence
    { requires monitor.statistics; requires hibernate.jpa; exports monitor.persistence;
    exports monitor.persistence.entity; }  module monitor.rest { requires spark.core;
    requires monitor.statistics; exports monitor.rest; }  module monitor { requires
    monitor.observer; requires monitor.observer.alpha; requires monitor.observer.beta;
    requires monitor.statistics; requires monitor.persistence; requires monitor.rest;
    }`'
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.observer { exports monitor.observer; }  module monitor.observer.alpha
    { requires monitor.observer; exports monitor.observer.alpha; }  module monitor.observer.beta
    { requires monitor.observer; exports monitor.observer.beta; }  module monitor.statistics
    { requires monitor.observer; exports monitor.statistics; }  module monitor.persistence
    { requires monitor.statistics; requires hibernate.jpa; exports monitor.persistence;
    exports monitor.persistence.entity; }  module monitor.rest { requires spark.core;
    requires monitor.statistics; exports monitor.rest; }  module monitor { requires
    monitor.observer; requires monitor.observer.alpha; requires monitor.observer.beta;
    requires monitor.statistics; requires monitor.persistence; requires monitor.rest;
    }`'
- en: 2.5.1 DECLARING DEPENDENCIES ON OTHER MODULES
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.5.1 在其他模块上声明依赖
- en: ESSENTIAL INFO A `requires` directive contains a module name and tells the JVM
    that the declaring module depends on the one given by the directive.
  id: totrans-386
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的是 `requires` 指令包含一个模块名称，并告诉JVM声明模块依赖于指令中给出的模块。
- en: You see that the observer implementations depend on the observer API, which
    immediately makes sense. The statistics module also depends on the observer API
    because `Statistician::compute` uses the type `DiagnosticDataPoint`, which is
    part of the API.
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以看到观察者实现依赖于观察者API，这立即就很有道理。统计模块也依赖于观察者API，因为 `Statistician::compute` 使用了 `DiagnosticDataPoint`
    类型，它是API的一部分。
- en: Similarly, the persistence module needs statistics, so it depends on the statistics
    module. It also depends on Hibernate because it uses Hibernate to talk to the
    database.
  id: totrans-388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类似地，持久化模块需要统计信息，因此它依赖于统计模块。它还依赖于Hibernate，因为它使用Hibernate与数据库通信。
- en: Then you have monitor.rest, which also depends on the statistics module because
    it handles statistics. Beyond that, it uses the Spark micro framework to create
    the REST endpoint. When modularizing the application in section 2.2.1, I made
    a point that `MonitorServer` doesn’t depend on `Monitor`. That comes in handy
    now because it means monitor.rest doesn’t depend on monitor; this is great because
    monitor depends on monitor.rest, and the module system forbids declaring cyclic
    dependencies. Finally, monitor depends on all the other modules because it creates
    most instances and pipes the results from one into the other.
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后是monitor.rest，它也依赖于统计模块，因为它处理统计信息。除此之外，它使用Spark微框架创建REST端点。在2.2.1节中模块化应用时，我特别指出`MonitorServer`不依赖于`Monitor`。这现在很有用，因为它意味着monitor.rest不依赖于monitor；这很好，因为monitor依赖于monitor.rest，而模块系统禁止声明循环依赖。最后，monitor依赖于所有其他模块，因为它创建了大多数实例，并将结果从一个模块传递到另一个模块。
- en: 2.5.2 DEFINING A MODULE’S PUBLIC API
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.5.2 定义模块的公共API
- en: ESSENTIAL INFO An `exports` directive contains a package name and informs the
    JVM that other modules depending on the declaring one can see public types in
    that package.
  id: totrans-391
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ESSENTIAL INFO 一个`exports`指令包含一个包名，并通知JVM，依赖于声明该包的其他模块可以查看该包中的公共类型。
- en: 'Most of the modules export a single package: the one that contains the types
    listed when the modules were determined. You may have noticed that the package
    names are always prefixed with the module names—often they’re identical. This
    isn’t mandatory, but because both module and package names follow the reverse-domain
    naming scheme, this is the common case.'
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数模块导出单个包：包含在模块确定时列出的类型的包。你可能已经注意到，包名总是以模块名作为前缀——通常它们是相同的。这不是强制的，但由于模块和包名都遵循反向域名命名方案，所以这是常见的情况。
- en: The persistence module is the only one that exports more than one package. In
    addition to monitor.persistence, which contains its core feature (`StatisticsRepository`),
    it also exports monitor.persistence.entity. That package defines a set of classes
    that are annotated so Hibernate understands how to store and load them (these
    are commonly called entities). This means Hibernate has to access them, which
    in turn implies that the module has to export the package containing them. (If
    you rely on Hibernate reflecting over private fields or constructors, exporting
    won’t suffice—see section 12.2 for a solution.)
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 持久化模块是唯一导出多个包的模块。除了包含其核心功能（`StatisticsRepository`）的`monitor.persistence`之外，它还导出`monitor.persistence.entity`。该包定义了一组被注解的类，Hibernate可以通过这些注解理解如何存储和加载它们（这些通常被称为实体）。这意味着Hibernate必须访问它们，这反过来又意味着模块必须导出包含它们的包。（如果你依赖于Hibernate对私有字段或构造函数进行反射，导出是不够的——请参阅第12.2节以获取解决方案。）
- en: The other exception is monitor, which exports no packages. This makes sense
    because it sits, like a spider in a web, in the center of the module graph and
    coordinates the execution flow. As such, it has no API of its own that anybody
    else might want to call. Having the main module—which usually and fittingly contains
    the program’s main method—not export any packages is typical.
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个例外是monitor，它没有导出任何包。这很有道理，因为它就像蜘蛛网中的蜘蛛一样，位于模块图的中心，协调执行流程。因此，它没有自己的API，其他人可能想要调用。主模块——通常和合适地包含程序的主方法——不导出任何包是典型的。
- en: 2.5.3 VISUALIZING SERVICEMONITOR WITH THE MODULE GRAPH
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.5.3 使用模块图可视化SERVICEMONITOR
- en: With the modules’ dependencies and exports neatly defined, let’s look at the
    resulting module graph in [figure 2.5](part0015.html#filepos296369). Although
    it looks like it’s just a cleaned-up version of [figure 2.3](part0015.html#filepos280835),
    it’s much more than that! [Figure 2.3](part0015.html#filepos280835) is a diagram
    that the application’s architects might have drawn on a whiteboard. It shows modules
    and their relations, but those were just figments of your imagination—nothing
    that mattered to the compiler or virtual machine. [Figure 2.5](part0015.html#filepos296369),
    on the other hand, is the module system’s interpretations of your architecture.
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在模块的依赖和导出定义得井井有条之后，让我们来看看[图2.5](part0015.html#filepos296369)中得到的模块图。虽然它看起来就像是对[图2.3](part0015.html#filepos280835)的一个清理版本，但它远不止于此！[图2.3](part0015.html#filepos280835)是一个应用架构师可能在白板上绘制的图表。它显示了模块及其关系，但那些只是你的想象产物——对编译器或虚拟机来说无关紧要。[图2.5](part0015.html#filepos296369)另一方面，则是模块系统对你架构的解释。
- en: '![](../images/00077.jpeg)'
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00077.jpeg)'
- en: '[Figure 2.5](part0015.html#filepos295279) The application’s module graph, showing
    modules with their exported packages and the dependencies between them. Unlike
    [figure 2.3](part0015.html#filepos280835), this is not merely an architecture
    diagram; it’s how the module system sees the application.'
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图2.5](part0015.html#filepos295279) 应用程序的模块图，显示了模块及其导出的包以及它们之间的依赖关系。与[图2.3](part0015.html#filepos280835)不同，这不仅仅是一个架构图；这是模块系统看待应用程序的方式。'
- en: 'That the modular aspects in both diagrams look so similar, to the point of
    being almost interchangeable, means you can express your vision of the application’s
    architecture fairly precisely in code: namely, in module declarations. Isn’t that
    something?'
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 两个图中的模块方面看起来如此相似，以至于几乎可以互换，这意味着你可以在代码中相当精确地表达你对应用程序架构的愿景：即在模块声明中。这不是很酷吗？
- en: Writing code is much like before
  id: totrans-400
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写代码与之前
- en: You may wonder if writing code will be different than before Java 9\. The answer
    is no, in the overwhelming majority of cases. A few details have changed, though,
    and to prepare you, chapters 6 and 7 cover them in detail.
  id: totrans-401
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能会想知道，编写代码在Java 9之前和之后会有什么不同。答案是大多数情况下不会有变化。尽管如此，一些细节已经发生了变化，为了让你做好准备，第6章和第7章将详细介绍这些变化。
- en: Other than properly modularizing a project and occasionally having to think
    about which package to place classes in or whether to modify a dependency or an
    export, the day-to-day work to model the domain and solve the problems at hand
    will remain the same. With IDE support, modifying dependencies or exports is as
    easy as managing package imports.
  id: totrans-402
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了正确模块化项目，偶尔需要考虑将类放在哪个包中，或者是否需要修改依赖项或导出项之外，日常工作中对领域建模和解决手头问题的努力将保持不变。有了IDE的支持，修改依赖项或导出项就像管理包导入一样简单。
- en: The big-picture work of how to organize a larger code base will get easier,
    though. Adding dependencies, particularly ones that were already transitively
    present, becomes more explicit and thus more readily a matter of discussion during
    pair programming, code reviews, or architecture reviews—this will make sure that
    perceived and real architecture can’t easily drift apart. Prominent features like
    services (see chapter 10) and aggregator modules (see section 11.1.5) will enhance
    the modularity tool box, leading to better design if used well.
  id: totrans-403
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管如此，如何组织更大的代码库的大局工作将变得更加容易。添加依赖项，尤其是那些已经间接存在的依赖项，变得更加明确，因此在结对编程、代码审查或架构审查期间更容易讨论——这将确保感知到的和实际的架构不会轻易分离。像服务（见第10章）和聚合模块（见第11.1.5节）这样的突出功能将增强模块化工具箱，如果使用得当，将导致更好的设计。
- en: 2.6 Compiling and packaging modules
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.6 编译和打包模块
- en: 'Now that you’ve neatly organized the project in module-specific folders, created
    module declarations, and written the code, you’re ready to build and (later) run
    the application. To build it, you’ll create module artifacts, which is a two-step
    process: compilation and packaging.'
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在你已经将项目整洁地组织到模块特定的文件夹中，创建了模块声明，并编写了代码，你就可以构建（稍后运行）应用程序了。要构建它，你需要创建模块工件，这是一个两步的过程：编译和打包。
- en: When compiling, you need the compiler to know where to find the modules the
    declarations are referencing. This is trivial for dependencies on Java modules,
    because the compiler knows where to find them (in the run-time environment’s libs/modules
    file).
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在编译时，你需要让编译器知道声明中引用的模块在哪里。对于Java模块的依赖项来说，这是微不足道的，因为编译器知道它们在哪里（在运行时环境的libs/modules文件中）。
- en: 'ESSENTIAL INFO For your own module to be found, you have to use the module
    path, a concept paralleling the class path but, as the name suggests, expecting
    modular JARs instead of plain JARs. It will be scanned when the compiler searches
    for referenced modules. To define the module path, `javac` has a new option: `--module-path`,
    or `-p` for short. (The same line of thought is true for launching the application
    with the JVM. Accordingly, the same options, `--module-path` and `-p`, were added
    to `java` as well, where they function just the same.)'
  id: totrans-407
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 为了让你的模块被发现，你必须使用模块路径，这是一个与类路径平行的概念，但正如其名称所暗示的，它期望的是模块化的JAR文件而不是普通的JAR文件。当编译器搜索引用的模块时，它将被扫描。为了定义模块路径，`javac`有一个新的选项：`--module-path`，或简写为`-p`。（同样的思路也适用于使用JVM启动应用程序。因此，相同的选项`--module-path`和`-p`也被添加到`java`中，它们的功能完全相同。）'
- en: 'You chose the `mods` folder to store your modules, which means two things:'
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你选择了`mods`文件夹来存储你的模块，这意味着两件事：
- en: The module path will contain `mods`.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块路径将包含`mods`。
- en: The packaged artifacts will be created in `mods`.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包的工件将创建在`mods`中。
- en: 'Some of your modules have external dependencies: the persistence module requires
    Hibernate (`hibernate.jpa`), and the REST module requires Spark (`spark.core`).
    For now, it’s easiest to assume that their artifacts are also already modularized
    JARs and that you or a tool placed them and their dependencies in the `mods` folder.'
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些模块有外部依赖项：持久化模块需要 Hibernate (`hibernate.jpa`)，而 REST 模块需要 Spark (`spark.core`)。目前，最容易的假设是它们的工件也已经模块化
    JAR，并且你或工具将它们及其依赖项放置在 `mods` 文件夹中。
- en: What happens if you place plain JARs on the module path, place modular JARs
    on the class path, or mix and match? And what can you do if a dependency isn’t
    yet modularized but you want to use it anyway? All of that is part of the migration
    story and covered in chapter 8.
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你将普通 JAR 放置在模块路径上，将模块化 JAR 放置在类路径上，或者混合使用，会发生什么？如果依赖项尚未模块化但你仍然想使用它，你能做什么？所有这些都属于迁移故事的一部分，并在第
    8 章中进行了介绍。
- en: 'With all the prerequisites in `mods`, you can compile and package the modules.
    You start with monitor.observer, which has no dependencies. It contains nothing
    new—executed with an older version of Java, these commands would lead to the exact
    same result:'
  id: totrans-413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 `mods` 中拥有所有先决条件后，你可以编译和打包模块。你从 `monitor.observer` 开始，它没有依赖项。它不包含任何新内容——使用较旧的
    Java 版本执行这些命令将产生完全相同的结果：
- en: '`$ javac` `-d monitor.observer/target/classes` [`①`](part0015.html#filepos304882)`${source-files}`
    [`②`](part0015.html#filepos305219) `$ jar --create` `--file mods/monitor.observer.jar`
    [`③`](part0015.html#filepos305719)`-C monitor.observer/target/classes .` [`④`](part0015.html#filepos306057)'
  id: totrans-414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac` `-d monitor.observer/target/classes` [①](part0015.html#filepos304882)`${source-files}`
    [②](part0015.html#filepos305219) `$ jar --create` `--file mods/monitor.observer.jar`
    [③](part0015.html#filepos305719)`-C monitor.observer/target/classes .` [④](part0015.html#filepos306057)'
- en: ①
  id: totrans-415
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Target folder for compilation
  id: totrans-416
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编译目标文件夹
- en: ②
  id: totrans-417
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: 'Lists or finds all source files: in this case, monitor.observer/src/main/java/monitor/observer/DiagnosticDataPoint.java
    and monitor.observer/src/main/java/monitor/observer/ServiceObserver.java'
  id: totrans-418
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列出或查找所有源文件：在这种情况下，`monitor.observer/src/main/java/monitor/observer/DiagnosticDataPoint.java`
    和 `monitor.observer/src/main/java/monitor/observer/ServiceObserver.java`
- en: ③
  id: totrans-419
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: Names the new JAR file in mods
  id: totrans-420
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 `mods` 中命名新的 JAR 文件
- en: ④
  id: totrans-421
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: Compiled source files
  id: totrans-422
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编译后的源文件
- en: 'The monitor.alpha module does have a dependency, so you have to use the module
    path to tell the compiler where to find the required artifacts. Packaging with
    `jar` of course isn’t impacted by that:'
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`monitor.alpha` 模块确实有一个依赖项，因此你必须使用模块路径来告诉编译器在哪里可以找到所需的工件。当然，使用 `jar` 打包不会受到影响：'
- en: '`$ javac --module-path mods` [`①`](part0015.html#filepos307345) `-d monitor.observer.alpha/target/classes
    ${source-files} $ jar --create --file mods/monitor.observer.alpha.jar -C monitor.observer.alpha/target/classes
    .`'
  id: totrans-424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac --module-path mods` [①](part0015.html#filepos307345) `-d monitor.observer.alpha/target/classes
    ${source-files} $ jar --create --file mods/monitor.observer.alpha.jar -C monitor.observer.alpha/target/classes
    .`'
- en: ①
  id: totrans-425
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Folder in which javac will search for modules that the code depends on
  id: totrans-426
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: javac 将在其中搜索代码所依赖的模块的文件夹
- en: 'Most other modules work much the same. One exception is monitor.rest, which
    has third-party dependencies in the `libs` folder, so you need to add that to
    the module path:'
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数其他模块的工作方式几乎相同。一个例外是 `monitor.rest`，它在 `libs` 文件夹中有第三方依赖项，因此你需要将其添加到模块路径中：
- en: '`$ javac --module-path mods:libs` [`①`](part0015.html#filepos308525) `-d monitor.rest/target/classes
    ${source-files}`'
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac --module-path mods:libs` [①](part0015.html#filepos308525) `-d monitor.rest/target/classes
    ${source-files}`'
- en: ①
  id: totrans-429
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: The module has dependencies in two folders, so both are added to the module
    path.
  id: totrans-430
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 该模块在两个文件夹中有依赖项，因此两个文件夹都被添加到模块路径中。
- en: 'Another exception is monitor. You take the opportunity to inform the module
    system that it has a `main` method that can be used as an entry point into the
    application:'
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个例外是 `monitor`。你利用这个机会通知模块系统它有一个 `main` 方法，可以用作应用程序的入口点：
- en: '`$ javac --module-path mods -d monitor/target/classes ${source-files} $ jar
    --create --file mods/monitor.jar` `--main-class monitor.Monitor` [`①`](part0015.html#filepos309879)
    `-C monitor/target/classes .`'
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac --module-path mods -d monitor/target/classes ${source-files} $ jar
    --create --file mods/monitor.jar` `--main-class monitor.Monitor` [①](part0015.html#filepos309879)
    `-C monitor/target/classes .`'
- en: ①
  id: totrans-433
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Class that contains the application’s main method
  id: totrans-434
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包含应用程序主方法的类
- en: '[Figure 2.6](part0015.html#filepos310757) shows what you end up with. These
    JAR files are just like plain old JARs, with one exception: each contains a module
    descriptor `module-info.class` that marks it as a modular JAR.'
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 2.6](part0015.html#filepos310757) 展示了你最终得到的结果。这些 JAR 文件就像普通的 JAR 文件一样，只有一个例外：每个都包含一个模块描述符
    `module-info.class`，将其标记为模块化 JAR。'
- en: '![](../images/00047.jpeg)'
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00047.jpeg)'
- en: '[Figure 2.6](part0015.html#filepos310127) All the application modules, compiled
    and packaged in `mods` and ready to be launched.'
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图2.6](part0015.html#filepos310127) 所有应用程序模块，编译并打包在`mods`中，准备启动。'
- en: 2.7 Running ServiceMonitor
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.7 运行ServiceMonitor
- en: 'With all the modules compiled into the `mods` folder, you’re finally ready
    to launch the application. As you can see in the following one-liner, this is
    where some of the hard work that you put into the module declarations pays off:'
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将所有模块编译到`mods`文件夹后，你终于可以启动应用程序了。正如你在下面的单行命令中可以看到的，这就是你在模块声明中投入的一些辛勤工作得到回报的地方：
- en: '`$ java` `--module-path mods:libs` [`①`](part0015.html#filepos312443)`--module
    monitor` [`②`](part0015.html#filepos312793)'
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java` `--module-path mods:libs` [`①`](part0015.html#filepos312443)`--module
    monitor` [`②`](part0015.html#filepos312793)'
- en: ①
  id: totrans-441
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Folders in which java searches for modules
  id: totrans-442
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java搜索模块的文件夹
- en: ②
  id: totrans-443
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Name of the module to launch
  id: totrans-444
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要启动的模块名称
- en: ESSENTIAL INFO All you need to do is to call `java`, specify the module path
    so `java` knows where to find the artifacts your application consists of, and
    tell it which module to launch. Resolving all dependencies, making sure there
    are no conflicts or ambiguous situations, and launching with just the right set
    of modules are handled by the module system.
  id: totrans-445
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 必要信息你所需要做的就是调用`java`，指定模块路径，这样`java`就知道在哪里找到你的应用程序所包含的工件，并告诉它要启动哪个模块。解决所有依赖项，确保没有冲突或模糊情况，以及仅使用正确的一组模块来启动，都由模块系统处理。
- en: 2.8 Extending a modular code base
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.8 扩展模块化代码库
- en: 'Of course, no software project is ever finished (unless it’s dead), so change
    is inevitable. What happens, for example, if you want to add another observer
    implementation? Usually you’d take these steps:'
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当然，没有任何软件项目是永远完成的（除非它已经死亡），所以变化是不可避免的。例如，如果你想添加另一个观察者实现，会发生什么？通常你会采取以下步骤：
- en: Develop the subproject.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发子项目。
- en: Make sure it builds.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保它能构建。
- en: Use it in existing code.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有代码中使用它。
- en: 'And this is exactly what you’ll do now. For the new module, the module system
    is content if you add a declaration:'
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这正是你现在要做的。对于新模块，模块系统如果添加了声明就会感到满意。
- en: '`module monitor.observer.gamma { requires monitor.observer; exports monitor.observer.gamma;
    }`'
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.observer.gamma { requires monitor.observer; exports monitor.observer.gamma;
    }`'
- en: 'You compile and package the new module just like the others:'
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你就像编译和打包其他模块一样编译和打包新模块：
- en: '`$ javac --module-path mods -d monitor.observer.gamma/target/classes ${source-files}
    $ jar --create --file mods/monitor.observer.gamma.jar -C monitor.observer.gamma/target/classes
    .`'
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac --module-path mods -d monitor.observer.gamma/target/classes ${source-files}
    $ jar --create --file mods/monitor.observer.gamma.jar -C monitor.observer.gamma/target/classes
    .`'
- en: 'Then you can add it as a dependency to your existing code:'
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后你可以将其作为依赖项添加到现有的代码中：
- en: '`module monitor { requires monitor.observer; requires monitor.observer.alpha;
    requires monitor.observer.beta; requires monitor.observer.gamma; requires monitor.statistics;
    requires monitor.persistence; requires monitor.rest; }`'
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor { requires monitor.observer; requires monitor.observer.alpha;
    requires monitor.observer.beta; requires monitor.observer.gamma; requires monitor.statistics;
    requires monitor.persistence; requires monitor.rest; }`'
- en: 'And you’re finished. Assuming a build takes care of compilation and packaging,
    all you really had to do was add or edit module declarations. This is also true
    for removing or refactoring modules: beyond the usual work you have to put in,
    you need to spend a little extra thought on how this impacts your module graph
    and update the declarations accordingly.'
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你就完成了。假设构建过程负责编译和打包，你实际上只需要添加或编辑模块声明。这也适用于删除或重构模块：除了你通常需要投入的工作之外，你还需要稍微思考一下这如何影响你的模块图，并相应地更新声明。
- en: '2.9 Post mortem: Effects of the module system'
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.9 剖析：模块系统的影响
- en: All in all, that went pretty well, don’t you think? Before exploring the details
    in the following chapters, let’s take some time to look at two of the benefits
    the module system promises as well as some of the rough edges you can hope to
    smooth out with more advanced features.
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总体来说，这进行得相当顺利，不是吗？在探索以下章节的细节之前，让我们花点时间看看模块系统承诺的两个好处以及一些你可以通过更高级的功能来平滑处理的一些粗糙边缘。
- en: 2.9.1 WHAT THE MODULE SYSTEM DOES FOR YOU
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.9.1 模块系统为你做了什么
- en: 'When discussing the goals of the module system in section 1.5, we talked about
    the two most important ones: reliable configuration and strong encapsulation.
    Now that you’ve built something more concrete, we can revisit those goals and
    see how they’re going to help you deliver robust, maintainable software.'
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在1.5节中讨论模块系统的目标时，我们提到了两个最重要的目标：可靠配置和强封装。现在你已经构建了一些更具体的东西，我们可以重新审视这些目标，看看它们将如何帮助你交付健壮、可维护的软件。
- en: RELIABLE CONFIGURATION
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可靠配置
- en: What happens if a dependency is missing from mods? What happens if two dependencies
    require different versions of the same project—maybe Log4j or Guava? What happens
    if two modules export the same types, inadvertently or on purpose?
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果mods中缺少依赖项会发生什么？如果两个依赖项需要同一项目的不同版本——比如Log4j或Guava——会发生什么？如果两个模块意外或故意导出相同的类型，会发生什么？
- en: 'With the class path, these problems would manifest at run time: some would
    crash the application, whereas others would be more subtle, and arguably more
    devious, and lead to corrupted application behavior. With the module system in
    play, many of these unreliable situations, particularly those I just mentioned,
    would be recognized much earlier. The compiler or JVM would abort with a detailed
    message and give you a chance to fix the mistake.'
  id: totrans-464
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用类路径时，这些问题会在运行时显现：一些会导致应用程序崩溃，而其他问题可能更为微妙，甚至可以说是狡猾，并可能导致应用程序行为损坏。在模块系统中，许多这些不可靠的情况，尤其是我刚才提到的那些，会在更早的时候被发现。编译器或JVM会通过详细的错误信息终止，并给你机会修复错误。
- en: 'This, for example, is the message you get if the application is launched but
    monitor.statistics is missing:'
  id: totrans-465
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，如果你启动应用程序但monitor.statistics缺失，你会收到以下消息：
- en: '`> Error occurred during initialization of boot layer > java.lang.module.FindException:
    > Module monitor.statistics not found, > required by monitor`'
  id: totrans-466
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 初始化引导层时发生错误 > java.lang.module.FindException: > 没有找到模块 monitor.statistics，
    > 它被 monitor 所需要`'
- en: 'Similarly, this is the result of launching the ServiceMonitor application with
    two SLF4J versions present on the module path:'
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类似地，这是在模块路径上存在两个SLF4J版本时启动ServiceMonitor应用程序的结果：
- en: '`> Error occurred during initialization of boot layer > java.lang.module.FindException:
    > Two versions of module org.slf4j.api found in mods > (org.slf4j.api-1.7.25.jar
    and org.slf4j.api-1.7.7.jar)`'
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 初始化引导层时发生错误 > java.lang.module.FindException: > 在mods中找到两个版本的模块 org.slf4j.api
    > (org.slf4j.api-1.7.25.jar 和 org.slf4j.api-1.7.7.jar)`'
- en: 'You can also no longer accidentally depend on your dependencies’ dependencies.
    Hibernate uses SLF4J, which means the library is always present when your application
    is launched. But as soon as you start importing types from SLF4J (which you don’t
    require in any module declaration), the compiler will stop you, informing you
    that you’re using code from a module you don’t explicitly depend on:'
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你也不再可能意外地依赖于你的依赖项的依赖项。Hibernate使用SLF4J，这意味着当你的应用程序启动时，库总是存在的。但一旦你开始从SLF4J导入类型（你不需要在任何模块声明中导入），编译器就会阻止你，并通知你正在使用你未显式依赖的模块中的代码：
- en: '`> monitor.persistence/src/main/java/.../StatisticsRepository.java:4: > error:
    package org.slf4j is not visible > (package org.slf4j is declared in module org.slf4j.api,
    > but module monitor.persistence does not read it)`'
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> monitor.persistence/src/main/java/.../StatisticsRepository.java:4: > 错误：无法看到包
    org.slf4j > (包 org.slf4j 在模块 org.slf4j.api 中声明， > 但模块 monitor.persistence 没有读取它)`'
- en: Even if you were to trick the compiler, the module system executes the same
    checks at launch time.
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使你试图欺骗编译器，模块系统在启动时也会执行相同的检查。
- en: STRONG ENCAPSULATION
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 强封装
- en: Now let’s change perspective from being a module’s user to being its maintainer.
    Imagine refactoring code in monitor.observer.alpha, maybe in preparation for fixing
    a bug or to improve performance. After releasing a new version, you find out that
    you broke some code in monitor and made the application unstable. If you changed
    a public API, it’s your fault.
  id: totrans-473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，让我们从模块的用户转变为模块的维护者。想象一下在monitor.observer.alpha中对代码进行重构，可能是为了修复一个错误或提高性能。在发布新版本后，你发现你破坏了monitor中的某些代码，使应用程序变得不稳定。如果你更改了公共API，那就是你的责任。
- en: But what if you changed an internal implementation detail in a type that was
    accessed despite being marked as unsupported? Maybe the type had to be public
    because you wanted to use it in two packages, or perhaps the authors of monitor
    accessed it via reflection. In that case, there’s nothing you could have done
    to prevent users from depending on your implementation.
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但是，如果你在一个被标记为不支持的类型中更改了内部实现细节，会发生什么呢？也许这个类型必须公开，因为你想要在两个包中使用它，或者可能是监控器的作者通过反射访问了它。在这种情况下，你无法阻止用户依赖你的实现。
- en: With the help of the module system, you can avoid this situation. You already
    did! Only types in the packages you export are visible. The rest are safe—even
    from reflection.
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过模块系统，你可以避免这种情况。你已经做到了！只有你导出的包中的类型是可见的。其余的都是安全的——甚至从反射中也是安全的。
- en: NOTE In case you’re wondering what you can do if you really need to break into
    a module, check out sections 7.1 and 12.2.2.
  id: totrans-476
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：如果你想知道在真正需要打破模块的情况下可以做什么，请参阅第7.1节和第12.2.2节。
- en: 2.9.2 WHAT ELSE THE MODULE SYSTEM CAN DO FOR YOU
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.9.2 模块系统还能为你做什么
- en: Although the modularization of ServiceMonitor went pretty well, there are a
    couple of rough edges we need to discuss. You won’t be able to do anything about
    them now, but the advanced features presented throughout part 3 of this book will
    enable you to smooth them out. This section gives you a preview of what’s to come.
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然ServiceMonitor的模块化进行得相当顺利，但还有一些粗糙的边缘我们需要讨论。你现在无法做任何事情，但本书第3部分的先进功能将使你能够平滑它们。本节为你预览了即将发生的事情。
- en: MARKING INDISPENSABLE MODULE DEPENDENCIES
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 标记必需的模块依赖项
- en: The modules monitor.observer.alpha and monitor.observer.beta declare a dependency
    on monitor.observer, which makes sense because they implement the `ServiceObserver`
    interface that the latter exposes. They also return instances of `DiagnosticDataPoint`,
    which belongs to the same module.
  id: totrans-480
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块`monitor.observer.alpha`和`monitor.observer.beta`声明了对`monitor.observer`的依赖，这是有意义的，因为它们实现了后者公开的`ServiceObserver`接口。它们还返回`DiagnosticDataPoint`实例，它属于同一个模块。
- en: 'This has interesting consequences for any code using the implementation modules:'
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这对任何使用实现模块的代码都有有趣的后果：
- en: '`ServiceObserver observer = new AlphaServiceObserver("some://service/url");
    DiagnosticDataPoint data = observer.gatherDataFromService();`'
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ServiceObserver observer = new AlphaServiceObserver("some://service/url");
    DiagnosticDataPoint data = observer.gatherDataFromService();`'
- en: The module containing these lines needs to depend on monitor.observer as well;
    otherwise it couldn’t see the types `ServiceObserver` and `DiagnosticDataPoint`.
    The entire monitor.observer.alpha module becomes pretty much useless to clients
    that don’t also depend on monitor.observer.
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包含这些行的模块需要依赖`monitor.observer`；否则，它将无法看到`ServiceObserver`和`DiagnosticDataPoint`类型。对于不依赖`monitor.observer`的客户端来说，整个`monitor.observer.alpha`模块几乎毫无用处。
- en: Having a module that’s usable only if clients remember to explicitly depend
    on another module is clumsy. Good thing there’s a way around that! You’ll read
    about implied readability in section 11.1.
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果一个模块只有在客户端记得显式依赖另一个模块时才能使用，这会很笨拙。幸运的是，有一个解决办法！你将在第11.1节中了解到隐式可读性。
- en: DECOUPLING IMPLEMENTATIONS AND CONSUMERS OF AN API
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解耦API的实现和消费者
- en: Thinking about the relationship between monitor.observer and the implementing
    modules, monitor.observer.alpha and monitor.observer.beta, something else comes
    to mind. Why does monitor have to know the implementations?
  id: totrans-486
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑到`monitor.observer`与实现模块之间的关系，以及`monitor.observer.alpha`和`monitor.observer.beta`，还有一些其他的事情需要考虑。为什么监控器必须知道实现细节呢？
- en: As it stands, monitor needs to instantiate the concrete classes, but from then
    on it only interacts with them through the interface. Depending on an entire module
    to call one constructor seems excessive. And indeed, any time a deprecated `ServiceObserver`
    implementation is phased out or a new implementation is introduced, you’d have
    to update monitor’s module dependencies and then recompile, package, and redeploy
    the artifact.
  id: totrans-487
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 目前，监控器需要实例化具体的类，但从那时起，它只通过接口与它们交互。依赖整个模块来调用一个构造函数似乎有些过度。实际上，每当一个废弃的`ServiceObserver`实现被淘汰或引入新的实现时，你都需要更新监控器的模块依赖，然后重新编译、打包和重新部署工件。
- en: To enable a looser coupling between implementations and consumers of an API,
    where consumers like monitor don’t need to depend on implementations like monitor.observer.alpha
    and monitor.observer.beta, the module system offers services. They’re discussed
    in chapter 10.
  id: totrans-488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了实现 API 实现和消费者之间的松散耦合，其中消费者如 monitor 不需要依赖实现如 monitor.observer.alpha 和 monitor.observer.beta，模块系统提供了服务。它们在第
    10 章中进行了讨论。
- en: MAKING EXPORTS MORE TARGETED
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使导出更具有针对性
- en: Remember how the persistence module exported the package that contains the data-transfer
    objects annotated for use by Hibernate?
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记得持久化模块是如何导出包含由 Hibernate 注解用于使用的对象的数据传输对象的包吗？
- en: '`module monitor.persistence { requires monitor.statistics; requires hibernate.jpa;
    exports monitor.persistence; exports monitor.persistence.entity; }`'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.persistence { requires monitor.statistics; requires hibernate.jpa;
    exports monitor.persistence; exports monitor.persistence.entity; }`'
- en: This doesn’t look right—only Hibernate needs to see those entities. But now
    other modules that depend on monitor.persistence, such as monitor, can see them,
    too.
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这看起来并不合适——只有 Hibernate 需要看到那些实体。但现在其他依赖于 monitor.persistence 的模块，如 monitor，也能看到它们。
- en: Again, an advanced module system feature has you covered. Qualified exports
    allow a module to export a package not to everybody, but just to a select list
    of modules. Section 11.3 introduces that mechanism.
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 再次强调，高级模块系统功能可以满足你的需求。合格导出允许模块仅向选定的模块导出包。第 11.3 节介绍了这一机制。
- en: MAKING PACKAGES AVAILABLE TO REFLECTION ONLY
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 仅使包对反射可用
- en: 'Even exporting a package only to selected modules can be too much:'
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使仅向选定的模块导出包也可能过多：
- en: You might compile your module against an API (such as the Java Persistence API
    [JPA]) and not against a concrete implementation (for example, Hibernate), so
    you’re understandably wary of mentioning the implementing module in your qualified
    exports.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能针对 API（如 Java 持久化 API [JPA]）编译你的模块，而不是针对具体实现（例如，Hibernate），因此你可能会在合格导出中谨慎提及实现模块。
- en: You might be using a reflection-based tool (like Hibernate or Guice) that only
    accesses your code at run time via reflection, so why make it accessible at compile
    time?
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能使用的是基于反射的工具（如 Hibernate 或 Guice），它仅在运行时通过反射访问你的代码，所以为什么要在编译时使其可访问呢？
- en: You might be relying on reflection over private members (Hibernate does it when
    configured for field injection), which doesn’t work in exported packages.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能依赖于对私有成员的反射（当配置为字段注入时，Hibernate 会这样做），这在导出包中是不起作用的。
- en: A solution is presented in section 12.2, which introduces open modules and open
    packages. They make packages available at run time only. In exchange, they allow
    reflection over private members as is often required by reflection-based tools.
    Similar to exports, there are qualified opens, with which you can open a package
    to just a selected module.
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第 12.2 节提供了一个解决方案，介绍了开放模块和开放包。它们仅在运行时使包可用。作为交换，它们允许反射私有成员，这是基于反射的工具通常需要的。类似于导出，还有合格开放，你可以使用它将包仅向选定的模块开放。
- en: If you’ve been using, for example, Hibernate as a JPA provider, you may have
    worked hard to prevent direct dependencies on Hibernate. In that case, hard-coding
    a dependency into a module declaration won’t be something you look forward to.
    Section 12.3.5 discusses that scenario in detail.
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你例如使用 Hibernate 作为 JPA 提供者，你可能已经努力防止模块声明中直接依赖 Hibernate。在这种情况下，将依赖项硬编码到模块声明中可能不是你期待的事情。第
    12.3.5 节详细讨论了这种情况。
- en: 2.9.3 ALLOWING OPTIONAL DEPENDENCIES
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.9.3 允许可选依赖
- en: It isn’t uncommon for a project to contain code that’s executed only if a specific
    dependency is present in the running application. The module monitor.statistics,
    for example, might contain code using a fancy statistics library that—perhaps
    due to licensing issues—isn’t always present when ServiceMonitor launches. Another
    example is a library with certain features that are interesting to users only
    if a third dependency is present—maybe a testing framework that cooperates with
    some assertion library if it’s used with the framework.
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 项目中包含仅在特定依赖项存在于运行中的应用程序中才执行的代码并不罕见。例如，模块 monitor.statistics 可能包含使用一个花哨的统计库的代码，由于可能是许可问题，当
    ServiceMonitor 启动时并不总是存在。另一个例子是，只有当存在第三个依赖项时，某些功能对用户才有吸引力——比如，如果与某些断言库一起使用，可能是一个与框架合作的测试框架。
- en: In such cases, according to what was discussed earlier, the dependency must
    be required in the module declaration. This forces it to be present at compile
    time for a successful compilation. Unfortunately, the same `requires` directive
    means the dependency must also be present at launch time, or the JVM will refuse
    to run the application.
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这种情况下，根据前面讨论的内容，必须在模块声明中要求依赖项。这迫使它在编译时存在，以便成功编译。不幸的是，相同的 `requires` 指令意味着依赖项也必须在启动时存在，否则
    JVM 将拒绝运行应用程序。
- en: 'This is unsatisfactory. But as expected, the module system presents an out:
    optional dependencies, which must be present at compile time but aren’t required
    at run time. They’re discussed in section 11.2\. After we’ve discussed all of
    these and other advanced features, section 15.1 shows a variant of ServiceMonitor
    that uses most of them.'
  id: totrans-504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这并不令人满意。但正如预期的那样，模块系统提供了一个出路：可选依赖项，它们必须在编译时存在，但在运行时不要求。它们在第 11.2 节中进行了讨论。在讨论了所有这些和其他高级功能之后，第
    15.1 节展示了使用其中大多数功能的 ServiceMonitor 的一个变体。
- en: 'Each of the three steps of defining, building, and running a modular application
    has its own chapter: 3, 4, and 5, respectively. All of them are important, but
    chapter 3 is particularly so because it introduces the fundamental concepts and
    mechanisms underlying the module system.'
  id: totrans-505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义、构建和运行模块化应用程序的三个步骤各自有自己的章节：第 3 章、第 4 章和第 5 章，分别。所有这些都很重要，但第 3 章尤其重要，因为它介绍了模块系统背后的基本概念和机制。
- en: Summary
  id: totrans-506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: When you’re modularizing an application, you can deduce the module dependencies
    from type dependencies across module boundaries. This makes creating an initial
    module-dependency graph a straightforward procedure.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你对应用程序进行模块化时，你可以从模块边界跨模块的类型依赖中推断出模块依赖。这使得创建初始模块依赖图变得简单直接。
- en: The directory structure of a multimodule project can be similar to what it would
    have been before Java 9, so existing tools and approaches will continue to work.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多模块项目的目录结构可以与 Java 9 之前的情况相似，因此现有的工具和方法将继续工作。
- en: The module declaration—a `module-info.java` file in the project’s root directory—is
    the most obvious change that the module system brings to coding. It names the
    module and declares dependencies as well as the public API. Other than that, the
    way code is written is virtually unchanged.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块声明——项目根目录中的 `module-info.java` 文件——是模块系统对编码带来的最明显变化。它命名了模块并声明了依赖项以及公共 API。除此之外，代码的编写方式几乎没有任何变化。
- en: The commands `javac`, `jar`, and `java` have been updated to work with modules.
    The most obvious and relevant change is the module path (command-line option `--module-pat`h
    or `-p`). It parallels the class path but is used for modules.
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令 `javac`、`jar` 和 `java` 已更新以支持模块化。最明显且相关的变化是模块路径（命令行选项 `--module-path` 或 `-p`）。它与类路径平行，但用于模块。
- en: '3'
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '3'
- en: Defining modules and their properties
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义模块及其属性
- en: This chapter covers
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: What modules are, and how module declarations define them
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是什么，以及模块声明如何定义它们
- en: Discerning different types of modules
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分不同类型的模块
- en: Module readability and accessibility
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的可读性和可访问性
- en: Understanding the module path
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模块路径
- en: Building module graphs with module resolution
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块解析构建模块图
- en: We’ve talked a lot about modules already. They’re the core building blocks not
    only of modular applications, but also of a true comprehension of the module system.
    As such, it’s important to build a deeper understanding of what they are and how
    their properties shape a program’s behavior.
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们已经讨论了很多关于模块的内容。它们不仅是模块化应用程序的核心构建块，也是对模块系统真正理解的核心。因此，深入了解它们是什么以及它们的属性如何塑造程序的行为是很重要的。
- en: Of the three essential steps of defining, building, and running modules, this
    chapter explores the first (for the other two, see chapters 4 and 5). This chapter
    explains in detail what a module is and how a module’s declaration defines its
    name, dependencies, and API (section 3.1). Some examples from the JDK give you
    a first look at the module landscape we’re going to explore from Java 9 on and
    categorize the kinds of modules to help you navigate.
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在定义、构建和运行模块的三个基本步骤中，本章探讨了第一个（关于其他两个步骤，请参阅第 4 章和第 5 章）。本章详细解释了什么是模块以及模块的声明如何定义其名称、依赖项和
    API（第 3.1 节）。一些来自 JDK 的示例让你对从 Java 9 开始将要探索的模块景观有一个初步的了解，并帮助你分类模块类型。
- en: We also discuss how the module system—and, by extension, the compiler and runtime—interact
    with modules (sections 3.2 and 3.3). Last but not least, we examine the module
    path and how the module system resolves dependencies and builds a graph from them
    (section 3.4).
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们还讨论了模块系统（以及由此扩展的编译器和运行时）如何与模块交互（第 3.2 节和第 3.3 节）。最后但同样重要的是，我们检查了模块路径以及模块系统如何解析依赖关系并从它们构建一个图（第
    3.4 节）。
- en: If you want to code along, check out ServiceMonitor’s master branch. It contains
    most of the module declarations shown in this chapter. By the end of the chapter,
    you’ll know how to define a module’s name, dependencies, and API and how the module
    system behaves based on that information. You’ll understand the error messages
    the module system may throw at you and be able to analyze and fix their root cause.
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您想跟随代码编写，请查看 ServiceMonitor 的主分支。它包含本章中展示的大多数模块声明。到本章结束时，您将知道如何定义模块的名称、依赖关系和
    API，以及模块系统如何根据这些信息表现。您将理解模块系统可能抛出的错误消息，并能够分析和修复其根本原因。
- en: Signposts
  id: totrans-523
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指示牌
- en: This chapter lays the groundwork for everything to come, and thus the rest of
    the book is connected to it. To make those connections apparent, the chapter includes
    a lot of forward references. If they bother you, you can ignore them—they will
    become important when you open this chapter to look something up.
  id: totrans-524
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章为后续内容奠定了基础，因此本书的其余部分都与它相连。为了使这些联系显而易见，本章包含大量的前瞻性引用。如果您觉得它们烦人，可以忽略它们——当您打开本章查找某些内容时，它们将变得重要。
- en: '3.1 Modules: The building blocks of modular applications'
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.1 模块：模块化应用程序的构建块
- en: After all that lofty talk about modules, it’s time to get your hands dirty.
    We’ll first look at the two file formats in which you may encounter modules (JMODs
    and modular JARs) before turning to how you declare a module’s properties. Laying
    some groundwork for easier discussions in the rest of this book, we’ll categorize
    the different kinds of modules.
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在所有关于模块的高谈阔论之后，是时候动手实践了。我们首先将查看您可能遇到的两种文件格式中的模块（JMODs 和模块化 JARs），然后转向如何声明模块的属性。为了在本书的其余部分更容易地进行讨论，我们将对不同的模块类型进行分类。
- en: 3.1.1 JAVA MODULES (JMODS), SHIPPED WITH THE JDK
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.1.1 与 JDK 一起提供的 JAVA 模块（JMODS）
- en: During the work on Project Jigsaw, the Java code base was split into about 100
    modules, which are delivered in a new format called JMOD. It’s deliberately unspecified
    to allow a more aggressive evolution than was possible with the JAR format (which
    is essentially a ZIP file). It’s reserved for use by the JDK, which is why we
    won’t discuss it in depth.
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Project Jigsaw 的工作过程中，Java 代码库被分割成大约 100 个模块，这些模块以新的格式 JMOD 提供的。它是故意不明确的，以便比使用
    JAR 格式（本质上是一个 ZIP 文件）更激进地进化。它被保留用于 JDK，因此我们不会深入讨论它。
- en: Although we aren’t supposed to create JMODs, we can examine them. To see the
    modules contained in a JRE or JDK, call `java --list-modules`. The information
    comes from an optimized module storage, the `modules` file in the runtime install’s
    `libs` folder. JDKs (not JREs) also contain the raw modules in a `jmods` folder;
    and the new `jmod` tool, which you can find in the `bin` folder next to `jmods`,
    can be used to output their properties with the `describe` operation.
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然我们不应该创建 JMODs，但我们可以检查它们。要查看 JRE 或 JDK 中的模块，请调用 `java --list-modules`。信息来自优化后的模块存储，即运行时安装的
    `libs` 文件夹中的 `modules` 文件。JDK（而非 JRE）还包含在 `jmods` 文件夹中的原始模块；并且新的 `jmod` 工具，您可以在
    `jmods` 旁边的 `bin` 文件夹中找到，可以使用 `describe` 操作输出它们的属性。
- en: 'The following snippet shows an example of examining a JMOD file. Here, `jmod`
    is used to describe java.sql on a Linux machine, where JDK 9 is installed in `*opt*jdk-9`.
    Like most Java modules, java.sql uses several of the module system’s advanced
    features, so not all details will be clear by the end of the chapter:'
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码片段展示了检查 JMOD 文件的一个示例。在这里，`jmod` 用于描述 Linux 机器上的 java.sql，其中 JDK 9 安装在 `*opt*jdk-9`。像大多数
    Java 模块一样，java.sql 使用了模块系统的一些高级功能，因此并非所有细节都会在章节结束时变得清晰：
- en: '`$ jmod describe *opt*jdk-9/jmods/java.sql.jmod` `> java.sql@9.0.4` [`①`](part0016.html#filepos346404)`>
    exports java.sql` [`②`](part0016.html#filepos346792) `> exports javax.sql > exports
    javax.transaction.xa` `> requires java.base mandated` [`③`](part0016.html#filepos347203)`>
    requires java.logging transitive` [`④`](part0016.html#filepos347644) `> requires
    java.xml transitive` `> uses java.sql.Driver` [`⑤`](part0016.html#filepos348013)`>
    platform linux-amd64` [`⑥`](part0016.html#filepos348412)'
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jmod describe *opt*jdk-9/jmods/java.sql.jmod` `> java.sql@9.0.4` [`①`](part0016.html#filepos346404)`>
    exports java.sql` [`②`](part0016.html#filepos346792) `> exports javax.sql > exports
    javax.transaction.xa` `> requires java.base mandated` [`③`](part0016.html#filepos347203)`>
    requires java.logging transitive` [`④`](part0016.html#filepos347644) `> requires
    java.xml transitive` `> uses java.sql.Driver` [`⑤`](part0016.html#filepos348013)`>
    platform linux-amd64` [`⑥`](part0016.html#filepos348412)'
- en: ①
  id: totrans-532
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: 'The module’s version is recorded in the file as a simple string: here, 9.0.4\.'
  id: totrans-533
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块的版本以简单字符串的形式记录在文件中：这里，9.0.4。
- en: ②
  id: totrans-534
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Packages that java.sql contains and exposes to other modules (exports are introduced
    in section 3.1.3)
  id: totrans-535
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包含在java.sql中并向其他模块公开的包（导出在第3.1.3节中介绍）
- en: ③
  id: totrans-536
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: The requires directives declare dependencies. The term “mandated” stems from
    java.base being a special case (see section 3.1.4).
  id: totrans-537
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 需求指令声明了依赖关系。术语“强制”源于java.base是一个特殊情况（参见第3.1.4节）。
- en: ④
  id: totrans-538
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: Dependencies that use implied readability (see section 11.1)
  id: totrans-539
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用隐式可读性（参见第11.1节）的依赖项
- en: ⑤
  id: totrans-540
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑤
- en: The uses directive is connected to services (see chapter 10, particularly section
    10.1.1).
  id: totrans-541
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用指令与服务相关联（参见第10章，特别是第10.1.1节）。
- en: ⑥
  id: totrans-542
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑥
- en: The module is built for a specific OS and hardware architecture.
  id: totrans-543
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块是为特定的操作系统和硬件架构构建的。
- en: '3.1.2 MODULAR JARS: HOME-GROWN MODULES'
  id: totrans-544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.1.2 模块 JAR：自建模块
- en: We aren’t supposed to create JMODs, so how do we deliver the modules we create?
    This is where modular JARs come in.
  id: totrans-545
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们不应该创建 JMOD，那么我们如何交付我们创建的模块呢？这正是模块 JAR 发挥作用的地方。
- en: 'Definition: Modular JAR and module descriptor'
  id: totrans-546
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：模块 JAR 和模块描述符
- en: 'A modular JAR is just a plain JAR, except for one small detail. Its root directory
    contains a module descriptor: a `module-info.class` file. (This book calls JARs
    without a module descriptor plain JARs, but that isn’t an official term.)'
  id: totrans-547
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块 JAR 只是一个普通的 JAR，除了一个小的细节。它的根目录包含一个模块描述符：一个`module-info.class`文件。（本书将没有模块描述符的
    JAR 称为普通 JAR，但这不是一个官方术语。）
- en: The module descriptor holds all the information needed by the module system
    to create a runtime representation of the module. All properties of an individual
    module are represented in this file; consequently, many of the features discussed
    throughout this book have their counterpart in it, too. Creating such a descriptor
    from a source file, as covered in the next section, and including it in a JAR
    allow developers and tools to create modules.
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块描述符包含模块系统创建模块运行时表示所需的所有信息。单个模块的所有属性都表示在这个文件中；因此，本书中讨论的许多功能也有其对应项。在下一节中，我们将介绍如何从源文件创建这样的描述符，并将其包含在
    JAR 中，以便开发人员和工具可以创建模块。
- en: Although the module descriptor allows a modular JAR to be more than a mere class
    file archive, using it that way isn’t mandatory. Clients can choose to use it
    as a simple JAR, ignoring all module-related properties, by placing it on the
    class path. This is indispensable for incremental modularizations of existing
    projects. (Section 8.2 introduces the unnamed module.)
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管模块描述符允许模块 JAR 不仅仅是类文件存档，但以这种方式使用它并不是强制性的。客户端可以选择将其作为简单的 JAR 使用，忽略所有模块相关属性，只需将其放置在类路径上。这对于现有项目的增量模块化至关重要。（第8.2节介绍了未命名的模块。）
- en: '3.1.3 MODULE DECLARATIONS: DEFINING A MODULE’S PROPERTIES'
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.1.3 模块声明：定义模块属性
- en: So a module descriptor, `module-info.class`, is all you need to turn any old
    JAR into a module. That begs the question, though, of how you create a descriptor.
    As the file extension `.class` suggests, it’s the result of compiling a source
    file.
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，模块描述符`module-info.class`是您将任何旧 JAR 转换为模块所需的所有内容。然而，这引发了一个问题，那就是如何创建描述符。正如文件扩展名`.class`所暗示的，它是编译源文件的结果。
- en: 'Definition: Module declaration'
  id: totrans-552
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：模块声明
- en: A module descriptor is compiled from a module declaration. By convention, this
    is a `module-info.java` file in the project’s root source folder. The declaration
    is the pivotal element of modules and thus the module system.
  id: totrans-553
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块描述符是从模块声明编译而来的。按照惯例，这是一个位于项目根源文件夹中的`module-info.java`文件。声明是模块的核心元素，因此是模块系统。
- en: Declaration vs. description
  id: totrans-554
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 声明与描述
- en: 'You may be worried that you’ll confuse the terms module declaration and module
    descriptor. If you do, that’s usually not a big deal. The former is source code
    and the latter bytecode, but they’re just different forms of the same idea: something
    that defines a module’s properties. The context often leaves only one option,
    so it’s usually clear which form is meant.'
  id: totrans-555
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能会担心你会混淆模块声明和模块描述符这两个术语。如果你这样做，通常不是什么大问题。前者是源代码，后者是字节码，但它们只是相同想法的不同形式：定义模块属性的东西。上下文通常只留下一个选项，所以通常很清楚指的是哪种形式。
- en: 'If that doesn’t satisfy you, and you want to always get it right, I can help
    by sharing my mnemonic: lexicographically speaking, declaration comes before descriptor,
    which is neat because temporally speaking, you first have the source code and
    then the bytecode. Both orderings align: first declaration/source, then descriptor/bytes.'
  id: totrans-556
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果这还不能满足你，并且你总是想做到正确无误，我可以通过分享我的记忆法来帮助你：按字典顺序来说，声明在描述符之前，这很整洁，因为从时间顺序来说，你首先有源代码，然后是字节码。这两种排序是一致的：首先是声明/源代码，然后是描述符/字节码。
- en: 'The module declaration determines a module’s identity and behavior in the module
    system. Many of the features the following chapters introduce have corresponding
    directives in the module declaration, presented in due time. For now, let’s look
    at the three basic properties lacking in JARs: a name, explicit dependencies,
    and encapsulated internals.'
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块声明决定了模块在模块系统中的身份和行为。后续章节中介绍的大多数功能在模块声明中都有相应的指令，将在适当的时候介绍。现在，让我们看看 JAR 文件缺少的三个基本属性：一个名字、显式的依赖关系和封装的内部结构。
- en: 'ESSENTIAL INFO This is the structure of a simple `module-info.java` file that
    defines these three properties:'
  id: totrans-558
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**基本信息** 这是定义这三个属性的简单 `module-info.java` 文件的结构：'
- en: '`module ${module-name} { requires ${module-name}; exports ${package-name};
    }`'
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module ${module-name} { requires ${module-name}; exports ${package-name};
    }`'
- en: Of course, `${module-name}` and `${package-name}` need to be replaced with actual
    module and package names.
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当然，`${module-name}` 和 `${package-name}` 需要替换为实际的模块和包名称。
- en: 'Take the descriptor of ServiceMonitor’s monitor.statistics module as an example:'
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以 ServiceMonitor 的 monitor.statistics 模块的描述符为例：
- en: '`module monitor.statistics { requires monitor.observer; exports monitor.statistics;
    }`'
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.statistics { requires monitor.observer; exports monitor.statistics;
    }`'
- en: 'You can easily recognize the structure I just described: the `module` keyword
    is followed by the module’s name, and the body contains `requires` and `exports`
    directives. The following sections look at the details of declaring these three
    properties.'
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以很容易地识别我刚才描述的结构：`module` 关键字后面跟着模块的名称，主体包含 `requires` 和 `exports` 指令。接下来的几节将探讨声明这三个属性的具体细节。
- en: New keywords?
  id: totrans-564
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 新的关键字？
- en: You may wonder what the new keywords `module`, `requires`, `exports`, and others
    in later chapters mean for code that already uses these terms as names for fields,
    parameters, variables, and other named entities. Fortunately, there’s nothing
    to worry about. These are restricted keywords, meaning they act as a keyword only
    if used in a position where the syntax expects them. So although you can’t have
    a variable named `package` or a module named `byte`, you can have a variable and
    even a module named `module`.
  id: totrans-565
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能会想知道，在后续章节中提到的新的关键字 `module`、`requires`、`exports` 等对于已经将这些术语用作字段、参数、变量和其他命名实体的名称的代码意味着什么。幸运的是，没有必要担心。这些是受限关键字，意味着它们只在语法期望它们的位置上作为关键字使用。所以，虽然你不能有一个名为
    `package` 的变量或一个名为 `byte` 的模块，但你可以有一个名为 `module` 的变量甚至模块。
- en: NAMING MODULES
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**模块命名**'
- en: The most basic property that JARs are missing is a name that the compiler and
    JVM can use to identify them. So, this is the most prominent characteristic of
    a module. You’ll have the opportunity and even the obligation to give every module
    you create a name.
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JAR 文件缺少的最基本属性是一个编译器和 JVM 可以用来识别它们的名字。因此，这是模块最突出的特征。你将有机会，甚至有义务给你的每个模块起一个名字。
- en: ESSENTIAL INFO In addition to the `module` keyword, a declaration starts by
    giving the module a name. This has to be an identifier, meaning it must adhere
    to the same rules as, for example, a package name. Module names are usually lowercase
    and hierarchically structured with dots.
  id: totrans-568
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**基本信息** 除了 `module` 关键字之外，声明从给模块命名开始。这必须是一个标识符，这意味着它必须遵循与例如包名称相同的规则。模块名称通常是小写的，并以点分层结构。'
- en: Naming a module will be fairly natural, because most tools you use on a daily
    basis already have you name your projects. But although it makes sense to take
    the project name as a springboard on the search for a module name, it’s important
    to choose wisely!
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命名模块将相当自然，因为你在日常生活中使用的多数工具已经让你命名项目了。但是，尽管将项目名称作为寻找模块名称的跳板是有意义的，但选择时仍然很重要！
- en: As you’ll see in section 3.2, the module system leans heavily on a module’s
    name. Conflicting or evolving names in particular cause trouble, so it’s important
    that the name is
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如你在3.2节中看到的，模块系统在很大程度上依赖于模块的名称。特别是冲突或演变的名称会引起问题，因此确保名称是
- en: Globally unique
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局唯一
- en: Stable
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定
- en: The best way to achieve this is to use the reverse-domain naming scheme that’s
    commonly used for packages. Together with the limitations for identifiers, this
    often leads to a module’s name being a prefix of the packages it contains. That
    isn’t mandatory, but it’s a good sign that both were chosen deliberately.
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现这一点的最好方法是使用通常用于包的逆向域名命名方案。结合标识符的限制，这通常导致模块的名称是其包含的包的前缀。这不是强制性的，但这是一个很好的迹象，表明两者都是经过深思熟虑选择的。
- en: Keeping the module name and package name prefix in sync emphasizes that a module
    name change (which would imply a package name change) is one of the most severe
    breaking changes possible. In the interest of stability, it should be an exceedingly
    rare event.
  id: totrans-574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 保持模块名称和包名前缀同步强调，模块名称更改（这会暗示包名更改）是可能的最严重的破坏性更改之一。为了稳定起见，这应该是一个非常罕见的事件。
- en: 'For example, the following descriptor names the module monitor.statistics (to
    keep names succinct, the modules making up the ServiceMonitor application don’t
    follow the reverse-domain naming scheme):'
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，以下描述符命名了模块monitor.statistics（为了使名称简洁，组成ServiceMonitor应用程序的模块不遵循反向域名命名方案）：
- en: '`module monitor.statistics { // requires and exports truncated }`'
  id: totrans-576
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.statistics { // requires and exports truncated }`'
- en: All other properties are defined within the curly braces following the module’s
    name. No particular order is enforced, but it’s common to start off with dependencies
    before coming to exports.
  id: totrans-577
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有其他属性都定义在模块名称后面的花括号内。没有特定的顺序要求，但通常是在定义依赖关系之前先定义导出。
- en: REQUIRING MODULES TO EXPRESS DEPENDENCIES
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过`requires`指令声明依赖关系
- en: Another thing we miss in JARs is the ability to declare dependencies. With JARs,
    we never know what other artifacts they need to run properly, and we depend on
    build tools or documentation to determine that. With the module system, dependencies
    have to be made explicit. (See [figure 3.1](part0016.html#filepos363629) for how
    this plays out.)
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在JARs中，我们缺少声明依赖的能力。使用JARs时，我们永远不知道它们需要哪些其他工件才能正常运行，我们依赖于构建工具或文档来确定这一点。在模块系统中，依赖关系必须明确声明。（参见[图3.1](part0016.html#filepos363629)了解这是如何实现的。）
- en: '![](../images/00005.jpeg)'
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00005.jpeg)'
- en: '[Figure 3.1](part0016.html#filepos363294) Being able to express dependencies
    between modules introduces a new layer of abstraction the JVM can reason about.
    Without them (left), it only sees dependencies between types; but with them (right),
    it sees dependencies between artifacts much as we tend to.'
  id: totrans-581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图3.1](part0016.html#filepos363294) 能够表达模块之间的依赖关系为JVM引入了一个新的抽象层，JVM可以对此进行推理。没有它们（左侧），它只能看到类型之间的依赖关系；但是有了它们（右侧），它看到的是类似于我们倾向于的工件之间的依赖关系。'
- en: 'Definition: Dependencies'
  id: totrans-582
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：依赖关系
- en: Dependencies are declared with `requires` directives, which consist of the keyword
    followed by a module name. The directive states that the declared module depends
    on the named one and requires it during compilation and at run time.
  id: totrans-583
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 依赖关系通过`requires`指令声明，该指令由关键字后跟模块名称组成。该指令表明声明的模块依赖于命名的模块，并在编译和运行时需要它。
- en: 'The monitor.statistics module has a compile-time and runtime dependency on
    monitor.observer, which is declared with a `requires` directive:'
  id: totrans-584
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: monitor.statistics模块在编译时和运行时依赖于monitor.observer，这是通过`requires`指令声明的：
- en: '`module monitor.statistics { requires monitor.observer; // exports truncated
    }`'
  id: totrans-585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.statistics { requires monitor.observer; // exports truncated
    }`'
- en: If a dependency is declared with a `requires` directive, the module system will
    throw an error if it can’t find a module with that exact name. Compiling as well
    as launching an application will fail if modules are missing (see section 3.2).
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果一个依赖关系通过`requires`指令声明，当模块系统找不到具有该确切名称的模块时，它将抛出一个错误。如果缺少模块，编译以及启动应用程序都将失败（参见3.2节）。
- en: EXPORTING PACKAGES TO DEFINE A MODULE’S API
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 导出包以定义模块的API
- en: Last up are exports, which define a module’s public API. Here you can pick and
    choose which packages contain types that should be available outside the module
    and which packages are only meant for internal use.
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后是导出，它定义了一个模块的公共 API。在这里，你可以选择哪些包包含应该对模块外部可用的类型，哪些包仅用于内部使用。
- en: 'Definition: Exported packages'
  id: totrans-589
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：导出包
- en: The keyword `exports` is followed by the name of a package the module contains.
    Only exported packages are usable outside the module; all others are strongly
    encapsulated within it (see section 3.3).
  id: totrans-590
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关键字 `exports` 后跟模块包含的包的名称。只有导出包才可以在模块外部使用；所有其他包都严格封装在模块内部（见第 3.3 节）。
- en: 'The module monitor.statistics exports a package of the same name:'
  id: totrans-591
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块 monitor.statistics 导出一个同名的包：
- en: '`module monitor.statistics { requires monitor.observer; exports monitor.statistics;
    }`'
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.statistics { requires monitor.observer; exports monitor.statistics;
    }`'
- en: Note that even though we like to think they are, packages aren’t hierarchical!
    The package `java.util` doesn’t contain `java.util.concurrent`; accordingly, exporting
    the former doesn’t expose any types in the latter. This is in line with imports,
    where `import java.util.*` will import types all from `java.util` but none from
    `java.util.concurrent` (see [figure 3.2](part0016.html#filepos369110)).
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，尽管我们喜欢认为它们是层级结构的，但包并不是层级结构的！包 `java.util` 不包含 `java.util.concurrent`；因此，导出前者不会暴露后者中的任何类型。这与导入一致，其中
    `import java.util.*` 将导入 `java.util` 中的所有类型，但不会从 `java.util.concurrent` 中导入（见[图
    3.2](part0016.html#filepos369110)）。
- en: '![](../images/00091.jpeg)'
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00091.jpeg)'
- en: '[Figure 3.2](part0016.html#filepos368798) We like to think of packages as hierarchical,
    where `org.junitpioneer` contains `extension` and `vintage` (left). But that isn’t
    the case! Java is only concerned with full package names and sees no relation
    between the two (right). This has to be considered when exporting packages. For
    example, `exports org.junitpioneer` won’t export any of the types in `jupiter`
    or `vintage`.'
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 3.2](part0016.html#filepos368798) 我们喜欢将包视为层级结构，其中 `org.junitpioneer` 包含
    `extension` 和 `vintage`（左）。但这并不是事实！Java 只关心完整的包名，看不到两者之间的任何关系（右）。在导出包时必须考虑这一点。例如，`exports
    org.junitpioneer` 不会导出 `jupiter` 或 `vintage` 中的任何类型。'
- en: This implies that if a module wants to export two packages, it always needs
    two `exports` directives. The module system also offers no wildcards like `exports
    java.util.*` to make that easier—exposing an API should be a deliberate act.
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这意味着如果模块想要导出两个包，它总是需要两个 `exports` 指令。模块系统也不提供通配符如 `exports java.util.*` 来简化这个过程——公开
    API 应该是一个故意的行动。
- en: EXAMPLE MODULE DECLARATIONS
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: EXAMPLE MODULE DECLARATIONS
- en: 'To get your feet wet, let’s look at some real-life module declarations. The
    most fundamental module is java.base, because it contains `java.lang.Object`,
    a class without which no Java program could function. It’s the dependency to end
    all dependencies: all other modules require it, but it requires nothing else.
    The dependency on java.base is so fundamental that modules don’t even have to
    declare it as the module system fills it in automatically (the following section
    goes into more detail). Although it depends on nothing, it exports a whopping
    116 packages, so I’ll only show a heavily truncated version of it:'
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了让你熟悉，让我们看看一些实际的模块声明。最基础的模块是 java.base，因为它包含 `java.lang.Object` 类，没有这个类，任何
    Java 程序都无法运行。这是所有依赖的终结者：所有其他模块都需要它，但它不需要其他任何东西。对 java.base 的依赖如此基本，以至于模块甚至不需要声明它，因为模块系统会自动填充它（下一节将详细介绍）。尽管它没有依赖，但它导出了
    116 个包，所以我只会展示一个高度截断的版本：
- en: '`module java.base { exports java.lang; exports java.math; exports java.nio;
    exports java.util; // many, many more exports // use of fancy features is truncated
    }`'
  id: totrans-599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module java.base { exports java.lang; exports java.math; exports java.nio;
    exports java.util; // 许多许多其他导出 // 精美特性的使用被截断 }`'
- en: 'A much simpler module is java.logging, which exposes the `java.util.logging`
    package:'
  id: totrans-600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个更简单的模块是 java.logging，它公开了 `java.util.logging` 包：
- en: '`module java.logging { exports java.util.logging; }`'
  id: totrans-601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module java.logging { exports java.util.logging; }`'
- en: 'To see a module that requires another, let’s turn to java.rmi. It creates log
    messages and accordingly depends on java.logging for that. The API it exposes
    can be found in `java.rmi` and other packages with that prefix:'
  id: totrans-602
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要查看需要另一个模块的模块，让我们转向 java.rmi。它创建日志消息，因此依赖于 java.logging 来完成这个任务。它公开的 API 可以在
    `java.rmi` 和其他带有该前缀的包中找到：
- en: '``module java.rmi { requires java.logging; exports java.rmi; // exports of
    other `java.rmi.*` packages // use of fancy features is truncated }``'
  id: totrans-603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '``module java.rmi { requires java.logging; exports java.rmi; // 其他 `java.rmi.*`
    包的导出 // 精美特性的使用被截断 }``'
- en: For more examples, flip back to section 2.2.3, particularly the code that declares
    the modules of the ServiceMonitor applications.
  id: totrans-604
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要了解更多示例，请翻回第2.2.3节，特别是声明ServiceMonitor应用程序模块的代码。
- en: 3.1.4 THE MANY TYPES OF MODULES
  id: totrans-605
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.1.4 模块的多种类型
- en: Think of an application you’re working on at the moment. There’s a good chance
    it consists of a number of JARs, which, at some point in the future, will likely
    all be modules. They aren’t the only ones making up the application, though. The
    JDK was also split into modules, and they will become part of your consideration,
    as well. But wait, there’s more! In this set of modules, some have characteristics
    that make it necessary to call them out specifically.
  id: totrans-606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 想想你现在正在工作的应用程序。它很可能由多个JAR文件组成，这些JAR文件在未来某个时刻可能会全部成为模块。但它们并不是构成应用程序的唯一元素。JDK也被分割成模块，它们也将成为你考虑的一部分。但是等等，还有更多！在这个模块集中，一些具有特定特征的模块需要特别指出。
- en: 'Definitions: Module types'
  id: totrans-607
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：模块类型
- en: To avoid an undecipherable mess, the following terms identify certain roles
    and make talking about the modular landscape much clearer. Now’s the time to hunker
    down and learn them. Don’t worry if you don’t memorize all of them at once; bookmark
    the page, and come back to it whenever you encounter a term you’re not sure how
    to interpret (or go straight to the book’s index).
  id: totrans-608
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '为了避免不可解的混乱，以下术语识别了某些角色，并使讨论模块化景观更加清晰。现在是时候坐下来学习它们了。如果你一次记不住所有这些术语，请不要担心；将页面书签，并在遇到不确定如何解释的术语时返回（或直接查看书籍的索引）。 '
- en: Application modules —A non-JDK module; the modules Java developers create for
    their own projects, be they libraries, frameworks, or applications. These are
    found on the module path. For the time being, they will be modular JARs (see section
    3.1.2).
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序模块 — 非JDK模块；Java开发者为他们自己的项目创建的模块，无论是库、框架还是应用程序。这些模块位于模块路径上。目前，它们将是模块化JAR文件（见第3.1.2节）。
- en: 'Initial module —Application module where compilation starts (for `javac`) or
    containing the `main` method (for `java`). Section 5.1.1 shows how to specify
    it when launching the application with the `java` command. The compiler also has
    a use for the concept: as explained in section 4.3.5, it defines which module
    the compilation starts with.'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始模块 — 应用模块，编译从这里开始（对于`javac`）或者包含`main`方法（对于`java`）。第5.1.1节展示了如何使用`java`命令启动应用程序时指定它。编译器也使用这个概念：如第4.3.5节所述，它定义了编译从哪个模块开始。
- en: Root modules —Where the JPMS starts resolving dependencies (a process explained
    in detail in section 3.4.1). In addition to containing the main class or the code
    to compile, the initial module is also a root module. In tricky situations you’ll
    encounter further into the book, it can become necessary to define root modules
    beyond the initial one (as explained in section 3.4.3).
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根模块 — JPMS开始解析依赖的地方（这个过程在第3.4.1节中详细解释）。除了包含主类或要编译的代码外，初始模块也是一个根模块。在书中进一步遇到的复杂情况下，可能需要定义除初始模块之外的根模块（如第3.4.3节所述）。
- en: Platform modules —Modules that make up the JDK. These are defined by the Java
    SE Platform Specification (prefixed with java.) as well as JDK-specific modules
    (prefixed with jdk.). As discussed in section 3.1.1, they’re stored in optimized
    form in a `modules` file in the runtime’s `libs` directory.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台模块 — 构成JDK的模块。这些模块由Java SE平台规范（以java.为前缀）以及JDK特定模块（以jdk.为前缀）定义。如第3.1.1节所述，它们以优化形式存储在运行时的`libs`目录中的`modules`文件中。
- en: Incubator modules —Nonstandard platform modules whose names always start with
    jdk.incubator. They contain experimental APIs that could benefit from being tested
    by adventurous developers before being set in stone.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 孵化器模块 — 非标准平台模块，其名称总是以jdk.incubator开头。它们包含可能从冒险的开发者测试中受益的实验性API。
- en: System modules —In addition to creating a runtime image from a subset of platform
    modules, `jlink` can also include application modules. The platform and application
    modules found in such an image are collectively called its system modules. To
    list them, use the `java` command in the image’s `bin` directory and call `java
    --list-modules`.
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统模块 — 除了从平台模块的子集中创建运行时镜像外，`jlink`还可以包括应用程序模块。这种镜像中找到的平台和应用程序模块统称为其系统模块。要列出它们，请使用镜像的`bin`目录中的`java`命令并调用`java
    --list-modules`。
- en: Observable modules —All platform modules in the current runtime as well as all
    application modules specified on the command line; modules that the JPMS can use
    to fulfill dependencies. Taken together, these modules make up the universe of
    observable modules.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察模块——当前运行时的所有平台模块以及命令行上指定的所有应用程序模块；JPMS可以使用这些模块来满足依赖项。总而言之，这些模块构成了可观察模块的宇宙。
- en: 'Base module —The distinction between application and platform modules exists
    only to make communication easier. To the module system, all modules are the same,
    except one: the platform module java.base, the so-called base module, plays a
    particular role.'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础模块——应用程序和平台模块之间的区别只是为了使通信更容易。对于模块系统来说，所有模块都是相同的，除了一个：平台模块java.base，所谓的基模块，扮演着特定的角色。
- en: 'Platform modules and most application modules have module descriptors that
    are given to them by the module’s creator. Do other modules exist? Yes:'
  id: totrans-617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 平台模块和大多数应用程序模块都有模块描述符，这些描述符是由模块创建者提供的。其他模块存在吗？是的：
- en: Explicit modules —Platform modules and most application modules that have module
    descriptors given to them by the module’s creator.
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确模块——由模块创建者提供模块描述符的平台模块和大多数应用程序模块。
- en: 'Automatic modules —Named modules without a module description (spoiler: plain
    JARs on the module path). These are application modules created by the runtime,
    not a developer.'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动模块——没有模块描述符的命名模块（提示：模块路径上的普通JAR文件）。这些是由运行时创建的应用程序模块，而不是由开发者创建的。
- en: Named modules —The set of explicit modules and automatic modules. These modules
    have a name, either defined by a descriptor or inferred by the JPMS.
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名模块——明确模块和自动模块的集合。这些模块有一个名称，要么由描述符定义，要么由JPMS推断。
- en: 'Unnamed modules —Modules that aren’t named (spoiler: class path content) and
    hence aren’t explicit.'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无名模块——未命名的模块（提示：类路径内容）因此不是明确的。
- en: Both automatic and unnamed modules become relevant in the context of migrating
    an application to the module system—a topic discussed in depth in chapter 8\.
    To get a better sense of how these types of modules relate to one another, see
    [figure 3.3](part0016.html#filepos382602).
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自动模块和无名模块在将应用程序迁移到模块系统的背景下变得相关——这是第8章深入讨论的主题。为了更好地理解这些类型的模块如何相互关联，请参阅[图3.3](part0016.html#filepos382602)。
- en: '![](../images/00113.jpeg)'
  id: totrans-623
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00113.jpeg)'
- en: '[Figure 3.3](part0016.html#filepos382291) Most types of modules, organized
    in a handy diagram. The modules shipped with the JDK are called platform modules,
    with the base module at their center. Then there are application modules, one
    of which must be the initial module, which contains the application’s `main` method.
    (Root, system, and incubator modules aren’t shown.)'
  id: totrans-624
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图3.3](part0016.html#filepos382291) 大多数类型的模块，组织在一个方便的图表中。与JDK一起提供的模块称为平台模块，基模块位于中心。然后是应用程序模块，其中必须有一个是初始模块，它包含应用程序的`main`方法。（根、系统和孵化模块未显示。）'
- en: To apply these terms to an example, let’s turn to the ServiceMonitor application
    we explored in chapter 2\. It consists of seven modules (monitor, monitor.observer,
    monitor.rest, and so forth) plus the external dependencies Spark and Hibernate
    and their transitive dependencies.
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了将这些术语应用到例子中，让我们转向第2章中我们探讨的ServiceMonitor应用程序。它由七个模块（monitor、monitor.observer、monitor.rest等等）以及外部依赖项Spark和Hibernate及其传递依赖项组成。
- en: When it’s launched, the folders containing its seven modules and its dependencies
    are specified on the command line. Together with the platform modules in the JRE
    or JDK that’s running the application, they form the universe of observable modules.
    This is the pool of modules from which the module system will try to fulfill all
    dependencies.
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当它启动时，包含其七个模块及其依赖项的文件夹在命令行上指定。与运行应用程序的JRE或JDK中的平台模块一起，它们构成了可观察模块的宇宙。这是模块系统将尝试满足所有依赖项的模块池。
- en: ServiceMonitor’s modules as well as those making up its dependencies, Hibernate
    and Spark, are the application modules. Because it contains the `main` method,
    monitor is the initial module—no other root modules are required. The only platform
    module the program depends on directly is the base module java.base, but Hibernate
    and Spark pull in further modules like java.sql and java.xml. Because this is
    a brand-new application and all dependencies are assumed to be modularized, this
    isn’t a migration scenario; hence, no automatic or unnamed modules are involved.
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ServiceMonitor的模块以及构成其依赖关系的Hibernate和Spark都是应用程序模块。因为它包含`main`方法，所以监控器是初始模块——不需要其他根模块。程序直接依赖的唯一平台模块是基础模块java.base，但Hibernate和Spark会引入进一步的模块，如java.sql和java.xml。因为这是一个全新的应用程序，并且所有依赖关系都被假定为模块化，这不是一个迁移场景；因此，没有涉及自动或未命名的模块。
- en: Now that you know what types of modules exist and how to declare them, it’s
    time to explore how Java processes this information.
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在你已经知道了存在哪些类型的模块以及如何声明它们，是时候探索Java如何处理这些信息了。
- en: '3.2 Readability: Connecting the pieces'
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.2 可读性：连接各个部分
- en: 'Modules are the atomic building blocks: the nodes in a graph of interacting
    artifacts. But there can be no graph without edges connecting the nodes! This
    is where readability comes in, based on which the module system will create connections
    between nodes.'
  id: totrans-630
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块是原子构建块：交互工件图中的节点。但没有节点之间的边，就无法形成图！这就是可读性发挥作用的地方，基于此，模块系统将在节点之间创建连接。
- en: 'Definition: Readability edge'
  id: totrans-631
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：可读性边
- en: When a module customer requires a module bar in its declaration, then at run
    time customer will read bar or, conversely, bar will be readable by customer (see
    [figure 3.4](part0016.html#filepos388330)). The connection between the two modules
    is called a readability edge, or reads edge for short.
  id: totrans-632
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当模块客户在其声明中需要模块bar时，则在运行时客户将读取bar，或者相反，bar将由客户可读（参见[图3.4](part0016.html#filepos388330)）。两个模块之间的连接称为可读性边，或简称为读取边。
- en: '![](../images/00081.jpeg)'
  id: totrans-633
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00081.jpeg)'
- en: '[Figure 3.4](part0016.html#filepos388145) The module customer requires the
    module bar in its descriptor (1). Based on that, the module system will let customer
    read bar at run time (2).'
  id: totrans-634
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图3.4](part0016.html#filepos388145) 模块客户在其描述符中需要模块bar（1）。基于此，模块系统将允许客户在运行时读取bar（2）。'
- en: 'Whereas phrases like “customer requires bar” and “customer depends on bar”
    mirror a static, compile-time relationship between customer and bar, readability
    is its more dynamic, runtime counterpart. Why is it more dynamic? The `requires`
    directive is the primal originator of reads edges, but it’s by no means the only
    one. Others are command-line options (see `--add-reads` in section 3.4.4) and
    the reflection API (see section 12.3.4), both of which can be used to add more;
    in the end, it’s irrelevant. Regardless of how reads edges come to be, their effects
    are always the same: they’re the basis for reliable configuration and accessibility
    (see section 3.3).'
  id: totrans-635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 而“客户需要bar”和“客户依赖于bar”这样的短语反映了客户和bar之间的静态、编译时关系，而可读性则是其更动态的运行时对应物。为什么它更动态？`requires`指令是读取边的原始发起者，但绝非唯一。其他还有命令行选项（参见第3.4.4节中的`--add-reads`）和反射API（参见第12.3.4节），都可以用来添加更多；最终，这并不重要。无论读取边是如何产生的，它们的效果总是相同的：它们是可靠配置和可访问性的基础（参见第3.3节）。
- en: 3.2.1 ACHIEVING RELIABLE CONFIGURATION
  id: totrans-636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.2.1 实现可靠的配置
- en: As described in section 1.5.1, reliable configuration aims to ensure that the
    particular configuration of artifacts a Java program is compiled against or launched
    with can sustain the program without spurious runtime errors. To this end, it
    performs a couple of checks (during module resolution, a process explained in
    section 3.4.1).
  id: totrans-637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如第1.5.1节所述，可靠的配置旨在确保Java程序编译或启动时使用的特定工件配置能够维持程序运行，而不会出现虚假的运行时错误。为此，它执行了一些检查（在模块解析过程中，该过程在第3.4.1节中解释）。
- en: 'ESSENTIAL INFO The module system checks whether the universe of observable
    modules contains all required dependencies, direct and transitive, and reports
    an error if something’s missing. There must be no ambiguity: no two artifacts
    can claim they’re the same module. This is particularly interesting in the case
    where two versions of the same module are present—because the module system has
    no concept of versions (see chapter 13), it treats this as a duplicate module.
    Accordingly, it reports an error if it runs into this situation. There must be
    no static dependency cycles between modules. At run time, it’s possible and even
    necessary for modules to access each other (think about code using Spring annotations
    and Spring reflecting over that code), but these must not be compile dependencies
    (Spring is obviously not compiled against the code it reflects over). Packages
    should have a unique origin, so no two modules must contain types in the same
    package. If they do, this is called a split package, and the module system will
    refuse to compile or launch such configurations. This is particularly interesting
    in the context of migration because some existing libraries and frameworks split
    packages on purpose (see section 7.2).'
  id: totrans-638
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**基本信息** 模块系统检查可观察模块的宇宙是否包含所有必需的依赖项，包括直接和间接依赖项，如果缺少任何内容，则会报告错误。绝对不能有歧义：没有两个工件可以声称它们是同一个模块。这在存在同一模块的两个版本的情况下尤其有趣——因为模块系统没有版本的概念（见第13章），它将此视为重复的模块。因此，如果遇到这种情况，它会报告错误。模块之间不能存在静态依赖循环。在运行时，模块之间相互访问是可能的，甚至是必要的（例如，考虑使用Spring注解的代码和Spring对该代码的反射），但这些不能是编译依赖项（Spring显然没有针对它所反射的代码进行编译）。包应该有唯一的来源，因此没有两个模块必须包含同一包中的类型。如果它们这样做，这被称为拆分包，模块系统将拒绝编译或启动此类配置。这在迁移的上下文中尤其有趣，因为一些现有的库和框架故意拆分包（见第7.2节）。'
- en: This verification of course isn’t airtight, and it’s possible for problems to
    hide long enough to crash a running application. If, for example, the wrong version
    of a module ends up in the right place, the application will launch (all required
    modules are present) but will crash later, when, for example, a class or method
    is missing.
  id: totrans-639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当然，这种验证并不是无懈可击的，问题可能隐藏足够长的时间，以至于导致正在运行的应用程序崩溃。例如，如果模块的错误版本最终出现在正确的位置，应用程序将启动（所有必需的模块都存在），但稍后，例如，当类或方法缺失时，将崩溃。
- en: Because the module system is developed to exhibit consistent behavior across
    compile time and run time, these errors can be further minimized by basing compilation
    and launch on the same artifacts. (In the example, the compilation against the
    module with the wrong version would have failed.)
  id: totrans-640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于模块系统是为了在编译时间和运行时展示一致的行为而开发的，因此可以通过基于相同的工件进行编译和启动来进一步最小化这些错误。（在示例中，针对具有错误版本的模块的编译将失败。）
- en: 3.2.2 EXPERIMENTING WITH UNRELIABLE CONFIGURATIONS
  id: totrans-641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.2.2 **尝试不可靠的配置**
- en: Let’s try to break things! What are some unreliable configurations the module
    system detects? To investigate, we’ll turn to the ServiceMonitor application introduced
    in chapter 2.
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们尝试破坏一些东西！模块系统检测到哪些不可靠的配置？为了调查，我们将转向第2章中引入的ServiceMonitor应用程序。
- en: MISSING DEPENDENCIES
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**缺少依赖项**'
- en: 'Consider monitor.observer.alpha and its declaration:'
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑monitor.observer.alpha及其声明：
- en: '`module monitor.observer.alpha { requires monitor.observer; exports monitor.observer.alpha;
    }`'
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.observer.alpha { requires monitor.observer; exports monitor.observer.alpha;
    }`'
- en: 'This is what it looks like to try to compile it with monitor.observer missing:'
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这就是尝试编译时缺少monitor.observer监视器的情况：
- en: '`> monitor.observer.alpha/src/main/java/module-info.java:2: > error: module
    not found: monitor.observer > requires monitor.observer > ^ > 1 error`'
  id: totrans-647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> monitor.observer.alpha/src/main/java/module-info.java:2: > error: 模块未找到:
    monitor.observer > requires monitor.observer > ^ > 1 error`'
- en: 'If the module is present at compile time but gets lost on the way to the launch
    pad, the JVM will quit with the following error:'
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果模块在编译时存在，但在到达发射台的过程中丢失，JVM将使用以下错误退出：
- en: '`> Error occurred during initialization of boot layer > java.lang.module.FindException:
    > Module monitor.observer not found, > required by monitor.observer.alpha`'
  id: totrans-649
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 初始化引导层时发生错误 > java.lang.module.FindException: > 模块monitor.observer未找到， >
    由monitor.observer.alpha所需`'
- en: Although it makes sense to enforce the presence of all transitively required
    modules at launch time, the same can’t be said for the compiler. Accordingly,
    if an indirect dependency is missing, the compiler emits neither a warning nor
    an error, as you can see in the following example.
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然在启动时强制所有传递性所需的模块存在是有意义的，但对于编译器来说则不然。因此，如果缺少间接依赖项，编译器既不会发出警告也不会报错，如下面的示例所示。
- en: 'These are the module declarations of monitor.persistence and monitor.statistics:'
  id: totrans-651
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些是 monitor.persistence 和 monitor.statistics 的模块声明：
- en: '`module monitor.persistence { requires monitor.statistics; exports monitor.persistence;
    }  module monitor.statistics { requires monitor.observer; exports monitor.statistics;
    }`'
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.persistence { requires monitor.statistics; exports monitor.persistence;
    }  module monitor.statistics { requires monitor.observer; exports monitor.statistics;
    }`'
- en: It’s clear that monitor.persistence doesn’t require monitor.observer directly,
    so compilation of monitor.persistence succeeds even if monitor.observer isn’t
    on the module path.
  id: totrans-653
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 很明显，monitor.persistence 并不直接需要 monitor.observer，因此即使 monitor.observer 不在模块路径上，monitor.persistence
    的编译也能成功。
- en: Launching an application with a missing transitive dependency won’t work. Even
    if the initial module doesn’t directly depend on it, some other module does, so
    it will be reported as missing. The branch `break-missing-transitive-dependency`
    in the ServiceMonitor repository creates a configuration where a missing module
    leads to an error message.
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果启动应用程序时缺少传递性依赖项，则无法工作。即使初始模块不直接依赖于它，其他模块可能会，因此它将被报告为缺失。ServiceMonitor 仓库中的
    `break-missing-transitive-dependency` 分支创建了一个配置，其中缺失的模块会导致错误信息。
- en: DUPLICATE MODULES
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重复模块**'
- en: Because modules reference one another by name, any situation where two modules
    claim to have the same name is ambiguous. Which one is correct to pick is highly
    dependent on the context and not something the module system can generally decide.
    So instead of making a potentially bad decision, it makes none at all, and instead
    produces an error. Failing fast like this allows the developer to notice the problem
    and fix it before it causes any more issues.
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于模块通过名称相互引用，任何两个模块声称具有相同名称的情况都是模糊的。选择哪个是正确的非常依赖于上下文，并且不是模块系统通常可以决定的。因此，为了避免可能的不良决策，它根本不做出任何决定，而是产生一个错误。快速失败允许开发者在问题造成更多问题之前注意到并修复它。
- en: 'This is the compile error the module system produces when trying to compile
    a module with two variants of monitor.observer.beta on the module path:'
  id: totrans-657
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是模块系统在尝试编译模块路径上具有两个版本的 monitor.observer.beta 时产生的编译错误：
- en: '`> error: duplicate module on application module path > module in monitor.observer.beta
    > 1 error`'
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 错误：应用程序模块路径上的重复模块 > module in monitor.observer.beta > 1 error`'
- en: Note that the compiler can’t link the error to one of the files under compilation
    because they aren’t the reason for the problem. Instead, the artifacts on the
    module path are causing the error.
  id: totrans-659
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，编译器无法将错误链接到编译下的任何文件，因为它们不是问题的原因。相反，模块路径上的工件导致了错误。
- en: 'When the error goes undetected until the JVM is launched, it gives a more precise
    message that lists the JAR filenames as well:'
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当错误直到 JVM 启动时才被发现，它会提供一个更精确的消息，列出 JAR 文件名：
- en: '`> Error occurred during initialization of boot layer > java.lang.module.FindException:
    > Two versions of module monitor.observer.beta found in mods > (monitor.observer.beta.jar
    and monitor.observer.gamma.jar)`'
  id: totrans-661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 初始化引导层时发生错误 > java.lang.module.FindException: > 在 mods 中找到两个版本的模块 monitor.observer.beta
    > (monitor.observer.beta.jar 和 monitor.observer.gamma.jar)`'
- en: As we discussed in section 1.5.6 and further explored in section 13.1, the module
    system has no concept of versions, so in this case the same error will occur.
    I’d say it’s a good guess that the vast majority of duplicate-module errors will
    be caused by having the same module in several versions on the module path.
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如我们在第 1.5.6 节中讨论的，并在第 13.1 节中进一步探讨的那样，模块系统没有版本的概念，因此在这种情况下，将发生相同的错误。我认为，绝大多数重复模块错误将是由模块路径上存在相同模块的多个版本引起的。
- en: ESSENTIAL INFO Ambiguity checks are only applied to individual module path entries!
    (That sentence may leave you scratching your head—I’ll explain what I mean in
    section 3.4.1, but I wanted to mention it here so this important fact isn’t left
    out.)
  id: totrans-663
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 模糊性检查仅应用于单个模块路径条目！（这句话可能会让你感到困惑——我将在第 3.4.1 节中解释我的意思，但我想在这里提一下，以免遗漏这个重要的事实。）'
- en: The module system also throws the duplicate module error if the module isn’t
    actually required. It suffices that the module path contains it! Two of the reasons
    for that are services and optional dependencies, which are presented in chapter
    10 and section 11.2\. The ServiceMonitor branch `break-duplicate-modules-even-if-unrequired`
    creates an error message due to a duplicate module even though it isn’t required.
  id: totrans-664
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果模块实际上并不需要，模块系统也会抛出重复模块错误。只要模块路径包含它就足够了！其中两个原因是服务和可选依赖项，这些将在第10章和第11.2节中介绍。ServiceMonitor分支`break-duplicate-modules-even-if-unrequired`即使不需要也会因为重复模块而创建错误信息。
- en: DEPENDENCY CYCLES
  id: totrans-665
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: DEPENDENCY CYCLES
- en: Accidentally creating cyclic dependencies isn’t hard, but getting them past
    the compiler is. It isn’t even straightforward to present them to the compiler.
    In order to do that, you’d have to solve the chicken-and-egg problem that if two
    projects depend on each other, it isn’t possible to compile one without the other.
    If you tried, you’d have missing dependencies and get the corresponding errors.
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 意外创建循环依赖并不难，但让编译器通过它却很难。甚至很难向编译器展示它们。为了做到这一点，你必须解决“先有鸡还是先有蛋”的问题，即如果两个项目相互依赖，那么不可能在没有另一个项目的情况下编译其中一个。如果你尝试这样做，你会遇到缺失的依赖项并得到相应的错误。
- en: 'One way to get past this is to compile both modules at once, starting with
    both the chicken and the egg at the same time, so to speak; section 4.3 explains
    how. Suffice it to say, if there’s a cyclic dependency between the modules being
    compiled, the module system recognizes that and causes a compile error. This is
    how it looks if monitor.persistence and monitor.statistics depend on each other:'
  id: totrans-667
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一种绕过这个问题的方法是同时编译两个模块，从鸡和蛋同时开始，换句话说；第4.3节解释了如何做到这一点。简单来说，如果在编译的模块之间存在循环依赖，模块系统会识别出来并导致编译错误。如果monitor.persistence和monitor.statistics相互依赖，它看起来是这样的：
- en: '`> monitor.statistics/src/main/java/module-info.java:3: > error: cyclic dependence
    involving monitor.persistence > requires monitor.persistence; > ^ > 1 error`'
  id: totrans-668
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> monitor.statistics/src/main/java/module-info.java:3: > 错误：涉及monitor.persistence的循环依赖
    > requires monitor.persistence; > ^ > 1个错误`'
- en: 'Another way to go about this is to establish the cyclic dependency not at once
    but over time, after a valid configuration is already built. Let’s once more turn
    to monitor.persistence and monitor.statistics:'
  id: totrans-669
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一种方法是逐步建立循环依赖，而不是一次性建立，在已经构建了有效配置之后。让我们再次转向monitor.persistence和monitor.statistics：
- en: '`module monitor.persistence { requires monitor.statistics; exports monitor.persistence;
    }  module monitor.statistics { requires monitor.observer; exports monitor.statistics;
    }`'
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.persistence { requires monitor.statistics; exports monitor.persistence;
    }  module monitor.statistics { requires monitor.observer; exports monitor.statistics;
    }`'
- en: 'This configuration is fine and compiles without problems. Now the trickery
    begins: compile the modules and keep the JARs around. Then change the module declaration
    of monitor.statistics to require monitor.persistence, which creates a cyclic dependency
    (the change doesn’t make much sense in this example, but in more-complex applications
    it often does):'
  id: totrans-671
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个配置没有问题，编译时没有出现任何问题。现在开始有点复杂了：编译模块并保留JAR文件。然后更改monitor.statistics模块的声明，使其需要monitor.persistence，这会创建一个循环依赖（在这个例子中，这种改变并没有太多意义，但在更复杂的应用程序中通常会有意义）：
- en: '`module monitor.statistics { requires monitor.observer; requires monitor.persistence;
    exports monitor.statistics; }`'
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.statistics { requires monitor.observer; requires monitor.persistence;
    exports monitor.statistics; }`'
- en: The next step is to compile just the changed monitor.statistics with the already-compiled
    modules on the module path. This must include monitor.persistence, because the
    statistics module now depends on it. In turn, the persistence module still declares
    its dependency on monitor.statistics, which is the second half of the dependency
    cycle. Unfortunately, for this round of hacking, the module system recognizes
    the cycle and causes the same compile error as before.
  id: totrans-673
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 下一步是仅编译已更改的monitor.statistics，同时使用模块路径上的已编译模块。这必须包括monitor.persistence，因为统计模块现在依赖于它。反过来，持久化模块仍然声明它对monitor.statistics的依赖，这是依赖循环的第二部分。不幸的是，对于这次黑客攻击，模块系统识别出这个循环并导致与之前相同的编译错误。
- en: 'Taking the shell game to the next level finally tricks the compiler. In this
    scenario, two completely unrelated modules—let’s pick monitor.persistence and
    monitor.rest —are compiled into modular JARs. Then comes the sleight of hand:'
  id: totrans-674
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将“偷壳游戏”提升到下一个层次最终欺骗了编译器。在这个场景中，两个完全无关的模块——让我们选择monitor.persistence和monitor.rest——被编译成模块化的JAR文件。然后是魔术表演：
- en: One dependency is added, say from persistence to rest, and the changed persistence
    is compiled against the original set of modules. This works because the original
    rest doesn’t depend on persistence.
  id: totrans-675
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 添加一个依赖关系，例如从持久化到rest，并且更改后的持久化针对原始模块集进行编译。这是因为原始的rest不依赖于持久化。
- en: The second dependency, rest to persistence, is added, but rest is also compiled
    against the original set of modules, including the version of persistence that
    doesn’t yet depend on it. As a consequence, it can be compiled as well.
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 添加第二个依赖关系，即从rest到持久化，但rest也针对包括尚未依赖它的持久化版本在内的原始模块集进行编译。因此，它也可以被编译。
- en: Confused? Look at [figure 3.5](part0016.html#filepos410054) to get another perspective.
  id: totrans-677
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 感到困惑？查看[图3.5](part0016.html#filepos410054)以获得另一个视角。
- en: '![](../images/00026.jpeg)'
  id: totrans-678
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00026.jpeg)'
- en: '[Figure 3.5](part0016.html#filepos409716) Getting dependency cycles past the
    compiler isn’t easy. Here it’s done by picking two unrelated modules, persistence
    and rest (both depend on statistics), and then adding dependencies from one to
    the other. It’s important to compile rest against the old persistence so the cycle
    doesn’t show and compilation passes. In a final step, both original modules can
    be replaced with the newly compiled ones that have the cyclic dependency between
    them.'
  id: totrans-679
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图3.5](part0016.html#filepos409716) 将依赖关系循环传递给编译器并不容易。这里是通过选择两个无关的模块，持久化和rest（两者都依赖于统计），然后从其中一个模块添加依赖到另一个模块来完成的。编译rest时，必须针对旧的持久化版本，这样循环就不会显示，并且编译可以通过。在最后一步，两个原始模块都可以用它们之间具有循环依赖关系的新编译版本来替换。'
- en: 'Now there are versions of monitor.persistence and monitor.rest that depend
    on each other. For this to happen in real life, the compilation process—maybe
    managed by a build tool—must be in serious disarray (but that isn’t unheard of).
    Luckily, the module system has your back and reports the error when the JVM is
    launched with such a configuration:'
  id: totrans-680
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在monitor.persistence和monitor.rest的版本相互依赖。要使这种情况在现实生活中发生，编译过程——可能由构建工具管理——必须处于严重混乱状态（但这并非闻所未闻）。幸运的是，模块系统支持你，并在使用这种配置启动JVM时报告错误：
- en: '`> Error occurred during initialization of boot layer > java.lang.module.FindException:
    > Cycle detected: > monitor.persistence > -> monitor.rest > -> monitor.persistence`'
  id: totrans-681
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 初始化引导层时发生错误 > java.lang.module.FindException: > 检测到循环： > monitor.persistence
    > -> monitor.rest > -> monitor.persistence`'
- en: All the examples show a cyclic dependency between two artifacts, but the module
    system detects cycles of all lengths. It’s good that it does! Changing code always
    risks breaking upstream functionality, meaning other code that uses the code that’s
    being changed—either directly or transitively.
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有示例都显示了两个工件之间的循环依赖关系，但模块系统可以检测到所有长度的循环。这样做是好事！更改代码总是存在破坏上游功能的风险，这意味着使用正在更改的代码的其他代码——无论是直接还是间接的。
- en: If dependencies go in one direction, there’s only so much code a change can
    impact. On the other hand, if dependencies can form cycles, then all code in that
    cycle and all that depends on it can be affected. Particularly if cycles are large,
    this can quickly turn into all the code being affected, and I’m sure you agree
    you want to avoid that. And the module system isn’t alone in helping you here—so
    is your build tool, which also bristles at dependency cycles.
  id: totrans-683
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果依赖关系只有一个方向，那么更改影响的代码量是有限的。另一方面，如果依赖关系可以形成循环，那么循环中的所有代码以及依赖于它的所有代码都可能受到影响。尤其是如果循环很大，这可能会迅速变成所有代码都受到影响，我相信你也会同意你想避免这种情况。模块系统并不是唯一帮助你在这里的工具——你的构建工具也是如此，它也会对依赖关系循环感到不满。
- en: SPLIT PACKAGES
  id: totrans-684
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 拆分包
- en: A split package occurs when two modules contain types in the same package. For
    example, recall that the monitor.statistics module contains a class `Statistician`
    in the `monitor.statistics` package. Now let’s assume the monitor module contained
    a simple fallback implementation, `SimpleStatistician`, and to promote uniformity,
    it’s in monitor’s own `monitor.statistics` package.
  id: totrans-685
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当两个模块包含同一包中的类型时，会发生拆分包的情况。例如，回想一下，monitor.statistics模块在`monitor.statistics`包中包含一个名为`Statistician`的类。现在让我们假设monitor模块包含一个简单的回退实现，`SimpleStatistician`，为了促进一致性，它位于monitor自己的`monitor.statistics`包中。
- en: 'When trying to compile monitor, you get the following error:'
  id: totrans-686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当尝试编译monitor时，你会得到以下错误：
- en: '`> monitor/src/main/java/monitor/statistics/SimpleStatistician.java:1: > error:
    package exists in another module: monitor.statistics > package monitor.statistics;
    > ^ > 1 error`'
  id: totrans-687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> monitor/src/main/java/monitor/statistics/SimpleStatistician.java:1: > 错误：另一个模块中存在相同的包：monitor.statistics
    > package monitor.statistics; > ^ > 1 错误`'
- en: ESSENTIAL INFO Interestingly, the compiler shows an error only if the module
    under compilation can access the split package in the other module. That means
    the split package must be exported.
  id: totrans-688
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 有趣的是，编译器只有在编译的模块可以访问另一个模块中的分割包时才会显示错误。这意味着分割包必须被导出。'
- en: 'To try this, let’s go a different route: `SimpleStatistician` is gone, and
    this time it’s monitor.statistics that creates the split package. In an attempt
    to reuse some utility methods, it creates a `Utils` class in the `monitor` package.
    It has no desire to share that class with other modules, so it continues to only
    export the `monitor.statistics` package.'
  id: totrans-689
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了尝试这一点，让我们走一条不同的路线：`SimpleStatistician`已经不存在了，这次是`monitor.statistics`创建了分割包。为了尝试重用一些实用方法，它在`monitor`包中创建了一个`Utils`类。它没有意愿与其他模块共享这个类，因此它继续只导出`monitor.statistics`包。
- en: Compiling monitor.statistics is error-free, which makes sense because it doesn’t
    require monitor and is hence unaware of the split package. It gets interesting
    when the time comes to compile monitor. It depends on monitor.statistics, and
    both contain types in the package `monitor`. But, as I just mentioned, because
    monitor.statistics doesn’t export the package, compilation works.
  id: totrans-690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编译`monitor.statistics`没有错误，这是有道理的，因为它不需要`monitor`，因此对分割包一无所知。当编译`monitor`的时候，情况变得有趣。它依赖于`monitor.statistics`，并且两者都包含`monitor`包中的类型。但是，正如我刚才提到的，因为`monitor.statistics`没有导出包，编译才能正常工作。
- en: 'Great! Now it’s time to launch:'
  id: totrans-691
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 太好了！现在到了启动的时候：
- en: '`> Error occurred during initialization of boot layer > java.lang.reflect.LayerInstantiationException:
    > Package monitor in both module monitor.statistics and module monitor`'
  id: totrans-692
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 初始化引导层时发生错误 > java.lang.reflect.LayerInstantiationException: > 模块监控器在模块
    monitor.statistics 和模块 monitor 中存在`'
- en: 'That didn’t go well. The module system checks for split packages on launch,
    and here it doesn’t matter whether they’re exported or not: no two modules can
    contain types in the same package. As you’ll see in section 7.2, this can turn
    into a problem when migrating code to Java 9.'
  id: totrans-693
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这并不顺利。模块系统在启动时检查分割包，并且这里无论它们是否导出都无关紧要：没有两个模块可以包含同一包中的类型。正如你在第7.2节中看到的，当将代码迁移到Java
    9时，这可能会变成一个问题。
- en: The ServiceMonitor repository demonstrates the split-package problem at compile
    and at run time in the branches `break-split-package-compilation` and `break-split-package-launch`.
  id: totrans-694
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ServiceMonitor仓库在`break-split-package-compilation`和`break-split-package-launch`分支中展示了编译和运行时分割包问题的示例。
- en: THE MODULAR DIAMOND OF DEATH
  id: totrans-695
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**模块化的死亡钻石**'
- en: '![](../images/00087.jpeg)'
  id: totrans-696
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00087.jpeg)'
- en: '[Figure 3.6](part0016.html#filepos420665) If a module changes its name (here,
    jackson to johnson), projects that depend on it twice (here, app via frame and
    border) can end up facing the modular diamond of death: They depend on the same
    project but by two different names.'
  id: totrans-697
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图3.6](part0016.html#filepos420665) 如果一个模块更改了其名称（这里，从jackson更改为johnson），依赖于它的项目（这里，通过frame和border的app）可能会面临模块化的死亡钻石：它们依赖于同一个项目，但通过两个不同的名称。'
- en: 'A particularly devious mixture of split packages and missing dependencies is
    the modular diamond of death (see [figure 3.6](part0016.html#filepos419567)).
    Assume a module changed its name between two releases: one of your dependencies
    requires it by its old name, and another dependency requires it by its new name.
    Now you need the same code to appear under two different module names, but the
    JPMS isn’t going to let that happen.'
  id: totrans-698
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 分割包和缺失依赖项的特别狡猾的混合体是模块化的死亡钻石（见[图3.6](part0016.html#filepos419567)）。假设一个模块在两个版本之间更改了名称：你的一个依赖项通过其旧名称需要它，另一个依赖项通过其新名称需要它。现在你需要相同的代码出现在两个不同的模块名称下，但JPMS不会允许这种情况发生。
- en: 'You’ll have one of the following situations:'
  id: totrans-699
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你会遇到以下情况之一：
- en: One modular JAR, which can only appear as one module with one name and will
    thus trigger an error because one dependency couldn’t be fulfilled
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模块化的JAR文件，它只能作为一个具有一个名称的模块出现，因此将触发错误，因为一个依赖项无法满足
- en: Two modular JARs with different names but the same packages, which will cause
    the split-package error you just observed
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个具有不同名称但相同包的模块化JAR文件，这将导致你刚刚观察到的分割包错误
- en: ESSENTIAL INFO You should avoid this situation at all costs! If you’re publishing
    artifacts to a public repository, you should carefully consider whether renaming
    your module is necessary. If it is, you may also want to change the package names,
    so people can use old and new modules side by side. If you end up in this situation
    as a user, you may be lucky to get away with creating an aggregator module (see
    section 11.1.5) or editing module descriptors (see section 9.3.3).
  id: totrans-702
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的是要避免这种情况！如果你正在向公共仓库发布工件，你应该仔细考虑是否需要重命名你的模块。如果是的话，你可能还希望更改包名，这样人们就可以同时使用旧模块和新模块。如果你作为用户最终处于这种情况，你可能很幸运地通过创建聚合模块（见11.1.5节）或编辑模块描述符（见9.3.3节）来摆脱困境。
- en: '3.3 Accessibility: Defining public APIs'
  id: totrans-703
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.3 可访问性：定义公共API
- en: 'With modules and the read edges in place, you know how the module system constructs
    the graph you have in mind. To keep that graph from behaving like the ball of
    mud you wanted to escape, there’s one more requirement: the ability to hide a
    module’s internals so no outside code can access it. This is where accessibility
    comes in.'
  id: totrans-704
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在模块和读取边已经就位的情况下，你知道模块系统是如何构建你心中所想的图的。为了防止这个图表现得像你想要逃离的泥球，还有一个额外的要求：隐藏模块内部结构，以便外部代码无法访问它。这就是可访问性的作用所在。
- en: 'Definition: Accessibility'
  id: totrans-705
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：可访问性
- en: 'A type `Drink` in a module bar is accessible to code in a module customer if
    all of the following conditions are fulfilled (see [figure 3.7](part0016.html#filepos425475)):'
  id: totrans-706
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果以下所有条件都得到满足，模块bar中的类型`Drink`对模块customer中的代码是可访问的（参见[图3.7](part0016.html#filepos425475)）：
- en: '`Drink` is public.'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Drink` 是公共的。'
- en: '`Drink` belongs to a package that bar exports.'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Drink` 属于bar导出的包。'
- en: customer reads bar.
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: customer读取bar。
- en: 'For an accessible type’s members (meaning its fields, methods, and nested classes),
    the usual visibility rules hold: public members are fully accessible, and protected
    members only to inheriting classes. Technically, package-private members are accessible
    in the same package, but as you saw in the previous section, that isn’t helpful
    due to the rule against split packages across modules.'
  id: totrans-710
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于可访问类型的成员（意味着它的字段、方法和嵌套类），通常的可见性规则适用：公共成员是完全可访问的，受保护成员仅限于继承类。技术上讲，包私有成员在同一包中是可访问的，但正如你在上一节中看到的，由于模块间不允许分割包的规则，这并不有用。
- en: '![](../images/00020.jpeg)'
  id: totrans-711
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00020.jpeg)'
- en: '[Figure 3.7](part0016.html#filepos424201) The module bar contains a public
    type `Drink` (1) in an exported package (2). The module customer reads the module
    bar (3), so all requirements are fulfilled for code in customer to access `Drink`.
    Want to know what happens if some aren’t fulfilled? Check section 3.3.3.'
  id: totrans-712
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图3.7](part0016.html#filepos424201) 模块bar在一个导出包中包含一个公共类型`Drink`（1）。模块customer读取模块bar（3），因此customer中的代码访问`Drink`的所有要求都得到了满足。想知道如果某些要求没有得到满足会发生什么？请查看3.3.3节。'
- en: NOTE The definition of accessibility includes the module that wants to access
    the type. In this sense, a type is never “accessible” but only “accessible to
    a particular module.” It’s common, though, to use the same term even if no other
    module is in sight and say that a type is accessible if it’s public and in an
    exported package. Any module is then free to access the type by reading the module
    that contains it.
  id: totrans-713
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：可访问性的定义包括想要访问类型的模块。从这个意义上说，一个类型永远不会“可访问”，而只能是“对特定模块可访问”。尽管如此，当没有其他模块可见时，人们通常使用相同的术语，并说如果一个类型是公共的且在导出包中，那么它是可访问的。然后任何模块都可以通过读取包含它的模块来自由访问该类型。
- en: 'To understand how accessibility shapes a module’s public API, it’s important
    to understand that term first: what is the public API?'
  id: totrans-714
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要理解可访问性如何塑造模块的公共API，首先理解这个术语很重要：什么是公共API？
- en: 'Definition: Public API'
  id: totrans-715
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：公共API
- en: 'In nontechnical terms, a module’s public API is everything that can’t be changed
    without causing compile errors in code that uses it. (In general, the term also
    includes a specification of runtime behavior, but because the module system doesn’t
    operate in that dimension, I’ll ignore it in this book.) More technically speaking,
    a module’s public API consists of the following:'
  id: totrans-716
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用非技术术语来说，模块的公共API是所有不能在不引起使用它的代码编译错误的情况下更改的内容。（一般来说，这个术语还包括运行时行为的规范，但由于模块系统不在这个维度上操作，我在本书中会忽略它。）更技术地说，模块的公共API包括以下内容：
- en: Names of all public types in exported packages
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有导出包中的公共类型名称
- en: Names and type names of public and protected fields
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共和受保护字段的名称和类型名称
- en: Names, argument type names, and return type names of all public and protected
    methods (called method signatures)
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有公共和受保护方法的名称、参数类型名称和返回类型名称（称为方法签名）
- en: 'In case you find it weird that I’m suddenly talking about names, think about
    what you can change in a type while keeping dependent code from outside the package
    compiling. Private and package-visible fields? Definitely! Private and package-visible
    methods? Sure. Bodies of public methods? Yes. What needs to stay untouched are
    the names of everything that other code may be compiled against: the type’s name,
    the signature of public methods, and so forth.'
  id: totrans-720
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你觉得我突然谈论名称很奇怪，想想你在保持包外依赖代码编译的同时可以在类型中更改什么。私有和包可见字段？当然可以！私有和包可见方法？当然可以。需要保持不变的是其他代码可能编译的名称：类型的名称、公共方法的签名等等。
- en: Looking over the definition of what makes a public API, it becomes clear that
    the module system changes things from before Java 9 on the level of packages (must
    be exported) and types (must be public). Within a type, on the other hand, nothing
    changed, and a type’s public API is the same in Java 8 as in Java 9 and later.
  id: totrans-721
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查公共API的定义，可以清楚地看出，模块系统从Java 9开始改变了包（必须导出）和类型（必须公共）层面的东西。另一方面，在类型内部，没有变化，类型在Java
    8、Java 9及以后的公共API是相同的。
- en: 3.3.1 ACHIEVING STRONG ENCAPSULATION
  id: totrans-722
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.3.1 实现强封装
- en: 'ESSENTIAL INFO If a type isn’t accessible, it isn’t possible to interact with
    it in any way specific to that type: you can’t instantiate it, access its fields,
    invoke methods, or use nested classes. The phrase “specific to that type” is a
    little unusual—what does it mean? That it’s possible to interact with a type’s
    members if they’re defined in an accessible supertype like an interface the type
    implements or, ultimately, `Object`. This is much like before Java 9, where a
    non-public implementation of a public interface could be used, but only through
    that interface.'
  id: totrans-723
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 如果一个类型不可访问，就无法以该类型特有的任何方式与之交互：无法实例化它，访问其字段，调用方法或使用嵌套类。“特定于该类型”这个短语有点不寻常——它是什么意思？如果它们在可访问的超类型（如类型实现的接口）或最终是`Object`中定义，则可以与类型的成员交互。这与Java
    9之前的版本非常相似，当时可以使用非公共接口实现来使用，但只能通过该接口。'
- en: As an example, consider a high-performance library superfast with custom implementations
    of the known Java collections. Let’s focus on a hypothetical `SuperfastHashMap`
    class, which implements Java’s `Map` interface and is not accessible (maybe it
    is package visible in an exported package, maybe the package is not exported at
    all).
  id: totrans-724
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，考虑一个高性能库superfast，它有已知Java集合的自定义实现。让我们关注一个假设的`SuperfastHashMap`类，它实现了Java的`Map`接口并且不可访问（可能它在导出的包中是包可见的，也可能整个包都没有导出）。
- en: If code outside the superfast module gets a `SuperfastHashMap` instance (maybe
    from a factory), then it’s limited to using it as a `Map`. It can’t assign it
    to a variable of type `SuperfastHashMap` and can’t call `superfastGet` on it (even
    if that method is public) but everything that’s defined on accessible supertypes
    like `Map` and `Object` is no problem. (See [figure 3.8](part0016.html#filepos433422).)
  id: totrans-725
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果超级快速模块之外的代码获得一个`SuperfastHashMap`实例（可能来自工厂），那么它只能将其用作`Map`。它不能将其分配给`SuperfastHashMap`类型的变量，也不能在它上面调用`superfastGet`（即使该方法为公共）但定义在可访问的超类型（如`Map`和`Object`）上的所有内容都没有问题。（参见[图3.8](part0016.html#filepos433422)。）
- en: '![](../images/00010.jpeg)'
  id: totrans-726
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00010.jpeg)'
- en: '[Figure 3.8](part0016.html#filepos433110) The inaccessible type `SuperfastHashMap`
    implements the accessible `Map` interface. Code outside of the superfast module,
    if it gets hold of an instance, can use it as a `Map` and as an `Object`, but
    never in ways specific to that type: for example, by calling `superfastGet`. Code
    in the superfast module is unrestricted by accessibility and can use the type
    as usual: for example, to create instances and return them.'
  id: totrans-727
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![图3.8](part0016.html#filepos433110) 不可访问的类型`SuperfastHashMap`实现了可访问的`Map`接口。超级快速模块之外的代码，如果得到一个实例，可以将其用作`Map`和`Object`，但永远不能以特定于该类型的方式使用：例如，通过调用`superfastGet`。超级快速模块中的代码不受访问限制，可以像通常一样使用该类型：例如，创建实例并返回它们。'
- en: The accessibility rules make it possible to expose carefully selected features
    while strongly encapsulating a module’s internals, making sure no outside code
    can depend on implementation details. Interestingly, this includes reflection,
    which can’t bypass the rules either if used across module boundaries! (We’re going
    to talk about reflection throughout the rest of the chapter—if you need to catch
    up on the basics, see appendix B.)
  id: totrans-728
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可访问性规则使得在强封装模块内部的同时，能够暴露精心选择的特性，确保外部代码不能依赖于实现细节。有趣的是，这包括反射，如果它跨越模块边界使用，也无法绕过这些规则！（我们将在本章的其余部分讨论反射——如果你需要复习基础知识，请参阅附录B。）
- en: 'Maybe you’re wondering how reflection-based libraries like Spring, Guice, Hibernate,
    and others will work in the future, or how code will be able to break into a module
    if it absolutely has to. There are a few ways to give or gain access:'
  id: totrans-729
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可能你会想知道像Spring、Guice、Hibernate等基于反射的库在未来的工作方式，或者如果代码绝对需要，它将如何突破到一个模块中。有几种方式可以提供或获取访问权限：
- en: Regular exports (see section 3.1)
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正规导出（参见第3.1节）
- en: Qualified export (see section 11.3)
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有资格的导出（参见第11.3节）
- en: Open modules and open packages (see section 12.2)
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放模块和开放包（参见第12.2节）
- en: Command-line options (summarized in section 7.1)
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行选项（总结在第7.1节）
- en: Chapter 12 explores reflection in more depth.
  id: totrans-734
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第12章将更深入地探讨反射。
- en: But let’s go back to the three conditions that are the premise for accessibility
    (public type, exported package, reading module). They have interesting consequences.
  id: totrans-735
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但让我们回到三个作为访问前提条件（公共类型、导出包、读取模块）的条件。它们有一些有趣的后果。
- en: ESSENTIAL INFO For one, `public` is no longer public. It’s no longer possible
    to tell by looking at a type whether it will be visible outside of the module—for
    that, it’s necessary to check `module-info.java` or trust the IDE to highlight
    exported packages or types. Without `requires` directives, all types in a module
    are inaccessible to the outside. Encapsulation is the new default!
  id: totrans-736
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的信息首先，`public`不再公开。通过查看类型，无法再判断它是否将在模块外部可见——为此，需要检查`module-info.java`或信任IDE突出显示导出的包或类型。如果没有`requires`指令，模块中的所有类型对外部都是不可访问的。封装是新的默认设置！
- en: The three conditions also imply that you can also no longer accidentally rely
    on transitive dependencies. Let’s see why.
  id: totrans-737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这三个条件还意味着你也不再可能意外地依赖于传递依赖。让我们看看原因。
- en: 3.3.2 ENCAPSULATING TRANSITIVE DEPENDENCIES
  id: totrans-738
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.3.2 封装传递依赖
- en: Without the module system, it’s possible to use types from a JAR that a dependency
    draws in but that isn’t declared as a dependency. Once a project uses types this
    way, the build configuration no longer reflects the true set of dependencies,
    which can lead to anything from uninformed architectural decisions to runtime
    errors.
  id: totrans-739
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 没有模块系统，使用一个依赖项引入的JAR文件中的类型（但未声明为依赖项）是可能的。一旦项目以这种方式使用类型，构建配置就不再反映实际的依赖项集合，这可能导致从无知的架构决策到运行时错误的各种问题。
- en: As an example, let’s say a project is using Spring, which depends on OkHttp.
    Writing code that uses types from OkHttp is as easy as letting the IDE add the
    import statements it helpfully suggests. The code will compile and run because
    the build tool will make sure Spring and all its dependencies, including OkHttp,
    are present at all times. This makes it unnecessary to declare the dependency
    on OkHttp, so it’s easily forgotten. (See [figure 3.9](part0016.html#filepos440341).)
  id: totrans-740
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，假设一个项目正在使用Spring，它依赖于OkHttp。编写使用OkHttp类型代码就像让IDE添加它所建议的导入语句一样简单。代码将能够编译和运行，因为构建工具将确保Spring及其所有依赖项，包括OkHttp，始终可用。这使得声明对OkHttp的依赖变得不必要，因此很容易被遗忘。（参见[图3.9](part0016.html#filepos440341)。）
- en: As a consequence, a dependency analysis of the project would deliver misleading
    results, based on which problematic decisions could be made. The OkHttp version
    also isn’t fixed and depends entirely on what Spring uses. If that version is
    updated, the code depending on OkHttp is silently running on a different version,
    creating the real risk that the program will misbehave or crash at run time.
  id: totrans-741
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为结果，项目的依赖项分析可能会提供误导性的结果，基于这些结果可能会做出有问题的决策。OkHttp的版本也不是固定的，完全取决于Spring使用什么。如果该版本被更新，依赖于OkHttp的代码将默默地运行在不同的版本上，这实际上会带来程序在运行时出现行为异常或崩溃的真实风险。
- en: '![](../images/00021.jpeg)'
  id: totrans-742
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00021.jpeg)'
- en: '[Figure 3.9](part0016.html#filepos439514) Without modules, it’s easy to accidentally
    depend on transitive dependencies as in this example, where the application depends
    on OkHttp, which is pulled in by Spring. With modules, on the other hand, dependencies
    have to be declared with `requires` directives to be able to access them. The
    application doesn’t require OkHttp and so can’t access it.'
  id: totrans-743
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图3.9](part0016.html#filepos439514) 没有模块时，很容易意外地依赖于传递依赖，如本例所示，其中应用程序依赖于OkHttp，它被Spring拉入。另一方面，使用模块时，必须使用`requires`指令声明依赖项才能访问它们。应用程序不需要OkHttp，因此无法访问它。'
- en: Due to the module system’s requirement that the accessing module must read the
    accessed module, this can no longer happen. Unless the project declares its dependency
    on OkHttp by using a `requires` directive, the module system won’t allow it to
    access OkHttp’s classes. This way it forces you to keep your configuration up
    to date.
  id: totrans-744
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于模块系统要求访问模块必须读取被访问的模块，这种情况现在不再发生。除非项目通过使用`requires`指令声明其对OkHttp的依赖，否则模块系统不允许它访问OkHttp的类。这样，它迫使你保持配置更新。
- en: Note that modules have the ability to pass their own dependencies on to modules
    that depend on them with a feature called implied readability. Check section 11.11
    for details.
  id: totrans-745
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，模块具有通过一个称为隐式可读性的功能将它们的依赖项传递给依赖于它们的模块的能力。有关详细信息，请参阅第11.11节。
- en: 3.3.3 ENCAPSULATION SKIRMISHES
  id: totrans-746
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.3.3 封装争斗
- en: As we did with readability, let’s break things! But before we do so, I want
    to show a scenario that follows all the rules and works. Once again, it’s based
    on the ServiceMonitor application introduced in chapter 2.
  id: totrans-747
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 就像我们对可读性所做的那样，让我们打破规则！但在我们这样做之前，我想展示一个遵循所有规则且能正常工作的场景。再次强调，它基于第2章中引入的ServiceMonitor应用程序。
- en: 'For the sake of these examples, assume that the module monitor.observer contained
    in its package `monitor.observer` a class `DisconnectedServiceObserver`. What
    it does is irrelevant: what counts is that it implements `ServiceObserver`, that
    it has a constructor that doesn’t require any arguments, and that the monitor
    module uses it.'
  id: totrans-748
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了这些示例的目的，假设模块`monitor.observer`包含在其包`monitor.observer`中的类`DisconnectedServiceObserver`。它所做的不重要：重要的是它实现了`ServiceObserver`接口，它有一个不需要任何参数的构造函数，并且监控模块使用它。
- en: The module monitor.observer exports `monitor.observer` and `DisconnectedServiceObserver`
    is public. This fulfills the first two accessibility requirements, so other modules
    can access it if they read monitor.observer. The module monitor fulfills that
    precondition, too, because it requires module.observer in its module declaration.
    Taken together ([figure 3.10](part0016.html#filepos445482) and [listing 3.1](part0016.html#filepos446911)),
    all requirements are fulfilled, and code in monitor can access `DisconnectedServiceObserver`.
    Accordingly, compilation and execution are error-free. Let’s fiddle with the details
    and watch how the module system reacts.
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块`monitor.observer`导出`monitor.observer`，`DisconnectedServiceObserver`是公开的。这满足了前两个可访问性要求，因此其他模块如果读取`monitor.observer`，则可以访问它。模块`monitor`也满足这个先决条件，因为它在其模块声明中需要`monitor.observer`。综合([图3.10](part0016.html#filepos445482)和[列表3.1](part0016.html#filepos446911))，所有要求都得到满足，monitor中的代码可以访问`DisconnectedServiceObserver`。相应地，编译和执行没有错误。让我们玩弄细节，看看模块系统如何反应。
- en: '![](../images/00031.jpeg)'
  id: totrans-750
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00031.jpeg)'
- en: '[Figure 3.10](part0016.html#filepos444618) `DisconnectedServiceObserver` is
    public (1) and in a package exported by `monitor.observer` (2). Because the monitor
    module reads `monitor.observer` (3), code in it can use `DisconnectedServiceObserver`.'
  id: totrans-751
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图3.10](part0016.html#filepos444618) `DisconnectedServiceObserver`是公开的（1）并且位于由`monitor.observer`导出的包中（2）。因为monitor模块读取`monitor.observer`（3），所以其中的代码可以使用`DisconnectedServiceObserver`。'
- en: Listing 3.1 `DisconnectedServiceObserver`, accessible by monitor
  id: totrans-752
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表3.1 `DisconnectedServiceObserver`，可由monitor访问
- en: '`// --- TYPE DisconnectedServiceObserver --- package monitor.observer;` `public
    class DisconnectedServiceObserver //` [`①`](part0016.html#filepos448159) `implements
    ServiceObserver { // class body truncated }  // --- MODULE DECLARATION monitor.observer
    --- module monitor.observer {` `exports monitor.observer; //` [`②`](part0016.html#filepos448519)
    `}  // --- MODULE DECLARATION monitor --- module monitor {` `requires monitor.observer;
    //` [`③`](part0016.html#filepos448893) `// other requires directives truncated
    }`'
  id: totrans-753
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`// --- TYPE DisconnectedServiceObserver --- package monitor.observer;` `public
    class DisconnectedServiceObserver //` [`①`](part0016.html#filepos448159) `implements
    ServiceObserver { // class body truncated }  // --- MODULE DECLARATION monitor.observer
    --- module monitor.observer {` `exports monitor.observer; //` [`②`](part0016.html#filepos448519)
    `}  // --- MODULE DECLARATION monitor --- module monitor {` `requires monitor.observer;
    //` [`③`](part0016.html#filepos448893) `// 其他requires指令省略 }`'
- en: ①
  id: totrans-754
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Public monitor.observer.DisconnectedServiceObserver
  id: totrans-755
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 公开的 monitor.observer.DisconnectedServiceObserver
- en: ②
  id: totrans-756
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: The module monitor.observer exports the package monitor.observer.
  id: totrans-757
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块monitor.observer导出包monitor.observer。
- en: ③
  id: totrans-758
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: The module monitor requires and thus eventually reads monitor.observer.
  id: totrans-759
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块monitor需要并最终读取monitor.observer。
- en: TYPE NOT PUBLIC
  id: totrans-760
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类型非公开
- en: 'If `DisconnectedServiceObserver` is made package-visible, compilation of monitor
    fails. More precisely, the import causes the first error:'
  id: totrans-761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果将`DisconnectedServiceObserver`设置为包可见，monitor的编译将失败。更确切地说，导入导致了第一个错误：
- en: '`> monitor/src/main/java/monitor/Monitor.java:4: error: > DisconnectedServiceObserver
    is not public in monitor.observer; > cannot be accessed from outside package >
    import monitor.observer.DisconnectedServiceObserver; > ^`'
  id: totrans-762
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> monitor/src/main/java/monitor/Monitor.java:4: 错误: > monitor.observer.DisconnectedServiceObserver
    在 monitor.observer 中不是公开的；不能从包外访问 > import monitor.observer.DisconnectedServiceObserver;
    > ^`'
- en: Accessing package-visible types from another package wasn’t possible before
    Java 9, either, and for that reason the error message is nothing new—you’d get
    the same one without the module system in play.
  id: totrans-763
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Java 9之前，从另一个包访问包可见的类型也是不可能的，因此错误信息并不新鲜——即使没有模块系统，你也会得到相同的错误。
- en: 'Similarly, if you bypass the compiler checks by recompiling just the monitor.observer
    module after `DisconnectedServiceObserver` is made package-visible and then launching
    the entire application, the error is the same as without the module system:'
  id: totrans-764
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 同样，如果你通过在将`DisconnectedServiceObserver`设置为包可见后重新编译monitor.observer模块并启动整个应用程序来绕过编译器检查，错误与没有模块系统时相同：
- en: '`> Exception in thread "main" java.lang.IllegalAccessError: > failed to access
    class monitor.observer.DisconnectedServiceObserver > from class monitor.Monitor`'
  id: totrans-765
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 异常发生在主线程中 java.lang.IllegalAccessError: > 无法从类 monitor.Monitor 访问类 monitor.observer.DisconnectedServiceObserver`'
- en: 'Before Java 9, it was possible to use the reflection API to access the type
    at run time, and this is something strong encapsulation prevents. Consider the
    following code:'
  id: totrans-766
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Java 9之前，可以使用反射API在运行时访问类型，这是强封装所阻止的。考虑以下代码：
- en: '`Constructor<?> constructor = Class .forName("monitor.observer.DisconnectedServiceObserver")
    .getDeclaredConstructor(); constructor.setAccessible(true); ServiceObserver observer
    = (ServiceObserver) constructor.newInstance();`'
  id: totrans-767
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Constructor<?> constructor = Class.forName("monitor.observer.DisconnectedServiceObserver").getDeclaredConstructor();
    constructor.setAccessible(true); ServiceObserver observer = (ServiceObserver)
    constructor.newInstance();`'
- en: 'In Java 8 and before, this works regardless of whether `DisconnectedServiceObserver`
    is public or package-visible. In Java 9 and later, the module system prevents
    access if `DisconnectedServiceObserver` is package-visible, and the call to `setAccessible`
    causes an exception:'
  id: totrans-768
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Java 8及之前版本中，无论`DisconnectedServiceObserver`是公开的还是包可见的，这都适用。在Java 9及以后的版本中，模块系统会阻止访问，如果`DisconnectedServiceObserver`是包可见的，调用`setAccessible`会导致异常：
- en: '`> Exception in thread "main" java.lang.reflect.InaccessibleObjectException:
    > Unable to make monitor.observer.DisconnectedServiceObserver() > accessible:
    module monitor.observer does not "opens monitor.observer" > to module monitor`'
  id: totrans-769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 异常发生在主线程中 java.lang.reflect.InaccessibleObjectException: > 无法使 monitor.observer.DisconnectedServiceObserver()
    可访问：模块 monitor.observer 不对模块 monitor "打开" monitor.observer`'
- en: The ServiceMonitor repository’s branch `break-reflection-over-internals` demonstrates
    the behavior shown here. The complaint that monitor.observer doesn’t open monitor.observer
    points toward one solution for this problem—something section 12.2 explores.
  id: totrans-770
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ServiceMonitor仓库的分支`break-reflection-over-internals`展示了这里的行为。monitor.observer没有打开monitor.observer的抱怨指向了该问题的解决方案——这是第12.2节探讨的内容。
- en: PACKAGE NOT EXPORTED
  id: totrans-771
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包未导出
- en: 'Next on the list of requirements is that the package containing the accessed
    type must be exported. To toy with that, let’s make `DisconnectedServiceObserver`
    public again but move it into another package monitor.observer.dis, which monitor.observer
    doesn’t export. The imports in monitor are updated to the new package:'
  id: totrans-772
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接下来是要求之一，即包含访问类型的包必须导出。为了试验这一点，让我们再次将`DisconnectedServiceObserver`设置为公开，但将其移动到另一个包monitor.observer.dis，该包monitor.observer没有导出。monitor中的导入更新到新包：
- en: '`> monitor/src/main/java/monitor/Monitor.java:4: error: > package monitor.observer.dis
    does not exist > import monitor.observer.dis.DisconnectedServiceObserver; > ^
    > (package monitor.observer.dis is declared in module > monitor.observer, which
    does not export it)`'
  id: totrans-773
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> monitor/src/main/java/monitor/Monitor.java:4: 错误: > 包 monitor.observer.dis
    不存在 > import monitor.observer.dis.DisconnectedServiceObserver; > ^ > (包 monitor.observer.dis
    在模块 monitor.observer 中声明，该模块没有导出它)`'
- en: That’s pretty straightforward.
  id: totrans-774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这相当直接。
- en: 'To see how the runtime fares in this case, you need to bypass the compiler
    checks. To that end, edit monitor.observer to export monitor.observer.dis, compile
    all modules, and then compile monitor.observer once again without that export.
    You can launch the application as before and provoke a runtime error:'
  id: totrans-775
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要查看运行时在这种情况下表现如何，你需要绕过编译器检查。为此，编辑 monitor.observer 以导出 monitor.observer.dis，编译所有模块，然后再次编译
    monitor.observer 而不进行该导出。你可以像以前一样启动应用程序并引发运行时错误：
- en: '`> Exception in thread "main" java.lang.IllegalAccessError: > class monitor.Monitor
    (in module monitor) cannot access class > monitor.observer.dis.DisconnectedServiceObserver
    (in module > monitor.observer) because module monitor.observer does not export
    > monitor.observer.dis to module monitor`'
  id: totrans-776
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 线程 "main" 中发生异常 java.lang.IllegalAccessError: > 类 monitor.Monitor（在模块 monitor
    中）无法访问类 > monitor.observer.dis.DisconnectedServiceObserver（在模块 > monitor.observer
    中），因为模块 monitor.observer 没有将 > monitor.observer.dis 导出给模块 monitor`'
- en: 'Like the compiler, the runtime is pretty talkative and explains what the problem
    is. The same is true for the reflection API when you try to make the constructor
    accessible, so you can create an instance of `DisconnectedServiceObserver`:'
  id: totrans-777
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 就像编译器一样，运行时相当健谈，并解释了问题所在。当你尝试使构造函数可访问时，这也适用于反射 API，这样你就可以创建 `DisconnectedServiceObserver`
    的实例：
- en: '`> Exception in thread "main" java.lang.reflect.InaccessibleObjectException:
    > Unable to make public > monitor.observer.dis.DisconnectedServiceObserver() accessible:
    > module monitor.observer does not "exports monitor.observer.dis" > to module
    monitor`'
  id: totrans-778
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 线程 "main" 中发生异常 java.lang.reflect.InaccessibleObjectException: > 无法使 public
    monitor.observer.dis.DisconnectedServiceObserver() 可访问：> 模块 monitor.observer 没有对模块
    monitor 导出 monitor.observer.dis`'
- en: If you look closely, you’ll see that both the runtime and the reflection API
    talk about exporting a package to a module. That’s called a qualified export (explained
    in section 11.3).
  id: totrans-779
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会看到运行时和反射 API 都提到了将包导出到模块。这被称为合格导出（在第 11.3 节中解释）。
- en: MODULE NOT READ
  id: totrans-780
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块未读取
- en: 'The last requirement on the list is that the exporting module must be read
    by the one accessing the type. Removing the `requires monitor.observer` directive
    from monitor’s module declaration leads to the expected compile-time error:'
  id: totrans-781
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表中的最后一个要求是，导出模块必须被访问类型的模块读取。从 monitor 的模块声明中移除 `requires monitor.observer`
    指令会导致预期的编译时错误：
- en: '`> monitor/src/main/java/monitor/Monitor.java:3: error: > package monitor.observer
    is not visible > import monitor.observer.DiagnosticDataPoint; > ^ > (package monitor.observer
    is declared in module > monitor.observer, but module monitor does not read it)`'
  id: totrans-782
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> monitor/src/main/java/monitor/Monitor.java:3: 错误：> 包 monitor.observer 不可见
    > 导入 monitor.observer.DiagnosticDataPoint; > ^ > （包 monitor.observer 在模块 monitor.observer
    中声明，但模块 monitor 没有读取它）`'
- en: 'To see how the runtime reacts to a missing `requires` directive, first compile
    the entire application with a working configuration, meaning monitor reads monitor.observer.
    Then remove the `requires` directive from monitor’s `module-info.java`, and recompile
    just that file. This way, the module’s code is compiled with a module declaration
    that still requires monitor.observer, but the runtime will see a module description
    that claims nothing of the kind. As expected, the result is a runtime error:'
  id: totrans-783
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要查看运行时对缺少 `requires` 指令的反应，首先使用一个正常配置编译整个应用程序，这意味着监控读取 monitor.observer。然后从
    monitor 的 `module-info.java` 中移除 `requires` 指令，并仅重新编译该文件。这样，模块的代码将使用一个仍然需要 monitor.observer
    的模块声明进行编译，但运行时将看到一个声称没有这种要求的模块描述。正如预期的那样，结果是运行时错误：
- en: '`> Exception in thread "main" java.lang.IllegalAccessError: > class monitor.Monitor
    (in module monitor) cannot access class > monitor.observer.DisconnectedServiceObserver
    (in module > monitor.observer) because module monitor does not read module > monitor.observer`'
  id: totrans-784
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 线程 "main" 中发生异常 java.lang.IllegalAccessError: > 类 monitor.Monitor（在模块 monitor
    中）无法访问类 > monitor.observer.DisconnectedServiceObserver（在模块 > monitor.observer
    中），因为模块 monitor 没有读取模块 > monitor.observer`'
- en: Again, the error message is pretty clear.
  id: totrans-785
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 再次，错误信息非常明确。
- en: Finally, let’s turn to reflection. You can use the same compilation trick to
    create a monitor module that doesn’t read monitor.observer. And reuse the reflection
    code from earlier when `DisconnectedServiceObserver` wasn’t public but you wanted
    to create an instance anyway.
  id: totrans-786
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，让我们转向反射。你可以使用相同的编译技巧创建一个不读取 monitor.observer 的监控模块。并且当 `DisconnectedServiceObserver`
    不是公共的，但你仍然想创建一个实例时，可以重用之前的反射代码。
- en: 'Surely running these modules together fails as well, right? Yes, it does, but
    not the way you may have expected:'
  id: totrans-787
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当然，运行这些模块一起失败，对吧？是的，它会失败，但不是你预期的那个方式：
- en: '`> Exception in thread "main" java.lang.IllegalAccessError: > class monitor.Monitor
    (in module monitor) cannot access class > monitor.observer.ServiceObserver (in
    module monitor.observer) > because module monitor does not read module monitor.observer`'
  id: totrans-788
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 异常发生在主线程 "main" 中 java.lang.IllegalAccessError: > 类 monitor.Monitor (在模块
    monitor) 无法访问类 > monitor.observer.ServiceObserver (在模块 monitor.observer) > 因为模块
    monitor 不读取模块 monitor.observer`'
- en: 'Why is the error message complaining about `ServiceObserver`? Because that
    type is also in monitor.observer, which monitor no longer reads. Let’s change
    the reflection code to only use `Object`:'
  id: totrans-789
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么错误信息会抱怨 `ServiceObserver`？因为该类型也在 monitor.observer 中，而 monitor 已经不再读取。让我们将反射代码更改为仅使用
    `Object`：
- en: '`Constructor<?> constructor = Class .forName("monitor.observer.DisconnectedServiceObserver")
    .getDeclaredConstructor(); constructor.setAccessible(true); Object observer =
    constructor.newInstance();`'
  id: totrans-790
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Constructor<?> constructor = Class.forName("monitor.observer.DisconnectedServiceObserver").getDeclaredConstructor();
    constructor.setAccessible(true); Object observer = constructor.newInstance();`'
- en: 'Run this—it works! But what about the missing read edge, you may ask? The answer
    is simple but a little surprising at first: the reflection API fills it in automatically.
    Section 12.3.1 explores the reasons behind that.'
  id: totrans-791
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行这个命令——它成功了！但你可能会问，缺失的读取边是什么？答案是简单但一开始有点令人惊讶：反射 API 会自动填充它。第 12.3.1 节探讨了背后的原因。
- en: '3.4 The module path: Letting Java know about modules'
  id: totrans-792
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.4 模块路径：让 Java 了解模块
- en: You now know how to define modules and their essential properties. What’s still
    a little unclear is how you tell the compiler and runtime about them. Chapter
    4 looks into building modules from source to JAR, and you’ll quickly run into
    the situation where you need to reference existing modules the code under compilation
    depends on. The situation is the same in chapter 5, where the runtime needs to
    know about the application modules, so you can launch one of them.
  id: totrans-793
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你现在知道如何定义模块及其基本属性。但仍然有点不清楚的是，你是如何告诉编译器和运行时关于它们的。第 4 章探讨了从源到 JAR 的模块构建，你很快就会遇到需要引用编译中代码所依赖的现有模块的情况。第
    5 章的情况相同，其中运行时需要了解应用程序模块，以便你可以启动其中一个。
- en: Before Java 9, you would have used the class path, which had plain JARs on it
    (see appendix A for a quick class-path recap), to inform compiler and runtime
    where to find artifacts. They search it when they’re looking for individual types
    required during compilation or execution.
  id: totrans-794
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，你会使用类路径，其上包含普通的 JAR 文件（参见附录 A 以快速回顾类路径），来告知编译器和运行时在哪里找到工件。它们在寻找编译或执行期间所需的单个类型时会搜索它。
- en: The module system, on the other hand, promises not to operate on types, but
    to go one level above them and manage modules instead. One way this approach is
    expressed is a new concept that parallels the class path but expects modules instead
    of bare types or plain JARs.
  id: totrans-795
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 相反，模块系统承诺不对类型进行操作，而是高于它们一个层级，并管理模块。这种方法的表达方式之一是一个与类路径平行的全新概念，但它期望模块而不是裸类型或普通
    JAR 文件。
- en: 'Definition: Module path'
  id: totrans-796
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：模块路径
- en: The module path is a list whose elements are artifacts or directories that contain
    artifacts. Depending on the OS, module path elements are separated by `:` (Unix-based)
    or `;` (Windows). It’s used by the module system to locate required modules that
    aren’t found among the platform modules. Both `javac` and `java` as well as other
    module-related commands can process it—the command-line options are `--module-path`
    and -`p`.
  id: totrans-797
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块路径是一个列表，其元素是包含工件或目录的工件。根据操作系统，模块路径元素由 `:`（基于 Unix）或 `;`（Windows）分隔。它由模块系统用于定位在平台模块中找不到的必需模块。`javac`
    和 `java` 以及其他与模块相关的命令都可以处理它——命令行选项是 `--module-path` 和 `-p`。
- en: '[Listing 3.2](part0016.html#filepos467655) shows how the ServiceMonitor application’s
    monitor module could be compiled, packaged, and launched. It uses `--module-path`
    to point to the directory `mods`, which you assume contains all required dependencies
    as modular JARs. For details on compilation, packaging, and launching, see sections
    4.2, 4.5, and 5.1.'
  id: totrans-798
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[列表 3.2](part0016.html#filepos467655) 展示了 ServiceMonitor 应用程序的 monitor 模块如何进行编译、打包和启动。它使用
    `--module-path` 指向目录 `mods`，你假设它包含所有必需的依赖项作为模块 JAR 文件。有关编译、打包和启动的详细信息，请参阅第 4.2、4.5
    和 5.1 节。'
- en: Listing 3.2 Compiling, packaging, and launching monitor
  id: totrans-799
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 3.2 编译、打包和启动 monitor
- en: '`$ javac` `--module-path mods` [`①`](part0016.html#filepos468810) `-d monitor/target/classes`
    `${source-files}` [`②`](part0016.html#filepos469174) `$ jar --create` `--file
    mods/monitor.jar` [`③`](part0016.html#filepos469514) `--main-class monitor.Main
    -C monitor/target/classes . $ java` `--module-path mods:libs` [`④`](part0016.html#filepos469856)
    `--module monitor`'
  id: totrans-800
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac` `--module-path mods` [`①`](part0016.html#filepos468810) `-d monitor/target/classes`
    `${source-files}` [`②`](part0016.html#filepos469174) `$ jar --create` `--file
    mods/monitor.jar` [`③`](part0016.html#filepos469514) `--main-class monitor.Main
    -C monitor/target/classes . $ java` `--module-path mods:libs` [`④`](part0016.html#filepos469856)
    `--module monitor`'
- en: ①
  id: totrans-801
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Directory containing the direct dependencies as modules
  id: totrans-802
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包含直接依赖项作为模块的目录
- en: ②
  id: totrans-803
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Lists or finds all source files
  id: totrans-804
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列出或查找所有源文件
- en: ③
  id: totrans-805
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: Name for the new JAR file in mods
  id: totrans-806
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在mods中为新JAR文件命名的名称
- en: ④
  id: totrans-807
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: Directories containing direct and transitive dependencies
  id: totrans-808
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包含直接和传递依赖项的目录
- en: 'ESSENTIAL INFO It’s important to clarify that only the module path processes
    artifacts as modules. Armed with that knowledge, you can be a little more precise
    about what constitutes the universe of observable modules. In section 3.1.4, it’s
    defined as follows: all platform modules in the current runtime as well as all
    application modules specified on the command line are called observable, and together
    they make up the universe of observable modules.'
  id: totrans-809
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的信息：重要的是要明确，只有模块路径将工件作为模块处理。有了这个知识，你可以更精确地了解构成可观察模块宇宙的内容。在第3.1.4节中，它被定义为如下：当前运行时的所有平台模块以及命令行上指定的所有应用程序模块被称为可观察的，它们共同构成了可观察模块的宇宙。
- en: The phrase “modules specified on the command line” is a little vague. Now you
    know that they’re artifacts that can be found on the module path.
  id: totrans-810
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “命令行上指定的模块”这个短语有点含糊。现在你知道它们是可以找到在模块路径上的工件。
- en: Note that I said artifacts, not modules! Not only modular JARs but also plain
    ones will, when placed on the module path, be turned into modules and become part
    of the universe of observable modules. This somewhat surprising behavior is part
    of the migration story, and discussing it here would derail our exploration of
    the module path, so let me defer explaining it to section 8.3\. What I want to
    mention now is that symmetrical to the module path interpreting every artifact
    as a module, the class path treats all artifacts as plain JARs, regardless of
    whether they contain a module descriptor.
  id: totrans-811
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，我说的是工件，而不是模块！不仅模块化JAR文件，即使是普通JAR文件，当放置在模块路径上时，也会被转换为模块，并成为可观察模块宇宙的一部分。这种多少有些令人惊讶的行为是迁移故事的一部分，在这里讨论它可能会偏离我们对模块路径的探索，所以让我将解释推迟到第8.3节。现在我想提到的是，与模块路径将每个工件解释为模块对称的是，类路径将所有工件视为普通JAR文件，无论它们是否包含模块描述符。
- en: Annotation processors
  id: totrans-812
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注解处理器
- en: 'If you’re using annotation processors, you’ve been placing them on the class
    path together with the application’s artifact. Java 9 suggests to separate by
    concerns and use `--class-path` or `--module-path` for application JARs and `--processor-path`
    or `--processor-module-path` for processor JARs. For unmodularized JARs, the distinction
    between the application and processor paths is optional: placing everything on
    the class path is valid, but for modules it’s binding; processors on the module
    path won’t be used.'
  id: totrans-813
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你正在使用注解处理器，你一直将它们与应用程序的工件一起放置在类路径上。Java 9建议根据关注点进行分离，并使用`--class-path`或`--module-path`为应用程序JAR文件，以及`--processor-path`或`--processor-module-path`为处理器JAR文件。对于非模块化JAR文件，应用程序和处理器路径之间的区别是可选的：将所有内容放置在类路径上是有效的，但对于模块来说则是强制性的；模块路径上的处理器不会被使用。
- en: Because the module path is used by several tools, most notably the compiler
    and the virtual machine, it makes sense to look at the concept in general. Unless
    otherwise noted, the described mechanisms work the same in all environments.
  id: totrans-814
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因为模块路径被多个工具使用，尤其是编译器和虚拟机，所以从一般概念上考虑这个概念是有意义的。除非另有说明，否则所描述的机制在所有环境中都按相同的方式工作。
- en: '3.4.1 MODULE RESOLUTION: ANALYZING AND VERIFYING AN APPLICATION’S STRUCTURE'
  id: totrans-815
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.4.1 模块解析：分析并验证应用程序的结构
- en: What happens after calling `javac` or `java` with a bunch of modules on the
    module path? This is when the module system starts checking the launch configuration,
    meaning the modules and their declared dependencies, for reliability.
  id: totrans-816
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在模块路径上调用`javac`或`java`并传递多个模块后会发生什么？这就是模块系统开始检查启动配置的时候，这意味着检查模块及其声明的依赖项以验证其可靠性。
- en: The process has to start somewhere, so the module system’s first order of business
    is to decide on the set of root modules. There are several ways to make a module
    a root, and we’ll discuss them all in due time, but the most prominent is specifying
    the initial module. For the compiler, that’s either the module under compilation
    (if a module declaration is among the source files) or the one specified with
    `--module` (if the module source path is used). In the case of launching the virtual
    machine, only the `--module` option remains.
  id: totrans-817
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个过程必须从某个地方开始，因此模块系统的首要任务是决定根模块集。有几种方法可以将模块设置为根，我们将在适当的时候讨论所有这些方法，但最突出的是指定初始模块。对于编译器来说，这要么是编译下的模块（如果模块声明在源文件中），要么是使用`--module`指定的模块（如果使用了模块源路径）。在启动虚拟机的情况下，只有`--module`选项保留。
- en: Next, the module system resolves dependencies. It checks the root modules’ declarations
    to see which other modules they depend on and tries to satisfy each dependency
    with an observable module. It then goes on to do the same with those modules and
    so forth. This continues until either all transitive dependencies of the initial
    module are fulfilled or the configuration is identified as unreliable.
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接下来，模块系统解决依赖关系。它检查根模块的声明，以查看它们依赖于哪些其他模块，并尝试使用可观察的模块来满足每个依赖项。然后它继续对那些模块执行相同的操作，以此类推。这个过程会一直持续，直到初始模块的所有传递依赖项都得到满足，或者配置被识别为不可靠。
- en: Resolving services and optional dependencies
  id: totrans-819
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解决服务和可选依赖项
- en: 'Two aspects of module resolution add a little to the process discussed so far:'
  id: totrans-820
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块解析的两个方面为之前讨论的过程增加了一些内容：
- en: Services (see chapter 10, particularly section 10.1.2)
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务（参见第10章，特别是10.1.2节）
- en: Optional dependencies (see section 11.2, particularly 11.2.3)
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选依赖项（参见第11.2节，特别是11.2.3节）
- en: I won’t go into them here because you lack the prerequisites, but I want to
    mention them, so you know more is coming. Suffice it to say, they don’t void anything
    I’ve described—they just add bits and pieces.
  id: totrans-823
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我在这里不会深入讨论它们，因为你们缺少先决条件，但我想要提及它们，这样你们就知道还有更多内容即将到来。简单来说，它们不会取消我描述的任何内容——它们只是添加了一些细节。
- en: 'ESSENTIAL INFO Regarding unreliable configurations, section 3.2.2 explores
    the kinds of things that can go wrong during this phase and how the module system
    reacts to them. There’s one noteworthy detail to add: if the module path consists
    of several entries (directories or individual JARs), ambiguity checks aren’t applied
    across them! Each individual entry must contain a module only once; but if several
    different entries contain the same module, the first one (in the order in which
    they were named on the module path) is picked—it `shadows` the other modules.'
  id: totrans-824
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有关不可靠配置的必要信息，第3.2.2节探讨了在此阶段可能发生的问题类型以及模块系统如何对这些问题做出反应。需要补充的一个值得注意的细节是：如果模块路径由多个条目（目录或单个JAR文件）组成，则在这些条目之间不会应用模糊性检查！每个单独的条目必须只包含一个模块；但如果多个不同的条目包含相同的模块，则第一个（在模块路径上命名的顺序中）被选中——它`遮蔽`了其他模块。
- en: 'The easiest way to demonstrate that modules can be duplicated across folders
    is to pick a project that’s ready to be launched and has all its modules in a
    folder (say, `mods`). Then create a copy of the entire folder (say, `mods-copy`)
    and place both on the module path:'
  id: totrans-825
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明模块可以在文件夹之间复制的最简单方法是从一个准备就绪且所有模块都在一个文件夹中的项目（比如说，`mods`）中选择。然后创建整个文件夹的副本（比如说，`mods-copy`），并将它们都放置在模块路径上：
- en: '`$ java --module-path mods:mods-copy:libs --module monitor`'
  id: totrans-826
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:mods-copy:libs --module monitor`'
- en: All modules appear once in each folder, but the application starts nonetheless.
  id: totrans-827
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有模块在每个文件夹中只出现一次，但应用程序仍然会启动。
- en: Now consider that build tools usually create a module path that lists each dependency
    individually. That means that as long as the build tool is in control, for example
    during compilation and testing, ambiguity checks aren’t applied across all dependencies.
  id: totrans-828
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在考虑一下，构建工具通常创建一个模块路径，其中列出每个依赖项。这意味着只要构建工具处于控制状态，例如在编译和测试期间，就不会在所有依赖项之间应用模糊性检查。
- en: I find this unfortunate, because it voids a part of the promise of reliable
    configuration. On the other hand, it does have the upside that you can purposely
    shadow modules with versions you like better as long as you put yours first. Just
    remember that unlike in class-path times, different JARs are never “mixed.” If
    the module system picks one module as a package’s origin, it will look up all
    classes from that package in that JAR and never look in other JARs (this is related
    to split packages, discussed in sections 3.2.2 and 7.2).
  id: totrans-829
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我认为这是不幸的，因为它违背了可靠配置的一部分承诺。另一方面，它也有一个优点，那就是只要你把你的模块放在第一位，你就可以故意用你更喜欢版本的模块来覆盖模块。但请记住，与类路径时代不同，不同的
    JAR 文件永远不会“混合”。如果模块系统选择一个模块作为包的来源，它将在这个 JAR 中查找该包的所有类，而不会在其他 JAR 中查找（这与第 3.2.2
    节和第 7.2 节中讨论的拆分包有关）。
- en: Next, let’s assume all modules were resolved. If no errors were found, the module
    system guarantees that each required module is present. Or rather, that modules
    with the right names are present.
  id: totrans-830
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接下来，让我们假设所有模块都已解析。如果没有发现错误，模块系统保证每个必需的模块都存在。或者更确切地说，具有正确名称的模块存在。
- en: There are no additional checks during this phase, so if a module depends on,
    for example, com.google.common (the module name for Google’s Guava library) and
    an empty module with that name was found, the module system is content. But the
    missing types will still cause trouble down the road, in the form of compile-time
    or runtime errors. While empty modules are unlikely, a module with a different
    version than expected, missing a couple of types, isn’t implausible. Still, a
    reliable configuration will greatly reduce the number of `NoClassDefFoundError`s
    that crop up during execution.
  id: totrans-831
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个阶段没有进行额外的检查，所以如果模块依赖于例如 com.google.common（Google Guava 库的模块名称）并且找到了具有该名称的空模块，模块系统就会满意。但缺失的类型仍然会在以后造成麻烦，以编译时或运行时错误的形式出现。虽然空模块不太可能，但具有不同版本且缺少几个类型的模块并不令人难以置信。尽管如此，可靠的配置将大大减少在执行过程中出现的
    `NoClassDefFoundError` 的数量。
- en: '3.4.2 MODULE GRAPH: REPRESENTATION OF AN APPLICATION’S STRUCTURE'
  id: totrans-832
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.4.2 模块图：应用程序结构的表示
- en: One of this book’s first headings is “Visualizing software as graphs” (section
    1.1.1). The ensuing paragraphs explain how developers and tools tend to see code
    in general but particularly dependencies between artifacts as graphs. The rest
    of chapter 1 illustrates that Java instead sees them as mere containers for types
    it consequently rolls into a ball of mud and how that mismatch is the root of
    a few hard problems plaguing the ecosystem.
  id: totrans-833
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本书的第一章标题之一是“将软件作为图可视化”（第 1.1.1 节）。接下来的段落解释了开发者和工具通常如何将代码视为图，尤其是将工件之间的依赖视为图。第一章的其余部分说明了
    Java 如何将它们视为仅包含类型的容器，随后将这些类型滚成一个泥球，以及这种不匹配是如何成为困扰生态系统的几个难题的根源。
- en: 'The module system promises to solve many of those issues by aligning Java’s
    perception with yours. All of this builds up to one revelation: the module system
    also sees a graph of artifacts. So here it is: the module graph!'
  id: totrans-834
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统承诺通过使 Java 的感知与你的感知一致来解决这些问题。所有这些都指向一个启示：模块系统也看到了一个工件图。所以，这就是：模块图！
- en: 'Definition: Module graph'
  id: totrans-835
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：模块图
- en: In a module graph, modules (as nodes) are connected according to their dependencies
    (with directed edges). The edges are the basis for readability (described in section
    3.2). The graph is constructed during module resolution and available at run time
    via the reflection API (explained in section 12.4.2).
  id: totrans-836
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在模块图中，模块（作为节点）根据它们的依赖关系（通过有向边）连接。边是可读性的基础（在第 3.2 节中描述）。图在模块解析期间构建，并在运行时通过反射
    API（在第 12.4.2 节中解释）提供。
- en: '[Figure 3.11](part0016.html#filepos483906) shows how module resolution creates
    the module graph for a simplified ServiceMonitor application. You don’t have to
    leave everything up to the JPMS, though. With the right command-line options,
    you can add more modules and reads edges to the graph; we’ll explore that next.'
  id: totrans-837
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 3.11](part0016.html#filepos483906) 展示了模块解析如何为简化的 ServiceMonitor 应用程序创建模块图。尽管如此，你不必把一切交给
    JPMS。通过正确的命令行选项，你可以向图中添加更多模块和读取边；我们将在下一节中探讨这一点。'
- en: '![](../images/00060.jpeg) ![](../images/00003.jpeg)'
  id: totrans-838
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片 1](../images/00060.jpeg) ![图片 2](../images/00003.jpeg)'
- en: '[Figure 3.11](part0016.html#filepos483083)a Module resolution builds the module
    graph for a simplified ServiceMonitor application. In each step, one module is
    resolved, meaning it’s located in the universe of observable modules and its dependencies
    are added to the module graph. Step by step, all transitive dependencies are resolved,
    at some point going from application to platform modules.'
  id: totrans-839
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图3.11](part0016.html#filepos483083)模块解析为简化版ServiceMonitor应用程序构建模块图。在每一步中，解析一个模块，意味着它在可观察模块的宇宙中，并且它的依赖关系被添加到模块图中。逐步解析所有传递依赖，最终从应用程序模块过渡到平台模块。'
- en: 3.4.3 ADDING MODULES TO THE GRAPH
  id: totrans-840
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.4.3 向图中添加模块
- en: It’s important to note that modules that didn’t make it into the module graph
    during resolution aren’t available later during compilation or execution, either.
    For cases where all application code is in modules, this is often irrelevant.
    After all, following the rules for readability and accessibility, even if such
    modules were available, their types would be inaccessible because nobody reads
    the modules. But there are scenarios using more advanced features where this may
    pop up as a compile-time or runtime error or even as an application that doesn’t
    behave the way it’s supposed to.
  id: totrans-841
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的是要注意，在解析过程中没有进入模块图的模块，在编译或执行期间也不可用。对于所有应用程序代码都在模块中的情况，这通常无关紧要。毕竟，遵循可读性和可访问性的规则，即使这些模块可用，它们的类型也是不可访问的，因为没有人会阅读这些模块。但是，在更高级的功能使用场景中，这可能会作为编译时或运行时错误出现，甚至作为不符合预期行为的应用程序。
- en: Various use cases can lead to the scenario of modules not making it into the
    graph. One of them is reflection. It can be used to have code in one module call
    code in another without explicitly depending on it. But without that dependency,
    the depended-on module may not make it into the graph.
  id: totrans-842
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 各种用例可能导致模块无法进入图中的情况。其中之一是反射。它可以用来在一个模块中调用另一个模块中的代码，而不需要显式地依赖于它。但是没有这种依赖，被依赖的模块可能无法进入图。
- en: Assume there was some alternative statistics module, monitor.statistics.fancy,
    that couldn’t be present on the module path for each deployment of the service.
    (The reason is irrelevant, but let’s go with a license that prevents the fancy
    code from being used “for evil.” Evil masterminds that we are, we occasionally
    want to do just that.) So the module may sometimes be present and sometimes not,
    and hence no other module can require it because then the application couldn’t
    launch if the module was missing.
  id: totrans-843
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设存在一个替代的统计模块，名为monitor.statistics.fancy，它不能在每个服务的部署中都存在于模块路径上。（原因无关紧要，但让我们假设一个许可证阻止了fancy代码被用于“邪恶”目的。作为邪恶的幕后黑手，我们偶尔想这么做。）因此，该模块可能有时存在，有时不存在，因此没有其他模块可以要求它，因为如果模块缺失，应用程序将无法启动。
- en: How could the application handle that? The code depending on the fancy statistics
    library could use reflection to check whether the library is present and only
    call it if it is. But according to what you just learned, that will never be the
    case! By necessity, the fancy statistics module isn’t required by any other module
    and hence won’t end up in the module graph, meaning it can never be called. For
    these and other scenarios that pop up throughout the book, the module system offers
    a solution.
  id: totrans-844
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应用程序如何处理这种情况？依赖于fancy统计库的代码可以使用反射来检查库是否存在，并且只有在它存在时才调用它。但是根据你刚刚学到的，这种情况永远不会发生！由于必要性，fancy统计模块不被任何其他模块所依赖，因此不会出现在模块图中，这意味着它永远无法被调用。对于书中出现的这些和其他场景，模块系统提供了一个解决方案。
- en: 'Definition: --add-modules'
  id: totrans-845
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：--add-modules
- en: The option`--add-modules ${modules}`, available on `javac` and `java`, takes
    a comma-separated list of module names and defines them as root modules beyond
    the initial module. (As explained in section 3.4.1, root modules form the initial
    set of modules from which the module graph is built by resolving their dependencies.)
    This enables users to add modules (and their dependencies) to the module graph
    that would otherwise not show up because the initial module doesn’t directly or
    indirectly depend on them.
  id: totrans-846
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`javac`和`java`上的`--add-modules ${modules}`选项接受一个以逗号分隔的模块名称列表，并将它们定义为初始模块之外的根模块。（如3.4.1节所述，根模块形成初始模块集，通过解析它们的依赖关系构建模块图。）这使用户能够将模块（及其依赖关系）添加到模块图中，否则这些模块不会显示，因为初始模块既不直接也不间接依赖于它们。'
- en: 'The `--add-modules` option has three special values: `ALL-DEFAULT`, `ALL-SYSTEM`,
    and `ALL-MODULE-PATH`. The first two only work at run time and are used for edge
    cases this book doesn’t discuss. The last one can be useful, though: with it,
    all modules on the module path become root modules, and hence all of them make
    it into the module graph.'
  id: totrans-847
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`--add-modules` 选项有三个特殊值：`ALL-DEFAULT`、`ALL-SYSTEM` 和 `ALL-MODULE-PATH`。前两个仅在运行时工作，用于本书不讨论的边缘情况。最后一个可能很有用：使用它，模块路径上的所有模块都成为根模块，因此它们都进入模块图。'
- en: 'In the case of the ServiceMonitor application having an optional dependency
    on monitor.statistics.fancy, you have to make sure the module shows up in the
    module graph for those deployments that ship with it. In such cases, you’d use
    `--add-modules` `monitor.statistics.fancy` to make it a root module, causing the
    module system to add it and its dependencies to the module graph:'
  id: totrans-848
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 ServiceMonitor 应用程序具有对 monitor.statistics.fancy 的可选依赖的情况下，你必须确保模块出现在包含它的部署的模块图中。在这种情况下，你会使用
    `--add-modules` `monitor.statistics.fancy` 使其成为根模块，这将导致模块系统将其及其依赖项添加到模块图中：
- en: '`$ java --module-path mods:libs --add-modules monitor.statistics.fancy --module
    monitor`'
  id: totrans-849
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs --add-modules monitor.statistics.fancy --module
    monitor`'
- en: '![](../images/00063.jpeg)'
  id: totrans-850
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00063.jpeg)'
- en: '[Figure 3.12](part0016.html#filepos492106) The module graph for the simplified
    ServiceMonitor application from [figure 3.10](part0016.html#filepos445482), with
    the additional root module monitor.statistics.fancy defined with `--add-modules`.
    Neither the monitor module nor any of its dependencies depend on it, so it wouldn’t
    make it into the module graph without that option.'
  id: totrans-851
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 3.12](part0016.html#filepos492106) 从 [图 3.10](part0016.html#filepos445482)
    中简化后的 ServiceMonitor 应用程序模块图，其中定义了额外的根模块 monitor.statistics.fancy，使用 `--add-modules`
    选项。监控模块及其任何依赖都没有依赖于它，因此如果没有该选项，它就不会出现在模块图中。'
- en: You can see the resulting module graph in [figure 3.12](part0016.html#filepos490778).
  id: totrans-852
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在 [图 3.12](part0016.html#filepos490778) 中看到生成的模块图。
- en: 'A particularly important use case for `--add-modules` are JEE modules, which,
    as section 6.1 explains, aren’t resolved by default when running an application
    from the class path. Because you can add modules to the graph, it’s only natural
    to wonder whether you can also remove them. The answer is yes, kind of: the option
    `--limit-modules` goes in that direction, and section 5.3.4 shows how it works.'
  id: totrans-853
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`--add-modules` 选项的一个特别重要的用例是 JEE 模块，正如第 6.1 节所解释的，在从类路径运行应用程序时默认不会解析这些模块。因为你可以向图中添加模块，所以自然会想知道你是否也可以移除它们。答案是肯定的，但有点复杂：选项
    `--limit-modules` 就朝这个方向前进，第 5.3.4 节展示了它是如何工作的。'
- en: Unfortunately, it isn’t possible to let the module system know a specific dependency
    won’t be fulfilled and you’re OK with that. That would allow you to exclude (transitive)
    dependencies you don’t need. Judging by the number of exclusions I see in typical
    Maven POMs, this is common, but, alas, the module system’s strictness doesn’t
    allow it.
  id: totrans-854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不幸的是，无法让模块系统知道一个特定的依赖项不会得到满足，而你对此是可以接受的。这将允许你排除（传递性）你不需要的依赖项。根据我在典型的 Maven POM
    文件中看到的排除数量，这是常见的，但是，遗憾的是，模块系统的严格性不允许这样做。
- en: 3.4.4 ADDING EDGES TO THE GRAPH
  id: totrans-855
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.4.4 向图中添加边
- en: When a module is added explicitly, it’s on its own in the module graph, without
    any incoming reads edges. If access to it is purely reflective, that’s fine, because
    the reflection API implicitly adds a reads edge. But for regular access, such
    as when importing a type from it, accessibility rules require readability.
  id: totrans-856
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当一个模块被显式添加时，它在模块图中是独立的，没有任何传入的读取边。如果对其的访问完全是反射性的，那没关系，因为反射 API 会隐式添加一个读取边。但对于常规访问，例如从其中导入类型时，可访问性规则要求可读性。
- en: 'Definition: --add-reads'
  id: totrans-857
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：--add-reads
- en: The compiler-time and runtime option `--add-reads${module}=${targets}` adds
    reads edges from `${module}` to all modules in the comma-separated list`${targets}`.
    This allows`${module}` to access all public types in packages exported by those
    modules even though it has no `requires` directives mentioning them. If `${targets}`
    includes `ALL-UNNAMED, ${module}` can read the class-path content (that’s a little
    handwavy—see section 8.2 for details).
  id: totrans-858
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编译时和运行时选项 `--add-reads${module}=${targets}` 从 `${module}` 向逗号分隔的列表 `${targets}`
    中的所有模块添加读取边。这允许 `${module}` 访问那些模块导出的所有公共类型，即使它没有提及它们的 `requires` 指令。如果 `${targets}`
    包含 `ALL-UNNAMED`，则 `${module}` 可以读取类路径内容（这有点抽象——有关详细信息，请参阅第 8.2 节）。
- en: 'Back to monitor.statistics.fancy, you can use `add-reads` to allow monitor.statistics
    to read it:'
  id: totrans-859
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 回到 monitor.statistics.fancy，你可以使用 `add-reads` 允许 monitor.statistics 读取它：
- en: '`$ java --module-path mods:libs --add-modules monitor.statistics.fancy --add-reads
    monitor.statistics=monitor.statistics.fancy --module monitor`'
  id: totrans-860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs --add-modules monitor.statistics.fancy --add-reads
    monitor.statistics=monitor.statistics.fancy --module monitor`'
- en: The resulting module graph is the same as in [figure 3.12](part0016.html#filepos490778),
    except the dashed line is now replaced by a proper reads edge. Toward the end
    of section 8.3.2 is a case where `--add-reads … =ALL-UNNAMED` saves the day.
  id: totrans-861
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 结果模块图与[图3.12](part0016.html#filepos490778)中的相同，除了虚线现在被适当的读取边替换。在第8.3.2节的末尾有一个案例，其中`--add-reads
    … =ALL-UNNAMED`挽救了局面。
- en: 3.4.5 ACCESSIBILITY IS AN ONGOING EFFORT
  id: totrans-862
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.4.5 可访问性是一个持续的努力
- en: Once the module system has resolved all dependencies, built the module graph,
    and established readability between modules, it stays active by checking the accessibility
    rules section 3.3 defines. If these rules are broken, compile-time or runtime
    errors ensue, as shown in section 3.3.3\. If you encounter a problem with the
    module system and can’t tell from the error message what went wrong, see section
    5.3 for advice on how to debug the situation.
  id: totrans-863
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦模块系统解决了所有依赖项，构建了模块图，并在模块之间建立了可读性，它将通过检查第3.3节定义的可访问性规则来保持活跃。如果这些规则被违反，将导致编译时或运行时错误，如第3.3.3节所示。如果你遇到模块系统的问题，并且无法从错误信息中判断出了什么问题，请参阅第5.3节以获取有关如何调试这种情况的建议。
- en: If you’re interested in learning more about building and running modular applications,
    such as your own green-field projects, chapters 4 and 5 go deeper into that. Alternatively,
    you can check out the module system’s effects on your existing project in chapters
    6 and 7\. You’re also well-prepared to go deeper and check out the advanced features,
    particularly chapters 10 and 11.
  id: totrans-864
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你感兴趣了解更多关于构建和运行模块化应用程序的信息，例如你的绿色田野项目，第4章和第5章将更深入地探讨这一点。或者，你也可以在第6章和第7章中查看模块系统对你现有项目的影响。你也为深入了解并检查高级特性做好了准备，尤其是第10章和第11章。
- en: NOTE You’ve hit a milestone! You now understand how modules are defined, which
    mechanisms operate on that definition, and what effects they have—generally speaking,
    how Java works with modules.
  id: totrans-865
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：你已经达到了一个里程碑！你现在已经理解了模块是如何定义的，哪些机制作用于这个定义，以及它们有什么影响——一般来说，Java是如何与模块一起工作的。
- en: Summary
  id: totrans-866
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Modules come in two forms:'
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块有两种形式：
- en: The ones shipped with the Java runtime are platform modules. They’re merged
    into a `modules` file in the runtime’s `libs` directory. A JDK also holds them
    in raw form as JMOD files in the `jmods` directory. Only java.base, the base module,
    is explicitly known to the module system.
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随Java运行时一起提供的模块是平台模块。它们被合并到运行时`libs`目录中的`modules`文件中。JDK还以原始形式将它们作为JMOD文件存储在`jmods`目录中。只有`java.base`，即基本模块，是模块系统明确知道的。
- en: Library, framework, and application developers create modular JARs, which are
    plain JARs containing a module descriptor`module-info.class`. These are called
    application modules, with the one containing the `main` method being the initial
    module.
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库、框架和应用开发者创建模块化的JAR文件，这些是包含模块描述符`module-info.class`的普通JAR文件。这些被称为应用程序模块，其中包含`main`方法的那个是初始模块。
- en: 'The module descriptor is compiled from a module declaration`module-info.java`
    that developers (and tools) can edit. It lies at the heart of the work with the
    module system and defines a module’s properties:'
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块描述符是从模块声明`module-info.java`编译而来的，开发人员（和工具）可以编辑它。它是模块系统工作的核心，并定义了一个模块的属性：
- en: Its name, which should be globally unique due to the reverse-domain naming scheme
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的名字，由于反向域名命名方案，应该是全局唯一的
- en: Its dependencies, which are stated with `requires` directives that refer to
    other modules by name
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的依赖项，这些依赖项通过`requires`指令以名称引用其他模块
- en: Its API, which is defined by exporting selected packages with `exports` directives
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的API，这是通过`exports`指令导出选定的包来定义的
- en: Dependency declarations and the readability edges the module system is creating
    from them are the basis for reliable configuration. It’s achieved by making sure,
    among other things, that all modules are present exactly once and no dependency
    cycles exist between them. This allows you to catch application-corrupting or
    crashing problems earlier.
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖声明和模块系统从这些声明中创建的可读性边缘是可靠配置的基础。这是通过确保，在众多事情中，所有模块都恰好出现一次，并且它们之间不存在依赖循环来实现的。这允许你更早地捕捉到可能破坏应用程序或导致崩溃的问题。
- en: Readability edges and package exports together are the basis for strong encapsulation.
    Here the module system ensures that only public types in exported packages are
    accessible and only to modules that read the exporting one. This prevents accidental
    dependencies on transitive dependencies and enables you to make sure outside code
    can’t easily depend on types you designed as being internal to a module.
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可读性边缘和包导出共同构成了强封装的基础。在这里，模块系统确保只有导出包中的公共类型可访问，并且仅限于读取导出模块的模块。这防止了意外依赖传递依赖，并确保外部代码不能轻易依赖于您设计为模块内部类型的类型。
- en: Accessibility limitations apply to reflection as well! This requires a little
    more work to interact with reflection-based frameworks like Spring, Guice, or
    Hibernate.
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射也受到可访问性限制！与基于反射的框架（如Spring、Guice或Hibernate）交互需要做更多的工作。
- en: The module path (option `--module-path` or `-p`) consists of files or directories
    and makes JARs available to the module system, which will represent them as modules.
    Use it instead of the class path to make the compiler or JVM aware of your project’s
    artifacts.
  id: totrans-877
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块路径（选项`--module-path`或`-p`）由文件或目录组成，使JAR文件对模块系统可用，模块系统将它们表示为模块。使用它而不是类路径，使编译器或JVM意识到你的项目工件。
- en: The application modules, specified on the module path, and the platform modules,
    contained in the runtime, make up the universe of observable modules. During resolution,
    the universe is searched for modules, starting with root modules, so all required
    modules must either be on the module path or in the runtime.
  id: totrans-878
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指定在模块路径上的应用程序模块和包含在运行时中的平台模块构成了可观察模块的宇宙。在解析过程中，宇宙会搜索模块，从根模块开始，因此所有必需的模块必须位于模块路径上或在运行时中。
- en: Module resolution verifies that the configuration is reliable (all dependencies
    present, no ambiguities, and so on, as introduced in section 3.2) and results
    in the module graph—a close representation within the module system of how you
    see artifact dependencies. Only modules that make it into the module graph are
    available at run time.
  id: totrans-879
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块解析验证配置的可靠性（所有依赖项都存在，没有歧义等，如第3.2节所述）并生成模块图——这是模块系统中对您所看到的工件依赖关系的紧密表示。只有进入模块图的模块在运行时才可用。
- en: '4'
  id: totrans-880
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '4'
- en: Building modules from source to JAR
  id: totrans-881
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从源文件构建模块到JAR
- en: This chapter covers
  id: totrans-882
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Project directory structures
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目目录结构
- en: Compiling sources from a single module to class files
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从单个模块编译源文件到类文件
- en: Compiling multiple modules at the same time
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时编译多个模块
- en: Packaging class files into a modular JAR
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类文件打包到模块JAR中
- en: Being able to define modules as described in chapter 3 is a good skill to have,
    but what is it good for without knowing how to turn those source files into modular
    artifacts (JARs) that can be shipped and executed? This chapter looks into building
    modules, all the way from organizing sources, to compiling them to class files,
    and eventually packaging those into modular JARs that can be distributed and executed.
    Chapter 5 focuses on running and debugging modular applications.
  id: totrans-887
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 能够按照第3章所述定义模块是一项很好的技能，但如果没有知道如何将这些源文件转换为模块化工件（JAR文件）以便分发和执行，这些技能有什么用呢？本章探讨了构建模块的过程，从组织源文件，到将它们编译成类文件，最终将这些文件打包成可以分发和执行的模块化JAR文件。第5章专注于运行和调试模块化应用程序。
- en: 'At times we’ll look at the `javac` and `jar` commands available on the command
    line. You may be wondering about that—aren’t IDEs and other tools going to use
    them for you? Likely, yes, but even putting aside the argument that it’s always
    good to know how those tools work their magic, there is a more important reason
    to get to know these commands: they’re the most direct path into the module system’s
    heart. We’ll use them to explore its features inside and out, and when we’re done,
    you can use any tool that gives access to these features.'
  id: totrans-888
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时我们会查看命令行上可用的`javac`和`jar`命令。你可能想知道——IDE和其他工具不会为你使用它们吗？很可能，是的，但即使抛开总是了解这些工具如何施展魔法的论点，还有一个更重要的理由要了解这些命令：它们是进入模块系统核心的最直接途径。我们将使用它们来探索其内部和外部功能，完成后，你可以使用任何提供这些功能的工具。
- en: The first thing we’ll look at in this chapter is how a project’s files should
    be organized on disk (section 4.1). This may seem trivial, but a new recommendation
    is making the rounds and it’s worth looking into. With the sources laid out and
    the modules declared as described in chapter 3, we’ll turn to compiling them.
    This can happen one module at a time (section 4.2) or for multiple modules at
    once (section 4.3). The final section discusses how to package class files into
    modular JARs. To see some real-life build scripts, take a look at ServiceMonitor’s
    `master` branch.
  id: totrans-889
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先探讨项目文件在磁盘上的组织方式（第4.1节）。这看起来可能微不足道，但有一个新的建议正在流传，值得深入研究。在按照第3章所述布局源文件并声明模块后，我们将转向编译它们。这可以一次编译一个模块（第4.2节）或同时编译多个模块（第4.3节）。最后一节讨论了如何将类文件打包成模块化的JAR文件。要查看一些实际的构建脚本，请查看ServiceMonitor的`master`分支。
- en: By the end of this chapter, you’ll be able to organize, compile, and package
    your source code and module declarations. The resulting modular JARs are ready
    to be deployed or shipped to anyone who uses Java 9 or later and is ready to take
    full advantage of modules.
  id: totrans-890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够组织、编译和打包你的源代码和模块声明。生成的模块化JAR文件可以部署或发送给任何使用Java 9或更高版本并准备充分利用模块的人。
- en: 4.1 Organizing your project in a directory structure
  id: totrans-891
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.1 在目录结构中组织你的项目
- en: A real-life project consists of myriad files of many different types. Obviously,
    source files are the most important, but are nonetheless only one kind of many—others
    are test sources, resources, build scripts or project descriptions, documentation,
    source control information, and many others. Any project has to choose a directory
    structure to organize those files, and it’s important to make sure it doesn’t
    clash with the module system’s characteristics.
  id: totrans-892
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个真实的项目由许多不同类型的文件组成。显然，源文件是最重要的，但它们只是众多类型中的一种——其他还包括测试源文件、资源、构建脚本或项目描述、文档、源代码控制信息等等。任何项目都必须选择一个目录结构来组织这些文件，并且确保它不会与模块系统的特性冲突。
- en: If you’ve been following the module system’s development under Project Jigsaw
    and studied the official quick-start guide or early tutorials, you may have noticed
    that they use a particular directory structure. Let’s look at the recommendation
    to check whether it should become a new convention and juxtapose it with the established
    default that’s implicitly understood by tools like Maven and Gradle.
  id: totrans-893
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你一直在关注Project Jigsaw下的模块系统发展，并研究了官方的快速入门指南或早期的教程，你可能已经注意到它们使用了一种特定的目录结构。让我们看看这个建议，以确定它是否应该成为新的约定，并将其与Maven和Gradle等工具隐含理解的标准默认约定进行对比。
- en: 4.1.1 NEW PROPOSAL—NEW CONVENTION?
  id: totrans-894
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.1.1 新提议——新的约定？
- en: In early publications covering the module system, the project directory often
    contains a `src` directory in which each module that belongs to the project has
    its own subdirectory containing the project’s source files. If the project needs
    more than just sources, the proposal suggests organizing these concerns in parallel
    trees with folders like `test` and `build` next to `src`. This results in a hierarchy
    `concern/module`, as shown in [figure 4.1](part0017.html#filepos510835).
  id: totrans-895
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在早期关于模块系统的出版物中，项目目录通常包含一个`src`目录，其中每个属于项目的模块都有自己的子目录，包含项目的源文件。如果项目需要不仅仅是源文件，建议将这些相关内容组织成与`src`目录并行的树状结构，旁边有如`test`和`build`这样的文件夹。这导致了一个`concern/module`的层次结构，如图4.1所示[part0017.html#filepos510835]。
- en: '![](../images/00119.jpeg)'
  id: totrans-896
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00119.jpeg)'
- en: '[Figure 4.1](part0017.html#filepos510523) This structure has top-level directories
    `classes`, `mods`, `src`, and `test-src`. Sources of individual modules are in
    directories below `src` or `test-src` that have the module’s name.'
  id: totrans-897
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图4.1](part0017.html#filepos510523) 这种结构有顶级目录`classes`、`mods`、`src`和`test-src`。各个模块的源文件位于`src`或`test-src`目录下的子目录中，这些子目录以模块的名称命名。'
- en: 'It’s important to recognize this single-`src` structure for what it is: the
    structure of a particular project (the JDK) and a proposal used in introductory
    material. Due to its tendency to split a single module’s files across parallel
    trees, I wouldn’t advise following it for anything but the smallest projects or
    ones where a meticulous examination concludes that this structure is preferable.
    Otherwise, I recommend using the established default, which we’ll discuss next.'
  id: totrans-898
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 认识到这种单 `src` 结构的本质很重要：它是特定项目（JDK）的结构以及入门材料中使用的建议。由于其倾向于将单个模块的文件分散在平行的树中，我不建议除了最小的项目或经过细致检查后认为这种结构更优的项目外，使用这种结构。否则，我建议使用已建立的默认结构，我们将在下一节讨论。
- en: 4.1.2 ESTABLISHED DIRECTORY STRUCTURE
  id: totrans-899
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.1.2 建立的目录结构
- en: Most projects that consist of several subprojects (what we now call modules)
    prefer separate root directories, where each contains a single module’s sources,
    tests, resources, and everything else mentioned earlier. They use a hierarchy
    `module/concern`, and this is what established project structures provide.
  id: totrans-900
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数由多个子项目（我们现在称之为模块）组成的工程更喜欢使用独立的根目录，其中每个目录包含单个模块的源代码、测试、资源和之前提到的所有其他内容。它们使用
    `module/concern` 层次结构，这正是已建立的项目结构所提供的。
- en: The default directory structure, implicitly understood by tools like Maven and
    Gradle, implements that hierarchy (see [figure 4.2](part0017.html#filepos515413)).
    First and foremost, the default structure gives each module its own directory
    tree. In that tree, the `src` directory contains production code and resources
    (in `main/java` and `main/resources`, respectively) as well as test code and resources
    (in `test/java` and `test/resources`, respectively).
  id: totrans-901
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认目录结构，如 Maven 和 Gradle 等工具隐式理解的那样，实现了这种层次结构（参见[图 4.2](part0017.html#filepos515413)）。首先，默认结构为每个模块提供自己的目录树。在这个树中，`src`
    目录包含生产代码和资源（分别在 `main/java` 和 `main/resources` 中），以及测试代码和资源（分别在 `test/java` 和
    `test/resources` 中）。
- en: It’s no requirement to structure projects this way. Putting aside the added
    work of configuring build tools for deviating directories and the specific case
    of multimodule compilation (covered in section 4.3.), all structures are equally
    valid and should be chosen based on their merits for the project at hand.
  id: totrans-902
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 按这种方式组织项目结构并不是强制要求。抛开为偏离目录配置构建工具的额外工作，以及多模块编译的特定情况（在第 4.3 节中介绍），所有结构都是同等有效的，应根据项目本身的优点来选择。
- en: '![](../images/00069.jpeg)'
  id: totrans-903
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图 4.2](../images/00069.jpeg)'
- en: '[Figure 4.2](part0017.html#filepos513901) This structure has a top-level directory
    for each module. The modules can then organize their own files as best fits their
    needs. Here, monitor.observer uses the common directory structure used in Maven
    and Gradle projects.'
  id: totrans-904
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 4.2](part0017.html#filepos513901) 这种结构为每个模块都有一个顶级目录。模块可以根据自己的需求组织自己的文件。在这里，monitor.observer
    使用 Maven 和 Gradle 项目中常用的目录结构。'
- en: 'All of that being said, the examples in this book use this default structure
    with one exception: using the command line is less cumbersome if all modular JARs
    end up in the same directory, so the ServiceMonitor application’s tree has a top-level
    `mods` folder containing the created modules.'
  id: totrans-905
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说了这么多，本书中的示例使用这种默认结构，只有一个例外：如果所有模块 JAR 文件最终都位于同一目录下，使用命令行会更方便，因此 ServiceMonitor
    应用程序的树结构有一个顶层的 `mods` 文件夹，其中包含创建的模块。
- en: 4.1.3 THE PLACE FOR MODULE DECLARATIONS
  id: totrans-906
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.1.3 模块声明的位置
- en: 'However the source files are structured, module declarations have to be named
    `module-info.java`. Otherwise, the compiler produces an error like this one, which
    tries to compile `monitor-observer-info.java`:'
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论源文件如何组织，模块声明必须命名为 `module-info.java`。否则，编译器会产生类似于以下错误的错误，尝试编译 `monitor-observer-info.java`：
- en: '`> monitor.observer/src/main/java/monitor-observer-info.java:1: > error: module
    declarations should be in a file named module-info.java > module monitor.observer
    { > ^ > 1 error`'
  id: totrans-908
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> monitor.observer/src/main/java/monitor-observer-info.java:1: > 错误：模块声明应在名为
    module-info.java 的文件中 > module monitor.observer { > ^ > 1 个错误`'
- en: Although not strictly necessary, the declaration should be located in the root
    source directory. Otherwise, using the module source path as described in section
    4.3.2 doesn’t work properly because the module system can’t locate the descriptor.
    As a consequence, it doesn’t recognize the module, leading to “module not found”
    errors.
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然不是严格必要的，但声明应位于根源目录中。否则，如第 4.3.2 节所述使用模块源路径将无法正常工作，因为模块系统无法定位描述符。结果，它无法识别模块，导致“找不到模块”错误。
- en: 'To try that out, move the descriptor of monitor.observer into a different directory
    and compile monitor. As you can see, this results in an error that the module
    monitor.observer, which is required by monitor, can’t be found:'
  id: totrans-910
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了尝试这一点，将monitor.observer的描述符移动到不同的目录，并编译monitor。正如你所看到的，这导致了一个错误，即monitor所需的模块monitor.observer找不到：
- en: '`> ./monitor/src/main/java/module-info.java:2: > error: module not found: monitor.observer
    > requires monitor.observer; > ^ > 1 error`'
  id: totrans-911
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> ./monitor/src/main/java/module-info.java:2: > 错误：找不到模块：monitor.observer
    > requires monitor.observer; > ^ > 1 错误`'
- en: 4.2 Compiling a single module
  id: totrans-912
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.2 编译单个模块
- en: Once the project files are laid out in a directory structure, some code has
    been written, and the module declarations are created, it’s time to compile the
    source files. But what will it be—a collection of types or a shiny module? Because
    the former didn’t change, we’ll focus on the latter before exploring how the compiler
    discerns the two cases.
  id: totrans-913
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦项目文件以目录结构排列，编写了一些代码，创建了模块声明，就到了编译源文件的时候。但它将是一个类型集合还是一个闪亮的模块？因为前者没有变化，所以我们将在探索编译器如何区分这两种情况之前，先关注后者。
- en: 4.2.1 COMPILING MODULAR CODE
  id: totrans-914
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.2.1 编译模块化代码
- en: This section focuses on the compilation of a single module in a world where
    all dependencies are already modularized. You can only compile a module if a declaration
    `module-info.java` is among the source files, so let’s assume this is the case.
  id: totrans-915
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本节重点介绍在一个所有依赖都已模块化的世界中编译单个模块的过程。只有当源文件中包含`module-info.java`声明时，才能编译模块，所以让我们假设这种情况成立。
- en: In addition to operating on the module path and checking readability and accessibility,
    another addition to the compiler is its ability to process module declarations.
    The result of compiling a module declaration is a module descriptor, a file `module-info.class`.
    Like other `.class` files, it contains bytecode and can be analyzed and manipulated
    by tools like ASM and Apache’s Byte Code Engineering Library (BCEL).
  id: totrans-916
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了在模块路径上操作并检查可读性和可访问性之外，编译器还增加了一个处理模块声明的能力。编译模块声明的结果是一个模块描述符，一个名为`module-info.class`的文件。像其他`.class`文件一样，它包含字节码，可以被像ASM和Apache的字节码工程库（BCEL）这样的工具分析和操作。
- en: Other than using the module path instead of the class path, compilation works
    exactly as it did before Java 9\. The compiler will compile all given files and
    produce a directory structure that matches the package hierarchy in the output
    directory specified with `-d`.
  id: totrans-917
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了使用模块路径而不是类路径之外，编译的工作方式与Java 9之前完全相同。编译器将编译所有给定的文件，并生成一个与输出目录中指定的`-d`选项匹配的包层次结构的目录结构。
- en: '[Figure 4.3](part0017.html#filepos523459) shows how the monitor.observer module,
    which uses the default directory structure, is laid out. To compile it, you create
    a `javac` call that’s similar to what you would have done before Java 9:'
  id: totrans-918
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图4.3](part0017.html#filepos523459)显示了使用默认目录结构的monitor.observer模块的布局。要编译它，你需要创建一个类似于Java
    9之前的`javac`调用：'
- en: The `--module-path` option points the compiler to the directory that contains
    required application modules.
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--module-path`选项指示编译器指向包含所需应用程序模块的目录。'
- en: The `-d` options determines the target directory for the compilation; it works
    the same as before Java 9.
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`选项确定编译的目标目录；它与Java 9之前的工作方式相同。'
- en: List or `find` all source files in `monitor.observer/src/main/java/`, including
    `module-info.java` (represented by `${source-files}`).
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出或`find` `monitor.observer/src/main/java/`中的所有源文件，包括`module-info.java`（由`${source-files}`表示）。
- en: '![](../images/00076.jpeg)'
  id: totrans-922
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00076.jpeg)'
- en: '[Figure 4.3](part0017.html#filepos521702) Directory structure of the monitor.observer
    module with the `src` directory expanded'
  id: totrans-923
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图4.3](part0017.html#filepos521702) monitor.observer模块的目录结构，其中`src`目录已展开'
- en: 'Put together, you issue the following command in the ServiceMonitor application’s
    root directory (i.e. the one containingmonitor.observer):'
  id: totrans-924
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在ServiceMonitor应用程序的根目录（即包含monitor.observer的目录）中，你需要执行以下命令：
- en: '`$ javac --module-path mods -d monitor.observer/target/classes ${source-files}`'
  id: totrans-925
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac --module-path mods -d monitor.observer/target/classes ${source-files}`'
- en: Collapsing `src` and looking into `target/classes`, [figure 4.4](part0017.html#filepos525299)
    shows the expected result.
  id: totrans-926
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 展开查看`src`目录，然后查看`target/classes`，[图4.4](part0017.html#filepos525299)显示了预期的结果。
- en: '![](../images/00108.jpeg)'
  id: totrans-927
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00108.jpeg)'
- en: '[Figure 4.4](part0017.html#filepos524962) Directory structure of the monitor.observer
    module with the `target` directory expanded'
  id: totrans-928
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图4.4](part0017.html#filepos524962) monitor.observer模块的目录结构，其中`target`目录已展开'
- en: 4.2.2 MODULAR OR NON-MODULAR?
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.2.2 模块化或非模块化？
- en: The Java Platform Module System is built with the intention to create and eventually
    run modules, but this is by no means mandatory. It’s still possible to build plain
    JARs, and this begs the question of how these two cases are distinguished. How
    does the compiler know whether to create a module or a bunch of types?
  id: totrans-930
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java平台模块系统旨在创建并最终运行模块，但这绝对不是强制性的。仍然可以构建普通的JAR文件，这引发了如何区分这两种情况的问题。编译器如何知道是创建一个模块还是一堆类型？
- en: ESSENTIAL INFO As discussed in section 3.1.2, a modular JAR is nothing but a
    plain JAR with a module descriptor `module-info.class`, which is compiled from
    a module declaration `module-info.java`. For that reason, the compiler uses the
    presence or absence of `module-info.java` in the list of sources to compile that
    to discern whether it works on a module. That’s why there is no compiler option
    `--create-module` or similar.
  id: totrans-931
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要信息：如第3.1.2节所述，模块化JAR文件只不过是一个带有模块描述符`module-info.class`的普通JAR文件，该描述符是从模块声明`module-info.java`编译而来的。因此，编译器使用源文件列表中是否存在`module-info.java`来编译，以区分它是否在模块上工作。这就是为什么没有`--create-module`或类似的编译器选项。
- en: What’s the difference between compiling a module and compiling just types? It
    comes down do readability, as explained in section 3.2\. If code that includes
    a module declaration is compiled
  id: totrans-932
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编译模块和仅编译类型之间有什么区别？这归结于可读性，如第3.2节所述。如果包含模块声明的代码被编译
- en: It must require its dependencies to be able to access the types these dependencies
    export
  id: totrans-933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须要求其依赖项能够访问这些依赖项导出的类型
- en: The required dependencies have to be present
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须存在所需的依赖
- en: If, on the other hand, non-modular code is compiled, no dependencies are expressed,
    due to the lack of a module declaration. In that case, the module system lets
    the code under compilation read all modules and everything it finds on the class
    path. Section 8.2 goes into detail on that classpath mode.
  id: totrans-935
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 相反，如果编译非模块化代码，由于缺少模块声明，不会表达任何依赖。在这种情况下，模块系统允许正在编译的代码读取所有模块以及它在类路径上找到的所有内容。第8.2节详细介绍了这种类路径模式。
- en: In contrast to readability, the accessibility rules described in section 3.3
    apply to both cases. Regardless of whether the code is compiled as a module or
    as a bunch of sources, it’s bound to the rules when accessing types in other modules.
    This is particularly relevant regarding JDK-internal classes, be they public classes
    in non-exported packages or nonpublic classes, because they’re inaccessible regardless
    of how code is compiled. [Figure 4.5](part0017.html#filepos529582) shows the difference
    between readability and accessibility.
  id: totrans-936
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与可读性不同，第3.3节中描述的可访问性规则适用于两种情况。无论代码是作为模块还是作为一堆源文件编译，它都会在访问其他模块中的类型时受到规则的约束。这尤其与JDK内部类有关，无论是非导出包中的公共类还是非公共类，因为无论代码如何编译，它们都是不可访问的。[图4.5](part0017.html#filepos529582)显示了可读性和可访问性之间的区别。
- en: '![](../images/00104.jpeg)'
  id: totrans-937
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00104.jpeg)'
- en: '[Figure 4.5](part0017.html#filepos529212) Comparing the compilation of non-modular
    code (left) with modular code (right). Readability rules differ slightly whereas
    accessibility rules are identical.'
  id: totrans-938
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图4.5](part0017.html#filepos529212)比较非模块化代码（左）与模块化代码（右）的编译。可读性规则略有不同，而可访问性规则是相同的。'
- en: A Note about compiler errors
  id: totrans-939
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于编译器错误的说明
- en: Let’s pick the ServiceMonitor application as an example. Its subproject monitor
    contains the source files `Main.java`, `Monitor.java`, and `module-info.java`.
  id: totrans-940
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们以ServiceMonitor应用程序为例。它的子项目monitor包含源文件`Main.java`、`Monitor.java`和`module-info.java`。
- en: If you include the module declaration in the list of files, `javac` sets out
    to compile a module and verifies that all dependencies on application and platform
    modules are declared in the descriptor. If you leave it out, the compiler falls
    back to only recognizing dependencies between types, as shown in [figure 3.1](part0016.html#filepos363629).
  id: totrans-941
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你在文件列表中包含了模块声明，`javac` 将开始编译一个模块，并验证所有对应用程序和平台模块的依赖是否已在描述符中声明。如果你省略了它，编译器将回退到仅识别类型之间的依赖，如[图3.1](part0016.html#filepos363629)所示。
- en: 'But regardless of whether monitor is compiled as a module or not, if it uses
    types that the JDK modules or other application modules don’t make accessible,
    the result will be the same: a compile error.'
  id: totrans-942
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但无论监控器是否作为模块编译，如果它使用了JDK模块或其他应用程序模块没有公开的类型，结果将是相同的：编译错误。
- en: Compiling a module obviously requires clearing more hurdles than compiling just
    types. So why do it? Again, I come back to the comparison to writing code in a
    statically typed language. As Java developers, we generally believe that static
    typing is worth the additional upfront costs because in exchange, we get fast
    and reliable consistency checks. They don’t prevent all errors, but they do prevent
    a lot of them.
  id: totrans-943
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 显然，编译一个模块比编译类型需要克服更多的障碍。那么，为什么要这样做呢？再次，我回到与在静态类型语言中编写代码的比较。作为 Java 开发者，我们通常认为静态类型是值得额外前期成本的，因为作为交换，我们得到了快速和可靠的一致性检查。它们不能防止所有错误，但确实可以防止很多错误。
- en: 'The same applies here: using the module system to compile modules requires
    more effort than creating plain JARs, but in exchange we get checks that reduce
    the likelihood of runtime errors. We exchange compile-time effort for runtime
    safety—a deal I’ll make any day of the week.'
  id: totrans-944
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 同样的情况也适用于这里：使用模块系统编译模块比创建普通的 JAR 文件需要更多的努力，但作为交换，我们得到了减少运行时错误可能性的检查。我们用编译时的努力换取运行时的安全性——这是我会每天都会做的交易。
- en: 4.3 Compiling multiple modules
  id: totrans-945
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.3 编译多个模块
- en: 'Compiling a single module as just described is straightforward, and compiling
    all seven ServiceMonitor modules is more of the same. But is it necessary to compile
    modules one by one? Or, to look at it another way, is there any reason not to
    do it like that? The answer to the latter is yes, a few details may make it preferable
    to compile multiple modules at once:'
  id: totrans-946
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如此描述的编译单个模块是直接的，编译所有七个 ServiceMonitor 模块也是类似的。但是，有必要逐个编译模块吗？或者，换一种说法，有没有不这样做的原因？对后者的回答是肯定的，一些细节可能使得一次性编译多个模块更可取：
- en: Effort —Although compiling a single module is simple, the effort required for
    multiple modules adds up quickly. And it surely feels redundant to more or less
    repeat the same command over and over with only slight variations. Chances are
    you’ll rarely do that by hand unless you’re experimenting with Java 9\. But the
    developers working on your tools should be considered as well.
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 努力程度——虽然编译单个模块很简单，但编译多个模块所需的工作量会迅速增加。而且，反复几乎重复相同的命令，只有细微的变化，这无疑感觉是多余的。除非你在尝试
    Java 9，否则你很少会手动这样做。但你的工具的开发者也应该被考虑在内。
- en: Performance —Compiling a single module descriptor takes about half a second
    on my system, and compiling all modules of the ServiceMonitor application takes
    about four. That’s a little much, considering that there are less than 20 source
    files involved and full builds of much larger projects take less time. It stands
    to reason that I pay the price for launching the compiler seven times (for seven
    modules).
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能——在我的系统上，编译单个模块描述符大约需要半秒钟，编译 ServiceMonitor 应用程序的所有模块大约需要四秒钟。考虑到涉及的源文件不到 20
    个，而更大项目的完整构建所需时间更短，这有点多。从逻辑上讲，我支付了启动编译器七次（为七个模块）的代价。
- en: Weak circular dependencies—Although the module system forbids circular dependencies
    with `requires` directives, there are other ways to have modules reference one
    another (trust me for now) that are deemed acceptable. Although the dependencies
    are circular, they can be considered weak because if the right one is missing,
    you only get a warning. Still, warning-free compilation is worth some effort,
    and to get there, both modules must be compiled together.
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弱循环依赖——尽管模块系统禁止使用 `requires` 指令来创建循环依赖，但还有其他方式让模块相互引用（现在就相信我）被认为是可接受的。尽管依赖是循环的，但它们可以被认为是弱的，因为如果缺少正确的依赖，你只会得到一个警告。尽管如此，无警告的编译还是值得一些努力的，为了达到这个目标，两个模块必须一起编译。
- en: ESSENTIAL INFO With a few reasons to compile multiple modules at once, it’s
    a good thing the compiler can do just that!
  id: totrans-950
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有关一次性编译多个模块的几个原因，编译器能够做到这一点是件好事！
- en: 4.3.1 THE NAIVE APPROACH
  id: totrans-951
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.3.1 原始方法
- en: 'How does compiling multiple modules at once work? Can you list source files
    from several modules and have the compiler figure it out? Nope:'
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一次性编译多个模块是如何工作的？你能列出几个模块的源文件，让编译器自己处理吗？不行的：
- en: '`$ javac --module-path mods:libs -d classes monitor/src/main/java/module-info.java
    monitor.rest/src/main/java/module-info.java  > monitor.rest/src/main/java/module-info.java:1:
    > error: too many module declarations found > module monitor.rest { > ^ > 1 error`'
  id: totrans-953
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac --module-path mods:libs -d classes monitor/src/main/java/module-info.java
    monitor.rest/src/main/java/module-info.java  > monitor.rest/src/main/java/module-info.java:1:
    > error: too many module declarations found > module monitor.rest { > ^ > 1 error`'
- en: Clearly, the compiler prefers to work on a single module at a time. This makes
    sense, too, because as discussed previously, it enforces readability and accessibility
    based on clearly defined module boundaries. Where would they come from, with sources
    from many different modules mixed up in the list of files to compile? Somehow
    the compiler needs to know where one module ends and the next begins.
  id: totrans-954
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 显然，编译器更喜欢一次处理一个模块。这也是有道理的，因为如前所述，它通过明确定义的模块边界来强制执行可读性和可访问性。如果许多不同模块的源文件混合在编译文件列表中，它们从何而来？编译器需要以某种方式知道一个模块在哪里结束，下一个模块在哪里开始。
- en: '4.3.2 THE MODULE SOURCE PATH: INFORMING THE COMPILER ABOUT THE PROJECT STRUCTURE'
  id: totrans-955
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.3.2 模块源路径：通知编译器关于项目结构
- en: The way out of that default single-module mode is a command-line option that
    informs the compiler about the project’s directory structure. The compiler supports
    multimodule compilation, where it can build multiple modules at once. The command-line
    option `--module-source-path ${path}` is used to enable this mode and to point
    out the directory structure containing the modules. All other compiler options
    work as usual.
  id: totrans-956
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从默认的单模块模式中解脱出来的方法是使用一个命令行选项来通知编译器关于项目的目录结构。编译器支持多模块编译，它可以在一次构建中构建多个模块。命令行选项
    `--module-source-path ${path}` 用于启用此模式并指出包含模块的目录结构。所有其他编译器选项都按常规工作。
- en: That sounds pretty easy, but there are important details to consider. Before
    doing that, though, let’s get a simple example to work.
  id: totrans-957
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这听起来很简单，但还有一些重要的细节需要考虑。不过，在这样做之前，让我们先从一个简单的例子开始。
- en: Let’s assume for a moment the ServiceMonitor application used the single-`src`
    structure defined in section 4.1.1 with all module source directories below `src`
    (see [figure 4.6](part0017.html#filepos539803)). Then you could use `--module-source-path
    src` to point the compiler toward the `src` folder, which contains all the modules’
    sources, and tell it to compile everything it finds at once.
  id: totrans-958
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设一下，ServiceMonitor 应用程序使用了第 4.1.1 节中定义的单个 `src` 结构，所有模块源目录都在 `src` 之下（参见 [图
    4.6](part0017.html#filepos539803)）。然后你可以使用 `--module-source-path src` 来指向包含所有模块源代码的
    `src` 文件夹，并告诉它一次性编译它找到的所有内容。
- en: '![](../images/00054.jpeg)'
  id: totrans-959
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00054.jpeg)'
- en: '[Figure 4.6](part0017.html#filepos539104) The module source path is easiest
    to use if the project has a single `src` directory with each module’s root source
    directory below it.'
  id: totrans-960
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 4.6](part0017.html#filepos539104) 如果项目只有一个 `src` 目录，并且每个模块的根源目录位于其下，那么模块源路径的使用最为简单。'
- en: As with a single-module build, the module path is used to point the compiler
    to the directory that contains required application modules—in this case, these
    are external dependencies because all ServiceMonitor modules are currently being
    compiled. The `-d` option works the same way as with a single-module build, and
    you still list all source files in `src`, including all module declarations.
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与单模块构建一样，模块路径用于指向包含所需应用程序模块的目录——在这种情况下，这些是外部依赖，因为所有 ServiceMonitor 模块目前都在编译中。`-d`
    选项与单模块构建中的用法相同，你仍然需要在 `src` 中列出所有源文件，包括所有模块声明。
- en: 'Put together, this is the command:'
  id: totrans-962
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 组合起来，这是以下命令：
- en: '`$ javac --module-path mods:libs --module-source-path src -d classes ${source-files}`'
  id: totrans-963
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac --module-path mods:libs --module-source-path src -d classes ${source-files}`'
- en: A look into `classes` shows a directory per module, each containing that module’s
    class files, including the module descriptor. Neat.
  id: totrans-964
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看 `classes` 目录可以看到每个模块都有一个目录，每个目录都包含该模块的类文件，包括模块描述符。整洁。
- en: But it’s not always that easy. How would this apply to a project that doesn’t
    use the single-`src` structure? This is where a nifty detail of the module source
    path comes in.
  id: totrans-965
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但并非总是那么简单。如果项目不使用单 `src` 结构，这该如何应用？这就是模块源路径的一个巧妙细节发挥作用的地方。
- en: 4.3.3 THE ASTERISK AS A TOKEN FOR THE MODULE NAME
  id: totrans-966
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.3.3 模块名称的通配符
- en: The module source path can contain an asterisk (`*`). Although it’s commonly
    interpreted as a wildcard, which in paths usually means “anything in the directory
    up to the asterisk,” this isn’t the case here. Instead, the asterisk functions
    as a token that indicates where on the path the module names appear. The rest
    of the path after the asterisk must point to the directory containing the modules’
    packages.
  id: totrans-967
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块源路径可以包含一个星号 (`*`)。虽然它通常被解释为通配符，在路径中通常表示“星号之前的目录中的任何内容”，但这在这里不是这种情况。相反，星号作为一个标记，指示模块名称在路径上的位置。星号之后路径的其余部分必须指向包含模块包的目录。
- en: This way, the compiler can match source file paths to the module source path
    and deduce which module a source file belongs to. For that to work, each source
    file must match the module source path.
  id: totrans-968
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这样，编译器可以将源文件路径与模块源路径匹配，并推断出源文件属于哪个模块。为了使这工作，每个源文件都必须匹配模块源路径。
- en: 'This may seem complicated, but an example will clarify. Let’s return to the
    ServiceMonitor application as structured in section 4.1.2, where each module has
    the common `src/main/java` directories that contain the source files. Starting
    in the project’s top-level directory, these are the relative paths to some of
    the sources:'
  id: totrans-969
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这可能看起来很复杂，但一个例子会澄清。让我们回到4.1.2节中结构化的ServiceMonitor应用程序，其中每个模块都有包含源文件的公共`src/main/java`目录。从项目的顶级目录开始，这些是某些源文件的相对路径：
- en: '`monitor/src/main/java/monitor/Monitor.java`'
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monitor/src/main/java/monitor/Monitor.java`'
- en: '`monitor/src/main/java/monitor/Main.java`'
  id: totrans-971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monitor/src/main/java/monitor/Main.java`'
- en: '`monitor/src/main/java/module-info.java`'
  id: totrans-972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monitor/src/main/java/module-info.java`'
- en: '`monitor.rest/src/main/java/monitor/rest/MonitorServer.java`'
  id: totrans-973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monitor.rest/src/main/java/monitor/rest/MonitorServer.java`'
- en: '`monitor.rest/src/main/java/module-info.java`'
  id: totrans-974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monitor.rest/src/main/java/module-info.java`'
- en: '`monitor.persistence/src/main/java/monitor/persistence/StatisticsRepository.java`'
  id: totrans-975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monitor.persistence/src/main/java/monitor/persistence/StatisticsRepository.java`'
- en: '`monitor.persistence/src/main/java/module-info.java`'
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monitor.persistence/src/main/java/module-info.java`'
- en: 'This makes the shared structure pretty obvious: all paths follow the schema
    `${modules}/src/main/java/${packages}/${sources}`.'
  id: totrans-977
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这样，共享结构就非常明显了：所有路径都遵循模式`${modules}/src/main/java/${packages}/${sources}`。
- en: 'Looking back at how the module source path is to be used, you can see that
    `${modules}` must be replaced with `*` and that you have to omit the package directories,
    leaving `*/src/main/java`. Unfortunately, it doesn’t work yet, because the compiler
    doesn’t accept the asterisk as the first character—you have to pad it with `./`.
    Now, multimodule compilation works like a charm:'
  id: totrans-978
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 回顾一下模块源路径的使用方法，你可以看到`${modules}`必须替换为`*`，并且你必须省略包目录，留下`*/src/main/java`。不幸的是，它现在还不工作，因为编译器不接受星号作为第一个字符——你必须用`.`填充它。现在，多模块编译工作得像魔法一样：
- en: '`$ javac --module-path mods:libs --module-source-path "./*/src/main/java" -d
    classes ${source-files}`'
  id: totrans-979
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac --module-path mods:libs --module-source-path "./*/src/main/java" -d
    classes ${source-files}`'
- en: As before, all class files end up in module-specific subdirectories of `classes`.
    With what you know about the asterisk being a token for the module name, you could
    summarize those paths as `-d classes/*`. Unfortunately, the `-d` option doesn’t
    understand the token, and you can’t use it to build output paths like `./*/target/classes`.
    What a shame.
  id: totrans-980
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与之前一样，所有类文件最终都会放在`classes`目录下的模块特定子目录中。根据你对星号是模块名称标记的了解，你可以将这些路径总结为`-d classes/*`。不幸的是，`-d`选项并不理解这个标记，你不能用它来构建输出路径，如`./*/target/classes`。真遗憾。
- en: You may wonder how the asterisk relates to the use of `--module-source-path
    src` in the first example. After all, there you didn’t specify where the module
    names would appear, and the compiler was able to deduce them. What may look like
    an inconsistency at first glance is an effort to make the simple case simple to
    use.
  id: totrans-981
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能会想知道星号是如何与第一个例子中`--module-source-path src`的使用相关的。毕竟，在那里你没有指定模块名称将出现在哪里，编译器能够推断出来。乍一看可能看似不一致，但这其实是为了使简单情况的使用更加简单。
- en: If the module source path contains no asterisk, the compiler will silently add
    it as the final path element. So you’ve effectively been specifying `src/*` as
    the module source path, which matches the directory structure in that example.
  id: totrans-982
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果模块源路径不包含星号，编译器会静默地将其添加为最后一个路径元素。所以你实际上已经指定了`src/*`作为模块源路径，这与该示例中的目录结构相匹配。
- en: Being able to compile multiple modules if all use the same directory structure
    should cover most cases. For those with more complicated setups, we need another
    technique.
  id: totrans-983
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果所有模块都使用相同的目录结构，那么编译多个模块应该可以覆盖大多数情况。对于设置更复杂的那些，我们需要另一种技术。
- en: 4.3.4 MULTIPLE MODULE SOURCE PATH ENTRIES
  id: totrans-984
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.3.4 多个模块源路径条目
- en: It’s possible a single module source path doesn’t suffice. Maybe different modules
    have different directory structures or some modules have sources in more than
    one directory. In such cases, you can specify several module source path entries
    to make sure every source file matches a path.
  id: totrans-985
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有可能单个模块源路径不足以满足需求。也许不同的模块有不同的目录结构，或者某些模块的源文件分布在多个目录中。在这种情况下，你可以指定多个模块源路径条目，以确保每个源文件都匹配一个路径。
- en: The JDK, being a complex project, has a nontrivial directory structure. [Figure
    4.7](part0017.html#filepos549729) shows just a tiny snippet of it—there are many
    more directories on all levels.
  id: totrans-986
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JDK 是一个复杂的项目，具有非平凡的目录结构。[图 4.7](part0017.html#filepos549729) 仅展示了其中的一小部分——在所有级别上还有许多更多的目录。
- en: '![](../images/00124.jpeg)'
  id: totrans-987
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00124.jpeg)'
- en: '[Figure 4.7](part0017.html#filepos549338) A limited view into the JDK’s source
    directories. Note how the module directories below `src` are further divided.
    It’s the `classes` directories further below that are the roots for the actual
    source files.'
  id: totrans-988
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 4.7](part0017.html#filepos549338) 对 JDK 源目录的有限视角。注意 `src` 下的模块目录是如何进一步细分的。实际上源文件的根目录是位于更下方的
    `classes` 目录。'
- en: Assuming you’re in the directory `jdk` and want to build for UNIX, what would
    a module source path look like that spans all modules and the correct source folders?
    The path to the UNIX sources is `src/java.desktop/unix/classes` or, more generally,
    src/${module}/unix/classes. Similarly, for the shared sources, it’s `src/${module}/share/classes`.
    Putting these two together, you get
  id: totrans-989
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你位于 `jdk` 目录中，并想要为 UNIX 构建项目，一个跨越所有模块和正确源文件夹的模块源路径会是什么样子？UNIX 源的路径是 `src/java.desktop/unix/classes`
    或更一般地，`src/${module}/unix/classes`。同样，对于共享源，它是 `src/${module}/share/classes`。将这两个路径组合起来，你得到
- en: '`--module-source-path "src/*/unix/classes":"src/*/share/classes"`'
  id: totrans-990
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`--module-source-path "src/*/unix/classes":"src/*/share/classes"`'
- en: 'To reduce redundancy, the module source path lets you define alternative paths
    with `{dir1,dir2}`. You can unify various paths if they only differ in the name
    of single path elements. With alternatives, you can unify the paths to source
    in `share` and `unix` as follows:'
  id: totrans-991
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了减少冗余，模块源路径允许你使用 `{dir1,dir2}` 定义替代路径。如果你只需要统一路径元素名称的不同路径，你可以统一这些路径。使用替代路径，你可以将
    `share` 和 `unix` 中的源路径统一如下：
- en: '`--module-source-path "src/*/{share,unix}/classes"`'
  id: totrans-992
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`--module-source-path "src/*/{share,unix}/classes"`'
- en: 4.3.5 SETTING THE INITIAL MODULE
  id: totrans-993
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.3.5 设置初始模块
- en: 'With everything set up for multimodule compilation, another possibility opens
    up: compiling a single module and its dependencies just by naming it. Why would
    you want to do that? Because it no longer requires you to explicitly list the
    source files to compile!'
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在为多模块编译设置好一切之后，又出现了一种可能性：只需命名即可编译单个模块及其依赖项。你为什么想要这样做呢？因为这样做不再需要你明确列出要编译的源文件！
- en: If the module source path is set, the option `--module` lets you compile a single
    module and its transitive dependencies without explicitly listing the source files.
    The module source path is used to determine which source files belong to the specified
    module, and dependencies are resolved based on its declaration.
  id: totrans-995
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果设置了模块源路径，`--module` 选项允许你编译单个模块及其传递依赖项，而无需明确列出源文件。模块源路径用于确定哪些源文件属于指定的模块，并且依赖项是根据其声明来解决的。
- en: 'Compiling monitor.rest and its dependencies is now easy. As before, you use
    `--module-path mods:libs` to specify where to find dependencies and `-d classes`
    to define the output folder. With `--module-source-path "./*/src/main/java"`,
    you inform the compiler of your project’s directory structure; and with `--module
    monitor.rest`, you command it to start with compiling monitor.rest:'
  id: totrans-996
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编译 `monitor.rest` 及其依赖项现在变得简单。和以前一样，你使用 `--module-path mods:libs` 来指定依赖项的位置，并使用
    `-d classes` 来定义输出文件夹。通过 `--module-source-path "./*/src/main/java"`，你通知编译器你的项目目录结构；并且通过
    `--module monitor.rest`，你命令它从编译 `monitor.rest` 开始：
- en: '`$ javac --module-path mods:libs --module-source-path "./*/src/main/java" -d
    classes --module monitor.rest`'
  id: totrans-997
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac --module-path mods:libs --module-source-path "./*/src/main/java" -d
    classes --module monitor.rest`'
- en: If `classes` was empty before, it now contains class files for `monitor.rest`
    (specified module), `monitor.statistics` (direct dependency), and `monitor.observer`
    (transitive dependency).
  id: totrans-998
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 `classes` 之前是空的，现在它包含了 `monitor.rest`（指定模块）、`monitor.statistics`（直接依赖）和 `monitor.observer`（间接依赖）的类文件。
- en: 'Listings 2.3, 2.4, and 2.5 showed how to compile the ServiceMonitor application
    step by step. Armed with the knowledge of how to use multimodule compilation,
    it could instead be done as easily as the following:'
  id: totrans-999
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 2.3、2.4 和 2.5 展示了如何逐步编译 ServiceMonitor 应用程序。掌握了如何使用多模块编译的知识，它也可以像以下这样轻松完成：
- en: '`$ javac --module-path mods:libs --module-source-path "./*/src/main/java" -d
    classes --module monitor`'
  id: totrans-1000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac --module-path mods:libs --module-source-path "./*/src/main/java" -d
    classes --module monitor`'
- en: Because the initial module monitor depends on all other modules, all of them
    are built. Unlike with the step-by-step approach, the class files don’t go in
    `*/target/classes`, but in `classes/*` (using `*` as a token for the module name).
  id: totrans-1001
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于初始模块监控器依赖于所有其他模块，因此所有模块都会被构建。与逐步方法不同，类文件不会放入`*/target/classes`，而是放入`classes/*`（使用`*`作为模块名称的占位符）。
- en: In addition to making the command easier to read, the combination of `--module-source-path`
    and `--module` also operates on a higher level of abstraction. As opposed to listing
    individual source files, it clearly states the intent of compiling a specific
    module. I like that.
  id: totrans-1002
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了使命令更容易阅读外，`--module-source-path`和`--module`的组合也在更高层次上操作。与列出单个源文件相比，它清楚地说明了编译特定模块的意图。我喜欢这一点。
- en: 'There are two downsides, though:'
  id: totrans-1003
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管如此，有两个缺点：
- en: The compiled class files can’t be redistributed into deeper directory structures
    and instead all end up below the same directory (in the recent examples, `classes`).
    If following stages of the build process depend on a precise location of those
    files, additional preparatory steps would have to be taken, which may void the
    advantages of using the module source path in the first place.
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译后的类文件不能重新分发到更深层次的目录结构中，而是全部位于相同的目录下（在最近的例子中，是`classes`目录）。如果构建过程的后续阶段依赖于这些文件的精确位置，就必须采取额外的准备步骤，这可能会抵消最初使用模块源路径的优势。
- en: 'If compilation is kicked off with `--module` (as opposed to listing all module’s
    source files), the compiler will apply optimizations that can lead to unexpected
    results. One of them is unused code detection: classes that aren’t transitively
    referenced from the initial module aren’t compiled, and even entire modules can
    be missing from the output if they were decoupled via services (see chapter 10).'
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用`--module`（而不是列出所有模块的源文件）启动编译，编译器将应用可能导致意外结果的优化。其中之一是未使用代码检测：没有从初始模块间接引用的类不会被编译，如果通过服务解耦，甚至整个模块可能从输出中缺失（见第10章）。
- en: 4.3.6 IS IT WORTH IT?
  id: totrans-1006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.3.6 是否值得？
- en: 'Does multimodule compilation pay off? I listed three reasons to motivate its
    use, so it makes sense to return to them:'
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 多模块编译是否有回报？我列出了三个理由来鼓励其使用，因此有必要回到它们：
- en: Effort —Once you grasp how the module source path has to be constructed, it’s
    considerably less effort to compile multiple modules. This expressly includes
    building a particular module and its dependencies, which becomes easier as well.
    At the same time, build tools usually compile projects one by one, and configuring
    them to do so all at once may add complexity, particularly if further steps have
    to be taken to distribute the class files into module-specific directories.
  id: totrans-1008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 努力程度——一旦你掌握了如何构建模块源路径，编译多个模块的工作量就会大大减少。这明确包括构建特定模块及其依赖项，这也会变得更容易。同时，构建工具通常逐个编译项目，将它们配置为一次性编译可能会增加复杂性，尤其是如果还需要采取进一步步骤将类文件分发到特定模块的目录中。
- en: Performance —With multimodule compilation, the ServiceMonitor application builds
    in less than a second, which is four times faster than building seven modules
    step by step. But this is a pretty extreme case, because each module contains
    only two or three classes. Relatively speaking, there’s a lot of overhead in launching
    the compiler seven times; but in absolute terms, it comes down to only three seconds.
    Given the build time of any decently sized project, shaving off a couple of seconds
    is hardly worth making the build more complex.
  id: totrans-1009
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能——使用多模块编译，ServiceMonitor应用程序的构建时间不到一秒，这比逐步构建七个模块快四倍。但这是一个相当极端的例子，因为每个模块只包含两到三个类。相对而言，启动编译器七次的开销很大；但从绝对意义上来说，这仅仅减少了三秒钟。考虑到任何适度规模项目的构建时间，减少几秒钟几乎不值得使构建更加复杂。
- en: Weak circular dependencies—In this case, there’s no way around multimodule compilation
    if the build should be free of warnings.
  id: totrans-1010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弱循环依赖——在这种情况下，如果构建过程中应该没有警告，那么就没有办法绕过多模块编译。
- en: 'Multimodule compilation is optional, and its benefits aren’t substantial enough
    to recommend it as the default practice. Particularly if your tools don’t support
    it seamlessly, setting it up may not be worth the effort. This is a classic “it
    depends” situation. I have to say, though, I like it for operating on a higher
    level of abstraction: modules instead of just types.'
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 多模块编译是可选的，其好处并不足以推荐它作为默认实践。尤其是如果你的工具不支持无缝集成，设置它可能不值得付出努力。这是一个典型的“视情况而定”的情况。不过，我必须说，我喜欢它在更高层次上操作：模块而不是仅仅类型。
- en: 4.4 Compiler options
  id: totrans-1012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.4 编译器选项
- en: With the module system comes a host of new command-line options that are explained
    throughout this book. To make sure you can easily find them, [table 4.1](part0017.html#filepos562040)
    lists all of those pertaining to the compiler. Have a look at [https://docs.oracle.com/javase/9/tools/javac.htm](https://docs.oracle.com/javase/9/tools/javac.htm)
    for the official compiler documentation.
  id: totrans-1013
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统带来了许多新的命令行选项，本书中对此进行了详细解释。为了确保你可以轻松找到它们，[表4.1](part0017.html#filepos562040)列出了所有与编译器相关的选项。查看[https://docs.oracle.com/javase/9/tools/javac.htm](https://docs.oracle.com/javase/9/tools/javac.htm)以获取官方编译器文档。
- en: Table 4.1 An alphabetized table of all module-related compiler (`javac` command)
    options. The descriptions are based on the documentation, and the references point
    to the sections in this book that explain in detail how to use the options.
  id: totrans-1014
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表4.1 所有模块相关编译器（`javac`命令）选项的字母顺序表。描述基于文档，引用指向本书中解释如何使用选项的章节。
- en: '| Option   | Description   | Ref.   |'
  id: totrans-1015
  prefs: []
  type: TYPE_TB
  zh: '| 选项   | 描述   | 参考   |'
- en: '| `--add-exports`   | Lets a module export additional packages   | 11.3.4   |'
  id: totrans-1016
  prefs: []
  type: TYPE_TB
  zh: '| `--add-exports`   | 允许模块导出额外的包   | 11.3.4   |'
- en: '| `--add-modules`   | Defines root modules in addition to the initial module   |
    3.4.3   |'
  id: totrans-1017
  prefs: []
  type: TYPE_TB
  zh: '| `--add-modules`   | 除了初始模块外，还定义根模块   | 3.4.3   |'
- en: '| `--add-reads`   | Adds read edges between modules   | 3.4.4   |'
  id: totrans-1018
  prefs: []
  type: TYPE_TB
  zh: '| `--add-reads`   | 在模块之间添加读取边   | 3.4.4   |'
- en: '| `--limit-modules`   | Limits the universe of observable modules   | 5.3.5   |'
  id: totrans-1019
  prefs: []
  type: TYPE_TB
  zh: '| `--limit-modules`   | 限制可观察模块的宇宙   | 5.3.5   |'
- en: '| `--module`, `-m`   | Sets the initial module   | 4.3.5   |'
  id: totrans-1020
  prefs: []
  type: TYPE_TB
  zh: '| `--module`, `-m`   | 设置初始模块   | 4.3.5   |'
- en: '| `--module-path`, `-p`   | Specifies where to find application modules   |
    3.4   |'
  id: totrans-1021
  prefs: []
  type: TYPE_TB
  zh: '| `--module-path`, `-p`   | 指定查找应用程序模块的位置   | 3.4   |'
- en: '| `--module-source-path`   | Conveys a project’s directory structure   | 4.3.2   |'
  id: totrans-1022
  prefs: []
  type: TYPE_TB
  zh: '| `--module-source-path`   | 传达项目的目录结构   | 4.3.2   |'
- en: '| `--module-version`   | Specifies the version of the modules under compilation   |
    13.2.1   |'
  id: totrans-1023
  prefs: []
  type: TYPE_TB
  zh: '| `--module-version`   | 指定编译中模块的版本   | 13.2.1   |'
- en: '| `--patch-module`   | Extends an existing module with classes during the course
    of compilation   | 7.2.4   |'
  id: totrans-1024
  prefs: []
  type: TYPE_TB
  zh: '| `--patch-module`   | 在编译过程中用类扩展现有模块   | 7.2.4   |'
- en: '| `--processor-module-path`   | Specifies where to find annotation processor
    modules   | 4.2.1   |'
  id: totrans-1025
  prefs: []
  type: TYPE_TB
  zh: '| `--processor-module-path`   | 指定查找注解处理器模块的位置   | 4.2.1   |'
- en: '| `--system`   | Overrides the location of system modules   |    |'
  id: totrans-1026
  prefs: []
  type: TYPE_TB
  zh: '| `--system`   | 覆盖系统模块的位置   |    |'
- en: '| `--upgrade-module-path`   | Defines the location of upgradeable modules   |
    6.1.3   |'
  id: totrans-1027
  prefs: []
  type: TYPE_TB
  zh: '| `--upgrade-module-path`   | 定义可升级模块的位置   | 6.1.3   |'
- en: New --release option
  id: totrans-1028
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 新的`--release`选项
- en: Have you ever used the `-source` and `-target` options to compile your code
    to run on an older version of Java, only to see it crash at runtime because a
    method call failed with a seemingly inexplicable error? Maybe you forgot to specify
    `-bootclasspath`.
  id: totrans-1029
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你是否曾经使用过`-source`和`-target`选项来编译你的代码，以便在较旧的Java版本上运行，但看到它在运行时崩溃，因为一个方法调用失败，出现了一个看似无法解释的错误？也许你忘记指定了`-bootclasspath`。
- en: Without that option, the compiler creates bytecode that a JVM with the target
    version understands (good), but it links against the current version’s core library
    API (bad). That can create calls to types or methods that didn’t exist in the
    older JDK version and thus cause runtime errors.
  id: totrans-1030
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 没有这个选项，编译器会创建JVM可以理解的字节码（好），但它会链接到当前版本的核心库API（不好）。这可能导致调用在旧JDK版本中不存在的类型或方法，从而引起运行时错误。
- en: From Java 9 on, the compiler prevents that common operating error with the `--release`
    option that sets all three options to the correct value.
  id: totrans-1031
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从Java 9开始，编译器通过`--release`选项防止了这种常见的操作错误，该选项将所有三个选项设置为正确的值。
- en: 4.5 Packaging a modular JAR
  id: totrans-1032
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.5 打包模块化JAR
- en: 'On the way from idea to running code, the next step after coding and compiling
    is to take the class files and package them as a module. As section 3.1.2 explains,
    this should result in a modular JAR, which is just like a plain JAR but contains
    the module’s descriptor `module-info.class`. Consequently, you expect the trusted
    `jar` tool to be in charge of packaging. This is how simple it is to create a
    modular JAR (in this case for monitor.observer):'
  id: totrans-1033
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在从想法到运行代码的过程中，编码和编译之后的下一步是将类文件打包成一个模块。正如3.1.2节所解释的，这应该生成一个模块化的JAR文件，它就像一个普通的JAR文件一样，但包含模块的描述符`module-info.class`。因此，你期望可信的`jar`工具负责打包。创建一个模块化的JAR文件（在这种情况下为monitor.observer）就是这么简单：
- en: '`$ jar --create --file mods/monitor.observer.jar -C monitor.observer/target/classes
    .`'
  id: totrans-1034
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --create --file mods/monitor.observer.jar -C monitor.observer/target/classes
    .`'
- en: Putting the new command-line aliases aside, this call works exactly the same
    as before Java 9\. The interesting and implicit detail is that because `monitor.observer/target/classes`
    contains a `module-info.class`, so will the resulting `monitor.observer.jar`,
    making it a modular JAR.
  id: totrans-1035
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将新的命令行别名放在一边，这个调用与 Java 9 之前完全相同。有趣且隐含的细节是，因为 `monitor.observer/target/classes`
    包含一个 `module-info.class`，所以生成的 `monitor.observer.jar` 也将包含它，使其成为一个模块化 JAR。
- en: Although the `jar` tool works much like before, there are a couple of module-related
    details and additions, like defining a module’s entry point, that we should look
    at.
  id: totrans-1036
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然 `jar` 工具的工作方式与之前相似，但有一些与模块相关的细节和新增功能，例如定义模块的入口点，我们应该看看。
- en: NOTE JAR isn’t the only format used to deliver Java bytecode. JEE also works
    with WAR and EAR files. Until the specification is updated to embrace modules,
    though, it isn’t possible to create modular WARs or EARs.
  id: totrans-1037
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：JAR 不是唯一用于交付 Java 字节码的格式。JEE 还与 WAR 和 EAR 文件一起工作。尽管如此，在规范更新以接受模块之前，无法创建模块化的
    WAR 或 EAR。
- en: 4.5.1 QUICK RECAP OF JAR
  id: totrans-1038
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.5.1 JAR 的快速回顾
- en: To make sure we’re all on the same page, let’s take a quick look at how `jar`
    is used to package archives. As I just pointed out, the result is a modular JAR
    if the list of included files contains a module descriptor `module-info.class`.
  id: totrans-1039
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了确保我们都在同一页面上，让我们快速看一下 `jar` 是如何用于打包存档的。正如我刚才指出的，如果包含的文件列表中包含模块描述符 `module-info.class`，则结果是一个模块化
    JAR。
- en: 'Let’s take the command that packages monitor.observer as an example. The result
    is a `module.observer.jar` in `mods` that contains all class files from `monitor.observer/target/classes`
    and its subdirectories. Because `classes` contains a module descriptor, the JAR
    will also contain it and thus be a modular JAR without any additional effort:'
  id: totrans-1040
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们以打包 `monitor.observer` 的命令为例。结果是 `mods` 中的 `module.observer.jar`，它包含 `monitor.observer/target/classes`
    及其子目录中的所有类文件。因为 `classes` 包含一个模块描述符，所以 JAR 也将包含它，因此无需额外努力就是一个模块化 JAR：
- en: '`$ jar --create` [`①`](part0017.html#filepos582321)`--file mods/monitor.observer.jar`
    [`②`](part0017.html#filepos582706)`-C monitor.observer/target/classes .` [`③`](part0017.html#filepos583072)'
  id: totrans-1041
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --create` [`①`](part0017.html#filepos582321)`--file mods/monitor.observer.jar`
    [`②`](part0017.html#filepos582706)`-C monitor.observer/target/classes .` [`③`](part0017.html#filepos583072)'
- en: ①
  id: totrans-1042
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: This operation mode indicates the creation of an archive (alternative is -c).
  id: totrans-1043
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此操作模式表示创建一个存档（另一种选择是 -c）。
- en: ②
  id: totrans-1044
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Name of the archive file to be created (alternative is -f)
  id: totrans-1045
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要创建的存档文件名（另一种选择是 -f）
- en: ③
  id: totrans-1046
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: -C makes jar change into the specified folder, and the dot (.) tells it to include
    all source files in the folder.
  id: totrans-1047
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -C 使 jar 变为指定的文件夹，点号 (.) 告诉它包含文件夹中的所有源文件。
- en: You should consider recording a module’s version with `--module-version` when
    packaging it. Section 13.2.1 explains how to do that.
  id: totrans-1048
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在打包模块时，您应该考虑使用 `--module-version` 记录模块的版本。第 13.2.1 节解释了如何进行操作。
- en: 4.5.2 ANALYZING A JAR
  id: totrans-1049
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.5.2 分析 JAR
- en: When working with JARs, it helps to know ways to analyze what you’ve created.
    Particularly important are the files a JAR contains and what its module descriptor
    has to say. Fortunately, `jar` has options for both.
  id: totrans-1050
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当与 JAR 一起工作时，了解分析您所创建内容的方法很有帮助。特别是，了解 JAR 包含的文件以及其模块描述符的内容非常重要。幸运的是，`jar` 有选项可以做到这两点。
- en: LISTING A JAR’S CONTENTS
  id: totrans-1051
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列出 JAR 的内容
- en: 'The most obvious thing to do is to look at a JAR’s contents, which is possible
    with `--list`. The following snippet shows the content of the `monitor.observer.jar`
    created in the previous section. It contains a `META-INF` folder, which we don’t
    go into because it’s been around for years and doesn’t pertain to the module system.
    There’s also a module descriptor, and `DiagnosticDataPoint` and `ServiceObserver`
    classes in the package `monitor.observer`. Nothing spectacular or unexpected:'
  id: totrans-1052
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最明显的事情是查看 JAR 的内容，这可以通过 `--list` 实现。以下片段显示了上一节创建的 `monitor.observer.jar` 的内容。它包含一个
    `META-INF` 文件夹，我们不会深入探讨，因为它已经存在多年，并且与模块系统无关。还有一个模块描述符，以及 `monitor.observer` 包中的
    `DiagnosticDataPoint` 和 `ServiceObserver` 类。没有什么特别或意外的：
- en: '`$ jar --list --file mods/monitor.observer.jar  > META-INF/ > META-INF/MANIFEST.MF
    > module-info.class > monitor/ > monitor/observer/ > monitor/observer/DiagnosticDataPoint.class
    > monitor/observer/ServiceObserver.class`'
  id: totrans-1053
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --list --file mods/monitor.observer.jar  > META-INF/ > META-INF/MANIFEST.MF
    > module-info.class > monitor/ > monitor/observer/ > monitor/observer/DiagnosticDataPoint.class
    > monitor/observer/ServiceObserver.class`'
- en: 'This is not a new command—it just looks different due to new aliases: `--list`
    is long for `–t`, and `--file` is long for `-f`. Before Java 9, `jar -t -f some.jar`
    would have done the same thing.'
  id: totrans-1054
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这不是一个新命令——它只是因为新的别名而看起来不同：`--list`是`–t`的简写，`--file`是`-f`的简写。在Java 9之前，`jar -t
    -f some.jar`会做同样的事情。
- en: EXAMINING MODULE DESCRIPTOR
  id: totrans-1055
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查模块描述符
- en: 'A module descriptor is a class file and thus consists of bytecode. This makes
    it necessary to use tools to look at its content. Fortunately, `jar` can do that
    with `--describe-module` (alternatively `-d`). Examining `monitor.observer.jar`,
    you see that it’s a module named monitor.observer that exports a package of the
    same name and requires the base module:'
  id: totrans-1056
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块描述符是一个类文件，因此由字节码组成。这使得使用工具查看其内容成为必要。幸运的是，`jar`可以使用`--describe-module`（或`-d`）来做这件事。检查`monitor.observer.jar`，你会发现它是一个名为`monitor.observer`的模块，导出同名的包并需要基础模块：
- en: '`$ jar --describe-module --file mods/monitor.observer.jar  > monitor.observer
    jar:.../monitor.observer.jar/!module-info.class > exports monitor.observer > requires
    java.base mandated`'
  id: totrans-1057
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --describe-module --file mods/monitor.observer.jar  > monitor.observer
    jar:.../monitor.observer.jar/!module-info.class > exports monitor.observer > requires
    java.base mandated`'
- en: (If you wonder what `mandated` means, remember from section 3.1.4 that every
    module implicitly requires the base module, meaning the presence of java.base
    is mandated.)
  id: totrans-1058
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （如果你想知道`mandated`是什么意思，记得从3.1.4节中了解到，每个模块隐式地需要基础模块，这意味着必须存在`java.base`。）
- en: 4.5.3 DEFINING AN ENTRY POINT
  id: totrans-1059
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.5.3 定义入口点
- en: To launch a Java application, it’s necessary to know the entry point, which
    is one of the classes containing a `public static void main(String[])` method.
    A class containing that method can either be specified on the command line when
    the application launches or be recorded in the manifest file that ships with the
    JAR. Don’t worry if you don’t know exactly how one or even both of these options
    work, because Java 9 adds a third one that’s the way to go with modules.
  id: totrans-1060
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要启动一个Java应用程序，必须知道入口点，它是包含`public static void main(String[])`方法的类之一。包含该方法的类可以在应用程序启动时在命令行上指定，或者记录在随JAR文件一起提供的清单文件中。如果你不知道这些选项是如何工作的，不必担心，因为Java
    9增加了一个第三种方式，即使用模块的方式。
- en: When `jar` is used to package class files into an archive, you can define a
    main class with `--main-class ${class}`, where `${class}` is the fully qualified
    name (meaning the package name appended with a dot and the class name) of the
    class with the `main` method. It will be recorded in the module descriptor and
    used by default as the main class when the module is the initial module for launching
    an application (see section 5.1 for details).
  id: totrans-1061
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当使用`jar`将类文件打包到归档中时，你可以使用`--main-class ${class}`定义主类，其中`${class}`是包含`main`方法的类的完全限定名（意味着包名后跟一个点和类名）。它将被记录在模块描述符中，并在模块是启动应用程序的初始模块时默认用作主类（有关详细信息，请参阅5.1节）。
- en: NOTE If you’re used to setting the manifest’s `Main-Class` entry for creating
    executable JARs, you’ll be pleased to hear that `jar --main-class` sets it as
    well.
  id: totrans-1062
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：如果你习惯于设置清单的`Main-Class`条目来创建可执行JAR文件，你将很高兴地听到`jar --main-class`也会设置它。
- en: 'The ServiceMonitor application has a single entry point in `monitor.Main`.
    You can use `--main-class monitor.Main` to record that during packaging:'
  id: totrans-1063
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ServiceMonitor应用程序在`monitor.Main`中有一个单一的入口点。你可以使用`--main-class monitor.Main`来记录在打包过程中的情况：
- en: '`$ jar --create --file mods/monitor.jar --main-class monitor.Main -C monitor/target/classes
    .`'
  id: totrans-1064
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --create --file mods/monitor.jar --main-class monitor.Main -C monitor/target/classes
    .`'
- en: 'Using `--describe-module`, you can see that the main class was recorded in
    the descriptor:'
  id: totrans-1065
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用`--describe-module`，你可以看到主类已被记录在描述符中：
- en: '`$ jar --describe-module --file mods/monitor.jar  > monitor jar:.../monitor.jar/!module-info.class
    # requires and contains truncated > main-class monitor.Main`'
  id: totrans-1066
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --describe-module --file mods/monitor.jar  > monitor jar:.../monitor.jar/!module-info.class
    # requires and contains truncated > main-class monitor.Main`'
- en: It’s interesting that the `jar` tool has neither the capabilities nor the responsibility
    to verify your claim that there is such a class. There’s no check of whether it
    exists or whether it contains a suitable `main` method. If things go wrong, no
    error will occur now, but launching the module will fail.
  id: totrans-1067
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 很有趣的是，`jar`工具既没有验证你声称存在此类的能力，也没有责任。没有检查它是否存在或是否包含合适的`main`方法。如果出现问题，现在不会发生错误，但启动模块将失败。
- en: 4.5.4 ARCHIVER OPTIONS
  id: totrans-1068
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.5.4 归档器选项
- en: We just explored only the most important options `jar` has to offer. A couple
    of others become interesting in different contexts and are explained in the relevant
    chapters. To make sure you can find them easily, [table 4.2](part0017.html#filepos594445)
    lists the options that have to do with the module system. Visit [https://docs.oracle.com/javase/9/tools/jar.htm](https://docs.oracle.com/javase/9/tools/jar.htm)
    for the official `jar` documentation.
  id: totrans-1069
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们只探索了 `jar` 提供的最重要选项。其他一些选项在不同的上下文中变得有趣，并在相关章节中解释。为了确保您可以轻松找到它们，[表 4.2](part0017.html#filepos594445)
    列出了与模块系统相关的选项。访问 [https://docs.oracle.com/javase/9/tools/jar.htm](https://docs.oracle.com/javase/9/tools/jar.htm)
    获取官方 `jar` 文档。
- en: Table 4.2 An alphabetized table of all module-related archiver (`jar` command)
    options. The descriptions are based on the documentation, and the references point
    to the sections in this book that explain in detail how to use the options.
  id: totrans-1070
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表 4.2 所有模块相关归档器（`jar` 命令）选项的字母顺序表。描述基于文档，参考信息指向本书中解释如何使用选项的章节。
- en: '| Option   | Description   | Ref.   |'
  id: totrans-1071
  prefs: []
  type: TYPE_TB
  zh: '| 选项   | 描述   | 参考信息   |'
- en: '| `--hash-modules`   | Records hashes of dependent modules   |    |'
  id: totrans-1072
  prefs: []
  type: TYPE_TB
  zh: '| `--hash-modules`   | 记录依赖模块的哈希值   |    |'
- en: '| `--describe-module`, `-d`   | Shows the module’s name, dependencies, exports,
    packages, and more   | 4.5.2   |'
  id: totrans-1073
  prefs: []
  type: TYPE_TB
  zh: '| `--describe-module`, `-d`   | 显示模块的名称、依赖项、导出、包等   | 4.5.2   |'
- en: '| `--main-class`   | Application entry point   | 4.5.3   |'
  id: totrans-1074
  prefs: []
  type: TYPE_TB
  zh: '| `--main-class`   | 应用程序入口点   | 4.5.3   |'
- en: '| `--module-path`, `-p`   | Specifies where to find application modules for
    recording hashes   | 3.4   |'
  id: totrans-1075
  prefs: []
  type: TYPE_TB
  zh: '| `--module-path`, `-p`   | 指定查找应用程序模块以记录哈希值的位置   | 3.4   |'
- en: '| `--module-version`   | Specifies the version of the modules under compilation   |
    13.2.1   |'
  id: totrans-1076
  prefs: []
  type: TYPE_TB
  zh: '| `--module-version`   | 指定编译中模块的版本   | 13.2.1   |'
- en: '| `--release`   | Creates a multi-release JAR containing bytecode for different
    Java versions   | Appendix E   |'
  id: totrans-1077
  prefs: []
  type: TYPE_TB
  zh: '| `--release`   | 创建包含不同 Java 版本字节码的多版本 JAR 文件   | 附录 E   |'
- en: '| `--update`   | Updates an existing archive, for example by adding more class
    files   | 9.3.3   |'
  id: totrans-1078
  prefs: []
  type: TYPE_TB
  zh: '| `--update`   | 更新现有归档，例如通过添加更多类文件   | 9.3.3   |'
- en: Summary
  id: totrans-1079
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: Make sure to pick a directory structure that fulfills your project’s requirements.
    If in doubt, stick to your build system’s default structure.
  id: totrans-1080
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保选择满足项目要求的目录结构。如果有疑问，请坚持使用构建系统的默认结构。
- en: The `javac` command to compile all of a module’s sources, including the declaration,
    is the same as before Java 9, except that it uses the module path instead of the
    class path.
  id: totrans-1081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译一个模块的所有源代码（包括声明）的 `javac` 命令与 Java 9 之前相同，除了它使用模块路径而不是类路径。
- en: The module source path (`--module-source-path`) informs the compiler of how
    the project is structured. This lifts the compiler operation from processing types
    to processing modules, allowing you to compile a selected module and all its dependencies
    with a simple option (`--module` or `-m`) instead of listing source files.
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块源路径（`--module-source-path`）通知编译器项目是如何结构的。这使编译器操作从处理类型提升到处理模块，允许您使用简单选项（`--module`
    或 `-m`）编译所选模块及其所有依赖项，而不是列出源文件。
- en: Modular JARs are just JARs with a module descriptor `module-info.class`. The
    `jar` tool processes them just as well as other class files, so packaging all
    of them into a JAR requires no new options.
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化 JAR 文件只是带有模块描述符 `module-info.class` 的 JAR 文件。`jar` 工具对它们处理得和其他类文件一样好，因此将它们全部打包到
    JAR 文件中不需要任何新选项。
- en: Optionally, `jar` allows the specification of a module’s entry point (with `--main-class`),
    which is the class with the `main` method. This makes launching the module simpler.
  id: totrans-1084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，`jar` 允许指定模块的入口点（使用 `--main-class`），这是具有 `main` 方法的类。这使得启动模块变得简单。
- en: '5'
  id: totrans-1085
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '5'
- en: Running and debugging modular applications
  id: totrans-1086
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行和调试模块化应用程序
- en: This chapter covers
  id: totrans-1087
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Launching a modular application by specifying an initial module
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定初始模块启动模块化应用程序
- en: Loading resources from modules
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模块中加载资源
- en: Validating modules, sets of modules, and module graphs
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证模块、模块集和模块图
- en: Reducing and listing the universe of observable modules
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少和列出可观察模块的宇宙
- en: Debugging a modular application with logging
  id: totrans-1092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用日志调试模块化应用程序
- en: 'With modules defined, compiled, and packaged into modular JARs as explained
    in chapters 3 and 4, it’s finally time to power up the JVM and run applications
    with the `java` command. This gives us the opportunity to discuss a runtime-related
    concept: how to load resources from modules (section 5.2). Sooner or later things
    will go wrong, though, so in section 5.3 we also look into debugging a module
    configuration with a variety of command-line options.'
  id: totrans-1093
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如第3章和第4章所述，将模块定义、编译并打包成模块化JAR文件后，终于到了使用`java`命令启动JVM和运行应用程序的时候了。这为我们提供了讨论与运行时相关的概念的机会：如何从模块中加载资源（第5.2节）。然而，迟早会遇到问题，因此第5.3节还将探讨使用各种命令行选项调试模块配置。
- en: By the end of the chapter, you’ll be able to launch an application made up of
    modules. Beyond that, you’ll have a firm understanding of how the module system
    processes a given configuration and how that can be observed through logging and
    other diagnostic tools.
  id: totrans-1094
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够启动由模块组成的程序。除此之外，你将深刻理解模块系统如何处理给定的配置，以及如何通过日志和其他诊断工具来观察这一点。
- en: This also finishes part 1 of the book, which teaches everything you need to
    know to write, compile, and run simple modular applications. It lays the groundwork
    for the more advanced features that parts 2 and 3 are going to look into, chief
    among them those that support a gradual migration to the module system.
  id: totrans-1095
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这也完成了本书的第一部分，它教授了你编写、编译和运行简单模块化应用程序所需的一切知识。它为第二部分和第三部分将要探讨的更高级功能奠定了基础，其中最重要的是那些支持逐步迁移到模块系统的功能。
- en: 5.1 Launching the JVM with modules
  id: totrans-1096
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.1 使用模块启动JVM
- en: After all the build-up—defining module dependencies and APIs, creating modular
    JARs, and placing them on the module path—launching the JVM with a modular application
    is embarrassingly easy. All you need to do is specify the initial module and maybe
    the main class.
  id: totrans-1097
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在定义模块依赖关系和API、创建模块化JAR文件并将它们放置在模块路径上之后，使用模块化应用程序启动JVM竟然如此简单。你只需要指定初始模块，也许还需要指定主类。
- en: The `java` command has an option `--module ${module}` that specifies the initial
    module ${module}. Module resolution starts from there, and it’s also the module
    from which a main class, meaning one with a `public static void main` method,
    will be launched.
  id: totrans-1098
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`java`命令有一个`--module ${module}`选项，它指定了初始模块${module}。模块解析从这里开始，并且这也是将启动具有`public
    static void main`方法的main类的模块。'
- en: The specific class is either defined by the initial module’s descriptor or specified
    with `--module ${module}/${class}` by appending the module name with a slash and
    the fully qualified class name (see section 5.1.1).
  id: totrans-1099
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 特定的类要么由初始模块的描述符定义，要么通过在模块名称后附加一个斜杠和完全限定的类名（见5.1.1节）来使用`--module ${module}/${class}`指定。
- en: 'For the ServiceMonitor application, all preparations culminate in the call
    you’ve already seen, which launches the JVM with monitor as the initial module:'
  id: totrans-1100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于ServiceMonitor应用程序，所有准备工作最终都集中在你已经看到的调用上，该调用以monitor作为初始模块启动JVM：
- en: '`$ java --module-path mods:libs --module monitor`'
  id: totrans-1101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs --module monitor`'
- en: 'As discussed in section 3.4, `--module-path mods:libs` informs the module system
    that the `mods` and `libs` directories contain ServiceMonitor’s application modules.
    The option `--module monitor` defines monitor as the initial module, as a consequence
    of which the module system will resolve all of monitor’s dependencies and build
    the module graph as discussed in the previous section. It will then launch the
    main class you set in the module descriptor during packaging in section 4.5.3:
    `monitor.Main`.'
  id: totrans-1102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如第3.4节所述，`--module-path mods:libs`通知模块系统`mods`和`libs`目录包含ServiceMonitor的应用程序模块。选项`--module
    monitor`将monitor定义为初始模块，因此模块系统将解析monitor的所有依赖关系，并构建如前所述的模块图。然后，它将启动在第4.5.3节打包期间在模块描述符中设置的main类：`monitor.Main`。
- en: 5.1.1 SPECIFYING THE MAIN CLASS
  id: totrans-1103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.1.1 指定主类
- en: The `--module` option can also be used to define the application’s main class.
    To this end, the initial module’s name is followed by a forward slash and the
    fully qualified class name (package name followed by a dot and the class name).
  id: totrans-1104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`--module`选项也可以用来定义应用程序的主类。为此，初始模块的名称后面跟着一个正斜杠和完全限定的类名（包名后跟一个点和类名）。'
- en: 'Here, you explicitly define that the application is launched by calling the
    `main` method in monitor’s class `monitor.Main`:'
  id: totrans-1105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这里，你明确地定义了应用程序是通过在监控器的类`monitor.Main`中调用`main`方法来启动的：
- en: '`$ java --module-path mods:libs --module monitor/monitor.Main`'
  id: totrans-1106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs --module monitor/monitor.Main`'
- en: Specifying the main class on the command line overrides whatever the module
    descriptor defines. This means applications can still have several entry points,
    just like without the module system. In case one of them is a sensible default,
    it makes sense to bake it into the module descriptor as described in section 4.5.3.
  id: totrans-1107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在命令行上指定主类覆盖了模块描述符中定义的内容。这意味着应用程序仍然可以有多个入口点，就像没有模块系统一样。如果其中一个是合理的默认值，那么将其嵌入到模块描述符中是有意义的，如第4.5.3节所述。
- en: 'If monitor defines `monitor.Main` as its main class but for some reason you
    don’t want to use it, you can easily override it. With the following command,
    the application is launched by calling monitor’s `some.other.MainClass`, ignoring
    whatever is defined in monitor’s descriptor:'
  id: totrans-1108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果监控器将 `monitor.Main` 定义为其主类，但出于某种原因你不想使用它，你可以轻松地覆盖它。使用以下命令，应用程序通过调用监控器的 `some.other.MainClass`
    来启动，忽略监控器描述符中定义的任何内容：
- en: '`$ java --module-path mods:libs --module monitor/some.other.MainClass`'
  id: totrans-1109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs --module monitor/some.other.MainClass`'
- en: 'For this to work, the initial module must contain the specified class. Because
    that isn’t the case for monitor and `some.other.MainClass`, executing the command
    you just saw results in an error:'
  id: totrans-1110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了使这起作用，初始模块必须包含指定的类。由于monitor和 `some.other.MainClass` 的情况并非如此，执行你刚才看到的命令会导致错误：
- en: '`> Error: Could not find or load main class > some.other.MainClass in module
    monitor`'
  id: totrans-1111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 错误：无法找到或加载主类 > some.other.MainClass 在模块monitor中`'
- en: 5.1.2 IF THE INITIAL MODULE AND MAIN MODULE AREN’T THE SAME
  id: totrans-1112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.1.2 如果初始模块和主模块不是同一个
- en: What can you do if the module you’d like to use as the initial one doesn’t contain
    the application’s main class? First, this seems to be a weird problem; but hey,
    software development is full of those, so that doesn’t mean it won’t occur.
  id: totrans-1113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想用作初始模块的模块不包含应用程序的主类，你该怎么办？首先，这似乎是一个奇怪的问题；但是，嘿，软件开发充满了这些问题，所以这并不意味着它不会发生。
- en: As an example, imagine a desktop application that can be launched in several
    modes (data entry, evaluation, administration) and that a mode is selected on
    launch by picking the correct main class. Being complex, the app consists of many
    modules, and each mode has its own module (data.entry, data.evaluation, administration).
    Each mode’s module also contains the respective entry point. On top comes app,
    which depends on all the application’s modules. ([Figure 5.1](part0018.html#filepos618348)
    shows the module graph.)
  id: totrans-1114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，想象一个可以以几种模式（数据输入、评估、管理）启动的桌面应用程序，并且在启动时通过选择正确的主类来选择模式。由于应用程序复杂，它由许多模块组成，每种模式都有自己的模块（data.entry、data.evaluation、administration）。每种模式的模块也包含相应的入口点。在最上面是app，它依赖于所有应用程序的模块。（[图5.1](part0018.html#filepos618348)显示了模块图。）
- en: 'To launch this application, you’d like to use `--module app` and then specify
    a main class from one of the other modules—but is that possible? To solve this,
    we need some terminology for the two involved modules:'
  id: totrans-1115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了启动此应用程序，你希望使用 `--module app` 并然后指定来自其他模块中的一个主类——但这可能吗？为了解决这个问题，我们需要为涉及的两个模块定义一些术语：
- en: There’s the module that (transitively) depends on all modules the application
    needs—I’ll call it all.
  id: totrans-1116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那是依赖于应用程序所需的所有模块（我将称之为所有）的模块。我会称它为all。
- en: Then there’s the module containing the main class you want to launch—I’ll call
    it main.
  id: totrans-1117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是包含你想要启动的主类的模块——我将称之为main。
- en: '![](../images/00044.jpeg)'
  id: totrans-1118
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00044.jpeg)'
- en: '[Figure 5.1](part0018.html#filepos617063) The module graph for a desktop application,
    with app at the top and the three modules containing entry points further down'
  id: totrans-1119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图5.1](part0018.html#filepos617063) 桌面应用程序的模块图，其中应用程序位于顶部，包含入口点的三个模块位于下方'
- en: Up to now, these two modules were always the same, so you passed the module
    name to `--module`, making it the initial module. What do you do if these are
    two separate modules?
  id: totrans-1120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到目前为止，这两个模块总是相同的，所以你将模块名称传递给 `--module`，使其成为初始模块。如果这两个是独立的模块，你会怎么做？
- en: The crux of the matter is that the module system is adamant about the origin
    of the main class. There’s no way to trick it into searching any module but the
    initial one for it. You hence have to pick main as the initial module, passing
    it to `--module`.
  id: totrans-1121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 问题的关键在于模块系统坚持主类的来源。没有方法可以欺骗它去搜索除了初始模块之外的任何模块。因此，你必须选择主模块作为初始模块，并将其传递给 `--module`。
- en: 'By assumption, this doesn’t resolve all dependencies correctly, so how do you
    ensure that all’s dependencies are taken into account? At this point, the `--add-modules`
    option introduced in section 3.4.3 comes in handy. With it, you can define all
    as an additional root module and make the module system resolve its dependencies
    as well:'
  id: totrans-1122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 根据假设，这并不能正确解决所有依赖项，那么你如何确保所有依赖项都被考虑在内？在这个时候，第3.4.3节中引入的`--add-modules`选项就派上用场了。使用它，你可以定义所有作为额外的根模块，并让模块系统解决其依赖项：
- en: '`$ java --module-path mods --add-modules all --module main`'
  id: totrans-1123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods --add-modules all --module main`'
- en: 'For the desktop application, that means you always use the `--add-modules app`
    option to make sure the graph contains all required modules and then select the
    module for the desired mode as the main module. For example:'
  id: totrans-1124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于桌面应用程序，这意味着你始终使用`--add-modules app`选项来确保图形包含所有必需的模块，然后选择所需模式的模块作为主模块。例如：
- en: '`$ java --module-path mods --add-modules app --module data.entry`'
  id: totrans-1125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods --add-modules app --module data.entry`'
- en: 'By the way, if you’re wondering why the modules for the various modes wouldn’t
    depend on all required modules, there are at least three answers:'
  id: totrans-1126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 顺便说一句，如果你想知道为什么各种模式的模块不会依赖于所有必需的模块，至少有三个答案：
- en: The application may be decoupled via services, as shown in chapter 10, and app
    is the consumer.
  id: totrans-1127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可能通过服务解耦，如第10章所示，其中app是消费者。
- en: The mode modules may have some optional dependencies, as explained in section
    11.2, and app makes sure they’re all present.
  id: totrans-1128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式模块可能有一些可选依赖项，如第11.2节所述，而app确保它们都存在。
- en: I did say it was a weird case, remember?
  id: totrans-1129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我确实说过这是一个奇怪的情况，记得吗？
- en: 5.1.3 PASSING PARAMETERS TO THE APPLICATION
  id: totrans-1130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.1.3 将参数传递给应用程序
- en: Passing parameters to the application is just as easy as before. The JVM puts
    everything after the initial module into an array of strings (split on space)
    and passes it to the `main` method.
  id: totrans-1131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将参数传递给应用程序与之前一样简单。JVM将初始模块之后的所有内容放入一个字符串数组中（按空格分割），并将其传递给`main`方法。
- en: Assume you call ServiceMonitor as follows. What do you think will be passed
    to `Main::main`? (Careful, it’s a trick question!)
  id: totrans-1132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你这样调用ServiceMonitor。你认为会传递给`Main::main`什么？（小心，这是一个陷阱问题！）
- en: '`$ java --module-path mods:libs --module monitor --add-modules monitor.rest
    opt arg`'
  id: totrans-1133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs --module monitor --add-modules monitor.rest
    opt arg`'
- en: It’s a trick question because `--add-modules monitor.rest` looks like something
    the module system should be in charge of. And it would be, if the option were
    in the right place, which is before `--module`. As it stands, the option comes
    after `--module`, making the JVM interpret it as an option for the application
    and passing it along.
  id: totrans-1134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是一个陷阱问题，因为`--add-modules monitor.rest`看起来像是模块系统应该负责的事情。如果这个选项放在正确的位置，即在`--module`之前，那么它就会是正确的。但现状是，这个选项在`--module`之后，这使得JVM将其解释为应用程序的选项，并将其传递下去。
- en: 'To demonstrate, let’s extend `Main::main` to print the parameters:'
  id: totrans-1135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了演示，让我们扩展`Main::main`以打印参数：
- en: '`public static void main(String[] args) { for (String arg : args) { System.out.print(arg
    + " / "); }  // [...]  }`'
  id: totrans-1136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public static void main(String[] args) { for (String arg : args) { System.out.print(arg
    + " / "); }  // [...]  }`'
- en: And indeed, you get the output `--add-modules *monitor.rest* opt / arg`.
  id: totrans-1137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确实，你得到输出`--add-modules *monitor.rest* opt / arg`。
- en: Be careful to make `--module` the last option you want the JVM to process and
    to put all application options behind it.
  id: totrans-1138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，确保将`--module`作为你希望JVM处理的最后一个选项，并将所有应用程序选项放在其后。
- en: 5.2 Loading resources from modules
  id: totrans-1139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.2 从模块中加载资源
- en: Section 3.3 extensively covers how the module system’s accessibility rules provide
    strong encapsulation across module boundaries. It only discusses types, though,
    and at runtime you usually need to access resources, too. Whether those are configurations,
    translations, media files, or in some instances even raw `.class` files, it’s
    common for code to load these from JARs that ship with the project. Because the
    JPMS turns modular JARs into modules, which claim to strongly encapsulate their
    internals, we need to explore how that affects resource loading. Before we go
    into that, in the following sections I’ll give a short recap of how resources
    were loaded in the past and point out the changes Java 9+ incurs. We’ll then take
    a closer look at loading package resources across module boundaries.
  id: totrans-1140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第 3.3 节详细介绍了模块系统的可访问性规则如何在模块边界之间提供强大的封装。尽管它只讨论了类型，但在运行时通常也需要访问资源。这些资源可能是配置、翻译、媒体文件，在某些情况下甚至是原始的
    `.class` 文件。通常，代码会从与项目一起发货的 JAR 文件中加载这些资源。由于 JPMS 将模块化 JAR 转换为模块，这些模块声称强封装其内部内容，我们需要探讨这如何影响资源加载。在深入探讨这一点之前，在接下来的几节中，我将简要回顾过去资源是如何加载的，并指出
    Java 9+ 引入的变化。然后我们将更仔细地研究跨模块边界加载包资源。
- en: 'TIP The topic of resource access surfaces a few more times throughout the book:
    section 6.3 explains how to access JDK resources and section 8.2.1 goes into access
    of non-modular resources. For a practical demonstration of how to load resources,
    check out ServiceMonitor’s `feature-resources` branch.'
  id: totrans-1141
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 提示：本书中多次提及资源访问的话题：第 6.3 节解释了如何访问 JDK 资源，第 8.2.1 节深入探讨了非模块化资源的访问。为了实际演示如何加载资源，请查看
    ServiceMonitor 的 `feature-resources` 分支。
- en: 5.2.1 RESOURCE LOADING BEFORE JAVA 9
  id: totrans-1142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.2.1 在 JAVA 9 之前的资源加载
- en: Without any boundaries between JARs, Java versions before 9 give every class
    access to all resources on the class path. That’s even worse than for types, because
    at least they can use package visibility to hide themselves in a package. No such
    thing exists for resources.
  id: totrans-1143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Java 9 之前的版本中，没有 JAR 之间的边界，每个类都可以访问类路径上的所有资源。这甚至比类型更糟糕，因为至少它们可以使用包可见性来隐藏自己在一个包中。对于资源来说，这种情况并不存在。
- en: 'ESSENTIAL INFO To load a resource, you call `getResource` or `getResourceAsStream`
    on either `Class` or `ClassLoader`. Conceptually, these methods are almost identical:
    you hand them the name of a resource file as a `String`, and they return a `URL`
    or `InputStream` if they find it; otherwise you get `null` back. To not make things
    more complicated than they have to be, we’ll stick to using `Class::getResource`.'
  id: totrans-1144
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的信息：要加载一个资源，你可以在 `Class` 或 `ClassLoader` 上调用 `getResource` 或 `getResourceAsStream`。从概念上讲，这些方法几乎相同：你将资源文件的名称作为
    `String` 传递给它们，如果找到，它们会返回一个 `URL` 或 `InputStream`；否则返回 `null`。为了不让事情比必要的更复杂，我们将坚持使用
    `Class::getResource`。
- en: '[Listing 5.1](part0018.html#filepos630585) shows how to load various resources.
    As long as all classes and resources are on the class path, it doesn’t matter
    which JAR they’re in. [Figure 5.2](part0018.html#filepos633863) shows a single
    JAR that contains all the loaded resources—if it’s on the class path, each call
    to `Class::getResource` returns a `URL` instance.'
  id: totrans-1145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[列表 5.1](part0018.html#filepos630585) 展示了如何加载各种资源。只要所有类和资源都在类路径上，它们在哪个 JAR
    中并不重要。[图 5.2](part0018.html#filepos633863) 显示了一个包含所有加载资源的单个 JAR 文件——如果它在类路径上，每次调用
    `Class::getResource` 都会返回一个 `URL` 实例。'
- en: 'Listing 5.1 Loading resources: all successful because they’re on the class
    path'
  id: totrans-1146
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 5.1 加载资源：所有成功，因为它们在类路径上
- en: '`Class<?> anchor = Class` `.forName("monitor.resources.opened.Anchor")` [`①`](part0018.html#filepos631957)`URL
    pack = anchor.getResource("file.txt");` [`②`](part0018.html#filepos632380)`URL
    root = anchor.getResource("/file.txt");` [`③`](part0018.html#filepos632738)`URL
    meta = anchor.getResource("*META-INF*file.txt");` [`④`](part0018.html#filepos633121)`URL
    bytecode = anchor.getResource("Anchor.class");` [`⑤`](part0018.html#filepos633472)'
  id: totrans-1147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Class<?> anchor = Class` `.forName("monitor.resources.opened.Anchor")` [`①`](part0018.html#filepos631957)`URL
    pack = anchor.getResource("file.txt");` [`②`](part0018.html#filepos632380)`URL
    root = anchor.getResource("/file.txt");` [`③`](part0018.html#filepos632738)`URL
    meta = anchor.getResource("*META-INF*file.txt");` [`④`](part0018.html#filepos633121)`URL
    bytecode = anchor.getResource("Anchor.class");` [`⑤`](part0018.html#filepos633472)'
- en: ①
  id: totrans-1148
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: To call Class::getResource, you first need a Class instance—the other two Anchor
    classes would work just as well.
  id: totrans-1149
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要调用 Class::getResource，你首先需要一个 Class 实例——其他两个 Anchor 类同样适用。
- en: ②
  id: totrans-1150
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Resolved relative to the package containing Anchor
  id: totrans-1151
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 相对于包含 Anchor 的包解析
- en: ③
  id: totrans-1152
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: Resolved as an absolute path from the JAR’s root because of the leading /
  id: totrans-1153
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于以“/”开头，因此从 JAR 的根目录解析为绝对路径。
- en: ④
  id: totrans-1154
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: META-INF is accessed with an absolute path.
  id: totrans-1155
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用绝对路径访问META-INF。
- en: ⑤
  id: totrans-1156
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑤
- en: Loads the anchor’s bytecode
  id: totrans-1157
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 加载锚点的字节码
- en: '![](../images/00027.jpeg)'
  id: totrans-1158
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00027.jpeg)'
- en: '[Figure 5.2](part0018.html#filepos629847) The JAR monitor.persistence contains
    a few resources—coincidentally, exactly the ones [listing 5.1](part0018.html#filepos630585)
    needs.'
  id: totrans-1159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![图5.2](part0018.html#filepos629847) JAR monitor.persistence包含一些资源——巧合的是，正好是[列表5.1](part0018.html#filepos630585)需要的那些。'
- en: 5.2.2 RESOURCE LOADING ON JAVA 9 AND LATER
  id: totrans-1160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.2.2 Java 9及以后版本的资源加载
- en: 'You may wonder why [listing 5.1](part0018.html#filepos630585) gives so many
    different examples. Some work with modules, but others don’t, and I want to discuss
    each of them in turn. Before we come to that, though, let’s consider the various
    resource APIs in Java 9:'
  id: totrans-1161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么[列表5.1](part0018.html#filepos630585)提供了如此多的不同示例。有些与模块一起工作，但有些则不行，我想依次讨论它们。在我们到达那里之前，让我们先考虑Java
    9中的各种资源API：
- en: The methods on `Class` are a good way to load resources from modules—we’ll explore
    their behavior momentarily.
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Class`上的方法是从模块中加载资源的好方法——我们将稍后探讨它们的行为。'
- en: The methods on `ClassLoader` have a different and generally less-useful behavior
    when it comes to modules, and we won’t discuss them. If you want to use them,
    have a look at their Javadoc.
  id: totrans-1163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassLoader`上的方法在模块方面有不同的行为，并且通常不那么有用，我们不会讨论它们。如果你想使用它们，请查看它们的Javadoc。'
- en: A new class, `java.lang.Module`, which we’ll explore in depth in section 12.3.3,
    also has methods `getResource` and `getResourceAsStream`. They behave pretty much
    like the ones on `Class`.
  id: totrans-1164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的类`java.lang.Module`，我们将在12.3.3节中深入探讨，它也有`getResource`和`getResourceAsStream`方法。它们的行为与`Class`上的方法非常相似。
- en: 'With that settled, we can turn to using the workhorse `Class::getResource`
    to load the various kinds of resources in [listing 5.1](part0018.html#filepos630585)
    from modules. The first important observation is that within the same module,
    each call returns a `URL` instance, meaning all resources are found. This is true
    regardless of which packages the module encapsulates. When it comes to loading
    resources across module boundaries, things are a little different:'
  id: totrans-1165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个问题解决之后，我们可以转向使用工作马力的`Class::getResource`来从模块中加载[列表5.1](part0018.html#filepos630585)中的各种资源。第一个重要的观察是，在同一个模块内，每次调用都返回一个`URL`实例，这意味着所有资源都被找到。这适用于模块封装的任何包。当涉及到跨模块边界加载资源时，事情就有些不同了：
- en: Resources from a package are by default encapsulated (see section 5.2.3 for
    details).
  id: totrans-1166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包中的资源默认是封装的（详细信息请参阅5.2.3节）。
- en: Resources from the JAR’s root or from folders whose names can’t be mapped to
    packages (like `META-INF` because of the dash) are never encapsulated.
  id: totrans-1167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自JAR根目录或名称无法映射到包的文件夹（例如，由于包含破折号而无法映射的`META-INF`）的资源永远不会被封装。
- en: '`.class` files are never encapsulated.'
  id: totrans-1168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.class`文件永远不会被封装。'
- en: If resources are encapsulated, the `getResource` call returns `null`.
  id: totrans-1169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果资源被封装，`getResource`调用将返回`null`。
- en: The reason most forms of access aren’t encapsulated comes down to ease of migration.
    Many critical and widely used tools and frameworks in the Java ecosystem rely
    on configurations in the JAR root or `META-INF` folder (for example, JPA implementations)
    or scan `.class` files (for example, to locate annotated classes). If all resources
    were encapsulated by default, these tools could, by default, not work with modules.
  id: totrans-1170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数形式的访问不被封装的原因归结为迁移的便利性。Java生态系统中的许多关键和广泛使用的工具和框架依赖于JAR根目录或`META-INF`文件夹中的配置（例如，JPA实现）或扫描`.class`文件（例如，以定位注解类）。如果所有资源默认都被封装，那么这些工具默认情况下将无法与模块一起工作。
- en: At the same time, the benefits of strong encapsulation of resources are much
    less significant than of types, so the decision was made to only encapsulate resources
    in packages. Let’s see how to get around that.
  id: totrans-1171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 同时，资源强封装的好处远不如类型重要，因此决定只封装包中的资源。让我们看看如何解决这个问题。
- en: 5.2.3 LOADING PACKAGE RESOURCES ACROSS MODULE BOUNDARIES
  id: totrans-1172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.2.3 在模块边界之间加载包资源
- en: Whenever `Class::getResource` or any of its equivalents is tasked to load a
    resource, it checks whether the path conforms to a package name. In simplified
    terms, if removing the file name from the path and then replacing all `/` with
    `.` yields a valid package name, the resource is loaded from a package.
  id: totrans-1173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每当`Class::getResource`或其等效方法被要求加载资源时，它会检查路径是否符合包名。简单来说，如果从路径中删除文件名，然后将所有`/`替换为`.`，得到一个有效的包名，则资源将从包中加载。
- en: Let’s pick some lines from [listing 5.1](part0018.html#filepos630585) as examples.
    The call `anchor.getResource("file.txt")` tells the JVM to load the resource `file.txt`
    relative to the `anchor` class. Because the class is in a package—`monitor.resources.opened`
    in this example—the resource is loaded from that package.
  id: totrans-1174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们从[列表 5.1](part0018.html#filepos630585)中选取一些行作为例子。调用`anchor.getResource("file.txt")`告诉
    JVM 从`anchor`类相对位置加载资源`file.txt`。因为该类在一个包中——在这个例子中是`monitor.resources.opened`——所以资源是从该包中加载的。
- en: A counterexample is `anchor.getResource("*META-INF*file.txt")`. The leading
    slash indicates an absolute path (so it doesn’t matter which package `anchor`
    is in), and trying to transform that to a package name would yield `META-INF`.
    That’s not valid in Java, and hence the resource isn’t loaded from a package.
  id: totrans-1175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个反例是 `anchor.getResource("*META-INF*file.txt")`。前面的斜杠表示绝对路径（因此，`anchor` 在哪个包中无关紧要），尝试将其转换为包名将得到
    `META-INF`。这在 Java 中是无效的，因此资源不会从包中加载。
- en: Opening a package
  id: totrans-1176
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 打开一个包
- en: It’s important to understand how the JVM determines whether a resource is in
    a package, because if it’s in a package, it’s strongly encapsulated. Furthermore,
    `exports` clausesdon’t give access to resources. Because `getResource` is bound
    to the reflection API, a different mechanism is needed.
  id: totrans-1177
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 理解 JVM 如何确定资源是否在包中非常重要，因为如果资源在包中，它会被强封装。此外，`exports`子句并不提供对资源的访问。因为`getResource`绑定到反射
    API，需要一个不同的机制。
- en: We haven’t discussed it so far, but what you’re looking for when wanting to
    give access to a resource is the `opens` clause. Syntactically it works exactly
    like `exports`, but it only gives reflective access to a package, which makes
    it a great fit for this use case.
  id: totrans-1178
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们之前还没有讨论过，但当你想要提供对资源的访问时，你寻找的是`opens`子句。在语法上，它与`exports`完全相同，但它只提供对包的反射访问，这使得它非常适合这种用例。
- en: 'There’s much more to learn about `opens`, and section 12.2 discusses it in
    detail, but all you need to know here is that it gives access to resources in
    otherwise encapsulated packages. Let’s try it and build a module monitor.resources
    around the resources loaded in [listing 5.1](part0018.html#filepos630585). Here’s
    the module declaration:'
  id: totrans-1179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于`opens`还有很多东西要学习，第 12.2 节详细讨论了它，但你需要知道的是，它提供了对其他情况下封装的包中资源的访问。让我们尝试一下，并在[列表
    5.1](part0018.html#filepos630585)中加载的资源周围构建一个名为`monitor.resources`的模块。以下是模块声明：
- en: '`module monitor.resources { exports monitor.resources.exported; opens monitor.resources.opened;
    }`'
  id: totrans-1180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.resources { exports monitor.resources.exported; opens monitor.resources.opened;
    }`'
- en: Comparing it to [figure 5.2](part0018.html#filepos633863), you can see that
    out of its three packages, one is encapsulated, one is exported, and one is opened.
    What can you expect if you run the code in [listing 5.2](part0018.html#filepos647265)?
  id: totrans-1181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与[图 5.2](part0018.html#filepos633863)进行比较，你可以看到在其三个包中，一个是封装的，一个是导出的，一个是开放的。如果你运行[列表
    5.2](part0018.html#filepos647265)中的代码，你能期待什么？
- en: That depends on the module that runs the code. If it’s monitor.resources, the
    calls go through because encapsulation only operates across module boundaries.
    If any other module runs the code, only the package `monitor.resources.opened`
    is made accessible to it for reflection. Hence, `getResource` will only return
    a non-`null` URL for `opened`, whereas it will return `null` for loading resources
    from `closed` and `exported`.
  id: totrans-1182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这取决于运行代码的模块。如果是`monitor.resources`，调用将通过，因为封装只在模块边界之间操作。如果任何其他模块运行代码，只有`monitor.resources.opened`包会被提供给它进行反射。因此，`getResource`将只为`opened`返回非`null`
    URL，而为从`closed`和`exported`加载资源将返回`null`。
- en: The other calls from [listing 5.1](part0018.html#filepos630585)—`getResource("Anchor.class")`,
    `getResource("/file.txt")`, and `getResource("*META-INF*file.txt")`—will go through,
    because they load either bytecode or resources that aren’t in packages. As discussed
    in section 5.2.2, those aren’t encapsulated.
  id: totrans-1183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来自[列表 5.1](part0018.html#filepos630585)的其他调用——`getResource("Anchor.class")`、`getResource("/file.txt")`和`getResource("*META-INF*file.txt")`——将会通过，因为它们加载的是字节码或不在包中的资源。如第
    5.2.2 节所述，这些资源没有被封装。
- en: Listing 5.2 Loading resources from packages with varying accessibility
  id: totrans-1184
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 5.2 从具有不同可访问性的包中加载资源
- en: '`URL closed = Class .forName("monitor.resources.closed.Anchor")` `.getResource("file.txt");`
    [`①`](part0018.html#filepos648347) `URL exported = Class .forName("monitor.resources.exported.Anchor")`
    `.getResource("file.txt");` [`②`](part0018.html#filepos648709) `URL opened = Class
    .forName("monitor.resources.opened.Anchor")` `.getResource("file.txt");` [`③`](part0018.html#filepos649067)'
  id: totrans-1185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`URL closed = Class .forName("monitor.resources.closed.Anchor")` `.getResource("file.txt");`
    [①](part0018.html#filepos648347) `URL exported = Class .forName("monitor.resources.exported.Anchor")`
    `.getResource("file.txt");` [②](part0018.html#filepos648709) `URL opened = Class
    .forName("monitor.resources.opened.Anchor")` `.getResource("file.txt");` [③](part0018.html#filepos649067)'
- en: ①
  id: totrans-1186
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Fails to load a resource from the encapsulated package
  id: totrans-1187
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无法从封装的包中加载资源
- en: ②
  id: totrans-1188
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Fails to load a resource from the exported package
  id: totrans-1189
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无法从导出的包中加载资源
- en: ③
  id: totrans-1190
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: Succeeds in loading a resource from the opened package
  id: totrans-1191
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 成功从打开的包中加载资源
- en: In summary, if you want to give access to resources in a module’s package, you
    have to open it.
  id: totrans-1192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总结来说，如果你想在模块的包中提供对资源的访问，你必须打开它。
- en: Opening packages to give access to resources invites other code to depend on
    your module’s internal structure. To avoid that, consider exposing a type in your
    public API that can be tasked with loading resources. You’re then free to rearrange
    resource internally as you see fit without breaking other modules.
  id: totrans-1193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 打开包以提供对资源的访问会邀请其他代码依赖你的模块的内部结构。为了避免这种情况，考虑在你的公共API中公开一个类型，它可以被分配加载资源的任务。这样，你就可以根据需要自由地重新排列内部资源，而不会破坏其他模块。
- en: 'TIP If you’d like to avoid dependencies on the module containing the resources,
    you can create a service instead. Chapter 10 introduces services, and using them
    to access resources would be straightforward, were it not for the name-wrangling
    required. Fortunately, there’s excellent documentation for that laborious process,
    so I won’t repeat it here. Check out the Javadoc for `ResourceBundleProvider`,
    but make sure you’re reading at least the Java 10 version—it works the same as
    on Java 9, but the docs are clearer: [http://mng.bz/G28M](http://mng.bz/G28M).'
  id: totrans-1194
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 提示：如果你想要避免依赖包含资源的模块，你可以创建一个服务。第10章介绍了服务，使用它们来访问资源将非常直接，如果不是因为需要处理名称，那么它将是简单的。幸运的是，对于这个费时的过程有出色的文档，所以在这里我不会重复它。查看`ResourceBundleProvider`的Javadoc，但请确保你至少阅读了Java
    10版本——它与Java 9的工作方式相同，但文档更清晰：[http://mng.bz/G28M](http://mng.bz/G28M)。
- en: 5.3 Debugging modules and modular applications
  id: totrans-1195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.3 调试模块和模块化应用程序
- en: 'The module system tackles a complex problem and has ambitious goals. I think
    it does a good job of making the simple cases simple to use, but let’s not kid
    ourselves: it’s intricate machinery, and things will go wrong—particularly when
    you get into the following two parts of this book, which explore migrations to
    the module system and its more advanced features. In such cases, it can be helpful
    to peek into the module system’s inner workings. Fortunately, it provides a couple
    of ways to do just that:'
  id: totrans-1196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块化系统解决了一个复杂的问题，并设定了雄心勃勃的目标。我认为它在使简单情况易于使用方面做得很好，但让我们不要自欺欺人：它是一个复杂的机械装置，事情可能会出错——尤其是在你进入本书的以下两个部分时，这些部分探讨了迁移到模块化系统及其更高级的功能。在这种情况下，深入了解模块化系统的内部工作原理可能会有所帮助。幸运的是，它提供了一些方法来实现这一点：
- en: Analyzing and validating modules
  id: totrans-1197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析和验证模块
- en: Test-building a module graph
  id: totrans-1198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试构建模块图
- en: Examining the universe of observable modules
  id: totrans-1199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查可观察模块的宇宙
- en: Excluding modules during resolution
  id: totrans-1200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在解析过程中排除模块
- en: Logging module system behavior
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录模块化系统行为
- en: In the following sections, I introduce each of them in turn.
  id: totrans-1202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下各节中，我将依次介绍它们。
- en: 5.3.1 ANALYZING INDIVIDUAL MODULES
  id: totrans-1203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.3.1 分析单个模块
- en: You’ve seen that `jmod describe` shows a JMOD’s modular properties (section
    3.1.1) and that `jar --describe-module` does a similar job for JARs (section 4.5.2).
    These are great ways to examine individual artifacts. A slightly different path
    to the same destination takes `java --describe-module`. Followed by a module name,
    this option prints the path to the corresponding artifact as well as the module’s
    descriptor. The module system does nothing else and neither resolves modules nor
    launches the application.
  id: totrans-1204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你已经看到`jmod describe`显示了JMOD的模块属性（第3.1.1节）以及`jar --describe-module`为JARs执行了类似的工作（第4.5.2节）。这些都是检查单个工件的好方法。通向同一目的地的不同路径是通过`java
    --describe-module`实现的。跟在模块名称后面，此选项会打印出对应工件的路经以及模块的描述符。模块化系统不做其他任何事情，也不解析模块或启动应用程序。
- en: So whereas `jmod describe` and `jar --describe-module` operate on artifacts,
    `java --describe` operates on modules. Depending on the situation, one or the
    other may be handier, but in the end their output is similar.
  id: totrans-1205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，虽然`jmod describe`和`jar --describe-module`操作于工件，但`java --describe`操作于模块。根据情况，一个或另一个可能更方便，但最终它们的输出是相似的。
- en: 'Once again turning to ServiceMonitor, you can use `--describe-module` to peek
    into descriptors of its modules as well as of platform modules:'
  id: totrans-1206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 再次转向ServiceMonitor，你可以使用`--describe-module`来查看其模块以及平台模块的描述：
- en: '`$ java --module-path mods --describe-module monitor.observer  > monitor.observer
    file:...monitor.observer.jar > exports monitor.observer > requires java.base mandated
    $ java --module-path mods --describe-module java.sql  > java.sql@9.0.4 > exports
    java.sql > exports javax.sql > exports javax.transaction.xa > requires java.base
    mandated > requires java.logging transitive > requires java.xml transitive > uses
    java.sql.Driver`'
  id: totrans-1207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods --describe-module monitor.observer  > monitor.observer
    file:...monitor.observer.jar > 导出 monitor.observer > 需要 java.base 强制 $ java --module-path
    mods --describe-module java.sql  > java.sql@9.0.4 > 导出 java.sql > 导出 javax.sql
    > 导出 javax.transaction.xa > 需要 java.base 强制 > 需要 java.logging 传递 > 需要 java.xml
    传递 > 使用 java.sql.Driver`'
- en: 5.3.2 VALIDATING SETS OF MODULES
  id: totrans-1208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.3.2 验证模块集
- en: Looking into individual modules comes in handy for analyzing known problems.
    But what about unknown issues? Is the module path free of duplicate modules? Do
    any modules split packages?
  id: totrans-1209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看单个模块对于分析已知问题很有帮助。但未知问题怎么办？模块路径是否有重复模块？是否有模块拆分包？
- en: The `java` option `--validate-modules` scans the module path for errors. It
    reports duplicate modules and split packages but builds no module graph, so it
    can’t discover missing modules or dependency cycles. After executing the checks,
    `java` exits.
  id: totrans-1210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`java`选项`--validate-modules`扫描模块路径以查找错误。它报告重复模块和拆分包，但不构建模块图，因此无法发现缺失模块或依赖循环。执行检查后，`java`退出。'
- en: 'For this example, I created a module monitor.rest that contains the package
    `monitor.observer` just like the module monitor.observer does. This is the result
    of validating those modules:'
  id: totrans-1211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于这个例子，我创建了一个包含`monitor.observer`包的模块monitor.rest，就像模块monitor.observer一样。这是验证这些模块的结果：
- en: '`$ java --module-path mods --validate-modules  # truncated standardized Java
    modules # truncated non-standardized JDK modules > file:.../monitor.rest.jar monitor.rest
    > file:.../monitor.observer.beta.jar monitor.observer.beta > file:.../spark.core.jar
    spark.core > file:.../monitor.statistics.jar monitor.statistics > file:.../monitor.jar
    monitor > file:.../monitor.observer.jar monitor.observer > contains monitor.observer
    conflicts with module monitor.rest > file:.../monitor.persistence.jar monitor.persistence
    > file:.../monitor.observer.alpha.jar monitor.observer.alpha > file:.../hibernate.jpa.jar
    hibernate.jpa`'
  id: totrans-1212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods --validate-modules  # 截断标准化的Java模块 # 截断非标准化的JDK模块
    > file:.../monitor.rest.jar monitor.rest > file:.../monitor.observer.beta.jar
    monitor.observer.beta > file:.../spark.core.jar spark.core > file:.../monitor.statistics.jar
    monitor.statistics > file:.../monitor.jar monitor > file:.../monitor.observer.jar
    monitor.observer > 包含 monitor.observer 与模块 monitor.rest 冲突 > file:.../monitor.persistence.jar
    monitor.persistence > file:.../monitor.observer.alpha.jar monitor.observer.alpha
    > file:.../hibernate.jpa.jar hibernate.jpa`'
- en: The output first lists all JDK modules, which are error-free, and then proceeds
    with the application modules. It lists the scanned JAR files and the modules discovered
    therein as well as the split package between monitor.rest and monitor.observer.
  id: totrans-1213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输出首先列出所有JDK模块，它们没有错误，然后继续列出应用程序模块。它列出了扫描的JAR文件以及其中发现的模块，以及monitor.rest和monitor.observer之间的拆分包。
- en: 5.3.3 VALIDATING A MODULE GRAPH
  id: totrans-1214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.3.3 验证模块图
- en: With the `--dry-run` option, the JVM executes the full module resolution, including
    building a module graph and asserting a reliable configuration, but then stops
    right before executing the main method. That may not sound particularly useful,
    but I find it is. Using `--dry-run` in a command that contains errors and thus
    prevents an application launch doesn’t change anything. But when you finally get
    it right, the command exits, and you’re back on the command line. This enables
    you to quickly experiment with command-line options until you get them right without
    continuously launching and aborting the application.
  id: totrans-1215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用`--dry-run`选项，JVM执行完整的模块解析，包括构建模块图和断言可靠的配置，但然后在执行主方法之前停止。这可能听起来不太有用，但我发现它很有用。在包含错误并因此阻止应用程序启动的命令中使用`--dry-run`不会改变任何东西。但当你最终正确时，命令会退出，你将回到命令行。这使得你可以快速尝试命令行选项，直到它们正确，而无需不断启动和终止应用程序。
- en: 'As an example of a faulty command, let’s try to launch ServiceMonitor without
    a module path. As expected, it fails, because without a place to search for application
    modules the module system can’t find the initial module monitor:'
  id: totrans-1216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为有缺陷命令的一个例子，让我们尝试在没有模块路径的情况下启动ServiceMonitor。正如预期的那样，它失败了，因为没有地方去搜索应用程序模块，模块系统找不到初始模块monitor：
- en: '`$ java --module monitor  > Error occurred during initialization of boot layer
    > java.lang.module.FindException: > Module monitor not found`'
  id: totrans-1217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module monitor  > Error occurred during initialization of boot layer
    > java.lang.module.FindException: > Module monitor not found`'
- en: 'Adding `--dry-run` to the mix changes nothing:'
  id: totrans-1218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在混合中使用`--dry-run`不会改变任何东西：
- en: '`$ java --dry-run --module monitor  > Error occurred during initialization
    of boot layer > java.lang.module.FindException: > Module monitor not found`'
  id: totrans-1219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --dry-run --module monitor  > Error occurred during initialization
    of boot layer > java.lang.module.FindException: > Module monitor not found`'
- en: 'Now for a command that’s supposed to work:'
  id: totrans-1220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在来一个应该能工作的命令：
- en: '`$ java --module-path mods:libs --dry-run --module monitor`'
  id: totrans-1221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs --dry-run --module monitor`'
- en: This results in—nothing. The command is correct, and the module system is content,
    so it exits after module resolution without any messages.
  id: totrans-1222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这导致——没有任何结果。命令是正确的，模块系统是满意的，因此在模块解析后没有消息就退出了。
- en: 'Remember from section 5.1.2 that `--dry-run` must come before `--module` even
    if that looks sequentially displeasing. And a note for experts: if you’re using
    a custom class loader, custom security manager, or agents, they will be initiated
    even with`--dry-run`.'
  id: totrans-1223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从5.1.2节中记住，即使看起来顺序上不令人满意，`--dry-run`也必须放在`--module`之前。并且对专家的一个备注：如果你正在使用自定义类加载器、自定义安全管理者或代理，即使使用`--dry-run`它们也会被启动。
- en: 5.3.4 LISTING OBSERVABLE MODULES AND DEPENDENCIES
  id: totrans-1224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.3.4 列出可观察模块和依赖项
- en: You used the option `--list-modules` in section 3.1.1, where it listed all platform
    modules in the current runtime with `java --list-modules`. With a better comprehension
    of how the module system works, I can let you in on the fact that it does more
    than that.
  id: totrans-1225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你在3.1.1节中使用了`--list-modules`选项，其中列出了当前运行时中的所有平台模块，使用`java --list-modules`。有了对模块系统如何工作的更好理解，我可以告诉你，它不仅仅如此。
- en: LISTING THE UNIVERSE OF OBSERVABLE MODULES
  id: totrans-1226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列出可观察模块的宇宙
- en: The option `--list-modules` lists the universe of observable modules. The module
    system does nothing else and neither resolves modules nor launches the application.
  id: totrans-1227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项`--list-modules`列出了可观察模块的宇宙。模块系统不做其他任何事情，也不解析模块或启动应用程序。
- en: As introduced in section 3.1.4, the universe of observable modules consists
    of the platform modules (the ones in the runtime) and the application modules
    (the ones on the module path). During resolution, modules are picked from this
    set to build the module graph. The application can never contain modules that
    aren’t listed with `--list-modules`. (But note that it’s possible and pretty likely
    that many observable modules won’t make it into the graph because they aren’t
    required by any of the root modules—not even transitively.)
  id: totrans-1228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如3.1.4节所述，可观察模块的宇宙包括平台模块（运行时中的那些）和应用模块（模块路径上的那些）。在解析过程中，模块从这个集合中选取来构建模块图。应用程序永远不会包含未用`--list-modules`列出的模块。（但请注意，许多可观察模块可能不会进入图，因为它们不是任何根模块所必需的——甚至不是间接必需的。）
- en: When calling `java --list-modules`, you tasked the JVM with listing all observable
    modules. Because you didn’t specify a module path, only the runtime’s platform
    modules would be printed.
  id: totrans-1229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当调用`java --list-modules`时，你要求JVM列出所有可观察模块。因为你没有指定模块路径，所以只会打印出运行时的平台模块。
- en: 'Let’s look at a less trivial example and list the modules in the ServiceMonitor
    application’s `mods` and `libs` folders:'
  id: totrans-1230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们看看一个不那么简单的问题，并列出ServiceMonitor应用程序的`mods`和`libs`文件夹中的模块：
- en: '`$ java --module-path mods:libs --list-modules  > spark.core # truncated Spark
    dependencies # truncated standardized Java modules # truncated non-standardized
    JDK modules > monitor > monitor.observer > monitor.observer.alpha > monitor.observer.beta
    > monitor.persistence > monitor.rest > monitor.statistics > hibernate.jpa # truncated
    Hibernate dependencies`'
  id: totrans-1231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs --list-modules  > spark.core # truncated Spark
    dependencies # truncated standardized Java modules # truncated non-standardized
    JDK modules > monitor > monitor.observer > monitor.observer.alpha > monitor.observer.beta
    > monitor.persistence > monitor.rest > monitor.statistics > hibernate.jpa # truncated
    Hibernate dependencies`'
- en: If executed on a regular JDK install, the output is overwhelming, because it
    lists the roughly 100 platform modules. It also always contains all modules on
    the module path. Together, these are useful to see which modules the module graph
    can be built from, but they also make it hard to see the forest for the trees.
    There’s a way to limit the output to a sensible subset, though, and we’ll look
    into that next.
  id: totrans-1232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果在一个常规 JDK 安装上执行，输出会非常庞大，因为它列出了大约 100 个平台模块。它还总是包含模块路径上的所有模块。这些一起对于查看可以从哪些模块构建模块图是有用的，但它们也使得难以看清整体。不过，有一种方法可以将输出限制到一个合理的子集，我们将在下一节中探讨。
- en: LISTING TRANSITIVE DEPENDENCIES
  id: totrans-1233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列出传递依赖项
- en: One interesting subset of that long list of observable modules is the transitive
    dependencies of an initial module. Luckily you can cut the list down to just that
    with the option `--limit-modules`. I’ll explain in a minute how exactly it works—for
    now, trust me when I say that combined with `--list-modules`, you can use it to
    print the list of all transitive dependencies of any given module.
  id: totrans-1234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在那长长的可观察模块列表中，有一个有趣的子集是初始模块的传递依赖。幸运的是，你可以使用 `--limit-modules` 选项将列表缩减到仅包含这些内容。我稍后会解释它具体是如何工作的——现在，请相信我说，结合
    `--list-modules`，你可以用它来打印任何给定模块的所有传递依赖的列表。
- en: 'Here are a few experiments with some platform modules:'
  id: totrans-1235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里有一些关于平台模块的实验：
- en: '`$ java --limit-modules java.xml --list-modules  > java.base > java.xml $ java
    --limit-modules java.sql --list-modules  > java.base > java.logging > java.sql
    > java.xml $ java --limit-modules java.desktop --list-modules  > java.base > java.datatransfer
    > java.desktop > java.prefs > java.xml`'
  id: totrans-1236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --limit-modules java.xml --list-modules  > java.base > java.xml $ java
    --limit-modules java.sql --list-modules  > java.base > java.logging > java.sql
    > java.xml $ java --limit-modules java.desktop --list-modules  > java.base > java.datatransfer
    > java.desktop > java.prefs > java.xml`'
- en: You can see that java.xml only depends on java.base, that the SQL module uses
    logging and XML capabilities, and that even java.desktop, which encompasses all
    of AWT, Swing, some media APIs, and the JavaBeans API has surprisingly few dependencies
    (although the reason isn’t flattering—it’s a humongous module containing a lot
    of functionality).
  id: totrans-1237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以看到，java.xml 只依赖于 java.base，SQL 模块使用了日志和 XML 功能，而且即使包含所有 AWT、Swing、一些媒体 API
    和 JavaBeans API 的 java.desktop，其依赖项也出奇地少（尽管原因并不令人满意——它是一个包含大量功能的巨大模块）。
- en: You can also use this approach to examine application modules. This becomes
    particularly useful once an application grows beyond a handful of modules, because
    then it quickly becomes difficult to keep all of them in mind.
  id: totrans-1238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你也可以使用这种方法来检查应用程序模块。一旦应用程序的模块数量超过几个，这尤其有用，因为那时很难记住所有模块。
- en: 'Let’s once again look at ServiceMonitor and examine the dependencies of some
    of its modules:'
  id: totrans-1239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们再次看看 ServiceMonitor 并检查其一些模块的依赖关系：
- en: '`$ java --module-path mods:libs --limit-modules monitor.statistics --list-modules  >
    java.base > monitor.observer > monitor.statistics $ java --module-path mods:libs
    --limit-modules monitor.rest --list-modules  > spark.core # truncated Spark dependencies
    > java.base > monitor.observer > monitor.rest > monitor.statistics`'
  id: totrans-1240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs --limit-modules monitor.statistics --list-modules  >
    java.base > monitor.observer > monitor.statistics $ java --module-path mods:libs
    --limit-modules monitor.rest --list-modules  > spark.core # Spark 的依赖被截断 > java.base
    > monitor.observer > monitor.rest > monitor.statistics`'
- en: The combination of `--limit-modules` and `--list-modules` shows that monitor.statistics
    only depends on monitor.observer (and on the omnipresent base module) and that
    monitor.rest pulls in all of Spark’s dependencies.
  id: totrans-1241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`--limit-modules` 和 `--list-modules` 的组合显示，monitor.statistics 只依赖于 monitor.observer（以及无处不在的基础模块），而
    monitor.rest 则拉入了 Spark 的所有依赖。'
- en: Now it’s time to look at how `--limit-modules` works.
  id: totrans-1242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在是时候看看 `--limit-modules` 参数是如何工作的了。
- en: 5.3.5 EXCLUDING MODULES DURING RESOLUTION
  id: totrans-1243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.3.5 在解析过程中排除模块
- en: You just used `--limit-modules` to cut down the output of `--list-modules`.
    How does that work? Given that `--list-modules` prints the universe of observable
    modules, `--limit-modules` obviously limits it. And because you could use it to
    see all transitive dependencies of a module, these must get evaluated. Taken together,
    these two observations pretty much define the option.
  id: totrans-1244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你刚刚使用 `--limit-modules` 来缩减 `--list-modules` 的输出。这是怎么工作的？鉴于 `--list-modules`
    打印出所有可观察模块的宇宙，`--limit-modules` 显然限制了它。而且因为你可以用它来查看一个模块的所有传递依赖，这些依赖必须被评估。结合这两个观察结果，基本上就定义了这个选项。
- en: The option `--limit-modules ${modules}` accepts a list of comma-separated module
    names. It limits the universe of observable modules to the specified ones and
    their transitive dependencies. If the option `--add-modules` (see section 3.4.3)
    or`--module` (see section 5.1) is used together with `--limit-modules`, the modules
    specified for those two options become observable but their dependencies don’t!
  id: totrans-1245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 `--limit-modules ${modules}` 接受一个以逗号分隔的模块名称列表。它将可观察模块的宇宙限制为指定的模块及其传递依赖项。如果与
    `--add-modules`（见第 3.4.3 节）或 `--module`（见第 5.1 节）一起使用 `--limit-modules`，则指定的模块变为可观察的，但它们的依赖项不会！
- en: 'Step by step, this is how the module system evaluates the option:'
  id: totrans-1246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 逐步来说，这是模块系统评估选项的方式：
- en: Starting from the modules specified to `--limit-modules`, the JPMS determines
    all their transitive dependencies. This is subject to the requirements for reliable
    configuration described in section 3.2.1.
  id: totrans-1247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `--limit-modules` 指定的模块开始，JPMS 确定它们的所有传递依赖项。这符合第 3.2.1 节中描述的可靠配置要求。
- en: If `--add-modules` or `--module` was used, the JPMS adds the specified modules
    (but not their dependencies).
  id: totrans-1248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用了 `--add-modules` 或 `--module`，JPMS 会添加指定的模块（但不是它们的依赖项）。
- en: The JPMS uses the resulting set as the universe of observable modules for any
    further steps (like listing modules or launching the application).
  id: totrans-1249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JPMS 使用生成的集合作为任何进一步步骤（如列出模块或启动应用程序）的可观察模块的宇宙。
- en: 'Some experimentation with `--limit-modules` should make it clear how exactly
    that works. Let’s start by listing all transitive dependencies of monitor.rest:'
  id: totrans-1250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对 `--limit-modules` 参数进行一些实验应该可以清楚地说明它是如何工作的。让我们首先列出 monitor.rest 的所有传递依赖项：
- en: '`$ java --module-path mods:libs --limit-modules monitor.rest --list-modules  >
    java.base # to unclutter the output # I''m leaving out the file paths > monitor.observer
    > monitor.rest > monitor.statistics > spark.core`'
  id: totrans-1251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs --limit-modules monitor.rest --list-modules  >
    java.base # 为了使输出更简洁 # 我省略了文件路径 > monitor.observer > monitor.rest > monitor.statistics
    > spark.core`'
- en: 'You can flip back to [figure 2.4](part0015.html#filepos282314) to verify that
    these are the right dependencies. Now, what do you think happens if you try to
    launch the application? To do that, you have to replace `--list-modules` with
    `--module monitor`:'
  id: totrans-1252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以翻回到 [图 2.4](part0015.html#filepos282314) 来验证这些确实是正确的依赖项。现在，你认为如果你尝试启动应用程序会发生什么？为了做到这一点，你必须将
    `--list-modules` 替换为 `--module monitor`：
- en: '`$ java --module-path mods:libs --limit-modules monitor.rest --module monitor  >
    Error occurred during initialization of boot layer > java.lang.module.FindException:
    > Module monitor.persistence not found, > required by monitor`'
  id: totrans-1253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs --limit-modules monitor.rest --module monitor  >
    初始化引导层时发生错误 > java.lang.module.FindException: > 模块 monitor.persistence 未找到， >
    由 monitor 需要`'
- en: 'This result demonstrates two aspects of how `--limit-modules` works:'
  id: totrans-1254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个结果展示了 `--limit-modules` 的工作的两个方面：
- en: The initial module specified with `--module` becomes observable (otherwise the
    exception would complain about monitor not being found).
  id: totrans-1255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `--module` 指定的初始模块变为可观察的（否则异常会抱怨 monitor 未找到）。
- en: None of the initial module’s dependencies become observable (otherwise the application
    would launch).
  id: totrans-1256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始模块的任何依赖项都不会变为可观察的（否则应用程序会启动）。
- en: The same is supposed to be true for `--add-modules`, so what can you expect
    to see when you add `add-modules monitor.persistence`?
  id: totrans-1257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于 `--add-modules` 也应该是这样，所以当你添加 `add-modules monitor.persistence` 时，你可以期待看到什么？
- en: Because monitor.persistence is now observable, that particular error should
    disappear.
  id: totrans-1258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 monitor.persistence 现在是可观察的，所以那个特定的错误应该会消失。
- en: Because its dependency hibernate.jpa isn’t observable, you can expect an error
    about that.
  id: totrans-1259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为它的依赖项 hibernate.jpa 不可观察，你可以预期会有关于这个的错误。
- en: 'Let’s try it:'
  id: totrans-1260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们试试：
- en: '`$ java --module-path mods:libs --limit-modules monitor.rest --add-modules
    monitor.persistence --module monitor  > Error occurred during initialization of
    boot layer > java.lang.module.FindException: > Module monitor.observer.alpha not
    found, > required by monitor`'
  id: totrans-1261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs --limit-modules monitor.rest --add-modules
    monitor.persistence --module monitor  > 初始化引导层时发生错误 > java.lang.module.FindException:
    > 模块 monitor.observer.alpha 未找到， > 由 monitor 需要`'
- en: This specific case is shown in [figure 5.3](part0018.html#filepos679256).
  id: totrans-1262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个特定的情况在 [图 5.3](part0018.html#filepos679256) 中展示。
- en: '![](../images/00071.jpeg)'
  id: totrans-1263
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00071.jpeg)'
- en: '[Figure 5.3](part0018.html#filepos678945) The `--limit-modules` option is evaluated
    before module resolution.'
  id: totrans-1264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 5.3](part0018.html#filepos678945) `--limit-modules` 选项在模块解析之前被评估。'
- en: 'Darn—the observer implementations are missing as well, so you never find out
    about Hibernate. Fortunately, this is nothing you can’t solve with more `--add-modules`:'
  id: totrans-1265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 真糟糕——观察者的实现也缺失了，所以你永远无法了解Hibernate。幸运的是，这并不是你不能通过更多的`--add-modules`解决的问题：
- en: '`$ java --module-path mods:libs --limit-modules monitor.rest --add-modules
    monitor.persistence, monitor.observer.alpha,monitor.observer.beta --module monitor  >
    Error occurred during initialization of boot layer > java.lang.module.FindException:
    > Module hibernate.jpa not found, > required by monitor.persistence`'
  id: totrans-1266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs --limit-modules monitor.rest --add-modules
    monitor.persistence, monitor.observer.alpha,monitor.observer.beta --module monitor  >
    Error occurred during initialization of boot layer > java.lang.module.FindException:
    > Module hibernate.jpa not found, > required by monitor.persistence`'
- en: There you go!
  id: totrans-1267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 就这样吧！
- en: In the previous section, you used the computed universe to list all modules
    referenced, thus effectively printing all transitive dependencies of some module.
    That isn’t the only use case for `--limit-modules`, though. More will come up
    when we discuss services in chapter 10 (see section 10.1.2 on limiting service
    providers).
  id: totrans-1268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在上一节中，你使用了计算出的宇宙来列出所有引用的模块，从而有效地打印出某个模块的所有传递依赖项。但这并不是`--limit-modules`的唯一用例。当我们讨论第10章中的服务时，会有更多内容出现（参见10.1.2节关于限制服务提供者的内容）。
- en: 5.3.6 OBSERVING THE MODULE SYSTEM WITH LOG MESSAGES
  id: totrans-1269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.3.6 使用日志消息观察模块系统
- en: 'Last but not least, we come to the magic bullet of debugging: log messages.
    Whenever a system misbehaves, and looking for problems in the obvious places (wherever
    those are for the particular misbehavior) doesn’t turn up anything actionable,
    it’s time to turn to the log.'
  id: totrans-1270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们来到了调试的神奇子弹：日志消息。每当系统出现异常行为，在明显的地方（无论这些地方在哪里，对于特定的异常行为而言）找不到任何可操作的问题时，就是时候转向日志了。
- en: Once you arrive here, chances are you’re dealing with a relatively rare problem.
    For those cases, it’s good to know how to extract log messages and related information
    as well as what the log is supposed to look like in the best-case scenario, where
    everything works. This section doesn’t show how to fix a concrete problem—instead,
    it gives you tools to do those things yourself.
  id: totrans-1271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦你到达这里，很可能是你正在处理一个相对罕见的问题。对于这些情况，了解如何提取日志消息和相关信息，以及日志在最佳情况下应该看起来像什么（即一切正常的情况）是很有帮助的。本节不会展示如何修复具体问题——相反，它为你提供了自己完成这些事情的工具。
- en: 'The module system logs messages into two different mechanisms (because, hey,
    why not?), one simpler and one more complex to configure:'
  id: totrans-1272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统将日志消息记录到两种不同的机制中（因为，嘿，为什么不呢？），一种更简单，一种更复杂：
- en: Diagnostic messages from the resolver
  id: totrans-1273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析器的诊断消息
- en: Unified JVM logging
  id: totrans-1274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一JVM日志
- en: We’ll look at both, starting with the simpler variant.
  id: totrans-1275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将探讨两种方法，先从更简单的变体开始。
- en: DIAGNOSTIC MESSAGES DURING MODULE RESOLUTION
  id: totrans-1276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块解析期间的诊断消息
- en: 'With the option `--show-module-resolution`, the module system prints messages
    during module resolution. The following is the output from launching the ServiceMonitor
    application with that option. It identifies the root modules (one, in this case),
    modules that were loaded as a dependency, and which dependency that was:'
  id: totrans-1277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用`--show-module-resolution`选项，模块系统会在模块解析期间打印消息。以下是在使用该选项启动ServiceMonitor应用程序时的输出。它确定了根模块（在这种情况下只有一个），以及作为依赖项加载的模块以及哪个依赖项：
- en: '`$ java --module-path mods:libs` `--show-module-resolution` [`①`](part0018.html#filepos685682)`--limit-modules
    monitor` [`②`](part0018.html#filepos686030)`--dry-run` [`③`](part0018.html#filepos686494)
    `--module monitor  # for each module the file is listed; # I removed that for
    succinctness but it can be helpful > root monitor > monitor requires monitor.observer
    > monitor requires monitor.rest > monitor requires monitor.persistence > monitor
    requires monitor.observer.alpha > monitor requires monitor.observer.beta > monitor
    requires monitor.statistics > monitor.rest requires spark.core > monitor.rest
    requires monitor.statistics > monitor.persistence requires hibernate.jpa > monitor.persistence
    requires monitor.statistics > monitor.observer.alpha requires monitor.observer
    > monitor.observer.beta requires monitor.observer > monitor.statistics requires
    monitor.observer # Spark dependencies truncated # Hibernate dependencies truncated`'
  id: totrans-1278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs` `--show-module-resolution` [`①`](part0018.html#filepos685682)`--limit-modules
    monitor` [`②`](part0018.html#filepos686030)`--dry-run` [`③`](part0018.html#filepos686494)
    `--module monitor  # 对于每个模块，文件被列出；# 我为了简洁性移除了它，但可能会有帮助 > root monitor > monitor
    需要 monitor.observer > monitor 需要 monitor.rest > monitor 需要 monitor.persistence
    > monitor 需要 monitor.observer.alpha > monitor 需要 monitor.observer.beta > monitor
    需要 monitor.statistics > monitor.rest 需要 spark.core > monitor.rest 需要 monitor.statistics
    > monitor.persistence 需要 hibernate.jpa > monitor.persistence 需要 monitor.statistics
    > monitor.observer.alpha 需要 monitor.observer > monitor.observer.beta 需要 monitor.observer
    > monitor.statistics 需要 monitor.observer # Spark 依赖项截断 # Hibernate 依赖项截断`'
- en: ①
  id: totrans-1279
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Activates messages for module resolution
  id: totrans-1280
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 激活模块解析的消息
- en: ②
  id: totrans-1281
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: For reasons that become clear when services are introduced, the universe of
    observable modules needs to be limited, or many unexpected modules are resolved.
  id: totrans-1282
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于在服务引入时原因变得清晰，需要限制可观察模块的宇宙，否则会解析出许多意外的模块。
- en: ③
  id: totrans-1283
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: You only want to see the resolver messages, so no need to launch the application.
  id: totrans-1284
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你只想看到解析器消息，因此不需要启动应用程序。
- en: Teasing the resolver’s diagnostic messages out of the module system is fairly
    simple but not customizable. Time to turn toward a more complex and powerful mechanism.
  id: totrans-1285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从模块系统中提取解析器的诊断消息相对简单但不可定制。现在是时候转向更复杂和强大的机制了。
- en: USING UNIFIED LOGGING TO LOOK INTO THE JPMS
  id: totrans-1286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用统一日志查看JPMS
- en: Java 9 brought a unified logging architecture that pipes a lot of messages the
    JVM generates through the same mechanism. Appendix C introduces it and explains
    how to configure it. If you never did that before, you should take a look now.
    I’ll wait here.
  id: totrans-1287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 9 带来了统一的日志架构，该架构通过相同的机制将 JVM 生成的许多消息管道化。附录C介绍了它并解释了如何配置它。如果你以前从未这样做过，现在应该看看。我在这里等你。
- en: 'Great—you’re back. Armed with an understanding of the logging mechanism and
    configuration, you can have a closer look at how the module system works. The
    following experiments all launch the ServiceMonitor application with the known
    command, using `--dry-run` to prevent actual execution:'
  id: totrans-1288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 太好了——你回来了。有了对日志机制和配置的理解，你可以更深入地了解模块系统是如何工作的。以下所有实验都是使用已知的命令启动 ServiceMonitor
    应用程序，使用 `--dry-run` 防止实际执行：
- en: '`$ java --module-path mods:libs --dry-run --module monitor`'
  id: totrans-1289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs --dry-run --module monitor`'
- en: The snippets will only show the `-Xlog` configuration used in addition to that
    command to define the output. To reduce the noise and keep your eye on the ball,
    I removed all tags and manually edited the messages to only show the most important
    parts—the real log contains much more information.
  id: totrans-1290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 碎片将仅显示除该命令外还使用的 `-Xlog` 配置，以定义输出。为了减少噪音并集中注意力，我移除了所有标签并手动编辑了消息，只显示最重要的部分——实际的日志包含更多信息。
- en: 'Following my own advice from appendix C, I looked into `-Xlog:help` and saw
    the tag `module`, which looks promising. I used it as `module*` to get all messages
    tagged with it:'
  id: totrans-1291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 遵循附录C中的建议，我查看了 `-Xlog:help` 并看到了 `module` 标签，这看起来很有希望。我将其用作 `module*` 以获取所有带有该标签的消息：
- en: '`# -Xlog:module*  # truncated many modules > java.base location: jrt:/java.base
    > jdk.compiler location: jrt:/jdk.compiler > spark.core location: file://... >
    monitor.persistence location: file://... > monitor.observer location: file://...
    > monitor location: file://... > monitor.rest location: file://... > Phase2 initialization,
    0.0977682 secs`'
  id: totrans-1292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# -Xlog:module*  # 截断许多模块 > java.base 位置: jrt:/java.base > jdk.compiler 位置:
    jrt:/jdk.compiler > spark.core 位置: file://... > monitor.persistence 位置: file://...
    > monitor.observer 位置: file://... > monitor 位置: file://... > monitor.rest 位置:
    file://... > Phase2 初始化，0.0977682 秒`'
- en: 'Here, the module system tells about the modules it loaded. These are all the
    involved platform modules as well as the monitor.* modules and their dependencies.
    To get more details, let’s include debug messages:'
  id: totrans-1293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这里，模块系统会告知它加载了哪些模块。这些都是所有涉及的平台模块以及monitor.*模块及其依赖项。要获取更多详细信息，让我们包括调试信息：
- en: '`# -Xlog:module*=debug  # Argh! About 1500 lines of log messages`'
  id: totrans-1294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# -Xlog:module*=debug  # 啊！大约1500行日志消息`'
- en: That output is a little overwhelming, but when you go through it step by step,
    it isn’t complicated. Also, you have the chance to see in action some of the details
    of how the module system works. So let’s do it!
  id: totrans-1295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个输出有点令人眼花缭乱，但当你一步一步地过一遍，它并不复杂。此外，你还有机会看到模块系统如何工作的细节。所以，让我们来做吧！
- en: 'The first thing the module system deals with is, interestingly enough, the
    unnamed module. That’s still largely a mystery—see section 8.2\. Next comes the
    base module—as described in section 3.1.4, all other modules depend on it, so
    it makes sense to define it early on:'
  id: totrans-1296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统首先处理的是，有趣的是，未命名的模块。这仍然在很大程度上是一个谜——参见第8.2节。接下来是基本模块——如第3.1.4节所述，所有其他模块都依赖于它，因此定义它很早是有意义的：
- en: '`> recording unnamed module for boot loader > java.base location: jrt:/java.base
    > Definition of module: java.base`'
  id: totrans-1297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 为引导加载器记录未命名的模块 > java.base位置：jrt:/java.base > 模块定义：java.base`'
- en: 'Then starts the creation of all observable modules:'
  id: totrans-1298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后开始创建所有可观察的模块：
- en: '`> jdk.compiler location: jrt:/jdk.compiler > creation of module: jdk.compiler
    > jdk.localedata location: jrt:/jdk.localedata > creation of module: jdk.localedata
    > monitor.observer.alpha location: file://... > creation of module: monitor.observer.alpha
    # many other modules get created`'
  id: totrans-1299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> jdk.compiler位置：jrt:/jdk.compiler > 创建模块：jdk.compiler > jdk.localedata位置：jrt:/jdk.localedata
    > 创建模块：jdk.localedata > monitor.observer.alpha位置：file://... > 创建模块：monitor.observer.alpha
    # 创建了许多其他模块`'
- en: 'After all modules are created, the module system processes their descriptors,
    adding reads edges and package exports as defined therein:'
  id: totrans-1300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在所有模块创建完成后，模块系统会处理它们的描述符，添加读取边和定义中的包导出：
- en: '`> Adding read from module java.xml to module java.base > package com/sun/org/apache/xpath/internal/functions
    in module java.xml > is exported to module java.xml.crypto > package javax/xml/datatype
    in module java.xml > is exported to all unnamed modules > package org/w3c/dom
    in module java.xml > is exported to all unnamed modules > Adding read from module
    monitor.statistics to module monitor.observer > Adding read from module monitor.statistics
    to module java.base > package monitor/statistics in module monitor.statistics
    > is exported to all unnamed modules`'
  id: totrans-1301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 将模块java.xml的读取添加到模块java.base > 包com/sun/org/apache/xpath/internal/functions位于模块java.xml
    > 导出至模块java.xml.crypto > 包javax/xml/datatype位于模块java.xml > 导出至所有未命名的模块 > 包org/w3c/dom位于模块java.xml
    > 导出至所有未命名的模块 > 将模块monitor.statistics的读取添加到模块monitor.observer > 将模块monitor.statistics的读取添加到模块java.base
    > 包monitor/statistics位于模块monitor.statistics > 导出至所有未命名的模块`'
- en: You can see that it phrases package exports as `"to module ..."` and sometimes
    the value isn’t even `all unnamed modules`. What’s going on? Section 11.3 goes
    into that—here it suffices to recognize that package exports are processed.
  id: totrans-1302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以看到它将包导出表述为`"导出至模块 ..."`，有时值甚至不是`所有未命名的模块`。这是怎么回事？第11.3节会深入探讨这一点——这里我们只需认识到包导出被处理了。
- en: 'And that’s it! The last message is one you’ve seen before, which comes shortly
    before aborting the dry run:'
  id: totrans-1303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 那就是全部了！最后一条消息是你之前见过的，它出现在中止dry run之前：
- en: '`> Phase2 initialization, 0.1048592 secs`'
  id: totrans-1304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> Phase2初始化，0.1048592秒`'
- en: If you take one step further into the Matrix and turn the log level to `trace`,
    you’re confronted with a few thousand messages, but no spectacular revelations
    await you. You just see that as each class is loaded, the module system records
    which package and module it belongs to before eventually defining the packages.
    Once that’s done, the corresponding module is created.
  id: totrans-1305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你进一步进入矩阵并将日志级别设置为`trace`，你会看到几千条消息，但并没有令人瞩目的发现等待着你。你只是看到，随着每个类的加载，模块系统会记录它属于哪个包和模块，在最终定义包之前。一旦完成，相应的模块就会被创建。
- en: If you remove `--dry-run` and execute the application, you don’t get much more
    information. On `debug`, no new messages are created; and on `trace`, you just
    see how a bunch of nested classes are assigned to the existing packages.
  id: totrans-1306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你移除`--dry-run`并执行应用程序，你不会得到更多信息。在`debug`模式下，不会创建新的消息；而在`trace`模式下，你只会看到如何将一些嵌套类分配给现有的包。
- en: NOTE In case you wondered, all of this happens in a single thread. You can verify
    that by printing the thread ID with `-Xlog:module*=debug:stdout:tid`, which shows
    the same ID for all module related operations.
  id: totrans-1307
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：如果您想知道，所有这些都在单个线程中发生。您可以通过使用`-Xlog:module*=debug:stdout:tid`打印线程ID来验证这一点，它显示所有模块相关操作的相同ID。
- en: Now you know how to configure logging and what the log is supposed to look like.
    That knowledge can be a great diagnostic tool. It comes in handy when a modular
    application doesn’t work the way it’s supposed to and other approaches failed
    to yield an analysis that helped solve the problem.
  id: totrans-1308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在您知道了如何配置日志以及日志应该是什么样子。这些知识可以成为一个很好的诊断工具。当模块化应用程序没有按预期工作且其他方法未能提供有助于解决问题的分析时，它非常有用。
- en: 5.4 Java Virtual Machine options
  id: totrans-1309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.4 虚拟机选项
- en: Just like compiler and archiver, the virtual machine gets a number of new command-line
    options that interact with the module system. For your convenience, [table 5.1](part0018.html#filepos697201)
    lists them. You can find the official documentation at [https://docs.oracle.com/javase/9/tools/java.htm](https://docs.oracle.com/javase/9/tools/java.htm).
  id: totrans-1310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 就像编译器和归档器一样，虚拟机获得了一些新的命令行选项，这些选项与模块系统交互。为了您的方便，[表5.1](part0018.html#filepos697201)列出了它们。您可以在[https://docs.oracle.com/javase/9/tools/java.htm](https://docs.oracle.com/javase/9/tools/java.htm)找到官方文档。
- en: Table 5.1 Alphabetized list of all module-related VM (`java` command) options.
    The descriptions are based on the documentation, and the references point to the
    sections in this book that explain in detail how to use the options.
  id: totrans-1311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表5.1 所有模块相关虚拟机（`java`命令）选项的字母顺序列表。描述基于文档，参考指向本书中解释如何使用选项的章节。
- en: '| Option   | Description   | Ref.   |'
  id: totrans-1312
  prefs: []
  type: TYPE_TB
  zh: '| 选项   | 描述   | 参考   |'
- en: '| `--add-exports`   | Lets a module export additional packages   | 11.3.4   |'
  id: totrans-1313
  prefs: []
  type: TYPE_TB
  zh: '| `--add-exports`   | 允许模块导出额外的包   | 11.3.4   |'
- en: '| `--add-modules`   | Defines root modules in addition to the initial module   |
    3.4.3   |'
  id: totrans-1314
  prefs: []
  type: TYPE_TB
  zh: '| `--add-modules`   | 除了初始模块外，还定义根模块   | 3.4.3   |'
- en: '| `--add-opens`   | Makes a module open additional packages   | 12.2.2   |'
  id: totrans-1315
  prefs: []
  type: TYPE_TB
  zh: '| `--add-opens`   | 使模块开放额外的包   | 12.2.2   |'
- en: '| `--add-reads`   | Adds read edges between modules   | 3.4.4   |'
  id: totrans-1316
  prefs: []
  type: TYPE_TB
  zh: '| `--add-reads`   | 在模块之间添加读取边   | 3.4.4   |'
- en: '| `--describe-module`, `-d`   | Shows the module’s name, dependencies, exports,
    packages, and more   | 5.3.1   |'
  id: totrans-1317
  prefs: []
  type: TYPE_TB
  zh: '| `--describe-module`, `-d`   | 显示模块的名称、依赖项、导出、包等   | 5.3.1   |'
- en: '| `--dry-run`   | Launches the VM but exits before calling the `main` method   |
    5.3.3   |'
  id: totrans-1318
  prefs: []
  type: TYPE_TB
  zh: '| `--dry-run`   | 启动虚拟机但在调用`main`方法之前退出   | 5.3.3   |'
- en: '| `--illegal-access`   | Configures how access from the class path to JDK-internal
    APIs is handled   | 7.1.4   |'
  id: totrans-1319
  prefs: []
  type: TYPE_TB
  zh: '| `--illegal-access`   | 配置如何处理从类路径到JDK内部API的访问   | 7.1.4   |'
- en: '| `--limit-modules`   | Limits the universe of observable modules   | 5.3.5   |'
  id: totrans-1320
  prefs: []
  type: TYPE_TB
  zh: '| `--limit-modules`   | 限制可观察模块的宇宙   | 5.3.5   |'
- en: '| `--list-modules`   | Lists all observable modules   | 5.3.4   |'
  id: totrans-1321
  prefs: []
  type: TYPE_TB
  zh: '| `--list-modules`   | 列出所有可观察模块   | 5.3.4   |'
- en: '| `--module`, `-m`   | Sets the initial module and launches its main class   |
    5.1   |'
  id: totrans-1322
  prefs: []
  type: TYPE_TB
  zh: '| `--module`, `-m`   | 设置初始模块并启动其主类   | 5.1   |'
- en: '| `--module-path`, `-p`   | Specifies where to find application modules   |
    3.4   |'
  id: totrans-1323
  prefs: []
  type: TYPE_TB
  zh: '| `--module-path`, `-p`   | 指定查找应用程序模块的位置   | 3.4   |'
- en: '| `--patch-module`   | Extends an existing module with classes during the course
    of the compilation   | 7.2.4   |'
  id: totrans-1324
  prefs: []
  type: TYPE_TB
  zh: '| `--patch-module`   | 在编译过程中扩展现有模块的类   | 7.2.4   |'
- en: '| `--show-module-resolution`   | Prints messages during module resolution   |
    5.3.6   |'
  id: totrans-1325
  prefs: []
  type: TYPE_TB
  zh: '| `--show-module-resolution`   | 在模块解析期间打印消息   | 5.3.6   |'
- en: '| `--upgrade-module-path`   | Defines the location of upgradeable modules   |
    6.1.3   |'
  id: totrans-1326
  prefs: []
  type: TYPE_TB
  zh: '| `--upgrade-module-path`   | 定义可升级模块的位置   | 6.1.3   |'
- en: '| `--validate-modules`   | Scans the module path for errors   | 5.3.2   |'
  id: totrans-1327
  prefs: []
  type: TYPE_TB
  zh: '| `--validate-modules`   | 扫描模块路径以查找错误   | 5.3.2   |'
- en: Beyond being able to use these options on the command line, you can also specify
    some of them in an executable JAR’s manifest, define them in a specific environment
    variable the `java` command picks up, or put them into an argument file you hand
    to the launching JVM. Section 9.1.4 explains them all.
  id: totrans-1328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了能够在命令行上使用这些选项之外，您还可以在可执行JAR的清单中指定其中的一些，在`java`命令选择的特定环境变量中定义它们，或者将它们放入您提供给启动JVM的参数文件中。第9.1.4节解释了所有这些。
- en: You’ve reached the second milestone and the conclusion of part 1\. You’re now
    well versed in the module system’s fundamentals. If you have a chance, spend some
    time working with what you learned—maybe create your own demo or play around with
    ServiceMonitor ([https://github.com/CodeFX-org/demo-jpms-monitor](https://github.com/CodeFX-org/demo-jpms-monitor)).
    What to read next depends on whether you have a project you’d like to migrate
    to Java 9+ and maybe even modularize (see part 2) or are more interested in learning
    what else the module system can do for you (see part 3).
  id: totrans-1329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你已经达到了第一部分的第二个里程碑和结论。你现在对模块系统的基本原理非常熟悉。如果你有机会，花些时间练习你所学的知识——也许创建自己的演示或尝试使用 ServiceMonitor
    ([https://github.com/CodeFX-org/demo-jpms-monitor](https://github.com/CodeFX-org/demo-jpms-monitor))。接下来要阅读的内容取决于你是否有一个想要迁移到
    Java 9+ 并可能模块化（见第二部分）的项目，或者你是否更感兴趣于了解模块系统还能为你做些什么（见第三部分）。
- en: Summary
  id: totrans-1330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: The initial module is defined with `--module`. If it defines a main class, no
    more is needed to launch the application; otherwise, the fully qualified class
    name is appended to the module name after a forward slash.
  id: totrans-1331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始模块通过 `--module` 定义。如果它定义了主类，则无需更多操作即可启动应用程序；否则，在正斜杠之后将完全限定类名附加到模块名称之后。
- en: Make sure to list all JVM options before `–module`, or they will be treated
    as application options and won’t affect the module system.
  id: totrans-1332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在 `–module` 之前列出所有 JVM 选项，否则它们将被视为应用程序选项，不会影响模块系统。
- en: Observable modules can be listed with `--list-modules`. This comes in handy
    if you need to debug problems and want to see which modules were available for
    resolution.
  id: totrans-1333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `--list-modules` 列出可观察的模块。如果你需要调试问题并查看哪些模块可用于解析，这会很有用。
- en: If `--limit-modules` is used, the universe of observable modules only consists
    of the specified modules and their transitive dependencies, thus reducing the
    modules that are available during resolution. Together with `--list-modules`,
    it’s a great way to determine a module’s transitive dependencies.
  id: totrans-1334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用 `--limit-modules`，可观察的模块宇宙仅由指定的模块及其传递依赖组成，从而减少了在解析期间可用的模块。与 `--list-modules`
    结合使用，这是一个确定模块传递依赖的好方法。
- en: The option `--add-modules` can be used to define additional root modules beyond
    the initial module. If a module isn’t required (for example, because it’s only
    accessed via reflection), `--add-modules` must be used to make sure it becomes
    part of the module graph.
  id: totrans-1335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项 `--add-modules` 可以用来定义除初始模块之外的其他根模块。如果一个模块不是必需的（例如，因为它仅通过反射访问），则必须使用 `--add-modules`
    来确保它成为模块图的一部分。
- en: The option `--dry-run` launches the JVM and lets the module system process the
    configuration (module path, initial module, and so on) and build a module graph,
    but it exits just before the main method is called. This lets you verify a configuration
    without launching the application.
  id: totrans-1336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项 `--dry-run` 启动 JVM 并让模块系统处理配置（模块路径、初始模块等）并构建模块图，但在调用主方法之前退出。这让你可以在不启动应用程序的情况下验证配置。
- en: The module system logs a variety of messages, which can be printed with either
    the simple `--show-module-resolution` or the more complex `-Xlog:module*`. They
    let you analyze how the module system puts together the module graph, which can
    help with troubleshooting.
  id: totrans-1337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块系统记录了各种消息，可以使用简单的 `--show-module-resolution` 或更复杂的 `-Xlog:module*` 打印它们。它们让你分析模块系统如何构建模块图，这有助于故障排除。
- en: Loading resources from modules works much like loading them from JARs. The only
    exceptions are resources that aren’t `.class` files and are in a different module’s
    package (as opposed to, for example, the JAR’s root or `META-INF` folder). These
    are by default encapsulated and therefore not accessible.
  id: totrans-1338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模块加载资源的工作方式与从 JAR 文件加载它们非常相似。唯一的例外是那些不是 `.class` 文件且位于不同模块包中的资源（例如，与 JAR 的根目录或
    `META-INF` 文件夹不同）。这些资源默认被封装，因此不可访问。
- en: A module can use `opens` directives to give reflective access to packages, which
    exposes resources located therein and allows other modules to load them. Unfortunately,
    this solution invites other code to depend on the module’s internal structure.
  id: totrans-1339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模块可以使用 `opens` 指令来提供对包的反射访问，这暴露了其中定位的资源，并允许其他模块加载它们。不幸的是，这种解决方案会邀请其他代码依赖于模块的内部结构。
- en: When loading resources, default to the methods `getResource` and `getResourceAsStream`
    on `Class` or their counterparts on the new type `java.lang.Module`. Those on
    `ClassLoader` generally have less-useful behavior.
  id: totrans-1340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在加载资源时，默认使用 `Class` 或新类型 `java.lang.Module` 上的 `getResource` 和 `getResourceAsStream`
    方法。`ClassLoader` 上的这些方法通常具有更少有用的行为。
