- en: 5 Building and maintaining a test suite
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 构建和维护测试套件
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Running unit tests with pytest
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pytest运行单元测试
- en: Creating test coverage reports with pytest-cov
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pytest-cov创建测试覆盖率报告
- en: Reducing duplicated test code with parameterization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数化减少重复的测试代码
- en: Automating packaging for testing using tox
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用tox自动化测试打包
- en: Creating a test matrix
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建测试矩阵
- en: Tests are an important aspect of any project you plan to maintain. They can
    ensure that new functionality behaves as you expect and that existing functionality
    hasn’t regressed. Tests are the guardrails for refactoring code—a common activity
    as projects mature.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是任何计划维护的项目的重要方面。它们可以确保新的功能表现如你所预期，并且现有的功能没有退化。测试是重构代码的护栏——随着项目的成熟，这是一个常见的活动。
- en: With all this value that tests provide, you might think all open source packages
    would be thoroughly tested. But many projects pass on things like code coverage
    or testing for multiple target platforms because of the maintenance burden they
    present. Some maintainers even *create* maintenance burden without realizing it
    due to the way they design and run their test suite. In this chapter, you’ll learn
    some beneficial aspects of testing and how to introduce them to your package’s
    test suite, with an eye toward automation and scalability.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然测试提供了所有这些价值，你可能会认为所有开源软件包都会经过彻底的测试。但许多项目因为维护负担而放弃了诸如代码覆盖率或针对多个目标平台的测试。一些维护者甚至没有意识到，由于他们设计和运行测试套件的方式，他们甚至*创造*了维护负担。在本章中，你将了解测试的一些有益方面以及如何将它们引入你的软件包测试套件，着眼于自动化和可扩展性。
- en: If you’re still new to unit-testing concepts, you can learn all about them in
    Roy Osherove’s *The Art of Unit Testing*, 3rd ed. (Manning Publications, anticipated
    2023, [http://mng.bz/YKGj](http://mng.bz/YKGj)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然对单元测试的概念感到陌生，你可以在Roy Osherove的《单元测试的艺术》（第3版）（Manning Publications，预计2023年出版，[http://mng.bz/YKGj](http://mng.bz/YKGj)）中了解所有相关信息。
- en: Important You can use the code companion ([http://mng.bz/69A5](http://mng.bz/69A5))
    to check your work for the exercises in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：你可以使用代码伴侣 ([http://mng.bz/69A5](http://mng.bz/69A5)) 来检查本章练习中的工作。
- en: 5.1 Integrating a testing setup
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 集成测试设置
- en: The first step toward building a robust test suite is configuring a *test runner*
    to run any tests for the project. If you’ve used the built-in `unittest` module
    in the past, you’ve most likely used a command like `python -m unittest discover`
    as your test runner. `unittest` is a perfectly capable piece of software, but,
    like any Python built-in, it requires work on your part when you want to extend
    or change its behavior. Further, the framework `unittest` employs is inspired
    both functionally and semantically by the xUnit ([https://xunit.net/](https://xunit.net/))
    family of testing frameworks, which can feel awkward because its conventions don’t
    always follow PEP 8 ([https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/))
    style.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 构建健壮测试套件的第一步是配置一个*测试运行器*来运行项目的任何测试。如果你过去使用过内置的`unittest`模块，你很可能使用过类似`python
    -m unittest discover`的命令作为你的测试运行器。`unittest`是一个功能齐全的软件，但，就像任何Python内置模块一样，当你想要扩展或改变其行为时，它需要你进行一些工作。此外，`unittest`框架所采用的框架在功能和语义上都受到xUnit
    ([https://xunit.net/](https://xunit.net/)) 测试框架家族的启发，这可能会感觉有些不自然，因为它的约定并不总是遵循PEP
    8 ([https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/))
    风格。
- en: For a testing experience that aligns more closely with Python runtime code and
    can scale in productivity with your test suite, pytest ([https://docs.pytest.org](https://docs.pytest.org))
    is a strong alternative. You’ll use pytest throughout the rest of this chapter
    and learn some of the advantages it has over the `unittest` module.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个与Python运行时代码更紧密对齐的测试体验，并且可以随着测试套件的扩展而提高生产效率，pytest ([https://docs.pytest.org](https://docs.pytest.org))
    是一个强大的替代方案。你将在本章的其余部分使用pytest，并了解它相对于`unittest`模块的一些优势。
- en: 5.1.1 The pytest testing framework
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 pytest测试框架
- en: pytest aims to make it easier to write simple tests and support increasingly
    complex projects as they grow. It can run `unittest`-based test suites out of
    the box but also provides its own assertion syntax and a plugin-based architecture
    to extend and change its behavior to suit your needs. The framework also provides
    a number of utilities for designing scalable tests, such as
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: pytest旨在使编写简单的测试更加容易，并支持随着项目的增长而变得越来越复杂的测试。它可以直接运行基于`unittest`的测试套件，但也提供了自己的断言语法和基于插件的架构，以扩展和改变其行为以满足你的需求。该框架还提供了一些设计可扩展测试的实用工具，例如
- en: '*Test fixtures*—Functions that provide additional dependencies to a test, such
    as data or database connections'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试固定装置*—提供额外依赖项给测试的函数，例如数据或数据库连接'
- en: '*Parameterized tests*—The ability to write a single test function and multiple
    sets of input arguments to create a unique test for each set of inputs'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数化测试*—能够编写一个单一的测试函数和多个输入参数集，为每组输入创建一个独特的测试'
- en: Tip For an in-depth look at pytest and all its features, check out Brian Okken’s
    *Python Testing with pytest*, 2nd ed. (Pragmatic Bookshelf, 2022, [http://mng.bz/1olg](http://mng.bz/1olg)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：要深入了解 pytest 及其所有功能，请查看 Brian Okken 的 *Python Testing with pytest*，第 2 版（Pragmatic
    Bookshelf，2022，[http://mng.bz/1olg](http://mng.bz/1olg)）。
- en: 'You *must* install pytest in the same virtual environment where your package
    and its dependencies are installed. Unit tests execute your real code, and that
    code must be importable. As an example, if you install pytest globally using pipx,
    pytest won’t know where to find your project’s dependencies and will fail to import
    them. Jump straight into pytest by installing it into your project’s virtual environment
    using the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你*必须*在安装你的包及其依赖项的同一虚拟环境中安装 pytest。单元测试执行你的真实代码，并且该代码必须是可导入的。例如，如果你使用 pipx 全局安装
    pytest，pytest 将不知道在哪里找到你的项目依赖项，并且无法导入它们。通过以下命令将 pytest 安装到你的项目虚拟环境中，直接跳入 pytest：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Installing pytest makes the `pytest` module available. In chapter 4, you installed
    your package’s code into the virtual environment so that it could be imported.
    pytest imports your code the same way when running tests. Run pytest now using
    the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 pytest 使得 `pytest` 模块可用。在第 4 章中，你将你的包代码安装到虚拟环境中，以便可以导入。pytest 在运行测试时以相同的方式导入你的代码。现在使用以下命令运行
    pytest：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This causes pytest to discover any tests it can and then execute them. Because
    you don’t have any tests yet, you will see output like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致 pytest 发现它能够发现的任何测试并执行它们。因为你还没有任何测试，你将看到如下输出：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Environment synopsis showing the Python version, pytest version, and plugin
    versions
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 显示 Python 版本、pytest 版本和插件版本的概要环境
- en: ❷ Directory for configuration, test discovery, and so on
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于配置、测试发现等的目录
- en: ❸ No tests were discovered.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 没有发现测试。
- en: ❹ No tests were executed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 没有执行任何测试。
- en: Remember that in chapter 3 you created a layout for your project that separates
    the source code from the test code. You added your implementation code to the
    src/ directory and created an empty test/ directory. To avoid including tests
    in the packaged code and to keep your tests in one easy-to-find place, you should
    place your tests in the test/ directory. By default, pytest discovers tests anywhere
    they might exist in your project. This includes tests in the root directory of
    the project or in the src/ directory, which isn’t ideal. You’ll configure pytest
    to ensure that it runs only tests placed in the proper location.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在第 3 章中，你为你的项目创建了一个布局，将源代码与测试代码分开。你将实现代码添加到 src/ 目录中，并创建了一个空的 test/ 目录。为了避免将测试包含在打包的代码中，并保持你的测试在一个易于找到的地方，你应该将你的测试放在
    test/ 目录中。默认情况下，pytest 会发现项目中可能存在的任何测试。这包括项目根目录中的测试或在 src/ 目录中的测试，这并不理想。你将配置 pytest
    以确保它只运行放置在正确位置的测试。
- en: Exercise 5.1
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.1
- en: Create a `test_harmonic_mean.py` module in the root directory of the project,
    and add one test function called `test_always_passes` that always passes. If you
    aren’t familiar with pytest, you can use Python `assert` statements directly for
    your test assertions; a statement like `assert True` will always pass.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录中创建一个 `test_harmonic_mean.py` 模块，并添加一个名为 `test_always_passes` 的测试函数，该函数总是通过。如果你不熟悉
    pytest，你可以直接使用 Python `assert` 语句进行测试断言；例如，`assert True` 将总是通过。
- en: 'After you create the test module, run pytest again. This time you will see
    output like the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建测试模块后，再次运行 pytest。这次你将看到如下输出：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ One test was discovered.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 发现了一个测试。
- en: ❷ A list of test modules discovered and a dot for each passing test
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 发现的测试模块列表以及每个通过测试的点
- en: ❸ One test was executed in 0.04 seconds, and it passed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个测试在 0.04 秒内执行并通过。
- en: 'This demonstrates that pytest is looking everywhere under the project’s root
    directory for tests. To encourage the placement of tests in the appropriate location,
    you should configure pytest to look only in the test/ directory. You can add configuration
    for pytest into your package’s setup.cfg file using a new section called `[tool:pytest]`.
    The `testpaths` key maps to a list of paths in which to look for tests. You need
    just one: `test`. After you add this configuration, pytest should confirm in its
    output both that it’s using setup.cfg as the configuration file and that it found
    the `testpaths` configuration.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明pytest正在项目根目录下的所有位置寻找测试。为了鼓励将测试放置在适当的位置，你应该配置pytest仅在其`test/`目录中查找测试。你可以通过在包的`setup.cfg`文件中使用一个名为`[tool:pytest]`的新部分来添加pytest的配置。`testpaths`键映射到一个包含查找测试的路径列表。你需要只有一个：`test`。添加此配置后，pytest应在其输出中确认它正在使用`setup.cfg`作为配置文件，并且找到了`testpaths`配置。
- en: Exercise 5.2
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.2
- en: 'Add the pytest configuration in `setup.cfg` to look only in the test/ directory
    for tests. After you add the configuration, do the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup.cfg`中添加pytest配置，使其仅在`test/`目录中查找测试。添加配置后，执行以下操作：
- en: Run pytest again, and confirm that it discovers and runs no tests.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次运行pytest，并确认它没有发现和运行任何测试。
- en: Move the `test_harmonic_mean.py` module into the test/ directory where it belongs.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`test_harmonic_mean.py`模块移动到它所属的`test/`目录。
- en: Run pytest another time, and confirm that it discovers and runs the test you
    wrote.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次运行pytest，并确认它发现了并运行了你编写的测试。
- en: 'Now you’re in a good place to add more tests. pytest will pick up any new test
    modules you add to the test/ directory, according to its naming conventions, as
    follows (see figure 5.1):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你处于添加更多测试的好位置。pytest会根据其命名约定，自动识别你添加到`test/`目录中的任何新的测试模块，如下所示（见图5.1）：
- en: Start in any directory in `testpaths`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`testpaths`中的任何目录开始。
- en: Find modules named `test_*.py`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找名为`test_*.py`的模块。
- en: Find classes in those modules named `Test*`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些模块中查找名为`Test*`的类。
- en: Find functions in those modules, or methods in those classes, named `test_*`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些模块中查找名为`test_*`的函数，或在这些类中查找名为`test_*`的方法。
- en: '![](../../OEBPS/Images/05-01.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-01.png)'
- en: Figure 5.1 pytest discovers the unit tests in a project using recursive pattern
    matching.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 pytest使用递归模式匹配发现项目中的单元测试。
- en: Now that you’ve created a mechanism for writing and running tests, the next
    step is figuring out which tests to write. In the next section, you’ll integrate
    test coverage and write more tests to ensure you’re covering all the code paths
    for your package.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个编写和运行测试的机制，下一步是确定要编写哪些测试。在下一节中，你将集成测试覆盖率并编写更多测试，以确保你覆盖了你的包的所有代码路径。
- en: 5.1.2 Adding test coverage measurement
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 添加测试覆盖率测量
- en: Before starting into test coverage, you must first understand that it isn’t
    a silver bullet. Test coverage tells you how much of your runtime code executed
    during test execution and can even measure how many conditional branches executed.
    But test coverage doesn’t ensure that all those lines and branches have corresponding
    assertions that verify their behavior. A test that executes your entire code base
    but ends with an `assert True` will have 100% coverage but no value whatsoever.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始测试覆盖率之前，你必须首先明白这并不是万能的解决方案。测试覆盖率会告诉你你的运行时代码在测试执行期间执行了多少，甚至可以测量执行了多少条件分支。但是测试覆盖率并不能保证所有这些行和分支都有相应的断言来验证它们的行为。一个执行了整个代码库但以`assert
    True`结束的测试将拥有100%的覆盖率，但毫无价值。
- en: 'That said, if you’re diligent about designing your test cases properly, coverage
    is a useful tool to help you find areas of code that definitely *don’t* have any
    assertions made about them. You can use this to add valuable tests and refactor
    your suite to get better coverage of your runtime code. To start measuring coverage,
    install the `pytest-cov` package in your project’s virtual environment like so:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果你在正确设计测试用例方面非常勤奋，覆盖率是一个有用的工具，可以帮助你找到那些肯定没有断言的代码区域。你可以利用这一点添加有价值的测试，并重构你的测试套件以获得更好的运行时代码覆盖率。要开始测量覆盖率，请在项目的虚拟环境中安装`pytest-cov`包，如下所示：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This package provides a pytest plugin that integrates the Coverage.py project
    ([https://coverage.readthedocs.io/](https://coverage.readthedocs.io/)) so that
    you can run it using pytest. Coverage.py is the de facto standard for measuring
    Python code coverage. With `pytest-cov` installed, run pytest with the `--cov`
    option to collect coverage measurements. You will see additional output at the
    end of the execution after the usual pytest report you’ve been seeing, listing
    a lot of files that you’ve never heard of, as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此包提供了一个pytest插件，该插件集成了Coverage.py项目([https://coverage.readthedocs.io/](https://coverage.readthedocs.io/))，以便您可以使用pytest运行它。Coverage.py是测量Python代码覆盖率的事实标准。安装了`pytest-cov`后，使用`--cov`选项运行pytest以收集覆盖率测量值。您将在执行结束时看到额外的输出，在您通常看到的pytest报告之后，列出了许多您从未听说过的文件，如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Like pytest, Coverage.py prints some environment info.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 与pytest一样，Coverage.py会打印一些环境信息。
- en: ❷ The name, line, branch, and overall coverage for each file
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每个文件的名字、行号、分支和整体覆盖率
- en: ❸ Coverage.py is measuring a lot of files that aren’t yours.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Coverage.py正在测量许多不属于您的文件。
- en: ❹ The overall coverage of the entire code base
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 整个代码库的整体覆盖率
- en: 'Coverage.py measures the coverage of all the installed Python code it can find,
    which includes code for your package’s dependencies and even pytest itself. To
    only measure coverage of your package, you can specify your import package’s name
    as the value for the `--cov` option. Your tests don’t even import your package
    yet, so you should expect the coverage to be zero. Run pytest again with your
    package specified for coverage and confirm this is the case. Coverage.py will
    produce output like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Coverage.py测量它能够找到的所有已安装Python代码的覆盖率，包括您包的依赖项代码甚至pytest本身。要仅测量您包的覆盖率，您可以指定您的导入包的名称作为`--cov`选项的值。您的测试甚至还没有导入您的包，因此您应该期望覆盖率为零。再次运行pytest以指定覆盖率，并确认这是否如此。Coverage.py将生成如下输出：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ A confirmation that your package isn’t imported in the tests
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 确认您的包在测试中没有被导入
- en: ❷ A confirmation that your runtime code is not covered at all
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确认您的运行时代码完全没有被覆盖
- en: 'You can quickly fix the `module-not-imported` issue by importing your code
    in your tests. At the top of the `test_harmonic_mean.py` module, import the `harmonic_mean`
    function and the `main` function that supports the `harmony` command. After you
    add the imports, run pytest with coverage again. This time, you will see the `__init__.py`
    and `harmony.py` modules in the coverage output, similar to the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在测试中导入您的代码来快速修复`module-not-imported`问题。在`test_harmonic_mean.py`模块的顶部，导入`harmonic_mean`函数和`main`函数，后者支持`harmony`命令。添加导入后，再次使用覆盖率运行pytest。这次，您将在覆盖率输出中看到`__init__.py`和`harmony.py`模块，类似于以下内容：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ There’s no code in this module, so it’s fully covered.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这个模块中没有代码，因此它完全被覆盖。
- en: ❷ There are six statements in this module, two of which aren’t executed by tests.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此模块中有六个语句，其中两个没有被测试执行。
- en: You should be able to see clearly now that test coverage doesn’t necessarily
    correlate with test value. You’ve written one test that doesn’t exercise any code,
    and you already have 67% coverage of your Python modules.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该清楚地看到测试覆盖率并不一定与测试值相关。您已经编写了一个不执行任何代码的测试，而您的Python模块已经有了67%的覆盖率。
- en: Coverage for non-Python extensions
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 非Python扩展的覆盖
- en: Coverage.py typically covers Python source code, but for some non-Python extensions,
    it may be possible to cover their source code by enabling line tracing during
    compilation and using Coverage.py plugins that understand the line trace information.
    As an example, you can specify additional directives in your Cython .pyx files
    to enable line tracing and use the `Cython.Coverage` plugin to measure coverage.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Coverage.py通常覆盖Python源代码，但对于某些非Python扩展，通过在编译时启用行跟踪并使用理解行跟踪信息的Coverage.py插件，可能覆盖它们的源代码。例如，您可以在Cython的.pyx文件中指定额外的指令以启用行跟踪，并使用`Cython.Coverage`插件来测量覆盖率。
- en: Enabling branch coverage
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 启用分支覆盖率
- en: 'In addition to line coverage, an important aspect of testing is understanding
    how many alternative execution paths are possible and which of those paths are
    untested. A piece of code’s *cyclomatic complexity* (Thomas J. McCabe, “A Complexity
    Measure.” *IEEE Transactions on Software Engineering* 4 [1976]: 308–20., doi:10.1109/tse.1976.233837)
    measures the number of paths through the code, and for full coverage of your code’s
    behavior, you need a test for each path. In Coverage.py, this is known as *branch
    coverage*.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '除了行覆盖率外，测试的一个重要方面是了解有多少可能的替代执行路径以及哪些路径没有被测试。一段代码的*循环复杂度*（托马斯·J·麦卡贝，《复杂性度量》。*IEEE
    Transactions on Software Engineering* 4 [1976]: 308–20., doi:10.1109/tse.1976.233837）衡量了代码中的路径数量，为了全面覆盖代码的行为，您需要对每个路径进行测试。在Coverage.py中，这被称为*分支覆盖率*。'
- en: 'To configure branch coverage for your tests, add a new section to setup.cfg
    called `[coverage:run]`. In this section, add a `branch` key with a value of `True`
    (see listing 5.1). This produces two new columns in the coverage output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要为测试配置分支覆盖率，请向setup.cfg添加一个名为`[coverage:run]`的新部分。在这个部分中，添加一个值为`True`的`branch`键（参见列表5.1）。这会在覆盖率输出中产生两列新数据：
- en: '`Branch`—How many branches exist throughout the code'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Branch`—代码中存在的分支数量'
- en: '`BrPart`—How many branches are only partially covered by tests'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BrPart`—测试仅部分覆盖的分支数量'
- en: Exercise 5.3
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.3
- en: While you’re adding the `[coverage:run]` section, add a `source` key with a
    value of `imppkg`. This is a handy way to stop specifying `imppkg` to the `--cov`
    option for pytest each time and ensures that anyone running tests with coverage
    will see the same output. You can also avoid specifying `--cov` altogether by
    adding an `addopts` key to the `[tool:pytest]` section with a value of `--cov`.
    You can override this at the command line later as desired using the corresponding
    `--no-cov` option.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当您添加`[coverage:run]`部分时，添加一个值为`imppkg`的`source`键。这是一种方便的方法，可以停止每次在pytest的`--cov`选项中指定`imppkg`，并确保运行带有覆盖率测试的任何人都会看到相同的输出。您还可以通过在`[tool:pytest]`部分添加一个值为`--cov`的`addopts`键来完全避免指定`--cov`。您可以在命令行上使用相应的`--no-cov`选项来覆盖它。
- en: After adding those configurations, what command should you run to get the same
    behavior you have been so far?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了这些配置后，您应该运行什么命令才能获得迄今为止的行为？
- en: A)   `pytest`
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: A)   `pytest`
- en: B)   `pytest --cov`
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: B)   `pytest --cov`
- en: C)   `py -m pytest --cov`
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: C)   `py -m pytest --cov`
- en: D)   `py -m pytest --no-cov`
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: D)   `py -m pytest --no-cov`
- en: E)   `py -m pytest`
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: E)   `py -m pytest`
- en: F)   `py -m pytest --cov=imppkg`
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: F)   `py -m pytest --cov=imppkg`
- en: Listing 5.1 Configuring coverage to measure branches
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 配置覆盖率以测量分支
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With branch coverage enabled, possible branches are added to the statement
    count to determine total coverage. Run pytest again. Notice that the coverage
    for your code dropped from 67% to 50%, as shown next:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 启用分支覆盖率后，可能的分支被添加到语句计数中，以确定总覆盖率。再次运行pytest。注意，您的代码覆盖率从67%下降到50%，如下所示：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Two branches were found, and none were partially covered.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 找到两个分支，且都没有部分覆盖。
- en: Note When branches are considered in coverage, the total coverage will be strictly
    less than or equal to the coverage without branching considered. The coverage
    percentage with branches considered can be difficult to calculate by hand because
    it considers all the different paths code may take during execution. You can read
    more about the specifics of branch measurement in the Coverage.py documentation
    ([http://mng.bz/G1EA](http://mng.bz/G1EA)).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当考虑分支覆盖率时，总覆盖率将严格小于或等于不考虑分支的覆盖率。考虑分支的覆盖率百分比可能难以手工计算，因为它考虑了代码在执行过程中可能采取的所有不同路径。您可以在Coverage.py文档中了解更多关于分支测量的具体信息（[http://mng.bz/G1EA](http://mng.bz/G1EA)）。
- en: Now that you have a clearer picture of how well your tests cover your code and
    its execution paths, it’s useful to know exactly which paths aren’t covered.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经清楚地了解了测试如何覆盖您的代码及其执行路径，了解哪些路径没有被覆盖是非常有用的。
- en: Enabling missing coverage
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 启用缺失覆盖率
- en: 'Coverage.py can keep track of exactly which lines and branches aren’t covered
    by tests, which is a big help as you try to write tests that increase the coverage
    of your code. You can turn this on by adding a new section to setup.cfg called
    `[coverage :report]`, with a new key called `show_missing` set to a value of `True`
    (see listing 5.2). This will produce one new `Missing` column in the coverage
    output. The `Missing` column lists the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Coverage.py 可以跟踪测试未覆盖的确切行和分支，这在尝试编写提高代码覆盖率测试时非常有帮助。你可以通过在 setup.cfg 中添加一个新的部分来启用此功能，该部分称为
    `[coverage :report]`，并添加一个新键 `show_missing`，将其值设置为 `True`（参见列表 5.2）。这将产生一个新列 `Missing`
    在覆盖率输出中。`Missing` 列列出以下内容：
- en: Lines or ranges of lines that aren’t covered. As an example, `9` means line
    9 is uncovered, and `10-12` means lines 10, 11, and 12 are uncovered.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未覆盖的行或行范围。例如，`9` 表示第 9 行未覆盖，而 `10-12` 表示第 10、11 和 12 行未覆盖。
- en: Logic flow from one line to another that represents a branch that isn’t covered.
    As an example, `13->19` means the execution path that starts at line 13 that would
    next execute line 19 is uncovered.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示未覆盖分支的逻辑流程从一个行到另一个行。例如，`13->19` 表示从第 13 行开始的执行路径将接下来执行第 19 行，这部分路径未覆盖。
- en: Listing 5.2 Configuring coverage to show uncovered code
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 配置覆盖率以显示未覆盖的代码
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run pytest again to see what the coverage report says you’re missing. The lines
    listed in the report will correspond to the lines of the `main` function body
    in the `harmony.py` module, as shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 pytest 来查看覆盖率报告显示你遗漏了哪些内容。报告中列出的行将与 `harmony.py` 模块中 `main` 函数体的行相对应，如下所示：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Lines 9 and 10 are uncovered.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 第 9 行和第 10 行未覆盖。
- en: You can use the report of missing lines to quickly identify areas of focus for
    writing more tests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用未覆盖行的报告快速识别需要编写更多测试的焦点区域。
- en: Take a close look at the file paths in the Coverage.py output. They point to
    the files created in the virtual environment when you installed your package,
    with a prefix like .venv/lib/python3.10/site-packages/imppkg/. This is perfectly
    correct but can sometimes be difficult to read with the long prefix in front of
    each file. To simplify these paths and map the coverage back to the related source
    code, you can tell Coverage.py which file paths it should consider equivalent.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看 Coverage.py 输出中的文件路径。它们指向你在安装你的包时在虚拟环境中创建的文件，前缀类似于 .venv/lib/python3.10/site-packages/imppkg/。这是完全正确的，但有时由于每个文件前都有长前缀，阅读起来可能会有点困难。为了简化这些路径并将覆盖率映射回相关的源代码，你可以告诉
    Coverage.py 它应考虑哪些文件路径是等效的。
- en: Simplifying coverage report output
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 简化覆盖率报告输出
- en: In your project, the .venv/lib/python3.10/site-packages/imppkg/ directory of
    your installed package is roughly equivalent to the src/imppkg/ directory of the
    package’s source code. Tell Coverage.py this is the case with a new section in
    setup.cfg called `[coverage:paths]`. Add a `source` key to this section, with
    a list value of equivalent file paths. Coverage.py will use the first entry to
    replace any subsequent entries in the output. Paths in this list can contain wildcard
    characters (`*`) to allow any name in that portion of the path to match. The new
    section should look like the next listing when you finish.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中，你已安装的包的 .venv/lib/python3.10/site-packages/imppkg/ 目录大致等同于包源代码的 src/imppkg/
    目录。通过在 setup.cfg 中添加一个新的部分来告诉 Coverage.py 这一点，该部分称为 `[coverage:paths]`。向此部分添加一个
    `source` 键，其值为等效文件路径的列表。Coverage.py 将使用列表中的第一个条目来替换输出中的任何后续条目。此列表中的路径可以包含通配符字符
    (`*`)，以允许路径该部分的任何名称匹配。完成时，新部分应类似于以下列表。
- en: Listing 5.3 Configuring coverage to output paths related to the source code
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.3 配置覆盖率以输出与源代码相关的路径
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run pytest again. The file paths in the output will be prefixed with src/imppkg
    instead of .venv/lib/python3.10/site-packages/imppkg, as shown next:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 pytest。输出中的文件路径将以 src/imppkg 为前缀，而不是 .venv/lib/python3.10/site-packages/imppkg，如下所示：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As your project grows and you spend more time testing, it might become harder
    to pick out uncovered modules from the coverage report. If you’re reaching 100%
    coverage for several files, it can be helpful to ignore them in the report output.
    You can add a `skip_covered` key with a value of `True` to the `[coverage:report]`
    section to filter those out (see the next listing). Files that are filtered out
    are only removed from the list; their coverage is still considered in the total
    coverage calculation for your code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的项目增长和你在测试上花费更多的时间，从覆盖率报告中挑选出未覆盖的模块可能会变得更加困难。如果你为几个文件达到了100%的覆盖率，那么在报告输出中忽略它们可能会有所帮助。你可以在`[coverage:report]`部分添加一个`skip_covered`键，其值为`True`来过滤它们（参见下一列表）。被过滤的文件仅从列表中删除；它们的覆盖率仍然被考虑在代码的总覆盖率计算中。
- en: Listing 5.4 Configuring coverage to skip covered files
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4 配置覆盖率以跳过已覆盖的文件
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run pytest again. The `__init__.py` module will be filtered out of the report,
    with a message confirming that’s the case, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行pytest。`__init__.py`模块将被从报告中过滤出来，有一条消息确认了这一点，如下所示：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ This confirms that fully covered files are filtered out.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这确认了完全覆盖的文件被过滤出来。
- en: Now the coverage report shows you only those files that require your attention
    when your aim is to increase your test coverage.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在覆盖率报告只显示当你旨在增加测试覆盖率时需要你注意的文件。
- en: 5.1.3 Increasing test coverage
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 增加测试覆盖率
- en: You’ve now got a trimmed-down way to see which files in your project may need
    testing attention with a report that can quickly let you know how changes you
    make impact the coverage. It’s a great time to get a real test written to replace
    the `assert True` you wrote earlier.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有一种简化的方式可以看到你的项目中哪些文件可能需要测试关注，报告可以快速让你知道你做的更改如何影响覆盖率。这是一个编写真正的测试来替换你之前写的`assert
    True`的好时机。
- en: 'In the `test_harmonic_mean.py` module, you need to write a test that exercises
    the code in the `harmony.py` module. The code there consists of the `main` function,
    which does the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test_harmonic_mean.py`模块中，你需要编写一个测试来测试`harmony.py`模块中的代码。那里的代码包括`main`函数，它执行以下操作：
- en: Reads arguments from `sys.argv`
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`sys.argv`读取参数
- en: Converts those arguments to floating-point numbers
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些参数转换为浮点数
- en: Calculates the harmonic mean of the numbers using the `harmonic_mean` function
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`harmonic_mean`函数计算数字的调和平均值
- en: Prints the result in colored text
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以彩色文本打印结果
- en: You can write a test that will facilitate all these actions by patching `sys.argv`
    to a controlled value and asserting that the output is what you expect. This will
    also result in 100% coverage of the `harmony.py` module. However, this is what’s
    known as a *happy path test*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将`sys.argv`修补到受控值并断言输出是你期望的来编写一个测试，这将促进所有这些操作。这将导致`harmony.py`模块的100%覆盖率。然而，这被称为*愉快的路径测试*。
- en: Uncovering unhappy paths
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 揭示不愉快的路径
- en: Unhappy path tests exercise the less-frequent, error-prone ways through the
    code under test. When you want to make your code more robust, you should venture
    outside happy path tests to find these edge cases that may break your code (see
    figure 5.2).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不愉快的路径测试会练习在测试代码中较少出现、容易出错的路径。当你想要使你的代码更加健壮时，你应该冒险走出愉快的路径测试，以找到可能破坏你代码的边缘情况（见图5.2）。
- en: '![](../../OEBPS/Images/05-02.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/05-02.png)'
- en: Figure 5.2 Tests may cover the common, desired execution paths or the less common
    edge and error cases.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 测试可能覆盖常见的、期望的执行路径或较少见的边缘和错误情况
- en: You might be wondering how you can write tests with 100% line *and* branch coverage
    that can still miss code failures. If you have tests for every execution path
    that all pass, how can there be a way for the code to fail? The reason often comes
    down to the inputs that a piece of code accepts, especially if that input can
    come directly from a user. In the case of the `harmony` console script, it accepts
    input directly from the user at the command line and passes it into the `harmony.py`
    module’s `main` function. If that input is invalid, your code may handle it in
    an unexpected way. This serves as a good reminder that full test coverage still
    isn’t a perfect protection against errors.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道如何编写具有100%行和分支覆盖率的测试，同时仍然可能错过代码故障。如果你有针对每个执行路径的测试并且所有测试都通过，那么代码如何失败呢？原因通常归结于代码接受的输入，特别是如果该输入可以直接来自用户。在`harmony`控制台脚本的情况下，它直接从命令行接收用户输入并将其传递到`harmony.py`模块的`main`函数。如果该输入无效，你的代码可能会以意想不到的方式处理它。这作为一个很好的提醒，即完整的测试覆盖率仍然不是完全防止错误的完美保护。
- en: Try running the installed `harmony` command. Note that you’ll need to run it
    using `.venv/bin/harmony` because you haven’t installed your package globally
    and the `harmony` command isn’t on your `$PATH`. What happens when you pass it
    arguments that can’t be converted to numbers? What happens when you don’t pass
    it any arguments at all? You can produce a `ZeroDivisionError` or a `ValueError`.
    So even though a happy path where you pass in numbers works correctly, it’s still
    possible to produce undesired outcomes with carefully chosen inputs. It’s up to
    you in these cases to choose between documenting the proper usage and ignoring
    the edge cases, or updating your code to accommodate.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行已安装的`harmony`命令。请注意，你需要使用`.venv/bin/harmony`来运行它，因为你没有全局安装你的包，并且`harmony`命令不在你的`$PATH`中。当你传递无法转换为数字的参数时会发生什么？当你一个参数都不传递时会发生什么？你可以产生`ZeroDivisionError`或`ValueError`。所以即使传递数字的愉快路径工作正常，仍然有可能通过精心选择的输入产生不期望的结果。在这些情况下，选择记录正确的用法、忽略边缘情况或更新代码以适应取决于你。
- en: For the moment, assume that any inputs that result in a division by zero or
    that can’t be converted to numbers should result in an output of `0.0`. One way
    to accommodate this in the code is with a `try` for each potentially dangerous
    operation and a `catch` to handle the corresponding exception (see listing 5.5).
    This can start to feel like *defensive programming*, where you guard against all
    possible risks, no matter how unlikely they might be. But for some applications,
    you want to provide an error-free outcome, either for user experience or safety.
    You want CarCorp to be happy, and with the back and forth you’ve already had with
    them, it seems worth covering your bases.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，假设任何导致除以零或无法转换为数字的输入都应该导致输出为`0.0`。在代码中实现这一点的 一种方式是使用每个潜在危险操作的`try`和相应的`catch`来处理异常（参见列表5.5）。这可能会开始感觉像*防御性编程*，其中你防范所有可能的风险，无论它们可能多么不可能发生。但对于某些应用，你希望提供一个无错误的输出，无论是为了用户体验还是安全性。你希望CarCorp感到满意，并且根据你与他们已经进行的来回交流，这似乎值得覆盖你的基础。
- en: Listing 5.5 A safer version of the main function that handles poor inputs
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5 主函数的一个更安全的版本，可以处理较差的输入
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ The result will be zero unless successfully calculated later.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 结果将在稍后成功计算之前为零。
- en: ❷ If any input can’t be converted to a number, proceed as if there’s no input.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果任何输入无法转换为数字，则按没有输入处理。
- en: ❸ If there’s no input or the input is only zero, proceed with the default result.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果没有输入或输入仅为零，则使用默认结果继续。
- en: This creates more lines and branches in the code, so you can expect the coverage
    to drop further. But now your coverage measurement can guide you to writing tests
    that assert the proper behavior for a wider variety of inputs. Update the source
    code in the `harmony.py` module to catch the `ValueError` and `ZeroDivisionError`
    cases. Then reinstall your package into your virtual environment using the `py
    -m pip install .` command.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在代码中创建更多的行和分支，因此你可以预期覆盖率会进一步下降。但现在你的覆盖率测量可以指导你编写测试，以断言更广泛输入的正确行为。更新`harmony.py`模块中的源代码以捕获`ValueError`和`ZeroDivisionError`情况。然后使用`py
    -m pip install .`命令将你的包重新安装到虚拟环境中。
- en: Exercise 5.4
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.4
- en: 'The following test covers the happy path of the `main` function, faking a user
    input and making an assertion about the printed output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试覆盖了`main`函数的愉快路径，模拟用户输入并对打印的输出进行断言：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ pytest fixtures to set state and get command output
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ pytest fixtures用于设置状态和获取命令输出
- en: ❷ Values for which to calculate a harmonic mean, as strings
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 要计算调和平均值的值，作为字符串
- en: ❸ Passes the values as if they were supplied to harmony
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将值作为如果它们是提供给harmony的参数传递
- en: ❹ Reads from sys.argv and performs the calculation
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从sys.argv读取并执行计算
- en: ❺ Asserts the output is 2.0 in colored text
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 断言输出为2.0，并以彩色文本显示
- en: Add this test to the `test_harmonic_mean.py` module and run pytest. You will
    see the coverage increase. What would you adjust for additional tests to cover
    the unhappy paths? How many additional tests do you need? Add a test for each
    of the unhappy paths you accounted for in the code to reach 100% coverage. Ensure
    that each test has a unique name so that pytest will run them all.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将此测试添加到`test_harmonic_mean.py`模块中并运行pytest。你会看到覆盖率增加。为了覆盖不愉快的路径，你会调整哪些内容进行额外的测试？你需要多少额外的测试？为代码中考虑到的每个不愉快的路径添加一个测试，以达到100%的覆盖率。确保每个测试都有一个独特的名称，以便pytest可以运行它们。
- en: 'Earlier in this chapter, you configured Coverage.py to skip listing fully covered
    files. When you reach 100% coverage, all your files will disappear from the output
    because they’re fully covered. The Coverage.py output shows an indication of 100%
    coverage as well, as shown next:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，你配置了Coverage.py以跳过列出完全覆盖的文件。当你达到100%的覆盖率时，所有文件都将从输出中消失，因为它们已经被完全覆盖。Coverage.py的输出也显示了100%覆盖率的指示，如下所示：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Indicates no missed statements or branches and 100% coverage
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 表示没有遗漏的语句或分支，并且100%的覆盖率
- en: ❷ Indicates both files were skipped in the report due to full coverage
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 表示报告中由于完全覆盖而跳过了两个文件
- en: Now that you’ve reached 100% coverage, including some unhappy paths, you’re
    in great shape. pytest will tell you if the behavior of your code regresses in
    the form of failing tests, and Coverage.py will tell you if there are any obvious
    opportunities for additional tests lurking. This leaves you free to get into the
    testing mindset and uncover unhappy paths that only you can identify. Now that
    you’ve got that out of the way, you’ll take a few additional measures to further
    reduce the effort of testing going forward.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经达到了100%的覆盖率，包括一些不愉快的路径，你处于非常好的状态。pytest会告诉你代码的行为是否因为失败的测试而退化，而Coverage.py会告诉你是否有任何明显的额外测试机会。这让你可以自由地进入测试思维模式，发现只有你能识别的不愉快路径。现在你已经解决了这些问题，你将采取一些额外的措施来进一步减少未来的测试工作量。
- en: 5.2 Addressing testing tedium
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 解决测试的乏味
- en: When you’re new to testing, it can feel like a big thing standing in the way
    of getting things done. When you just want to deliver new features and value,
    tests can feel like a tangential effort. Reducing the effort of testing is a good
    way to encourage its adoption, and the investment will pay dividends in the future
    as your test suite grows.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始接触测试时，它可能感觉像是一个巨大的障碍，阻碍你完成任务。当你只想交付新的特性和价值时，测试可能会感觉像是一项附带的工作。减少测试的工作量是鼓励其采用的好方法，随着你的测试套件的增长，这种投资将在未来带来回报。
- en: 5.2.1 Addressing repetitive, data-driven tests
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 解决重复的、数据驱动的测试
- en: You might have noticed that the tests you wrote to cover the `main` function
    all looked eerily similar. They each have the same basic shape, with just a few
    values altered. pytest has a great tool to address this kind of repeated, data-driven
    test. The `@pytest.mark.parametrize` decorator maps a list of values to arguments
    for the decorated test function, creating a separate test for each set of values.
    You can then use these arguments to construct a single test function that will
    properly assert the behavior for all the different values.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，你为覆盖`main`函数编写的测试看起来非常相似。它们都有相同的基本形状，只是改变了一些值。pytest有一个很好的工具来解决这种重复的、数据驱动的测试。`@pytest.mark.parametrize`
    装饰器将一个值列表映射到装饰的测试函数的参数上，为每一组值创建一个单独的测试。然后你可以使用这些参数来构建一个单一的测试函数，该函数将正确断言所有不同值的行为。
- en: 'The `@pytest.mark.parametrize` decorator accepts the following arguments:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`@pytest.mark.parametrize` 装饰器接受以下参数：'
- en: The argument names to map values to as a comma-separated string
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值映射到参数的逗号分隔字符串
- en: A list, where each item is a tuple of values to map to the arguments
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个列表，其中每个项都是一个映射到参数的值的元组
- en: The decorated test function must accept arguments that correspond to the first
    `parametrize` argument, but it can accept additional arguments in any order. It’s
    a common practice to place the parameterized arguments first and any additional
    arguments like fixtures last.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰的测试函数必须接受与第一个`parametrize`参数对应的参数，但它可以以任何顺序接受额外的参数。将参数化的参数放在前面，将像 fixtures
    这样的额外参数放在最后是一种常见的做法。
- en: 'Imagine you’ve written a `mul` function that accepts two numeric arguments
    and returns their product. You want to write some tests that ensure it works properly
    when an input is positive, zero, and negative. You can use pytest’s parameterization
    to do so, as shown in the following snippet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经编写了一个接受两个数值参数并返回其乘积的`mul`函数。你想要编写一些测试来确保它在输入为正数、零和负数时都能正常工作。你可以使用pytest的参数化来实现这一点，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ The argument names to which values are mapped
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 映射到值的参数名称
- en: ❷ A list of tuples, each of which gets mapped
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个元组的列表，每个元组都得到映射
- en: ❸ Argument names that match the specification to parametrize
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 与参数化规范匹配的参数名称
- en: ❹ A test constructed using the mapped arguments
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用映射参数构建的测试
- en: This parameterized test function will result in four tests; each will have its
    own status in the pytest output. If one fails, the others can still pass. If you
    want to add more cases, it’s a matter of adding a new tuple to the list of parameters.
    This can make it much faster to deal with data-heavy test suites with repetitive
    tests.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数化测试函数将产生四个测试；每个测试在pytest输出中都有自己的状态。如果一个失败了，其他的仍然可以通过。如果你想添加更多的情况，只需在参数列表中添加一个新的元组即可。这可以使处理数据密集型测试套件中的重复测试变得更快。
- en: Exercise 5.5
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.5
- en: Using `@pytest.mark.parametrize`, convert your tests for the `harmony.py` module’s
    `main` function into a single, parameterized test. Don’t forget to import `pytest`.
    After you finish, you should still have 100% coverage and the same number of passing
    tests.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@pytest.mark.parametrize`，将`harmony.py`模块的`main`函数的测试转换为单个参数化测试。别忘了导入`pytest`。完成之后，你应该仍然有100%的覆盖率，以及相同数量的通过测试。
- en: Now that you’ve made your tests a bit leaner, you’ll take a closer look at the
    testing process itself.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经使你的测试变得更加精简，你将更仔细地查看测试过程本身。
- en: 5.2.2 Addressing frequent package installation
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 解决频繁安装包的问题
- en: You’ve installed your package into your virtual environment at least twice now.
    Because you set up your package to ensure you’re always testing against the installed
    package, you need to reinstall the package each time you make any functional changes.
    This ensures that what you see matches what others see, but it also creates this
    manual work for you. You’ve only made one or two small changes to your source
    code so far, but imagine how you’ll feel after your tenth feature request from
    CarCorp.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在至少已经将你的包安装到你的虚拟环境中两次了。因为你设置了你的包以确保你总是测试安装的包，所以每次你进行任何功能更改时，都需要重新安装包。这确保了你看到的内容与别人看到的一致，但这也为你创造了手动工作。到目前为止，你只对源代码做了一两个小的更改，但想象一下，当你从CarCorp收到第十个功能请求时，你会是什么感觉。
- en: You also learned that making your package compatible with multiple dependencies
    and systems helps more people use it successfully. If you want to test your package
    with those different dependencies, that multiplies your manual work; each new
    dependency range causes further *combinatorial* growth (see figure 5.3). Combinatorial
    growth happens in a system where the number of possible states increases significantly
    with each new dimension added to the system. In your testing system, with only
    a few dependency variables, you can quickly reach tens of combinations to test.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你还了解到，使你的包与多个依赖项和系统兼容可以帮助更多的人成功使用它。如果你想用那些不同的依赖项测试你的包，这会成倍增加你的手动工作；每个新的依赖项范围都会导致进一步的*组合增长*（见图5.3）。组合增长发生在系统中，随着系统新增每个新维度，可能的状态数量显著增加。在你的测试系统中，只有几个依赖变量，你就可以快速达到需要测试的数十种组合。
- en: '![](../../OEBPS/Images/05-03.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/05-03.png)'
- en: Figure 5.3 Testing across a range of versions for multiple dependencies grows
    very quickly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 在多个依赖项的多个版本范围内进行测试会迅速增长。
- en: tox ([https://tox.readthedocs.io](https://tox.readthedocs.io)) automates the
    installation of packages for testing and the creation of a test matrix for dependency
    combinations. It significantly reduces the manual work you need to do, and as
    a result, it reduces the chance of human error in your testing.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: tox ([https://tox.readthedocs.io](https://tox.readthedocs.io)) 自动安装测试包，并为依赖项组合创建测试矩阵。这显著减少了你需要进行的手动工作，因此，它减少了你在测试中的人为错误机会。
- en: Getting started with tox
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用tox
- en: tox builds a fresh virtual environment for each combination of dependencies
    you test. Because of this isolated approach, you can make tox available globally
    and use it across projects instead of installing it separately in each.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: tox为每个测试的依赖项组合创建一个新的虚拟环境。由于这种隔离方法，你可以将tox设置为全局可用，并在多个项目中使用它，而不是在每个项目中单独安装。
- en: Note If you haven’t installed tox yet, head over to appendix B and return to
    this section when you’re done.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你还没有安装tox，请转到附录B，完成安装后返回本节。
- en: 'From the root directory of your project, run the `tox` command. Because you
    haven’t configured tox yet, you will see the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的项目根目录运行`tox`命令。因为你还没有配置tox，你会看到以下输出：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now add a new section to the setup.cfg file called `[tox:tox]`. This section
    is where you’ll put the high-level configuration for your test matrix, as well
    as for tox itself. Start by adding an `isolated_build` key with a value of `True`
    as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在向 setup.cfg 文件添加一个名为 `[tox:tox]` 的新部分。这部分是你将放置测试矩阵以及 tox 本身的高级配置的地方。首先添加一个
    `isolated_build` 键，其值为 `True`，如下所示：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This tells tox to use the PEP 517 and PEP 518 standards you learned about in
    chapter 3 to build your package. Run tox again to confirm that it sees the configuration.
    tox produces the following friendly output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 tox 使用你在第 3 章中学到的 PEP 517 和 PEP 518 标准来构建你的包。再次运行 tox 以确认它看到了配置。tox 产生以下友好的输出：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the confirmation that tox is reading your configuration, you’re ready to
    start creating a test matrix.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 确认 tox 正在读取你的配置后，你就可以开始创建测试矩阵了。
- en: The tox environment model
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: tox 环境模型
- en: tox operates on the concept of *environments*. A tox environment is an isolated
    place to perform a set of commands, with its own set of installed dependencies
    and environment variables. Each tox environment includes a virtual environment
    with a copy of the Python interpreter (see figure 5.4). The tox configuration
    language gives you fine control over all of this, with a syntax that overcomes
    most of the challenges arising from the combinatorial nature of your test matrix.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: tox 运作在 *环境* 的概念上。tox 环境是一个执行一组命令的隔离场所，它有自己的安装依赖和环境变量集。每个 tox 环境都包含一个包含 Python
    解释器副本的虚拟环境（见图 5.4）。tox 配置语言为你提供了对所有这些内容的精细控制，其语法克服了你测试矩阵组合性质带来的大多数挑战。
- en: '![](../../OEBPS/Images/05-04.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4](../../OEBPS/Images/05-04.png)'
- en: Figure 5.4 tox environments are an isolated place to build, install, and test
    your code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 tox 环境是构建、安装和测试你的代码的隔离场所。
- en: You can create any arbitrary environments that you wish, but tox treats a few
    environment names specially. Environments with names like `py37` or `py310` will
    create a virtual environment with a copy of the corresponding version of the Python
    interpreter. The `envlist` key in the tox configuration defines which environments
    tox should create and execute by default when running the `tox` command. The environments
    in the `envlist` can also be run individually as desired by using the `-e` argument
    to the `tox` command and specifying the environment name.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建任何你想要的任意环境，但 tox 对一些环境名称有特殊处理。名称如 `py37` 或 `py310` 的环境将创建一个包含相应版本 Python
    解释器的虚拟环境。tox 配置中的 `envlist` 键定义了 tox 在运行 `tox` 命令时默认创建和执行哪些环境。`envlist` 中的环境也可以通过使用
    `tox` 命令的 `-e` 参数并指定环境名称来单独运行。
- en: 'To get started, add an `envlist` key to the `tox:tox` section in your setup.cfg
    file with a value of `py310` as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请在 setup.cfg 文件中的 `tox:tox` 部分添加一个 `envlist` 键，其值为 `py310`，如下所示：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ The list of tox environments is your test matrix.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ tox 环境列表是你的测试矩阵。
- en: The next time you run tox, it will
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下次你运行 tox 时，它将
- en: Create an isolated build of your package
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个隔离的包构建
- en: Create a virtual environment with a copy of Python 3.10
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含 Python 3.10 复制品的虚拟环境
- en: Install your package in the virtual environment
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚拟环境中安装你的包
- en: Set `PYTHONHASHSEED` to a new value to create more randomness for tests
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `PYTHONHASHSEED` 设置为新值以为测试创建更多随机性
- en: 'Run the `tox` command again. You will see output similar to the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 `tox` 命令。你将看到类似以下输出：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ An isolated package build using tox as the build frontend
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 tox 作为构建前端进行隔离的包构建
- en: ❷ The build backend dependencies
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 构建后端依赖
- en: ❸ Virtual environment creation
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建虚拟环境
- en: ❹ Installation of your package
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 安装你的包
- en: ❺ Successful installation of your package
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 成功安装你的包
- en: ❻ Successful installation of package dependencies
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 成功安装包依赖
- en: ❼ Seeds Python’s randomization
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 为 Python 的随机化设置种子
- en: ❽ Any commands executed in the environment succeeded.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 环境中执行的所有命令都成功。
- en: With only a small amount of configuration, tox is able to do all this work for
    you. You haven’t told tox what commands to run in the environment yet, but your
    environment is there and ready. What if you want to do the same thing for multiple
    versions of Python? The `envlist` key accepts a comma-separated list of environments.
    As an example, you can specify `py39,py310` to create both a Python 3.9 and Python
    3.10 environment.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 只需少量配置，tox就能为你完成所有这些工作。你还没有告诉tox在环境中要运行哪些命令，但你的环境已经存在并准备好了。如果你想为多个Python版本做同样的事情呢？`envlist`
    键接受一个以逗号分隔的环境列表。例如，你可以指定 `py39,py310` 来创建Python 3.9和Python 3.10的环境。
- en: Update your `envlist` value to include an environment for an additional Python
    version. Although you’ve specified a new environment to create, tox will skip
    building your package because it knows the source code hasn’t changed since the
    last build. Similar to the `py310` environment you already created, in the `py39`
    environment, tox will
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的`envlist`值以包括一个额外的Python版本。虽然你指定了要创建的新环境，但tox会跳过构建你的包，因为它知道自上次构建以来源代码没有变化。类似于你已创建的`py310`环境，在`py39`环境中，tox将
- en: Create the virtual environment
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建虚拟环境
- en: Install your package into it
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的包安装到其中
- en: Set `PYTHONHASHSEED`
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `PYTHONHASHSEED`
- en: 'tox will then execute the `py310` environment again. Because it already existed,
    tox won’t recreate it or reinstall dependencies unless it detects that the dependencies
    have changed. Run tox again. You will see output similar to the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: tox将再次执行`py310`环境。因为它已经存在，tox不会重新创建它或重新安装依赖项，除非它检测到依赖项已更改。再次运行tox。你将看到类似以下输出的内容：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ The py39 environment is added.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加了py39环境。
- en: ❷ The inst-nodeps skips installing dependencies.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ inst-nodeps跳过了安装依赖项。
- en: ❸ Confirmation of each environment executed
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 确认每个环境都已执行
- en: You doubled the size of your test matrix by adding a few characters to the tox
    configuration. This becomes more and more valuable as you expand the combinations
    of dependencies you need to test, because you don’t need to specify the combinations
    individually. tox will also ensure that your tests execute for each combination,
    which maximizes the chance of uncovering a bug specific to a given combination.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在tox配置中添加几个字符，你将测试矩阵的大小翻倍了。随着你需要测试的依赖组合的扩展，这变得越来越有价值，因为你不需要单独指定这些组合。tox还将确保为每个组合执行测试，从而最大限度地提高发现特定组合的bug的机会。
- en: Because adding a new combination of dependencies will execute the tests an additional
    time, the total execution time of your test suite will grow. It can be helpful
    to run your tests in a single environment using the `-e` option while you’re changing
    your code or your tests, and then run `tox` without specifying an argument after
    you’ve made your changes to ensure nothing has broken across all environments.
    You can also run multiple environments in parallel, which is covered later in
    this chapter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因为添加新的依赖组合将使测试额外执行一次，所以你的测试套件的总体执行时间会增长。在你更改代码或测试时，使用`-e`选项在单个环境中运行测试可能会有所帮助，然后在你做出更改后不指定任何参数运行`tox`，以确保所有环境中没有出现任何问题。你还可以并行运行多个环境，这将在本章后面介绍。
- en: Now you have two testing environments, but neither one does anything yet. The
    next step is to tell tox what to do within each environment.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有两个测试环境，但它们目前都还没有做任何事情。下一步是告诉tox在每个环境中要做什么。
- en: 5.2.3 Configuring test environments
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 配置测试环境
- en: So far you’ve configured tox in the `[tox:tox]` section to indicate how to build
    your package and which environments to create. To configure the test environments
    themselves, add a new `[testenv]` section. This section is used by default for
    any configured test environment. In this section, you tell tox what commands to
    run using the `commands` key. This key accepts a list of commands to run, with
    some special syntax available to pass arguments to the commands.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经在 `[tox:tox]` 部分配置了tox，以指示如何构建你的包以及要创建哪些环境。为了配置测试环境本身，添加一个新的 `[testenv]`
    部分。这个部分默认用于任何配置的测试环境。在这个部分中，你使用 `commands` 键告诉tox要运行哪些命令。这个键接受一个要运行的命令列表，并提供一些特殊语法来传递参数给命令。
- en: Within each command, you can use the `{posargs}` placeholder, which will pass
    any arguments to specify to the `tox` command along to the test environment commands.
    As an example, if you specify `python -c 'print("{posargs}")'` as a command, running
    `tox hello world` will execute `python -c 'print("hello world")'` in the environment.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个命令中，你可以使用 `{posargs}` 占位符，它将传递任何指定给 `tox` 命令的参数到测试环境命令中。例如，如果你指定 `python
    -c 'print("{posargs}")'` 作为命令，运行 `tox hello world` 将在环境中执行 `python -c 'print("hello
    world")'`。
- en: You can also pass options to a test command by separating them from the `tox`
    command and any of its options with two dashes (`--`). As an example, if you specify
    `python` as a command, running `tox -- -V` will execute `python -V` in the environment.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用两个短横线（`--`）将选项与 `tox` 命令及其任何选项分开来传递测试命令的选项。例如，如果你指定 `python` 作为命令，运行
    `tox -- -V` 将在环境中执行 `python -V`。
- en: Exercise 5.6
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.6
- en: Your test environments should execute the `pytest` command, with the ability
    to pass it additional arguments when running tox. Which of the following show
    a valid test command and corresponding tox command?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试环境应该能够执行 `pytest` 命令，并在运行 tox 时能够传递额外的参数。以下哪个显示了有效的测试命令和相应的 tox 命令？
- en: A) `pytest {posargs}`, `tox`
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: A) `pytest {posargs}`, `tox`
- en: B) `pytest {posargs}`, `tox --no-cov`
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: B) `pytest {posargs}`, `tox --no-cov`
- en: C) `pytest {posargs}`, `tox -- --no-cov`
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: C) `pytest {posargs}`, `tox -- --no-cov`
- en: D) `pytest --no-cov {posargs}`, `tox`
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: D) `pytest --no-cov {posargs}`, `tox`
- en: E) `pytest {posargs} --no-cov`, `tox`
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: E) `pytest {posargs} --no-cov`, `tox`
- en: F) `{posargs} pytest`, `tox -- --no-cov`
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: F) `{posargs} pytest`, `tox -- --no-cov`
- en: 'After you add the `pytest` command to the `commands` list, run tox again. You’ll
    see that after the steps you saw previously, tox tries to execute pytest and fails,
    as shown in the following output:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将 `pytest` 命令添加到 `commands` 列表后，再次运行 tox。你会看到在之前看到的步骤之后，tox 尝试执行 pytest 并失败，如下面的输出所示：
- en: '[PRE26]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Attempted execution of the correct command
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 尝试执行正确的命令
- en: ❷ The command can’t be found in the test environment.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 命令在测试环境中找不到。
- en: 'Even though you installed pytest into the virtual environment for your project
    earlier, recall that tox creates and uses an isolated virtual environment for
    each test environment. This means that tox won’t use the copy of pytest that you’ve
    been running. You haven’t told tox to install pytest in those environments, so
    it can’t find a copy there either. You can specify dependencies in the `[testenv]`
    section using the `deps` key. The value for `deps` is a list of Python packages
    to install, with syntax similar to `requirements.txt` or `install_requires`. For
    now, add `pytest` and `pytest-cov` as dependencies like so:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你之前已经将 pytest 安装到你的项目的虚拟环境中，但请记住，tox 为每个测试环境创建并使用一个独立的虚拟环境。这意味着 tox 不会使用你一直在运行的
    pytest 的副本。你没有告诉 tox 在这些环境中安装 pytest，所以它也找不到副本。你可以在 `[testenv]` 部分使用 `deps` 键指定依赖项。`deps`
    的值是一个要安装的 Python 包列表，其语法类似于 `requirements.txt` 或 `install_requires`。现在，像这样将 `pytest`
    和 `pytest-cov` 作为依赖项添加：
- en: '[PRE27]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run tox again. This time it will install the additional dependencies, and the
    `pytest` command will successfully run the tests and the coverage report, with
    output similar to the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 tox。这次它将安装额外的依赖项，并且 `pytest` 命令将成功运行测试和覆盖率报告，输出类似于以下内容：
- en: '[PRE28]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You’ve now got pytest and coverage running successfully in isolated environments
    on two different Python versions, without having to install your package manually.
    Any time you make a change to your source code, dependencies, or tests, you can
    run tox to see if things are still working. This early investment in infrastructure—especially
    for those who prefer test-driven development—will pay dividends throughout the
    rest of a package’s life.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你在两个不同的 Python 版本上成功地在隔离环境中运行了 pytest 和覆盖率，而不必手动安装你的包。每次你更改源代码、依赖项或测试时，你都可以运行
    tox 来查看一切是否仍然正常工作。这种对基础设施的早期投资——特别是对于那些喜欢测试驱动开发的人来说——将在整个包的生命周期中带来回报。
- en: Before you move on, read the next section for some additional testing and configuration
    tips.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，阅读下一节以获取一些额外的测试和配置技巧。
- en: 5.2.4 Tips for quicker and safer testing
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 更快、更安全的测试技巧
- en: As your project grows, you run the risk that the time you spend testing will
    grow along with it. To keep your productivity up, you want to keep testing as
    fast as possible and to reduce human error as much as possible. The following
    sections discuss some tips to keep your test suite execution in check.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的项目增长，你面临的风险是你在测试上花费的时间也会随之增长。为了保持你的生产力，你希望尽可能快地完成测试，并尽可能减少人为错误。以下章节讨论了一些保持你的测试套件执行受控的建议。
- en: Running test environments in parallel
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 并行运行测试环境
- en: You might have noticed that your Python 3.9 and Python 3.10 environments have
    been executing sequentially. They each take a few seconds, so it’s not too big
    of a deal. Now imagine a project where you’re testing three Python versions and
    three different versions of a dependency. Are you patient enough to wait for nine
    environments to run sequentially?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，你的 Python 3.9 和 Python 3.10 环境一直在顺序执行。每个环境都需要几秒钟，所以这不是什么大问题。现在想象一下，在一个项目中，你需要测试三个
    Python 版本和三个不同版本的依赖项。你有足够的耐心等待九个环境顺序运行吗？
- en: 'tox provides a parallel mode ([http://mng.bz/z546](http://mng.bz/z546)) that
    can execute multiple environments at a time. To run your two environments in parallel
    automatically, pass the `-p` option when running tox, as shown in the next code
    snippet. This mode will hide the output from each individual environment by default,
    showing only a progress indicator for the active environments and an overall pass
    or fail status for each environment:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: tox 提供了并行模式（[http://mng.bz/z546](http://mng.bz/z546)），可以在一次执行多个环境。要自动并行运行你的两个环境，在运行
    tox 时传递 `-p` 选项，如下一个代码片段所示。此模式默认将隐藏每个单独环境的输出，只显示活动环境的进度指示器和每个环境的整体通过或失败状态：
- en: '[PRE29]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Uncovering stateful tests
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 揭露状态测试
- en: 'Consider the following snippet with two tests that make assertions about how
    Python lists work:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下包含两个测试的片段，这两个测试对 Python 列的工作方式提出断言：
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Can you spot the issue? It might be subtle, but the second test alters the
    state of the system. Although `FRUITS` starts out containing one item, `"apple"`,
    the test alters the list by adding `"banana"`. These tests will pass as written,
    but they’ll fail if you put them in reverse order (see figure 5.5):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现这个问题吗？它可能很微妙，但第二个测试改变了系统的状态。尽管 `FRUITS` 开始时只包含一个项目，即 `"apple"`，但测试通过添加 `"banana"`
    改变了列表。这些测试按原样编写时将通过，但如果将它们按相反顺序排列（见图 5.5），它们将失败：
- en: '[PRE31]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![](../../OEBPS/Images/05-05.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/05-05.png)'
- en: Figure 5.5 Tests that depend on state created by other tests may fail when reordered
    or moved.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 依赖于其他测试创建的状态的测试在重新排序或移动时可能会失败。
- en: Although it might be easy enough to spot and fix this example, stateful tests
    are often the result of several layers and interactions that you might not notice
    while writing the code. To increase the likelihood that you’ll find and uncover
    these situations, you should run your tests in a random order. The `pytest-randomly`
    plugin ([https://github.com/pytest-dev/pytest-randomly](https://github.com/pytest-dev/pytest-randomly))
    does exactly this. It requires no configuration for the basic behavior of randomly
    ordered tests; add it to your `[testenv]` section’s `deps` list, and you’ll be
    all set.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能很容易发现并修复这个例子，但状态测试通常是多个层次和交互的结果，你在编写代码时可能不会注意到。为了增加你发现并揭露这些情况的可能性，你应该以随机顺序运行你的测试。`pytest-randomly`
    插件（[https://github.com/pytest-dev/pytest-randomly](https://github.com/pytest-dev/pytest-randomly)）正是这样做的。它不需要对随机顺序测试的基本行为进行配置；将其添加到
    `[testenv]` 部分的 `deps` 列表，你就可以设置好了。
- en: 'By swapping the order of test modules, classes, methods, and functions, `pytest-randomly`
    uncovers tests that fail because of a dependency on state created in an earlier
    test (see figure 5.6). It does this by changing the random seed to a repeatable
    value for each run. This information is added to the pytest output shown here:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过交换测试模块、类、方法和函数的顺序，`pytest-randomly` 揭示了由于依赖于早期测试中创建的状态而失败的测试（见图 5.6）。它是通过在每个运行中将随机种子更改为可重复的值来做到这一点的。此信息添加到了此处显示的
    pytest 输出中：
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](../../OEBPS/Images/05-06.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/05-06.png)'
- en: Figure 5.6 `pytest-randomly` runs your tests in a shuffled order on each run.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 `pytest-randomly` 在每次运行中都以打乱顺序运行你的测试。
- en: 'When a test run produces a test failure, you can force future runs to execute
    in the same order that produced the failure by passing the `--randomly-seed` option
    to the `pytest` command with the same value output in the original run. Because
    pytest is being run by tox, you can pass the option to the underlying `pytest`
    command using a `--` to separate tox options from pytest options like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试运行产生测试失败时，你可以通过将 `--randomly-seed` 选项传递给 `pytest` 命令，并使用原始运行中输出的相同值来强制未来的运行以产生失败时的相同顺序执行。因为
    pytest 是由 tox 运行的，所以你可以使用 `--` 来将 tox 选项与 pytest 选项分开，并将选项传递给底层的 `pytest` 命令，如下所示：
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ tox passes the argument to pytest.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ tox 将参数传递给 pytest。
- en: With `pytest-randomly` installed, your tests will run in a different order each
    time you run tox. If you notice that a test occasionally fails for no obvious
    reason, the test or the code under test may be stateful. You can use these hints
    as a good starting place to hunt down stateful issues.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 `pytest-randomly` 后，每次运行 tox 时，你的测试将以不同的顺序运行。如果你注意到一个测试偶尔会没有明显原因地失败，那么测试或被测试的代码可能是状态化的。你可以使用这些提示作为寻找状态化问题的良好起点。
- en: Ensuring pytest markers are valid
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 确保pytest标记有效
- en: Earlier in this chapter, you used the `@ pytest.mark.parametrize` marker to
    parameterize a data-driven test. Although pytest provides built-in markers like
    `parametrize`, you can also devise your own arbitrary markers; in a way, you can
    think of them as labels or tags for your tests. This is a powerful feature, but
    because you can create arbitrary markers, there’s a chance you’ll misremember
    or misspell the name of a marker, which could cause silent issues down the road.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，你使用了 `@pytest.mark.parametrize` 标记来参数化一个数据驱动的测试。尽管 pytest 提供了内置的标记，如
    `parametrize`，但你也可以设计自己的任意标记；从某种意义上说，你可以把它们看作是你测试的标签或标记。这是一个强大的功能，但由于你可以创建任意的标记，所以有可能记错或拼错标记的名称，这可能会在将来引起无声的问题。
- en: 'By default, pytest will gently warn you about an invalid marker, as you can
    see in the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，pytest 会温和地警告你无效的标记，如下所示：
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you want to ensure that all your markers are known and valid—that is, they’re
    registered by a plugin or in your `[tool:pytest]` section in the `markers` key—add
    the `--strict-markers` option to the `addopts` key in the setup.cfg file. With
    strict markers enabled, pytest will fail a test run if it finds an unknown marker,
    as you can see in the following output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想确保所有标记都是已知且有效的——也就是说，它们由插件或配置文件 `setup.cfg` 中的 `[tool:pytest]` 部分的 `markers`
    键注册——请在 `setup.cfg` 文件中将 `--strict-markers` 选项添加到 `addopts` 键中。启用严格标记后，pytest
    如果发现未知标记，将失败测试运行，如下面的输出所示：
- en: '[PRE35]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will ensure that your tests run only if you have a valid set of markers
    defined. An invalid marker isn’t harmful by itself, but it minimizes the chance
    of unexpected behavior.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保只有在你定义了有效的标记集时，你的测试才会运行。无效的标记本身并不可怕，但它最小化了意外行为的机会。
- en: Ensuring expected failures don’t pass unexpectedly
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 确保预期的失败不会意外通过
- en: pytest provides a marker called `xfail` that marks a test as an expected failure.
    A test might be expected to fail for a variety of reasons—environmental issues,
    an upstream issue you’re waiting on, or simply a lack of time to adress it. Occasionally,
    an expected failure can start passing again after you make a change. It might
    sound good to have more passing tests, but an unexpected change in behavior should
    always engender some scrutiny.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: pytest 提供了一个名为 `xfail` 的标记，用于标记一个测试为预期失败。一个测试可能因为各种原因而预期失败——环境问题、你正在等待的上游问题，或者简单地没有时间处理它。偶尔，一个预期失败在做出更改后可能会再次开始通过。虽然更多的通过测试听起来不错，但行为的不预期变化应该总是引起一些审查。
- en: By default, pytest will warn you about this situation by marking a test as `XPASS`.
    If you want to be loudly alerted to this situation so that you can examine why
    an expected failure started passing, add the `xfail_strict` key to the `[tool:pytest]`
    section with a value of `True`. This will cause any passing tests that were expected
    to fail to fail the test run so that you have to address them before continuing.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，pytest 会通过将测试标记为 `XPASS` 来警告你这种情况。如果你想对此情况大声警告，以便检查为什么预期的失败开始通过，请在 `[tool:pytest]`
    部分添加 `xfail_strict` 键，并将其值设置为 `True`。这将导致任何预期失败的通过测试在测试运行中失败，这样你必须在继续之前处理它们。
- en: With your lean, mean, testing machine well-oiled and ready for any changes you
    throw at it, you’re ready to start adding and automating more code quality processes
    in the next chapter.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的精简、高效的测试机器已经准备好应对你抛出的任何变化时，你就可以开始添加和自动化更多代码质量流程了。
- en: Answers to exercises
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习答案
- en: '**5.3**—Answer: E'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.3**—答案：E'
- en: '**5.4**—Answer: Add two new tests that adjust `inputs` to `[]` and, for example,
    `["foo", "bar"]` respectively, and adjust `expected_value` to `0.0` for both.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.4**—答案：添加两个新的测试，分别调整`inputs`为`[]`和例如`["foo", "bar"]`，并将`expected_value`都调整为`0.0`。'
- en: '**5.5**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.5**'
- en: '[PRE36]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**5.6**—Answer: A, C, D, E'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.6**—答案：A, C, D, E'
- en: B would pass the `--no-cov` option to tox itself instead of pytest. F would
    put any passed arguments before the command.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: B会将`--no-cov`选项传递给tox自身而不是pytest。F会将任何传递的参数放在命令之前。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The pytest framework has a rich plugin ecosystem that you can use to test more
    productively than using the built-in `unittest` module.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pytest框架有一个丰富的插件生态系统，你可以使用它比使用内置的`unittest`模块更高效地进行测试。
- en: Use test coverage to guide the tests you write by identifying areas of code
    that aren’t executed by your existing tests.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试覆盖率通过识别现有测试未执行的代码区域来指导你编写的测试。
- en: Test the uncommon paths through your code because coverage is useful, but not
    sufficient to understand how well your tests ensure the proper behavior.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你代码中不常见的路径，因为覆盖率是有用的，但不足以理解你的测试如何确保代码的正确行为。
- en: Testing many combinations of dependencies is tedious and error-prone, but tox
    reduces this effort and increases safety by automating most of the steps involved.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试许多依赖关系的组合既繁琐又容易出错，但tox通过自动化大多数涉及步骤来减少这种努力并提高安全性。
- en: To maximize safety, use plugins and tool options to your advantage to restrict
    your project to only valid configurations.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了最大化安全性，利用插件和工具选项的优势，将你的项目限制在只有有效的配置。
