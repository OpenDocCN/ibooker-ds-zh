- en: Appendix E. Regular expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录E. 正则表达式
- en: A *regular* *expression* (often abbreviated *RegEx*) is a search pattern for
    text. It defines a logical sequence of characters that the computer should look
    for in a string.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*正则* *表达式*（通常缩写为*RegEx*）是文本的搜索模式。它定义了计算机应在字符串中查找的逻辑字符序列。
- en: Here’s a simple example. You’ve likely used the Find feature in your web browser
    at some point. In most web browsers, you can access this feature by pressing Ctrl-F
    in Windows or Command-F in macOS. The browser reveals a dialog box in which we
    type a sequence of characters. Then the browser searches for those characters
    on the web page. Figure E.1 shows an example of the browser searching for and
    finding `romance` in the page’s content.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子。你可能在某个时候使用过网页浏览器中的查找功能。在大多数网页浏览器中，你可以通过按Windows上的Ctrl-F或macOS上的Command-F来访问这个功能。浏览器会弹出一个对话框，我们在其中输入一串字符。然后浏览器会在网页上搜索这些字符。图E.1展示了浏览器在页面内容中搜索并找到`romance`的例子。
- en: '![](../Images/APPE_F01_Paskhaver.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPE_F01_Paskhaver.png)'
- en: Figure E.1 Searching for the text `romance` by using the Find feature in Google
    Chrome
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图E.1 使用Google Chrome的查找功能搜索文本`romance`
- en: Chrome’s Find feature is a simple example of RegEx in action. The tool does
    have its limitations. We can search for characters only in the exact order in
    which they appear, for example. We can search for the character sequence `"cat"`,
    but we cannot declare a condition such as either the letter `"c"` or `"a"` or
    `"t"`. Regular expressions make this kind of dynamic search possible.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome的查找功能是正则表达式在行动中的简单例子。这个工具确实有其局限性。例如，我们只能按字符出现的顺序搜索字符。我们可以搜索字符序列`"cat"`，但不能声明一个条件，比如字母`"c"`或`"a"`或`"t"`。正则表达式使得这种动态搜索成为可能。
- en: 'A regular expression describes how to look for content in a piece of text.
    We can search for characters such as letters, digits, or spaces, but we can also
    use special symbols to declare conditions. Here are a few examples of what we
    can search for:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式描述了如何在一段文本中查找内容。我们可以搜索字母、数字或空格等字符，但也可以使用特殊符号来声明条件。以下是一些我们可以搜索的内容示例：
- en: Any two digits in a row
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续的两个数字
- en: A sequence of three or more alphabetic characters followed by a space
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由三个或更多字母组成的序列，后面跟一个空格
- en: The character `s`, but only at the beginning of a word
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符`s`，但仅限于单词的开头
- en: In this appendix, we’ll explore how regular expressions work in Python and then
    apply our knowledge to a data set in pandas. Entire textbooks and college courses
    are dedicated to RegEx, so our hope here is to scratch the surface of this complex
    field of study. RegEx is easy to get started with and difficult to master.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们将探讨正则表达式在Python中的工作原理，然后应用我们的知识来处理pandas中的数据集。关于正则表达式，有整本教科书和大学课程，所以我们在这里的目的是触及这个复杂研究领域的一角。正则表达式易于入门，但难以精通。
- en: E.1 Introduction to Python’s re module
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: E.1 Python的re模块简介
- en: 'Let’s begin by creating a new Jupyter Notebook. We’ll import pandas and a special
    module called `re`. The `re` (regular expressions) module is part of Python’s
    standard library and is built into the language:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的Jupyter Notebook开始。我们将导入pandas和一个名为`re`的特殊模块。`re`（正则表达式）模块是Python标准库的一部分，并内置于语言中：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `re` module has a `search` function that looks for a substring in a string.
    The function accepts two arguments: a search sequence and a string in which to
    look for it. The next example looks for the string `"flower"` within the string
    `"field of flowers"`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`re`模块有一个`search`函数，用于在字符串中查找子字符串。该函数接受两个参数：一个搜索序列和一个要查找的字符串。下一个例子是在字符串`"field
    of flowers"`中查找字符串`"flower"`：'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `search` function returns a `Match` object if Python finds the character
    sequence in the target string. The `Match` object stores information on what content
    matched the search pattern and where it exists in the target string. The preceding
    output communicates that `"flower"` was found in a span of characters from index
    positions 9 to 15\. The first index is inclusive, and the second index is exclusive.
    If we count character index positions in `"field of flowers"`, we see that index
    9 is the lowercase `"f"` in `"flowers"`, and index 15 is the `"s"` in `"flowers"`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`函数如果Python在目标字符串中找到字符序列，则返回一个`Match`对象。`Match`对象存储有关与搜索模式匹配的内容以及它在目标字符串中的位置的信息。前面的输出表明`"flower"`在从索引位置9到15的字符范围内被找到。第一个索引是包含的，第二个索引是排除的。如果我们计算`"field
    of flowers"`中的字符索引位置，我们会看到索引9是`"flowers"`中的小写`"f"`，而索引15是`"flowers"`中的`"s"`。'
- en: 'The `search` function returns `None` if the search pattern does not exist in
    the target string. By default, Jupyter Notebook will not output anything for a
    `None` value. But we can wrap the `search` invocation in a `print` function to
    force Jupyter to print the value:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果搜索模式在目标字符串中不存在，`search` 函数返回 `None`。默认情况下，Jupyter Notebook 不会为 `None` 值输出任何内容。但我们可以将
    `search` 调用包裹在 `print` 函数中，强制 Jupyter 打印值：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `search` function returns only the first match in the target string. We
    can use the `findall` function to find all matches. This function accepts the
    same two arguments—a search sequence and a target string—and returns a list of
    strings that match the search sequence. In the next example, Python finds the
    search pattern `"flower"` twice within `"Picking flowers in the flower field":`
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`search` 函数只返回目标字符串中的第一个匹配项。我们可以使用 `findall` 函数来找到所有匹配项。此函数接受相同的两个参数——一个搜索序列和一个目标字符串——并返回一个字符串列表，其中包含与搜索序列匹配的字符串。在下一个示例中，Python
    在 `"Picking flowers in the flower field"` 中找到了 `"flower"` 这个搜索模式两次：'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the search is case-sensitive.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，搜索是区分大小写的。
- en: E.2 Metacharacters
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: E.2 元字符
- en: 'Now let’s declare a more complex search pattern using regular expressions.
    We’ll start by assigning a long string to a `sentence` variable. The next code
    sample breaks the string across multiple lines for readability, but you are welcome
    to type it in a single line in Jupyter Notebook:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用正则表达式声明一个更复杂的搜索模式。我们将首先将一个长字符串赋值给 `sentence` 变量。下一个代码示例将字符串拆分为多行以提高可读性，但您也可以在
    Jupyter Notebook 中将其输入为单行：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside a regular expression, we can declare *metacharacters—*special symbols
    that define search patterns. The `\d` metacharacter, for example, instructs Python
    to match any digit. Let’s say we want to identify all digits in our `sentence`
    string. The next example invokes the `findall` function with the regular expression
    `"\d"` as the search pattern:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中，我们可以声明 *元字符——*定义搜索模式的特殊符号。例如，`\d` 元字符指示 Python 匹配任何数字。假设我们想要识别 `sentence`
    字符串中的所有数字。下一个示例使用正则表达式 `"\d"` 作为搜索模式调用 `findall` 函数：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The function’s return value is a list of the four digits in `sentence` in the
    order in which they appear:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值是按出现顺序排列的 `sentence` 中的四个数字列表：
- en: the `"5"` in `"5 apples"`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"5"` 在 `"5 apples"` 中'
- en: the `"4"` in `"4 oranges"`
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"4"` 在 `"4 oranges"` 中'
- en: the `"1"` in `"15 plums"`
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"1"` 在 `"15 plums"` 中'
- en: the `"5"` in `"15 plums"`
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"5"` 在 `"15 plums"` 中'
- en: We’ve learned our first metacharacter! With a simple `\d` symbol, we’ve created
    a search pattern that matches any digit in a target string.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了我们的第一个元字符！通过简单的 `\d` 符号，我们创建了一个匹配目标字符串中任何数字的搜索模式。
- en: 'Two points are worth mentioning before we move forward:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有两点值得注意：
- en: When a list contains many elements, Jupyter Notebook likes to print each element
    on a separate line. This stylistic approach makes the output easier to read but
    also causes it to take up significant space. To force Jupyter to print the list
    normally—add line breaks only after a certain threshold of characters has been
    output—we’ll wrap our `findall` function calls inside Python’s built-in `print`
    function from this point on.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个列表包含许多元素时，Jupyter Notebook 喜欢将每个元素打印在单独的一行上。这种风格方法使得输出更容易阅读，但也导致输出占用大量空间。为了强制
    Jupyter 正常打印列表——只在输出了一定数量的字符后添加换行符——从现在起，我们将把 `findall` 函数调用包裹在 Python 内置的 `print`
    函数中。
- en: We’ll pass our RegEx arguments to the `findall` function as raw strings. Python
    interprets each character in a raw string literally. This parsing option prevents
    conflicts between regular expressions and escape sequences. Consider the character
    sequence `\b`. It has a symbolic meaning in a plain Python string and a different
    meaning in a regular expression. When we use a raw string, we instruct Python
    to treat `\b` as a literal backslash character followed by a literal `b` character.
    This syntax guarantees that Python will parse the regular expression’s metacharacters
    correctly.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将把 RegEx 参数作为原始字符串传递给 `findall` 函数。Python 将原始字符串中的每个字符按字面意思解释。此解析选项防止正则表达式与转义序列之间的冲突。考虑字符序列
    `\b`。它在普通 Python 字符串中有符号意义，在正则表达式中有不同的意义。当我们使用原始字符串时，我们指示 Python 将 `\b` 解释为字面意义上的反斜杠字符后跟字面意义上的
    `b` 字符。这种语法保证了 Python 将正确解析正则表达式的元字符。
- en: 'We declare a raw string with an `"r"` character before the double quotes. Let’s
    rewrite the preceding example with a `print` function call and a raw string:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用双引号前的 `"r"` 字符来声明一个原始字符串。让我们用 `print` 函数调用和原始字符串重写前面的示例：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To declare the inverse of an operation, we swap the letter casing of the metacharacter.
    If `\d` means “match any digit,” for example, `\D` means "match any nondigit."
    Nondigit characters consist of letters, spaces, commas, and symbols. In the next
    example, we use `\D` to identify all nondigit characters in `sentence`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明操作的逆操作，我们交换元字符的大小写。例如，如果 `\d` 表示“匹配任何数字”，那么 `\D` 表示“匹配任何非数字”。非数字字符包括字母、空格、逗号和符号。在下一个示例中，我们使用
    `\D` 来识别 `sentence` 中的所有非数字字符：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that you understand the basics of regular expressions, the next step is
    learning more metacharacters and building complex search queries. Here’s another
    example. The `\w` metacharacter matches any word character, a category that includes
    letters, digits, and underscores:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了正则表达式的基础知识，下一步是学习更多元字符并构建复杂的搜索查询。以下是一个示例。`\w` 元字符匹配任何单词字符，这个类别包括字母、数字和下划线：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The inverse `\W` metacharacter matches any nonword character. Nonword characters
    include spaces, commas, and periods:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 逆 `\W` 元字符匹配任何非单词字符。非单词字符包括空格、逗号和句号：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `\s` metacharacter searches for any whitespace character:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`\s` 元字符搜索任何空白字符：'
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The inverse `\S` metacharacter searches for any nonwhitespace character:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 逆 `\S` 元字符搜索任何非空白字符：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To search for a specific character, declare it literally in the search pattern.
    The next example searches for all occurrences of the letter `"t"`. This syntax
    is the same one we used in this appendix’s first examples:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索特定字符，请在搜索模式中直接声明该字符。以下示例搜索所有出现的字母 `"t"`。此语法与我们在此附录的第一个示例中使用的是相同的：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To search for a sequence of characters, write them in order in the search pattern.
    The next example searches for the letters `"to"` in the `sentence` string. Python
    finds it twice (the `"to"` word and the `"to"` in `"store")`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索字符序列，请按顺序在搜索模式中写出这些字符。以下示例在 `sentence` 字符串中搜索字母 `"to"`。Python 找到了两次（单词 `"to"`
    和 `"store"` 中的 `"to"`）：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `\b` metacharacter declares a word boundary. A *word boundary* mandates
    where a character must exist relative to a space. The next example searches for
    `"\bt"`. The logic translates to “any `t` character after a word boundary” or,
    equivalently, “any `t` character after a space.” The pattern matches the `"t"`
    characters in `"to"` and `"the"`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`\b` 元字符声明单词边界。*单词边界*强制字符相对于空格的位置。以下示例搜索 `"\bt"`。逻辑可以翻译为“任何在单词边界之后的 `t` 字符”或等价地，“任何在空格之后的
    `t` 字符”。该模式匹配 `"to"` 和 `"the"` 中的 `"t"` 字符：'
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s flip the symbols around. If we use `"t\b"`, we search for “any `t` character
    before a word boundary” or, equivalently, “any `t` character before a space.”
    The `"t"` characters that Python matches are different. These are the `"t"` characters
    at the end of `"went"` and `"bought":`
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们翻转符号。如果我们使用 `"t\b"`，我们搜索“任何在单词边界之前的 `t` 字符”或等价地，“任何在空格之前的 `t` 字符”。Python
    匹配的 `"t"` 字符不同。这些是 `"went"` 和 `"bought"` 结尾的 `"t"` 字符：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The inverse `\B` metacharacter declares a nonword boundary. `"\Bt"`, for example,
    means “any `t` character that does not come after a word boundary” or, equivalently,
    “any `t` character that does not come after a space”:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 逆 `\B` 元字符声明非单词边界。例如，`"\Bt"` 表示“任何不在单词边界之后的 `t` 字符”或等价地，“任何不在空格之后的 `t` 字符”：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding example matched the `"t"` characters in `"went"`, `"store"`, and
    `"bought"`. Python ignored the `"t"` characters in `"to"` and `"the"` because
    they appear after a word boundary.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例匹配了 `"went"`、`"store"` 和 `"bought"` 中的 `"t"` 字符。Python 忽略了 `"to"` 和 `"the"`
    中的 `"t"` 字符，因为它们出现在单词边界之后。
- en: E.3 Advanced search patterns
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: E.3 高级搜索模式
- en: In review, a *metacharacter* is a symbol that designates a search sequence in
    a regular expression. Section E.2 explored the `\d`, `\w`, `\s`, and `\b` metacharacters
    for digits, word characters, spaces, and word boundaries. Let’s learn some new
    metacharacters and then combine them into a complex search query.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，*元字符*是在正则表达式中指定搜索序列的符号。第 E.2 节探讨了 `\d`、`\w`、`\s` 和 `\b` 元字符，用于数字、单词字符、空格和单词边界。让我们学习一些新的元字符，然后将它们组合成复杂的搜索查询。
- en: 'The dot (`.`) metacharacter matches any character whatsoever:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 点 (`.`) 元字符匹配任何字符：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At first glance, this metacharacter may not seem to be particularly helpful,
    but it works wonders when paired with other symbols. The regular expression `"c."`,
    for example, searches for the character `"c"` followed by any character. There
    are three such matches in our string:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这个元字符可能看起来并不特别有用，但与其他符号搭配使用时却效果神奇。例如，正则表达式 `"c."` 搜索的是紧跟在 `"c"` 字符后面的任何字符。在我们的字符串中存在三个这样的匹配项：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What if we want to search for a literal dot in a string? In that case, we have
    to escape it with a backslash in the regular expression. The `"\."` in the next
    example locates the period at the end of the `soda` string:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在字符串中搜索一个字面上的点，该怎么办？在这种情况下，我们必须在正则表达式中用反斜杠转义它。下一个示例中的 `"\."` 定位到 `soda`
    字符串的末尾：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Earlier, we saw that we could combine characters to search for them in sequence
    in the target string. Here, we search for the exact sequence of `"co"`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了如何将字符组合起来，以便在目标字符串中按顺序搜索它们。这里，我们搜索 `"co"` 的确切序列：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What if we want to search for either the character `"c"` or the character `"o"`?
    To do so, we can wrap the characters in a pair of square brackets. The matches
    will include any occurrence of either `"c"` or `"o"` in the target string:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想搜索字符 `"c"` 或字符 `"o"` 中的任何一个，怎么办？为了做到这一点，我们可以将字符包裹在一对方括号中。匹配项将包括目标字符串中 `"c"`
    或 `"o"` 的任何出现：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The order of characters in the square brackets does not affect the result:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号中字符的顺序不会影响结果：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Suppose that we want to target any characters between `"c"` and `"l"`. One
    option would be to write out the complete sequence of alphabetic characters within
    the square brackets:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想目标化 `"c"` 和 `"l"` 之间的任何字符。一个选项是写出方括号内完整的字母字符序列：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A better solution is to use the dash symbol (`-`) to declare a range of characters.
    The following code sample yields the same list as the preceding code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是使用破折号符号（`-`）来声明字符的范围。下面的代码示例产生与前面代码相同的列表：
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, let’s explore how we can target multiple occurrences of characters in
    a row. Consider the string `"bookkeeper"`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索如何目标化字符的连续多个出现。考虑字符串 `"bookkeeper"`：
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To search for exactly two `"e"` characters in a row, we can pair them in the
    search sequence:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索连续的两个 `"e"` 字符，我们可以在搜索序列中将它们配对：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can also search for multiple occurrences of a character with a pair of curly
    braces. Inside the braces, we declare the number of occurrences to match. In the
    next example, we search for two `"e"` characters in a row within `"bookkeeper":`
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用一对大括号来搜索字符的多个出现。在大括号内，我们声明要匹配的出现次数。在下一个示例中，我们在 `"bookkeeper"` 中搜索连续的两个
    `"e"` 字符：
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we search for three `"e"` characters in a row with `"e{3}"`, the return value
    will be an empty list because there are no sequences of three consecutive `"e"`
    characters in `"bookkeeper":`
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `"e{3}"` 搜索连续的三个 `"e"` 字符，返回值将是一个空列表，因为在 `"bookkeeper"` 中没有三个连续的 `"e"`
    字符序列：
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can also enter two numbers inside the curly braces, separated by a comma.
    The first value sets the lower bound of occurrences, and the second value sets
    the upper bound of occurrences. The next example searches for between one and
    three occurrences of the `"e"` character in a row. The first match is the sequential
    `"ee"` characters in `"keeper"`, and the second match is the final `"e"` in `"keeper"`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在大括号内输入两个数字，用逗号分隔。第一个值设置出现次数的下限，第二个值设置出现次数的上限。下一个示例搜索连续出现一次到三次的 `"e"` 字符。第一个匹配项是
    `"keeper"` 中的连续 `"ee"` 字符，第二个匹配项是 `"keeper"` 中的最后一个 `"e"`：
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let’s walk through this example in more detail. The pattern searches for one
    to three `"e"` characters in a row. When Python finds a match, it keeps traversing
    the string until the search pattern is violated. The regular expression first
    looks at the letters `"bookk"` individually. None of these letters fits the search
    pattern, so Python moves on. Then the pattern locates its first `"e"`. Python
    cannot mark this match as final yet because the next character may also be an
    `"e"`, so, it checks the next character. That character is indeed another `"e"`,
    which fits the original search criteria. Python proceeds to the `"p"`, which does
    not match the pattern, and declares the match to be `"ee"` rather than two individual
    `"e"` characters. The same logic repeats for the `"e"` closer to the end of the
    string.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地走一遍这个例子。该模式搜索一行中的一到三个 `"e"` 字符。当 Python 找到匹配项时，它会继续遍历字符串，直到搜索模式被违反。正则表达式首先单独查看字母
    `"bookk"`。这些字母中没有哪一个符合搜索模式，所以 Python 继续前进。然后模式定位到它的第一个 `"e"`。Python 还不能将这个匹配项标记为最终匹配，因为下一个字符也可能是一个
    `"e"`，所以它检查下一个字符。那个字符确实又是另一个 `"e"`，这符合原始搜索标准。Python 继续到 `"p"`，它不匹配模式，并宣布匹配项是 `"ee"`
    而不是两个单独的 `"e"` 字符。相同的逻辑重复应用于字符串末尾更接近的 `"e"`。
- en: We’re making good progress, but all the previous examples have been mostly theoretical.
    How can we use RegEx when working with real-world data sets?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在取得良好的进展，但所有之前的例子都主要是理论性的。我们在处理现实世界的数据集时如何使用正则表达式？
- en: 'Imagine that we are running a customer-support hotline and storing transcriptions
    of phone calls. We may have a message like this one:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们正在运行一个客户支持热线并存储电话通话的转录。我们可能有一个这样的消息：
- en: '[PRE30]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's say we'd like to pull out a phone number from each person’s message, but
    each transcription is unique. We can assume, however, that a phone number has
    a consistent pattern consisting of
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想从每个人的消息中提取电话号码，但每个转录都是独特的。然而，我们可以假设电话号码有一个一致的格式，由
- en: Three digits
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个数字
- en: A dash
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个破折号
- en: Three digits
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个数字
- en: A dash
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个破折号
- en: Four digits
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 四个数字
- en: 'The beauty of RegEx is that it can identify this search pattern irrespective
    of the string’s contents. The next example declares our most complex regular expression
    yet. We simply combine metacharacters and symbols to describe the logic above:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的美在于它可以不受字符串内容的影响地识别这种搜索模式。下一个示例声明了我们迄今为止最复杂的正则表达式。我们只是将元字符和符号组合起来，以描述上述逻辑：
- en: '`\d{3}` searches for exactly three digits.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\d{3}` 搜索恰好三个数字。'
- en: '- searches for a dash.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '- 搜索一个破折号。'
- en: '`\d{3}` searches for exactly three digits.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\d{3}` 搜索恰好三个数字。'
- en: '- searches for a dash.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '- 搜索一个破折号。'
- en: '`\d{4}` searches for exactly four digits.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\d{4}` 搜索恰好四个数字。'
- en: '[PRE31]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Voila!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！
- en: 'There’s also a convenient `+` metacharacter that indicates “one or more” of
    the preceding characters or metacharacters. `\d+`, for example, searches for one
    or more digits in a row. We can use the `+` symbol to simplify the preceding code.
    The next regular expression holds a different search pattern but returns the same
    result:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个方便的 `+` 元字符，表示“一个或多个”前面的字符或元字符。例如，`\d+` 搜索一行中的一或多个数字。我们可以使用 `+` 符号简化前面的代码。下一个正则表达式持有不同的搜索模式，但返回相同的结果：
- en: One or more sequential digits
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个或多个连续的数字
- en: A dash
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个破折号
- en: One or more sequential digits
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个或多个连续的数字
- en: A dash
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个破折号
- en: One or more sequential digits
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个或多个连续的数字
- en: '[PRE32]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With one line of code, we can extract a telephone number from a dynamic piece
    of text—pretty powerful stuff.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一行代码从一个动态文本片段中提取电话号码——相当强大的功能。
- en: E.4 Regular expressions and pandas
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: E.4 正则表达式和 pandas
- en: In chapter 6, we introduced the `StringMethods` object for manipulating `Series`
    of strings. The object is available via the `str` attribute, and many of its methods
    support RegEx arguments, which significantly expand their power. Let’s practice
    these RegEx concepts on a real data set.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 章中，我们介绍了用于操作字符串 `Series` 的 `StringMethods` 对象。该对象通过 `str` 属性提供，并且它的许多方法支持正则表达式参数，这极大地扩展了它们的功能。让我们在实际数据集上练习这些正则表达式概念。
- en: 'The ice_cream.csv data set is a collection of ice cream flavors for four popular
    brands (Ben & Jerry’s, Haagen-Dazs, Breyers, and Talenti). Each row includes a
    brand, a flavor, and a description:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ice_cream.csv 数据集是四个流行品牌（Ben & Jerry’s、Haagen-Dazs、Breyers 和 Talenti）的冰淇淋口味的集合。每一行包括一个品牌、一个口味和描述：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: NOTE ice_cream is a modified version of a data set available from Kaggle ([https://www.kaggle.com/tysonpo/ice-cream-dataset](https://www.kaggle.com/tysonpo/ice-cream-dataset)).
    There are typos and inconsistencies within the data; we have preserved them so
    that you can see the data irregularities that appear in the real world. I encourage
    you to consider how you can optimize this data with the techniques you’ll learn
    in this chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：ice_cream 是从 Kaggle 可用的数据集的一个修改版本（[https://www.kaggle.com/tysonpo/ice-cream-dataset](https://www.kaggle.com/tysonpo/ice-cream-dataset)）。数据中存在拼写错误和不一致性；我们保留了它们，以便你可以看到在现实世界中出现的真实数据不规则性。我鼓励你考虑如何使用本章中学习的技巧来优化这些数据。
- en: I’m curious how many different chocolate treats we can find in the flavors.
    Our challenge is to find all words that immediately follow the string `"Chocolate"`
    within the Description column. We can use the `str.extract` method on a `Series`
    to accomplish this task. The method accepts a RegEx pattern and returns a `DataFrame`
    with its matches.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我很好奇我们能在口味中找到多少种不同的巧克力美食。我们的挑战是在描述列中找到紧跟在字符串 `"Chocolate"` 后面的所有单词。我们可以使用 `Series`
    上的 `str.extract` 方法来完成这个任务。该方法接受一个正则表达式模式，并返回一个包含匹配项的 `DataFrame`。
- en: Let’s construct our regular expression. We’ll begin with a word boundary (`\b`).
    Then we’ll target the literal text `"Chocolate"`. Next, we’ll mandate a single
    whitespace character (`\s`). Finally, we’ll match one or more word characters
    in a row (`\w+`) to capture all alphanumeric letters until Python encounters a
    space or period. Thus, the final expression is `"\bChocolate\s\w+)"`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的正则表达式。我们将从一个单词边界 (`\b`) 开始。然后我们将目标定位在文本 `"Chocolate"` 上。接下来，我们将强制一个单独的空白字符
    (`\s`)。最后，我们将匹配一行中的一或多个单词字符 (`\w+`)，以捕获所有直到 Python 遇到空格或句点为止的字母数字字母。因此，最终的表达式是
    `"\bChocolate\s\w+)"`。
- en: 'For technical reasons, we have to wrap the regular expression in parentheses
    when passing it to the `str.extract` method. The method supports an advanced syntax
    that searches for multiple regular expressions, and the parentheses limit it to
    one:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于技术原因，我们必须在将正则表达式传递给 `str.extract` 方法时将其括起来。该方法支持高级语法，可以搜索多个正则表达式，而括号将其限制为一个：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So far, so good. Our `Series` includes matches such as `"Chocolate` `Ice"`
    at index position 2 and `"Chocolate` `Cookie"` at index position 4; it also stores
    `NaN` values wherever it could not find the search pattern in the row. Let’s invoke
    the `dropna` method to remove rows with missing values:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。我们的 `Series` 包含了像索引位置 2 的 `"Chocolate` `Ice"` 和索引位置 4 的 `"Chocolate`
    `Cookie"` 这样的匹配项；它还在找不到搜索模式的地方存储了 `NaN` 值。让我们调用 `dropna` 方法来删除有缺失值的行：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We’re getting closer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们越来越接近了。
- en: 'Next, let’s convert the `DataFrame` to a `Series`. The `str.extract` method
    returns a `DataFrame` by default to support the potential of multiple search patterns.
    We can use the `squeeze` method to coerce the single-column `DataFrame` into a
    `Series`. You may recall the related `squeeze` parameter from the `read_csv` import
    function; the `squeeze` method accomplishes the same result:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将 `DataFrame` 转换为 `Series`。默认情况下，`str.extract` 方法返回一个 `DataFrame` 以支持潜在的多个搜索模式。我们可以使用
    `squeeze` 方法将单列 `DataFrame` 转换为 `Series`。你可能还记得从 `read_csv` 导入函数中的相关 `squeeze`
    参数；`squeeze` 方法可以达到相同的效果：
- en: '[PRE36]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Our method chaining is getting quite lengthy, so let’s assign the current `Series`
    to a `chocolate_flavors` variable:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法链变得越来越长，所以让我们将当前的 `Series` 赋值给一个 `chocolate_flavors` 变量：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We ultimately want to identify what ingredients come after `"Chocolate"`. Let’s
    invoke the `str.split` method to split each string by the occurrence of whitespace.
    Instead of passing a string with a single space, we’ll provide an argument of
    a regular expression here as well. As a reminder, the `"\s"` metacharacter looks
    for a single whitespace:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终想要识别在 `"Chocolate"` 之后是什么成分。让我们调用 `str.split` 方法通过空格的出现来分割每个字符串。在这里，我们不会传递一个包含单个空格的字符串，而是提供一个正则表达式的参数。提醒一下，`"\s"`
    元字符查找单个空白：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `str.get` method retrieves a value at a consistent index position from
    each list in a `Series`. In the next example, we retrieve the second element (index
    position 1) from each list or, equivalently, the word that follows `"Chocolate"`
    in the original string:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.get` 方法从 `Series` 中的每个列表中检索一个在一致索引位置的值。在下一个示例中，我们从每个列表中检索第二个元素（索引位置 1），或者等价地，检索原始字符串中
    `"Chocolate"` 后面的单词：'
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For curiosity’s sake, let’s invoke the `value_counts` method to see the most
    frequent words that follow `"Chocolate"` across all ice cream flavors. Unsurprisingly,
    `"Ice"` is the winner. `"Cookie"` comes in at a distant second:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 出于好奇，让我们调用 `value_counts` 方法来看看在所有冰淇淋口味中紧跟 `"Chocolate"` 的最频繁出现的单词。不出所料， `"Ice"`
    是赢家，而 `"Cookie"` 则位居第二：
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Regular expressions offer a sophisticated way of searching for patterns in text.
    I hope that you’ve gained greater understanding of the benefits of RegEx and how
    to apply it to various methods in pandas.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式提供了一种在文本中搜索模式的高级方法。我希望你已经对正则表达式的益处以及如何在 pandas 的各种方法中应用它有了更深入的理解。
