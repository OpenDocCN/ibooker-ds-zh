- en: '18 Gematria: Numeric encoding of text using ASCII values'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18 素数编码：使用 ASCII 值对文本进行数值编码
- en: '| Gematria is a system for assigning a number to a word by summing the numeric
    values of each of the characters ([https://en.wikipedia.org/wiki/Gematria](https://en.wikipedia.org/wiki/Gematria)).
    In the standard encoding (*Mispar hechrechi*), each character of the Hebrew alphabet
    is assigned a numeric value ranging from 1 to 400, but there are more than a dozen
    other methods for calculating the numeric value for the letters. To encode a word,
    these values are added together. Revelation 13:18 from the Christian Bible says,
    “Let the one who has insight calculate the number of the wild beast, for it is
    a man’s number, and its number is 666.” Some scholars believe that number is derived
    from the encoding of the characters representing Nero Caesar’s name and title
    and that it was used as a way of writing about the Roman emperor without naming
    him. | ![](../Images/18-unnumb-1.png)  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 素数编码是一种通过将每个字符的数值相加来给单词分配一个数字的系统 ([https://en.wikipedia.org/wiki/Gematria](https://en.wikipedia.org/wiki/Gematria))。在标准编码
    (*Mispar hechrechi*) 中，希伯来字母表中的每个字符都被分配一个从 1 到 400 的数值，但还有十几种其他方法用于计算字母的数值。为了编码一个单词，这些值会被相加。基督教圣经的启示录
    13:18 说：“让有洞察力的人计算野兽的数目，因为这是人的数目，它的数目是 666。”一些学者认为这个数字是从代表尼禄·凯撒的名字和头衔的字符编码中得出的，并且它被用作一种不提名字就写关于罗马皇帝的方式。
    | ![](../Images/18-unnumb-1.png)  |'
- en: We will write a program called gematria.py that will numerically encode each
    word in a given text by similarly adding numeric values for the characters in
    each word. There are many ways we could assign these values. For instance, we
    could start by giving “a” the value `1`, “b” the value `2`, and so forth. Instead,
    we will use the ASCII table ([https://en.wikipedia.org/wiki/ASCII](https://en.wikipedia.org/wiki/ASCII))
    to derive a numeric value for English alphabet characters. For non-English characters,
    we could consider using a Unicode value, but this exercise will stick to ASCII
    letters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个名为 gematria.py 的程序，该程序将通过对每个单词中的字符赋予相似的数值来对给定文本中的每个单词进行数值编码。我们可以以多种方式分配这些值。例如，我们可以从给“a”分配值
    `1`，“b”分配值 `2` 等等开始。相反，我们将使用 ASCII 表 ([https://en.wikipedia.org/wiki/ASCII](https://en.wikipedia.org/wiki/ASCII))
    来为英语字母表中的字符推导出数值。对于非英语字符，我们可以考虑使用 Unicode 值，但这个练习将坚持使用 ASCII 字母。
- en: 'The input text may be entered on the command line:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文本可以输入到命令行中：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or it could be in a file:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它也可以在一个文件中：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Figure 18.1 shows a string diagram showing how the program should work.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.1 显示了一个程序应如何工作的字符串图。
- en: '![](../Images/18-1.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-1.png)'
- en: Figure 18.1 The gematria program will accept input text and will produce a numeric
    encoding for each word.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.1 素数编码程序将接受输入文本并为每个单词生成一个数值编码。
- en: In this exercise, you will
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将
- en: Learn about the `ord()` and `chr()` functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 `ord()` 和 `chr()` 函数
- en: Explore how characters are organized in the ASCII table
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索字符在 ASCII 表中的组织方式
- en: Understand character ranges used in regular expressions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解正则表达式中使用的字符范围
- en: Use the `re.sub()` function
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `re.sub()` 函数
- en: Learn how `map()` can be written without `lambda`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '学习如何在不使用 `lambda` 的情况下编写 `map()` '
- en: Use the `sum()` function and see how that relates to using `reduce()`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `sum()` 函数并看看它与使用 `reduce()` 的关系
- en: Learn how to perform case-insensitive string sorting
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何执行不区分大小写的字符串排序
- en: 18.1 Writing gematria.py
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.1 编写 gematria.py
- en: I will always recommend you start your programs in some way that avoids having
    to type all the boilerplate text. Either copy template/template.py to 18_gematria/gematria.py
    or use `new.py` `gematria.py` in the 18_gematria directory to create a starting
    point.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是会推荐你以某种方式开始你的程序，以避免需要输入所有样板文本。要么将模板/template.py 复制到 18_gematria/gematria.py，要么在
    18_gematria 目录中使用 `new.py` `gematria.py` 创建一个起点。
- en: 'Modify the program until it prints the following usage statement if it’s given
    no arguments or the `-h` or `--help` flag:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 修改程序，直到在没有参数或 `-h` 或 `--help` 标志时打印以下用法说明：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As in previous exercises, the input may come from the command line or from
    a file. I suggest you copy the code you used in chapter 5 to handle this, and
    then modify your `main()` function as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，输入可以来自命令行或文件。我建议你复制第 5 章中使用的代码来处理这个问题，然后按照以下方式修改你的 `main()` 函数：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Verify that your program will print text from the command line,
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 验证你的程序是否可以从命令行打印文本，
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'or from a file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 或者从文件中：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 18.1.1 Cleaning a word
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1.1 清理单词
- en: Let’s discuss how a single word will be encoded, as it will affect how we will
    break the text in the next section. In order to be absolutely sure we are only
    dealing with ASCII values, let’s remove anything that is not an upper- or lowercase
    English alphabet character or any of the Arabic numerals 0-9\. We can define that
    class of characters using the regular expression `[A-Za-z0-9]`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论单个单词的编码方式，因为它将影响我们在下一节中如何分割文本。为了确保我们只处理ASCII值，让我们删除任何不是大写或小写英文字母或阿拉伯数字0-9的东西。我们可以使用正则表达式
    `[A-Za-z0-9]` 来定义这个字符类。
- en: 'We can use the `re.findall()` function we used in chapter 17 to find all the
    characters in `word` that match this class. For instance, we should expect to
    find everything except the apostrophe in the word “Don’t” (see figure 18.2):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用第17章中使用的`re.findall()`函数来找到`word`中所有匹配这个类的字符。例如，我们应该在单词“Don’t”中找到除了撇号之外的所有内容（见图18.2）：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](../Images/18-2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-2.png)'
- en: Figure 18.2 This character class only matches alphanumeric values.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.2 这个字符类只匹配字母数字值。
- en: 'If we put a caret (`^`) as the first character inside the class, like `[^A-Za-z0-9]`,
    we’ll find anything that is *not* one of those characters. Now we would expect
    to match *only* the apostrophe (see figure 18.3):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在类内部将撇号（`^`）作为第一个字符，例如 `[^A-Za-z0-9]`，我们会发现任何不是这些字符的东西。现在我们预计只会匹配到撇号（见图18.3）：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](../Images/18-3.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-3.png)'
- en: Figure 18.3 The caret will find the complement of the character class, so any
    non-alphanumeric character.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.3 破折号将找到字符类的补集，因此任何非字母数字字符。
- en: 'We can use the `re.sub()` function to replace any characters in that second
    class with the empty string. As you learned in chapter 17, this will replace *all*
    occurrences of the pattern unless we use the `count=n` option:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`re.sub()`函数替换第二个类中的任何字符为空字符串。正如你在第17章中学到的，这将替换模式的所有出现，除非我们使用`count=n`选项：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will want to use this operation to clean each word that we’ll encode, as
    shown in figure 18.4\.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想要使用这个操作来清理我们将要编码的每个单词，如图18.4所示。
- en: '![](../Images/18-4.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-4.png)'
- en: Figure 18.4 The `re.sub()` function will replace any text matching a pattern
    with another value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.4 `re.sub()`函数将替换与模式匹配的任何文本为另一个值。
- en: 18.1.2 Ordinal character values and ranges
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1.2 序列字符值和范围
- en: We will encode a string like “Dont” by converting *each character* to a numeric
    value and then adding them together, so let’s first figure out how to encode a
    single character.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将每个字符转换为数值并将它们相加来编码字符串“Dont”，所以让我们首先弄清楚如何编码单个字符。
- en: 'Python has a function called `ord()` that will convert a character to its “ordinal”
    value. For all alphanumeric values that we are using, this will be equal to the
    character’s position in the American Standard Code for Information Interchange
    (ASCII, pronounced like “as-kee”) table:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个名为`ord()`的函数，它将字符转换为它的“序数值”。对于我们所使用的所有字母数字值，这将等于字符在American Standard
    Code for Information Interchange（ASCII，发音为“as-kee”）表中的位置：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `chr()` function works in reverse to convert a number to a character:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`chr()`函数与`ord()`函数相反，它将数字转换为字符：'
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Following is the ASCII table. For simplicity’s sake, I show “NA” (“not available”)
    for the values up to index 31 as they are not printable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的ASCII表。为了简单起见，我将索引31之前的值显示为“NA”（不可用）。
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note I have included the asciitbl.py program in the 18_gematria directory of
    the source code repository.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经将asciitbl.py程序包含在源代码仓库的18_gematria目录中。
- en: 'We can use a `for` loop to cycle through all the characters in a string:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个`for`循环遍历字符串中的所有字符：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that upper- and lowercase letters have different `ord()` values. This
    makes sense because they are two different letters:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，大写和小写字母有不同的`ord()`值。这是有道理的，因为它们是两个不同的字母：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can iterate over the values from “a” to “z” by finding their `ord()` values:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过找到它们的`ord()`值来迭代从“a”到“z”的值：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see in the previous ASCII table, the letters “a” through “z” lie
    contiguously. The same is true for “A” to “Z” and “0” to “9,” which is why we
    can use `[A-Za-z0-9]` as a regex.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个ASCII表所示，字母“a”到“z”是连续的。对于“A”到“Z”和“0”到“9”也是如此，这就是为什么我们可以使用 `[A-Za-z0-9]`
    作为正则表达式。
- en: 'Note that the uppercase letters have *lower* ordinal values than their lowercase
    versions, which is why you cannot use the range `[a-Z]`. Try this in the REPL
    and note the error you get:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，大写字母的序数值比小写字母版本低，这就是为什么你不能使用范围 `[a-Z]`。在REPL中尝试这个，并注意你得到的错误：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If I execute the preceding function in the REPL, the last line of the error
    I see is this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在 REPL 中执行前面的函数，我看到的错误信息的最后一行是：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You *can*, however, use the range `[A-z]`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用范围 `[A-z]`：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'But note that “Z” and “a” are not contiguous:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，“Z” 和 “a” 并不连续：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There are other characters in between them:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间还有其他字符：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we try to use that range on all the printable characters, you’ll see that
    it matches characters that are not letters:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将这个范围应用于所有可打印字符，你会发现它匹配了不是字母的字符：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| That is why it is safest to specify the characters we want as the three separate
    ranges, `[A-Za-z0-9]`, which you may sometimes hear pronounced as “A to Z, a to
    z, zero to nine,” as it assumes you understand that there are two “a to z” ranges
    that are distinct according to their case. | ![](../Images/18-unnumb-4.png)  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 这就是为什么指定我们想要的字符为三个单独的范围 `[A-Za-z0-9]` 是最安全的，你有时可能会听到它被读作“从 A 到 Z，从 a 到 z，从
    0 到 9”，因为它假设你理解有两个“从 a 到 z”的范围是不同的，根据它们的案例。 | ![](../Images/18-unnumb-4.png)  |'
- en: 18.1.3 Summing and reducing
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1.3 求和与归约
- en: 'Let’s keep reminding ourselves what the goal is here: convert all the characters
    in a word, and then sum those values. There is a handy Python function called
    `sum()` that will add a `list` of numbers:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不断提醒自己我们的目标是什么：将单词中的所有字符转换，然后对这些值求和。有一个方便的 Python 函数叫做 `sum()`，它将添加一个数字列表：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can manually encode the string “Dont” by calling `ord()` on each letter
    and passing the results as a `list` to `sum()`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对每个字母调用 `ord()` 并将结果作为 `list` 传递给 `sum()` 来手动编码字符串 “Dont”：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The question is how to apply the function `ord()` to all the characters in
    a `str` and pass a `list` to `sum()`. You’ve seen this pattern many times now.
    What’s the first tool you’ll reach for? We can always start with our handy `for`
    loop:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是如何将函数 `ord()` 应用到 `str` 中的所有字符上，并将一个 `list` 传递给 `sum()`。你现在已经看到这种模式很多次了。你首先会想到什么工具？我们总是可以从我们手头的
    `for` 循环开始：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Can you see how to make that into a single line using a list comprehension?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出如何使用列表推导式将其简化为单行吗？
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'From there, we can move to a `map()`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以转向一个 `map()`：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here I’d like to show that the `map()` version doesn’t need the `lambda` declaration
    because the `ord()` function expects a single value, which is exactly what it
    will get from `map()`. Here is a nicer way to write it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我想展示 `map()` 版本不需要 `lambda` 声明，因为 `ord()` 函数期望一个单一值，这正是它将从 `map()` 中获得的东西。这是一个更优雅的方式来写它：
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To my eye, that is a really beautiful piece of code!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这是一段非常漂亮的代码！
- en: 'Now we can `sum()` that to get a final value for our `word`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以 `sum()` 它以得到 `word` 的最终值：
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'That is correct:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正确的：
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 18.1.4 Using functools.reduce
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1.4 使用 functools.reduce
- en: If Python has a `sum()` function, you might suspect it also has a `product()`
    function to multiply a list of numbers together. Alas, this is not a built-in
    function, but it does represent a common idea of *reducing* a list of values into
    a single value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Python 有 `sum()` 函数，你可能会怀疑它也有一个 `product()` 函数来将数字列表相乘。然而，这并不是一个内置函数，但它确实代表了一个将值列表归约为一个值的常见想法。
- en: 'The `reduce()` function from the `functools` module provides a generic way
    to reduce a list. Let’s consult the documentation for how to use it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`functools` 模块中的 `reduce()` 函数提供了一个通用的归约列表的方法。让我们查阅文档以了解如何使用它：'
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is another higher-order function that wants *another function* as the
    first argument, just like `map()` and `filter()`. The documentation shows us how
    to write our own `sum()` function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要另一个函数作为第一个参数的高阶函数，就像 `map()` 和 `filter()` 一样。文档告诉我们如何编写我们自己的 `sum()` 函数：
- en: '[PRE30]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we change the `+` operator to `*`, we have a product:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `+` 运算符改为 `*`，我们得到一个乘积：
- en: '[PRE31]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is how you might write a function for this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可能写这个函数的方式：
- en: '[PRE32]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And now you can call it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以调用它：
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Instead of writing our own `lambda`, we can use any function that expects two
    arguments. The `operator.mul` function fits this bill:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不用写自己的 `lambda`，而可以使用任何期望两个参数的函数。`operator.mul` 函数符合这个要求：
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So it would be easier to write this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这将更容易写：
- en: '[PRE35]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Fortunately, the `math` module also contains a `prod()` function you can use:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`math` 模块也包含一个 `prod()` 函数你可以使用：
- en: '[PRE36]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you think about it, the `str.join()` method also reduces a `list` of strings
    to a single `str` value. Here’s how we can write our own:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，`str.join()` 方法也将字符串列表归约为一个单一的 `str` 值。这是我们可以这样编写的：
- en: '[PRE37]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'I much prefer the syntax of calling this `join` over the `str.join()` function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常偏好调用这个 `join` 而不是 `str.join()` 函数的语法：
- en: '[PRE38]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Whenever you have a `list` of values that you want to combine to produce a single
    value, consider using the `reduce()` function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个 `list` 的值需要组合成单个值时，考虑使用 `reduce()` 函数。
- en: 18.1.5 Encoding the words
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1.5 编码单词
- en: That was a lot of work just to get to summing the ordinal values of the characters,
    but wasn’t it fascinating to explore? Let’s get back on track, though.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了计算字符的序数值之和就做了很多工作，但这不是很有趣吗？不过，让我们回到正题。
- en: 'We can create a function to encapsulate the idea of converting a word into
    a numeric value derived from summing the ordinal values of the characters. I call
    mine `word2num()`, and here is my test:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个函数来封装将单词转换为从字符序数值之和派生的数值的想法。我称之为 `word2num()`，以下是我的测试：
- en: '[PRE39]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice that my function returns a `str` value, not an `int`. This is because
    I want to use the result with the `str.join()` function that only accepts `str`
    values--so `''405''` instead of `405`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我的函数返回一个 `str` 值，而不是 `int`。这是因为我想使用 `str.join()` 函数，该函数只接受 `str` 值——所以 `'405'`
    而不是 `405`：
- en: '[PRE40]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To summarize, the `word2num()` function accepts a word, removes unwanted characters,
    converts the remaining characters to `ord()` values, and returns a `str` representation
    of the `sum()` of those values.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`word2num()` 函数接受一个单词，删除不需要的字符，将剩余字符转换为 `ord()` 值，并返回这些值的 `str` 表示之和。
- en: 18.1.6 Breaking the text
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1.6 拆分文本
- en: The tests expect you to maintain the same line breaks as the original text,
    so I recommend you use `str.splitlines()` as in other exercises. In chapters 15
    and 16, we used different regexes to split each line into “words,” a process sometimes
    called “tokenization” in programs that deal with natural language processing (NLP).
    If you write a `word2num()` function that passes the tests I’ve provided, then
    you can use `str.split()` to break a line on spaces because the function will
    ignore anything that is not a character or number. You are, of course, welcome
    to break the line into words using whatever means you like.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 测试期望你保持与原文相同的行断行，所以我建议你使用 `str.splitlines()`，就像在其他练习中一样。在第 15 章和第 16 章中，我们使用了不同的正则表达式将每一行拆分为“单词”，这个过程在处理自然语言处理
    (NLP) 的程序中有时被称为“分词”。如果你编写了一个 `word2num()` 函数，并且它通过了我所提供的测试，那么你可以使用 `str.split()`
    在空格处拆分行，因为该函数会忽略任何不是字符或数字的内容。当然，你也可以使用你喜欢的任何方式将行拆分为单词。
- en: The following code will maintain the line breaks and reconstruct the text. Can
    you modify it to add the `word2num()` function so that it instead prints out encoded
    words as shown in figure 18.5?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将保持行断行并重建文本。你能修改它以添加 `word2num()` 函数，使其打印出如图 18.5 所示的编码单词吗？
- en: '[PRE41]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![](../Images/18-5.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 18-5](../Images/18-5.png)'
- en: Figure 18.5 Each word of the text will be cleaned and encoded into a number.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.5 文本中的每个单词都将被清理并编码成数字。
- en: 'The output will be one number for each word:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将为每个单词提供一个数字：
- en: '[PRE42]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Time to finish writing the solution. Be sure to use the tests! See you on the
    flip side.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候完成解决方案的编写了。务必使用测试！在另一边见。
- en: 18.2 Solution
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.2 解决方案
- en: I do enjoy the ideas of cryptography and encoding messages, and this program
    is (sort of) encrypting the input text, albeit in a way that cannot be reversed.
    Still, it’s fun to think of other ways you might process some text and transmogrify
    it to some other value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实喜欢密码学和编码消息的想法，而这个程序（某种程度上）正在加密输入文本，尽管这种方式不能被逆转。但思考其他可能处理文本并将其转换成其他值的方法仍然很有趣。
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ① The text argument is a string that might be a filename.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ① 文本参数可能是一个文件名。
- en: ② Get the parsed command-line arguments.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ② 获取解析的命令行参数。
- en: ③ Check if the text argument is an existing file.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 检查文本参数是否是现有文件。
- en: ④ Overwrite the args.text with the contents of the file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 用文件内容覆盖 args.text。
- en: ⑤ Return the arguments.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 返回参数。
- en: ⑥ Get the parsed arguments.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 获取解析的参数。
- en: ⑦ Split args.text on newlines to retain line breaks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 在 args.text 上使用换行符拆分以保留行断行。
- en: ⑧ Split the line on spaces, map the result through word2num(), and then join
    that result on spaces.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 在空格处拆分行，将结果通过 word2num() 函数映射，然后使用空格连接该结果。
- en: ⑨ Define a function to convert a word to a number.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 定义一个将单词转换为数字的函数。
- en: ⑩ Use re.sub() to remove anything that’s not an alphanumeric character. Map
    the resulting string through the ord() function, sum the ordinal values of the
    characters, and return a str representation of the sum.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 使用 re.sub() 删除任何非字母数字字符。将结果字符串通过 ord() 函数映射，计算字符的序数值之和，并返回该和的字符串表示。
- en: ⑪ Define a function to test the word2num() function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 定义一个测试 word2num() 函数的函数。
- en: 18.3 Discussion
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.3 讨论部分
- en: I trust you understand `get_args()`, as we’ve used this exact code several times
    now. Let’s jump to the `word2num()` function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经理解了 `get_args()`，因为我们已经多次使用这段代码。让我们跳转到 `word2num()` 函数。
- en: 18.3.1 Writing word2num()
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.1 编写 word2num()
- en: 'I could have written the function like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以像这样编写函数：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ① Initialize an empty list to hold the ordinal values.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ① 初始化一个空列表来存储序数值。
- en: ② Iterate all the characters returned from re.sub().
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ② 遍历 `re.sub()` 返回的所有字符。
- en: ③ Convert the character to an ordinal value and append that to the values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将字符转换为序数值并将其追加到值列表中。
- en: ④ Sum the values and return a string representation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 求和这些值并返回一个字符串表示形式。
- en: 'That’s four lines of code instead of the one I wrote. I would at least rather
    use a list comprehension, which collapses three lines of code into one:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我所写的单行代码多了四行。我至少更愿意使用列表推导式，它将三行代码压缩成一行：
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'That could be written in one line, though it could be argued that readability
    suffers:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以将其写在一行中，但有人可能会说可读性会受到影响：
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'I still think the `map()` version is the most readable and concise:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然认为 `map()` 版本是最易读和简洁的：
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Figure 18.6 shows how the three methods relate to each other.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.6展示了三种方法之间的关系。
- en: '![](../Images/18-6.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-6.png)'
- en: Figure 18.6 How the `for` loop, a list comprehension, and a `map()` relate to
    each other
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.6展示了 `for` 循环、列表推导式和 `map()` 之间的关系。
- en: Figure 18.7 will help you see how the data moves through the `map()` version
    with the string “Don’t.”
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.7将帮助你看到字符串“Don’t”通过 `map()` 版本的数据流动。
- en: The `re.sub()` function will replace any character not in the character class
    with the empty string. This will turn a word like “Don’t” into “Dont” (without
    the apostrophe).
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`re.sub()` 函数将替换掉字符集中不存在的任何字符，将其替换为空字符串。这将把像“Don’t”这样的单词变成“Dont”（没有撇号）。'
- en: The `map()` will apply the given function `ord()` to each element of a sequence.
    Here that “sequence” is a `str`, so it will use each character of the word.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`map()` 将给定的函数 `ord()` 应用到序列的每个元素上。在这里，“序列”是一个 `str`，所以它将使用单词中的每个字符。'
- en: The result of `map()` is a new `list`, where each character from “Dont” is given
    to the `ord()` function.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`map()` 的结果是一个新的 `list`，其中“Dont”中的每个字符都被 `ord()` 函数处理。'
- en: The results of the calls to `ord()` will be a `list` of `int` values, one for
    each letter.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ord()` 函数调用的结果将是一个 `int` 值的 `list`，每个字母对应一个。'
- en: The `sum()` function will reduce a list of numbers to a single value by adding
    them together.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sum()` 函数通过将它们相加将数字列表减少到单个值。'
- en: The final value from our function needs to be a `str`, so we use the `str()`
    function to turn the return from `sum()` into a string representation of the number.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们函数的最终值需要是一个 `str`，所以我们使用 `str()` 函数将 `sum()` 的返回值转换为数字的字符串表示形式。
- en: '![](../Images/18-7.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18-7.png)'
- en: Figure 18.7 A representation of the order of operations for the functions
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.7展示了函数运算顺序的表示。
- en: 18.3.2 Sorting
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.2 排序
- en: The point of this exercise was less about the `ord()` and `chr()` functions
    and more about exploring regular expressions, function application, and how characters
    are represented inside programming languages like Python.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的重点不是 `ord()` 和 `chr()` 函数，而是探索正则表达式、函数应用以及字符在像Python这样的编程语言中的表示方式。
- en: 'For instance, the sorting of strings is case sensitive because of the relative
    order of the `ord()` values of the characters (because the uppercase letters are
    defined earlier in the ASCII table than the lowercase values). Note that the words
    that begin with uppercase letters are sorted before those with lowercase letters:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，字符串排序是大小写敏感的，因为字符的 `ord()` 值的相对顺序（因为大写字母在ASCII表中定义的比小写字母早）。请注意，以大写字母开头的单词会排在以小写字母开头的单词之前：
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This is because all the uppercase ordinal values are lower than those of the
    lowercase letters. In order to perform a case sensitive sorting of strings, you
    can use `key=str.casefold`. The `str.casefold()` function will return “a version
    of the string suitable for caseless comparisons.” We are using the function’s
    name *without parentheses* here because we are passing *the function itself* as
    the argument for `key`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为所有大写序数值都小于小写字母的序数值。为了对字符串进行大小写敏感的排序，你可以使用 `key=str.casefold`。`str.casefold()`
    函数将返回“一个适合无大小写比较的字符串版本。”我们在这里使用函数名*不带括号*，因为我们正在将*函数本身*作为 `key` 的参数：
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you add the parentheses, it will cause an exception. This is exactly the
    same way we pass functions as arguments to `map()` and `filter()`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加括号，它将引发异常。这正是我们将函数作为参数传递给`map()`和`filter()`的方式：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The option is the same with `list.sort()` if you prefer to sort the list in
    place:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢就地排序列表，`list.sort()`的选项是相同的：
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Command-line tools like the `sort` program behave in the same way due to the
    same representation of characters. Given a file of these same words,
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符表示相同，命令行工具（如`sort`程序）的行为方式也相同。给定一个包含这些相同单词的文件，
- en: '[PRE52]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'the `sort` program on my Mac[1](#pgfId-1021150) will first sort the uppercase
    words and then the lowercase:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我Mac上的`sort`程序[1](#pgfId-1021150)将首先对大写单词进行排序，然后是对小写单词进行排序：
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'I have to read the `sort` manual page (via `man` `sort`) to find the `-f` flag
    to perform a case-insensitive sort:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须阅读`sort`的手册页面（通过`man sort`）来找到`-f`标志以执行不区分大小写的排序：
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 18.3.3 Testing
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.3 测试
- en: I would like to take a moment to point out how often I use my own tests. Every
    time I write an alternative version of a function or program, I run my own tests
    to verify that I’m not accidentally showing you buggy code. Having a test suite
    gives me the freedom and confidence to extensively refactor my programs because
    I know I can check my work. If I ever find a bug in my code, I add a test to verify
    that the bug exists. Then I fix the bug and verify that it’s handled. I know if
    I accidentally reintroduce that bug, my tests will catch it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我想花点时间指出我有多频繁地使用自己的测试。每次我编写函数或程序的替代版本时，我都会运行自己的测试来验证我没有意外地展示出有错误的代码。拥有测试套件让我有自由和信心对我的程序进行大量重构，因为我知道我可以检查我的工作。如果我在代码中找到错误，我会添加一个测试来验证该错误是否存在。然后我修复错误并验证它是否被处理。我知道如果我意外地重新引入该错误，我的测试会捕捉到它。
- en: For the purposes of this book, I’ve tried to never write a program over 100
    lines. It’s common for programs to grow to thousands of lines of code spread over
    dozens of modules. I recommend you start writing and using tests, no matter how
    small you start. It’s a good habit to establish early on, and it will only help
    you as you write longer code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的目的，我尽量不编写超过100行的程序。程序通常增长到数千行代码，分布在数十个模块中。我建议你开始编写和使用测试，无论你从哪里开始。这是一个早期建立的好习惯，并且它只会帮助你编写更长的代码。
- en: 18.4 Going further
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.4 进一步探索
- en: Analyze text files to find other words that sum to the value 666\. Are these
    particularly scary words?
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析文本文件以找到其他总和为666的单词。这些单词特别令人恐惧吗？
- en: Given some text input, find the most frequently occurring value from `word2num()`
    and all the words that reduce to that value.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一些文本输入，找出`word2num()`中最频繁出现的值以及所有转换为该值的单词。
- en: Create a version using your own numeric values for each character. For instance,
    each letter could be encoded as its position in the alphabet so that “A” and “a”
    are 1, “B” and “b” are 2, and so on. Or you might decide to weigh each consonant
    as 1 and each vowel as -1\. Create your own scheme, and write tests to ensure
    your program performs as you expect.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个使用每个字符的自己的数值版本的版本。例如，每个字母可以编码为其在字母表中的位置，使得“A”和“a”是1，“B”和“b”是2，以此类推。或者你可能决定将每个辅音的权重设为1，每个元音的权重设为-1。创建你自己的方案，并编写测试以确保你的程序按预期运行。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The `ord()` function will return the Unicode code point of a character. For
    our alphanumeric values, the ordinal values correspond to their position in the
    ASCII table.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ord()`函数将返回字符的Unicode码点。对于我们的数字值，序数值对应于它们在ASCII表中的位置。'
- en: The `chr()` function will return the character for a given ordinal value.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chr()`函数将返回给定序数值的字符。'
- en: You can use character ranges like `a-z` in regular expressions when ordinal
    values of the characters lie contiguously, such as in the ASCII table.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当字符的序数值连续时，例如在ASCII表中，你可以在正则表达式中使用字符范围，如`a-z`。
- en: The `re.sub()` function will replace matching patterns of text in a string with
    new values, such as replacing all non-characters with the empty string to remove
    punctuation and whitespace.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re.sub()`函数将替换字符串中匹配的文本模式为新值，例如，将所有非字符替换为空字符串以删除标点符号和空白。'
- en: A `map()` can be written using a function reference instead of a `lambda` if
    the function expects a single positional argument.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数期望一个单一的位置参数，可以使用函数引用而不是`lambda`来编写`map()`。
- en: The `sum()` function reduces a list of numbers using addition. You can manually
    write a version of this using the `functools.reduce()` function.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum()`函数通过加法减少数字列表。你可以使用`functools.reduce()`函数手动编写这个版本的代码。'
- en: To perform a case-insensitive sort of string values, use the `key=str.casefold`
    option with both the `sorted()` and `list.sort()` functions.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要对字符串值进行不区分大小写的排序，请使用`sorted()`和`list.sort()`函数的`key=str.casefold`选项。
- en: '* * *'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1 The GNU coreutils 8.30 version on one of my Linux machines will perform a
    case-insensitive sort by default. How does your `sort` work?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 1 在我的Linux机器上，GNU coreutils 8.30版本默认会进行不区分大小写的排序。你的`sort`命令是如何工作的？
