- en: '11 Playing audio: Sound effects and music'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 播放音频：音效和音乐
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Importing and playing audio clips for various sound effects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入和播放各种音效的音频剪辑
- en: Using 2D sounds for the UI and 3D sounds in the scene
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用2D声音进行UI和场景中的3D声音
- en: Modulating the volume of all sounds when they play
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调节播放时所有声音的音量
- en: Playing background music while the game is being played
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏进行时播放背景音乐
- en: Fading in and out between different background tunes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的背景曲调之间淡入淡出
- en: Although graphics get most of the attention when it comes to content in video
    games, audio is crucial too. Most games play background music and have sound effects.
    Accordingly, Unity has audio functionality so that you can put sound effects and
    music into your games. Unity can import and play a variety of audio file formats,
    adjust the volume of sounds, and even handle sounds playing from a specific position
    within the scene.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在视频游戏的内容中图形通常受到最多的关注，但音频同样重要。大多数游戏都会播放背景音乐和音效。因此，Unity提供了音频功能，以便你可以在游戏中添加音效和音乐。Unity可以导入和播放多种音频文件格式，调整声音的音量，甚至可以处理场景中特定位置播放的声音。
- en: NOTE Audio is handled the same way for both 2D and 3D games. Although the sample
    project in this chapter is a 3D game, everything we’ll do applies to 2D games
    as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：2D和3D游戏中的音频处理方式相同。尽管本章的示例项目是一个3D游戏，但我们所做的一切同样适用于2D游戏。
- en: This chapter starts off looking at sound effects rather than music. *Sound effects*
    are short clips that play along with actions in the game (such as a gunshot that
    plays when the player fires), whereas the sound clips for music are longer (often
    running into minutes) and playback isn’t directly tied to events in the game.
    Ultimately, both boil down to the same kind of audio files and playback code,
    but the simple fact that the sound files for music are usually much larger than
    the short clips used for sound effects (indeed, files for music are often the
    largest files in the game!) merits covering them in a separate section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先从音效而不是音乐开始。*音效*是与游戏中的动作（如玩家开火时播放的枪声）一起播放的短剪辑，而音乐的音频剪辑则更长（通常持续几分钟），播放并不直接与游戏中的事件相关联。最终，两者都归结为同一种音频文件和播放代码，但音乐的声音文件通常比音效的短剪辑大得多（实际上，音乐文件往往是游戏中最大的文件！）这一点值得单独介绍。
- en: 'The complete road map for this chapter will be to take a game without sound
    and do the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整路线图将是将一个没有声音的游戏进行以下操作：
- en: Import audio files for sound effects.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入音效的音频文件。
- en: Play sound effects for the enemy and for shooting.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为敌人和射击播放音效。
- en: Program an audio manager to control volume.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程一个音频管理器来控制音量。
- en: Optimize the loading of music.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优化音乐的加载。
- en: Control music volume separately from sound effects, including cross-fading tracks.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别控制音乐音量和音效，包括交叉淡入淡出曲目。
- en: NOTE In this chapter, we’ll simply add audio capabilities on top of an existing
    game demo. All of the examples in this chapter are built on top of the FPS created
    in chapter 3, and you could download that sample project, but you’re free to use
    whatever game demo you’d like.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本章中，我们将在现有的游戏演示基础上简单地添加音频功能。本章中的所有示例都是基于第3章中创建的FPS构建的，你可以下载那个示例项目，但你也可以使用你喜欢的任何游戏演示。
- en: 'Once you have an existing game demo copied to use for this chapter, you can
    tackle the first step: importing sound effects.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将现有的游戏演示复制用于本章，你就可以着手第一步：导入音效。
- en: 11.1 Importing sound effects
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 导入音效
- en: Before you can play any sounds, you obviously need to import the sound files
    into your Unity project. First, you’ll collect sound clips in the desired file
    format, and then you’ll bring the files into Unity and adjust them for your purposes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够播放任何声音之前，显然你需要将声音文件导入到你的Unity项目中。首先，你将收集所需文件格式的声音剪辑，然后你将把文件带入Unity并调整它们以适应你的需求。
- en: 11.1.1 Supported file formats
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 支持的文件格式
- en: Much as you saw with art assets in chapter 4, Unity supports a variety of audio
    formats with different pros and cons. Table 11.1 lists the audio file formats
    that Unity supports.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在第4章中看到的艺术资源一样，Unity支持多种音频格式，各有优缺点。表11.1列出了Unity支持的音频文件格式。
- en: The primary consideration differentiating audio files is the compression applied.
    Compression reduces a file’s size but accomplishes that by throwing out a bit
    of information from the file. Audio compression is clever about throwing out only
    the least important information so that the compressed sound still sounds good.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 区分音频文件的主要考虑因素是应用的压缩方式。压缩可以减小文件的大小，但这是通过从文件中丢弃一些信息来实现的。音频压缩非常巧妙，只丢弃最不重要的信息，这样压缩后的声音仍然听起来不错。
- en: Table 11.1 Audio file formats supported by Unity
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1 Unity支持的音频文件格式
- en: '| File type | Pros and cons |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 文件类型 | 优点和缺点 |'
- en: '| WAV | Default audio format on Windows. Uncompressed sound file. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| WAV | Windows上的默认音频格式。未压缩声音文件。|'
- en: '| AIF | Default audio format on Mac. Uncompressed sound file. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| AIF | Mac上的默认音频格式。未压缩声音文件。|'
- en: '| MP3 | Compressed sound file; sacrifices a bit of quality for much smaller
    files. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| MP3 | 压缩声音文件；为了获得更小的文件，牺牲了一部分质量。|'
- en: '| OGG | Compressed sound file; sacrifices a bit of quality for much smaller
    files. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| OGG | 压缩声音文件；为了获得更小的文件，牺牲了一部分质量。|'
- en: '| MOD | Music tracker file format. A specialized kind of efficient digital
    music. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| MOD | 音乐跟踪文件格式。一种高效的数字音乐。|'
- en: '| XM | Music tracker file format. A specialized kind of efficient digital music.
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| XM | 音乐跟踪文件格式。一种高效的数字音乐。|'
- en: Nevertheless, compression results in a small amount of loss of quality, so you
    should choose uncompressed audio when the sound clip is short and thus wouldn’t
    be a large file. Longer sound clips (especially music) should use compressed audio,
    because the audio clip would be prohibitively large otherwise. Unity adds a small
    wrinkle to this decision, though.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，压缩会导致少量质量的损失，因此当声音剪辑较短且不会成为大文件时，你应该选择未压缩的音频。较长的声音剪辑（尤其是音乐）应使用压缩音频，否则音频剪辑会过大。尽管如此，Unity
    在这个决定上增加了一个小细节。
- en: TIP Although music should be compressed in the final game, Unity can compress
    the audio after you’ve imported the file. When developing a game in Unity, you
    usually want to use uncompressed file formats even for lengthy music, as opposed
    to importing compressed audio.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 尽管音乐应该在最终的游戏中压缩，但Unity可以在导入文件后压缩音频。在Unity中开发游戏时，你通常希望即使对于较长的音乐，也使用未压缩的文件格式，而不是导入压缩音频。
- en: Because Unity will compress the audio after it’s been imported, you should always
    choose either WAV or AIF file format. You’ll probably need to adjust the import
    settings differently for short sound effects and longer music (in particular,
    to tell Unity when to apply compression), but the original files should always
    be uncompressed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Unity会在导入音频后对其进行压缩，因此你应该始终选择WAV或AIF文件格式。你可能需要根据短声音效果和较长的音乐（特别是告诉Unity何时应用压缩）调整不同的导入设置，但原始文件始终应该是未压缩的。
- en: How digital audio works
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数字音频的工作原理
- en: In general, audio files store the waveform that’ll be created in the speakers
    when the sound plays. Sound is a series of waves that travel through the air,
    and different sounds are made with different sizes and frequencies of sound waves.
    Audio files record these waves by sampling them repeatedly at short time intervals
    and saving the state of the wave at each sample.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，音频文件存储的是当声音播放时在扬声器中产生的波形。声音是一系列通过空气传播的波，不同的声音是通过不同大小和频率的声音波产生的。音频文件通过在短时间间隔内重复采样这些波，并保存每个样本的波形状态来记录这些波。
- en: Recordings that sample waves more frequently get a more accurate recording of
    them changing over time—the gaps between changes are smaller. But more frequent
    samples mean more data to save, resulting in a larger file. Compressed sound files
    reduce the file size through a number of tricks, including tossing out data at
    sound frequencies that aren’t noticeable to listeners.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 采样频率更高的录音可以得到更准确的随时间变化的记录——变化之间的间隔更小。但更频繁的采样意味着需要保存更多的数据，从而导致文件更大。压缩声音文件通过多种技巧来减小文件大小，包括在听众听不到的声音频率上丢弃数据。
- en: 'Music trackers are a special type of sequencer software used to create music.
    Whereas traditional audio files store the raw waveform for the sound, sequencers
    store something more akin to sheet music: the tracker file is a sequence of notes,
    with information like intensity and pitch stored with each note. These “notes”
    consist of little waveforms, but the total amount of data stored is reduced because
    the same note is used repeatedly throughout the sequence. Music composed this
    way can be efficient, but this is a fairly specialized sort of audio.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐跟踪器是一种特殊的序列软件，用于创作音乐。与传统音频文件存储原始声波波形不同，序列软件存储的更像是乐谱：跟踪文件是一系列音符，每个音符都存储了强度和音高等信息。这些“音符”由小波形组成，但由于在序列中重复使用相同的音符，因此存储的数据总量减少。以这种方式创作的音乐可以很高效，但这是一种相当专业的音频类型。
- en: There are various ways to create sound files (appendix B mentions tools like
    Audacity, which can record sounds from a microphone), but for our purposes we’ll
    download sounds from one of the many free sound websites. We’re going to use clips
    downloaded from [www.freesound.org](https://freesound.org/) in WAV file format.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建声音文件有多种方法（附录B提到了Audacity等工具，可以从麦克风录制声音），但为了我们的目的，我们将从众多免费声音网站之一下载声音。我们将使用从[www.freesound.org](https://freesound.org/)下载的WAV格式剪辑。
- en: WARNING “Free” sounds are offered under a variety of licensing schemes, so always
    make sure that you’re allowed to use the sound clip in the way you intend. For
    example, many free sounds are for noncommercial use only.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：“免费”的声音提供在多种许可方案下，所以请确保你允许以你打算的方式使用声音剪辑。例如，许多免费声音仅限非商业用途。
- en: 'The sample project uses the following public domain sound effects (of course,
    you can choose to download your own sounds; look for a 0 license listed on the
    side):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '样本项目使用以下公共领域声音效果（当然，你也可以选择下载自己的声音；查找旁边列出的0许可）： '
- en: “thump” by hy96
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “thump” by hy96
- en: “ding” by Daphne_in_Wonderland
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “ding” by Daphne_in_Wonderland
- en: “swish bamboo pole” by ra_gun
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “swish bamboo pole” by ra_gun
- en: “fireplace” by leosalom
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “fireplace” by leosalom
- en: Once you have the sound files to use in your game, the next step is to import
    the sounds into Unity.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了游戏中要使用的声音文件，下一步就是将声音导入到Unity中。
- en: 11.1.2 Importing audio files
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 导入音频文件
- en: After gathering some audio files, you need to bring them into Unity. Just as
    you did with art assets in chapter 4, you have to import audio assets into the
    project before they can be used in the game.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集了一些音频文件之后，你需要将它们导入到Unity中。就像在第4章中处理艺术资产一样，在使用游戏之前，你必须将音频资产导入到项目中。
- en: 'The mechanics of importing files are simple and are the same as with other
    assets: drag the files from their location on the computer to the Project view
    within Unity (create a folder called Sound FX to drag the files into). Well, that
    was easy! But just like other assets, these audio files have import settings (shown
    in figure 11.1) to adjust in the Inspector.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 导入文件的操作很简单，与其他资产相同：将文件从电脑上的位置拖动到Unity中的项目视图中（在Unity中创建一个名为Sound FX的文件夹以将文件拖入）。嗯，这很简单！但就像其他资产一样，这些音频文件也有导入设置（如图11.1所示）可以在检查器中进行调整。
- en: '![CH11_F01_Hocking3](../Images/CH11_F01_Hocking3.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![CH11_F01_Hocking3](../Images/CH11_F01_Hocking3.png)'
- en: Figure 11.1 Import settings for audio files
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 音频文件导入设置
- en: Leave the Force To Mono option unchecked. This refers to mono versus stereo
    sound. Often, sounds are recorded in stereo, resulting in two waveforms in the
    file, one for the left ear/speaker, and one for the right. To save on file size,
    you might want to halve the audio information so that the same waveform is sent
    to both speakers rather than separate waves sent to the left and right speakers.
    (A Normalize setting, which applies only when mono is on, is grayed out when mono
    is off.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 不要勾选“强制单声道”选项。这指的是单声道与立体声声音。通常，声音是以立体声录制的，文件中有两个波形，一个用于左耳/扬声器，一个用于右耳。为了节省文件大小，你可能想要将音频信息减半，以便将相同的波形发送到两个扬声器，而不是分别发送到左右扬声器。（当单声道关闭时，仅当单声道打开时才应用的归一化设置会变灰。）
- en: Below Force To Mono, you’ll see check boxes for Load In Background and Preload
    Audio Data. The preload setting relates to balancing playback performance and
    memory usage; preloading audio will consume memory while the sound waits to be
    used but will avoid having to wait to load. Thus, you don’t want to preload long
    audio clips, but turn it on for short sound effects like this.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在“强制转换为单声道”下方，你会看到“在后台加载”和“预加载音频数据”的复选框。预加载设置与平衡回放性能和内存使用有关；预加载音频将在声音等待使用时消耗内存，但可以避免等待加载。因此，你不想预加载长音频剪辑，但对于这种短声音效果，可以将其打开。
- en: Meanwhile, loading audio in the background will allow the program to keep running
    while the audio is loading; this is generally a good idea for long music clips
    so that the program doesn’t freeze. But this means the audio won’t start playing
    right away. Usually you want to keep this setting off for short sound clips to
    ensure that they load completely before they play. Because the imported clips
    are short sound effects, you should leave Load In Background unchecked.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，在后台加载音频将允许程序在音频加载时继续运行；这对于长音乐剪辑来说通常是个好主意，这样程序就不会冻结。但这也意味着音频不会立即开始播放。通常，对于短声音剪辑，你希望关闭此设置，以确保它们在播放之前完全加载。因为导入的剪辑是短声音效果，你应该取消选中“在后台加载”。
- en: Finally, the most important settings are Load Type and Compression Format. Compression
    Format controls the formatting of the audio data that’s stored. As discussed in
    the previous section, music should be compressed, so choose Vorbis (it’s the name
    of a compressed audio format) in that case. Short sound clips don’t need to be
    compressed, so choose PCM (pulse code modulation, the technical term for the raw,
    sampled sound wave) for these clips. The third setting, ADPCM, is a variation
    on PCM and occasionally results in slightly better sound quality.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最重要的设置是加载类型和压缩格式。压缩格式控制存储的音频数据的格式。如前所述，音乐应该被压缩，所以在这种情况下选择Vorbis（这是一个压缩音频格式的名称）。短声音剪辑不需要压缩，因此对于这些剪辑选择PCM（脉冲编码调制，原始采样声音波的术语）。第三个设置，ADPCM，是PCM的一种变体，偶尔会产生略微更好的音质。
- en: Load Type controls how the data from the file will be loaded by the computer.
    Because computers have limited memory and audio files can be large, sometimes
    you want the audio to play while it’s streaming into memory, saving the computer
    from needing to have the entire file loaded. But a bit of computing overhead is
    required when streaming audio like this, so audio plays fastest when it’s loaded
    into memory first. Even then, you can choose whether the loaded audio data will
    be in compressed form or will be decompressed for faster playback. Because these
    sound clips are short, they don’t need to stream and can be set to Decompress
    On Load.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 加载类型控制计算机如何加载文件中的数据。由于计算机的内存有限，而音频文件可能很大，有时你希望音频在流式传输到内存时播放，从而节省计算机不需要加载整个文件。但以这种方式流式传输音频时需要一些计算开销，因此当音频首先加载到内存中时，音频播放速度最快。即使如此，你也可以选择加载的音频数据是压缩形式还是解压缩以实现更快的回放。因为这些声音剪辑很短，它们不需要流式传输，可以设置为“加载时解压缩”。
- en: The last option is Sample Rate Setting; leave this at Preserve Sample Rate so
    Unity won’t change the samples in the imported file. At this point, the sound
    effects are all imported and ready to use.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项是采样率设置；将其保留为“保留采样率”，这样Unity就不会更改导入文件中的样本。到此为止，声音效果都已导入并准备好使用。
- en: 11.2 Playing sound effects
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 播放声音效果
- en: Now that you have sound files added to the project, you naturally want to play
    the sounds. The code for triggering sound effects isn’t terribly hard to understand,
    but the audio system in Unity does have multiple parts that must work in concert.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将声音文件添加到项目中，你自然会想要播放这些声音。触发声音效果的代码并不难理解，但Unity中的音频系统确实有多个部分必须协同工作。
- en: '11.2.1 Explaining what’s involved: Audio clip vs. source vs. listener'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 解释所涉及的内容：音频剪辑 vs. 源 vs. 听众
- en: 'Although you might expect playing a sound to be simply a matter of telling
    Unity which clip to play, it turns out that you must define three parts in order
    to play sounds in Unity: AudioClip, AudioSource, and AudioListener. The reason
    for breaking the sound system into multiple components has to do with Unity’s
    support for 3D sounds: the different components tell Unity positional information
    that it uses for manipulating 3D sounds.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可能认为播放声音只是告诉Unity播放哪个剪辑这么简单，但结果是您必须定义三个部分才能在Unity中播放声音：AudioClip、AudioSource和AudioListener。将声音系统分解成多个组件的原因与Unity对3D声音的支持有关：不同的组件告诉Unity位置信息，Unity使用这些信息来操纵3D声音。
- en: 2D vs. 3D sound
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 2D与3D声音
- en: 'Sounds in games can be either 2D or 3D. 2D sounds are what you’re already familiar
    with: standard audio that plays normally. The moniker 2D sound mostly means *not
    3D sound*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的声音可以是2D或3D。2D声音是您已经熟悉的：标准音频正常播放。2D声音的称呼主要意味着**不是3D声音**。
- en: 3D sounds are specific to 3D simulations and may not already be familiar to
    you; these are sounds that have a specific location within the simulation. Their
    volume and pitch are influenced by the movement of the listener. A sound effect
    triggered in the distance will sound faint, for example.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 3D声音是针对3D模拟的，可能您并不熟悉；这些是在模拟中有特定位置的声音。它们的音量和音调受监听者移动的影响。例如，在远处触发的一个声音效果会听起来很微弱。
- en: Unity supports both kinds of audio, and you decide whether an audio source should
    play audio as 2D sounds or 3D sounds. Things like music should be 2D sounds, but
    using 3D sounds for most sound effects will create immersive audio in the scene.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Unity支持这两种音频，您决定音频源应该播放2D声音还是3D声音。像音乐这样的东西应该是2D声音，但使用3D声音为大多数声音效果创建场景中的沉浸式音频。
- en: As an analogy, imagine a room in the real world. The room has a stereo playing
    a CD. If a man comes into the room, he hears it clearly. When he leaves the room,
    he hears it less clearly, and eventually not at all. Similarly, if we move the
    stereo around the room, he’ll hear the music changing volume as it moves. As figure
    11.2 illustrates, in this analogy the CD is an AudioClip, the stereo is an AudioSource,
    and the man is the AudioListener.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个类比，想象一下现实世界中的一个房间。房间里有立体声音响在播放CD。如果一个人走进房间，他会清楚地听到声音。当他离开房间时，他会听得更不清楚，最终完全听不到。同样，如果我们把立体声音响在房间里移动，他会听到音乐随着移动而改变音量。如图11.2所示，在这个类比中，CD是一个AudioClip，立体声音响是一个AudioSource，而那个人是AudioListener。
- en: '![CH11_F02_Hocking3](../Images/CH11_F02_Hocking3.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![CH11_F02_Hocking3](../Images/CH11_F02_Hocking3.png)'
- en: Figure 11.2 The three things you control in Unity’s audio system
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 Unity音频系统中您所控制的三个要素
- en: The first of the three parts is an *audio clip*. This is the sound file that
    we imported in the preceding section. This raw waveform data is the foundation
    for everything else the audio system does, but audio clips don’t do anything by
    themselves.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 三个部分中的第一个是**音频剪辑**。这是我们之前章节中导入的声音文件。这些原始波形数据是音频系统所做一切的基础，但音频剪辑本身并不做任何事情。
- en: The next kind of object is an *audio source*. This is the object that plays
    audio clips. This is an abstraction over what the audio system is actually doing,
    but it’s a useful abstraction that makes 3D sounds easier to understand. A 3D
    sound played from a specific audio source is located at the position of that audio
    source; 2D sounds must also be played from an audio source, but the location doesn’t
    matter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种对象是**音频源**。这是播放音频剪辑的对象。这是对音频系统实际所做事情的一种抽象，但它是一种有用的抽象，使得3D声音更容易理解。从特定音频源播放的3D声音位于该音频源的位置；2D声音也必须从音频源播放，但位置并不重要。
- en: The third kind of object involved in Unity’s audio system is an *audio listener*.
    As the name indicates, this is the object that hears sounds projected from the
    audio sources. This is another abstraction on top of what the audio system is
    doing (obviously, the actual listener is the player of the game!), but—much as
    the position of the audio source gives the position that the sound is projected
    from—the position of the audio listener gives the position that the sound is heard
    from.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Unity音频系统中涉及的第三种对象是**音频监听器**。正如其名所示，这是接收从音频源投射出的声音的对象。这是在音频系统所做事情之上的一种抽象（显然，实际的监听者是游戏玩家！），但——就像音频源的位置给出了声音投射的位置一样——音频监听器的位置给出了声音被听到的位置。
- en: Advanced sound control using audio mixers
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用音频混音器进行高级声音控制
- en: '*Audio mixers* are an advanced alternative way to control audio in Unity. Rather
    than playing audio clips directly, audio mixers enable you to process audio signals
    and apply various effects to your clips. Learn more about AudioMixer in Unity’s
    documentation. You can watch a Unity tutorial video, for example: [http://mng.bz/Mlp3](http://mng.bz/Mlp3).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*音频混合器*是控制Unity中音频的高级替代方法。而不是直接播放音频剪辑，音频混合器允许你处理音频信号并对你的剪辑应用各种效果。在Unity的文档中了解更多关于音频混合器的信息。例如，你可以观看Unity教程视频：[http://mng.bz/Mlp3](http://mng.bz/Mlp3)。'
- en: Although both the audio clips and the AudioSource components have to be assigned,
    an AudioListener component is already on the default camera when you create a
    new scene. Typically, you want 3D sounds to react to the position of the viewer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然音频剪辑和音频源组件都需要分配，但当你创建一个新场景时，默认相机上已经有一个音频监听器组件。通常，你希望3D声音能够对观众的方位做出反应。
- en: 11.2.2 Assigning a looping sound
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 分配循环声音
- en: All right, now let’s set our first sound in Unity! The audio clips were already
    imported, and the default camera has an AudioListener component, so we need to
    assign only an AudioSource component. We’re going to put a crackling fire sound
    on the Enemy prefab, the enemy character that wanders around.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在让我们在Unity中设置我们的第一个声音！音频剪辑已经导入，默认相机有一个音频监听器组件，所以我们只需要分配一个音频源组件。我们将把噼啪声放在敌人预制体上，即四处游荡的敌人角色。
- en: NOTE Because the enemy will sound like it’s on fire, you might want to give
    it a particle system so that it looks like it’s on fire. You can copy over the
    particle system created in chapter 4 by making the particle object into a prefab
    and then choosing Export Package from the Asset menu. Alternatively, you could
    redo the steps from chapter 4 here (after first double-clicking the Enemy prefab
    to open it for editing, rather than editing the scene) to create a new particle
    object from scratch.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：因为敌人听起来像是在着火，你可能想给它一个粒子系统，让它看起来像是在着火。你可以通过将粒子对象制作成预制体，然后从资产菜单中选择导出包，来复制第4章中创建的粒子系统。或者，你也可以在这里重新执行第4章的步骤（首先双击敌人预制体以打开它进行编辑，而不是编辑场景）来从头创建一个新的粒子对象。
- en: 'Usually, you need to open a prefab into the scene to edit it, but just adding
    a component onto the object can be done without double-clicking the prefab to
    open it. Select the Enemy prefab so that its properties appear in the Inspector.
    Now add a new component: choose Audio > Audio Source. An AudioSource component
    will appear in the Inspector.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要将预制体打开到场景中才能编辑它，但只需将组件添加到对象上就可以完成，而无需双击预制体来打开它。选择敌人预制体，使其属性出现在检查器中。现在添加一个新的组件：选择音频
    > 音频源。一个音频源组件将出现在检查器中。
- en: Tell the audio source what sound clip to play. Drag an audio file from the Project
    view up to the Audio Clip slot in the Inspector; we’re going to use the “fireplace”
    sound effect for this example (refer to figure 11.3).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉音频源要播放哪个声音剪辑。将一个音频文件从项目视图拖动到检查器中的音频剪辑槽；我们将使用这个示例的“壁炉”声音效果（参见图11.3）。
- en: '![CH11_F03_Hocking3](../Images/CH11_F03_Hocking3.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![CH11_F03_Hocking3](../Images/CH11_F03_Hocking3.png)'
- en: Figure 11.3 Settings for the AudioSource component
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 音频源组件的设置
- en: Skip down a bit in the settings and select both Play On Awake and Loop (of course,
    make sure that Mute isn’t checked). Play On Awake tells the audio source to begin
    playing as soon as the scene starts (in the next section, you’ll learn how to
    trigger sounds manually while the scene is running). Loop tells the audio source
    to keep playing continuously, repeating the audio clip when playback is over.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置中向下滚动一点，并选择播放于唤醒和循环（当然，确保没有勾选静音）。播放于唤醒告诉音频源在场景开始时立即开始播放（在下一节中，你将学习如何在场景运行时手动触发声音）。循环告诉音频源在播放结束后持续播放，重复音频剪辑。
- en: You want this audio source to project 3D sounds. As explained earlier, 3D sounds
    have a distinct position within the scene. That aspect of the audio source is
    adjusted using the Spatial Blend setting, which is a slider from 2D to 3D. Set
    it to 3D for this audio source.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望这个音频源能够投射3D声音。如前所述，3D声音在场景中有一个独特的位置。音频源的这个方面是通过空间混合设置进行调整的，这是一个从2D到3D的滑块。为此音频源将其设置为3D。
- en: Now play the game and make sure your speakers are turned on. You can hear a
    crackling fire coming from the enemy, and the sound becomes faint if you move
    away because you used a 3D audio source.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在播放游戏并确保你的扬声器已打开。你可以听到从敌人那里传来的噼啪声，如果你移动远离，声音会变得微弱，因为你使用了3D音频源。
- en: 11.2.3 Triggering sound effects from code
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 从代码中触发音效
- en: Setting the AudioSource component to play automatically is handy for some looping
    sounds, but for the majority of sound effects, you’ll want to trigger the sound
    with code commands. That approach still requires an AudioSource component, but
    now the audio source will play sound clips only when told to by the program, instead
    of automatically all the time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将 AudioSource 组件设置为自动播放对于一些循环音效很有用，但对于大多数音效，你将希望通过代码命令来触发音效。这种方法仍然需要一个 AudioSource
    组件，但现在音频源只有在程序告诉它时才会播放音剪辑，而不是始终自动播放。
- en: Add an AudioSource component to the player object (not the camera object). You
    don’t have to link in a specific audio clip because the audio clips will be defined
    in code. You can turn off Play On Awake because sounds from this source will be
    triggered in code. Also, adjust Spatial Blend to 3D because this sound is located
    in the scene. Now make the additions shown in the next listing to RayShooter,
    the script that handles shooting.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将 AudioSource 组件添加到玩家对象（不是相机对象）。你不需要链接特定的音频剪辑，因为音频剪辑将在代码中定义。你可以关闭 Play On Awake，因为来自此源的声音将在代码中触发。此外，将空间混合调整到
    3D，因为此声音位于场景中。现在，在处理射击的脚本 RayShooter 中添加下一列表中的添加内容。
- en: Listing 11.1 Sound effects added in the RayShooter script
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 在 RayShooter 脚本中添加的音效
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ References the two sound files you want to play
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 引用你想要播放的两个声音文件
- en: ❷ If target is not null, the player has hit an enemy, so . . .
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果目标不为空，则玩家击中了敌人，所以……
- en: ❸ . . . call PlayOneShot() to play the Hit An Enemy sound, or . . .
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ ……调用 PlayOneShot() 来播放击中敌人的声音，或者……
- en: ❹ . . . call PlayOneShot() to play the Hit A Wall sound if the player missed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ ……如果玩家未击中，则调用 PlayOneShot() 来播放击中墙壁的声音。
- en: The new code includes several serialized variables at the top of the script.
    Drag the player object (the object with an AudioSource component) to the soundSource
    slot in the Inspector. Then drag the audio clips to play onto the sound slots;
    “swish” is for hitting the wall, and “ding” is for hitting the enemy.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码在脚本顶部包含几个序列化变量。将玩家对象（具有 AudioSource 组件的对象）拖动到检查器中的 soundSource 槽。然后将要播放的音频剪辑拖动到音槽；“swish”用于击中墙壁，“ding”用于击中敌人。
- en: The other two lines added are PlayOneShot() methods. PlayOneShot() causes an
    audio source to play a given audio clip. Add those methods inside the target conditional
    to play sounds when various objects are hit.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的其他两行是 PlayOneShot() 方法。PlayOneShot() 会使音频源播放指定的音频剪辑。将这些方法添加到目标条件内部，以便在击中各种对象时播放声音。
- en: 'NOTE You could set the clip in the AudioSource and call Play() to play the
    clip. Multiple sounds would cut one another off, though, so we used PlayOneShot()
    instead. Replace PlayOneShot() with this code and shoot a bunch rapidly to see
    (er, hear) the problem: soundSource.clip=hitEnemySound; soundSource.Play();.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在 AudioSource 中设置剪辑并调用 Play() 来播放剪辑。但是，多个声音会相互切断，所以我们使用了 PlayOneShot()。用以下代码替换
    PlayOneShot() 并快速射击以查看（或者说，听到）问题：soundSource.clip=hitEnemySound; soundSource.Play();。
- en: All right, play the game and shoot around. You now have several sound effects
    in the game. These same basic steps can be used to add all sorts of sound effects.
    A robust sound system in a game requires a lot more than a bunch of disconnected
    sounds, though; at a minimum, all games should offer volume control. You’ll implement
    that control next through a central audio module.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，玩玩游戏，四处射击。你现在游戏中已经有了几个音效。这些基本步骤可以用来添加各种音效。然而，一个健壮的游戏音效系统需要的不仅仅是零散的声音；至少，所有游戏都应该提供音量控制。你将通过一个中央音频模块来实现这个控制功能。
- en: 11.3 Using the audio control interface
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 使用音频控制界面
- en: Continuing the code architecture established in previous chapters, you’re going
    to create an AudioManager. Recall that the Managers object has a master list of
    the various code modules used by the game, such as a manager for the player’s
    inventory. This time, you’ll create an audio manager to stick into the list. This
    central audio module will allow you to modulate the volume of audio in the game
    and even mute it. Initially, you’ll worry about only sound effects, but in later
    sections you’ll extend the AudioManager to handle music as well.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前几章中建立的代码架构，你将创建一个 AudioManager。回想一下，Managers 对象有一个用于游戏的各种代码模块的主列表，例如玩家库存的管理器。这次，你将创建一个音频管理器并将其添加到列表中。这个中央音频模块将允许你调节游戏中的音量，甚至可以静音。最初，你将只关注音效，但在后面的章节中，你将扩展
    AudioManager 以处理音乐。
- en: 11.3.1 Setting up the central AudioManager
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 设置中央 AudioManager
- en: The first step in setting up AudioManager is to put in place the Managers code
    framework. From the chapter 10 project, copy over IGameManager, ManagerStatus,
    and NetworkService; we won’t change them. (Remember that IGameManager is the interface
    that all managers must implement, whereas ManagerStatus is an enum that IGameManager
    uses. NetworkService provides calls to the internet and won’t be used in this
    chapter.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 AudioManager 的第一步是放置 Managers 代码框架。从第 10 章的项目中复制 IGameManager、ManagerStatus
    和 NetworkService；我们不会更改它们。（记住，IGameManager 是所有管理器必须实现的接口，而 ManagerStatus 是 IGameManager
    使用的枚举。NetworkService 提供对互联网的调用，在本章中不会使用。）
- en: NOTE Unity will probably issue a warning because NetworkService is assigned
    but not used. You can ignore Unity’s warning; we want to enable the code framework
    to access the internet, even though we don’t use that functionality in this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Unity 可能会发出警告，因为 NetworkService 已分配但未使用。您可以忽略 Unity 的警告；我们希望启用代码框架以访问互联网，尽管在本章中我们不使用该功能。
- en: Also copy over the Managers file, which will be adjusted for the new AudioManager.
    Leave it as is for now (or comment out the erroneous sections if the sight of
    compiler errors drives you crazy!). Create a new script called AudioManager that
    the Managers code can refer to.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 同时复制 Managers 文件，该文件将针对新的 AudioManager 进行调整。现在先保持原样（或者如果编译错误让您感到疯狂，可以注释掉错误部分！）创建一个新的脚本名为
    AudioManager，Manager 代码可以引用它。
- en: Listing 11.2 Skeleton code for AudioManager
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 AudioManager 的骨架代码
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Any long-running startup tasks go here.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 任何长时间运行的启动任务放在这里。
- en: ❷ Set status to Initializing if there are long-running startup tasks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果有长时间运行的启动任务，将状态设置为初始化。
- en: This initial code looks like managers from previous chapters; this is the minimum
    amount that IGameManager requires the class to implement. The Managers script
    can now be adjusted with the new manager.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这段初始代码看起来像前几章的管理器；这是 IGameManager 所需的最小实现量。现在可以调整 Manager 脚本以使用新的管理器。
- en: Listing 11.3 Managers script adjusted with AudioManager
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 使用 AudioManager 调整的 Managers 脚本
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ List only AudioManager in this project, instead of PlayerManager, and so on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在此项目中仅列出 AudioManager，而不是 PlayerManager 等。
- en: As you have in previous chapters, create the Game Managers object in the scene
    and then attach both Managers and AudioManager to the empty object. Playing the
    game will show the managers’ startup messages in the console, but the audio manager
    doesn’t do anything yet.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，在场景中创建 Game Managers 对象，然后将两个 Managers 和 AudioManager 都附加到空对象上。玩游戏将在控制台显示管理器的启动消息，但音频管理器目前还没有任何操作。
- en: 11.3.2 Volume control UI
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 音量控制 UI
- en: With the bare-bones AudioManager set up, it’s time to give it volume control
    functionality. These volume control methods will then be used by UI displays to
    mute the sound effects or adjust the volume.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好基本的 AudioManager 后，现在是时候给它添加音量控制功能了。这些音量控制方法将被 UI 显示用于静音音效或调整音量。
- en: 'You’ll use the UI tools that were the focus of chapter 7\. Specifically, you’re
    going to create a pop-up window with a button and a slider to control volume settings
    (see figure 11.4). I’ll list the steps involved without going into detail; if
    you need a refresher, refer to chapter 7\. If needed, install the TextMeshPro
    and 2D Sprite packages (refer back to chapters 5 and 6 for these) before starting:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用第 7 章中重点介绍的 UI 工具。具体来说，您将创建一个带有按钮和滑块的弹出窗口来控制音量设置（见图 11.4）。我将列出涉及的步骤而不深入细节；如果您需要复习，请参考第
    7 章。如果需要，在开始之前安装 TextMeshPro 和 2D Sprite 包（请参考第 5 章和第 6 章），然后：
- en: Import popup.png as a sprite (set Texture Type to Sprite).
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 popup.png 导入为精灵（设置纹理类型为精灵）。
- en: In the Sprite Editor, set a 12-pixel border on all sides (remember to apply
    changes).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在精灵编辑器中，在所有边设置 12 像素的边框（记得应用更改）。
- en: Create a canvas in the scene (GameObject > UI > Canvas).
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个画布（GameObject > UI > Canvas）。
- en: Turn on the Pixel Perfect setting for the canvas.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为画布开启像素完美设置。
- en: (Optional) Name the object HUD Canvas and switch to 2D view mode.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）将对象命名为 HUD Canvas 并切换到 2D 视图模式。
- en: Create an image connected to that canvas (GameObject > UI > Image).
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与该画布连接的图像（GameObject > UI > Image）。
- en: Name the new object Settings Popup.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新对象命名为设置弹出窗口。
- en: Assign the popup sprite to the image’s Source Image.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将弹出精灵分配给图像的源图像。
- en: Set Image Type to Sliced and turn on Fill Center.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像类型设置为 Sliced 并开启填充中心。
- en: Position the pop-up image at 0, 0 to center it.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将弹出图像定位在 0, 0 以居中。
- en: Scale the pop-up to 250 width and 150 height.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将弹出图像缩放为 250 宽度和 150 高度。
- en: Create a button (GameObject > UI > Button - TextMeshPro).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个按钮（GameObject > UI > Button - TextMeshPro）。
- en: Parent the button to the pop-up (drag it in the Hierarchy).
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮拖到弹出窗口中（在层次结构中拖动）。
- en: Position the button at 0, 40.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮放置在 0, 40 位置。
- en: Expand the button’s hierarchy to select its text label.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展按钮的层次结构以选择其文本标签。
- en: Change the text to Toggle Sound.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本更改为切换声音。
- en: Create a slider (GameObject > UI > Slider).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个滑块（GameObject > UI > Slider）。
- en: Parent the slider to the pop-up and position it at 0, 15.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将滑块拖到弹出窗口中，并放置在 0, 15 位置。
- en: Set the slider’s Value (at the bottom of the Inspector) to 1.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将滑块的值（检查器底部的值）设置为 1。
- en: '![CH11_F04_Hocking3](../Images/CH11_F04_Hocking3.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![CH11_F04_Hocking3](../Images/CH11_F04_Hocking3.png)'
- en: Figure 11.4 UI display for mute and volume control
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 静音和音量控制的 UI 显示
- en: Those are all the steps to create the settings pop-up! Now that the pop-up has
    been created, let’s write code that it’ll work with. This will involve a script
    on the pop-up object itself as well as the volume control functionality that the
    pop-up script calls. First, adjust the code in AudioManager according to this
    listing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是创建设置弹出窗口的所有步骤！现在弹出窗口已经创建，让我们编写与之协同工作的代码。这将涉及弹出窗口对象上的脚本以及弹出窗口脚本调用的音量控制功能。首先，根据此列表调整
    AudioManager 中的代码。
- en: Listing 11.4 Volume control added to AudioManager
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.4 添加到 AudioManager 的音量控制
- en: '[PRE3]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Property with getter and setter for volume
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 具有getter和setter的音量属性
- en: ❷ Implement the getter/setter using AudioListener.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 AudioListener 实现 getter/setter。
- en: ❸ Add a similar property to mute.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为静音添加一个类似的属性。
- en: ❹ Italicized code was already in script, shown here for reference.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 已在脚本中添加斜体代码，此处仅供参考。
- en: ❺ Initialize the value (0 to 1 range; 1 is full volume).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 初始化值（0 到 1 范围；1 为全音量）。
- en: 'Properties for soundVolume and soundMute were added to AudioManager. For both
    properties, the get and set functions were implemented using global values on
    AudioListener. The AudioListener class can modulate the volume of all sounds received
    by all AudioListener instances. Setting AudioManager’s soundVolume property has
    the same effect as setting the volume on AudioListener. The advantage here is
    encapsulation: everything having to do with audio is being handled in a single
    manager, without code outside the manager needing to know the details of the implementation.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 已为 AudioManager 添加了 soundVolume 和 soundMute 属性。对于这两个属性，get 和 set 函数都是通过在 AudioListener
    上使用全局值来实现的。AudioListener 类可以调节所有 AudioListener 实例接收到的所有声音的音量。设置 AudioManager 的
    soundVolume 属性与在 AudioListener 上设置音量具有相同的效果。这里的优势在于封装：所有与音频相关的事情都在一个管理器中处理，无需管理器外部的代码了解实现的细节。
- en: With those methods added to AudioManager, you can now write a script for the
    pop-up. Create a script called SettingsPopup and add the contents of this listing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在将那些方法添加到 AudioManager 后，你现在可以编写一个弹出窗口的脚本。创建一个名为 SettingsPopup 的脚本，并添加此列表的内容。
- en: Listing 11.5 SettingsPopup script with controls for adjusting the volume
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.5 用于调整音量的 SettingsPopup 脚本
- en: '[PRE4]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Button will toggle the mute property of AudioManager.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 按钮将切换 AudioManager 的静音属性。
- en: ❷ Slider will adjust the volume property of AudioManager.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 滑块将调整 AudioManager 的音量属性。
- en: 'This script has two methods that affect the properties of AudioManager: OnSoundToggle()
    sets the soundMute property, and OnSoundValue() sets the soundVolume property.
    As usual, link in the SettingsPopup script by dragging it onto the Settings Popup
    object in the UI.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本有两个影响 AudioManager 属性的方法：OnSoundToggle() 设置 soundMute 属性，而 OnSoundValue()
    设置 soundVolume 属性。像往常一样，通过将脚本拖到 UI 中的 Settings Popup 对象上链接 SettingsPopup 脚本。
- en: Then, to call the functions from the button and slider, link the pop-up object
    to interaction events in those controls. In the Inspector for the button, look
    for the panel labeled On Click. Click the + button to add a new entry to this
    event. Drag Settings Popup to the object slot in the new entry and then look for
    SettingsPopup in the menu; select OnSoundToggle() to make the button call that
    function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了从按钮和滑块中调用函数，将弹出窗口对象链接到那些控件中的交互事件。在按钮的检查器中，寻找标有 On Click 的面板。点击 + 按钮向此事件添加一个新条目。将
    Settings Popup 拖到新条目中的对象槽位，然后在菜单中查找 SettingsPopup；选择 OnSoundToggle() 以使按钮调用该函数。
- en: Now select the slider and link a function, just as you did with the button.
    First look for the interaction event in a panel of the slider’s settings; in this
    case, the panel is called OnValueChanged. Click the + button to add a new entry
    and then drag Settings Popup to the object slot. In the function menu, find the
    SettingsPopup script and then choose OnSoundValue() under Dynamic Float.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选择滑块并链接一个函数，就像您处理按钮时做的那样。首先在滑块设置的面板中查找交互事件；在这种情况下，面板被称为 OnValueChanged。点击
    + 按钮添加一个新条目，然后将设置弹出窗口拖到对象槽位。在函数菜单中，找到 SettingsPopup 脚本，然后选择动态浮点下的 OnSoundValue()。
- en: WARNING Remember to choose the function under Dynamic Float and not Static Parameter!
    Although the method appears in both sections of the list, in the latter case it
    will receive only a single value typed in ahead of time.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：请记住选择动态浮点函数下的功能，而不是静态参数！尽管该方法出现在列表的两个部分中，但在后一种情况下，它将只接收预先输入的一个值。
- en: The settings controls are now working, but we need to address one more script—the
    pop-up is currently always covering up the screen. A simple fix is to make the
    pop-up open only when you press the M key. Create a new script called UIController,
    link that script to the controller object in the scene, and write this code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 设置控制现在正在工作，但我们还需要解决一个脚本问题——弹出窗口目前总是覆盖整个屏幕。一个简单的解决方案是使弹出窗口仅在您按下 M 键时打开。创建一个新的脚本名为
    UIController，将其链接到场景中的控制器对象，并编写以下代码。
- en: Listing 11.6 UIController that toggles the settings pop-up
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 UIController 切换设置弹出窗口
- en: '[PRE5]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ References the pop-up object in the scene
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 引用场景中的弹出对象
- en: ❷ Initializes the hidden pop-up
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始化隐藏的弹出窗口
- en: ❸ Toggles the pop-up with the M key
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 M 键切换弹出窗口
- en: ❹ Also toggles the cursor along with the pop-up
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 同时切换光标和弹出窗口
- en: To wire up this object reference, drag the settings pop-up to the slot on this
    script. Play now and try changing the slider (remember to activate the UI by pressing
    the M key) while shooting around to hear the sound effects; you’ll hear the sound
    effects change volume according to the slider.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接此对象引用，将设置弹出窗口拖到脚本上的槽位。现在播放并尝试更改滑块（记得通过按 M 键激活 UI）并在射击时听声音效果；您会听到声音效果根据滑块改变音量。
- en: 11.3.3 Playing UI sounds
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3 播放 UI 声音
- en: You’re going to make another addition to AudioManager now to allow the UI to
    play sounds when buttons are clicked. This task is more involved than it seems
    at first, owing to Unity’s need for an AudioSource. When sound effects were issued
    from objects in the scene, it was fairly obvious where to attach the AudioSource.
    But UI sound effects aren’t part of the scene, so you’ll set up a special AudioSource
    for AudioManager to use when there isn’t any other audio source.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将向 AudioManager 添加另一个功能，以便在按钮被点击时 UI 可以播放声音。这项任务比最初看起来更复杂，因为 Unity 需要一个
    AudioSource。当场景中的对象发出声音效果时，很明显应该将 AudioSource 附加在哪里。但 UI 声音效果不是场景的一部分，因此您将为 AudioManager
    设置一个特殊的 AudioSource，以便在没有其他音频源时使用。
- en: Create a new empty GameObject and attach it as a child of the main Game Managers
    object; this new object is going to have an AudioSource used by AudioManager,
    so call the new object Audio. Add an AudioSource component to this object (leave
    the Spatial Blend setting at 2D this time, because the UI doesn’t have a specific
    position in the scene) and then add this code to use this source in AudioManager.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的空 GameObject 并将其附加为主游戏管理器对象的子对象；这个新对象将使用 AudioManager 的 AudioSource，因此将新对象命名为
    Audio。向此对象添加一个 AudioSource 组件（这次保留 Spatial Blend 设置为 2D，因为 UI 在场景中没有特定的位置），然后添加以下代码以在
    AudioManager 中使用此源。
- en: Listing 11.7 Playing sound effects in AudioManager
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7 在 AudioManager 中播放声音效果
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Variable slot in the Inspector to reference the new audio source
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在检查器中的变量槽位引用新的音频源
- en: ❷ Play sounds that don’t have any other source.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 播放没有其他来源的声音。
- en: A new variable slot will appear in the manager’s Inspector; drag the Audio object
    onto this slot. Now modify the pop-up script (as shown in the following listing)
    to add the UI sound effect.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理器的检查器中会出现一个新的变量槽位；将 Audio 对象拖到这个槽位上。现在修改弹出脚本（如下所示）以添加 UI 声音效果。
- en: Listing 11.8 Adding sound effects to SettingsPopup
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.8 向 SettingsPopup 添加声音效果
- en: '[PRE7]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Inspector slot to reference the sound clip
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 引用声音片段的检查器槽位
- en: ❷ Play the sound effect when the button is clicked.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当按钮被点击时播放声音效果。
- en: Drag the UI sound effect onto the variable slot; I used the 2D sound “thump.”
    When you click the UI button, that sound effect plays at the same time (when the
    sound isn’t muted, of course!). Even though the UI doesn’t have an audio source
    itself, AudioManager has an audio source that plays the sound effect.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将UI音效拖到变量槽中；我使用了2D音效“thump。”当你点击UI按钮时，该音效会同时播放（当然，如果声音没有被静音的话！）尽管UI本身没有音频源，但AudioManager有一个播放音效的音频源。
- en: Great, we’ve set up all our sound effects! Now let’s turn our attention to music.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们已经设置好了所有的音效！现在让我们把注意力转向音乐。
- en: 11.4 Adding background music
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 添加背景音乐
- en: You’re going to add background music to the game, and you’ll do that by adding
    music to AudioManager. As explained in the chapter introduction, music clips aren’t
    fundamentally different from sound effects. The way digital audio functions through
    waveforms is the same, and the commands for playing the audio are largely the
    same. The main difference is the length of the audio, but that difference cascades
    out into numerous consequences.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你将向游戏中添加背景音乐，你将通过向AudioManager添加音乐来实现这一点。如章节引言中所述，音乐剪辑在本质上与音效没有区别。数字音频通过波形工作的方式相同，播放音频的命令也大致相同。主要区别是音频的长度，但这种差异会引发许多后果。
- en: 'For starters, music tracks tend to consume a large amount of memory on the
    computer, and that memory consumption must be optimized. You must watch out for
    two areas of memory issues: having the music loaded into memory before it’s needed,
    and consuming too much memory when loaded.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，音乐曲目往往会在计算机上消耗大量内存，并且必须优化这种内存消耗。你必须注意两个内存问题区域：在需要之前将音乐加载到内存中，以及加载时消耗过多内存。
- en: 'Optimizing *when* music loads is done using the Resources.Load() command introduced
    in chapter 9\. As you learned, this command allows you to load assets by name.
    Though that’s certainly one handy feature, that’s not the only reason to load
    assets from the Resources folder. Another key consideration is delaying loading:
    normally, Unity loads all assets in a scene as soon as the scene loads, but assets
    from Resources aren’t loaded until the code manually fetches them. In this case,
    we want to *lazy-load* the audio clips for music. Otherwise, the music could consume
    a lot of memory even when it isn’t being used.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第9章中介绍的Resources.Load()命令优化音乐加载的时间。正如你所学的，这个命令允许你按名称加载资源。尽管这确实是一个方便的功能，但这不是从Resources文件夹加载资源的唯一原因。另一个关键考虑因素是延迟加载：通常，Unity在场景加载时立即加载场景中的所有资源，但来自Resources的资源只有在代码手动获取它们时才会加载。在这种情况下，我们想要**懒加载**音乐音频剪辑。否则，即使音乐没有被使用，它也可能消耗大量内存。
- en: DEFINITION With *lazy loading*, a file isn’t loaded ahead of time but rather
    is delayed until it’s needed. Typically, data responds faster (for example, the
    sound plays immediately) if it’s loaded in advance of use, but lazy loading can
    save a lot of memory when responsiveness doesn’t matter as much.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 使用**懒加载**，文件不是提前加载，而是在需要时才延迟加载。通常，如果数据在使用前提前加载，响应速度会更快（例如，声音会立即播放），但懒加载可以在响应性不是很重要的情况下节省大量内存。'
- en: The second memory consideration is dealt with by streaming music off the disc.
    As explained in section 11.1.2, streaming the audio saves the computer from ever
    needing to have the entire file loaded at once. The style of loading was a setting
    in the Inspector of the imported audio clip. Ultimately, playing background music
    requires several steps, including steps to cover these memory optimizations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个内存考虑因素是通过从光盘流式传输音乐来处理的。如第11.1.2节所述，流式传输音频可以防止计算机需要一次性加载整个文件。加载风格是导入音频剪辑检查器中的一个设置。最终，播放背景音乐需要几个步骤，包括覆盖这些内存优化步骤。
- en: 11.4.1 Playing music loops
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1 播放音乐循环
- en: 'The process of playing music involves the same series of steps as UI sound
    effects did (background music is also 2D sound without a source within the scene),
    so we’re going to go through all those steps again:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 播放音乐的过程涉及与UI音效相同的步骤序列（背景音乐也是场景内没有源的2D声音），因此我们将再次走完所有这些步骤：
- en: Importing audio clips.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入音频剪辑。
- en: Setting up an AudioSource for AudioManager to use.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为AudioManager设置AudioSource。
- en: Writing code to play the audio clips in AudioManager.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码在AudioManager中播放音频剪辑。
- en: Adding music controls to the UI.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将音乐控件添加到用户界面中。
- en: Each step will be modified slightly to work with music instead of sound effects.
    Let’s look at the first step.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每个步骤都将略微修改以适应音乐而不是音效。让我们看看第一步。
- en: 'Step 1: Importing audio clips'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第1步：导入音频剪辑
- en: 'Obtain some music by downloading or recording tracks. For the sample project,
    I went to [www.freesound.org](https://freesound.org/) and downloaded the following
    public domain music loops:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过下载或录制曲目来获取一些音乐。对于示例项目，我去了[www.freesound.org](https://freesound.org/)并下载了以下公共领域的音乐循环：
- en: “loop” by Xythe/Ville Nousiainen
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “loop” by Xythe/Ville Nousiainen
- en: “Intro Synth” by noirenex
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Intro Synth” by noirenex
- en: Drag the files into Unity to import them and then adjust their import settings
    in the Inspector. As explained earlier, audio clips for music generally have different
    settings than audio clips for sound effects. First, the audio format should be
    set to Vorbis, for compressed audio. Remember, compressed audio will have a significantly
    smaller file size. Compression also degrades the audio quality slightly, but that
    slight degradation is an acceptable trade-off for long music clips; set Quality
    to 50% in the slider that appears.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件拖入Unity以导入它们，然后在检查器中调整它们的导入设置。如前所述，音乐音频剪辑通常具有与音效音频剪辑不同的设置。首先，音频格式应设置为Vorbis，用于压缩音频。记住，压缩音频将具有显著较小的文件大小。压缩也会稍微降低音频质量，但对于较长的音乐剪辑来说，这种轻微的降级是可以接受的折衷方案；在出现的滑块中将质量设置为50%。
- en: The next import setting to adjust is Load Type. Again, music should stream from
    the disc rather than being loaded completely. Choose Streaming from the Load Type
    menu. Similarly, turn on Load In Background so that the game won’t pause or slow
    down while music is loading.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要调整的下一个导入设置是加载类型。同样，音乐应从光盘流式传输，而不是完全加载。从加载类型菜单中选择流式传输。同样，打开后台加载，这样在音乐加载时游戏不会暂停或减慢。
- en: Even after you adjust all the import settings, the asset files must be moved
    to the correct location in order to load correctly. Remember that the Resources.Load()
    command requires the assets to be in the Resources folder. Create a new folder
    called Resources, create a folder within that called Music, and drag the audio
    files into the Music folder (see figure 11.5). That takes care of step 1.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 即使调整了所有导入设置，资产文件也必须移动到正确的位置才能正确加载。记住，Resources.Load()命令要求资产在Resources文件夹中。创建一个名为Resources的新文件夹，在该文件夹内创建一个名为Music的文件夹，并将音频文件拖入Music文件夹（见图11.5）。这样就完成了第1步。
- en: '![CH11_F05_Hocking3](../Images/CH11_F05_Hocking3.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![CH11_F05_Hocking3](../Images/CH11_F05_Hocking3.png)'
- en: Figure 11.5 Music audio clips placed inside the Resources folder
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 音乐音频剪辑放置在Resources文件夹内
- en: 'Step 2: Setting up an AudioSource for AudioManager to use'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步：为AudioManager设置AudioSource
- en: Step 2 is to create a new AudioSource for music playback. Create another empty
    GameObject, name this object Music 1 (instead of Music because we’ll add Music
    2 later in the chapter), and attach it as a child of the Audio object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步是创建一个新的AudioSource以播放音乐。创建另一个空的GameObject，将此对象命名为Music 1（而不是Music，因为我们将在本章后面添加Music
    2），并将其作为Audio对象的子对象。
- en: Add an AudioSource component to Music 1 and then adjust the settings in the
    component. Deselect Play On Awake but turn on the Loop option this time; whereas
    sound effects usually play only once, music plays over and over in a loop. Leave
    the Spatial Blend setting at 2D, because music doesn’t have any specific position
    in the scene.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将音频源组件添加到Music 1，然后调整组件中的设置。取消选择“唤醒时播放”，但这次打开循环选项；而音效通常只播放一次，音乐则反复循环播放。将空间混合设置保留在2D，因为音乐在场景中没有特定的位置。
- en: You may want to reduce the Priority value too. For sound effects, this value
    didn’t matter, so we left the value at the default 128\. But for music, you probably
    want to lower this value, so I set the music source to 60. This value tells Unity
    which sounds are most important when layering multiple sounds; somewhat counterintuitively,
    lower values are higher priority. When too many sounds are playing simultaneously,
    the audio system will start discarding sounds; by making music higher priority
    than sound effects, you ensure that the music will keep playing when too many
    sound effects trigger at the same time.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想降低优先级值。对于音效，这个值并不重要，所以我们将其保留在默认的128。但对于音乐，您可能希望降低这个值，所以我将音乐源设置为60。这个值告诉Unity在分层多个声音时哪些声音最重要；有些反直觉，较低的值具有更高的优先级。当同时播放太多声音时，音频系统将开始丢弃声音；通过使音乐比音效具有更高的优先级，您确保当太多音效同时触发时，音乐仍然会播放。
- en: 'Step 3: Writing code to play the audio clips in AudioManager'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步：编写代码在AudioManager中播放音频剪辑
- en: The Music audio source has been set up, so add the following listing to AudioManager.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐音频源已经设置好了，所以将以下条目添加到AudioManager。
- en: Listing 11.9 Playing music in AudioManager
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.9 在AudioManager中播放音乐
- en: '[PRE8]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Write music names in these strings.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在这些字符串中写入音乐名称。
- en: ❷ Load intro music from Resources.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从资源中加载开场音乐。
- en: ❸ Load main music from Resources.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从资源中加载主音乐。
- en: ❹ Play music by setting AudioSource.clip.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通过设置AudioSource.clip来播放音乐。
- en: 'As usual, the new serialized variables will be visible in the Inspector when
    you select the Game Managers object. Drag Music 1 into the audio source slot.
    Then type in the names of the music files in the two string variables: intro-synth
    and loop.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，当你选择Game Managers对象时，新的序列化变量将在检查器中可见。将Music 1拖入音频源槽中。然后在两个字符串变量中输入音乐文件的名称：intro-synth和loop。
- en: The remainder of the added code calls commands for loading and playing music
    (or, in the last added method, stopping the music). The Resources.Load() command
    loads the named asset from the Resources folder (taking into account that the
    files are placed in the Music subfolder within Resources). A generic object is
    returned by that command, but the object can be converted to a more specific type
    (in this case, an AudioClip) by using the as keyword.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的其余代码调用加载和播放音乐的命令（或者在最后添加的方法中，停止音乐）。Resources.Load()命令从资源文件夹中加载命名的资产（考虑到文件被放置在资源文件夹内的Music子文件夹中）。该命令返回一个通用对象，但可以通过使用as关键字将该对象转换为更具体的类型（在这种情况下，是AudioClip）。
- en: The loaded audio clip is then passed into the PlayMusic() method. This function
    sets the clip in the AudioSource and then calls Play(). As I explained earlier,
    sound effects are better implemented using PlayOneShot(), but setting the clip
    in the AudioSource is a more robust approach for music, allowing you to stop or
    pause the playing music.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 加载的音频剪辑随后传递到PlayMusic()方法。此函数将剪辑设置在AudioSource中，然后调用Play()。正如我之前解释的，使用PlayOneShot()实现音效更好，但将剪辑设置在AudioSource中是音乐的一个更稳健的方法，允许你停止或暂停正在播放的音乐。
- en: 'Step 4: Adding music controls to the UI'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步：向UI添加音乐控制
- en: 'The new music playback methods in AudioManager won’t do anything unless they’re
    called from elsewhere. Let’s add more buttons to the audio UI that will play different
    music when clicked. Here are the steps again, enumerated with little explanation
    (refer to chapter 7 if needed):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: AudioManager中的新音乐播放方法除非在其他地方被调用，否则不会做任何事情。让我们添加更多按钮到音频UI，当点击时将播放不同的音乐。以下是步骤再次列出，附带少量解释（如有需要，请参阅第7章）：
- en: Change the pop-up’s width to 350 (to fit more buttons).
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将弹出窗口的宽度更改为350（以容纳更多按钮）。
- en: Create a new UI button and attach it to the pop-up.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的UI按钮并将其附加到弹出窗口。
- en: Set the button’s width to 100 and position to 0, -20.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮的宽度设置为100，位置为0, -20。
- en: Expand the button’s hierarchy to select the text label and set that to Level
    Music.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开按钮的层级以选择文本标签，并将其设置为Level Music。
- en: Repeat these steps twice more to create two additional buttons.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复这些步骤两次，以创建两个额外的按钮。
- en: Position one at -105, -20 and the other at 105, -20 (so they appear on either
    side).
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个放置在-105, -20的位置，另一个放置在105, -20的位置（这样它们会出现在两侧）。
- en: Change the first text label to Intro Music and the last text label to No Music.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个文本标签更改为Intro Music，最后一个文本标签更改为No Music。
- en: Now the pop-up has three buttons for playing different music. Write a method
    in SettingsPopup that will be linked to each button.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在弹出窗口有三个按钮用于播放不同的音乐。在SettingsPopup中编写一个方法，该方法将与每个按钮相关联。
- en: Listing 11.10 Adding music controls to SettingsPopup
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.10 向SettingsPopup添加音乐控制
- en: '[PRE9]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ This method gets a number parameter from the button.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此方法从按钮获取一个数字参数。
- en: ❷ Call a different music function in AudioManager for each button.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为每个按钮调用AudioManager中的不同音乐函数。
- en: Note that the function takes an int parameter this time; normally, button methods
    don’t have a parameter and are simply triggered by the button. In this case, we
    need to distinguish between the three buttons, so each button will send a different
    number.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次函数接受一个int参数；通常，按钮方法没有参数，只是通过按钮触发。在这种情况下，我们需要区分三个按钮，因此每个按钮将发送不同的数字。
- en: 'Go through the typical steps to connect a button to this code: add an entry
    to the On Click panel in the Inspector, drag the pop-up to the object slot, and
    choose the appropriate function from the menu. This time, a text box for typing
    in a number is displayed, because OnPlayMusic() takes a number for a parameter.
    Type 1 for Intro Music, 2 for Level Music, and anything else for No Music (I went
    with 0). The switch statement in OnMusic() plays intro music or level music, depending
    on the number, or stops the music as a default if the number isn’t 1 or 2.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 按照典型的步骤将按钮连接到这段代码：在检查器中的OnClick面板中添加一个条目，将弹出窗口拖到对象槽中，并从菜单中选择适当的函数。这次，显示了一个用于输入数字的文本框，因为OnPlayMusic()需要一个数字作为参数。输入1表示开场音乐，2表示关卡音乐，其他任何内容表示没有音乐（我选择了0）。OnMusic()中的switch语句根据数字播放开场音乐或关卡音乐，如果数字不是1或2，则默认停止音乐。
- en: 'When you click the music buttons while the game is playing, you’ll hear the
    music. Great! The code is loading the audio clips from the Resources folder. Music
    plays efficiently, although we still have two bits of polish to add: separate
    music volume control and cross-fading when changing the music.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在游戏播放时点击音乐按钮，你会听到音乐。太好了！代码正在从Resources文件夹中加载音频剪辑。音乐播放效率很高，尽管我们仍然需要添加两个细节：单独的音乐音量控制和在更改音乐时的淡入淡出。
- en: 11.4.2 Controlling music volume separately
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.2 单独控制音乐音量
- en: The game already has volume control, and currently that affects the music too.
    Most games have separate volume controls for sound effects and music, though,
    so let’s tackle that now.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏已经有了音量控制，目前这也影响了音乐。不过，大多数游戏都有单独的音效和音乐音量控制，所以让我们现在解决这个问题。
- en: The first step is to tell the music AudioSource to ignore the settings on Audio-
    Listener. We want volume and mute on the global AudioListener to continue to affect
    all sound effects, but we don’t want this volume to apply to music. Listing 11.10
    includes code to tell the music source to ignore the volume on AudioListener.
    The following listing also adds volume control and mute for music, so add it to
    AudioManager.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是告诉音乐AudioSource忽略AudioListener上的设置。我们希望全局AudioListener的音量和静音设置继续影响所有音效，但我们不希望这个音量应用于音乐。列表11.10包含了告诉音乐源忽略AudioListener音量的代码。接下来的列表还添加了音乐音量和静音控制，所以将其添加到AudioManager。
- en: Listing 11.11 Controlling music volume separately in AudioManager
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.11 在AudioManager中单独控制音乐音量
- en: '[PRE10]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Private variable that won’t be accessed directly, only through the property’s
    getter
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 私有变量，不会直接访问，只能通过属性的getter访问
- en: ❷ Adjust volume of the AudioSource directly.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 直接调整AudioSource的音量。
- en: ❸ Default value in case the AudioSource is missing
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果AudioSource缺失时的默认值
- en: ❹ Italicized code was already in script, shown here for reference.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 已在脚本中使用的斜体代码，此处展示以供参考。
- en: ❺ These properties tell the AudioSource to ignore the AudioListener volume.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 这些属性告诉AudioSource忽略AudioListener的音量。
- en: The key to this code is realizing you can adjust the volume of an AudioSource
    directly, even though that audio source is ignoring the global volume defined
    in AudioListener. Properties for both volume and mute manipulate the individual
    music source.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的关键是意识到你可以直接调整AudioSource的音量，即使这个音频源正在忽略在AudioListener中定义的全局音量。音量和静音属性都用于操作单个音乐源。
- en: The Startup() method initializes the music source with both ignoreListenerVolume
    and ignoreListenerPause turned on. As the names suggest, those properties cause
    the audio source to ignore the global volume setting on AudioListener.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Startup()方法将ignoreListenerVolume和ignoreListenerPause都设置为开启，初始化音乐源。正如其名称所暗示的，这些属性导致音频源忽略AudioListener上的全局音量设置。
- en: You can click Play now to verify that the music is no longer affected by the
    existing volume control. Let’s add a second UI control for the music volume; start
    by adjusting SettingsPopup.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击“播放”现在来验证音乐不再受现有音量控制的影响。让我们为音乐音量添加第二个UI控制；首先调整SettingsPopup。
- en: Listing 11.12 Music volume controls in SettingsPopup
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.12 在SettingsPopup中的音乐音量控制
- en: '[PRE11]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Repeat the mute control, but use musicMute instead.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 重复静音控制，但使用musicMute。
- en: ❷ Repeat the volume control, but use musicVolume instead.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 重复音量控制，但使用musicVolume。
- en: This code doesn’t need a lot of explaining—it’s mostly repeating the sound volume
    controls. Obviously, the AudioManager properties used have changed from soundMute/
    soundVolume to musicMute/musicVolume.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不需要太多解释——它主要是重复声音音量控制。显然，使用的AudioManager属性已经从soundMute/soundVolume更改为musicMute/musicVolume。
- en: 'In the editor, create a button and slider, as you did before. Here are those
    steps again:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中，创建一个按钮和滑块，就像你之前做的那样。以下步骤再次列出：
- en: Change the pop-up’s height to 225 (to fit more controls).
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将弹出窗口的高度更改为225（以容纳更多控件）。
- en: Create a UI button.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个UI按钮。
- en: Parent the button to the pop-up.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮作为父级添加到弹出窗口中。
- en: Position the button at 0, -60.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮定位在0, -60。
- en: Expand the button’s hierarchy to select its text label.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开按钮的层次结构以选择其文本标签。
- en: Change the text to Toggle Music.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本更改为切换音乐。
- en: Create a slider (from the same UI menu).
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个滑块（来自相同的UI菜单）。
- en: Parent the slider to the pop-up and position it at 0, -85.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将滑块作为父级添加到弹出窗口中，并将其定位在0, -85。
- en: Set the slider’s Value (at the bottom of the Inspector) to 1.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将滑块的值（在检查器的底部）设置为1。
- en: Link these UI controls to the code in SettingsPopup. Find the On Click/OnValueChanged
    panel in the UI element’s settings, click the + button to add an entry, drag the
    pop-up object to the object slot, and select the function from the menu. The functions
    you need to pick are OnMusicToggle() and OnMusicValue() from the Dynamic Float
    section of the menu.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些UI控件链接到SettingsPopup中的代码。在UI元素的设置中找到OnClick/OnValueChanged面板，点击+按钮添加条目，将弹出对象拖到对象槽中，并从菜单中选择函数。您需要选择的函数是Dynamic
    Float部分中的OnMusicToggle()和OnMusicValue()。
- en: 'Run this code and you’ll see that the controls affect sound effects and music
    separately. This is getting pretty sophisticated, but one more bit of polish remains:
    cross-fade between music tracks.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码，你会看到控件分别影响音效和音乐。这已经很复杂了，但还有一个细节需要润色：音乐轨道之间的交叉淡入淡出。
- en: 11.4.3 Fading between songs
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.3 在歌曲之间淡入淡出
- en: As a final bit of polish, let’s make AudioManager fade in and out between different
    background tunes. Currently, the switch between music tracks is pretty jarring,
    with the sound suddenly cutting off and changing to the new track. We can smooth
    out that transition by having the volume of the previous track quickly dwindle
    away while the volume quickly rises from 0 on the new track. This is a simple
    but clever bit of code that combines both the volume control methods you just
    saw, along with a coroutine to change the volume incrementally over time.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的润色，让我们让AudioManager在不同的背景曲调之间淡入淡出。目前，音乐轨道之间的切换相当刺耳，声音突然切断并切换到新轨道。我们可以通过让上一个轨道的音量迅速减少，同时新轨道的音量从0迅速上升来平滑这个过渡。这是一段简单但巧妙的代码，结合了你刚才看到的音量控制方法，以及一个协程来随时间逐步改变音量。
- en: 'Listing 11.13 adds a lot of bits to AudioManager, but most revolve around a
    simple concept: now that we have two separate audio sources, we’ll play separate
    music tracks on separate audio sources, and incrementally increase the volume
    of one source while simultaneously decreasing the volume of the other. (As usual,
    italicized code was already in the script and is shown here for reference.)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.13向AudioManager添加了许多位，但大多数都围绕一个简单的概念：既然我们现在有两个独立的音频源，我们将在不同的音频源上播放不同的音乐轨道，并逐步增加一个源的音量，同时同时降低另一个源的音量。（如往常一样，斜体代码已经在脚本中，这里显示以供参考。）
- en: Listing 11.13 Cross-fading between music in AudioManager
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.13 在AudioManager中实现音乐之间的交叉淡入淡出
- en: '[PRE12]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Second AudioSource (keep the first, too)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 第二个AudioSource（也要保留第一个）
- en: ❷ Keep track of which source is active vs. inactive.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 跟踪哪个源是活动的，哪个是未活动的。
- en: ❸ A toggle to avoid bugs while a cross-fade is happening
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在交叉淡入淡出发生时避免错误的切换
- en: ❹ Adjust the volume on both music sources.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 调整两个音乐源的音量。
- en: ❺ Initialize one as the active AudioSource.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将一个初始化为活动的AudioSource。
- en: ❻ Call a coroutine when changing music.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在更改音乐时调用协程。
- en: ❼ Yield statement pauses for one frame.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ Yield语句暂停一帧。
- en: ❽ Temporary variable to use while swapping active and inactive
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 在交换活动和未活动时使用的临时变量
- en: The first addition is a variable for the second music source. While keeping
    the first AudioSource object, duplicate that object (make sure the settings are
    the same—select Loop) and then drag the new object into this Inspector slot. The
    code also defines the AudioSource variables activeMusic and inactiveMusic, but
    those are private variables used within the code and not exposed in the Inspector.
    Specifically, those variables define which of the two audio sources is considered
    active or inactive at any given time.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个添加是为第二个音乐源创建的变量。在保留第一个AudioSource对象的同时，复制该对象（确保设置相同——选择Loop），然后将新对象拖到这个检查器槽中。代码还定义了activeMusic和inactiveMusic这两个AudioSource变量，但这些都是代码内部使用的私有变量，不在检查器中暴露。具体来说，这些变量定义了在任何给定时间哪个音频源被认为是活动的或未活动的。
- en: The code now calls a coroutine when playing new music. This coroutine sets the
    new music playing on one AudioSource while the old music keeps playing on the
    old AudioSource. Then, the coroutine incrementally increases the volume of the
    new music while incrementally decreasing the volume of the old music. Once the
    cross-fading is complete (that is, the volumes have completely exchanged places),
    the function swaps which audio source is considered active and inactive.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码在播放新音乐时会调用一个协程。这个协程在保持旧音乐在旧AudioSource上播放的同时，将新音乐设置在新的AudioSource上播放。然后，协程逐渐增加新音乐的音量，同时逐渐减少旧音乐的音量。一旦交叉淡入淡出完成（即音量完全交换），函数会交换哪个音频源被认为是活动状态和无效状态。
- en: Great! We’ve completed the background music for our game’s audio system.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经完成了游戏音频系统的背景音乐。
- en: Advanced game audio plugins for FMOD and Wwise
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 高级游戏音频插件，适用于FMOD和Wwise
- en: 'The audio system in Unity is powered by FMOD, a popular audio programming library.
    Unity has integrated many features of FMOD, but more advanced audio features are
    accessible through FMOD Studio, with a plugin offered at [www.fmod.com/unity/](https://www.fmod.com/unity/).
    Alternatively, Wwise is a different audio system that also offers a Unity plugin:
    [http://mng.bz/6mvD](http://mng.bz/6mvD).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的音频系统由FMOD提供支持，这是一个流行的音频编程库。Unity集成了FMOD的许多功能，但更高级的音频功能可以通过FMOD Studio访问，该插件可在[www.fmod.com/unity/](https://www.fmod.com/unity/)获取。或者，Wwise是另一个音频系统，它也提供了一个Unity插件：[http://mng.bz/6mvD](http://mng.bz/6mvD)。
- en: The examples in this chapter stick to the functionality built into Unity, because
    that core functionality comprises the most important features for a game’s audio
    system. Most game developers have their audio needs served quite well by this
    core functionality, but these plugins are useful for those wishing to get even
    more intricate with their game’s audio.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例坚持使用Unity内置的功能，因为核心功能构成了游戏音频系统最重要的功能。大多数游戏开发者通过这些核心功能就能很好地满足他们的音频需求，但这些插件对于那些希望使游戏音频更加复杂的人来说是有用的。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Sound effects should be uncompressed audio, and music should be compressed,
    but use the WAV format for both because Unity applies compression to imported
    audio.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音效应该是未压缩的音频，音乐应该是压缩的，但两者都使用WAV格式，因为Unity会对导入的音频应用压缩。
- en: Audio clips can be 2D sounds that always play the same, or 3D sounds that react
    to the listener’s position.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频剪辑可以是始终播放相同的2D声音，或者是对听众位置做出反应的3D声音。
- en: The volume of sound effects is easily adjusted globally using Unity’s AudioListener.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity的AudioListener可以轻松全局调整音效的音量。
- en: You can set the volume on individual audio sources that play music.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为播放音乐的各个音频源设置音量。
- en: You can fade background music in and out by setting the volume on individual
    audio sources.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过设置各个音频源的音量来淡入淡出背景音乐。
