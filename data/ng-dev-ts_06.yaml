- en: Chapter 7\. Laying out pages with Flex Layout
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 7 章\. 使用 Flex Layout 布局页面
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Implementing responsive web design using the Flex Layout library
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Flex Layout 库实现响应式网页设计
- en: Using the `ObservableMedia` service
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ObservableMedia` 服务
- en: Changing the layout based on the viewport size
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据视口大小更改布局
- en: When it comes to developing a web app, you need to decide whether you’ll have
    separate apps for desktop and mobile versions or reuse the same code on all devices.
    The former approach allows you to use the native controls on mobile devices so
    the UI looks more natural, but you need to maintain separate versions of the code
    for each app. The latter approach is to use a single code base and implement *responsive
    web design* (RWD) so the UI layout will adapt to the device screen size.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到开发网络应用程序时，你需要决定你是否将为桌面和移动版本创建单独的应用程序，或者是否在所有设备上重用相同的代码。前者方法允许你使用移动设备上的原生控件，从而使
    UI 看起来更自然，但你需要为每个应用程序维护代码的单独版本。后者方法是使用单个代码库并实现 *响应式网页设计*（RWD），以便 UI 布局将适应设备屏幕尺寸。
- en: '|  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-7
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The term RWD was coined by Ethan Marcotte in the article “Responsive Web Design,”
    available at [http://alistapart.com/article/responsive-web-design](http://alistapart.com/article/responsive-web-design).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 RWD 是由 Ethan Marcotte 在文章“Responsive Web Design”（可在 [http://alistapart.com/article/responsive-web-design](http://alistapart.com/article/responsive-web-design)
    查找）中提出的。
- en: '|  |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'There’s a third approach: in addition to your web application that works on
    desktops, develop a *hybrid* application, which is a web application that works
    inside the mobile browser but can invoke the native API of the mobile device too.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有第三种方法：除了你的在桌面上工作的网络应用程序之外，开发一个 *混合* 应用程序，这是一个在移动浏览器中运行但也可以调用移动设备原生 API 的网络应用程序。
- en: In this chapter, you’ll see how to make your app look good and be functional
    on large and small screens using the RWD approach. [Chapter 6](kindle_split_015.xhtml#ch06)
    covered observables that can push notifications when certain important events
    happen in your app. Let’s see if you can use observables to let you know if the
    user’s screen size changes and change the UI layout based on the width of the
    viewport of the user’s device. Users with smartphones and users with large monitors
    should see different layouts of the same app.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解如何使用响应式设计（RWD）方法使你的应用程序在大屏幕和小屏幕上看起来美观且功能齐全。[第 6 章](kindle_split_015.xhtml#ch06)
    介绍了当应用程序中发生某些重要事件时可以推送通知的可观察对象。让我们看看你是否可以使用可观察对象来通知你用户屏幕尺寸的变化，并根据用户设备视口的宽度更改 UI
    布局。使用智能手机的用户和使用大屏幕的用户应该看到相同应用程序的不同布局。
- en: We’ll show you how to use the Flex Layout library for implementing RWD and how
    to use its `ObservableMedia` service to spare you from writing lots of CSS.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向你展示如何使用 Flex Layout 库来实现 RWD，以及如何使用其 `ObservableMedia` 服务来节省你编写大量 CSS。
- en: Finally, you’ll start rewriting the ngAuction app, illustrating many of the
    techniques you’ve learned, with the main goal to remove Bootstrap from the app,
    using only the Angular Material and Flex Layout libraries.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将开始重写 ngAuction 应用程序，展示你所学到的许多技术，主要目标是移除应用程序中的 Bootstrap，仅使用 Angular Material
    和 Flex Layout 库。
- en: 7.1\. Flex Layout and ObservableMedia
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. Flex Layout 和 ObservableMedia
- en: 'Imagine that you’ve laid out the UI of your application, and it looks great
    on a user’s monitor with a width resolution of 1200 pixels or more. What if the
    user opens this app on a smartphone with a viewport width of 640 pixels? Depending
    on the device, it may either render only a part of your app’s UI, adding a horizontal
    bar at the bottom, or scale down the UI so it fits in a small viewport, making
    the app difficult to use. Or consider another scenario: users with large monitors
    who reduce the width of their browser window because they need to fit another
    app on their monitor.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你已经布局了应用程序的 UI，它在用户具有 1200 像素或更宽的宽度分辨率的显示器上看起来很棒。如果用户在具有 640 像素视口宽度的智能手机上打开此应用程序会发生什么？根据设备的不同，它可能只会渲染应用程序
    UI 的一部分，在底部添加一个水平栏，或者缩小 UI 以适应小视口，使应用程序难以使用。或者考虑另一种场景：具有大屏幕的用户缩小浏览器窗口，因为他们需要在显示器上放置另一个应用程序。
- en: To implement RWD, you can use CSS media queries, represented by the `@media`
    rule. In the CSS of your app, you can include a set of media queries offering
    different layouts for various screen widths. The browser constantly checks the
    current window width, and as soon as the width crosses a *breakpoint* set in the
    `@media` rules (for example, the width becomes smaller than 640 pixels), a new
    page layout is applied.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 RWD，您可以使用 CSS 媒体查询，由 `@media` 规则表示。在您的应用 CSS 中，您可以包含一组媒体查询，为不同的屏幕宽度提供不同的布局。浏览器会持续检查当前窗口宽度，一旦宽度超过
    `@media` 规则中设置的 *断点*（例如，宽度小于 640 像素），就会应用新的页面布局。
- en: Another way to implement flexible layouts is by using CSS Flexbox with media
    queries (see [http://mng.bz/6B42](http://mng.bz/6B42)). The UI of your app is
    styled as a set of flexible boxes, and if the browser can’t fit the Flexbox content
    horizontally (or vertically), the content is rendered in the next row (or column).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实现灵活布局的另一种方法是使用 CSS Flexbox 和媒体查询（参见 [http://mng.bz/6B42](http://mng.bz/6B42)）。您的应用
    UI 被设计成一系列灵活的盒子，如果浏览器无法水平（或垂直）地容纳 Flexbox 内容，内容将被渲染在下一行（或列）中。
- en: You can also implement RWD with the help of CSS Grid (see [http://mng.bz/k29F](http://mng.bz/k29F)).
    Both Flexbox and CSS Grid require a good understanding of `@media` rules.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以借助 CSS Grid 实现 RWD（参见 [http://mng.bz/k29F](http://mng.bz/k29F)）。Flexbox
    和 CSS Grid 都需要您对 `@media` 规则有良好的理解。
- en: The Angular Flex Layout library (see [https://github.com/angular/flex-layout](https://github.com/angular/flex-layout))
    is a UI layout engine for implementing RWD without writing media queries in your
    CSS files. The library provides a set of simple Angular directives that internally
    apply the rules of the `flexbox` layout and offer you the `ObservableMedia` service
    that notifies your app about the current width of the viewport on the user’s device.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Flex Layout 库（参见 [https://github.com/angular/flex-layout](https://github.com/angular/flex-layout)）是一个
    UI 布局引擎，用于实现响应式 Web 设计，而无需在您的 CSS 文件中编写媒体查询。该库提供了一套简单的 Angular 指令，内部应用 `flexbox`
    布局规则，并提供 `ObservableMedia` 服务，该服务通知您的应用用户设备视口的当前宽度。
- en: 'Angular Flex Layout has the following advantages over the standard CSS API:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Flex Layout 相比于标准 CSS API 具有以下优势：
- en: It produces cross-browser-compatible CSS.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它生成跨浏览器的 CSS。
- en: It provides an Angular-friendly API for dealing with media queries using directives
    and observables.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个对 Angular 友好的 API，用于使用指令和可观察者处理媒体查询。
- en: '|  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In this section, we provide a minimal description of the Flex Layout library
    to get you started quickly. For more details and demos, refer to the Flex Layout
    documentation at [https://github.com/angular/flex-layout/wiki](https://github.com/angular/flex-layout/wiki).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们提供了 Flex 布局库的简要描述，以便您快速入门。有关更多详细信息和大纲，请参阅 Flex 布局文档，网址为 [https://github.com/angular/flex-layout/wiki](https://github.com/angular/flex-layout/wiki)。
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The Flex Layout library provides two APIs: static and responsive. The static
    API allows you to use directives to specify layout attributes for containers and
    their children. The responsive API enhances static API directives, enabling you
    to implement RWD so app layouts change for different screen sizes.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Flex 布局库提供了两个 API：静态和响应式。静态 API 允许您使用指令来指定容器及其子元素的布局属性。响应式 API 增强了静态 API 指令，使您能够实现响应式
    Web 设计（RWD），以便应用布局根据不同的屏幕尺寸进行变化。
- en: 7.1.1\. Using Flex Layout directives
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1\. 使用 Flex 布局指令
- en: 'There are two types of directives in the Flex Layout library: one for containers
    and one for their child elements. A container’s directives are used to align its
    children. Child directives are applied to child elements of a container managed
    by Flex Layout. With child directives, you can specify the order of each child,
    the amount of space it takes, and some other properties, as shown in [table 7.1](#ch07table01).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Flex 布局库中有两种类型的指令：一种用于容器，另一种用于其子元素。容器的指令用于对其子元素进行对齐。子指令应用于由 Flex 布局管理的容器的子元素。使用子指令，您可以指定每个子元素的顺序、它所占的空间量以及一些其他属性，如
    [表 7.1](#ch07table01) 所示。
- en: Table 7.1\. Frequently used Flex Layout directives
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 7.1\. 常用 Flex 布局指令
- en: '| Directive | Description |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *Container directives* |   |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| *容器指令* |   |'
- en: '|'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: fxLayout
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fxLayout
- en: '| Instructs the element to use CSS Flexbox for laying out child elements. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 指令指示元素使用 CSS Flexbox 来布局子元素。 |'
- en: '|'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: fxLayoutAlign
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fxLayoutAlign
- en: '| Aligns child elements in a particular way (to the left, to the bottom, evenly
    distribute, and so on). Allowed values depend on the fxLayout value attached to
    the same container element—see Angular Flex Layout documentation. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 以特定方式（向左、向底、均匀分布等）对齐子元素。允许的值取决于附加到同一容器元素的fxLayout值——请参阅Angular Flex Layout文档。
    |'
- en: '|'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: fxLayoutGap
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fxLayoutGap
- en: '| Controls space between child elements. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 控制子元素之间的空间。 |'
- en: '| *Child directives* |   |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| *子指令* |   |'
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: fxFlex
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fxFlex
- en: '| Controls the amount of space a child element takes within the parent container.
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 控制子元素在父容器中占据的空间量。 |'
- en: '|'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: fxFlexAlign
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fxFlexAlign
- en: '| Allows selectively changing a child’s alignment within the parent container
    prescribed by the fxLayoutAlign directive. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 允许根据fxLayoutAlign指令在父容器中选择性更改子元素的定位。 |'
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: fxFlexOrder
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fxFlexOrder
- en: '| Allows changing the order of a child element within the parent container.
    For example, it can be used to move an important component to the visible area
    when switching from desktop to a mobile screen. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 允许更改子元素在父容器中的顺序。例如，当从桌面切换到移动屏幕时，可以使用它将重要组件移动到可见区域。 |'
- en: '|  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Child directives expect to be inside an HTML element with a container directive
    attached.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 子指令期望位于一个带有容器指令的HTML元素内部。
- en: '|  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s take a look at how to use the Flex Layout library to align two `<div>`
    elements next to each other in a row. First, you need to add the Flex Layout library
    and its peer dependency, `@angular/cdk`, to your project:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Flex Layout库将两个`<div>`元素在一行中并排对齐。首先，你需要将Flex Layout库及其依赖项`@angular/cdk`添加到你的项目中：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The next step is to add the `FlexLayoutModule` to the root `@NgModule()` decorator,
    as shown in the following listing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`FlexLayoutModule`添加到根`@NgModule()`装饰器中，如下所示。
- en: Listing 7.1\. Adding the `FlexLayoutModule`
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.1\. 添加`FlexLayoutModule`
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The next listing creates a component that displays the `<div>` elements next
    to each other from left to right.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表创建了一个组件，该组件从左到右显示相邻的`<div>`元素。
- en: Listing 7.2\. flex-layout/app.component.ts
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.2\. flex-layout/app.component.ts
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* The fxLayout directive turns the <div> into a flex-layout container where
    children are allocated horizontally (in a row).**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* fxLayout指令将<div>转换为flex布局容器，其中子元素水平分配（在一行中）。**'
- en: '***2* The fxFlex directive instructs each child element to take equal space
    within the parent container.**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* fxFlex指令指示每个子元素在父容器中占据相等的空间。**'
- en: 'To see this application in action, run the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用程序的实际效果，请运行以下命令：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Figure 7.1](#ch07fig01) shows how the browser renders the child elements.
    Each child takes 50% of container’s available width.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.1](#ch07fig01)展示了浏览器如何渲染子元素。每个子元素占据容器可用宽度的50%。'
- en: Figure 7.1\. Two elements aligned in a row
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1\. 两元素在一行中对齐
- en: '![](Images/07fig01_alt.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig01_alt.jpg)'
- en: 'To make the right div take more space than the left one, you can assign the
    required space values to the child `fxFlex` directives. The following template
    uses the child-level directive `fxFlex` to allocate 30% of the available width
    to the left child and 70% to the right one:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要使右div比左div占据更多空间，你可以将所需的空间值分配给子`fxFlex`指令。以下模板使用子级指令`fxFlex`将30%的可用宽度分配给左子元素，70%分配给右子元素：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now the UI is rendered as shown in [figure 7.2](#ch07fig02).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，UI渲染如图[图7.2](#ch07fig02)所示。
- en: Figure 7.2\. The right element takes more space than the left one.
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2\. 右元素比左元素占据更多空间。
- en: '![](Images/07fig02_alt.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig02_alt.jpg)'
- en: 'To lay out the container’s children vertically, change the direction of the
    container’s layout from rows to columns, as in `fxLayout="column"`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要将容器子元素的布局从行更改为列，将容器的布局方向从行更改为列，如`fxLayout="column"`：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Figure 7.3](#ch07fig03) shows how the child elements are rendered vertically.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.3](#ch07fig03)展示了子元素如何垂直渲染。'
- en: Figure 7.3\. Column layout of the container element
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.3\. 容器元素的列布局
- en: '![](Images/07fig03_alt.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig03_alt.jpg)'
- en: Say that on a wide screen you have enough room to render your left and right
    components horizontally next to each other, but if the user opens the same app
    on a smaller screen, you want to automatically change the layout to vertical so
    the right component is shown under the left one.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 说到在宽屏上，你有足够的空间水平地渲染左右组件并排，但如果用户在较小的屏幕上打开相同的应用程序，你希望自动更改布局为垂直，以便右组件显示在左组件下方。
- en: 'Each directive in the Flex Layout library can optionally have a *suffix* (an
    alias to the media query rule) that specifies which screen size it has to apply.
    For example, the `flexLayout.sm` directive has the suffix `.sm`, which means it
    should be applied only when the screen width is small. These aliases correspond
    to the width breakpoints defined in the Material Design guidelines (see [http://mng.bz/RmLN](http://mng.bz/RmLN)):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Flex 布局库中的每个指令都可以选择性地有一个 *后缀*（媒体查询规则的别名），用于指定它应该应用于哪个屏幕尺寸。例如，`flexLayout.sm`
    指令的后缀是 `.sm`，这意味着它只应在屏幕宽度较小时应用。这些别名对应于在《Material Design 指南》中定义的宽度断点（见 [http://mng.bz/RmLN](http://mng.bz/RmLN)）：
- en: '**`xs`—** Extra small (less than 599 px)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`xs`—** 超小（小于 599 像素）'
- en: '**`sm`—** Small (560–959 px)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`sm`—** 小（560–959 像素）'
- en: '**`md`—** Medium (960–1279 px)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`md`—** 中等（960–1279 像素）'
- en: '**`lg`—** Large (1280–1919 px)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`lg`—** 大（1280–1919 像素）'
- en: '**`xl`—** Extra large (1920–5000 px)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`xl`—** 超大（1920–5000 像素）'
- en: The next listing changes your app so its parent container lays out its children
    horizontally on medium and large screens, and vertically on small devices.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表更改了您的应用程序，使其父容器在中等和大型屏幕上水平排列其子元素，而在小设备上垂直排列。
- en: Listing 7.3\. Adding the `.sm` suffix
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. 添加 `.sm` 后缀
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Child elements are aligned in a row by default.**'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 默认情况下，子元素按行对齐。**'
- en: '***2* On small screen sizes, child elements are aligned vertically.**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在小屏幕尺寸下，子元素垂直对齐。**'
- en: To illustrate how this will change the layout, you’ll use Chrome Dev Tools,
    which has an icon on the left side of its toolbar that allows you to toggle devices.
    For desktops, the small size means that the width of the window is between 600
    and 959 pixels. [Figure 7.4](#ch07fig04) shows how the UI is rendered if the width
    is 960 (still the medium size).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这将如何改变布局，您将使用 Chrome 开发者工具，它在其工具栏左侧有一个图标，允许您切换设备。对于桌面，小尺寸意味着窗口宽度在 600 到
    959 像素之间。[图 7.4](#ch07fig04) 显示了宽度为 960（仍然是中等尺寸）时的 UI 渲染。
- en: Figure 7.4\. Rendering on a medium device with a width of 960 pixels
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.4\. 在宽度为 960 像素的中等设备上的渲染
- en: '![](Images/07fig04_alt.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig04_alt.jpg)'
- en: Let’s cross the breakpoint and change the width to 959 to emulate a small device.
    [Figure 7.5](#ch07fig05) shows that the layout has changed from horizontal to
    vertical.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们越过断点，将宽度更改为 959 以模拟小设备。[图 7.5](#ch07fig05) 显示布局已从水平变为垂直。
- en: Figure 7.5\. Rendering on a small device with a width of 959 pixels
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.5\. 在宽度为 959 像素的小设备上的渲染
- en: '![](Images/07fig05_alt.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig05_alt.jpg)'
- en: 'Changing the width to anything smaller than 600 will cause a switch back to
    the horizontal layout, because you haven’t specified that for extra-small devices
    (the `.xs` suffix), the layout should remain vertical. You can add the vertical
    layout for extra small (`xs`) devices:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将宽度更改为小于 600 的任何值将导致切换回水平布局，因为您没有指定对于超小设备（`.xs` 后缀），布局应保持垂直。您可以添加超小（`xs`）设备的垂直布局：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also apply less-than (`lt-`) and greater-than (`>-`) suffixes to the
    media query aliases. For example, if you use the `lt-md` alias, the respective
    layout will be applied to the small and extra-small screens. In your app, you
    can specify that on any screen with a width less than medium, the column layout
    should be applied:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将小于（`lt-`）和大于（`>-`）后缀应用于媒体查询别名。例如，如果您使用 `lt-md` 别名，相应的布局将应用于小屏幕和超小屏幕。在您的应用程序中，您可以指定在宽度小于中等的任何屏幕上，应应用列布局：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using breakpoints, you can statically define how your UI should be laid out
    in the component’s template. What if you want not only to change the layout inside
    the container, but also to conditionally show or hide certain children, depending
    on the screen size? To dynamically decide what and how the browser should render
    depending on the screen size, you’ll use the `ObservableMedia` service, which
    comes with the Flex Layout library.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用断点，您可以在组件模板中静态定义您的 UI 应如何布局。如果您不仅想更改容器内的布局，还想根据屏幕尺寸有条件地显示或隐藏某些子元素，怎么办？为了根据屏幕尺寸动态决定浏览器应如何渲染，您将使用
    Flex Layout 库提供的 `ObservableMedia` 服务。
- en: 7.1.2\. ObservableMedia service
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2\. ObservableMedia 服务
- en: The `ObservableMedia` service enables subscribing to screen-size changes and
    programmatically changing the look and feel of your app. For example, on large
    screens, you may decide to display additional information. To avoid rendering
    unnecessary components on small screens, you may subscribe to events emitted by
    `ObservableMedia`, and if the screen size becomes larger, you can render more
    components.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObservableMedia` 服务允许订阅屏幕大小变化并程序化地更改应用程序的外观和感觉。例如，在大型屏幕上，你可能会决定显示额外信息。为了避免在小屏幕上渲染不必要的组件，你可以订阅
    `ObservableMedia` 发射的事件，如果屏幕大小变得更大，你可以渲染更多组件。'
- en: To implement this functionality, import the `ObservableMedia` service and subscribe
    to its `Observable` object. The following listing shows how to subscribe to notifications
    about screen-size changes with the `async` pipe and print the current size on
    the console.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此功能，导入 `ObservableMedia` 服务并订阅其 `Observable` 对象。以下列表显示了如何使用 `async` 管道订阅关于屏幕大小变化的通知，并在控制台打印当前大小。
- en: Listing 7.4\. observable-media/app.component.ts
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4\. observable-media/app.component.ts
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Shows/hides text based on the value of showExtras$; the async pipe subscribes
    to showExtras$**'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 根据 showExtras$ 的值显示/隐藏文本；async 管道订阅 showExtras$***'
- en: '***2* Injects the ObservableMedia service**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入 ObservableMedia 服务***'
- en: '***3* Subscribes to the Observable that emits values when the screen size changes**'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 订阅屏幕大小变化时发射的 Observable***'
- en: '***4* showExtras$ emits true if the screen is medium.**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* showExtras$ 在屏幕为中等时发射 true。***'
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Note the use of the `*ngIf` structural directive. If the `showExtras$` observable
    emits `true`, the span is added to the DOM. If it emits `false`, the span is removed
    from the DOM.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `*ngIf` 结构指令的使用。如果 `showExtras$` 可观察对象发射 `true`，则将 span 添加到 DOM 中。如果它发射 `false`，则从
    DOM 中移除 span。
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The values emitted by `media.asObservable()` have the type `MediaChange` that
    includes the `mqAlias` property, which holds the value representing the current
    width—`lg` for large or `md` for medium.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`media.asObservable()` 发射的值具有 `MediaChange` 类型，该类型包含 `mqAlias` 属性，它包含表示当前宽度的值——`lg`
    表示大或 `md` 表示中等。'
- en: 'To see [listing 7.4](#ch07ex04) in action, run the following command, and open
    the browser’s console:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 [列表 7.4](#ch07ex04) 的实际效果，运行以下命令，并打开浏览器的控制台：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You’ll see the text “Showing extra info on medium screens” when the screen size
    is `md` (medium). Reduce the width of the browser window to the `sm` size, and
    this text will be hidden. To see the current CSS media query and other properties
    of the `mediaChange` class, change the log statement to `console.log(mediaChange);`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕大小为 `md`（中等）时，你会看到文本“在中等屏幕上显示额外信息”。将浏览器窗口的宽度缩小到 `sm` 大小，此文本将被隐藏。要查看当前的 CSS
    媒体查询和 `mediaChange` 类的其他属性，请将日志语句更改为 `console.log(mediaChange);`。
- en: In [listing 7.4](#ch07ex04), you explicitly declared a `showExtras$` observable
    and subscribed to it because you wanted to monitor `MediaChange`. But this code
    can be simplified by using the `ObservableMedia.isActive()` API, as shown in the
    following listing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 7.4](#ch07ex04) 中，你明确声明了一个 `showExtras$` 可观察对象并订阅它，因为你想要监控 `MediaChange`。但可以通过使用以下列表中所示的
    `ObservableMedia.isActive()` API 来简化此代码。
- en: Listing 7.5\. Using the `ObservableMedia.isActive()` API
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5\. 使用 `ObservableMedia.isActive()` API
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Shows text only if the current viewport width is md**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 仅在当前视口宽度为 md 时显示文本***'
- en: In the hands-on section later in this chapter, you’ll create the new version
    of ngAuction that will implement RWD using the Flex Layout library and `ObservableMedia`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面的实践部分，你将创建 ngAuction 的新版本，该版本将使用 Flex 布局库和 `ObservableMedia` 实现响应式设计。
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Other options for implementing RWD**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现响应式设计的其他选项**'
- en: 'The Flex Layout library may be appealing to beginners because it’s simple to
    use. But it’s not the only solution for creating responsive layouts in Angular
    apps. Here are some other options:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Flex 布局库可能对初学者有吸引力，因为它易于使用。但它在 Angular 应用中创建响应式布局的解决方案并非唯一。这里有一些其他选项：
- en: The Angular CDK (component development kit) package includes the layout module.
    After installing the `@angular/cdk` package, you can use the `LayoutModule` and
    `BreakpointObserver` or `MediaMatcher` classes that monitor changes in the viewport
    size. Besides, because Angular CDK is a peer dependency of Flex Layout, by working
    directly with Angular CDK, you’ll use one library instead of two.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular CDK（组件开发套件）包包括布局模块。安装了 `@angular/cdk` 包之后，你可以使用 `LayoutModule` 和 `BreakpointObserver`
    或 `MediaMatcher` 类来监控视口大小的变化。此外，由于 Angular CDK 是 Flex 布局的同级依赖，通过直接使用 Angular CDK，你将使用一个库而不是两个。
- en: At the time of writing, the Flex Layout library remains in beta, and its creators
    often introduce breaking changes with new beta releases. If you’re not using the
    latest version of Angular, Flex Layout may not support the version of Angular
    you use. For example, the Flex Layout library doesn’t support Angular 4.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在撰写本文时，Flex Layout 库仍处于测试版，其创建者经常在新版测试版中引入破坏性更改。如果您不使用 Angular 的最新版本，Flex Layout
    可能不支持您使用的 Angular 版本。例如，Flex Layout 库不支持 Angular 4。
- en: To minimize the number of libraries used in your app, consider implementing
    RWD by using CSS Flexbox and CSS Grid. Also, using CSS that’s natively supported
    by the browser will always be more performant than using any JavaScript library.
    We recommend the free CSS Grid video course by Wes Bos, available at [https://cssgrid.io](https://cssgrid.io).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化应用程序中使用的库的数量，考虑使用 CSS Flexbox 和 CSS Grid 实现响应式设计。此外，使用浏览器原生支持的 CSS 总是比使用任何
    JavaScript 库更高效。我们推荐 Wes Bos 提供的免费 CSS Grid 视频课程，可在 [https://cssgrid.io](https://cssgrid.io)
    获取。
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '7.2\. Hands-on: Rewriting ngAuction'
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 实践：重写 ngAuction
- en: Starting in this chapter, you’ll rewrite ngAuction from scratch. The new ngAuction
    will be written using Angular Material from the get-go and will include images,
    not just the grey rectangles. The search component will be represented by a small
    icon on the toolbar, and you’ll add shopping cart functionality. Users will be
    able to bid on products and buy them if they place winning bids.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，您将从零开始重写 ngAuction。新的 ngAuction 将从一开始就使用 Angular Material，并包括图像，而不仅仅是灰色矩形。搜索组件将由工具栏上的小图标表示，您将添加购物车功能。用户将能够对产品进行竞标，并在他们出价获胜时购买产品。
- en: 7.2.1\. Why rewrite the ngAuction app from scratch?
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. 为什么要从头开始重写 ngAuction 应用程序？
- en: You may be thinking, “We already worked on ngAuction in [chapters 2](kindle_split_011.xhtml#ch02),
    [3](kindle_split_012.xhtml#ch03), and [5](kindle_split_014.xhtml#ch05). Why not
    just continue building the same app?” In the first chapters, the goal was to gently
    introduce you to the main artifacts of the Angular framework without overloading
    you with information on application architecture, implementing RWD, and customizing
    themes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想，“我们已经在 [第 2 章](kindle_split_011.xhtml#ch02)、[第 3 章](kindle_split_012.xhtml#ch03)
    和 [第 5 章](kindle_split_014.xhtml#ch05) 中对 ngAuction 进行了工作。为什么不一如既往地继续构建相同的应用程序？”
    在前几章中，目标是温和地介绍 Angular 框架的主要组件，而不让您被应用程序架构、实现响应式设计和定制主题的信息所压倒。
- en: 'The ngAuction app developed in the previous chapters served that goal well.
    This rewrite will showcase the best development practices for real-world Angular
    applications. You want to accomplish the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中开发的 ngAuction 应用程序很好地实现了该目标。这次重写将展示真实世界 Angular 应用程序的最佳开发实践。您希望实现以下目标：
- en: Create a modularized app where each view is a lazy-loaded module.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模块化应用程序，其中每个视图都是一个懒加载的模块。
- en: Use Angular Material for the UI, illustrating theme customization with SaaS.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular Material 进行 UI 设计，用 SaaS 说明了主题定制的示例。
- en: Use the Flex Layout library.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Flex Layout 库。
- en: Remove the dependency on the Bootstrap and JQuery libraries.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除对 Bootstrap 和 JQuery 库的依赖。
- en: Remove the search box from the landing page to make better use of screen space.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从首页移除搜索框，以更好地利用屏幕空间。
- en: Keep shared components and services in a separate folder.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将共享组件和服务保存在单独的文件夹中。
- en: Illustrate state management using injectable services and then reimplement it
    using the NgRx library.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可注入服务说明状态管理，然后使用 NgRx 库重新实现。
- en: Create scripts for unit and end-to-end testing.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单元测试和端到端测试的脚本。
- en: You’re not going to implement all of that in this chapter, but you’ll get started.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本章中不会实现所有这些功能，但您将开始着手。
- en: In this app, you’ll implement RWD using the Flex Layout library and its `ObservableMedia`
    service, introduced earlier. On large screens, the landing page of ngAuction will
    display four products per row, as shown in [figure 7.6](#ch07fig06).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，您将使用 Flex Layout 库及其之前介绍的 `ObservableMedia` 服务来实现响应式设计。在大型屏幕上，ngAuction
    的首页将每行显示四个产品，如图 7.6 所示 [图 7.6](#ch07fig06)。
- en: Figure 7.6\. Rendering ngAuction on large screens
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.6\. 在大屏幕上渲染 ngAuction
- en: '![](Images/07fig06_alt.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig06_alt.jpg)'
- en: '|  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We borrowed the data and images from the Google app illustrating the Polymer
    library (see [http://mng.bz/Y5d9](http://mng.bz/Y5d9)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 Google 应用中借用了数据和图像，展示了 Polymer 库（见 [http://mng.bz/Y5d9](http://mng.bz/Y5d9)）。
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The app will be subscribed to the `ObservableMedia` service using the `async`
    pipe and will automatically change the layout to three products per row as soon
    as the width of the window changes to a medium size, as shown in [figure 7.7](#ch07fig07).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 应用将使用 `async` 管道订阅 `ObservableMedia` 服务，并在窗口宽度变为中等大小时自动将布局更改为每行三个产品，如图 7.7 所示。
- en: Figure 7.7\. Rendering ngAuction on medium screens
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.7\. 在中等屏幕上渲染 ngAuction
- en: '![](Images/07fig07_alt.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig07_alt.jpg)'
- en: On small screens, the app will change to the two-column layout, as shown in
    [figure 7.8](#ch07fig08).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在小屏幕上，应用将切换到两列布局，如图 7.8 所示。
- en: Figure 7.8\. Rendering ngAuction on small screens
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.8\. 在小屏幕上渲染 ngAuction
- en: '![](Images/07fig08_alt.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig08_alt.jpg)'
- en: The app will also change its layout when rendered on extra-small (one-column
    layout) and extra-large screens (five-column layout).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 应用在渲染在超小屏幕（单列布局）和超大屏幕（五列布局）时也会更改其布局。
- en: 7.2.2\. Generating a new ngAuction app
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2\. 生成新的 ngAuction 应用
- en: '|  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Source code for this chapter can be found at [https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)
    and [www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在 [https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)
    和 [www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition)
    找到。
- en: '|  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This time, you’ll generate the project using the Angular CLI `new` command
    with options. The new ngAuction will use the Sass preprocessor for styles with
    the SCSS syntax. You also want to specify the `nga-` prefix, so each newly generated
    component will have this prefix in its selector:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你将使用 Angular CLI 的 `new` 命令并带有选项来生成项目。新的 ngAuction 将使用 Sass 预处理器进行样式，并使用
    SCSS 语法。你还想指定 `nga-` 前缀，因此每个新生成的组件在其选择器中都将具有此前缀：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We discuss the benefits of using SCSS in the next section, “[Creating a custom
    Angular Material theme with Sass](#ch07lev2sec5).”
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节“[使用 Sass 创建自定义 Angular Material 主题](#ch07lev2sec5)”中讨论使用 SCSS 的优点。
- en: '|  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Change to the ng-auction directory and run the following commands to add Angular
    Material and Flex Layout libraries to the project:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 ng-auction 目录并运行以下命令以将 Angular Material 和 Flex Layout 库添加到项目中：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Installs the Angular Material library and Component Development Kit.
    The Angular Material library also requires the animations package, which was already
    installed by Angular CLI during the project generation.**'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 安装 Angular Material 库和组件开发工具包。Angular Material 库还需要动画包，该包在项目生成时已被 Angular
    CLI 安装。**'
- en: '***2* Installs the Flex Layout library**'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 安装 Flex Layout 库**'
- en: The Angular Material library comes with four prebuilt themes, and you had a
    chance to try one of them in [section 5.6.1](kindle_split_014.xhtml#ch05lev2sec5)
    in [chapter 5](kindle_split_014.xhtml#ch05). But what if none of the prebuilt
    themes fits your UI requirements?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material 库附带四个预构建主题，你已经在第 5 章的 5.6.1 节（kindle_split_014.xhtml#ch05lev2sec5）中尝试了其中一个。但如果你需要的
    UI 主题不符合预构建主题怎么办？
- en: 7.2.3\. Creating a custom Angular Material theme with Sass
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3\. 使用 Sass 创建自定义 Angular Material 主题
- en: If you want to create a custom Angular Material theme for your app, read the
    Theming Guide at [https://material.angular.io/guide/theming](https://material.angular.io/guide/theming).
    In this section, we’ll just give you a code review of the .scss files that we
    created to customize the theme for ngAuction.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为你的应用创建一个自定义 Angular Material 主题，请阅读位于 [https://material.angular.io/guide/theming](https://material.angular.io/guide/theming)
    的主题指南。在本节中，我们只为你提供我们为自定义 ngAuction 主题创建的 .scss 文件的代码审查。
- en: 'When you generated the ngAuction app, you used the option `--style scss`. By
    doing so, you informed Angular CLI that you’re not going to use CSS files, but
    instead will use the Syntactically Awesome Style Sheets, also known as Sass (see
    [http://sass-lang.com](http://sass-lang.com)). Sass is an extension to CSS with
    its own preprocessor. Some Sass benefits include the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你生成 ngAuction 应用时，你使用了 `--style scss` 选项。这样做是为了通知 Angular CLI 你将不会使用 CSS 文件，而是将使用语法优美的样式表（Syntactically
    Awesome Style Sheets），也称为 Sass（见 [http://sass-lang.com](http://sass-lang.com)）。Sass
    是 CSS 的扩展，具有自己的预处理器。Sass 的一些优点包括以下内容：
- en: '***Variables*—** Assigning styles to variables and reusing them in multiple
    stylesheets'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***变量*—** 将样式分配给变量并在多个样式表中重用'
- en: '***Nesting*—** An easy-to-write and -read syntax for nested CSS selectors'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***嵌套*—** 用于嵌套 CSS 选择器的易于编写和阅读的语法'
- en: '***Mixins*—** Blocks of styles that can include variables'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***混入（Mixins）*—** 包含变量的样式块'
- en: Sass provides two syntaxes, Sass and SCSS, and you’ll use the latter in this
    book. If you were installing SaaS separately, you’d need to run your .scss files
    through the preprocessor to compile them into regular .css files before deployment.
    But Angular CLI supports Sass out of the box, so the preprocessor does its job
    during bundling.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Sass 提供了两种语法，Sass 和 SCSS，你将在本书中使用后者。如果你单独安装 SaaS，你需要运行你的 .scss 文件通过预处理器来编译它们成常规的
    .css 文件，然后再部署。但是 Angular CLI 默认支持 Sass，因此预处理器在捆绑过程中完成其工作。
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**SCSS syntax**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**SCSS 语法**'
- en: 'Here’s a quick introduction to SCSS syntax:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 SCSS 语法的快速介绍：
- en: '***Variables*—** A variable name starts with the dollar sign. The following
    code snippet declares and uses the variable `$font-stack`:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***变量（Variables）*—** 变量名以美元符号开头。以下代码片段声明并使用了变量 `$font-stack`：'
- en: '[PRE14]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This variable can be used in multiple places, and if you decide to change the
    Helvetica font to another one, you do it in one place instead of making changes
    in each and every .css file where you used it.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个变量可以在多个地方使用，如果你决定将 Helvetica 字体更改为另一个字体，你只需在一个地方进行更改，而不是在每个使用它的 .css 文件中进行更改。
- en: '***Nesting*—** It’s an easy-to-read syntax for writing nested CSS selectors.
    The following sample shows how to nest the `ul` and `a` style selectors inside
    the `div` selector:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***嵌套（Nesting）*—** 它是一种易于阅读的语法，用于编写嵌套 CSS 选择器。以下示例展示了如何将 `ul` 和 `a` 样式选择器嵌套在
    `div` 选择器内部：'
- en: '[PRE15]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***Mixins*—** A mixin is a block of Sass style. A mixin can be added to your
    styles with `@include`. Mixins can also use variables and can be invoked as functions
    with arguments, as in `mat-palette($mat-red);`.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***混入（Mixins）*—** 混入是一块 Sass 风格的代码块。混入可以通过 `@include` 添加到你的样式表中。混入也可以使用变量，并且可以作为带参数的函数调用，例如
    `mat-palette($mat-red);`。'
- en: '***Partials*—** Partials are just files with code fragments meant to be imported
    by other Sass files. Partials must have names that start with an underscore, such
    as _theme.scss. When you import a partial, the underscore isn’t needed, as in
    `@import ''./theme'';` Partials aren’t compiled into separate CSS files—their
    content is compiled only as a part of .scss files that import them.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***部分（Partials）*—** 部分是包含代码片段的文件，旨在由其他 Sass 文件导入。部分必须以下划线开头，例如 _theme.scss。当你导入一个部分时，下划线是不需要的，例如
    `@import ''./theme'';` 部分不会编译成单独的 CSS 文件——它们的内容只作为导入它们的 .scss 文件的一部分进行编译。'
- en: '***Imports*—** The `@import` statement allows you to import styles located
    in other files. Although CSS also has an `@import` keyword, it makes an additional
    HTTP request for each file. With Sass, all imports are combined into a single
    CSS file during preprocessing, so only one HTTP request is needed to load the
    CSS.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***导入（Imports）*—** `@import` 语句允许你导入其他文件中的样式。虽然 CSS 也有一个 `@import` 关键字，但它会对每个文件进行额外的
    HTTP 请求。使用 Sass，所有导入在预处理期间都会合并成一个单一的 CSS 文件，因此只需要一个 HTTP 请求来加载 CSS。'
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In your ngAuction app, you’ll create the styles directory, move the generated
    styles.scss file there, and add one more partial, _theme.scss. The content of
    _theme.scss is shown in the following listing. You use the `$mat-cyan` palette
    defined in the imported file _theming.scss.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 ngAuction 应用中，你将创建一个样式目录，将生成的 styles.scss 文件移到那里，并添加一个额外的部分，_theme.scss。_theme.scss
    的内容如下所示。你使用在导入的文件 _theming.scss 中定义的 `$mat-cyan` 调色板。
- en: Listing 7.6\. _theme.scss
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.6\. _theme.scss
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Declares a variable for the primary palette and initializes it with $mat-cyan
    palette**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明一个用于主要调色板的变量，并用 $mat-cyan 调色板初始化**'
- en: '***2* Declares and initializes a variable for the accent palette specifying
    a default, lighter, and darker hue of $mat-cyan**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明并初始化一个用于强调调色板的变量，指定 $mat-cyan 的默认、较浅和较深的色调**'
- en: '***3* Declares and initializes a variable for the warning palette**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 声明并初始化一个用于警告调色板的变量**'
- en: '***4* Creates the theme (Sass object containing all palettes)**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建主题（包含所有调色板的 Sass 对象）**'
- en: '***5* Declares and initializes a variable for the background palette**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 声明并初始化背景调色板变量**'
- en: '***6* Declares and initializes a variable for the foreground palette**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 声明并初始化前景调色板变量**'
- en: '***7* Declares and initializes the variable for typography**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 声明并初始化用于排版的变量**'
- en: In the _theme.scss file, you used the cyan color for the primary and accent
    palettes. You can find their definitions in node_modules/@angular/material/_theming.scss.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 _theme.scss 文件中，你使用了青色为主要的和强调调色板。你可以在 node_modules/@angular/material/_theming.scss
    中找到它们的定义。
- en: In the following listing, you add styles in styles.scss, starting from importing
    the preceding _theme.scss.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，你将在 styles.scss 中添加样式，从导入前面的 _theme.scss 开始。
- en: Listing 7.7\. styles.scss
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.7\. styles.scss
- en: '[PRE17]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Imports Google Material icons**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 Google Material 图标**'
- en: '***2* Imports the Titillium Web fonts (you’ll use it for the toolbar title
    and later for bid values)**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入 Titillium Web 字体（你将用于工具栏标题和稍后用于出价值）**'
- en: '***3* Imports the Abril Fatface fonts (you’ll use it for product titles)**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导入 Abril Fatface 字体（你将用于产品标题）**'
- en: '***4* Imports Angular Material core styles that aren’t theme-dependent**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 导入 Angular Material 核心样式，这些样式不依赖于主题**'
- en: '***5* Loads your custom theme configured in _theme.scss**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 加载在 _theme.scss 中配置的自定义主题**'
- en: The styles.scss and _theme.scss files define your global styles for the entire
    app, and you’ll specify them in the `styles` property in the .angular-cli.json
    file. In ngAuction, you’ll also be styling individual components, and _theme.scss
    will be reused in each component. We’ve intentionally broken the style definition
    into two files so you can reuse _theme.scss (just the variables definitions) in
    components without duplicating the core styles, images, and fonts used in styles.scss.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: styles.scss 和 _theme.scss 文件定义了整个应用的全球样式，你将在 .angular-cli.json 文件的 `styles`
    属性中指定它们。在 ngAuction 中，你还将为单个组件添加样式，_theme.scss 将在每个组件中重复使用。我们故意将样式定义分成两个文件，这样你就可以在组件中重复使用
    _theme.scss（仅变量定义），而不必在 styles.scss 中重复核心样式、图像和字体。
- en: Now your custom theme is configured, and you can start working on the UI of
    the landing page of ngAuction.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在自定义主题已配置，你可以开始为 ngAuction 的着陆页的 UI 工作了。
- en: 7.2.4\. Adding a toolbar to the top-level component
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.4\. 在顶级组件中添加工具栏
- en: '[Figure 7.6](#ch07fig06) shows the landing page of ngAuction, which includes
    the Material toolbar and the `HomeComponent`. To be more precise, it includes
    the toolbar and a `<router-outlet>` tag where you render the `HomeComponent`.
    Let’s start with creating the first version of the toolbar. This toolbar will
    include the menu icon on the left, the logo of ngAuction in the middle, and the
    shopping cart icon on the right. It won’t include the Search button (you’ll add
    that in [section 11.8](kindle_split_020.xhtml#ch11lev1sec8) in [chapter 11](kindle_split_020.xhtml#ch11))
    and will look like [figure 7.9](#ch07fig09).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.6](#ch07fig06) 展示了 ngAuction 的着陆页，其中包含 Material 工具栏和 `HomeComponent`。更准确地说，它包括工具栏和一个
    `<router-outlet>` 标签，你在其中渲染 `HomeComponent`。让我们从创建工具栏的第一个版本开始。这个工具栏将包括左边的菜单图标，中间的
    ngAuction 标志，以及右边的购物车图标。它不包括搜索按钮（你将在第 11 章的 [11.8 节](kindle_split_020.xhtml#ch11lev1sec8)
    中添加该按钮）并且看起来像 [图 7.9](#ch07fig09)。'
- en: Figure 7.9\. The toolbar
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.9\. 工具栏
- en: '![](Images/07fig09_alt.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig09_alt.jpg)'
- en: On the left, you use the Google Material icon `menu`, and on the right, `shopping_cart`.
    For the logo, you place the Google Material `gavel` icon on top of the shape resembling
    the Angular logo, and save it in the logo.svg file, included with the book’s source
    code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，你使用 Google Material 图标 `menu`，在右侧，`shopping_cart`。对于标志，你将 Google Material
    的 `gavel` 图标放在类似 Angular 标志的形状上方，并将其保存为 logo.svg 文件，该文件包含在本书的源代码中。
- en: As you learned in the hands-on section of [chapter 5](kindle_split_014.xhtml#ch05),
    to use Angular Material components, you should include the corresponding modules
    in the `imports` section of the root module of your app. In your toolbar, you’ll
    need `MatToolbarModule`, `MatButtonModule`, and `MatIconModule`. Since you’re
    going to use the Flex Layout library, you’ll also need to add `FlexLayoutModule`
    to the root module. Later in this section, you’ll use `HttpClient` to read the
    product data, so you need to add the `HttpClientModule` to the root module.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在第 5 章的动手实践部分所学，要使用 Angular Material 组件，你应该在应用的根模块的 `imports` 部分中包含相应的模块。在你的工具栏中，你需要
    `MatToolbarModule`、`MatButtonModule` 和 `MatIconModule`。由于你将使用 Flex Layout 库，你还需要将
    `FlexLayoutModule` 添加到根模块。稍后在本节中，你将使用 `HttpClient` 读取产品数据，因此需要将 `HttpClientModule`
    添加到根模块。
- en: Update the CLI-generated app.module.ts to include the modules in the following
    listing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将 CLI 生成的 app.module.ts 更新为包含以下列表中的模块。
- en: Listing 7.8\. app.module.ts
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.8\. app.module.ts
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Adds the required modules from the Angular Material library**'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加 Angular Material 库中所需的模块**'
- en: '***2* Adds the Flex Layout module**'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加 Flex Layout 模块**'
- en: '***3* Adds HttpClientModule—you’ll use HttpClient for getting the product data**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 添加 HttpClientModule—you’ll use HttpClient for getting the product data**'
- en: Replace the generated app.component.html with the following listing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成的 app.component.html 替换为以下列表。
- en: Listing 7.9\. app.component.html
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.9\. app.component.html
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* The menu button with the icon**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 带有图标的菜单按钮**'
- en: '***2* Displays the logo in the center of the toolbar**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在工具栏中心显示标志**'
- en: '***3* Turns the logo into a clickable link that will display HomeComponent
    after you configure routes**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将标志转换为可点击的链接，配置路由后显示HomeComponent**'
- en: '***4* Turns the text ngAuction into a clickable link**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将ngAuction文本转换为可点击的链接**'
- en: '***5* A filler to push the shopping cart icon to the right**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 填充物，将购物车图标推到右边**'
- en: '***6* The shopping cart button with an icon**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 带有图标的购物车按钮**'
- en: '***7* You’ll keep the router outlet commented out until you configure routes.**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 你将保持路由出口被注释，直到你配置路由。**'
- en: To make the toolbar look like [figure 7.9](#ch07fig09), you need to add the
    following listing’s styling to the app.component.scss file.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使工具栏看起来像[图7.9](#ch07fig09)，你需要将以下列表的样式添加到app.component.scss文件中。
- en: Listing 7.10\. app.component.scss
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.10\. app.component.scss
- en: '[PRE20]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Imports your custom theme**'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入你的自定义主题**'
- en: '***2* Uses Angular pseudo selector :host to style the component that hosts
    the AppComponent**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用Angular伪选择器:host来样式化托管AppComponent的组件**'
- en: '***3* Applies the same background as in the Material card component in this
    theme (it’s white in your theme)**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 应用与该主题中Material卡片组件相同的背景（在你的主题中是白色）**'
- en: '***4* Styles the logo name**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 样式化标志名称**'
- en: '***5* Styles the logo image**'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 样式化标志图像**'
- en: '***6* Styles the toolbar title**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 样式化工具栏标题**'
- en: '***7* Styles the icon foreground**'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 样式化图标前景**'
- en: '***8* Styles the shopping cart button**'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 样式化购物车按钮**'
- en: Running the `ng serve` command will render the ngAuction app that looks like
    [figure 7.9](#ch07fig09).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`ng serve`命令将渲染看起来像[图7.9](#ch07fig09)的ngAuction应用。
- en: You have a toolbar UI rendered, and now you need to show products under the
    toolbar. First, you need to create the `ProductService` that will provide the
    product data, and then you’ll create the `HomeComponent` that will render the
    data. Let’s start with the `ProductService`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经渲染了一个工具栏UI，现在你需要显示工具栏下的产品。首先，你需要创建一个`ProductService`来提供产品数据，然后你将创建一个`HomeComponent`来渲染这些数据。让我们从`ProductService`开始。
- en: 7.2.5\. Creating the product service
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.5\. 创建产品服务
- en: The product service needs data. In real-world apps, the data would be supplied
    by the server, and you’ll do that in [chapter 12](kindle_split_021.xhtml#ch12).
    For now, you’ll just use the JSON file that contains the information about the
    product. The product images will be located on the client side as well. The code
    samples that come with the book include the src/data/products.json file, of which
    a fragment is shown in the following listing.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 产品服务需要数据。在现实世界的应用中，数据将由服务器提供，你将在[第12章](kindle_split_021.xhtml#ch12)中这样做。现在，你将只使用包含产品信息的JSON文件。产品图片也将位于客户端。本书附带的一些代码示例包括src/data/products.json文件，其一个片段如下所示。
- en: Listing 7.11\. A fragment from src/data/products.json
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.11\. src/data/products.json的一个片段
- en: '[PRE21]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This file includes URLs of the product images located in the data/img folder.
    If you’re following along and are trying to build ngAuction by yourself, copy
    the src/data directory into your project from the code that comes with the book
    and add the line `"data"` to the app property `assets` in the .angular-cli.json
    file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含位于data/img文件夹中的产品图片的URL。如果你正在跟随并尝试自己构建ngAuction，请将src/data目录从本书附带代码复制到你的项目中，并将行`"data"`添加到.app属性`.angular-cli.json`文件中的`assets`。
- en: 'You’ll use the `ProductService` class in more than one component; you’ll generate
    it in the folder src/app/shared/services. You’ll be adding other reusable services
    in this folder later on (such as `SearchService`). You’ll generate `ProductService`
    using the following Angular CLI command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在多个组件中使用`ProductService`类；你将在src/app/shared/services文件夹中生成它。你将在稍后在这个文件夹中添加其他可重用服务（例如`SearchService`）。你将使用以下Angular
    CLI命令生成`ProductService`：
- en: '[PRE22]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then you’ll add the provider for this service to the app.module:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将添加此服务的提供者到app.module：
- en: '[PRE23]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|  |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Best practice**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: The import statement for `ProductService` is rather long, and it points at the
    file where this service is implemented. As your application grows, the number
    of services as well as the number of import statements in your module increases,
    polluting the module code.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductService`的导入语句相当长，并且指向实现此服务文件的路径。随着你的应用程序的增长，模块中的服务数量以及导入语句的数量也会增加，这会污染模块代码。'
- en: 'Create the file named index.ts in the services folder like so:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在services文件夹中创建名为index.ts的文件，如下所示：
- en: '[PRE24]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You import the `Product` and `ProductService` classes and reexport them right
    away. Now the import statement in the app.module can be simplified to look like
    this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您导入 `Product` 和 `ProductService` 类，并立即重新导出它们。现在，app.module 中的导入语句可以简化为如下所示：
- en: '[PRE25]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you have just one reexported class, this may look like overkill. But if
    you have multiple classes in the services folder, you can write just one import
    statement for all classes, functions, or variables that you want to import—for
    example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只有一个重新导出的类，这可能看起来有些过度。但如果您在服务文件夹中有多个类，您可以只写一个导入语句来导入所有类、函数或变量——例如：
- en: '[PRE26]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Keep in mind, this will work only if the file with such reexports is called
    index.ts.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这仅在具有此类重新导出的文件名为 index.ts 时才有效。
- en: '|  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The product.service.ts file includes the `Product` interface and the `ProductService`
    class. The `Product` interface defines the type of objects returned by the methods
    of the `ProductService` class: `getAll()` and `getById()`. The code for your `ProductService`
    is shown in the following listing.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: product.service.ts 文件包含 `Product` 接口和 `ProductService` 类。`Product` 接口定义了 `ProductService`
    类的方法返回的对象类型：`getAll()` 和 `getById()`。您的 `ProductService` 代码如下所示。
- en: Listing 7.12\. product.service.ts
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.12\. product.service.ts
- en: '[PRE27]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Defines the Product type**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义产品类型**'
- en: '***2* Injects the HttpClient object**'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入 HttpClient 对象**'
- en: '***3* This function declares an Observable that can return all Product objects.**'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 此函数声明了一个可以返回所有产品对象的 Observable。**'
- en: '***4* This function declares an Observable that can return products by ID.**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 此函数声明了一个可以按 ID 返回产品的 Observable。**'
- en: '***5* map() finds the product ID that matches the function argument.**'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* map() 查找与函数参数匹配的产品 ID。**'
- en: Because you don’t have a real data server, both methods read the entire products.json
    file, and the `getById()` method also applies `find()` to the array of products
    to find the one with a matching ID.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您没有真实的数据服务器，这两个方法都读取整个 products.json 文件，并且 `getById()` 方法还将 `find()` 应用于产品数组以找到匹配的
    ID。
- en: '|  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Best practice**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: You defined the type `Product` as an interface and not a class. Because JavaScript
    doesn’t support interfaces, the compiled code won’t include `Product`. If you
    were to define `Product` as a class, the TypeScript compiler would turn the `Product`
    class into either a JavaScript function or a class and would include it in the
    executable code. Defining types as TypeScript interfaces instead of classes reduces
    the size of the runnable code.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您将 `Product` 类型定义为接口而不是类。因为 JavaScript 不支持接口，编译后的代码将不包括 `Product`。如果您将 `Product`
    定义为类，TypeScript 编译器会将 `Product` 类转换为 JavaScript 函数或类，并将其包含在可执行代码中。将类型定义为 TypeScript
    接口而不是类可以减小可执行代码的大小。
- en: '|  |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the next section, you’ll create the feature module that will include `HomeComponent`—the
    first consumer of the `ProductService`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将创建包含 `HomeComponent` 的功能模块——`ProductService` 的第一个消费者。
- en: 7.2.6\. Creating the home module
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.6\. 创建主页模块
- en: 'You want to create each view as a feature module. This will allow you to lazy
    load them, and the code of each view will be built as a separate bundle. Generate
    a feature home module as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将每个视图创建为功能模块。这将允许您按需加载它们，并且每个视图的代码将作为单独的包构建。按照以下方式生成功能主页模块：
- en: '[PRE28]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This command will create a src/app/home directory containing the home.module.ts
    file with the content shown in the following listing.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在 src/app/home 目录下创建一个包含 home.module.ts 文件的目录，其内容如下所示。
- en: Listing 7.13\. home.module.ts
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.13\. home.module.ts
- en: '[PRE29]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can generate the home component with the following command:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令生成主页组件：
- en: '[PRE30]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After running this command, Angular CLI will print the message that four files
    were generated (the home component) and one file was updated (the home module)—the
    `HomeComponent` was added to the `declarations` section in the `@NgModule` decorator
    of the module:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，Angular CLI 将打印出已生成四个文件（主页组件）和一个文件被更新（主页模块）——`HomeComponent` 被添加到模块的
    `@NgModule` 装饰器的 `declarations` 部分中：
- en: '[PRE31]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You’ll use the Flex Layout library in this module, so you want to configure
    the default route so that it renders `HomeComponent`. Also, you’re going to display
    products using the `<mat-grid-list>` component from the Angular Material library.
    Add the required code to home.module.ts so it looks like the following listing.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模块中，您将使用 Flex 布局库，因此您想要配置默认路由以便它渲染 `HomeComponent`。此外，您将使用 Angular Material
    库中的 `<mat-grid-list>` 组件来显示产品。将所需的代码添加到 home.module.ts 中，使其看起来如下所示。
- en: Listing 7.14\. modified home.module.ts
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.14\. modified home.module.ts
- en: '[PRE32]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Adds the route configuration for your feature module**'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为您的功能模块添加路由配置**'
- en: '***2* Adds the Flex Layout library**'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加 Flex Layout 库**'
- en: '***3* Adds the Angular Material module required by <mat-grid-list>**'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 添加 <mat-grid-list> 所需的 Angular Material 模块**'
- en: 'The next step is to update the `HomeComponent` in the generated home.component.ts
    file. You’ll inject two services into this component: `ProductService` and `ObservableMedia`.
    You’ll invoke the `getAll()` method on `ProductService` to get product data. `ObservableMedia`
    will be watching the viewport width to change the UI layout accordingly. To be
    more specific, the product data will be shown in a grid, and the `ObservableMedia`
    service will change the number of columns in the grid from one to five, based
    on the current viewport width. The code of the `HomeComponent` is shown in the
    next listing.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是更新生成的 home.component.ts 文件中的 `HomeComponent`。您将向此组件注入两个服务：`ProductService`
    和 `ObservableMedia`。您将调用 `ProductService` 上的 `getAll()` 方法以获取产品数据。`ObservableMedia`
    将监视视口宽度以相应地更改 UI 布局。更具体地说，产品数据将以网格形式显示，而 `ObservableMedia` 服务将根据当前视口宽度将网格中的列数从一列变为五列。`HomeComponent`
    的代码如下所示。
- en: Listing 7.15\. home.component.ts
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.15\. home.component.ts
- en: '[PRE33]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* An observable to supply the number of columns in the grid**'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 提供网格列数的 observable**'
- en: '***2* An observable of products**'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 产品的可观察量**'
- en: '***3* Maps the media query alias to the number of columns in the grid**'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将媒体查询别名映射到网格中的列数**'
- en: '***4* Injects ObservableMedia and ProductService**'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 注入 ObservableMedia 和 ProductService**'
- en: '***5* Gets data about all products**'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 获取所有产品的数据**'
- en: '***6* Turns the ObservableMedia object into an Observable**'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将 ObservableMedia 对象转换为 Observable**'
- en: '***7* Gets the number of the grid column based on the emitted media query alias;
    <number> means casting from object to number**'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 根据发出的媒体查询别名获取网格列数；<number> 表示从对象转换为数字**'
- en: The `getAll()` method on `ProductService` initializes the `product$` variable
    of type `Observable`. You don’t see the invocation of the `subscribe()` method
    here, because you’ll use the `async` pipe in the template of the home component.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductService` 上的 `getAll()` 方法初始化了类型为 `Observable` 的 `product$` 变量。您在这里看不到
    `subscribe()` 方法的调用，因为您将在 home 组件的模板中使用 `async` 管道。'
- en: The role of `ObservableMedia` is to send the media query alias to the component,
    indicating the current width of the user’s device viewport. This width may be
    changing if the viewport is a window in the browser and the user resizes it. If
    the user runs this app on a smartphone, the width of the viewport won’t change,
    but `HomeComponent` needs to know it anyway to render the grid of products.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObservableMedia` 的作用是向组件发送媒体查询别名，指示用户设备视口的当前宽度。如果视口是浏览器中的窗口并且用户调整大小，则此宽度可能会变化。如果用户在智能手机上运行此应用程序，视口的宽度不会改变，但
    `HomeComponent` 仍然需要知道它以渲染产品网格。'
- en: Now you need to replace the generated template in home.component.html with the
    markup to display products in a grid of rows and columns. For the grid, you’ll
    use the `<mat-grid-list>` component from the Angular Material library. The content
    of each grid cell will be rendered in a `<mat-grid-tile>` component.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要将生成的 home.component.html 模板替换为显示产品网格的行和列的标记。对于网格，您将使用来自 Angular Material
    库的 `<mat-grid-list>` 组件。每个网格单元格的内容将在 `<mat-grid-tile>` 组件中渲染。
- en: In this template, you’ll use the `async` pipe twice. The first `async` pipe
    will subscribe to the observable that emits the number of columns in a grid, and
    the second pipe will subscribe to the observable that emits product data. The
    code of the home.component.html file is shown in the following listing.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模板中，您将使用两次 `async` 管道。第一个 `async` 管道将订阅发出网格中列数的 observable，第二个管道将订阅发出产品数据的
    observable。home.component.html 文件的代码如下所示。
- en: Listing 7.16\. home.component.html
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.16\. home.component.html
- en: '[PRE34]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* Subscribes to the number of columns and binds it to the cols property
    of <mat-grid-list>**'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 订阅列数并将其绑定到 <mat-grid-list> 的 cols 属性**'
- en: '***2* Renders a <mat-grid-tile> for each product using the data from the products$
    observable**'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 products$ observable 中的数据为每个产品渲染一个 <mat-grid-tile>**'
- en: '***3* Wraps the content of each tile in the <a> tag to turn the tile into a
    clickable link**'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将每个瓷砖的内容包裹在 <a> 标签中，将瓷砖转换为可点击的链接**'
- en: '***4* Clicking on the tile will navigate to the path /products, passing the
    selected product’s id as a parameter.**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 点击瓷砖将导航到路径 /products，并传递所选产品的 id 作为参数。**'
- en: '***5* For extra-small viewports, adds the styles defined in tile__price-tag--xs**'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 对于额外小视口，添加 tile__price-tag--xs 中定义的样式**'
- en: '|  |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Navigation to the product-detail screen isn’t implemented in this version of
    ngAuction. Clicking the product tile will result in an error in the browser console.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的 ngAuction 中没有实现导航到商品详情屏幕。点击商品瓷砖将在浏览器控制台产生错误。
- en: '|  |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We’d like to explain the last annotation in [listing 7.16](#ch07ex16) a bit
    more. That `<span>` element is styled as defined in `tile__price-tag`, but if
    the size of the viewport becomes extra small (`xs`), the Flex Layout `ngClass.xs`
    directive will add the styles defined in `tile__price-tag--xs`. If you compare
    the definitions of the `tile__price-tag` and `tile__price-tag--xs` styles in [listing
    7.17](#ch07ex17), you see that merging these two styles would mean changing the
    font size from 16 px to 14 px.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想对 [列表 7.16](#ch07ex16) 中的最后一个注释进行更多解释。这个 `<span>` 元素被设置为 `tile__price-tag`
    中定义的样式，但如果视口的尺寸变为额外小（`xs`），Flex Layout 的 `ngClass.xs` 指令将添加 `tile__price-tag--xs`
    中定义的样式。如果你比较 `tile__price-tag` 和 `tile__price-tag--xs` 样式的定义，你会在 [列表 7.17](#ch07ex17)
    中看到，合并这两个样式意味着将字体大小从 16 px 更改为 14 px。
- en: '|  |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: We use the symbols `__` and `--` in naming some styles, as recommended by the
    block, element, modifier (BEM) methodology (see [http://getbem.com](http://getbem.com)).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在命名一些样式时使用 `__` 和 `--` 符号，这是按照块、元素、修饰符（BEM）方法（见 [http://getbem.com](http://getbem.com)）推荐的。
- en: '|  |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To complete the `HomeComponent`, you need to add some styles in home.component
    .scss.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成 `HomeComponent`，你需要在 home.component .scss 中添加一些样式。
- en: Listing 7.17\. home.component.scss
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.17\. home.component.scss
- en: '[PRE35]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Imports your customized theme**'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入你的自定义主题**'
- en: '***2* Makes the tile background color the same as the Angular Material card
    (white)**'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使瓷砖的背景颜色与 Angular Material 卡片（白色）相同**'
- en: '***3* If the user hovers over the tile, elevates the tile to level 4 by adding
    the shadow effect (returned by the mat-elevation mixin)**'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果用户将鼠标悬停在瓷砖上，通过添加阴影效果（由 mat-elevation mixin 返回）将瓷砖提升到4级**'
- en: '***4* Default style for the product price tag**'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 商品价格标签的默认样式**'
- en: '***5* Style for the product price tag for extra-small viewports**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 商品价格标签的额外小视口样式**'
- en: '***6* Default style for the product title**'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 商品标题的默认样式**'
- en: '***7* As per Material Design spec, uses Display 1 for font styles instead of
    specifying the hardcoded size**'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 根据 Material Design 规范，使用 Display 1 字体样式而不是指定硬编码的大小**'
- en: '***8* Style for the product title for small viewports**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 针对小型视口的商品标题样式**'
- en: '***9* Style for the product title for extra-small viewports**'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 针对额外小视口的商品标题样式**'
- en: The `HomeComponent` is ready. What do you need to do to render it under the
    toolbar?
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`HomeComponent` 已准备好。你需要在工具栏下渲染它，需要做什么？'
- en: 7.2.7\. Configuring routes
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.7\. 配置路由
- en: 'In the beginning of this hands-on exercise, we stated that each view on ngAuction
    will be a separate module, and you created the `HomeComponent` as a module. Now
    you need to configure the route for this module. Create an src/app/app.routing.ts
    file with the following content:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个动手实践的最初，我们提到 ngAuction 的每个视图都将是一个独立的模块，并且你已经创建了 `HomeComponent` 作为模块。现在你需要为这个模块配置路由。创建一个
    src/app/app.routing.ts 文件，内容如下：
- en: '[PRE36]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you see, you use the syntax for lazy-loaded modules, as explained in section
    4.3 in [chapter 4](kindle_split_013.xhtml#ch04). You to load this configuration
    in app.module.ts by invoking `Router.forRoot()`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你使用了第 4 章中 4.3 节解释的懒加载模块的语法。你需要在 app.module.ts 中通过调用 `Router.forRoot()`
    来加载这个配置：
- en: '[PRE37]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last step is to uncomment the last line in app.component.html that has
    the `<router-outlet>` tag, so the app component template is laid out as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是取消注释 app.component.html 中最后一行带有 `<router-outlet>` 标签的行，这样应用程序组件模板的布局如下：
- en: '[PRE38]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The coding part of the landing page is done.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 落地页的编码部分已完成。
- en: 7.2.8\. Running ngAuction
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.8\. 运行 ngAuction
- en: The first version of the new ngAuction is ready, so let’s build the dev bundles
    and see how it looks in the browser. Running `ng serve` produces the output shown
    in [figure 7.10](#ch07fig10).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 ngAuction 的第一个版本已准备好，所以让我们构建开发包并看看它在浏览器中的样子。运行 `ng serve` 产生如图 7.10 所示的输出。
- en: Figure 7.10\. Bundling ngAuction with `ng serve`
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.10\. 使用 `ng serve` 打包 ngAuction
- en: '![](Images/07fig10_alt.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7.10](Images/07fig10_alt.jpg)'
- en: 'Note the first line: Angular CLI placed the home module in a separate bundle.
    It did that because in configuring routes, you used the syntax for lazy-loaded
    modules, but when you open the browser at http://localhost:4200, you’ll see that
    the home module was loaded, as shown in [figure 7.11](#ch07fig11).'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第一行：Angular CLI 将主模块放置在单独的包中。它之所以这样做，是因为在配置路由时，你使用了懒加载模块的语法，但当你打开浏览器到 http://localhost:4200
    时，你会看到主模块已经被加载，如图 7.11 所示。
- en: Figure 7.11\. Running ngAuction
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.11\. 运行 ngAuction
- en: '![](Images/07fig11_alt.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7.11](Images/07fig11_alt.jpg)'
- en: The home module was eagerly loaded because it was configured as a default route
    (mapped to an empty path). The landing page of ngAuction is ready, except it doesn’t
    have the Search button on the toolbar. You’ll add it in [section 11.8](kindle_split_020.xhtml#ch11lev1sec8)
    in [chapter 11](kindle_split_020.xhtml#ch11).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 主模块被急切地加载，因为它被配置为默认路由（映射到空路径）。ngAuction 的着陆页已经准备好了，除了工具栏上没有搜索按钮。你将在第 11 章的 [11.8
    节](kindle_split_020.xhtml#ch11lev1sec8) 中添加它。
- en: '|  |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you click on any of the product tiles, the browser console shows an error,
    as in “Cannot match any routes. URL Segment: ‘products/2’.” This error will disappear
    in [chapter 9](kindle_split_018.xhtml#ch09)’s version of ngAuction, after you
    develop the product-detail page.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击任何产品瓷砖，浏览器控制台会显示错误，例如“无法匹配任何路由。URL 段：'products/2'。”这个错误将在你开发产品详情页后，第 9
    章的 ngAuction 版本中消失。
- en: '|  |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You can keep a single code base of the web app that will adopt its UI based
    on the available width of the user device.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以保持单个代码库的 web 应用，该应用将根据用户设备的可用宽度采用其 UI。
- en: The Flex Layout library allows you to subscribe to notifications about viewport
    width changes and apply the respective UI layout.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flex 布局库允许你订阅关于视口宽度变化的通知，并应用相应的 UI 布局。
- en: The Flex Layout library includes the `ObservableMedia` class, which can notify
    you about the current width of the viewport, sparing you from writing CSS for
    this purpose.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flex 布局库包括 `ObservableMedia` 类，它可以通知你关于视口当前宽度的信息，让你免于为此编写 CSS。
