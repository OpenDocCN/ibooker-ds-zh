- en: 5 Communication between microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 微服务之间的通信
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using live reload at the application level for faster iterations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用级别使用实时重载以实现更快的迭代
- en: Sending direct messages between microservices with HTTP requests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTTP 请求在微服务之间发送直接消息
- en: Sending indirect messages between microservices with RabbitMQ
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RabbitMQ 在微服务之间发送间接消息
- en: Choosing between using direct and indirect messages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用直接和间接消息之间进行选择
- en: A microservices application is composed of many microservices, each looking
    after its own area of responsibility. Because each microservice by itself is small,
    simple, and doesn’t do much, our microservices must collaborate to create the
    complex behaviors needed to implement our application’s feature set. To work together,
    our microservices need ways to communicate. If they can’t talk to each other,
    then they won’t be able to coordinate their activities, and they won’t achieve
    much.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微服务应用由许多微服务组成，每个微服务负责其自己的领域。因为每个微服务本身都很小、简单，并且不做很多事情，所以我们的微服务必须协作以创建实现应用功能集所需复杂行为。为了协作，我们的微服务需要通信方式。如果它们不能相互交谈，那么它们将无法协调它们的活动，也不会取得很大成就。
- en: In this chapter, we examine the different ways that microservices can communicate
    so that these can collaborate and fulfill the higher-level requirements of the
    application. In the process, we’ll also revisit Docker and Docker Compose to set
    up live reload for our entire application. Moving forward, that’s essential so
    that we aren’t constantly rebuilding and restarting our application as we update
    our code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了微服务之间可以采用的不同通信方式，以便它们能够协作并满足应用的高级需求。在这个过程中，我们还将回顾 Docker 和 Docker
    Compose，以设置整个应用的实时重载。向前推进，这是必要的，这样我们就不需要不断地重建和重新启动我们的应用，随着代码的更新。
- en: We already saw in earlier chapters that HTTP requests are one way that microservices
    communicate. In this chapter, we’ll expand on using HTTP requests for direct messaging,
    and we’ll also look at using RabbitMQ for indirect messaging. Throughout the chapter,
    you’ll learn how to decide what type of messaging to use for a given situation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经看到 HTTP 请求是微服务之间通信的一种方式。在本章中，我们将扩展使用 HTTP 请求进行直接消息传递，同时我们还将探讨使用
    RabbitMQ 进行间接消息传递。在整个章节中，你将学习如何根据具体情况决定使用哪种类型的消息传递。
- en: 5.1 New and familiar tools
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 新的和熟悉的工具
- en: This chapter introduces the RabbitMQ software for queuing messages. This will
    help us decouple our microservices. We’ll use the npm package, amqplib, to connect
    our microservices to RabbitMQ so these can send and receive messages. We’ll also
    revise some familiar tools, and we’ll explore in more detail how we can use HTTP
    requests to send messages and upgrade our development environment to support application-wide
    live reload.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 RabbitMQ 软件用于消息队列。这将帮助我们解耦我们的微服务。我们将使用 npm 包 amqplib 将我们的微服务连接到 RabbitMQ，以便它们可以发送和接收消息。我们还将回顾一些熟悉工具，并更详细地探讨我们如何使用
    HTTP 请求发送消息，以及如何升级我们的开发环境以支持应用级别的实时重载。
- en: Table 5.1 New and familiar tools in chapter 5
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 第 5 章中的新和熟悉工具
- en: '| Tool | Version | Purpose |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 版本 | 目的 |'
- en: '| Docker Compose | 1.26.2 | Docker Compose lets you configure, build, run,
    and manage multiple containers at the same time. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| Docker Compose | 1.26.2 | Docker Compose 允许你同时配置、构建、运行和管理多个容器。|'
- en: '| HTTP | 1.1 | Hypertext Transfer Protocol (HTTP) is used to send direct (or
    synchronous) messages from one microservice to another. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| HTTP | 1.1 | 超文本传输协议（HTTP）用于从一个微服务向另一个微服务发送直接（或同步）消息。|'
- en: '| RabbitMQ | 3.8.5 | RabbitMQ is the message queuing software that we’ll use
    to send indirect (or asynchronous) messages from one microservice to another.
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| RabbitMQ | 3.8.5 | RabbitMQ 是我们将用于从一个微服务向另一个微服务发送间接（或异步）消息的消息队列软件。|'
- en: '| amqplib | 0.5.6 | This npm package allows us to configure RabbitMQ and to
    send and receive messages from JavaScript. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| amqplib | 0.5.6 | 这个 npm 包允许我们配置 RabbitMQ，并从 JavaScript 发送和接收消息。|'
- en: 5.2 Getting the code
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 获取代码
- en: To follow along with this chapter, you need to download the code or clone the
    repository.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，你需要下载代码或克隆存储库。
- en: 'Download a zip file of the code from here:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这里下载代码的 zip 文件：
- en: '[https://github.com/bootstrapping-microservices/chapter-5](https://github.com/bootstrapping-microservices/chapter-5)'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/bootstrapping-microservices/chapter-5](https://github.com/bootstrapping-microservices/chapter-5)'
- en: 'You can clone the code using Git like this:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 Git 如下克隆代码：
- en: '`git clone https://github.com/bootstrapping-microservices/chapter-5.git`'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`git clone https://github.com/bootstrapping-microservices/chapter-5.git`'
- en: For help on installing and using Git, see chapter 2\. If you have problems with
    the code, log an issue against the repository in GitHub.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安装和使用Git的帮助，请参阅第二章。如果您对代码有问题，请在GitHub仓库中记录一个问题。
- en: 5.3 Getting our microservices talking
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 让我们的微服务开始对话
- en: 'At this point in the book, we have an application with two microservices: video
    streaming and video storage. In the previous chapter, we added data storage capability;
    the video-streaming microservice has a database, and the video-storage microservice
    uses external cloud storage to store the video files. Figure 5.1 shows what our
    application looks like now.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们有一个包含两个微服务的应用程序：视频流和视频存储。在上一章中，我们添加了数据存储功能；视频流微服务有一个数据库，视频存储微服务使用外部云存储来存储视频文件。图5.1显示了我们的应用程序现在的样子。
- en: '![](../Images/CH05_F01_Davis4.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F01_Davis4.png)'
- en: Figure 5.1 We finished the last chapter with two microservices and a database
    running under Docker Compose on our development workstation. In that chapter,
    we also added a connection to Azure cloud storage to store our videos.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 我们在上一个章节中完成了两个微服务和数据库在开发工作站上运行在Docker Compose下的工作。在那个章节中，我们还添加了连接到Azure云存储以存储我们的视频。
- en: A microservices application can only be built from services that collaborate
    to provide the application’s features. Our application can’t do much if we have
    microservices that can’t communicate! Communication between microservices is therefore
    a crucial part of building with microservices, and it’s essential that we have
    communication techniques at our disposal.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微服务应用程序只能由协作以提供应用程序功能的微服务构建而成。如果我们有无法通信的微服务，我们的应用程序将无法做很多事情！因此，微服务之间的通信是构建微服务的重要组成部分，我们必须有可用的通信技术。
- en: 'Actually, we wouldn’t have gotten this far without having already used HTTP
    requests for communication between the video-streaming and video-storage microservices
    like we did in chapter 4\. We glossed over it there, but it was really quite important.
    Without it, we would have stumbled at the first hurdle: separating out the streaming
    and storage capabilities for our application.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果没有在第四章中像我们那样使用HTTP请求来在视频流和视频存储微服务之间进行通信，我们就不会走到这一步。我们在那里只是略过了这一点，但实际上它非常重要。没有它，我们就会在第一个障碍上跌倒：将我们的应用程序的流媒体和存储功能分离出来。
- en: Note Our microservices must work together to implement the features of our application,
    so it’s crucial that they be able to communicate for collaboration.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们的微服务必须协同工作以实现应用程序的功能，因此它们能够进行通信以协作至关重要。
- en: 'In this chapter, we add a third microservice to our application: the history
    microservice. The purpose of adding this new microservice is to demonstrate communication
    among microservices. You can see in figure 5.2 how the video-streaming microservice
    is sending a stream of messages to the history microservice.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向我们的应用程序添加了第三个微服务：历史微服务。添加这个新微服务的目的是为了演示微服务之间的通信。您可以在图5.2中看到视频流微服务是如何向历史微服务发送消息流的。
- en: Figure 5.2 shows conceptually what our application will look like at the end
    of this chapter, but it doesn’t show the full technical details of what we’ll
    add. To get the full picture, we need to know the various styles of communication
    we can make use of, and the technologies that underpin these. Before that though,
    let’s better understand the history microservice.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2从概念上展示了本章结束时我们的应用程序将是什么样子，但它并没有展示我们将要添加的完整技术细节。为了获得完整的图景，我们需要了解我们可以使用的各种通信风格以及支撑这些技术的技术。在此之前，让我们更好地理解历史微服务。
- en: '![](../Images/CH05_F02_Davis4.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F02_Davis4.png)'
- en: Figure 5.2 In this chapter, we expand our application with a new microservice
    and explore methods of communication between our microservices.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 在本章中，我们通过添加一个新的微服务来扩展我们的应用程序，并探索微服务之间的通信方法。
- en: 5.4 Introducing the history microservice
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 介绍历史微服务
- en: We are using the history microservices in this chapter as an example of how
    microservices can send and receive messages to each other. Actually, this new
    microservice really does have a proper place in FlixTube, and as the name suggests,
    it records our user’s viewing history.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用历史微服务作为示例，说明微服务如何相互发送和接收消息。实际上，这个新微服务在FlixTube中确实有一个合适的位置，正如其名称所暗示的，它记录了我们的用户的观看历史。
- en: There are multiple ways our application can make use of this history. For starters,
    our user might want to look at their own history to remember a video they watched
    in the past. They might like to resume watching a video later, or we might use
    it to provide recommendations for other users.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序可以通过多种方式利用这个历史记录。首先，我们的用户可能想查看自己的历史记录以记住他们以前观看的视频。他们可能希望在以后继续观看视频，或者我们可以用它来为其他用户提供推荐。
- en: To keep the examples in this chapter simple, we’ll drop out the video-storage
    microservice from the last chapter, which simplifies the video-streaming microservice.
    In fact, for our starting point in this chapter, we’ll revert back to an earlier
    version of the video-streaming microservice that has the example video baked into
    its Docker image. We’ll use the video-streaming microservice like it was after
    chapter 3\. This simplification is just while we get our heads around the communication
    techniques. After this chapter, we’ll reinstate the video-storage microservice
    and restore the video-streaming microservice to its former glory.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本章的示例简单，我们将从上一章中删除视频存储微服务，这简化了视频流微服务。实际上，在本章的起点，我们将回到视频流微服务的早期版本，其中示例视频已经嵌入到其Docker镜像中。我们将像第3章之后那样使用视频流微服务。这种简化只是为了我们熟悉通信技术。在本章之后，我们将恢复视频存储微服务，并将视频流微服务恢复到其原来的状态。
- en: The message we’ll transmit between microservices is the *viewed* message. This
    is how the video-streaming microservice informs the history microservice that
    the user has watched a video. Figure 5.3 shows you what the history microservice
    is doing. It receives a stream of messages from the video-streaming microservice,
    and it records them in its own database.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在微服务之间传输的消息是*已查看*的消息。这就是视频流微服务如何通知历史微服务用户已经观看了一个视频。图5.3展示了历史微服务正在做什么。它从视频流微服务接收一系列消息，并将它们记录在其自己的数据库中。
- en: '![](../Images/CH05_F03_Davis4.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3](../Images/CH05_F03_Davis4.png)'
- en: Figure 5.3 As a way to explore communication methods, we’ll have the video-streaming
    microservice send a viewed message to the history microservice to record our user’s
    viewing history.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 作为探索通信方法的一种方式，我们将让视频流微服务向历史微服务发送已查看的消息以记录我们的用户观看历史。
- en: We haven’t yet discussed the styles of messaging we could use-that’s coming
    soon. For the moment, know that we have multiple techniques we can use to send
    the viewed message. Through this chapter, we’ll explore our options, and we can
    decide later which one is best suited for this particular situation. Before that
    though, let’s upgrade our development environment for faster development cycles.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论我们可以使用的消息风格——这将在不久的将来讨论。目前，请知道我们有多项技术可以用来发送已查看的消息。在本章中，我们将探讨我们的选项，我们可以在以后决定哪个最适合这种特定情况。不过，在之前，让我们升级我们的开发环境以加快开发周期。
- en: 5.5 Live reload for fast iterations
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 快速迭代的实时重载
- en: In section 2.4, we talked about our philosophy of development and how small,
    fast increments are essential for a tight feedback loop and for maintaining a
    fast development pace. In chapter 2, when directly running our first microservice
    under Node.js, we were able to use the npm package, nodemon, to make our microservice
    *live reload*. This means our microservice automatically reloads when we make
    changes to its code. Having an efficient live reload mechanism is even more important
    at the application level than it is at the microservice level. That’s because
    building and booting up the whole application is much slower than it is for each
    individual microservice.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.4节中，我们讨论了我们的开发哲学以及为什么小而快的增量对于紧密的反馈循环和保持快速的开发节奏至关重要。在第2章中，当我们直接在Node.js下运行我们的第一个微服务时，我们能够使用npm包nodemon来使我们的微服务*实时重载*。这意味着当我们对其代码进行更改时，我们的微服务会自动重新加载。在应用层面，拥有高效的实时重载机制比在微服务层面更为重要。这是因为构建和启动整个应用程序比每个单独的微服务要慢得多。
- en: In chapter 3, we used Docker and began to “bake” the code for our microservice
    into the Docker image. Docker is an incredibly useful way for us to package, publish,
    and deploy our microservices. That’s why we use it, even though we’ve yet to see
    the deploy part of this puzzle. To see deployment in action, however, we need
    a production environment (which is coming in chapter 6) and by chapter 7, we’ll
    see our Docker images deployed to production.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们使用了Docker，并开始将我们的微服务代码“烘焙”到Docker镜像中。Docker是我们打包、发布和部署微服务的极其有用的方式。这就是我们使用它的原因，尽管我们还没有看到这个谜题的部署部分。然而，为了看到部署的实际操作，我们需要一个生产环境（将在第6章中介绍），到第7章，我们将看到我们的Docker镜像被部署到生产环境中。
- en: In chapter 4, we used Docker Compose in our development environment as a convenient
    way to structure and manage our growing application. This is all well and good,
    but unfortunately, in transitioning from direct use of Node.js to running our
    microservices in Docker containers, we lost our ability to automatically reload
    our code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，我们使用Docker Compose在我们的开发环境中作为一种方便的方式来构建和管理我们不断增长的应用程序。这一切都很好，但不幸的是，在从直接使用Node.js过渡到在Docker容器中运行我们的微服务时，我们失去了自动重新加载代码的能力。
- en: Because we are baking our code into our Docker images, we aren’t able to change
    it afterward! This is great for production because, for security reasons, we really
    don’t want any *man-in-the-middle* able to mess with that code. The problem now
    is that during development, we don’t want to constantly rebuild our images and
    reboot our application to include updated code. Doing this is quite slow. And
    for repeated rebuilds and restarts, the time really adds up, especially as our
    application grows in size.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将代码烘焙到我们的Docker镜像中，我们无法在之后更改它！这对于生产来说很棒，因为出于安全原因，我们真的不希望任何中间人能够篡改这段代码。现在的问题是，在开发过程中，我们不希望不断地重建我们的镜像和重新启动应用程序以包含更新的代码。这样做非常慢。而且，对于重复的重建和重启，时间真的会累积起来，尤其是随着我们的应用程序规模的扩大。
- en: Note Not being able to quickly update the code in a running application is a
    terrible thing for our development process and can be a huge drain on our productivity.
    We’ll address this early and find a way to restore our live reload capability.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：无法快速更新运行中的应用程序代码对我们的开发过程来说是一件糟糕的事情，这可能会极大地消耗我们的生产力。我们将尽早解决这个问题，并找到一种方法来恢复我们的实时重新加载功能。
- en: In this section, we’ll upgrade our Docker Compose file to support sharing code
    between our development workstation and our containers. Figure 5.4 shows you how
    the source code directory for the new history microservice is shared from our
    development workstation into the microservice’s container.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将升级我们的Docker Compose文件，以支持在开发工作站和我们的容器之间共享代码。图5.4展示了新历史微服务的源代码目录是如何从我们的开发工作站共享到微服务的容器中的。
- en: Again, we’ll use nodemon for this, and we’ll use it across the board for all
    our microservices. It automatically restarts each microservice when the code changes.
    This configuration might seem onerous to put in place, but it really is worthwhile
    to get this right because it’s going to have a big impact on our pace of development!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将使用nodemon来完成这项工作，并且我们将将其应用于所有我们的微服务。它会在代码更改时自动重启每个微服务。这种配置可能看起来很繁琐，但将其正确设置是非常有价值的，因为它将对我们的开发速度产生重大影响！
- en: '![](../Images/CH05_F04_Davis4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4](../Images/CH05_F04_Davis4.png)'
- en: Figure 5.4 To enable live reload on a larger scale, we synchronize our code
    between our development workstation and the container so that changes to the code
    automatically propagate through into the container.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 为了在更大范围内启用实时重新加载，我们在开发工作站和容器之间同步我们的代码，以便代码的更改自动传播到容器中。
- en: 5.5.1 Creating a stub for the history microservice
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 为历史微服务创建存根
- en: We’ll create the live reload configuration only for the new history microservice,
    but after that, we’ll need to apply this same configuration to each and every
    microservice. This way live reload is supported for all the microservices in our
    application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只为新的历史微服务创建实时重新加载配置，但之后，我们需要将此相同的配置应用到每个微服务上。这样，我们的应用程序中的所有微服务都支持实时重新加载。
- en: Before we get started, read through listing 5.1 and familiarize yourself with
    the newly born history microservice. This doesn’t do anything yet. It’s just a
    stub and is waiting to have features added. Once we have live reload working for
    this microservice, we’ll be able to boot our application using Docker Compose.
    Then, we’ll make live updates and incremental changes to evolve this new microservice
    without having to restart the application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，阅读列表5.1，熟悉新生的历史微服务。目前它还没有做任何事情。它只是一个占位符，等待添加功能。一旦我们为这个微服务实现了实时重新加载，我们就能使用Docker
    Compose启动我们的应用程序。然后，我们将对新的微服务进行实时更新和增量更改，而无需重新启动应用程序。
- en: Listing 5.1 A stub for the history microservice (chapter-5/example-1/history/src/index.js)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 历史微服务的占位符（第5章/示例1/历史/src/index.js）
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① This is a stub microservice. Later, we’ll add HTTP routes and message handlers
    here!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这是一个占位符微服务。稍后，我们将在这里添加HTTP路由和消息处理器！
- en: 5.5.2 Augmenting the microservice for live reload
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2 为实时重新加载增强微服务
- en: 'We don’t need to do anything else to the basic code for our microservice, other
    than what we already learned in chapter 2, where we set up our first microservice
    and installed nodemon for live reload. Each microservice needs nodemon installed
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的微服务的基本代码，除了我们在第2章中学到的之外，我们不需要做任何其他的事情，包括我们设置第一个微服务和安装nodemon以实现实时重新加载。每个微服务都需要像这样安装nodemon：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The npm package, nodemon, is what we’ll use to watch our code and to automatically
    restart our microservice when the code changes. The package.json file for the
    microservice includes an npm script called start:dev, according to the convention
    we started in chapter 2\. You can see what this looks like in listing 5.2.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: npm包nodemon是我们用来监控代码并在代码更改时自动重启微服务的工具。微服务的package.json文件中包含了一个名为start:dev的npm脚本，这是我们在第2章中开始使用的约定。你可以在列表5.2中看到它的样子。
- en: Listing 5.2 Setting up package.json for live reload with nodemon (chapter-5/example-1/history/package.json)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2 使用nodemon设置package.json以实现实时重新加载（第5章/示例1/历史/package.json）
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Uses nodemon to enable live reload for this microservice. When the code changes,
    nodemon automatically restarts the microservice.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用nodemon为这个微服务启用实时重新加载。当代码更改时，nodemon会自动重启微服务。
- en: 'With the start:dev npm script in place, we can run our microservice like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在start:dev npm脚本设置到位后，我们可以这样运行我们的微服务：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This invokes nodemon for our microservice like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将像这样调用nodemon来监控我们的微服务：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Obviously, you could always type out the full nodemon command, but using `npm
    run start:dev` is shorter, and it’s always the same for all our microservices,
    assuming that we apply the convention to each and every microservice. If you just
    started the history microservice, now exit with Ctrl-C. Soon, we’ll run our entire
    application again using Docker Compose.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你总是可以键入完整的nodemon命令，但使用`npm run start:dev`更短，并且对于我们的所有微服务都是一样的，前提是我们将这个约定应用到每个微服务上。如果你刚刚启动了历史微服务，现在使用Ctrl-C退出。不久，我们将再次使用Docker
    Compose运行我们的整个应用程序。
- en: You are probably wondering why I used the `--legacy-watch` argument with nodemon.
    I used this argument because I often run Docker and Docker Compose under a Linux
    virtual machine (VM). It’s a convenient way to work with Linux on your Windows
    Home PC. (Prior to WSL2, Windows Home wasn’t capable of directly running Docker.)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我在nodemon中使用了`--legacy-watch`参数。我使用这个参数是因为我经常在Linux虚拟机（VM）下运行Docker和Docker
    Compose。这是在Windows Home PC上使用Linux的一种方便方式。（在WSL2之前，Windows Home无法直接运行Docker。）
- en: The `--legacy-watch` argument disables the filesystem watch and, instead, uses
    a frequent polling mechanism to monitor for code changes. If you do your development
    on a VM, you need this because the automatic file watch required by live reload
    doesn’t translate changes through from the host operating system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`--legacy-watch`参数禁用了文件系统监控，并使用频繁轮询机制来监控代码更改。如果你在虚拟机上开发，你需要这个参数，因为实时重新加载所需的自动文件监控无法从宿主操作系统传递更改。'
- en: If you are not doing your development under a VM, you can safely remove the
    `--legacy-watch` argument and your live reload will work with slightly better
    performance. You can read more about using VMs for development in appendix A.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是在虚拟机（VM）下进行开发，你可以安全地移除`--legacy-watch`参数，你的实时重新加载将会有更好的性能。你可以在附录A中了解更多关于在开发中使用虚拟机的内容。
- en: 5.5.3 Splitting our Dockerfile for development and production
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.3 为开发和生产分割Dockerfile
- en: In chapter 2, we talked about being able to run our microservices in either
    development mode or production mode. We made this distinction so that we can optimize
    separately for the differing needs of development and production. In this section,
    you’ll see this separation start to come to fruition.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章，我们讨论了能够在开发模式或生产模式下运行我们的微服务。我们做出这种区分是为了能够针对开发和生产的不同需求分别进行优化。在本节中，您将看到这种分离开始实现。
- en: Note At this point, we’ll create separate Dockerfiles for our development and
    production modes. In each case, our needs differ. For development, we prioritize
    fast iteration. For production, we prioritize performance and security.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在此阶段，我们将为我们的开发和生产模式创建单独的Dockerfile。在每种情况下，我们的需求都不同。对于开发，我们优先考虑快速迭代。对于生产，我们优先考虑性能和安全。
- en: For all microservices, henceforth, we’ll create not just one but two Dockerfiles.
    We now need one for development and another for production. We’ll call the development
    one Dockerfile-dev and the production one Dockerfile-prod.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有微服务，从现在起，我们将创建不止一个，而是两个Dockerfile。我们现在需要一个用于开发，另一个用于生产。我们将开发版本的Dockerfile命名为Dockerfile-dev，生产版本的Dockerfile命名为Dockerfile-prod。
- en: These names are chosen to avoid confusion. Naming is so important in software
    development that we should aim to select clear names to help avoid ambiguity.
    We are separating our Dockefiles at this point so that we can enable live reload
    in development. That isn’t something that we want to be enabled in production!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称的选择是为了避免混淆。在软件开发中，命名非常重要，我们应该努力选择清晰的名字以帮助避免歧义。我们现在将Dockefiles分开，以便在开发中启用实时重载。这不是我们希望在生产中启用的事情！
- en: Listing 5.3 shows a production Dockerfile for the new history microservice.
    There’s nothing new here as this is a fairly standard Node.js Dockerfile. It’s
    similar to the Dockerfile we created in chapter 3.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3显示了新历史微服务的生产Dockerfile。这里没有什么新内容，因为这基本上是一个相当标准的Node.js Dockerfile。它与我们在第3章中创建的Dockerfile相似。
- en: Listing 5.3 Creating the production Dockerfile (chapter-5/example-1/history/Dockerfile-prod)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 创建生产Dockerfile（chapter-5/example-1/history/Dockerfile-prod）
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① We use the alpine Linux image for production because it makes the image for
    our microservice much smaller.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们使用alpine Linux镜像用于生产，因为它使我们的微服务镜像变得很小。
- en: ② Installs just the production dependencies
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ② 仅安装生产依赖项
- en: ③ Copies the source code into the image. We can say that the code is baked into
    the image.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将源代码复制到镜像中。我们可以说代码被“烘焙”到镜像中了。
- en: ④ Starts the microservice in production mode
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 以生产模式启动微服务
- en: We won’t actually make use of the production Dockerfiles in this chapter, but
    we’ll definitely need these in chapter 7, when we deploy to our production environment.
    It’s a good idea to maintain our development and production Dockerfiles side by
    side so that the development version doesn’t get too far ahead of the production
    one.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实际上不会使用生产Dockerfile，但在第7章，当我们部署到生产环境时，我们肯定会需要这些。将开发和生产Dockerfile并排维护是一个好主意，这样开发版本就不会比生产版本领先太多。
- en: Listing 5.4 shows the development Dockerfile for the history microservice. Read
    through it and compare it to the production Dockerfile in listing 5.3\. Notice
    the differences between development and production for yourself.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4显示了历史微服务的开发Dockerfile。阅读它，并将其与列表5.3中的生产Dockerfile进行比较。自己注意开发与生产之间的差异。
- en: Listing 5.4 Creating the dev Dockerfile (chapter-5/example-1/history/Dockerfile-dev)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4 创建开发Dockerfile（chapter-5/example-1/history/Dockerfile-dev）
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Instead of the alpine version, we could choose to use the non-alpine version
    of Linux here. A non-alpine distribution is bigger, but it has more debugging
    tools that can be handy during development.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们可以选择在这里使用非alpine版本的Linux，而不是alpine版本。非alpine发行版更大，但它有更多在开发期间有用的调试工具。
- en: ② Copies the package.json file into the image. Note that we don’t copy the code
    into the image.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将package.json文件复制到镜像中。请注意，我们并没有将代码复制到镜像中。
- en: ③ Enables caching for npm installs, making subsequent npm installs faster
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 启用npm安装的缓存，使得后续的npm安装更快
- en: ④ Does the npm install when the container starts. This means we can make use
    of npm caching so it’s much faster to install at container startup than if we
    installed it during the build process.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 容器启动时执行npm install。这意味着我们可以利用npm缓存，使得在容器启动时安装比在构建过程中安装要快得多。
- en: ⑤ Starts the microservice in development mode, using nodemon for live reload
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 以开发模式启动微服务，使用nodemon进行实时重载
- en: 'Did you pick up the differences between the two different Dockerfiles? In listing
    5.3, we installed production only dependencies, whereas in listing 5.4, we installed
    all dependencies, including our dev dependencies. But did you spot the most important
    change? In listing 5.3, we baked our code into the production Docker image using
    the `COPY` instruction:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到了两个不同的Dockerfile之间的差异？在列表5.3中，我们只安装了生产依赖项，而在列表5.4中，我们安装了所有依赖项，包括我们的开发依赖项。但你是否注意到了最重要的变化？在列表5.3中，我们使用`COPY`指令将我们的代码烘焙到生产Docker镜像中：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That command copies our code into the image. What’s most interesting in the
    development version of the Dockerfile is what’s missing. You’ll note there is
    *no* `COPY` instruction for our code in listing 5.4 (although there is one for
    the package.json), and we are, thus, excluding our code from the development Docker
    image! If we bake our code into the image, then we can’t easily change it later.
    If we can’t change our code, then we can’t use live reload.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那个命令将我们的代码复制到镜像中。在Dockerfile的开发版本中最有趣的是缺少的部分。你会注意到，在列表5.4中，我们的代码没有`COPY`指令（尽管有package.json的一个），因此我们排除了我们的代码从开发Docker镜像中！如果我们把我们的代码烘焙到镜像中，那么我们就不容易稍后更改它。如果我们不能更改我们的代码，那么我们就不能使用实时重新加载。
- en: But if we aren’t copying code into our development image, then how will it get
    into the container? We’ll find an answer to this in the next section. For now,
    we still have one more big difference to look at between our development and production
    Dockerfiles.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们没有将代码复制到我们的开发镜像中，那么它将如何进入容器呢？我们将在下一节中找到这个问题的答案。现在，我们还需要看看开发Dockerfile和产品Dockerfile之间还有一个重大差异。
- en: 'Note the `CMD` instruction that specifies how to start our microservice within
    the container. In the production Dockerfile, we simply start the microservice
    using the `npm start` convention that was described in chapter 2:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意指定如何在容器内启动我们的微服务的`CMD`指令。在产品Dockerfile中，我们简单地使用第2章中描述的`npm start`约定启动微服务：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `CMD` instruction in the development Dockerfile is different and does a
    lot more work:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 开发Dockerfile中的`CMD`指令不同，并且做了更多的工作：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command is separated over three lines using the backslash (\) line continuation
    character. The first line configures the npm cache, and the second installs the
    npm. The third line starts the microservice.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令通过反斜杠（\）行续字符在三条线上分开。第一行配置了npm缓存，第二行安装了npm，第三行启动了微服务。
- en: In the production Dockerfile, we invoke `npm install` during the Docker build
    process, which means our dependencies are baked into the image, just as they should
    be in production. In the development version, though, we do the `npm install`
    at container startup. The reason for the difference in development is for better
    performance in doing subsequent rebuilds.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品Dockerfile中，我们在Docker构建过程中调用`npm install`，这意味着我们的依赖项被烘焙到镜像中，正如在生产中应该的那样。然而，在开发版本中，我们在容器启动时执行`npm
    install`。开发中这种差异的原因是为了在后续重建中提供更好的性能。
- en: The `npm install` can take significant time. When we do it at container startup,
    we are able to cache the npm packages on the host operating system. That’s why
    we configured the cache on the first line. Caching our npm packages in this way
    makes subsequent npm installs much faster, and this in turn, makes container startup
    faster. We’ll learn more about how this works in the next section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm install`可能需要很长时间。当我们容器启动时执行它，我们能够在主机操作系统上缓存npm包。这就是为什么我们在第一行配置了缓存。以这种方式缓存我们的npm包使得后续的npm安装变得更快，这反过来又使得容器启动更快。我们将在下一节中了解更多关于它是如何工作的信息。'
- en: The third line of the `CMD` instruction in the development Dockerfile is what
    actually starts the microservice. It invokes `npm script start:dev` to start our
    microservice in development mode with live reload enabled.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 开发Dockerfile中`CMD`指令的第三行实际上是启动微服务。它调用`npm script start:dev`以启用实时重新加载来以开发模式启动我们的微服务。
- en: 5.5.4 Updating the Docker Compose file for live reload
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.4 更新Docker Compose文件以实现实时重新加载
- en: The final part of getting our application-wide live reload working is to make
    some necessary changes to our Docker Compose file to share our code and the npm
    cache between the host operating system and the containers. In this section, we
    use Docker volumes to share the filesystem between our development workstation
    and the container. This means we can edit code in Visual Studio (VS) Code and
    see the changes appear almost immediately in our microservice running in the application
    under Docker Compose.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的应用程序级实时重新加载工作完成的最后部分是对我们的Docker Compose文件进行一些必要的更改，以在主机操作系统和容器之间共享我们的代码和npm缓存。在本节中，我们使用Docker卷在开发工作站和容器之间共享文件系统。这意味着我们可以在Visual
    Studio (VS) Code中编辑代码，并且更改几乎立即在我们的在Docker Compose下运行的微服务中可见。
- en: Listing 5.5 is an extract from the example-1 Docker Compose file that shows
    the configuration for our new history microservice. This is similar to the Docker
    Compose files we created in chapter 4, but there are some differences and new
    additions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5是从example-1 Docker Compose文件中提取的，展示了我们新历史微服务的配置。这与我们在第4章中创建的Docker Compose文件类似，但有一些差异和新增内容。
- en: Listing 5.5 Updating the Docker Compose file for live reload (extract from chapter-5/example-1/docker-compose.yaml)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5 更新Docker Compose文件以实现实时重新加载（第5章/example-1/docker-compose.yaml的提取）
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① Defines the container for our new history microservice
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义了我们的新历史微服务的容器
- en: ② Uses the development version of the Dockerfile
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用Dockerfile的开发版本
- en: ③ Defines volumes that are shared between the host operating system and the
    container
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义了主机操作系统和容器之间共享的卷
- en: ④ Shares the npm cache from the host to the container. This is what allows npm
    modules to be cached, making subsequent installs faster.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 从主机共享npm缓存到容器中。这正是允许npm模块被缓存，使得后续安装更快的原因。
- en: ⑤ Shares the source code directly from the host to the container. You can make
    changes on your development workstation (e.g., using VS Code), and those changes
    are automatically visible within the container.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 直接从主机共享源代码到容器。你可以在你的开发工作站上（例如，使用VS Code）进行更改，这些更改将自动在容器内可见。
- en: The first thing that is new in listing 5.5 is that we now use `Dockerfile-dev`,
    which is the development version of our Dockerfile. I mentioned back in chapter
    4 that we could omit the `dockerfile` field and that it would default to `Dockerfile`.
    In chapter 4, we didn’t leave it at the default value; instead, we explicitly
    set it to `Dockerfile`. I indicated that we’d need to explicitly set this in the
    near future. Well, this is where we are at now, and we are explicitly setting
    it to `Dockerfile-dev` to use the development version of our Dockerfile.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5中新的第一点是，我们现在使用`Dockerfile-dev`，这是我们的Dockerfile的开发版本。我在第4章提到，我们可以省略`dockerfile`字段，并且它将默认为`Dockerfile`。在第4章中，我们没有将其设置为默认值；相反，我们明确将其设置为`Dockerfile`。我指出，我们将在不久的将来明确设置它。好吧，现在我们就到了这里，我们明确将其设置为`Dockerfile-dev`以使用我们的Dockerfile的开发版本。
- en: The next thing that is new is the addition of the `volumes` field, where we
    create some Docker volumes to connect the filesystem on our development workstation
    with the filesystem of the container. This links our source code directly into
    the container. It’s the reason why we didn’t bake our code directly into the image.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来新的内容是添加了`volumes`字段，我们在其中创建了一些Docker卷来连接我们的开发工作站上的文件系统与容器的文件系统。这直接将我们的源代码链接到容器中。这也是我们没有直接将代码烘焙到镜像中的原因。
- en: To share the code, we use one Docker volume. The other volume creates a shared
    directory for the npm cache. This allows npm packages that are installed in the
    container to be cached on the host operating system so that, if we destroy and
    recreate the container, subsequent npm installs are faster because we have retained
    the cache outside of the container.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了共享代码，我们使用一个Docker卷。另一个卷创建了一个用于npm缓存的共享目录。这允许在容器中安装的npm包在主机操作系统上被缓存，这样，如果我们销毁并重新创建容器，后续的npm安装会更快，因为我们已经保留了容器外的缓存。
- en: 'In case you were wondering about the `z` flag used in the volume configuration
    in listing 5.5, that simply indicates to Docker that the volume is to be shared
    (potentially among multiple containers). If you like, you can read more about
    it here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对列表5.5中卷配置中使用的`z`标志感到好奇，这仅仅是指示Docker该卷是要共享的（可能是在多个容器之间）。如果你愿意，你可以在这里了解更多信息：
- en: '[https://docs.docker.com/storage/bind-mounts/](https://docs.docker.com/storage/bind-mounts/)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/storage/bind-mounts/](https://docs.docker.com/storage/bind-mounts/)'
- en: 'This has been quite a lot to take in, and so far, it’s only for the history
    microservice! We’ll need to make these changes to all our microservices. Fortunately,
    we can just use the same pattern and apply it to each microservice as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经有很多东西要吸收了，到目前为止，这只是为了历史微服务！我们需要对所有微服务进行这些更改。幸运的是，我们只需使用相同的模式并将其应用于每个微服务，如下所示：
- en: Install nodemon for each microservice.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个微服务安装nodemon。
- en: Update package.json and implement the start:dev script to start the microservice
    with nodemon (as in listing 5.3).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新package.json并实现start:dev脚本来使用nodemon启动微服务（如列表5.3所示）。
- en: Create development and production versions of our Dockerfiles. The development
    Dockerfile should not copy the code into the image (as in listing 5.4).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的Dockerfile的开发和生成版本。开发Dockerfile不应该将代码复制到镜像中（如列表5.4所示）。
- en: Do the `npm install` on container startup; only for development, not production
    (this is for performance, as in listing 5.4).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器启动时执行`npm install`；仅限开发，不用于生产（这是为了性能，如列表5.4所示）。
- en: Update the Docker Compose file so that it uses the development Dockerfile (as
    in listing 5.5).
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新Docker Compose文件，使其使用开发Dockerfile（如列表5.5所示）。
- en: Add Docker volumes to the Docker Compose file so that the source code and npm
    cache are shared into the container (as in listing 5.5).
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker Compose文件中添加Docker卷，以便将源代码和npm缓存共享到容器中（如列表5.5所示）。
- en: I’ve gone ahead and done this already for all examples in the chapter 5 repository
    so you don’t have to worry about it. But you should at least start example-1 and
    then make some code changes to the history microservice so that you can see live
    reload in action! So let’s do that now.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为第5章仓库中的所有示例都做了这件事，所以你不必担心。但你应该至少启动example-1，然后对历史微服务进行一些代码更改，这样你就可以看到实时重新加载的效果！所以现在让我们来做这件事。
- en: 5.5.5 Trying out live reload
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.5 尝试实时重新加载
- en: 'Enough looking at code listings! It’s time to see live reload in action so
    you can truly appreciate how useful it is. Open a terminal and change directory
    to the example-1 subdirectory under the chapter-5 code repository. Then use Docker
    Compose to start the application:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 看代码列表已经够多了！现在是时候看到实时重新加载的效果，这样你才能真正欣赏它的有用性。打开一个终端，切换到chapter-5代码仓库下的example-1子目录。然后使用Docker
    Compose启动应用程序：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example contains the simplified video-streaming microservice and the new
    stub history microservice. Check the output from Docker Compose. You should see
    “Hello world!” printed out by the stub history microservice as it starts up. To
    test live reload, we’ll change the message that is printed by the history microservice:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子包含了简化的视频流微服务和新的存根历史微服务。检查Docker Compose的输出。你应该会看到存根历史微服务启动时打印出“Hello world!”。为了测试实时重新加载，我们将更改历史微服务打印的消息：
- en: Open the example-1 directory in VS Code.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开example-1目录。
- en: Find and open the index.js file for the history microservice.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到并打开历史微服务的index.js文件。
- en: Search for the line of code that prints the “Hello world!” message and change
    this line of code to print “Hello computer!” instead.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索打印“Hello world!”消息的代码行，并将此代码行更改为打印“Hello computer!”。
- en: Save the index.js file and then switch back to the Docker Compose output.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存index.js文件，然后切换回Docker Compose输出。
- en: If you switched over quickly enough, you’ll see the history microservice being
    reloaded and printing your updated message. If you weren’t quick enough, you should
    see that this has already happened. When you do this, note that the video-streaming
    microservice didn’t reload. That’s because we didn’t change its code. Only the
    history microservice was updated so only it reloaded.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你切换得足够快，你会看到历史微服务正在重新加载并打印你的更新消息。如果你切换得不够快，你应该看到这已经发生了。当你这样做的时候，请注意视频流微服务并没有重新加载。那是因为我们没有更改它的代码。只有历史微服务被更新了，所以只有它重新加载了。
- en: This is the promise of live reload. We can update our code in quick iterations
    and receive fast and direct feedback. We don’t have to wait to build and start
    the entire application. Instead, we can *hot reload* the code for each microservice
    that needs to be updated.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是实时重新加载的承诺。我们可以快速迭代更新我们的代码并快速直接地获得反馈。我们不必等待构建和启动整个应用程序。相反，我们可以为需要更新的每个微服务*热加载*代码。
- en: So what happens if we introduce an error in our code? What do we see when a
    microservice reloads with an error? The error is displayed in the Docker Compose
    output. We can then correct the error and save the code file. The microservice
    automatically reloads, and assuming our change actually fixes the error, we should
    see clean output from the updated microservice.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们代码中引入了错误会发生什么？当微服务带有错误重新加载时，我们会看到什么？错误会在Docker Compose输出中显示。然后我们可以纠正错误并保存代码文件。微服务会自动重新加载，并且假设我们的更改实际上修复了错误，我们应该会看到更新后的微服务的干净输出。
- en: At this point, I’ll actually recommend that you try and break the history microservice
    to see what happens. Go on. Open the index.js file for it and type some random
    gibberish that’s sure to break it. Save the file and switch back to the Docker
    Compose output to see the result.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我实际上建议你尝试破坏历史微服务，看看会发生什么。继续。打开它的index.js文件，输入一些肯定会导致它崩溃的随机胡言乱语。保存文件，然后切换回Docker
    Compose输出以查看结果。
- en: Ask yourself what the error message means and what did I do that caused it?
    Now I hear you say, “But Ash, we’d like to keep our code working, so why are we
    trying to break it?”
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 问问自己错误信息是什么意思，我做了什么导致了它？现在我听到你说，“但是Ash，我们希望保持代码的正常工作，那么我们为什么要尝试破坏它？”
- en: It’s actually good to practice breaking and fixing your code in a controlled
    and safe environment. That way, when it comes to encountering real problems in
    the wild, you’ll be more experienced and have a better understanding of the error
    messages and how to deal with these. Spend some time now breaking the code; cause
    problems and try to have some fun while you’re at it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在受控和安全的环境中练习破坏和修复代码是很好的。这样，当遇到野外真实问题时，你会更有经验，并且对错误信息和如何处理这些问题会有更好的理解。现在花点时间破坏代码；造成问题，并在过程中找点乐趣。
- en: Forcing a container to restart
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 强制容器重新启动
- en: Every so often we might want to force a reload of a microservice that hasn’t
    changed. Say the microservice has hung or crashed and is now stuck. With our live
    reload system, we can make a container restart simply by changing the code, for
    example, adding some whitespace and then saving the file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能想要强制重新加载一个没有更改的微服务。比如说，微服务已经挂起或崩溃，现在卡住了。使用我们的实时重新加载系统，我们可以通过更改代码来简单地使容器重新启动，例如，添加一些空白字符，然后保存文件。
- en: Actually, we don’t even need to go that far. We can simply save the file in
    VS Code, and that’s enough to make the container restart. We don’t need to make
    the change!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们甚至不需要走那么远。我们只需在VS Code中保存文件就足够了，这样就可以使容器重新启动。我们不需要做出更改！
- en: 'If you have access to the `touch` command from your terminal, you can also
    trigger live reload from the command line for the history microservice as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以从终端访问`touch`命令，你也可以像以下这样从命令行触发历史微服务的实时重新加载：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you don’t have live reload set up for a particular container (you only really
    need live reload for microservices whose code changes frequently), then you can
    use the Docker Compose `restart` command to make a container restart; for example,
    to force the history microservice to restart, type
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有为特定容器设置实时重新加载（你实际上只需要为代码频繁更改的微服务使用实时重新加载），那么你可以使用Docker Compose的`restart`命令来使容器重新启动；例如，要强制历史微服务重新启动，请输入
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 5.5.6 Testing production mode in development
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.6 在开发中测试生产模式
- en: So far, in this chapter, we’ve split our Dockerfiles into separate files so
    that we can have different versions for development mode and production mode,
    but we aren’t making use of the production Dockerfiles yet. This will change in
    chapter 7, when we deploy to production. For now, just be aware that we won’t
    test our application in production mode quite as frequently as we test it during
    development.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经将我们的Dockerfile拆分为单独的文件，以便我们可以为开发模式和生产模式拥有不同的版本，但我们还没有使用生产Dockerfile。这将在第7章中改变，当我们部署到生产环境时。现在，只需注意，我们不会像在开发期间那样频繁地在生产模式下测试我们的应用程序。
- en: During development, we’ll constantly make small incremental code changes and
    then test that our application still works. Even though we aren’t making quite
    as frequent use of our production Dockerfiles as the development version, we should
    still keep these updated alongside the development versions. We should also regularly
    test in production, albeit less frequently than we test in development.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们将不断进行小的增量代码更改，然后测试我们的应用程序是否仍然正常工作。尽管我们并不像开发版本那样频繁地使用我们的生产Dockerfile，但我们仍然应该与开发版本一起更新这些文件。我们还应该定期在生产环境中进行测试，尽管不如开发期间频繁。
- en: For example, you might be testing in development mode every few minutes as you
    make code changes. You still want to test production mode, but maybe, you’ll only
    do that every few hours after substantial code changes have been accumulated.
    The main point is that you also need to test your production Dockerfiles even
    before you deploy these to production. What you don’t want is to unwittingly bank
    up hidden problems that will only be revealed *after* deployment to production.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能每几分钟就在开发模式下进行一次测试，因为你正在修改代码。你仍然想测试生产模式，但也许，你只有在积累了大量代码更改之后，每隔几个小时才进行一次。主要观点是，在你将这些部署到生产之前，你也需要测试你的生产
    Dockerfile。你不想无意中积累隐藏的问题，这些问题只有在部署到生产后才会暴露出来。
- en: 'You can easily and preemptively solve this problem by testing regularly in
    production mode on your development workstation. Usually, what I do to make this
    easier is to have two separate Docker Compose files: one for development and the
    other for production.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在开发工作站上定期以生产模式进行测试来轻松且主动地解决这个问题。通常，我会做的是有两个单独的 Docker Compose 文件：一个用于开发，另一个用于生产。
- en: 'When you invoke Docker Compose, you can use the `-f` argument to specify the
    Docker Compose file. For instance, if you want to run your application in production
    mode on your development workstation, you might like to create a separate *production*
    version of your Docker Compose file and run it like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 Docker Compose 时，可以使用 `-f` 参数来指定 Docker Compose 文件。例如，如果你想在你开发工作站上以生产模式运行你的应用程序，你可能想创建一个单独的
    *生产* 版本的 Docker Compose 文件并像这样运行它：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can get away with having a single Docker Compose file that is parameterized
    by an environment variable, but generally, I keep separate versions for testing
    development and production. That’s because I like to have my production Docker
    Compose file mimic the real production environment as much as feasible. Also,
    usually my development version will replace various microservices with mock versions
    for easier and faster testing.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有一个单一的 Docker Compose 文件，该文件由环境变量参数化，但通常我会为测试开发和生产保留不同的版本。这是因为我喜欢让我的生产 Docker
    Compose 文件尽可能地模仿真实的生产环境。此外，通常我的开发版本会用模拟版本替换各种微服务，以便更容易和更快地进行测试。
- en: We’ll talk about mocking microservices in chapter 9\. And in chapter 8, we’ll
    cover automated testing, which is another thing that can enhance your productivity.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 9 章中讨论模拟微服务。在第 8 章中，我们将介绍自动化测试，这是可以增强你生产力的另一个方面。
- en: 5.5.7 What have we achieved?
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.7 我们取得了什么成果？
- en: In section 5.5, we configured our microservices for live reload. We started
    with the history microservice and applied the same pattern to the video-streaming
    microservice. From now on, we’ll use this for all our microservices.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5.5 节中，我们为我们的微服务配置了实时重新加载。我们从历史微服务开始，并将相同的模式应用到视频流微服务上。从现在起，我们将为此使用所有我们的微服务。
- en: We did this because it takes significant time to build and start our application.
    We don’t want to build and restart our application for each line of code that
    we change. Instead, we want to be able to quickly change code to experiment and
    iterate quickly and have the application automatically update itself. Now, we
    can edit code and our microservices will automatically restart. That’s why this
    is called *live reload--*it reloads automatically while you are coding.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为构建和启动我们的应用程序需要花费相当多的时间。我们不希望每次更改代码时都构建和重新启动我们的应用程序。相反，我们希望能够快速更改代码以进行实验和快速迭代，并让应用程序自动更新自己。现在，我们可以编辑代码，我们的微服务将自动重启。这就是为什么这被称为
    *实时重新加载--* 它在你编码时自动重新加载。
- en: This makes for a very efficient and effective workflow. We can now continuously
    evolve our microservices application while receiving a constant stream of feedback.
    Browse the code in example-1 and make sure you understand how the live reload
    configuration is applied across the entire application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得工作流程非常高效和有效。我们现在可以持续演进我们的微服务应用程序，同时接收持续的反馈流。浏览 example-1 中的代码，确保你理解实时重新加载配置是如何在整个应用程序中应用的。
- en: 5.6 Methods of communication for microservices
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 微服务通信方法
- en: 'After that interlude of upgrading our development environment to support application-wide
    live reload, let’s now return to the main topic of this chapter: exploring mechanisms
    for communication between microservices. But before we dive into the technology
    for communication, we’ll start with a high-level overview of the two styles of
    communication used by microservices: direct messaging and indirect messaging,
    also commonly known as *synchronous* and *asynchronous* communication.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在升级我们的开发环境以支持应用程序范围实时重载的间歇之后，现在让我们回到本章的主题：探索微服务之间的通信机制。但在我们深入研究通信技术之前，我们将从对微服务使用的两种通信风格的高级概述开始：直接消息和间接消息，也通常称为
    *同步* 和 *异步* 通信。
- en: I prefer to use the terms direct and indirect messaging rather than synchronous
    and asynchronous messaging because the words “synchronous” and “asynchronous”
    have a different meaning in normal computer programming. Also, the concept of
    asynchronous programming, especially, can be difficult to learn and has sent chills
    down the spines of many aspiring coders. Don’t be concerned; we will avoid using
    the word asynchronous.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用“直接消息”和“间接消息”这样的术语，而不是“同步消息”和“异步消息”，因为“同步”和“异步”这两个词在常规计算机编程中具有不同的含义。此外，异步编程的概念，尤其是，可能很难学习，并且让许多有志于编程的人感到寒心。不要担心；我们将避免使用“异步”这个词。
- en: 5.6.1 Direct messaging
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.1 直接消息
- en: '*Direct* *messaging* simply means that one microservice directly sends a message
    to another microservice and then receives an immediate and direct response. Direct
    messaging is used when we’d like one microservice to directly message a particular
    microservice and immediately invoke an action or task within it.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*直接* *消息* 简单来说就是指一个微服务直接向另一个微服务发送消息，然后立即接收直接响应。当希望一个微服务直接向特定微服务发送消息并立即在其中调用动作或任务时，会使用直接消息。'
- en: Direct messaging is also used for triggering a direct action in another microservice.
    We can also use it to sequence a strict series of behaviors across multiple microservices.
    You can think of this as sending commands or instructions to another microservice
    (e.g., *do this* or *do that* and then *tell me* if you were successful).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 直接消息也用于在另一个微服务中触发直接动作。我们还可以用它来在多个微服务之间按顺序执行一系列严格的行为。你可以将其视为向另一个微服务发送命令或指示（例如，*这样做*
    或 *那样做* 然后告诉我*你是否成功*）。
- en: The recipient microservice can’t ignore or avoid the incoming message. If it
    were to do so, the sender will know about it directly from the response. Figure
    5.5 shows how the video-streaming microservice directs the viewed message to the
    history microservice, which provides a direct and immediate response.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接收微服务不能忽略或避免传入的消息。如果它这样做，发送者将直接从响应中得知。图 5.5 展示了视频流微服务如何将查看的消息直接发送到历史微服务，该服务提供直接且即时的响应。
- en: Direct messaging is often required for certain use cases. It has the major drawback
    that it requires the tight coupling of the two microservices that are at either
    end of the communication. Often, we’d prefer to avoid the tight coupling between
    our microservices, and for that reason, we’ll make frequent use of indirect messaging
    instead of direct messaging.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些用例中，通常需要使用直接消息。它的主要缺点是它要求通信两端两个微服务紧密耦合。我们通常更愿意避免微服务之间的紧密耦合，因此我们将频繁使用间接消息而不是直接消息。
- en: '![](../Images/CH05_F05_Davis4.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F05_Davis4.png)'
- en: Figure 5.5 A direct message is sent to the history microservice explicitly by
    its name and is handled immediately.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 通过名称显式发送直接消息到历史微服务，并立即处理。
- en: 5.6.2 Indirect messaging
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.2 间接消息
- en: '*Indirect* *messaging* introduces an intermediary between the endpoints in
    the communication process. We add a middleman to sit between our microservices.
    For that reason, the two parties of the communication don’t actually have to know
    about each other. This style of communication results in a much looser coupling
    between our microservices. It means two things:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*间接* *消息* 在通信过程的两端之间引入了一个中介。我们在微服务之间添加了一个中间人。因此，通信的双方实际上不必相互了解。这种通信方式导致我们的微服务之间的耦合更加松散。这意味着两件事：'
- en: '*Messages are sent via an intermediary so that both sender and receiver of
    the messages don’t know which other microservice is involved.* In the case of
    the sender, it doesn’t even know if any other microservice will receive the message
    at all!'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消息通过中介发送，这样消息的发送者和接收者都不知道涉及了哪个其他微服务。* 对于发送者来说，甚至不知道是否有其他微服务会接收这条消息！'
- en: '*Because the receiver doesn’t know which microservice has sent the message,
    it can’t send a direct reply.* This means that this style of communication can’t
    be applied in situations where a direct response is required for confirming success
    or failure.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*因为接收者不知道哪个微服务发送了消息，所以它不能发送直接的回复。* 这意味着这种通信方式不能应用于需要直接响应以确认成功或失败的情况。'
- en: We should use indirect messages when the sending microservice doesn’t care if
    any subsequent action has been taken or not. We can also use it to broadcast messages
    to the entire application (e.g., a notification of an important event that other
    microservices would like to know about).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送微服务不在乎是否采取了后续操作时，我们应该使用间接消息。我们还可以用它向整个应用程序广播消息（例如，通知其他微服务可能感兴趣的重要事件）。
- en: Note We use indirect messaging to announce important events that don’t need
    a direct response. This kind of messaging allows a more flexible communication
    structure than direct messages and makes for less coupling between our microservices.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们使用间接消息来宣布不需要直接响应的重要事件。这种消息方式比直接消息提供了更灵活的通信结构，并且减少了我们的微服务之间的耦合。
- en: Figure 5.6 shows how the video-streaming microservice (on the left) sends an
    indirect message through a message queue (the intermediary) to the history microservice
    (on the right). Note that there is no direct connection between the video-streaming
    and history microservices. This is why we can say they are *loosely coupled*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 展示了视频流微服务（在左侧）如何通过消息队列（中介）向历史微服务（在右侧）发送间接消息。请注意，视频流微服务和历史微服务之间没有直接连接。这就是为什么我们可以说它们是
    *松散耦合* 的。
- en: '![](../Images/CH05_F06_Davis4.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F06_Davis4.png)'
- en: Figure 5.6 An indirect message isn’t explicitly sent to a microservice; instead,
    the message is placed in a queue and can be handled later.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 一个间接消息不会明确发送给微服务；相反，消息被放置在队列中，可以在稍后处理。
- en: Indirect messaging can help us to build flexible messaging architectures to
    solve many complicated communication problems. Unfortunately, with this flexibility
    comes increased complexity. And as your application grows, you will find it more
    difficult to map the communication pathways precisely because these are not direct
    and, therefore, not as obvious. With this overview of direct and indirect messaging
    out of the way, we can dive head first into actually trying out each of these
    communication methods.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 间接消息可以帮助我们构建灵活的消息架构来解决许多复杂的通信问题。不幸的是，这种灵活性带来了更高的复杂性。随着你的应用程序的增长，你会发现更难精确地映射通信路径，因为这些路径不是直接的，因此也不那么明显。在了解了直接和间接消息的概述之后，我们可以一头扎进尝试每种通信方法。
- en: 5.7 Direct messaging with HTTP
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7 使用 HTTP 进行直接消息传递
- en: 'In the previous chapter, we used HTTP for data retrieval, which retrieved our
    streaming video from storage. In this chapter, we use HTTP for a different purpose:
    sending direct messages from one microservice to another.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用 HTTP 进行数据检索，从存储中检索了我们的流媒体视频。在本章中，我们使用 HTTP 达到不同的目的：从一个微服务向另一个微服务发送直接消息。
- en: Note Messages sent with HTTP requests have direct responses. We can know immediately
    if the handling of the message succeeded or failed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用 HTTP 请求发送的消息会有直接的响应。我们可以立即知道消息的处理是成功还是失败。
- en: Specifically, in this section, we’ll use HTTP POST requests to send messages
    directly from the video-streaming microservice to the history microservice. Figure
    5.7 shows this process.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本节中，我们将使用 HTTP POST 请求直接从视频流微服务向历史微服务发送消息。图 5.7 展示了这一过程。
- en: '![](../Images/CH05_F07_Davis4.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F07_Davis4.png)'
- en: Figure 5.7 An HTTP POST request explicitly targets another microservice by name.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 HTTP POST 请求通过名称显式地针对另一个微服务。
- en: 5.7.1 Why HTTP?
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7.1 为什么使用 HTTP？
- en: Hypertext transfer protocol (HTTP) is the language and foundation of the world
    wide web and is the defacto standard when creating a *web service*. It’s well
    understood by everyone, and it’s something we can depend on.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本传输协议（HTTP）是万维网的语言和基础，在创建 *网络服务* 时是事实上的标准。它被每个人所理解，并且是我们可以依赖的东西。
- en: HTTP is already ubiquitous for creating representational state transfer (REST)
    APIs, and we don’t need to think too hard about why we should use it. It was made
    for this kind of thing, and it’s supported by every programming language we would
    care to work with. We also have easy access to huge amounts of learning resources
    related to it, and ironically, this information will most likely be delivered
    to us via the HTTP protocol that is underlying the world wide web.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 已经被广泛用于创建表示状态转移（REST）API，我们不需要太费脑筋去想为什么我们应该使用它。它是为此类事情而设计的，并且被我们愿意与之合作的每一种编程语言所支持。我们还可以轻松访问与之相关的海量学习资源，而且讽刺的是，这些信息很可能会通过互联网世界万维网底层的
    HTTP 协议传递给我们。
- en: 5.7.2 Directly targeting messages at particular microservices
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7.2 直接针对特定微服务发送消息
- en: Before we can send a message to a microservice, we need a way to locate it.
    Accompanying HTTP is another internet protocol called *domain name system* (DNS).
    This gives us a simple and almost automatic means by which to direct messages
    at microservices using their names.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向微服务发送消息之前，我们需要一种方法来定位它。与 HTTP 伴随的是另一种互联网协议，称为 *域名系统*（DNS）。这为我们提供了一种简单且几乎自动的方法，可以通过微服务的名称将消息直接发送到微服务。
- en: A key question with microservices communication is how do we direct a message
    to another microservice? The simplest answer to this question is the ubiquitous
    DNS, which translates hostnames to IP addresses. This works automatically with
    Docker Compose (the container name is the hostname) and doesn’t require much effort
    to have it work within our production Kubernetes cluster.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 关于微服务通信的一个关键问题是，我们如何将消息定向到另一个微服务？对这个问题的最简单答案是无处不在的 DNS，它将主机名转换为 IP 地址。这在使用 Docker
    Compose（容器名称是主机名）时自动工作，并且不需要太多努力就可以在我们的生产 Kubernetes 集群中使其工作。
- en: Figure 5.8 shows how we can send an HTTP POST message to a particular hostname.
    A lookup of the DNS is done automatically when sending an HTTP request, and it
    translates our hostname to the internet protocol (IP) address of the microservice.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 显示了我们可以向特定的主机名发送 HTTP POST 消息。在发送 HTTP 请求时，会自动进行 DNS 查找，并将我们的主机名转换为微服务的互联网协议（IP）地址。
- en: '![](../Images/CH05_F08_Davis4.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F08_Davis4.png)'
- en: Figure 5.8 HTTP requests are routed through the DNS lookup to translate the
    hostname of the target microservice to an internet protocol (IP) address.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 显示了 HTTP 请求是如何通过 DNS 查找将目标微服务的主机名转换为互联网协议（IP）地址的。
- en: The IP address is the string of numbers that represents the unique internet
    location for our microservice. Note that just because it’s an IP address doesn’t
    necessarily mean we are talking about the public internet. The IP address, in
    this case, actually represents a private server that is located in a private network,
    either operating under the Docker runtime on our development workstation or operating
    within our production Kubernetes cluster. It is the IP address that we need to
    direct a message at a recipient using an HTTP request, and DNS operates automatically
    and almost magically under the hood when we make the request.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址是一串数字，代表我们微服务的唯一互联网位置。请注意，仅仅因为它是 IP 地址，并不意味着我们正在谈论公共互联网。在这种情况下，IP 地址实际上代表一个位于私有网络中的私有服务器，无论是在我们的开发工作站上运行
    Docker 运行时，还是在我们的生产 Kubernetes 集群内部运行。这是我们需要在发送 HTTP 请求时指向接收者的消息的 IP 地址，并且当我们发起请求时，DNS
    会自动且几乎神奇地在幕后工作。
- en: Using Docker and Docker Compose for development as we have been doing means
    that DNS works automatically, and we can rely on it. When we deploy to our production
    Kubernetes cluster, we’ll have some more work to make our microservices accessible
    via DNS, but we’ll address that in chapter 7.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所做的那样，使用 Docker 和 Docker Compose 进行开发意味着 DNS 会自动工作，我们可以依赖它。当我们部署到我们的生产 Kubernetes
    集群时，我们将有一些额外的工作来使我们的微服务可以通过 DNS 访问，但我们将在这第 7 章中讨论这个问题。
- en: 5.7.3 Sending a message with HTTP POST
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7.3 使用 HTTP POST 发送消息
- en: 'There are two sides to the messaging equation: one microservice sends a message
    and another receives it. In this section, we examine how to send a message using
    an HTTP POST request.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递方程有两个方面：一个微服务发送消息，另一个接收消息。在本节中，我们将探讨如何使用 HTTP POST 请求发送消息。
- en: In section 4.4.2, we looked at an HTTP GET request that was forwarded from one
    microservice to another. We did that then using the builtin Node.js http library.
    We’ll use that library again to make a request from one microservice to another.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 4.4.2 节中，我们查看了一个从微服务转发到另一个微服务的 HTTP GET 请求。我们当时使用内置的 Node.js http 库来做这件事。我们将再次使用这个库从一个微服务向另一个微服务发送请求。
- en: Listing 5.6 is an extract from an updated index.js file from the example-2 video-streaming
    microservice that shows how to send an HTTP POST message. It implements a new
    function, `sendViewedMessage`, that sends the viewed message to the history microservice
    whenever a user starts watching a video.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 是从示例 2 视频流微服务的更新后的 index.js 文件中摘取的，展示了如何发送 HTTP POST 消息。它实现了一个新的函数 `sendViewedMessage`，当用户开始观看视频时，该函数会将查看的消息发送到历史微服务。
- en: Listing 5.6 Sending a direct message with HTTP POST (extract from chapter-5/example-2/video-streaming/index.js)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 使用 HTTP POST 发送直接消息（摘自第 5 章/示例 2/video-streaming/index.js）
- en: '[PRE15]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① A helper function that sends the viewed message to the history microservice
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ① 一个辅助函数，用于将查看的消息发送到历史微服务。
- en: ② Configures options for the HTTP request
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ② 配置 HTTP 请求的选项。
- en: ③ Sets the HTTP method to POST
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置 HTTP 方法为 POST。
- en: ④ Sets the content type for the body of the HTTP request
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置 HTTP 请求主体的内容类型。
- en: ⑤ The body of the HTTP request defines the message payload; this is the data
    we send with the message.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ HTTP 请求的主体定义了消息负载；这是我们随消息发送的数据。
- en: ⑥ Sends the HTTP request to the history microservice
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 将 HTTP 请求发送到历史微服务。
- en: ⑦ Sets the URL for the HTTP request, which identifies the history microservice
    and the viewed message
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 设置 HTTP 请求的 URL，该 URL 识别历史微服务和查看消息。
- en: ⑧ This function is called when the request completes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 当请求完成时调用此函数。
- en: ⑨ Handles any errors that might have occurred
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 处理可能发生的任何错误。
- en: ⑩ Writes the body to the request
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 将主体写入请求。
- en: ⑪ Finalizes the request
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 完成请求。
- en: We call the function `http.request` to create the HTTP POST request. We direct
    the request to the history microservice using the URL http://history/viewed. This
    URL incorporates both the hostname (`history` in this case) and the route (`viewed`
    in this case). It is this combination that identifies the target microservice
    and the message we send to it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `http.request` 函数来创建 HTTP POST 请求。我们使用 URL http://history/viewed 将请求定向到历史微服务。这个
    URL 结合了主机名（在这种情况下是 `history`）和路由（在这种情况下是 `viewed`）。正是这种组合识别了目标微服务和发送给它的消息。
- en: Separate callback functions handle the success and the failure of the request.
    It is here where we can detect an error and take subsequent remedial action. Otherwise,
    if it succeeds, we might want to invoke follow up actions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 分别处理请求的成功和失败回调函数。正是在这里，我们可以检测到错误并采取后续的补救措施。否则，如果请求成功，我们可能希望调用后续操作。
- en: 5.7.4 Receiving a message with HTTP POST
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7.4 使用 HTTP POST 接收消息
- en: On the other side of the equation, we receive HTTP POST messages by creating
    an Express route handler in the receiving microservice. Listing 5.7 shows an extract
    of the index.js file for the history microservice, which demonstrates this.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在等式的另一边，我们通过在接收微服务中创建 Express 路由处理程序来接收 HTTP POST 消息。列表 5.7 展示了历史微服务的 index.js
    文件摘录，展示了这一点。
- en: The updated `setupHandlers` function adds an HTTP POST handler for the `viewed`
    route to receive incoming messages. In this listing, we simply store the received
    messages in the database to keep a record of the viewing history.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的 `setupHandlers` 函数为 `viewed` 路由添加了一个 HTTP POST 处理程序以接收传入的消息。在这个列表中，我们只是将接收到的消息存储在数据库中，以保留查看历史记录。
- en: Listing 5.7 Receiving a direct message with HTTP POST (extract from chapter-5/example-2/history/index.js)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 使用 HTTP POST 接收直接消息（摘自第 5 章/示例 2/history/index.js）
- en: '[PRE16]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Handles the viewed message received via an HTTP POST request
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ① 处理通过 HTTP POST 请求接收到的查看消息。
- en: ② Extracts data from the JSON body of the HTTP request
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从 HTTP 请求的 JSON 主体中提取数据。
- en: ③ Records the view in the database
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在数据库中记录视图。
- en: 'Did you notice in the HTTP POST handler how we access the body of the request
    through `req.body`? We treated the body of the request as the message *payload*.
    The `body` variable was automatically parsed from the JSON format because we used
    the body-parser middleware for Express, installed like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到了在 HTTP POST 处理程序中我们是如何通过 `req.body` 访问请求体的？我们将请求体作为消息 *负载* 处理。由于我们使用了
    Express 的 body-parser 中间件，`body` 变量被自动解析为 JSON 格式，安装方式如下：
- en: '[PRE17]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you are interested in seeing how the body-parser middleware is added to Express,
    look at the code file chapter-5/example-2/history/index.js.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对如何将 body-parser 中间件添加到 Express 感兴趣，请查看代码文件 chapter-5/example-2/history/index.js。
- en: 5.7.5 Testing the updated application
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7.5 测试更新后的应用程序
- en: 'Now it’s time to test our latest code and see for yourself how this kind of
    messaging operates. Open a terminal, change to the example-2 directory, and start
    the application in the usual way:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试我们最新的代码，亲自看看这种消息操作是如何进行的了。打开一个终端，切换到 example-2 目录，并按常规方式启动应用程序：
- en: '[PRE18]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you get any errors about containers already created, it might be because
    you left the previous example running. When moving on from each example, be sure
    to shut it down using
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到任何关于容器已创建的错误，可能是因为你留下了上一个示例在运行。在从每个示例继续之前，务必使用
- en: '[PRE19]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Wait for the microservices to come online and then point your browser to http://localhost:4001/video.
    The test video will play.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 等待微服务上线，然后将浏览器指向 http://localhost:4001/video。测试视频将开始播放。
- en: Switch back to the terminal to see the Docker Compose output. You should see
    output confirming that the video-streaming microservice sent a viewed message,
    followed up by some text that shows the history microservice received the message.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回终端以查看 Docker Compose 输出。你应该会看到确认视频流微服务发送了已查看消息的输出，随后是一些显示历史微服务接收了消息的文本。
- en: At this point, we can directly check to make sure that the “view” was stored
    in the database. You’ll need a database viewer installed. If you have Robo 3T
    installed from chapter 4, you can use that.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以直接检查以确保“查看”操作已存储在数据库中。你需要安装数据库查看器。如果你已经从第 4 章安装了 Robo 3T，你可以使用它。
- en: Connect your database viewer to the database (connect on localhost:4000 as the
    port that is configured in the Docker Compose file), then look at the videos collection
    of the history database and confirm that a new record is created each time you
    refresh your browser. Checking the database is a practical way to test the end
    result of this code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的数据库查看器连接到数据库（在 localhost:4000 上连接，这是 Docker Compose 文件中配置的端口），然后查看历史数据库的视频集合，确认每次刷新浏览器时都会创建一个新的记录。检查数据库是测试代码最终结果的一种实用方法。
- en: 5.7.6 Sequencing direct messages
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7.6 直接消息的顺序
- en: A potential benefit of direct messaging is the ability to have one controller
    microservice that can orchestrate complex sequences of behavior across multiple
    other microservices. Because direct messages have a direct response, this allows
    a single microservice to coordinate or orchestrate the activities of multiple
    other microservices.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 直接消息的一个潜在好处是能够拥有一个控制器微服务，它可以协调多个其他微服务之间的复杂行为序列。因为直接消息有直接响应，这允许单个微服务协调或编排多个其他微服务的活动。
- en: The reason this type of messaging is called *synchronous communication* is that
    we are able to coordinate messages as shown in figure 5.9\. In the figure, Microservice
    A is coordinating the activities of the other microservices.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的消息被称为 *同步通信* 的原因是我们可以像图 5.9 所示的那样协调消息。在图中，微服务 A 正在协调其他微服务的活动。
- en: '![](../Images/CH05_F09_Davis4.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9](../Images/CH05_F09_Davis4.png)'
- en: Figure 5.9 Direct messaging allows one controller microservice (here, Microservice
    A) to orchestrate complex behaviors across multiple other microservices.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 直接消息允许一个控制器微服务（此处为微服务 A）在多个其他微服务之间编排复杂行为。
- en: Note Direct messaging can be useful to coordinate behaviors in an explicit way
    or well-defined order.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 直接消息可以用来以明确的方式或定义良好的顺序协调行为。
- en: With direct messages, it’s easy to follow the code and understand the sequence
    of messages. You’ll see in a moment that tracing the sequence of indirect messages
    isn’t as easy.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用直接消息，很容易跟踪代码并理解消息的顺序。你很快就会看到追踪间接消息的顺序并不那么容易。
- en: 5.7.7 What have we achieved?
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7.7 我们取得了什么成果？
- en: In section 5.7, we explored using HTTP POST requests to directly send a viewed
    message from microservice to microservice. This is called *direct messaging* because
    we can direct these messages to particular microservices by their name. We can
    also know immediately if the message was handled successfully or if it failed.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 5.7 节中，我们探讨了使用 HTTP POST 请求直接从微服务向微服务发送已查看消息。这被称为 *直接消息*，因为我们可以通过名称直接将这些消息发送到特定的微服务。我们还可以立即知道消息是否成功处理或失败。
- en: It’s best to think of this type of message more as a command or a call to action
    and less as a notification. Due to the synchronous nature of direct messages,
    we can sequence multiple coordinated messages. This is useful when we want a controller
    microservice that orchestrates complex behaviors in other microservices.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将此类消息视为命令或行动呼吁，而不是通知。由于直接消息的同步性质，我们可以对多个协调消息进行排序。当我们想要一个控制器微服务来协调其他微服务的复杂行为时，这很有用。
- en: Although direct messages can be useful and are sometimes necessary, these also
    have some major downsides. For a start, we can only target a single other microservice
    at a time. Direct messages, therefore, don’t work easily when we’d like to have
    a single message received by multiple recipients.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管直接消息可能很有用，有时也是必要的，但它们也有一些主要的缺点。首先，我们一次只能针对一个其他微服务。因此，当我们希望一条消息被多个接收者接收时，直接消息并不容易工作。
- en: In addition, direct messages are a point of high coupling between microservices.
    Sometimes high coupling is necessary, but we’d prefer to avoid it where possible.
    The ability to centrally orchestrate multiple microservices from a controller
    microservice might seem like an advantage, and it certainly can make it easier
    to work out what’s going on in your application.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，直接消息是微服务之间高度耦合的点。有时高度耦合是必要的，但我们更喜欢尽可能避免它。从控制器微服务集中编排多个微服务的能力可能看起来像是一个优势，而且确实可以使了解应用程序中正在发生的事情变得更容易。
- en: But the biggest problem is that this creates a single point of failure for what
    could be a large and complex operation. What happens if the controlling microservice
    crashes while in the middle of the orchestration? Our application might now be
    in an inconsistent state, and it may have lost data. The problems that arise from
    direct messaging can be solved with indirect messaging, and that’s why we now
    turn to RabbitMQ.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 但最大的问题是，这可能会为可能是一个庞大且复杂的操作创建一个单点故障。如果在编排过程中控制微服务崩溃了会发生什么？我们的应用程序现在可能处于不一致的状态，并且可能已经丢失了数据。直接消息引起的问题可以通过间接消息来解决，这就是我们现在转向
    RabbitMQ 的原因。
- en: 5.8 Indirect messaging with RabbitMQ
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.8 使用 RabbitMQ 进行间接消息传递
- en: Now that we have a handle on using HTTP POST requests for direct messages, it’s
    time to look at indirect messaging, which can help us decouple our microservices.
    On the one hand, it can make the architecture of our application more difficult
    to understand. On the other hand, it has many positive side effects for security,
    scalability, extensibility, reliability, and performance.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了使用 HTTP POST 请求进行直接消息的方法，是时候看看间接消息了，这可以帮助我们解耦我们的微服务。一方面，它可能会使我们的应用程序架构更难以理解。另一方面，它对安全性、可扩展性、可扩展性、可靠性和性能有许多积极的副作用。
- en: Note RabbitMQ allows us to decouple message senders from message receivers.
    A sender doesn’t know which, if any, other microservices will handle a message.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：RabbitMQ 允许我们解耦消息发送者与消息接收者。发送者不知道是否还有其他微服务将处理一条消息。
- en: Figure 5.10 shows the structure of our application after the addition of a RabbitMQ
    server. The video-streaming microservice is no longer directly coupled to the
    history microservice. Instead, it is publishing its viewed messages to a message
    queue. The history microservice then pulls messages from the queue in its own
    time.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 展示了在添加 RabbitMQ 服务器后我们应用程序的结构。视频流微服务不再直接耦合到历史微服务。相反，它将查看的消息发布到消息队列。然后，历史微服务在其自己的时间从队列中拉取消息。
- en: '![](../Images/CH05_F10_Davis4.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F10_Davis4.png)'
- en: Figure 5.10 Using RabbitMQ to indirectly send messages to other microservices
    through message queues
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 使用 RabbitMQ 通过消息队列间接向其他微服务发送消息
- en: 5.8.1 Why RabbitMQ?
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.1 为什么选择 RabbitMQ？
- en: RabbitMQ is well known and established software for queuing messages. It is
    in common use by many companies, and it’s my go-to solution for indirect messaging.
    RabbitMQ is stable and mature. It was developed over a decade ago, and among other
    protocols, it implements the Advanced Message Queueing Protocol (AMQP), which
    is an open standard for message-broker communication.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 是一种广为人知且成熟的用于消息队列的软件。许多公司都在普遍使用它，而且它也是我用于间接消息的首选解决方案。RabbitMQ 稳定且成熟。它是在十年前开发的，并且除了其他协议外，它还实现了高级消息队列协议（AMQP），这是一种消息代理通信的开放标准。
- en: Note RabbitMQ is well-known for indirect communication between microservices,
    and it allows for complex and flexible messaging architectures.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：RabbitMQ 以微服务之间的间接通信而闻名，并允许实现复杂和灵活的消息架构。
- en: 'RabbitMQ has libraries for all the popular programming languages, so you’ll
    have no problems using it whatever your tech stack. We are using Node.js, so we’ll
    use the amqplib library available on the npm registry. RabbitMQ is open source
    and fairly easy to get started with. You can find the code for the server here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ为所有流行的编程语言都提供了库，所以无论你的技术栈如何，你都不会有任何问题使用它。我们正在使用Node.js，所以我们将使用npm注册表上可用的amqplib库。RabbitMQ是开源的，并且相对容易入门。你可以在以下链接找到服务器的代码：
- en: '[https://github.com/rabbitmq/rabbitmq-server](https://github.com/rabbitmq/rabbitmq-server)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/rabbitmq/rabbitmq-server](https://github.com/rabbitmq/rabbitmq-server)'
- en: 5.8.2 Indirectly targeting messages to microservices
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.2 间接针对微服务发送消息
- en: With indirect messaging, we aren’t directly targeting any particular microservice,
    but we do still need to direct our messages to something. And that something will
    be a RabbitMQ server. In that server is either a named queue or a message exchange.
    The combination of queues and exchanges gives us a lot of flexibility in how we
    structure our messaging architecture.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用间接消息，我们并不是直接针对任何特定的微服务，但我们仍然需要将我们的消息指向某个东西。而那个东西将是一个RabbitMQ服务器。在那个服务器中，要么是一个命名队列，要么是一个消息交换。队列和交换的组合为我们提供了在结构化我们的消息架构方面的很大灵活性。
- en: Note The message sender uses DNS to resolve the IP address of the RabbitMQ server.
    It then communicates with it to publish a message on a particular named queue
    or exchange. The receiver also uses DNS to locate the RabbitMQ server and communicate
    with it to retrieve the message from the queue. At no point do the sender and
    receiver communicate directly.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：消息发送者使用DNS解析RabbitMQ服务器的IP地址。然后它与它通信，在特定的命名队列或交换上发布消息。接收者也使用DNS定位RabbitMQ服务器并与它通信，从队列中检索消息。在任何时候，发送者和接收者都没有直接通信。
- en: To publish a message to a queue or an exchange, we must first add a RabbitMQ
    server to our application. Then we can use the AMQP code library (called amqplib)
    to send and receive messages.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要向队列或交换发布消息，我们必须首先将RabbitMQ服务器添加到我们的应用程序中。然后我们可以使用AMQP代码库（称为amqplib）来发送和接收消息。
- en: Under the hood, DNS resolves the RabbitMQ hostname to an IP address. Now, rather
    than directing our message to a particular microservice, as we did when sending
    messages via HTTP POST requests, we are instead directing these to a particular
    queue or exchange on our RabbitMQ server with the server located by DNS.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，DNS将RabbitMQ主机名解析为IP地址。现在，我们不再像通过HTTP POST请求发送消息时那样将消息直接指向特定的微服务，而是将这些消息指向通过DNS定位的RabbitMQ服务器上的特定队列或交换。
- en: '![](../Images/CH05_F11_Davis4.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F11_Davis4.png)'
- en: Figure 5.11 A message is sent by pushing it into a RabbitMQ queue.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 通过将消息推入RabbitMQ队列来发送消息。
- en: The transferal of an indirect message is conducted in two parts, so I’ll use
    two diagrams to explain it. We’ll first consider using queues, and later we’ll
    look at using an exchange. Figure 5.11 shows the video-streaming microservice
    *pushing* its message to the *viewed* queue. Then in figure 5.12, we can see the
    history microservice *pulling* the message from the queue.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 间接消息的传输分为两部分进行，所以我将使用两个图来解释它。我们首先考虑使用队列，然后我们再看看使用交换。图5.11显示了视频流微服务**pushing**其消息到**viewed**队列。然后在图5.12中，我们可以看到历史微服务**pulling**队列中的消息。
- en: '![](../Images/CH05_F12_Davis4.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F12_Davis4.png)'
- en: Figure 5.12 A message is received by pulling it from a RabbitMQ queue.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 通过从RabbitMQ队列中拉取消息来接收消息。
- en: I’ve used the verbs *pushing* and *pulling* here because that’s a good way to
    visualize this transaction. Earlier with HTTP POST, we can imagine the video-streaming
    microservice is pushing its message onto the history microservice, which has no
    choice in the matter. The message is forced on to the history microservice with
    no regard for whether it actually has the capacity to handle it.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用了**pushing**和**pulling**这两个动词，因为这是一种很好的方式来可视化这个交易。在之前的HTTP POST中，我们可以想象视频流微服务正在将其消息推送到历史微服务，而历史微服务在这方面没有选择。消息被强制推送到历史微服务，而不考虑它实际上是否有处理它的能力。
- en: With indirect messaging, more control is given to the history microservice.
    It now pulls messages from the queue when it is ready to do so. When it is overwhelmed
    and has no capacity to accept new messages, it is free to just ignore these, letting
    those pile up in the queue until it is able to handle them.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用间接消息，历史微服务得到了更多的控制。现在，当它准备好这样做时，它会从队列中拉取消息。当它不堪重负，没有能力接受新消息时，它可以自由地忽略这些消息，让它们在队列中堆积，直到它能够处理它们。
- en: 5.8.3 Creating a RabbitMQ server
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.3 创建RabbitMQ服务器
- en: Let’s add a RabbitMQ server to our application. Believe it or not, RabbitMQ
    is programmed in the Erlang language. There might have been a day when it was
    difficult to set up, but not anymore! These days, it’s a no brainer, thanks to
    the skills we have already learned with Docker and Docker Compose.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的应用程序中添加一个 RabbitMQ 服务器。信不信由你，RabbitMQ 是用 Erlang 语言编写的。曾经有一段时间设置它可能很困难，但现在不再是了！如今，这已经变得非常简单，多亏了我们已经学到的
    Docker 和 Docker Compose 技能。
- en: Listing 5.8 is an extract from the example-3 Docker Compose file that shows
    adding a RabbitMQ server to our application. This is another example of instantiating
    a container from an image on Docker Hub, as we did in chapter 4 for our MongoDB
    database.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 是 example-3 Docker Compose 文件的摘录，展示了如何将 RabbitMQ 服务器添加到我们的应用程序中。这是从 Docker
    Hub 上的镜像实例化容器的另一个例子，就像我们在第 4 章为 MongoDB 数据库所做的那样。
- en: Listing 5.8 Adding a RabbitMQ server to the Docker Compose file (extract from
    chapter-5/example-3/docker-compose.yaml)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 向 Docker Compose 文件中添加 RabbitMQ 服务器（摘自第 5 章的 example-3/docker-compose.yaml）
- en: '[PRE20]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① Defines the container that hosts our RabbitMQ server
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义了托管我们的 RabbitMQ 服务器的容器
- en: ② We use the management version of the RabbitMQ image. This gives us the RabbitMQ
    dashboard.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用 RabbitMQ 镜像的管理版本。这为我们提供了 RabbitMQ 控制台。
- en: ③ Sets the name of the container. This is the name we’ll use to connect to the
    RabbitMQ server.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置了容器的名称。这是我们用来连接到 RabbitMQ 服务器的名称。
- en: ④ Configures port mappings from the host operating system to the container
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 配置了从主机操作系统到容器的端口映射
- en: ⑤ Configures which container ports are exposed. These are the standard RabbitMQ
    ports for connecting to the server and viewing the dashboard.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 配置了哪些容器端口被暴露。这些是连接到服务器和查看控制台的标准 RabbitMQ 端口。
- en: ⑥ If something goes wrong with the RabbitMQ server, this makes it restart automatically.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 如果 RabbitMQ 服务器出现故障，这将使其自动重启。
- en: 5.8.4 Investigating the RabbitMQ dashboard
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.4 探索 RabbitMQ 控制台
- en: You might have already noticed in listing 5.8 how the RabbitMQ ports were configured.
    Port 5672 is the port number we’ll soon use with amqplib to send and receive messages
    through RabbitMQ. We’ll use port 15672 to access the RabbitMQ management dashboard.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了列表 5.8 中 RabbitMQ 端口的配置。5672 端口是我们很快将用于通过 amqplib 通过 RabbitMQ 发送和接收消息的端口号。我们将使用
    15672 端口访问 RabbitMQ 管理控制台。
- en: Note RabbitMQ’s dashboard is a great way to learn about how RabbitMQ works and
    to better understand the messages that are being passed around your application.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 RabbitMQ 的控制台是了解 RabbitMQ 的工作方式以及更好地理解在应用程序中传递的消息的绝佳方式。
- en: We booted our RabbitMQ server from the image named rabbitmq:3.8.1-management
    because this one comes with a built-in management dashboard. The dashboard is
    pictured in figure 5.13 and serves as a graphical way to explore message flow
    in our application. Let’s have a look at that now. Start the application for yourself
    so you can try it out!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从名为 rabbitmq:3.8.1-management 的镜像启动了 RabbitMQ 服务器，因为这个镜像自带内置的管理控制台。控制台在图 5.13
    中展示，它作为探索我们应用程序中消息流的一种图形方式。现在让我们看看它。自己启动应用程序，以便你可以尝试一下！
- en: 'Open a terminal and change to the example-3 directory. Start the application
    in the normal way (if nothing else, I’m going to make sure you remember this command!):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端并切换到 example-3 目录。以正常方式启动应用程序（如果其他方式不起作用，我将会确保你记住这个命令！）：
- en: '[PRE21]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](../Images/CH05_F13_Davis4.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F13_Davis4.png)'
- en: Figure 5.13 The RabbitMQ management dashboard
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 RabbitMQ 管理控制台
- en: In addition to the output from the database and your microservices, you should
    also see a stream of output from your RabbitMQ server. Give it some time to start
    and then point your web browser at http://localhost:15672/. You can login with
    the default user name, *guest*, and the default password, *guest*.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据库和你的微服务的输出之外，你还应该看到来自你的 RabbitMQ 服务器的输出流。给它一些时间启动，然后用你的网络浏览器指向 http://localhost:15672/。你可以使用默认用户名
    *guest* 和默认密码 *guest* 登录。
- en: You should now see the RabbitMQ dashboard. But unlike figure 5.13, you won’t
    yet see any queues or exchanges. I took the figure’s screenshot after the viewed
    queue was created. We’ll trigger the queue to be created in a moment and then
    you can come back to the dashboard to see what it looks like.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能看到 RabbitMQ 控制台。但与图 5.13 不同，你目前还看不到任何队列或交换机。我是在创建了查看队列之后截图的。我们将在稍后触发队列的创建，然后你可以回到控制台看看它的样子。
- en: The RabbitMQ dashboard is a useful tool for debugging. I believe it’s always
    better to be able to visualize what’s happening rather than just assuming we know
    what’s happening. The dashboard is one of those great visual tools that make it
    obvious what our application is actually doing!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 仪表板是一个有用的调试工具。我相信，能够可视化正在发生的事情总是比仅仅假设我们知道正在发生的事情要好。仪表板是那些优秀的可视化工具之一，它使我们的应用程序实际上在做什么一目了然！
- en: You might note that we don’t have to include the RabbitMQ dashboard. We could,
    instead, use the image rabbitmq:3.8.1\. This is a version of the image that doesn’t
    include the dashboard. This might be your preference if you are building a lean,
    mean production application or if you have particular security concerns. But generally,
    I prefer to leave the dashboard in place for production (behind a private network,
    of course) because it’s so valuable to have these tools to help us understand
    what’s happening in our production environment.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们不需要包含 RabbitMQ 仪表板。我们可以使用 rabbitmq:3.8.1 的镜像，这是一个不包含仪表板的镜像。如果你正在构建一个精简的生产应用程序或者你有特定的安全顾虑，这可能是你的首选。但通常，我更喜欢在生产环境中保留仪表板（当然是在私有网络之后），因为这些工具对我们理解生产环境中的情况非常有价值。
- en: 5.8.5 Connecting our microservice to the message queue
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.5 将我们的微服务连接到消息队列
- en: 'With our RabbitMQ server in place, we can now update our microservices to connect
    to it. If you are coding this from scratch, you must first install the amqplib
    npm package into each microservice that needs to connect to RabbitMQ:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RabbitMQ 服务器就绪后，我们现在可以更新我们的微服务以连接到它。如果你从头开始编写代码，你必须首先将 amqplib npm 包安装到每个需要连接到
    RabbitMQ 的微服务中：
- en: '[PRE22]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you are running the code from example-3 directly under Node.js, you must
    first install all dependencies:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接在 Node.js 下运行 example-3 的代码，你必须首先安装所有依赖项：
- en: '[PRE23]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The next listing is an extract from the index.js file for the history microservice.
    It shows how we make the connection to the RabbitMQ server.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表是历史微服务的 index.js 文件的摘录。它展示了我们如何连接到 RabbitMQ 服务器。
- en: Listing 5.9 Connecting to the RabbitMQ server (extract from chapter-5/example-3/history/index.js)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 连接到 RabbitMQ 服务器（摘自第 5 章/示例-3/history/index.js）
- en: '[PRE24]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① Imports the amqplib library. This is the API for talking to the RabbitMQ server.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入 amqplib 库。这是与 RabbitMQ 服务器通信的 API。
- en: ② Gets the URI for connecting to RabbitMQ
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ② 获取连接到 RabbitMQ 的 URI
- en: ③ A helper function to create the connection
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 一个用于创建连接的辅助函数
- en: ④ Connects to the RabbitMQ server
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 连接到 RabbitMQ 服务器
- en: ⑤ Creates a RabbitMQ messaging channel
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建 RabbitMQ 消息通道
- en: ⑥ Connects to the database
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 连接到数据库
- en: ⑦ Connects to the RabbitMQ server
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 连接到 RabbitMQ 服务器
- en: ⑧ Starts the HTTP server
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 启动 HTTP 服务器
- en: One of the most important parts of listing 5.9 and listing 5.10 (which follows)
    is how the RABBIT environment variable configures the connection to the RabbitMQ
    server. Listing 5.10 is an extract from the example-3 Docker Compose file. It
    sets the RABBIT environment variable to include the user name (guest), the password
    (also guest), the hostname for the server (rabbit), and the port number (5672)
    for the connection.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 和列表 5.10（紧随其后）最重要的部分是如何通过 RABBIT 环境变量配置到 RabbitMQ 服务器的连接。列表 5.10 是 example-3
    Docker Compose 文件的摘录。它设置了 RABBIT 环境变量，包括用户名（guest）、密码（也是 guest）、服务器的主机名（rabbit）和连接的端口号（5672）。
- en: Listing 5.10 Configuring the history microservice (extract from chapter-5/example-3/docker-compose.yaml)
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.10 配置历史微服务（摘自第 5 章/示例-3/docker-compose.yaml）
- en: '[PRE25]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① Sets the URl for connecting to RabbitMQ
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置连接到 RabbitMQ 的 URL
- en: ② The history microservice now depends on the rabbit container that we defined
    in listing 5.8.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ② 历史微服务现在依赖于我们在列表 5.8 中定义的 rabbit 容器。
- en: There’s yet another piece to this puzzle that may not have occurred to you until
    you try and start this version of our application. The RabbitMQ server is fairly
    heavyweight, and it takes time to start up and get ready to accept connections.
    Our tiny microservices, on the other hand, are lightweight and ready in just moments.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题还有一个部分你可能直到尝试启动这个版本的应用程序时才意识到。RabbitMQ 服务器相当重量级，启动并准备好接受连接需要时间。另一方面，我们的微服务轻量级，只需片刻即可准备就绪。
- en: What happens when our microservice attempts the connection to RabbitMQ and it’s
    not ready yet? It will error and abort! We now have a problem because we have
    startup dependencies in our application that need to be resolved in a particular
    order.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的微服务尝试连接到RabbitMQ但RabbitMQ尚未准备好时会发生什么？它会出错并终止！我们现在遇到了问题，因为我们应用程序中有启动依赖项需要按特定顺序解决。
- en: To be a fault-tolerant and well-behaved microservice, it should really wait
    until the RabbitMQ server is ready before it tries to connect. Better yet, if
    RabbitMQ ever goes down (say because we are upgrading it), we’d like our microservices
    to handle the disconnection and automatically reconnect as soon as possible. We’d
    like it to work that way, but that’s more complicated. For the moment, we’ll solve
    this with a simple workaround. In chapter 10, we’ll learn a more sophisticated
    way to handle this.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为一个容错且表现良好的微服务，它实际上应该在尝试连接之前等待RabbitMQ服务器准备好。更好的是，如果RabbitMQ突然关闭（例如，因为我们正在升级它），我们希望我们的微服务能够处理断开连接并在尽可能快的时间内自动重新连接。我们希望它能这样工作，但这更复杂。目前，我们将使用一个简单的解决方案来解决这个问题。在第10章中，我们将学习一种更复杂的方式来处理这个问题。
- en: 'What’s the simplest way to solve this problem? We’ll add an extra command to
    our Dockerfile that delays our microservice until the RabbitMQ server is ready.
    We’ll use the handy `wait-port` command installed using npm:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最简单方法是什么？我们将在Dockerfile中添加一个额外的命令，以延迟我们的微服务直到RabbitMQ服务器准备好。我们将使用通过npm安装的方便的`wait-port`命令：
- en: '[PRE26]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Listing 5.11 shows the history microservice’s updated Dockerfile with the addition
    of the `wait-port` command. We use this to delay the start of the microservice
    until after RabbitMQ has started.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.11显示了带有`wait-port`命令的历史微服务更新后的Dockerfile。我们使用这个命令来延迟微服务的启动，直到RabbitMQ启动后。
- en: Listing 5.11 Updated Dockerfile for the history microservice, which waits for
    RabbitMQ (chapter-5/example-3/history/Dockerfile-dev)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.11历史微服务的更新后的Dockerfile，它等待RabbitMQ（第5章/示例3/历史/Dockerfile-dev）
- en: '[PRE27]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ① Uses npx to invoke the locally installed wait-port command to wait until the
    server at hostname rabbit is accepting connections on port 5672
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用npx调用本地安装的`wait-port`命令，等待在主机名为rabbit的服务器上端口5672接受连接
- en: ② After wait-port has completed, this starts the history microservice
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在`wait-port`完成后，启动历史微服务
- en: At the same time, we should update the production version of the Dockerfile.
    It’s good to keep both versions in sync as we work.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们应该更新Dockerfile的生产版本。在我们工作时，保持两个版本同步是好事。
- en: Using `wait-port` is a simple and effective way to get up and running when we
    first start building our microservices application. It’s not very robust though.
    The startup ordering problem isn’t the only problem. We generally want our microservice
    to be fault-tolerant and able to survive the inevitable outages of other servers
    and microservices. We’ll come back to this in chapter 10.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`wait-port`是在我们首次开始构建微服务应用程序时快速启动的一种简单而有效的方法。然而，它并不非常健壮。启动顺序问题并不是唯一的问题。我们通常希望我们的微服务具有容错能力，能够应对其他服务器和微服务的不可避免的中断。我们将在第10章中回到这个问题。
- en: At this point, you might be wondering why we didn’t have this startup order
    problem in chapter 4 when we started using the MongoDB database? Surely the database
    also takes time to start up, but we didn’t have to wait for it to be ready before
    we connected to it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想知道为什么在第4章开始使用MongoDB数据库时我们没有遇到这个启动顺序问题？当然，数据库也需要时间来启动，但我们不需要在连接到它之前等待它准备好。
- en: Well, this is simply down to good software engineering in the MongoDB library.
    It is already programmed for automatic reconnections, so thank the MongoDB engineers
    for going to this level of effort for you. This should give you some pause for
    thought. When writing code libraries, a little time considering the perspective
    of our users translates into a much better experience for them.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这完全是MongoDB库中良好的软件工程的结果。它已经为自动重新连接进行了编程，所以感谢MongoDB工程师为你付出了这么多的努力。这应该让你有所思考。当编写代码库时，花点时间考虑我们的用户视角，将转化为他们更好的体验。
- en: 5.8.6 Single-recipient indirect messaging
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.6 单接收者间接消息
- en: There are many ways we can configure message routing in RabbitMQ to achieve
    various messaging architectures. We will focus on just two simple configurations
    that will handle many of the communication problems you will face when building
    your application.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式配置RabbitMQ中的消息路由来实现各种消息架构。我们将专注于两种简单的配置，这些配置将处理你在构建应用程序时面临的大多数通信问题。
- en: The first is a setup for single-recipient messages that we’ll use to create
    a one-to-one, but still indirect, messaging conduit between microservices. Although,
    in this configuration you are allowed to have multiple senders and receivers participating,
    you are guaranteed that only a single microservice will receive each individual
    message. This is great for when you are distributing a job to a pool of microservices,
    but the job should be handled only by the first one that is capable of dealing
    with it.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是单接收者消息的设置，我们将使用它来创建一对一，但仍然间接的消息通道，在微服务之间。尽管在这个配置中，您允许有多个发送者和接收者参与，但您可以保证每个单独的消息只由一个微服务接收。这对于将工作分配给一组微服务时非常出色，但这项工作应由第一个能够处理它的微服务来处理。
- en: 'Note Single-recipient messages are *one-to-one* : a message is sent from one
    microservice and received by only a single other. This is a great way of making
    sure that a particular job is done only once within your application.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 单接收者消息是 **一对一** 的：一条消息从一个微服务发送，只被另一个微服务接收。这是一种确保在您的应用程序中特定工作只执行一次的绝佳方式。
- en: Receiving single-recipient messages
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 接收单接收者消息
- en: Let’s add code to the history microservice so that it can receive single-recipient
    messages. We already added code in section 5.8.5 to connect to our RabbitMQ server.
    Once connected, we can now *assert* a message queue and start pulling messages
    from that queue. Note the new terminology I’ve used here.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在历史微服务中添加代码，以便它可以接收单接收者消息。我们已经在 5.8.5 节中添加了连接到我们的 RabbitMQ 服务器的代码。一旦连接，我们现在可以
    *断言* 一个消息队列并开始从该队列拉取消息。注意我在这里使用的新术语。
- en: I said “assert” a message queue and not “create” a message queue. The difference
    is that multiple microservices can assert a queue, so it’s like checking for the
    existence of the queue and then only creating it when it doesn’t already exist.
    That means the queue is created once and shared between all participating microservices.
    Don’t get this confused with the other kind of assert that is commonly used in
    programming-these are two separate concepts.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我说的是“断言”一个消息队列，而不是“创建”一个消息队列。区别在于多个微服务可以断言一个队列，所以它就像检查队列是否存在，然后只有在它不存在时才创建它。这意味着队列只创建一次，并在所有参与的微服务之间共享。不要将这与其他在编程中常用的一种断言概念混淆——这两个是两个不同的概念。
- en: Listing 5.12 is an extract of the index.js from the history microservice that
    asserts the viewed queue and calls `consume` to start receiving messages. This
    causes our function `consumeViewedMessage` to be called each time a new message
    arrives. This is it! There really isn’t very much code needed to receive messages
    from RabbitMQ.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12 是历史微服务的 index.js 的摘录，它断言了已查看队列并调用 `consume` 以开始接收消息。这就是它！实际上，接收 RabbitMQ
    消息所需的代码并不多。
- en: Listing 5.12 Consuming viewed messages from a RabbitMQ queue (extract from chapter-5/example-3/history/index.js)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12 从 RabbitMQ 队列中消费已查看消息（摘自 chapter-5/example-3/history/index.js）
- en: '[PRE28]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① A function to handle incoming messages
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ① 一个处理传入消息的函数
- en: ② Parses the JSON message to a JavaScript object
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将 JSON 消息解析为 JavaScript 对象
- en: ③ Records the view in the history database
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在历史数据库中记录查看
- en: ④ If there is no error ...
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果没有错误……
- en: ⑤ ... acknowledges the message.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ ……确认消息。
- en: ⑥ Asserts that we have a viewed queue
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 断言我们有一个已查看队列
- en: ⑦ Starts receiving messages from the viewed queue
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 开始从已查看队列接收消息
- en: The code in listing 5.12 is only slightly complicated by the fact that we’d
    like to send messages in the JSON format, but RabbitMQ doesn’t natively support
    JSON. We must therefore manually parse the incoming message payload.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12 中的代码仅因我们希望以 JSON 格式发送消息而略显复杂，但 RabbitMQ 并没有原生支持 JSON。因此，我们必须手动解析传入的消息有效负载。
- en: RabbitMQ is actually agnostic about the format for the message payload, and
    from its point of view, a message is just a blob of binary data. This can be useful
    in performance-critical cases where we’d probably like to replace JSON with a
    more efficient binary format.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 实际上对消息有效负载的格式是中立的，从它的角度来看，一条消息只是一个二进制数据块。这在性能关键的情况下可能很有用，我们可能会用更有效的二进制格式来替换
    JSON。
- en: Sending single-recipient messages
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 发送单接收者消息
- en: Sending a simple message with RabbitMQ is even easier than receiving a message.
    Listing 5.13 is an extract of the index.js file from the video-streaming microservice.
    Assume that we’ve already added code like that in listing 5.9 and connected this
    microservice to the RabbitMQ server. We now call `publish` by specifying the name
    of the queue (viewed) and providing the message payload.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RabbitMQ 发送简单消息甚至比接收消息更容易。列表 5.13 是视频流微服务的 index.js 文件的摘录。假设我们已经添加了类似列表 5.9
    中的代码并将此微服务连接到 RabbitMQ 服务器。我们现在通过指定队列名称（viewed）和提供消息负载来调用 `publish`。
- en: Listing 5.13 Publishing viewed messages to a RabbitMQ queue (extract from chapter-5/example-3/video-streaming/index.js)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.13 将观看消息发布到 RabbitMQ 队列（摘自第 5 章/示例 3/video-streaming/index.js）
- en: '[PRE29]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ① A helper function to send the viewed message
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ① 发送观看消息的辅助函数
- en: ② Defines the message payload. This is the data we send with the message.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义消息负载。这是我们随消息发送的数据。
- en: ③ Converts the message to the JSON format
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将消息转换为 JSON 格式
- en: ④ Publishes the message to the viewed queue
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将消息发布到观看队列
- en: Again, listing 5.13 is only slightly complicated by the fact that we have to
    manually *stringify* (or serialize) our message payload to JSON before sending
    the message. Other than that, it’s pretty straightforward. Now we have the video-streaming
    microservice publishing a viewed message whenever a user watches a video.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，列表 5.13 只稍微复杂一些，因为我们必须在发送消息之前手动 **字符串化**（或序列化）我们的消息负载为 JSON。除此之外，它相当直接。现在我们有了视频流微服务，每当用户观看视频时，就会发布观看消息。
- en: Testing single-recipient messages
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 测试单收件人消息
- en: 'We have everything we need in place to do another test run. We have a RabbitMQ
    server. The video-streaming microservice is sending the viewed message, and the
    history microservice is receiving it. If you haven’t already, start the example-3
    application:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好进行另一次测试运行。我们有一个 RabbitMQ 服务器。视频流微服务正在发送观看消息，而历史微服务正在接收它。如果您还没有这样做，请启动示例-3
    应用程序：
- en: '[PRE30]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Wait for the database and RabbitMQ to start and the microservices to establish
    their connections. Now point your web browser at http://localhost:4001/video.
    Check the output to see that the message has been sent and received. You can use
    Robo3T to check that the history microservice has created a new record for the
    view in its database.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 等待数据库和 RabbitMQ 启动以及微服务建立连接。现在将您的网络浏览器指向 http://localhost:4001/video。检查输出以确认消息已发送并接收。您可以使用
    Robo3T 检查历史微服务是否在其数据库中为观看创建了新的记录。
- en: 5.8.7 Multiple-recipient messages
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.7 多收件人消息
- en: Sending single-recipient messages is the first common use case for RabbitMQ.
    It’s also the simplest to understand-that’s why we started with it. Potentially,
    even more useful are multiple-recipient (or broadcast-style) messages. Put simply,
    one microservice sends the message, but many others can receive it.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 发送单收件人消息是 RabbitMQ 的第一个常见用例。它也是最简单的，这就是为什么我们从它开始。潜在地更有用得多的是多收件人（或广播式）消息。简单来说，一个微服务发送消息，但许多其他微服务可以接收它。
- en: We use this type of message for *notifications* (e.g., messages that indicate
    an important event has occurred in the application, such as the event that a video
    has been viewed). This is the kind of message that multiple other microservices
    would like to know about.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这种类型的消息用于 **通知**（例如，指示应用程序中发生重要事件的邮件，如视频被观看的事件）。这是多个其他微服务都希望了解的消息。
- en: 'Note Multiple-recipient messages are *one-to-many* : a message is sent from
    only a single microservice but potentially received by many others. This is a
    great way of publishing notifications within your application.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 多收件人消息是 **一点对多**：消息只从一个微服务发送，但可能被许多其他微服务接收。这是在您的应用程序中发布通知的绝佳方式。
- en: To make this work with RabbitMQ, we must now use a message exchange. Figure
    5.14 shows the video-streaming microservice publishing its message to the viewed
    exchange. From the exchange, the message is routed to multiple anonymous queues
    to be handled by multiple microservices simultaneously.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这适用于 RabbitMQ，我们现在必须使用一个消息交换。图 5.14 显示了视频流微服务将其消息发布到观看交换。从交换中，消息被路由到多个匿名队列，以便多个微服务同时处理。
- en: When you look at figure 5.14, you might wonder where the recommendations microservice
    came from? No, you didn’t miss anything! I’ve literally just snuck a new microservice
    in while you weren’t looking. I had to do this; otherwise, I don’t have a way
    to show you how these broadcast-style messages work.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看图 5.14 时，你可能会想知道推荐微服务是从哪里来的？不，你没有错过任何东西！我实际上在你没注意的时候悄悄地引入了一个新的微服务。我不得不这样做；否则，我没有办法向你展示这些广播式消息是如何工作的。
- en: '![](../Images/CH05_F14_Davis4.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F14_Davis4.png)'
- en: Figure 5.14 Broadcasting a message to be handled by multiple recipients
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 向多个收件人广播要处理的消息
- en: The recommendations microservice will later suggest videos to watch to our users.
    It’s appearance here and now is only so that we can see multiple-recipient messages
    in action.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐微服务将在以后向我们的用户推荐观看的视频。它现在出现在这里只是为了让我们看到多收件人消息的实际操作。
- en: Receiving multiple-recipient messages
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 接收多收件人消息
- en: Receiving multiple-recipient messages is not much different than receiving single-recipient
    messages. The following listing is an extract of the index.js file from the history
    microservice.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接收多收件人消息与接收单收件人消息没有太大区别。以下是从历史微服务的 index.js 文件中摘取的代码。
- en: Listing 5.14 Consuming viewed messages from a RabbitMQ exchange (extract from
    chapter-5/example-4/history/index.js)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.14 从 RabbitMQ 交换机中消费已查看的消息（摘自第 5 章/示例 4/history/index.js）
- en: '[PRE31]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ① A function to handle incoming messages
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ① 一个处理传入消息的函数
- en: ② Parses the JSON message to a JavaScript object
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将 JSON 消息解析为 JavaScript 对象
- en: ③ Records the view in the history database
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 记录历史数据库中的视图
- en: ④ If there is no error ...
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果没有错误……
- en: ⑤ ... acknowledges the message.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ ... 确认消息。
- en: ⑥ Asserts that we have a viewed exchange
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 断言我们有一个已查看的交换机
- en: ⑦ Creates an anonymous queue. The option exclusive is set to true so that the
    queue will be deallocated automatically when the microservices disconnects from
    it (otherwise, our application will have a memory leak).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 创建一个匿名队列。选项 exclusive 设置为 true，这样当微服务从队列断开连接时，队列将被自动释放（否则，我们的应用程序将出现内存泄漏）。
- en: ⑧ Assigns the anonymous queue an automatically generated unique identifier for
    its name
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 为匿名队列分配一个自动生成的唯一标识符作为其名称
- en: ⑨ Binds the queue to the exchange
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 将队列绑定到交换机
- en: ⑩ Starts receiving messages from the anonymous queue that’s bound to the viewed
    exchange
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 开始从绑定到已查看交换机的匿名队列接收消息
- en: The difference between listing 5.14 and listing 5.12 is that we are now *asserting*
    the viewed exchange (there’s that assert terminology again) rather than the viewed
    queue. After that, we assert an anonymous queue. By creating an unnamed queue,
    we get one that was created uniquely for this microservice. The viewed exchange
    is shared among all microservices, but the anonymous queue is owned solely by
    this microservice. That detail is an important part of how this works.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.14 与列表 5.12 的区别在于我们现在*断言*的是已查看的交换机（又是那个断言术语），而不是已查看的队列。之后，我们断言一个匿名队列。通过创建一个无名的队列，我们得到一个只为这个微服务创建的独特队列。已查看的交换机在所有微服务之间共享，但匿名队列仅由这个微服务拥有。这个细节是这个工作的重要部分。
- en: In creating the unnamed queue, we are returned a random name generated by RabbitMQ.
    The name that RabbitMQ assigned to our queue is only important because we must
    now bind the queue to the viewed exchange. This binding connects the exchange
    and the queue, such that RabbitMQ messages published on the exchange are routed
    to the queue.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建无命名的队列时，我们将得到 RabbitMQ 生成的随机名称。RabbitMQ 分配给我们的队列的名称只重要，因为我们现在必须将队列绑定到已查看交换机。这种绑定将交换机和队列连接起来，使得
    RabbitMQ 在交换机上发布的消息被路由到队列。
- en: Every other microservice that wants to receive the viewed message (e.g., the
    recommendations microservice that I snuck in here) creates its own unnamed queue
    to bind to the viewed exchange. We can have any number of other microservices
    bound to the viewed exchange, and these will all receive copies of messages on
    their own anonymous queues as messages are published to the exchange.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 每个其他想要接收已查看消息的微服务（例如，我悄悄引入的推荐微服务）都会创建自己的无命名的队列来绑定到已查看交换机。我们可以有任意数量的其他微服务绑定到已查看交换机，并且当消息发布到交换机时，这些微服务都会在自己的匿名队列上接收到消息的副本。
- en: Sending multiple-recipient messages
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 发送多收件人消息
- en: Sending multiple-recipient messages is, again, similar to sending single-recipient
    messages. Listing 5.15 is an extract of the index.js file for video-streaming
    microservice. I’ve included more code in this extract because it’s important to
    see how the connection to the RabbitMQ service is different in this situation.
    It’s different because we are asserting the existence of the viewed exchange when
    the microservice starts.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，发送多收件人消息与发送单收件人消息类似。列表 5.15 是视频流微服务的 index.js 文件的摘录。我在这个摘录中包含了更多代码，因为了解在这种情况下与
    RabbitMQ 服务的连接方式很重要。它之所以不同，是因为微服务启动时我们断言存在查看交换。
- en: Doing this once at start up means we can rely on the existence of the exchange
    for the lifetime of the microservice. In the listing, we are still sending the
    message with the `publish` function, except now we are specifying that the message
    is published to the viewed exchange rather than the viewed queue.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时执行此操作意味着我们可以依赖交换在整个微服务生命周期中的存在。在列表中，我们仍然使用 `publish` 函数发送消息，但现在我们指定消息是发布到查看交换而不是查看队列。
- en: Listing 5.15 Publishing viewed messages to a RabbitMQ exchange (extract from
    chapter-4/example-3/video-streaming/index.js)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.15 将查看消息发布到 RabbitMQ 交换（来自第 4 章示例 3/video-streaming/index.js 的摘录）
- en: '[PRE32]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ① Asserts that we have a viewed exchange
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: ① 断言我们有一个查看交换
- en: ② A helper function to send the viewed message
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: ② 一个发送查看消息的辅助函数
- en: ③ Defines the payload of the message
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义消息的有效负载
- en: ④ Converts the message to the JSON format
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将消息转换为 JSON 格式
- en: ⑤ Publishes the message to the viewed exchange
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将消息发布到查看交换
- en: ⑥ Connects to the RabbitMQ server
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 连接到 RabbitMQ 服务器
- en: ⑦ Starts the HTTP server
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 启动 HTTP 服务器
- en: Testing multiple-recipient messages
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 测试多收件人消息
- en: 'Let’s test our updated code. It is for this test that I added the recommendations
    microservice to our application. The new microservice is really just a stub; it
    does nothing except print out the messages it receives. That’s just enough to
    show that multiple microservices can handle these messages. Open a terminal, change
    to the example-4 directory, and do the usual thing:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试我们的更新代码。正是为了这个测试，我将推荐微服务添加到我们的应用程序中。这个新微服务实际上只是一个存根；它除了打印接收到的消息外，什么都不做。这足以表明多个微服务可以处理这些消息。打开终端，切换到
    example-4 目录，并执行常规操作：
- en: '[PRE33]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When you hit http://localhost:4001/video in your web browser, you should see
    messages being printed to the console to show that both the history microservice
    and the recommendations microservice are receiving the viewed message.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在网页浏览器中访问 http://localhost:4001/video 时，你应该会看到消息被打印到控制台，以显示历史微服务和推荐微服务都在接收查看的消息。
- en: 'This works because we have one exchange that is bound to two queues: we have
    one queue for each receiving microservice. We can’t achieve this behavior with
    only a single queue. When we publish a message to a single shared queue, the receiving
    microservices compete to be the first one that pulls the message and handles it.
    You can view this as a kind of load balancing. That’s a useful technique, sometimes,
    but broadcast-style messages are more generally useful.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以可行，是因为我们有一个绑定到两个队列的交换：我们为每个接收微服务有一个队列。仅使用单个队列无法实现这种行为。当我们向单个共享队列发布消息时，接收微服务会竞争成为第一个拉取并处理该消息的服务。你可以把这看作是一种负载均衡。这有时是一种有用的技术，但广播式消息通常更有用。
- en: 5.8.8 Sequencing indirect messages
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.8 间接消息的排序
- en: Indirect messages have plenty of positive benefits, but these can make it harder
    to understand and control the behavior of our application. There’s no way to get
    a direct response for an indirect message, and from the sender’s point of view,
    the receiver may as well not even exist! The sender has no way of knowing if there
    is a receiver out there waiting to pick up its message.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 间接消息有许多积极的好处，但这些都可能使理解和控制我们应用程序的行为变得更加困难。对于间接消息，没有直接响应的方式，并且从发送者的角度来看，接收者可能根本不存在！发送者无法知道是否有一个接收者在等待接收其消息。
- en: Note Because there is no “central control” over indirect messages, these allow
    for much more flexible, extensible, and evolvable messaging architectures. Each
    separate microservice is in charge of how it responds to incoming messages and
    can generate many other messages in response.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于间接消息没有“中央控制”，因此这些允许实现更加灵活、可扩展和可演化的消息架构。每个独立的微服务负责如何响应传入的消息，并且可以生成许多其他响应消息。
- en: With indirect messaging, unlike direct messaging, there is no single microservice
    in charge of orchestrating the others. This isn’t necessarily a bad thing. Consider
    that having a single controlling microservice means we have a single point of
    failure, and that’s undoubtedly a bad thing. If that controlling microservice
    crashes in the middle of a complex orchestration, what happens? Whatever was in
    progress will be lost! That can be the terrible side effect of direct messages.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接消息不同，间接消息没有单个微服务负责协调其他微服务。这并不一定是个坏事情。考虑一下，有一个单一的控制器微服务意味着我们有一个单点故障，这无疑是件坏事。如果控制微服务在复杂协调过程中崩溃，会发生什么？正在进行的任何操作都将丢失！这就是直接消息可能产生的可怕副作用。
- en: Sometimes direct messaging is useful, but generally speaking, indirect messaging
    allows for much more complex and resilient networks of behaviors. We might struggle
    to understand how it all fits together in its complexity, but at least we know
    that it’s reliable! That’s because there is no single point that can fail, and
    the connections between microservices are implemented by reliable and fault-tolerant
    message queues (well, RabbitMQ can fail, but it’s much less likely to do so than
    one of our own microservices).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 有时直接消息很有用，但一般来说，间接消息允许构建更复杂和更具弹性的行为网络。我们可能难以理解它在复杂性中的整体结构，但至少我们知道它是可靠的！这是因为没有单个点可以失败，微服务之间的连接是通过可靠和容错的队列（好吧，RabbitMQ可能会失败，但它比我们自己的微服务失败的可能性要小得多）实现的。
- en: Any particular microservice can fail, but even if it does so while handling
    a message, we know that the message won’t be lost. Because messages aren’t acknowledged
    when a microservice crashes, these will eventually be delivered to another microservice
    to be handled. It’s the sum of small techniques like this that contribute to us
    building a rock-solid and reliable microservices application. Cast your eyes over
    figure 5.15 for a more visual understanding of how indirect messages can be sequenced
    into a dynamic flow of messages within your application.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 任何特定的微服务都可能失败，但即使它在处理消息时失败，我们也知道消息不会丢失。因为当微服务崩溃时，消息不会被确认，所以这些消息最终会被发送到另一个微服务进行处理。正是这些小技术的总和，帮助我们构建了一个坚固可靠且可靠的微服务应用程序。请查看图5.15，以更直观地了解间接消息如何在您的应用程序中按顺序排列成动态的消息流。
- en: '![](../Images/CH05_F15_Davis4.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![图5.15](../Images/CH05_F15_Davis4.png)'
- en: Figure 5.15 Indirect messages allow for more freeform and flexible orchestration
    of microservices, resulting in emergent behavior.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15 间接消息允许更自由和灵活地编排微服务，从而产生涌现行为。
- en: 5.8.9 What have we achieved?
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.9 我们取得了什么成果？
- en: In the section, we have learned how to use RabbitMQ to send indirect messages
    between our microservices. First, we tried sending single-recipient messages.
    Then we changed to multi-recipient messages so that we can broadcast application-wide
    messages.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用RabbitMQ在我们的微服务之间发送间接消息。首先，我们尝试发送单收件人消息。然后，我们改为多收件人消息，以便我们可以广播全应用的消息。
- en: Note Using indirect multi-recipient messages seems like the right way to go
    for the viewed message, and our microservices are less coupled as a result. That’s
    a good win.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用间接的多收件人消息似乎是处理查看消息的正确方式，因此我们的微服务耦合度更低。这是一个很好的成果。
- en: We could have easily planned ahead and headed straight for the indirect broadcast-style
    messages, but that’s the benefit of experience. Now that we have worked through
    all the options, you have that experience and are better placed to decide for
    yourself what style of messaging you’ll need case by case as you add more messages
    to your application.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以提前规划并直接转向间接广播风格的短信，但这是经验的好处。现在我们已经考虑了所有选项，您有了这样的经验，并且更有能力根据您向应用程序添加更多消息的情况，自行决定需要哪种风格的消息。
- en: 5.9 Microservices communication review
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.9 微服务通信回顾
- en: You now have at your disposal two different styles of messaging that you can
    use to make your microservices talk to each other. You’ve learned how to send
    direct messages with HTTP requests and indirect messages with RabbitMQ. With RabbitMQ,
    you can send single-recipient and multiple-recipient (or broadcast) messages.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您手头上有两种不同的消息风格可供使用，以使您的微服务相互通信。您已经学会了如何使用HTTP请求发送直接消息，以及如何使用RabbitMQ发送间接消息。使用RabbitMQ，您可以发送单收件人和多收件人（或广播）消息。
- en: We have a flexible structure for messaging that can be extended in the future.
    Later, we’ll add more microservices to this application, and each one may or may
    not care about the viewed message. But those that do can simply handle it without
    us having to modify the original sender of the message.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个灵活的消息结构，未来可以扩展。稍后，我们将向这个应用添加更多微服务，每个微服务可能或可能不会关心查看的消息。但那些关心的可以简单地处理它，而无需我们修改消息的原始发送者。
- en: We’ve talked through various reasons why you might want to choose one style
    of messaging over the other. For your convenience, this information is summarized
    in table 5.2\. You can refer back to this table later when you are deciding what
    style of messaging you need in particular situations.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了为什么你可能想要选择一种消息风格而不是另一种风格的各种原因。为了您的方便，这些信息已在表 5.2 中总结。当您在特定情况下决定需要哪种消息风格时，可以参考此表。
- en: Table 5.2 When to use each type of communication
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.2 何时使用每种通信类型
- en: '| Situation | What to use |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| 情况 | 使用什么 |'
- en: '| I need to direct a message to a particular microservice by name. | Direct
    messaging: HTTP |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| 我需要通过名称将消息直接发送到特定的微服务。 | 直接消息：HTTP |'
- en: '| I need confirmation that the message handling was successful or that it failed.
    | Direct messaging: HTTP |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| 我需要确认消息处理成功或失败。 | 直接消息：HTTP |'
- en: '| I need to be able to sequence subsequent messages after completion of the
    first. | Direct messaging: HTTP |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| 我需要在第一个消息完成后对后续消息进行排序。 | 直接消息：HTTP |'
- en: '| I want one microservice to be able to orchestrate the activity of other microservices.
    | Direct messaging: HTTP |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| 我希望一个微服务能够协调其他微服务的活动。 | 直接消息：HTTP |'
- en: '| I need to broadcast a message across the application to notify zero or more
    microservices of an event in the system (and I don’t care if the messages are
    handled or not). | Indirect messaging: RabbitMQ |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| 我需要将一条消息广播到整个应用中，以通知零个或多个微服务系统中的事件（我不关心消息是否被处理）。 | 间接消息：RabbitMQ |'
- en: '| I want to decouple the sender and the receiver (so these can more easily
    change and evolve independently). | Indirect messaging: RabbitMQ |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| 我想要解耦发送者和接收者（这样它们可以更容易地独立更改和演进）。 | 间接消息：RabbitMQ |'
- en: '| I want the performance of sender and receiver to be independent (the sender
    can emit as many messages as it likes, the receiver will process these in its
    own time). | Indirect messaging: RabbitMQ |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| 我希望发送者和接收者的性能是独立的（发送者可以发送任意数量的消息，接收者将按自己的时间处理这些消息）。 | 间接消息：RabbitMQ |'
- en: '| I want to be sure that if message handling fails that it will automatically
    be retried again later until it succeeds (so no messages are lost due to intermittent
    failures). | Indirect messaging: RabbitMQ |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| 我要确保如果消息处理失败，它将自动稍后重试，直到成功（这样就不会因为间歇性故障而丢失消息）。 | 间接消息：RabbitMQ |'
- en: '| I need to load balance handling of a message so it is handled by one out
    of a pool of workers. | Either HTTP or RabbitMQ |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| 我需要将消息的处理负载均衡到一组工人中的一个。 | 要么 HTTP 要么 RabbitMQ |'
- en: '| I need to distribute handling of a message to multiple workers who can act
    in parallel. | Indirect messaging: RabbitMQ |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| 我需要将消息的处理分配给多个可以并行操作的工人。 | 间接消息：RabbitMQ |'
- en: 5.10 Continue your learning
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.10 继续你的学习
- en: 'This chapter has been a tour through the various ways we can make our microservices
    communicate. We’ve used HTTP for direct messages and RabbitMQ for indirect messages.
    As usual, we only briefly touched on each of these subjects, and there is a whole
    lot more you can learn. Here are some great resources for you to learn more:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 本章带您游览了我们可以让我们的微服务进行通信的各种方式。我们使用了 HTTP 进行直接消息，RabbitMQ 进行间接消息。像往常一样，我们只是简要地触及了这些主题，还有很多可以学习。以下是一些学习更多知识的优秀资源：
- en: '*API Design Patterns* by JJ Geewax (Manning, est. Spring 2021)'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《API 设计模式》* 由 JJ Geewax 著（Manning，预计 2021 年春季）'
- en: '*The Design of Web APIs* by Arnaud Lauret (Manning, 2019)'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Web API 设计》* 由 Arnaud Lauret 著（Manning，2019年）'
- en: '*RabbitMQ in Depth* by Gavin M Roy (Manning, 2017)'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《深入 RabbitMQ》* 由 Gavin M Roy 著（Manning，2017年）'
- en: RabbitMQ in Action by Alvaro Videla and Jason J.W. Williams (Manning, 2012)
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《RabbitMQ in Action》由 Alvaro Videla 和 Jason J.W. Williams 著（Manning，2012年）
- en: 'To learn more about the amqplib package, read the documentation here:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 amqplib 包的信息，请在此处阅读文档：
- en: '[http://www.squaremobius.net/amqp.node/](http://www.squaremobius.net/amqp.node/)'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.squaremobius.net/amqp.node/](http://www.squaremobius.net/amqp.node/)'
- en: 'To learn more about the `wait-port` command, see:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `wait-port` 命令的信息，请参阅：
- en: '[https://github.com/dwmkerr/wait-port](https://github.com/dwmkerr/wait-port)'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/dwmkerr/wait-port](https://github.com/dwmkerr/wait-port)'
- en: We’ve come a long way to this point. After building our first microservice,
    we quickly scaled up to developing multiple communicating microservices. Each
    microservice can have its own database and/or file storage. We are now using live
    reload to efficiently reload our whole application while we are coding.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走了很长的路。在构建我们的第一个微服务后，我们迅速扩展到开发多个通信微服务。每个微服务都可以有自己的数据库和/或文件存储。我们现在使用实时重新加载来高效地在我们编码时重新加载整个应用程序。
- en: What’s next? We have a fledgling app. It can’t do much yet, but that’s no reason
    to avoid moving to production. Getting our application to run in a production
    environment can be a difficult affair, and it’s best done while the application
    is small and simple. So without further ado, in chapters 6 and 7, we’ll take our
    application to production!
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是什么？我们有一个初出茅庐的应用程序。它目前还做不了很多事情，但这并不是避免将其部署到生产环境的原因。将我们的应用程序部署到生产环境可能是一项艰巨的任务，最好在应用程序小而简单时完成。因此，无需多言，在第6章和第7章中，我们将把我们的应用程序部署到生产环境！
- en: Summary
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We can use Docker volumes to share code between our development workstation
    and the containers in our application.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用Docker卷在开发工作站和应用程序中的容器之间共享代码。
- en: Using nodemon for live reload means we can update our code and have the relevant
    microservices in our application automatically reload without having to rebuild
    and restart the entire application.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用nodemon进行实时重新加载意味着我们可以更新我们的代码，并且应用程序中相关的微服务可以自动重新加载，而无需重新构建和重启整个应用程序。
- en: 'There are two styles of communication between microservices: direct and indirect.'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务之间的通信有两种风格：直接和间接。
- en: Direct or synchronous messaging is most useful when we want to explicitly sequence
    the flow of messages or carefully orchestrate the behavior of other microservices.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要明确地序列化消息流或仔细编排其他微服务的行为时，直接或同步消息最为有用。
- en: With direct messages, we know immediately if the message handling succeeded
    or failed.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用直接消息，我们可以立即知道消息处理是否成功或失败。
- en: Indirect or asynchronous messaging helps us to decouple our microservices from
    each other, which helps promote the development of flexible and evolvable applications.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 间接或异步消息帮助我们解耦微服务，这有助于促进灵活和可扩展的应用程序的开发。
- en: With indirect messages, we can broadcast a message throughout the application
    to notify other microservices of important events in the system.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用间接消息，我们可以在整个应用程序中广播一条消息，以通知其他微服务系统中的重要事件。
- en: HTTP POST requests are useful for sending direct messages between microservices.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP POST请求用于在微服务之间发送直接消息。
- en: RabbitMQ is software for queuing messages. We can use it to send indirect messages
    between microservices.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ是一种用于消息队列的软件。我们可以用它来在微服务之间发送间接消息。
- en: Although we used the wait-port npm package to wait until the RabbitMQ server
    was ready before our microservice connected to it, in chapter 10, we’ll learn
    a better way of waiting for other services that aren’t currently available.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管我们使用了wait-port npm包在微服务连接到它之前等待RabbitMQ服务器准备好，但在第10章中，我们将学习一种更好的等待当前不可用的其他服务的方法。
- en: Deciding to use either HTTP or RabbitMQ depends on the needs of the situation.
    Refer to table 5.2 in section 5.9 for help deciding which to use based on your
    needs.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定使用HTTP还是RabbitMQ取决于具体情况的需求。请参考第5.9节中的表5.2，以帮助您根据需求决定使用哪种方式。
