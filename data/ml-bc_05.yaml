- en: 5 Deploying machine learning models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 部署机器学习模型
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Saving models with Pickle
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pickle 保存模型
- en: Serving models with Flask
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Flask 提供模型服务
- en: Managing dependencies with Pipenv
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pipenv 管理依赖项
- en: Making the service self-contained with Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 使服务自包含
- en: Deploying it to the cloud using AWS Elastic Beanstalk
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS Elastic Beanstalk 将其部署到云端
- en: 'As we continue to work with machine learning techniques, we’ll keep using the
    project we already started: churn prediction. In chapter 3, we used Scikit-learn
    to build a model for identifying churning customers. After that, in chapter 4,
    we evaluated the quality of this model and selected the best parameter `C` using
    cross-validation.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续使用机器学习技术，我们将继续使用我们已经开始的项目：流失预测。在第 3 章中，我们使用 Scikit-learn 构建了一个用于识别流失客户的模型。之后，在第
    4 章中，我们使用交叉验证选择了最佳参数 `C` 来评估该模型的质量。
- en: We already have a model that lives in our Jupyter Notebook. Now we need to put
    this model into production, so other services can use the model to make decisions
    based on the output of our model.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个存在于我们的 Jupyter Notebook 中的模型。现在我们需要将这个模型投入生产，以便其他服务可以使用模型根据我们模型的结果做出决策。
- en: 'In this chapter, we cover *model deployment* : the process of putting models
    to use. In particular, we see how to package a model inside a web service, so
    other services can use it. We also see how to deploy the web service to a production-ready
    environment.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍 *模型部署*：将模型投入使用的流程。特别是，我们看看如何将模型打包到网络服务中，以便其他服务可以使用它。我们还看看如何将网络服务部署到生产就绪环境。
- en: 5.1 Churn-prediction model
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 流失预测模型
- en: To get started with deployment we use the model we trained previously. First,
    in this section, we review how we can use the model for making predictions, and
    then we see how to save it with Pickle.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始部署，我们使用之前训练的模型。首先，在本节中，我们回顾如何使用该模型进行预测，然后我们看看如何使用 Pickle 保存它。
- en: 5.1.1 Using the model
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 使用模型
- en: To make it easier, we can continue the same Jupyter Notebook we used for chapters
    3 and 4.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化操作，我们可以继续使用我们在第 3 章和第 4 章中使用的相同的 Jupyter Notebook。
- en: 'Let’s use this model to calculate the probability of churning for the following
    customer:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个模型来计算以下客户的流失概率：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To predict whether this customer is going to churn, we can use the `predict`
    function we wrote in the previous chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预测这位客户是否会流失，我们可以使用上一章中编写的 `predict` 函数：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This function needs a dataframe, so first we create a dataframe with one row—our
    customer. Next, we put it into the `predict` function. The result is a NumPy array
    with a single element—the predicted probability of churn for this customer:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数需要一个数据框，因此我们首先创建一个包含一行——我们的客户的数据框。然后，我们将它放入 `predict` 函数中。结果是包含单个元素的 NumPy
    数组——这位客户的预测流失概率：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This means that this customer has a 6% probability of churning.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这位客户有 6% 的流失概率。
- en: 'Now let’s take a look at the `predict` function, which we wrote previously
    for applying the model to the customers in the validation set:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看之前编写的 `predict` 函数，该函数用于将模型应用于验证集中的客户：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using it for one customer seems inefficient and unnecessary: we create a dataframe
    from a single customer only to convert this dataframe back to a dictionary later
    inside `predict`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个客户使用它似乎效率低下且不必要：我们仅从单个客户创建一个数据框，然后在 `predict` 中将其转换回字典。
- en: 'To avoid doing this unnecessary conversion, we can create a separate function
    for predicting the probability of churn for a single customer only. Let’s call
    this function `predict_single`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免进行这种不必要的转换，我们可以为仅预测单个客户的流失概率创建一个单独的函数。让我们称这个函数为 `predict_single`：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Instead of passing a dataframe, passes a single customer
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不是传递一个数据框，而是传递单个客户
- en: '❷ Vectorizes the customer: creates the matrix X'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向量化客户：创建矩阵 X
- en: ❸ Applies the model to this matrix
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将模型应用于此矩阵
- en: ❹ Because we only have one customer, we only need the first element of the result.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 由于我们只有一个客户，我们只需要结果的第一元素。
- en: 'Using it becomes simpler—we simply invoke it with our customer (a dictionary):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它变得简单——我们只需用我们的客户（一个字典）调用它：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result is the same: this customer has a 6% probability of churning.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 结果相同：这位客户有 6% 的流失概率。
- en: We trained our model inside the Jupyter Notebook we started in chapter 3\. This
    model lives there, and once we stop the Jupyter Notebook, the trained model will
    disappear. This means that now we can use it only inside the notebook and nowhere
    else. Next, we see how to address it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 3 章开始的 Jupyter Notebook 中训练了我们的模型。这个模型就在那里，一旦我们停止 Jupyter Notebook，训练好的模型就会消失。这意味着现在我们只能在笔记本中使用它，其他地方都不能使用。接下来，我们将看到如何解决这个问题。
- en: 5.1.2 Using Pickle to save and load the model
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 使用 Pickle 保存和加载模型
- en: To be able to use it outside of our notebook, we need to save it, and then later,
    another process can load and use it (figure 5.1).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要在笔记本之外使用它，我们需要保存它，然后稍后，另一个进程可以加载并使用它（图 5.1）。
- en: '![](../Images/05-01.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05-01.png)'
- en: Figure 5.1 We train a model in a Jupyter Notebook. To use it, we first need
    to save it and then load it in a different process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 我们在一个 Jupyter Notebook 中训练模型。要使用它，我们首先需要保存它，然后在不同的进程中加载它。
- en: 'Pickle is a serialization/deserialization module that’s already built into
    Python: using it, we can save an arbitrary Python object (with a few exceptions)
    to a file. Once we have a file, we can load the model from there in a different
    process.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Pickle 是一个序列化/反序列化模块，它已经内置到 Python 中：使用它，我们可以将任意 Python 对象（除少数例外）保存到文件中。一旦我们有了文件，我们就可以在不同的进程中从那里加载模型。
- en: 'Note “Pickle” can also be used as a verb: *pickling* an object in Python means
    saving it using the Pickle module.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：“Pickle”也可以用作动词：在 Python 中 *pickle* 一个对象意味着使用 Pickle 模块保存它。
- en: Saving the model
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 保存模型
- en: 'To save the model, we first import the Pickle module, and then use the `dump`
    function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存模型，我们首先导入 Pickle 模块，然后使用 `dump` 函数：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Specifies the file where we want to save
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指定我们想要保存的文件
- en: ❷ Saves the model to file with Pickle
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 Pickle 将模型保存到文件
- en: 'To save the model, we use the `open` function, which takes two arguments:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存模型，我们使用 `open` 函数，它接受两个参数：
- en: The name of the file that we want to open. For us, it’s churn-model.bin.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要打开的文件名。对我们来说，它是 churn-model.bin。
- en: The mode with which we open the file. For us, it’s `wb`, which means we want
    to write to the file (`w`), and the file is binary (`b`) and not text—Pickle uses
    binary format for writing to files.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们打开文件的模式。对我们来说，它是 `wb`，这意味着我们想要写入文件（`w`），文件是二进制（`b`）而不是文本——Pickle 使用二进制格式写入文件。
- en: The `open` function returns `f_out`—the file descriptor we can use to write
    to the file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`open` 函数返回 `f_out`——我们可以用来写入文件的文件描述符。'
- en: 'Next, we use the `dump` function from Pickle. It also takes two arguments:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 Pickle 的 `dump` 函数。它也接受两个参数：
- en: The object we want to save. For us, it’s `model`.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要保存的对象。对我们来说，它是 `model`。
- en: The file descriptor, pointing to the output file, which is `f_out` for us.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向输出文件的文件描述符，对我们来说它是 `f_out`。
- en: 'Finally, we use the `with` construction in this code. When we open a file with
    `open`, we need to close it after we finish writing. When using `with`, it happens
    automatically. Without `with`, our code would look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在代码中使用 `with` 构造。当我们使用 `open` 打开文件时，我们需要在完成写入后关闭它。使用 `with` 会自动完成。如果没有使用
    `with`，我们的代码将看起来像这样：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In our case, however, saving just the model is not enough: we also have a `DictVectorizer`
    that we “trained” together with the model. We need to save both.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的情况下，仅仅保存模型是不够的：我们还有一个与模型一起“训练”的 `DictVectorizer`。我们需要保存这两个。
- en: 'The simplest way of doing this is to put both of them in a tuple when pickling:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列化时将这两个都放在一个元组中是最简单的方法：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ The object we save is a tuple with two elements.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们保存的对象是一个包含两个元素的元组。
- en: Loading the model
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 加载模型
- en: 'To load the model, we use the `load` function from Pickle. We can test it in
    the same Jupyter Notebook:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载模型，我们使用 Pickle 的 `load` 函数。我们可以在同一个 Jupyter Notebook 中测试它：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Opens the file in read mode
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 以读取模式打开文件
- en: ❷ Loads the tuple and unpacks it
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 加载元组并解包它
- en: 'We again use the `open` function, but this time, with a different mode: `rb`,
    which means we open it for reading (`r`), and the file is binary (`b`).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用 `open` 函数，但这次使用不同的模式：`rb`，这意味着我们以读取模式打开它（`r`），文件是二进制（`b`）。
- en: 'Warning Be careful when specifying the mode. Accidentally specifying an incorrect
    mode may result in data loss: if you open an existing file with the `w` mode instead
    of `r`, it will overwrite the content.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：指定模式时要小心。意外指定错误模式可能会导致数据丢失：如果你用 `w` 模式而不是 `r` 模式打开现有文件，它将覆盖内容。
- en: Because we saved a tuple, we unpack it when loading, so we get both the vectorizer
    and the model at the same time.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们保存了一个元组，所以在加载时我们解包它，因此我们同时得到向量化器和模型。
- en: 'Warning Unpickling objects found on the internet is not secure: it can execute
    arbitrary code on your machine. Use it only for things you trust and things you
    saved yourself.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：从互联网上解包对象是不安全的：它可以在您的机器上执行任意代码。仅用于您信任的事物以及您自己保存的事物。
- en: Let’s create a simple Python script that loads the model and applies it to a
    customer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的Python脚本，该脚本加载模型并将其应用于客户。
- en: We will call this file churn_serving.py. (In the book’s GitHub repository, this
    file is called churn_serving_simple.py.) It contains
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个文件命名为churn_serving.py。（在本书的GitHub仓库中，这个文件被命名为churn_serving_simple.py。）它包含
- en: The `predict_single` function that we wrote earlier
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前编写的`predict_single`函数
- en: The code for loading the model
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载模型的代码
- en: The code for applying the model to a customer
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模型应用于客户的代码
- en: You can refer to appendix B to learn more about creating Python scripts.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考附录B来了解如何创建Python脚本。
- en: 'First, we start with imports. For this script, we need to import Pickle and
    NumPy:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从导入开始。对于这个脚本，我们需要导入Pickle和NumPy：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, let’s put the `predict_single` function there:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将`predict_single`函数放在那里：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we can load our model:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以加载我们的模型：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And apply it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 并应用它：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, let’s display the results:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们显示结果：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After saving the file, we can run this script with Python:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，我们可以使用Python运行此脚本：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We should immediately see the results:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该立即看到结果：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This way, we can load the model and apply it to the customer we specified in
    the script.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以加载模型并将其应用于脚本中指定的客户。
- en: 'Of course, we aren’t going to manually put the information about customers
    in the script. In the next section, we cover a more practical approach: putting
    the model into a web service.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不会手动将客户信息放入脚本中。在下一节中，我们将介绍一个更实用的方法：将模型放入网络服务中。
- en: 5.2 Model serving
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 模型提供
- en: We already know how to load a trained model in a different process. Now we need
    to *serve* this model—make it available for others to use.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何在不同的进程中加载一个训练好的模型。现在我们需要**提供**这个模型——使其可供他人使用。
- en: In practice, this usually means that a model is deployed as a web service, so
    other services can communicate with it, ask for predictions, and use the results
    to make their own decisions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这通常意味着模型被部署为一个网络服务，这样其他服务就可以与之通信，请求预测，并使用结果来做出自己的决策。
- en: In this section, we see how to do it in Python with Flask—a Python framework
    for creating web services. First, we take a look at why we need to use a web service
    for it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何使用Flask在Python中实现它——一个用于创建网络服务的Python框架。首先，我们来看看为什么我们需要使用网络服务。
- en: 5.2.1 Web services
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 网络服务
- en: We already know how to use a model to make a prediction, but so far, we have
    simply hardcoded the features of a customer as a Python dictionary. Let’s try
    to imagine how our model will be used in practice.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何使用模型进行预测，但到目前为止，我们只是将客户的特征作为Python字典硬编码。让我们尝试想象我们的模型在实际中是如何被使用的。
- en: Suppose we have a service for running marketing campaigns. For each customer,
    it needs to determine the probability of churn, and if it’s high enough, it will
    send a promotional email with discounts. Of course, this service needs to use
    our model to decide whether it should send an email.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个运行营销活动的服务。对于每个客户，它需要确定流失的概率，如果足够高，它将发送带有折扣的促销电子邮件。当然，这个服务需要使用我们的模型来决定是否应该发送电子邮件。
- en: 'One possible way of achieving this is to modify the code of the campaign service:
    load the model, and score the customers right in the service. This approach is
    good, but the campaign service needs to be in Python, and we need to have full
    control over its code.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的一种可能方式是修改活动服务的代码：加载模型，并在服务中评分客户。这种方法很好，但活动服务需要是Python编写的，我们需要完全控制其代码。
- en: 'Unfortunately, this situation is not always the case: it may be written in
    some other language, or a different team might be in charge of this project, which
    means we won’t have the control we need.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种情况并不总是如此：它可能用某种其他语言编写，或者可能由不同的团队负责这个项目，这意味着我们不会拥有所需的控制权。
- en: The typical solution for this problem is putting a model inside a web service—a
    small service (a *microservice*) that only takes care of scoring customers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的典型方案是将模型放入一个网络服务中——一个只负责评分客户的小型服务（一个*微服务*）。
- en: So, we need to create a churn service—a service in Python that will serve the
    churn model. Given the features of a customer, it will respond with the probability
    of churn for this customer. For each customer, the campaign service will ask the
    churn service for the probability of churn, and if it’s high enough, then we send
    a promotional email (figure 5.2).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要创建一个流失服务——一个在 Python 中提供流失模型的网络服务。给定客户的特征，它将返回该客户流失的概率。对于每个客户，营销服务将向流失服务请求流失概率，如果流失概率足够高，那么我们将发送促销电子邮件（图
    5.2）。
- en: '![](../Images/05-02.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05-02.png)'
- en: Figure 5.2 The churn service takes care of serving the churn-prediction model,
    making it possible for other services to use it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 流失服务负责提供流失预测模型，使其他服务能够使用它。
- en: 'This gives us another advantage: separation of concerns. If the model is created
    by data scientists, then they can take ownership of the service and maintain it,
    while the other team takes care of the campaign service.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了另一个优势：关注点的分离。如果模型是由数据科学家创建的，那么他们可以负责服务并维护它，而其他团队则负责营销服务。
- en: One of the most popular frameworks for creating web services in Python is Flask,
    which we cover next.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中创建网络服务最受欢迎的框架之一是 Flask，我们将在下一节中介绍。
- en: 5.2.2 Flask
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 Flask
- en: The easiest way to implement a web service in Python is to use Flask. It’s quite
    lightweight, requires little code to get started, and hides most of the complexity
    of dealing with HTTP requests and responses.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中实现网络服务最简单的方法是使用 Flask。它相当轻量级，启动时需要很少的代码，并且隐藏了处理 HTTP 请求和响应的大部分复杂性。
- en: Before we put our model inside a web service, let’s cover the basics of using
    Flask. For that, we’ll create a simple function and make it available as a web
    service. After covering the basics, we’ll take care of the model.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将模型放入网络服务之前，让我们先了解使用 Flask 的基础知识。为此，我们将创建一个简单的函数并将其作为网络服务提供。在了解基础知识之后，我们将处理模型。
- en: 'Suppose we have a simple Python function called `ping`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简单的 Python 函数，名为 `ping`：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It doesn’t do much: when invoked, it simply responds with PONG. Let’s use Flask
    to turn this function into a web service.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有做太多：当被调用时，它只是简单地响应 PONG。让我们使用 Flask 将这个函数转换成网络服务。
- en: 'Anaconda comes with Flask preinstalled, but if you use a different Python distribution,
    you’ll need to install it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda 预装了 Flask，但如果您使用不同的 Python 发行版，您需要安装它：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will put this code in a Python file and will call it flask_test.py.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个代码放入一个 Python 文件中，并将其命名为 flask_test.py。
- en: 'To be able to use Flask, we first need to import it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Flask，我们首先需要导入它：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we create a Flask app—the central object for registering functions that
    need to be exposed in the web service. We’ll call our app test:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个 Flask 应用程序——这是注册需要在网络服务中公开的函数的中心对象。我们将我们的应用程序命名为 test：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we need to specify how to reach the function by assigning it to an address,
    or a *route* in Flask terms. In our case, we want to use the `/ping` address:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要指定如何通过分配地址或 Flask 术语中的“路由”来访问函数。在我们的例子中，我们想使用 `/ping` 地址：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Registers the /ping route, and assigns it to the ping function
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注册了 /ping 路由，并将其分配给 ping 函数
- en: This code uses decorators—an advanced Python feature that we don’t cover in
    this book. We don’t need to understand how it works in detail; it’s enough to
    know that by putting `@app.route` on top of the function definition, we assign
    the `/ping` address of the web service to the `ping` function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了装饰器——这是一种高级的 Python 功能，我们在这本书中不会详细讲解。我们不需要详细了解它是如何工作的；只需知道，通过在函数定义上方放置
    `@app.route`，我们将网络服务的 `/ping` 地址分配给 `ping` 函数。
- en: 'To run it, we only need one last bit:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行它，我们只需要最后一部分：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `run` method of `app` starts the service. We specify three parameters:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`app` 的 `run` 方法启动服务。我们指定了三个参数：'
- en: '`debug=True`. Restarts our application automatically when there are changes
    in the code.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug=True`。当代码有更改时，会自动重新启动我们的应用程序。'
- en: '`host=''0.0.0.0''`. Makes the web service public; otherwise, it won’t be possible
    to reach it when it’s hosted on a remote machine (e.g., in AWS).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host=''0.0.0.0''`。使网络服务公开；否则，当它在远程机器（例如 AWS）上托管时，将无法访问它。'
- en: '`port=9696`. The port that we use to access the application.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port=9696`。我们用来访问应用程序的端口。'
- en: 'We’re ready to start our service now. Let’s do it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始我们的服务了。让我们来做这件事：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we run it, we should see the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，我们应该看到以下内容：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This means that our Flask app is now running and ready to get requests. To
    test it, we can use our browser: open it and type localhost:9696/ping in the address
    bar. If you run it on a remote server, you should replace localhost with the address
    of the server. (For AWS EC2, use the public DNS hostname. Make sure that the port
    9696 is open in the security group of your EC2 instance: go to the security group,
    and add a custom TCP rule with the port 9696 and the source 0.0.0.0/0.) The browser
    should respond with PONG (figure 5.3).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的 Flask 应用程序现在正在运行，并准备好接收请求。为了测试它，我们可以使用我们的浏览器：打开它，在地址栏中输入 localhost:9696/ping。如果您在远程服务器上运行它，应将
    localhost 替换为服务器的地址。（对于 AWS EC2，请使用公共 DNS 主机名。确保在您的 EC2 实例的安全组中打开了端口 9696：转到安全组，并添加一个自定义
    TCP 规则，端口为 9696，源为 0.0.0.0/0。）浏览器应响应 PONG（图 5.3）。
- en: '![](../Images/05-03.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05-03.png)'
- en: Figure 5.3 The easiest way to check if our application works is to use a web
    browser.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 检查我们的应用程序是否工作的最简单方法是使用 Web 浏览器。
- en: 'Flask logs all the requests it receives, so we should see a line indicating
    that there was a GET request on the `/ping` route:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 记录它接收到的所有请求，因此我们应该看到一条指示在 `/ping` 路由上有一个 GET 请求的行：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we can see, Flask is quite simple: with fewer than 10 lines of code, we
    created a web service.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Flask 非常简单：用不到 10 行代码，我们就创建了一个 Web 服务。
- en: Next, we’ll see how to adjust our script for churn prediction and also turn
    it into a web service.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何调整我们的流失预测脚本，并将其转换为 Web 服务。
- en: 5.2.3 Serving churn model with Flask
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 使用 Flask 提供流失模型
- en: We’ve learned a bit of Flask, so now we can come back to our script and convert
    it to a Flask application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了一些 Flask 的知识，所以现在我们可以回到我们的脚本，将其转换为 Flask 应用程序。
- en: To score a customer, our model needs to get the features, which means that we
    need a way of transferring some data from one service (the campaign service) to
    another (the churn service).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要对客户进行评分，我们的模型需要获取特征，这意味着我们需要一种方法将一些数据从一项服务（营销服务）传输到另一项服务（流失服务）。
- en: 'As a data exchange format, web services typically use JSON (Javascript Object
    Notation). It’s similar to the way we define dictionaries in Python:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据交换格式，Web 服务通常使用 JSON（JavaScript 对象表示法）。它与我们在 Python 中定义字典的方式类似：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To send data, we use POST requests, not GET: POST requests can include the
    data in the request, whereas GET cannot.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送数据，我们使用 POST 请求，而不是 GET：POST 请求可以在请求中包含数据，而 GET 请求则不能。
- en: Thus, to make it possible for the campaign service to get predictions from the
    churn service, we need to create a `/predict` route that accepts POST requests.
    The churn service will parse JSON data about a customer and respond in JSON as
    well (figure 5.4).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了让营销服务能够从流失服务获取预测，我们需要创建一个接受 POST 请求的 `/predict` 路由。流失服务将解析有关客户的 JSON 数据并以
    JSON 格式响应（图 5.4）。
- en: '![](../Images/05-04.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05-04.png)'
- en: Figure 5.4 To get predictions, we POST the data about a customer in JSON to
    the `/predict` route and get the probability of churn in response.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 要获取预测，我们将有关客户的 JSON 数据 POST 到 `/predict` 路由，并得到响应中的流失概率。
- en: Now we know what we want to do, so let’s start modifying the churn_serving.py
    file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们想要做什么，所以让我们开始修改 churn_serving.py 文件。
- en: 'First, we add a few more imports at the top of the file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在文件顶部添加一些额外的导入：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Although previously we imported only `Flask`, now we need to import two more
    things:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管之前我们只导入了 `Flask`，但现在我们需要导入两个更多的事物：
- en: '`request`: To get the content of a POST request'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request`：获取 POST 请求的内容'
- en: '`jsonsify`: To respond with JSON'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonsify`：以 JSON 格式响应'
- en: 'Next, create the Flask app. Let’s call it churn:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建 Flask 应用程序。让我们称它为 churn：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we need to create a function that
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个函数，
- en: Gets the customer data in a request
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取请求中的客户数据
- en: Invokes `predict_simple` to score the customer
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `predict_simple` 对客户进行评分
- en: Responds with the probability of churn in JSON
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 JSON 格式响应流失概率
- en: 'We’ll call this function `predict` and assign it to the `/predict` route:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称此函数为 `predict` 并将其分配给 `/predict` 路由：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Assigns the /predict route to the predict function
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 /predict 路由分配给 predict 函数
- en: ❷ Gets the content of the request in JSON
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取请求内容的 JSON 格式
- en: ❸ Scores the customer
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对客户进行评分
- en: ❹ Prepares the response
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 准备响应
- en: ❺ Converts the response to JSON
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将响应转换为 JSON
- en: To assign the route to the function, we use the `@app.route` decorator, where
    we also tell Flask to expect POST requests only.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要将路由分配给函数，我们使用 `@app.route` 装饰器，同时告诉 Flask 只期望 POST 请求。
- en: 'The core content of the `predict` function is similar to what we did in the
    script previously: it takes a customer, passes it to `predict_single`, and does
    some work with the result.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`predict` 函数的核心内容与我们之前在脚本中做的类似：它接受一个客户，将其传递给 `predict_single`，并对结果进行一些处理。'
- en: 'Finally, let''s add the last two lines for running the Flask app:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加运行Flask应用的最后两行：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We’re ready to run it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好运行它：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After running it, we should see a message saying that the app started and is
    now waiting for incoming requests:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，我们应该看到一条消息，说明应用已启动并正在等待传入的请求：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Testing this code is a bit more difficult than previously: this time, we need
    to use POST requests and include the customer we want to score in the body of
    the request.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这段代码比之前要困难一些：这次，我们需要使用POST请求，并在请求体中包含我们想要评分的客户。
- en: 'The simplest way of doing this is to use the requests library in Python. It
    also comes preinstalled in Anaconda, but if you use a different distribution,
    you can install it with `pip`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中使用requests库来做这件事是最简单的方式。它也预安装在Anaconda中，但如果使用不同的发行版，可以使用`pip`安装它：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can open the same Jupyter Notebook that we used previously and test the web
    service from there.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打开之前使用的同一个Jupyter Notebook，并从那里测试网络服务。
- en: 'First, import requests:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入requests：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, make a POST request to our service
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向我们的服务发送一个POST请求
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ The URL where the service lives
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 服务所在的服务器地址
- en: ❷ Sends the customer (as JSON) in the POST request
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在POST请求中发送客户（作为JSON）
- en: ❸ Parses the response as JSON
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将响应解析为JSON
- en: 'The `results` variable contains the response from the churn service:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`results` 变量包含来自流失服务的响应：'
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is the same information we previously saw in the terminal, but now we got
    it as a response from a web service.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前在终端中看到的信息，但现在我们是从一个网络服务中获取的响应。
- en: Note Some tools, like Postman ([https://www.postman.com/](https://www.postman.com/)),
    make it easier to test web services. We don’t cover Postman in this book, but
    you’re free to give it a try.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一些工具，如Postman ([https://www.postman.com/](https://www.postman.com/))，使测试网络服务变得更容易。本书中不涵盖Postman，但你可以自由尝试。
- en: If the campaign service used Python, this is exactly how it could communicate
    with the churn service and decide who should get promotional emails.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果营销服务使用Python，这正是它与流失服务通信并决定谁应该收到促销邮件的方式。
- en: With just a few lines of code, we created a working web service that runs on
    our laptop. In the next section, we’ll see how to manage dependencies in our service
    and prepare it for deployment.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 只用几行代码，我们就创建了一个在笔记本电脑上运行的实用网络服务。在下一节中，我们将看到如何管理服务中的依赖项并为其部署做准备。
- en: 5.3 Managing dependencies
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 管理依赖
- en: 'For local development, Anaconda is a perfect tool: it has almost all the libraries
    we may ever need. This, however, also has a downside: it takes up 4 GB when unpacked,
    which is too large. For production, we prefer to have only the libraries we actually
    need.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地开发，Anaconda是一个完美的工具：它几乎包含了我们可能需要的所有库。然而，这也存在一个缺点：解包后占用4GB的空间，这太大了。对于生产环境，我们更倾向于只安装我们实际需要的库。
- en: Additionally, different services have different requirements. Often, these requirements
    conflict, so we cannot use the same environment for running multiple services
    at the same time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，不同的服务有不同的要求。通常，这些要求是冲突的，因此我们无法使用同一个环境同时运行多个服务。
- en: 'In this section, we see how to manage dependencies of our application in an
    isolated way that doesn’t interfere with other services. We cover two tools for
    this: Pipenv, for managing Python libraries, and Docker, for managing the system
    dependencies such as the operating system and the system libraries.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何以隔离的方式管理我们应用程序的依赖项，这样就不会干扰其他服务。我们将介绍两个工具来完成这项工作：用于管理Python库的Pipenv，以及用于管理操作系统和系统库等系统依赖项的Docker。
- en: 5.3.1 Pipenv
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 Pipenv
- en: 'To serve the churn model, we only need a few libraries: NumPy, Scikit-learn,
    and Flask. So, instead of bringing in the entire Anaconda distribution with all
    its libraries, we can get a fresh Python installation and install only the libraries
    we need with `pip`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供流失模型，我们只需要几个库：NumPy、Scikit-learn和Flask。因此，我们不需要带上包含所有库的整个Anaconda发行版，我们可以安装一个全新的Python安装，并使用`pip`安装我们需要的库：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before we do that, let’s think for a moment about what happens when we use
    `pip` to install a library:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在做之前，让我们思考一下当我们使用`pip`安装库时会发生什么：
- en: We run `pip` `install` `library` to install a Python package called Library
    (let’s suppose it exists).
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们运行`pip install library`来安装一个名为Library的Python包（假设它存在）。
- en: Pip goes to PyPI.org (the Python package index—a repository with Python packages),
    and gets and installs the latest version of this library. Let’s say, it’s version
    1.0.0.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pip 前往 PyPI.org（Python 包索引——一个包含 Python 包的仓库），获取并安装这个库的最新版本。比如说，它是版本 1.0.0。
- en: After installing it, we develop and test our service using this particular version.
    Everything works great. Later, our colleagues want to help us with the project,
    so they also run `pip` `install` to set up everything on their machine—except
    this time, the latest version turns out to be 1.3.1.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，我们使用这个特定的版本开发和测试我们的服务。一切工作得很好。后来，我们的同事想帮助我们进行项目，所以他们也在他们的机器上运行 `pip install`
    来设置一切——但这次，最新版本变成了 1.3.1。
- en: If we’re unlucky, versions 1.0.0 and 1.3.1 might not be compatible with each
    other, meaning that the code we wrote for version 1.0.0 won’t work for version
    1.3.1.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运气不好，版本 1.0.0 和 1.3.1 可能不兼容，这意味着我们为版本 1.0.0 编写的代码将无法在版本 1.3.1 中工作。
- en: 'It’s possible to solve this problem by specifying the exact version of the
    library when installing it with `pip`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `pip` 安装库时指定确切的版本可以解决这个问题：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Unfortunately, a different problem may appear: what if some of our colleagues
    already have version 1.3.1 installed, and they already used it for some other
    services? In this case, they cannot go back to using version 1.0.0: it could cause
    their code to stop working.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，可能还会出现另一个问题：如果我们的某些同事已经安装了版本 1.3.1，并且他们已经使用它为其他服务，那么在这种情况下，他们不能回到使用版本 1.0.0：这可能导致他们的代码停止工作。
- en: We can solve these problems by creating a *virtual environment* for each project—a
    separate Python distribution with nothing else but libraries required for this
    particular project.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为每个项目创建一个 *虚拟环境* 来解决这些问题——一个仅包含特定项目所需库的独立 Python 发行版。
- en: 'Pipenv is a tool that makes managing virtual environments easier. We can install
    it with pip:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Pipenv 是一个使管理虚拟环境更简单的工具。我们可以使用 pip 来安装它：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After that, we use `pipenv` instead of `pip` for installing dependencies:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用 `pipenv` 而不是 `pip` 来安装依赖项：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When running it, we’ll see that first, it configures the virtual environment,
    and then it installs the libraries:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行它时，我们会看到首先配置虚拟环境，然后安装库：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After finishing the installation, it creates two files: Pipenv and Pipenv.lock.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，它创建了两个文件：Pipenv 和 Pipenv.lock。
- en: 'The Pipenv file looks pretty simple:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Pipenv 文件看起来相当简单：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We see that this file contains a list of libraries as well as the version of
    Python we use.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个文件包含了一个库列表以及我们使用的 Python 版本。
- en: 'The other file—Pipenv.lock—contains the specific versions of the libraries
    that we used for the project. The file is too large to show in its entirety here,
    but let’s take a look at one of the entries in the file:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个文件——Pipenv.lock——包含了项目中使用的库的具体版本。由于文件太大，无法在此全部显示，但让我们看看文件中的一个条目：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As we can see, it records the exact version of the library that was used during
    installation. To make sure the library doesn’t change, it also saves the hashes—the
    checksums that can be used to validate that in the future we download the exact
    same version of the library. This way, we “lock” the dependencies to specific
    versions. By doing this, we make sure that in the future we will not have surprises
    with two incompatible versions of the same library.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它记录了安装期间使用的库的确切版本。为了确保库不会更改，它还保存了散列——可以用来验证未来我们下载的库的确切版本的校验和。这样，我们将依赖项“锁定”到特定版本。通过这样做，我们确保未来我们不会遇到同一库的两个不兼容版本。
- en: 'If somebody needs to work on our project, they simply need to run the `install`
    command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人需要为我们项目工作，他们只需运行 `install` 命令：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This step will first create a virtual environment and then install all the required
    libraries from Pipenv.lock.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤将首先创建一个虚拟环境，然后从 Pipenv.lock 中安装所有必需的库。
- en: Important Locking the version of a library is important for reproducibility
    in the future and helps us avoid having unpleasant surprises with code incompatibility.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 重要：锁定库的版本对于未来的可重复性很重要，并有助于我们避免代码不兼容带来的不愉快惊喜。
- en: 'After all the libraries are installed, we need to activate the virtual environment—this
    way, our application will use the correct versions of the libraries. We do it
    by running the `shell` command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完所有库后，我们需要激活虚拟环境——这样，我们的应用程序将使用库的正确版本。我们通过运行 `shell` 命令来完成：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It tells us that it’s running in a virtual environment:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我们它正在虚拟环境中运行：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we can run our script for serving:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行我们的脚本以提供服务：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Alternatively, instead of first explicitly entering the virtual environment
    and then running the script, we can perform these two steps with just one command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们不必首先明确进入虚拟环境然后运行脚本，我们可以用一条命令完成这两个步骤：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `run` command in Pipenv simply runs the specified program in the virtual
    environment.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Pipenv中的`run`命令简单地运行虚拟环境中的指定程序。
- en: 'Regardless of the way we run it, we should see exactly the same output as previously:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们以何种方式运行它，我们都应该看到与之前完全相同的输出：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When we test it with requests, we see the same output:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用requests进行测试时，我们会看到相同的输出：
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You most likely also noticed the following warning in the console:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能会在控制台注意到以下警告：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The built-in Flask web server is indeed for development only: it’s very easy
    to use for testing our application, but it won’t work reliably under load. We
    should use a proper WSGI server instead, as the warning suggests.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的Flask网络服务器确实仅适用于开发：它非常容易用于测试我们的应用程序，但在负载下不会可靠地工作。我们应该使用合适的WSGI服务器，正如警告所建议的。
- en: WSGI stands for *web server gateway interface*, which is a specification describing
    how Python applications should handle HTTP requests. The details of WSGI are not
    important for the purposes of this book, so we won’t cover it in detail.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI代表*Web服务器网关接口*，这是一个描述Python应用程序应该如何处理HTTP请求的规范。WSGI的细节对于本书的目的并不重要，所以我们不会详细讨论。
- en: We will, however, address the warning by installing a production WSGI server.
    We have multiple possible options in Python, and we’ll use Gunicorn.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过安装生产WSGI服务器来处理这个警告。Python有多种可能的选择，我们将使用Gunicorn。
- en: 'Note Gunicorn doesn’t work on Windows: it relies on features specific to Linux
    and Unix (which includes MacOS). A good alternative that also works on Windows
    is Waitress. Later, we will use Docker, which will solve this problem—it runs
    Linux inside a container.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Gunicorn在Windows上不工作：它依赖于Linux和Unix（包括MacOS）特有的功能。一个在Windows上也能工作的良好替代品是Waitress。稍后，我们将使用Docker，这将解决这个问题——它在容器内运行Linux。
- en: 'Let’s install it with Pipenv:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用Pipenv安装它：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This command installs the library and includes it as a dependency in the project
    by adding it to the Pipenv and Pipenv.lock files.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令安装库，并通过将其添加到Pipenv和Pipenv.lock文件中，将其作为项目依赖项包含在内。
- en: 'Let’s run our application with Gunicorn:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用Gunicorn运行我们的应用程序：
- en: '[PRE53]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If everything goes well, we should see the following messages in the terminal:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该在终端看到以下信息：
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Unlike the Flask built-in web server, Gunicorn is ready for production, so it
    will not have any problems under load when we start using it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与Flask内置的网络服务器不同，Gunicorn适用于生产，因此当我们开始使用它时，在负载下不会出现任何问题。
- en: 'If we test it with the same code as previously, we see the same answer:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用之前相同的代码进行测试，我们会看到相同的答案：
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Pipenv is a great tool for managing dependencies: it isolates the required
    libraries into a separate environment, thus helping us avoid conflicts between
    different versions of the same package.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Pipenv是一个管理依赖项的出色工具：它将所需的库隔离到单独的环境中，从而帮助我们避免不同版本的同一包之间的冲突。
- en: In the next section, we look at Docker, which allows us to isolate our application
    even further and ensure it runs smoothly anywhere.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨Docker，它允许我们进一步隔离我们的应用程序并确保它在任何地方都能顺利运行。
- en: 5.3.2 Docker
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 Docker
- en: We have learned how to manage Python dependencies with Pipenv. However, some
    of the dependencies live outside of Python. Most importantly, these dependencies
    include the operating system (OS) as well as the system libraries.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用Pipenv管理Python依赖。然而，一些依赖项存在于Python之外。最重要的是，这些依赖项包括操作系统（OS）以及系统库。
- en: For example, we might use Ubuntu version 16.04 for developing our service, but
    if some of our colleagues use Ubuntu version 20.04, they may run into trouble
    when trying to execute the service on their laptop.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能会使用Ubuntu 16.04版本来开发我们的服务，但如果我们的某些同事使用Ubuntu 20.04版本，他们在尝试在自己的笔记本电脑上执行服务时可能会遇到麻烦。
- en: Docker solves this “but it works on my machine” problem by also packaging the
    OS and the system libraries into a *Docker container*—a self-contained environment
    that works anywhere where Docker is installed (figure 5.5).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Docker通过将操作系统和系统库打包到*Docker容器*中解决了“在我的机器上它工作”的问题——这是一个在任何安装了Docker的地方都能工作的自包含环境（图5.5）。
- en: '![](../Images/05-05.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05-05.png)'
- en: Figure 5.5 In case of no isolation (a), the service runs with system Python.
    In virtual environments (b), we isolate the dependencies of our service inside
    the environment. In Docker containers (c), we isolate the entire environment of
    the service, including the OS and system libraries.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 在没有隔离（a）的情况下，服务使用系统 Python 运行。在虚拟环境（b）中，我们将服务的依赖项隔离在环境中。在 Docker 容器（c）中，我们将服务的整个环境隔离，包括操作系统和系统库。
- en: Once the service is packaged into a Docker container, we can run it on the *host
    machine*—our laptop (regardless of the OS) or any public cloud provider.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务被打包成 Docker 容器，我们就可以在 *主机机器* 上运行它——我们的笔记本电脑（无论操作系统如何）或任何公共云提供商。
- en: Let’s see how to use it for our project. We assume you already have Docker installed.
    Please refer to appendix A for details on how to install it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将其用于我们的项目。我们假设您已经安装了 Docker。请参阅附录 A 了解如何安装 Docker 的详细信息。
- en: First, we need to create a *Docker image*—the description of our service that
    includes all the settings and dependencies. Docker will later use the image to
    create a container. To do it, we need a Dockerfile—a file with instructions on
    how the image should be created (figure 5.6).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个 *Docker 镜像*——这是我们的服务的描述，包括所有设置和依赖项。Docker 将稍后使用该镜像来创建容器。为此，我们需要一个
    Dockerfile——一个包含如何创建镜像的指令的文件（图 5.6）。
- en: '![](../Images/05-06.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05-06.png)'
- en: Figure 5.6 We build an image using instructions from Dockerfile. Then we can
    run this image on a host machine.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 我们使用 Dockerfile 中的指令构建一个镜像。然后我们可以在主机机器上运行这个镜像。
- en: 'Let’s create a file with name Dockerfile and the following content (note that
    the file shouldn’t include the annotations):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 Dockerfile 的文件，并包含以下内容（注意，文件不应包含注释）：
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ❶ Specifies the base image
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指定基础镜像
- en: ❷ Sets a special Python settings for being able to see logs
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置特殊的 Python 设置以便能够看到日志
- en: ❸ Installs Pipenv
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 安装 Pipenv
- en: ❹ Sets the working directory to /app
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将工作目录设置为 /app
- en: ❺ Copies the Pipenv files
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 复制 Pipenv 文件
- en: ❻ Installs the dependencies from the Pipenv files
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 从 Pipenv 文件中安装依赖项
- en: ❼ Copies our code as well as the model
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 复制我们的代码以及模型
- en: ❽ Opens the port that our web service uses
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 打开我们的 Web 服务使用的端口
- en: ❾ Specifies how the service should be started
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 指定服务应该如何启动
- en: That’s a lot of information to unpack, especially if you have never seen Dockerfiles
    previously. Let’s go line by line.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要解包大量信息，尤其是如果你以前从未见过 Dockerfile。让我们逐行分析。
- en: 'First, we specify the base Docker image:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们指定基本 Docker 镜像：
- en: '[PRE57]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We use this image as the starting point and build our own image on top of that.
    Typically, the base image already contains the OS and the system libraries like
    Python itself, so we need to install only the dependencies of our project. In
    our case, we use `python:3.7.5-slim`, which is based on Debian 10.2 and contains
    Python version 3.7.5 and `pip`. You can read more about the Python base image
    in Docker hub ([https://hub.docker.com/_ /python](https://hub.docker.com/_/python))—the
    service for sharing Docker images.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个镜像作为起点，并在其之上构建自己的镜像。通常，基础镜像已经包含了操作系统和系统库，如 Python 本身，因此我们只需要安装我们项目的依赖项。在我们的例子中，我们使用
    `python:3.7.5-slim`，它基于 Debian 10.2，包含 Python 版本 3.7.5 和 `pip`。您可以在 Docker Hub
    上了解更多关于 Python 基础镜像的信息（[https://hub.docker.com/_/python](https://hub.docker.com/_/python)）——共享
    Docker 镜像的服务。
- en: All Dockerfiles should start with the `FROM` statement.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Dockerfile 都应该以 `FROM` 语句开始。
- en: 'Next, we set the `PYTHONUNBUFFERED` environmental variable to `TRUE`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 `PYTHONUNBUFFERED` 环境变量设置为 `TRUE`：
- en: '[PRE58]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Without this setting, we won’t be able to see the logs when running Python scripts
    inside Docker.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这个设置，我们在 Docker 内运行 Python 脚本时将无法看到日志。
- en: 'Then, we use `pip` to install Pipenv:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `pip` 安装 Pipenv：
- en: '[PRE59]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `RUN` instruction in Docker simply runs a shell command. By default, `pip`
    saves the libraries to a cache, so later they can be installed faster. We don’t
    need that in a Docker container, so we use the `--no-cache-dir` setting.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 中的 `RUN` 指令简单地运行一个 shell 命令。默认情况下，`pip` 将库保存到缓存中，以便稍后可以更快地安装。我们不需要在 Docker
    容器中这样做，因此我们使用 `--no-cache-dir` 设置。
- en: 'Then, we specify the working directory:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们指定工作目录：
- en: '[PRE60]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is roughly equivalent to the `cd` command in Linux (change directory),
    so everything we will run after that will be executed in the /app folder.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这大致相当于 Linux 中的 `cd` 命令（更改目录），因此之后我们将运行的所有内容都将执行在 /app 文件夹中。
- en: 'Then, we copy the Pipenv files to the current working directory (i.e., /app):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 Pipenv 文件复制到当前工作目录（即，/app）：
- en: '[PRE61]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We use these files for installing the dependencies with Pipenv:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这些文件通过 Pipenv 安装依赖项：
- en: '[PRE62]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Previously, we simply used `pipenv` `install` for doing this. Here, we include
    two extra parameters: `--deploy` and `--system`. Inside Docker, we don’t need
    to create a virtual environment—our Docker container is already isolated from
    the rest of the system. Setting these parameters allows us to skip creating a
    virtual environment and use the system Python for installing all the dependencies.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们只是简单地使用`pipenv install`来做这件事。在这里，我们包括了两个额外的参数：`--deploy`和`--system`。在Docker内部，我们不需要创建虚拟环境——我们的Docker容器已经与系统其他部分隔离。设置这些参数允许我们跳过创建虚拟环境，并使用系统Python来安装所有依赖项。
- en: After installing the libraries, we clean the cache to make sure our Docker image
    doesn’t grow too big.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完库后，我们清理缓存以确保我们的Docker镜像不会变得太大。
- en: 'Then, we copy our project files as well as the pickled model:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们复制我们的项目文件以及pickle模型：
- en: '[PRE63]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, we specify which port our application will use. In our case, it’s 9696:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指定应用程序将使用的端口。在我们的例子中，它是9696：
- en: '[PRE64]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, we tell Docker how our application should be started:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们告诉Docker我们的应用程序应该如何启动：
- en: '[PRE65]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is the same command we used previously when running Gunicorn locally.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前在本地运行Gunicorn时使用的相同命令。
- en: 'Let’s build the image. We do it by running the `build` command in Docker:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建图像。我们通过在Docker中运行`build`命令来完成：
- en: '[PRE66]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `-t` flag lets us set the tag name for the image, and the final parameter—the
    dot—specifies the directory with the Dockerfile. In our case, it means that we
    use the current directory.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t`标志让我们设置图像的标签名称，最后一个参数——点号——指定了包含Dockerfile的目录。在我们的例子中，这意味着我们使用当前目录。'
- en: 'When we run it, the first thing Docker does is download the base image:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，Docker首先下载基础镜像：
- en: '[PRE67]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then it executes each line of the Dockerfile one by one:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它逐行执行Dockerfile中的每一行：
- en: '[PRE68]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'At the end, Docker tells us that it successfully built an image and tagged
    it as churn-prediction:latest:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Docker告诉我们它已成功构建了一个图像，并将其标记为churn-prediction:latest：
- en: '[PRE69]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We’re ready to use this image to start a Docker container. Use the `run` command
    for that:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好使用这个图像来启动一个Docker容器。使用`run`命令来执行：
- en: '[PRE70]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We specify a few parameters here:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里指定了一些参数：
- en: The `-it` flag tells Docker that we run it from our terminal and we need to
    see the results.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-it`标志告诉Docker我们从终端运行它，并且我们需要看到结果。'
- en: The `-p` parameter specifies the port mapping. `9696:9696` means to map the
    port 9696 on the container to the port 9696 on the host machine.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`参数指定端口映射。`9696:9696`意味着将容器上的端口9696映射到主机机器上的端口9696。'
- en: Finally, we need the image name and tag, which in our case is `churn-prediction
    :latest`.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们需要图像名称和标签，在我们的例子中是`churn-prediction :latest`。
- en: Now our service is running inside a Docker container, and we can connect to
    it using port 9696 (figure 5.7). This is the same port we used for our application
    previously.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的服务正在Docker容器内运行，我们可以通过端口9696（图5.7）连接到它。这是我们之前用于应用程序的相同端口。
- en: '![](../Images/05-07.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7](../Images/05-07.png)'
- en: Figure 5.7 The 9696 port on the host machine is mapped to the 9696 port of the
    container, so when we send a request to `localhost:9696`, it’s handled by our
    service in Docker.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 主机机器上的9696端口映射到容器的9696端口，因此当我们向`localhost:9696`发送请求时，它由Docker中的我们的服务处理。
- en: 'Let’s test it using the same code. When we run it, we’ll see the same response:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用相同的代码进行测试。当我们运行它时，我们会看到相同的响应：
- en: '[PRE71]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Docker makes it easy to run services in a reproducible way. With Docker, the
    environment inside the container always stays the same. This means that if we
    can run our service on a laptop, it will work anywhere else.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使得以可重复的方式运行服务变得容易。使用Docker，容器内的环境始终保持不变。这意味着如果我们能在笔记本电脑上运行我们的服务，它将可以在任何其他地方工作。
- en: We already tested our application on our laptop, so now let’s see how to run
    it on a public cloud and deploy it to AWS.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在笔记本电脑上测试了我们的应用程序，所以现在让我们看看如何在公共云上运行它并将其部署到AWS。
- en: 5.4 Deployment
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 部署
- en: We don’t run production services on our laptops; we need special servers for
    that.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不在笔记本电脑上运行生产服务；我们需要专门的服务器来运行这些服务。
- en: 'In this section, we’ll cover one possible option for that: Amazon Web Services,
    or AWS. We decided to choose AWS for its popularity—we’re not affiliated with
    Amazon or AWS.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一个可能的选项：亚马逊网络服务，或简称AWS。我们选择AWS是因为它的流行——我们与亚马逊或AWS没有关联。
- en: Other popular public clouds include Google Cloud, Microsoft Azure, and Digital
    Ocean. We don’t cover them in this book, but you should be able to find similar
    instructions online and deploy a model to your favourite cloud provider.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 其他流行的公共云包括Google Cloud、Microsoft Azure和Digital Ocean。本书不涵盖它们，但你应该能够在网上找到类似的说明并将模型部署到你喜欢的云服务提供商。
- en: This section is optional, so you can safely skip it. To follow the instructions
    in this section, you need to have an AWS account and configure the AWS command-line
    tool (CLI). Please refer to appendix A to see how to set it up.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分是可选的，所以你可以安全地跳过它。要遵循本节中的说明，你需要有一个AWS账户并配置AWS命令行工具（CLI）。请参阅附录A以了解如何设置它。
- en: 5.4.1 AWS Elastic Beanstalk
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 AWS Elastic Beanstalk
- en: AWS provides a lot of services, and we have many possible ways of deploying
    a web service there. For example, you can rent an EC2 machine (a server in AWS)
    and manually set up a service on it, use a “serverless” approach with AWS Lambda,
    or use a range of other services.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: AWS提供了许多服务，我们有很多可能的部署Web服务的方式。例如，你可以租用一个EC2机器（AWS中的服务器）并手动在其上设置服务，使用AWS Lambda的“无服务器”方法，或者使用一系列其他服务。
- en: In this section, we’ll use AWS Elastic Beanstalk, which is one of the simplest
    ways of deploying a model to AWS. Additionally, our service is simple enough,
    so it’s possible to stay within the free-tier limits. In other words, we can use
    it for free for the first year.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用AWS Elastic Beanstalk，这是将模型部署到AWS的最简单方法之一。此外，我们的服务足够简单，因此我们可以在免费层限制内使用。换句话说，我们可以在第一年免费使用它。
- en: Elastic Beanstalk automatically takes care of many things that we typically
    need in production, including
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Elastic Beanstalk自动处理我们在生产环境中通常需要处理的大量事情，包括
- en: Deploying our service to EC2 instances
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的服务部署到EC2实例
- en: 'Scaling up: adding more instances to handle the load during peak hours'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展规模：在高峰时段添加更多实例以处理负载
- en: 'Scaling down: removing these instances when the load goes away'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩小规模：在负载消失时移除这些实例
- en: Restarting the service if it crashes for any reason
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务因任何原因崩溃，重新启动服务
- en: Balancing the load between instances
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实例之间平衡负载
- en: We’ll also need a special utility—Elastic Beanstalk command-line interface (CLI)—to
    use Elastic Beanstalk. The CLI is written in Python, so we can install it with
    `pip`, like any other Python tool.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个特殊的实用工具——Elastic Beanstalk命令行界面（CLI）——来使用Elastic Beanstalk。CLI是用Python编写的，因此我们可以像安装任何其他Python工具一样使用`pip`来安装它。
- en: However, because we use Pipenv, we can add it as a development dependency. This
    way, we’ll install it only for our project and not systemwide.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因为我们使用Pipenv，我们可以将其添加为开发依赖项。这样，我们只为我们的项目安装它，而不是系统范围内。
- en: '[PRE72]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note Development dependencies are the tools and libraries that we use for developing
    our application. Usually, we need them only locally and don’t need them in the
    actual package deployed to production.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，开发依赖项是我们用于开发应用程序的工具和库。通常，我们只需要在本地使用它们，不需要将它们包含在实际部署到生产环境的包中。
- en: 'After installing Elastic Beanstalk, we can enter the virtual environment of
    our project:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Elastic Beanstalk后，我们可以进入我们项目的虚拟环境：
- en: '[PRE73]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now the CLI should be available. Let’s check it:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在CLI应该可用。让我们检查一下：
- en: '[PRE74]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'It should print the version:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该打印版本：
- en: '[PRE75]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, we run the initialization command:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们运行初始化命令：
- en: '[PRE76]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Note that we use `-p` `docker`: this way, we specify that this is a Docker-based
    project.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `-p` `docker`：这样，我们指定这是一个基于Docker的项目。
- en: If everything is fine, it creates a couple of files, including a config.yml
    file in .elasticbeanstalk folder.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，它会在 `.elasticbeanstalk` 文件夹中创建一些文件，包括一个 config.yml 文件。
- en: 'Now we can test our application locally by using `local` `run` command:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用 `local` `run` 命令在本地测试我们的应用程序：
- en: '[PRE77]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This should work in the same way as in the previous section with Docker: it’ll
    first build an image and then run the container.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该与上一节中的Docker以相同的方式工作：它首先构建一个镜像，然后运行容器。
- en: 'To test it, we can use the same code as previously and get the same answer:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，我们可以使用之前相同的代码并得到相同的答案：
- en: '[PRE78]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'After verifying that it works well locally, we’re ready to deploy it to AWS.
    We can do that with one command:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地验证它运行良好后，我们就准备好将其部署到AWS了。我们可以用一条命令来完成：
- en: '[PRE79]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This simple command takes care of setting up everything we need, from the EC2
    instances to auto-scaling rules:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的命令负责设置我们需要的所有内容，从EC2实例到自动扩展规则：
- en: '[PRE80]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: It’ll take a few minutes to create everything. We can monitor the process and
    see what it’s doing in the terminal.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 创建所有内容需要几分钟。我们可以监控这个过程，并在终端中查看它在做什么。
- en: 'When it’s ready, we should see the following information:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当它准备就绪时，我们应该看到以下信息：
- en: '[PRE81]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The URL (churn-serving-env.5w9pp7bkmj.us-west-2.elasticbeanstalk.com) in the
    logs is important: this is how we reach our application. Now we can use this URL
    to make predictions (figure 5.8).'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 日志中的 URL（churn-serving-env.5w9pp7bkmj.us-west-2.elasticbeanstalk.com）很重要：这是我们访问应用程序的方式。现在我们可以使用此
    URL 进行预测（图 5.8）。
- en: '![](../Images/05-08.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-08.png)'
- en: Figure 5.8 Our service is deployed inside a container on AWS Elastic Beanstalk.
    To reach it, we use its public URL.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 我们的服务已部署在 AWS Elastic Beanstalk 的容器内。要访问它，我们使用其公共 URL。
- en: 'Let’s test it:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下：
- en: '[PRE82]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'As previously, we should see the same response:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们应该看到相同的响应：
- en: '[PRE83]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: That’s all! We have a running service.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！我们有一个正在运行的服务。
- en: Warning This is a toy example, and the service we created is accessible by anyone
    in the world. If you do it inside an organization, the access should be restricted
    as much as possible. It’s not difficult to extend this example to be secure, but
    it’s outside the scope of this book. Consult the security department at your company
    before doing it at work.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：这是一个玩具示例，我们创建的服务对世界上任何人都可访问。如果您在组织内部进行操作，应尽可能限制访问权限。将此示例扩展为安全版本并不困难，但这超出了本书的范围。在您的工作中实施之前，请咨询公司的安全部门。
- en: We can do everything from the terminal using the CLI, but it’s also possible
    to manage it from the AWS Console. To do so, we find Elastic Beanstalk there and
    select the environment we just created (figure 5.9).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 CLI 从终端做所有事情，但也可以从 AWS 控制台管理它。为此，我们在那里找到 Elastic Beanstalk，并选择我们刚刚创建的环境（图
    5.9）。
- en: '![](../Images/05-09.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-09.png)'
- en: Figure 5.9 We can manage the Elastic Beanstalk environment in the AWS Console.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 我们可以在 AWS 控制台中管理 Elastic Beanstalk 环境。
- en: To turn it off, choose Terminate deployment in the Environment actions menu
    using the AWS Console.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭它，请使用 AWS 控制台中的环境操作菜单选择“终止部署”。
- en: Warning Even though Elastic Beanstalk is free-tier eligible, we should always
    be careful and turn it off as soon as we no longer need it.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：尽管 Elastic Beanstalk 允许免费层使用，但我们始终应该小心，一旦不再需要，就立即将其关闭。
- en: 'Alternatively, we use the CLI to do it:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 CLI 来执行：
- en: '[PRE84]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: After a few minutes, the deployment will be removed from AWS and the URL will
    no longer be accessible.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，部署将从 AWS 中移除，URL 将不再可访问。
- en: AWS Elastic Beanstalk is a great tool for getting started with serving machine
    learning models. More advanced ways of doing it involve container orchestration
    systems like AWS ECS or Kubernetes or “serverless” with AWS Lambda. We will come
    back to this topic in chapters 8 and 9 when covering the deployment of deep learning
    models.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Elastic Beanstalk 是一个用于开始提供机器学习模型的出色工具。更高级的实现方式涉及容器编排系统，如 AWS ECS 或 Kubernetes，或者使用
    AWS Lambda 的“无服务器”。我们将在第 8 章和第 9 章中介绍深度学习模型的部署时回到这个话题。
- en: 5.5 Next steps
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 下一步
- en: We’ve learned about Pipenv and Docker and deployed our model to AWS Elastic
    Beanstalk. Try these other things to expand your skills on your own.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了 Pipenv 和 Docker，并将我们的模型部署到了 AWS Elastic Beanstalk。尝试以下其他事情来扩展您自己的技能。
- en: 5.5.1 Exercises
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 练习
- en: 'Try the following exercises to further explore the topics of model deployment:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下练习，以进一步探索模型部署的主题：
- en: If you don’t use AWS, try to repeat the steps from section 5.4 on any other
    cloud provider. For example, you could try Google Cloud, Microsoft Azure, Heroku,
    or Digital Ocean.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您不使用 AWS，请尝试在其他云服务提供商上重复第 5.4 节中的步骤。例如，您可以尝试 Google Cloud、Microsoft Azure、Heroku
    或 Digital Ocean。
- en: Flask is not the only way of creating web services in Python. You can try alternative
    frameworks like FastAPI ([https://fastapi.tiangolo.com/](https://fastapi.tiangolo.com/)),
    Bottle ([https://github.com/bottlepy/bottle](https://github.com/bottlepy/bottle)),
    or Falcon ([https://github.com/falconry/falcon](https://github.com/falconry/falcon)).
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask 并非在 Python 中创建 Web 服务的唯一方式。您可以尝试其他框架，如 FastAPI ([https://fastapi.tiangolo.com/](https://fastapi.tiangolo.com/))、Bottle
    ([https://github.com/bottlepy/bottle](https://github.com/bottlepy/bottle)) 或 Falcon
    ([https://github.com/falconry/falcon](https://github.com/falconry/falcon))。
- en: 5.5.2 Other projects
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2 其他项目
- en: 'You can continue other projects from the previous chapters and make them available
    as a web service as well. For example:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续之前章节中的其他项目，并将它们作为 Web 服务提供。例如：
- en: The car-price prediction model we created in chapter 2
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 2 章中创建的汽车价格预测模型。
- en: 'The self-study projects from chapter 3: the lead scoring project and the default
    prediction project.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 3 章中的自学项目：评分项目和使用默认预测项目。
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Pickle is a serialization/deserialization library that comes built into Python.
    We can use it to save a model we trained in Jupyter Notebook and load it in a
    Python script.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pickle 是一个内置在 Python 中的序列化/反序列化库。我们可以用它来保存我们在 Jupyter Notebook 中训练的模型，并在 Python
    脚本中加载它。
- en: The simplest way of making a model available for others is wrapping it into
    a Flask web service.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模型提供给他人的最简单方式是将它封装成一个 Flask 网络服务。
- en: Pipenv is a tool for managing Python dependencies by creating virtual environments,
    so dependencies of one Python project don’t interfere with dependencies of another
    Python project.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pipenv 是一个通过创建虚拟环境来管理 Python 依赖项的工具，因此一个 Python 项目的依赖项不会干扰另一个 Python 项目的依赖项。
- en: Docker makes it possible to isolate the service completely from other services
    by packaging into a Docker container not only the Python dependencies but also
    the system dependencies, as well as the operational system itself.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 通过将 Python 依赖项、系统依赖项以及操作本身打包到一个 Docker 容器中，使得服务可以完全与其他服务隔离。
- en: AWS Elastic Beanstalk is a simple way to deploy a web service. It takes care
    of managing EC2 instances, scaling the service up and down, and restarting if
    something fails.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Elastic Beanstalk 是一种简单的方式来部署一个网络服务。它负责管理 EC2 实例，根据需要调整服务的大小，并在出现故障时重启服务。
- en: In the next chapter, we continue learning about classification but with a different
    type of model—decision trees.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们继续学习分类，但使用的是不同类型的模型——决策树。
