- en: Chapter 13\. Refactoring to microservices
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第13章\. 微服务重构
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: When to migrate a monolithic application to a microservice architecture
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时将单体应用迁移到微服务架构
- en: Why using an incremental approach is essential when refactoring a monolithic
    application to microservices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么在重构单体应用为微服务时使用增量方法至关重要
- en: Implementing new features as services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新功能作为服务实现
- en: Extracting services from the monolith
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从单体中提取服务
- en: Integrating a service and the monolith
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成服务和单体
- en: I hope that this book has given you a good understanding of the microservice
    architecture, its benefits and drawbacks, and when to use it. There is, however,
    a fairly good chance you’re working on a large, complex monolithic application.
    Your daily experience of developing and deploying your application is slow and
    painful. Microservices, which appear like a good fit for your application, seem
    like distant nirvana. Like Mary and the rest of the FTGO development team, you’re
    wondering how on earth you can adopt the microservice architecture?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这本书已经让你对微服务架构、其优势和劣势以及何时使用它有了很好的理解。然而，你很可能正在处理一个大型、复杂的单体应用。你开发和应用应用程序的日常体验缓慢且痛苦。看起来非常适合你的应用程序的微服务似乎是一个遥远的极乐世界。像玛丽和FTGO开发团队的其他成员一样，你可能想知道如何才能采用微服务架构？
- en: Fortunately, there are strategies you can use to escape from monolithic hell
    without having to rewrite your application from scratch. You incrementally convert
    your monolith into microservices by developing what’s known as a strangler application.
    The idea of a strangler application comes from strangler vines, which grow in
    rain forests by enveloping and sometimes killing trees. A *strangler application*
    is a new application consisting of microservices that you develop by implementing
    new functionality as services and extracting services from the monolith. Over
    time, as the strangler application implements more and more functionality, it
    shrinks and ultimately kills the monolith. An important benefit of developing
    a strangler application is that, unlike a big bang rewrite, it delivers value
    to the business early and often.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一些策略你可以使用，以避免从头开始重写你的应用程序，从而逃离单体地狱。你通过开发所谓的“绞杀应用”来逐步将单体转换为微服务。绞杀应用的灵感来源于热带雨林中的绞杀藤，它们通过包围和有时杀死树木来生长。一个*绞杀应用*是由微服务组成的新应用，你通过将新功能作为服务实现并从单体中提取服务来开发它。随着时间的推移，随着绞杀应用实现越来越多的功能，它逐渐缩小并最终杀死单体。开发绞杀应用的一个重要好处是，与一次性的大改写不同，它能够早期且频繁地向业务交付价值。
- en: I begin this chapter by describing the motivations for refactoring a monolith
    to a microservice architecture. I then describe how to develop the strangler application
    by implementing new functionality as services and extracting services from the
    monolith. Next, I cover various design topics, including how to integrate the
    monolith and services, how to maintain database consistency across the monolith
    and services, and how to handle security. I end the chapter by describing a couple
    of example services. One service is `Delayed Order Service`, which implements
    brand new functionality. The other service is `Delivery Service`, which is extracted
    from the monolith. Let’s start by taking a look at the concept of refactoring
    to a microservice architecture.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我以描述将单体重构为微服务架构的动机开始本章。然后，我描述了如何通过将新功能作为服务实现并从单体中提取服务来开发绞杀应用。接下来，我涵盖了各种设计主题，包括如何集成单体和服务，如何在单体和服务之间维护数据库一致性，以及如何处理安全问题。我通过描述几个示例服务来结束本章。一个服务是`Delayed
    Order Service`，它实现了全新的功能。另一个服务是`Delivery Service`，它是从单体中提取出来的。让我们先从查看重构到微服务架构的概念开始。
- en: 13.1\. Overview of refactoring to microservices
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1\. 微服务重构概述
- en: Put yourself in Mary’s shoes. You’re responsible for the FTGO application, a
    large and old monolithic application. The business is extremely frustrated with
    engineering’s inability to deliver features rapidly and reliably. FTGO appears
    to be suffering from a classic case of monolithic hell. Microservices seem, at
    least on the surface, to be the answer. Should you propose diverting development
    resources away from feature development to migrating to a microservice architecture?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 换位思考，假设你是玛丽。你负责FTGO应用程序，这是一个庞大且老旧的单体应用程序。企业对工程团队无法快速和可靠地交付功能感到极度沮丧。FTGO似乎正遭受单体地狱的典型案例。至少表面上，微服务似乎是一个解决方案。你应该提出将开发资源从功能开发转移到迁移到微服务架构的建议吗？
- en: I start this section by discussing why you should consider refactoring to microservices.
    I also discuss why it’s important to be sure that your software development problems
    are because you’re in monolithic hell rather than in, for example, a poor software
    development process. I then describe strategies for incrementally refactoring
    your monolith to a microservice architecture. Next, I discuss the importance of
    delivering improvements earlier and often in order to maintain the support of
    the business. I then describe why you should avoid investing in a sophisticated
    deployment infrastructure until you’ve developed a few services. Finally, I describe
    the various strategies you can use to introduce services into your architecture,
    including implementing new features as services and extracting services from the
    monolith.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我从这个部分开始讨论为什么你应该考虑将单体架构重构为微服务。我还讨论了为什么确定你的软件开发问题是因为你处于单体地狱，而不是例如一个糟糕的软件开发流程中，这一点很重要。然后，我描述了将单体架构逐步重构为微服务架构的策略。接下来，我讨论了为了保持企业的支持，为什么需要尽早和经常交付改进的重要性。然后，我描述了为什么在开发了一些服务之前，你应该避免投资复杂的部署基础设施。最后，我描述了你可以用来将服务引入架构的各种策略，包括将新功能作为服务实现，以及从单体中提取服务。
- en: 13.1.1\. Why refactor a monolith?
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.1. 为什么重构单体架构？
- en: The microservice architecture has, as described in [chapter 1](kindle_split_009.xhtml#ch01),
    numerous benefits. It has much better maintainability, testability, and deployability,
    so it accelerates development. The microservice architecture is more scalable
    and improves fault isolation. It’s also much easier to evolve your technology
    stack. But refactoring a monolith to microservices is a significant undertaking.
    It will divert resources away from new feature development. As a result, it’s
    likely that the business will only support the adoption of microservices if it
    solves a significant business problem.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](kindle_split_009.xhtml#ch01)所述，微服务架构具有众多优势。它具有更好的可维护性、可测试性和可部署性，因此可以加速开发。微服务架构更具有可扩展性并提高了故障隔离性。同时，它也更容易演进你的技术栈。但是，将单体架构重构为微服务是一项重大任务。这将分散资源，导致新功能开发受阻。因此，企业可能只有在微服务能够解决重大业务问题时，才会支持其采用。
- en: 'If you’re in monolithic hell, it’s likely that you already have at least one
    business problem. Here are some examples of business problems caused by monolithic
    hell:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处于单体地狱，你很可能已经至少有一个业务问题。以下是一些由单体地狱引起的业务问题的例子：
- en: '***Slow delivery*—** The application is difficult to understand, maintain,
    and test, so developer productivity is low. As a result, the organization is unable
    to compete effectively and risks being overtaken by competitors.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***缓慢的交付速度***—** 应用程序难以理解、维护和测试，因此开发者的生产力低下。结果，组织无法有效竞争，并面临被竞争对手超越的风险。'
- en: '***Buggy software releases*—** The lack of testability means that software
    releases are often buggy. This makes customers unhappy, which results in losing
    customers and reduced revenue.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***有缺陷的软件发布***—** 缺乏可测试性意味着软件发布往往存在缺陷。这使客户不满意，导致客户流失和收入减少。'
- en: '***Poor scalability*—** Scaling a monolithic application is difficult because
    it combines modules with very different resource requirements into one executable
    component. The lack of scalability means that it’s either impossible or prohibitively
    expensive to scale the application beyond a certain point. As a result, the application
    can’t support the current or predicted needs of the business.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***较差的可扩展性***—** 扩展单体应用程序很困难，因为它将具有非常不同资源需求的功能模块组合成一个可执行组件。缺乏可扩展性意味着在某个点之后，要么无法扩展应用程序，要么成本过高。因此，应用程序无法满足当前或预测的业务需求。'
- en: It’s important to be sure that these problems are there because you’ve outgrown
    your architecture. A common reason for slow delivery and buggy releases is a poor
    software development process. For example, if you’re still relying on manual testing,
    then adopting automated testing alone can significantly increase development velocity.
    Similarly, you can sometimes solve scalability problems without changing your
    architecture. You should first try simpler solutions. If, and only if, you still
    have software delivery problems should you then migrate to the microservice architecture.
    Let’s look at how to do that.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 确保这些问题是因为你已经超过了你的架构是很重要的。缓慢交付和有缺陷的发布的一个常见原因是软件开发流程不佳。例如，如果你仍然依赖于手动测试，那么仅采用自动化测试就可以显著提高开发速度。同样，有时你可以在不改变架构的情况下解决可伸缩性问题。你应该首先尝试更简单的解决方案。只有在你仍然有软件交付问题时，你才应该迁移到微服务架构。让我们看看如何做到这一点。
- en: 13.1.2\. Strangling the monolith
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.2. 绞杀单体
- en: The process of transforming a monolithic application into microservices is a
    form of application modernization ([https://en.wikipedia.org/wiki/Software_modernization](https://en.wikipedia.org/wiki/Software_modernization)).
    *Application modernization* is the process of converting a legacy application
    to one having a modern architecture and technology stack. Developers have been
    modernizing applications for decades. As a result, there is wisdom accumulated
    through experience we can use when refactoring an application into a microservice
    architecture. The most important lesson learned over the years is to not do a
    big bang rewrite.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将单体应用转换为微服务的过程是一种应用现代化形式([https://en.wikipedia.org/wiki/Software_modernization](https://en.wikipedia.org/wiki/Software_modernization))。*应用现代化*是将遗留应用转换为具有现代架构和技术堆栈的过程。开发者们已经进行了数十年的应用现代化。因此，我们在将应用重构为微服务架构时，可以借鉴通过经验积累的智慧。多年来学到的最重要的教训就是不要进行一次性大规模重构。
- en: A *big bang rewrite* is when you develop a new application—in this case, a microservices-based
    application—from scratch. Although starting from scratch and leaving the legacy
    code base behind sounds appealing, it’s extremely risky and will likely end in
    failure. You will spend months, possibly years, duplicating the existing functionality,
    and only then can you implement the features that the business needs today! Also,
    you’ll need to develop the legacy application anyway, which diverts effort away
    from the rewrite and means that you have a constantly moving target. What’s more,
    it’s possible that you’ll waste time reimplementing features that are no longer
    needed. As Martin Fowler reportedly said, “the only thing a Big Bang rewrite guarantees
    is a Big Bang!” ([www.randyshoup.com/evolutionary-architecture](http://www.randyshoup.com/evolutionary-architecture)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: “一次性大规模重构”是指从头开始开发一个新应用——在这种情况下，是一个基于微服务的新应用。虽然从头开始并放弃遗留代码库听起来很有吸引力，但这非常冒险，很可能会以失败告终。你可能会花费数月甚至数年去复制现有的功能，然后才能实现业务今天需要的功能！此外，你仍然需要开发遗留应用，这会分散重构的努力，意味着你有一个不断移动的目标。更重要的是，你可能会浪费时间重新实现不再需要的功能。正如马丁·福勒据说所说，“一次性大规模重构唯一保证的就是一次性的爆炸！”([www.randyshoup.com/evolutionary-architecture](http://www.randyshoup.com/evolutionary-architecture))。
- en: Instead of doing a big bang rewrite, you should, as [figure 13.1](#ch13fig01)
    shows, incrementally refactor your monolithic application. You gradually build
    a new application, which is called a strangler application. It consists of microservices
    that runs in conjunction with your monolithic application. Over time, the amount
    of functionality implemented by the monolithic application shrinks until either
    it disappears entirely or it becomes just another microservice. This strategy
    is akin to servicing your car while driving down the highway at 70 mph. It’s challenging,
    but is far less risky that attempting a big bang rewrite.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是进行一次性的大规模重构，你应该像[图13.1](#ch13fig01)所示的那样，逐步重构你的单体应用。你逐渐构建一个新的应用，这被称为“绞杀应用”。它由与你的单体应用一起运行的微服务组成。随着时间的推移，单体应用实现的功能量会逐渐减少，直到它完全消失或者变成另一个微服务。这种策略类似于在高速公路上以70英里每小时的速度开车时给你的车做保养。这很具挑战性，但比起尝试一次性的大规模重构风险要小得多。
- en: Figure 13.1\. The monolith is incrementally replaced by a strangler application
    comprised of services. Eventually, the monolith is replaced entirely by the strangler
    application or becomes another microservice.
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.1. 单体应用逐步被由服务组成的绞杀应用所取代。最终，单体应用完全被绞杀应用取代或变成另一个微服务。
- en: '![](Images/13fig01_alt.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig01_alt.jpg)'
- en: Martin Fowler refers to this application modernization strategy as the Strangler
    application pattern ([www.martinfowler.com/bliki/StranglerApplication.html](http://www.martinfowler.com/bliki/StranglerApplication.html)).
    The name comes from the strangler vine (or strangler fig—see [https://en.wikipedia.org/wiki/Strangler_fig](https://en.wikipedia.org/wiki/Strangler_fig))
    that is found in rain forests. A strangler vine grows around a tree in order to
    reach the sunlight above the forest canopy. Often the tree dies, because either
    it’s killed by the vine or it dies of old age, leaving a tree-shaped vine.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Martin Fowler将这种应用现代化策略称为Strangler应用模式([www.martinfowler.com/bliki/StranglerApplication.html](http://www.martinfowler.com/bliki/StranglerApplication.html))。这个名字来源于热带雨林中发现的绞杀藤（或绞杀榕——见[https://en.wikipedia.org/wiki/Strangler_fig](https://en.wikipedia.org/wiki/Strangler_fig))。绞杀藤围绕树木生长，以到达森林冠层之上的阳光。通常，树木会死亡，因为要么被藤蔓杀死，要么因年老而死亡，留下一个形状像树的藤蔓。
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Strangler application**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：Strangler应用**'
- en: Modernize an application by incrementally developing a new (strangler) application
    around the legacy application. See [http://microservices.io/patterns/refactoring/strangler-application.html](http://microservices.io/patterns/refactoring/strangler-application.html).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逐步在遗留应用周围开发新的（绞杀）应用来现代化应用。见[http://microservices.io/patterns/refactoring/strangler-application.html](http://microservices.io/patterns/refactoring/strangler-application.html)。
- en: '|  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The refactoring process typically takes months, or years. For example, according
    to Steve Yegge ([https://plus.google.com/+RipRowan/posts/eVeouesvaVX](https://plus.google.com/+RipRowan/posts/eVeouesvaVX))
    it took Amazon.com a couple of years to refactor its monolith. In the case of
    a very large system, you may never complete the process. You could, for example,
    get to a point where you have tasks that are more important than breaking up the
    monolith, such as implementing revenue-generating features. If the monolith isn’t
    an obstacle to ongoing development, you may as well leave it alone.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重构过程通常需要数月或数年。例如，根据Steve Yegge ([https://plus.google.com/+RipRowan/posts/eVeouesvaVX](https://plus.google.com/+RipRowan/posts/eVeouesvaVX))的说法，亚马逊.com花费了几年时间来重构其单体应用。在非常大型系统中，你可能永远无法完成这个过程。例如，你可能达到一个点，此时你有比拆分单体更重要的任务，比如实现盈利功能。如果单体不是持续发展的障碍，那么你不妨让它保持原样。
- en: Demonstrate value early and often
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 早期并频繁地展示价值
- en: An important benefit of incrementally refactoring to a microservice architecture
    is that you get an immediate return on your investment. That’s very different
    than a big bang rewrite, which doesn’t deliver any benefit until it’s complete.
    When incrementally refactoring the monolith, you can develop each new service
    using a new technology stack and a modern, high-velocity, DevOps-style development
    and delivery process. As a result, your team’s delivery velocity steadily increases
    over time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步重构到微服务架构的一个重要好处是，你可以立即获得投资回报。这与一次性重写大不相同，后者直到完成才提供任何好处。当逐步重构单体应用时，你可以使用新的技术栈和现代、高速的DevOps风格开发和交付流程来开发每个新的服务。因此，随着时间的推移，你团队的交付速度稳步提高。
- en: What’s more, you can migrate the high-value areas of your application to microservices
    first. For instance, imagine you’re working on the FTGO application. The business
    might, for example, decide that the delivery scheduling algorithm is a key competitive
    advantage. It’s likely that delivery management will be an area of constant, ongoing
    development. By extracting delivery management into a standalone service, the
    delivery management team will be able to work independently of the rest of the
    FTGO developers and significantly increase their development velocity. They’ll
    be able to frequently deploy new versions of the algorithm and evaluate their
    effectiveness.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以首先将应用中的高价值区域迁移到微服务中。例如，假设你正在开发FTGO应用。例如，业务可能会决定配送调度算法是一个关键竞争优势。配送管理可能是一个持续、不断发展的领域。通过将配送管理提取为一个独立的服务，配送管理团队将能够独立于FTGO的其他开发者工作，并显著提高他们的开发速度。他们能够频繁部署算法的新版本并评估其有效性。
- en: Another benefit of being able to deliver value earlier is that it helps maintain
    the business’s support for the migration effort. Their ongoing support is essential,
    because the refactoring effort will mean that less time is spent on developing
    features. Some organizations have difficulty eliminating technical debt because
    past attempts were too ambitious and didn’t provide much benefit. As a result,
    the business becomes reluctant to invest in further cleanup efforts. The incremental
    nature of refactoring to microservices means that the development team is able
    to demonstrate value early and often.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 能够更早地交付价值的好处之一是，它有助于维持业务对迁移工作的支持。他们的持续支持是至关重要的，因为重构工作将意味着在开发功能上花费的时间减少。一些组织难以消除技术债务，因为过去的尝试过于雄心勃勃且没有带来太多好处。结果，业务变得不愿意投资进一步的清理工作。将单体重构为微服务的增量性质意味着开发团队能够早期且频繁地展示价值。
- en: Minimize changes to the monolith
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最小化对单体的更改
- en: A recurring theme in this chapter is that you should avoid making widespread
    changes to the monolith when migrating to a microservice architecture. It’s inevitable
    that you’ll need to make some changes in order to support migration to services.
    [Section 13.3.2](#ch13lev2sec7) talks about how the monolith often needs to be
    modified so that it can participate in sagas that maintain data consistency across
    the monolith and services. The problem with making widespread changes to the monolith
    is that it’s time consuming, costly, and risky. After all, that’s probably why
    you want to migrate to microservices in the first place.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一个反复出现的主题是，在迁移到微服务架构时，你应该避免对单体应用进行大规模的更改。在支持迁移到服务的过程中，你不可避免地需要做出一些更改。[第13.3.2节](#ch13lev2sec7)讨论了单体通常需要修改以便能够参与维护单体和服务之间数据一致性的叙事。对单体进行大规模更改的问题在于它耗时、成本高昂且风险较大。毕竟，这可能是你最初想要迁移到微服务的原因。
- en: Fortunately, there are strategies you can use for reducing the scope of the
    changes you need to make. For example, in [section 13.2.3](#ch13lev2sec5), I describe
    the strategy of replicating data from an extracted service back to the monolith’s
    database. And in [section 13.3.2](#ch13lev2sec7), I show how you can carefully
    sequence the extraction of services to reduce the impact on the monolith. By applying
    these strategies, you can reduce the amount of work required to refactor the monolith.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用一些策略来减少你需要做出的更改范围。例如，在[第13.2.3节](#ch13lev2sec5)中，我描述了从提取的服务将数据复制回单体数据库的策略。在[第13.3.2节](#ch13lev2sec7)中，我展示了如何谨慎地安排服务的提取以减少对单体的影响。通过应用这些策略，你可以减少重构单体所需的工作量。
- en: 'Technical deployment infrastructure: You don’t need all of it yet'
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 技术部署基础设施：你目前不需要全部
- en: Throughout this book I’ve discussed a lot of shiny new technology, including
    deployment platforms such as Kubernetes and AWS Lambda and service discovery mechanisms.
    You might be tempted to begin your migrating to microservices by selecting technologies
    and building out that infrastructure. You might even feel pressure from the business
    people and from your friendly PaaS vendor to start spending money on this kind
    of infrastructure.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我讨论了许多闪亮的新技术，包括Kubernetes和AWS Lambda这样的部署平台以及服务发现机制。你可能会被诱惑通过选择技术并构建基础设施来开始你的微服务迁移。你甚至可能感受到来自商业人士和友好的PaaS供应商的压力，开始在这类基础设施上花钱。
- en: As tempting as it seems to build out this infrastructure up front, I recommend
    only making a minimal up-front investment in developing it. The only thing you
    can’t live without is a deployment pipeline that performs automating testing.
    For example, if you only have a handful of services, you don’t need a sophisticated
    deployment and observability infrastructure. Initially, you can even get away
    with just using a hard-coded configuration file for service discovery. I suggest
    deferring any decisions about technical infrastructure that involve significant
    investment until you’ve gained real experience with the microservice architecture.
    It’s only once you have a few services running that you’ll have the experience
    to pick technologies.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始就构建这个基础设施看起来很有吸引力，但我建议只进行最小的前期投资来开发它。你无法离开的唯一东西是执行自动化测试的部署管道。例如，如果你只有少数几个服务，你不需要复杂的部署和可观察性基础设施。最初，你甚至可以用硬编码的配置文件来进行服务发现。我建议在获得微服务架构的真实经验之前，推迟任何涉及重大投资的技术基础设施决策。只有当你有几个服务运行时，你才会拥有选择技术的经验。
- en: Let’s now look at the strategies you can use for migrating to a microservice
    architecture.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看你可以用来迁移到微服务架构的策略。
- en: 13.2\. Strategies for refactoring a monolith to microservices
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2. 单体重构为微服务的策略
- en: 'There are three main strategies for strangling the monolith and incrementally
    replacing it with microservices:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种主要的策略可以扼杀单体并逐步用微服务替换它：
- en: Implement new features as services.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新功能作为服务实现。
- en: Separate the presentation tier and backend.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将表示层和后端分离。
- en: Break up the monolith by extracting functionality into services.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将功能提取到服务中拆分单体。
- en: The first strategy stops the monolith from growing. It’s typically a quick way
    to demonstrate the value of microservices, helping build support for the migration
    effort. The other two strategies break apart the monolith. When refactoring your
    monolith, you might sometimes use the second strategy, but you’ll definitely use
    the third strategy, because it’s how functionality is migrated from the monolith
    into the strangler application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种策略阻止单体增长。这通常是展示微服务价值的一种快速方式，有助于建立迁移工作的支持。其他两种策略将单体拆分。在重构单体时，你可能会使用第二种策略，但你肯定会使用第三种策略，因为这是将功能从单体迁移到缠扰应用的方式。
- en: Let’s take a look at each of these strategies, starting with implementing new
    features as services.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一审视这些策略，从将新功能作为服务实现开始。
- en: 13.2.1\. Implement new features as services
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.1. 将新功能作为服务实现
- en: The Law of Holes states that “if you find yourself in a hole, stop digging”
    ([https://en.m.wikipedia.org/wiki/Law_of_holes](https://en.m.wikipedia.org/wiki/Law_of_holes)).
    This is great advice to follow when your monolithic application has become unmanageable.
    In other words, if you have a large, complex monolithic application, don’t implement
    new features by adding code to the monolith. That will make your monolith even
    larger and more unmanageable. Instead, you should implement new features as services.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 洞穴法则指出：“如果你发现自己陷入了一个洞，就停止挖掘”([https://en.m.wikipedia.org/wiki/Law_of_holes](https://en.m.wikipedia.org/wiki/Law_of_holes))。当你的单体应用变得难以管理时，这是一条很好的建议。换句话说，如果你有一个庞大而复杂的单体应用，不要通过向单体添加代码来实现新功能。这将使单体变得更大，更难以管理。相反，你应该将新功能作为服务来实现。
- en: This is a great way to begin migrating your monolithic application to a microservice
    architecture. It reduces the growth rate of the monolith. It accelerates the development
    of the new features, because you’re doing development in a brand new code base.
    It also quickly demonstrates the value of adopting the microservice architecture.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种将单体应用程序迁移到微服务架构的绝佳方式。它减缓了单体的增长速度。由于你在全新的代码库中进行开发，因此它加速了新功能的发展。它还迅速展示了采用微服务架构的价值。
- en: Integrating the new service with the monolith
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将新服务与单体集成
- en: '[Figure 13.2](#ch13fig02) shows the application’s architecture after implementing
    a new feature as a service. Besides the new service and monolith, the architecture
    includes two other elements that integrate the service into the application:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13.2](#ch13fig02)展示了实现新功能作为服务后的应用程序架构。除了新服务和单体之外，该架构还包括两个其他元素，它们将服务集成到应用程序中：'
- en: '***API gateway*—** Routes requests for new functionality to the new service
    and routes legacy requests to the monolith.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***API网关*——**将新功能请求路由到新服务，并将旧请求路由到单体。'
- en: '***Integration glue code*—** Integrates the service with the monolith. It enables
    the service to access data owned by the monolith and to invoke functionality implemented
    by the monolith.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***集成胶水代码**—** 将服务与单体应用集成。它使服务能够访问单体应用拥有的数据，并调用单体应用实现的功能。'
- en: Figure 13.2\. A new feature is implemented as a service that’s part of the strangler
    application. The integration glue integrates the service with the monolith and
    consists of adapters that implement synchronous and asynchronous APIs. An API
    gateway routes requests that invoke new functionality to the service.
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.2\. 新功能作为 strangler 应用程序的一部分以服务的形式实现。集成胶水将服务与单体应用集成，包括实现同步和异步 API 的适配器。API
    网关将调用新功能的请求路由到服务。
- en: '![](Images/13fig02_alt.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 的替代文本](Images/13fig02_alt.jpg)'
- en: The integration glue code isn’t a standalone component. Instead, it consists
    of adapters in the monolith and the service that use one or more interprocess
    communication mechanisms. For example, integration glue for `Delayed Delivery
    Service`, described in [section 13.4.1](#ch13lev2sec9), uses both REST and domain
    events. The service retrieves customer contract information from the monolith
    by invoking a REST API. The monolith publishes `Order` domain events so that `Delayed
    Delivery Service` can track the state of `Orders` and respond to orders that won’t
    be delivered on time. [Section 13.3.1](#ch13lev2sec6) describes the integration
    glue code in more detail.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 集成胶水代码不是一个独立的组件。相反，它由单体应用和服务中的适配器组成，这些适配器使用一个或多个进程间通信机制。例如，[第 13.4.1 节](#ch13lev2sec9)中描述的
    `Delayed Delivery Service` 的集成胶水使用 REST 和领域事件。服务通过调用 REST API 从单体应用检索客户合同信息。单体应用发布
    `Order` 领域事件，以便 `Delayed Delivery Service` 能够跟踪 `Orders` 的状态并对无法按时交付的订单做出响应。[第
    13.3.1 节](#ch13lev2sec6)更详细地描述了集成胶水代码。
- en: When to implement a new feature as a service
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 何时将新功能实现为服务
- en: Ideally, you should implement every new feature in the strangler application
    rather than in the monolith. You’ll implement a new feature as either a new service
    or as part of an existing service. This way you’ll avoid ever having to touch
    the monolith code base. Unfortunately, though, not every new feature can be implemented
    as a service.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该在 strangler 应用程序中而不是在单体应用中实现每个新功能。你可以将新功能实现为一个新服务或作为现有服务的一部分。这样，你将永远不需要接触单体代码库。然而，不幸的是，并非每个新功能都可以作为服务实现。
- en: That’s because the essence of a microservice architecture is a set of loosely
    coupled services that are organized around business capabilities. A feature might,
    for instance, be too small to be a meaningful service. You might, for example,
    just need to add a few fields and methods to an existing class. Or the new feature
    might be too tightly coupled to the code in the monolith. If you attempted to
    implement this kind of feature as a service you would typically find that performance
    would suffer because of excessive interprocess communication. You might also have
    problems maintaining data consistency. If a new feature can’t be implemented as
    a service, the solution is often to initially implement the new feature in the
    monolith. Later on, you can then extract that feature along with other related
    features into their own service.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为微服务架构的本质是一组围绕业务能力组织的松散耦合服务。例如，一个功能可能太小，不足以成为一个有意义的服务。你可能只需要向现有类添加几个字段和方法。或者，新功能可能与单体应用中的代码过于紧密耦合。如果你尝试将此类功能作为服务实现，你通常会发现由于过多的进程间通信而导致性能下降。你也可能遇到维护数据一致性的问题。如果一个新功能不能作为服务实现，通常的解决方案是首先在单体应用中实现该新功能。然后，你可以将这个功能以及其他相关功能提取出来，形成它们自己的服务。
- en: Implementing new features as services accelerates the development of those features.
    It’s a good way to quickly demonstrate the value of the microservice architecture.
    It also reduces the monolith’s growth rate. But ultimately, you need to break
    apart the monolith using the two other strategies. You need to migrate functionality
    to the strangler application by extracting functionality from the monolith into
    services. You might also be able to improve development velocity by splitting
    the monolith horizontally. Let’s look at how to do that.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将新功能作为服务实现可以加速这些功能的开发。这是快速展示微服务架构价值的好方法。它还可以降低单体应用的增长速度。但最终，你需要使用另外两种策略来分解单体应用。你需要通过从单体应用中提取功能到服务中来迁移功能到
    strangler 应用程序。你还可以通过水平拆分单体应用来提高开发速度。让我们看看如何做到这一点。
- en: 13.2.2\. Separate presentation tier from the backend
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.2\. 将表示层从后端分离
- en: 'One strategy for shrinking a monolithic application is to split the presentation
    layer from the business logic and data access layers. A typical enterprise application
    consists of the following layers:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小单体应用程序的一种策略是将表示层从业务逻辑和数据访问层中分离出来。一个典型的企业应用程序由以下层组成：
- en: '***Presentation logic*—** This consists of modules that handle HTTP requests
    and generate HTML pages that implement a web UI. In an application that has a
    sophisticated user interface, the presentation tier is often a substantial body
    of code.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***表示逻辑***—** 这包括处理HTTP请求并生成实现Web UI的HTML页面的模块。在一个具有复杂用户界面的应用程序中，表示层通常是大量的代码。'
- en: '***Business logic*—** This consists of modules that implement the business
    rules, which can be complex in an enterprise application.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***业务逻辑***—** 这包括实现业务规则的模块，在企业应用程序中可能很复杂。'
- en: '***Data access logic*—** This consists of modules that access infrastructure
    services such as databases and message brokers.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***数据访问逻辑***—** 这包括访问基础设施服务，如数据库和消息代理。'
- en: There is usually a clean separation between the presentation logic and the business
    and data access logic. The business tier has a coarse-grained API consisting of
    one or more facades that encapsulate the business logic. This API is a natural
    seam along which you can split the monolith into two smaller applications, as
    shown in [figure 13.3](#ch13fig03). One application contains the presentation
    layer, and the other contains the business and data access logic. After the split,
    the presentation logic application makes remote calls to the business logic application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，表示逻辑与业务和数据访问逻辑之间有一个清晰的分离。业务层有一个粗粒度的API，由一个或多个封装业务逻辑的门面组成。这个API是你可以沿着它将单体拆分为两个较小应用程序的自然缝隙，如图13.3所示。一个应用程序包含表示层，另一个包含业务和数据访问逻辑。拆分后，表示逻辑应用程序会对业务逻辑应用程序进行远程调用。
- en: Figure 13.3\. Splitting the frontend from the backend enables each to be deployed
    independently. It also exposes an API for services to invoke.
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.3\. 将前端从后端分离，使得每个都可以独立部署。它还公开了一个服务可以调用的API。
- en: '![](Images/13fig03_alt.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig03_alt.jpg)'
- en: Splitting the monolith in this way has two main benefits. It enables you to
    develop, deploy, and scale the two applications independently of one another.
    In particular, it allows the presentation layer developers to rapidly iterate
    on the user interface and easily perform A/B testing, for example, without having
    to deploy the backend. Another benefit of this approach is that it exposes a remote
    API that can be called by the microservices you develop later.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式拆分单体有两个主要好处。它使你可以独立于彼此开发、部署和扩展两个应用程序。特别是，它允许表示层开发人员快速迭代用户界面，并轻松执行A/B测试，例如，而无需部署后端。这种方法的另一个好处是公开了一个远程API，可以由你后来开发的微服务调用。
- en: But this strategy is only a partial solution. It’s very likely that at least
    one or both of the resulting applications will still be an unmanageable monolith.
    You need to use the third strategy to replace the monolith with services.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种策略只是部分解决方案。很可能至少有一个或两个结果应用程序仍然是一个难以管理的单体。你需要使用第三种策略用服务替换单体。
- en: 13.2.3\. Extract business capabilities into services
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.3\. 将业务能力提取到服务中
- en: Implementing new features as services and splitting the frontend web application
    from the backend will only get you so far. You’ll still end up doing a lot of
    development in the monolithic code base. If you want to significantly improve
    your application’s architecture and increase your development velocity, you need
    to break apart the monolith by incrementally migrating business capabilities from
    the monolith to services. For example, [section 13.5](#ch13lev1sec5) describes
    how to extract delivery management from the FTGO monolith into a new `Delivery
    Service`. When you use this strategy, over time the number of business capabilities
    implemented by the services grows, and the monolith gradually shrinks.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将新功能作为服务实现并将前端Web应用程序与后端分离，这只能让你走这么远。你仍然会在单体代码库中进行大量的开发。如果你想显著改进应用程序的架构并提高开发速度，你需要通过逐步将业务能力从单体迁移到服务中来拆分单体。例如，[第13.5节](#ch13lev1sec5)描述了如何将交付管理从FTGO单体中提取到新的`Delivery
    Service`中。当你使用这种策略时，随着时间的推移，由服务实现的企业能力数量会增加，而单体逐渐缩小。
- en: 'The functionality you want extract into a service is a vertical slice through
    the monolith. The slice consists of the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要提取到服务中的功能是单体应用的一个垂直切片。该切片包括以下内容：
- en: Inbound adapters that implement API endpoints
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现API端点的入站适配器
- en: Domain logic
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域逻辑
- en: Outbound adapters such as database access logic
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出站适配器，如数据库访问逻辑
- en: The monolith’s database schema
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体应用的数据库模式
- en: As [figure 13.4](#ch13fig04) shows, this code is extracted from the monolith
    and moved into a standalone service. An API gateway routes requests that invoke
    the extracted business capability to the service and routes the other requests
    to the monolith. The monolith and the service collaborate via the integration
    glue code. As described in [section 13.3.1](#ch13lev2sec6), the integration glue
    consists of adapters in the service and monolith that use one or more interprocess
    communication (IPC) mechanisms.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图13.4](#ch13fig04)所示，此代码是从单体应用中提取出来并移动到独立服务中的。API网关将调用提取出的业务能力的请求路由到服务，并将其他请求路由到单体应用。单体应用和服务通过集成粘合代码进行协作。如[第13.3.1节](#ch13lev2sec6)所述，集成粘合代码由服务中的适配器和单体应用中使用一个或多个进程间通信（IPC）机制组成的适配器组成。
- en: Figure 13.4\. Break apart the monolith by extracting services. You identify
    a slice of functionality, which consists of business logic and adapters, to extract
    into a service. You move that code into the service. The newly extracted service
    and the monolith collaborate via the APIs provided by the integration glue.
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.4。通过提取服务来分解单体应用。你确定一个功能切片，它由业务逻辑和适配器组成，并将其提取到服务中。你将那段代码移动到服务中。新提取的服务和单体应用通过集成粘合代码提供的API进行协作。
- en: '![](Images/13fig04_alt.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4](Images/13fig04_alt.jpg)'
- en: Extracting services is challenging. You need to determine how to split the monolith’s
    domain model into two separate domain models, one of which becomes the service’s
    domain model. You need to break dependencies such as object references. You might
    even need to split classes in order to move functionality into the service. You
    also need to refactor the database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 提取服务具有挑战性。你需要确定如何将单体应用的领域模型分割成两个独立的领域模型，其中一个将成为服务的领域模型。你需要打破诸如对象引用之类的依赖关系。你可能甚至需要分割类以将功能移动到服务中。你还需要重构数据库。
- en: Extracting a service is often time consuming, especially because the monolith’s
    code base is likely to be messy. Consequently, you need to carefully think about
    which services to extract. It’s important to focus on refactoring those parts
    of the application that provide a lot of value. Before extracting a service, ask
    yourself what the benefit is of doing that.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 提取服务通常耗时较长，尤其是因为单体应用的代码库可能很混乱。因此，你需要仔细思考要提取哪些服务。重要的是要关注那些提供大量价值的应用程序的部分的重构。在提取服务之前，问问自己这样做的好处是什么。
- en: For example, it’s worthwhile to extract a service that implements functionality
    that’s critical to the business and constantly evolving. It’s not valuable to
    invest effort in extracting services when there’s not much benefit from doing
    so. Later in this section I describe some strategies for determining what to extract
    and when. But first, let’s look in more detail at some of the challenges you’ll
    face when extracting a service and how to address them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，提取一个实现对业务至关重要且不断发展的功能的服务的做法是值得的。当这样做没有多少好处时，投入精力提取服务是没有价值的。在本节的后面部分，我将描述一些确定提取什么以及何时提取的策略。但首先，让我们更详细地看看在提取服务时你将面临的一些挑战以及如何解决它们。
- en: 'You’ll encounter a couple of challenges when extracting a service:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在提取服务时，你将遇到一些挑战：
- en: Splitting the domain model
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分割领域模型
- en: Refactoring the database
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构数据库
- en: Let’s look at each one, starting with splitting the domain model.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一来看，首先是分割领域模型。
- en: Splitting the domain model
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分割领域模型
- en: In order to extract a service, you need to extract its domain model out of the
    monolith’s domain model. You’ll need to perform major surgery to split the domain
    models. One challenge you’ll encounter is eliminating object references that would
    otherwise span service boundaries. It’s possible that classes that remain in the
    monolith will reference classes that have been moved to the service or vice versa.
    For example, imagine that, as [figure 13.5](#ch13fig05) shows, you extract `Order
    Service`, and as a result its `Order` class references the monolith’s `Restaurant`
    class. Because a service instance is typically a process, it doesn’t make sense
    to have object references that cross service boundaries. Somehow you need to eliminate
    these types of object reference.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取一个服务，你需要将其领域模型从单体领域模型中提取出来。你需要进行重大手术来分割领域模型。你将遇到的挑战之一是消除那些本应跨越服务边界的对象引用。可能留在单体中的类会引用已移动到服务中的类，反之亦然。例如，想象一下，正如[图
    13.5](#ch13fig05)所示，你提取了`Order Service`，因此其`Order`类引用了单体的`Restaurant`类。由于服务实例通常是进程，跨越服务边界的对象引用是没有意义的。你需要以某种方式消除这些类型的对象引用。
- en: Figure 13.5\. The `Order` domain class has a reference to a `Restaurant` class.
    If we extract `Order` into a separate service, we need to do something about its
    reference to `Restaurant`, because object references between processes don’t make
    sense.
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.5\. `Order`域类引用了一个`Restaurant`类。如果我们把`Order`提取到一个单独的服务中，我们需要对其对`Restaurant`的引用进行处理，因为进程之间的对象引用是没有意义的。
- en: '![](Images/13fig05_alt.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片 13.5](Images/13fig05_alt.jpg)'
- en: One good way to solve this problem is to think in terms of DDD aggregates, described
    in [chapter 5](kindle_split_013.xhtml#ch05). *Aggregates* reference each other
    using primary keys rather than object references. You would, therefore, think
    of the `Order` and `Restaurant` classes as aggregates and, as [figure 13.6](#ch13fig06)
    shows, replace the reference to `Restaurant` in the `Order` class with a `restaurantId`
    field that stores the primary key value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的好方法之一是考虑 DDD 聚合，这在[第 5 章](kindle_split_013.xhtml#ch05)中有描述。*聚合*通过主键而不是对象引用相互引用。因此，你会把`Order`和`Restaurant`类视为聚合，正如[图
    13.6](#ch13fig06)所示，将`Order`类中对`Restaurant`的引用替换为存储主键值的`restaurantId`字段。
- en: Figure 13.6\. The `Order` class’s reference to `Restaurant` is replaced with
    the `Restaurant`’s primary key in order to eliminate an object that would span
    process boundaries.
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.6\. 为了消除跨越进程边界的对象，`Order`类对`Restaurant`的引用被替换为`Restaurant`的主键。
- en: '![](Images/13fig06_alt.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片 13.6](Images/13fig06_alt.jpg)'
- en: One issue with replacing object references with primary keys is that although
    this is a minor change to the class, it can potentially have a large impact on
    the clients of the class, which expect an object reference. Later in this section,
    I describe how to reduce the scope of the change by replicating data between the
    service and monolith. `Delivery Service`, for example, could define a `Restaurant`
    class that’s a replica of the monolith’s `Restaurant` class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象引用替换为主键的问题在于，尽管这仅仅是类的一个小改动，但它可能会对期望对象引用的类的客户端产生重大影响。在本节稍后，我将描述如何通过在服务和单体之间复制数据来缩小更改的范围。例如，`Delivery
    Service`可以定义一个与单体`Restaurant`类相同的`Restaurant`类。
- en: Extracting a service is often much more involved than moving entire classes
    into a service. An even greater challenge with splitting a domain model is extracting
    functionality that’s embedded in a class that has other responsibilities. This
    problem often occurs in god classes, described in [chapter 2](kindle_split_010.xhtml#ch02),
    that have an excessive number of responsibilities. For example, the `Order` class
    is one of the god classes in the FTGO application. It implements multiple business
    capabilities, including order management, delivery management, and so on. Later
    in [section 13.5](#ch13lev1sec5), I discuss how extracting the delivery management
    into a service involves extracting a `Delivery` class from the `Order` class.
    The `Delivery` entity implements the delivery management functionality that was
    previously bundled with other functionality in the `Order` class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 提取服务通常比将整个类移动到服务中涉及更多。在拆分领域模型时，一个更大的挑战是从具有其他职责的类中提取嵌入的功能。这个问题通常出现在[第2章](kindle_split_010.xhtml#ch02)中描述的“全能类”中，这些类承担了过多的职责。例如，`Order`类是FTGO应用程序中的全能类之一。它实现了多个业务能力，包括订单管理、配送管理等。在[第13.5节](#ch13lev1sec5)中，我讨论了如何将配送管理提取到服务中，这涉及到从`Order`类中提取`Delivery`类。`Delivery`实体实现了之前与`Order`类中其他功能捆绑在一起的配送管理功能。
- en: Refactoring the database
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 重构数据库
- en: Splitting a domain model involves more than just changing code. Many classes
    in a domain model are persistent. Their fields are mapped to a database schema.
    Consequently, when you extract a service from the monolith, you’re also moving
    data. You need to move tables from the monolith’s database to the service’s database.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将领域模型拆分不仅涉及代码的改变。领域模型中的许多类都是持久的。它们的字段映射到数据库模式中。因此，当你从一个单体中提取服务时，你也在移动数据。你需要将表从单体数据库移动到服务数据库。
- en: Also, when you split an entity you need to split the corresponding database
    table and move the new table to the service. For example, when extracting delivery
    management into a service, you split the `Order` entity and extract a `Delivery`
    entity. At the database level, you split the `ORDERS` table and define a new `DELIVERY`
    table. You then move the `DELIVERY` table to the service.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当你拆分一个实体时，你需要拆分相应的数据库表并将新表移动到服务中。例如，当将配送管理提取到服务中时，你拆分了`Order`实体并提取了`Delivery`实体。在数据库层面，你拆分了`ORDERS`表并定义了一个新的`DELIVERY`表。然后你将`DELIVERY`表移动到服务中。
- en: The book *Refactoring Databases* by Scott W. Ambler and Pramod J. Sadalage (Addison-Wesley,
    2011) describes a set of refactorings for a database schema. For example, it describes
    the *Split Table* refactoring, which splits a table into two or more tables. Many
    of the technique in that book are useful when extracting services from the monolith.
    One such technique is the idea of replicating data in order to allow you to incrementally
    update clients of the database to use the new schema. We can adapt that idea to
    reduce the scope of the changes you must make to the monolith when extracting
    a service.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Scott W. Ambler和Pramod J. Sadalage合著的《重构数据库》（Addison-Wesley，2011年）描述了一系列针对数据库模式的重构方法。例如，它描述了*Split
    Table*（拆分表）重构，将一个表拆分为两个或更多表。书中许多技术对于从单体中提取服务非常有用。其中一种技术是复制数据，以便你可以逐步更新数据库客户端以使用新架构。我们可以将这个想法适应到减少在提取服务时必须对单体进行的更改范围。
- en: Replicate data to avoid widespread changes
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 复制数据以避免广泛更改
- en: As mentioned, extracting a service requires you to change to the monolith’s
    domain model. For example, you replace object references with primary keys and
    split classes. These types of changes can ripple through the code base and require
    you to make widespread changes to the monolith. For example, if you split the
    `Order` entity and extract a `Delivery` entity, you’ll have to change every place
    in the code that references the fields that have been moved. Making these kinds
    of changes can be extremely time consuming and can become a huge barrier to breaking
    up the monolith.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，提取服务需要你修改单体领域的模型。例如，你用主键替换对象引用并拆分类。这类改变可能会在代码库中产生连锁反应，并要求你对单体进行广泛的修改。例如，如果你拆分了`Order`实体并提取了`Delivery`实体，你将不得不更改代码中所有引用已移动字段的部位。进行这类改变可能非常耗时，并可能成为拆分单体的一大障碍。
- en: A great way to delay and possibly avoid making these kinds of expensive changes
    is to use an approach that’s similar to the one described in *Refactoring Databases*.
    A major obstacle to refactoring a database is changing all the clients of that
    database to use the new schema. The solution proposed in the book is to preserve
    the original schema for a transition period and use triggers to synchronize the
    original and new schemas. You then migrate clients from the old schema to the
    new schema over time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟并可能避免做出这些昂贵改变的一个好方法是用一种类似于在《重构数据库》中描述的方法。重构数据库的一个主要障碍是改变该数据库的所有客户端以使用新的模式。书中提出的解决方案是在过渡期间保留原始模式，并使用触发器来同步原始和新的模式。然后你可以在一段时间内将客户端从旧模式迁移到新模式。
- en: We can use a similar approach when extracting services from the monolith. For
    example, when extracting the `Delivery` entity, we leave the `Order` entity mostly
    unchanged for a transition period. As [figure 13.7](#ch13fig07) shows, we make
    the delivery-related fields read-only and keep them up-to-date by replicating
    data from `Delivery Service` back to the monolith. As a result, we only need to
    find the places in the monolith’s code that update those fields and change them
    to invoke the new `Delivery Service`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当从单体应用中提取服务时，我们可以使用类似的方法。例如，当提取`Delivery`实体时，我们让`Order`实体在过渡期间基本保持不变。如图13.7所示，我们将与交付相关的字段设置为只读，并通过从`Delivery
    Service`复制数据回单体应用来保持它们是最新的。因此，我们只需要找到单体应用代码中更新这些字段的地方，并将它们更改为调用新的`Delivery Service`。
- en: Figure 13.7\. Minimize the scope of the changes to the FTGO monolith by replicating
    delivery-related data from the newly extracted `Delivery Service` back to the
    monolith’s database.
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过从新提取的`Delivery Service`复制相关数据回单体数据库，最小化对FTGO单体应用更改的范围。
- en: '![](Images/13fig07_alt.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图13.7](Images/13fig07_alt.jpg)'
- en: Preserving the structure of the `Order` entity by replicating data from `Delivery
    Service` significantly reduces the amount of work we need to do immediately. Over
    time, we can migrate code that uses the delivery-related `Order` entity fields
    or `ORDERS` table columns to `Delivery Service`. What’s more, it’s possible that
    we never need to make that change in the monolith. If that code is subsequently
    extracted into a service, then the service can access `Delivery Service`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从`Delivery Service`复制数据以保留`Order`实体的结构，显著减少了我们立即需要做的工作量。随着时间的推移，我们可以将使用与交付相关的`Order`实体字段或`ORDERS`表列的代码迁移到`Delivery
    Service`。更重要的是，我们可能永远不需要在单体应用中进行这种更改。如果该代码随后被提取到一个服务中，那么该服务就可以访问`Delivery Service`。
- en: What services to extract and when
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提取哪些服务和何时提取
- en: As I mentioned, breaking apart the monolith is time consuming. It diverts effort
    away from implementing features. As a result, you must carefully decide the sequence
    in which you extract services. You need to focus on extracting services that give
    the largest benefit. What’s more, you want to continually demonstrate to the business
    that there’s value in migrating to a microservice architecture.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，拆分单体应用是耗时的。它会分散实现功能的精力。因此，你必须仔细决定提取服务的顺序。你需要专注于提取能带来最大效益的服务。更重要的是，你想要不断地向业务展示迁移到微服务架构的价值。
- en: On any journey, it’s essential to know where you’re going. A good way to start
    the migration to microservices is with a time-boxed architecture definition effort.
    You should spend a short amount of time, such as a couple of weeks, brainstorming
    your ideal architecture and defining a set of services. This gives you a destination
    to aim for. It’s important, though, to remember that this architecture isn’t set
    in stone. As you break apart the monolith and gain experience, you should revise
    the architecture to take into account what you’ve learned.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何旅程中，了解你要去哪里是至关重要的。开始向微服务迁移的一个好方法是通过一个时间限制的架构定义努力。你应该花上一些时间，比如几周时间，来头脑风暴你的理想架构并定义一组服务。这为你提供了一个目标去追求。然而，重要的是要记住，这个架构并不是一成不变的。随着你将单体应用拆分并积累经验，你应该修订架构以考虑你所学到的内容。
- en: Once you’ve determined the approximate destination, the next step is to start
    breaking apart the monolith. There are a couple of different strategies you can
    use to determine the sequence in which you extract services.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了大致的目标，下一步就是开始拆分单体应用。你可以使用几种不同的策略来确定提取服务的顺序。
- en: One strategy is to effectively freeze development of the monolith and extract
    services on demand. Instead of implementing features or fixing bugs in the monolith,
    you extract the necessary service or service(s) and change those. One benefit
    of this approach is that it forces you to break up the monolith. One drawback
    is that the extraction of services is driven by short-term requirements rather
    than long-term needs. For instance, it requires you to extract services even if
    you’re making a small change to a relatively stable part of the system. As a result,
    you risk doing a lot of work for minimal benefit.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一种策略是有效地冻结单体应用的开发，并根据需求提取服务。而不是在单体应用中实现功能或修复错误，你提取必要的或多个服务并对其进行更改。这种方法的一个优点是它迫使你分解单体应用。一个缺点是服务的提取是由短期需求而不是长期需求驱动的。例如，即使你只是对系统的一个相对稳定的部分进行小的更改，这也要求你提取服务。结果，你可能会做很多工作，但收益却很小。
- en: 'An alternative strategy is a more planned approach, where you rank the modules
    of an application by the benefit you anticipate getting from extracting them.
    There are a few reasons why extracting a service is beneficial:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是一种更计划的途径，其中你根据从提取模块中预期获得的收益对应用程序的模块进行排序。提取服务有几个好处：
- en: '***Accelerates development*—** If your application’s roadmap suggests that
    a particular part of your application will undergo a lot of development over the
    next year, then converting it to a service accelerates development.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***加速开发*—** 如果你的应用程序路线图表明应用程序的某个部分将在下一年经历大量的开发，那么将其转换为服务可以加速开发。'
- en: '***Solves a performance, scaling, or reliability problem*—** If a particular
    part of your application has a performance or scalability problem or is unreliable,
    then it’s valuable to convert it to a service.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***解决性能、扩展性或可靠性问题*—** 如果应用程序的某个部分存在性能或可扩展性问题或不可靠，那么将其转换为服务是有价值的。'
- en: '***Enables the extraction of some other services*—** Sometimes extracting one
    service simplifies the extraction of another service, due to dependencies between
    modules.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***使提取其他服务成为可能*—** 有时，由于模块之间的依赖关系，提取一个服务可以简化另一个服务的提取。'
- en: You can use these criteria to add refactoring tasks to your application’s backlog,
    ranked by expected benefit. The benefit of this approach is that it’s more strategic
    and much more closely aligned with the needs of the business. During sprint planning,
    you decide whether it’s more valuable to implement features or extract services.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些标准将重构任务添加到应用程序的待办事项列表中，按预期收益进行排序。这种方法的优点是它更加战略化，并且与业务需求更加紧密地一致。在冲刺计划期间，你决定是实施功能还是提取服务更有价值。
- en: 13.3\. Designing how the service and the monolith collaborate
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3\. 设计服务与单体应用的协作方式
- en: A service is rarely standalone. It usually needs to collaborate with the monolith.
    Sometimes a service needs to access data owned by the monolith or invoke its operations.
    For example, `Delayed Delivery Service`, described in detail in [section 13.4.1](#ch13lev2sec9),
    requires access to the monolith’s orders and customer contact info. The monolith
    might also need to access data owned by the service or invoke its operations.
    For example, later in [section 13.5](#ch13lev1sec5), when discussing how to extract
    delivery management into a service, I describe how the monolith needs to invoke
    `Delivery Service`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务很少是独立的。它通常需要与单体应用协作。有时一个服务需要访问单体应用拥有的数据或调用其操作。例如，详细描述在[第13.4.1节](#ch13lev2sec9)中的`延迟交付服务`，需要访问单体应用的订单和客户联系信息。单体应用也可能需要访问服务拥有的数据或调用其操作。例如，在[第13.5节](#ch13lev1sec5)中稍后讨论如何将交付管理提取为服务时，我描述了单体应用需要调用`交付服务`。
- en: One important concern is maintaining data consistency between the service and
    monolith. In particular, when you extract a service from the monolith, you invariably
    split what were originally ACID transactions. You must be careful to ensure that
    data consistency is still maintained. As described later in this section, sometimes
    you use sagas to maintain data consistency.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的关注点是维护服务与单体应用之间的数据一致性。特别是，当你从单体应用中提取服务时，你不可避免地会分割原本的ACID事务。你必须小心确保数据一致性仍然得到维护。正如本节稍后所述，有时你使用sagas来维护数据一致性。
- en: The interaction between a service and the monolith is, as described earlier,
    facilitated by integration glue code. [Figure 13.8](#ch13fig08) shows the structure
    of the integration glue. It consists of adapters in the service and monolith that
    communicate using some kind of IPC mechanism. Depending on the requirements, the
    service and monolith might interact over REST or they might use messaging. They
    might even communicate using multiple IPC mechanisms.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，服务和单体之间的交互由集成粘合剂代码促进。[图13.8](#ch13fig08)显示了集成粘合剂的结构。它由服务和单体中使用某种IPC机制进行通信的适配器组成。根据要求，服务和单体可能通过REST交互，或者它们可能使用消息传递。它们甚至可能使用多种IPC机制进行通信。
- en: Figure 13.8\. When migrating a monolith to microservices, the services and monolith
    often need to access each other’s data. This interaction is facilitated by the
    integration glue, which consists of adapters that implement APIs. Some APIs are
    messaging based. Other APIs are RPI based.
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.8\. 当将单体应用迁移到微服务时，服务和单体通常需要相互访问对方的数据。这种交互由集成粘合剂促进，它由实现API的适配器组成。一些API是基于消息的。其他API是基于RPI的。
- en: '![](Images/13fig08_alt.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig08_alt.jpg)'
- en: For example, `Delayed Delivery Service` uses both REST and domain events. It
    retrieves customer contact info from the monolith using REST. It tracks the state
    of `Orders` by subscribing to domain events published by the monolith.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Delayed Delivery Service`同时使用REST和领域事件。它使用REST从单体应用中检索客户联系信息。它通过订阅由单体应用发布的领域事件来跟踪`Orders`的状态。
- en: In this section, I first describe the design of the integration glue. I talk
    about the problems it solves and the different implementation options. After that
    I describe transaction management strategies, including the use of sagas. I discuss
    how sometimes the requirement to maintain data consistency changes the order in
    which you extract services.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我首先描述了集成粘合剂的设计。我讨论了它解决的问题和不同的实现选项。之后，我描述了事务管理策略，包括使用sagas。我讨论了有时保持数据一致性的要求会改变你提取服务时的顺序。
- en: Let’s first look at the design of the integration glue.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看集成粘合剂的设计。
- en: 13.3.1\. Designing the integration glue
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.1\. 设计集成粘合剂
- en: When implementing a feature as a service or extracting a service from the monolith,
    you must develop the integration glue that enables a service to collaborate with
    the monolith. It consists of code in both the service and monolith that uses some
    kind of IPC mechanism. The structure of the integration glue depends on the type
    of IPC mechanism that is used. If, for example, the service invokes the monolith
    using REST, then the integration glue consists of a REST client in the service
    and web controllers in the monolith. Alternatively, if the monolith subscribes
    to domain events published by the service, then the integration glue consists
    of an event-publishing adapter in the service and event handlers in the monolith.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当将一个功能作为服务实现或从单体应用中提取服务时，你必须开发一个集成粘合剂，使服务能够与单体应用协作。它由服务和单体中使用的某种IPC机制代码组成。集成粘合剂的结构取决于所使用的IPC机制类型。例如，如果服务使用REST调用单体应用，那么集成粘合剂由服务中的REST客户端和单体应用中的Web控制器组成。或者，如果单体应用订阅由服务发布的领域事件，那么集成粘合剂由服务中的事件发布适配器和单体应用中的事件处理器组成。
- en: Designing the integration glue API
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设计集成粘合剂API
- en: 'The first step in designing the integration glue is to decide what APIs it
    provides to the domain logic. There are a couple of different styles of interface
    to choose from, depending on whether you’re querying data or updating data. Let’s
    say you’re working on `Delayed Delivery Service`, which needs to retrieve customer
    contact info from the monolith. The service’s business logic doesn’t need to know
    the IPC mechanism that the integration glue uses to retrieve the information.
    Therefore, that mechanism should be encapsulated by an interface. Because `Delayed
    Delivery Service` is querying data, it makes sense to define a `CustomerContactInfoRepository`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 设计集成粘合剂的第一步是决定它为领域逻辑提供哪些API。根据你是查询数据还是更新数据，你可以从几种不同的接口风格中进行选择。假设你正在处理`Delayed
    Delivery Service`，该服务需要从单体应用中检索客户联系信息。服务的业务逻辑不需要知道集成粘合剂用来检索信息的IPC机制。因此，该机制应该被一个接口封装。因为`Delayed
    Delivery Service`正在查询数据，所以定义一个`CustomerContactInfoRepository`是有意义的：
- en: '[PRE0]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The service’s business logic can invoke this API without knowing how the integration
    glue retrieves the data.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的业务逻辑可以调用这个API，而无需知道集成粘合剂如何检索数据。
- en: 'Let’s consider a different service. Imagine that you’re extracting delivery
    management from the FTGO monolith. The monolith needs to invoke `Delivery Service`
    to schedule, reschedule, and cancel deliveries. Once again, the details of the
    underlying IPC mechanism aren’t important to the business logic and should be
    encapsulated by an interface. In this scenario, the monolith must invoke a service
    operation, so using a repository doesn’t make sense. A better approach is to define
    a service interface, such as the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个不同的服务。想象一下，你正在从 FTGO 单体中提取配送管理。单体需要调用 `Delivery Service` 来安排、重新安排和取消配送。再次强调，底层
    IPC 机制的细节对业务逻辑来说并不重要，应该由接口封装。在这种情况下，单体必须调用服务操作，因此使用存储库没有意义。更好的方法是定义一个服务接口，如下所示：
- en: '[PRE1]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The monolith’s business logic invokes this API without knowing how it’s implemented
    by the integration glue.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 单体的业务逻辑调用此 API，而不知道它是如何由集成粘合剂实现的。
- en: Now that we’ve seen interface design, let’s look at interaction styles and IPC
    mechanisms.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了接口设计，让我们来看看交互样式和 IPC 机制。
- en: Picking an interaction style and IPC mechanism
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选择交互样式和 IPC 机制
- en: An important design decision you must make when designing the integration glue
    is selecting the interaction styles and IPC mechanisms that enable the service
    and the monolith to collaborate. As described in [chapter 3](kindle_split_011.xhtml#ch03),
    there are several interaction styles and IPC mechanisms to choose from. Which
    one you should use depends on what one *party*—the service or monolith—needs in
    order to query or update the other party.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计集成粘合剂时，你必须做出的一个重要设计决策是选择使服务和单体协作的交互样式和 IPC 机制。如第 3 章所述（kindle_split_011.xhtml#ch03），有几种交互样式和
    IPC 机制可供选择。你应该使用哪一种取决于一方——服务或单体——需要什么来查询或更新另一方。
- en: If one party needs to query data owned by the other party, there are several
    options. One option is, as [figure 13.9](#ch13fig09) shows, for the adapter that
    implements the repository interface to invoke an API of the data provider. This
    API will typically use a request/response interaction style, such as REST or gRPC.
    For example, `Delayed Delivery Service` might retrieve the customer contact info
    by invoking a REST API implemented by the FTGO monolith.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一方需要查询另一方的数据，有几个选择。一个选项是，如图 13.9 所示，实现存储库接口的适配器调用数据提供者的 API。这个 API 通常使用请求/响应交互样式，如
    REST 或 gRPC。例如，`Delayed Delivery Service` 可能通过调用由 FTGO 单体实现的 REST API 来检索客户联系信息。
- en: Figure 13.9\. The adapter that implements the `CustomerContactInfoRepository`
    interface invokes the monolith’s REST API to retrieve the customer information.
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.9\. 实现存储库接口的适配器调用单体的 REST API 来检索客户信息。
- en: '![](Images/13fig09_alt.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.9](Images/13fig09_alt.jpg)'
- en: In this example, the `Delayed Delivery Service`’s domain logic retrieves the
    customer contact info by invoking the `CustomerContactInfoRepository` interface.
    The implementation of this interface invokes the monolith’s REST API.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Delayed Delivery Service` 的领域逻辑通过调用 `CustomerContactInfoRepository`
    接口来检索客户联系信息。该接口的实现调用单体的 REST API。
- en: An important benefit of querying data by invoking a query API is its simplicity.
    The main drawback is that it’s potentially inefficient. A consumer might need
    to make a large number of requests. A provider might return a large amount of
    data. Another drawback is that it reduces availability because it’s synchronous
    IPC. As a result, it might not be practical to use a query API.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用查询 API 查询数据的一个重要好处是其简单性。主要缺点是它可能效率低下。消费者可能需要发出大量请求。提供者可能返回大量数据。另一个缺点是它减少了可用性，因为它是一种同步的
    IPC。因此，使用查询 API 可能不切实际。
- en: An alternative approach is for the data consumer to maintain a replica of the
    data, as shown in [figure 13.10](#ch13fig10). The replica is essentially a CQRS
    view. The data consumer keeps the replica up-to-date by subscribing to domain
    events published by the data provider.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方法是数据消费者维护数据的副本，如图 13.10 所示。副本本质上是一个 CQRS 视图。数据消费者通过订阅数据提供者发布的领域事件来保持副本的更新。
- en: Figure 13.10\. The integration glue replicates data from the monolith to the
    service. The monolith publishes domain events, and an event handler implemented
    by the service updates the service’s database.
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.10\. 集成粘合剂从单体复制数据到服务。单体发布领域事件，由服务实现的事件处理器更新服务的数据库。
- en: '![](Images/13fig10_alt.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.10](Images/13fig10_alt.jpg)'
- en: Using a replica has several benefits. It avoids the overhead of repeatedly querying
    the data provider. Instead, as discussed when describing CQRS in [chapter 7](kindle_split_015.xhtml#ch07),
    you can design the replica to support efficient queries. One drawback of using
    a replica, though, is the complexity of maintaining it. A potential challenge,
    as described later in this section, is the need to modify the monolith to publish
    domain events.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用副本有几个好处。它避免了反复查询数据提供者的开销。相反，正如在描述第7章中的CQRS时讨论的那样，你可以设计副本以支持高效的查询。然而，使用副本的一个缺点是维护它的复杂性。本节后面将描述的一个潜在挑战是需要修改单体以发布领域事件。
- en: Now that we’ve discussed how to do queries, let’s consider how to do updates.
    One challenge with performing updates is the need to maintain data consistency
    across the service and monolith. The party making the update request (the requestor)
    has updated or needs to update its database. So it’s essential that both updates
    happen. The solution is for the service and monolith to communicate using transactional
    messaging implemented by a framework, such as Eventuate Tram. In simple scenarios,
    the requestor can send a notification message or publish an event to trigger an
    update. In more complex scenarios, the requestor must use a saga to maintain data
    consistency. [Section 13.3.2](#ch13lev2sec7) discusses the implications of using
    sagas.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了如何进行查询，让我们考虑如何进行更新。执行更新的一个挑战是需要维护服务和单体之间的数据一致性。发起更新请求的方（请求者）已经更新或需要更新其数据库。因此，确保两个更新都发生至关重要。解决方案是服务和单体通过框架实现的交易性消息进行通信，例如Eventuate
    Tram。在简单场景中，请求者可以发送通知消息或发布事件来触发更新。在更复杂场景中，请求者必须使用一个叙事来维护数据一致性。[第13.3.2节](#ch13lev2sec7)讨论了使用叙事的后果。
- en: Implementing an anti-corruption layer
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现反腐败层
- en: Imagine you’re implementing a new feature as a brand new service. You’re not
    constrained by the monolith’s code base, so you can use modern development techniques
    such as DDD and develop a pristine new domain model. Also, because the FTGO monolith’s
    domain is poorly defined and somewhat out-of-date, you’ll probably model concepts
    differently. As a result, your service’s domain model will have different class
    names, field names, and field values. For example, `Delayed Delivery Service`
    has a `Delivery` entity with narrowly focused responsibilities, whereas the FTGO
    monolith has an `Order` entity with an excessive number of responsibilities. Because
    the two domain models are different, you must implement what DDD calls an *anti-corruption
    layer* (ACL) in order for the service to communicate with the monolith.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在作为一项全新的服务实现一个新功能。由于不受单体代码库的限制，你可以使用现代开发技术，如领域驱动设计（DDD），并开发一个全新的领域模型。此外，由于FTGO单体领域的定义不佳且有些过时，你可能会以不同的方式建模概念。因此，你的服务领域模型将具有不同的类名、字段名和字段值。例如，`Delayed
    Delivery Service` 有一个专注于特定责任的 `Delivery` 实体，而FTGO单体则有一个具有过多责任的 `Order` 实体。由于这两个领域模型不同，你必须实现DDD所说的*反腐败层*（ACL），以便服务能与单体通信。
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Anti-corruption layer**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：反腐败层**'
- en: A software layer that translates between two different domain models in order
    to prevent concepts from one model polluting another. See [https://microservices.io/patterns/refactoring/anti-corruption-layer.html](https://microservices.io/patterns/refactoring/anti-corruption-layer.html).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一种软件层，用于在两个不同的领域模型之间进行转换，以防止一个模型的概念污染另一个模型。请参阅[https://microservices.io/patterns/refactoring/anti-corruption-layer.html](https://microservices.io/patterns/refactoring/anti-corruption-layer.html)。
- en: '|  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The goal of an ACL is to prevent a legacy monolith’s domain model from polluting
    a service’s domain model. It’s a layer of code that translates between the different
    domain models. For example, as [figure 13.11](#ch13fig11) shows, `Delayed Delivery
    Service` has a `CustomerContactInfoRepository` interface, which defines a `findCustomerContactInfo()`
    method that returns `CustomerContactInfo`. The class that implements the `CustomerContactInfoRepository`
    interface must translate between the ubiquitous language of `Delayed Delivery
    Service` and that of the FTGO monolith.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 反腐败层的目的是防止遗留单体领域模型污染服务领域模型。它是一层代码，在不同的领域模型之间进行转换。例如，如图13.11所示，`Delayed Delivery
    Service` 有一个 `CustomerContactInfoRepository` 接口，该接口定义了一个返回 `CustomerContactInfo`
    的 `findCustomerContactInfo()` 方法。实现 `CustomerContactInfoRepository` 接口的类必须在 `Delayed
    Delivery Service` 的通用语言和FTGO单体之间的语言进行转换。
- en: Figure 13.11\. A service adapter that invokes the monolith must translate between
    the service’s domain model and the monolith’s domain model.
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.11。调用单体应用的服务适配器必须在服务的领域模型和单体应用的领域模型之间进行转换。
- en: '![](Images/13fig11_alt.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig11_alt.jpg)'
- en: The implementation of `findCustomerContactInfo()` invokes the FTGO monolith
    to retrieve the customer information and translates the response to `CustomerContactInfo`.
    In this example, the translation is quite simple, but in other scenarios it could
    be quite complex and involve, for example, mapping values such as status codes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`findCustomerContactInfo()` 方法的实现调用FTGO单体应用以检索客户信息，并将响应转换为`CustomerContactInfo`。在这个例子中，转换相当简单，但在其他场景中可能会非常复杂，例如涉及映射状态代码等值。'
- en: An event subscriber, which consumes domain events, also has an ACL. Domain events
    are part of the publisher’s domain model. An event handler must translate domain
    events to the subscriber’s domain model. For example, as [figure 13.12](#ch13fig12)
    shows, the FTGO monolith publishes `Order` domain events. `Delivery Service` has
    an event handler that subscribes to those events.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 消费领域事件的领域事件订阅者也有一个访问控制列表（ACL）。领域事件是发布者领域模型的一部分。事件处理器必须将领域事件转换为订阅者的领域模型。例如，如图13.12所示，FTGO单体应用发布`Order`领域事件。`Delivery
    Service`有一个订阅这些事件的处理器。
- en: Figure 13.12\. An event handler must translate from the event publisher’s domain
    model to the subscriber’s domain model.
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.12。事件处理器必须从事件发布者的领域模型转换为订阅者的领域模型。
- en: '![](Images/13fig12_alt.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig12_alt.jpg)'
- en: The event handler must translate domain events from the monolith’s domain language
    to that of `Delivery Service`. It might need to map class and attribute names
    and potentially attribute values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器必须将单体应用的领域语言中的领域事件转换为`Delivery Service`的语言。它可能需要映射类和属性名称，以及可能属性值。
- en: It’s not just services that use an anti-corruption layer. A monolith also uses
    an ACL when invoking the service and when subscribing to domain events published
    by a service. For example, the FTGO monolith schedules a delivery by sending a
    notification message to `Delivery Service`. It sends the notification by invoking
    a method on the `DeliveryService` interface. The implementation class translates
    its parameters into a message that `Delivery Service` understands.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅服务使用反腐败层。单体应用在调用服务和订阅由服务发布的领域事件时，也会使用ACL。FTGO单体应用通过向`Delivery Service`发送通知消息来安排交付。它通过在`DeliveryService`接口上调用方法来发送通知。实现类将其参数转换为`Delivery
    Service`能够理解的消息。
- en: How the monolith publishes and subscribes to domain events
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 单体应用如何发布和订阅领域事件
- en: Domain events are an important collaboration mechanism. It’s straightforward
    for a newly developed service to publish and consume events. It can use one of
    the mechanisms described in [chapter 3](kindle_split_011.xhtml#ch03), such as
    the Eventuate Tram framework. A service might even publish events using event
    sourcing, described in [chapter 6](kindle_split_014.xhtml#ch06). It’s potentially
    challenging, though, to change the monolith to publish and consume events. Let’s
    look at why.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件是一个重要的协作机制。对于新开发的服务来说，发布和消费事件是直接的。它可以使用第3章中描述的机制之一，例如Eventuate Tram框架。服务甚至可以使用第6章中描述的事件溯源来发布事件。然而，将单体应用改为发布和消费事件可能具有挑战性。让我们看看原因。
- en: There are a couple of different ways that a monolith can publish domain events.
    One approach is to use the same domain event publishing mechanism used by the
    services. You find all the places in the code that change a particular entity
    and insert a call to an event publishing API. The problem with this approach is
    that changing a monolith isn’t always easy. It might be time consuming and error
    prone to locate all the places and insert calls to publish events. To make matters
    worse, some of the monolith’s business logic might consist of stored procedures
    that can’t easily publish domain events.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单体应用可以通过几种不同的方式发布领域事件。一种方法就是使用服务所使用的相同的领域事件发布机制。你需要在代码中找到所有改变特定实体的地方，并插入对事件发布API的调用。这种方法的问题在于改变单体应用并不总是容易的。定位所有这些地方并插入发布事件的调用可能会很耗时，且容易出错。更糟糕的是，单体应用的一些业务逻辑可能由无法轻松发布领域事件的存储过程组成。
- en: Another approach is to publish domain events at the database level. You can,
    for example, use either transaction logic tailing or polling, described in [chapter
    3](kindle_split_011.xhtml#ch03). A key benefit of using transaction tailing is
    that you don’t have to change the monolith. The main drawback of publishing events
    at the database level is that it’s often difficult to identify the reason for
    the update and publish the appropriate high-level business event. As a result,
    the service will typically publish events representing changes to tables rather
    than business entities.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在数据库级别发布领域事件。例如，你可以使用事务逻辑尾随或轮询，这些内容在[第3章](kindle_split_011.xhtml#ch03)中有描述。使用事务尾随的一个关键好处是，你不需要改变单体应用。在数据库级别发布事件的缺点是，通常很难确定更新的原因并发布适当的高级业务事件。因此，服务通常会发布表示表变更的事件，而不是业务实体的事件。
- en: Fortunately, it’s usually easier for the monolith to subscribe to domain events
    published as services. Quite often, you can write event handlers using a framework,
    such as Eventuate Tram. But sometimes it’s even challenging for the monolith to
    subscribe to events. For example, the monolith might be written in a language
    that doesn’t have a message broker client. In that situation, you need to write
    a small “helper” application that subscribes to events and updates the monolith’s
    database directly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于单体应用来说，通常更容易订阅作为服务发布的领域事件。很多时候，你可以使用框架，如Eventuate Tram，来编写事件处理器。但有时，单体应用订阅事件甚至具有挑战性。例如，单体应用可能使用的是没有消息代理客户端的语言。在这种情况下，你需要编写一个小型的“辅助”应用程序来订阅事件并直接更新单体应用的数据库。
- en: 'Now that we’ve looked at how to design the integration glue that enables a
    service and the monolith to collaborate, let’s look at another challenge you might
    face when migrating to microservices: maintaining data consistency across a service
    and a monolith.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何设计集成胶水，使服务和单体应用能够协作，让我们看看在迁移到微服务时可能会遇到的另一个挑战：在服务和单体应用之间维护数据一致性。
- en: 13.3.2\. Maintaining data consistency across a service and a monolith
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.2\. 在服务和单体应用之间维护数据一致性
- en: When you develop a service, you might find it challenging to maintain data consistency
    across the service and the monolith. A service operation might need to update
    data in the monolith, or a monolith operation might need to update data in the
    service. For example, imagine you extracted `Kitchen Service` from the monolith.
    You would need to change the monolith’s order-management operations, such as `createOrder()`
    and `cancelOrder()`, to use sagas in order to keep the `Ticket` consistent with
    the `Order`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开发一个服务时，你可能会发现很难在服务和单体应用之间维护数据一致性。服务操作可能需要更新单体应用中的数据，或者单体应用操作可能需要更新服务中的数据。例如，想象一下你从单体应用中提取了“厨房服务”。你需要更改单体应用的订单管理操作，如`createOrder()`和`cancelOrder()`，以使用sagas来保持“票据”与“订单”的一致性。
- en: The problem with using sagas, however, is that the monolith might not be a willing
    participant. As described in [chapter 4](kindle_split_012.xhtml#ch04), sagas must
    use compensating transactions to undo changes. `Create Order Saga`, for example,
    includes a compensating transaction that marks an `Order` as rejected if it’s
    rejected by `Kitchen Service`. The problem with compensating transactions in the
    monolith is that you might need to make numerous and time-consuming changes to
    the monolith in order to support them. The monolith might also need to implement
    countermeasures to handle the lack of isolation between sagas. The cost of these
    code changes can be a huge obstacle to extracting a service.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用sagas的问题在于，单体应用可能不愿意参与。如[第4章](kindle_split_012.xhtml#ch04)所述，sagas必须使用补偿事务来撤销更改。例如，“创建订单sagas”包括一个补偿事务，如果“厨房服务”拒绝订单，则将订单标记为已拒绝。在单体应用中使用补偿事务的问题是你可能需要做出许多耗时且复杂的更改来支持它们。单体应用可能还需要实施对策来处理sagas之间缺乏隔离的问题。这些代码更改的成本可能是提取服务的一个巨大障碍。
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Key saga terminology**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键sagas术语**'
- en: 'I cover sagas in [chapter 4](kindle_split_012.xhtml#ch04). Here are some key
    terms:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第4章](kindle_split_012.xhtml#ch04)中介绍了sagas。以下是一些关键术语：
- en: '***Saga*—** A sequence of local transactions coordinated through asynchronous
    messaging.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Saga*—** 通过异步消息协调的一系列本地事务。'
- en: '***Compensating transaction*—** A transaction that undoes the updates made
    by a local transaction.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***补偿事务*—** 撤销本地事务所做的更新的交易。'
- en: '***Countermeasure*—** A design technique used to handle the lack of isolation
    between sagas.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***对策*——** 用于处理故事（sagas）之间隔离不足的设计技术。'
- en: '***Semantic lock*—** A countermeasure that sets a flag in a record that is
    being updated by a saga.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***语义锁*——** 在由故事（saga）更新的记录中设置标志的一种对策。'
- en: '***Compensatable transaction*—** A transaction that needs a compensating transaction
    because one of the transactions that follows it in the saga can fail.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可补偿事务*——** 需要补偿事务的事务，因为叙事（saga）中跟随它的某个事务可能会失败。'
- en: '***Pivot transaction*—** A transaction that is the saga’s go/no-go point. If
    it succeeds, then the saga will run to completion.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***枢纽事务*——** 一个决定故事（saga）是否执行的事务。如果它成功，那么故事（saga）将运行到完成。'
- en: '***Retriable transaction*—** A transaction that follows the pivot transaction
    and is guaranteed to succeed.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可重试事务*——** 跟随枢纽事务并保证成功的事务。'
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Fortunately, many sagas are straightforward to implement. As covered in [chapter
    4](kindle_split_012.xhtml#ch04), if the monolith’s transactions are either *pivot
    transactions* or *retriable transactions*, then implementing sagas should be straightforward.
    You may even be able to simplify implementation by carefully ordering the sequence
    of service extractions so that the monolith’s transactions never need to be compensatable.
    Or it may be relatively difficult to change the monolith to support compensating
    transactions. To understand why implementing compensating transactions in the
    monolith is sometimes challenging, let’s look at some examples, beginning with
    a particularly troublesome one.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，许多故事（sagas）的实现都很直接。如第4章[第4章](kindle_split_012.xhtml#ch04)所述，如果单体架构的事务要么是*枢纽事务*要么是*可重试事务*，那么实现故事（sagas）应该很简单。你甚至可以通过仔细排序服务提取的顺序来简化实现，这样单体架构的事务就永远不需要是可补偿的。或者，改变单体架构以支持补偿事务可能相对困难。为了理解为什么在单体架构中实现补偿事务有时具有挑战性，让我们看看一些例子，从特别棘手的一个开始。
- en: The challenge of changing the monolith to support compensatable transactions
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将单体架构改为支持可补偿事务的挑战
- en: Let’s dig into the problem of compensating transactions that you’ll need to
    solve when extracting `Kitchen Service` from the monolith. This refactoring involves
    splitting the `Order` entity and creating a `Ticket` entity in `Kitchen Service`.
    It impacts numerous commands implemented by the monolith, including `createOrder()`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨当你从单体架构中提取`厨房服务`时需要解决的补偿事务问题。这个重构涉及将`订单`实体拆分并在`厨房服务`中创建一个`票证`实体。它影响了单体架构实现的许多命令，包括`createOrder()`。
- en: 'The monolith implements the `createOrder()` command as a single ACID transaction
    consisting of the following steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构将`createOrder()`命令实现为一个包含以下步骤的单个ACID事务：
- en: Validate order details.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证订单详情。
- en: Verify that the consumer can place an order.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证消费者能否下单。
- en: Authorize consumer’s credit card.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权消费者的信用卡。
- en: Create an `Order`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`订单`。
- en: 'You need to replace this ACID transaction with a saga consisting of the following
    steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要用以下步骤组成的叙事（saga）来替换这个ACID事务：
- en: In the monolith
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单体架构中
- en: Create an `Order` in an `APPROVAL_PENDING` state.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`审批待定`状态下创建一个`订单`。
- en: Verify that the consumer can place an order.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证消费者能否下单。
- en: In the `Kitchen Service`
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`厨房服务`
- en: Validate order details.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证订单详情。
- en: Create a `Ticket` in the `CREATE_PENDING` state.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`创建待定`状态下创建一个`票证`。
- en: In the monolith
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单体架构中
- en: Authorize consumer’s credit card.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权消费者的信用卡。
- en: Change state of `Order` to `APPROVED`.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`订单`的状态改为`已批准`。
- en: In `Kitchen Service`
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`厨房服务`
- en: Change the state of the `Ticket` to `AWAITING_ACCEPTANCE`.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`票证`的状态改为`等待接受`。
- en: This saga is similar to `CreateOrderSaga` described in [chapter 4](kindle_split_012.xhtml#ch04).
    It consists of four local transactions, two in the monolith and two in `Kitchen
    Service`. The first transaction creates an `Order` in the `APPROVAL_PENDING` state.
    The second transaction creates a `Ticket` in the `CREATE_PENDING` state. The third
    transaction authorizes the `Consumer` credit card and changes the state of the
    order to `APPROVED`. The fourth and final transaction changes the state of the
    `Ticket` to `AWAITING_ACCEPTANCE`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事与第4章中描述的`CreateOrderSaga`类似。[第4章](kindle_split_012.xhtml#ch04)。它由四个本地事务组成，两个在单体架构中，两个在`厨房服务`中。第一个事务在`审批待定`状态下创建一个`订单`。第二个事务在`创建待定`状态下创建一个`票证`。第三个事务授权`消费者`的信用卡并将订单状态改为`已批准`。第四个也是最后一个事务将`票证`的状态改为`等待接受`。
- en: The challenge with implementing this saga is that the first step, which creates
    the `Order`, must be compensatable. That’s because the second local transaction,
    which occurs in `Kitchen Service`, might fail and require the monolith to undo
    the updates performed by the first local transaction. As a result, the `Order`
    entity needs to have an `APPROVAL_PENDING`, a semantic lock countermeasure, described
    in [chapter 4](kindle_split_012.xhtml#ch04), that indicates an `Order` is in the
    process of being created.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个Saga的挑战在于，第一步，即创建`Order`，必须是可补偿的。这是因为第二个本地事务，发生在`Kitchen Service`中，可能会失败并要求单体应用撤销第一个本地事务所做的更新。因此，`Order`实体需要有一个`APPROVAL_PENDING`，一个在[第4章](kindle_split_012.xhtml#ch04)中描述的语义锁定对策，它表明`Order`正在创建过程中。
- en: The problem with introducing a new `Order` entity state is that it potentially
    requires widespread changes to the monolith. You might need to change every place
    in the code that touches an `Order` entity. Making these kinds of widespread changes
    to the monolith is time consuming and not the best investment of development resources.
    It’s also potentially risky, because the monolith is often difficult to test.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 引入新的`Order`实体状态的问题在于，这可能会要求对单体应用进行广泛的更改。你可能需要更改代码中所有触及`Order`实体的地方。对单体应用进行这类广泛的更改既耗时又不是开发资源的最佳投资。此外，这也可能存在风险，因为单体应用通常难以测试。
- en: Sagas don’t always require the monolith to support compensatable transactions
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Saga不一定需要单体应用来支持可补偿的事务。
- en: Sagas are highly domain-specific. Some, such as the one we just looked at, require
    the monolith to support compensating transactions. But it’s quite possible that
    when you extract a service, you may be able to design sagas that don’t require
    the monolith to implement compensating transactions. That’s because a monolith
    only needs to support compensating transactions if the transactions that follow
    the monolith’s transaction can fail. If each of the monolith’s transactions is
    either a pivot transaction or a retriable transaction, then the monolith never
    needs to execute a compensating transaction. As a result, you only need to make
    minimal changes to the monolith to support sagas.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Saga具有高度领域特定性。有些，例如我们刚刚看到的，需要单体应用来支持补偿性事务。但完全有可能，当你提取一个服务时，你可能能够设计出不需要单体应用实现补偿性事务的Saga。这是因为单体应用只需要支持补偿性事务，如果跟随单体应用事务的事务可能会失败。如果单体应用中的每个事务要么是关键事务要么是可重试事务，那么单体应用就永远不需要执行补偿性事务。因此，你只需要对单体应用进行最小程度的更改以支持Saga。
- en: 'For example, imagine that instead of extracting `Kitchen Service`, you extract
    `Order Service`. This refactoring involves splitting the `Order` entity and creating
    a slimmed-down `Order` entity in `Order Service`. It also impacts numerous commands,
    including `createOrder()`, which is moved from the monolith to `Order Service`.
    In order to extract `Order Service`, you need to change the `createOrder()` command
    to use a saga, using the following steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下，如果你不是提取`Kitchen Service`，而是提取`Order Service`。这次重构涉及将`Order`实体拆分，并在`Order
    Service`中创建一个精简的`Order`实体。它还影响了包括`createOrder()`在内的许多命令，该命令从单体应用移动到`Order Service`。为了提取`Order
    Service`，你需要更改`createOrder()`命令以使用saga，按照以下步骤进行：
- en: '`Order Service`'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Order Service`'
- en: Create an `Order` in an `APPROVAL_PENDING` state.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`APPROVAL_PENDING`状态下创建一个`Order`。
- en: Monolith
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体应用
- en: Verify that the consumer can place an order.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证消费者可以下订单。
- en: Validate order details and create a `Ticket`.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证订单详情并创建一个`Ticket`。
- en: Authorize consumer’s credit card.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权消费者的信用卡。
- en: '`Order Service`'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Order Service`'
- en: Change state of `Order` to `APPROVED`.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Order`的状态更改为`APPROVED`。
- en: This saga consists of three local transactions, one in the monolith and two
    in `Order Service`. The first transaction, which is in `Order Service`, creates
    an `Order` in the `APPROVAL_PENDING` state. The second transaction, which is in
    the monolith, verifies that the consumer can place orders, authorizes their credit
    card, and creates a `Ticket`. The third transaction, which is in `Order Service`,
    changes the state of the `Order` to `APPROVED`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Saga由三个本地事务组成，一个在单体应用中，两个在`Order Service`中。第一个事务，在`Order Service`中，创建了一个处于`APPROVAL_PENDING`状态的`Order`。第二个事务，在单体应用中，验证消费者可以下订单，授权他们的信用卡并创建一个`Ticket`。第三个事务，在`Order
    Service`中，将`Order`的状态更改为`APPROVED`。
- en: The monolith’s transaction is the saga’s pivot transaction—the point of no return
    for the saga. If the monolith’s transaction completes, then the saga will run
    until completion. Only the first and second steps of this saga can fail. The third
    transaction can’t fail, so the second transaction in the monolith never needs
    to be rolled back. As a result, all the complexity of supporting compensatable
    transactions is in `Order Service`, which is much more testable than the monolith.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 单体的事务是saga的枢纽事务——saga的不可逆转点。如果单体的事务完成，那么saga将运行至完成。只有这个saga的前两个步骤可能会失败。第三个事务不能失败，因此单体中的第二个事务永远不会需要回滚。因此，支持补偿性事务的所有复杂性都在`订单服务`中，这使得它比单体更容易测试。
- en: If all the sagas that you need to write when extracting a service have this
    structure, you’ll need to make far fewer changes to the monolith. What’s more,
    it’s possible to carefully sequence the extraction of services to ensure that
    the monolith’s transactions are either pivot transactions or retriable transactions.
    Let’s look at how to do that.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在提取服务时需要编写的所有sagas都具有这种结构，那么您需要对单体进行更少的更改。更重要的是，您可以仔细地排序服务提取，以确保单体的事务要么是枢纽事务，要么是可重试事务。让我们看看如何做到这一点。
- en: Sequencing the extraction of services to avoid implementing compe- ensating
    transactions in the monolith
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对服务提取进行排序以避免在单体中实现补偿性事务。
- en: As we just saw, extracting `Kitchen Service` requires the monolith to implement
    compensating transactions, whereas extracting `Order Service` doesn’t. This suggests
    that the order in which you extract services matters. By carefully ordering the
    extraction of services, you can potentially avoid having to make widespread modifications
    to the monolith to support compensatable transactions. We can ensure that the
    monolith’s transactions are either pivot transactions or retriable transactions.
    For example, if we first extract `Order Service` from the FTGO monolith and then
    extract `Consumer Service`, extracting `Kitchen Service` will be straightforward.
    Let’s take a closer look at how to do that.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，提取`厨房服务`需要单体实现补偿性事务，而提取`订单服务`则不需要。这表明提取服务的顺序很重要。通过仔细排序服务提取，您可以避免需要对单体进行广泛的修改以支持补偿性事务。我们可以确保单体的事务要么是枢纽事务，要么是可重试事务。例如，如果我们首先从FTGO单体中提取`订单服务`，然后提取`消费者服务`，提取`厨房服务`将变得简单。让我们更详细地看看如何做到这一点。
- en: 'Once we have extracted `Consumer Service`, the `createOrder()` command uses
    the following saga:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们提取了`消费者服务`，`createOrder()`命令使用以下saga：
- en: '`Order Service`: create an `Order` in an `APPROVAL_PENDING` state.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`订单服务`: 在`APPROVAL_PENDING`状态下创建一个`订单`。'
- en: '`Consumer Service`: verify that the consumer can place an order.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`消费者服务`: 验证消费者能否下订单。'
- en: Monolith
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体
- en: Validate order details and create a `Ticket`.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证订单详情并创建一个`票据`。
- en: Authorize consumer’s credit card.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权消费者的信用卡。
- en: '`Order Service`: change state of `Order` to `APPROVED`.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`订单服务`: 将`订单`的状态更改为`APPROVED`。'
- en: In this saga, the monolith’s transaction is the pivot transaction. `Order Service`
    implements the compensatable transaction.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个saga中，单体的事务是枢纽事务。`订单服务`实现补偿性事务。
- en: 'Now that we’ve extracted `Consumer Service`, we can extract `Kitchen Service`.
    If we extract this service, the `createOrder()` command uses the following saga:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经提取了`消费者服务`，我们可以提取`厨房服务`。如果我们提取这个服务，`createOrder()`命令将使用以下saga：
- en: '`Order Service`: create an `Order` in an `APPROVAL_PENDING` state.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`订单服务`: 在`APPROVAL_PENDING`状态下创建一个`订单`。'
- en: '`Consumer Service`: verify that the consumer can place an order.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`消费者服务`: 验证消费者能否下订单。'
- en: '`Kitchen Service`: validate order details and create a PENDING `Ticket`.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`厨房服务`: 验证订单详情并创建一个`PENDING`的`票据`。'
- en: 'Monolith: authorize consumer’s credit card.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体：授权消费者的信用卡。
- en: '`Kitchen Service`: change state of `Ticket` to `APPROVED`.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`厨房服务`: 将`票据`的状态更改为`APPROVED`。'
- en: '`Order Service`: change state of `Order` to `APPROVED`.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`订单服务`: 将`订单`的状态更改为`APPROVED`。'
- en: In this saga, the monolith’s transaction is still the pivot transaction. `Order
    Service` and `Kitchen Service` implement the compensatable transactions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个saga中，单体的事务仍然是枢纽事务。`订单服务`和`厨房服务`实现补偿性事务。
- en: 'We can even continue to refactor the monolith by extracting `Accounting Service`.
    If we extract this service, the `createOrder()` command uses the following saga:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过提取`会计服务`来继续重构单体。如果我们提取这个服务，`createOrder()`命令将使用以下saga：
- en: '`Order Service`: create an `Order` in an `APPROVAL_PENDING` state.'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Order Service`：创建一个处于 `APPROVAL_PENDING` 状态的 `Order`。'
- en: '`Consumer Service`: verify that the consumer can place an order.'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Consumer Service`：验证消费者能否下订单。'
- en: '`Kitchen Service`: validate order details and create a PENDING `Ticket`.'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Kitchen Service`：验证订单详情并创建一个 PENDING 的 `Ticket`。'
- en: '`Accounting Service`: authorize consumer’s credit card.'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Accounting Service`：授权消费者的信用卡。'
- en: '`Kitchen Service`: change state of `Ticket` to `APPROVED`.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Kitchen Service`：将 `Ticket` 的状态更改为 `APPROVED`。'
- en: '`Order Service`: change state of `Order` to `APPROVED`.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Order Service`：将 `Order` 的状态更改为 `APPROVED`。'
- en: As you can see, by carefully sequencing the extractions, you can avoid using
    sagas that require making complex changes to the monolith. Let’s now look at how
    to handle security when migrating to a microservice architecture.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过仔细排序提取，您可以避免使用需要修改单体应用的复杂 sagas。现在让我们看看如何在迁移到微服务架构时处理安保问题。
- en: 13.3.3\. Handling authentication and authorization
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.3. 处理身份验证和授权
- en: Another design issue you need to tackle when refactoring a monolithic application
    to a microservice architecture is adapting the monolith’s security mechanism to
    support the services. [Chapter 11](kindle_split_019.xhtml#ch11) describes how
    to handle security in a microservice architecture. A microservices-based application
    uses tokens, such as JSON Web tokens (JWT), to pass around user identity. That’s
    quite different than a typical traditional, monolithic application that uses in-memory
    session state and passes around the user identity using a thread local. The challenge
    when transforming a monolithic application to a microservice architecture is that
    you need to support both the monolithic and JWT-based security mechanisms simultaneously.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当将单体应用重构为微服务架构时，需要解决的另一个设计问题是将单体应用的安保机制适应以支持服务。[第 11 章](kindle_split_019.xhtml#ch11)
    描述了如何在微服务架构中处理安保问题。基于微服务的应用程序使用令牌，例如 JSON Web 令牌 (JWT)，来传递用户身份。这与典型的传统单体应用大不相同，后者使用内存中的会话状态并通过线程局部传递用户身份。将单体应用转换为微服务架构的挑战在于，你需要同时支持单体和基于
    JWT 的安保机制。
- en: Fortunately, there’s a straightforward way to solve this problem that only requires
    you to make one small change to the monolith’s login request handler. [Figure
    13.13](#ch13fig13) shows how this works. The login handler returns an additional
    cookie, which in this example I call `USERINFO`, that contains user information,
    such as the user ID and roles. The browser includes that cookie in every request.
    The API gateway extracts the information from the cookie and includes it in the
    HTTP requests that it makes to a service. As a result, each service has access
    to the needed user information.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个简单直接的方法可以解决这个问题，只需对单体应用的登录请求处理程序进行一个小改动。[图 13.13](#ch13fig13) 展示了这是如何工作的。登录处理程序返回一个额外的
    cookie，在这个例子中我称之为 `USERINFO`，它包含用户信息，如用户 ID 和角色。浏览器在每次请求中都包含该 cookie。API 网关从 cookie
    中提取信息，并将其包含在它向服务发出的 HTTP 请求中。因此，每个服务都可以访问所需用户信息。
- en: Figure 13.13\. The login handler is enhanced to set a `USERINFO` cookie, which
    is a JWT containing user information. `API Gateway` transfers the `USERINFO` cookie
    to an authorization header when it invokes a service.
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.13. 登录处理程序已增强以设置一个 `USERINFO` cookie，它是一个包含用户信息的 JWT。`API Gateway` 在调用服务时将
    `USERINFO` cookie 转移到授权头中。
- en: '![](Images/13fig13_alt.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.13 说明](Images/13fig13_alt.jpg)'
- en: 'The sequence of events is as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 事件序列如下：
- en: The client makes a login request containing the user’s credentials.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发出包含用户凭证的登录请求。
- en: '`API Gateway` routes the login request to the FTGO monolith.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`API Gateway` 将登录请求路由到 FTGO 单体应用。'
- en: The monolith returns a response containing the `JSESSIONID` session cookie and
    the `USERINFO` cookie, which contains the user information, such as ID and roles.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体应用返回一个包含 `JSESSIONID` 会话 cookie 和 `USERINFO` cookie 的响应，其中包含用户信息，如 ID 和角色。
- en: The client makes a request, which includes the `USERINFO` cookie, in order to
    invoke an operation.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发出一个包含 `USERINFO` cookie 的请求，以调用一个操作。
- en: '`API Gateway` validates the `USERINFO` cookie and includes it in the `Authorization`
    header of the request that it makes to the service. The service validates the
    `USERINFO` token and extracts the user information.'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`API Gateway` 验证 `USERINFO` cookie，并将其包含在它向服务发出的请求的 `Authorization` 头中。服务验证
    `USERINFO` 令牌并提取用户信息。'
- en: Let’s look at `LoginHandler` and `API Gateway` in more detail.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看 `LoginHandler` 和 `API Gateway`。
- en: The monolith’s LoginHandler sets the USERINFO cookie
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 单体应用的 LoginHandler 设置 USERINFO cookie
- en: '`LoginHandler` processes the `POST` of the user’s credentials. It authenticates
    the user and stores information about the user in the session. It’s often implemented
    by a security framework, such as Spring Security or Passport for NodeJS. If the
    application is configured to use the default in-memory session, the HTTP response
    sets a session cookie, such as `JSESSIONID`. In order to support the migration
    to microservices, `LoginHandler` must also set the `USERINFO` cookie containing
    the JWT that describes the user.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginHandler`处理用户的凭证的`POST`请求。它验证用户并将在会话中存储有关用户的信息。这通常由安全框架实现，例如Spring Security或NodeJS的Passport。如果应用程序配置为使用默认的内存会话，HTTP响应将设置一个会话cookie，例如`JSESSIONID`。为了支持迁移到微服务，`LoginHandler`还必须设置包含描述用户的JWT的`USERINFO`cookie。'
- en: The API gateway maps the USERINFO cookie to the Authorization header
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: API网关将USERINFO cookie映射到Authorization头
- en: The API gateway, as described in [chapter 8](kindle_split_016.xhtml#ch08), is
    responsible for request routing and API composition. It handles each request by
    making one or more requests to the monolith and the services. When the API gateway
    invokes a service, it validates the `USERINFO` cookie and passes it to the service
    in the HTTP request’s `Authorization` header. By mapping the cookie to the `Authorization`
    header, the API gateway ensures that it passes the user identity to the service
    in a standard way that’s independent of the type of client.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如第8章所述，API网关负责请求路由和API组合。它通过向单体和各个服务发送一个或多个请求来处理每个请求。当API网关调用一个服务时，它会验证`USERINFO`cookie并将其传递给服务，在HTTP请求的`Authorization`头中。通过将cookie映射到`Authorization`头，API网关确保以标准方式将用户身份传递给服务，这种方式与客户端的类型无关。
- en: Eventually, we’ll most likely extract login and user management into services.
    But as you can see, by only making one small change to the monolith’s login handler,
    it’s now possible for services to access user information. This enables you focus
    on developing services that provide the greatest value to the business and delay
    extracting less valuable services, such as user management.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们很可能会将登录和用户管理提取到服务中。但正如你所看到的，通过仅对单体登录处理程序进行一个小改动，现在服务就可以访问用户信息了。这使得你可以专注于开发为业务提供最大价值的服务，并推迟提取价值较低的服务，例如用户管理。
- en: Now that we’ve looked at how to handle security when refactoring to microservices,
    let’s see an example of implementing a new feature as a service.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了在重构到微服务时如何处理安全问题，让我们来看一个将新功能作为服务实现的示例。
- en: '13.4\. Implementing a new feature as a service: handling misdelivered orders'
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4. 将新功能作为服务实现：处理误送订单
- en: Let’s say you’ve been tasked with improving how FTGO handles misdelivered orders.
    A growing number of customers have been complaining about how customer service
    handles orders not being delivered. The majority of orders are delivered on time,
    but from time to time orders are either delivered late or not at all. For example,
    the courier gets delayed by unexpectedly bad traffic, so the order is picked up
    and delivered late. Or perhaps by the time the courier arrives at the restaurant,
    it’s closed, and the delivery can’t be made. To make matters worse, the first
    time customer service hears about the misdelivery is when they receive an angry
    email from an unhappy customer.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被分配去改进FTGO处理误送订单的方式。越来越多的客户抱怨客户服务如何处理未能送达的订单。大多数订单都能按时送达，但有时订单要么送达晚，要么根本没送达。例如，快递员因意外糟糕的交通而延误，所以订单被取走并晚些时候送达。或者，也许当快递员到达餐厅时，餐厅已经关门，无法完成配送。更糟糕的是，客户服务第一次听说误送是在收到一个愤怒的客户发来的电子邮件时。
- en: '|  |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**A true story: My missing ice cream**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个真实的故事：我丢失的冰淇淋**'
- en: One Saturday night I was feeling lazy and placed an order using a well-known
    food delivery app to have ice cream delivered from Smitten. It never showed up.
    The only communication from the company was an email the next morning saying my
    order had been canceled. I also got a voicemail from a very confused customer
    service agent who clearly didn’t know what she was calling about. Perhaps the
    call was prompted by one of my tweets describing what happened. Clearly, the delivery
    company had not established any mechanisms for properly handling inevitable mistakes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一个周六晚上，我感到很懒，使用一个知名的食品配送应用从Smitten订购了冰淇淋，但从未送达。公司唯一的沟通是在第二天早上发来的电子邮件，说我的订单已被取消。我还接到一个来自非常困惑的客户服务代表的语音邮件，显然她不知道她为什么要打电话。也许这个电话是由我的一条推文触发的，描述了发生的事情。显然，配送公司没有建立任何处理不可避免的错误的机制。
- en: '|  |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The root cause for many of these delivery problems is the primitive delivery
    scheduling algorithm used by the FTGO application. A more sophisticated scheduler
    is under development but won’t be finished for a few months. The interim solution
    is for FTGO to proactively handle delayed or canceled orders by apologizing to
    the customer, and in some cases offering compensation before the customer complains.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 许多配送问题的根本原因是FTGO应用使用的原始配送调度算法。一个更复杂的调度器正在开发中，但还需要几个月才能完成。临时解决方案是FTGO通过向客户道歉，并在某些情况下在客户投诉之前提供补偿，来主动处理延迟或取消的订单。
- en: 'Your job is to implement a new feature that will do the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是实现一个新功能，该功能将执行以下操作：
- en: Notify the customer when their order won’t be delivered on time.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当订单无法按时交付时，通知客户。
- en: Notify the customer when their order can’t be delivered because it can’t be
    picked up before the restaurant closes.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当订单因为无法在餐厅关门前取货而无法交付时，通知客户。
- en: Notify customer service when an order can’t be delivered on time so that they
    can proactively rectify the situation by compensating the customer.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当订单无法按时交付时，通知客户服务，以便他们可以通过补偿客户来主动纠正情况。
- en: Track delivery statistics.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪配送统计数据。
- en: This new feature is fairly simple. The new code must track the state of each
    `Order`, and if an `Order` can’t be delivered as promised, the code must notify
    the customer and customer support, by, for example, sending an email.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新功能相当简单。新的代码必须跟踪每个 `Order` 的状态，如果 `Order` 无法按承诺交付，代码必须通过例如发送电子邮件的方式通知客户和客户支持。
- en: 'But how—or perhaps more precisely, *where*—should you implement this new feature?
    One approach is to implement a new module in the monolith. The problem there is
    that developing and testing this code will be difficult. What’s more, this approach
    increases the size of the monolith and thereby makes monolith hell even worse.
    Remember the Law of Holes from earlier: when you’re in a hole, it’s best to stop
    digging. Rather than make the monolith larger, a much better approach is to implement
    these new features as a service.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 但你应该如何——或者更确切地说，*在哪里*——实现这个新功能呢？一种方法是在单体中实现一个新的模块。那里的问题是开发和测试此代码将很困难。更重要的是，这种方法增加了单体的大小，从而使单体地狱变得更加糟糕。记住之前提到的洞穴法则：当你陷入洞穴时，最好的办法是停止挖掘。与其使单体更大，不如将这些新功能作为服务来实现是一个更好的方法。
- en: 13.4.1\. The design of Delayed Delivery Service
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.1. 延迟配送服务的设计
- en: We’ll implement this feature as a service called `Delayed Order Service`. [Figure
    13.14](#ch13fig14) shows the FTGO application’s architecture after implementing
    this service. The application consists of the FTGO monolith, the new `Delayed
    Delivery Service`, and an `API Gateway`. `Delayed Delivery Service` has an API
    that defines a single query operation called `getDelayedOrders()`, which returns
    the currently delayed or undeliverable orders. `API Gateway` routes the `getDelayedOrders()`
    request to the service and all other requests to the monolith. The integration
    glue provides `Delayed Order Service` with access to the monolith’s data.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个功能实现为一个名为 `Delayed Order Service` 的服务。[图13.14](#ch13fig14) 展示了在实现此服务后FTGO应用的架构。该应用由FTGO单体应用、新的
    `Delayed Delivery Service` 和一个 `API Gateway` 组成。`Delayed Delivery Service` 有一个API，定义了一个名为
    `getDelayedOrders()` 的单一查询操作，该操作返回当前延迟或无法交付的订单。`API Gateway` 将 `getDelayedOrders()`
    请求路由到服务，并将所有其他请求路由到单体。集成胶水为 `Delayed Order Service` 提供了对单体数据的访问。
- en: Figure 13.14\. The design of `Delayed Delivery Service`. The integration glue
    provides `Delayed Delivery Service` access to data owned by the monolith, such
    as the `Order` and `Restaurant` entities, and the customer contact information.
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.14\. `Delayed Delivery Service` 的设计。集成粘合剂为 `Delayed Delivery Service` 提供了对单体拥有的数据的访问权限，例如
    `Order` 和 `Restaurant` 实体以及客户联系信息。
- en: '![](Images/13fig14_alt.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.14](Images/13fig14_alt.jpg)'
- en: The `Delayed Order Service`’s domain model consists of various entities, including
    `DelayedOrderNotification`, `Order`, and `Restaurant`. The core logic is implemented
    by the `DelayedOrderService` class. It’s periodically invoked by a timer to find
    orders that won’t be delivered on time. It does that by querying `Orders` and
    `Restaurants`. If an `Order` can’t be delivered on time, `DelayedOrderService`
    notifies the consumer and customer service.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delayed Order Service` 的领域模型由各种实体组成，包括 `DelayedOrderNotification`、`Order`
    和 `Restaurant`。核心逻辑由 `DelayedOrderService` 类实现。它由定时器定期调用以查找无法按时交付的订单。它是通过查询 `Orders`
    和 `Restaurants` 来做到这一点的。如果一个 `Order` 无法按时交付，`DelayedOrderService` 会通知消费者和客户服务。'
- en: '`Delayed Order Service` doesn’t own the `Order` and `Restaurant` entities.
    Instead, this data is replicated from the FTGO monolith. What’s more, the service
    doesn’t store the customer contact information, but instead retrieves it from
    the monolith. Let’s look at the design of the integration glue that provides `Delayed
    Order Service` access to the monolith’s data.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delayed Order Service` 不拥有 `Order` 和 `Restaurant` 实体。相反，这些数据是从 FTGO 单体复制的。更重要的是，该服务不存储客户联系信息，而是从单体中检索它。让我们看看为
    `Delayed Order Service` 提供单体数据访问权限的集成粘合剂的设计。'
- en: 13.4.2\. Designing the integration glue for Delayed Delivery Service
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.2\. 为 `Delayed Delivery Service` 设计集成粘合剂
- en: Even though a service that implements a new feature defines its own entity classes,
    it usually accesses data that’s owned by the monolith. `Delayed Delivery Service`
    is no exception. It has a `DelayedOrderNotification` entity, which represents
    a notification that it has sent to the consumer. But as I just mentioned, its
    `Order` and `Restaurant` entities replicate data from the FTGO monolith. It also
    needs to query user contact information in order to notify the user. Consequently,
    we need to implement integration glue that enables `Delivery Service` to access
    the monolith’s data.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 即使实现新功能的服务的定义了自己的实体类，它通常也会访问单体拥有的数据。`Delayed Delivery Service` 也不例外。它有一个 `DelayedOrderNotification`
    实体，代表它发送给消费者的通知。但正如我刚才提到的，它的 `Order` 和 `Restaurant` 实体复制了 FTGO 单体的数据。它还需要查询用户联系信息以便通知用户。因此，我们需要实现集成粘合剂，使
    `Delivery Service` 能够访问单体的数据。
- en: '[Figure 13.15](#ch13fig15) shows the design of the integration glue. The FTGO
    monolith publishes `Order` and `Restaurant` domain events. `Delivery Service`
    consumes these events and updates its replicas of those entities. The FTGO monolith
    implements a REST endpoint for querying the customer contact information. `Delivery
    Service` calls this endpoint when it needs to notify a user that their order cannot
    be delivered on time.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13.15](#ch13fig15) 展示了集成粘合剂的设计。FTGO 单体发布 `Order` 和 `Restaurant` 领域事件。`Delivery
    Service` 消费这些事件并更新其那些实体的副本。FTGO 单体实现了一个用于查询客户联系信息的 REST 端点。`Delivery Service`
    在需要通知用户他们的订单无法按时交付时调用此端点。'
- en: Figure 13.15\. The integration glue provides `Delayed Delivery Service` with
    access to the data owned by the monolith.
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.15\. 集成粘合剂为 `Delayed Delivery Service` 提供了对单体拥有的数据的访问权限。
- en: '![](Images/13fig15_alt.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.15](Images/13fig15_alt.jpg)'
- en: Let’s look at the design of each part of the integration, starting with the
    REST API for retrieving customer contact information.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看集成每个部分的设计，从检索客户联系信息的 REST API 开始。
- en: Querying customer contact information using CustomerContactInfoRepository
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 CustomerContactInfoRepository 查询客户联系信息
- en: As described in [section 13.3.1](#ch13lev2sec6), there are a couple of different
    ways that a service such as `Delayed Delivery Service` could read the monolith’s
    data. The simplest option is for `Delayed Order Service` to retrieve data using
    the monolith’s query API. This approach makes sense when retrieving the `User`
    contact information. There aren’t any latency or performance, issues because `Delayed
    Delivery Service` rarely needs to retrieve a user’s contact information, and the
    amount of data is quite small.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 13.3.1 节](#ch13lev2sec6) 所述，服务如 `Delayed Delivery Service` 读取单体应用数据的方式有几种。最简单的方法是
    `Delayed Order Service` 使用单体应用的查询 API 来检索数据。当检索 `User` 联系信息时，这种方法是合理的。由于 `Delayed
    Delivery Service` 很少需要检索用户的联系信息，且数据量相当小，因此不存在延迟或性能问题。
- en: '`CustomerContactInfoRepository` is an interface that enables `Delayed Delivery
    Service` to retrieve a consumer’s contact info. It’s implemented by a `CustomerContactInfoProxy`,
    which retrieves the user information by invoking the monolith’s `getCustomerContactInfo()`
    REST endpoint.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerContactInfoRepository` 是一个接口，它使 `Delayed Delivery Service` 能够检索消费者的联系信息。它通过一个
    `CustomerContactInfoProxy` 实现，该代理通过调用单体应用的 `getCustomerContactInfo()` REST 端点来检索用户信息。'
- en: Publishing and consuming Order and Restaurant domain events
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 发布和消费订单和餐厅领域事件
- en: Unfortunately, it isn’t practical for `Delayed Delivery Service` to query the
    monolith for the state of all open `Orders` and `Restaurant` hours. That’s because
    it’s inefficient to repeatedly transfer a large amount of data over the network.
    Consequently, `Delayed Delivery Service` must use the second, more complex option
    and maintain a replica of `Orders` and `Restaurants` by subscribing to events
    published by the monolith. It’s important to remember that the replica isn’t a
    complete copy of the data from the monolith—it just stores a small subset of the
    attributes of `Order` and `Restaurant` entities.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于 `Delayed Delivery Service` 来说，查询单体应用以获取所有开放 `Orders` 和 `Restaurant`
    小时的状态并不实用。这是因为反复在网络中传输大量数据效率低下。因此，`Delayed Delivery Service` 必须使用第二种更复杂的方法，通过订阅单体发布的事件来维护
    `Orders` 和 `Restaurants` 的副本。重要的是要记住，副本并不是单体数据的一个完整副本——它只存储 `Order` 和 `Restaurant`
    实体属性的一个小子集。
- en: As described earlier in [section 13.3.1](#ch13lev2sec6), there are a couple
    of different ways that we can change the FTGO monolith so that it publishes `Order`
    and `Restaurant` domain events. One option is to modify all the places in the
    monolith that update `Orders` and `Restaurants` to publish high-level domain events.
    The second option is to tail the transaction log to replicate the changes as events.
    In this particular scenario, we need to synchronize the two databases. We don’t
    require the FTGO monolith to publish high-level domain events, so either approach
    is fine.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述 [第 13.3.1 节](#ch13lev2sec6)，我们可以通过几种不同的方式修改 FTGO 单体应用，使其发布 `Order` 和 `Restaurant`
    领域事件。一种选择是修改单体应用中所有更新 `Orders` 和 `Restaurants` 的地方，以发布高级领域事件。第二种选择是跟踪事务日志以将更改作为事件进行复制。在这个特定场景中，我们需要同步两个数据库。我们不需要
    FTGO 单体应用发布高级领域事件，所以两种方法都可以。
- en: '`Delayed Order Service` implements event handlers that subscribe to events
    from the monolith and update its `Order` and `Restaurant` entities. The details
    of the event handlers depend on whether the monolith publishes specific high-level
    events or low-level change events. In either case, you can think of an event handler
    as translating an event in the monolith’s bounded context to the update of an
    entity in the service’s bounded context.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delayed Order Service` 实现了事件处理器，这些处理器订阅来自单体应用的事件，并更新其 `Order` 和 `Restaurant`
    实体。事件处理器的细节取决于单体是否发布特定的低级事件或高级事件。在任一情况下，你可以将事件处理器视为将单体应用边界上下文中的事件转换为服务边界上下文中实体的更新。'
- en: An important benefit of using a replica is that it enables `Delayed Order Service`
    to efficiently query the orders and the restaurant opening hours. One drawback,
    however, is that it’s more complex. Another drawback is that it requires the monolith
    to publish the necessary `Order` and `Restaurant` events. Fortunately, because
    `Delayed Delivery Service` only needs what’s essentially a subset of the columns
    of the `ORDERS` and `RESTAURANT` tables, we shouldn’t encounter the problems described
    in [section 13.3.1](#ch13lev2sec6).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用副本的一个重要好处是它使`Delayed Order Service`能够高效地查询订单和餐厅营业时间。然而，一个缺点是它更复杂。另一个缺点是它需要单体发布必要的`Order`和`Restaurant`事件。幸运的是，因为`Delayed
    Delivery Service`只需要`ORDERS`和`RESTAURANT`表的基本子集列，我们不应该遇到[第13.3.1节](#ch13lev2sec6)中描述的问题。
- en: Implementing a new feature such as delayed order management as a standalone
    service accelerates its development, testing, and deployment. What’s more, it
    enables you to implement the feature using a brand new technology stack instead
    of the monolith’s older one. It also stops the monolith from growing. Delayed
    order management is just one of many new features planned for the FTGO application.
    The FTGO team can implement many of these features as separate services.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 将新功能如延迟订单管理作为一个独立服务实现可以加速其开发、测试和部署。更重要的是，它允许你使用全新的技术栈而不是单体较旧的技术栈来实现该功能。它还可以阻止单体继续增长。延迟订单管理只是FTGO应用程序计划中的许多新功能之一。FTGO团队可以将这些功能中的许多作为独立服务实现。
- en: Unfortunately, you can’t implement all changes as new services. Quite often
    you must make extensive changes to the monolith to implement new features or change
    existing features. Any development involving the monolith will mostly likely be
    slow and painful. If you want to accelerate the delivery of these features, you
    must break up the monolith by migrating functionality from the monolith into services.
    Let’s look at how to do that.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你不能将所有更改都作为新服务实现。很多时候，你必须对单体进行大量更改来实现新功能或更改现有功能。任何涉及单体的开发都可能很慢且痛苦。如果你想加速这些功能的交付，你必须通过将功能从单体迁移到服务中来拆分单体。让我们看看如何做到这一点。
- en: '13.5\. Breaking apart the monolith: extracting delivery management'
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5\. 拆分单体：提取配送管理
- en: To accelerate the delivery of features that are implemented by a monolith, you
    need to break up the monolith into services. For example, let’s imagine that you
    want to enhance FTGO delivery management by implementing a new routing algorithm.
    A major obstacle to developing delivery management is that it’s entangled with
    order management and is part of the monolithic code base. Developing, testing,
    and deploying delivery management is likely to be slow. In order to accelerate
    its development, you need to extract delivery management into a `Delivery Service`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加速实现单体应用的功能交付，你需要将单体应用拆分成服务。例如，让我们设想你希望通过实现一个新的路由算法来增强FTGO的配送管理。开发配送管理的一个主要障碍是它与订单管理纠缠在一起，并且是单体代码库的一部分。开发和部署配送管理可能会很慢。为了加速其开发，你需要将配送管理提取为一个`Delivery
    Service`。
- en: I start this section by describing delivery management and how it’s currently
    embedded within the monolith. Next I discuss the design of the new, standalone
    `Delivery Service` and its API. I then describe how `Delivery Service` and the
    FTGO monolith collaborate. Finally I talk about some of the changes we need to
    make to the monolith to support `Delivery Service`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个部分开始描述配送管理以及它目前如何在单体中嵌入。接下来，我讨论新的独立`Delivery Service`及其API的设计。然后，我描述`Delivery
    Service`和FTGO单体如何协作。最后，我谈谈我们需要对单体进行的一些更改以支持`Delivery Service`。
- en: Let’s begin by reviewing the existing design.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从回顾现有设计开始。
- en: 13.5.1\. Overview of existing delivery management functionality
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.5.1\. 现有配送管理功能概述
- en: Delivery management is responsible for scheduling the couriers that pick up
    orders at restaurants and deliver them to consumers. Each courier has a plan that
    is a schedule of pickup and deliver actions. A *pickup* action tells the `Courier`
    to pick up an order from a restaurant at a particular time. A *deliver* action
    tells the `Courier` to deliver an order to a consumer. The plans are revised whenever
    orders are placed, canceled, or revised, and as the location and availability
    of couriers changes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 配送管理负责安排在餐厅取订单并将其递送给消费者的快递员。每个快递员都有一个计划，即取货和配送行动的日程表。一个*取货*行动告诉`Courier`在特定时间从餐厅取订单。一个*配送*行动告诉`Courier`将订单递送给消费者。每当下单、取消或修改订单，以及快递员的位置和可用性发生变化时，计划都会进行修订。
- en: Delivery management is one of the oldest parts of the FTGO application. As [figure
    13.16](#ch13fig16) shows, it’s embedded within order management. Much of the code
    for managing deliveries is in `OrderService`. What’s more, there’s no explicit
    representation of a `Delivery`. It’s embedded within the `Order` entity, which
    has various delivery-related fields, such as `scheduledPickupTime` and `scheduledDeliveryTime`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 配送管理是FTGO应用程序中最古老的组成部分之一。如图13.16所示，它嵌入在订单管理中。管理配送的大部分代码都在`OrderService`中。更重要的是，没有显式地表示`Delivery`。它嵌入在`Order`实体中，该实体包含各种与配送相关的字段，例如`scheduledPickupTime`和`scheduledDeliveryTime`。
- en: Figure 13.16\. Delivery management is entangled with order management within
    the FTGO monolith.
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.16。配送管理在FTGO单体中与订单管理交织在一起。
- en: '![](Images/13fig16_alt.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig16_alt.jpg)'
- en: 'Numerous commands implemented by the monolith invoke delivery management, including
    the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 单体实现了许多命令，包括以下内容调用配送管理：
- en: '**`acceptOrder()`—** Invoked when a restaurant accepts an order and commits
    to preparing it by a certain time. This operation invokes delivery management
    to schedule a delivery.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`acceptOrder()`—** 当餐厅接受订单并承诺在特定时间内准备时调用。此操作调用配送管理以安排配送。'
- en: '**`cancelOrder()`—** Invoked when a consumer cancels an order. If necessary,
    it cancels the delivery.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`cancelOrder()`—** 当消费者取消订单时调用。如果需要，它将取消配送。'
- en: '**`noteCourierLocationUpdated()`—** Invoked by the courier’s mobile application
    to update the courier’s location. It triggers the rescheduling of deliveries.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`noteCourierLocationUpdated()`—** 由快递员的移动应用程序调用以更新快递员的位置。它触发了配送的重新安排。'
- en: '**`noteCourierAvailabilityChanged()`—** Invoked by the courier’s mobile application
    to update the courier’s availability. It triggers the rescheduling of deliveries.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`noteCourierAvailabilityChanged()`—** 由快递员的移动应用程序调用以更新快递员的可用性。它触发了配送的重新安排。'
- en: 'Also, various queries retrieve data maintained by delivery management, including
    the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，各种查询检索由配送管理维护的数据，包括以下内容：
- en: '**`getCourierPlan()`—** Invoked by the courier’s mobile application and returns
    the courier’s plan'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`getCourierPlan()`—** 由快递员的移动应用程序调用并返回快递员的计划。'
- en: '**`getOrderStatus()`—** Returns the order’s status, which includes delivery-related
    information such as the assigned courier and the ETA'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`getOrderStatus()`—** 返回订单的状态，包括与配送相关的信息，例如指定的快递员和预计到达时间（ETA）。'
- en: '**`getOrderHistory()`—** Returns similar information as `getOrderStatus()`
    except about multiple orders'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`getOrderHistory()`—** 返回与`getOrderStatus()`类似的信息，但关于多个订单。'
- en: Quite often what’s extracted into a service is, as mentioned in [section 13.2.3](#ch13lev2sec5),
    an entire vertical slice, with controllers at the top and database tables at the
    bottom. We could consider the `Courier`-related commands and queries to be part
    of delivery management. After all, delivery management creates the courier plans
    and is the primary consumer of the `Courier` location and availability information.
    But in order to minimize the development effort, we’ll leave those operations
    in the monolith and just extract the core of the algorithm. Consequently, the
    first iteration of `Delivery Service` won’t expose a publicly accessible API.
    Instead, it will only be invoked by the monolith. Next, let’s explore the design
    of `Delivery Service`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见的是，提取到服务中的是，如[第13.2.3节](#ch13lev2sec5)中提到的，一个完整的垂直切片，顶部是控制器，底部是数据库表。我们可以考虑与`Courier`相关的命令和查询是配送管理的一部分。毕竟，配送管理创建快递员计划，并且是`Courier`位置和可用信息的主要消费者。但为了最小化开发工作量，我们将保留这些操作在单体中，并仅提取算法的核心。因此，`Delivery
    Service`的第一迭代不会公开提供API。相反，它将仅由单体调用。接下来，让我们探索`Delivery Service`的设计。
- en: 13.5.2\. Overview of Delivery Service
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.5.2. 配送服务概述
- en: The proposed new `Delivery Service` is responsible for scheduling, rescheduling,
    and canceling deliveries. [Figure 13.17](#ch13fig17) shows a high-level view of
    the architecture of the FTGO application after extracting `Delivery Service`.
    The architecture consists of the FTGO monolith and `Delivery Service`. They collaborate
    using the integration glue, which consists of APIs in both the service and monolith.
    `Delivery Service` has its own domain model and database.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 建议的新`Delivery Service`负责调度、重新调度和取消交付。[图13.17](#ch13fig17)显示了提取`Delivery Service`后的FTGO应用程序的架构视图。该架构由FTGO单体和`Delivery
    Service`组成。它们通过服务中的API和单体中的API组成的集成胶水进行协作。`Delivery Service`有自己的领域模型和数据库。
- en: Figure 13.17\. The high-level view of the FTGO application after extracting
    `Delivery Service`. The FTGO monolith and `Delivery Service` collaborate using
    the integration glue, which consists of APIs in each of them. The two key decisions
    that need to be made are which functionality and data are moved to `Delivery Service`
    and how do the monolith and `Delivery Service` collaborate via APIs?
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.17\. 提取`Delivery Service`后的FTGO应用程序的高级视图。FTGO单体和`Delivery Service`通过它们各自的API组成的集成胶水进行协作。需要做出的两个关键决策是哪些功能和数据被移动到`Delivery
    Service`，以及单体和`Delivery Service`如何通过API进行协作？
- en: '![](Images/13fig17_alt.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig17_alt.jpg)'
- en: 'In order to flesh out this architecture and determine the service’s domain
    model, we need to answer the following questions:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完善这个架构并确定服务的领域模型，我们需要回答以下问题：
- en: Which behavior and data are moved to `Delivery Service`?
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些行为和数据被移动到`Delivery Service`？
- en: What API does `Delivery Service` expose to the monolith?
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Delivery Service`向单体暴露了哪些API？'
- en: What API does the monolith expose to `Delivery Service`?
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该单体向`Delivery Service`暴露了哪些API？
- en: These issues are interrelated because the distribution of responsibilities between
    the monolith and the service affects the APIs. For instance, `Delivery Service`
    will need to invoke an API provided by the monolith to access the data in the
    monolith’s database and vice versa. Later, I’ll describe the design of the integration
    glue that enables `Delivery Service` and the FTGO monolith to collaborate. But
    first, let’s look at the design of `Delivery Service`’s domain model.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题是相互关联的，因为单体和服务之间责任分配的分布会影响API。例如，`Delivery Service`将需要调用单体提供的API来访问单体数据库中的数据，反之亦然。稍后，我将描述使`Delivery
    Service`和FTGO单体协作的集成胶水的结构。但首先，让我们看看`Delivery Service`的领域模型设计。
- en: 13.5.3\. Designing the Delivery Service domain model
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.5.3\. 设计`Delivery Service`领域模型
- en: To be able to extract delivery management, we first need to identify the classes
    that implement it. Once we’ve done that, we can decide which classes to move to
    `Delivery Service` to form its domain logic. In some cases, we’ll need to split
    classes. We’ll also need to decide which data to replicate between the service
    and the monolith.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够提取交付管理，我们首先需要识别实现它的类。一旦我们做到了这一点，我们就可以决定哪些类要移动到`Delivery Service`以形成其领域逻辑。在某些情况下，我们需要拆分类。我们还需要决定在服务与单体之间复制哪些数据。
- en: Let’s start by identifying the classes that implement delivery management.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先识别实现交付管理的类。
- en: Identifying which entities and their fields are part of delivery management
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 确定哪些实体及其字段是交付管理的一部分
- en: The first step in the process of designing `Delivery Service` is to carefully
    review the delivery management code and identify the participating entities and
    their fields. [Figure 13.18](#ch13fig18) shows the entities and fields that are
    part of delivery management. Some fields are inputs to the delivery-scheduling
    algorithm, and others are the outputs. The figure shows which of those fields
    are also used by other functionality implemented by the monolith.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 设计`Delivery Service`的第一步是仔细审查交付管理代码，并确定参与实体及其字段。[图13.18](#ch13fig18)显示了交付管理的一部分实体和字段。一些字段是交付调度算法的输入，而其他字段是输出。该图显示了哪些字段也被单体实现的其他功能使用。
- en: Figure 13.18\. The entities and fields that are accessed by delivery management
    and other functionality implemented by the monolith. A field can be read or written
    or both. It can be accessed by delivery management, the monolith, or both.
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.18\. 由单体实现的交付管理和其他功能访问的实体和字段。字段可以被读取或写入，或者两者都可以。它可以被交付管理、单体或两者访问。
- en: '![](Images/13fig18_alt.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig18_alt.jpg)'
- en: The delivery scheduling algorithm reads various attributes including the `Order`’s
    `restaurant`, `promisedDeliveryTime`, and `deliveryAddress`, and the `Courier`’s
    `location`, `availability`, and current plans. It updates the `Courier`’s plans,
    the `Order`’s `scheduledPickupTime`, and `scheduledDeliveryTime`. As you can see,
    the fields used by delivery management are also used by the monolith.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 配送调度算法读取各种属性，包括 `Order` 的 `restaurant`、`promisedDeliveryTime` 和 `deliveryAddress`，以及
    `Courier` 的 `location`、`availability` 和当前计划。它更新 `Courier` 的计划、`Order` 的 `scheduledPickupTime`
    和 `scheduledDeliveryTime`。如您所见，配送管理使用的字段也被单体应用使用。
- en: Deciding which data to migrate to Delivery Service
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 决定哪些数据迁移到 `Delivery Service`
- en: Now that we’ve identified which entities and fields participate in delivery
    management, the next step is to decide which of them we should move to the service.
    In an ideal scenario, the data accessed by the service is used exclusively by
    the service, so we could simply move that data to the service and be done. Sadly,
    it’s rarely that simple, and this situation is no exception. All the entities
    and fields used by the delivery management are also used by other functionality
    implemented by the monolith.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了参与配送管理的实体和字段，下一步就是决定将哪些实体和字段移动到服务中。在理想情况下，服务访问的数据仅由服务使用，因此我们可以简单地将这些数据移动到服务中并完成。遗憾的是，这种情况很少见，这种情况也不例外。配送管理使用的所有实体和字段也被单体应用的其他功能使用。
- en: 'As a result, when determining which data to move to the service, we need to
    keep in mind two issues. The first is: how does the service access the data that
    remains in the monolith? The second is: how does the monolith access data that’s
    moved to the service? Also, as described earlier in [section 13.3](#ch13lev1sec3),
    we need to carefully consider how to maintain data consistency between the service
    and the monolith.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在确定要将哪些数据移动到服务中时，我们需要考虑两个问题。第一个问题是：服务如何访问单体应用中保留的数据？第二个问题是：单体应用如何访问已移动到服务中的数据？此外，如前文在
    [第 13.3 节](#ch13lev1sec3) 中所述，我们需要仔细考虑如何维护服务与单体应用之间的数据一致性。
- en: The essential responsibility of `Delivery Service` is managing courier plans
    and updating the `Order`’s `scheduledPickupTime` and `scheduledDeliveryTime` fields.
    It makes sense, therefore, for it to own those fields. We could also move the
    `Courier.location` and `Courier.availability` fields to `Delivery Service`. But
    because we’re trying to make the smallest possible change, we’ll leave those fields
    in the monolith for now.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delivery Service` 的基本责任是管理快递计划并更新 `Order` 的 `scheduledPickupTime` 和 `scheduledDeliveryTime`
    字段。因此，拥有这些字段是有意义的。我们还可以将 `Courier.location` 和 `Courier.availability` 字段移动到 `Delivery
    Service`。但由于我们正在尝试进行尽可能小的更改，因此我们将暂时保留这些字段在单体应用中。'
- en: The design of the Delivery Service domain logic
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Delivery Service` 领域逻辑的设计'
- en: '[Figure 13.19](#ch13fig19) shows the design of the `Delivery Service`’s domain
    model. The core of the service consists of domain classes such as `Delivery` and
    `Courier`. The `DeliveryServiceImpl` class is the entry point into the delivery
    management business logic. It implements the `DeliveryService` and `CourierService`
    interfaces, which are invoked by `DeliveryServiceEventsHandler` and `DeliveryServiceNotificationsHandlers`,
    described later in this section.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13.19](#ch13fig19) 展示了 `Delivery Service` 的领域模型设计。服务的核心由 `Delivery` 和 `Courier`
    等领域类组成。`DeliveryServiceImpl` 类是进入配送管理业务逻辑的入口点。它实现了 `DeliveryService` 和 `CourierService`
    接口，这些接口将由后续章节中描述的 `DeliveryServiceEventsHandler` 和 `DeliveryServiceNotificationsHandlers`
    调用。'
- en: Figure 13.19\. The design of the `Delivery Service`’s domain model
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.19\. `Delivery Service` 领域模型的设计
- en: '![](Images/13fig19_alt.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.19 的替代文本](Images/13fig19_alt.jpg)'
- en: The delivery management business logic is mostly code copied from the monolith.
    For example, we’ll copy the `Order` entity from the monolith to `Delivery Service`,
    rename it to `Delivery`, and delete all fields except those used by delivery management.
    We’ll also copy the `Courier` entity and delete most of its fields. In order to
    develop the domain logic for `Delivery Service`, we will need to untangle the
    code from the monolith. We’ll need to break numerous dependencies, which is likely
    to be time consuming. Once again, it’s a lot easier to refactor code when using
    a statically typed language, because the compiler will be your friend.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 配送管理业务逻辑主要是从单体应用中复制过来的代码。例如，我们将从单体应用中复制 `Order` 实体到 `Delivery Service`，并将其重命名为
    `Delivery`，删除所有除配送管理使用的字段外的所有字段。我们还将复制 `Courier` 实体并删除其大部分字段。为了开发 `Delivery Service`
    的领域逻辑，我们需要将代码从单体应用中解耦。我们需要打破许多依赖关系，这可能会很耗时。再次强调，使用静态类型语言重构代码要容易得多，因为编译器将成为你的朋友。
- en: '`Delivery Service` is not a standalone service. Let’s look at the design of
    the integration glue that enables `Delivery Service` and the FTGO monolith to
    collaborate.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delivery Service` 不是一个独立的服务。让我们看看使 `Delivery Service` 和 FTGO 单体应用协作的集成粘合剂的设计。'
- en: 13.5.4\. The design of the Delivery Service integration glue
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.5.4\. Delivery Service 集成粘合剂的设计
- en: The FTGO monolith needs to invoke `Delivery Service` to manage deliveries. The
    monolith also needs to exchange data with `Delivery Service`. This collaboration
    is enabled by the integration glue. [Figure 13.20](#ch13fig20) shows the design
    of the `Delivery Service` integration glue. `Delivery Service` has a delivery
    management API. It also publishes `Delivery` and `Courier` domain events. The
    FTGO monolith publishes `Courier` domain events.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO 单体应用需要调用 `Delivery Service` 来管理配送。单体应用还需要与 `Delivery Service` 交换数据。这种协作是通过集成粘合剂实现的。[图
    13.20](#ch13fig20) 展示了 `Delivery Service` 集成粘合剂的设计。`Delivery Service` 有一个配送管理
    API。该服务与 FTGO 单体应用通过交换领域事件同步数据。
- en: Figure 13.20\. The design of the `Delivery Service` integration glue. `Delivery
    Service` has a delivery management API. The service and the FTGO monolith synchronize
    data by exchanging domain events.
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.20\. `Delivery Service` 集成粘合剂的设计。`Delivery Service` 有一个配送管理 API。该服务和 FTGO
    单体应用通过交换领域事件同步数据。
- en: '![](Images/13fig20_alt.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig20_alt.jpg)'
- en: Let’s look at the design of each part of the integration glue, starting with
    `Delivery Service`’s API for managing deliveries.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看集成粘合剂的每个部分的设计，从 `Delivery Service` 管理配送的 API 开始。
- en: The design of the Delivery Service API
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Delivery Service API 的设计
- en: '`Delivery Service` must provide an API that enables the monolith to schedule,
    revise, and cancel deliveries. As you’ve seen throughout this book, the preferred
    approach is to use asynchronous messaging, because it promotes loose coupling
    and increases availability. One approach is for `Delivery Service` to subscribe
    to `Order` domain events published by the monolith. Depending on the type of the
    event, it creates, revises, and cancels a `Delivery`. A benefit of this approach
    is that the monolith doesn’t need to explicitly invoke `Delivery Service`. The
    drawback of relying on domain events is that it requires `Delivery Service` to
    know how each `Order` event impacts the corresponding `Delivery`.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delivery Service` 必须提供一个 API，使单体应用能够安排、修改和取消配送。正如你在本书中看到的，首选的方法是使用异步消息传递，因为它促进了松散耦合并增加了可用性。一种方法是为
    `Delivery Service` 订阅由单体应用发布的 `Order` 领域事件。根据事件类型，它创建、修改和取消一个 `Delivery`。这种方法的优点是单体应用不需要显式调用
    `Delivery Service`。依赖于领域事件的缺点是它要求 `Delivery Service` 了解每个 `Order` 事件如何影响相应的 `Delivery`。'
- en: 'A better approach is for `Delivery Service` to implement a notification-based
    API that enables the monolith to explicitly tell `Delivery Service` to create,
    revise, and cancel deliveries. `Delivery Service`’s API consists of a message
    notification channel and three message types: `ScheduleDelivery`, `ReviseDelivery`,
    or `CancelDelivery`. A notification message contains `Order` information needed
    by `Delivery Service`. For example, a `ScheduleDelivery` notification contains
    the pickup time and location and the delivery time and location. An important
    benefit of this approach is that `Delivery Service` doesn’t have detailed knowledge
    of the `Order` lifecycle. It’s entirely focused on managing deliveries and has
    no knowledge of orders.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是让`配送服务`实现一个基于通知的API，使单体可以明确地告诉`配送服务`创建、修改和取消配送。`配送服务`的API由一个消息通知通道和三种消息类型组成：`ScheduleDelivery`、`ReviseDelivery`或`CancelDelivery`。通知消息包含`配送服务`所需的信息。例如，`ScheduleDelivery`通知包含取货时间和地点以及配送时间和地点。这种方法的一个重要好处是`配送服务`对`订单`生命周期没有详细的了解。它完全专注于管理配送，并且对订单一无所知。
- en: This API isn’t the only way that `Delivery Service` and the FTGO monolith collaborate.
    They also need to exchange data.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API并不是`配送服务`和FTGO单体协作的唯一方式。它们还需要交换数据。
- en: How the Delivery Service accesses the FTGO monolith’s data
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配送服务如何访问FTGO单体数据
- en: '`Delivery Service` needs to access the `Courier` location and availability
    data, which is owned by the monolith. Because that’s potentially a large amount
    of data, it’s not practical for the service to repeatedly query the monolith.
    Instead, a better approach is for the monolith to replicate the data to `Delivery
    Service` by publishing `Courier` domain events, `CourierLocationUpdated` and `CourierAvailabilityUpdated`.
    `Delivery Service` has a `CourierEventSubscriber` that subscribes to the domain
    events and updates its version of the `Courier`. It might also trigger the rescheduling
    of deliveries.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`配送服务`需要访问由单体拥有的`快递员`位置和可用性数据。由于这可能是一大量数据，服务反复查询单体并不实际。相反，更好的方法是由单体通过发布`快递员`领域事件，`CourierLocationUpdated`和`CourierAvailabilityUpdated`，将数据复制到`配送服务`。`配送服务`有一个`CourierEventSubscriber`，它订阅领域事件并更新其`快递员`版本。它还可能触发配送的重新安排。'
- en: How the FTGO monolith accesses the Delivery Service data
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: FTGO单体如何访问配送服务数据
- en: The FTGO monolith needs to read the data that’s been moved to `Delivery Service`,
    such as the `Courier` plans. In theory, the monolith could query the service,
    but that requires extensive changes to the monolith. For the time being, it’s
    easier to leave the monolith’s domain model and database schema unchanged and
    replicate data from the service back to the monolith.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO单体需要读取已移动到`配送服务`中的数据，例如`快递员`计划。理论上，单体可以查询服务，但这需要对单体进行大量更改。目前，保持单体领域模型和数据库模式不变，并从服务中复制数据回单体更容易。
- en: The easiest way to accomplish that is for `Delivery Service` to publish `Courier`
    and `Delivery` domain events. The service publishes a `CourierPlanUpdated` event
    when it updates a `Courier`’s plan, and a `DeliveryScheduleUpdate` event when
    it updates a `Delivery`. The monolith consumes these domain events and updates
    its database.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的最简单方法是让`配送服务`发布`快递员`和`配送`领域事件。当服务更新`快递员`的计划时，它会发布一个`CourierPlanUpdated`事件，当它更新`配送`时，它会发布一个`DeliveryScheduleUpdate`事件。单体消费这些领域事件并更新其数据库。
- en: Now that we’ve looked at how the FTGO monolith and `Delivery Service` interact,
    let’s see how to change the monolith.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了FTGO单体和`配送服务`的交互方式，让我们看看如何修改单体。
- en: 13.5.5\. Changing the FTGO monolith to interact with Delivery Service
  id: totrans-365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.5.5\. 将FTGO单体改为与配送服务交互
- en: In many ways, implementing `Delivery Service` is the easier part of the extraction
    process. Modifying the FTGO monolith is much more difficult. Fortunately, replicating
    data from the service back to the monolith reduces the size of the change. But
    we still need to change the monolith to manage deliveries by invoking `Delivery
    Service`. Let’s look at how to do that.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，实现`配送服务`是提取过程中的较简单部分。修改FTGO单体要困难得多。幸运的是，将服务中的数据复制回单体可以减少更改的大小。但我们需要修改单体以通过调用`配送服务`来管理配送。让我们看看如何做到这一点。
- en: Defining a DeliveryService interface
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义DeliveryService接口
- en: The first step is to encapsulate the delivery management code with a Java interface
    corresponding to the messaging-based API defined earlier. This interface, shown
    in [figure 13.21](#ch13fig21), defines methods for scheduling, rescheduling, and
    canceling deliveries. Eventually, we’ll implement this interface with a proxy
    that sends messages to the delivery service. But initially, we’ll implement this
    API with a class that calls the delivery management code.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将配送管理代码封装在一个与之前定义的消息基础 API 对应的 Java 接口中。如图 13.21 所示的该接口定义了用于安排、重新安排和取消配送的方法。最终，我们将使用发送消息到配送服务的代理来实现这个接口。但最初，我们将使用一个调用配送管理代码的类来实现这个
    API。
- en: Figure 13.21\. The first step is to define `DeliveryService`, which is a coarse-grained,
    remotable API for invoking the delivery management logic.
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.21\. 第一步是定义 `DeliveryService`，它是一个粗粒度、可远程调用的 API，用于调用配送管理逻辑。
- en: '![](Images/13fig21_alt.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig21_alt.jpg)'
- en: The `DeliveryService` interface is a coarse-grained interface that’s well suited
    to being implemented by an IPC mechanism. It defines `schedule()`, `reschedule()`,
    and `cancel()` methods, which correspond to the notification message types defined
    earlier.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeliveryService` 接口是一个粗粒度接口，非常适合由 IPC 机制实现。它定义了 `schedule()`、`reschedule()`
    和 `cancel()` 方法，这些方法对应于之前定义的通知消息类型。'
- en: Refactoring the monolith to call the DeliveryService interface
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 重构单块以调用 DeliveryService 接口
- en: Next, as [figure 13.22](#ch13fig22) shows, we need to identify all the places
    in the FTGO monolith that invoke delivery management and change them to use the
    `DeliveryService` interface. This may take some time and is one of the most challenging
    aspects of extracting a service from the monolith.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如图 13.22 所示，我们需要识别 FTGO 单块中所有调用配送管理的位置，并将它们更改为使用 `DeliveryService` 接口。这可能需要一些时间，并且是提取服务从单块中的一项最具挑战性的工作。
- en: Figure 13.22\. The second step is to change the FTGO monolith to invoke delivery
    management via the `DeliveryService` interface.
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.22\. 第二步是将 FTGO 单块更改为通过 `DeliveryService` 接口调用配送管理。
- en: '![](Images/13fig22_alt.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig22_alt.jpg)'
- en: It certainly helps if the monolith is written in a statically typed language,
    such as Java, because the tools do a better job of identifying dependencies. If
    not, then hopefully you have some automated tests with sufficient coverage of
    the parts of the code that need to be changed.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单块是用静态类型语言编写的，例如 Java，这肯定有帮助，因为工具在识别依赖关系方面做得更好。如果不是这样，那么希望您有一些自动化测试，足以覆盖需要更改的代码部分。
- en: Implementing the DeliveryService interface
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现 DeliveryService 接口
- en: The final step is to replace the `DeliveryServiceImpl` class with a proxy that
    sends notification messages to the standalone `Delivery Service`. But rather than
    discard the existing implementation right away, we’ll use a design, shown in [figure
    13.23](#ch13fig23), that enables the monolith to dynamically switch between the
    existing implementation and `Delivery Service`. We’ll implement the `DeliveryService`
    interface with a class that uses a dynamic feature toggle to determine whether
    to invoke the existing implementation or `Delivery Service`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将 `DeliveryServiceImpl` 类替换为一个代理，该代理向独立的 `Delivery Service` 发送通知消息。但与其立即丢弃现有的实现，我们将使用如图
    13.23 所示的设计，该设计使单块能够动态地在现有实现和 `Delivery Service` 之间切换。我们将使用一个使用动态功能开关的类来实现 `DeliveryService`
    接口，以确定是否调用现有实现或 `Delivery Service`。
- en: Figure 13.23\. The final step is to implement `DeliveryService` with a proxy
    class that sends messages `Delivery Service`. A feature toggle controls whether
    the FTGO monolith uses the old implementation or the new `Delivery Service`.
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.23\. 最后一步是实现 `DeliveryService`，使用一个发送消息到 `Delivery Service` 的代理类。一个功能开关控制
    FTGO 单块是使用旧实现还是新的 `Delivery Service`。
- en: '![](Images/13fig23_alt.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig23_alt.jpg)'
- en: Using a feature toggle significantly reduces the risk of rolling out `Delivery
    Service`. We can deploy `Delivery Service` and test it. And then, once we’re sure
    it works, we can flip the toggle to route traffic to it. If we then discover that
    `Delivery Service` isn’t working as expected, we can switch back to the old implementation.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 使用功能开关可以显著降低推出 `Delivery Service` 的风险。我们可以部署 `Delivery Service` 并对其进行测试。然后，一旦我们确信它工作正常，我们可以翻转开关以将流量路由到它。如果我们随后发现
    `Delivery Service` 并没有按预期工作，我们可以切换回旧实现。
- en: '|  |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**About feature toggles**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于功能开关**'
- en: '*Feature toggles*, or *feature flags*, let you deploy code changes without
    necessarily releasing them to users. They also enable you to dynamically change
    the behavior of the application by deploying new code. This article by Martin
    Fowler provides an excellent overview of the topic: [https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html).'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '*功能开关* 或 *功能标志* 允许你在不必向用户发布的情况下部署代码更改。它们还使你能够通过部署新代码来动态更改应用程序的行为。本文由马丁·福勒撰写，对这一主题提供了极好的概述：[https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html)。'
- en: '|  |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Once we’re sure that `Delivery Service` is working as expected, we can then
    remove the delivery management code from the monolith.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确认 `配送服务` 正如预期那样工作，我们就可以从单体应用中移除配送管理代码。
- en: '`Delivery Service` and `Delayed Order Service` are examples of the services
    that the FTGO team will develop during their journey to the microservice architecture.
    Where they go next after implementing these services depends on the priorities
    of the business. One possible path is to extract `Order History Service`, described
    in [chapter 7](kindle_split_015.xhtml#ch07). Extracting this service partially
    eliminates the need for `Delivery Service` to replicate data back to the monolith.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`配送服务` 和 `延迟订单服务` 是 FTGO 团队在他们的微服务架构之旅中将要开发的服务示例。在实现这些服务后，他们下一步将走向何方取决于业务的优先级。一条可能的路径是提取
    [第 7 章](kindle_split_015.xhtml#ch07) 中描述的 `订单历史服务`。提取此服务部分消除了 `配送服务` 需要向单体应用复制数据的需求。'
- en: 'After implementing `Order History Service`, the FTGO team can then extract
    the services in the order described in [section 13.3.2](#ch13lev2sec7): `Order
    Service`, `Consumer Service`, `Kitchen Service`, and so on. As the FTGO team extracts
    each service, the maintainability and testability of their application gradually
    improves, and their development velocity increases.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 `订单历史服务` 之后，FTGO 团队可以接着提取 [第 13.3.2 节](#ch13lev2sec7) 中描述的服务：`订单服务`、`消费者服务`、`厨房服务`
    等等。随着 FTGO 团队提取每个服务，他们应用程序的可维护性和可测试性逐渐提高，他们的开发速度也在增加。
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Before migrating to a microservice architecture, it’s important to be sure that
    your software delivery problems are a result of having outgrown your monolithic
    architecture. You might be able to accelerate delivery by improving your software
    development process.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在迁移到微服务架构之前，确保你的软件交付问题是由于你的单体架构已经过时是很重要的。你可能会通过改进你的软件开发流程来加速交付。
- en: It’s important to migrate to microservices by incrementally developing a strangler
    application. A strangler application is a new application consisting of microservices
    that you build around the existing monolithic application. You should demonstrate
    value early and often in order to ensure that the business supports the migration
    effort.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过增量开发一个“杀手应用”来迁移到微服务是很重要的。一个“杀手应用”是由微服务组成的新应用程序，你围绕现有的单体应用程序构建它。你应该尽早并经常展示价值，以确保业务支持迁移工作。
- en: A great way to introduce microservices into your architecture is to implement
    new features as services. Doing so enables you to quickly and easily develop a
    feature using a modern technology and development process. It’s a good way to
    quickly demonstrate the value of migrating to microservices.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将微服务引入你的架构的一个好方法是将新功能作为服务来实现。这样做可以让你快速、轻松地使用现代技术和开发流程开发一个功能。这是快速展示迁移到微服务价值的不错方式。
- en: One way to break up the monolith is to separate the presentation tier from the
    backend, which results in two smaller monoliths. Although it’s not a huge improvement,
    it does mean that you can deploy each monolith independently. This allows, for
    example, the UI team to iterate more easily on the UI design without impacting
    the backend.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单体应用拆分的一种方法是将表示层与后端分离，这导致出现两个更小的单体应用。尽管这不是巨大的改进，但它确实意味着你可以独立部署每个单体应用。例如，这允许
    UI 团队更容易地对 UI 设计进行迭代，而不会影响后端。
- en: The main way to break up the monolith is by incrementally migrating functionality
    from the monolith into services. It’s important to focus on extracting the services
    that provide the most benefit. For example, you’ll accelerate development if you
    extract a service that implements functionality that’s being actively developed.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆分单体应用的主要方法是通过增量地将功能从单体迁移到服务中。关注提取提供最大利益的服务是很重要的。例如，如果你提取一个实现正在积极开发的功能的服务，这将加速开发。
- en: Newly developed services almost always have to interact with the monolith. A
    service often needs to access a monolith’s data and invoke its functionality.
    The monolith sometimes needs to access a service’s data and invoke its functionality.
    To implement this collaboration, develop integration glue, which consists of inbound
    and outbound adapters in the monolith.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新开发的几乎总是需要与单体交互。一个服务通常需要访问单体数据并调用其功能。有时单体需要访问服务数据并调用其功能。为了实现这种协作，开发集成胶水，它由单体中的入站和出站适配器组成。
- en: To prevent the monolith’s domain model from polluting the service’s domain model,
    the integration glue should use an anti-corruption layer, which is a layer of
    software that translates between domain models.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了防止单体领域模型污染服务领域模型，集成胶水应使用反腐败层，这是一个在领域模型之间进行转换的软件层。
- en: One way to minimize the impact on the monolith of extracting a service is to
    replicate the data that was moved to the service back to the monolith’s database.
    Because the monolith’s schema is left unchanged, this eliminates the need to make
    potentially widespread changes to the monolith code base.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了最小化提取服务对单体的影响，可以将移动到服务中的数据复制回单体数据库。因为单体架构保持不变，这消除了对单体代码库进行可能广泛更改的需要。
- en: Developing a service often requires you to implement sagas that involve the
    monolith. But it can be challenging to implement a compensatable transaction that
    requires making widespread changes to the monolith. Consequently, you sometimes
    need to carefully sequence the extraction of services to avoid implementing compensatable
    transactions in the monolith.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发服务通常需要实现涉及单体的sagas。但是，实现需要广泛更改单体的可补偿事务可能具有挑战性。因此，有时需要仔细安排服务的提取，以避免在单体中实现可补偿事务。
- en: When refactoring to a microservice architecture, you need to simultaneously
    support the monolithic application’s existing security mechanism, which is often
    based on an in-memory session, and the token-based security mechanism used by
    the services. Fortunately, a simple solution is to modify the monolith’s login
    handler to generate a cookie containing a security token, which is then forwarded
    to the services by the API gateway.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当重构到微服务架构时，你需要同时支持单体应用的现有安全机制，这通常基于内存会话，以及服务使用的基于令牌的安全机制。幸运的是，一个简单的解决方案是修改单体应用的登录处理器以生成包含安全令牌的cookie，然后通过API网关转发给服务。
- en: List of Patterns
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式列表
- en: Application architecture patterns
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用架构模式
- en: Monolithic architecture (40)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构（40）
- en: Microservice architecture (40)
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构（40）
- en: Decomposition patterns
  id: totrans-404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分解模式
- en: Decompose by business capability (51)
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 按业务能力分解（51）
- en: Decompose by subdomain (54)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 按子域分解（54）
- en: Messaging style patterns
  id: totrans-407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 消息风格模式
- en: Messaging (85)
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 消息（85）
- en: Remote procedure invocation (72)
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 远程过程调用（72）
- en: Reliable communications patterns
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可靠通信模式
- en: Circuit breaker (78)
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器（78）
- en: Service discovery patterns
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务发现模式
- en: 3rd party registration (85)
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方注册（85）
- en: Client-side discovery (83)
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发现（83）
- en: Self-registration (82)
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 自注册（82）
- en: Server-side discovery (85)
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端发现（85）
- en: Transactional messaging patterns
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 事务性消息模式
- en: Polling publisher (98)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询发布者（98）
- en: Transaction log tailing (99)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 事务日志尾部（99）
- en: Transactional outbox (98)
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 事务性输出箱（98）
- en: Data consistency patterns
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据一致性模式
- en: Saga (114)
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Saga（114）
- en: Business logic design patterns
  id: totrans-423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 业务逻辑设计模式
- en: Aggregate (150)
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合（150）
- en: Domain event (160)
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件（160）
- en: Domain model (150)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型（150）
- en: Event sourcing (184)
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源（184）
- en: Transaction script (149)
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 事务脚本（149）
- en: Querying patterns
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查询模式
- en: API composition (223)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: API组合（223）
- en: Command query responsibility segregation (228)
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 命令查询责任分离（228）
- en: External API patterns
  id: totrans-432
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 外部API模式
- en: API gateway (259)
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: API网关（259）
- en: Backends for frontends (265)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 前端后端（265）
- en: Testing patterns
  id: totrans-435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试模式
- en: Consumer-driven contract test (302)
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者驱动合约测试（302）
- en: Consumer-side contract test (303)
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者端合约测试（303）
- en: Service component test (335)
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 服务组件测试（335）
- en: Security patterns
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安全模式
- en: Access token (354)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌（354）
- en: Cross-cutting concerns patterns
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 横切关注点模式
- en: Externalized configuration (361)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 外部化配置（361）
- en: Microservice chassis (379)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务框架（379）
- en: Observability patterns
  id: totrans-444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可观察性模式
- en: Application metrics (373)
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 应用指标（373）
- en: Audit logging (377)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 审计日志（377）
- en: Distributed tracing (370)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式跟踪（370）
- en: Exception tracking (376)
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 异常跟踪（376）
- en: Health check API (366)
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查API（366）
- en: Log aggregation (368)
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 日志聚合（368）
- en: Deployment patterns
  id: totrans-451
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部署模式
- en: Deploy a service as a container (393)
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务作为容器部署（393）
- en: Deploy a service as a VM (390)
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务作为虚拟机部署（390）
- en: Language-specific packaging format (387)
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 语言特定的打包格式（387）
- en: Service mesh (380)
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格（380）
- en: Serverless deployment (416)
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器部署（416）
- en: Sidecar (410)
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 侧车（410）
- en: Refactoring to microservices patterns
  id: totrans-458
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重构为微服务模式
- en: Anti-corruption layer (447)
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 防腐层（447）
- en: Strangler application (432)
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: Strangler应用（432）
- en: '![](Images/f0ibc-01_alt.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0ibc-01_alt.jpg)'
- en: The rapid, frequent, and reliable delivery of large, complex applications requires
    a combination of DevOps, which includes continuous delivery/deployment, small,
    autonomous teams, and the microservice architecture.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 快速、频繁且可靠地交付大型、复杂应用程序需要结合DevOps，包括持续交付/部署、小型、自治团队和微服务架构。
- en: '![](Images/f0ibc-02_alt.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0ibc-02_alt.jpg)'
- en: The microservice architecture structures an application as a set of loosely
    coupled services that are organized around business capabilities. Each team develops,
    tests, and deploys their services independently.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构将应用程序结构化为一组围绕业务能力组织松散耦合的服务。每个团队独立开发、测试和部署他们的服务。
