- en: 7 Hooked on metaprogramming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 沉迷于元编程
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Applying cross-functional behavior with metaprogramming and reflection
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元编程和反射应用跨功能行为
- en: Using symbols to create interoperability between different realms in your application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用符号在应用程序的不同领域之间创建互操作性
- en: Augmenting JavaScript’s internals with symbols
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用符号增强 JavaScript 的内部功能
- en: Understanding the basics of the Proxy/Reflect APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Proxy/Reflect API 的基础知识
- en: Enhancing the execution of methods with decorators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器增强方法的执行
- en: Performing leaner error handling with the throw expressions proposal
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 throw 表达式提案进行更精简的错误处理
- en: '*A program''s text is just one representation of the program. Programs are
    not text. . . . We need a different way to store and work with our programs.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*程序文本只是程序的一种表示。程序不是文本……我们需要一种不同的方式来存储和处理我们的程序。*'
- en: —Sergey Dmitriev, president and co-founder of JetBrains
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ——Sergey Dmitriev，JetBrains 的总裁和联合创始人
- en: Imagine a company like Intel that builds CPU chips. To automate a lot of the
    repetitive tasks, the company programs robots to build chips—a task that we call
    programming. Then, to scale to higher industry demands, it programs factories
    that build robots that build chips—a task that we call metaprogramming.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下英特尔这样的公司，它制造 CPU 芯片。为了自动化大量重复性任务，公司编写程序让机器人制造芯片——我们称之为编程任务。然后，为了满足更高的行业需求，它编写程序让工厂制造制造芯片的机器人——我们称之为元编程。
- en: 'I hope that by now, you’re hooked on JavaScript. I know I am. As a byproduct
    of all the topics we’ve covered throughout our journey, we’ve uncovered some interesting
    dualities. One of these dualities is “functions as data” (chapter 4): the idea
    of expressing an eventual value as an execution of some function. We took that
    concept to another level in chapter 6 with “modules as data,” referring to JavaScript’s
    nature of reifying a module as a bound object that you can pass around as data
    to other parts of your application.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望到现在为止，你已经对 JavaScript 上瘾了。我知道我确实如此。在我们旅途中涵盖的所有主题的副产品中，我们揭示了一些有趣的二分法。其中之一是“函数作为数据”（第
    4 章）：将最终值表达为执行某个函数的想法。我们在第 6 章中把这一概念提升到了另一个层次，即“模块作为数据”，指的是 JavaScript 将模块作为可以传递给应用程序其他部分的数据的绑定对象。
- en: 'In this chapter, I’m introducing another duality: “code as data.” This duality
    refers to the idea of metaprogramming: using code to automate code or in some
    way modify or alter the behavior of code. As it does for companies like Intel,
    metaprogramming has many applications, such as automating repetitive tasks or
    dynamically inserting code to handle orthogonal design issues such as logging,
    tracing, and tracking performance metrics, to name a few.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍另一个二分法：“代码作为数据”。这个二分法指的是元编程的概念：使用代码来自动化代码或以某种方式修改或改变代码的行为。正如它对英特尔这样的公司一样，元编程有许多应用，例如自动化重复性任务或动态插入代码来处理正交设计问题，如日志记录、跟踪和跟踪性能指标，仅举几例。
- en: This chapter starts with the Symbol primitive data type, showing how you can
    use it to guide the flow of execution and influence low-level system operations
    such as how an object gets spread or iterated over, or what happens when an object
    appears next to some mathematical symbol. JavaScript gives you a few controls
    to tweak the way that this data type works. You’ll learn that you can use JavaScript
    symbols in many ways to define special object properties, as well as inject static
    hooks.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从 Symbol 原始数据类型开始，展示您如何使用它来引导执行流程并影响低级系统操作，例如对象如何被展开或迭代，或者当对象出现在某些数学符号旁边时会发生什么。JavaScript
    给您一些控制来调整此数据类型的工作方式。您将了解到您可以使用 JavaScript 符号以多种方式定义特殊对象属性，以及注入静态钩子。
- en: Metaprogramming is also deeply related to dynamic concepts such as reflection
    and introspection, which happen when a computer program treats/observes its own
    instruction set as raw runtime data. In this regard, you’ll use the `Proxy` and
    `Reflect` JavaScript APIs to change the runtime behavior of your code by hooking
    into the dynamic structure of objects and functions. Think about a time when you
    needed to add performance timers or trace logs around your functions to measure
    or trace their execution, but then had to live with that code forever. Proxies
    are great for enhancing and augmenting objects with pluggable behavior in a modular
    way without cluttering the source code. The `Proxy` and `Reflect` APIs are more
    frequently used in framework or library development, but you’ll learn how to take
    advantage of them in your own code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程也与动态概念如反射和内省密切相关，这些概念发生在计算机程序将其自己的指令集作为原始运行时数据对待/观察时。在这方面，你将使用 `Proxy` 和
    `Reflect` JavaScript API 通过挂钩对象和函数的动态结构来改变代码的运行时行为。想想你需要添加性能计时器或跟踪日志来测量或跟踪函数的执行，但不得不永远忍受那段代码的时候。代理非常适合以模块化的方式增强和增强对象，而不会使源代码变得杂乱。`Proxy`
    和 `Reflect` API 在框架或库开发中更频繁地使用，但你将学习如何在你的代码中利用它们。
- en: Before you get hooked on these features, let’s begin with some simple examples
    of metaprogramming that occur in day-to-day coding.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在你沉迷于这些特性之前，让我们从一些日常编码中发生的简单元编程示例开始。
- en: 7.1 Common uses of metaprogramming in JavaScript
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 JavaScript 中元编程的常见用途
- en: When talking about code as data in the context of JavaScript, people might immediately
    relate it to writing code inside code or using variables to concatenate and/or
    replace code statements. The next listing shows the types of things you could
    do with `eval`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 JavaScript 的上下文中谈论代码作为数据时，人们可能会立即将其与在代码中编写代码或使用变量来连接和/或替换代码语句联系起来。下面的列表显示了你可以使用
    `eval` 做的事情：
- en: Listing 7.1 Simple example that uses `eval`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 使用 `eval` 的简单示例
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Prints 7 to the console
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 7 打印到控制台
- en: In strict mode, `eval` expects code in the form of a raw string literal (data
    as code) and executes it in its own environment. Alarms should be going off in
    your head at this moment. You can imagine that `eval` can be an extremely dangerous
    and insecure operation, arguably considered to be unnecessary these days.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，`eval` 期望以原始字符串字面量（数据作为代码）的形式提供代码，并在其自己的环境中执行它。此刻，你的脑海中应该响起警报。你可以想象 `eval`
    可以是一个非常危险和不安全的操作，可以说在当今时代被认为是多余的。
- en: 'Another example of data as code is JavaScript Object Notation (JSON) text,
    which is a string representation of code that can be directly understood as an
    object in the language. In fact, with ECMAScript Modules (ESM), you can directly
    import a JSON file as code without needing to do any special parsing, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据作为代码的另一个例子是 JavaScript 对象表示法（JSON）文本，它是对代码的字符串表示，可以直接在语言中作为对象理解。实际上，使用 ECMAScript
    模块（ESM）时，你可以直接将 JSON 文件作为代码导入，而无需进行任何特殊解析，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also consider computed property names, which allow you to create a key from
    any expression that evaluates to a string. We used this concept to support the
    `prop` and `props` methods back in chapter 4\. Here’s a simple example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还要考虑计算属性名，它允许你创建一个从任何评估为字符串的表达式中得到的键。我们在第 4 章中使用了这个概念来支持 `prop` 和 `props` 方法。这里有一个简单的例子：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Metaprogramming also occurs when introspecting the structure of an object.
    The most important use case is JavaScript’s own duck typing, in which the “type”
    of an object is determined solely by its shape with methods such as `Object.getOwnPropertyNames`,
    `Object.getPrototypeOf`, `Object.getOwnPropertyDescriptors`, and `Object .getOwnPropertySymbols`.
    Here’s a simple example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当内省对象的架构时，也会发生元编程。最重要的用例是 JavaScript 的自身鸭子类型，其中对象的“类型”完全由其形状决定，使用 `Object.getOwnPropertyNames`、`Object.getPrototypeOf`、`Object.getOwnPropertyDescriptors`
    和 `Object .getOwnPropertySymbols` 等方法。这里有一个简单的例子：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Even functions, as other objects, have some limited awareness of their own
    shape and contents. You can see this awareness when you use `Function#toString`
    to print the string representing the function’s signature and body:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是函数，作为其他对象，也对其形状和内容有一定的认识。当你使用 `Function#toString` 打印表示函数签名和主体的字符串时，你可以看到这种认识：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You could potentially pass this text representation to a parser that can understand
    what the function does and act accordingly, or even inject more instructions into
    it if need be.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这种文本表示传递给一个可以理解函数做什么并相应行动的解析器，或者在必要时向其中注入更多指令。
- en: A more useful property of functions is `Function#length`. Consider the way that
    we implemented the `curry` function combinator in chapter 4, using `length` to
    figure out the number of arguments with which the curried function is declared
    and determine how many inner functions to evaluate partially.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的一个更有用的属性是`Function#length`。考虑我们在第4章中实现`curry`函数组合器的方式，使用`length`来确定声明了具有多少参数的curried函数，并确定要部分评估多少内部函数。
- en: NOTE Because JavaScript makes it simple to use data as code, JavaScript has
    some qualities of a homoiconic language. This topic is interesting to research
    on your own, if you like. A homoiconic language mirrors the syntax of code as
    the syntax of data. Lisp (List Programming) programs, for example, are written
    as lists, which could be fed back into another (or the same) Lisp program. All
    JSON text is considered to be valid JavaScript ([https://github.com/tc39/ proposal-json-superset](https://github.com/tc39/proposal-json-superset)),
    but not all JavaScript code could be understood as JSON, so it’s not a full mirror.
    Interestingly enough, JavaScript was inspired by the language Scheme, which is
    a homoiconic Lisp dialect.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于JavaScript使得将数据用作代码变得简单，JavaScript具有一些同构语言的特点。如果你喜欢，这个主题值得你自己去研究。同构语言反映了代码的语法作为数据的语法。例如，Lisp（列表编程）程序是以列表的形式编写的，这些列表可以反馈到另一个（或相同的）Lisp程序中。所有JSON文本都被认为是有效的JavaScript（[https://github.com/tc39/proposal-json-superset](https://github.com/tc39/proposal-json-superset)），但并非所有JavaScript代码都可以被理解为JSON，所以它不是完全的镜像。有趣的是，JavaScript受到了语言Scheme的启发，而Scheme是一种同构Lisp方言。
- en: These tasks are examples of basic tasks in which some form of metacoding is
    present. But with JavaScript, there is much more than meets the eye, especially
    when you start to take advantage of special symbols to annotate the static structure
    of your code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务是一些基本任务的例子，其中存在某种形式的元编程。但与JavaScript相比，还有更多超出表面之下的内容，尤其是在你开始利用特殊符号来注释代码的静态结构时。
- en: 7.2 JavaScript symbols
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 JavaScript符号
- en: Symbols are a subtle and powerful feature of the language, used mostly in library
    and framework development. Define them in the correct places, and with little
    effort, objects light up and take on new roles and new behavior. You can use symbols
    to establish behavioral contracts among objects, to keep data private and secret,
    and to enhance the way that the JavaScript runtime treats objects. Before we dive
    into all those topics, let’s spend some time understanding what they are and how
    to create them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 符号是语言中微妙而强大的特性，主要用于库和框架的开发。在正确的位置定义它们，只需付出小小的努力，对象就能发光，承担新的角色和新的行为。你可以使用符号在对象之间建立行为契约，以保持数据私密和保密，并增强JavaScript运行时处理对象的方式。在我们深入所有这些主题之前，让我们花些时间了解它们是什么以及如何创建它们。
- en: The first thing to know is that unlike any new API, a `Symbol` is a true built-in
    primitive data type (like number, string, or Boolean).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要知道的是，与任何新的API不同，`Symbol`是一个真正的内置原始数据类型（如数字、字符串或布尔值）。
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A `Symbol` represents a dynamic, anonymous, unique value. Unlike number or string,
    symbols have no literal syntax, and you can never serialize them into a string.
    They follow the function factory pattern (like `Money`), which means that you
    don’t use `new` to create a new one. Instead, you create a symbol by calling the
    `Symbol` function, which generates a unique value behind the scenes. The next
    listing shows a snippet.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbol`代表一个动态的、匿名的、唯一的值。与数字或字符串不同，符号没有字面语法，你永远不能将它们序列化为字符串。它们遵循函数工厂模式（类似于`Money`），这意味着你不需要使用`new`来创建一个新的。相反，你通过调用`Symbol`函数来创建一个符号，该函数在幕后生成一个唯一的值。下面的列表显示了代码片段。'
- en: Listing 7.2 Basic use of symbols
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 符号的基本用法
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Because symbols hide their unique value, you can provide an optional description,
    which is used only for debugging and logging purposes. This string doesn’t factor
    into the underlying unique value or into the lookup process.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 因为符号隐藏了它们的唯一值，你可以提供一个可选的描述，这只用于调试和日志记录目的。这个字符串不影响底层唯一的值或查找过程。
- en: Because a symbol represents a unique value, it is used primarily as a collision-free
    object property, like a dynamic string key using the computed property-name syntax
    `obj[symbol]`. Under the hood, JavaScript maps the unique value of a symbol to
    a unique object key, which you can retrieve only if you possess the symbol reference.
    The following listing shows some simple use cases.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因为符号代表一个唯一值，它主要用作无碰撞的对象属性，就像使用计算属性名语法 `obj[symbol]` 的动态字符串键。在底层，JavaScript 将符号的唯一值映射到一个唯一对象键，你只能在你拥有符号引用的情况下检索它。以下列表展示了几个简单的用例。
- en: Listing 7.3 Using symbols as property keys
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 使用符号作为属性键
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Adds property foo
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加属性 foo
- en: ❷ Adds a property with a symbol described as foo
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加一个描述为 foo 的符号属性
- en: ❸ foo and Symbol('foo') map to different keys.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ foo 和 Symbol('foo') 映射到不同的键。
- en: ❹ You can’t refer to Symbol('foo'), which would create a new symbol.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 你不能引用 Symbol('foo')，这将创建一个新的符号。
- en: 'By design, symbols are not discoverable by conventional means. So iterating
    over an object with `for..in`, `for..of`, `Object.keys`, or `Object.getOwnPropertyNames`
    won’t work, mostly for backward-compatibility reasons. The only way is through
    introspection by explicitly calling `Object.getOwnPropertySymbols`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 按设计，符号不能通过常规方式被发现。因此，使用 `for..in`、`for..of`、`Object.keys` 或 `Object.getOwnPropertyNames`
    遍历对象不会起作用，这主要是出于向后兼容性的原因。唯一的方法是通过显式调用 `Object.getOwnPropertySymbols` 来进行内省：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Even then, this technique offers a “view” of each symbol. Without the actual
    symbol reference, you still can’t access the property value. By contrast, symbol
    references are copied over when you spread an object and use `Object.assign`.
    The difference is subtle but important. Unlike how other primitives are copied
    by value, the clone of `obj` copies not the value, but the symbol reference itself—the
    same symbol, not a copy. Take a look:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，这种技术也只提供了每个符号的“视图”。没有实际的符号引用，你仍然无法访问属性值。相比之下，当你展开一个对象并使用 `Object.assign`
    时，符号引用会被复制。这种区别虽然微妙但很重要。与其他原始数据类型不同，`obj` 的克隆不是复制值，而是复制符号引用本身——相同的符号，而不是一个副本。请看以下示例：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As discussed in chapter 3, these operations rely on the `enumerable` data descriptor
    to be set to `true`. If you want more privacy, you could set this descriptor to
    `false` by using `Object.defineProperty`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 3 章所述，这些操作依赖于将 `enumerable` 数据描述符设置为 `true`。如果你想有更多的隐私，你可以通过使用 `Object.defineProperty`
    将此描述符设置为 `false`。
- en: At this point, we have not dealt with specific uses of symbols—only the basics.
    Before we look at some interesting examples, it is important to understand how
    and where symbols are created.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有处理符号的具体用法——只是基础知识。在我们查看一些有趣的例子之前，了解符号是如何以及在哪里被创建的是非常重要的。
- en: 7.3 Symbol registries
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 符号注册表
- en: Understanding registries will help you understand how and where symbols are
    created and used. When a symbol is created, it generates a new, unique, and opaque
    value inside the JavaScript runtime. These values are automatically added to different
    registries—local or global, depending on how the symbol is created. With the `Symbol`
    constructor, you target the local registry, and with static methods like `Symbol.for`,
    you target the global registry, which is accessible across realms.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 理解注册表将帮助你了解符号是如何以及在哪里被创建和使用的。当一个符号被创建时，它会在 JavaScript 运行时内部生成一个新、唯一且不透明的值。这些值会自动添加到不同的注册表中——本地或全局，这取决于符号是如何被创建的。使用
    `Symbol` 构造函数，你针对本地注册表，而使用静态方法如 `Symbol.for`，你针对全局注册表，这是跨领域可访问的。
- en: It helps to think of a registry as being a map data structure in memory that
    allows you to retrieve objects by means of a key, much like JavaScript’s own `Map`.
    Let’s begin with the local registry.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将注册表想象成内存中的一种映射数据结构，它允许你通过键来检索对象，就像 JavaScript 自身的 `Map` 一样，这有助于理解。让我们从本地注册表开始。
- en: 7.3.1 Local registry
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 本地注册表
- en: 'To target the local registry, you call the factory function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要定位本地注册表，你需要调用工厂函数：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function adds the value generated from `Symbol('foo')` to the local registry,
    whether you create this symbol from a global variable scope or from within a module.
    Remember that you can access and use a symbol only when you possess the variable
    to reference it. If you declare `symFoo` inside a module (or a function), the
    variable is visible only within that module’s (or function’s) scope, and callers
    can access it only if you export `symFoo` from your module (or return it from
    your function). Nevertheless, in all these cases, the local registry is being
    used.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将 `Symbol('foo')` 生成值添加到本地注册表中，无论您是从全局变量作用域还是从模块内部创建此符号。请记住，您只能在拥有引用它的变量时才能访问和使用符号。如果您在模块（或函数）内部声明
    `symFoo`，则该变量仅在模块的（或函数的）作用域内可见，并且调用者只能通过您从模块（或函数）导出 `symFoo`（或从函数返回它）来访问它。然而，在这些所有情况下，都在使用本地注册表。
- en: The next listing shows an example of creating a local symbol and exporting the
    binding from a module.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了创建本地符号并从模块导出绑定的示例。
- en: Listing 7.4 Exporting/importing a reference to a `Symbol` object
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 导出/导入 `Symbol` 对象的引用
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ In someModule.js
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 someModule.js 中
- en: ❷ sym and global.sym point to two different variables.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ sym 和 global.sym 指向两个不同的变量。
- en: Section 7.3.2 shows how the global registry comes into play.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 7.3.2 节展示了全局注册表是如何起作用的。
- en: 7.3.2 Global registry
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 全局注册表
- en: The global registry is an internal structure available across the entire runtime.
    The `Symbol` API exposes static methods that interact with this registry, such
    as looking up symbols with `Symbol.keyFor`. Any symbols created in the local registry
    will not be accessible with this API. Check out the code in the following listing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 全局注册表是一个在整个运行时中可用的内部结构。`Symbol` API 提供了与该注册表交互的静态方法，例如使用 `Symbol.keyFor` 查找符号。在本地注册表中创建的任何符号都无法使用此
    API 访问。查看以下列表中的代码。
- en: Listing 7.5 Local symbols not accessible with the global registry
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 使用全局注册表无法访问的本地符号
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Uses local registry
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用本地注册表
- en: ❷ Can’t find either one
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 找不到任何一个
- en: This code may seem to be rather unintuitive at first. Accessing the local registry
    didn’t require special APIs. You treated the symbol variables as you would any
    other. But when you want to use the runtime-wide registry to share symbols across
    many parts of your application, you need the special APIs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码一开始可能看起来相当不直观。访问本地注册表不需要特殊的 API。您将符号变量当作其他任何变量一样对待。但是，当您想要使用运行时范围内的注册表在应用程序的许多部分之间共享符号时，您需要特殊的
    API。
- en: The static methods `Symbol.keyFor` and `Symbol.for` are designed to interact
    with the global symbol registry that lives inside the JavaScript runtime. The
    next listing shows how we can tweak the snippet of code in listing 7.5 to target
    this registry.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法 `Symbol.keyFor` 和 `Symbol.for` 被设计用来与 JavaScript 运行时内部的全球符号注册表交互。下一个列表展示了我们如何调整列表
    7.5 中的代码片段以针对此注册表。
- en: Listing 7.6 Interacting with the global registry
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 与全局注册表交互
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ A globally registered symbol in someModule.js
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 someModule.js 中的全局注册符号
- en: ❷ A globally registered symbol in current scope
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在当前作用域中的全局注册符号
- en: ❸ Both keys found
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 找到两个键
- en: 'Global symbols have the additional quality of transcending code realms. You
    may not be familiar with this term. Here’s how the ECMAScript specification describes
    a realm:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 全局符号具有超越代码领域的额外特性。您可能不熟悉这个术语。以下是 ECMAScript 规范如何描述领域：
- en: '*Before it is evaluated, all ECMAScript code must be associated with a realm.
    Conceptually, a realm consists of a set of intrinsic objects, an ECMAScript global
    environment, all of the ECMAScript code that is loaded within the scope of that
    global environment, and other associated state and resources.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*在评估之前，所有 ECMAScript 代码都必须与一个领域相关联。从概念上讲，一个领域包括一组固有对象、一个 ECMAScript 全局环境、在该全局环境范围内加载的所有
    ECMAScript 代码，以及其他相关的状态和资源。*'
- en: In other words, a realm is the environment (set of variables and resources)
    associated with a script running in the browser, a module, an iframe, or even
    a worker script. Each module runs in its own realm; each iframe has its own window
    and its own realm; and unlike local symbols, global symbols are accessible across
    these realms, as depicted in figure 7.1.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，领域是与在浏览器、模块、iframe 或甚至工作脚本中运行的脚本关联的环境（变量和资源集）。每个模块在自己的领域中运行；每个 iframe 有自己的窗口和自己的领域；与局部符号不同，全局符号可以在这些领域中访问，如图
    7.1 所示。
- en: '![](../Images/7-1.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-1.png)'
- en: Figure 7.1 Scope of the local and global registries
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 本地和全局注册表的范围
- en: As shown in listing 7.6, you can create these symbols by using `Symbol.for(key``)`.
    If `key` isn’t in the registry yet, JavaScript creates a new symbol and files
    it globally under that key. Then you can look it up with `Symbol.keyFor(key``)`
    anywhere else in your application. If the symbol has not yet been defined in the
    global registry, the API returns `undefined`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表7.6所示，你可以使用`Symbol.for(key)`来创建这些符号。如果`key`尚未在注册表中，JavaScript将创建一个新的符号，并将其在全球范围内以该键归档。然后你可以在应用程序的任何其他地方查找它。如果符号尚未在全局注册表中定义，该API返回`undefined`。
- en: Now that you understand how symbols work, section 7.4 shows some practical applications
    for them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了符号的工作原理，第7.4节展示了它们的一些实际应用。
- en: 7.4 Practical application of symbols
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 符号的实际应用
- en: Symbols have many practical applications. In the following sections, we’ll discuss
    using them to implement hidden properties and make objects interoperate with other
    parts of your application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 符号有许多实际应用。在接下来的章节中，我们将讨论如何使用它们来实现隐藏属性，并使对象与你的应用程序的其他部分进行互操作。
- en: 7.4.1 Hidden properties
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 隐藏属性
- en: Symbols provide a different way to attach properties to an object (data or functions)
    because these property keys are guaranteed to be conflict-free, collision-free,
    and unique in the runtime. This doesn’t mean you should use them to key all your
    properties, however, because the access rules for symbols, as discussed in section
    7.3, make it inconvenient to pull them out.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 符号提供了一种将属性附加到对象（数据或函数）的不同方式，因为这些属性键在运行时保证是冲突-free、碰撞-free和唯一的。但这并不意味着你应该用它们作为所有属性的键，因为正如第7.3节所讨论的，符号的访问规则使得它们不方便被提取。
- en: For this reason, it was thought that symbols could be used to emulate private
    properties because users would need access to the symbol reference itself, which
    you can control (hide) inside the module or class in question, as the next listing
    shows.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，人们认为可以使用符号来模拟私有属性，因为用户需要访问符号引用本身，你可以控制（隐藏）在相关的模块或类内部，如下面的列表所示。
- en: Listing 7.7 Using symbols to implement private, hidden properties
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.7 使用符号实现私有、隐藏属性
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ This value would never be exported and, thus, is kept private within the module.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这个值永远不会被导出，因此它被保留在模块内部作为私有。
- en: ❷ Uses Object.defineProperty to make internal property nonenumerable
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用`Object.defineProperty`使内部属性不可枚举
- en: ❸ Increases/decreases the object’s internal count property by a specified amount
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过指定数量增加/减少对象的内部计数属性
- en: 'Outside this class, there’s no way to access the internal `count` property:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类外部，没有方法可以访问内部的`count`属性：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Unfortunately, this solution has a drawback: symbols are easily discovered
    via reflective APIs such as `Reflect.ownKeys` and `Object.getOwnPropertySymbols`.
    Hence, they are not truly private. Instead of using symbols for private access,
    why not use them to expose access and aid the interoperability among different
    realms of your code (aka different modules)? This use is much better for them.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个解决方案有一个缺点：符号很容易通过反射API，如`Reflect.ownKeys`和`Object.getOwnPropertySymbols`被发现。因此，它们并不是真正的私有。为什么不使用符号来公开访问并帮助你的代码不同领域（即不同的模块）之间的互操作性呢？这种用途对它们来说要好得多。
- en: Having a way to establish some cross-realm set of properties is analogous to
    what interfaces do for statically typed, class-based language (appendix B). In
    other words, symbols can be used to create contracts of interoperability among
    other parts of the code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以建立一些跨域的属性集，这与接口在静态类型、基于类的语言中的作用类似（附录B）。换句话说，符号可以用来在其他代码部分之间创建互操作性合约。
- en: 7.4.2 Interoperability
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 互操作性
- en: 'As an example, a third-party library could use a symbol to which objects could
    refer and adhere to a certain convention imposed by the library. Symbols are ideal
    for interoperable metadata values. Back in chapter 2, you learned that setting
    up your own prototype logic is an error-prone process. Here’s one of the issues
    again:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，第三方库可以使用一个对象可以引用的符号，并遵守库强加的某些约定。符号是理想的互操作性元数据值。在第二章中，你了解到设置自己的原型逻辑是一个容易出错的进程。这里再次提出一个问题：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Remember that the issue was forgetting to use the `prototype` property of `Transaction`.
    It should have been `Object.create(Transaction.prototype``)`. Otherwise, creating
    a new instance resulted in a weird and confusing error:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，问题是忘记使用`Transaction`的`prototype`属性。它应该是`Object.create(Transaction.prototype)`。否则，创建一个新实例会导致奇怪且令人困惑的错误：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This error occurred because the code was attempting to alter the nonwritable
    `Function .name` property. Before symbols existed, you had to use normal properties
    to represent all metadata, such as the name of the function in this case. A much
    better alternative would have been to use a non-writable symbol so that adding
    a `name` property to your functions would have never caused a collision. With
    a symbol, a function’s name could be set as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误发生是因为代码试图修改不可写的`Function .name`属性。在符号存在之前，你必须使用普通属性来表示所有元数据，例如在这个例子中函数的名称。一个更好的替代方案是使用不可写的符号，这样在函数上添加`name`属性就永远不会引起冲突。使用符号，函数的名称可以设置如下：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Symbols can make objects more extensible by preventing the code from accidentally
    breaking API contracts or the internal workings of an object. If every object
    in JavaScript had a `Symbol('name')` property, for example, any object’s `toString`
    could easily use it in a consistent manner to enhance its own string representation,
    especially in stack traces of obfuscated code. (In section 7.5, you’ll learn about
    a well-known symbol that performs this task.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 符号可以通过防止代码意外破坏API合同或对象的内部工作来使对象更具可扩展性。例如，如果JavaScript中的每个对象都有一个`Symbol('name')`属性，那么任何对象的`toString`方法都可以轻松地以一致的方式使用它来增强其字符串表示，尤其是在混淆代码的堆栈跟踪中。（在第7.5节中，你将了解执行此任务的知名符号。）
- en: Furthermore, library authors could use symbols to force their users to adhere
    to conventions imposed by the library. The following sections present a couple
    of practical examples extracted from the blockchain application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，库作者可以使用符号强制用户遵守库强加的约定。以下几节将展示从区块链应用程序中提取的几个实际示例。
- en: Control protocols
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 控制协议
- en: Let’s look at an example that uses symbols to define a control protocol. As
    you know, a protocol is a convention (contract) that defines some behavior in
    the language. This behavior needs to be unique and must never clash with any other
    language feature. Symbols fit in nicely for this kind of task.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用符号定义控制协议的例子。正如你所知，协议是一种惯例（合同），它定义了某种行为在语言中的规则。这种行为需要是唯一的，并且绝不能与其他语言特性冲突。符号非常适合这类任务。
- en: The example that we’re about to discuss comes directly from our blockchain application.
    This concept is known as proof-of-work.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将讨论的例子直接来自我们的区块链应用程序。这个概念被称为工作量证明。
- en: Why is proof of work important?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么工作量证明很重要？
- en: For some asset to acquire value, it needs to be both scarce and hard to extract
    or obtain. The value of a resource also follows the rules of supply and demand.
    Oil and petroleum acquire value, for example, because they’re nonrenewable resources
    and expensive to extract. The process is the same for gold, silver, and diamonds,
    which require expensive mining processes. Similarly, bitcoin is capped at around
    21 million as of this writing, which looks like a large amount but is rather scarce
    compared with other forms of currency.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要使某些资产获得价值，它必须既稀缺又难以提取或获得。资源的价值也遵循供需规则。例如，石油和石油产品获得价值，因为它们是非可再生资源，提取成本高昂。黄金、银和钻石也是如此，它们需要昂贵的采矿过程。同样，截至本文撰写时，比特币的上限约为2100万，这看起来是一个很大的数字，但与其他货币形式相比却相当稀缺。
- en: The “mining” or proof-of-work process of Bitcoin for obtaining a new block could
    be rather expensive in terms of energy use. Although the algorithm is simple to
    understand, it’s time-consuming to run even with today’s computing capabilities.
    The puzzle involves finding a block’s cryptographic hash value that fulfils certain
    conditions. The hash value should be hard to find but easy to verify. The only
    condition we’ll implement is that the computed hash string must start with an
    arbitrary number of leading zeroes, given by the `block.difficulty` property.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以获得新块为目的的比特币“挖掘”或工作量证明过程在能源使用方面可能相当昂贵。尽管算法易于理解，但即使使用今天的计算能力，运行它也是耗时的。这个谜题涉及到找到一个满足某些条件的块的加密哈希值。哈希值应该难以找到但易于验证。我们将实施的唯一条件是计算出的哈希字符串必须以任意数量的前导零开始，由`block.difficulty`属性给出。
- en: The next listing shows the proof-of-work function and also introduces a new
    proposal, throw expressions ([https://github.com/tc39/proposal-throw-expressions](https://github.com/tc39/proposal-throw-expressions)),
    that will make error handling code leaner.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了工作量证明函数，并介绍了一个新的提案，即抛出表达式([https://github.com/tc39/proposal-throw-expressions](https://github.com/tc39/proposal-throw-expressions))，这将使错误处理代码更加精简。
- en: Listing 7.8 Proof-of work-algorithm (proof_of_work.js)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 工作量证明算法（proof_of_work.js）
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Uses a throw expression as a default parameter to throw an exception if the
    provided block is undefined
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用抛出表达式作为默认参数，如果提供的块未定义则抛出异常
- en: ❷ padStart is used to fill or pad the current string with another string and
    was added to JavaScript as part of the ECMAScript 2017 update. If difficulty is
    set to null or missing, it defaults to using a difficulty value of 2.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `padStart` 用于填充或填充当前字符串，它是作为 ECMAScript 2017 更新的一部分添加到 JavaScript 中的。如果难度设置为
    null 或缺失，则默认使用难度值为 2。
- en: ❸ Increments the nonce at every iteration
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在每次迭代时增加nonce值
- en: ❹ Rehashes the block
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 重新计算块的哈希
- en: ❺ Tests whether the new hash contains the string of leading zeroes
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 测试新的哈希是否包含前导零字符串
- en: Before we discuss the algorithm, let’s spend a little bit of time talking about
    `throw` expressions as used in listing 7.8\. A `throw` expression can be assigned
    like a value or an expression (function). Without it, the only way to throw exceptions
    in place of a default argument would be to wrap the exception inside a function.
    In other words, you would need to create a block context (`{}`) somewhere else
    in which `throw` is allowed. With this new feature, throwing an exception works
    like a first-class artifact, like any other object, and significantly cuts the
    amount of typing required. You will be able to throw exceptions in many ways,
    including parameter initializing (as used here); one-line arrow functions, conditionals,
    and switch statements; and even evaluation of logical operators, all without requiring
    a block scope. See appendix A for details on enabling this feature.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论算法之前，让我们花一点时间来谈谈列表 7.8 中使用的 `throw` 表达式。`throw` 表达式可以被赋值，就像一个值或表达式（函数）。如果没有它，代替默认参数抛出异常的唯一方法是将异常包裹在一个函数内部。换句话说，你需要在允许
    `throw` 的某个地方创建一个块上下文（`{}`）。有了这个新特性，抛出异常就像一等公民一样工作，就像任何其他对象一样，并且显著减少了所需的输入量。你将以多种方式抛出异常，包括参数初始化（如这里使用）；一行箭头函数、条件语句和开关语句；甚至逻辑运算符的评估，所有这些都不需要块作用域。有关启用此功能的详细信息，请参阅附录
    A。
- en: 'Listing 7.8 is a brute-force algorithm, as most proof-of-work functions are.
    `proofOfWork` will loop and compute the block’s hash until it starts with the
    given `hashPrefix`, created from a string of zeroes of size `block.difficulty`.
    Naturally, the higher the difficulty value, the harder it is to find that hash.
    In the real world, the miner that solves this puzzle first cashes in the mining
    reward, which is how miners are incentivized to invest and spend energy in dedicated
    mining infrastructure. Because a block’s data is constant at every iteration,
    the hash value is always the same, so you compute a nonce for it. (Nonce is jargon
    for a “number you use only once.”) You change the nonce in a certain way to differentiate
    the block’s data between hash calculations. If you recall the definition of `Block`,
    `nonce` is one the properties we provided to `HasHash`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 是一种暴力算法，因为大多数工作量证明函数都是。`proofOfWork` 将循环并计算块的哈希，直到它以给定的 `hashPrefix`
    开头，该 `hashPrefix` 由大小为 `block.difficulty` 的零字符串创建。显然，难度值越高，找到该哈希就越困难。在现实世界中，第一个解决这个谜题的矿工将兑换采矿奖励，这就是矿工被激励投资和消耗专用采矿基础设施的原因。因为每个迭代中块的日期是恒定的，所以哈希值总是相同的，所以你需要为它计算一个nonce值。（nonce是“一次使用”的术语。）你以某种方式更改nonce来区分哈希计算之间的块数据。如果你还记得
    `Block` 的定义，`nonce` 是我们提供给 `HasHash` 的属性之一：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What does this have to do with symbols? Remember that a blockchain is a large,
    distributed protocol. At any point in time, miners can be running any version
    of the software, so changes need to be made with caution and rolled out in a timely
    manner. To make enhancements or even bug fixes easier to apply to large Bitcoin
    networks, you must keep track of versions, and code must fork accordingly. In
    the real world, blocks contain metadata that keeps track of the version of the
    software. The following listing shows another part of the `Block` class that I
    omitted earlier for brevity.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这与符号有什么关系？记住，区块链是一个大型、分布式协议。在任何时间点，矿工可能正在运行软件的任何版本，因此需要谨慎地做出更改，并及时推出。为了使增强功能或甚至错误修复更容易应用于大型比特币网络，你必须跟踪版本，并且代码必须相应地进行分叉。在现实世界中，块包含元数据，用于跟踪软件的版本。以下列表显示了之前为了简洁而省略的
    `Block` 类的另一部分。
- en: Listing 7.9 Version property inside the `Block` class implemented as a symbol
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 `Block` 类内部的版本属性实现为符号
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Registers the software version as a global symbol
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将软件版本注册为全局符号
- en: Having each block tagged with a global version symbol allows you to preserve
    backward compatibility with blocks persisted with a previous version of your blockchain
    software. Symbols let you control this compatibility in a seamless and interoperable
    way.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在每个区块上标记一个全局版本符号，您可以保留与之前版本区块链软件持久化的区块的向后兼容性。符号让您能够以无缝和互操作的方式控制这种兼容性。
- en: Suppose that we want to push a new release of our software that enhances `proofOfWork`
    to make it a bit more challenging and harder to compute. Listing 7.10 shows the
    `mineNewBlockIntoChain` method of `BitcoinService`, which uses the global symbol
    registry to read the version of the software implementing a `Block` to decide
    how to route the logic behind proof-of-work. We can use dynamic `import` to load
    the right `proofOfWork` function to use.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，Node.js在其`console.log`的实现中尝试做类似的事情，检查提供的对象上的`inspect`方法，并在它可用时使用它。这个特性很笨拙，因为它很容易与您意外实现的自己的`inspect`方法冲突，导致`console.log`的行为出乎意料。因此，这个特性已被弃用。如果当时有符号的话，情况可能就不同了。
- en: Although I haven’t covered all the details of `async`/`await` yet, you should
    be able to follow the next listing because I covered dynamic `import` in chapter
    6 when handling a similar use case.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要推出软件的新版本，增强`proofOfWork`使其更具挑战性且更难计算。列表7.10显示了`BitcoinService`的`mineNewBlockIntoChain`方法，它使用全局符号注册表来读取实现`Block`的软件的版本，以决定如何路由工作量证明背后的逻辑。我们可以使用动态`import`来加载正确的`proofOfWork`函数。
- en: Listing 7.10 Mining a new block
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我还没有涵盖`async`/`await`的所有细节，但您应该能够理解下一个列表，因为我已经在第6章中处理了类似用例时介绍了动态`import`。
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using a symbol here is much better than adding a regular `version` property
    to every block, which is what you would have had to do pre-ECMAScript 2015\. This
    technique protects users of your API from accidentally breaking the contract by
    adding their own or modifying `version` at runtime. The following listing shows
    an enhanced proof-of-work implementation that uses a pseudorandom `nonce` value
    instead of incrementing it at every iteration.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用符号比在每个区块中添加一个常规的`version`属性要好得多，这是在ECMAScript 2015之前您必须做的事情。这种技术可以保护您的API用户免受意外破坏合约的风险，即添加他们自己的或修改运行时`version`。
- en: Listing 7.11 Enhanced proof-of-work algorithm (proof_of_work2.js)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.11增强型工作量证明算法（proof_of_work2.js）
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Instead of incrementing by 1, increments by a random number
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 而不是每次增加1，通过一个随机数进行增加
- en: In the real world, as blocks become more scarce and the difficulty parameter
    algorithm increases, it gets harder to compute the hash. Proof-of-work is one
    step required in transferring Bitcoin. In chapter 8, we’ll see the entire process
    involved in mining a new block into the chain and the reward that comes with it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，随着区块变得更加稀缺，难度参数算法增加，计算哈希变得更为困难。工作量证明是比特币转账过程中的一步。在第8章中，我们将看到将新块挖掘到链中涉及的整个过程及其带来的奖励。
- en: Section 7.4.3 looks at another practical example of symbols, this time involving
    functions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 7.4.3节探讨了符号的另一个实际例子，这次涉及到函数。
- en: 7.4.3 Serialization
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下一个列表以正确的方式做事，向负责返回其自身JSON表示的`Block`类添加了另一个全局符号属性。
- en: Serialization is the process of converting an object from one representation
    to another. One of the most common examples is going from an object in memory
    to a file (serialization), and from a file into memory (deserialization or hydration).
    Because different objects may need to control how they’re serialized, it’s a good
    idea to implement a serialization function that gives them this control.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化是将对象从一种表示形式转换为另一种表示形式的过程。最常见的一个例子是将内存中的对象转换为文件（序列化），以及从文件中恢复到内存（反序列化或活化）。由于不同的对象可能需要控制它们的序列化方式，因此实现一个允许它们进行这种控制的序列化函数是一个好主意。
- en: Years ago, Node.js tried to do a similar thing in its implementation of `console
    .log`, checking for the `inspect` method on the provided object and using it if
    it was available. This feature was clunky because it could easily clash with your
    own `inspect` method that you accidentally implemented to do something else, causing
    `console .log` to behave unexpectedly. As a result, the feature was deprecated.
    Had symbols been around back then, the story might have been different.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个增强型工作量证明实现，它使用伪随机的`nonce`值而不是在每次迭代中增加它。
- en: The next listing does things the right way, adding another global symbol property
    to the `Block` class in charge of returning its own JSON representation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.10挖掘新块
- en: Listing 7.12 `Symbol(toJson)` that creates a JSON representation of the object
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.12 `Symbol(toJson)`，用于创建对象的 JSON 表示形式
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Uses a global symbol so that it can be read out from other modules
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用全局符号，以便可以从其他模块中读取
- en: ❷ Uses optional chaining operator with the nullish coalesce operators, both
    added as part of the ECMAScript 2020 specification
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用可选链操作符与空值合并操作符，这两个操作符都是作为 ECMAScript 2020 规范的一部分添加的
- en: ❸ Converts data contents by using a toJson helper function (shown in listing
    7.14)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 `toJson` 辅助函数（如列表 7.14 所示）转换数据内容
- en: This JSON representation is a tailored, summarized version of the block’s data.
    With this function, any time you need JSON, you can consult this symbol from anywhere
    in your application—even across realms. Serializing a blockchain to JSON uses
    a helper called `toJson` that inspects this symbol. The following listing shows
    the code to serialize in `BitcoinService.serializeLedger`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JSON 表示形式是区块数据的定制、总结版本。使用这个函数，每次您需要 JSON 时，都可以从应用程序的任何地方（甚至跨领域）咨询这个符号。将区块链序列化为
    JSON 使用了一个名为 `toJson` 的辅助函数来检查这个符号。下面的列表显示了在 `BitcoinService.serializeLedger`
    中序列化的代码。
- en: Listing 7.13 Serializing a ledger as a list of JSON strings
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.13 将账本序列化为 JSON 字符串列表
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Uses the pipeline operator to run a sequence of functions, assuming that the
    pipes feature is enabled (appendix A)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用管道操作符运行一系列函数，假设管道功能已启用（附录 A）
- en: I’ve taken the liberty of combining many of the concepts you’ve learned in previous
    chapters. The most noticeable of these concepts is breaking logic into functions
    and currying those functions to make them easier to compose (or pipe). As you
    can see, I used the pipeline operator to combine this logic and return the data
    as a raw buffer that can be written to a file or sent over the network, effectively
    keeping side effects away from the main logic. The next listing shows the code
    for those helper functions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经自由地结合了您在前几章中学到的许多概念。其中最引人注目的是将逻辑分解成函数，并将这些函数柯里化以使它们更容易组合（或管道化）。如您所见，我使用了管道操作符来组合这个逻辑，并将数据作为原始缓冲区返回，可以将其写入文件或通过网络发送，从而有效地将副作用从主逻辑中分离出来。下一个列表显示了这些辅助函数的代码。
- en: Listing 7.14 Helper functions used in serializing an entire blockchain object
    to a buffer
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.14 用于将整个区块链对象序列化为缓冲区的辅助函数
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Spreads any object to an array
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将任何对象展开为数组
- en: ❷ Converts any object to a JSON string. If the object implements Symbol('toJson'),
    the code uses that as its JSON string representation; otherwise, it defaults to
    JSON.stringify.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将任何对象转换为 JSON 字符串。如果对象实现了 Symbol('toJson')，则代码使用该对象的 JSON 字符串表示形式；否则，它默认使用
    JSON.stringify。
- en: ❸ Helper function that applies a serializer function to elements of an array
    and joins the array using the provided delimiter
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 辅助函数，将序列化函数应用于数组的元素，并使用提供的分隔符连接数组
- en: ❹ Converts any string to a UTF-8 Buffer object
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将任何字符串转换为 UTF-8 缓冲区对象
- en: As you can see, `toJson` checks the object’s metaproperties first for any global
    JSON transformation symbol; otherwise, it falls back to `JSON.stringify` on all
    fields. The rest of the helper functions are ones that you’ve seen at some point
    and are simple to follow.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`toJson` 首先检查对象的元属性，看是否有任何全局 JSON 转换符号；如果没有，它将回退到对所有字段的 `JSON.stringify`。其余的辅助函数都是您在某些时候见过且易于理解的。
- en: 'Recall from chapter 4 that `pipe` is the reverse of `compose`. Alternatively,
    you could have written the logic in listing 7.13 this way, provided that you implemented
    or imported the `compose` combinator function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 回想第 4 章的内容，`pipe` 是 `compose` 的逆操作。或者，您也可以按照列表 7.13 中的这种方式编写逻辑，前提是您实现了或导入了 `compose`
    组合函数：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Custom symbols such as `Symbol.for('toJson``')` and `Symbol.for('version``')`
    are known to the entire application. This use of symbols is so far-reaching and
    compelling that JavaScript ships with a set of well-known system symbols of its
    own, which you can use to bend JavaScript’s runtime behavior to your desires.
    Section 7.5 explores these symbols.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义符号，如 `Symbol.for('toJson')` 和 `Symbol.for('version')`，在整个应用程序中都是已知的。这种符号的使用范围广泛且具有说服力，以至于
    JavaScript 自带了一套知名的系统符号，您可以使用这些符号来弯曲 JavaScript 的运行时行为以满足您的需求。第 7.5 节探讨了这些符号。
- en: 7.5 Well-known symbols
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 已知符号
- en: As you can use symbols to augment some key processes in your application, you
    can also use JavaScript’s well-known symbols as an introspection mechanism to
    hook into core JavaScript features and create some powerful behavior. These symbols
    are special and are meant to target the JavaScript runtime’s own behavior, whereas
    any custom symbols you declare can only augment userland code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，你可以使用符号来增强一些关键过程，同样，你也可以使用JavaScript中广为人知的符号作为一个内省机制，以钩入核心JavaScript特性并创建一些强大的行为。这些符号是特殊的，旨在针对JavaScript运行时的自身行为，而任何你声明的自定义符号只能增强用户代码。
- en: The well-known symbols are available as static properties of the `Symbol` API.
    In this section, we’ll briefly explore
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 已知的符号作为 `Symbol` API 的静态属性可用。在本节中，我们将简要探讨
- en: '`@@toStringTag`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@@toStringTag`'
- en: '`@@isConcatSpreadable`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@@isConcatSpreadable`'
- en: '`@@species`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@@species`'
- en: '`@@toPrimitive`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@@toPrimitive`'
- en: '`@@iterator`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@@iterator`'
- en: NOTE For simplicity and ease of documentation, a well-known `Symbol.<name>`
    is often abbreviated as `@@<name>`. `Symbol.iterator`, for example, is `@@iterator`,
    and `Symbol.toPrimitive` is `@@toPrimitive`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：为了简单和便于文档，已知的 `Symbol.<name>` 常常缩写为 `@@<name>`。例如，`Symbol.iterator` 是 `@@iterator`，而
    `Symbol.toPrimitive` 是 `@@toPrimitive`。
- en: 7.5.1 @@toStringTag
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.1 @@toStringTag
- en: Soon, you’ll try to log an object to the console by calling `toString`, only
    to get the infamous (and meaningless) message `'[object` `Object]'`. Fortunately,
    we now have a symbol that hooks into this behavior. JavaScript checks whether
    you have `toString` overridden in your own object, and if you don’t, it uses Object’s
    `toString` method, which internally hooks into a symbol called `Symbol.toStringTag`.
    I recommend adding this symbol to classes or objects for which you don’t have
    or need `toString` defined, because it will help you during debugging and troubleshooting.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，你将尝试通过调用 `toString` 将对象记录到控制台，但只会得到臭名昭著的（且毫无意义的）消息 `'[object Object]'`。幸运的是，我们现在有一个符号可以钩入这种行为。JavaScript
    会检查你是否在自己的对象中重写了 `toString`，如果没有，它将使用对象的 `toString` 方法，该方法内部会钩入一个名为 `Symbol.toStringTag`
    的符号。我建议将此符号添加到没有或不需要定义 `toString` 的类或对象中，因为它将有助于你在调试和故障排除过程中。
- en: 'Here are a couple of variations, the first using a computed-property syntax,
    used mostly in object literals, and the second using computed-getter syntax, used
    mostly inside classes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些变体，第一个使用计算属性语法，主要用于对象字面量中，第二个使用计算获取器语法，主要用于类内部：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now `toString` has a bit more information:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `toString` 有更多一点信息：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For objects built with classes and pseudoclassical constructors (chapter 2),
    to avoid hardcoding, you could use the more general
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用类和伪经典构造函数（第2章）构建的对象，为了避免硬编码，你可以使用更通用的
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`@@toStringTag` is also used for error handling. As an example, consider adding
    it to `Money`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`@@toStringTag` 也用于错误处理。例如，考虑将其添加到 `Money`：'
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you try to mutate `Money(''USD'',` `5)`, JavaScript throws the following
    error, using `toStringTag` to enhance the error message:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试修改 `Money('USD', 5)`，JavaScript 会抛出以下错误，使用 `toStringTag` 来增强错误信息：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 7.5.2 @@isConcatSpreadable
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.2 @@isConcatSpreadable
- en: This symbol is used to control the internal behavior of `Array#concat`. What
    outcome would you expect from this expression?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个符号用于控制 `Array#concat` 的内部行为。你期望从这个表达式中得到什么结果？
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Do you expect `[[''a''],` `[''b'']]` or `[''a'',` `''b'']`? Most of the time,
    you’d want the latter. And that is exactly what happens. When concatenating objects,
    `concat` determines whether any of its arguments are “spreadable.” In other words,
    it tries to unpack and flatten all the elements of the target object over another,
    using semantics similar to those of the spread operator. Here’s a simple example
    that shows the effect of this operator:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你期望得到 `[['a'], ['b']]` 还是 `['a', 'b']`？大多数情况下，你希望得到后者。这正是发生的情况。当连接对象时，`concat`
    会确定其任何参数是否是“可展开的”。换句话说，它试图解包并展平目标对象的所有元素，使用与展开操作符类似的语义。以下是一个简单的示例，展示了该操作符的效果：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In some cases, however, you don’t want the default behavior. Consider implementing
    record types, such as a `Pair`, as a simple array:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，你可能不希望有默认行为。考虑将记录类型，如 `Pair`，实现为一个简单的数组：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For `Pair`, you would not want to spread its elements by default when concatenating
    with another `Pair`, because then you’ll lose the proper two-element grouping:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Pair`，你不想在与其他 `Pair` 连接时默认展开其元素，因为这样你会失去正确的两个元素分组：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'What you want in this case is a collection of pairs. If you turn off the `Symbol.isConcatSpreadable`
    knob, everything works as expected:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你想要的是一对对的集合。如果你关闭 `Symbol.isConcatSpreadable` 开关，一切都会按预期工作：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The symbols described so far hook into some superficial behavior; others go
    even deeper into the nooks and crannies of the JavaScript APIs. Section 7.5.3
    looks at `Symbol.species`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止所描述的符号连接到一些表面的行为；其他则更深入地探索了 JavaScript API 的各个角落。第 7.5.3 节探讨了 `Symbol.species`。
- en: 7.5.3 @@species
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.3 @@species
- en: '`Symbol.species` is a nice, clever artifact used to control what the constructor
    should be on a resultant or derived object after operations are used on some original
    object. The following sections look at two use cases for this symbol: information
    hiding and documenting closure of operations.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbol.species` 是一个巧妙的艺术品，用于在操作某些原始对象后控制结果或派生对象的构造函数。以下几节将探讨此符号的两个用例：信息隐藏和记录操作封闭。'
- en: Information hiding
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 信息隐藏
- en: You can use `Symbol.species` to avoid exposing unnecessary implementation details
    by downgrading derived types to base types. Consider the simple use case in the
    next listing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Symbol.species` 将派生类型降级为基类型，以避免暴露不必要的实现细节。考虑以下列表中的简单用例。
- en: Listing 7.15 Using `@@species` so that `EvenNumbers` becomes `Array`
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.15 使用 `@@species` 使 `EvenNumbers` 成为 `Array`
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Excludes odd numbers from being pushed into this array
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 排除奇数被推入此数组
- en: ❷ Hides the derived class after any mapping operations
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在任何映射操作之后隐藏派生类
- en: 'At this point, this object created an instance of both `EvenNumber` and `Array`,
    as you’d expect. But the fact that this data structure was constructed from `EvenNumber`
    is not important to users of this API after it’s been initialized, because `Array`
    would be more than adequate. With the `@@species` metasymbol added, after mapping
    over this array, you see that the type is downgraded to `Array` and used thereafter
    for all operations (`some`, `every`, `filter`), effectively hiding the original
    object. Here’s an example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，此对象创建了一个 `EvenNumber` 和 `Array` 的实例，正如你所期望的。但这个数据结构是从 `EvenNumber` 构造的事实，在初始化后对
    API 的用户来说并不重要，因为 `Array` 已经足够好了。通过添加 `@@species` 元符号，在映射这个数组之后，你会看到类型被降级为 `Array`，并且之后用于所有操作（`some`、`every`、`filter`），实际上隐藏了原始对象。以下是一个例子：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Aside from `Array`, types such as `Promise` support this feature, as do data
    structures such as `Map` and `Set`. By default, `@@species` points to their default
    constructors:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Array` 之外，`Promise` 等类型以及 `Map` 和 `Set` 等数据结构都支持此功能。默认情况下，`@@species` 指向它们的默认构造函数：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here’s another example, this one using promises. Suppose that after some user
    action, you’d like to fire a task that starts after some period of time has elapsed.
    (Normally, you should not extend from built-in types, but I’ll make an exception
    here for teaching purposes.) After the first deferred action runs, every subsequent
    action should behave like a standard promise. Consider the `DelayedPromise` class
    shown in the following listing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子，这次使用承诺。假设在用户执行某些操作后，你希望在一段时间过去后启动一个任务。（通常，你不应该扩展内置类型，但为了教学目的，我会在这里破例。）在第一个延迟操作运行后，每个后续操作都应该像标准承诺一样表现。考虑以下列表中所示的
    `DelayedPromise` 类。
- en: Listing 7.16 Deriving `DelayedPromise` as a subclass of `Promise`
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.16 将 `DelayedPromise` 作为 `Promise` 的子类进行派生
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Creates a promise that delays its initial execution by the provided seconds
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个承诺，其初始执行延迟由提供的秒数
- en: ❷ Hides the derived class so that subsequent calls to then are not delayed
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 隐藏派生类，以便后续对 then 的调用不会延迟
- en: You can wrap any asynchronous task as you would any other promise, as shown
    next.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像包装任何其他承诺一样包装任何异步任务，如下所示。
- en: Listing 7.17 Using `DelayedPromise`
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.17 使用 `DelayedPromise`
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Returns the number 10 after three seconds
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在三秒后返回数字 10
- en: ❷ Squares the eventual number returned
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 平方最终返回的数字
- en: ❸ Uses the bind operator to pass in a reference to the log function of a properly
    bound console object
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用绑定运算符传入正确绑定的控制台对象的日志函数引用
- en: Documenting closure of operations
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 记录操作封闭
- en: 'Here’s another example in which `@@species` can be useful in an application,
    particularly in the area of functional programming. Let’s circle back to the `Functor`
    mixin in chapter 5 that implements a generic `map` contract:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子，其中 `@@species` 在应用程序中非常有用，尤其是在函数式编程领域。让我们回到第 5 章中实现的 `Functor` 混合，它实现了通用的
    `map` 协议：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Remember that functors have a special requirement for `map`: it must preserve
    the structure of the type being mapped over. `Array#map` should return a new `Array`,
    `Validation#map` should return a new `Validation`, and so on. You can use `@@species`
    to guarantee and document the fact that functors close over the type that you
    expect—helping preserve the species, you might say. It’s the responsibility of
    the implementer to respect this symbol when it exists. Arrays use this symbol,
    and we can add it to `Validation` as well, as shown in the following listing.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，泛函对 `map` 有特殊要求：它必须保留映射的类型结构。`Array#map` 应返回一个新的 `Array`，`Validation#map`
    应返回一个新的 `Validation`，依此类推。你可以使用 `@@species` 来保证并记录泛函封闭你期望的类型的事实——帮助保留物种，可以说。这是实现者的责任，当存在此符号时必须尊重它。数组使用此符号，我们也可以将其添加到
    `Validation` 中，如下所示。
- en: Listing 7.18 `@@species` as implemented in the `Validation` class
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.18 `@@species` 在 `Validation` 类中的实现
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ In a static context, refers to the surrounding class
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在静态上下文中，指代周围的类
- en: Then we can enhance `Functor` to hook into `@@species` before defaulting to
    the object’s constructor, as shown in the next listing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以增强 `Functor` 以在默认到对象构造函数之前挂钩到 `@@species`，如下所示列表。
- en: Listing 7.19 Inspecting the contents of `@@species` when mapping functions on
    functors
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.19 检查在泛函上映射函数时的 `@@species` 内容
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Looks into the species function-valued symbol first to decide the derived
    object type
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 首先查看物种函数值符号以决定派生对象类型
- en: ❷ Falls back to using constructor if no @@species symbol is defined
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果没有定义 @@species 符号，则回退到使用构造函数
- en: This code results in
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的结果是
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 7.5.4 @@toPrimitive
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.4 @@toPrimitive
- en: This symbol gets queried by JavaScript when it converts (or coerces) some object
    into a primitive value such as a string or a number—when you place an object next
    to a plus sign (`+`) or concatenate it to a string, for example. JavaScript already
    has a well-defined rule for its internal coercion algorithm (called an abstract
    operation) that goes by the name ToPrimitive.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript将某些对象转换为（或强制转换为）原始值，例如字符串或数字时（例如，当你将对象放在加号（`+`）旁边或将其连接到字符串时），它会查询此符号。JavaScript已经为其内部强制转换算法（称为抽象操作）定义了明确的规则，该规则名为ToPrimitive。
- en: '`Symbol.toPrimitive` customizes this behavior. This function-valued property
    accepts one parameter, `hint`, which could have a string value of `number`, `string`,
    or `default`. This operation is in many ways equivalent to overriding `Object#valueOf`
    and `Object#toString` (discussed in chapter 4), except for the additional hinting
    capability, which allows you to be smarter about the process. In fact, both of
    these methods are checked when `@@toPrimitive` is not defined and JavaScript needs
    to coerce an object into a value that makes sense. For strings and numbers, the
    general rule is as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbol.toPrimitive` 定制了这种行为。这个值函数属性接受一个参数 `hint`，它可以是字符串值 `number`、`string`
    或 `default`。在许多方面，这种操作等同于覆盖 `Object#valueOf` 和 `Object#toString`（在第4章中讨论），除了额外的提示功能，这允许你更智能地处理这个过程。实际上，当
    `@@toPrimitive` 未定义且JavaScript需要将对象强制转换为有意义的值时，这两个方法都会被检查。对于字符串和数字，一般规则如下：'
- en: When `hint` is a number, JavaScript attempts to use `valueOf`.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `hint` 是数字时，JavaScript尝试使用 `valueOf`。
- en: When `hint` is a string, JavaScript attempts to use `toString`.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `hint` 是字符串时，JavaScript尝试使用 `toString`。
- en: 'When implementing `@@toPrimitive`, we should try to stay consistent with these
    rules. A classic example is the `Date` object. When a `Date` object is `hint`ed
    to act as a string, its `toString` representation is used. If the object is `hint`ed
    as a number, its numerical representation (seconds from the epoch) is used:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 `@@toPrimitive` 时，我们应该尽量保持这些规则的一致性。一个经典的例子是 `Date` 对象。当 `Date` 对象被 `hint`
    为作为字符串时，使用其 `toString` 表示形式。如果对象被 `hint` 为数字，则使用其数值表示形式（从纪元起的秒数）：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Let’s go back to our `EvenNumbers` example, adding this symbol to that class
    with an implementation that sums all the numbers in the array when a number is
    requested or creates a comma-separated-values (CSV) string representation of the
    array in a string context, as shown in the next listing.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的 `EvenNumbers` 示例，向该类添加此符号，并实现当请求数字时对数组中的所有数字求和或在字符串上下文中创建数组的逗号分隔值（CSV）字符串表示形式，如下所示。
- en: Listing 7.20 Defining `@@toPrimitive` in class `EvenNumbers`
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.20 在类 `EvenNumbers` 中定义 `@@toPrimitive`
- en: '[PRE48]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ Returns a string representation of this array (showing only even numbers)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回此数组的字符串表示形式（仅显示偶数）
- en: ❷ Returns a single number representation of this array by adding up all even
    numbers
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过将所有偶数相加，返回该数组的单个数字表示。
- en: You can also think of `@@toPrimitive` as a means of unboxing or unfolding some
    container into its primitive value. The next listing adds this metasymbol to `Validation`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将`@@toPrimitive`视为一种将某些容器展开或展开为其原始值的方法。下一个列表将此元符号添加到`Validation`。
- en: Listing 7.21 Adding `@@toPrimitive` to the `Validation` class to extract its
    value
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.21 向`Validation`类添加`@@toPrimitive`以提取其值。
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ When a Validation instance is in a primitive position, the JavaScript runtime
    folds the container automatically.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当Validation实例处于原始位置时，JavaScript运行时会自动折叠容器。
- en: Now you can use these containers with less friction in the code because JavaScript
    takes care of the unboxing for you, as shown in the following listing.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以以更少的摩擦使用这些容器，因为JavaScript会为你处理展开，如下面的列表所示。
- en: Listing 7.22 Taking advantage of `@@toPrimitive` used with `Validation` objects
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.22 利用与`Validation`对象一起使用的`@@toPrimitive`。
- en: '[PRE50]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ The plus operator causes the Validation.Succes object to be in primitive position.
    It automatically unwraps the container with its value, 10.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加法运算符导致Validation.Succes对象处于原始位置。它自动展开包含其值的容器，值为10。
- en: ❷ The plus operator causes a Validation.Failure to wrongfully unbox and throw
    an error.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 加法运算符会导致Validation.Failure错误地展开并抛出错误。
- en: Value objects are also good opportunities to use this symbol. In `Money`, for
    example, we can use this symbol to return the numerical portion directly and make
    math operations easier and more transparent, as the next listing shows.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象也是使用此符号的好机会。例如，在`Money`中，我们可以使用此符号直接返回数值部分，使数学运算更容易且更透明，如下一个列表所示。
- en: Listing 7.23 Using `@@toPrimitive` in `Money` to return its numerical portion
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.23 在`Money`中使用`@@toPrimitive`返回其数值部分。
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ Both arithmetic operators unwrap Money objects to perform the numerical operation.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 两个算术运算符会将Money对象展开以执行数值运算。
- en: The last well-known symbol covered in this book, and by far the most useful,
    is `@@iterator`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所涵盖的最后一个著名的符号，也是迄今为止最有用的，是`@@iterator`。
- en: 7.5.5 @@iterator
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.5 `@@iterator`
- en: Most class-based languages have standard libraries that support some form of
    an `Iterable` or `Enumerable` interface. Classes that implement this interface
    must abide by a contract that communicates how to deliver data when some collection
    is looped over. JavaScript’s response is `Symbol.iterator`, which acts like one
    of these interfaces and is used to hook into the mechanics of how an object behaves
    when it’s the subject of a `for...of` loop, consumed by the spread operator, or
    even destructured.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于类的语言都有支持某种形式的`Iterable`或`Enumerable`接口的标准库。实现此接口的类必须遵守一个合同，该合同传达了在遍历某些集合时如何提供数据。JavaScript的响应是`Symbol.iterator`，它类似于这些接口之一，并用于挂钩对象在作为`for...of`循环的主题、由扩展运算符消费或甚至解构时的行为机制。
- en: 'As you can expect, all of JavaScript’s abstract data types already implement
    `@@iterator`, starting with arrays:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，JavaScript的所有抽象数据类型都已经实现了`@@iterator`，从数组开始：
- en: '[PRE52]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Arrays are an obvious choice. What about strings? You can think of a string
    as being a character array. Spread it, destructure it, or iterate over it, as
    the next listing shows.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个明显的选择。字符串呢？你可以将字符串视为字符数组。扩展它、解构它或遍历它，如下一个列表所示。
- en: Listing 7.24 Enumerating a string as a character array
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.24 将字符串枚举为字符数组。
- en: '[PRE53]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ❶ Spread operator
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 扩展运算符。
- en: ❷ Destructuring the array
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 解构数组。
- en: ❸ Manual iteration
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 手动迭代。
- en: Similarly, it makes sense that `Blockchain` could seamlessly deliver all blocks
    when it’s put through a `for` loop or spread over. After all, a blockchain is
    a collection of blocks. `Blockchain` delegates all of its block storage needs
    to a private instance field of `Map` (chapter 3). The following listing shows
    the pertinent details.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当`Blockchain`通过`for`循环或扩展运算符处理时，无缝地提供所有区块是有意义的。毕竟，区块链是一系列区块的集合。`Blockchain`将所有其区块存储需求委托给`Map`的私有实例字段（第3章）。以下列表显示了相关细节。
- en: Listing 7.25 Using `@@iterator` for blockchain
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.25 使用`@@iterator`进行区块链操作。
- en: '[PRE54]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ❶ Delegates to the iterator object returned from Map#values
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 委托给Map#values返回的迭代器对象。
- en: '`Map` is also iterable, so calling `values` on a `Map` object delivers the
    values (without keys) as an array, which is iterable by design, meaning we can
    easily have `Blockchain`’s `@@iterator` symbol delegate to it, as listing 7.25
    shows. The same is true for `Block` to deliver the items contained in `data`,
    which in this case is each `Transaction` object, as shown in the next listing.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 也是一个可迭代的对象，因此在对 `Map` 对象调用 `values` 时，会以数组的形式返回值（不包含键），这个数组是按设计可迭代的，这意味着我们可以轻松地让
    `Blockchain` 的 `@@iterator` 符号委托给它，如列表 7.25 所示。对于 `Block` 来说，也是如此，它将 `data` 中包含的项目（在这种情况下是每个
    `Transaction` 对象）交付出来，如以下列表所示。'
- en: Listing 7.26 Implementing `@@iterator` in `Block` to enumerate all transactions
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.26 在 `Block` 中实现 `@@iterator` 以枚举所有交易
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ❶ Automatically delivers transactions when a Block object is spread or looped
    over
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当 Block 对象被展开或循环遍历时自动交付交易
- en: 'To read out all the transactions in a block, loop over it:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取一个区块中的所有交易，遍历它：
- en: '[PRE56]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You have nothing to gain from iterating over a `Transaction`, which is a terminal/leaf
    object in our design. So you can let JavaScript error out abruptly if a user of
    your API tries to iterate over it, or you can manipulate the iterator yourself
    to handle this situation gracefully and silently by sending back the object `{done:`
    `true}`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设计中，`Transaction` 是一个终端/叶对象，遍历它没有任何好处。因此，如果您的 API 用户尝试遍历它，您可以允许 JavaScript
    突然出错，或者您可以自己操作迭代器，以优雅且无声地处理这种情况，通过返回对象 `{done:` `true}`：
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Iterator protocol
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器协议
- en: 'JavaScript has a well-defined iterator protocol that communicates to the runtime
    what the next value is and when iteration has reached its conclusion. The shape
    of that object looks like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有一个定义良好的迭代器协议，它向运行时传达下一个值是什么以及迭代何时结束。该对象的形状如下所示：
- en: '[PRE58]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Both iterators (and generators) in JavaScript work the same way. We’ll study
    generators in more depth in chapter 8 and async generators in chapter 9.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的迭代器（和生成器）工作方式相同。我们将在第 8 章深入研究生成器，在第 9 章深入研究异步生成器。
- en: Furthermore, `@@iterator` is a central part of the validation algorithm in `HasValidation`
    that we implemented in chapter 5, which relies on traversing the entire blockchain
    structure. Here’s that code again (listing 7.27).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`@@iterator` 是 `HasValidation` 中验证算法的核心部分，我们在第 5 章中实现它，该算法依赖于遍历整个区块链结构。以下是该代码的再次展示（列表
    7.27）。
- en: Listing 7.27 `HasValidation` mixin
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.27 `HasValidation` 混合
- en: '[PRE59]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ❶ Invokes the Symbol.iterator property of the object being validated
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用正在验证的对象的 Symbol.iterator 属性
- en: 'Now that you know that `@@iterator` plugs into the behavior of `for..of` as
    well as the spread operator, you can design a more memory-friendly solution than
    the algorithm in listing 7.27\. As it stands, `validate` is creating new arrays
    in memory when executing: `[...this]`. This code won’t scale to large data structures.
    Instead, you can loop over the objects inline with a more traditional `for` loop,
    as shown in the next listing.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道 `@@iterator` 连接到 `for..of` 循环和展开操作的行为，你可以设计一个比列表 7.27 中的算法更节省内存的解决方案。目前，`validate`
    在执行时会在内存中创建新的数组：`[...this]`。这段代码无法扩展到大型数据结构。相反，你可以使用更传统的 `for` 循环直接遍历对象，如以下列表所示。
- en: Listing 7.28 Refactoring `validate` to use `for` loops to benefit from `@@iterator`
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.28 将 `validate` 重构为使用 `for` 循环以利用 `@@iterator`
- en: '[PRE60]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ❶ Calls the internal @@iterator property of Blockchain, Block, and Transaction
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 Blockchain、Block 和 Transaction 的内部 @@iterator 属性
- en: You can do many things with `@@iterator`. Data structures that extend from or
    depend on arrays are natural candidates, but you can do much more, especially
    when you combine these structures with generators. A `Generator` is an object
    that is returned from a generator function and abides by the same iterator protocol.
    `@@iterator` is a function-valued property, and generators can implement it elegantly.
    The next listing shows a variation on a `Pair` object that uses a generator to
    `yield` the `left` and `right` properties during a destructuring assignment.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 `@@iterator` 做很多事情。从数组扩展或依赖的数据结构是自然的选择，但你还可以做更多，特别是当你将这些结构与生成器结合使用时。`Generator`
    是从生成器函数返回的对象，并遵循相同的迭代器协议。`@@iterator` 是一个函数值属性，生成器可以优雅地实现它。以下列表展示了 `Pair` 对象的一个变体，它使用生成器在解构赋值期间
    `yield` `left` 和 `right` 属性。
- en: Listing 7.29 Using a generator to return `left` and `right` elements of a `Pair`
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.29 使用生成器返回 `Pair` 的 `left` 和 `right` 元素
- en: '[PRE61]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ❶ The function* notation identifies a generator function.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数*符号标识一个生成器函数。
- en: ❷ The yield keyword is equivalent to a return in a regular function.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `yield` 关键字与常规函数中的 `return` 等效。
- en: Again, don’t worry too much now about how generators work behind the scenes.
    All you need to understand is that calls to `yield` within the function are analogous
    to calling the returned iterator object’s `next` method. Behind the scenes, JavaScript
    is taking care of this task for you. I’ll cover this topic in more detail in chapter
    8.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，现在不必过于担心生成器在幕后是如何工作的。你需要理解的是，函数内部的 `yield` 调用与调用返回的迭代器对象的 `next` 方法类似。幕后，JavaScript
    正在为你处理这项任务。我将在第 8 章中更详细地介绍这个话题。
- en: 'To sum up the well-known symbols, here’s `Pair` implementing all of the symbols
    at the same time, as well as our custom `[Symbol.for(''toJson'')]`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下众所周知的符号，这里有一个 `Pair` 实现了所有这些符号，以及我们的自定义 `[Symbol.for('toJson')]`：
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Normally, you wouldn’t load objects with all possible symbols; their true power
    comes from using the ones that truly affect your code globally to remove sources
    of duplication. These examples are for teaching purposes only.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会加载包含所有可能符号的对象；它们的真正力量来自于使用那些真正影响你代码全局性的符号来消除重复的来源。这些例子仅用于教学目的。
- en: You can hook into many symbols other than the ones discussed in this chapter.
    The following code
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以钩入本章未讨论的许多符号。以下代码
- en: '[PRE63]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: returns
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: '[PRE64]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: I’ll cover `@@asyncIterator` in chapter 8.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第 8 章中介绍 `@@asyncIterator`。
- en: As you can see, symbols allow you to create static hooks that you can use to
    apply a fixed enhancement to the behavior of your code. But what if you need to
    turn things on or off at runtime? In section 7.6, we turn our attention to other
    JavaScript APIs that dynamically hook into running code.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，符号允许你创建静态钩子，你可以使用这些钩子来对你的代码行为应用固定的增强。但如果你需要在运行时打开或关闭某些功能呢？在第 7.6 节中，我们将关注其他动态钩入运行代码的
    JavaScript API。
- en: 7.6 Dynamic introspection and weaving
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 动态内省和编织
- en: The techniques discussed so far fall under the umbrella of static introspection.
    You created tokens (aka symbols) that you or the JavaScript runtime can use to
    change how running code behaves. This technique, however, requires that you add
    symbols directly as properties of objects. For the extended functionality that
    well-known symbols give you, this is the only option. But when you’re considering
    any custom symbols, modifying the shape of objects syntactically may seem a bit
    invasive. Let’s consider another option.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的技术属于静态内省的范畴。你创建了标记（也称为符号），你可以或 JavaScript 运行时可以使用这些标记来改变运行代码的行为。然而，这种技术要求你直接将符号作为对象的属性添加。对于知名符号提供的扩展功能，这是唯一的选择。但是，当你考虑任何自定义符号时，从语法上修改对象的形状可能显得有些侵入性。让我们考虑另一个选项。
- en: In this section, you’ll learn about a technique that involves changing the behavior
    of your code externally via dynamic introspection. Along the way, you’ll learn
    how to use this technique to consolidate cross-cutting logic such as logging/tracing
    and performance, and even the implementation of smart objects.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解一种涉及通过动态内省外部改变代码行为的技术。在这个过程中，你将学习如何使用这项技术来整合跨切面逻辑，如日志/跟踪和性能，甚至智能对象的实现。
- en: JavaScript makes it easy to manipulate and change the shape and structure of
    objects at runtime. But special APIs allow you to hook into the event of calling
    a method or accessing a property. To understand the motivation here, it helps
    to think about the popular, widely used Proxy design pattern (figure 7.2).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 使得在运行时操纵和改变对象的形状和结构变得容易。但特殊的 API 允许你钩入调用方法或访问属性的触发事件。为了理解这里的动机，思考一下流行的、广泛使用的代理设计模式（图
    7.2）会有所帮助。
- en: '![](../Images/7-2.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-2.png)'
- en: Figure 7.2 The Proxy pattern uses an object (proxy) to act on behalf of a target.
    When fetching for a property, if it finds the property in the proxy, the code
    uses that property; otherwise, it consults the target object. Proxies have lots
    of uses, including logging, caching, and masking.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 代理模式使用一个对象（代理）代表目标对象进行操作。当获取属性时，如果它在代理中找到该属性，代码就会使用该属性；否则，它会咨询目标对象。代理有很多用途，包括日志记录、缓存和伪装。
- en: As shown in figure 7.2, a proxy is a wrapper to another object that is being
    called by a client to access the real internal object. The proxy object usurps
    an object’s interface and takes full control of how it’s accessed and used. Proxies
    are used quite a bit to interface network communications and filesystems, for
    example. Most notably, proxies are used in application code to implement a caching
    layer or perhaps a centralized logging system.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如图7.2所示，代理是一个包装器，它被客户端调用以访问真实内部对象。代理对象篡夺了一个对象的接口，并完全控制了其访问和使用方式。代理在接口网络通信和文件系统等方面被广泛使用。最值得注意的是，代理在应用程序代码中用于实现缓存层或可能是一个集中式日志系统。
- en: 'Instead of requiring you to roll your own proxy code scaffolding every time,
    JavaScript takes this pattern to heart and makes it first-class APIs: `Proxy`
    and `Reflect``.` Together, these APIs allow you to implement dynamic introspection
    so that you can weave or inject code at runtime in a non-invasive manner. This
    solution is optimal because it keeps your application separate from your injectable
    code. In some ways, this solution is similar to dynamic extension via mixins (chapter
    3), except that dynamic extension occurs during object construction, whereas dynamic
    weaving occurs during object use.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是要求你每次都自己编写代理代码框架，JavaScript将这种模式视为一等API：`Proxy`和`Reflect`。这两个API一起允许你实现动态内省，以便以非侵入的方式在运行时编织或注入代码。这种解决方案是最佳的，因为它使你的应用程序与可注入的代码分离。在某种程度上，这种解决方案类似于通过混入（第3章）的动态扩展，除了动态扩展发生在对象构造期间，而动态编织发生在对象使用期间。
- en: In section 7.6.1, we use dynamic introspection to weave performance counters
    and logging statements into important parts of the code without touching their
    implementation, beginning with the `Proxy` API.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在7.6.1节中，我们使用动态内省将性能计数器和日志语句编织到代码的重要部分，而不触及它们的实现，从`Proxy` API开始。
- en: 7.6.1 Proxy objects
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.1 代理对象
- en: Proxies have many practical uses, such as interception, tracing, and profiling.
    A `Proxy` object is one that can intercept or trap access to a target object’s
    properties. When an object is being used with a `get`, `set`, or method call,
    JavaScript’s internal [[Get]] and [[Set]] mechanisms are executed, respectively.
    You can use proxies to plant traps in your objects that hook into these internal
    operations.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 代理有许多实际用途，例如拦截、跟踪和性能分析。`Proxy`对象是一种可以拦截或捕获对目标对象属性访问的对象。当一个对象使用`get`、`set`或方法调用时，JavaScript的内部[[Get]]和[[Set]]机制分别执行。你可以使用代理在你的对象中设置陷阱，以挂钩到这些内部操作。
- en: Proxies enable the creation of objects with the full range of behaviors available
    to host objects. In other words, they look and behave like regular objects, so
    unlike symbols, they have no additional properties.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 代理允许创建具有主机对象可用的完整行为范围的对象。换句话说，它们看起来和表现就像普通对象一样，因此与符号不同，它们没有额外的属性。
- en: The first thing to understand about proxies is the handler object, which sets
    up the traps against the host object. You can intercept nearly any operation on
    an object and even inherited properties.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代理，首先需要了解的是处理程序对象，它设置了对主机对象的陷阱。你可以拦截对象上的几乎所有操作，甚至继承属性。
- en: NOTE You can apply many traps to an object. I don’t cover all traps in this
    book—only the most useful ones. For a full list, visit [http://mng.bz/zxlX](http://mng.bz/zxlX).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以对一个对象应用许多陷阱。本书中不涵盖所有陷阱——只涵盖最有用的。要获取完整列表，请访问[http://mng.bz/zxlX](http://mng.bz/zxlX)。
- en: 'Let’s start with an example that showcases a tracer proxy object to trace or
    log any property and method access, beginning with the `get` ([[Get]]) trap:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下示例开始，该示例展示了用于跟踪或记录任何属性和方法访问的跟踪器代理对象，从`get`([[Get]])陷阱开始：
- en: '[PRE65]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As you can see, after creating the log entry, the handler allows the default
    behavior to happen by returning a reference to the original property accessed
    by `target[key]`. To see this behavior in action, consider this object:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在创建日志条目后，处理程序通过返回`target[key]`访问的原始属性的引用来允许默认行为发生。为了看到这种行为的作用，考虑以下对象：
- en: '[PRE66]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Creating a proxied version of this object is simple:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此对象的代理版本很简单：
- en: '[PRE67]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The statements
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 语句
- en: '[PRE68]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'print the following logs:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 打印以下日志：
- en: '[PRE69]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: I said before that proxies allow you to intercept anything, and I mean anything,
    even symbols. So trying to log the object itself (not by calling `toString`) invokes
    certain symbols behind the scenes. This code
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，代理允许你拦截任何东西，我的意思是任何东西，甚至符号。所以尝试记录对象本身（不是通过调用`toString`）会触发幕后的一些符号。此代码
- en: '[PRE70]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: prints
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '[PRE71]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The dynamic weaving happens without the API objects having any knowledge of
    it, which is an ideal separation of concerns. We can get a bit more creative.
    Suppose that we’d like to obfuscate and hide any sensitive information (such as
    a password) from being read as plain text. Consider the handler in the next listing,
    which traps `get` and `has`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 动态编织发生时，API 对象本身没有任何知识，这是一个理想的关注点分离。我们可以更加有创意。假设我们想要混淆并隐藏任何敏感信息（如密码）不被作为纯文本读取。考虑以下列表中的处理程序，它拦截
    `get` 和 `has`。
- en: Listing 7.30 `passwordObfuscatorHandler` proxy handler
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.30 `passwordObfuscatorHandler` 代理处理程序
- en: '[PRE72]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ❶ U+2022 is Unicode for a bullet character (•).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ U+2022 是 Unicode 中用于项目符号字符（•）的编码。
- en: 'Now reading out a password from credentials returns the obfuscated value:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从凭证中读取密码会返回混淆后的值：
- en: '[PRE73]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'And checking for the password field with the `in` operator invokes the `has`
    trap:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `in` 操作符检查密码字段会触发 `has` 陷阱：
- en: '[PRE74]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Unfortunately, you seem to have lost the tracing behavior you had earlier.
    Because proxies wrap an object (and are themselves plain objects), you can apply
    proxies on top of proxies. In other words, proxies compose. Composing proxies
    allows you to implement progressive enhancement or decoration techniques:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你似乎失去了之前拥有的跟踪行为。因为代理封装了一个对象（并且自身是普通对象），你可以在代理之上应用代理。换句话说，代理可以组合。组合代理允许你实现渐进增强或装饰技术：
- en: '[PRE75]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The FP principles that you learned in chapter 4 apply here. You can turn those
    nested proxy objects into an elegant right-to-left `compose` pipeline. Consider
    this helper function:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第 4 章中学到的 FP 原则也适用于这里。你可以将这些嵌套的代理对象转换成一个优雅的从右到左 `compose` 管道。考虑以下辅助函数：
- en: '[PRE76]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`weave` takes a handler and waits for you to supply the host object, which
    can be credentials or a credential proxy. Let’s partially apply two handler functions,
    one for log tracing and the other for automatic password obfuscation:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`weave` 接收一个处理程序并等待你提供主机对象，这可以是凭证或凭证代理。让我们部分应用两个处理程序函数，一个用于日志跟踪，另一个用于自动密码混淆：'
- en: '[PRE77]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Compose the functions in the right order to obfuscate before printing:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 按正确的顺序组合函数以在打印前混淆：
- en: '[PRE78]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You can also use the more natural left-to-right pipe operator (provided that
    pipes are enabled). See how clean and terse the code becomes?
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用更自然的从左到右的管道操作符（前提是启用了管道）。看看代码变得多么简洁和简短？
- en: '[PRE79]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: It’s great to see how core principles apply to all sorts of scenarios. In this
    case, by combining metaprogramming with functional and object-oriented paradigms,
    we get a best-of-breed implementation.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 看到核心原则如何应用于各种场景真是太好了。在这种情况下，通过结合元编程、函数式和面向对象范式，我们得到了最佳的实施方案。
- en: 'In section 7.6.2, we look at the mirror API to a proxy handler: `Reflect`.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在 7.6.2 节中，我们查看代理处理程序的镜像 API：`Reflect`。
- en: 7.6.2 The Reflect API
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.2 Reflect API
- en: '`Reflect` is a complementary API to `Proxy` that you can use to invoke any
    interceptable property of an object dynamically. You could invoke a function by
    using `Reflect .apply`, for example. Arguably, you could also use the legacy parts
    of the language, such as `Function#{call,apply}`. `Reflect` has a similar shape
    to `Proxy`, but it provides a less verbose, more contextual, easier-to-understand
    API for these cases, which makes `Reflect` a more natural and reasonable way to
    forward actions on behalf of `Proxy` objects.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect` 是 `Proxy` 的补充 API，你可以用它动态地调用对象的可拦截属性。例如，你可以使用 `Reflect.apply` 来调用一个函数。可以说，你也可以使用语言的旧部分，如
    `Function#{call,apply}`。`Reflect` 与 `Proxy` 有类似的形状，但它为这些情况提供了一个更简洁、更上下文相关、更易于理解的
    API，这使得 `Reflect` 成为代表 `Proxy` 对象执行操作的一种更自然和合理的方式。'
- en: '`Reflect` packs the most useful internal object methods into a simple-to-use
    API. In other words, all the methods provided by proxy handlers—`get`, `set`,
    `has`, and others--are available here. You can also use `Reflect` to uncover other
    internal behavior about objects, such as whether a property was defined or a setter
    operation succeeded. You can’t get this information with regular reflective inquiries
    such as `Object.{getPrototypeOf`, `getOwnPropertyDescriptors`, and `getOwnPropertySymbols}`.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect` 将最有用的内部对象方法打包成一个简单易用的 API。换句话说，所有由代理处理程序提供的 `get`、`set`、`has` 以及其他方法在这里都是可用的。你还可以使用
    `Reflect` 来揭示关于对象的其他内部行为，例如属性是否已定义或设置操作是否成功。你不能通过常规的反射查询（如 `Object.{getPrototypeOf`,
    `getOwnPropertyDescriptors`, 和 `getOwnPropertySymbols}`）获得这些信息。'
- en: One example of some internal behavior exposed by `Reflect` is `Reflect.defineProperty`,
    which returns a Boolean stating whether a property was created successfully. By
    contrast, `Object.defineProperty` merely returns the object that was passed to
    the function. `Reflect.defineProperty` is more useful for this reason.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect` 暴露的一些内部行为的一个例子是 `Reflect.defineProperty`，它返回一个布尔值，表示属性是否成功创建。相比之下，`Object.defineProperty`
    仅返回传递给函数的对象。`Reflect.defineProperty` 由于这个原因更有用。'
- en: The sample code in the following listing takes advantage of the Boolean result
    to define a new property on an object.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的示例代码利用布尔结果在对象上定义一个新属性。
- en: Listing 7.31 Using `Reflect.defineProperty` to create a property
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.31 使用 `Reflect.defineProperty` 创建属性
- en: '[PRE80]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: ❶ Returning true means that the property was added successfully.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回 true 表示属性已成功添加。
- en: Again, because `Reflect`’s API matches that of the proxy handler for all traps,
    it’s naturally suitable to be the default behavior inside proxy traps. The [[Get]]
    trap for `passwordObfuscatorHandler`, for example, can be refactored as such,
    as shown next.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于 `Reflect` 的API与所有陷阱的代理处理器的API相匹配，它自然适合作为代理陷阱中的默认行为。例如，`passwordObfuscatorHandler`
    的 [[Get]] 陷阱可以重构为如下所示。
- en: Listing 7.32 [[Get]] trap of `passwordObfuscatorHandler`
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.32 `passwordObfuscatorHandler` 的 [[Get]] 陷阱
- en: '[PRE81]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: ❶ Uses Reflect.get(target, key) instead of target[key]
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 Reflect.get(target, key) 而不是 target[key]
- en: 'Furthermore, this API parity means that you don’t have to declare all parameters
    explicitly every time if you don’t need to use them. Let’s clean up `traceLogHandler`
    a bit:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个API兼容性意味着如果你不需要显式声明所有参数，你不必每次都这样做。让我们稍微清理一下 `traceLogHandler`：
- en: '[PRE82]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Section 7.6.3 discusses some interesting and practical uses for this feature.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 7.6.3 节讨论了此功能的一些有趣和实用的用途。
- en: 7.6.3 Additional use cases
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.3 其他用例
- en: In this section, you’ll learn about some interesting use cases for dynamic proxies
    in our blockchain application, starting with a smart block that knows to rehash
    itself on the fly when any of its hashed properties change. Then you’ll use proxies
    to measure the performance of the blockchain `validate` function.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解区块链应用中动态代理的一些有趣用例，从知道在散列属性发生变化时自动重新散列自己的智能区块开始。然后你将使用代理来衡量区块链 `validate`
    函数的性能。
- en: Autohashed blocks
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 自动散列的区块
- en: 'Recall that a block computes its own hash upon instantiation:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，一个区块在实例化时会计算自己的哈希值：
- en: '[PRE83]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: A hash value uniquely identifies a block, but it can get out of sync if some
    malicious actor changes or tampers with the block data, which is why validation
    algorithms for blockchain are so important. Ideally, if a block’s property value
    changes (a new transaction is added or its nonce gets incremented, for example),
    we should rehash it. To implement this behavior without proxies, you would need
    to define setters explicitly for all your mutable, hashed properties and call
    `this.calculateHash` when each one changes. The properties of interest are `index`,
    `timestamp`, `previousHash`, `nonce`, and `data`. You can imagine how much duplicated
    code that process would require.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希值唯一标识一个区块，但如果某些恶意行为者更改或篡改区块数据，它可能会失去同步，这就是为什么区块链的验证算法如此重要的原因。理想情况下，如果一个区块的属性值发生变化（例如添加新交易或其nonce增加），我们应该重新散列它。要实现这种行为而不使用代理，你需要为所有可变的、散列的属性定义显式的设置器，并在每个属性变化时调用
    `this.calculateHash`。感兴趣的属性有 `index`、`timestamp`、`previousHash`、`nonce` 和 `data`。你可以想象这个过程需要多少重复的代码。
- en: Consolidating this dynamic behavior is what proxies are all about. The ability
    to implement this on/off behavior from a single place is a plus too. Let’s start
    by creating the proxy handler, as the following listing shows.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种动态行为统一起来就是代理的全部意义。从单一位置实现这种开/关行为也是一个优点。让我们从创建代理处理器开始，如下面的列表所示。
- en: Listing 7.33 Implementing the `autoHashHandler` proxy handler
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.33 实现 `autoHashHandler` 代理处理器
- en: '[PRE84]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: ❶ Executing the default set behavior. Normally, it’s best to stay away from
    using arguments, but in this case, arguments make the code shorter.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 执行默认的设置行为。通常，最好避免使用参数，但在这个情况下，参数使代码更短。
- en: ❷ Reflect.apply calls calculateHash on the target object being proxied.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Reflect.apply 在代理的目标对象上调用 calculateHash。
- en: In this case, we used a function to return a handler that monitors the properties
    we want, as shown in the next listing.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用一个函数返回一个处理器，该处理器监视我们想要的属性，如下一个列表所示。
- en: Listing 7.34 Using `autoHashHandler` to automatically rehash an object that
    changes
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.34 使用 `autoHashHandler` 自动重新散列发生变化的对象
- en: '[PRE85]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: ❶ This [[Set]] operation calls calculateHash and updates the block’s hash value.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这个[[Set]]操作调用calculateHash并更新区块的哈希值。
- en: Making blocks autohashable is a nice property when you’re building your block
    objects, but you want to make sure that you revoke this behavior as soon as a
    block gets mined into the chain. (Checking the hash is part of validating the
    tamperproof nature of a blockchain.)
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建区块对象时，使区块自动可哈希是一个很好的属性，但你要确保一旦区块被挖入链中，就立即撤销这种行为。（检查哈希是验证区块链防篡改性质的一部分。）
- en: measuring performance with revocable proxies
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可撤销代理测量性能
- en: In the world of blockchains, one of the most important, time-consuming operations
    is validating the entire chain data structure from genesis to the last mined block.
    You can imagine the complexity of validating a ledger with millions of blocks,
    each with hundreds or thousands of transactions. Capturing and monitoring the
    performance of the chain’s `validate` method can be crucial, but you don’t want
    that code to litter the application code. Also, remember that `validate` is an
    extension through the `HasValidate` mixin, so adding the code there would mean
    measuring the validation time not only of blockchain, but also of each block,
    which we don’t need. To collect these metrics, we’ll use Node.js’ `process.hrtime`
    API. We’ll start by defining the proxy handler in the next listing.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块链的世界里，最重要且耗时的一项操作是从创世区块到最新挖矿区块验证整个链数据结构。你可以想象验证包含数百万个区块、每个区块有数百或数千笔交易的账本有多么复杂。捕捉和监控链的`validate`方法性能可能至关重要，但你不想让这段代码散布在应用程序代码中。此外，记住`validate`是通过`HasValidate`混入扩展的，所以在那里添加代码意味着不仅要测量区块链的验证时间，还要测量每个区块的验证时间，而这并不是我们需要的。为了收集这些指标，我们将使用Node.js的`process.hrtime`
    API。我们将在下一列表中定义代理处理程序。
- en: Listing 7.35 Defining the `perfCountHandler` proxy handler object
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.35 定义`perfCountHandler`代理处理程序对象
- en: '[PRE86]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: ❶ Uses BigInt to represent integers of arbitrary precision
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用BigInt表示任意精度的整数
- en: '`process.hrtime` is a high-resolution API that captures time in nanoseconds,
    using a new ECMAScript2020 primitive type called `BigInt`, which can perform arbitrary
    precision arithmetic and prevent any issues when operating with integer values
    that exceed 253 - 1 (the largest value that `Number` can represent in JavaScript).'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.hrtime`是一个高精度API，它以纳秒为单位捕捉时间，使用名为`BigInt`的新ECMAScript2020原始类型，它可以执行任意精度算术，并防止在操作超过253
    - 1（`Number`在JavaScript中可以表示的最大值）的整数值时出现任何问题。'
- en: 'We use this handler to instantiate our ledger object proxy. But because performance
    counters should be switchable (on/off) at runtime, instead of a plain proxy, we’re
    going to use a revocable proxy. A revocable proxy is nothing more than an object
    that has a `revoke` method, aside from the actual `proxy` object:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此处理程序来实例化我们的账本对象代理。但由于性能计数器应在运行时可切换（开启/关闭），我们不会使用普通代理，而是将使用可撤销代理。可撤销代理只不过是一个具有`revoke`方法的普通对象：
- en: '[PRE87]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'After a few blocks and transactions are added, at the end of calling `ledger.validate`,
    something like this prints to the console:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了几块和几笔交易之后，在调用`ledger.validate`的末尾，控制台会打印出类似以下内容：
- en: '[PRE88]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Instead of printing to the console, you can send this value to a special logger
    to monitor your blockchain’s performance. When you’re done, call `chain$RevocableProxy
    .revoke` to switch off and remove all traps from your target blockchain object.
    Let me remind you that the wonderful thing about this feature is the fact that
    whether it’s switched on or off, objects never have knowledge that any traps were
    installed in the first place.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不将此值打印到控制台，而是将其发送到特殊的记录器以监控你的区块链性能。完成后，调用`chain$RevocableProxy.revoke`来关闭并从目标区块链对象中移除所有陷阱。让我提醒你，这个特性的美妙之处在于，无论它是否开启，对象都不会知道最初安装了任何陷阱。
- en: A technique known as method decorators centers on the same idea. In section
    7.7, we’ll see how to use JavaScript’s Proxy API to emulate this technique.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 一种称为方法装饰器的技术集中在相同的思想上。在第7.7节中，我们将看到如何使用JavaScript的Proxy API来模拟这种技术。
- en: 7.7 Implementing method decorators
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 实现方法装饰器
- en: Method decorators help you separate and modularize cross-cutting (orthogonal)
    code from your business logic. Similar to proxies, a method decorator can intercept
    a method call and apply (decorate) code that runs before and after the method
    call and is useful for verifying pre- and postconditions or for enhancing a method’s
    return value.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 方法装饰器帮助你将横切（正交）代码从业务逻辑中分离和模块化。类似于代理，方法装饰器可以拦截方法调用，并在方法调用前后运行（装饰）代码，这对于验证先决条件和增强方法的返回值非常有用。
- en: 'For illustration purposes, let’s circle back to our simple `Counter` example:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明目的，让我们回到我们简单的 `Counter` 示例：
- en: '[PRE89]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We’ll write a decorator specification as an object literal that describes the
    actions or the functions to execute before and after a decorated method runs,
    as well as the names of the methods to decorate. Here’s the shape of this object:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个装饰器规范，作为一个对象字面量，描述在装饰方法运行前后要执行的操作或函数，以及要装饰的方法的名称。以下是这个对象的形状：
- en: '[PRE90]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `before` action preprocesses the method arguments, and the `after` action
    postprocesses the return value. In case you want to bypass or pass through any
    `before` or `after` action, the `identity` function (discussed in chapter 4) serves
    as a good placeholder.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`before` 操作预处理方法参数，而 `after` 操作后处理返回值。如果你想要绕过或传递任何 `before` 或 `after` 操作，可以使用（在第
    4 章中讨论的）`identity` 函数作为良好的占位符。'
- en: 'The next listing creates a custom decorator called `validation` that captures
    the following use case: “Validate the function arguments passed to the function
    calls `inc` and `dec` on `Counter` objects.”'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表创建了一个名为 `validation` 的自定义装饰器，它捕获以下用例：“验证传递给 `Counter` 对象上的 `inc` 和 `dec`
    函数调用的函数参数。”
- en: Listing 7.36 Defining a custom decorator object with `before` and `after` behavior
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.36 定义具有 `before` 和 `after` 行为的自定义装饰器对象
- en: '[PRE91]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: ❶ Applies checkLimit to enforce preconditions
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 应用 checkLimit 以强制执行先决条件
- en: ❷ Leaves the method’s return value untouched after it runs
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在运行后不改变方法的返回值
- en: ❸ Decorates both inc and dec methods
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 同时装饰 inc 和 dec 方法
- en: 'Here, we’re going to apply custom behavior before the method runs and use a
    pass-through function (`identity`) as the `after` action. `checkLimit` ensures
    that the number passed in is a valid, positive integer; otherwise, it throws an
    exception. Again, we’ll use the `throw` expression syntax to write the function
    as a single arrow function:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将在方法运行之前应用自定义行为，并使用一个透传函数（`identity`）作为 `after` 操作。`checkLimit` 确保传入的数字是有效的正整数；否则，它将抛出异常。同样，我们将使用
    `throw` 表达式语法将函数编写为单个箭头函数：
- en: '[PRE92]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: To wire all this code up, we use the `Proxy`/`Reflect` APIs to create our action
    bindings, using the `get` trap. The challenge is that `get` doesn’t let you gain
    access to the method call’s actual arguments; as you know, it gives the method
    reference in `target[key]`. Hence, we’ll have to use a higher-order function to
    return a wrapped function call instead. This trick was inspired by [http://mng.bz/0m7l](http://mng.bz/0m7l).
    Let’s define our action binding in the next listing.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有这些代码连接起来，我们使用 `Proxy`/`Reflect` API 通过 `get` 陷阱创建我们的操作绑定。挑战在于 `get` 不允许你访问方法调用的实际参数；正如你所知，它给出的是
    `target[key]` 中的方法引用。因此，我们将不得不使用一个高阶函数来返回一个包装后的函数调用。这个技巧是受 [http://mng.bz/0m7l](http://mng.bz/0m7l)
    启发的。让我们在下一个列表中定义我们的操作绑定。
- en: Listing 7.37 Main logic that applies a decorator to a proxy object
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.37 将装饰器应用于代理对象的主要逻辑
- en: '[PRE93]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: ❶ Saves a reference to the method property for later use
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 保存方法属性引用以供以后使用
- en: ❷ Returns a wrapped method reference that we can use to capture the arguments
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回一个包装后的方法引用，我们可以用它来捕获参数
- en: ❸ Applies the before action
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 应用 before 操作
- en: ❹ Executes the original method
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 执行原始方法
- en: ❺ Executes the original method
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 执行原始方法
- en: 'Now you can see how the object behaves with the decorator applied:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到应用了装饰器后对象的行为：
- en: '[PRE94]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: You can see in this example how `checkLimit` abruptly aborts the `inc` operation
    when it sees a negative value being passed to it. Figure 7.3 reinforces the interaction
    between the client API augmented with a decorator.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这个例子中看到，当 `checkLimit` 发现传递给它的值是负数时，它会突然中断 `inc` 操作。图 7.3 强调了装饰器增强的客户端 API
    之间的交互。
- en: '![](../Images/7-3.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-3.png)'
- en: Figure 7.3 The call to `counter$Proxy.inc` gets intercepted and wrapped with
    `before` and `after` actions. The method `argument` `(2)` is validated by `checkLimit`
    and allowed to pass through to the target object of `Counter`. Its result (`identity(3)`)
    is echoed on the way out by the `identity` function and is available to the caller.
    In the event that `checkLimit` detects an invalid value, however, a `RangeError`
    is returned to the caller.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 对 `counter$Proxy.inc` 的调用被拦截并使用 `before` 和 `after` 操作进行包装。方法 `argument`
    `(2)` 通过 `checkLimit` 进行验证，并被允许通过到 `Counter` 的目标对象。其结果（`identity(3)`）在返回过程中由 `identity`
    函数回显，并可供调用者使用。然而，如果 `checkLimit` 检测到无效值，则会向调用者返回一个 `RangeError`。
- en: Decorators are extremely useful for removing tangential code and keeping your
    business logic clean. It’s simple to see how you could also refactor use cases
    such as logging, password obfuscation, and performance counters as `before` or
    `after` advice.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器对于移除旁路代码并保持业务逻辑清晰极为有用。很容易看出，您还可以将日志记录、密码混淆和性能计数器等用例作为“之前”或“之后”的建议进行重构。
- en: In fact, a proposal for static decorators ([https://github.com/tc39/proposal
    -decorators](https://github.com/tc39/proposal-decorators)) uses native syntax
    to automate a lot of what we did here. These decorators would have the look and
    feel of TypeScript decorators, Java annotations, or C# attributes. You could annotate
    a method with `@trace`, `@perf`, `@before`, and `@after`, for example, and have
    all the wrapping code modularized and moved away from the function code itself.
    Static decorators are a feature to keep your eye on; they will significantly change
    the game of application and framework development. This feature is used extensively
    in the TypeScript Angular framework.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，一个关于静态装饰器的提案（[https://github.com/tc39/proposal-decorators](https://github.com/tc39/proposal-decorators)）使用原生语法来自动化我们在这里所做的大部分工作。这些装饰器将具有
    TypeScript 装饰器、Java 注解或 C# 属性的外观和感觉。例如，您可以用 `@trace`、`@perf`、`@before` 和 `@after`
    注解一个方法，并将所有包装代码模块化并从函数代码本身移开。静态装饰器是一个值得关注的特性；它们将极大地改变应用程序和框架开发的游戏规则。这个特性在 TypeScript
    Angular 框架中被广泛使用。
- en: NOTE Although you can do endless things by using reflection, whether via symbols
    or proxies, practice due diligence. There’s such a thing as too much reflection,
    and you don’t want your teammates who are debugging your code to spend hours figuring
    out why their code is not behaving as they expect it to, syntactically speaking.
    A good heuristic is duplication. When you find yourself writing the same or similar
    code over and over across your entire codebase, that’s a good indication that
    you can reach into introspection and/or code weaving to refactor and modularize
    it.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：尽管您可以通过使用反射（无论是通过符号还是代理）来做无数的事情，但请务必谨慎行事。过度使用反射是存在的，您不希望您的队友在调试代码时花费数小时来弄清楚为什么他们的代码没有按预期行为，从语法上讲。一个好的经验法则是重复。当您发现自己反复在整个代码库中编写相同或类似的代码时，这是一个很好的迹象，表明您可以深入到内省和/或代码编织中，对其进行重构和模块化。
- en: Summary
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Metaprogramming is the art of using the programming language itself to influence
    new behavior or to automate code. It can be implemented statically via symbols
    or dynamically via code weaving.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元编程是使用编程语言本身来影响新行为或自动化代码的艺术。它可以通过符号静态实现，或通过代码编织动态实现。
- en: The `Symbol` primitive data type is used to create unique, collision-free object
    properties.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol` 原始数据类型用于创建唯一、无碰撞的对象属性。'
- en: Symbols make objects extensible by preventing code from accidentally breaking
    API contracts or the internal workings of an object.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号通过防止代码意外破坏 API 协议或对象的内部工作来使对象可扩展。
- en: You can use symbols to create static hooks that you can use to alter your code’s
    behavior with regard to fundamental operations such as looping, primitive conversion,
    and printing.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用符号来创建静态钩子，这些钩子可以用来改变代码在基本操作（如循环、原始转换和打印）方面的行为。
- en: JavaScript ships with native reflection APIs such as `Proxy` and `Reflect`.
    These APIs allow you to weave code into the runtime representation of objects
    dynamically without polluting their interface with other concerns.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 随带原生的反射 API，如 `Proxy` 和 `Reflect`。这些 API 允许您动态地将代码编织到对象的运行时表示中，而不会污染它们的接口。
- en: JavaScript’s reflection APIs make it easy to develop method decorators, which
    allow you to implement cross-cutting behavior and modularize sources of duplication
    in your code.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 的反射 API 使得开发方法装饰器变得容易，这些装饰器允许您实现跨切面行为，并将代码中的重复源模块化。
