- en: '3 Event bus: The backbone of a Vert.x application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 事件总线：Vert.x应用程序的骨干
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的内容
- en: What the event bus is
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件总线是什么
- en: How to have point-to-point, request-reply, and publish/subscribe communications
    over the event bus
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在事件总线上进行点对点、请求/响应和发布/订阅通信
- en: The distributed event bus for verticle-to-verticle communication across the
    network
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于网络中verticle到verticle通信的分布式事件总线
- en: The previous chapter introduced *verticles*. A Vert.x application is made up
    of one or more verticles, and each verticle forms a unit for processing asynchronous
    events. It is common to specialize verticles by functional and technical concerns,
    such as having one verticle for exposing an HTTP API and another for dealing with
    a data store. This design also encourages the deployment of several instances
    of a given verticle for scalability purposes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了*verticles*。Vert.x应用程序由一个或多个verticles组成，每个verticle形成一个处理异步事件的单元。根据功能和技术的关注点专门化verticles是很常见的，例如，有一个verticle用于公开HTTP
    API，另一个用于处理数据存储。这种设计也鼓励为了可扩展性目的部署给定verticle的多个实例。
- en: What we have *not* covered yet is how verticles can communicate with each other.
    For example, an HTTP API verticle needs to *talk* to the data store verticle if
    the larger Vert.x application is to do anything useful.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未涵盖的是verticles如何相互通信。例如，如果更大的Vert.x应用程序要做任何有用的事情，HTTP API verticle需要与数据存储verticle“交谈”。
- en: Connecting verticles and making sure they can cooperate is the role of the *event
    bus*. This is important when building reactive applications--the event bus offers
    a way to transparently distribute event-processing work both inside a process
    and across several nodes over the network.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 连接各个节点并确保它们可以协作是*事件总线*的作用。这在构建响应式应用程序时非常重要——事件总线提供了一种在进程内部以及跨多个节点通过网络透明地分配事件处理工作的方式。
- en: 3.1 What is the event bus?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 什么是事件总线？
- en: The event bus is a means for sending and receiving messages in an asynchronous
    fashion. Messages are sent to and retrieved from *destinations*. A destination
    is simply a free-form string, such as `incoming.purchase.orders` or `incoming-purchase-orders`,
    although the former format with dots is preferred.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线是一种以异步方式发送和接收消息的手段。消息被发送到并从*目的地*检索。目的地只是一个自由形式的字符串，例如`incoming.purchase.orders`或`incoming-purchase-orders`，尽管前者带有点号的格式更受欢迎。
- en: Messages have a body, optional headers for storing metadata, and an expiration
    timestamp after which they will be discarded if they haven’t been processed yet.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 消息有一个主体，可选的头部用于存储元数据，以及一个过期时间戳，在此之后如果尚未处理，它们将被丢弃。
- en: Message bodies are commonly encoded using the Vert.x JSON representation. The
    advantage of using JSON is that it is a serialization format that can be easily
    transported over the network, and all programming languages understand it. It
    is also possible to use Java primitive and string types, especially as JVM languages
    that may be used for writing verticles have direct bindings for them. Last but
    not least, it is possible to register custom encoder/decoders (codecs) to support
    more specialized forms of message body serialization. For instance, you could
    write a codec for converting Java objects to a binary encoding of your own. It
    is rarely useful to do so, however, and JSON and string data cover most Vert.x
    applications’ needs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 消息主体通常使用Vert.x JSON表示法进行编码。使用JSON的优势在于它是一种易于通过网络传输的序列化格式，所有编程语言都理解它。还可能使用Java原始类型和字符串类型，特别是当用于编写verticles的JVM语言有直接绑定时。最后但同样重要的是，可以注册自定义编码器/解码器（codec）以支持更专业的消息主体序列化形式。例如，你可以编写一个将Java对象转换为自定义二进制编码的codec。然而，这样做很少有用，JSON和字符串数据覆盖了大多数Vert.x应用程序的需求。
- en: The event bus allows for decoupling between verticles. There is no need for
    one verticle to access another verticle class--all that is needed is to agree
    on destination names and data representation. Another benefit is that since Vert.x
    is polyglot, the event bus allows verticles written in different languages to
    communicate with each other without requiring any complex language interoperability
    layer, whether for communications inside the same JVM process or across the network.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线允许在verticles之间解耦。不需要一个verticle访问另一个verticle类——所需的一切只是就目的地名称和数据表示达成一致。另一个好处是，由于Vert.x是多语言的，事件总线允许用不同语言编写的verticles之间进行通信，而无需任何复杂的语言互操作性层，无论是同一JVM进程内的通信还是跨网络的通信。
- en: An interesting property of the event bus is that it can be extended outside
    of the application process. You will see in this chapter that the event bus also
    works across distributed members of a cluster. Later in this book you will see
    how to extend the event bus to embedded or external message brokers, to remote
    clients, and also to JavaScript applications running in a web browser.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线的一个有趣特性是它可以扩展到应用程序进程之外。你将在本章中看到事件总线也可以在集群的分布式成员之间工作。在本书的后面部分，你将看到如何将事件总线扩展到嵌入式或外部消息代理、远程客户端，以及运行在网页浏览器中的JavaScript应用程序。
- en: 'Communications over the event bus follow three patterns:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过事件总线进行的通信遵循三种模式：
- en: Point-to-point messaging
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点对点消息
- en: Request-reply messaging
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求/响应消息
- en: Publish/subscribe messaging
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布/订阅消息
- en: 3.1.1 Is the event bus just another message broker?
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 事件总线仅仅是另一个消息代理吗？
- en: Readers familiar with message-oriented middleware will have spotted the obvious
    resemblance between the event bus and a message broker. After all, the event bus
    exhibits familiar messaging patterns, such as the publish/subscribe pattern, which
    is popular for integrating distributed and heterogeneous applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉面向消息中间件的读者会发现事件总线与消息代理之间有明显的相似之处。毕竟，事件总线表现出熟悉的消息模式，如发布/订阅模式，这种模式在集成分布式和异构应用程序中很受欢迎。
- en: 'The short answer is that no, the Vert.x event bus is not an alternative to
    Apache ActiveMQ, RabbitMQ, ZeroMQ, or Apache Kafka. The longer explanation is
    that it is an *event* bus for verticle-to-verticle communications inside an application,
    not a *message* bus for application-to-application communications. As you will
    see later in this book, Vert.x integrates with message brokers, but the event
    bus is no replacement for this type of middleware. Specifically, the event bus
    does not do the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是，不，Vert.x事件总线不是Apache ActiveMQ、RabbitMQ、ZeroMQ或Apache Kafka的替代品。更长的解释是，它是一个应用于应用程序内部verticle到verticle通信的*事件*总线，而不是应用于应用程序到应用程序通信的*消息*总线。正如你将在本书后面看到的那样，Vert.x与消息代理集成，但事件总线不能替代此类中间件。具体来说，事件总线不执行以下操作：
- en: Support message acknowledgments
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持消息确认
- en: Support message priorities
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持消息优先级
- en: Support message durability to recover from crashes
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持消息持久性以从崩溃中恢复
- en: Provide routing rules
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供路由规则
- en: Provide transformation rules (schema adaptation, scatter/gather, etc.)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供转换规则（模式适应、分散/收集等）
- en: The event bus simply carries *volatile* events that are being processed asynchronously
    by verticles.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线简单地携带*易失性*事件，这些事件由verticles异步处理。
- en: Not all events are created equal, and while some may be lost, some may not.
    In our quest for writing *reactive applications*, you will see where to use data
    replication or message brokers such as Apache Kafka in combination with the event
    bus.[1](#pgfId-1012188)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有事件都是平等的，有些可能会丢失，而有些则不会。在我们编写*反应式应用程序*的过程中，你将看到在哪里使用数据复制或与事件总线结合使用消息代理，如Apache
    Kafka。[1](#pgfId-1012188)
- en: The event bus is a simple and *fast* event conveyor, and we can take advantage
    of it for most verticle-to-verticle interactions, while turning to more costly
    middleware for events that cannot be lost.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线是一个简单且*快速*的事件传输器，我们可以利用它进行大多数verticle到verticle的交互，而对于不能丢失的事件，则转向更昂贵的中间件。
- en: Tip Readers familiar with messaging patterns may want to skim the next three
    subsections, or even skip them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉消息模式的读者，可能希望快速浏览下一三个小节，甚至跳过它们。
- en: 3.1.2 Point-to-point messaging
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 点对点消息
- en: Messages are sent by producers to destinations, such as `a.b.c` in figure 3.1\.
    Destination names are free-form strings, but the convention in the Vert.x community
    is to use separating dots. For example, we could use `datastore.new-purchase-orders`
    to send new purchase orders to be stored in a database.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 消息由生产者发送到目的地，例如图3.1中的`a.b.c`。目的地名称是自由形式的字符串，但在Vert.x社区中，惯例是使用分隔点。例如，我们可以使用`datastore.new-purchase-orders`将新的采购订单发送到数据库中存储。
- en: With point-to-point messaging, one of the possibly multiple consumers picks
    a message and processes it. Figure 3.1 shows this with messages `M1`, `M2`, and
    `M3`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在点对点消息中，一个可能的多消费者之一选择一条消息并处理它。图3.1展示了消息`M1`、`M2`和`M3`。
- en: '![](../Images/CH03_F01_Ponge.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F01_Ponge.png)'
- en: Figure 3.1 Point-to-point messaging over the event bus
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 通过事件总线进行点对点消息
- en: Messages are distributed in a round-robin fashion among the consumers, so they
    split message processing in equal proportions. This is why in figure 3.1 the first
    consumer processes `M1` and `M3`, while the second consumer processes `M2`. Note
    that there is no fairness mechanism to distribute fewer messages to an overloaded
    consumer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 消息以轮询方式在消费者之间分发，因此它们以相等的比例分割消息处理。这就是为什么在图3.1中，第一个消费者处理`M1`和`M3`，而第二个消费者处理`M2`。请注意，没有公平机制来将更少的消息分配给过载的消费者。
- en: 3.1.3 Request-reply messaging
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 请求-回复消息
- en: In Vert.x, the request-reply messaging communication pattern is a variation
    on point-to-point messaging. When a message is sent in point-to-point messaging,
    it is possible to register a *reply* handler. When you do, the event bus generates
    a temporary destination name dedicated solely to communications between the request
    message producer that is expecting a reply, and the consumer that will eventually
    receive and process the message.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vert.x中，请求-回复消息通信模式是点对点消息的一种变体。在点对点消息中发送消息时，可以注册一个*回复*处理程序。当你这样做时，事件总线生成一个临时目的地名称，该名称仅用于期望得到回复的请求消息生产者和最终将接收并处理消息的消费者之间的通信。
- en: This messaging pattern works well for mimicking remote procedure calls, but
    with the response being sent in an asynchronous fashion, so there is no need to
    keep waiting until it comes back. For example, an HTTP API verticle can send a
    request to a data store verticle to fetch some data, and the data store verticle
    eventually returns a reply message.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种消息模式非常适合模拟远程过程调用，但由于响应是以异步方式发送的，因此不需要一直等待它返回。例如，一个HTTP API verticle可以向数据存储verticle发送请求以获取一些数据，而数据存储verticle最终返回一个回复消息。
- en: This pattern is illustrated in figure 3.2\. When a message expects a reply,
    a reply destination is generated by the event bus and attached to the message
    before it reaches a consumer. You can inspect the reply destination name through
    the event-bus message API if you want, but you will rarely need to know the destination,
    since you will simply call a `reply` method on the message object. Of course,
    a message consumer needs to be programmed to provide a reply when this pattern
    is being used.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在图3.2中得到了说明。当一条消息期望得到回复时，事件总线生成一个回复目的地，并在消息到达消费者之前将其附加到消息上。如果你想检查回复目的地名称，可以通过事件总线消息API进行，但你很少需要知道目的地，因为你只需在消息对象上调用一个`reply`方法。当然，消息消费者需要编程以在应用此模式时提供回复。
- en: '![](../Images/CH03_F02_Ponge.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F02_Ponge.png)'
- en: Figure 3.2 Request-reply messaging over the event bus
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 通过事件总线进行请求-回复消息
- en: 3.1.4 Publish/subscribe messaging
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.4 发布/订阅消息
- en: In publish/subscribe communications, there is even more decoupling between producers
    and consumers. When a message is sent to a destination, all subscribers receive
    it, as illustrated by figure 3.3\. Messages `M1`, `M2`, and `M3` are each sent
    by a different producer, and all subscribers receive the messages, unlike in the
    case of point-to-point messaging (see figure 3.1). It is not possible to specify
    reply handlers for publish/subscribe communications on the event bus.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布/订阅通信中，生产者和消费者之间的解耦程度更高。当一条消息发送到目的地时，所有订阅者都会收到它，如图3.3所示。消息`M1`、`M2`和`M3`分别由不同的生产者发送，所有订阅者都会收到这些消息，这与点对点消息的情况不同（见图3.1）。在事件总线上，无法为发布/订阅通信指定回复处理程序。
- en: '![](../Images/CH03_F03_Ponge.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F03_Ponge.png)'
- en: Figure 3.3 Publish/subscribe messaging over the event bus
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 通过事件总线进行发布/订阅消息
- en: Publish/subscribe is useful when you are not sure how many verticles and handlers
    will be interested in a particular event. If you need message consumers to get
    back to the entity that sent the event, go for request-reply. Otherwise, opting
    for point-to-point versus publish/subscribe is a matter of functional requirements,
    mostly whether all consumers should process an event or just one consumer should.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不确定有多少verticle和处理器会对特定事件感兴趣时，发布/订阅非常有用。如果你需要消息消费者返回到发送事件的实体，请选择请求-回复。否则，选择点对点与发布/订阅是功能需求的问题，主要是所有消费者是否应该处理一个事件，或者只有一个消费者应该处理。
- en: 3.2 The event bus in an example
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 示例中的事件总线
- en: Let’s put the event bus to use and see how we can communicate between independent
    verticles. The example that we’ll use involves several temperature sensors. Of
    course, we won’t use any hardware. Instead we’ll let temperatures evolve using
    pseudo-random numbers. We will also expose a simple web interface where temperatures
    and their average will be updated live.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用事件总线并看看我们如何在独立的垂直结构之间进行通信。我们将使用的示例涉及几个温度传感器。当然，我们不会使用任何硬件。相反，我们将让温度通过伪随机数演变。我们还将提供一个简单的网络界面，其中温度及其平均值将实时更新。
- en: '![](../Images/CH03_F04_Ponge.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F04_Ponge.png)'
- en: Figure 3.4 Screenshot of the web interface
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 网络界面截图
- en: A screenshot of the web interface is shown in figure 3.4\. It displays the temperatures
    from four sensors and keeps their average up to date. The communication between
    the web interface and the server will happen using *server-sent events*, a simple
    yet effective protocol supported by most web browsers.[2](#pgfId-1012619)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 网络界面的截图如图3.4所示。它显示了四个传感器的温度，并保持它们的平均值最新。网络界面和服务器之间的通信将使用 *server-sent events*，这是一种简单而有效的协议，大多数网络浏览器都支持。[2](#pgfId-1012619)
- en: '![](../Images/CH03_F05_Ponge.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F05_Ponge.png)'
- en: Figure 3.5 Overview of the example architecture
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 示例架构概述
- en: Figure 3.5 gives an overview of the application architecture. The figure shows
    two concurrent event communications annotated with ordering sequences `[1,` `2,`
    `3]` (a temperature update is being sent) and `[a,` `b,` `c,` `d]` (a temperature
    average computation is being requested).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5展示了应用架构的概述。图中显示了两个带有排序序列 `[1,` `2,` `3]`（正在发送温度更新）和 `[a,` `b,` `c,` `d]`（请求温度平均值计算）的并发事件通信。
- en: 'The application is structured around four verticles:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序围绕四个垂直结构构建：
- en: '`HeatSensor` generates temperature measures at non-fixed rates and publishes
    them to subscribers to the `sensor.updates` destination. Each verticle has a unique
    sensor identifier.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HeatSensor` 以非固定速率生成温度测量值，并将它们发布到订阅 `sensor.updates` 目的地的订阅者。每个垂直结构都有一个唯一的传感器标识符。'
- en: '`Listener` monitors new temperature measures and logs them using SLF4J.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Listener` 监控新的温度测量值并使用SLF4J记录它们。'
- en: '`SensorData` keeps a record of the latest observed values for each sensor.
    It also supports request-response communications: sending a message to `sensor
    .average` triggers a computation of the average based on the latest data, and
    the result is sent back as a response.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SensorData` 记录每个传感器的最新观测值。它还支持请求-响应通信：向 `sensor.average` 发送消息将触发基于最新数据的平均值计算，并将结果作为响应发送。'
- en: '`HttpServer` exposes the HTTP server and serves the web interface. It pushes
    new values to its clients whenever a new temperature measurement has been observed,
    and it periodically asks for the current average and updates all the connected
    clients.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpServer` 提供HTTP服务器并服务于网络界面。每当观察到新的温度测量值时，它都会将其推送到客户端，并定期请求当前平均值并更新所有已连接的客户端。'
- en: 3.2.1 Heat sensor verticle
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 温度传感器垂直结构
- en: The following listing shows the implementation of the `HeatSensor` verticle
    class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 `HeatSensor` 垂直结构类的实现。
- en: Listing 3.1 `Heatsensor` verticle implementation
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 `Heatsensor` 垂直实现
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ The sensor identifier is generated using a UUID.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 传感器标识符使用UUID生成。
- en: ❷ Updates are scheduled with a random delay between one and six seconds.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更新安排在1到6秒之间的随机延迟。
- en: ❸ publish sends a message to subscribers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 发布向订阅者发送消息。
- en: ❹ We schedule the next update.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们安排下一次更新。
- en: ❺ This computes a random positive or negative value to slightly modify the current
    temperature.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 这计算一个随机正数或负数以略微修改当前温度。
- en: The `HeatSensor` verticle class does not use any realistic temperature model
    but instead uses random increments or decrements. Hence, if you run it long enough,
    it may report absurd values, but this is not very important in our journey through
    reactive applications.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`HeatSensor` 垂直结构类不使用任何真实的温度模型，而是使用随机增减。因此，如果你运行足够长时间，它可能会报告荒谬的值，但这在我们通过反应式应用程序的旅程中并不重要。'
- en: The event bus is accessed through the `Vertx` context and the `eventBus()` method.
    Since this verticle does not know what the published values will be used for,
    we use the `publish` method to send them to subscribers on the `sensor.updates`
    destination. We also use JSON to encode data, which is idiomatic with Vert.x.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `Vertx` 上下文和 `eventBus()` 方法访问事件总线。由于这个垂直结构不知道发布的值将用于什么，我们使用 `publish` 方法将它们发送到
    `sensor.updates` 目的地的订阅者。我们还使用JSON编码数据，这是与Vert.x一致的。
- en: Let’s now look at a verticle that consumes temperature updates.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个消费温度更新的竖直类。
- en: 3.2.2 Listener verticle
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 监听竖直类
- en: The following listing shows the implementation of the `Listener` verticle class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了 `Listener` 竖直类的实现。
- en: Listing 3.2 `Listener` verticle implementation
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 `Listener` 竖直类实现
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ We don’t need the full double value, so we format all temperatures to two-decimal
    string representations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们不需要完整的双精度值，所以我们将所有温度格式化为两位小数的字符串表示。
- en: ❷ The consumer method allows subscribing to messages, and a callback handles
    all event-bus messages.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `consumer` 方法允许订阅消息，一个回调处理所有事件总线消息。
- en: ❸ The message payload is in the body.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 消息负载在主体中。
- en: ❹ We simply log.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们只是记录日志。
- en: The purpose of the `Listener` verticle class is to log all temperature measures,
    so all it does is listen to messages received on the `sensor.updates` destination.
    Since the emitter in the `HeatSensor` class uses a publish/subscribe pattern,
    `Listener` is not the only verticle that can receive the messages.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Listener` 竖直类的作用是记录所有温度测量值，所以它所做的只是监听在 `sensor.updates` 目标上接收到的消息。由于 `HeatSensor`
    类中的发射器使用发布/订阅模式，`Listener` 不仅仅是唯一可以接收消息的竖直类。'
- en: We did not take advantage of message headers in this example, but it is possible
    to use them for any metadata that does not belong to the message body. A common
    header is that of an “action,” to help receivers know what the message is about.
    For instance, given a `database.operations` destination, we could use an action
    header to specify whether we intend to query the database, update an entry, store
    a new entry, or delete a previously stored one.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们没有利用消息头，但可以使用它们来处理不属于消息体的任何元数据。一个常见的头是“操作”，以帮助接收者了解消息的内容。例如，给定 `database.operations`
    目标，我们可以使用操作头来指定我们是否打算查询数据库、更新条目、存储新条目或删除之前存储的条目。
- en: Let’s now look at another verticle that consumes temperature updates.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看另一个消费温度更新的竖直类。
- en: 3.2.3 Sensor data verticle
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 传感器数据竖直类
- en: The following listing shows the implementation of the `SensorData` verticle
    class.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了 `SensorData` 竖直类的实现。
- en: Listing 3.3 `Sensordata` verticle implementation
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 `Sensordata` 竖直类实现
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ We store the latest measurement of each sensor by its unique identifier.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们通过每个传感器的唯一标识符存储其最新的测量值。
- en: ❷ The start method only declares two event-bus destination handlers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `start` 方法只声明了两个事件总线目标处理器。
- en: ❸ When a new measurement is being received, we extract the data from the JSON
    body.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当接收到新的测量值时，我们从 JSON 主体中提取数据。
- en: ❹ The incoming message for average requests is not used, so it can just contain
    an empty JSON document.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对于平均请求的传入消息没有使用，所以它可以只包含一个空的 JSON 文档。
- en: ❺ The reply method is used to reply to a message.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ `reply` 方法用于回复消息。
- en: 'The `SensorData` class has two event-bus handlers: one for sensor updates and
    one for average temperature computation requests. In one case, it updates entries
    in a `HashMap`, and in the other case, it computes the average and responds to
    the message sender.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`SensorData` 类有两个事件总线处理器：一个用于传感器更新，另一个用于平均温度计算请求。在一种情况下，它更新 `HashMap` 中的条目，在另一种情况下，它计算平均值并回复消息发送者。'
- en: The next verticle is the HTTP server.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个竖直类是 HTTP 服务器。
- en: 3.2.4 HTTP server verticle
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 HTTP 服务器竖直类
- en: The HTTP server is interesting as it requests temperature averages from the
    `SensorData` verticle via the event bus, and it implements the server-sent events
    protocol to consume temperature updates.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 服务器很有趣，因为它通过事件总线从 `SensorData` 竖直类请求温度平均值，并实现了服务器发送事件协议来消费温度更新。
- en: Let’s start with the backbone of this verticle implementation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个竖直类实现的骨干开始。
- en: Server implementation
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器实现
- en: The following listing shows a classical example of starting an HTTP server and
    declaring a request handler.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了一个启动 HTTP 服务器并声明请求处理器的经典例子。
- en: Listing 3.4 Prologue of the HTTP server verticle implementation
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 HTTP 服务器竖直类实现的序言
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The HTTP server port is configured with 8080 as the default value.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ HTTP 服务器端口默认配置为 8080。
- en: ❷ The sendFile method allows the content of any local file to be streamed to
    the client. This closes the connection automatically.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `sendFile` 方法允许将任何本地文件的内容流式传输到客户端。这会自动关闭连接。
- en: ❸ Server-sent events will use the /sse resource, and we provide a method for
    handling these requests.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 服务器发送事件将使用 /sse 资源，我们提供了一个处理这些请求的方法。
- en: ❹ Anything else triggers an HTTP 404 (not found) response.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 任何其他触发都会返回 HTTP 404（未找到）响应。
- en: 'The handler deals with three cases:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器处理三种情况：
- en: Serving the web application to browsers
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向浏览器提供Web应用程序
- en: Providing a resource for server-sent events
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为服务器发送事件提供资源
- en: Responding with 404 errors for any other resource path
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何其他资源路径返回404错误
- en: Tip Manually dispatching custom actions depending on the requested resource
    path and HTTP method is tedious. As you will see later, the `vertx-web` module
    provides a nicer *router* API for conveniently declaring handlers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：手动根据请求的资源路径和HTTP方法分发自定义操作是繁琐的。正如你稍后将会看到的，`vertx-web`模块提供了一个更友好的*路由器*API，方便声明处理器。
- en: The web application
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序
- en: Let’s now see the client-side application, which is served by the HTTP server.
    The web application fits in a single HTML document shown in the following listing
    (I removed the irrelevant HTML portions, such as headers and footers).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看客户端应用程序，它由HTTP服务器提供。Web应用程序适合在以下列表中显示的单个HTML文档中（我移除了不相关的HTML部分，如页眉和页脚）。
- en: Listing 3.5 Web application code
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 Web应用程序代码
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ EventSource objects deal with server-sent events.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ EventSource对象处理服务器发送事件。
- en: ❷ This callback listens for server-sent events of type update.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个回调监听更新类型的服务器发送事件。
- en: ❸ The response data is plain text, and since the server will be sending JSON,
    we need to parse it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 响应数据是纯文本，由于服务器将发送JSON，我们需要解析它。
- en: ❹ If the sensor doesn’t have a div for displaying its data, we create it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果传感器没有用于显示数据的div，我们创建它。
- en: ❺ This updates a temperature div.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 这将更新一个温度div。
- en: ❻ This callback listens to server-sent events of type average.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 这个回调监听平均类型的服务器发送事件。
- en: The JavaScript code in the preceding listing deals with server-sent events and
    reacts to update the displayed content. We could have used one of the many popular
    JavaScript frameworks, but sometimes it’s good to get back to basics.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表中的JavaScript代码处理服务器发送事件并响应更新显示的内容。我们本可以使用许多流行的JavaScript框架之一，但有时回到基础是好的。
- en: Note You may have noticed that listing 3.5 uses a modern version of JavaScript,
    with *arrow functions*, no semicolons, and string templates. This code should
    work as is on any recent web browser. I tested it with Mozilla Firefox 63, Safari
    12, and Google Chrome 70\.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可能已经注意到列表3.5使用了现代版本的JavaScript，有*箭头函数*、没有分号和字符串模板。这段代码应该在任何最近的Web浏览器上正常工作。我在Mozilla
    Firefox 63、Safari 12和Google Chrome 70上进行了测试。
- en: Supporting server-sent events
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 支持服务器发送事件
- en: Let’s now focus on how server-sent events work, and how they can be easily implemented
    with Vert.x.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在关注服务器发送事件的工作原理，以及如何使用Vert.x轻松实现它们。
- en: 'Server-sent events are a very simple yet effective protocol for a server to
    push events to its clients. The protocol is text-based, and each event is a block
    with an event type and some data:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送事件是一个非常简单但有效的协议，允许服务器向其客户端推送事件。该协议基于文本，每个事件都是一个包含事件类型和一些数据的块：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Each block event is separated by an empty line, so two successive events look
    like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每个块事件由一个空行分隔，因此连续的两个事件看起来像这样：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Implementing server-sent events with Vert.x is very easy.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vert.x实现服务器发送事件非常简单。
- en: Listing 3.6 Supporting server-sent events
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 支持服务器发送事件
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ The text/event-stream MIME type is specified for server-sent events.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 服务器发送事件指定了text/event-stream MIME类型。
- en: ❷ Since this is a live stream, we need to prevent browsers and proxies from
    caching it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 由于这是一个实时流，我们需要防止浏览器和代理缓存它。
- en: ❸ We call consumer without a handler, as we need an object to cancel the subscription
    when the client disconnects.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们调用没有处理器的消费者，因为我们需要一个对象在客户端断开连接时取消订阅。
- en: ❹ Sending event blocks is just sending text.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 发送事件块只是发送文本。
- en: ❺ We update the average every second, so we need a periodic timer. Since it
    needs to be cancelled, we also use a form without a handler to get an object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 我们每秒更新一次平均值，因此需要一个周期性定时器。由于它需要取消，我们也使用一个没有处理器的形式来获取一个对象。
- en: ❻ request sends a message that expects a response. The reply is an asynchronous
    object, as it may have failed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 请求发送一个期望得到响应的消息。回复是一个异步对象，因为它可能失败了。
- en: ❼ When the client disconnects (or refreshes the page) we need to unregister
    the event-bus message consumer and cancel the periodic task that computes averages.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 当客户端断开连接（或刷新页面）时，我们需要注销事件总线消息消费者并取消计算平均值的周期性任务。
- en: Listing 3.6 provides the implementation of the `sse` method that deals with
    HTTP requests to the `/sse` resource. It declares one consumer for each HTTP request
    for temperature updates, and it pushes new events. It also declares a periodic
    task to query the `SensorData` verticle and maintain the average in a request-reply
    manner.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.6 提供了处理对 `/sse` 资源 HTTP 请求的 `sse` 方法的实现。它为每个温度更新请求声明一个消费者，并推送新事件。它还声明了一个周期性任务，以请求-响应方式查询
    `SensorData` verticle 并维护平均值。
- en: Since these two handlers are for an HTTP request, we need to be able to stop
    them when the connection is lost. This may happen because a web browser tab is
    closed, or simply on page reloads. To do that, we obtain *stream* objects, and
    we declare a handler for each, just like we would with forms that accept callbacks.
    You will see in the next chapter how to deal with stream objects, and when they
    are useful.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个处理程序是针对 HTTP 请求的，我们需要能够在连接丢失时停止它们。这可能是由于浏览器标签页被关闭，或者简单地页面重新加载。为此，我们获取 *流*
    对象，并为每个对象声明一个处理程序，就像我们处理接受回调的表单一样。你将在下一章中看到如何处理流对象，以及它们何时有用。
- en: We can also use a command-line tool, such as HTTPie or curl, against the running
    application to see the event stream, as in the following listing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用命令行工具，如 HTTPie 或 curl，对运行中的应用程序进行操作，以查看事件流，如下所示。
- en: Listing 3.7 Stream of SSE events using HTTPie
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.7 使用 HTTPie 列出 SSE 事件
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ The --stream flag allows streaming the response to the console rather than
    waiting for the server to end the connection.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 --stream 标志可以将响应流式传输到控制台，而不是等待服务器结束连接。
- en: ❷ Each event has a type.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每个事件都有一个类型。
- en: ❸ Since JSON is just text, it transports well as event data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 由于 JSON 只是文本，它作为事件数据传输得很好。
- en: Warning At the time of writing, server-sent events are supported by all major
    web browsers except those from Microsoft. There are some JavaScript *polyfills*
    that provide the missing functionality to Microsoft’s browsers, albeit with some
    limitations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在撰写本文时，除了微软的浏览器外，所有主流网页浏览器都支持服务器发送事件。有一些 JavaScript *polyfills* 提供了微软浏览器缺失的功能，尽管有一些限制。
- en: 3.2.5 Bootstrapping the application
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.5 启动应用程序
- en: Now that we have all the verticles ready, we can assemble them as a Vert.x application.
    The following listing shows a main class for bootstrapping the application. It
    deploys four sensor verticles and one instance of each other verticle.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有 verticle，我们可以将它们组装成一个 Vert.x 应用程序。以下列表显示了用于启动应用程序的主类。它部署了四个传感器
    verticle 和每个其他 verticle 的一个实例。
- en: Listing 3.8 Main class to bootstrap the application
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 用于启动应用程序的主类
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ We start four sensors.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们启动了四个传感器。
- en: ❷ We are using the variants of deployVerticle that use reflection to instantiate
    the verticle classes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们正在使用使用反射实例化 verticle 类的 deployVerticle 的变体。
- en: Running the `main` method of this class allows us to connect with a web browser
    to http://localhost:8080/. When you do, you should see a graphical interface similar
    to that in figure 3.4, with continuous live updates. The console logs will also
    display temperature updates.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此类的 `main` 方法允许我们通过网页浏览器连接到 http://localhost:8080/。当你这样做时，你应该看到一个类似于图 3.4
    的图形界面，并且有连续的实时更新。控制台日志也将显示温度更新。
- en: 3.3 Clustering and the distributed event bus
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 聚类和分布式事件总线
- en: 'Our use of the event bus so far has been *local*: all communications happened
    within the same JVM process. What is even more interesting is to use Vert.x *clustering*
    and benefit from a *distributed* event bus.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的事件总线是 *本地* 的：所有通信都在同一个 JVM 进程内发生。更有趣的是使用 Vert.x *聚类* 并从 *分布式* 事件总线中受益。
- en: 3.3.1 Clustering in Vert.x
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 Vert.x 中的聚类
- en: Vert.x applications can run in clustering mode where a set of Vert.x application
    nodes can work together over the network. They may be node instances of the same
    application and have the same set of deployed verticles, but this is not a requirement.
    Some nodes can have one set of verticles, while others have a different set.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 应用程序可以在聚类模式下运行，其中一组 Vert.x 应用程序节点可以在网络上协同工作。它们可能是同一应用程序的节点实例，并具有相同的已部署
    verticle 集合，但这不是必需的。一些节点可以有一组 verticle，而其他节点可以有不同的集合。
- en: 'Figure 3.6 shows an overview of Vert.x clustering. A *cluster manager* ensures
    nodes can exchange messages over the event bus, enabling the following set of
    functionalities:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 展示了 Vert.x 聚类的概览。一个 *集群管理器* 确保节点可以通过事件总线交换消息，从而实现以下功能集：
- en: Group membership and discovery allow discovering new nodes, maintaining the
    list of current nodes, and detecting when nodes disappear.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组成员资格和发现允许发现新的节点，维护当前节点的列表，并检测节点何时消失。
- en: Shared data allows maps and counters to be maintained cluster-wide, so that
    all nodes share the same values. Distributed locks are useful for some forms of
    coordination between nodes.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享数据允许在集群范围内维护映射和计数器，以便所有节点共享相同的值。分布式锁对于节点之间的一些协调形式非常有用。
- en: Subscriber topology allows knowing what event-bus destinations each node has
    interest in. This is useful for efficiently dispatching messages over the distributed
    event bus. If one node has no consumer on destination `a.b.c`, there is no point
    in sending events from that destination to that node.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅拓扑允许知道每个节点对哪些事件总线目的地感兴趣。这对于在分布式事件总线中高效地分发消息非常有用。如果一个节点在目的地`a.b.c`上没有消费者，就没有必要从该目的地向该节点发送事件。
- en: There are several cluster manager implementations for Vert.x based on Hazelcast,
    Infinispan, Apache Ignite, and Apache ZooKeeper. Historically Hazelcast was the
    cluster manager for Vert.x, and then other engines were added. They all support
    the same Vert.x clustering abstractions for membership, shared data, and event-bus
    message passing. They are all functionally equivalent, so you will have to choose
    one depending on your needs and constraints. If you have no idea which one to
    pick, I recommend going with Hazelcast, which is a good default.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Hazelcast、Infinispan、Apache Ignite和Apache ZooKeeper，有几个针对Vert.x的集群管理器实现。从历史上看，Hazelcast曾是Vert.x的集群管理器，然后添加了其他引擎。它们都支持相同的Vert.x集群抽象，包括成员资格、共享数据和事件总线消息传递。它们在功能上是等效的，所以你必须根据你的需求和限制来选择一个。如果你不确定该选择哪一个，我建议选择Hazelcast，这是一个好的默认选择。
- en: '![](../Images/CH03_F06_Ponge.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 Vert.x集群概述](../Images/CH03_F06_Ponge.png)'
- en: Figure 3.6 Overview of Vert.x clustering
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 Vert.x集群概述
- en: Finally, as shown in figure 3.6, the event-bus communications between nodes
    happen through direct TCP connections, using a custom protocol. When a node sends
    a message to a destination, it checks the subscriber topology with the cluster
    manager and dispatches the message to the nodes that have subscribers for that
    destination.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如图3.6所示，节点之间的事件总线通信是通过直接TCP连接，使用自定义协议进行的。当一个节点向目的地发送消息时，它会与集群管理器一起检查订阅拓扑，并将消息分发给有该目的地订阅者的节点。
- en: What cluster manager should you use?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用哪个集群管理器？
- en: There is no good answer to the question of which cluster manager you should
    use. It depends on whether you need special integration with one library, and
    also on what type of environment you need to deploy. If, say, you need to use
    the Infinispan APIs in your code, and not just Infinispan as the cluster manager
    engine for Vert.x, you should go with Infinispan to cover both needs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“你应该使用哪个集群管理器”这个问题，没有好的答案。这取决于你是否需要与某个库进行特殊集成，以及你需要部署的环境类型。比如说，如果你需要在你的代码中使用Infinispan
    API，而不仅仅是将Infinispan作为Vert.x的集群管理器引擎，你应该选择Infinispan来满足这两个需求。
- en: You should also consider your deployment environment. If you deploy to some
    environment where Apache ZooKeeper is being used, perhaps it would be a good choice
    to also rely on it for the Vert.x cluster manager.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该考虑你的部署环境。如果你部署到使用Apache ZooKeeper的环境，也许选择依赖它作为Vert.x集群管理器也是一个不错的选择。
- en: By default, some cluster managers use multicast communications for node discovery,
    which may be disabled on some networks, especially those found in containerized
    environments like Kubernetes. In this case, you will need to configure the cluster
    manager to work in these environments.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，一些集群管理器使用多播通信进行节点发现，这在某些网络中可能被禁用，尤其是在像Kubernetes这样的容器化环境中。在这种情况下，你需要配置集群管理器以在这些环境中工作。
- en: As mentioned earlier, in case of doubt, choose Hazelcast, and check the project
    documentation for specific network configuration, like when deploying to Kubernetes.
    You can always change to another cluster manager implementation later.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果有疑问，请选择Hazelcast，并检查项目文档以获取特定的网络配置信息，例如在部署到Kubernetes时。你总是可以在以后切换到另一个集群管理器实现。
- en: 3.3.2 From event bus to distributed event bus
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 从事件总线到分布式事件总线
- en: Let’s get back to the heat sensor application that we developed earlier in this
    chapter. Moving to a distributed event bus is transparent for the verticles.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到本章前面开发的温度传感器应用程序。迁移到分布式事件总线对verticles来说是透明的。
- en: 'We will prepare two main classes with different verticle deployments, as illustrated
    in figure 3.7:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将准备两个主类，具有不同的垂直部署，如图3.7所示：
- en: Four instances of `HeatSensor`, and one instance of `HttpServer` on port 8080
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个`HeatSensor`实例，一个8080端口的`HttpServer`实例
- en: Four instances of `HeatSensor`, one instance of `Listener`, one instance of
    `SensorData`, and one instance of `HttpServer` on port 8081 (so you can run and
    test it on the same host)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个`HeatSensor`实例，一个`Listener`实例，一个`SensorData`实例，以及一个8081端口的`HttpServer`实例（这样您就可以在同一主机上运行和测试它）
- en: '![](../Images/CH03_F07_Ponge.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F07_Ponge.png)'
- en: Figure 3.7 Clustered application overview
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 集群应用程序概述
- en: The goal is to show that by launching one instance of each deployment in clustering
    mode, verticles communicate just as if they were running within the same JVM process.
    Connecting with a web browser to either of the instances will give the same view
    of the eight sensors’ data. Similarly, the `Listener` verticle on the second instance
    will get temperature updates from the first instance.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是展示通过在集群模式下启动每种部署的一个实例，verticles之间的通信就像它们在同一个JVM进程中运行一样。通过网页浏览器连接到任一实例将显示八个传感器的相同数据视图。同样，第二个实例上的`Listener`
    verticle将从第一个实例获取温度更新。
- en: 'We will use Infinispan as the cluster manager, but you can equally use another
    one. Supposing your project is built with Gradle, you’ll need to add `vertx-infinispan`
    as a dependency:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Infinispan作为集群管理器，但您也可以使用另一个。假设您的项目是用Gradle构建的，您需要将`vertx-infinispan`作为依赖项添加：
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The following listing shows the implementation of the main class `FirstInstance`
    that we can use to start one node that doesn’t deploy all of the application verticles.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了主类`FirstInstance`的实现，我们可以使用它来启动一个节点，该节点不部署所有应用程序verticle。
- en: Listing 3.9 Code of the main class for the first instance
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9 第一个实例的主类代码
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Starting a clustered Vert.x application is an asynchronous operation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 启动集群Vert.x应用程序是一个异步操作。
- en: ❷ Upon success, we retrieve the Vertx instance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 成功后，我们检索Vertx实例。
- en: ❸ A potential cause of failure could be the absence of a cluster manager library.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 失败的可能原因是缺少集群管理器库。
- en: As you can see, starting an application in clustered mode requires calling the
    `clusteredVertx` method. The remainder is just classic verticle deployment.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，以集群模式启动应用程序需要调用`clusteredVertx`方法。其余部分只是经典的verticle部署。
- en: The code of the second instance’s main method is very similar and is shown in
    the following listing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个实例的主方法代码非常相似，如下所示。
- en: Listing 3.10 Code of the main class for the second instance
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.10 第二个实例的主类代码
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ We use a different port so you can start both instances on the same host.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们使用不同的端口，以便您可以在同一主机上启动两个实例。
- en: Both main classes can be run on the same host, and the two instances will discover
    each other. As before, you can start them from your IDE, or by running `gradle
    run -PmainClass=chapter3.cluster.FirstInstance` and `gradle run -PmainClass= chapter3.cluster.SecondInstance`
    in two different terminals.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 两个主类都可以在同一主机上运行，两个实例将相互发现。像以前一样，您可以从您的IDE启动它们，或者在不同的终端中运行`gradle run -PmainClass=chapter3.cluster.FirstInstance`和`gradle
    run -PmainClass= chapter3.cluster.SecondInstance`。
- en: Tip If you are using IPv6 and encountering issues, you can add the `-Djava.net.preferIPv4Stack=true`
    flag to the JVM parameters.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果您使用IPv6并遇到问题，可以将`-Djava.net.preferIPv4Stack=true`标志添加到JVM参数中。
- en: By default, the Vert.x Infinispan cluster manager is configured to perform discovery
    using network broadcast, so the two instances discover each other when they’re
    run on the same machine. You can also use two machines on the same network.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Vert.x Infinispan集群管理器配置为使用网络广播进行发现，因此当它们在同一台机器上运行时，两个实例会相互发现。您也可以使用同一网络上的两台机器。
- en: warning Network broadcast rarely works in cloud environments and many data centers.
    In these cases, the cluster manager needs to be configured to use other discovery
    and group membership protocols. In the case of Infinispan, the documentation has
    specific details at [https://infinispan.org/documentation/](https://infinispan.org/documentation/).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：网络广播在云环境中和数据中心很少工作。在这些情况下，集群管理器需要配置为使用其他发现和组成员资格协议。在Infinispan的情况下，文档中有具体的细节，请参阅[https://infinispan.org/documentation/](https://infinispan.org/documentation/)。
- en: Figure 3.8 shows the application running with one browser connected to the instance
    with port 8080 and another browser connected to the second instance with port
    8081, and we see logs from the `Listener` verticle in the background. As you can
    see, both instances display events from the eight sensors, and the first instance
    has its average temperature updated so it can interact with the `SensorData` verticle
    on the second instance.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8显示了运行在一个浏览器连接到端口8080的实例，另一个浏览器连接到端口8081的第二个实例的应用程序，我们看到了来自后台`Listener` verticle的日志。如图所示，两个实例都显示了来自八个传感器的事件，第一个实例的平均温度已更新，因此它可以与第二个实例上的`SensorData`
    verticle进行交互。
- en: '![](../Images/CH03_F08_Ponge.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8](../Images/CH03_F08_Ponge.png)'
- en: Figure 3.8 Screenshot of the application running in clustered mode
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 集群模式下应用程序的截图
- en: The distributed event bus is an interesting tool, as it is transparent to the
    verticles.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式事件总线是一个有趣的工具，因为它对verticles是透明的。
- en: Tip The event-bus API has `localConsumer` methods for declaring message handlers
    that only work *locally* when running with clustering. For instance, a consumer
    for destination `a.b.c` will not receive messages sent to that destination from
    another instance in the cluster.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：事件总线API有`localConsumer`方法用于声明仅在集群运行时本地工作的消息处理器。例如，针对目的地`a.b.c`的消费者将不会接收到来自集群中另一个实例发送到该目的地的消息。
- en: The next chapter discusses asynchronous data and event streams.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章讨论异步数据和事件流。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The event bus is the preferred way for verticles to communicate, and it uses
    asynchronous message passing.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件总线是verticles通信的首选方式，它使用异步消息传递。
- en: The event bus implements both publish/subscribe (one-to-many) and point-to-point
    (many-to-one) communications.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件总线实现了发布/订阅（一对多）和点对点（多对一）通信。
- en: While it looks like a traditional message broker, the event bus does not provide
    durability guarantees, so it must only be used for transient data.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然它看起来像传统的消息代理，但事件总线不提供持久性保证，因此只能用于临时数据。
- en: Clustering allows networked instances to communicate over the distributed event
    bus in a transparent fashion, and to scale the workload across several application
    instances.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群允许网络实例以透明的方式通过分布式事件总线进行通信，并将工作负载扩展到多个应用实例。
- en: '* * *'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: 1.For a thorough discussion of using Kafka, see Dylan Scott’s Kafka in Action
    (Manning, 2019).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 1.关于使用Kafka的详细讨论，请参阅Dylan Scott的《Kafka in Action》（Manning，2019）。
- en: 2.The W3C specification for server-sent events is available at [www.w3.org/TR/eventsource](http://www.w3.org/TR/eventsource).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 2.W3C关于服务器发送事件的规范可在[www.w3.org/TR/eventsource](http://www.w3.org/TR/eventsource)找到。
