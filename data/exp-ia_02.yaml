- en: 3  Foundations of Express
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 Express的基础
- en: As we saw in the previous chapter, Node.js comes with a number of built-in modules,
    one of which is called `http`. Node's HTTP module allows you to build an HTTP
    server that responds to HTTP requests from browsers (and more). In short, the
    HTTP module lets you build websites with Node!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，Node.js自带了许多内置模块，其中之一被称为`http`。Node的HTTP模块允许你构建一个能够响应浏览器（以及更多）HTTP请求的HTTP服务器。简而言之，HTTP模块让你能够使用Node构建网站！
- en: While you can build full web servers with nothing but Node's built-in HTTP module,
    you might not want to. As we discussed in Chapter 1 and saw in Chapter 2, the
    API exposed by the HTTP module is pretty minimal and doesn't do a lot of heavy
    lifting for you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以仅使用Node的内置HTTP模块构建完整的Web服务器，但你可能不想这样做。正如我们在第1章中讨论的，以及在第2章中看到的，HTTP模块公开的API相当有限，并没有为你做很多繁重的工作。
- en: 'That''s where Express comes in: it''s a helpful third-party module (that is,
    not bundled with Node.js). When you get right down to it, Express is really just
    an abstraction layer on top of Node''s built-in HTTP server. You could, in theory,
    write everything with "vanilla" Node and never touch Express. But as we''ll see,
    Express smooths out a lot of the difficult parts and says "don''t worry, you don''t
    need to deal with this ugly part. I''ll handle this!" In other words, it''s magic!'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正是Express在这里发挥作用：它是一个有用的第三方模块（即，不是与Node.js捆绑在一起的）。实际上，你可以用“纯”Node编写一切，而无需接触Express。但正如我们将看到的，Express简化了许多困难的部分，并说“别担心，你不需要处理这部分丑陋的部分。我会处理这个！”换句话说，它就像魔法一样！
- en: In this chapter, we'll spring off of our Node knowledge and make an effort to
    really understand Express. We'll talk about its relationship to bare Node, the
    concepts of middleware and routing, and learn the other nice features Express
    gives us. In future chapters, we'll go more in depth; this chapter will give a
    code-heavy overview of the framework.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从我们的Node知识出发，努力真正理解Express。我们将讨论它与“纯”Node的关系，中间件和路由的概念，以及学习Express为我们提供的其他优秀功能。在未来的章节中，我们将更深入地探讨；本章将给出一个代码密集的框架概述。
- en: 'At a high level, Express really just gives us four major features, which we''ll
    be learning about in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，Express实际上只提供了四个主要功能，我们将在本章中学习这些功能：
- en: 1.  In contrast to "vanilla" Node, where your requests only flow through one
    function, Express has a "middleware stack", which is effectively an array of functions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 与“纯”Node相比，其中你的请求只通过一个函数，Express有一个“中间件栈”，这实际上是一个函数数组。
- en: 2.  Routing is a lot like middleware, but the functions are only called when
    you visit a specific URL with a specific HTTP method. For example, you could only
    run a request handler when the browser visits `yourwebsite.com/about`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 路由与中间件类似，但只有在访问特定URL并使用特定HTTP方法时才会调用函数。例如，你可以在浏览器访问`yourwebsite.com/about`时仅运行请求处理器。
- en: 3.  Express also extends request and response with a bunch of extra methods
    and properties for developer convenience.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 3. Express还扩展了请求和响应，为开发者提供了许多额外的方法和属性，以便于使用。
- en: 4.  Views allow you to dynamically render HTML. This both allows you to change
    the HTML on the fly and allows you to write the HTML in other languages.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 视图允许你动态渲染HTML。这不仅允许你在飞行中更改HTML，还允许你用其他语言编写HTML。
- en: We'll build a simple guestbook in this chapter to get a feel for these four
    features.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章构建一个简单的留言簿，以了解这四个功能。
- en: 3.1     Middleware
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 中间件
- en: 'One of Express''s biggest features is called "middleware". Middleware is very
    similar to the request handlers we saw in "vanilla" Node (accepting a request
    and sending back a response), but middleware has one important difference: rather
    than having just one handler, middleware allows for many to happen in sequence.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Express的一个最大特性被称为“中间件”。中间件与我们在“纯”Node中看到的请求处理器非常相似（接受请求并返回响应），但中间件有一个重要的区别：它不仅仅有一个处理器，中间件允许多个处理器按顺序发生。
- en: Middleware has a variety of applications, which we'll explore. For example,
    one middleware could log all requests, and then continue onto another middleware
    that sets special HTTP headers for every request, which could then continue further.
    While we could do this with one large request handler, we'll see that it's often
    preferable to decompose these disparate tasks into separate middleware functions.
    If this is confusing now, don't worry—we'll have some helpful diagrams and get
    into some concrete examples.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件有多种应用，我们将探讨。例如，一个中间件可以记录所有请求，然后继续到另一个为每个请求设置特殊 HTTP 标头的中间件，然后继续进一步。虽然我们可以用一个大的请求处理器来完成这个任务，但我们会看到，通常将不同的任务分解成单独的中间件函数更可取。如果你现在感到困惑，不要担心——我们将有一些有用的图表和一些具体的例子。
- en: ANALOGS IN OTHER FRAMEWORKS Middleware isn't unique to Express; it's present
    in a lot of other places in different forms. Middleware is present in other web
    application frameworks like Python's Django or PHP's Laravel. Ruby web applications
    also have this concept, often called "Rack middleware". This concept may not be
    radically new to you, though Express has its own flavor of middleware.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他框架中的类似之处 中间件并不仅限于 Express；它在很多其他地方以不同的形式存在。中间件存在于其他 Web 应用程序框架中，如 Python
    的 Django 或 PHP 的 Laravel。Ruby Web 应用程序也有这个概念，通常称为 "Rack 中间件"。尽管 Express 有自己独特的中间件风味，但这个概念可能对你来说并不陌生。
- en: Let's start rewriting out "Hello, World" application using Express's middleware
    feature. We'll see that it has far fewer lines of code, which can help us speed
    up development time and reduce the number of potential bugs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用 Express 的中间件功能重写我们的 "Hello, World" 应用程序。我们会看到它有更少的代码行，这可以帮助我们加快开发速度并减少潜在错误的数量。
- en: 3.1.1  "Hello, World" with Express
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 使用 Express 的 "Hello, World"
- en: Let's set up a new Express project. Make a new directory and put a file called `package.json` inside.
    Recall that `package.json` is how we store information about a Node project. It
    lists simple data like the project's name and author, and also contains information
    about its dependencies.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个新的 Express 项目。创建一个新的目录，并在其中放置一个名为 `package.json` 的文件。回想一下，`package.json`
    是我们存储有关 Node 项目信息的方式。它列出了简单的数据，如项目的名称和作者，还包含有关其依赖项的信息。
- en: 'Start with a skeleton `package.json`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个骨架 `package.json` 开始：
- en: Listing 3.1 A bare-bones package.json
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 一个裸骨的 package.json
- en: '`{` `  "name": "hello-world",` `  "author": "Your Name Here!",` `  "private":
    true,` `  "dependencies": {}``}`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "name": "hello-world",` `  "author": "Your Name Here!",` `  "private":
    true,` `  "dependencies": {}``}`'
- en: '...and then install Express and save it to your `package.json`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '...然后安装 Express 并将其保存到你的 `package.json` 中：'
- en: '`npm install express –save`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm install express –save`'
- en: 'Running this command will find Express in the directory of third-party Node
    packages and fetch the latest version. It will put it in a folder called `node_modules/`.
    Adding `--save` to the installation command will save it under the`dependencies` key
    of `package.json`. After running this command, your `package.json` will look something
    like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将在第三方 Node 软件包目录中查找 Express 并获取最新版本。它将把它放在一个名为 `node_modules/` 的文件夹中。将
    `--save` 添加到安装命令中，它将保存到 `package.json` 的 `dependencies` 键下。运行此命令后，你的 `package.json`
    将类似于以下内容：
- en: Listing 3.2 package.json after installing Express with the --save flag
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 使用 --save 标志安装 Express 后的 package.json
- en: '`{` `  "name": "hello-world",` `  "author": "Your Name Here!",` `  "private":
    true,` `  "dependencies": {` `    "express": "^4.10.5"` `  }` `}`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "name": "hello-world",` `  "author": "Your Name Here!",` `  "private":
    true,` `  "dependencies": {` `    "express": "^4.10.5"` `  }` `}`'
- en: 'Alright, now we''re ready. Save this file into app.js:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们准备好了。将此文件保存为 app.js：
- en: Listing 3.3 "Hello, World" with Express
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 使用 Express 的 "Hello, World"
- en: '`var express = require("express");  #A` `var http = require("http");` `var
    app = express();   #B`   `app.use(function(request, response) {  #C` `  response.writeHead(200,
    { "Content-Type": "text/plain" });      #C` `  response.end("Hello, World!"); 
    #C` `});  #C`   `http.createServer(app).listen(3000);  #D`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");  #A` `var http = require("http");` `var
    app = express();   #B` `app.use(function(request, response) {  #C` `  response.writeHead(200,
    { "Content-Type": "text/plain" });      #C` `  response.end("Hello, World!"); 
    #C` `});  #C` `http.createServer(app).listen(3000);  #D`'
- en: '#A There''s a new kid on the block: the Express module. We require it just
    like we require the http module.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 块中有一个新成员：Express 模块。我们像要求 http 模块一样要求它。'
- en: '#B To start a new Express application, we simply call the express function.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 要启动一个新的 Express 应用程序，我们只需调用 express 函数。'
- en: '#C This function is called "middleware". As we''ll see, it looks an awful lot
    like the request handlers from before.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 这个函数被称为 "中间件"。正如我们将看到的，它看起来非常像之前的请求处理器。'
- en: '#D Start the server up!'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 启动服务器！'
- en: Now let's step through this.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们逐步分析这个。
- en: First, we require Express. We then require Node's HTTP module just like we did
    before. We're ready.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们引入 Express。然后，就像之前一样，我们引入 Node 的 HTTP 模块。我们已经准备好了。
- en: 'Then we make a variable called app like we did before, but instead of creating
    the server, we call `express()`, which returns a request handler function. This
    is important: it means that we can pass the result into `http.createServer` just
    like before.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个名为 app 的变量，就像之前一样，但不是创建服务器，而是调用 `express()`，它返回一个请求处理函数。这很重要：这意味着我们可以像之前一样将结果传递给
    `http.createServer`。
- en: 'Remember the request handler we had in the previous chapter, with "vanilla"
    Node? It looked like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在上一章中使用的请求处理函数，使用“纯”Node？它看起来像这样：
- en: '`var app = http.createServer(function(request, response) {` `  response.writeHead(200,
    { "Content-Type": "text/plain" });` `  response.end("Hello, world!");``});`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`var app = http.createServer(function(request, response) {` `  response.writeHead(200,
    { "Content-Type": "text/plain" });` `  response.end("Hello, world!");``});`'
- en: We have a very similar function in this example (in fact, I copy-pasted it).
    It's also passed a request and a response object, and we interact with them in
    the same way.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个非常类似的功能（实际上，我是复制粘贴的）。它也传递了一个请求和响应对象，我们以相同的方式与它们交互。
- en: Next we create the server and start listening. Recall that `http.createServer` took
    a function before, so guess what—`app` is just a function. It's an Express-made
    request handler that starts going through all the middleware until the end. At
    the end of the day, it's just a request handler function like before.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建服务器并开始监听。回想一下，`http.createServer` 之前接受了一个函数，所以——`app` 只是一个函数。它是一个 Express
    制作的请求处理函数，它将从中间件开始一直处理到结束。最终，它只是一个像之前一样的请求处理函数。
- en: NOTE You will see people using `app.listen(3000)`, which just defers to `http.createServer`.
    It's just shorthand, like how we will shorten `request` to `req` and `response` to `res` in
    following chapters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你会看到人们使用 `app.listen(3000)`，这实际上只是将调用委托给 `http.createServer`。这只是简写，就像我们在后续章节中将
    `request` 简写为 `req` 和 `response` 为 `res` 一样。
- en: 3.1.2  How middleware works at a high level
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 中间件在高级层面上的工作原理
- en: 'In Node, everything goes through one big function. To resurface an example
    from Chapter 2, it looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 中，所有内容都通过一个大函数。为了回顾第二章的一个例子，它看起来像这样：
- en: Listing 3.4 A Node request handler function
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 Node 请求处理函数
- en: '`function requestHandler(request, response) {` `  console.log("In comes a request
    to: " + request.url);` `  response.end("Hello, world!");``}`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`function requestHandler(request, response) {` `  console.log("In comes a request
    to: " + request.url);` `  response.end("Hello, world!");``}`'
- en: In a world without middleware, we find ourselves having one master request function
    that handles everything. If we were to draw the flow of our application, it might
    look like Figure 3.1.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有中间件的世界里，我们发现只有一个主请求函数来处理所有事情。如果我们绘制应用程序的流程图，它可能看起来像图 3.1。
- en: '![](../Images/03_01.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_01.png)'
- en: Figure 3.1 A request without middleware
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 没有中间件的请求。
- en: Every request goes through just one request handler function, which eventually
    generates the response. That's not to say that the master handler function can't
    call other functions, but at the end of the day, the master function responds
    to every request.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求都通过一个请求处理函数，它最终生成响应。这并不是说主处理函数不能调用其他函数，但最终，主函数会响应每个请求。
- en: With middleware, rather than having your request pass through one you write
    function, it passes through an array of functions you write called a "middleware
    stack". It might look like Figure 3.2.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中间件时，你的请求不是通过你编写的单个函数，而是通过一个由你编写的函数数组（称为“中间件栈”）传递。它可能看起来像图 3.2。
- en: '![](../Images/03_02.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_02.png)'
- en: Figure 3.2 A request with middleware.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 带有中间件的请求。
- en: Okay, so Express lets you execute an array of functions instead of just one.
    What might some of these functions be? And why might we want this?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以 Express 允许你执行一个函数数组，而不是一个函数。这些函数可能是什么？为什么我们可能想要这样做？
- en: 'Let''s resurface an example from Chapter 1: an application that authenticates
    users. If they''re authenticated, it shows them some secret information. All the
    while, our server is logging every request that comes into our server, authenticated
    or not.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回顾第一章的一个例子：一个验证用户的应用程序。如果用户验证成功，它会显示一些秘密信息。在此期间，我们的服务器会记录进入服务器的每个请求，无论是否已验证。
- en: 'This app might have three middleware functions: one that does logging, one
    that does authentication, and one that responds with secret information. The logging
    middleware will log every request and continue onto the next middleware; the authentication
    middleware will only continue if the user is authorized; the final middleware
    will always respond and it won''t continue on because nothing follows it.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用可能有三个中间件函数：一个用于记录日志，一个用于身份验证，一个用于响应秘密信息。记录中间件将记录每个请求并继续到下一个中间件；身份验证中间件只有在用户被授权的情况下才会继续；最后的中间件将始终响应，并且它不会继续，因为没有其他中间件跟随。
- en: There are two possible ways a request could flow through this simple app; an
    illustration of two possible options is shown in Figure 3.3.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请求可以通过这个简单应用有两种可能的方式；两种可能选项的示意图如图 3.3 所示。
- en: '![](../Images/03_03.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_03.png)'
- en: Figure 3.3 Two requests flowing through middleware functions. See that middleware
    sometimes continues on, but sometimes responds to requests.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 两个请求通过中间件函数。注意中间件有时会继续，但有时会响应请求。
- en: Each middleware function can modify the request or the response, but it doesn't
    always have to. Eventually, some middleware should respond to the request. It
    could be the first one, it could be the last. If none of them respond, then the
    server will hang and the browser will sit alone, without a response.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个中间件函数都可以修改请求或响应，但并不总是必须这样做。最终，某些中间件应该响应请求。它可能是第一个，也可能是最后一个。如果它们都没有响应，那么服务器将会挂起，浏览器将独自坐着，没有响应。
- en: This is powerful because we can split our application into many small parts,
    rather than having one behemoth. They become easier to compose and reorder, and
    it's also easy to pull in third-party middleware.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这很强大，因为我们可以将我们的应用程序分成许多小部分，而不是有一个巨大的单一实体。它们变得更容易组合和重新排序，而且也很容易引入第三方中间件。
- en: We'll see some examples that will (hopefully!) make all of this more clear.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一些例子，希望它们能（希望如此！）使这一切更加清晰。
- en: 3.1.3  Middleware code that's passive
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 中间件代码的被动性
- en: Middleware can affect the response, but it doesn't have to. For example, the
    logging middleware from the previous section doesn't need to send different data—it
    just needs to log the request and move on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件可以影响响应，但不必这样做。例如，上一节中的记录中间件不需要发送不同的数据——它只需要记录请求并继续。
- en: 'Let''s start by building a completely useless middleware and then moving on
    from there. Here''s what an empty middleware function looks like:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建一个完全没有用的中间件开始，然后继续前进。下面是一个空中间件函数的样子：
- en: Listing 3.5 An empty middleware that does nothing
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.5 一个什么也不做的空中间件
- en: '`function myFunMiddleware(request, response, next) {`   `  ... #A`   `  next();
    #B``}`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`function myFunMiddleware(request, response, next) {` `  ... #A` `  next();
    #B`'
- en: '#A Do stuff with the request and/or response.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 对请求和/或响应进行操作。'
- en: '#B When we''re all done, call next() to defer to the next middleware in the
    chain.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 当我们全部完成时，调用 next() 来将控制权推迟到链中的下一个中间件。'
- en: When we start a server, we start at the topmost middleware and work our way
    to the bottom. So if we wanted to add simple logging to our app, we could do it!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动服务器时，我们从最顶层的中间件开始，一直工作到底部。所以如果我们想在应用中添加简单的记录，我们可以这样做！
- en: Listing 3.6 Logging middleware
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.6 记录中间件
- en: '`var express = require("express");` `var http = require("http");` `var app
    = express();`   `app.use(function(request, response, next) { #A` `  console.log("In
    comes a " + request.method + " to " + request.url);` `  next();` `}); `   `app.use(function(request,
    response) {  #B ` `  response.writeHead(200, { "Content-Type": "text/plain" });`
    `  response.end("Hello, World!");` `}); `  `http.createServer(app).listen(3000);`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var http = require("http");` `var app
    = express();` `app.use(function(request, response, next) { #A` `  console.log("In
    comes a " + request.method + " to " + request.url);` `  next();` `});` `app.use(function(request,
    response) {  #B` `  response.writeHead(200, { "Content-Type": "text/plain" });`
    `  response.end("Hello, World!");` `});` `http.createServer(app).listen(3000);`'
- en: '#A This is the logging middleware, which will log the request to the console
    and then advance to the next middleware.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这是记录中间件，它将请求记录到控制台，然后转到下一个中间件。'
- en: '#B This sends the actual response.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 这发送了实际的响应。'
- en: Run this app and visit `http://localhost:3000`. In the console, you'll see that
    your server is logging your requests (refresh to see). You'll also see your "Hello,
    World!" in the browser.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此应用并访问 `http://localhost:3000`。在控制台中，你会看到你的服务器正在记录你的请求（刷新以查看）。你也会在浏览器中看到你的
    "Hello, World!"。
- en: It's important to note that anything that works in the vanilla Node.js server
    also works in middleware. For example, you can inspect `request.method` in a vanilla
    Node web server, without Express. Express doesn't get rid of it--it's right there
    like it was before. If you want to set the `statusCode` of the response, you can
    do that too. Express adds some more things to these objects, but it doesn't remove anything.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在纯Node.js服务器上工作的一切在中间件中也同样有效。例如，你可以在没有Express的情况下在纯Node网络服务器中检查`request.method`。Express并没有去掉它——它就像之前一样在那里。如果你想设置响应的`statusCode`，你也可以这样做。Express向这些对象添加了一些东西，但它并没有移除任何东西。
- en: The above example shows middleware that doesn't change the request or the response—it
    logs the request and always continues. While this kind of middleware can be useful,
    middleware can also change the request or response objects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例显示的中间件不会改变请求或响应——它记录请求并始终继续。虽然这种中间件可能很有用，但中间件也可以改变请求或响应对象。
- en: 3.1.4  Middleware code that changes the request and response
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.4 中间件代码改变请求和响应
- en: Not all middleware should be passive, though—the rest of the middleware from
    our example doesn't work that way; they'll actually need to change the response.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有中间件都应该被动的——我们示例中的其他中间件并不是这样工作的；它们实际上需要改变响应。
- en: 'Let''s try writing the authentication middleware that we mentioned before.
    Let''s choose a weird authentication scheme for simplicity: you''re only authenticated
    if you visit on an even-numbered minute of the hour (which would be 12:00, 12:02,
    12:04, 12:06, and so on). Recall that we can use the modulo operator (`%`) to
    help determine whether a number is divisible by another.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试编写之前提到的认证中间件。为了简单起见，让我们选择一个奇怪的认证方案：只有在你访问小时的偶数分钟时（例如12:00、12:02、12:04、12:06等）你才是认证的。回想一下，我们可以使用取模运算符（`%`）来帮助确定一个数是否可以被另一个数整除。
- en: 'We add this middleware to our application in Listing 3.7:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个中间件添加到我们的应用程序中，如列表3.7所示：
- en: Listing 3.7 Adding fake authentication middleware
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 添加伪造认证中间件
- en: '`app.use(function(request, response, next) {  #A` `  console.log("In comes
    a " + request.method + " to " + request.url);` `  next();` `});`   `app.use(function(request,
    response, next) {` `  var minute = (new Date()).getMinutes();` `  if ((minute
    % 2) === 0) {` `    next();   #B` `  } else {` `    response.statusCode = 403;       
    #C` `    response.end("Not authorized.");  #C` `  }` `});`   `app.use(function(request,
    response) {` `  response.end(''Secret info: the password is "swordfish"!''); 
    #D``});`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.use(function(request, response, next) {  #A` `  console.log("In comes
    a " + request.method + " to " + request.url);` `  next();` `});` `app.use(function(request,
    response, next) {` `  var minute = (new Date()).getMinutes();` `  if ((minute
    % 2) === 0) {` `    next();   #B` `  } else {` `    response.statusCode = 403;       
    #C` `    response.end("Not authorized.");  #C` `  }` `});` `app.use(function(request,
    response) {` `  response.end(''Secret info: the password is "swordfish"!''); 
    #D``});`'
- en: '#A This is the logging middleware, just as before.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这就是记录中间件，就像之前一样。'
- en: '#B If you''re visiting at the first minute of the hour, call next() to continue
    onto the “send secret info” middleware.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 如果你是在小时的第一个分钟访问，调用next()来继续到“发送秘密信息”中间件。'
- en: '#C If you''re not authorized, send a status code of 403 (“Not authorized”)
    and respond to the user. Notice that we don''t call next() to continue on.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 如果未经授权，发送状态码403（“未经授权”）并响应用户。请注意，我们没有调用next()来继续执行。'
- en: '#D Send the secret information!'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 发送秘密信息！'
- en: When a request comes in, it will always go through the middleware in the same
    order you `use` them. First, it will start with the logging middleware. Then,
    if you're visiting in an even-numbered minute, you'll continue onto the next middleware
    and see the secret information. But if you're visiting at any of the other minutes
    of the hour, you'll stop and never continue on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求到来时，它将始终按照你`use`它们的相同顺序通过中间件。首先，它将从记录中间件开始。然后，如果你是在偶数分钟访问，你将继续到下一个中间件并看到秘密信息。但如果你在小时的任何其他分钟访问，你将停止并无法继续。
- en: 3.1.5  Third-party middleware libraries
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.5 第三方中间件库
- en: Like many parts of programming, it's often the case that someone else has done
    what you're trying to do. You can write your own middleware, but it's common to
    find that the functionality you want is already in somebody else's middleware.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 就像编程的许多部分一样，通常情况下，其他人已经做了你试图做的事情。你可以编写自己的中间件，但通常会发现你想要的功能已经在别人的中间件中实现了。
- en: Let's look at a couple of examples of helpful third-party middleware.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个有用的第三方中间件的例子。
- en: 'MORGAN: LOGGING MIDDLEWARE'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'MORGAN: 记录中间件'
- en: Let's remove our logger and use Morgan, a nice logger for Express that has far
    more features. Loggers are pretty helpful for a number of reasons. First of all,
    they're one way to see what your users are doing. This isn't the best way to do
    things like marketing analytics, but it's really useful when your app crashes
    for a user and you're not sure why. I also find it really useful when developing—you
    can see when a request comes into your server. If something is wrong, you can
    use Morgan's logging as a sanity check.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们移除我们的日志记录器并使用 Morgan，这是一个为 Express 提供的很好的日志记录器，它具有许多功能。日志记录器有很多用途。首先，它们是查看用户行为的一种方式。这不是做市场分析等事情的最佳方式，但当你不确定为什么应用程序崩溃时，它非常有用。我也发现它在开发中非常有用——你可以看到请求何时进入你的服务器。如果有什么问题，你可以使用
    Morgan 的日志记录作为合理性检查。
- en: 'Run `npm install morgan --save` and give this a try (saving it into app.js
    again):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm install morgan --save` 并尝试一下（再次将其保存到 app.js 中）：
- en: Listing 3.8 Using Morgan for logging (in app.js)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 使用 Morgan 进行日志记录（在 app.js 中）
- en: '`var express = require("express");` `var logger = require("morgan");` `var
    http = require("http");`   `var app = express();`   `app.use(logger("short"));
    #A`   `app.use(function(request, response) {` `  response.writeHead(200, { "Content-Type":
    "text/plain" });` `  response.end("Hello, World!");` `});`  `http.createServer(app).listen(3000);`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var logger = require("morgan");` `var
    http = require("http");` `var app = express();` `app.use(logger("short")); #A`
    `app.use(function(request, response) {` `  response.writeHead(200, { "Content-Type":
    "text/plain" });` `  response.end("Hello, World!");` `});` `http.createServer(app).listen(3000);`'
- en: '#A Fun fact: logger("short") returns a function.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 有趣的事实：logger("short") 返回一个函数。'
- en: Visit `http://localhost:3000` and you'll see some logging! Thanks, Morgan.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 `http://localhost:3000`，你会看到一些日志！感谢，摩根。
- en: EXPRESS'S STATIC MIDDLEWARE
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: EXPRESS 的静态中间件
- en: There's more middleware out there than just Morgan.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Morgan 之外，还有更多的中间件。
- en: It's very common for web applications to need to send static files over the
    wire. This is things like images or CSS or HTML—content that isn't dynamic.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络应用程序来说，需要通过网络发送静态文件是非常常见的。这包括图像、CSS 或 HTML 等内容，这些内容不是动态的。
- en: '`express.static` ships with Express, and helps you serve static files. The
    simple act of sending files turns out to be a lot of work, because there are a
    lot of edge cases and performance considerations to think about. Express to the
    rescue!'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`express.static` 与 Express 一起提供，帮助你提供静态文件。发送文件这一简单的行为实际上要做很多工作，因为有很多边缘情况和性能考虑因素需要考虑。Express
    来拯救！'
- en: 'Let''s say we want to serve files out of a directory called "public". Here''s
    how we might do that with Express''s static middleware:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从一个名为 "public" 的目录中提供文件。这是我们可以使用 Express 的静态中间件来完成的方式：
- en: Listing 3.9 Using express.static (in app.js)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9 使用 express.static（在 app.js 中）
- en: '`var express = require("express");` `var path = require("path");` `var http
    = require("http");`   `var app = express();`   `var publicPath = path.resolve(__dirname,
    "public");  #A` `app.use(express.static(publicPath));  #B`   `app.use(function(request,
    response) {` `  response.writeHead(200, { "Content-Type": "text/plain" });` ` 
    response.end("Looks like you didn''t find a static file.");` `});`  `http.createServer(app).listen(3000);`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var path = require("path");` `var http
    = require("http");` `var app = express();` `var publicPath = path.resolve(__dirname,
    "public"); #A` `app.use(express.static(publicPath)); #B` `app.use(function(request,
    response) {` `  response.writeHead(200, { "Content-Type": "text/plain" });` ` 
    response.end("看起来你没有找到静态文件.");` `});` `http.createServer(app).listen(3000);`'
- en: '#A Set up the public path, using Node''s path module.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 使用 Node 的 path 模块设置公共路径。'
- en: '#B Send static files from the publicPath directory.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 从 publicPath 目录发送静态文件。'
- en: Now, any file in the public directory will be shown. We can put anything in
    there that we please and the server will send it. If no matching file exists in
    the `public` folder, it'll go onto the next middleware, and say "Hello, World!".
    If a matching file is found, `express.static` will send it off and stop the middleware
    chain.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，公共目录中的任何文件都会显示出来。我们可以把任何我们想放的东西放进去，服务器会发送它。如果 `public` 文件夹中没有找到匹配的文件，它将进入下一个中间件，并显示
    "Hello, World!"。如果找到匹配的文件，`express.static` 将发送它并停止中间件链。
- en: Why use path.resolve?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用 path.resolve？
- en: What's all that business about path.resolve? Why can't we just say /public?
    The short answer is that we could, but it's not cross-platform.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那些关于 path.resolve 的业务是什么？我们为什么不能只说 /public？简短的答案是我们可以，但这不是跨平台的。
- en: 'On Mac and Linux, we want this directory:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 和 Linux 上，我们想要这个目录：
- en: '`/public`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`/public`'
- en: 'But on Windows, we want this directory:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 Windows 上，我们想要这个目录：
- en: '`\public`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`\public`'
- en: Node's built-in path module will make sure that things run smoothly on Windows,
    Mac, and Linux.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的内置 path 模块将确保在 Windows、Mac 和 Linux 上运行顺畅。
- en: FINDING MORE MIDDLEWARE
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找更多中间件
- en: 'I''ve shown Morgan and Express''s static middleware, but there''s a lot more.
    Here are a few other helpful ones:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经展示了 Morgan 和 Express 的静态中间件，但还有很多。这里有一些其他有用的中间件：
- en: ·  connect-ratelimit lets you throttle connections to a certain number of requests
    per hour. If someone is sending lots of requests to your server, you can start
    giving them errors to stop them from bringing your site down.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ·  connect-ratelimit 允许你限制每小时请求的数量。如果有人向你的服务器发送大量请求，你可以开始给他们错误信息，阻止他们使你的网站崩溃。
- en: ·  helmet helps you add HTTP headers to make your app safer against certain
    kinds of attacks. We'll explore it in later chapters. (I'm a contributor to Helmet,
    so I'd definitely recommend it!)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ·  helmet 帮助你添加 HTTP 头信息，使你的应用程序更安全地防止某些类型的攻击。我们将在后面的章节中探讨它。（我是 Helmet 的贡献者，所以我肯定会推荐它！）
- en: ·  cookie-parser parses browser cookies.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ·  cookie-parser 解析浏览器 cookie。
- en: ·  response-time sends the X-Response-Time header so you can debug the performance
    of your application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ·  response-time 发送 X-Response-Time 头信息，这样你可以调试你应用程序的性能。
- en: We'll explore many of these middleware options further in the next chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章进一步探讨这些中间件选项。
- en: If you're looking for more middleware, you'll have luck searching for "Express
    middleware", but you should also search for "Connect middleware" too. There's
    another framework called Connect that's like Express but only does middleware.
    Connect middleware is compatible with Express, so if the "Express middleware"
    search isn't fruitful, try searching for Connect middleware.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找更多的中间件，搜索“Express 中间件”会有所帮助，但你也应该搜索“Connect 中间件”。还有一个名为 Connect 的框架，它类似于
    Express，但只做中间件。Connect 中间件与 Express 兼容，所以如果“Express 中间件”搜索没有结果，尝试搜索 Connect 中间件。
- en: 3.2     Routing
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2     路由
- en: 'Routing is a way to map requests to specific handlers depending on their URL
    and HTTP verb. You could imagine having a homepage and an about page and a 404
    page. Routing can do all of this. I think is better explained with code than with
    English:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是一种根据 URL 和 HTTP 动词将请求映射到特定处理器的机制。你可以想象有一个主页、一个关于页面和一个 404 页面。路由可以完成所有这些。我认为用代码比用英语解释更好：
- en: Listing 3.10 Express routing example
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10 Express 路由示例
- en: '`var express = require("express");` `var path = require("path");` `var http
    = require("http");`   `var app = express();`   `var publicPath = path.resolve(__dirname,
    "public");  #A` `app.use(express.static(publicPath));  #A`   `app.get("/", function(request,
    response) {    #B` `  response.end("Welcome to my homepage!");` `});`   `app.get("/about",
    function(request, response) {    #C` `  response.end("Welcome to the about page!");`
    `});`   `app.get("/weather", function(request, response) {    #D` `  response.end("The
    current weather is NICE.");` `});`   `app.use(function(request, response) {   
    #E` `  response.statusCode = 404;` `  response.end("404!");` `});`  `http.createServer(app).listen(3000);`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var path = require("path");` `var http
    = require("http");` `var app = express();` `var publicPath = path.resolve(__dirname,
    "public");  #A` `app.use(express.static(publicPath));  #A` `app.get("/", function(request,
    response) {    #B` `  response.end("欢迎来到我的主页!");` `});` `app.get("/about", function(request,
    response) {    #C` `  response.end("欢迎来到关于页面!");` `});` `app.get("/weather", function(request,
    response) {    #D` `  response.end("当前天气是晴朗的.");` `});` `app.use(function(request,
    response) {    #E` `  response.statusCode = 404;` `  response.end("404!");` `});`
    `http.createServer(app).listen(3000);`'
- en: '#A  This sets up static middleware like we''ve seen before. Every request will
    go through this middleware, and if no static file is found, it will continue onto
    the routes below.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '#A  这设置了类似于我们之前看到的静态中间件。每个请求都会通过这个中间件，如果没有找到静态文件，它将继续到下面的路由。'
- en: '#B This request handler is called when a request to the root is called. In
    this example''s case, this handler is called when you visit http://localhost:3000.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 当请求根路径时，这个请求处理器会被调用。在这个例子中，当你访问 http://localhost:3000 时，这个处理器会被调用。'
- en: '#C This request handler is called when a request to /about (http://localhost:3000/about
    in this case) comes in.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 当请求到来时，这个请求处理器会被调用，请求的路径是 /about（在这个例子中是 http://localhost:3000/about）。'
- en: '#D This request handler is called when a request to /weather (http://localhost:3000/weather
    in this case) comes in.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 当请求到来时，这个请求处理器会被调用，请求的路径是 /weather（在这个例子中是 http://localhost:3000/weather）。'
- en: '#E If we didn''t hit the static file middleware or any of the routes above,
    then we''ve tried everything and we''ll wind up here. This will happen when you
    visit an unknown URL, like /edward_cullen or /delicious_foods/burrito.jpg.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '#E 如果我们没有命中静态文件中间件或上述任何路由，那么我们已经尝试了一切，最终会到这里。当你访问一个未知的URL，如/edward_cullen或/delicious_foods/burrito.jpg时，这将会发生。'
- en: After the basic requires, we add our static file middleware (just like we've
    seen before). This will serve any files in a folder called `public`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本需求之后，我们添加了我们的静态文件中间件（就像我们之前看到的那样）。这将服务于名为`public`的文件夹中的任何文件。
- en: The three calls to `app.get` are Express's magical routing system. They could
    also be `app.post`, which respond to POST requests, or PUT, or any of the HTTP
    verbs. (We'll talk more about these other HTTP verbs in later chapters.) The first
    argument is a path, like `/about` or `/weather` or simply `/`, the site's root.
    The second argument is a request handler function similar to what we've seen before
    in the middleware section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.get`的三个调用是Express的神奇路由系统。它们也可以是`app.post`，响应POST请求，或者PUT，或者任何HTTP动词。（我们将在后面的章节中更多地讨论这些其他HTTP动词。）第一个参数是一个路径，比如`/about`、`/weather`或者简单地`/`，网站的根目录。第二个参数是一个请求处理函数，类似于我们在中间件部分看到过的。'
- en: They're the same request handler functions we've seen before. They work just
    like middleware; it's just a matter of when they're called.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是我们之前看到过的相同的请求处理函数。它们的工作方式就像中间件一样；只是它们被调用的时机不同。
- en: These routes can get smarter. In addition to matching fixed routes, they can
    also match more complex ones (imagine a regular expression or more complicated
    parsing).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路由可以变得更智能。除了匹配固定路由外，它们还可以匹配更复杂的路由（想象一下正则表达式或更复杂的解析）。
- en: Listing 3.11 Grabbing data from routes
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.11 从路由中获取数据
- en: '`app.get("/hello/:who", function(request, response) {   #A` `  response.end("Hello,
    " + request.params.who + ".");  #B` `  // Fun fact: this has some security issues,
    which we''ll get to!``});`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.get("/hello/:who", function(request, response) {   #A response.end("Hello,
    " + request.params.who + ".");  #B });`'
- en: '#A This specifies that the "hello" part of the route is fixed, but the string
    afterward can vary.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这指定了路由中的"hello"部分是固定的，但之后的字符串可以变化。'
- en: '#B req.params has a property called "who". It''s no coincidence that this was
    also the name specified in the route above. Express will pull the value from the
    incoming URL and set it to the name you specify.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '#B `req.params`有一个名为"who"的属性。这并不是巧合，它也是上面指定路由的名称。Express将从传入的URL中提取值并将其设置为指定的名称。'
- en: 'Restart your server and visit `localhost:3000/hello/earth` for the following
    message:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动你的服务器，访问`localhost:3000/hello/earth`以获取以下消息：
- en: Hello, earth.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，地球。
- en: Note that this won't work if you add a slash—for example, `localhost:3000/hello/entire/earth` will
    give a 404 error.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你添加一个斜杠，比如`localhost:3000/hello/entire/earth`将会返回一个404错误。
- en: 'It''s likely that you''ve seen this sort of behavior all over the internet.
    For example, you''ve likely seen websites where you can visit a URL for a specific
    user. For example, if your username were ExpressSuperHero, the URL for your user
    page might look something like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能在网上到处都见过这种行为。例如，你可能见过可以访问特定用户URL的网站。例如，如果你的用户名是ExpressSuperHero，你的用户页面URL可能看起来像这样：
- en: '`https://mywebsite.com/users/ExpressSuperHero`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://mywebsite.com/users/ExpressSuperHero`'
- en: Express allows us to do something like this. Rather than defining a route for every
    single possible username (or article, or photo, or whatever), you define one route
    that matches all of them.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Express允许我们这样做。而不是为每个可能的用户名（或文章、照片，或任何东西）定义一个路由，你可以定义一个匹配所有这些的路由。
- en: The docs also show an example that uses regular expressions to do even more
    complex matching, and you can do lots of other stuff with this routing. For a
    conceptual understanding, I've said enough. We'll explore this in far more detail
    in Chapter 5.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 文档还展示了一个使用正则表达式进行更复杂匹配的示例，你可以用这个路由做很多其他的事情。为了概念上的理解，我已经说得足够多了。我们将在第5章中更详细地探讨这一点。
- en: But it gets cooler.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但这更酷。
- en: 3.3     Extending request and response
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 扩展请求和响应
- en: Express augments the request and response objects that you're passed in every
    request handler. The old stuff is still there, but Express adds some new stuff
    too! The API docs (at [http://expressjs.com/api.html](http://expressjs.com/api.html))
    explain everything, but let's look at a couple of examples.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Express增强了你传递给每个请求处理函数的请求和响应对象。旧的内容还在那里，但Express也添加了一些新的内容！API文档（在[http://expressjs.com/api.html](http://expressjs.com/api.html)）解释了一切，但让我们看看几个例子。
- en: 'One nicety Express offers is a redirect method. Listing 3.12 shows how the
    redirect method might work:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Express 提供的一个优点是重定向方法。列表 3.12 展示了重定向方法可能的工作方式：
- en: Listing 3.12 Using redirect
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.12 使用重定向
- en: '`response.redirect("/hello/world");` `response.redirect("http://expressjs.com");`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`response.redirect("/hello/world");` `response.redirect("http://expressjs.com");`'
- en: If we were just using Node, `response` would have no method called `redirect`;
    Express adds it to the response object for us. You can do this in vanilla Node,
    but it's a lot more code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是使用 Node.js，`response` 将没有名为 `redirect` 的方法；Express 为我们添加了它到响应对象中。你可以在原生
    Node.js 中这样做，但需要更多的代码。
- en: 'Express also adds methods like `sendFile` which lets you just send a whole
    file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Express 还添加了 `sendFile` 这样的方法，允许你发送整个文件：
- en: Listing 3.13 sendFile example
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.13 sendFile 示例
- en: '`response.sendFile("/path/to/cool_song.mp3");`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`response.sendFile("/path/to/cool_song.mp3");`'
- en: Once again, the `sendFile` method isn't available in vanilla Node; Express adds
    it for us. And just like the redirect example above, you can do this in vanilla
    Node, but it's a lot more code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`sendFile` 方法在原生 Node.js 中不可用；Express 为我们添加了它。就像上面的重定向示例一样，你可以在原生 Node.js
    中这样做，但需要更多的代码。
- en: It's not just the response object that gets conveniences—the request object
    gets a number of other cool properties and methods, like `request.ip` to get the
    IP address or the `request.get` method to get incoming HTTP headers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅响应对象得到了便利，请求对象也得到了许多其他酷炫的属性和方法，如 `request.ip` 获取 IP 地址或 `request.get` 方法获取传入的
    HTTP 头部。
- en: 'Let''s use some of these things to build some middleware that blocks an evil
    IP address. Express makes this pretty easy:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些功能来构建一些中间件，以阻止一个恶意 IP 地址。Express 使这变得非常简单：
- en: Listing 3.14 Blacklisting an IP
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.14 黑名单 IP
- en: '`var express = require("express");` `var app = express();`   `var EVIL_IP =
    "123.45.67.89";`   `app.use(function(request, response, next) {` `  if (request.ip
    === EVIL_IP) {` `    response.status(401).send("Not allowed!");` `  } else {`
    `    next();` `  }` `});`  `// ... the rest of your app ...`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var app = express();` `var EVIL_IP = "123.45.67.89";`
    `app.use(function(request, response, next) {` `  if (request.ip === EVIL_IP) {`
    `    response.status(401).send("Not allowed!");` `  } else {` `    next();` ` 
    }` `});` `// ... 你的应用其余部分 ...`'
- en: Notice that we're using `req.ip`, a function called `res.status()`, and `res.send()`.
    None of these are built into vanilla Node—they're all extensions added by Express.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用了 `req.ip`，一个名为 `res.status()` 的函数，以及 `res.send()`。这些都不是 Node.js 的原生功能——它们都是
    Express 添加的扩展。
- en: Conceptually, there's not much to know here, other than the fact that Express
    extends the request and response.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，这里没有太多需要了解的，除了 Express 扩展了请求和响应的事实。
- en: We've looked at a few niceties in this chapter, but I don't want to give you
    the full laundry list here. For every nice feature that Express gives you, check
    out its API documentation at [http://expressjs.com/4x/api.html](http://expressjs.com/4x/api.html).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经看到了一些优点，但我不想在这里列出全部。对于 Express 提供的每一个优点，请查看其 API 文档[http://expressjs.com/4x/api.html](http://expressjs.com/4x/api.html)。
- en: 3.4     Views
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 视图
- en: Websites are built with HTML. They've been built that way for a long, long time.
    While single-page apps are en vogue (and totally possible with Express), it's
    often the case that you want the server to dynamically generate HTML. You might
    want to serve HTML that greets the currently logged-in user, or maybe you want
    to dynamically generate a data table.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 网站是用 HTML 构建的。它们已经这样做了很长时间。虽然单页应用很流行（并且完全可以用 Express 实现），但通常你希望服务器动态生成 HTML。你可能想要提供问候当前登录用户的
    HTML，或者可能想要动态生成一个数据表。
- en: 'There are a number of different view engines out there. There''s EJS (which
    stands for "embedded JavaScript"), Handlebars, Jade, and more. There are even
    ports of templating languages from other programming worlds, like Swig and HAML.
    All of these have one thing in common: at the end of the day, they spit out HTML.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 目前市面上有多种不同的视图引擎。有 EJS（代表“嵌入式 JavaScript”）、Handlebars、Jade 以及更多。甚至还有从其他编程世界移植的模板语言，如
    Swig 和 HAML。它们都有一个共同点：最终都会输出 HTML。
- en: For the rest of these examples, we'll use EJS. I chose EJS because it's a popular
    option made by the people who created Express. I hope you'll like it, but if you
    don't, there are plenty of alternatives which we'll discuss in Chapter 7.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的示例，我们将使用 EJS。我选择 EJS 是因为它是由 Express 的创造者团队开发的一个流行的选项。希望你会喜欢它，但如果不喜欢，第七章中我们将讨论许多其他替代方案。
- en: 'Here''s what it looks like to set up views:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是设置视图的示例：
- en: Listing 3.15 Setting up views with Express
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.15 使用 Express 设置视图
- en: '`var express = require("express");` `var path = require("path");`   `var app
    = express();`   `app.set("views", path.resolve(__dirname, "views")); #A``app.set("view
    engine", "ejs");  #B`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var path = require("path");` `var app
    = express();` `app.set("views", path.resolve(__dirname, "views")); #A` `app.set("view
    engine", "ejs"); #B`'
- en: '#A This tells Express that your views will be in a folder called views. We
    could put it in another path, but "views" is a common name.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这告诉 Express，你的视图将放在一个名为 views 的文件夹中。我们也可以将其放在另一个路径，但 "views" 是一个常见的名称。'
- en: '#B This tells Express that you''re going to use the EJS templating engine.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 这告诉 Express，你将使用 EJS 模板引擎。'
- en: We'll add more to this file in a moment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会向这个文件添加更多内容。
- en: 'The first block is the same as always: require what we need to. Then we say
    "our views are in a folder called views". After that, we say "use EJS". EJS (documentation
    at [https://github.com/tj/ejs](https://github.com/visionmedia/ejs)) is a templating
    language that compiles to HTML. Make sure to install it with `npm install ejs
    --save`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个块和以前一样：引入我们需要的东西。然后我们说 "我们的视图在一个名为 views 的文件夹中"。之后，我们说 "使用 EJS"。EJS（文档在 [https://github.com/tj/ejs](https://github.com/visionmedia/ejs)）是一种模板语言，它编译成
    HTML。确保使用 `npm install ejs --save` 安装它。
- en: Now, we've set up these views on the Express side. How do we use them? What
    is this EJS business?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在 Express 端设置了这些视图。我们如何使用它们？这个 EJS 是什么意思？
- en: 'Let''s start by making a file called `index.ejs` and put it into a directory
    called `views`. It might look like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `index.ejs` 的文件开始，并将其放入一个名为 `views` 的目录中。它可能看起来像这样：
- en: Listing 3.16 A simple EJS file
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.16 一个简单的 EJS 文件
- en: '`<!DOCTYPE html>` `<html>` `  <head>` `    <meta charset="utf-8">` `    <title>Hello,
    world</title>` `  </head>` `<body>` `  <%= message %>` `</body>``</html>`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`<!DOCTYPE html>` `<html>` `  <head>` `    <meta charset="utf-8">` `    <title>Hello,
    world</title>` `  </head>` `<body>` `  <%= message %>` `</body>``</html>`'
- en: 'This should look exactly like HTML to you, but for the one weird bit inside
    the body tag. EJS is a superset of HTML, so everything that''s valid HTML is valid
    EJS. But EJS also adds a few new features, like variable interpolation. `<%= message
    %>` will interpolate a variable called message, which we''ll pass when we render
    the view from Express. Here''s what that looks like:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该看起来完全像 HTML，但在 body 标签内的一个奇怪部分。EJS 是 HTML 的超集，所以所有有效的 HTML 都是有效的 EJS。但 EJS
    还增加了一些新特性，比如变量插值。`<%= message %>` 将插值一个名为 message 的变量，这是我们将在从 Express 渲染视图时传递的。下面是这个样子的：
- en: Listing 3.17 Rendering a view from Express
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.17 使用 Express 渲染视图
- en: '`app.get("/", function(request, response) {` `  response.render("index", {`
    `    message: "Hey everyone! This is my webpage."` `  });``});`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.get("/", function(request, response) {` `  response.render("index", {`
    `    message: "Hey everyone! This is my webpage."` `  });``});`'
- en: Express adds a method to response, called `render`. It basically looks at the
    view engine and views directory (which we defined earlier) and renders `index.ejs` with
    the variables you pass in.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Express 向 response 添加了一个名为 `render` 的方法。它基本上查看视图引擎和视图目录（我们之前定义的），并使用你传递的变量渲染
    `index.ejs`。
- en: 'The code in Listing 3.18 would render the following HTML:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.18 中的代码将渲染以下 HTML：
- en: Listing 3.18 A simple EJS file, rendered
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.18 一个简单的 EJS 文件，已渲染
- en: '`<!DOCTYPE html>` `<html>` `  <head>` `    <meta charset="utf-8">` `    <title>Hello,
    world</title>` `  </head>` `<body>` `  Hey everyone! This is my webpage. #A` `</body>``</html>`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`<!DOCTYPE html>` `<html>` `  <head>` `    <meta charset="utf-8">` `    <title>Hello,
    world</title>` `  </head>` `<body>` `  Hey everyone! This is my webpage. #A` `</body>``</html>`'
- en: '#A Notice that this is the variable we specified in the render method above.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 注意，这是我们上面在 render 方法中指定的变量。'
- en: EJS is a popular solution to views, but there are a number of other options.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: EJS 是一个流行的视图解决方案，但还有许多其他选项。
- en: We'll explore other options in later chapters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中探索其他选项。
- en: '3.5     Example: putting it all together in a guestbook'
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 示例：在留言簿中综合运用所有内容
- en: 'If you''re like me, you saw the internet in its early days; awkward animated
    GIFs, crufty code, and Times New Roman on every page. In this chapter, we''ll
    resurrect one component from that bygone era: the guestbook. A guestbook is pretty
    simple: users can write new entries in the online guestbook, and they can browse
    others'' entries.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，你曾在互联网的早期看到过它；尴尬的动画 GIF，糟糕的代码，以及每个页面上的 Times New Roman。在本章中，我们将从这个过去的时代复活一个组件：留言簿。留言簿相当简单：用户可以在在线留言簿中写入新的条目，并且可以浏览他人的条目。
- en: 'Let''s use all that we''ve learned to build a more real application for this
    guestbook. It turns out that all of these things will come in handy! Our site
    will have two pages:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运用所学的一切来为这个留言簿构建一个更真实的应用。结果证明，所有这些都会派上用场！我们的网站将有两个页面：
- en: 1.  A homepage that lists all of the previously-posted guestbook entries
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  一个列出所有之前发布的留言簿条目的主页
- en: 2.  A page with an "add new entry" form
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  一个带有“添加新条目”表单的页面
- en: That's it! Before we start, we have to get set up. Ready?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！在我们开始之前，我们必须先设置好。准备好了吗？
- en: 3.5.1  Getting set up
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1  准备设置
- en: 'Let''s start a new project. Make a new folder, and inside, make a file called `package.json`.
    It should look something like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一个新的项目。创建一个新的文件夹，并在其中创建一个名为`package.json`的文件。它应该看起来像这样：
- en: Listing 3.19 package.json for the guestbook
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.19 guestbook的`package.json`
- en: '`{` `  "name": "express-guestbook",` `  "private": true,` `  "scripts": {`
    `    "start": "node app"  #A` `  }``}`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "name": "express-guestbook",` `  "private": true,` `  "scripts": {`
    `    "start": "node app"  #A` `  }``}`'
- en: '#A Typing "npm start" in your terminal will run "node app", which will start
    your app.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 在终端中键入 "npm start" 将会运行 "node app"，这将启动您的应用程序。'
- en: 'You can add other fields (like author or version), but for this example, we
    don''t need much. Now, let''s install our dependencies like we''ve done before
    and save them into `package.json`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加其他字段（如作者或版本），但在这个例子中，我们不需要太多。现在，让我们像之前一样安装我们的依赖项，并将它们保存到`package.json`中：
- en: '`npm install express morgan body-parser ejs --save`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm install express morgan body-parser ejs --save`'
- en: These modules should look familiar to you, except for `body-parser`. Our app
    will need to post new guestbook entries in HTTP POST requests, so we'll need to
    parse the body of the POST; that's where body will come in.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块对您来说应该很熟悉，除了`body-parser`。我们的应用程序将需要在HTTP POST请求中发布新的留言簿条目，因此我们需要解析POST请求的正文；这就是body的作用所在。
- en: Check to make sure that Express, Morgan, body-parser, and EJS have been saved
    into `package.json`. If they haven't, make sure you've added the `--save` flag.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Express、Morgan、body-parser和EJS已经被保存到`package.json`中。如果没有，请确保您已经添加了`--save`标志。
- en: 3.5.2  The main app code
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.2  主要应用程序代码
- en: 'Now we''ve installed all of our dependencies, create `app.js` and put the following
    app inside:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有的依赖项，创建`app.js`并将以下应用程序放入其中：
- en: Listing 3.20 The Express guestbook, in app.js
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.20 Express留言簿，在`app.js`中
- en: '`var http = require("http");               #A` `var path = require("path");              
    #A` `var express = require("express");         #A` `var logger = require("morgan");          
    #A` `var bodyParser = require("body-parser");  #A`   `var app = express();  #B`
      `app.set("views", path.resolve(__dirname, "views"));  #C` `app.set("view engine",
    "ejs");                       #C`   `var entries = [];              #D` `app.locals.entries
    = entries;  #E`   `app.use(logger("dev"));  #F`   `app.use(bodyParser.urlencoded({
    extended: false })); #G`   `app.get("/", function(request, response) {  #H` ` 
    response.render("index");             #H` `});                               
    #H`   `app.get("/new-entry", function(request, response) { #I` `    response.render("new-entry");              
    #I` `});                                        #I`   `app.post("/new-entry",
    function(request, response) {  #J` `  if (!request.body.title || !request.body.content)
    {                       #K` `    response.status(400).send("Entries must have
    a title and content."); #K` `    return;                                                         #K`
    `  }                                                                 #K` `  entries.push({              
    #L` `    title: request.body.title,     #L` `    content: request.body.content,
    #L` `    published: new Date()      #L` `  });                          #L` ` 
    response.redirect("/");  #M` `});`   `app.use(function(request, response) {    
    #N` `  response.status(404).render("404"); #N` `});                             
    #N`   `http.createServer(app).listen(3000, function() {     #O` `  console.log("Guestbook
    app started on port 3000."); ``});`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`var http = require("http");               #A` `var path = require("path");              
    #A` `var express = require("express");         #A` `var logger = require("morgan");          
    #A` `var bodyParser = require("body-parser");  #A` '
- en: '#A First, we require all of the modules we need, just like before.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 首先，我们要求所有需要的模块，就像之前一样。'
- en: '#B Next, we make an Express app, just like we''ve done before.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 接下来，我们创建一个 Express 应用程序，就像我们之前做的那样。'
- en: '#C The first line tells Express that the views are in a folder called views,
    and the next line says that the views will use the EJS engine.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 第一行告诉 Express 视图位于名为 views 的文件夹中，下一行说明视图将使用 EJS 引擎。'
- en: '#D Create a "global" array to store all of our entries.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 创建一个 "全局" 数组来存储我们所有的条目。'
- en: '#E Make this entries array available in all views.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '#E 使此 entries 数组在所有视图中可用。'
- en: '#F Use Morgan to log every request.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '#F 使用 Morgan 记录每个请求。'
- en: '#G This middleware will populate a variable called req.body if the user is
    submitting a form. (The extended option is required and we choose false for slight
    security benefits. We''ll discuss the reasons why in great detail in Chapter 10.)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '#G 如果用户提交表单，则此中间件将填充一个名为 req.body 的变量。（需要扩展选项，我们选择 false 以获得轻微的安全优势。我们将在第 10
    章中详细讨论原因。）'
- en: '#H When visiting the site root, render the homepage (which will be in a views/index.ejs).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '#H 访问网站根目录时，渲染主页（它将在 views/index.ejs 中）。'
- en: '#I Render the "new entry" page (at views/index.ejs) when GETting the URL.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '#I 当获取 URL 时，渲染 "new entry" 页面（在 views/index.ejs 中）。'
- en: '#J Define a route handler when we POST to the "new entry" URL. Note that this
    is the same URL but a different HTTP verb.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '#J 当我们向 "new entry" URL 发送 POST 请求时，定义一个路由处理器。注意，这是相同的 URL，但不同的 HTTP 方法。'
- en: '#K If the user submits the form with no title or content (which we read out
    of req.body), respond with a 400 "bad request" error.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '#K 如果用户提交的表单没有标题或内容（我们从 req.body 中读取），则返回一个 400 "bad request" 错误。'
- en: '#L Add a new entry to the list of entries, with the title, body, and the time
    published.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '#L 将标题、正文和发布时间添加到条目列表中。'
- en: '#M Finally, redirect back to the homepage to see your new entry.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '#M 最后，重定向回主页以查看您的新条目。'
- en: '#N None of the other request handlers happened, so that means we''re trying
    to request an unknown resource. Render a 404 page.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '#N 没有其他请求处理器发生，这意味着我们正在尝试请求一个未知资源。渲染 404 页面。'
- en: '#O Start the server on port 3000!'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '#O 在端口 3000 上启动服务器！'
- en: 3.5.3  Creating the views
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.3 创建视图
- en: 'We''ve referenced a few views here, so let''s fill those in. Create a folder
    called views, and then create the header in `views/header.ejs`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里引用了一些视图，所以让我们来填充这些内容。创建一个名为 views 的文件夹，然后在 `views/header.ejs` 中创建标题：
- en: Listing 3.21 header.ejs
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.21 header.ejs
- en: '`<!DOCTYPE html>` `<html>` `<head>` `<meta charset="utf-8">` `<title>Express
    Guestbook</title>` `<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"> 
    #A` `</head>` `<body class="container">` `  <h1>` `    Express Guestbook` `   
    <a href="/new-entry" class="btn btn-primary pull-right">` `      Write in the
    guestbook` `    </a>``  </h1>`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`<!DOCTYPE html>` `<html>` `<head>` `<meta charset="utf-8">` `<title>Express
    Guestbook</title>` `<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"> 
    #A` `</head>` `<body class="container">` `  <h1>` `    Express Guestbook` `   
    <a href="/new-entry" class="btn btn-primary pull-right">` `      在留言簿中写点什么` `   
    </a>` `  </h1>`'
- en: '#A This code loads Twitter''s Bootstrap CSS from the Bootstrap CDN, an external
    server that hosts Bootstrap for your convenience.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 此代码从 Bootstrap CDN 加载 Twitter 的 Bootstrap CSS，这是一个为您的方便而托管 Bootstrap 的外部服务器。'
- en: Notice that we use Twitter Bootstrap for styling, but you could easily replace
    it with your own CSS. The most important part is that this is the header; this
    HTML will appear at the top of every page.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 Twitter Bootstrap 进行样式设计，但你也可以轻松地用你自己的 CSS 替换它。最重要的是，这是头部；此 HTML 将出现在每个页面的顶部。
- en: NOTE In short, Bootstrap is a bunch of CSS and JavaScript that provides a bunch
    of default styling. You can absolutely write navbars and buttons and header CSS
    yourself, but Bootstrap helps us get up and running quickly. You can find out
    more at http://getbootstrap.com/.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：简而言之，Bootstrap 是一些 CSS 和 JavaScript 的集合，它提供了一系列默认样式。你完全可以自己编写导航栏、按钮和标题 CSS，但
    Bootstrap 帮助我们快速启动。你可以在 http://getbootstrap.com/ 上了解更多信息。
- en: 'Next, create the simple footer in `views/footer.ejs`, which will appear at
    the bottom of every page:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个简单的页脚在 `views/footer.ejs`，它将出现在每个页面的底部：
- en: Listing 3.22 footer.ejs
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.22 footer.ejs
- en: '`</body>` `</html>`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`</body>` `</html>`'
- en: 'Now that we''ve defined the common header and footer, let''s define the three
    views: the homepage, the "add a new entry" page, and the 404 page.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了常见的头部和页脚，让我们定义三个视图：主页、添加新条目的页面和 404 页面。
- en: 'Save the following into `views/index.ejs`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容保存到 `views/index.ejs`：
- en: Listing 3.23 index.ejs
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.23 index.ejs
- en: '`<% include header %>` `<% if (entries.length) { %>` `  <% entries.forEach(function(entry)
    { %>` `    <div class="panel panel-default">` `      <div class="panel-heading">`
    `        <div class="text-muted pull-right">` `          <%= entry.published %>`
    `        </div>` `        <%= entry.title %>` `      </div>` `      <div class="panel-body">`
    `        <%= entry.content %>` `      </div>` `    </div>` `  <% }) %>` `<% }
    else { %>` `  No entries! <a href="/new-entry">Add one!</a>` `<% } %>``<% include
    footer %>`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`<% include header %>` `<% if (entries.length) { %>` `  <% entries.forEach(function(entry)
    { %>` `    <div class="panel panel-default">` `      <div class="panel-heading">`
    `        <div class="text-muted pull-right">` `          <%= entry.published %>`
    `        </div>` `        <%= entry.title %>` `      </div>` `      <div class="panel-body">`
    `        <%= entry.content %>` `      </div>` `    </div>` `  <% }) %>` `<% }
    else { %>` `  没有条目！ <a href="/new-entry">添加一个！</a>` `<% } %>` `<% include footer
    %>`'
- en: '...the following into `views/new-entry.ejs`...'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '...以下内容保存到 `views/new-entry.ejs`...'
- en: Listing 3.24 new-entry.ejs
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.24 new-entry.ejs
- en: '`<% include header %>`   `<h2>Write a new entry</h2>`   `<form method="post"
    role="form">` `  <div class="form-group">` `    <label for="title">Title</label>`
    `    <input type="text" class="form-control" id="title"` `    [CA]name="title"
    placeholder="Entry title" required>` `  </div>` `  <div class="form-group">` `   
    <label for="content">Entry text</label>` `    <textarea class="form-control" id="content"
    name="content"` `    [CA]placeholder="Love Express! It''s a great tool for` `   
    [CA]building websites." rows="3" required></textarea>` `  </div>` `  <div class="form-group">`
    `    <input type="submit" value="Post entry" class="btn btn-primary">` `  </div>`
    `</form>`  `<% include footer %>`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`<% include header %>` `<h2>写一篇新条目</h2>` `<form method="post" role="form">`
    `  <div class="form-group">` `    <label for="title">标题</label>` `    <input type="text"
    class="form-control" id="title"` `    [CA]name="title" placeholder="条目标题" required>`
    `  </div>` `  <div class="form-group">` `    <label for="content">条目文本</label>`
    `    <textarea class="form-control" id="content" name="content"` `    [CA]placeholder="爱的表达！这是一个构建网站的好工具。"
    rows="3" required></textarea>` `  </div>` `  <div class="form-group">` `    <input
    type="submit" value="发布条目" class="btn btn-primary">` `  </div>` `</form>`  `<%
    include footer %>`'
- en: '...and finally, the following into `views/404.ejs`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '...最后，将以下内容放入`views/404.ejs`：'
- en: Listing 3.25 404.ejs
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.25 404.ejs
- en: '`<% include header %>` `<h2>404! Page not found.</h2>``<% include footer %>`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`<% include header %>` `<h2>404! 页面未找到。</h2>``<% include footer %>`'
- en: And that's all your views!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是您所有的视图！
- en: 3.5.4  Start it up!
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.4  启动它！
- en: Now, `npm start` up your app and visit `http://localhost:3000`, and see our
    guestbook.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`npm start`启动您的应用，并访问`http://localhost:3000`，查看我们的客户留言。
- en: '![](../Images/03_04.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_04.png)'
- en: Figure 3.4 The guestbook homepage
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 客户留言主页
- en: '![](../Images/03_05.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03_05.png)'
- en: Figure 3.5 The guestbook homepage
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 客户留言主页
- en: Look at that! What a beautiful little guestbook. It reminds me of the 1990s.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个！多漂亮的迷你留言簿。它让我想起了20世纪90年代。
- en: 'Let''s review the different parts of this little project:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这个小项目的不同部分：
- en: ·  We use a middleware function to log all requests, which helps us do debugging.
    We also use a middleware at the end to serve the 404 page.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ·   我们使用一个中间件函数来记录所有请求，这有助于我们进行调试。我们还在最后使用一个中间件来服务404页面。
- en: ·  We use Express's routing to direct users to the homepage, the "add a new
    entry" view, and the POST for adding a new entry.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ·   我们使用Express的路由将用户导向主页、“添加新条目”视图以及添加新条目的POST请求。
- en: ·  We use Express and EJS to render pages. It lets us dynamically create HTML;
    we use this to dynamically display the content.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ·   我们使用Express和EJS来渲染页面。它允许我们动态创建HTML；我们使用这个功能来动态显示内容。
- en: 3.6     Summary
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6     总结
- en: 'In this chapter you saw that:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您看到了以下内容：
- en: ·  Express is a library that sits on top of Node and abstracts away a lot of
    that complexity
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ·   Express是一个位于Node之上的库，它抽象了很多复杂性
- en: '·  Express has four main features:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ·   Express有四个主要特性：
- en: ·  Middleware for letting a request flow through multiple headers
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ·   允许请求通过多个头部的中间件
- en: -  Routing for handling a request at a specific spot
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '-   在特定位置处理请求的路由'
- en: -  Convenience methods and properties
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '-   便捷方法和属性'
- en: -  Views for dynamically rendering HTML
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '-   用于动态渲染HTML的视图'
- en: ·  Many templating engines have been ported to work with Express. A popular
    one is called EJS, which is the simplest for folks who know already HTML.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ·   许多模板引擎已被移植到与Express一起使用。其中一个流行的是EJS，对于已经了解HTML的人来说，它是最简单的。
