- en: 8 What is a quantum algorithm?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 什么是量子算法？
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding what a quantum algorithm is
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解量子算法是什么
- en: Designing oracles to represent classical functions in quantum programs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计或acles以在量子程序中表示经典函数
- en: Working with useful quantum programming techniques
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用有用的量子编程技术
- en: One important application of quantum algorithms is obtaining speedups for solving
    problems where we need to search inputs to a function we’re trying to learn about.
    Such functions could be obfuscated (such as hash functions) or computationally
    difficult to evaluate (common in studying mathematical problems). In either case,
    applying quantum computers to such problems requires us to understand how we program
    and provide input to quantum algorithms. To learn how to do so, we’ll program
    and run an implementation of the *Deutsch–Jozsa algorithm*, which will let us
    learn properties of unknown functions quickly using quantum devices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 量子算法的一个重要应用是加速解决需要搜索我们试图学习的函数输入的问题。这些函数可能是模糊的（例如哈希函数）或计算上难以评估（在研究数学问题时很常见）。在两种情况下，将量子计算机应用于此类问题需要我们理解如何编程以及如何向量子算法提供输入。为了学习如何这样做，我们将编写并运行*Deutsch–Jozsa算法*的实现，这将使我们能够快速使用量子设备学习未知函数的性质。
- en: 8.1 Classical and quantum algorithms
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 经典和量子算法
- en: '*Algorithm (noun): a step-by-step procedure for solving a problem or accomplishing
    some end*.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法（名词）：解决问题或达到某个目的的逐步过程*。'
- en: —Merriam-Webster Dictionary
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: —Merriam-Webster词典
- en: 'When we talk about classical programming, we sometimes say that a program implements
    an *algorithm*: that is, a sequence of steps that can be used to solve a problem.
    For example, if we want to sort a list, we can talk about the quicksort algorithm
    independently of what language or operating system we are using. We often specify
    these steps at a high level. In the quicksort example, we might list the steps
    as something like the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论经典编程时，我们有时会说一个程序实现了 *算法*：也就是说，一系列可以用来解决问题的步骤。例如，如果我们想对一个列表进行排序，我们可以独立于我们使用的语言或操作系统来谈论快速排序算法。我们经常在高级别指定这些步骤。在快速排序的例子中，我们可能会列出以下步骤：
- en: If the list to be sorted is empty or only has one element, return it as is.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要排序的列表为空或只有一个元素，则按原样返回。
- en: Pick an element of the list to be sorted, called the *pivot*.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择列表中要排序的元素，称为 *枢轴*。
- en: Separate all other elements of the list into those that are smaller than the
    pivot and those that are larger.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列表中的其他所有元素分为小于枢轴和大于枢轴的元素。
- en: Quicksort each new list recursively.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归地对每个新列表进行快速排序。
- en: Return the first list, then the pivot, and finally the second list.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回第一个列表，然后是枢轴，最后是第二个列表。
- en: These steps serve as a guide for writing an implementation in a particular language
    of interest. Say we want to write the quicksort algorithm in Python.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤作为在特定感兴趣的语言中编写实现的指南。比如说我们想在Python中编写快速排序算法。
- en: Listing 8.1 An example implementation of quicksort
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 快速排序的一个示例实现
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Checks for the base case by seeing if there are at least two elements in the
    list
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过查看列表中是否至少有两个元素来检查基本情况
- en: ❷ Picks the first element to be our pivot for step 2
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为步骤2选择第一个元素作为枢轴
- en: ❸ Python code that builds two new lists as described in step 3
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 按照第3步描述构建两个新列表的Python代码
- en: ❹ Concatenates everything back together as described in steps 4 and 5
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 按照步骤4和5描述将所有内容重新连接在一起
- en: 'A well-written algorithm can help guide how to write implementations by making
    clear the steps that must be executed. Quantum algorithms are the same in this
    respect: they list the steps we need to perform in any implementation.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个编写良好的算法可以帮助指导如何编写实现，因为它清楚地说明了必须执行的步骤。在这一点上，量子算法是相同的：它们列出了在任何实现中我们需要执行的步骤。
- en: Definition A *quantum program* is an implementation of a quantum algorithm consisting
    of a *classical program* that sends instructions to a *quantum device* to prepare
    a particular state or measurement result.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *量子程序* 是量子算法的实现，由一个 *经典程序* 组成，该程序向 *量子设备* 发送指令以准备特定的状态或测量结果。
- en: As we saw in chapter 7, when we write a Q# program, we are writing a classical
    program that sends instructions to one of several different target machines on
    our behalf, as illustrated as figure 8.1, returning measurements to our classical
    program.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第7章中看到的，当我们编写一个Q#程序时，我们实际上是在编写一个经典程序，该程序代表我们向我们的多个不同目标机器之一发送指令，如图8.1所示，将测量结果返回给我们的经典程序。
- en: '![](../Images/8-1.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-1.png)'
- en: Figure 8.1 The Microsoft Quantum Development Kit software stack on a classical
    computer. We can write a Q# program consisting of functions and operations and
    referencing any Q# libraries we want to include. A host program can then coordinate
    communication between our Q# program and the target machine (e.g., a simulator
    running locally on our computer).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 在经典计算机上的 Microsoft Quantum Development Kit 软件堆栈。我们可以编写一个包含函数和操作并引用我们想要包含的任何
    Q# 库的 Q# 程序。然后，主机程序可以协调我们的 Q# 程序和目标机器（例如，在我们的计算机上本地运行的模拟器）之间的通信。
- en: The art of quantum programming
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 量子编程的艺术
- en: We cannot copy quantum states, but if they resulted from running a program,
    we can tell someone else what steps they need to take to prepare the same states.
    As we saw previously, quantum programs are a special kind of classical program,
    so we can copy them with reckless abandon. As we will see throughout the rest
    of the book, any quantum state can either be approximated or written out exactly
    by the output of a quantum program that starts with only copies of the |0〉 state.
    For example, in chapter 2, we prepared the initial state |+〉 of a QRNG with a
    program consisting of a single `H` instruction.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法复制量子状态，但如果它们是运行程序的结果，我们可以告诉其他人他们需要采取哪些步骤来准备相同的状态。正如我们之前所看到的，量子程序是一种特殊的经典程序，因此我们可以随意复制它们。正如我们将在本书的其余部分看到的那样，任何量子状态都可以通过从只有
    |0〉 状态的副本开始的量子程序的输出来近似或精确写出。例如，在第 2 章中，我们使用一个由单个 `H` 指令组成的程序来准备 QRNG 的初始状态 |+〉。
- en: Put differently, we can think of a program as being a recipe for how to prepare
    a qubit. Given a qubit, we cannot determine what recipe was used to prepare it,
    but we can copy the recipe itself as much as we like.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们可以将程序视为如何准备量子比特的配方。给定一个量子比特，我们无法确定用于准备它的配方是什么，但我们可以随意复制配方本身。
- en: Whereas the steps in executing `quicksort` instruct the Python interpreter to
    compare values and to move values around in memory, the steps in a Q# program
    instruct our target machines to apply rotations and measurements to qubits in
    a device. As shown in figure 8.1, we can use a host program to send Q# applications
    to each different target machine to run. For now, we’ll keep using the IQ# plugin
    for Jupyter Notebook as our host program; in the next chapter, we’ll see how to
    use C# to write our own host programs as well.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与执行 `quicksort` 的步骤指导 Python 解释器比较值并在内存中移动值不同，Q# 程序中的步骤指导我们的目标机器对设备中的量子比特应用旋转和测量。如图
    8.1 所示，我们可以使用主机程序将 Q# 应用程序发送到每个不同的目标机器以运行。目前，我们将继续使用 IQ# 插件作为 Jupyter Notebook
    的主机程序；在下一章中，我们将看到如何使用 C# 编写我们自己的主机程序。
- en: Most of the time in this book, we’re interested in simulating quantum programs,
    so we use the `QuantumSimulator` target machine. This simulator works very similarly
    to the ones we developed in chapters 2 and 4, as it executes instructions such
    as the Hadamard instruction `H` by multiplying quantum states with unitary operators
    like *H*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的大部分时间里，我们感兴趣的是模拟量子程序，所以我们使用 `QuantumSimulator` 目标机器。这个模拟器的工作方式与我们在第 2 章和第
    4 章中开发的模拟器非常相似，因为它通过乘以单位算符如 *H* 来执行像 `H` 这样的指令。
- en: Tip As in previous chapters, we use fonts to distinguish instructions like `H`
    from unitary matrices like *H* that we use to simulate those instructions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：与前面的章节一样，我们使用字体来区分像 `H` 这样的指令与用于模拟这些指令的单位矩阵 *H*。
- en: The `ResourcesEstimator` target machine allows us to not run a quantum program
    but get estimates of how many qubits *would* be required to run it. This is useful
    for larger programs that cannot be classically simulated or run on available hardware,
    to help us learn how many qubits it will take; we’ll see more about this target
    machine later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourcesEstimator` 目标机器允许我们不仅运行量子程序，还可以得到运行该程序所需的量子比特数量的估计。这对于无法用经典方法模拟或运行在现有硬件上的大型程序非常有用，帮助我们了解需要多少量子比特；我们将在稍后了解更多关于这个目标机器的信息。'
- en: Since Q# applications send instructions to the target machines that we use to
    run them, it’s easy to reuse Q# code later across different target machines that
    share the same instruction set. The `QuantumSimulator` target machine, for instance,
    uses the same instructions that we expect actual quantum hardware to take, once
    it becomes available; thus we can test Q# programs on simulators now using small
    instances of problems and then run the same programs on quantum hardware later.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Q#应用程序将指令发送到我们用于运行它们的目标机器，因此很容易在具有相同指令集的不同目标机器上重用Q#代码。例如，`QuantumSimulator`目标机器使用我们期望实际量子硬件采取的相同指令，一旦它可用；因此，我们现在可以在模拟器上使用小规模的问题实例测试Q#程序，然后稍后在这些量子硬件上运行相同的程序。
- en: What remains in common across these different target machines and applications
    is that we need to write the program that sends instructions to the target machine
    to accomplish some goal. Our task as quantum programmers is thus to make sure
    these instructions have the effect of solving a useful problem.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些不同的目标机器和应用中，共同的是我们需要编写一个程序，向目标机器发送指令以实现某个目标。因此，作为量子程序员，我们的任务是确保这些指令具有解决有用问题的效果。
- en: Tip The way that we use simulators to test Q# programs is a bit similar to how
    we use simulators to test programs for other specialized hardware like field-programmable
    gate arrays (FPGAs) or emulators to test applications for mobile devices from
    our desktops and laptops. The main difference is that we can only use a classical
    computer to simulate a quantum computer for a very small number of qubits or restricted
    kinds of programs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：我们使用模拟器来测试Q#程序的方式与使用模拟器测试其他专用硬件（如现场可编程门阵列（FPGAs））的程序或使用模拟器测试桌面和笔记本电脑上的移动设备应用程序的方式有些相似。主要区别在于，我们只能使用经典计算机来模拟一个非常小的量子比特数或受限制的程序类型的量子计算机。
- en: This is much easier to do when we have an algorithm guiding us to organize the
    steps that need to happen in classical and quantum devices. In developing new
    quantum algorithms, we can use quantum effects, such as entanglement, which we
    saw in chapter 4.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有算法引导我们组织在经典和量子设备中需要发生的步骤时，这样做要容易得多。在开发新的量子算法时，我们可以使用量子效应，例如纠缠，这在第4章中我们已经看到。
- en: Tip To get any advantage from our quantum hardware, we *must* use the unique
    quantum properties of the hardware. Otherwise, we just have a more expensive,
    slower classical computer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：要获得量子硬件的任何优势，我们*必须*使用硬件的独特量子属性。否则，我们只是拥有一个更昂贵、速度更慢的经典计算机。
- en: '8.2 Deutsch–Jozsa algorithm: Moderate improvements for searching'
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 德尔布希-约萨算法：搜索的适度改进
- en: So what might make a good example of a *quantum* algorithm that takes advantage
    of our shiny new quantum hardware? We learned in chapters 4 and 7 that thinking
    about games often helps, and this is no exception. To find a game for this chapter,
    let’s take a trip back to Camelot, where Merlin finds himself facing a test.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么可能是一个好的例子，一个利用我们崭新的量子硬件的*量子*算法呢？我们在第4章和第7章中学到，思考游戏往往有帮助，这也不例外。为了找到本章的游戏，让我们回到卡美洛，梅林在那里发现自己面临着一个考验。
- en: 8.2.1 Lady of the (quantum) Lake
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 量子湖的女神
- en: Merlin, the famous and wise wizard, has just encountered Nimue, the Lady of
    the Lake. Nimue, seeking a capable mentor for the next King of England, has decided
    to test Merlin to see if he is up to the task. Two bitter rivals, Arthur and Mordred,
    are vying for the throne, and if Merlin accepts Nimue’s task, he must choose whom
    to mentor as king.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 著名的智慧巫师梅林刚刚遇到了尼姆，湖之女神。尼姆，寻求为下一任英格兰国王寻找一位有能力的导师，已经决定测试梅林，看看他是否胜任这项任务。两个 bitter
    rivals，亚瑟和莫德雷德，正在争夺王位，如果梅林接受尼姆的任务，他必须选择谁作为国王的导师。
- en: For her part, Nimue does not care who becomes king, as long as Merlin can give
    them sage council. Nimue *is* concerned about whether Merlin, the appointed instructor
    for the new king, will be reliable and consistent in his leadership.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于尼姆，她不关心谁成为国王，只要梅林能给他们提供明智的建议。尼姆*关心*的是，作为新国王指定的指导者，梅林在领导力上是否会可靠和一致。
- en: 'Since Nimue shares our love of games, she has decided to play a game with Merlin
    to test whether he will be a good mentor. Nimue’s game, Kingmaker, tests to see
    if Merlin is *consistent* in his role as advisor to the king. To play Kingmaker,
    Nimue gives Merlin the name of one of the two bitter rivals, and Merlin must respond
    with whether Nimue’s candidate should be the true heir to the throne. Here are
    the rules:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Nimue和我们一样喜欢玩游戏，她决定和梅林玩游戏来测试他是否会成为一个好导师。Nimue的游戏，国王制造者，测试梅林作为国王顾问的角色是否**一致**。要玩国王制造者，Nimue给梅林两个激烈对手中的一个的名字，梅林必须回答Nimue的候选人是否应该是真正的王位继承人。以下是规则：
- en: In each round, Nimue asks Merlin a single question of the form “Should *potential
    heir* be the king?”
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每一轮中，Nimue问梅林一个形式为“**潜在继承人**应该成为国王吗？”的问题。
- en: Merlin must answer either “yes” or “no,” giving no additional information.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 梅林必须回答“是”或“不”，不提供任何额外信息。
- en: 'Each round gives Nimue more information about the realm of mortals, so she
    wants to ask as few questions as is needed to catch Merlin out if he is not trustworthy.
    Her objectives are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每一轮都给Nimue更多关于凡人领域的信息，因此她希望尽可能少地问问题，以捕捉梅林的不诚实。她的目标是以下内容：
- en: Verify that Merlin will be a good mentor to the new King of England.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证梅林是否会是新英格兰国王的好导师。
- en: Ask as few questions as possible to verify.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能少地问问题来验证。
- en: Avoid learning whom Merlin will say yes to mentoring.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免了解梅林会同意指导谁。
- en: 'At this point, Merlin has four possible strategies:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，梅林有四种可能的策略：
- en: Say “yes” when asked if Arthur should be king and “no” otherwise (good mentor).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被问及亚瑟是否应该成为国王时说“是”，否则说“不”（好导师）。
- en: Say “yes” when asked if Mordred should be king and “no” otherwise (good mentor).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被问及莫德雷德是否应该成为国王时说“是”，否则说“不”（好导师）。
- en: Say “yes” regardless of whom Nimue asks about (bad mentor).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论Nimue询问谁（不良导师）。
- en: Say “no” regardless of whom Nimue asks about (bad mentor).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论Nimue询问谁都说“不”（不良导师）。
- en: We can think of Merlin’s strategies by using the concept of a truth table once
    again. Suppose, for instance, that Merlin has decided to be singularly unhelpful
    and deny any candidates to the throne. We might write this down using the truth
    table in table 8.1.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过再次使用真值表的概念来思考梅林的战略。例如，假设梅林决定特别不帮忙，并拒绝所有王位候选人。我们可能使用表8.1中的真值表来写下这一点。
- en: 'Table 8.1 Truth table for one possible Kingmaker strategy: Merlin always says
    no.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 一种可能的国王制造者策略的真值表：梅林总是说“不”。
- en: '| Input (Nimue) | Output (Merlin) |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 输入（Nimue） | 输出（梅林） |'
- en: '| “Should Mordred be king?” | “No.” |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| “莫德雷德应该成为国王吗？” | “不。” |'
- en: '| “Should Arthur be king?” | “No.” |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| “亚瑟应该成为国王吗？” | “不。” |'
- en: At this point, Nimue would be right to complain about Merlin’s wisdom as a mentor!
    Merlin has not been consistent with his charge to choose between Arthur and Mordred.
    While Nimue may not care whom Merlin picks, he surely must pick *someone* to mentor
    and prepare for the throne.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，Nimue有理由抱怨梅林作为导师的智慧！梅林在让亚瑟和莫德雷德之间做出选择的责任上并不一致。虽然Nimue可能不在乎梅林选择谁，但他肯定必须选择**某人**来指导并准备王位。
- en: 'Nimue needs a strategy to determine in as few rounds of the game as possible
    if Merlin has strategy 1 or 2 (good mentor) or if Merlin is playing according
    to 3 or 4 (bad mentor). She could just ask both questions: “Should Mordred be
    king?” and “Should Arthur be king?” and then compare his answers, but this would
    result in Nimue knowing for sure whom he chose to be king. With each question,
    Nimue learns more about the kingdom’s mortal affairs—how distasteful!'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Nimue需要一种策略，以尽可能少的游戏回合来确定梅林是否有策略1或2（好导师）或梅林是否按照3或4（不良导师）进行游戏。她可以简单地问两个问题：“莫德雷德应该成为国王吗？”和“亚瑟应该成为国王吗？”然后比较他的答案，但这样会导致Nimue确定他选择了谁作为国王。每个问题，Nimue都会更多地了解王国的凡人事务——多么令人不快！
- en: While it would seem Nimue’s game is doomed to force her to learn Merlin’s choice
    of heir, she is in luck. This being a quantum lake, we’ll see throughout the rest
    of this chapter that Nimue can ask a *single* question that will tell her *only*
    if Merlin is committed to his role as a mentor and not whom he has chosen.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来Nimue的游戏注定要迫使她了解梅林的选择继承人，但她很幸运。这是一个量子湖，我们将在本章的其余部分看到，Nimue可以问一个**单一**的问题，这将告诉她**只有**梅林是否致力于他的导师角色，而不是他选择了谁。
- en: Since we don’t have a quantum lake at our disposal, let’s try to model what
    Nimue is doing with quantum instructions in Q# on our classical computer and then
    simulate it. Let’s represent Merlin’s strategy by a classical function *f*, which
    takes Nimue’s question as an input *x*. That is, we’ll write *f*(Arthur) to mean
    “what Merlin answers when asked if Arthur should be king.” Note that since Nimue
    will ask one of only two questions, which question she asks is an example of a
    bit. Sometimes it’s convenient to write that bit using the labels “0” and “1”,
    and other times it’s helpful to label Nimue’s input bit using the Boolean values
    “False” and “True”. After all, “1” would be a pretty strange answer to a question
    like “Should Mordred be king?”
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有可用的量子湖，让我们尝试用Q#在经典计算机上模拟尼缪使用量子指令的行为，然后进行模拟。让我们用梅林的战略来表示一个经典函数*f*，它将尼缪的问题作为输入*x*。也就是说，我们将写*f*(亚瑟)来表示“当被问及亚瑟是否应该成为国王时，梅林会怎么回答。”请注意，由于尼缪只会问两个问题中的一个，她问的问题是一个比特的例子。有时使用标签“0”和“1”来写这个比特是方便的，有时使用布尔值“False”和“True”来标记尼缪的输入比特是有帮助的。毕竟，“1”对于一个像“莫德雷德应该成为国王吗？”这样的问题来说是一个非常奇怪的答案。
- en: Using bits, we write *f*(0) = 0 to mean that if Nimue asks Merlin, “Should Mordred
    be king?” his answer is no. Table 8.2 shows how we can map Nimue’s questions to
    Boolean values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用比特，我们写*f*(0) = 0来表示，如果尼缪问梅林，“莫德雷德应该成为国王吗？”他的回答是否定的。表8.2显示了我们可以如何将尼缪的问题映射到布尔值。
- en: Table 8.2 Encoding Nimue’s question as a bit
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2 将尼缪的问题编码为比特
- en: '| Nimue’s question | Representation as a bit | Representation as a Boolean
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 尼缪的问题 | 作为比特的表示 | 作为布尔值的表示 |'
- en: '| “Should Mordred be king?” | 0 | False |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| “莫德雷德应该成为国王吗？” | 0 | 否 |'
- en: '| “Should Arthur be king?” | 1 | True |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| “亚瑟应该成为国王吗？” | 1 | 是 |'
- en: If she didn’t have any quantum resources, to be sure of what Merlin’s strategy
    is, Nimue would have to try both inputs to *f*; that is, she’d have to ask Merlin
    both questions. Trying all the inputs would give her Merlin’s full strategy; and
    as noted, Nimue is not really interested in it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果她没有量子资源，为了确保知道梅林的战略，尼缪必须尝试*f*的所有输入；也就是说，她必须问梅林两个问题。尝试所有输入将给出梅林的全部战略；如前所述，尼缪并不真正对此感兴趣。
- en: Instead of having to ask Merlin about both Mordred and Arthur, we can implement
    a quantum algorithm in Q# that uses quantum effects to learn whether Merlin is
    a good mentor by asking him only *one* question. Using the simulators provided
    with the Quantum Development Kit, we can even run our new Q# program on our laptops
    or desktops! In the rest of this chapter, we’ll look at an example of how to write
    this quantum algorithm, called the Deutsch–Jozsa algorithm (see figure 8.2).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要询问梅林关于莫德雷德和亚瑟的情况，我们可以在Q#中实现一个量子算法，通过只问梅林一个问题来学习他是否是一个好的导师。使用Quantum Development
    Kit提供的模拟器，我们甚至可以在我们的笔记本电脑或台式机上运行我们的新Q#程序！在本章的其余部分，我们将探讨如何编写这个量子算法的示例，称为Deutsch–Jozsa算法（见图8.2）。
- en: '![](../Images/8-2.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图8-2](../Images/8-2.png)'
- en: Figure 8.2 We will be working in the Microsoft Quantum Development Kit software
    stack for this chapter, writing Q# programs that are run via a Jupyter Notebook
    host on a simulator target machine.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 本章我们将使用Microsoft Quantum Development Kit软件栈，编写在模拟目标机器上的Jupyter Notebook主机上运行的Q#程序。
- en: Let’s sketch out what our quantum program will look like. The possible inputs
    and outputs for *f* (Merlin’s strategy) are `True` and `False`. We can write a
    truth table for *f* using the inputs and outputs we get when we call *f*. For
    instance, if *f* is the classical NOT operation (often denoted ¬), then we will
    observe that *f* (`True`) is `False` and vice versa. As shown in table 8.3, using
    a classical NOT operation as a strategy in our game corresponds to picking Mordred
    to be king.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们勾勒出我们的量子程序将是什么样子。函数*f*（梅林的战略）的可能输入和输出是`True`和`False`。我们可以使用调用*f*时得到的输入和输出为*f*编写一个真值表。例如，如果*f*是经典NOT操作（通常表示为¬），那么我们会观察到*f*(`True`)是`False`，反之亦然。如表8.3所示，在我们的游戏中使用经典NOT操作作为策略对应于选择莫德雷德成为国王。
- en: Table 8.3 Truth table for the classical NOT operation
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.3 经典NOT操作的真值表
- en: '| Input | Output |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | 输出 |'
- en: '| `True` (“Should Arthur be king?”) | `False` (“No.”) |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `True`（“亚瑟应该成为国王吗？”） | `False`（“不。”） |'
- en: '| `False` (“Should Mordred be king?”) | `True` (“Yes.”) |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `False`（“莫德雷德应该成为国王吗？”） | `True`（“是的。”） |'
- en: There are four possible options for the definition of our function *f*, each
    of which represents one of the four strategies available to Merlin, as summarized
    in figure 8.3.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们函数*f*的定义有四种可能的选择，每种选择代表梅林可用的四种策略之一，如图8.3所示。
- en: '![](../Images/8-3.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-3.png)'
- en: Figure 8.3 Four different functions from one bit to one bit. We call the two
    functions in the top row *balanced* because equally many inputs map to 0 as inputs
    that map to 1\. We call the two functions in the bottom row *constant* as all
    inputs map to a single output.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 从一位到一位的四个不同函数。我们称顶行中的两个函数为**平衡的**，因为映射到0的输入和映射到1的输入数量相等。我们称底行中的两个函数为**常函数**，因为所有输入都映射到单个输出。
- en: Two of these functions, labeled `id` and `not` for convenience, send each of
    the `0` and `1` inputs to different outputs; we call these functions *balanced*.
    In our little game, they represent the cases in which Merlin picks exactly one
    person to be king. All the cases are listed in table 8.4.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其中两个函数，为了方便起见标记为`id`和`not`，将每个`0`和`1`输入映射到不同的输出；我们称这些函数为**平衡的**。在我们的小游戏中，它们代表梅林恰好选择一个人成为国王的情况。所有情况都在表8.4中列出。
- en: Table 8.4 Classifying Merlin’s strategies as either constant or balanced
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.4 将梅林的战略分类为常函数或平衡函数
- en: '| Merlin’s strategy | Function | Type | Passes Nimue’s challenge? |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 梅林的战略 | 函数 | 类型 | 是否通过尼缪的挑战？ |'
- en: '| Choose Arthur | `id` | Balanced (*f*(0) ≠ *f*(1)) | Yes |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 选择亚瑟 | `id` | 平衡的 (*f*(0) ≠ *f*(1)) | 是 |'
- en: '| Choose Mordred | `not` | Balanced (*f*(0) ≠ *f*(1)) | Yes |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 选择莫德雷德 | `not` | 平衡的 (*f*(0) ≠ *f*(1)) | 是 |'
- en: '| Choose neither | `zero` | Constant (*f*(0) = *f*(1)) | No |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 选择两者都不 | `zero` | 常函数 (*f*(0) = *f*(1)) | 否 |'
- en: '| Choose both | `one` | Constant (*f*(0) = *f*(1)) | No |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 选择两者 | `one` | 常函数 (*f*(0) = *f*(1)) | 否 |'
- en: On the other hand, the functions that we label `zero` and `one` are *constant*
    functions since they send both inputs to the same output. Constant functions then
    represent strategies in which Merlin is decidedly useless, as he’s either picked
    both to be king (a good way to start a bad war) or picked neither.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们标记为`zero`和`one`的函数是**常函数**，因为它们将两个输入都映射到相同的输出。常函数代表梅林毫无用处的策略，因为他要么选择了两者都成为国王（开启一场糟糕战争的糟糕方式），要么两者都不选择。
- en: Classically, to determine if a function is constant or balanced (whether Merlin
    is a bad or good mentor, respectively), we must learn the entire function by building
    up its truth table. Remember, Nimue wants to ensure that Merlin is a reliable
    mentor. If Merlin follows a strategy represented by a constant function, he will
    not be a good mentor. Looking at the truth tables for the `id` and `one` functions,
    tables 8.5 and 8.6, respectively, we can see how they describe when Merlin is
    following a strategy that will let him be a good or bad mentor.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 经典地，要确定一个函数是否是常函数或平衡函数（分别对应梅林是好导师还是坏导师），我们必须通过构建其真值表来学习整个函数。记住，尼缪想要确保梅林是一个可靠的导师。如果梅林遵循由常函数表示的策略，他将不是一个好的导师。通过查看`id`和`one`函数的真值表，即表8.5和表8.6，我们可以看到它们如何描述梅林遵循的策略将使他成为一个好导师或坏导师。
- en: Table 8.5 Truth table for the `id` function, an example of a balanced function
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.5 `id`函数的真值表，一个平衡函数的例子
- en: '| Input | Output |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | 输出 |'
- en: '| `True` (“Should Arthur be king?”) | `True` (“Yes”) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `True`（“亚瑟应该成为国王吗？”） | `True`（“是”） |'
- en: '| `False` (“Should Mordred be king?”) | `False` (“No”) |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `False`（“莫德雷德应该成为国王吗？”） | `False`（“否”） |'
- en: Table 8.6 Truth table for the `one` function, an example of a constant function
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.6 `one`函数的真值表，一个常函数的例子
- en: '| Input | Output |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | 输出 |'
- en: '| `True` (“Should Arthur be king?”) | `True` (“Yes”) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `True`（“亚瑟应该成为国王吗？”） | `True`（“是”） |'
- en: '| `False` (“Should Mordred be king?”) | `True` (“Yes”) |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `False`（“莫德雷德应该成为国王吗？”） | `True`（“是”） |'
- en: 'Nimue’s difficulty in trying to learn whether Merlin is a good or bad mentor
    (that is, whether *f* is balanced or constant) is that the quality of Merlin’s
    mentorship is a kind of *global* property of his strategy. There’s no way to look
    at a single output of *f* and conclude anything about what *f* would output for
    different inputs. If we only have access to *f*, then Nimue is stuck: she must
    reconstruct the entire truth table to decide whether Merlin’s strategy is constant
    or balanced.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尼缪试图学习梅林是好导师还是坏导师（即，*f*是否平衡或常函数）的困难在于，梅林导师的质量是他策略的一种**全局**属性。无法通过查看*f*的单一输出来得出关于*f*对不同输入输出的任何结论。如果我们只能访问*f*，那么尼缪就陷入了困境：她必须重建整个真值表来决定梅林的策略是否是常函数或平衡函数。
- en: On the other hand, if we can represent Merlin’s strategy as a part of a quantum
    program, we can use the quantum effects we’ve learned about so far in the book.
    Using quantum computing, Nimue can learn *only* if his strategy is constant or
    balanced, without having to learn exactly which strategy he’s using. Since we
    are not interested in the information the truth table provides beyond whether
    Merlin is a good or bad mentor, using quantum effects can help us learn what we
    care about more directly. With our quantum algorithm, we can do this with one
    call of the function and without needing to learn any additional information we
    are not interested in. By not asking for all the details of the truth table but
    only looking for more general properties of our function, we can best utilize
    our quantum resources.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们能将梅林的战略表示为量子程序的一部分，我们就可以使用本书中我们已经了解到的量子效应。利用量子计算，尼姆只有在梅林的战略是恒定或平衡的情况下才能学习，而不必确切地了解他正在使用哪种策略。由于我们并不关心真值表提供的信息是否超出了梅林是好导师还是坏导师，使用量子效应可以帮助我们更直接地学习我们所关心的内容。凭借我们的量子算法，我们可以通过一次函数调用就完成这项工作，而无需学习任何我们不感兴趣的信息。通过不要求所有真值表的细节，而只是寻找我们函数的更一般性质，我们可以最大限度地利用我们的量子资源。
- en: The power of quantum computing
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算的力量
- en: 'If we want to use a *classical* computer to learn whether a function is constant
    or balanced, we have to solve a harder problem first: identifying exactly which
    function we have. In contrast, quantum mechanics lets us solve only the problem
    we care about (constant versus balanced) without solving the more challenging
    problem a classical computer has to solve.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用经典计算机来学习一个函数是否恒定或平衡，我们首先必须解决一个更难的问题：确定我们确切拥有哪个函数。相比之下，量子力学只让我们解决我们关心的问题（恒定与平衡），而不必解决经典计算机必须解决的更具挑战性的问题。
- en: This is an example of a pattern we’ll see throughout the book, in which quantum
    mechanics lets us specify less powerful algorithms than we can express classically.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中我们将看到的一个模式示例，其中量子力学让我们能够指定比经典情况下更弱的算法。
- en: To do so, we will use the Deutsch–Jozsa algorithm, which uses a *single query*
    to our quantum representation of Merlin’s strategy to learn whether he is a good
    or bad mentor. The advantage isn’t terribly practical (a savings of only one question),
    but that’s OK; we’ll see more practical algorithms later in the book. For now,
    the Deutsch–Jozsa algorithm is a great place to start learning how to implement
    quantum algorithms and, even more importantly, what tools we can use to understand
    what quantum algorithms do.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用 Deutsch-Jozsa 算法，该算法使用对梅林策略的量子表示的单次查询来学习他是否是一个好导师或坏导师。这种优势并不非常实用（仅节省一个问题），但没关系；我们将在本书的后面部分看到更多实用的算法。现在，Deutsch-Jozsa
    算法是一个学习如何实现量子算法和，更重要的是，我们可以使用哪些工具来理解量子算法做什么的绝佳起点。
- en: '8.3 Oracles: Representing classical functions in quantum algorithms'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 奥秘：在量子算法中表示经典函数
- en: 'Let’s see what things look like from Nimue’s quantum lake. As we plunge in
    for a swim, we face a somewhat immediate question: how can we use qubits to implement
    the function *f* that represents Merlin’s strategy? From the previous section,
    we saw that the classical function *f* is our description of a strategy that Merlin
    uses to play each round of Kingmaker. Since *f* is classical, it’s easy to translate
    this back into a set of actions that Merlin will take: Nimue gives Merlin a single
    classical bit (her question), and Merlin gives Nimue a classical bit back (his
    answer).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看从尼姆的量子湖中看事物是什么样子。当我们跳入湖中游泳时，我们面临一个相当直接的问题：我们如何使用量子位来实现代表梅林策略的函数 *f*？从上一节中，我们看到经典函数
    *f* 是我们对梅林在每一轮国王制造者游戏中使用的策略的描述。由于 *f* 是经典的，因此很容易将其翻译成梅林将采取的一系列行动：尼姆给梅林一个单独的经典比特（她的问题），梅林给尼姆一个经典比特作为回答（他的答案）。
- en: To avoid meddling in the affairs of mortals, Nimue now wants to use the Deutsch–Jozsa
    algorithm, instead. Since she lives in a quantum lake, Nimue can easily allocate
    a qubit to give Merlin. Lucky for us, Merlin knows how to communicate with qubits,
    but we still need to figure out what Merlin will do with Nimue’s qubits to act
    on his strategy.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免干涉凡人的事务，尼姆现在想使用 Deutsch-Jozsa 算法，而不是其他方法。由于她生活在量子湖中，尼姆可以轻松地分配一个量子位给梅林。幸运的是，梅林知道如何与量子位进行通信，但我们仍然需要弄清楚梅林会如何使用尼姆的量子位来执行他的策略。
- en: 'The trouble is, we can’t pass qubits to the function *f* that we use to represent
    Merlin’s strategy: *f* takes and returns classical bits, not qubits. For Merlin
    to use his strategy to guide what he does with Nimue’s qubits, we want to turn
    Merlin’s strategy *f* into a kind of quantum program known as an *oracle*. Conveniently
    for us, Merlin plays the role of an oracle pretty well.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，我们不能将量子比特传递给用于表示梅林策略的函数*f*：*f*接受并返回经典比特，而不是量子比特。为了使梅林能够使用他的策略来指导他对尼穆量子比特的处理，我们希望将梅林的策略*f*转化为一种称为*预言机*的量子程序。对我们来说，幸运的是，梅林非常适合扮演预言机的角色。
- en: Note From the T. H. White treatment of Merlin, we learn that he lives life backward
    in time. We’ll represent that by making sure everything Merlin does is *unitary*.
    As we saw in chapter 2, one consequence is that the transformations Merlin applies
    are *reversible*. In particular, Merlin won’t be able to measure Nimue’s qubits
    since measurement is not reversible. That privilege is Nimue’s alone.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：从T. H. White对梅林的描述中，我们了解到他生活在时间倒流中。我们将通过确保梅林所做的一切都是*可逆的*来表示这一点。正如我们在第2章中看到的，一个结果是梅林无法测量尼穆的量子比特，因为测量是不可逆的。这项特权仅属于尼穆。
- en: 'To understand what we need to do to model Merlin’s actions as an oracle, we
    have to figure out two things:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解我们将梅林的行为建模为预言机需要做什么，我们必须弄清楚两件事：
- en: What transformation should Merlin apply to Nimue’s qubits based on his strategy?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于他的策略，梅林应该对尼穆的量子比特应用什么变换？
- en: What quantum operations will Merlin need to apply to implement that transformation?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 梅林需要应用哪些量子操作来实现这种变换？
- en: Unitary matrices and truth tables
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵和真值表
- en: 'Another way of saying what we need to do in step 1 is that we need to find
    a *unitary matrix* that represents what Merlin does, similar to how we used classical
    functions like *f* to represent what Merlin did when Nimue gave him classical
    bits. As we saw in chapter 2, unitary matrices are to quantum computing as truth
    tables are to classical computing: they tell us what the effect of a quantum operation
    is for every possible input. Once we find the right unitary, in step 2 we’ll figure
    out the sequence of quantum operations we can do that will be described by that
    unitary.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种说法是，我们在步骤1中需要做的事情是找到表示梅林行为的*单位矩阵*，类似于我们如何使用经典函数*f*来表示梅林在尼穆给他经典比特时所做的行为。正如我们在第2章中看到的，单位矩阵对量子计算的作用就像真值表对经典计算的作用：它们告诉我们对于每个可能的输入，量子操作的效果是什么。一旦我们找到了正确的单位矩阵，在步骤2中，我们将确定可以由该单位矩阵描述的量子操作的序列。
- en: 8.3.1 Merlin’s transformations
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 梅林的变换
- en: To complete step 1, we need to turn functions like *f* into unitary matrices,
    so let’s start by recapping what *f* can be. The possible strategies Merlin can
    use are represented by the functions `id`, `not`, `zero`, and `one` (see figure
    8.4).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成步骤1，我们需要将像*f*这样的函数转换为单位矩阵，所以让我们首先回顾一下*f*可以是什么。梅林可能使用的策略由函数`id`、`not`、`zero`和`one`（见图8.4）表示。
- en: '![](../Images/8-4.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/8-4.png](../Images/8-4.png)'
- en: Figure 8.4 Four different functions from one bit to one bit
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 从一位到一位的四个不同函数
- en: For the two balanced functions `id` and `not` in figure 8.4 we can answer question
    1 easily. Quantum programs for `id` and `not` can be implemented as rotation operations,
    making it easy to turn them into quantum operations. The quantum NOT operation,
    for instance, is a rotation of 180° around the *X*-axis, exchanging the |0〉 and
    |1〉 states with each other.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图8.4中的两个平衡函数`id`和`not`，我们可以轻松回答问题1。`id`和`not`的量子程序可以作为旋转操作实现，这使得它们很容易转化为量子操作。例如，量子非操作是在*X*-轴上旋转180°，交换|0〉和|1〉状态。
- en: 'Tip Recall from chapter 3 that the quantum operation `X`, represented by the
    unitary matrix ![](../Images/8-4_E1.png), applies a rotation of 180° around the
    *X* axis. This operation implements a quantum NOT: since *X*|0〉 = |1〉 and *X*|1〉
    = |0〉, we can write it using the ¬ (NOT) operator from chapter 2 as *X*|*x*〉 =
    |¬*x*〉.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：回顾第3章，量子操作`X`，由单位矩阵![../Images/8-4_E1.png](../Images/8-4_E1.png)表示，在*X*轴上旋转180°。这个操作实现了量子非操作：因为*X*|0〉
    = |1〉和*X*|1〉 = |0〉，我们可以用第2章中的¬（非）操作符来表示它，即*X*|*x*〉 = |¬*x*〉。
- en: While any rotation can be undone by rotating the same amount in the opposite
    direction, we run into more problems with the constant functions `zero` and `one`.
    Neither `zero` nor `one` can be implemented directly as rotations, so we have
    a bit more work to do. For instance, if *f* is `zero`, then the outputs *f*(0)
    and *f*(1) are both `0`. If we only have the output `0`, we cannot tell whether
    we got that output from giving *f* a 0 or a 1 as input (see figure 8.5).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然任何旋转都可以通过向相反方向旋转相同的角度来撤销，但在常数函数`zero`和`one`上我们会遇到更多问题。`zero`和`one`都不能直接作为旋转来实现，所以我们还有更多工作要做。例如，如果*f*是`zero`，那么输出*f*(0)和*f*(1)都是`0`。如果我们只有输出`0`，我们就无法判断我们是将`0`还是`1`作为输入给*f*得到的（见图8.5）。
- en: '![](../Images/8-5.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图8-5](../Images/8-5.png)'
- en: Figure 8.5 Why can’t we reverse the constant `zero` or `one` functions? Basically,
    we lose the information about which input we started with if all inputs map to
    a single output.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 为什么不能撤销常数`zero`或`one`函数？基本上，如果所有输入都映射到单个输出，我们就失去了关于我们最初输入的信息。
- en: Note Once we apply `zero` or `one`, we have lost any information about the input.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一旦我们应用`zero`或`one`，我们就失去了关于输入的任何信息。
- en: 'Since `one` and `zero` are both irreversible, and valid operations on qubits
    are reversible, Merlin needs another way to represent functions like *f* in quantum
    algorithms such as the one for Nimue’s challenge. On the other hand, if we can
    represent Merlin’s strategy with a reversible classical function instead of *f*,
    it will be much easier to write a quantum representation of his strategy. Here
    is our strategy for representing classical functions as quantum oracles:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`one`和`zero`都是不可逆的，而有效的量子比特操作是可逆的，因此梅林需要另一种方法来在尼缪挑战等量子算法中代表像*f*这样的函数。另一方面，如果我们可以用可逆的经典函数而不是*f*来表示梅林的战略，那么编写他战略的量子表示将容易得多。以下是我们将经典函数表示为量子或acles的策略：
- en: Find a way to represent our irreversible classical function with a reversible
    classical function.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一种方法来用可逆的经典函数表示我们的不可逆经典函数。
- en: Write a transformation on quantum states using our reversible classical function.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们可逆的经典函数对量子态进行变换。
- en: Figure out what quantum operations we can do that result in that transformation.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定我们可以进行哪些量子操作以产生那种变换。
- en: Let’s use the tried-and-true approach of guessing and checking to see if we
    can design a valid reversible classical function. The easiest way to figure out
    whether we were given a `0` or a `1` as an input is to record it somewhere. So
    let’s make a new function that returns two bits instead of one.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用经过验证的方法，即猜测和检查，来看看我们是否可以设计一个有效的可逆经典函数。确定我们是否得到了`0`或`1`作为输入的最简单方法是将它记录下来。所以让我们创建一个新的函数，它返回两个比特而不是一个。
- en: 'For our first attempt, let’s record and keep the input:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一次尝试，让我们记录并保留输入：
- en: '*g*(*x*) = (*x*, *f*(*x*))'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*g*(x) = (x, *f*(x*))'
- en: For example, if Merlin uses the strategy `one` (that is, he says “yes” to Nimue
    no matter what she asks), then *f*(*x*) = 1, and *g*(*x*) = (*x*, *f*(*x*)) =
    (*x*, 1).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果梅林使用策略`one`（也就是说，无论尼缪问他什么，他都回答“是”），那么*f*(x) = 1，而*g*(x) = (x, *f*(x*))
    = (x, 1)。
- en: This gets us a lot closer since we can now tell whether we started with a 0
    or 1 input. But we’re not quite there, since *g* has two outputs and one input
    (see figure 8.6).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们更接近目标，因为我们现在可以判断我们是开始于`0`还是`1`输入。但我们还没有完全达到目标，因为*g*有两个输出和一个输入（见图8.6）。
- en: '![](../Images/8-6.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图8-6](../Images/8-6.png)'
- en: 'Figure 8.6 First attempt: keeping input and output with *g*(*x*). Using this
    approach, some output combinations can’t be reached from any input (e.g., no input
    produces the output (`1`,`0`)). Thus it is impossible to reverse the function
    since there’s no input corresponding to those outputs.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 第一次尝试：使用*g*(x)保留输入和输出。使用这种方法，一些输出组合无法从任何输入中得到（例如，没有输入产生输出（`1`,`0`））。因此，由于没有输入对应那些输出，无法撤销函数。
- en: To use *g* as a strategy, Merlin would have to give Nimue back more qubits than
    she gave him, but she is the keeper of both swords and qubits. More technically,
    reversing *g* would destroy information, as it would take two inputs and return
    one output!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用*g*作为策略，梅林必须给尼缪回更多的量子比特，但她既是双剑也是量子比特的守护者。更技术地说，撤销*g*会破坏信息，因为它需要两个输入并返回一个输出！
- en: Trying one more time, let’s define a new classical function *h* that takes two
    inputs and returns two outputs, *h*(*x*, *y*). Let’s again consider the example
    where we describe Merlin’s strategy with the function *f*(*x*) = 1\. Since *g*
    got us nearly there, we’ll choose *h* such that *h*(*x*, 0) = *g*(*x*). We saw
    from our first attempt that when Merlin uses the strategy *f*(*x*) = 1, then *g*(*x*)
    = (*x*, 1), so we have that *h*(*x*, 0) = (*x*, 1). Now we just need to define
    what happens when we pass *y* = 1 to *h*. If we want *h* to be reversible, we
    need that *h*(*x*, 1) is assigned to something other than (*x*, 1). One way to
    do this is to let *h*(*x*, *y*) = (*x*, ¬*y*) so that *h*(*x*, 1) = (*x*, 0) ≠
    (*x*, 1). This choice is especially convenient since applying *H* twice gets us
    back our original input, *h*(*h*(*x*, *y*)) = *h*(*x*, ¬*y*) = (*x*, ¬¬*y*) =
    (*x*, *y*). If this a bit wordy, take a look at a visual representation of this
    argument in figure 8.7.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 再试一次，让我们定义一个新的经典函数 *h*，它接受两个输入并返回两个输出，即 *h*(*x*, *y*)。让我们再次考虑这样一个例子，我们用函数 *f*(*x*)
    = 1 来描述 Merlin 的策略。由于 *g* 几乎带我们到达了目的地，我们将选择 *h* 使得 *h*(*x*, 0) = *g*(*x*)。从我们的第一次尝试中，我们看到当
    Merlin 使用策略 *f*(*x*) = 1 时，*g*(*x*) = (*x*, 1)，因此我们有 *h*(*x*, 0) = (*x*, 1)。现在我们只需要定义当我们将
    *y* = 1 传递给 *h* 时会发生什么。如果我们想让 *h* 是可逆的，我们需要 *h*(*x*, 1) 被分配给除了 (*x*, 1) 之外的其他值。一种方法是将
    *h*(*x*, *y*) 定义为 (*x*, ¬*y*)，这样 *h*(*x*, 1) = (*x*, 0) ≠ (*x*, 1)。这个选择特别方便，因为应用
    *H* 两次会带我们回到原始输入，即 *h*(*h*(*x*, *y*)) = *h*(*x*, ¬*y*) = (*x*, ¬¬*y*) = (*x*,
    *y*)。如果这有点啰嗦，请查看图 8.7 中这个论点的视觉表示。
- en: '![](../Images/8-7.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7](../Images/8-7.png)'
- en: 'Figure 8.7 Second attempt: *h*(*x*, *y*), which is reversible and has the same
    number of inputs and outputs'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 第二次尝试：*h*(*x*, *y*)，这是一个可逆的，并且具有相同数量输入和输出的函数
- en: Now that we know how to make a *reversible* classical function from each strategy,
    let’s finish by making a quantum program from our reversible function. In the
    case of `one`, we saw that *h* flips its second input, *h*(*x*, *y*) = (*x*, ¬*y*).
    Thus we can write a quantum program that does the same thing as our reversible
    classical function simply by flipping the second of two input qubits. As we saw
    in chapter 4, we can do this using the `X` instruction since *X*|*x*〉 = |¬*x*〉.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何从每个策略制作一个可逆的经典函数，让我们通过制作一个量子程序来完成我们的可逆函数。在 `one` 的情况下，我们看到 *h* 翻转了它的第二个输入，*h*(*x*,
    *y*) = (*x*, ¬*y*)。因此，我们可以编写一个量子程序，它简单地通过翻转两个输入量子比特中的第二个来实现与我们的可逆经典函数相同的功能。正如我们在第
    4 章中看到的，我们可以使用 `X` 指令来做这件事，因为 *X*|*x*〉 = |¬*x*〉。
- en: 8.3.2 Generalizing our results
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 推广我们的结果
- en: More generally, we can make a reversible quantum operation in precisely the
    same way we made reversible classical function *h* by flipping an output bit based
    on the output of the irreversible function *f*. We can define the unitary matrix
    (that is, the quantum analogue of a truth table) *U[f]* for *f* for each input
    state in exactly the same way. Figure 8.8 shows a comparison of how we can do
    this definition.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，我们可以通过翻转不可逆函数 *f* 的输出位来精确地以我们构建可逆经典函数 *h* 的相同方式构建一个可逆的量子操作。我们可以为 *f* 的每个输入状态定义单位矩阵（即真值表的量子对应物）*U[f]*。图
    8.8 显示了如何进行这种定义的比较。
- en: '![](../Images/8-8.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8](../Images/8-8.png)'
- en: 'Figure 8.8 Constructing reversible classical functions and unitary matrices
    from irreversible classical functions. On the left, we can see that we can build
    a reversible classical function from an irreversible one if we keep track of the
    input we are giving to the irreversible function. We can do the same for a unitary
    matrix that describes a quantum operation by having two registers of qubits: one
    register keeps track of the input, and the other holds the output of our irreversible
    function.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 从不可逆的经典函数构建可逆的经典函数和幺正矩阵。在左侧，我们可以看到，如果我们跟踪我们提供给不可逆函数的输入，我们可以从一个不可逆的经典函数构建一个可逆的经典函数。我们可以通过有两个量子比特寄存器来描述量子操作的单位矩阵，一个寄存器跟踪输入，另一个持有不可逆函数的输出。
- en: Defining *U[f]* this way makes it easy to undo the call to *f* since applying
    *U[f]* twice gives us the identity 𝟙 (that is, the unitary matrix for the “do
    nothing” instruction). When we define a unitary matrix this way by applying a
    function *f* conditionally to the labels for qubit states, we call this new operation
    an *oracle*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式定义 *U[f]* 使得取消对 *f* 的调用变得容易，因为应用 *U[f]* 两次给出恒等矩阵 𝟙（即“无操作”指令的单位矩阵）。当我们通过将函数
    *f* 有条件地应用于量子状态标签来以这种方式定义单位矩阵时，我们称这种新操作为 *oracle*。
- en: Definition An *oracle* is a quantum operation represented by a unitary matrix
    *U[f]* that transforms its input state as
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：一个*预言机*是一个由单位矩阵*U[f]*表示的量子操作，它将其输入状态转换为
- en: '![](../Images/equation_8-1.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/equation_8-1.png)'
- en: The symbol ⊕ represents the exclusive OR operator from regular Boolean logic.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 符号⊕代表常规布尔逻辑中的异或运算符。
- en: 'All that’s left is to figure out what sequence of instructions we need to send
    to implement each unitary *U[f]* . We’ve seen the instructions we need to implement
    an oracle for `one`: an `X` instruction on the second qubit. Now let’s look at
    how to write oracles for other possible *f* functions. That way, Merlin will know
    what he should do no matter what his strategy is.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是确定我们需要发送什么序列的指令来实现每个单位操作*U[f]*。我们已经看到了实现`one`预言机的指令：对第二个量子比特执行一个`X`指令。现在让我们看看如何为其他可能的*f*函数编写预言机。这样，梅林就会知道无论他的策略是什么，他都应该做什么。
- en: 'Deep dive: Why is it called an oracle?'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：为什么叫它预言机？
- en: So far, we’ve seen a few different examples of the kind of whimsical naming
    that quantum computing owes to its physics history, like bra, ket, and teleportation.
    It’s not just physicists who like to have a bit of fun, though! One branch of
    theoretical computer science called *complexity theory* explores what it is possible
    to do efficiently, even in principle, given different kinds of computing machines.
    You may have heard, for instance, of the “**P** versus **NP**” problem, a classic
    conundrum in complexity theory that asks whether problems in **P** are as difficult
    to solve as those in **NP**. The complexity class **P** is the group of questions
    for which there exists a way to answer them with an algorithm that takes polynomial
    time. In contrast, **NP** is the group of questions for which we can check a potential
    answer in polynomial time, but we don’t know if we can come up with an answer
    from scratch in polynomial time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一些量子计算从其物理历史中继承的有趣命名例子，如bra、ket和传送。然而，喜欢玩点小乐趣的不仅仅是物理学家！理论计算机科学的一个分支，称为*复杂性理论*，探索了在给定不同类型的计算机器的情况下，理论上可以高效完成的事情。例如，你可能听说过“**P**与**NP**”问题，这是复杂性理论中的一个经典难题，它询问**P**类问题是否像**NP**类问题一样难以解决。复杂度类**P**是那些存在算法可以在多项式时间内回答的问题的集合。相比之下，**NP**是那些我们可以在多项式时间内检查一个潜在答案的集合，但我们不知道是否可以在多项式时间内从头开始提出一个答案。
- en: Many other problems in complexity theory are posed by introducing small games
    or stories to help researchers remember what definitions to use where. Our own
    little story about Merlin and Nimue is a nod to this tradition. In fact, one of
    the most celebrated stories in quantum computing is called **MA** for “Merlin–Arthur.”
    Problems in the class **MA** are thought of using a story in which Arthur gets
    to ask Merlin, an all-powerful but untrustworthy wizard, a set of questions. A
    yes/no decision problem is in **MA** if, whenever the answer is “yes,” there exists
    a proof that Merlin can give Arthur and that Arthur can easily check using a **P**
    machine and a random number generator.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性理论中的许多其他问题都是通过引入小的游戏或故事来提出的，以帮助研究人员记住在哪里使用哪些定义。我们关于梅林和尼姆的这个小故事是对这一传统的致敬。事实上，量子计算中最受赞誉的故事之一被称为**MA**，代表“梅林-亚瑟”。在**MA**类中的问题被认为是一个故事，其中亚瑟可以向全能但不可信的巫师梅林提出一系列问题。如果一个yes/no决策问题在**MA**中，那么每当答案是“yes”时，都存在梅林可以给亚瑟的证明，亚瑟可以使用一个**P**机器和一个随机数生成器轻松检查。
- en: The name *oracle* fits into this kind of storytelling, in that any complexity
    class **A** can be turned into a new complexity class **A^B** by allowing **A**
    machines to solve a **B** problem in a single step, as though they were consulting
    an oracle. Much of the history of problems like the Deutsch–Jozsa problem stems
    from trying to understand how quantum computing affects computational complexity,
    so many of the naming conventions and much of the terminology has been adopted
    into quantum computing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: “预言机”这个名字很适合这种讲故事的方式，因为任何复杂度类**A**都可以通过允许**A**机器在单步中解决一个**B**问题而转变为一个新的复杂度类**A^B**，就像它们在咨询一个预言机一样。德鲁什-约萨问题等类似问题的历史大部分源于试图理解量子计算如何影响计算复杂性，因此许多命名惯例和术语已被纳入量子计算。
- en: For more on complexity theory and how it relates to quantum computing, black
    holes, free will, and Greek philosophy, check out *Quantum Computing Since Democritus*
    by Scott Aaronson (Cambridge University Press, 2013).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于复杂性理论及其与量子计算、黑洞、自由意志和希腊哲学的关系的信息，请参阅斯科特·阿伦森（Cambridge University Press，2013年）所著的《自从德谟克利特以来的量子计算》。
- en: In general, finding a sequence of instructions by starting from a unitary matrix
    is a mathematically difficult problem known as *unitary synthesis*. That said,
    in this case, we can figure it out by substituting each of Merlin’s strategies
    *f* into our definition for *U f* and identifying what instructions will have
    that effect—we can guess and check in the same way we did to turn the `one` function
    into an oracle. Let’s try this for the `zero` function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，从单位矩阵开始找到一系列指令是一个数学上困难的问题，被称为 *单位合成*。尽管如此，在这种情况下，我们可以通过将Merlin的策略 *f* 中的每一个都代入我们的
    *U f* 定义中，并确定哪些指令会产生那种效果来解决这个问题——我们可以像将 `one` 函数转换为预言机那样猜测和检查。让我们为 `zero` 函数尝试一下。
- en: 'Exercise 8.1: Try writing an oracle!'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习8.1**：尝试编写一个预言机！'
- en: What would the oracle operation (*U[f]*) be for *f* if *f* was `zero`?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *f* 是 `zero`，预言机操作 (*U[f]*) 会是什么？
- en: '*Solution*: Let’s work it out one step at a time:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们一步一步来解决这个问题：'
- en: From the definition for *U[f]*, we know that *U[f]* |*xy*〉 = |*x*〉 |*y* ⊕ *f*(*x*)〉.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *U[f]* 的定义中，我们知道 *U[f]* |*xy*〉 = |*x*〉 |*y* ⊕ *f*(*x*)〉。
- en: Substituting `zero` for *f*, *f*(*x*) = 0, we get that *U[f]* |*xy*〉 = |*x*〉|*y*
    ⊕ 0〉.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `zero` 替换为 *f*，*f*(*x*) = 0，我们得到 *U[f]* |*xy*〉 = |*x*〉|*y* ⊕ 0〉。
- en: We can use that *y* ⊕ 0 = *y* to simplify this further, getting that *U[f]*
    |*xy*〉 = |*x*〉|*y*〉.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 *y* ⊕ 0 = *y* 来进一步简化这个表达式，得到 *U[f]* |*xy*〉 = |*x*〉|*y*〉。
- en: At this point, we notice *U[f]* does nothing to its input state, so we can implement
    it by—doing nothing.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们注意到 *U[f]* 对其输入状态没有任何作用，因此我们可以通过——什么都不做来实现它。
- en: Exercise solutions
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习解决方案**'
- en: 'All solutions for exercises in this book can be found in the companion code
    repo: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).
    Just go to the folder for the chapter you are in and open the Jupyter notebook
    with the name that mentions exercise solutions.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所有练习的解决方案都可以在配套代码仓库中找到：[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)。只需进入你所在章节的文件夹，打开提及练习解决方案的Jupyter笔记本。
- en: The function *f* = `id` is slightly more subtle than the `zero` and `one` cases
    because *y* ⊕ *f*(*x*) cannot be simplified to not depend on *x*. As summarized
    in table 8.7, we need *U[f]* |*x*〉 |*y*〉 = |*x*〉 |*y* ⊕ *f*(*x*)〉 = |*x*〉 |*y*
    ⊕ *x*〉. That is to say, we need the action of the oracle on the input state (|*x*〉
    |*y*〉) to leave *x* alone and replace y with the exclusive OR of *x* and *y*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 *f* = `id` 比零和一的情况稍微复杂一些，因为 *y* ⊕ *f*(*x*) 不能简化为不依赖于 *x*。如表8.7总结所示，我们需要 *U[f]*
    |*x*〉 |*y*〉 = |*x*〉 |*y* ⊕ *f*(*x*)〉 = |*x*〉 |*y* ⊕ *x*〉。也就是说，我们需要预言机对输入状态（|*x*〉
    |*y*〉）的作用是保持 *x* 不变，并用 *x* 和 *y* 的异或替换 *y*。
- en: Another way to think of this output is to is recall that *y* ⊕ 1 = ¬*y*, so
    when *x* = 1, we need to flip *y*. This is precisely how we defined the controlled-NOT
    (CNOT) instruction in chapter 6, so we recognize that when *f* is `id`, *U[f]*
    can be implemented by applying a CNOT.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考这个输出的方式是回忆 *y* ⊕ 1 = ¬*y*，所以当 *x* = 1 时，我们需要翻转 *y*。这正是我们在第6章中定义的CNOT（控制非）指令的方式，因此我们认识到当
    *f* 是 `id` 时，*U[f]* 可以通过应用一个CNOT来实现。
- en: This leaves us with how to define the oracle for *f* = `not`. Just as the oracle
    for `id` flips the output (target) qubit when the input (control) qubit is in
    the |1〉 state, the same argument gives us that we need our oracle for `not` to
    flip the second qubit when the input qubit is in |0〉. The easiest way to do this
    is to first flip the input qubit with an `X` instruction, apply a `CNOT` instruction,
    and then undo the first flip with another `X`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这就剩下如何定义 *f* = `not` 的预言机了。正如 `id` 的预言机在输入（控制）量子比特处于 |1〉 状态时翻转输出（目标）量子比特一样，同样的论点告诉我们，我们需要我们的
    `not` 预言机在输入量子比特处于 |0〉 时翻转第二个量子比特。最简单的方法是首先使用 `X` 指令翻转输入量子比特，然后应用一个CNOT指令，最后使用另一个
    `X` 指令撤销第一次翻转。
- en: TIP If you want to see more about how you can construct the other oracles and
    use QuTiP to prove they do what you want, check out appendix D.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：如果你想知道更多关于如何构建其他预言机和如何使用QuTiP来证明它们能完成你想要的功能，请查看附录D。'
- en: To review the oracles we have learned to define, we collected all the work in
    this section in table 8.7.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾我们学习到的定义预言机的方法，我们将本节的所有工作收集在表8.7中。
- en: Table 8.7 Oracle outputs for each one-bit function *f*
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**表8.7** 每个一位函数 *f* 的预言机输出'
- en: '| Function name | Function | Output of oracle |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 函数名称 | 函数 | 预言机的输出 |'
- en: '| `zero` | *f*(*x*) = 0 | &#124;*x*〉&#124;*y* ⊕ 0〉 = &#124;*x*〉&#124;*y*〉 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `zero` | *f*(*x*) = 0 | &#124;*x*〉&#124;*y* ⊕ 0〉 = &#124;*x*〉&#124;*y*〉 |'
- en: '| `one` | *f*(*x*) = 1 | &#124;*x*〉&#124;*y* ⊕ 1〉 = &#124;*x*〉&#124;¬*y*〉 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `one` | *f*(*x*) = 1 | &#124;*x*〉&#124;*y* ⊕ 1〉 = &#124;*x*〉&#124;¬*y*〉 |'
- en: '| `id` | *f*(*x*) = *x* | &#124;*x*〉&#124;*y* ⊕ *x*〉 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `id` | *f*(*x*) = *x* | &#124;*x*〉&#124;*y* ⊕ *x*〉 |'
- en: '| `not` | *f*(*x*) = ¬*x* | &#124;*x*〉&#124;*y* ⊕ ¬*x*〉 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `not` | *f*(*x*) = ¬*x* | &#124;*x*〉&#124;*y* ⊕ ¬*x*〉 |'
- en: 'The uncompute trick: Turning functions into quantum oracles'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*uncompute trick*：将函数转换为量子或然子'
- en: As it stands, it may seem as though it takes a lot of work to design *U[f]*
    for each function *f*. Fortunately, there’s a nice trick that lets us build an
    oracle starting with a somewhat simpler requirement.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如此看来，似乎需要很多工作来为每个函数 *f* 设计 *U[f]*。幸运的是，有一个很好的技巧，它允许我们从相对简单的需求开始构建或然子。
- en: Recall that earlier, we attempted to define a reversible version of *f* by returning
    (*x*, *f*(*x*)) as output when given (*x*, 0) as input. Similarly, suppose that
    we are given a quantum operation *V[f]* that correctly transforms |*x*〉|0〉 to
    |*x*〉|*f*(*x*)〉. We can always make an oracle *U[f]* by using one additional qubit
    and calling *V[f]* twice using a technique called the *uncompute trick,* as shown
    in the following figure.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，之前我们尝试定义一个可逆版本的 *f*，通过返回 (*x*, *f*(*x*)) 作为输出，当给定 (*x*, 0) 作为输入时。同样地，假设我们给定一个量子操作
    *V[f]*，它能够正确地将 |*x*〉|0〉 转换为 |*x*〉|*f*(*x*)〉。我们可以通过使用一个额外的量子比特并使用称为 *uncompute
    trick* 的技术，将 *V[f]* 调用两次来始终创建一个或然子 *U[f]*，如图所示。
- en: '![](../Images/8-unnumb-1.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-unnumb-1.png)'
- en: Using the uncompute trick to turn an operation that only works when we add an
    extra |0〉 input qubit into an operation that can be used as an oracle
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *uncompute trick* 将仅在我们添加额外的 |0〉 输入量子比特时才工作的操作转换为可以作为一个或然子使用的操作
- en: While this doesn’t especially help in the case of Deutsch–Jozsa, it shows that
    the concept of an oracle is very general, as it’s often much easier to start with
    an operation of the form *V[f]*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在 Deutsch–Jozsa 的情况下并不特别有帮助，但它表明或然子的概念非常通用，因为它通常更容易从一个形式为 *V[f]* 的操作开始。
- en: Note The oracle construction also works for multiple-qubit functions. As a thought
    exercise, if we have a function *f*(*x*[0], *x*[1]) = *x*[0] AND *x*[1], how will
    the oracle *U[f]* transform an input state |*x*[0] *x*[1]〉? We’ll see in later
    chapters how to code this oracle.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：或然子构造也适用于多量子比特函数。作为一个思维练习，如果我们有一个函数 *f*(*x*[0], *x*[1]) = *x*[0] AND *x*[1]，那么或然子
    *U[f]* 将如何转换输入状态 |*x*[0] *x*[1]〉？我们将在后面的章节中看到如何编码这个或然子。
- en: We’ve thus used the oracle representation to solve the problem that functions
    like `zero` and `one` cannot be represented as rotations. With that dealt with,
    we can continue to write the rest of the algorithm that Nimue uses to challenge
    Merlin.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用了或然子表示来解决像 `zero` 和 `one` 这样的函数不能表示为旋转的问题。处理完这个问题后，我们可以继续编写 Nimue 用于挑战
    Merlin 的其余算法。
- en: 'Deep dive: Other ways to represent functions as oracles'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：将函数表示为或然子的其他方法
- en: 'This isn’t the only way we could have defined *U[f]*. Merlin could have flipped
    the sign of Nimue’s input *x* when *f*(*x*) is `one`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是定义 *U[f]* 的唯一方法。Merlin 可以在 *f*(*x*) 为 `one` 时翻转 Nimue 的输入 *x* 的符号：
- en: '![](../Images/equation_8-2.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/equation_8-2.png)'
- en: This turns out to be a more useful representation in some cases, such as in
    gradient descent algorithms. These algorithms are common in machine learning and
    minimize functions by searching along directions in which a function changes the
    fastest. For more information, see section 4.10 of *Grokking Deep Learning* by
    Andrew Trask (Manning, 2019).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示在某些情况下更有用，例如在梯度下降算法中。这些算法在机器学习中很常见，通过搜索函数变化最快的方向来最小化函数。更多信息，请参阅 Andrew Trask
    的《Grokking Deep Learning》（Manning，2019）第 4.10 节。
- en: Picking the right way for a particular application to represent classical information
    such as subroutine calls within a quantum algorithm is a part of the art of quantum
    programming. For now, we will use the definition of *oracle* introduced earlier.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定应用中选择正确的方法来表示经典信息，如量子算法中的子程序调用，是量子编程艺术的一部分。现在，我们将使用之前引入的 *oracle* 定义。
- en: 'With the oracle representation of *f* in hand, the first few steps of the Deutsch–Jozsa
    algorithm can be written in the same sort of pseudocode that we used to write
    `quicksort` earlier:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在手头有了 *f* 的或然子表示后，Deutsch–Jozsa 算法的最初几个步骤可以用我们之前用来编写 `quicksort` 的类似伪代码来编写：
- en: Prepare two qubits labeled `control` and `target` in the |0〉 ⊗ |0〉 state.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备两个标记为 `control` 和 `target` 的量子比特，处于 |0〉 ⊗ |0〉 状态。
- en: 'Apply operations to the `control` and `target` qubits to prepare the following
    state: |+〉 ⊗ |−〉.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `control` 和 `target` 量子比特应用操作，以准备以下状态：|+〉 ⊗ |−〉。
- en: Apply the oracle *U[f]* to the input state |+〉 ⊗ |−〉. Recall that *U[f]* |*x*〉
    |*y*〉 = |*x*〉 |*y* ⊕ *f*(*x*)〉.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将或然子 *U[f]* 应用到输入状态 |+〉 ⊗ |−〉。回想一下，*U[f]* |*x*〉 |*y*〉 = |*x*〉 |*y* ⊕ *f*(*x*)〉。
- en: Measure the `control` qubit in the *X*-basis. If we observe a 0, then the function
    is constant; otherwise, the function is balanced.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在X基态测量`control`量子比特。如果我们观察到0，那么函数是常量的；否则，函数是平衡的。
- en: Tip Measuring a qubit in the *X*-basis always returns a 0 or 1, just like if
    we measured in the *Z*-basis. Recall from chapter 3 that if the state of the qubit
    is |+〉, we always get a 0 when we measure in the *X*-basis, while we always get
    a 1 if the qubit is in |−〉.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士测量基态的量子比特总是返回0或1，就像我们在Z基态测量一样。回想第3章，如果量子比特的状态是|+〉，我们在X基态测量时总是得到0，而如果量子比特是|−〉，我们总是得到1。
- en: Figure 8.9 illustrates these steps. We’ll see at the end of the chapter *why*
    this algorithm works, but let’s jump in and start programming it. To do so, we’ll
    use the Q# language provided by the Quantum Development Kit since this makes it
    much easier to see the structure of a quantum algorithm from its source code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9展示了这些步骤。我们将在本章末尾看到这个算法为什么**能**工作，但现在让我们跳进去开始编程。为了做到这一点，我们将使用量子开发工具包提供的Q#语言，因为这使得从源代码中看到量子算法的结构变得容易得多。
- en: '![](../Images/8-9.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-9.png)'
- en: Figure 8.9 Steps in the Deutsch–Jozsa algorithm. We start by preparing the |+−〉
    state, then query the oracle (that is, we ask Merlin the question), and then measure
    the control qubit to learn whether the oracle represents a constant or balanced
    function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 Deutsch–Jozsa算法的步骤。我们首先制备|+−〉状态，然后查询或acles（即我们向Merlin提问），然后测量控制量子比特以了解或acles代表的是常量函数还是平衡函数。
- en: 8.4 Simulating the Deutsch–Jozsa algorithm in Q#
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 在Q#中模拟Deutsch–Jozsa算法
- en: In chapter 7, we tried passing operations as arguments in Q# programs. We can
    use the same approach of passing operations as inputs to oracles to help predict
    how Nimue’s challenge will turn out. To do so, recall that we can consider four
    possible functions for this problem, each representing a possible strategy that
    Merlin could use (see table 8.8).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章中，我们尝试在Q#程序中将操作作为参数传递。我们可以使用相同的方法，将操作作为或acles的输入来帮助预测Nimue的挑战结果。为此，回想一下，我们可以考虑这个问题的四种可能的函数，每个函数代表Merlin可能使用的策略（见表8.8）。
- en: Table 8.8 Representing one-bit functions as two-qubit oracles
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.8 将单比特函数表示为双比特或acles
- en: '| Function name | Function | Output of oracle | Q# operation |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 函数名称 | 函数 | 或acles的输出 | Q#操作 |'
- en: '| `zero` | *f*(*x*) = 0 | &#124;*x*〉&#124;*y* ⊕ 0〉 = &#124;*x*〉&#124;*y*〉 |
    `NoOp(control, target);` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `zero` | *f*(*x*) = 0 | &#124;*x*〉&#124;*y* ⊕ 0〉 = &#124;*x*〉&#124;*y*〉 |
    `NoOp(control, target);` |'
- en: '| `one` | *f*(*x*) = 1 | &#124;*x*〉&#124;*y* ⊕ 1〉 = &#124;*x*〉&#124;¬*y*〉 |
    `X(target);` |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `one` | *f*(*x*) = 1 | &#124;*x*〉&#124;*y* ⊕ 1〉 = &#124;*x*〉&#124;¬*y*〉 |
    `X(target);` |'
- en: '| `id` | *f*(*x*) = *x* | &#124;*x*〉&#124;*y* ⊕ *x*〉 | `CNOT(control, target)`
    |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `id` | *f*(*x*) = *x* | &#124;*x*〉&#124;*y* ⊕ *x*〉 | `CNOT(control, target)`
    |'
- en: '| `not` | *f*(*x*) = ¬*x* | &#124;*x*〉&#124;*y* ⊕ ¬*x*〉 | `X(control); CNOT(control,
    target); X(control);` |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `not` | *f*(*x*) = ¬*x* | &#124;*x*〉&#124;*y* ⊕ ¬*x*〉 | `X(control); CNOT(control,
    target); X(control);` |'
- en: If we represent each function *f*(*x*) by an oracle (quantum operation) that
    maps |*x*〉|*y*〉 to |*x*〉|*y* ⊕ *f*(*x*)〉, then we can identify each of the functions
    `zero`, `one`, `id`, and `not` from figure 8.3.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用将|*x*〉|*y*〉映射到|*x*〉|*y* ⊕ *f*(*x*)〉的量子操作（或acles）来表示每个函数*f*(*x*)，那么我们可以从图8.3中识别出每个函数`zero`、`one`、`id`和`not`。
- en: 'Each of the four oracles translates immediately into Q#:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 四个或acles可以直接翻译成Q#：
- en: '[PRE1]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Can’t we just look at the source code?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就不能直接查看源代码吗？
- en: In Oracles.qs, we wrote the source code for each of the four single-qubit oracles
    `ApplyZeroOracle`, `ApplyOneOracle`, `ApplyIdOracle`, and `ApplyNotOracle`. Looking
    at that source code, we can tell whether each is constant or balanced without
    having to call it, so why should we worry about the Deutsch–Jozsa algorithm? Thinking
    from Nimue’s perspective, she doesn’t necessarily have the source code that Merlin
    uses to apply operations to her qubits. Even if she does, Merlin’s ways are inscrutable,
    so she may not be able to easily predict what Merlin does even given the source
    code he uses.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在Oracles.qs中，我们为四个单量子比特或acles `ApplyZeroOracle`、`ApplyOneOracle`、`ApplyIdOracle`和`ApplyNotOracle`编写了源代码。查看这些源代码，我们可以判断每个是常量还是平衡的，而无需调用它，那么我们为什么要担心Deutsch–Jozsa算法呢？从Nimue的角度思考，她不一定有Merlin用来对她量子比特执行操作的源代码。即使她有，Merlin的方法是难以理解的，所以她可能无法轻易预测Merlin即使给出了他使用的源代码会做什么。
- en: Practically speaking, while it’s hard to obfuscate a two-qubit oracle all that
    much, the Deutsch–Jozsa algorithm demonstrates a technique that is useful more
    generally. For example, we might have access to the source code for an operation,
    but it is a mathematically or computationally difficult problem to extract the
    answer to a question about that operation. All cryptographic hash functions have
    this property by design, whether they’re used to ensure that a file has been downloaded
    correctly, to check whether an application has been signed by a developer, or
    as part of growing a blockchain through mining for collisions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际角度来说，虽然很难对双量子比特的预言机进行太多模糊处理，但Deutsch–Jozsa算法展示了一种更通用的技术。例如，我们可能能够访问到一个操作的源代码，但提取关于该操作的问题答案可能是一个数学上或计算上困难的问题。所有加密哈希函数都通过设计具有这种属性，无论是用来确保文件正确下载，检查应用是否由开发者签名，还是作为通过挖掘冲突来扩展区块链的一部分。
- en: In chapter 10, we’ll see an example that uses techniques like those developed
    in the Deutsch–Jozsa algorithm to ask questions about such functions more quickly.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10章中，我们将看到一个使用类似于在Deutsch–Jozsa算法中开发的技术来更快地询问此类函数的例子。
- en: With these oracles implemented in Q#, we can write the entire Deutsch–Jozsa
    algorithm (as well as Nimue’s strategy for Kingmaker)! See figure 8.10 for a refresher
    on the steps of Deutsch-Jozsa.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在Q#中实现了这些预言机之后，我们可以编写整个Deutsch–Jozsa算法（以及Nimue的Kingmaker策略）！参见图8.10以刷新对Deutsch-Jozsa步骤的了解。
- en: '![](../Images/8-10.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/8-10.png)'
- en: Figure 8.10 Steps of the Deutsch–Jozsa algorithm. We start by preparing the
    |+−〉 state, then query the oracle (aka ask Merlin the question), and then measure
    the control qubit.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 Deutsch–Jozsa算法的步骤。我们首先准备|+−〉状态，然后查询预言机（即向Merlin提问），然后测量控制量子比特。
- en: 'Listing 8.2 Algorithm.qs: Q# operation to run Deutsch–Jozsa'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2 Algorithm.qs：运行Deutsch–Jozsa的Q#操作
- en: '[PRE2]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Asks the target machine to give us two qubits, control and target, each starting
    in the |0〉 state
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 要求目标机器给我们两个量子比特，控制量子比特和目标量子比特，每个都从|0〉状态开始
- en: ❷ Prepares the input state |+−〉 = (|00〉 − |01〉 + |10〉 − |11〉) / 2 on control
    and target, as shown in step 2 of figure 8.10
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在控制和目标量子比特上准备输入状态|+−〉 = (|00〉 − |01〉 + |10〉 − |11〉) / 2，如图8.10步骤2所示
- en: ❸ Calls the oracle given as the input argument. Note that the oracle is called
    only once!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用作为输入参数给出的预言机。注意，预言机只调用一次！
- en: ❹ We know the target qubit is still in |−〉, so we can undo the X(target); H(target);
    sequence of operations to reset the target qubit.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们知道目标量子比特仍然在|−〉状态，因此我们可以撤销X(target); H(target);操作序列以重置目标量子比特。
- en: ❺ Measures whether the control qubit is in |+〉 or |−〉, corresponding to Zero
    or One results in the *X*-basis
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 测量控制量子比特是在|+〉还是|−〉状态，对应于**X**-基下的零或一的结果
- en: Like the `MResetZ` operation provided by the Q# standard libraries, the `MResetX`
    operation performs the desired *X*-basis measurement and resets the measured qubit
    to the |0〉 state. Now we want to make sure our implementation is good, so let’s
    test it!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与Q#标准库提供的`MResetZ`操作一样，`MResetX`操作执行所需的**X**-基测量并将被测量的量子比特重置到|0〉状态。现在我们想要确保我们的实现是好的，所以让我们来测试它！
- en: Measurement results in Q#
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Q#中的测量结果
- en: We’ve now seen both the `MResetX` and `MResetZ` operations in Q#, which measure
    and reset a qubit in the *X**-* and *Z*-bases, respectively. Both of these operations
    return a `Result` value, which seems a little confusing at first. After all, an
    *X*-basis measurement tells us whether we were in the |+〉 or |−〉 state, so why
    does Q# use the labels `Zero` and `One`?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在Q#中看到了`MResetX`和`MResetZ`操作，它们分别测量和重置量子比特在**X**-和**Z**-基下的状态。这两个操作都返回一个`Result`值，一开始可能会有些令人困惑。毕竟，**X**-基测量告诉我们我们是在|+〉或|−〉状态，那么为什么Q#使用`Zero`和`One`这样的标签呢？
- en: '| Result value | *X*-basis | *Z*-basis |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 结果值 | **X**-基 | **Z**-基 |'
- en: '| Zero | 〈+&#124; | 〈0&#124; |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 零 | 〈+| | 〈0| |'
- en: '| One | 〈–&#124; | 〈1&#124; |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 一 | 〈–| | 〈1| |'
- en: We’ll see more about this later, but the short version is that a value of type
    `Result` tells us how many phases of (–1) are applied to a state by different
    instructions. For example, *Z*|1〉 = –|1〉 = (–1)¹ |1〉, while *X*|–〉 = (–1)¹ |−〉.
    Since in both cases we raise (–1) to the power of 1, |1〉 and |−〉 are assigned
    to the `One` result when we measure in the *Z**-* and *X*-bases, respectively.
    Similarly, since *Z*|0〉 = (–1)⁰|0〉, we assign |0〉 to the `Zero` result when we
    measure *Z*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后了解更多关于这一点，但简而言之，类型为`Result`的值告诉我们不同的指令对一个状态应用了(-1)的多少个相位。例如，*Z*|1〉 = –|1〉
    = (–1)¹ |1〉，而*X*|–〉 = (–1)¹ |−〉。由于在这两种情况下，我们都是将(-1)提升到1次幂，当我们分别测量*Z**-*和*X*-基时，|1〉和|−〉被分配到`One`结果。同样，由于*Z*|0〉
    = (–1)⁰|0〉，当我们测量*Z*时，我们将|0〉分配到`Zero`结果。
- en: We said earlier that Nimue would like to learn as little as she can about humankind’s
    affairs. So, she only asks Merlin to do something with her qubits once, where
    we call `oracle(control, target)`. Nimue gets only one classical bit of information
    from the call to `MResetX`, which isn’t enough for her to tell the difference
    between the `id` strategy (Merlin selects Arthur to mentor as king) and the `not`
    strategy (Merlin selects Mordred to mentor).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，尼姆乌希望尽可能少地了解人类事务。因此，她只让梅林对她的一次量子比特进行操作，我们称之为`oracle(control, target)`。尼姆乌从`MResetX`的调用中只得到一个经典比特的信息，这不足以让她区分`id`策略（梅林选择亚瑟作为国王的导师）和`not`策略（梅林选择莫德雷德作为导师）。
- en: To make sure she can still learn what she actually cares about—whether Merlin’s
    strategy is constant or balanced—we can use the `Fact` function provided with
    the Q# standard libraries to test that our implementation works. `Fact` takes
    two Boolean variables as the first two arguments, checks to see if they are equal,
    and, if they aren’t, issues a message.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保她仍然可以学习她真正关心的内容——梅林的战略是恒定还是平衡——我们可以使用Q#标准库提供的`Fact`函数来测试我们的实现是否正常工作。`Fact`函数接受两个布尔变量作为前两个参数，检查它们是否相等，如果不相等，则发出一条消息。
- en: Tip Later, we’ll see how to use these assertions to write unit tests for quantum
    libraries.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 提示稍后，我们将了解如何使用这些断言为量子库编写单元测试。
- en: The first thing we do is pass the `ApplyZeroOracle` operation that we wrote
    earlier as the oracle for the `zero` function. Since `zero` isn’t a balanced function,
    we expect `CheckIfOracleIsBalanced(ApplyZeroOracle)` to return `false` as its
    output; this expectation can be checked using the `Fact` function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的是将我们之前编写的`ApplyZeroOracle`操作作为`zero`函数的或然性。由于`zero`不是一个平衡函数，我们预计`CheckIfOracleIsBalanced(ApplyZeroOracle)`将返回`false`作为其输出；这个预期可以使用`Fact`函数来检查。
- en: 'Listing 8.3 Algorithm.qs: Q# operation testing Deutsch–Jozsa'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3 Algorithm.qs：Q#操作测试Deutsch–Jozsa
- en: '[PRE3]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Runs the Deutsch–Jozsa algorithm for the case in which Merlin uses the zero
    strategy
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 运行梅林使用零策略的情况下的Deutsch–Jozsa算法
- en: ❷ Does exactly the same thing for the one strategy, this time calling CheckIfOracleIsBalanced(ApplyOneOracle)
    instead
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对单一策略执行完全相同的事情，这次调用CheckIfOracleIsBalanced(ApplyOneOracle)而不是
- en: ❸ If all four assertions passed, then we can be sure that our program for the
    Deutsch–Jozsa algorithm works regardless of which strategy Merlin uses.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果所有四个断言都通过了，那么我们可以确信，无论梅林使用哪种策略，我们的Deutsch–Jozsa算法的程序都是有效的。
- en: 'If we run this using the `%simulate` magic command, we can confirm that by
    using the Deutsch–Jozsa algorithm, Nimue can learn exactly what she wants to learn
    about Merlin’s strategy:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`%simulate`魔法命令运行此程序，我们可以通过使用Deutsch–Jozsa算法来确认尼姆乌可以学习她想要了解的梅林战略的详细信息：
- en: '[PRE4]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 8.5 Reflecting on quantum algorithm techniques
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 反思量子算法技术
- en: 'Phew—we’ve taken a couple of pretty big steps here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 呼——我们在这一步迈出了相当大的步伐：
- en: We’ve used classical reversible functions to model Merlin’s strategy in a way
    that we can write it as a quantum oracle.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经使用经典可逆函数来模拟梅林的战略，以便我们可以将其编写为量子或然性。
- en: We’ve used Q# and the Quantum Development Kit to implement the Deutsch–Jozsa
    algorithm and test that we can learn Merlin’s strategy with a single oracle call.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经使用Q#和量子开发工具包实现了Deutsch–Jozsa算法，并测试了我们可以通过一次或然性调用来学习梅林的战略。
- en: At this point, it’s helpful to reflect on what we learned from taking a splash
    in Nimue’s quantum lake, as the techniques we used in this chapter will be helpful
    throughout the rest of the book.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，回顾我们在尼姆乌的量子湖中游泳时所学到的东西是有帮助的，因为我们在本章中使用的技巧将在本书的其余部分都有所帮助。
- en: '8.5.1 Shoes and socks: Applying and undoing quantum operations'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.1 鞋子和袜子：应用和撤销量子操作
- en: The first pattern that’s helpful to reflect on is one we might have noticed
    in Algorithm.qs. Let’s take another look at the order in which operations are
    applied to the `target` qubit.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于反思的第一个模式可能是在`Algorithm.qs`中注意到的。让我们再次看看操作应用于`target`量子比特的顺序。
- en: Listing 8.4 Instructions from Deutsch–Jozsa for the `target`
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 来自Deutsch–Jozsa的`target`指令
- en: '[PRE5]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One way to think of this sequence is that the `X(target); H(target);` instructions
    prepare `target` in the |−〉 state, while the `H(target); X(target);` instructions
    “unprepare” |−〉, returning `target` back to the |0〉 state. We have to reverse
    the order due to what’s often called the *shoes and socks* principle. If we want
    to put on shoes and socks, we’ll have better results if we put on our socks first;
    but if we want to take them off, we need to take our shoes off first. See figure
    8.11 for an illustration of this procedure.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将这个序列视为`X(target); H(target);`指令将`target`准备在|−〉状态，而`H(target); X(target);`指令“取消准备”|−〉，将`target`返回到|0〉状态。我们必须反转顺序，因为通常所说的*鞋子和袜子*原则。如果我们想穿上鞋子和袜子，我们最好先穿上袜子；但如果我们想脱掉它们，我们需要先脱掉鞋子。参见图8.11说明此过程。
- en: '![](../Images/8-11.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/8-11.png)'
- en: Figure 8.11 We can’t take off our socks before our shoes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 在脱鞋之前我们不能脱袜子。
- en: The Q# language makes it easier to do shoes-and-socks kinds of transformations
    of our code using a feature called *functors*. Functors allow us to easily describe
    new variants of an operation we have already defined. Let’s jump right into an
    example and introduce a new operation, `PrepareTargetQubit`, that encapsulates
    the `X(target); H(target);` sequence.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Q#语言通过一个称为*函子*的功能使我们的代码进行鞋子和袜子之类的变换变得更容易。函子允许我们轻松地描述已经定义的操作的新变体。让我们直接进入一个示例，并介绍一个新的操作`PrepareTargetQubit`，它封装了`X(target);
    H(target);`序列。
- en: Listing 8.5 The state preparation from listing 8.4
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 从列表8.4的状态准备
- en: '[PRE6]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ By writing “is Adj” as a part of the signature, we tell the Q# compiler to
    automatically compute the inverse operation—that is, the adjoint—of this operation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过将“is Adj”作为签名的一部分来编写，我们告诉Q#编译器自动计算此操作的逆操作——即伴随——。
- en: We can then call the inverse operation generated by the compiler using `Adjoint`,
    one of the two functors provided by Q# (we’ll see the other one in chapter 9).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用编译器生成的逆操作，即Q#提供的两个函子之一`Adjoint`（我们将在第9章看到另一个），来调用`Adjoint`。
- en: Listing 8.6 Using the `Adjoint` keyword to apply instructions
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.6 使用`Adjoint`关键字应用指令
- en: '[PRE7]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Adjoint PrepareTargetQubit applies the Adjoint functor to PrepareTargetQubit,
    giving back an operation that “undoes” PrepareTargetQubit. Following shoes-and-socks
    thinking, this new operation works by first calling Adjoint H(target); and then
    Adjoint X(target);.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `Adjoint PrepareTargetQubit`将`Adjoint`函子应用于`PrepareTargetQubit`，从而得到一个“撤销”`PrepareTargetQubit`的操作。按照鞋子和袜子思维，这个新操作首先调用`Adjoint
    H(target)`；然后调用`Adjoint X(target)`。
- en: Self-adjoint operations
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 自伴操作
- en: In this case, `X` and `Adjoint X` are the same operation, since flipping a bit
    and then flipping it again always gets us back to where we started. Put differently,
    `X` undoes `X`. Similarly, `Adjoint H` is the same as `H`, so the previous snippet
    gives us the sequence `H(target); X(target);`. We say that the instructions `X`
    and `H` are *self-adjoint*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`X`和`Adjoint X`是相同的操作，因为翻转一个比特然后再翻转它总是让我们回到起点。换句话说，`X`撤销了`X`。同样，`Adjoint
    H`与`H`相同，所以前面的代码片段给出了`H(target); X(target);`的顺序。我们说指令`X`和`H`是`self-adjoint`的。
- en: Not all operations are their own adjoints, though! For instance, `Adjoint Rz(theta,
    _ )` is the same operation as `Rz(-theta, _ )`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是所有操作都是其自身的伴随，但！例如，`Adjoint Rz(theta, _)`与`Rz(-theta, _)`是相同的操作。
- en: In more practical terms, the `Adjoint` functor on the operation *U* is the same
    as the operation that reverses or undoes the effects of *U*. The name *adjoint*
    refers to the conjugate transpose *U*^+ of a unitary matrix *U*. In words, *U*^+
    is called the *adjoint* of *U*. The `Adjoint` keyword in Q# guarantees that if
    an operation `U` is described by the unitary *U*, then if `Adjoint U` exists,
    it is described by *U*^+.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在更实际的意义上，操作`U`上的`Adjoint`函子与反转或撤销`U`效果的运算相同。名称`adjoint`指的是单位矩阵`U`的共轭转置`U^+`。换句话说，`U^+`被称为`U`的`adjoint`。Q#中的`Adjoint`关键字保证，如果操作`U`由单位矩阵`U`描述，那么如果存在`Adjoint
    U`，它将由`U^+`描述。
- en: The pattern of performing an instruction is so commonly used that the Q# standard
    libraries provide the `ApplyWith` operation to express this pattern of doing and
    then undoing an operation.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 执行指令的模式如此常用，以至于 Q# 标准库提供了 `ApplyWith` 操作来表达这种先执行后撤销操作的模式。
- en: Note The `ApplyWith` operation is provided by the `Microsoft.Quantum .Canon`
    namespace in the Q# standard library. Much like the standard library in other
    languages, the Q# standard library provides many of the basic tools you’ll need
    for writing programs in Q#. As you go through the rest of the book, you’ll see
    lots of ways the Q# standard library can help make your life as a quantum developer
    easier.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`ApplyWith` 操作由 `Microsoft.Quantum.Canon` 命名空间在 Q# 标准库中提供。与其它语言的库类似，Q# 标准库提供了许多编写
    Q# 程序所需的基本工具。随着你继续阅读本书，你会看到 Q# 标准库如何帮助使量子开发者的生活变得更轻松。
- en: Using `ApplyWith` and partial application, we can rewrite the `CheckIfOracleIsBalanced`
    operation in a compact way.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `ApplyWith` 和部分应用，我们可以以紧凑的方式重写 `CheckIfOracleIsBalanced` 操作。
- en: Listing 8.7 `ApplyWith` and partial application help with shoes-and-socks ordering
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 `ApplyWith` 和部分应用帮助实现鞋子与袜子排序
- en: '[PRE8]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `ApplyWith` operation in this sample automatically applies the adjoint of
    `PrepareTargetQubit` after `oracle(control, _ )` is done. Note that `_` is used
    to partially apply the `oracle` to the `control` qubit.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`ApplyWith` 操作在 `oracle(control, _ )` 完成后自动应用 `PrepareTargetQubit` 的伴随算符。注意
    `_` 被用来部分应用 `oracle` 到控制比特上。
- en: Let’s expand listing 8.7 step by step to see how it works. The call to `ApplyWith`
    applies its first argument, then applies its second argument, then applies the
    adjoint of its first argument to the qubit supplied in the last argument.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步展开列表 8.7，看看它是如何工作的。对 `ApplyWith` 的调用首先应用其第一个参数，然后应用其第二个参数，最后将第一个参数的伴随算符应用到最后一个参数提供的量子比特上。
- en: Listing 8.8 Expanding `ApplyWith` in listing 8.7
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 在列表 8.7 中展开 `ApplyWith`
- en: '[PRE9]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The partial application on the third line can then be replaced by substituting
    `target` for the `_`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行的部分应用可以通过将 `target` 替换为 `_` 来替换。
- en: Listing 8.9 Resolving partial application in listing 8.8
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 解决列表 8.8 中的部分应用
- en: '[PRE10]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using operations like `ApplyWith` helps reuse common patterns in quantum programming,
    particularly to make sure we don’t forget to take an `Adjoint` in a large quantum
    program.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 `ApplyWith` 这样的操作有助于在量子编程中重用常见的模式，尤其是在确保我们不会在大型量子程序中忘记取一个 `Adjoint`。
- en: Q# also provides another way to represent the shoes-and-socks pattern using
    blocks of statements instead of passing around operations. For example, we could
    write listing 8.7 using the `within` and `apply` keywords instead, as shown next.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Q# 还提供了另一种使用语句块而不是传递操作来表示鞋子与袜子模式的方法。例如，我们可以使用 `within` 和 `apply` 关键字来编写列表 8.7，如下所示。
- en: Listing 8.10 Using `within` and `apply` for shoes-and-socks ordering
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 使用 `within` 和 `apply` 进行鞋子与袜子排序
- en: '[PRE11]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Both forms can be useful in different contexts, so feel free to use whichever
    works best for you!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 两种形式在不同的上下文中都可能很有用，所以请随意使用最适合您的方法！
- en: 8.5.2 Using Hadamard instructions to flip control and target
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.2 使用 Hadamard 指令翻转控制比特和目标比特
- en: 'We can use shoes-and-socks kinds of thinking from the previous section to change
    which qubits play the roles of control and target in instructions like `CNOT`.
    To understand how this works, it’s important to keep in mind that quantum instructions
    transform the entire state of the registers they act on. In cases like the Deutsch–Jozsa
    algorithm, the control qubit can be affected by applying gates to the control
    and target qubits together—not just the target qubit. This is an example of a
    more general pattern: the control and target of a `CNOT` operation swap roles
    when we apply a `CNOT` instruction in the *X*-basis instead of the *Z -* (computational)
    basis.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用上一节中的鞋子与袜子般的思维方式来改变在 `CNOT` 等指令中扮演控制比特和目标比特角色的量子比特。为了理解这是如何工作的，重要的是要记住量子指令会转换它们所作用的寄存器的整个状态。在像
    Deutsch–Jozsa 算法这样的情况下，控制比特可以通过对控制比特和目标比特同时应用门来受到影响——而不仅仅是目标比特。这是一个更一般模式的例子：当我们用
    *X*-基而不是 *Z*-（计算）基应用 `CNOT` 指令时，`CNOT` 操作的控制比特和目标比特会交换角色。
- en: To see this, let’s look at the unitary operator (the quantum analogue to classical
    truth tables) for what happens if we use `H` instructions to transform to the
    *X*-basis, apply a `CNOT` instruction, and then use more `H` instructions to go
    back to the *z* -basis.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这一点，让我们看看如果使用`H`指令转换到*X*-基，应用`CNOT`指令，然后使用更多的`H`指令回到*z* -基会发生什么单位算子（量子真值表的经典对应物）。
- en: Listing 8.11 Checking that `H` flips the control and target of `CNOT`
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.11 检查`H`是否翻转了`CNOT`的控制和目标
- en: '[PRE12]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ It’s helpful to define a shorthand for the unitary operator *H* ⊗ *H* that
    simulates the sequence of instructions H(control); H(target);.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个简写来表示模拟H(control); H(target);序列的单位算子*H* ⊗ *H*是有帮助的。
- en: ❷ Looking at the unitary operator *H* ⊗ *H*, we see that |00〉 is transformed
    to (|00〉 + |01〉 + |10〉 + |11〉) / 2, a uniform superposition over all four computational
    basis states.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 观察单位算子*H* ⊗ *H*，我们看到|00〉被转换成(|00〉 + |01〉 + |10〉 + |11〉) / 2，这是对所有四个计算基状态的平均叠加。
- en: ❸ Gives the unitary operator representing H(control); H(target); CNOT(control,
    target); H(control); H(target);. We can think of this sequence of instructions
    as applying a CNOT in the *X*-basis instead of the *Z*-basis.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 给出表示H(control); H(target); CNOT(control, target); H(control); H(target);的单位算子。我们可以将这个指令序列视为在*Z*-基而不是*X*-基上应用CNOT。
- en: ❹ The unitary operator for this sequence looks a bit like CNOT, but with some
    of the rows flipped around. What happened?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 这个序列的单位算子看起来有点像CNOT，但有一些行被翻转了。发生了什么？
- en: ❺ To try to figure out what applying *H* instructions to each qubit did to the
    CNOT instruction, let’s look at the unitary operator for CNOT(target, control).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 为了尝试弄清楚将*H*指令应用于每个量子比特对`CNOT`指令做了什么，让我们看看`CNOT(target, control)`的单位算子。
- en: ❻ Reversing the role of the control and target qubits in a call to the CNOT
    instruction gives us exactly the same unitary operator as using *H* instructions
    to apply a CNOT instruction in the *X*-basis.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在调用CNOT指令时翻转控制量子比特和目标量子比特的角色，将给我们与使用*H*指令在*X*-基上应用CNOT指令时完全相同的单位算子。
- en: Figure 8.12 provides a visual representation of the Python code we just ran.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12展示了我们刚刚运行的Python代码的视觉表示。
- en: '![](../Images/8-12.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-12.png)'
- en: Figure 8.12 Changing which qubits are the control and target of a CNOT instruction
    using Hadamard instructions. By applying Hadamards on each qubit, and both before
    and after the CNOT, we can flip the roles of the control and target qubits.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 使用Hadamard指令改变CNOT指令的控制和目标量子比特。通过在每个量子比特上应用Hadamard，并在CNOT之前和之后应用，我们可以翻转控制量子比特和目标量子比特的角色。
- en: From the previous calculation, we can conclude that `CNOT(target, control)`
    does precisely the same thing as `H(control); H(target); CNOT(control, target);
    H(control); H(target);`. In the same way that `H` flips the role of the *X-* and
    *Z*-bases, `H` instructions can flip between using a qubit as a control or a target.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的计算中，我们可以得出结论，`CNOT(target, control)`与`H(control); H(target); CNOT(control,
    target); H(control); H(target);`完全相同。与`H`翻转了*X-*和*Z*-基的角色一样，`H`指令可以在使用量子比特作为控制或目标之间翻转。
- en: '8.6 Phase kickback: The key to our success'
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 相位回弹：我们成功的关键
- en: 'With these techniques in mind, we’re now equipped to explore what makes the
    Deutsch–Jozsa algorithm do its thing: a quantum programming technique called *phase
    kickback*. This technique lets us write the `CheckIfOracleIsBalanced` operation
    to work for several different oracles while revealing only the one bit we want
    to know (whether Merlin was acting as a good mentor).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些技术，我们现在可以探索德-约萨算法是如何工作的：一种称为*相位回弹*的量子编程技术。这项技术允许我们编写`CheckIfOracleIsBalanced`操作，使其适用于几个不同的预言机，同时只揭示我们想要知道的一个比特（是否梅林扮演了一个好的导师）。
- en: To see how the Deutsch–Jozsa algorithm uses phase kickback to work in *general*,
    let’s go back to our three ways of thinking and use math to predict what happens
    when we call any oracle. Recall that we defined the oracle *U[f]* that we constructed
    from each classical function *f* such that, for all classical bits *x* and *y*,
    *U[f]* |*xy*〉 = |*x*〉|*f*(*x*) ⊕ *y*〉.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解德-约萨算法如何使用相位回弹在*一般*情况下工作，让我们回到我们的三种思考方式，并使用数学来预测当我们调用任何预言机时会发生什么。回想一下，我们定义了预言机*U[f]*，它是从每个经典函数*f*构建的，使得对于所有经典比特*x*和*y*，*U[f]*
    |*xy*〉 = |*x*〉|*f*(*x*) ⊕ *y*〉。
- en: Tip Here we use *x* and *y* to represent classical bits that label two-qubit
    states. This is another example of using the computational basis to reason about
    how quantum programs behave.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：在这里，我们使用*x*和*y*来表示经典比特，这些比特标记了两个量子比特的状态。这是使用计算基来推理量子程序行为的另一个例子。
- en: Let’s begin the same way we did in our QuTiP programs by expanding the input
    state |+−〉 = |+〉 ⊗ |−〉 in the computational basis. Starting by expanding the state
    of the control qubit, we have that |+−〉 = |+〉 ⊗ |−〉 = (|0〉 + |1〉) / √2 ⊗ |−〉 =
    (|0−〉 + |1−〉) / √2. As before, we can check our math using QuTiP.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以与我们在QuTiP程序中相同的方式开始，将输入状态|+−〉 = |+〉 ⊗ |−〉在计算基中展开。首先展开控制量子比特的状态，我们有|+−〉 =
    |+〉 ⊗ |−〉 = (|0〉 + |1〉) / √2 ⊗ |−〉 = (|0−〉 + |1−〉) / √2。像之前一样，我们可以使用QuTiP来检查我们的数学。
- en: Listing 8.12 Using QuTiP to check (|0−〉 + |1−〉) / √2 = |+−〉
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.12 使用QuTiP检查(|0−〉 + |1−〉) / √2 = |+−〉
- en: '[PRE13]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Starts with useful shorthand notation
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从有用的缩写符号开始
- en: ❷ Both vectors are the same, telling us that (|0−〉 + |1−〉) / √2 is another way
    of writing |+−〉.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 两个向量相同，这告诉我们(|0−〉 + |1−〉) / √2是|+−〉的另一种写法。
- en: Next, as we saw in chapter 2, we can use linearity to predict how *U[f]* transforms
    this input state.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，正如我们在第2章中看到的，我们可以使用线性来预测*U[f]*如何转换这个输入状态。
- en: The matrix revisited
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵回顾
- en: We implicitly used linearity earlier in this section when we used matrices to
    model how the Deutsch–Jozsa algorithm works. As described in chapter 2, matrices
    are one way of writing linear functions.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们隐式地使用了线性，当我们使用矩阵来模拟Deutsch–Jozsa算法的工作原理时。正如第2章所述，矩阵是线性函数的一种写法。
- en: Since *U[f]* is a unitary matrix, we know that for *any* states |*Ψ*〉 and |*ϕ*〉
    and for *any* numbers *α* and *β*, *U[f]* (*α*|*Ψ*〉 + *β*|*ϕ*〉) = *α* *U[f]* |*Ψ*〉
    + *β* *U[f]* |*ϕ*〉]. Using this property with the computational basis, we have
    that in the same way |+−〉 and (|0−〉 + |1−〉) / √2 are the same state, *U[f]* |+−〉
    and *U[f]* (|0−〉 + |1−〉) / √2 are the also same state.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*U[f]*是一个幺正矩阵，我们知道对于任何状态|*Ψ*〉和|*ϕ*〉以及任何数*α*和*β*，*U[f]* (*α*|*Ψ*〉 + *β*|*ϕ*〉)
    = *α* *U[f]* |*Ψ*〉 + *β* *U[f]* |*ϕ*〉]。使用这个性质与计算基一起，我们有|+−〉和(|0−〉 + |1−〉) / √2是相同的状态，同样*U[f]*
    |+−〉和*U[f]* (|0−〉 + |1−〉) / √2也是相同的状态。
- en: Tip Using our shorthand for multi-qubit states, |+−〉 = |+〉 ⊗ |−〉, |0−〉 = |0〉
    ⊗ |−〉, and |1−〉 = |1〉 ⊗ |−〉.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士使用我们的多量子比特状态缩写，|+−〉 = |+〉 ⊗ |−〉，|0−〉 = |0〉 ⊗ |−〉，和|1−〉 = |1〉 ⊗ |−〉。
- en: Figure 8.13 gives a visual depiction of linearity.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13给出了线性的视觉表示。
- en: '![](../Images/8-13.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-13.png)'
- en: Figure 8.13 Applying linearity to understand how our oracle transforms the input
    state
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 应用线性来理解我们的预言机如何转换输入状态
- en: Written like this, it’s not immediately clear what advantage we’ve obtained
    by applying *U[f]* to |0−〉 and |1−〉. Let’s look at how the oracle operation applies
    to the first term by factoring out the control (first) qubit to consider the effect
    on the target qubit.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这样写，我们并不立即清楚通过将*U[f]*应用于|0−〉和|1−〉我们获得了什么优势。让我们通过提取控制（第一个）量子比特来考虑对目标量子比特的影响，来看看预言机操作是如何应用于第一项的。
- en: Doing so, we’ll again use linearity to understand how *U[f]* works by passing
    one state at a time to our oracle. As we learned in chapter 2, linearity is a
    very powerful tool that lets us break down even quite complicated quantum algorithms
    into pieces that we can understand and analyze more easily. In this case, we can
    understand how *U[f]* acts on |0−〉 by using linearity (that is, by breaking |0−〉
    into a superposition between |00〉 and |01〉).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，我们再次使用线性来通过一次传递一个状态到我们的预言机来理解*U[f]*的工作原理。正如我们在第2章中学到的，线性是一个非常强大的工具，它让我们能够将甚至相当复杂的量子算法分解成我们可以更容易理解和分析的部分。在这种情况下，我们可以通过线性（即，将|0−〉分解成|00〉和|01〉的叠加）来理解*U[f]*对|0−〉的作用。
- en: '![](../Images/8-unnumb-2.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-unnumb-2.png)'
- en: For instance, if we’re considering the `zero` function, then *f*(0) = 0\. Thus,
    |*f*(0)〉 = |0〉 and |¬*f*(0)〉 = |1〉, so *U[f]* |0−〉 = |0−〉.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们考虑`zero`函数，那么*f*(0) = 0。因此，|*f*(0)〉 = |0〉和|¬*f*(0)〉 = |1〉，所以*U[f]* |0−〉
    = |0−〉。
- en: On the other hand, if *f*(0) = 1, then *U[f]* |0−〉 = |0〉 ⊗ (|1〉 − |0〉) / √2
    = –|0–〉. That is, *U[f]* flips the sign of |0−〉.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果*f*(0) = 1，那么*U[f]* |0−〉 = |0〉 ⊗ (|1〉 − |0〉) / √2 = –|0–〉。也就是说，*U[f]*翻转了|0−〉的符号。
- en: Tip (|1〉 − |0〉) / √2 can also be written as –|–〉, or as *X*|–〉.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士(|1〉 − |0〉) / √2也可以写成–|–〉，或者写成*X|–〉。
- en: 'Note then that *U[f]* either rotates the target qubit by *X* or not depending
    on the value of *f*(0):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*U[f]*根据*f*(0)的值要么旋转目标量子比特的X，要么不旋转：
- en: '![](../Images/equation_8-3.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/equation_8-3.png)'
- en: We can use the same technique we used before to understand what *U[f]* does
    if the control qubit is in the |1〉 state instead. Doing so, we get a phase of
    (–1)^(*f*(1)) instead of (–1)^(*f*(0)), so that *U[f]* |1−〉 = (–1)^(*f*(1)) |1−〉.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果控制量子比特处于|1〉状态，我们可以使用之前相同的技巧来理解*U[f]*的作用。这样做，我们得到一个相位为(–1)^(*f*(1))而不是(–1)^(*f*(0))，因此*U[f]*
    |1−〉 = (–1)^(*f*(1)) |1−〉。
- en: 'Using linearity again to combine the terms for the two states of the control
    qubit, we now know how *U[f]* transforms the state of both qubits when the control
    qubit is in |+〉:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用线性来组合控制量子比特的两个状态，我们现在知道当控制量子比特处于|+〉状态时，*U[f]*如何转换两个量子比特的状态：
- en: '![](../Images/equation_8-4.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![方程式8-4](../Images/equation_8-4.png)'
- en: The last step is to note that, as we saw in chapter 4, we cannot observe *global*
    phases. Thus, we can factor out (–1)^(*f*(0)) to express the output state in terms
    of *f*(0) ⊕ *f*(1), the question we were interested in to start with, as shown
    in figure 8.14.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是注意，正如我们在第4章中看到的，我们不能观察到*全局*相位。因此，我们可以将(–1)^(*f*(0))提取出来，用*f*(0) ⊕ *f*(1)（这是我们最初感兴趣的问题）来表示输出状态，如图8.14所示。
- en: '![](../Images/8-14.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![8-14.png](../Images/8-14.png)'
- en: Figure 8.14 Working out the last couple of steps in the Deutsch–Jozsa algorithm.
    By writing the oracle’s action on the |+−〉 state, we can see how measuring the
    control qubit at the end tells us whether the oracle represents a constant or
    balanced function.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 计算Deutsch–Jozsa算法的最后几个步骤。通过写出算子对|+−〉状态的作用，我们可以看到在最后测量控制量子比特时，算子是否代表常数或平衡函数。
- en: If *f*(0) ⊕ *f*(1) = 0 (constant), then the output state is |+−〉; but if *f*(0)
    ⊕ *f*(1) = 1 (balanced), then the output state is |–〉. With one call to *U[f]*,
    we learn whether *f* is constant or balanced *even though we do not learn what*
    *f*(*x*) *is for any particular input* *x*.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*f*(0) ⊕ *f*(1) = 0（常数），则输出状态是|+−〉；但如果*f*(0) ⊕ *f*(1) = 1（平衡），则输出状态是|–〉。通过一次调用*U[f]*，我们可以了解*f*是否为常数或平衡，即使我们不知道对于任何特定的输入*x*，*f*(x)*是什么。
- en: One way to think of what happens when we apply *U[f]* with the input qubit in
    the |+〉 state is that the state of the input qubit represents the question we
    are asking about *f*. If we ask the question |0〉, we get the answer *f*(0), while
    if we ask |1〉, we get the answer *f*(1). The question |+〉 then tells us about
    *f*(0) ⊕ *f*(1) without telling us about either *f*(0) or *f*(1) alone.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将*U[f]*应用于输入量子比特处于|+〉状态时，我们可以这样思考发生的事情：输入量子比特的状态代表我们对*f*提出的问题。如果我们提出|0〉问题，我们得到答案是*f*(0)，而如果我们提出|1〉问题，我们得到答案是*f*(1)。然后|+〉问题告诉我们关于*f*(0)
    ⊕ *f*(1)的信息，而不告诉我们关于*f*(0)或*f*(1)单独的信息。
- en: When we ask questions in superposition like this, however, the roles of “input”
    and “output” aren’t as immediately clear as they are classically. In particular,
    the |0〉 and |1〉 inputs both cause the output qubit to flip, while the |+〉 input
    causes the *input* qubit to flip, provided we start the output qubit in the |−〉
    state. In general, two-qubit operations like *U[f]* transform the entire space
    of the qubits they act on—our division into inputs and outputs is one way we interpret
    the action of *U[f]*.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们以这种叠加方式提问时，"输入"和"输出"的角色并不像经典情况下那样立即明确。特别是，|0〉和|1〉输入都会使输出量子比特翻转，而|+〉输入会使输入量子比特翻转，前提是我们从|−〉状态开始输出量子比特。一般来说，像*U[f]*这样的双量子比特操作会改变它们所作用的量子比特的全部空间——我们将输入和输出分开是解释*U[f]*作用的一种方式。
- en: The fact that the input qubit’s state changes based on transformations defined
    in the output qubit is an example of phase kickback, the quantum effect used by
    the Deutsch–Jozsa algorithm. In the next two chapters, we’ll use phase kickback
    to explore new algorithms such as those used in quantum sensing and quantum chemistry
    simulations.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 输入量子比特的状态根据输出量子比特中定义的变换而改变的事实是相位回波的一个例子，这是Deutsch–Jozsa算法使用的量子效应。在接下来的两章中，我们将使用相位回波来探索新的算法，例如用于量子传感和量子化学模拟的算法。
- en: 'Deep dive: Extending Deutsch–Jozsa'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 深入研究：扩展Deutsch–Jozsa
- en: While we only considered functions with one-bit inputs here, the Deutsch–Jozsa
    algorithm only ever needs one query for any sized input/output of our function.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这里我们只考虑了一比特输入的函数，但Deutsch–Jozsa算法对于函数的任何大小的输入/输出都只需要一个查询。
- en: To encode a two-qubit function *f*(*x*[0], *x*[1]), we can introduce a three-qubit
    oracle *U[f]* |*x*[0]*x*[1]*y*〉 = |*x*[0] *x*[1]〉 ⊗ |*f*(*x*[0], *x*[1]) ⊕ *y*〉.
    For example, consider *f*(*x*[0], *x*[1]) = *x*[0] ⊕ *x*[1]. This function is
    balanced since *f*(0, 0) = *f*(1, 1) = 0 but *f*(0, 1) = *f*(1, 0) = 1\. When
    we apply *U[f]* to the three-qubit state |++−〉 = (|00〉 + |01〉 + |10〉 + |11〉) ⊗
    |−〉, we get (|00〉 − |01〉 − |10〉 + |11〉) ⊗ |−〉 = |−−−〉. Using an *X*-basis measurement,
    we can tell this from a constant function like *f*(*x*[0], *x*[1]) = 0, which
    will give us an output of |−〉.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要编码一个双量子比特函数*f*(*x*[0], *x*[1])，我们可以引入一个三量子比特预言机*U[f]* |*x*[0]*x*[1]*y*〉 = |*x*[0]
    *x*[1]〉 ⊗ |*f*(*x*[0], *x*[1]) ⊕ *y*〉。例如，考虑*f*(*x*[0], *x*[1]) = *x*[0] ⊕ *x*[1]。这个函数是平衡的，因为*f*(0,
    0) = *f*(1, 1) = 0，但*f*(0, 1) = *f*(1, 0) = 1。当我们对三量子比特状态|++−〉 = (|00〉 + |01〉
    + |10〉 + |11〉) ⊗ |−〉应用*U[f]*时，我们得到(|00〉 − |01〉 − |10〉 + |11〉) ⊗ |−〉 = |−−−〉。使用X基测量，我们可以从像*f*(*x*[0],
    *x*[1]) = 0这样的常数函数中区分出来，这将给我们一个输出|−〉。
- en: 'As long as we’re promised that *f* is either constant or balanced, the same
    pattern holds no matter how many bits *f* takes as input: we can learn a single
    bit of data about how *f* behaves with a single call to *U[f]*. Talk about O(1)!
    If you are not familiar with Big O notation, see *Grokking Algorithms* by Aditya
    Bhargava (Manning, 2016).'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们承诺*f*要么是常数要么是平衡的，无论*f*作为输入接受多少位，相同的模式都成立：我们可以通过一次调用*U[f]*来学习关于*f*行为的一个数据位。这简直是O(1)！如果你不熟悉大O符号，请参阅Aditya
    Bhargava的《Grokking Algorithms》（Manning，2016年）。
- en: In the next chapter, we’ll build on the skills we’ve learned here by looking
    at how the *phase estimation algorithm* enables spin-off technologies like quantum
    sensors.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过研究相位估计算法如何使量子传感器等衍生技术成为可能，来构建我们在本章学到的技能。
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Quantum algorithms are sequences of steps that we can follow to solve a problem
    using quantum computers. We can implement quantum algorithms by writing quantum
    programs in Q#.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量子算法是一系列步骤，我们可以遵循这些步骤来使用量子计算机解决问题。我们可以通过在Q#中编写量子程序来实现量子算法。
- en: The Deutsch–Jozsa algorithm is an example of a quantum algorithm that lets us
    solve a computational problem with fewer resources than any possible classical
    algorithm.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Deutsch-Jozsa算法是量子算法的一个例子，它使我们能够用比任何可能的经典算法更少的资源来解决计算问题。
- en: If we want to embed classical functions into a quantum algorithm or program,
    we need to do so *reversibly*. We can construct special kinds of quantum operations
    called *oracles* that allow us to represent classical functions applied to quantum
    data.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们要将经典函数嵌入到量子算法或程序中，我们需要以可逆的方式进行。我们可以构建一种特殊的量子操作，称为预言机，它允许我们表示应用于量子数据的经典函数。
- en: The Deutsch–Jozsa algorithm lets us test if both outputs from a one-bit oracle
    are the same or different using only one call to that oracle; we don’t learn any
    particular output but instead directly learn the global property that we’re interested
    in.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Deutsch-Jozsa算法允许我们通过仅调用一次该预言机来测试一个一位预言机的两个输出是否相同或不同；我们不是学习任何特定的输出，而是直接学习我们感兴趣的全球属性。
- en: The Deutsch–Jozsa algorithm demonstrates “shoes-and-socks” patterns that occur
    commonly in other quantum algorithms as well. We will often need to apply an outer
    operation, apply an inner operation, and then undo (or take the adjoint of) the
    outer operation.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Deutsch-Jozsa算法展示了在其他量子算法中也常见的“鞋袜”模式。我们通常需要应用外层操作，然后应用内层操作，最后撤销（或取外层操作的伴随算符）。
- en: The phase kickback technique lets us associate the phase applied by a quantum
    operation with a control qubit instead of the target qubit. We will see more of
    this in the algorithms we learn next.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相位回弹技术使我们能够将量子操作施加的相位与控制量子比特而不是目标量子比特相关联。我们将在接下来学习的算法中看到更多这方面的内容。
