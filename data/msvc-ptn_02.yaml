- en: Chapter 3\. Interprocess communication in a microservice architecture
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章\. 微服务架构中的进程间通信
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: 'Applying the communication patterns: Remote procedure invocation, Circuit breaker,
    Client-side discovery, Self registration, Server-side discovery, Third party registration,
    Asynchronous messaging, Transactional outbox, Transaction log tailing, Polling
    publisher'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用通信模式：远程过程调用、断路器、客户端发现、自我注册、服务器端发现、第三方注册、异步消息、事务性输出箱、事务日志尾部、轮询发布者
- en: The importance of interprocess communication in a microservice architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程间通信在微服务架构中的重要性
- en: Defining and evolving APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和演进API
- en: The various interprocess communication options and their trade-offs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种进程间通信选项及其权衡
- en: The benefits of services that communicate using asynchronous messaging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步消息通信的服务的好处
- en: Reliably sending messages as part of a database transaction
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为数据库事务一部分可靠地发送消息
- en: Mary and her team, like most other developers, had some experience with interprocess
    communication (IPC) mechanisms. The FTGO application has a REST API that’s used
    by mobile applications and browser-side JavaScript. It also uses various cloud
    services, such as the Twilio messaging service and the Stripe payment service.
    But within a monolithic application like FTGO, modules invoke one another via
    language-level method or function calls. FTGO developers generally don’t need
    to think about IPC unless they’re working on the REST API or the modules that
    integrate with cloud services.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Mary和她的团队，像大多数其他开发者一样，对进程间通信（IPC）机制有一些经验。FTGO应用程序有一个REST API，该API被移动应用程序和浏览器端的JavaScript使用。它还使用了各种云服务，例如Twilio消息服务和Stripe支付服务。但在像FTGO这样的单体应用程序中，模块通过语言级别的函数或方法调用相互调用。FTGO开发者通常不需要考虑IPC，除非他们正在处理REST
    API或与云服务集成的模块。
- en: In contrast, as you saw in [chapter 2](kindle_split_010.xhtml#ch02), the microservice
    architecture structures an application as a set of services. Those services must
    often collaborate in order to handle a request. Because service instances are
    typically processes running on multiple machines, they must interact using IPC.
    It plays a much more important role in a microservice architecture than it does
    in a monolithic application. Consequently, as they migrate their application to
    microservices, Mary and the rest of the FTGO developers will need to spend a lot
    more time thinking about IPC.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，正如你在[第2章](kindle_split_010.xhtml#ch02)中看到的，微服务架构将应用程序结构化为一系列服务。这些服务必须经常协作以处理请求。因为服务实例通常是运行在多台机器上的进程，它们必须使用IPC进行交互。在微服务架构中，IPC比在单体应用程序中扮演着更加重要的角色。因此，当Mary和其他FTGO开发者将应用程序迁移到微服务时，他们需要花费更多的时间来思考IPC。
- en: There’s no shortage of IPC mechanisms to chose from. Today, the fashionable
    choice is REST (with JSON). It’s important, though, to remember that there are
    no silver bullets. You must carefully consider the options. This chapter explores
    various IPC options, including REST and messaging, and discusses the trade-offs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可供选择的IPC机制并不缺乏。今天，时尚的选择是REST（使用JSON）。然而，重要的是要记住，没有银弹。你必须仔细考虑选项。本章探讨了包括REST和消息在内的各种IPC选项，并讨论了权衡。
- en: The choice of IPC mechanism is an important architectural decision. It can impact
    application availability. What’s more, as I explain in this chapter and the next,
    IPC even intersects with transaction management. I favor an architecture consisting
    of loosely coupled services that communicate with one another using asynchronous
    messaging. Synchronous protocols such as REST are used mostly to communicate with
    other applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: IPC机制的选择是一个重要的架构决策。它可能影响应用程序的可用性。更重要的是，正如我在本章和下一章中解释的，IPC甚至与事务管理相交。我倾向于一个由松散耦合的服务组成的架构，这些服务通过异步消息相互通信。同步协议，如REST，主要用于与其他应用程序通信。
- en: I begin this chapter with an overview of interprocess communication in microservice
    architecture. Next, I describe remote procedure invocation-based IPC, of which
    REST is the most popular example. I cover important topics including service discovery
    and how to handle partial failure. After that, I describe asynchronous messaging-based
    IPC. I also talk about scaling consumers while preserving message ordering, correctly
    handling duplicate messages, and transactional messaging. Finally, I go through
    the concept of self-contained services that handle synchronous requests without
    communicating with other services in order to improve availability.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我以微服务架构中进程间通信的概述开始本章。接下来，我描述基于远程过程调用的IPC，其中REST是最流行的例子。我涵盖了包括服务发现和如何处理部分失败等重要主题。之后，我描述基于异步消息的IPC。我还谈论了在保持消息顺序的同时扩展消费者，正确处理重复消息和事务性消息。最后，我探讨了处理同步请求而不与其他服务通信的自包含服务的概念，以提高可用性。
- en: 3.1\. Overview of interprocess communication in a microservice architecture
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. 微服务架构中进程间通信概述
- en: There are lots of different IPC technologies to choose from. Services can use
    synchronous request/response-based communication mechanisms, such as HTTP-based
    REST or gRPC. Alternatively, they can use asynchronous, message-based communication
    mechanisms such as AMQP or STOMP. There are also a variety of different messages
    formats. Services can use human-readable, text-based formats such as JSON or XML.
    Alternatively, they could use a more efficient binary format such as Avro or Protocol
    Buffers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多不同的IPC技术可供选择。服务可以使用基于同步请求/响应的通信机制，如基于HTTP的REST或gRPC。或者，它们可以使用基于异步、基于消息的通信机制，如AMQP或STOMP。还有各种不同的消息格式。服务可以使用人类可读的、基于文本的格式，如JSON或XML。或者，它们可以使用更高效的二进制格式，如Avro或Protocol
    Buffers。
- en: Before getting into the details of specific technologies, I want to bring up
    several design issues you should consider. I start this section with a discussion
    of interaction styles, which are a technology-independent way of describing how
    clients and services interact. Next I discuss the importance of precisely defining
    APIs in a microservice architecture, including the concept of API-first design.
    After that, I discuss the important topic of API evolution. Finally, I discuss
    different options for message formats and how they can determine ease of API evolution.
    Let’s begin by looking at interaction styles.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨具体技术的细节之前，我想提出几个你应该考虑的设计问题。我以讨论交互风格开始这一节，交互风格是一种与技术无关的描述客户端和服务如何交互的方式。接下来，我将讨论在微服务架构中精确定义API的重要性，包括API-first设计概念。然后，我将讨论API进化的重要主题。最后，我将讨论消息格式的不同选项以及它们如何决定API进化的容易程度。让我们从查看交互风格开始。
- en: 3.1.1\. Interaction styles
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1\. 交互风格
- en: It’s useful to first think about the style of interaction between a service
    and its clients before selecting an IPC mechanism for a service’s API. Thinking
    first about the interaction style will help you focus on the requirements and
    avoid getting mired in the details of a particular IPC technology. Also, as described
    in [section 3.4](#ch03lev1sec4), the choice of interaction style impacts the availability
    of your application. Furthermore, as you’ll see in [chapters 9](kindle_split_017.xhtml#ch09)
    and [10](kindle_split_018.xhtml#ch10), it helps you select the appropriate integration
    testing strategy.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择服务API的IPC机制之前，首先思考一下服务与其客户端之间的交互风格是有用的。首先考虑交互风格将有助于你集中精力考虑需求，避免陷入特定IPC技术的细节中。此外，如[第3.4节](#ch03lev1sec4)所述，交互风格的选择会影响你应用程序的可用性。此外，正如你将在[第9章](kindle_split_017.xhtml#ch09)和[第10章](kindle_split_018.xhtml#ch10)中看到的那样，它有助于你选择适当的集成测试策略。
- en: 'There are a variety of client-service interaction styles. As [table 3.1](#ch03table01)
    shows, they can be categorized in two dimensions. The first dimension is whether
    the interaction is one-to-one or one-to-many:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种客户端-服务交互风格。如[表3.1](#ch03table01)所示，它们可以从两个维度进行分类。第一个维度是交互是一对一还是一对多：
- en: '***One-to-one*—** Each client request is processed by exactly one service.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***一对一***—**每个客户端请求由恰好一个服务处理**。'
- en: '***One-to-many*—** Each request is processed by multiple services.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***一对多***—**每个请求由多个服务处理**。'
- en: 'The second dimension is whether the interaction is synchronous or asynchronous:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个维度是交互是同步还是异步：
- en: '***Synchronous*—** The client expects a timely response from the service and
    might even block while it waits.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***同步***—** 客户端期望从服务中获得及时响应，甚至可能在等待时阻塞。'
- en: '***Asynchronous*—** The client doesn’t block, and the response, if any, isn’t
    necessarily sent immediately.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***异步***—** 客户端不会阻塞，如果有的话，响应也不一定是立即发送的。'
- en: 'Table 3.1\. The various interaction styles can be characterized in two dimensions:
    one-to-one vs one-to-many and synchronous vs asynchronous.'
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.1\. 不同的交互风格可以从两个维度进行描述：一对一与一对多，以及同步与异步。
- en: '|   | one-to-one | one-to-many |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|   | 一对一 | 一对多 |'
- en: '| --- | --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Synchronous | Request/response | — |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 同步 | 请求/响应 | — |'
- en: '| Asynchronous | Asynchronous request/response One-way notifications | Publish/subscribe
    Publish/async responses |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 异步 | 异步请求/响应 单向通知 | 发布/订阅 发布/异步响应 |'
- en: 'The following are the different types of one-to-one interactions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一对一交互的不同类型：
- en: '***Request/response*—** A service client makes a request to a service and waits
    for a response. The client expects the response to arrive in a timely fashion.
    It might event block while waiting. This is an interaction style that generally
    results in services being tightly coupled.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***请求/响应***—** 客户端向服务发出请求并等待响应。客户端期望及时收到响应。它甚至可能在等待时阻塞。这种交互风格通常会导致服务紧密耦合。'
- en: '***Asynchronous request/response*—** A service client sends a request to a
    service, which replies asynchronously. The client doesn’t block while waiting,
    because the service might not send the response for a long time.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***异步请求/响应***—** 服务客户端向服务发送请求，服务异步回复。客户端在等待时不会阻塞，因为服务可能不会立即发送响应。'
- en: '***One-way notifications*—** A service client sends a request to a service,
    but no reply is expected or sent.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***单向通知***—** 服务客户端向服务发送请求，但不需要也不发送回复。'
- en: It’s important to remember that the synchronous request/response interaction
    style is mostly orthogonal to IPC technologies. A service can, for example, interact
    with another service using request/response style interaction with either REST
    or messaging. Even if two services are communicating using a message broker, the
    client service might be blocked waiting for a response. It doesn’t necessarily
    mean they’re loosely coupled. That’s something I revisit later in this chapter
    when discussing the impact of inter-service communication on availability.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点很重要，即同步请求/响应交互风格通常与进程间通信（IPC）技术正交。例如，一个服务可以通过使用REST或消息传递的请求/响应风格与另一个服务交互。即使两个服务正在使用消息代理进行通信，客户端服务也可能因为等待响应而被阻塞。这并不一定意味着它们是松散耦合的。这是我在本章后面讨论服务间通信对可用性影响时再次回顾的内容。
- en: 'The following are the different types of one-to-many interactions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一对多交互的不同类型：
- en: '***Publish/subscribe*—** A client publishes a notification message, which is
    consumed by zero or more interested services.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***发布/订阅***—** 客户端发布一个通知消息，该消息被零个或多个感兴趣的服务消费。'
- en: '***Publish/async responses*—** A client publishes a request message and then
    waits for a certain amount of time for responses from interested services.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***发布/异步响应***—** 客户端发布一个请求消息，然后等待一定时间，以从感兴趣的服务那里获取响应。'
- en: Each service will typically use a combination of these interaction styles. Many
    of the services in the FTGO application have both synchronous and asynchronous
    APIs for operations, and many also publish events.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务通常会使用这些交互风格的组合。FTGO应用程序中的许多服务都有同步和异步API用于操作，许多服务还发布事件。
- en: Let’s look at how to define a service’s API.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何定义服务的API。
- en: 3.1.2\. Defining APIs in a microservice architecture
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2\. 在微服务架构中定义API
- en: APIs or interfaces are central to software development. An application is comprised
    of modules. Each module has an interface that defines the set of operations that
    module’s clients can invoke. A well-designed interface exposes useful functionality
    while hiding the implementation. It enables the implementation to change without
    impacting clients.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: API或接口是软件开发的核心。一个应用程序由模块组成。每个模块都有一个接口，该接口定义了该模块客户端可以调用的操作集。一个设计良好的接口可以暴露有用的功能，同时隐藏实现细节。它使得实现可以改变而不会影响客户端。
- en: In a monolithic application, an interface is typically specified using a programming
    language construct such as a Java interface. A Java interface specifies a set
    of methods that a client can invoke. The implementation class is hidden from the
    client. Moreover, because Java is a statically typed language, if the interface
    changes to be incompatible with the client, the application won’t compile.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用程序中，通常使用编程语言构造，如Java接口来指定接口。Java接口定义了一组客户端可以调用的方法。实现类对客户端是隐藏的。此外，由于Java是一种静态类型语言，如果接口发生变化，与客户端不兼容，则应用程序将无法编译。
- en: APIs and interfaces are equally important in a microservice architecture. A
    service’s API is a contract between the service and its clients. As described
    in [chapter 2](kindle_split_010.xhtml#ch02), a service’s API consists of operations,
    which clients can invoke, and events, which are published by the service. An operation
    has a name, parameters, and a return type. An event has a type and a set of fields
    and is, as described in [section 3.3](#ch03lev1sec3), published to a message channel.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，API和接口同样重要。服务的API是服务与其客户端之间的合同。如[第2章](kindle_split_010.xhtml#ch02)所述，服务的API包括客户端可以调用的操作和由服务发布的事件。一个操作有一个名称、参数和返回类型。一个事件有一个类型和一组字段，如[第3.3节](#ch03lev1sec3)所述，发布到一个消息通道。
- en: The challenge is that a service API isn’t defined using a simple programming
    language construct. By definition, a service and its clients aren’t compiled together.
    If a new version of a service is deployed with an incompatible API, there’s no
    compilation error. Instead, there will be runtime failures.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于服务API不是使用简单的编程语言构造来定义的。根据定义，服务和其客户端不是一起编译的。如果一个服务的新的不兼容API版本被部署，将不会有编译错误。相反，将会出现运行时错误。
- en: Regardless of which IPC mechanism you choose, it’s important to precisely define
    a service’s API using some kind of *interface definition language* (IDL). Moreover,
    there are good arguments for using an API-first approach to defining services
    (see [www.programmableweb.com/news/how-to-design-great-apis-api-first-design-and-raml/how-to/2015/07/10](http://www.programmableweb.com/news/how-to-design-great-apis-api-first-design-and-raml/how-to/2015/07/10)
    for more). First you write the interface definition. Then you review the interface
    definition with the client developers. Only after iterating on the API definition
    do you then implement the service. Doing this up-front design increases your chances
    of building a service that meets the needs of its clients.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种IPC机制，使用某种类型的*接口定义语言*（IDL）精确地定义服务的API都是非常重要的。此外，有很好的理由使用API优先的方法来定义服务（更多信息请参阅[www.programmableweb.com/news/how-to-design-great-apis-api-first-design-and-raml/how-to/2015/07/10](http://www.programmableweb.com/news/how-to-design-great-apis-api-first-design-and-raml/how-to/2015/07/10)）。首先，你编写接口定义。然后，与客户端开发者审查接口定义。只有在迭代API定义之后，你才实施服务。这种前期设计可以增加你构建满足客户端需求的服务的机会。
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**API-first design is essential**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**API优先设计是至关重要的**'
- en: Even in small projects, I’ve seen problems occur because components don’t agree
    on an API. For example, on one project the backend Java developer and the AngularJS
    frontend developer both said they had completed development. The application,
    however, didn’t work. The REST and WebSocket API used by the frontend application
    to communicate with the backend was poorly defined. As a result, the two applications
    couldn’t communicate!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在小项目中，我也见过由于组件没有就API达成一致而导致问题发生的情况。例如，在一个项目中，后端Java开发者和AngularJS前端开发者都表示他们已经完成了开发。然而，应用程序却无法工作。前端应用程序用于与后端通信的REST和WebSocket
    API定义得不好。结果，两个应用程序无法通信！
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The nature of the API definition depends on which IPC mechanism you’re using.
    For example, if you’re using messaging, the API consists of the message channels,
    the message types, and the message formats. If you’re using HTTP, the API consists
    of the URLs, the HTTP verbs, and the request and response formats. Later in this
    chapter, I explain how to define APIs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: API定义的性质取决于你使用的IPC机制。例如，如果你使用消息传递，API包括消息通道、消息类型和消息格式。如果你使用HTTP，API包括URL、HTTP动词以及请求和响应格式。在本章的后面部分，我将解释如何定义API。
- en: A service’s API is rarely set in stone. It will likely evolve over time. Let’s
    take a look at how to do that and consider the issues you’ll face.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的API很少是一成不变的。它很可能会随着时间的推移而演变。让我们看看如何做到这一点，并考虑你将面临的问题。
- en: 3.1.3\. Evolving APIs
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.3. API的演变
- en: APIs invariably change over time as new features are added, existing features
    are changed, and (perhaps) old features are removed. In a monolithic application,
    it’s relatively straightforward to change an API and update all the callers. If
    you’re using a statically typed language, the compiler helps by giving a list
    of compilation errors. The only challenge may be the scope of the change. It might
    take a long time to change a widely used API.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新功能的添加、现有功能的更改以及（可能）旧功能的删除，API不可避免地会随着时间的推移而变化。在单体应用程序中，更改API并更新所有调用者相对简单。如果你使用静态类型语言，编译器会通过提供编译错误列表来帮助。唯一的挑战可能是变更的范围。更改广泛使用的API可能需要很长时间。
- en: In a microservices-based application, changing a service’s API is a lot more
    difficult. A service’s clients are other services, which are often developed by
    other teams. The clients may even be other applications outside of the organization.
    You usually can’t force all clients to upgrade in lockstep with the service. Also,
    because modern applications are usually never down for maintenance, you’ll typically
    perform a rolling upgrade of your service, so both old and new versions of a service
    will be running simultaneously.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于微服务的应用程序中，更改服务的API要困难得多。服务的客户端是其他服务，这些服务通常由其他团队开发。客户端甚至可能是组织外的其他应用程序。你通常无法强迫所有客户端与服务同步升级。此外，由于现代应用程序通常永远不会因维护而停机，你通常会执行服务的滚动升级，因此服务的旧版本和新版本将同时运行。
- en: It’s important to have a strategy for dealing with these challenges. How you
    handle a change to an API depends on the nature of the change.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 制定应对这些挑战的策略很重要。你如何处理API的变更取决于变更的性质。
- en: Use semantic versioning
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用语义版本控制
- en: The Semantic Versioning specification ([http://semver.org](http://semver.org))
    is a useful guide to versioning APIs. It’s a set of rules that specify how version
    numbers are used and incremented. Semantic versioning was originally intended
    to be used for versioning of software packages, but you can use it for versioning
    APIs in a distributed system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制规范([http://semver.org](http://semver.org))是API版本化的有用指南。它是一组规则，指定了如何使用和递增版本号。语义版本控制最初旨在用于软件包的版本控制，但你也可以用于分布式系统中API的版本控制。
- en: 'The Semantic Versioning specification (Semvers) requires a version number to
    consist of three parts: `MAJOR.MINOR.PATCH`. You must increment each part of a
    version number as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制规范（Semvers）要求版本号由三部分组成：`MAJOR.MINOR.PATCH`。你必须按照以下方式递增版本号的每一部分：
- en: '**`MAJOR`—** When you make an incompatible change to the API'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`MAJOR`—** 当你对API进行不兼容的变更时'
- en: '**`MINOR`—** When you make backward-compatible enhancements to the API'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`MINOR`—** 当你对API进行向后兼容的增强时'
- en: '**`PATCH`—** When you make a backward-compatible bug fix'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`PATCH`—** 当你进行向后兼容的错误修复时'
- en: There are a couple of places you can use the version number in an API. If you’re
    implementing a REST API, you can, as mentioned below, use the major version as
    the first element of the URL path. Alternatively, if you’re implementing a service
    that uses messaging, you can include the version number in the messages that it
    publishes. The goal is to properly version APIs and to evolve them in a controlled
    fashion. Let’s look at how to handle minor and major changes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在API中，你可以使用版本号的地方有几个。如果你正在实现REST API，你可以像下面提到的，将主版本号用作URL路径的第一个元素。或者，如果你正在实现使用消息传递的服务，你可以在它发布的消息中包含版本号。目标是正确地版本化API，并按受控方式演进。让我们看看如何处理次要和主要变更。
- en: Making minor, backward-compatible changes
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 进行次要的向后兼容变更
- en: 'Ideally, you should strive to only make backward-compatible changes. Backward-compatible
    changes are additive changes to an API:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该努力只进行向后兼容的变更。向后兼容的变更是对API的增量变更：
- en: Adding optional attributes to request
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加可选属性到请求中
- en: Adding attributes to a response
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向响应中添加属性
- en: Adding new operations
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新操作
- en: 'If you only ever make these kinds of changes, older clients will work with
    newer services, provided that they observe the Robustness principle ([https://en.wikipedia.org/wiki/Robustness_principle](https://en.wikipedia.org/wiki/Robustness_principle)),
    which states: “Be conservative in what you do, be liberal in what you accept from
    others.” Services should provide default values for missing request attributes.
    Similarly, clients should ignore any extra response attributes. In order for this
    to be painless, clients and services must use a request and response format that
    supports the Robustness principle. Later in this section, I describe how text-based
    formats such as JSON and XML generally make it easier to evolve APIs.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只进行这类更改，较旧的客户端仍然可以与较新的服务一起工作，前提是它们遵循鲁棒性原则([https://en.wikipedia.org/wiki/Robustness_principle](https://en.wikipedia.org/wiki/Robustness_principle))，该原则指出：“在行动上要保守，在接受他人时要有宽容。”服务应提供缺失请求属性的默认值。同样，客户端应忽略任何额外的响应属性。为了使这一过程不痛苦，客户端和服务必须使用支持鲁棒性原则的请求和响应格式。在本节后面的内容中，我将描述基于文本的格式，如JSON和XML，通常如何使API的演变更容易。
- en: Making major, breaking changes
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 进行重大、破坏性的更改
- en: Sometimes you must make major, incompatible changes to an API. Because you can’t
    force clients to upgrade immediately, a service must simultaneously support old
    and new versions of an API for some period of time. If you’re using an HTTP-based
    IPC mechanism, such as REST, one approach is to embed the major version number
    in the URL. For example, version 1 paths are prefixed with `'/v1/...'`, and version
    2 paths with `'/v2/...'`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你必须对API进行重大且不兼容的更改。由于你不能强迫客户端立即升级，因此服务必须在一段时间内同时支持API的旧版本和新版本。如果你使用基于HTTP的IPC机制，如REST，一种方法是将主要版本号嵌入到URL中。例如，版本1的路径以`'/v1/...'`开头，版本2的路径以`'/v2/...'`开头。
- en: 'Another option is to use HTTP’s content negotiation mechanism and include the
    version number in the MIME type. For example, a client would request version `1.x`
    of an `Order` using a request like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用HTTP的内容协商机制，并在MIME类型中包含版本号。例如，客户端可以通过以下请求来请求`Order`的`1.x`版本：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This request tells the `Order Service` that the client expects a version `1.x`
    response.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求告诉`Order Service`，客户端期望得到一个版本`1.x`的响应。
- en: In order to support multiple versions of an API, the service’s adapters that
    implement the APIs will contain logic that translates between the old and new
    versions. Also, as described in [chapter 8](kindle_split_016.xhtml#ch08), the
    API gateway will almost certainly use versioned APIs. It may even have to support
    numerous older versions of an API.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持API的多个版本，实现API的服务适配器将包含在旧版本和新版本之间进行转换的逻辑。此外，正如在第8章[chapter 8](kindle_split_016.xhtml#ch08)中所述，API网关几乎肯定会使用版本化的API。它甚至可能需要支持API的多个旧版本。
- en: Now we’ll look at the issue of message formats, the choice of which can impact
    how easy evolving an API will be.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨消息格式的问题，选择哪种格式可能会影响API演变的难易程度。
- en: 3.1.4\. Message formats
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.4\. 消息格式
- en: The essence of IPC is the exchange of messages. *Messages* usually contain data,
    and so an important design decision is the format of that data. The choice of
    message format can impact the efficiency of IPC, the usability of the API, and
    its evolvability. If you’re using a messaging system or protocols such as HTTP,
    you get to pick your message format. Some IPC mechanisms—such as gRPC, which you’ll
    learn about shortly—might dictate the message format. In either case, it’s essential
    to use a cross-language message format. Even if you’re writing your microservices
    in a single language today, it’s likely that you’ll use other languages in the
    future. You shouldn’t, for example, use Java serialization.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: IPC的本质是消息的交换。*消息*通常包含数据，因此一个重要的设计决策是数据格式。消息格式的选择可能会影响IPC的效率、API的可用性和其可扩展性。如果你使用消息系统或如HTTP之类的协议，你可以选择你的消息格式。一些IPC机制——如你很快就会了解到的gRPC——可能会规定消息格式。在任何情况下，使用跨语言的消息格式都是至关重要的。即使你今天正在用单一语言编写微服务，将来也很可能使用其他语言。例如，你不应该使用Java序列化。
- en: 'There are two main categories of message formats: text and binary. Let’s look
    at each one.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 消息格式主要分为两大类：文本和二进制。让我们逐一来看。
- en: Text-based message formats
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于文本的消息格式
- en: The first category is text-based formats such as JSON and XML. An advantage
    of these formats is that not only are they human readable, they’re self describing.
    A JSON message is a collection of named properties. Similarly, an XML message
    is effectively a collection of named elements and values. This format enables
    a consumer of a message to pick out the values of interest and ignore the rest.
    Consequently, many changes to the message schema can easily be backward-compatible.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类是基于文本的格式，如 JSON 和 XML。这些格式的优点是不仅可读性好，而且具有自描述性。一个 JSON 消息是一组命名的属性集合。同样，一个
    XML 消息实际上是一组命名的元素和值的集合。这种格式使得消息的消费者能够挑选出感兴趣的值并忽略其余部分。因此，许多对消息架构的更改可以很容易地实现向后兼容。
- en: The structure of XML documents is specified by an XML schema ([www.w3.org/XML/Schema](http://www.w3.org/XML/Schema)).
    Over time, the developer community has come to realize that JSON also needs a
    similar mechanism. One popular option is to use the JSON Schema standard ([http://json-schema.org](http://json-schema.org)).
    A JSON schema defines the names and types of a message’s properties and whether
    they’re optional or required. As well as being useful documentation, a JSON schema
    can be used by an application to validate incoming messages.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: XML 文档的结构由 XML 模式指定 ([www.w3.org/XML/Schema](http://www.w3.org/XML/Schema))。随着时间的推移，开发社区逐渐意识到
    JSON 也需要类似的机制。一个流行的选择是使用 JSON Schema 标准 ([http://json-schema.org](http://json-schema.org))。一个
    JSON 模式定义了消息属性的名称和类型，以及它们是可选的还是必需的。除了作为有用的文档外，JSON 模式还可以由应用程序用于验证传入的消息。
- en: A downside of using a text-based messages format is that the messages tend to
    be verbose, especially XML. Every message has the overhead of containing the names
    of the attributes in addition to their values. Another drawback is the overhead
    of parsing text, especially when messages are large. Consequently, if efficiency
    and performance are important, you may want to consider using a binary format.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于文本的消息格式的缺点是消息往往很冗长，尤其是 XML。每个消息都包含属性名称及其值的开销。另一个缺点是解析文本的开销，尤其是当消息很大时。因此，如果效率和性能很重要，你可能想要考虑使用二进制格式。
- en: Binary message formats
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 二进制消息格式
- en: There are several different binary formats to choose from. Popular formats include
    Protocol Buffers ([https://developers.google.com/protocol-buffers/docs/overview](https://developers.google.com/protocol-buffers/docs/overview))
    and Avro ([https://avro.apache.org](https://avro.apache.org)). Both formats provide
    a typed IDL for defining the structure of your messages. A compiler then generates
    the code that serializes and deserializes the messages. You’re forced to take
    an API-first approach to service design! Moreover, if you write your client in
    a statically typed language, the compiler checks that it uses the API correctly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的二进制格式可供选择。流行的格式包括 Protocol Buffers ([https://developers.google.com/protocol-buffers/docs/overview](https://developers.google.com/protocol-buffers/docs/overview))
    和 Avro ([https://avro.apache.org](https://avro.apache.org))。这两种格式都提供了一种类型化的 IDL，用于定义消息的结构。然后编译器生成序列化和反序列化消息的代码。这使得你不得不采取
    API 首选的方法来设计服务！此外，如果你用静态类型语言编写客户端，编译器会检查它是否正确使用了 API。
- en: One difference between these two binary formats is that Protocol Buffers uses
    tagged fields, whereas an Avro consumer needs to know the schema in order to interpret
    messages. As a result, handling API evolution is easier with Protocol Buffers
    than with Avro. This blog post ([http://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html](http://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html))
    is an excellent comparison of Thrift, Protocol Buffers, and Avro.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种二进制格式之间的一个区别是，Protocol Buffers 使用标记字段，而 Avro 消费者需要知道模式才能解释消息。因此，与 Avro 相比，使用
    Protocol Buffers 处理 API 进化要容易得多。这篇博客文章 ([http://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html](http://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html))
    是 Thrift、Protocol Buffers 和 Avro 之间优秀比较。
- en: Now that we’ve looked at message formats, let’s look at specific IPC mechanisms
    that transport the messages, starting with the Remote procedure invocation (RPI)
    pattern.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了消息格式，接下来让我们看看具体的 IPC 机制，这些机制用于传输消息，从远程过程调用（RPI）模式开始。
- en: 3.2\. Communicating using the synchronous Remote procedure invocation pattern
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2. 使用同步远程过程调用模式进行通信
- en: When using a remote procedure invocation-based IPC mechanism, a client sends
    a request to a service, and the service processes the request and sends back a
    response. Some clients may block waiting for a response, and others might have
    a reactive, nonblocking architecture. But unlike when using messaging, the client
    assumes that the response will arrive in a timely fashion.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基于远程过程调用的IPC机制时，客户端向服务发送请求，服务处理请求并发送响应。一些客户端可能会阻塞等待响应，而另一些可能具有反应性、非阻塞的架构。但与使用消息传递不同，客户端假设响应将及时到达。
- en: '[Figure 3.1](#ch03fig01) shows how RPI works. The business logic in the client
    invokes a *proxy interface*, implemented by an *RPI proxy* adapter class. The
    *RPI proxy* makes a request to the service. The request is handled by an *RPI
    server* adapter class, which invokes the service’s business logic via an interface.
    It then sends back a reply to the *RPI proxy*, which returns the result to the
    client’s business logic.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.1](#ch03fig01)展示了RPI的工作原理。客户端的业务逻辑调用一个由*RPI代理*适配器类实现的接口。*RPI代理*向服务发送请求。请求由一个*RPI服务器*适配器类处理，该适配器类通过接口调用服务的业务逻辑。然后它将回复发送回*RPI代理*，*RPI代理*将结果返回给客户端的业务逻辑。'
- en: '|  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Remote procedure invocation**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：远程过程调用**'
- en: A client invokes a service using a synchronous, remote procedure invocation-based
    protocol, such as REST ([http://microservices.io/patterns/communication-style/messaging.html](http://microservices.io/patterns/communication-style/messaging.html)).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端使用基于同步、远程过程调用协议的服务，例如REST ([http://microservices.io/patterns/communication-style/messaging.html](http://microservices.io/patterns/communication-style/messaging.html))。
- en: '|  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 3.1\. The client’s business logic invokes an interface that is implemented
    by an *RPI proxy* adapter class. The *RPI proxy class* makes a request to the
    service. The *RPI server* adapter class handles the request by invoking the service’s
    business logic.
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1\. 客户端业务逻辑调用一个由*RPI代理*适配器类实现的接口。*RPI代理类*向服务发送请求。*RPI服务器*适配器类通过调用服务的业务逻辑来处理请求。
- en: '![](Images/03fig01_alt.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig01_alt.jpg)'
- en: The *proxy interface* usually encapsulates the underlying communication protocol.
    There are numerous protocols to choose from. In this section, I describe REST
    and gRPC. I cover how to improve the availability of your services by properly
    handling partial failure and explain why a microservices-based application that
    uses RPI must use a service discovery mechanism.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代理接口通常封装了底层的通信协议。有众多协议可供选择。在本节中，我将介绍REST和gRPC。我将解释如何通过妥善处理部分故障来提高服务的可用性，并解释为什么基于RPI的微服务应用必须使用服务发现机制。
- en: Let’s first take a look at REST.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看REST。
- en: 3.2.1\. Using REST
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. 使用REST
- en: 'Today, it’s fashionable to develop APIs in the RESTful style ([https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)).
    *REST* is an IPC mechanism that (almost always) uses HTTP. Roy Fielding, the creator
    of REST, defines REST as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以RESTful风格开发API很流行 ([https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer))。*REST*是一种IPC机制，几乎总是使用HTTP。REST的创造者Roy
    Fielding将其定义为如下：
- en: '*REST provides a set of architectural constraints that, when applied as a whole,
    emphasizes scalability of component interactions, generality of interfaces, independent
    deployment of components, and intermediary components to reduce interaction latency,
    enforce security, and encapsulate legacy systems.*'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: REST提供了一套架构约束，当整体应用时，强调组件交互的可扩展性、接口的通用性、组件的独立部署，以及中间件组件以减少交互延迟、加强安全性和封装遗留系统。
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*[www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)*'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*[www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)*'
- en: A key concept in REST is a *resource*, which typically represents a single business
    object, such as a Customer or Product, or a collection of business objects. REST
    uses the HTTP verbs for manipulating resources, which are referenced using a URL.
    For example, a GET request returns the representation of a resource, which is
    often in the form of an XML document or JSON object, although other formats such
    as binary can be used. A POST request creates a new resource, and a PUT request
    updates a resource. The `Order Service`, for example, has a `POST /orders` endpoint
    for creating an `Order` and a `GET /orders/{orderId}` endpoint for retrieving
    an `Order`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: REST中的一个关键概念是*资源*，它通常代表单个业务对象，如客户或产品，或一组业务对象。REST使用HTTP动词来操作资源，这些动词通过URL引用。例如，GET请求返回资源的表示，这通常是XML文档或JSON对象的形式，尽管也可以使用其他格式，如二进制格式。POST请求创建新的资源，而PUT请求更新资源。例如，`Order
    Service`有一个`POST /orders`端点用于创建`Order`，以及一个`GET /orders/{orderId}`端点用于检索`Order`。
- en: Many developers claim their HTTP-based APIs are RESTful. But as Roy Fielding
    describes in a blog post, not all of them actually are ([http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)).
    To understand why, let’s take a look at the REST maturity model.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员声称他们的基于HTTP的API是RESTful的。但正如Roy Fielding在博客文章中描述的，并非所有这些API实际上都是RESTful的。为了了解原因，让我们看一下REST成熟度模型。
- en: The REST maturity model
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: The REST成熟度模型
- en: 'Leonard Richardson (no relation to your author) defines a very useful maturity
    model for REST ([http://martinfowler.com/articles/richardsonMaturityModel.html](http://martinfowler.com/articles/richardsonMaturityModel.html))
    that consists of the following levels:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Leonard Richardson（与您的作者无亲属关系）定义了一个非常实用的REST成熟度模型([http://martinfowler.com/articles/richardsonMaturityModel.html](http://martinfowler.com/articles/richardsonMaturityModel.html))，它包括以下级别：
- en: '***Level 0*—** Clients of a level 0 service invoke the service by making HTTP
    POST requests to its sole URL endpoint. Each request specifies the action to perform,
    the target of the action (for example, the business object), and any parameters.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Level 0*—** 0级服务的客户端通过向其唯一的URL端点发送HTTP POST请求来调用服务。每个请求都指定要执行的操作、操作的目标（例如，业务对象）以及任何参数。'
- en: '***Level 1*—** A level 1 service supports the idea of resources. To perform
    an action on a resource, a client makes a POST request that specifies the action
    to perform and any parameters.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Level 1*—** 1级服务支持资源的概念。要对资源执行操作，客户端需要发送一个POST请求，指定要执行的操作和任何参数。'
- en: '***Level 2*—** A level 2 service uses HTTP verbs to perform actions: GET to
    retrieve, POST to create, and PUT to update. The request query parameters and
    body, if any, specify the actions’ parameters. This enables services to use web
    infrastructure such as caching for GET requests.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Level 2*—** 2级服务使用HTTP动词执行操作：GET用于检索，POST用于创建，PUT用于更新。请求的查询参数和（如果有的话）正文指定了操作的参数。这使得服务可以使用Web基础设施，如缓存，用于GET请求。'
- en: '***Level 3*—** The design of a level 3 service is based on the terribly named
    HATEOAS (Hypertext As The Engine Of Application State) principle. The basic idea
    is that the representation of a resource returned by a GET request contains links
    for performing actions on that resource. For example, a client can cancel an order
    using a link in the representation returned by the GET request that retrieved
    the order. The benefits of HATEOAS include no longer having to hard-wire URLs
    into client code ([www.infoq.com/news/2009/04/hateoas-restful-api-advantages](http://www.infoq.com/news/2009/04/hateoas-restful-api-advantages)).'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Level 3*—** 3级服务的设计基于名为HATEOAS（Hypertext As The Engine Of Application State）的糟糕命名原则。基本思想是，GET请求返回的资源表示中包含执行该资源操作的超链接。例如，客户端可以使用GET请求返回的表示中的链接来取消订单。HATEOAS的好处包括不再需要在客户端代码中硬编码URL([www.infoq.com/news/2009/04/hateoas-restful-api-advantages](http://www.infoq.com/news/2009/04/hateoas-restful-api-advantages))。'
- en: I encourage you to review the REST APIs at your organization to see which level
    they correspond to.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您审查贵组织的REST API，以了解它们对应哪个级别。
- en: Specifying REST APIs
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 指定REST API
- en: As mentioned earlier in [section 3.1](#ch03lev1sec1), you must define your APIs
    using an interface definition language (IDL). Unlike older communication protocols
    like CORBA and SOAP, REST did not originally have an IDL. Fortunately, the developer
    community has rediscovered the value of an IDL for RESTful APIs. The most popular
    REST IDL is the Open API Specification ([www.openapis.org](http://www.openapis.org)),
    which evolved from the Swagger open source project. The Swagger project is a set
    of tools for developing and documenting REST APIs. It includes tools that generate
    client stubs and server skeletons from an interface definition.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文[第3.1节](#ch03lev1sec1)所述，你必须使用接口定义语言（IDL）来定义你的API。与像CORBA和SOAP这样的旧通信协议不同，REST最初并没有IDL。幸运的是，开发社区重新发现了IDL对RESTful
    API的价值。最受欢迎的REST IDL是Open API规范 ([www.openapis.org](http://www.openapis.org))，它起源于Swagger开源项目。Swagger项目是一套用于开发文档化REST
    API的工具。它包括从接口定义生成客户端存根和服务器骨架的工具。
- en: The challenge of fetching multiple resources in a single request
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在单个请求中检索多个资源的挑战
- en: REST resources are usually oriented around business objects, such as `Consumer`
    and `Order`. Consequently, a common problem when designing a REST API is how to
    enable the client to retrieve multiple related objects in a single request. For
    example, imagine that a REST client wanted to retrieve an `Order` and the `Order`’s
    `Consumer`. A pure REST API would require the client to make at least two requests,
    one for the `Order` and another for its `Consumer`. A more complex scenario would
    require even more round-trips and suffer from excessive latency.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: REST资源通常围绕业务对象，如`Consumer`和`Order`。因此，设计REST API时常见的难题是如何使客户端能够在一个请求中检索多个相关对象。例如，想象一个REST客户端想要检索一个`Order`及其`Order`的`Consumer`。一个纯REST
    API将要求客户端至少发出两个请求，一个用于`Order`，另一个用于其`Consumer`。更复杂的场景可能需要更多的往返，并遭受过度的延迟。
- en: One solution to this problem is for an API to allow the client to retrieve related
    resources when it gets a resource. For example, a client could retrieve an `Order`
    and its `Consumer` using `GET /orders/order-id-1345?expand=consumer`. The query
    parameter specifies the related resources to return with the `Order`. This approach
    works well in many scenarios but it’s often insufficient for more complex scenarios.
    It’s also potentially time consuming to implement. This has led to the increasing
    popularity of alternative API technologies such as GraphQL ([http://graphql.org](http://graphql.org))
    and Netflix Falcor ([http://netflix.github.io/falcor/](http://netflix.github.io/falcor/)),
    which are designed to support efficient data fetching.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是让API允许客户端在获取资源时检索相关资源。例如，客户端可以使用`GET /orders/order-id-1345?expand=consumer`来检索`Order`及其`Consumer`。查询参数指定了与`Order`一起返回的相关资源。这种方法在许多场景下效果良好，但对于更复杂的场景通常是不够的。此外，实现起来可能也很耗时。这导致了像GraphQL
    ([http://graphql.org](http://graphql.org)) 和Netflix Falcor ([http://netflix.github.io/falcor/](http://netflix.github.io/falcor/))
    这样的替代API技术的日益流行，这些技术旨在支持高效的数据检索。
- en: The challenge of mapping operations to HTTP verbs
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将操作映射到HTTP动词的挑战
- en: Another common REST API design problem is how to map the operations you want
    to perform on a business object to an HTTP verb. A REST API should use PUT for
    updates, but there may be multiple ways to update an order, including cancelling
    it, revising the order, and so on. Also, an update might not be idempotent, which
    is a requirement for using PUT. One solution is to define a sub-resource for updating
    a particular aspect of a resource. The `Order Service`, for example, has a `POST
    /orders/{orderId}/cancel` endpoint for cancelling orders, and a `POST /orders/{orderId}/revise`
    endpoint for revising orders. Another solution is to specify a verb as a URL query
    parameter. Sadly, neither solution is particularly RESTful.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的REST API设计问题是如何将你想要在业务对象上执行的操作映射到HTTP动词。REST API应该使用PUT进行更新，但可能有多种更新订单的方式，包括取消订单、修改订单等。此外，更新可能不是幂等的，这是使用PUT的要求。一种解决方案是为更新资源的特定方面定义一个子资源。例如，`Order
    Service`有一个用于取消订单的`POST /orders/{orderId}/cancel`端点，以及一个用于修改订单的`POST /orders/{orderId}/revise`端点。另一种解决方案是将动词指定为URL查询参数。遗憾的是，这两种解决方案都不太符合REST原则。
- en: This problem with mapping operations to HTTP verbs has led to the growing popularity
    of alternatives to REST, such as gPRC, discussed shortly in [section 3.2.2](#ch03lev2sec6).
    But first let’s look at the benefits and drawbacks of REST.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将操作映射到HTTP动词的问题导致了REST替代方案的日益流行，如稍后将在[第3.2.2节](#ch03lev2sec6)中讨论的gPRC。但首先让我们看看REST的好处和缺点。
- en: Benefits and drawbacks of REST
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: REST的好处和缺点
- en: 'There are numerous benefits to using REST:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用REST有许多好处：
- en: It’s simple and familiar.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它简单且熟悉。
- en: You can test an HTTP API from within a browser using, for example, the Postman
    plugin, or from the command line using curl (assuming JSON or some other text
    format is used).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用例如Postman插件在浏览器内测试HTTP API，或者使用curl从命令行测试（假设使用JSON或其他文本格式）。
- en: It directly supports request/response style communication.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它直接支持请求/响应风格的通信。
- en: HTTP is, of course, firewall friendly.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，HTTP是防火墙友好的。
- en: It doesn’t require an intermediate broker, which simplifies the system’s architecture.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不需要中间代理，这简化了系统的架构。
- en: 'There are some drawbacks to using REST:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用REST有一些缺点：
- en: It only supports the request/response style of communication.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仅支持请求/响应风格的通信。
- en: Reduced availability. Because the client and service communicate directly without
    an intermediary to buffer messages, they must both be running for the duration
    of the exchange.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性降低。由于客户端和服务直接通信，没有中间件来缓冲消息，因此它们都必须在交换期间运行。
- en: Clients must know the locations (URLs) of the service instances(s). As described
    in [section 3.2.4](#ch03lev2sec8), this is a nontrivial problem in a modern application.
    Clients must use what is known as a *service discovery mechanism* to locate service
    instances.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端必须知道服务实例的位置（URL）。如[第3.2.4节](#ch03lev2sec8)所述，这在现代应用中是一个非平凡的问题。客户端必须使用所谓的*服务发现机制*来定位服务实例。
- en: Fetching multiple resources in a single request is challenging.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单个请求中检索多个资源具有挑战性。
- en: It’s sometimes difficult to map multiple update operations to HTTP verbs.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个更新操作映射到HTTP动词有时很困难。
- en: Despite these drawbacks, REST seems to be the de facto standard for APIs, though
    there are a couple of interesting alternatives. GraphQL, for example, implements
    flexible, efficient data fetching. [Chapter 8](kindle_split_016.xhtml#ch08) discusses
    GraphQL and covers the API gateway pattern.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些缺点，REST似乎仍然是API的事实标准，尽管有几个有趣的替代方案。例如，GraphQL实现了灵活、高效的数据获取。[第8章](kindle_split_016.xhtml#ch08)讨论了GraphQL并涵盖了API网关模式。
- en: gRPC is another alternative to REST. Let’s take a look at how it works.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC是REST的另一种选择。让我们看看它是如何工作的。
- en: 3.2.2\. Using gRPC
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. 使用gRPC
- en: As mentioned in the preceding section, one challenge with using REST is that
    because HTTP only provides a limited number of verbs, it’s not always straightforward
    to design a REST API that supports multiple update operations. An IPC technology
    that avoids this issue is gRPC ([www.grpc.io](http://www.grpc.io)), a framework
    for writing cross-language clients and servers (see [https://en.wikipedia.org/wiki/Remote_procedure_call](https://en.wikipedia.org/wiki/Remote_procedure_call)
    for more). gRPC is a binary message-based protocol, and this means—as mentioned
    earlier in the discussion of binary message formats—you’re forced to take an API-first
    approach to service design. You define your gRPC APIs using a Protocol Buffers-based
    IDL, which is Google’s language-neutral mechanism for serializing structured data.
    You use the Protocol Buffer compiler to generate client-side stubs and server-side
    skeletons. The compiler can generate code for a variety of languages, including
    Java, C#, NodeJS, and GoLang. Clients and servers exchange binary messages in
    the Protocol Buffers format using HTTP/2.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用REST的一个挑战是，由于HTTP只提供有限数量的动词，因此设计支持多个更新操作的REST API并不总是直接的。避免此问题的IPC技术是gRPC
    ([www.grpc.io](http://www.grpc.io))，这是一个用于编写跨语言客户端和服务器框架（更多内容请参见[https://en.wikipedia.org/wiki/Remote_procedure_call](https://en.wikipedia.org/wiki/Remote_procedure_call)）。gRPC是一个基于二进制消息的协议，这意味着——如前所述，在讨论二进制消息格式时——您被迫采用以API为先的方法来设计服务。您使用基于Protocol
    Buffers的IDL定义您的gRPC API，这是Google的用于序列化结构化数据的中立语言机制。您使用Protocol Buffer编译器生成客户端存根和服务器骨架。编译器可以为包括Java、C#、NodeJS和GoLang在内的多种语言生成代码。客户端和服务器使用HTTP/2在Protocol
    Buffers格式中交换二进制消息。
- en: A gRPC API consists of one or more services and request/response message definitions.
    A *service definition* is analogous to a Java interface and is a collection of
    strongly typed methods. As well as supporting simple request/response RPC, gRPC
    support streaming RPC. A server can reply with a stream of messages to the client.
    Alternatively, a client can send a stream of messages to the server.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC API由一个或多个服务和请求/响应消息定义组成。*服务定义*类似于Java接口，是一组强类型方法的集合。除了支持简单的请求/响应RPC外，gRPC还支持流式RPC。服务器可以向客户端发送消息流作为响应。或者，客户端可以向服务器发送消息流。
- en: gRPC uses Protocol Buffers as the message format. Protocol Buffers is, as mentioned
    earlier, an efficient, compact, binary format. It’s a tagged format. Each field
    of a Protocol Buffers message is numbered and has a type code. A message recipient
    can extract the fields that it needs and skip over the fields that it doesn’t
    recognize. As a result, gRPC enables APIs to evolve while remaining backward-compatible.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC使用Protocol Buffers作为消息格式。正如之前提到的，Protocol Buffers是一种高效、紧凑的二进制格式。它是一种标记格式。Protocol
    Buffers消息的每个字段都进行了编号并具有类型代码。消息接收者可以提取它需要的字段，并跳过它不认识的字段。因此，gRPC使得API在保持向后兼容的同时可以进化。
- en: '[Listing 3.1](#ch03ex01) shows an excerpt of the gRPC API for the `Order Service`.
    It defines several methods, including `createOrder()`. This method takes a `CreateOrderRequest`
    as a parameter and returns a `CreateOrderReply`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表3.1](#ch03ex01)展示了`Order Service`的gRPC API摘录。它定义了包括`createOrder()`在内的几个方法。该方法接受一个`CreateOrderRequest`作为参数，并返回一个`CreateOrderReply`。'
- en: Listing 3.1\. An excerpt of the gRPC API for the `Order Service`
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.1\. `Order Service`的gRPC API摘录
- en: '[PRE1]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`CreateOrderRequest` and `CreateOrderReply` are typed messages. For example,
    `CreateOrderRequest` message has a `restaurantId` field of type `int64`. The field’s
    tag value is 1.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateOrderRequest`和`CreateOrderReply`是类型消息。例如，`CreateOrderRequest`消息有一个类型为`int64`的`restaurantId`字段。该字段的标签值是1。'
- en: 'gRPC has several benefits:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC有以下几个优点：
- en: It’s straightforward to design an API that has a rich set of update operations.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个具有丰富更新操作的API很简单。
- en: It has an efficient, compact IPC mechanism, especially when exchanging large
    messages.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个高效、紧凑的IPC机制，尤其是在交换大消息时。
- en: Bidirectional streaming enables both RPI and messaging styles of communication.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向流支持RPI和消息通信风格。
- en: It enables interoperability between clients and services written in a wide range
    of languages.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得用各种语言编写的客户端和服务之间能够互操作。
- en: 'gRPC also has several drawbacks:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC也有一些缺点：
- en: It takes more work for JavaScript clients to consume gRPC-based API than REST/JSON-based
    APIs.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相比于基于REST/JSON的API，JavaScript客户端消费基于gRPC的API需要更多的工作。
- en: Older firewalls might not support HTTP/2.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较旧的防火墙可能不支持HTTP/2。
- en: gRPC is a compelling alternative to REST, but like REST, it’s a synchronous
    communication mechanism, so it also suffers from the problem of partial failure.
    Let’s take a look at what that is and how to handle it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC是REST的强大替代品，但像REST一样，它也是一种同步通信机制，因此它也面临着部分失败的问题。让我们看看这是什么以及如何处理它。
- en: 3.2.3\. Handling partial failure using the Circuit breaker pattern
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.3\. 使用断路器模式处理部分失败
- en: In a distributed system, whenever a service makes a synchronous request to another
    service, there is an ever-present risk of partial failure. Because the client
    and the service are separate processes, a service may not be able to respond in
    a timely way to a client’s request. The service could be down because of a failure
    or for maintenance. Or the service might be overloaded and responding extremely
    slowly to requests. Because the client is blocked waiting for a response, the
    danger is that the failure could cascade to the client’s clients and so on and
    cause an outage.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，每当一个服务向另一个服务发起同步请求时，总存在部分失败的风险。因为客户端和服务是独立的进程，服务可能无法及时响应客户端的请求。服务可能因为故障或维护而宕机。或者服务可能过载，对请求响应极其缓慢。由于客户端被阻塞等待响应，风险是失败可能会级联到客户端的客户端，等等，从而导致服务中断。
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pattern: Circuit breaker**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：断路器**'
- en: An RPI proxy that immediately rejects invocations for a timeout period after
    the number of consecutive failures exceeds a specified threshold. See [http://microservices.io/patterns/reliability/circuit-breaker.html](http://microservices.io/patterns/reliability/circuit-breaker.html).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当连续失败次数超过指定阈值后，RPI代理会立即拒绝超时期间的调用。参见[http://microservices.io/patterns/reliability/circuit-breaker.html](http://microservices.io/patterns/reliability/circuit-breaker.html)。
- en: '|  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Consider, for example, the scenario shown in [figure 3.2](#ch03fig02), where
    the `Order Service` is unresponsive. A mobile client makes a REST request to an
    API gateway, which, as discussed in [chapter 8](kindle_split_016.xhtml#ch08),
    is the entry point into the application for API clients. The API gateway proxies
    the request to the unresponsive `Order Service`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑[图3.2](#ch03fig02)中所示的场景，其中`Order Service`无响应。移动客户端向API网关发出REST请求，正如[第8章](kindle_split_016.xhtml#ch08)中讨论的，API网关是API客户端进入应用的入口点。API网关将请求代理到无响应的`Order
    Service`。
- en: Figure 3.2\. An API gateway must protect itself from unresponsive services,
    such as the `Order Service`.
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2\. API网关必须保护自己免受无响应服务，如`Order Service`的影响。
- en: '![](Images/03fig02_alt.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig02_alt.jpg)'
- en: A naive implementation of the `OrderServiceProxy` would block indefinitely,
    waiting for a response. Not only would that result in a poor user experience,
    but in many applications it would consume a precious resource, such as a thread.
    Eventually the API gateway would run out of resources and become unable to handle
    requests. The entire API would be unavailable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderServiceProxy`的简单实现会无限期地阻塞，等待响应。这不仅会导致糟糕的用户体验，而且在许多应用中还会消耗宝贵的资源，例如线程。最终，API网关会耗尽资源，无法处理请求。整个API将不可用。'
- en: 'It’s essential that you design your services to prevent partial failures from
    cascading throughout the application. There are two parts to the solution:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你设计的服务能够防止部分失败在整个应用中级联至关重要。解决方案有两个部分：
- en: You must use design RPI proxies, such as `OrderServiceProxy`, to handle unresponsive
    remote services.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须使用设计RPI代理，例如`OrderServiceProxy`，来处理无响应的远程服务。
- en: You need to decide how to recover from a failed remote service.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要决定如何从失败的远程服务中恢复。
- en: First we’ll look at how to write robust RPI proxies.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨如何编写健壮的RPI代理。
- en: Developing robust RPI proxies
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 开发健壮的RPI代理
- en: 'Whenever one service synchronously invokes another service, it should protect
    itself using the approach described by Netflix ([http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html](http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html)).
    This approach consists of a combination of the following mechanisms:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每当某个服务同步调用另一个服务时，它应该使用Netflix([http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html](http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html))描述的方法来保护自己。这种方法包括以下机制的组合：
- en: '***Network timeouts*—** Never block indefinitely and always use timeouts when
    waiting for a response. Using timeouts ensures that resources are never tied up
    indefinitely.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络超时**—**永远不要无限期地阻塞，并且在等待响应时始终使用超时。使用超时可以确保资源不会被无限期地占用。'
- en: '***Limiting the number of outstanding requests from a client to a service*—**
    Impose an upper bound on the number of outstanding requests that a client can
    make to a particular service. If the limit has been reached, it’s probably pointless
    to make additional requests, and those attempts should fail immediately.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制客户端对服务的未完成请求数量**—**对客户端对特定服务可以发出的未完成请求的数量设置上限。如果达到限制，再进行额外的请求可能毫无意义，并且这些尝试应该立即失败。'
- en: '***Circuit breaker pattern*—** Track the number of successful and failed requests,
    and if the error rate exceeds some threshold, trip the circuit breaker so that
    further attempts fail immediately. A large number of requests failing suggests
    that the service is unavailable and that sending more requests is pointless. After
    a timeout period, the client should try again, and, if successful, close the circuit
    breaker.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器模式**—**跟踪成功和失败的请求数量，如果错误率超过某个阈值，则触发断路器，使进一步的尝试立即失败。大量请求失败表明服务不可用，发送更多请求是毫无意义的。在超时期间，客户端应再次尝试，如果成功，则关闭断路器。'
- en: Netflix Hystrix ([https://github.com/Netflix/Hystrix](https://github.com/Netflix/Hystrix))
    is an open source library that implements these and other patterns. If you’re
    using the JVM, you should definitely consider using Hystrix when implementing
    RPI proxies. And if you’re running in a non-JVM environment, you should use an
    equivalent library. For example, the Polly library is popular in the .NET community
    ([https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly)).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Hystrix([https://github.com/Netflix/Hystrix](https://github.com/Netflix/Hystrix))是一个开源库，实现了这些和其他模式。如果您使用JVM，在实现RPI代理时，您绝对应该考虑使用Hystrix。如果您在非JVM环境中运行，您应该使用等效的库。例如，Polly库在.NET社区中很受欢迎([https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly))。
- en: Recovering from an unavailable service
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从不可用的服务中恢复
- en: Using a library such as Hystrix is only part of the solution. You must also
    decide on a case-by-case basis how your services should recover from an unresponsive
    remote service. One option is for a service to simply return an error to its client.
    For example, this approach makes sense for the scenario shown in [figure 3.2](#ch03fig02),
    where the request to create an `Order` fails. The only option is for the API gateway
    to return an error to the mobile client.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Hystrix这样的库只是解决方案的一部分。你还必须根据每个服务的情况决定如何从无响应的远程服务中恢复。一个选项是服务简单地向其客户端返回错误。例如，这种方法对于图3.2中显示的场景是有意义的，其中创建`订单`的请求失败。唯一的选择是API网关向移动客户端返回错误。
- en: In other scenarios, returning a fallback value, such as either a default value
    or a cached response, may make sense. For example, [chapter 7](kindle_split_015.xhtml#ch07)
    describes how the API gateway could implement the `findOrder()` query operation
    by using the API composition pattern. As [figure 3.3](#ch03fig03) shows, its implementation
    of the `GET /orders/{orderId}` endpoint invokes several services, including the
    `Order Service`, `Kitchen Service`, and `Delivery Service`, and combines the results.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他场景中，返回回退值，例如默认值或缓存响应，可能是有意义的。例如，第7章描述了API网关如何通过使用API组合模式实现`findOrder()`查询操作。如图3.3所示，其实现在`GET
    /orders/{orderId}`端点的实现调用包括`订单服务`、`厨房服务`和`配送服务`在内的多个服务，并组合结果。
- en: Figure 3.3\. The API gateway implements the `GET /orders/{orderId}` endpoint
    using API composition. It calls several services, aggregates their responses,
    and sends a response to the mobile app. The code that implements the endpoint
    must have a strategy for handling the failure of each service that it calls.
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3。API网关使用API组合实现了`GET /orders/{orderId}`端点。它调用多个服务，聚合它们的响应，并将响应发送到移动应用程序。实现端点的代码必须有一种处理它所调用每个服务失败的策略。
- en: '![](Images/03fig03_alt.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig03_alt.jpg)'
- en: It’s likely that each service’s data isn’t equally important to the client.
    The data from the `Order Service` is essential. If this service is unavailable,
    the API gateway should return either a cached version of its data or an error.
    The data from the other services is less critical. A client can, for example,
    display useful information to the user even if the delivery status was unavailable.
    If the `Delivery Service` is unavailable, the API gateway should return either
    a cached version of its data or omit it from the response.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能每个服务的数据对客户端的重要性并不相同。`订单服务`的数据是至关重要的。如果这个服务不可用，API网关应该返回其数据的缓存版本或错误。其他服务的数据不太关键。例如，即使配送状态不可用，客户端也可以向用户显示有用的信息。如果`配送服务`不可用，API网关应该返回其数据的缓存版本或从响应中省略它。
- en: It’s essential that you design your services to handle partial failure, but
    that’s not the only problem you need to solve when using RPI. Another problem
    is that in order for one service to invoke another service using RPI, it needs
    to know the network location of a service instance. On the surface this sounds
    simple, but in practice it’s a challenging problem. You must use a service discovery
    mechanism. Let’s look at how that works.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 设计你的服务以处理部分故障是至关重要的，但这并不是在使用RPI时你需要解决的唯一问题。另一个问题是，为了使用RPI调用另一个服务，一个服务需要知道服务实例的网络位置。表面上这听起来很简单，但在实践中这是一个具有挑战性的问题。你必须使用服务发现机制。让我们看看它是如何工作的。
- en: 3.2.4\. Using service discovery
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.4. 使用服务发现
- en: Say you’re writing some code that invokes a service that has a REST API. In
    order to make a request, your code needs to know the network location (IP address
    and port) of a service instance. In a traditional application running on physical
    hardware, the network locations of service instances are usually static. For example,
    your code could read the network locations from a configuration file that’s occasionally
    updated. But in a modern, cloud-based microservices application, it’s usually
    not that simple. As is shown in [figure 3.4](#ch03fig04), a modern application
    is much more dynamic.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一些调用具有REST API的服务的代码。为了发出请求，你的代码需要知道服务实例的网络位置（IP地址和端口）。在一个运行在物理硬件上的传统应用程序中，服务实例的网络位置通常是静态的。例如，你的代码可以从偶尔更新的配置文件中读取网络位置。但在一个现代的基于云的微服务应用程序中，这通常并不那么简单。如图3.4所示，现代应用程序要动态得多。
- en: Figure 3.4\. Service instances have dynamically assigned IP addresses.
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4\. 服务实例具有动态分配的IP地址。
- en: '![](Images/03fig04_alt.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig04_alt.jpg)'
- en: Service instances have dynamically assigned network locations. Moreover, the
    set of service instances changes dynamically because of autoscaling, failures,
    and upgrades. Consequently, your client code must use a service discovery.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 服务实例具有动态分配的网络位置。此外，由于自动扩展、故障和升级，服务实例的集合会动态变化。因此，您的客户端代码必须使用服务发现。
- en: Overview of service discovery
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 服务发现概述
- en: 'As you’ve just seen, you can’t statically configure a client with the IP addresses
    of the services. Instead, an application must use a dynamic service discovery
    mechanism. Service discovery is conceptually quite simple: its key component is
    a service registry, which is a database of the network locations of an application’s
    service instances.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您刚才看到的，您不能使用服务的IP地址静态配置客户端。相反，应用程序必须使用动态服务发现机制。服务发现从概念上讲相当简单：其关键组件是服务注册表，它是应用程序服务实例网络位置的数据库。
- en: The service discovery mechanism updates the service registry when service instances
    start and stop. When a client invokes a service, the service discovery mechanism
    queries the service registry to obtain a list of available service instances and
    routes the request to one of them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现机制在服务实例启动和停止时更新服务注册表。当客户端调用服务时，服务发现机制查询服务注册表以获取可用服务实例的列表，并将请求路由到其中之一。
- en: 'There are two main ways to implement service discovery:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 实现服务发现主要有两种方式：
- en: The services and their clients interact directly with the service registry.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务及其客户端直接与服务注册表交互。
- en: The deployment infrastructure handles service discovery. (I talk more about
    that in [chapter 12](kindle_split_020.xhtml#ch12).)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署基础设施处理服务发现。（我在第12章中谈到了更多关于这一点。）
- en: Let’s look at each option.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个选项。
- en: Applying the application-level service discovery patterns
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用应用程序级服务发现模式
- en: One way to implement service discovery is for the application’s services and
    their clients to interact with the service registry. [Figure 3.5](#ch03fig05)
    shows how this works. A service instance registers its network location with the
    service registry. A service client invokes a service by first querying the service
    registry to obtain a list of service instances. It then sends a request to one
    of those instances.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 实现服务发现的一种方式是让应用程序的服务及其客户端与服务注册表进行交互。[图3.5](#ch03fig05)展示了这是如何工作的。服务实例将其网络位置注册到服务注册表中。服务客户端通过首先查询服务注册表以获取服务实例列表来调用服务。然后，它向这些实例中的一个发送请求。
- en: Figure 3.5\. The service registry keeps track of the service instances. Clients
    query the service registry to find network locations of available service instances.
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.5\. 服务注册表跟踪服务实例。客户端查询服务注册表以找到可用服务实例的网络位置。
- en: '![](Images/03fig05_alt.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig05_alt.jpg)'
- en: This approach to service discovery is a combination of two patterns. The first
    pattern is the Self registration pattern. A service instance invokes the service
    registry’s registration API to register its network location. It may also supply
    a health check URL, described in more detail in [chapter 11](kindle_split_019.xhtml#ch11).
    The *health check* URL is an API endpoint that the service registry invokes periodically
    to verify that the service instance is healthy and available to handle requests.
    A service registry may require a service instance to periodically invoke a “heartbeat”
    API in order to prevent its registration from expiring.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这种服务发现方法结合了两种模式。第一种模式是自动注册模式。服务实例通过调用服务注册表的注册API来注册其网络位置。它还可以提供一个详细的健康检查URL，如第11章中所述。[健康检查](kindle_split_019.xhtml#ch11)
    URL是服务注册表定期调用的API端点，以验证服务实例是否健康且可以处理请求。服务注册表可能要求服务实例定期调用“心跳”API，以防止其注册过期。
- en: '|  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Self registration**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：自动注册**'
- en: A service instance registers itself with the service registry. See [http://microservices.io/patterns/self-registration.html](http://microservices.io/patterns/self-registration.html).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 服务实例将自己注册到服务注册表中。请参阅[http://microservices.io/patterns/self-registration.html](http://microservices.io/patterns/self-registration.html)。
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The second pattern is the Client-side discovery pattern. When a service client
    wants to invoke a service, it queries the service registry to obtain a list of
    the service’s instances. To improve performance, a client might cache the service
    instances. The service client then uses a load-balancing algorithm, such as a
    round-robin or random, to select a service instance. It then makes a request to
    a select service instance.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种模式是客户端发现模式。当服务客户端想要调用一个服务时，它会查询服务注册表以获取该服务的实例列表。为了提高性能，客户端可能会缓存服务实例。然后服务客户端使用负载均衡算法，例如轮询或随机，来选择一个服务实例。然后它向选定的服务实例发出请求。
- en: '|  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Client-side discovery**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：客户端发现**'
- en: A service client retrieves the list of available service instances from the
    service registry and load balances across them. See [http://microservices.io/patterns/client-side-discovery.html](http://microservices.io/patterns/client-side-discovery.html).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 服务客户端从服务注册表中检索可用服务实例的列表，并在它们之间进行负载均衡。请参阅[http://microservices.io/patterns/client-side-discovery.html](http://microservices.io/patterns/client-side-discovery.html)。
- en: '|  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Application-level service discovery has been popularized by Netflix and Pivotal.
    Netflix developed and open sourced several components: Eureka, a highly available
    service registry, the Eureka Java client, and Ribbon, a sophisticated HTTP client
    that supports the Eureka client. Pivotal developed Spring Cloud, a Spring-based
    framework that makes it remarkably easy to use the Netflix components. Spring
    Cloud-based services automatically register with Eureka, and Spring Cloud-based
    clients automatically use Eureka for service discovery.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 应用级服务发现已被Netflix和Pivotal普及。Netflix开发和开源了几个组件：Eureka，一个高度可用的服务注册表，Eureka Java客户端，以及Ribbon，一个支持Eureka客户端的复杂HTTP客户端。Pivotal开发了基于Spring的Spring
    Cloud框架，这使得使用Netflix组件变得非常容易。基于Spring Cloud的服务会自动注册到Eureka，基于Spring Cloud的客户端会自动使用Eureka进行服务发现。
- en: One benefit of application-level service discovery is that it handles the scenario
    when services are deployed on multiple deployment platforms. Imagine, for example,
    you’ve deployed only some of services on Kubernetes, discussed in [chapter 12](kindle_split_020.xhtml#ch12),
    and the rest is running in a legacy environment. Application-level service discovery
    using Eureka, for example, works across both environments, whereas Kubernetes-based
    service discovery only works within Kubernetes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 应用级服务发现的优点之一是它处理了服务部署在多个部署平台上的场景。想象一下，例如，你只将一些服务部署在[第12章](kindle_split_020.xhtml#ch12)中讨论的Kubernetes上，其余的运行在传统环境中。例如，使用Eureka进行的应用级服务发现可以在两个环境中工作，而基于Kubernetes的服务发现仅限于Kubernetes内部。
- en: One drawback of application-level service discovery is that you need a service
    discovery library for every language—and possibly framework—that you use. Spring
    Cloud only helps Spring developers. If you’re using some other Java framework
    or a non-JVM language such as NodeJS or GoLang, you must find some other service
    discovery framework. Another drawback of application-level service discovery is
    that you’re responsible for setting up and managing the service registry, which
    is a distraction. As a result, it’s usually better to use a service discovery
    mechanism that’s provided by the deployment infrastructure.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 应用级服务发现的一个缺点是，你需要为使用的每种语言（以及可能的项目框架）都提供一个服务发现库。Spring Cloud仅帮助Spring开发者。如果你使用的是其他Java框架或非JVM语言，如NodeJS或GoLang，你必须找到其他服务发现框架。应用级服务发现的另一个缺点是你需要负责设置和管理服务注册表，这会分散注意力。因此，通常最好使用由部署基础设施提供的服务发现机制。
- en: Applying the platform-provided service discovery patterns
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用平台提供的服务发现模式
- en: Later in [chapter 12](kindle_split_020.xhtml#ch12) you’ll learn that many modern
    deployment platforms such as Docker and Kubernetes have a built-in service registry
    and service discovery mechanism. The deployment platform gives each service a
    DNS name, a virtual IP (VIP) address, and a DNS name that resolves to the VIP
    address. A service client makes a request to the DNS name/VIP, and the deployment
    platform automatically routes the request to one of the available service instances.
    As a result, service registration, service discovery, and request routing are
    entirely handled by the deployment platform. [Figure 3.6](#ch03fig06) shows how
    this works.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](kindle_split_020.xhtml#ch12)中，你将了解到许多现代部署平台，如Docker和Kubernetes，都内置了服务注册和服务发现机制。部署平台为每个服务分配一个DNS名称、一个虚拟IP（VIP）地址以及解析到VIP地址的DNS名称。服务客户端向DNS名称/VIP发起请求，部署平台自动将请求路由到可用的服务实例之一。因此，服务注册、服务发现和请求路由完全由部署平台处理。[图3.6](#ch03fig06)展示了这是如何工作的。
- en: Figure 3.6\. The platform is responsible for service registration, discovery,
    and request routing. Service instances are registered with the service registry
    by the *registrar*. Each service has a network location, a DNS name/virtual IP
    address. A client makes a request to the service’s network location. The router
    queries the service registry and load balances requests across the available service
    instances.
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.6。平台负责服务注册、发现和请求路由。服务实例由**注册器**注册到服务注册表中。每个服务都有一个网络位置、一个DNS名称/虚拟IP地址。客户端向服务的网络位置发起请求。路由器查询服务注册表并在可用的服务实例之间负载均衡请求。
- en: '![](Images/03fig06_alt.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig06_alt.jpg)'
- en: The deployment platform includes a service registry that tracks the IP addresses
    of the deployed services. In this example, a client accesses the `Order Service`
    using the DNS name `order-service`, which resolves to the virtual IP address `10.1.3.4`.
    The deployment platform automatically load balances requests across the three
    instances of the `Order Service`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 部署平台包含一个服务注册表，跟踪已部署服务的IP地址。在这个例子中，客户端使用DNS名称`order-service`访问`Order Service`，该名称解析为虚拟IP地址`10.1.3.4`。部署平台自动在`Order
    Service`的三个实例之间负载均衡请求。
- en: 'This approach is a combination of two patterns:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法结合了两种模式：
- en: '***3rd party registration pattern*—** Instead of a service registering itself
    with the service registry, a third party called the *registrar*, which is typically
    part of the deployment platform, handles the registration.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***第三方注册模式*—** 不同于服务将自己注册到服务注册表中，一个称为**注册器**的第三方，通常是部署平台的一部分，负责注册。'
- en: '***Server-side discovery pattern*—** Instead of a client querying the service
    registry, it makes a request to a DNS name, which resolves to a request router
    that queries the service registry and load balances requests.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***服务器端发现模式*—** 不同于客户端查询服务注册表，它向一个DNS名称发起请求，该名称解析为一个请求路由器，该路由器查询服务注册表并负载均衡请求。'
- en: '|  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: 3rd party registration**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：第三方注册**'
- en: Service instances are automatically registered with the service registry by
    a third party. See [http://microservices.io/patterns/3rd-party-registration.html](http://microservices.io/patterns/3rd-party-registration.html).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 服务实例由第三方自动注册到服务注册表中。请参阅[http://microservices.io/patterns/3rd-party-registration.html](http://microservices.io/patterns/3rd-party-registration.html)。
- en: '|  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Server-side discovery**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：服务器端发现**'
- en: A client makes a request to a router, which is responsible for service discovery.
    See [http://microservices.io/patterns/server-side-discovery.html](http://microservices.io/patterns/server-side-discovery.html).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端向负责服务发现的**路由器**发起请求。请参阅[http://microservices.io/patterns/server-side-discovery.html](http://microservices.io/patterns/server-side-discovery.html)。
- en: '|  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The key benefit of platform-provided service discovery is that all aspects of
    service discovery are entirely handled by the deployment platform. Neither the
    services nor the clients contain any service discovery code. Consequently, the
    service discovery mechanism is readily available to all services and clients regardless
    of which language or framework they’re written in.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 平台提供的服务发现的关键优势是服务发现的各个方面完全由部署平台处理。服务和客户端都不包含任何服务发现代码。因此，无论服务或客户端是用哪种语言或框架编写的，服务发现机制都可供所有服务和客户端使用。
- en: One drawback of platform-provided service discovery is that it only supports
    the discovery of services that have been deployed using the platform. For example,
    as mentioned earlier when describing application-level discovery, Kubernetes-based
    discovery only works for services running on Kubernetes. Despite this limitation,
    I recommend using platform-provided service discovery whenever possible.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 平台提供的服务发现的一个缺点是它仅支持发现使用该平台部署的服务。例如，如前所述，在描述应用级发现时，基于Kubernetes的发现仅适用于在Kubernetes上运行的服务。尽管存在这种限制，我还是建议尽可能使用平台提供的服务发现。
- en: 'Now that we’ve looked at synchronous IPC using REST or gRPC, let’s take a look
    at the alternative: asynchronous, message-based communication.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了使用REST或gRPC进行的同步IPC，让我们看看另一种选择：基于消息的异步通信。
- en: 3.3\. Communicating using the Asynchronous messaging pattern
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3. 使用异步消息模式进行通信
- en: When using messaging, services communicate by asynchronously exchanging messages.
    A messaging-based application typically uses a *message broker*, which acts as
    an intermediary between the services, although another option is to use a brokerless
    architecture, where the services communicate directly with each other. A service
    client makes a request to a service by sending it a message. If the service instance
    is expected to reply, it will do so by sending a separate message back to the
    client. Because the communication is asynchronous, the client doesn’t block waiting
    for a reply. Instead, the client is written assuming that the reply won’t be received
    immediately.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用消息传递时，服务通过异步交换消息进行通信。基于消息传递的应用程序通常使用一个**消息代理**，它充当服务之间的中介，尽管另一种选择是使用无代理架构，其中服务直接相互通信。服务客户端通过向服务发送消息来向服务发出请求。如果预期服务实例将回复，它将通过向客户端发送一条单独的消息来这样做。因为通信是异步的，所以客户端不会阻塞等待回复。相反，客户端的编写假设回复不会立即收到。
- en: '|  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Messaging**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：消息传递**'
- en: A client invokes a service using asynchronous messaging. See [http://microservices.io/patterns/communication-style/messaging.html](http://microservices.io/patterns/communication-style/messaging.html).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端使用异步消息调用服务。参见[http://microservices.io/patterns/communication-style/messaging.html](http://microservices.io/patterns/communication-style/messaging.html)。
- en: '|  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: I start this section with an overview of messaging. I show how to describe a
    messaging architecture independently of messaging technology. Next I compare and
    contrast brokerless and broker-based architectures and describe the criteria for
    selecting a message broker. I then discuss several important topics, including
    scaling consumers while preserving message ordering, detecting and discarding
    duplicate messages, and sending and receiving messages as part of a database transaction.
    Let’s begin by looking at how messaging works.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我以对消息的概述开始本节。我展示了如何独立于消息技术描述消息架构。接下来，我比较和对比了无代理和基于代理的架构，并描述了选择消息代理的标准。然后，我讨论了几个重要主题，包括在保持消息顺序的同时扩展消费者、检测和丢弃重复消息，以及作为数据库事务一部分发送和接收消息。让我们先看看消息是如何工作的。
- en: 3.3.1\. Overview of messaging
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1. 消息概述
- en: A useful model of messaging is defined in the book *Enterprise Integration Patterns*
    (Addison-Wesley Professional, 2003) by Gregor Hohpe and Bobby Woolf. In this model,
    messages are exchanged over message channels. A sender (an application or service)
    writes a message to a channel, and a receiver (an application or service) reads
    messages from a channel. Let’s look at messages and then look at channels.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gregor Hohpe和Bobby Woolf合著的书籍《企业集成模式》（Addison-Wesley Professional，2003年）中定义了一个有用的消息传递模型。在这个模型中，消息通过消息通道进行交换。发送者（一个应用程序或服务）将消息写入通道，接收者（一个应用程序或服务）从通道读取消息。让我们先看看消息，然后再看看通道。
- en: About messages
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于消息
- en: A message consists of a header and a message body ([www.enterpriseintegrationpatterns.com/Message.html](http://www.enterpriseintegrationpatterns.com/Message.html)).
    The *header* is a collection of name-value pairs, metadata that describes the
    data being sent. In addition to name-value pairs provided by the message’s sender,
    the message header contains name-value pairs, such as a unique *message id* generated
    by either the sender or the messaging infrastructure, and an optional *return
    address*, which specifies the message channel that a reply should be written to.
    The message *body* is the data being sent, in either text or binary format.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 消息由一个头部和消息体组成([www.enterpriseintegrationpatterns.com/Message.html](http://www.enterpriseintegrationpatterns.com/Message.html))。*头部*是一系列名称-值对，是描述正在发送的数据的元数据。除了消息发送者提供的名称-值对之外，消息头部还包含名称-值对，例如由发送方或消息基础设施生成的唯一*消息ID*，以及可选的*返回地址*，它指定了应写入的回复消息通道。消息*体*是正在发送的数据，可以是文本或二进制格式。
- en: 'There are several different kinds of messages:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几种不同类型的消息：
- en: '***Document*—** A generic message that contains only data. The receiver decides
    how to interpret it. The reply to a command is an example of a document message.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***文档*—** 仅包含数据的通用消息。接收方决定如何解释它。命令的回复是一个文档消息的例子。'
- en: '***Command*—** A message that’s the equivalent of an RPC request. It specifies
    the operation to invoke and its parameters.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***命令*—** 与RPC请求等价的消息。它指定要调用的操作及其参数。'
- en: '***Event*—** A message indicating that something notable has occurred in the
    sender. An event is often a domain event, which represents a state change of a
    domain object such as an `Order`, or a `Customer`.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***事件*—** 指示发送方发生了值得注意的事情的消息。事件通常是领域事件，它代表领域对象（如`Order`或`Customer`）的状态变化。'
- en: The approach to the microservice architecture described in this book uses commands
    and events extensively.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所描述的微服务架构方法广泛使用了命令和事件。
- en: Let’s now look at channels, the mechanism by which services communicate.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看通道，这是服务之间通信的机制。
- en: About message channels
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于消息通道
- en: As [figure 3.7](#ch03fig07) shows, messages are exchanged over channels ([www.enterpriseintegrationpatterns.com/MessageChannel.html](http://www.enterpriseintegrationpatterns.com/MessageChannel.html)).
    The business logic in the sender invokes a *sending port* interface, which encapsulates
    the underlying communication mechanism. The *sending port* is implemented by a
    *message sender* adapter class, which sends a message to a receiver via a message
    channel. A *message channel* is an abstraction of the messaging infrastructure.
    A *message handler* adapter class in the receiver is invoked to handle the message.
    It invokes a *receiving port* interface implemented by the consumer’s business
    logic. Any number of senders can send messages to a channel. Similarly, any number
    of receivers can receive messages from a channel.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图3.7](#ch03fig07)所示，消息通过通道([www.enterpriseintegrationpatterns.com/MessageChannel.html](http://www.enterpriseintegrationpatterns.com/MessageChannel.html))进行交换。发送方的业务逻辑调用一个*发送端口*接口，该接口封装了底层的通信机制。*发送端口*由一个*消息发送器*适配器类实现，它通过消息通道向接收方发送消息。*消息通道*是对消息基础设施的一种抽象。接收方的一个*消息处理器*适配器类被调用以处理消息。它调用由消费者的业务逻辑实现的*接收端口*接口。任何数量的发送者可以向通道发送消息。同样，任何数量的接收者都可以从通道接收消息。
- en: Figure 3.7\. The business logic in the sender invokes a sending port interface,
    which is implemented by a message sender adapter. The message sender sends a message
    to a receiver via a message channel. The message channel is an abstraction of
    messaging infrastructure. A message handler adapter in the receiver is invoked
    to handle the message. It invokes the receiving port interface implemented by
    the receiver’s business logic.
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.7。发送方的业务逻辑调用一个发送端口接口，该接口由消息发送器适配器实现。消息发送器通过消息通道向接收方发送消息。消息通道是对消息基础设施的一种抽象。接收方的一个消息处理器适配器被调用以处理消息。它调用由接收方业务逻辑实现的接收端口接口。
- en: '![](Images/03fig07_alt.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig07_alt.jpg)'
- en: 'There are two kinds of channels: point-to-point ([www.enterpriseintegrationpatterns.com/PointToPointChannel.html](http://www.enterpriseintegrationpatterns.com/PointToPointChannel.html))
    and publish-subscribe ([www.enterpriseintegrationpatterns.com/PublishSubscribeChannel.html](http://www.enterpriseintegrationpatterns.com/PublishSubscribeChannel.html)):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的通道：点对点([www.enterpriseintegrationpatterns.com/PointToPointChannel.html](http://www.enterpriseintegrationpatterns.com/PointToPointChannel.html))和发布-订阅([www.enterpriseintegrationpatterns.com/PublishSubscribeChannel.html](http://www.enterpriseintegrationpatterns.com/PublishSubscribeChannel.html))：
- en: A *point-to-point* channel delivers a message to exactly one of the consumers
    that is reading from the channel. Services use point-to-point channels for the
    one-to-one interaction styles described earlier. For example, a command message
    is often sent over a point-to-point channel.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *点对点* 通道将消息发送给从通道中读取的恰好一个消费者。服务使用点对点通道来实现前面描述的一对一交互风格。例如，命令消息通常通过点对点通道发送。
- en: A *publish-subscribe* channel delivers each message to all of the attached consumers.
    Services use publish-subscribe channels for the one-to-many interaction styles
    described earlier. For example, an event message is usually sent over a publish-subscribe
    channel.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *发布-订阅* 通道将每条消息发送给所有附加的消费者。服务使用发布-订阅通道来实现前面描述的一对多交互风格。例如，事件消息通常通过发布-订阅通道发送。
- en: 3.3.2\. Implementing the interaction styles using messaging
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2\. 使用消息实现交互风格
- en: One of the valuable features of messaging is that it’s flexible enough to support
    all the interaction styles described in [section 3.1.1](#ch03lev2sec1). Some interaction
    styles are directly implemented by messaging. Others must be implemented on top
    of messaging.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的一个宝贵特性是它足够灵活，可以支持[第3.1.1节](#ch03lev2sec1)中描述的所有交互风格。一些交互风格可以通过消息直接实现。其他交互风格必须在消息之上实现。
- en: Let’s look at how to implement each interaction style, starting with request/response
    and asynchronous request/response.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现每种交互风格，从请求/响应和异步请求/响应开始。
- en: Implementing request/response and asynchronous request/response
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现请求/响应和异步请求/响应
- en: When a client and service interact using either request/response or asynchronous
    request/response, the client sends a request and the service sends back a reply.
    The difference between the two interaction styles is that with request/response
    the client expects the service to respond immediately, whereas with asynchronous
    request/response there is no such expectation. Messaging is inherently asynchronous,
    so only provides asynchronous request/response. But a client could block until
    a reply is received.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端和服务使用请求/响应或异步请求/响应进行交互时，客户端发送一个请求，服务发送一个回复。这两种交互风格之间的区别在于，在请求/响应中，客户端期望服务立即响应，而在异步请求/响应中则没有这样的期望。消息本质上是异步的，因此只提供异步请求/响应。但是客户端可以阻塞，直到收到回复。
- en: The client and service implement the asynchronous request/response style interaction
    by exchanging a pair of messages. As [figure 3.8](#ch03fig08) shows, the client
    sends a command message, which specifies the operation to perform, and parameters,
    to a point-to-point messaging channel owned by a service. The service processes
    the requests and sends a reply message, which contains the outcome, to a point-to-point
    channel owned by the client.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务通过交换一对消息来实现异步请求/响应风格的交互。如图3.8所示，客户端向服务拥有的点对点消息通道发送一个命令消息，该消息指定要执行的操作和参数。服务处理请求，并将包含结果的回复消息发送到客户端拥有的点对点通道。
- en: Figure 3.8\. Implementing asynchronous request/response by including a reply
    channel and message identifier in the request message. The receiver processes
    the message and sends the reply to the specified reply channel.
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.8\. 通过在请求消息中包含回复通道和消息标识符来实现异步请求/响应。接收者处理消息并将回复发送到指定的回复通道。
- en: '![](Images/03fig08_alt.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8的替代文本](Images/03fig08_alt.jpg)'
- en: The client must tell the service where to send a reply message and must match
    reply messages to requests. Fortunately, solving these two problems isn’t that
    difficult. The client sends a command message that has a *reply channel* header.
    The server writes the reply message, which contains a *correlation id* that has
    the same value as *message identifier*, to the reply channel. The client uses
    the *correlation id* to match the reply message with the request.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端必须告诉服务将回复消息发送到何处，并且必须将回复消息与请求匹配。幸运的是，解决这两个问题并不困难。客户端发送一个带有*回复通道*头的命令消息。服务器将包含与*消息标识符*相同值的*关联ID*的回复消息写入回复通道。客户端使用*关联ID*来匹配回复消息与请求。
- en: Because the client and service communicate using messaging, the interaction
    is inherently asynchronous. In theory, a messaging client could block until it
    receives a reply, but in practice the client will process replies asynchronously.
    What’s more, replies are typically processed by any one of the client’s instances.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于客户端和服务通过消息进行通信，因此交互本质上是异步的。从理论上讲，消息客户端可能会阻塞，直到它收到回复，但在实践中，客户端将异步处理回复。更重要的是，回复通常由客户端的任何实例之一处理。
- en: Implementing one-way notifications
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现单向通知
- en: Implementing one-way notifications is straightforward using asynchronous messaging.
    The client sends a message, typically a command message, to a point-to-point channel
    owned by the service. The service subscribes to the channel and processes the
    message. It doesn’t send back a reply.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步消息实现单向通知很简单。客户端向服务拥有的点对点通道发送消息，通常是命令消息。服务订阅该通道并处理消息。它不会发送回复。
- en: Implementing publish/subscribe
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现发布/订阅
- en: Messaging has built-in support for the publish/subscribe style of interaction.
    A client publishes a message to a publish-subscribe channel that is read by multiple
    consumers. As described in [chapters 4](kindle_split_012.xhtml#ch04) and [5](kindle_split_013.xhtml#ch05),
    services use publish/subscribe to publish domain events, which represent changes
    to domain objects. The service that publishes the domain events owns a publish-subscribe
    channel, whose name is derived from the domain class. For example, the `Order
    Service` publishes `Order` events to an `Order` channel, and the `Delivery Service`
    publishes `Delivery` events to a `Delivery` channel. A service that’s interested
    in a particular domain object’s events only has to subscribe to the appropriate
    channel.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 消息内置了对发布/订阅交互风格的支撑。客户端向由多个消费者读取的发布/订阅通道发布消息。如第[4](kindle_split_012.xhtml#ch04)章和[5](kindle_split_013.xhtml#ch05)章所述，服务使用发布/订阅来发布表示领域对象变化的领域事件。发布领域事件的服务的拥有一个发布/订阅通道，其名称来自领域类。例如，`Order
    Service`将`Order`事件发布到`Order`通道，而`Delivery Service`将`Delivery`事件发布到`Delivery`通道。只对特定领域对象的事件感兴趣的服务只需订阅适当的通道。
- en: Implementing publish/async responses
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现发布/异步响应
- en: The publish/async responses interaction style is a higher-level style of interaction
    that’s implemented by combining elements of publish/subscribe and request/response.
    A client publishes a message that specifies a *reply channel* header to a publish-subscribe
    channel. A consumer writes a reply message containing a *correlation id* to the
    reply channel. The client gathers the responses by using the *correlation id*
    to match the reply messages with the request.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 发布/异步响应交互风格是一种高级交互风格，通过结合发布/订阅和请求/响应的元素来实现。客户端向发布/订阅通道发布一条消息，该消息指定了一个*回复通道*头。消费者将包含*关联ID*的回复消息写入回复通道。客户端通过使用*关联ID*来匹配回复消息与请求来收集响应。
- en: Each service in your application that has an asynchronous API will use one or
    more of these implementation techniques. A service that has an asynchronous API
    for invoking operations will have a message channel for requests. Similarly, a
    service that publishes events will publish them to an event message channel.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中，每个具有异步API的服务都将使用这些实现技术之一或多个。具有用于调用操作异步API的服务将有一个用于请求的消息通道。同样，发布事件的服务会将事件发布到事件消息通道。
- en: As described in [section 3.1.2](#ch03lev2sec2), it’s important to write an API
    specification for a service. Let’s look at how to do that for an asynchronous
    API.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如第[3.1.2节](#ch03lev2sec2)所述，为服务编写API规范非常重要。让我们看看如何为异步API执行此操作。
- en: 3.3.3\. Creating an API specification for a messaging-based service API
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.3. 为基于消息的服务API创建API规范
- en: The specification for a service’s asynchronous API must, as [figure 3.9](#ch03fig09)
    shows, specify the names of the message channels, the message types that are exchanged
    over each channel, and their formats. You must also describe the format of the
    messages using a standard such as JSON, XML, or Protobuf. But unlike with REST
    and Open API, there isn’t a widely adopted standard for documenting the channels
    and the message types. Instead, you need to write an informal document.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的异步API规范必须，如图3.9所示，指定消息通道的名称，每个通道上交换的消息类型及其格式。您还必须使用JSON、XML或Protobuf等标准描述消息的格式。但与REST和Open
    API不同，没有广泛采用的标准来记录通道和消息类型。相反，您需要编写一个非正式的文档。
- en: Figure 3.9\. A service’s asynchronous API consists of message channels and command,
    reply, and event message types.
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.9. 服务的异步API由消息通道和命令、回复和事件消息类型组成。
- en: '![](Images/03fig09_alt.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig09_alt.jpg)'
- en: A service’s asynchronous API consists of operations, invoked by clients, and
    events, published by the services. They’re documented in different ways. Let’s
    take a look at each one, starting with operations.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的异步API由客户端调用的操作和由服务发布的事件组成。它们以不同的方式进行记录。让我们看看每个，从操作开始。
- en: Documenting asynchronous operations
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 记录异步操作
- en: 'A service’s operations can be invoked using one of two different interaction
    styles:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的操作可以使用两种不同的交互风格之一来调用：
- en: '***Request/async response-style API*—** This consists of the service’s command
    message channel, the types and formats of the command message types that the service
    accepts, and the types and formats of the reply messages sent by the service.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***请求/异步响应式API**—** 这包括服务的命令消息通道，服务接受的命令消息类型的类型和格式，以及服务发送的回复消息的类型和格式。'
- en: '***One-way notification-style API*—** This consists of the service’s command
    message channel and the types and format of the command message types that the
    service accepts.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***单向通知式API**—** 这包括服务的命令消息通道和服务接受的命令消息类型的类型和格式。'
- en: A service may use the same request channel for both asynchronous request/response
    and one-way notification.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可能使用相同的请求通道进行异步请求/响应和单向通知。
- en: Documenting published events
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 记录已发布的事件
- en: A service can also publish events using a publish/subscribe interaction style.
    The specification of this style of API consists of the event channel and the types
    and formats of the event messages that are published by the service to the channel.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 服务还可以使用发布/订阅交互风格发布事件。这种API风格的规范包括事件通道和服务向该通道发布的消息类型和格式。
- en: The messages and channels model of messaging is a great abstraction and a good
    way to design a service’s asynchronous API. But in order to implement a service
    you need to choose a messaging technology and determine how to implement your
    design using its capabilities. Let’s take a look at what’s involved.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 消息和通道模型是消息的一个很好的抽象，也是设计服务异步API的好方法。但为了实现服务，您需要选择一个消息技术并确定如何使用其功能来实现您的设计。让我们看看涉及的内容。
- en: 3.3.4\. Using a message broker
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.4. 使用消息代理
- en: A messaging-based application typically uses a *message broker*, an infrastructure
    service through which the service communicates. But a broker-based architecture
    isn’t the only messaging architecture. You can also use a brokerless-based messaging
    architecture, in which the services communicate with one another directly. The
    two approaches, shown in [figure 3.10](#ch03fig10), have different trade-offs,
    but usually a broker-based architecture is a better approach.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 基于消息的应用程序通常使用一个**消息代理**，这是一个服务通过其进行通信的基础设施服务。但基于代理的架构并不是唯一的消息架构。您还可以使用无代理的消息架构，其中服务直接相互通信。这两种方法，如图3.10所示，有不同的权衡，但通常基于代理的架构是更好的方法。
- en: Figure 3.10\. The services in brokerless architecture communicate directly,
    whereas the services in a broker-based architecture communicate via a message
    broker.
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.10. 无代理架构中的服务直接通信，而基于代理架构中的服务通过消息代理进行通信。
- en: '![](Images/03fig10_alt.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig10_alt.jpg)'
- en: This book focuses on broker-based architecture, but it’s worthwhile to take
    a quick look at the brokerless architecture, because there may be scenarios where
    you find it useful.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本书侧重于基于代理的架构，但快速看一下无代理架构是有价值的，因为可能存在您会发现它有用的场景。
- en: Brokerless messaging
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无代理消息
- en: In a brokerless architecture, services can exchange messages directly. ZeroMQ
    ([http://zeromq.org](http://zeromq.org)) is a popular brokerless messaging technology.
    It’s both a specification and a set of libraries for different languages. It supports
    a variety of transports, including TCP, UNIX-style domain sockets, and multicast.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在无代理架构中，服务可以直接交换消息。ZeroMQ ([http://zeromq.org](http://zeromq.org)) 是一种流行的无代理消息技术。它既是一个规范，也是一套支持不同语言的库。它支持多种传输方式，包括TCP、UNIX风格的域套接字和多播。
- en: 'The brokerless architecture has some benefits:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 无代理架构有一些好处：
- en: Allows lighter network traffic and better latency, because messages go directly
    from the sender to the receiver, instead of having to go from the sender to the
    message broker and from there to the receiver
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于消息直接从发送者到接收者，而不是必须从发送者到消息代理再到接收者，因此允许更轻的网络流量和更好的延迟
- en: Eliminates the possibility of the message broker being a performance bottleneck
    or a single point of failure
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除了消息代理成为性能瓶颈或单点故障的可能性
- en: Features less operational complexity, because there is no message broker to
    set up and maintain
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于没有消息代理需要设置和维护，因此具有更少的操作复杂性
- en: 'As appealing as these benefits may seem, brokerless messaging has significant
    drawbacks:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些好处可能很有吸引力，但无代理消息存在显著的缺点：
- en: Services need to know about each other’s locations and must therefore use one
    of the discovery mechanisms describer earlier in [section 3.2.4](#ch03lev2sec8).
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务需要了解彼此的位置，因此必须使用之前在[第3.2.4节](#ch03lev2sec8)中描述的发现机制之一。
- en: It offers reduced availability, because both the sender and receiver of a message
    must be available while the message is being exchanged.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于消息的发送者和接收者必须在消息交换期间都可用，因此它提供了降低的可用性
- en: Implementing mechanisms, such as guaranteed delivery, is more challenging.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现机制，如保证交付，更具挑战性。
- en: In fact, some of these drawbacks, such as reduced availability and the need
    for service discovery, are the same as when using synchronous, response/response.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这些缺点中的一些，如降低的可用性和服务发现的需求，与使用同步、请求/响应相同。
- en: Because of these limitations, most enterprise applications use a message broker-based
    architecture. Let’s look at how that works.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些限制，大多数企业应用程序使用基于消息代理的架构。让我们看看它是如何工作的。
- en: Overview of broker-based messaging
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于代理的消息概述
- en: A message broker is an intermediary through which all messages flow. A sender
    writes the message to the message broker, and the message broker delivers it to
    the receiver. An important benefit of using a message broker is that the sender
    doesn’t need to know the network location of the consumer. Another benefit is
    that a message broker buffers messages until the consumer is able to process them.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理是一个中介，所有消息都通过它流动。发送者将消息写入消息代理，然后消息代理将其传递给接收者。使用消息代理的一个重要好处是发送者不需要知道消费者的网络位置。另一个好处是消息代理可以缓冲消息，直到消费者能够处理它们。
- en: 'There are many message brokers to chose from. Examples of popular open source
    message brokers include the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多消息代理可供选择。以下是一些流行的开源消息代理的例子：
- en: ActiveMQ ([http://activemq.apache.org](http://activemq.apache.org))
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ActiveMQ ([http://activemq.apache.org](http://activemq.apache.org))
- en: RabbitMQ ([https://www.rabbitmq.com](https://www.rabbitmq.com))
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ ([https://www.rabbitmq.com](https://www.rabbitmq.com))
- en: Apache Kafka ([http://kafka.apache.org](http://kafka.apache.org))
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Kafka ([http://kafka.apache.org](http://kafka.apache.org))
- en: There are also cloud-based messaging services, such as AWS Kinesis ([https://aws.amazon.com/kinesis/](https://aws.amazon.com/kinesis/))
    and AWS SQS ([https://aws.amazon.com/sqs/](https://aws.amazon.com/sqs/)).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有基于云的消息服务，例如AWS Kinesis ([https://aws.amazon.com/kinesis/](https://aws.amazon.com/kinesis/))
    和 AWS SQS ([https://aws.amazon.com/sqs/](https://aws.amazon.com/sqs/))。
- en: 'When selecting a message broker, you have various factors to consider, including
    the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择消息代理时，你需要考虑各种因素，包括以下内容：
- en: '***Supported programming languages*—** You probably should pick one that supports
    a variety of programming languages.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***支持的编程语言*—** 你可能应该选择支持多种编程语言的。'
- en: '***Supported messaging standards*—** Does the message broker support any standards,
    such as AMQP and STOMP, or is it proprietary?'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***支持的消息标准*—** 消息代理是否支持任何标准，如AMQP和STOMP，或者它是专有的？'
- en: '***Messaging ordering*—** Does the message broker preserve ordering of messages?'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***消息排序*—** 消息代理是否保留消息的顺序？'
- en: '***Delivery guarantees*—** What kind of delivery guarantees does the broker
    make?'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投递保证**—**代理提供什么样的投递保证？**'
- en: '***Persistence*—** Are messages persisted to disk and able to survive broker
    crashes?'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**—**消息是否持久化到磁盘并且能够在代理崩溃后存活？**'
- en: '***Durability*—** If a consumer reconnects to the message broker, will it receive
    the messages that were sent while it was disconnected?'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**—**如果消费者重新连接到消息代理，它是否会收到在断开连接期间发送的消息？**'
- en: '***Scalability*—** How scalable is the message broker?'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**—**消息代理的可扩展性如何？**'
- en: '***Latency*—** What is the end-to-end latency?'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**—**端到端延迟是多少？**'
- en: '***Competing consumers*—** Does the message broker support competing consumers?'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞争消费者**—**消息代理支持竞争消费者吗？**'
- en: Each broker makes different trade-offs. For example, a very low-latency broker
    might not preserve ordering, make no guarantees to deliver messages, and only
    store messages in memory. A messaging broker that guarantees delivery and reliably
    stores messages on disk will probably have higher latency. Which kind of message
    broker is the best fit depends on your application’s requirements. It’s even possible
    that different parts of your application will have different messaging requirements.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 每个代理都会做出不同的权衡。例如，一个低延迟的代理可能不会保持顺序，不保证投递消息，并且只在内存中存储消息。一个保证投递并可靠地将消息存储在磁盘上的消息代理可能会具有更高的延迟。哪种类型的消息代理最适合取决于您的应用程序需求。甚至可能您的应用程序的不同部分会有不同的消息需求。
- en: It’s likely, though, that messaging ordering and scalability are essential.
    Let’s now look at how to implement message channels using a message broker.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，消息排序和可扩展性可能是至关重要的。现在让我们看看如何使用消息代理实现消息通道。
- en: Implementing message channels using a message broker
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用消息代理实现消息通道
- en: Each message broker implements the message channel concept in a different way.
    As [table 3.2](#ch03table02) shows, JMS message brokers such as ActiveMQ have
    queues and topics. AMQP-based message brokers such as RabbitMQ have exchanges
    and queues. Apache Kafka has topics, AWS Kinesis has streams, and AWS SQS has
    queues. What’s more, some message brokers offer more flexible messaging than the
    message and channels abstraction described in this chapter.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 每个消息代理以不同的方式实现消息通道的概念。如表3.2所示，ActiveMQ等JMS消息代理有队列和主题。基于AMQP的代理，如RabbitMQ，有交换机和队列。Apache
    Kafka有主题，AWS Kinesis有流，AWS SQS有队列。更重要的是，一些消息代理提供的消息传递比本章中描述的消息和通道抽象更灵活。
- en: Table 3.2\. Each message broker implements the message channel concept in a
    different way.
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.2。每个消息代理以不同的方式实现消息通道的概念。
- en: '| Message broker | Point-to-point channel | Publish-subscribe channel |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 消息代理 | 点对点通道 | 发布/订阅通道 |'
- en: '| --- | --- | --- |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| JMS | Queue | Topic |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| JMS | 队列 | 主题 |'
- en: '| Apache Kafka | Topic | Topic |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| Apache Kafka | 主题 | 主题 |'
- en: '| AMQP-based brokers, such as RabbitMQ | Exchange + Queue | Fanout exchange
    and a queue per consumer |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| 基于 AMQP 的代理，如 RabbitMQ | 交换机 + 队列 | 广播交换机以及每个消费者的队列 |'
- en: '| AWS Kinesis | Stream | Stream |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| AWS Kinesis | 流 | 流 |'
- en: '| AWS SQS | Queue | — |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| AWS SQS | 队列 | — |'
- en: Almost all the message brokers described here support both point-to-point and
    publish-subscribe channels. The one exception is AWS SQS, which only supports
    point-to-point channels.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有这里描述的消息代理都支持点对点和发布/订阅通道。唯一的例外是AWS SQS，它只支持点对点通道。
- en: Now let’s look at the benefits and drawbacks of broker-based messaging.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看基于代理的消息传递的优缺点。
- en: Benefits and drawbacks of broker-based messaging
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于代理的消息传递的优缺点
- en: 'There are many advantages to using broker-based messaging:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于代理的消息传递有许多优点：
- en: '***Loose coupling*—** A client makes a request by simply sending a message
    to the appropriate channel. The client is completely unaware of the service instances.
    It doesn’t need to use a discovery mechanism to determine the location of a service
    instance.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松散耦合**—**客户端通过向适当的通道发送消息来发出请求。客户端完全不知道服务实例。它不需要使用发现机制来确定服务实例的位置。**'
- en: '***Message buffering*—** The message broker buffers messages until they can
    be processed. With a synchronous request/response protocol such as HTTP, both
    the client and service must be available for the duration of the exchange. With
    messaging, though, messages will queue up until they can be processed by the consumer.
    This means, for example, that an online store can accept orders from customers
    even when the order-fulfillment system is slow or unavailable. The messages will
    simply queue up until they can be processed.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***消息缓冲*—** 消息代理将消息缓冲起来，直到它们可以被处理。在同步请求/响应协议（如HTTP）中，客户端和服务必须在交换期间都可用。然而，在消息传递中，消息将排队直到它们可以被消费者处理。这意味着，例如，即使订单履行系统缓慢或不可用，在线商店也可以接受客户的订单。消息将简单地排队，直到它们可以被处理。'
- en: '***Flexible communication*—** Messaging supports all the interaction styles
    described earlier.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***灵活的通信*—** 消息传递支持前面描述的所有交互样式。'
- en: '***Explicit interprocess communication*—** RPC-based mechanism attempts to
    make invoking a remote service look the same as calling a local service. But due
    to the laws of physics and the possibility of partial failure, they’re in fact
    quite different. Messaging makes these differences very explicit, so developers
    aren’t lulled into a false sense of security.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***显式的进程间通信*—** 基于RPC的机制试图使调用远程服务看起来与调用本地服务相同。但由于物理定律和部分失败的可能性，它们实际上相当不同。消息传递使得这些差异非常明确，因此开发者不会陷入虚假的安全感。'
- en: 'There are some downsides to using messaging:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息传递有一些缺点：
- en: '***Potential performance bottleneck*—** There is a risk that the message broker
    could be a performance bottleneck. Fortunately, many modern message brokers are
    designed to be highly scalable.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***潜在的性能瓶颈*—** 消息代理可能成为性能瓶颈。幸运的是，许多现代消息代理都设计为高度可扩展。'
- en: '***Potential single point of failure*—** It’s essential that the message broker
    is highly available—otherwise, system reliability will be impacted. Fortunately,
    most modern brokers have been designed to be highly available.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***潜在的单一故障点*—** 消息代理必须高度可用，这是至关重要的——否则，系统可靠性将受到影响。幸运的是，大多数现代代理都已被设计为高度可用。'
- en: '***Additional operational complexity*—** The messaging system is yet another
    system component that must be installed, configured, and operated.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***额外的操作复杂性*—** 消息系统是必须安装、配置和运行的另一个系统组件。'
- en: Let’s look at some design issues you might face.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你可能会遇到的一些设计问题。
- en: 3.3.5\. Competing receivers and message ordering
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.5. 竞争接收器和消息顺序
- en: One challenge is how to scale out message receivers while preserving message
    ordering. It’s a common requirement to have multiple instances of a service in
    order to process messages concurrently. Moreover, even a single service instance
    will probably use threads to concurrently process multiple messages. Using multiple
    threads and service instances to concurrently process messages increases the throughput
    of the application. But the challenge with processing messages concurrently is
    ensuring that each message is processed once and in order.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一个挑战是如何在保持消息顺序的同时扩展消息接收器。为了并发处理消息，通常需要多个服务实例。此外，即使单个服务实例也可能使用线程来并发处理多个消息。使用多个线程和服务实例并发处理消息可以增加应用程序的吞吐量。但并发处理消息的挑战在于确保每个消息只被处理一次，并且按照顺序处理。
- en: For example, imagine that there are three instances of a service reading from
    the same point-to-point channel and that a sender publishes `Order Created`, `Order
    Updated`, and `Order Cancelled` event messages sequentially. A simplistic messaging
    implementation could concurrently deliver each message to a different receiver.
    Because of delays due to network issues or garbage collections, messages might
    be processed out of order, which would result in strange behavior. In theory,
    a service instance might process the `Order Cancelled` message before another
    service processes the `Order Created` message!
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象有三个服务实例从同一个点对点通道读取，并且发送者按顺序发布`Order Created`、`Order Updated`和`Order Cancelled`事件消息。一个简单的消息实现可能会并发地将每条消息发送给不同的接收者。由于网络问题或垃圾回收导致的延迟，消息可能会以错误的顺序处理，这可能导致奇怪的行为。理论上，一个服务实例可能会在另一个服务处理`Order
    Created`消息之前处理`Order Cancelled`消息！
- en: 'A common solution, used by modern message brokers like Apache Kafka and AWS
    Kinesis, is to use *sharded* (partitioned) channels. [Figure 3.11](#ch03fig11)
    shows how this works. There are three parts to the solution:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的解决方案，由现代消息代理如Apache Kafka和AWS Kinesis使用，是使用*分片*（分区）通道。[图3.11](#ch03fig11)展示了这是如何工作的。该解决方案有三个部分：
- en: A sharded channel consists of two or more shards, each of which behaves like
    a channel.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分片通道由两个或多个分片组成，每个分片的行为都像一个通道。
- en: The sender specifies a shard key in the message’s header, which is typically
    an arbitrary string or sequence of bytes. The message broker uses a shard key
    to assign the message to a particular shard/partition. It might, for example,
    select the shard by computing the hash of the shard key modulo the number of shards.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送者在消息头中指定一个分片键，这通常是一个任意字符串或字节序列。消息代理使用分片键将消息分配给特定的分片/分区。例如，它可能通过计算分片键的哈希值模分片数来选择分片。
- en: The messaging broker groups together multiple instances of a receiver and treats
    them as the same logical receiver. Apache Kafka, for example, uses the term *consumer
    group*. The message broker assigns each shard to a single receiver. It reassigns
    shards when receivers start up and shut down.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息代理将多个接收器实例组合在一起，并将它们视为同一个逻辑接收器。例如，Apache Kafka使用术语*消费者组*。消息代理将每个分片分配给单个接收器。当接收器启动和关闭时，它会重新分配分片。
- en: Figure 3.11\. Scaling consumers while preserving message ordering by using a
    sharded (partitioned) message channel. The sender includes the shard key in the
    message. The message broker writes the message to a shard determined by the shard
    key. The message broker assigns each partition to an instance of the replicated
    receiver.
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.11\. 通过使用分片（分区）消息通道在扩展消费者时保持消息排序。发送者在消息中包含分片键。消息代理将消息写入由分片键确定的分片。消息代理将每个分区分配给复制接收器的单个实例。
- en: '![](Images/03fig11_alt.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig11_alt.jpg)'
- en: In this example, each `Order` event message has the `orderId` as its shard key.
    Each event for a particular order is published to the same shard, which is read
    by a single consumer instance. As a result, these messages are guaranteed to be
    processed in order.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个`Order`事件消息的`orderId`作为其分片键。特定订单的每个事件都发布到同一个分片，由单个消费者实例读取。因此，这些消息保证按顺序处理。
- en: 3.3.6\. Handling duplicate messages
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.6\. 处理重复消息
- en: Another challenge you must tackle when using messaging is dealing with duplicate
    messages. A message broker should ideally deliver each message only once, but
    guaranteeing exactly-once messaging is usually too costly. Instead, most message
    brokers promise to deliver a message *at least* once.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用消息传递时，你必须解决的另一个挑战是处理重复消息。理想情况下，消息代理应该只投递每条消息一次，但保证恰好一次投递通常成本太高。相反，大多数消息代理承诺至少投递一条消息。
- en: When the system is working normally, a message broker that guarantees at-least-once
    delivery will deliver each message only once. But a failure of a client, network,
    or message broker can result in a message being delivered multiple times. Say
    a client crashes after processing a message and updating its database—but before
    acknowledging the message. The message broker will deliver the unacknowledged
    message again, either to that client when it restarts or to another replica of
    the client.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统正常运行时，保证至少一次投递的消息代理将每条消息只投递一次。但是，客户端、网络或消息代理的故障可能导致消息被多次投递。假设一个客户端在处理消息并更新其数据库后崩溃，但在确认消息之前。消息代理将再次投递未确认的消息，要么在客户端重启时投递给该客户端，要么投递给客户端的另一个副本。
- en: Ideally, you should use a message broker that preserves ordering when redelivering
    messages. Imagine that the client processes an `Order Created` event followed
    by an `Order Cancelled` event for the same `Order`, and that somehow the `Order
    Created` event wasn’t acknowledged. The message broker should redeliver both the
    `Order Created` and `Order Cancelled` events. If it only redelivers the `Order
    Created`, the client may undo the cancelling of the `Order`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该使用在重新投递消息时保留排序的消息代理。想象一下，客户端处理了一个`Order Created`事件，然后处理了同一订单的`Order
    Cancelled`事件，但`Order Created`事件没有被确认。消息代理应该重新投递`Order Created`和`Order Cancelled`事件。如果它只重新投递`Order
    Created`，客户端可能会撤销取消订单的操作。
- en: 'There are a couple of different ways to handle duplicate messages:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 处理重复消息有几种不同的方法：
- en: Write idempotent message handlers.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写幂等消息处理器。
- en: Track messages and discard duplicates.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪消息并丢弃重复项。
- en: Let’s look at each option.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看每个选项。
- en: Writing idempotent message handlers
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写幂等消息处理器
- en: If the application logic that processes messages is idempotent, then duplicate
    messages are harmless. Application logic is *idempotent* if calling it multiple
    times with the same input values has no additional effect. For instance, cancelling
    an already-cancelled order is an idempotent operation. So is creating an order
    with a client-supplied ID. An idempotent message handler can be safely executed
    multiple times, provided that the message broker preserves ordering when redelivering
    messages.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理消息的应用程序逻辑是幂等的，那么重复的消息是无害的。如果多次以相同的输入值调用它没有额外的效果，则应用程序逻辑是*幂等的*。例如，取消已取消的订单是一个幂等操作。创建带有客户端提供的ID的订单也是如此。只要消息代理在重新投递消息时保持顺序，幂等的消息处理器就可以安全地多次执行。
- en: Unfortunately, application logic is often not idempotent. Or you may be using
    a message broker that doesn’t preserve ordering when redelivering messages. Duplicate
    or out-of-order messages can cause bugs. In this situation, you must write message
    handlers that track messages and discard duplicate messages.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，应用程序逻辑通常不是幂等的。或者你可能使用的是一个在重新投递消息时不保留顺序的消息代理。重复或顺序错误的消息可能导致错误。在这种情况下，你必须编写跟踪消息和丢弃重复消息的消息处理器。
- en: Tracking messages and discarding duplicates
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 跟踪消息和丢弃重复项
- en: Consider, for example, a message handler that authorizes a consumer credit card.
    It must authorize the card exactly once for each order. This example of application
    logic has a different effect each time it’s invoked. If duplicate messages caused
    the message handler to execute this logic multiple times, the application would
    behave incorrectly. The message handler that executes this kind of application
    logic must become idempotent by detecting and discarding duplicate messages.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个授权消费者信用卡的消息处理器。它必须为每个订单恰好授权一次卡。这个应用程序逻辑的例子每次被调用时都有不同的效果。如果重复的消息导致消息处理器多次执行此逻辑，应用程序的行为将不正确。执行此类应用程序逻辑的消息处理器必须通过检测和丢弃重复消息来成为幂等的。
- en: A simple solution is for a message consumer to track the messages that it has
    processed using the `message id` and discard any duplicates. It could, for example,
    store the `message id` of each message that it consumed in a database table. [Figure
    3.12](#ch03fig12) shows how to do this using a dedicated table.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方案是消息消费者使用`消息ID`跟踪它已处理的消息，并丢弃任何重复项。例如，它可以在数据库表中存储它消耗的每个消息的`消息ID`。[图3.12](#ch03fig12)展示了如何使用专用表来实现这一点。
- en: Figure 3.12\. A consumer detects and discards duplicate messages by recording
    the IDs of processed messages in a database table. If a message has been processed
    before, the INSERT into the PROCESSED_MESSAGES table will fail.
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.12。消费者通过在数据库表中记录已处理消息的ID来检测和丢弃重复消息。如果消息之前已被处理，向`PROCESSED_MESSAGES`表的`INSERT`操作将失败。
- en: '![](Images/03fig12_alt.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig12_alt.jpg)'
- en: When a consumer handles a message, it records the `message id` in the database
    table as part of the transaction that creates and updates business entities. In
    this example, the consumer inserts a row containing the `message id` into a `PROCESSED_MESSAGES`
    table. If a message is a duplicate, the `INSERT` will fail and the consumer can
    discard the message.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当消费者处理消息时，它将`消息ID`记录在数据库表中，作为创建和更新业务实体的事务的一部分。在这个例子中，消费者将包含`消息ID`的行插入到`PROCESSED_MESSAGES`表中。如果消息是重复的，`INSERT`操作将失败，消费者可以丢弃该消息。
- en: Another option is for a message handler to record `message id`s in an application
    table instead of a dedicated table. This approach is particularly useful when
    using a NoSQL database that has a limited transaction model, so it doesn’t support
    updating two tables as part of a database transaction. [Chapter 7](kindle_split_015.xhtml#ch07)
    shows an example of this approach.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是消息处理器在应用表中而不是专用表中记录`消息ID`。当使用具有有限事务模型的NoSQL数据库时，这种方法特别有用，因为它不支持在数据库事务中更新两个表。[第7章](kindle_split_015.xhtml#ch07)展示了这种方法的一个例子。
- en: 3.3.7\. Transactional messaging
  id: totrans-368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.7. 事务性消息
- en: A service often needs to publish messages as part of a transaction that updates
    the database. For instance, throughout this book you see examples of services
    that publish domain events whenever they create or update business entities. Both
    the database update and the sending of the message must happen within a transaction.
    Otherwise, a service might update the database and then crash, for example, before
    sending the message. If the service doesn’t perform these two operations atomically,
    a failure could leave the system in an inconsistent state.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务通常需要在更新数据库的事务中发布消息。例如，在这本书的整个过程中，你都会看到服务在创建或更新业务实体时发布领域事件的示例。数据库更新和发送消息都必须在事务内完成。否则，服务可能在发送消息之前更新数据库并崩溃，例如。如果服务没有原子地执行这两个操作，失败可能会导致系统处于不一致的状态。
- en: The traditional solution is to use a distributed transaction that spans the
    database and the message broker. But as you’ll learn in [chapter 4](kindle_split_012.xhtml#ch04),
    distributed transactions aren’t a good choice for modern applications. Moreover,
    many modern brokers such as Apache Kafka don’t support distributed transactions.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的解决方案是使用跨越数据库和消息代理的分布式事务。但正如你将在第4章（kindle_split_012.xhtml#ch04）中了解到的那样，分布式事务并不是现代应用程序的好选择。此外，许多现代代理，如Apache
    Kafka，不支持分布式事务。
- en: As a result, an application must use a different mechanism to reliably publish
    messages. Let’s look at how that works.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应用程序必须使用不同的机制来可靠地发布消息。让我们看看它是如何工作的。
- en: Using a database table as a message queue
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用数据库表作为消息队列
- en: Let’s imagine that your application is using a relational database. A straightforward
    way to reliably publish messages is to apply the Transactional outbox pattern.
    This pattern uses a database table as a temporary message queue. As [figure 3.13](#ch03fig13)
    shows, a service that sends messages has an `OUTBOX` database table. As part of
    the database transaction that creates, updates, and deletes business objects,
    the service sends messages by inserting them into the `OUTBOX` table. Atomicity
    is guaranteed because this is a local ACID transaction.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你的应用程序正在使用关系型数据库。一种可靠发布消息的简单方法是应用事务性输出队列模式。该模式使用数据库表作为临时消息队列。如图3.13所示，发送消息的服务有一个`OUTBOX`数据库表。作为创建、更新和删除业务对象的数据库事务的一部分，服务通过将消息插入`OUTBOX`表来发送消息。原子性得到保证，因为这是一个本地ACID事务。
- en: Figure 3.13\. A service reliably publishes a message by inserting it into an
    `OUTBOX` table as part of the transaction that updates the database. The `Message
    Relay` reads the `OUTBOX` table and publishes the messages to a message broker.
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.13。一个服务通过将消息插入更新数据库的事务中的`OUTBOX`表来可靠地发布消息。`Message Relay`读取`OUTBOX`表并将消息发布到消息代理。
- en: '![](Images/03fig13_alt.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig13_alt.jpg)'
- en: The `OUTBOX` table acts a temporary message queue. The `MessageRelay` is a component
    that reads the `OUTBOX` table and publishes the messages to a message broker.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`OUTBOX`表充当临时消息队列。`MessageRelay`是一个组件，它读取`OUTBOX`表并将消息发布到消息代理。'
- en: '|  |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Transactional outbox**'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：事务性输出队列**'
- en: Publish an event or message as part of a database transaction by saving it in
    an `OUTBOX` in the database. See [http://microservices.io/patterns/data/transactional-outbox.html](http://microservices.io/patterns/data/transactional-outbox.html).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在数据库中的`OUTBOX`中保存事件或消息作为数据库事务的一部分来发布事件或消息。请参阅[http://microservices.io/patterns/data/transactional-outbox.html](http://microservices.io/patterns/data/transactional-outbox.html)。
- en: '|  |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You can use a similar approach with some NoSQL databases. Each business entity
    stored as a `record` in the database has an attribute that is a list of messages
    that need to be published. When a service updates an entity in the database, it
    appends a message to that list. This is atomic because it’s done with a single
    database operation. The challenge, though, is efficiently finding those business
    entities that have events and publishing them.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类似的方法与一些NoSQL数据库一起使用。每个存储在数据库中作为`record`的业务实体都有一个属性，该属性是需要发布的消息列表。当服务更新数据库中的实体时，它会将一条消息追加到该列表中。这是原子的，因为它通过单个数据库操作完成。然而，挑战在于高效地找到具有事件的业务实体并将它们发布出去。
- en: There are a couple of different ways to move messages from the database to the
    message broker. We’ll look at each one.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 将消息从数据库移动到消息代理有几种不同的方法。我们将逐一查看。
- en: Publishing events by using the Polling publisher pattern
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过轮询发布者模式发布事件
- en: 'If the application uses a relational database, a very simple way to publish
    the messages inserted into the `OUTBOX` table is for the `MessageRelay` to poll
    the table for unpublished messages. It periodically queries the table:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序使用关系型数据库，一个发布`OUTBOX`表中插入的消息的非常简单的方法是让`MessageRelay`轮询表以查找未发布消息。它定期查询表：
- en: '[PRE2]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, the `MessageRelay` publishes those messages to the message broker, sending
    one to its destination message channel. Finally, it deletes those messages from
    the `OUTBOX` table:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`MessageRelay`将这些消息发布到消息代理，将一条消息发送到其目标消息通道。最后，它从`OUTBOX`表中删除这些消息：
- en: '[PRE3]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|  |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pattern: Polling publisher**'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：轮询发布者**'
- en: Publish messages by polling the outbox in the database. See [http://microservices.io/patterns/data/polling-publisher.html](http://microservices.io/patterns/data/polling-publisher.html).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 通过轮询数据库中的`OUTBOX`来发布消息。参见[http://microservices.io/patterns/data/polling-publisher.html](http://microservices.io/patterns/data/polling-publisher.html)。
- en: '|  |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Polling the database is a simple approach that works reasonably well at low
    scale. The downside is that frequently polling the database can be expensive.
    Also, whether you can use this approach with a NoSQL database depends on its querying
    capabilities. That’s because rather than querying an `OUTBOX` table, the application
    must query the business entities, and that may or may not be possible to do efficiently.
    Because of these drawbacks and limitations, it’s often better—and in some cases,
    necessary—to use the more sophisticated and performant approach of tailing the
    database transaction log.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询数据库是一种简单的方法，在低规模下效果相当不错。缺点是频繁轮询数据库可能会很昂贵。此外，您是否可以使用此方法与NoSQL数据库一起使用取决于其查询能力。这是因为，而不是查询`OUTBOX`表，应用程序必须查询业务实体，这可能或可能无法高效地完成。由于这些缺点和限制，通常更好的做法——在某些情况下，这是必要的——是使用更复杂且性能更好的方法，即跟踪数据库事务日志。
- en: Publishing events by applying the Transaction log tailing pattern
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过应用事务日志跟踪模式发布事件
- en: A sophisticated solution is for `MessageRelay` to *tail* the database transaction
    log (also called the commit log). Every committed update made by an application
    is represented as an entry in the database’s transaction log. A transaction log
    miner can read the transaction log and publish each change as a message to the
    message broker. [Figure 3.14](#ch03fig14) shows how this approach works.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 一个复杂的解决方案是让`MessageRelay`跟踪数据库事务日志（也称为提交日志）。应用程序所做的每个提交更新都表示为数据库事务日志中的一个条目。事务日志挖掘器可以读取事务日志，并将每个更改作为消息发布到消息代理。[图3.14](#ch03fig14)展示了这种方法是如何工作的。
- en: Figure 3.14\. A service publishes messages inserted into the `OUTBOX` table
    by mining the database’s transaction log.
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.14。一个服务通过挖掘数据库的事务日志来发布插入到`OUTBOX`表中的消息。
- en: '![](Images/03fig14_alt.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig14_alt.jpg)'
- en: The `Transaction Log Miner` reads the transaction log entries. It converts each
    relevant log entry corresponding to an inserted message into a message and publishes
    that message to the message broker. This approach can be used to publish messages
    written to an `OUTBOX` table in an RDBMS or messages appended to records in a
    NoSQL database.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`事务日志挖掘器`读取事务日志条目。它将每个与插入消息相对应的相关日志条目转换为消息，并将该消息发布到消息代理。这种方法可以用来发布写入关系型数据库的`OUTBOX`表中的消息或追加到NoSQL数据库记录中的消息。'
- en: '|  |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pattern: Transaction log tailing**'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：事务日志跟踪**'
- en: Publish changes made to the database by tailing the transaction log. See [http://microservices.io/patterns/data/transaction-log-tailing.html](http://microservices.io/patterns/data/transaction-log-tailing.html).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 通过跟踪事务日志来发布对数据库所做的更改。参见[http://microservices.io/patterns/data/transaction-log-tailing.html](http://microservices.io/patterns/data/transaction-log-tailing.html)。
- en: '|  |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'There are a few examples of this approach in use:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个使用此方法的例子：
- en: '*Debezium* ([http://debezium.io](http://debezium.io))—An open source project
    that publishes database changes to the Apache Kafka message broker.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Debezium* ([http://debezium.io](http://debezium.io))——一个开源项目，将数据库更改发布到Apache
    Kafka消息代理。'
- en: '*LinkedIn Databus* ([https://github.com/linkedin/databus](https://github.com/linkedin/databus))—An
    open source project that mines the Oracle transaction log and publishes the changes
    as events. LinkedIn uses Databus to synchronize various derived data stores with
    the system of record.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*LinkedIn Databus* ([https://github.com/linkedin/databus](https://github.com/linkedin/databus))——一个开源项目，挖掘Oracle事务日志并将更改作为事件发布。LinkedIn使用Databus来同步各种派生数据存储与记录系统。'
- en: '*DynamoDB streams* ([http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html))—DynamoDB
    streams contain the time-ordered sequence of changes (creates, updates, and deletes)
    made to the items in a DynamoDB table in the last 24 hours. An application can
    read those changes from the stream and, for example, publish them as events.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DynamoDB streams* ([http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html))—DynamoDB
    streams包含在过去24小时内对DynamoDB表中项目所做的更改（创建、更新和删除）的时间顺序序列。应用程序可以从流中读取这些更改，例如，将它们作为事件发布。'
- en: '*Eventuate Tram* ([https://github.com/eventuate-tram/eventuate-tram-core](https://github.com/eventuate-tram/eventuate-tram-core))—Your
    author’s very own open source transaction messaging library that uses MySQL binlog
    protocol, Postgres WAL, or polling to read changes made to an `OUTBOX` table and
    publish them to Apache Kafka.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Eventuate Tram* ([https://github.com/eventuate-tram/eventuate-tram-core](https://github.com/eventuate-tram/eventuate-tram-core))—您作者的专属开源事务消息库，它使用MySQL
    binlog协议、Postgres WAL或轮询来读取对`OUTBOX`表所做的更改，并将它们发布到Apache Kafka。'
- en: Although this approach is obscure, it works remarkably well. The challenge is
    that implementing it requires some development effort. You could, for example,
    write low-level code that calls database-specific APIs. Alternatively, you could
    use an open source framework such as Debezium that publishes changes made by an
    application to MySQL, Postgres, or MongoDB to Apache Kafka. The drawback of using
    Debezium is that its focus is capturing changes at the database level and that
    APIs for sending and receiving messages are outside of its scope. That’s why I
    created the Eventuate Tram framework, which provides the messaging APIs as well
    as transaction tailing and polling.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法不太为人所知，但它工作得非常出色。挑战在于实现它需要一些开发工作。例如，你可以编写低级代码来调用数据库特定的API。或者，你可以使用如Debezium这样的开源框架，它将MySQL、Postgres或MongoDB中应用程序所做的更改发布到Apache
    Kafka。使用Debezium的缺点是它的重点是捕获数据库级别的更改，而发送和接收消息的API超出了其范围。这就是我创建Eventuate Tram框架的原因，它不仅提供了消息API，还提供了事务跟踪和轮询功能。
- en: 3.3.8\. Libraries and frameworks for messaging
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.8\. 消息的库和框架
- en: 'A service needs to use a library to send and receive messages. One approach
    is to use the message broker’s client library, although there are several problems
    with using such a library directly:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务需要使用库来发送和接收消息。一种方法是用消息代理的客户端库，尽管直接使用此类库存在一些问题：
- en: The client library couples business logic that publishes messages to the message
    broker APIs.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端库将发布消息到消息代理API的业务逻辑耦合在一起。
- en: A message broker’s client library is typically low level and requires many lines
    of code to send or receive a message. As a developer, you don’t want to repeatedly
    write boilerplate code. Also, as the author of this book I don’t want the example
    code cluttered with low-level boilerplate.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息代理的客户端库通常是低级的，发送或接收消息需要很多行代码。作为开发者，你不想反复编写样板代码。此外，作为本书的作者，我不想示例代码被低级样板代码所充斥。
- en: The client library usually provides only the basic mechanism to send and receive
    messages and doesn’t support the higher-level interaction styles.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端库通常只提供发送和接收消息的基本机制，不支持高级交互样式。
- en: A better approach is to use a higher-level library or framework that hides the
    low-level details and directly supports the higher-level interaction styles. For
    simplicity, the examples in this book use my Eventuate Tram framework. It has
    a simple, easy-to-understand API that hides the complexity of using the message
    broker. Besides an API for sending and receiving messages, Eventuate Tram also
    supports higher-level interaction styles such as asynchronous request/response
    and domain event publishing.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用一个高级库或框架，它隐藏了低级细节并直接支持高级交互样式。为了简单起见，本书中的示例使用我的Eventuate Tram框架。它有一个简单、易于理解的API，隐藏了使用消息代理的复杂性。除了发送和接收消息的API之外，Eventuate
    Tram还支持异步请求/响应和领域事件发布等高级交互样式。
- en: '|  |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What!? Why the Eventuate frameworks?**'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么？！为什么是Eventuate框架？**'
- en: The code samples in this book use the open source Eventuate frameworks I’ve
    developed for transactional messaging, event sourcing, and sagas. I chose to use
    my frameworks because, unlike with, say, dependency injection and the Spring framework,
    there are no widely adopted frameworks for many of the features the microservice
    architecture requires. Without the Eventuate Tram framework, many examples would
    have to use the low-level messaging APIs directly, making them much more complicated
    and obscuring important concepts. Or they would use a framework that isn’t widely
    adopted, which would also provoke criticism.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码示例使用我开发的开源 Eventuate 框架，用于事务消息、事件溯源和 sagas。我选择使用我的框架，因为与依赖注入和 Spring 框架不同，微服务架构所需的功能中，没有广泛采用的框架。如果没有
    Eventuate Tram 框架，许多示例将不得不直接使用低级消息API，这将使它们变得更加复杂，并掩盖重要的概念。或者，它们将使用一个不受广泛采用的框架，这也会引起批评。
- en: Instead, the examples use the Eventuate Tram frameworks, which have a simple,
    easy-to-understand API that hides the implementation details. You can use these
    frameworks in your applications. Alternatively, you can study the Eventuate Tram
    frameworks and reimplement the concepts yourself.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，示例使用 Eventuate Tram 框架，它具有简单、易于理解的API，隐藏了实现细节。您可以在您的应用程序中使用这些框架。或者，您可以研究
    Eventuate Tram 框架，并自行重新实现这些概念。
- en: '|  |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Eventuate Tram also implements two important mechanisms:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Eventuate Tram 还实现了两个重要机制：
- en: '***Transactional messaging*—** It publishes messages as part of a database
    transaction.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***事务消息*—** 它将消息作为数据库事务的一部分发布。'
- en: '***Duplicate message detection*—** The Eventuate Tram message consumer detects
    and discards duplicate messages, which is essential for ensuring that a consumer
    processes messages exactly once, as discussed in [section 3.3.6](#ch03lev2sec14).'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***重复消息检测*—** Eventuate Tram 消息消费者检测并丢弃重复消息，这对于确保消费者恰好处理一次消息至关重要，如[第3.3.6节](#ch03lev2sec14)中所述。'
- en: Let’s take a look at the Eventuate Tram APIs.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Eventuate Tram API。
- en: Basic messaging
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本消息
- en: 'The basic messaging API consists of two Java interfaces: `MessageProducer`
    and `MessageConsumer`. A producer service uses the `MessageProducer` interface
    to publish messages to message channels. Here’s an example of using this interface:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 基本消息API由两个Java接口组成：`MessageProducer` 和 `MessageConsumer`。生产者服务使用 `MessageProducer`
    接口将消息发布到消息通道。以下是如何使用此接口的示例：
- en: '[PRE4]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A consumer service uses the `MessageConsumer` interface to subscribe to messages:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者服务使用 `MessageConsumer` 接口订阅消息：
- en: '[PRE5]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`MessageProducer` and `MessageConsumer` are the foundation of the higher-level
    APIs for asynchronous request/response and domain event publishing.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageProducer` 和 `MessageConsumer` 是异步请求/响应和领域事件发布的高级API的基础。'
- en: Let’s talk about how to publish and subscribe to events.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈如何发布和订阅事件。
- en: Domain event publishing
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 领域事件发布
- en: 'Eventuate Tram has APIs for publishing and consuming domain events. [Chapter
    5](kindle_split_013.xhtml#ch05) explains that domain events are events that are
    emitted by an *aggregate* (business object) when it’s created, updated, or deleted.
    A service publishes a domain event using the `DomainEventPublisher` interface.
    Here is an example:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: Eventuate Tram 提供了发布和消费领域事件的API。[第5章](kindle_split_013.xhtml#ch05) 解释了领域事件是当
    *聚合*（业务对象）创建、更新或删除时发出的事件。服务使用 `DomainEventPublisher` 接口发布领域事件。以下是一个示例：
- en: '[PRE6]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A service consumes domain events using the `DomainEventDispatcher`. An example
    follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务使用 `DomainEventDispatcher` 来消费领域事件。以下是一个示例：
- en: '[PRE7]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Events aren’t the only high-level messaging pattern supported by Eventuate Tram.
    It also supports command/reply-based messaging.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 事件不是 Eventuate Tram 支持的唯一高级消息模式。它还支持基于命令/回复的消息。
- en: Command/Reply-based messaging
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于命令/回复的消息
- en: A client can send a command message to a service using the `CommandProducer`
    interface. For example
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以使用 `CommandProducer` 接口向服务发送命令消息。例如
- en: '[PRE8]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A service consumes command messages using the `CommandDispatcher` class. `CommandDispatcher`
    uses the `MessageConsumer` interface to subscribe to specified events. It dispatches
    each command message to the appropriate handler method. Here’s an example:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务使用 `CommandDispatcher` 类来消费命令消息。`CommandDispatcher` 使用 `MessageConsumer`
    接口订阅指定的事件。它将每个命令消息调度到适当的手动方法。以下是一个示例：
- en: '[PRE9]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Throughout this book, you’ll see code examples that use these APIs for sending
    and receiving messages.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，您将看到使用这些API发送和接收消息的代码示例。
- en: As you’ve seen, the Eventuate Tram framework implements transactional messaging
    for Java applications. It provides a low-level API for sending and receiving messages
    transactionally. It also provides the higher-level APIs for publishing and consuming
    domain events and for sending and processing commands.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Eventuate Tram 框架实现了 Java 应用程序的事务性消息传递。它提供了一个低级 API 用于事务性地发送和接收消息。它还提供了用于发布和消费领域事件以及发送和处理命令的高级
    API。
- en: Let’s now look at a service design approach that uses asynchronous messaging
    to improve availability.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一种使用异步消息传递来提高可用性的服务设计方法。
- en: 3.4\. Using asynchronous messaging to improve availability
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4. 使用异步消息传递来提高可用性
- en: As you’ve seen, a variety of IPC mechanisms have different trade-offs. One particular
    trade-off is how your choice of IPC mechanism impacts availability. In this section,
    you’ll learn that synchronous communication with other services as part of request
    handling reduces application availability. As a result, you should design your
    services to use asynchronous messaging whenever possible.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，各种 IPC 机制有不同的权衡。一个特定的权衡是你选择的 IPC 机制如何影响可用性。在本节中，你将了解到作为请求处理一部分与其他服务进行同步通信会降低应用程序的可用性。因此，你应该尽可能设计你的服务使用异步消息传递。
- en: Let’s first look at the problem with synchronous communication and how it impacts
    availability.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看同步通信的问题以及它如何影响可用性。
- en: 3.4.1\. Synchronous communication reduces availability
  id: totrans-447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.1. 同步通信降低可用性
- en: 'REST is an extremely popular IPC mechanism. You may be tempted to use it for
    interservice communication. The problem with REST, though, is that it’s a synchronous
    protocol: an HTTP client must wait for the service to send a response. Whenever
    services communicate using a synchronous protocol, the availability of the application
    is reduced.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: REST 是一种极其流行的 IPC 机制。你可能想用它来进行服务间通信。然而，REST 的问题在于它是一个同步协议：HTTP 客户端必须等待服务发送响应。每当服务使用同步协议进行通信时，应用程序的可用性就会降低。
- en: To see why, consider the scenario shown in [figure 3.15](#ch03fig15). The `Order
    Service` has a REST API for creating an `Order`. It invokes the `Consumer Service`
    and the `Restaurant Service` to validate the `Order`. Both of those services also
    have REST APIs.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解原因，请考虑[图3.15](#ch03fig15)中所示的场景。`Order Service` 提供了一个用于创建 `Order` 的 REST
    API。它调用 `Consumer Service` 和 `Restaurant Service` 来验证 `Order`。这两个服务也都有 REST API。
- en: Figure 3.15\. The `Order Service` invokes other services using REST. It’s straightforward,
    but it requires all the services to be simultaneously available, which reduces
    the availability of the API.
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.15. `Order Service` 使用 REST 调用其他服务。这很简单，但要求所有服务同时可用，这降低了 API 的可用性。
- en: '![](Images/03fig15_alt.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig15_alt.jpg)'
- en: 'The sequence of steps for creating an order is as follows:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 创建订单的步骤顺序如下：
- en: Client makes an HTTP `POST /orders` request to the `Order Service`.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向 `Order Service` 发送 HTTP `POST /orders` 请求。
- en: '`Order Service` retrieves consumer information by making an HTTP `GET /consumers/id`
    request to the `Consumer Service`.'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Order Service` 通过向 `Consumer Service` 发送 HTTP `GET /consumers/id` 请求来检索消费者信息。'
- en: '`Order Service` retrieves restaurant information by making an HTTP `GET /restaurant/id`
    request to the `Restaurant Service`.'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Order Service` 通过向 `Restaurant Service` 发送 HTTP `GET /restaurant/id` 请求来检索餐厅信息。'
- en: '`Order Taking` validates the request using the consumer and restaurant information.'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Order Taking` 使用消费者和餐厅信息验证请求。'
- en: '`Order Taking` creates an Order.'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Order Taking` 创建一个订单。'
- en: '`Order Taking` sends an HTTP response to the client.'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Order Taking` 向客户端发送 HTTP 响应。'
- en: Because these services use HTTP, they must all be simultaneously available in
    order for the FTGO application to process the `CreateOrder` request. The FTGO
    application couldn’t create orders if any one of these three services is down.
    Mathematically speaking, the availability of a system operation is the product
    of the availability of the services that are invoked by that operation. If the
    `Order Service` and the two services that it invokes are 99.5% available, the
    overall availability is 99.5%³ = 98.5%, which is significantly less. Each additional
    service that participates in handling a request further reduces availability.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些服务使用HTTP，所以为了FTGO应用程序能够处理`CreateOrder`请求，它们必须同时可用。如果这三个服务中的任何一个出现故障，FTGO应用程序就无法创建订单。从数学上讲，系统操作的可用性是调用该操作的服务可用性的乘积。如果`Order
    Service`及其调用的两个服务都是99.5%可用，则整体可用性为99.5%³ = 98.5%，这明显较低。每个参与处理请求的额外服务都会进一步降低可用性。
- en: This problem isn’t specific to REST-based communication. Availability is reduced
    whenever a service can only respond to its client after receiving a response from
    another service. This problem exists even if services communicate using request/response
    style interaction over asynchronous messaging. For example, the availability of
    the `Order Service` would be reduced if it sent a message to the `Consumer Service`
    via a message broker and then waited for a response.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题并不仅限于基于REST的通信。每当服务只能在收到另一个服务的响应后才能对其客户端做出响应时，可用性就会降低。即使服务通过异步消息的请求/响应风格进行通信，这个问题也存在。例如，如果`Order
    Service`通过消息代理向`Consumer Service`发送消息，然后等待响应，那么`Order Service`的可用性就会降低。
- en: If you want to maximize availability, you must minimize the amount of synchronous
    communication. Let’s look at how to do that.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想最大化可用性，你必须最小化同步通信的数量。让我们看看如何做到这一点。
- en: 3.4.2\. Eliminating synchronous interaction
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2\. 消除同步交互
- en: There are a few different ways to reduce the amount of synchronous communication
    with other services while handling synchronous requests. One solution is to avoid
    the problem entirely by defining services that only have asynchronous APIs. That’s
    not always possible, though. For example, public APIs are commonly RESTful. Services
    are therefore sometimes required to have synchronous APIs.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理同步请求的同时，有几种不同的方法可以减少与其他服务的同步通信量。一种解决方案是通过定义仅具有异步API的服务来完全避免这个问题。但这并不总是可能的。例如，公共API通常是RESTful的。因此，有时服务需要具有同步API。
- en: Fortunately, there are ways to handle synchronous requests without making synchronous
    requests. Let’s talk about the options.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一些方法可以处理同步请求而不进行同步请求。让我们谈谈这些选项。
- en: Use asynchronous interaction styles
  id: totrans-465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用异步交互风格
- en: Ideally, all interactions should be done using the asynchronous interaction
    styles described earlier in this chapter. For example, say a client of the FTGO
    application used an asynchronous request/asynchronous response style of interaction
    to create orders. A client creates an order by sending a request message to the
    `Order Service`. This service then asynchronously exchanges messages with other
    services and eventually sends a reply message to the client. [Figure 3.16](#ch03fig16)
    shows the design.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，所有交互都应使用本章前面描述的异步交互风格进行。例如，假设FTGO应用程序的一个客户端使用异步请求/异步响应风格的交互来创建订单。客户端通过向`Order
    Service`发送请求消息来创建订单。然后，该服务与其他服务异步交换消息，并最终向客户端发送回复消息。[图3.16](#ch03fig16)展示了设计。
- en: Figure 3.16\. The FTGO application has higher availability if its services communicate
    using asynchronous messaging instead of synchronous calls.
  id: totrans-467
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.16\. 如果FTGO应用程序的服务使用异步消息而不是同步调用进行通信，则其可用性更高。
- en: '![](Images/03fig16_alt.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig16_alt.jpg)'
- en: The client and the services communicate asynchronously by sending messages via
    messaging channels. No participant in this interaction is ever blocked waiting
    for a response.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务通过通过消息通道发送消息进行异步通信。在这个交互中的任何参与者都不会因为等待响应而被阻塞。
- en: Such an architecture would be extremely resilient, because the message broker
    buffers messages until they can be consumed. The problem, however, is that services
    often have an external API that uses a synchronous protocol such as REST, so it
    must respond to requests immediately.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的架构将具有极高的弹性，因为消息代理会缓冲消息，直到它们可以被消费。然而，问题是服务通常有一个使用同步协议（如REST）的外部API，因此它必须立即响应请求。
- en: If a service has a synchronous API, one way to improve availability is to replicate
    data. Let’s see how that works.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个服务有一个同步API，提高可用性的方法之一是复制数据。让我们看看这是如何工作的。
- en: Replicate data
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 复制数据
- en: One way to minimize synchronous requests during request processing is to replicate
    data. A service maintains a replica of the data that it needs when processing
    requests. It keeps the replica up-to-date by subscribing to events published by
    the services that own the data. For example, `Order Service` could maintain a
    replica of data owned by `Consumer Service` and `Restaurant Service`. This would
    enable `Order Service` to handle a request to create an order without having to
    interact with those services. [Figure 3.17](#ch03fig17) shows the design.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求处理期间最小化同步请求的一种方法是通过复制数据。服务在处理请求时维护所需数据的副本。它通过订阅拥有数据的服务发布的事件来保持副本的更新。例如，`订单服务`可以维护由`消费者服务`和`餐厅服务`拥有的数据的副本。这将使`订单服务`能够在不与那些服务交互的情况下处理创建订单的请求。[图3.17](#ch03fig17)展示了该设计。
- en: Figure 3.17\. `Order Service` is self-contained because it has replicas of the
    consumer and restaurant data.
  id: totrans-474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.17\. `订单服务`是自包含的，因为它拥有消费者和餐厅数据的副本。
- en: '![](Images/03fig17_alt.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig17_alt.jpg)'
- en: '`Consumer Service` and `Restaurant Service` publish events whenever their data
    changes. `Order Service` subscribes to those events and updates its replica.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`消费者服务`和`餐厅服务`在其数据更改时发布事件。`订单服务`订阅这些事件并更新其副本。'
- en: In some situations, replicating data is a useful approach. For example, [chapter
    5](kindle_split_013.xhtml#ch05) describes how `Order Service` replicates data
    from `Restaurant Service` so that it can validate and price menu items. One drawback
    of replication is that it can sometimes require the replication of large amounts
    of data, which is inefficient. For example, it may not be practical for `Order
    Service` to maintain a replica of the data owned by `Consumer Service`, due to
    the large number of consumers. Another drawback of replication is that it doesn’t
    solve the problem of how a service updates data owned by other services.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，复制数据是一种有用的方法。例如，[第5章](kindle_split_013.xhtml#ch05)描述了`订单服务`如何从`餐厅服务`复制数据，以便验证和定价菜单项。复制的缺点之一是有时可能需要复制大量数据，这效率低下。例如，由于消费者数量庞大，`订单服务`维护`消费者服务`拥有的数据的副本可能不切实际。复制的另一个缺点是它没有解决服务如何更新其他服务拥有的数据的问题。
- en: One way to solve that problem is for a service to delay interacting with other
    services until after it responds to its client. We’ll next look at how that works.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 解决该问题的一种方法是为服务延迟与其他服务交互，直到它向其客户端响应之后。我们接下来将看看这是如何工作的。
- en: Finish processing after returning a response
  id: totrans-479
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在返回响应后完成处理
- en: 'Another way to eliminate synchronous communication during request processing
    is for a service to handle a request as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求处理期间消除同步通信的另一种方法是服务按照以下方式处理请求：
- en: Validate the request using only the data available locally.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅使用本地可用的数据验证请求。
- en: Update its database, including inserting messages into the `OUTBOX` table.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新其数据库，包括将消息插入到`OUTBOX`表中。
- en: Return a response to its client.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其客户端返回响应。
- en: While handling a request, the service doesn’t synchronously interact with any
    other services. Instead, it asynchronously sends messages to other services. This
    approach ensures that the services are loosely coupled. As you’ll learn in the
    next chapter, this is often implemented using a *saga*.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理请求时，服务不会与任何其他服务同步交互。相反，它异步地向其他服务发送消息。这种方法确保服务是松散耦合的。正如你将在下一章学到的那样，这通常是通过使用一个*saga*来实现的。
- en: 'For example, if `Order Service` uses this approach, it creates an order in
    a `PENDING` state and then validates the order asynchronously by exchanging messages
    with other services. [Figure 3.18](#ch03fig18) shows what happens when the `createOrder()`
    operation is invoked. The sequence of events is as follows:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`订单服务`使用这种方法，它会在`待处理`状态下创建一个订单，然后通过与其他服务交换消息异步验证订单。[图3.18](#ch03fig18)展示了当调用`createOrder()`操作时会发生什么。事件序列如下：
- en: '`Order Service` creates an Order in a `PENDING` state.'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`订单服务`创建一个处于`待处理`状态的订单。'
- en: '`Order Service` returns a response to its client containing the order ID.'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`订单服务`向其客户端返回包含订单ID的响应。'
- en: '`Order Service` sends a `ValidateConsumerInfo` message to `Consumer Service`.'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`订单服务`向`消费者服务`发送`ValidateConsumerInfo`消息。'
- en: Figure 3.18\. `Order Service` creates an order without invoking any other service.
    It then asynchronously validates the newly created `Order` by exchanging messages
    with other services, including `Consumer Service` and `Restaurant Service`.
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.18\. `Order Service` 在不调用任何其他服务的情况下创建订单。然后它通过与其他服务（包括 `Consumer Service`
    和 `Restaurant Service`）交换消息来异步验证新创建的 `Order`。
- en: '![](Images/03fig18_alt.jpg)'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](Images/03fig18_alt.jpg)'
- en: '`Order Service` sends a `ValidateOrderDetails` message to `Restaurant Service`.'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Order Service` 向 `Restaurant Service` 发送一个 `ValidateOrderDetails` 消息。'
- en: '`Consumer Service` receives a `ValidateConsumerInfo` message, verifies the
    consumer can place an order, and sends a `ConsumerValidated` message to `Order
    Service`.'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Consumer Service` 接收到一个 `ValidateConsumerInfo` 消息，验证消费者能否下订单，并向 `Order Service`
    发送一个 `ConsumerValidated` 消息。'
- en: '`Restaurant Service` receives a `ValidateOrderDetails` message, verifies the
    menu item are valid and that the restaurant can deliver to the order’s delivery
    address, and sends an `OrderDetailsValidated` message to `Order Service`.'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Restaurant Service` 接收到一个 `ValidateOrderDetails` 消息，验证菜单项是否有效以及餐厅是否能够将订单送达指定地址，然后向
    `Order Service` 发送一个 `OrderDetailsValidated` 消息。'
- en: '`Order Service` receives `ConsumerValidated` and `OrderDetailsValidated` and
    changes the state of the order to `VALIDATED`.'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Order Service` 接收到 `ConsumerValidated` 和 `OrderDetailsValidated` 并将订单状态改为
    `VALIDATED`。'
- en: '...'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '...'
- en: '`Order Service` can receive the `ConsumerValidated` and `OrderDetailsValidated`
    messages in either order. It keeps track of which message it receives first by
    changing the state of the order. If it receives the `ConsumerValidated` first,
    it changes the state of the order to `CONSUMER_VALIDATED`, whereas if it receives
    the `OrderDetailsValidated` message first, it changes its state to `ORDER_DETAILS_VALIDATED`.
    `Order Service` changes the state of the `Order` to `VALIDATED` when it receives
    the other message.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order Service` 可以以任意顺序接收 `ConsumerValidated` 和 `OrderDetailsValidated` 消息。它通过改变订单的状态来跟踪它首先接收哪个消息。如果它首先接收到
    `ConsumerValidated` 消息，它将订单状态改为 `CONSUMER_VALIDATED`；而如果它首先接收到 `OrderDetailsValidated`
    消息，它将状态改为 `ORDER_DETAILS_VALIDATED`。当它接收到另一个消息时，`Order Service` 将 `Order` 的状态改为
    `VALIDATED`。'
- en: After the Order has been validated, `Order Service` completes the rest of the
    order-creation process, discussed in the next chapter. What’s nice about this
    approach is that even if `Consumer Service` is down, for example, `Order Service`
    still creates orders and responds to its clients. Eventually, `Consumer Service`
    will come back up and process any queued messages, and orders will be validated.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在订单验证完成后，`Order Service` 完成订单创建过程的其余部分，这些内容将在下一章中讨论。这种方法的好处是，即使 `Consumer Service`
    停止运行，例如，`Order Service` 仍然可以创建订单并响应其客户端。最终，`Consumer Service` 将恢复运行并处理任何排队中的消息，订单将被验证。
- en: A drawback of a service responding before fully processing a request is that
    it makes the client more complex. For example, `Order Service` makes minimal guarantees
    about the state of a newly created order when it returns a response. It creates
    the order and returns immediately before validating the order and authorizing
    the consumer’s credit card. Consequently, in order for the client to know whether
    the order was successfully created, either it must periodically poll or `Order
    Service` must send it a notification message. As complex as it sounds, in many
    situations this is the preferred approach—especially because it also addresses
    the distributed transaction management issues I discuss in the next chapter. In
    [chapters 4](kindle_split_012.xhtml#ch04) and [5](kindle_split_013.xhtml#ch05),
    for example, I describe how `Order Service` uses this approach.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 服务在完全处理请求之前就做出响应的缺点是它使得客户端变得更加复杂。例如，当 `Order Service` 返回响应时，它对新建订单的状态只提供最基本保证。它在验证订单和授权消费者的信用卡之前立即创建订单并返回。因此，为了使客户端知道订单是否成功创建，它必须定期轮询或者
    `Order Service` 必须发送通知消息。尽管听起来很复杂，但在许多情况下，这种方法是首选的——特别是因为它还解决了我在下一章中讨论的分布式事务管理问题。例如，在第
    [4](kindle_split_012.xhtml#ch04) 和 [5](kindle_split_013.xhtml#ch05) 章中，我描述了 `Order
    Service` 如何使用这种方法。
- en: Summary
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The microservice architecture is a distributed architecture, so interprocess
    communication plays a key role.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构是一种分布式架构，因此进程间通信扮演着关键角色。
- en: It’s essential to carefully manage the evolution of a service’s API. Backward-compatible
    changes are the easiest to make because they don’t impact clients. If you make
    a breaking change to a service’s API, it will typically need to support both the
    old and new versions until its clients have been upgraded.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精心管理服务API的演变至关重要。向后兼容的更改最容易实现，因为它们不会影响客户端。如果你对服务的API进行了破坏性更改，通常需要同时支持旧版和新版，直到客户端升级。
- en: There are numerous IPC technologies, each with different trade-offs. One key
    design decision is to choose either a synchronous remote procedure invocation
    pattern or the asynchronous Messaging pattern. Synchronous remote procedure invocation-based
    protocols, such as REST, are the easiest to use. But services should ideally communicate
    using asynchronous messaging in order to increase availability.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多IPC技术，每种技术都有不同的权衡。一个关键的设计决策是选择同步远程过程调用模式或异步消息模式。基于同步远程过程调用的协议，如REST，最容易使用。但理想情况下，服务应使用异步消息进行通信，以提高可用性。
- en: In order to prevent failures from cascading through a system, a service client
    that uses a synchronous protocol must be designed to handle partial failures,
    which are when the invoked service is either down or exhibiting high latency.
    In particular, it must use timeouts when making requests, limit the number of
    outstanding requests, and use the Circuit breaker pattern to avoid making calls
    to a failing service.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了防止故障在系统中级联，使用同步协议的服务客户端必须设计成能够处理部分故障，即调用服务时服务可能处于宕机状态或表现出高延迟。特别是，在发起请求时必须使用超时，限制未完成请求的数量，并使用断路器模式来避免调用失败的服务。
- en: 'An architecture that uses synchronous protocols must include a service discovery
    mechanism in order for clients to determine the network location of a service
    instance. The simplest approach is to use the service discovery mechanism implemented
    by the deployment platform: the Server-side discovery and 3rd party registration
    patterns. But an alternative approach is to implement service discovery at the
    application level: the Client-side discovery and Self registration patterns. It’s
    more work, but it does handle the scenario where services are running on multiple
    deployment platforms.'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用同步协议的架构必须包括服务发现机制，以便客户端确定服务实例的网络位置。最简单的方法是使用部署平台实现的服务发现机制：服务器端发现和第三方注册模式。但另一种方法是实现应用级别的服务发现：客户端发现和自注册模式。这需要更多的工作，但它确实处理了服务运行在多个部署平台上的场景。
- en: A good way to design a messaging-based architecture is to use the messages and
    channels model, which abstracts the details of the underlying messaging system.
    You can then map that design to a specific messaging infrastructure, which is
    typically message broker–based.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计基于消息的架构的一个好方法就是使用消息和通道模型，该模型抽象了底层消息系统的细节。然后你可以将这个设计映射到特定的消息基础设施上，这通常是基于消息代理的。
- en: One key challenge when using messaging is atomically updating the database and
    publishing a message. A good solution is to use the Transactional outbox pattern
    and first write the message to the database as part of the database transaction.
    A separate process then retrieves the message from the database using either the
    Polling publisher pattern or the Transaction log tailing pattern and publishes
    it to the message broker.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息时，一个关键挑战是原子地更新数据库并发布消息。一个好的解决方案是使用事务性输出队列模式，首先将消息作为数据库事务的一部分写入数据库。然后，一个单独的过程使用轮询发布者模式或事务日志尾部模式从数据库检索消息，并将其发布到消息代理。
