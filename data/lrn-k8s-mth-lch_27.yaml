- en: appendix A. Packaging applications from source code into Docker Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A：将源代码打包到Docker镜像中
- en: 'Building Docker images is easy. There’s one thing you need to know to package
    your own applications: you can also run commands inside Dockerfiles.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Docker镜像非常简单。你需要知道的一件事是，你可以也在Dockerfile中运行命令来打包你自己的应用程序。
- en: Commands execute during the build, and any filesystem changes from the command
    are saved in the image layer. That makes Dockerfiles about the most flexible packaging
    format there is; you can expand zip files, run Windows installers, and do pretty
    much anything else. In this chapter you’ll use that flexibility to package applications
    from source code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 命令在构建过程中执行，并且从命令中产生的任何文件系统更改都会保存在镜像层中。这使得Dockerfile成为最灵活的打包格式之一；你可以展开zip文件，运行Windows安装程序，以及做几乎所有其他事情。在本章中，你将利用这种灵活性来从源代码打包应用程序。
- en: This appendix is reproduced from chapter 4, "Packaging Applications from Source
    Code into Docker Images," from *Learn Docker in a Month of Lunches* by Elton Stoneman
    (Manning, 2020). Any chapter references or references to code repositories refer
    to the chapters or code repositories of that book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录摘自第4章“将源代码打包到Docker镜像中”，来自Elton Stoneman的《一个月午餐时间学习Docker》（Manning，2020）。任何章节引用或对代码仓库的引用都指的是该书的章节或代码仓库。
- en: A.1 Who needs a build server when you have a Dockerfile?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 当你有Dockerfile时，还需要构建服务器吗？
- en: Building software on your laptop is something you do for local development,
    but when you’re working in a team there’s a more rigorous delivery process. There’s
    a shared source control system like GitHub where everyone pushes their code changes,
    and there’s typically a separate server (or online service) that builds the software
    when changes get pushed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的笔记本电脑上构建软件是你在本地开发时做的事情，但当你在一个团队中工作时，有一个更严格的交付过程。有一个共享的源代码控制系统，如GitHub，每个人都会推送他们的代码更改，通常还有一个单独的服务器（或在线服务），当更改被推送时，它会构建软件。
- en: That process exists to catch problems early. If a developer forgets to add a
    file when they push code, the build will fail on the build server and the team
    will be alerted. It keeps the project healthy, but the cost is having to maintain
    a build server. Most programming languages need a lot of tools to build projects—figure
    A.1 shows some examples.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程存在是为了尽早发现问题。如果一个开发者在推送代码时忘记添加文件，构建将在构建服务器上失败，并且团队将会被通知。它保持了项目的健康，但代价是必须维护一个构建服务器。大多数编程语言需要大量的工具来构建项目——图A.1展示了几个例子。
- en: '![](../Images/A-1.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/A-1.jpg)'
- en: Figure A.1 Everyone needs the same set of tools to build a software project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.1 每个人都需要一套相同的工具来构建一个软件项目。
- en: There’s a big maintenance overhead here. A new starter on the team will spend
    the whole of their first day installing the tools. If a developer updates their
    local tools so the build server is running a different version, the build can
    fail. You have the same issues even if you’re using a managed build service, and
    there you may have a limited set of tools you can install.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个很大的维护开销。新加入团队的成员将花费他们第一天的大部分时间来安装工具。如果一个开发者更新了他们的本地工具，导致构建服务器运行的是不同版本，构建可能会失败。即使你使用的是托管构建服务，你也会遇到同样的问题，在那里你可能只能安装有限的一组工具。
- en: It would be much cleaner to package the build toolset once and share it, which
    is exactly what you can do with Docker. You can write a Dockerfile that scripts
    the deployment of all your tools, and build that into an image. Then you can use
    that image in your application Dockerfiles to compile the source code, and the
    final output is your packaged application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性打包构建工具集并共享会更好，这正是你可以使用Docker做到的。你可以编写一个Dockerfile来脚本化所有工具的部署，并将其构建到镜像中。然后你可以在你的应用程序Dockerfile中使用该镜像来编译源代码，最终输出就是你的打包应用程序。
- en: Let’s start with a very simple example, because there are a couple of new things
    to understand in this process. Listing A.1 shows a Dockerfile with the basic workflow.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的例子开始，因为在这个过程中有几个新事物需要理解。列表A.1展示了包含基本工作流程的Dockerfile。
- en: Listing A.1 A multi-stage Dockerfile
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.1 多阶段Dockerfile
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is called a multi-stage Dockerfile, because there are several stages to
    the build. Each stage starts with a `FROM` instruction, and you can optionally
    give stages a name with the `AS` parameter. Listing A.1 has three stages: `build-stage`,
    `test-stage`, and the final unnamed stage. Although there are multiple stages,
    the output will be a single Docker image with the contents of the final stage.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为多阶段Dockerfile，因为构建有几个阶段。每个阶段都以`FROM`指令开始，你可以选择性地使用`AS`参数给阶段命名。列表A.1有三个阶段：`build-stage`、`test-stage`和最终的未命名阶段。尽管有多个阶段，但输出将是一个包含最终阶段内容的单个Docker镜像。
- en: Each stage runs independently, but you can copy files and directories from previous
    stages. I’m using the `COPY` instruction with the `-from` argument, which tells
    Docker to copy files from an earlier stage in the Dockerfile, rather than from
    the filesystem of the host computer. In this example I generate a file in the
    build stage, copy it into the test stage, and then copy the file from the test
    stage into the final stage.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段都是独立运行的，但你可以从早期阶段复制文件和目录。我使用带有`-from`参数的`COPY`指令，它告诉Docker从Dockerfile中的早期阶段复制文件，而不是从主机计算机的文件系统中复制。在这个例子中，我在构建阶段生成一个文件，将其复制到测试阶段，然后从测试阶段将文件复制到最终阶段。
- en: There’s one new instruction here, `RUN`, which I’m using to write files. The
    `RUN` instruction executes a command inside a container during the build, and
    any output from that command is saved in the image layer. You can execute anything
    in a `RUN` instruction, but the commands you want to run need to exist in the
    Docker image you’re using in the `FROM` instruction. In this example I used `diamol/base`
    as the base image, and it contains the `echo` command, so I knew my `RUN` instruction
    would work.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个新的指令，`RUN`，我正在用它来写入文件。`RUN`指令在构建过程中在容器内执行命令，并且该命令的任何输出都将保存在镜像层中。你可以在`RUN`指令中执行任何操作，但你想运行的命令需要存在于你在`FROM`指令中使用的Docker镜像中。在这个例子中，我使用了`diamol/base`作为基础镜像，它包含了`echo`命令，所以我确定我的`RUN`指令会工作。
- en: Figure A.2 shows what’s going to happen when we build this Dockerfile—Docker
    will run the stages sequentially.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.2显示了构建此Dockerfile时将要发生的事情——Docker将按顺序运行这些阶段。
- en: '![](../Images/A-2.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/A-2.jpg)'
- en: Figure A.2 Executing a multi-stage Dockerfile
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.2 执行多阶段Dockerfile
- en: It’s important to understand that the individual stages are isolated. You can
    use different base images with different sets of tools installed and run whatever
    commands you like. The output in the final stage will only contain what you explicitly
    copy from earlier stages. If a command fails in any stage, the whole build fails.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解各个阶段是相互独立的。你可以使用安装了不同工具集的不同基础镜像，并运行你喜欢的任何命令。最终阶段的输出将只包含你从早期阶段显式复制的部分。如果任何阶段的命令失败，整个构建将失败。
- en: 'Try it now Open a terminal session to the folder where you stored the book’s
    source code, and build this multi-stage Dockerfile:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 打开终端会话到存储本书源代码的文件夹，并构建此多阶段Dockerfile：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You’ll see that the build executes the steps in the order of the Dockerfile,
    which gives the sequential build through the stages you can see in figure A.3.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到构建将按照Dockerfile中的顺序执行步骤，这通过图A.3中可以看到的阶段进行顺序构建。
- en: '![](../Images/A-3.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/A-3.jpg)'
- en: Figure A.3 Building a multi-stage Dockerfile
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.3构建多阶段Dockerfile
- en: This is a simple example, but the pattern is the same for building apps of any
    complexity with a single Dockerfile. Figure A.4 shows what the workflow looks
    like for a Java application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但构建任何复杂性的应用程序的单个Dockerfile的模式是相同的。图A.4显示了Java应用程序的工作流程。
- en: '![](../Images/A-4.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/A-4.jpg)'
- en: Figure A.4 A multi-stage build for a Java application
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.4 Java应用程序的多阶段构建
- en: In the build stage you use a base image that has your application’s build tools
    installed. You copy in the source code from your host machine and run the `build`
    command. You can add a test stage to run unit tests, which uses a base image with
    the test framework installed, copies the compiled binaries from the build stage,
    and runs the tests. The final stage starts from a base image with just the application
    runtime installed, and it copies the binaries from the build stage that have been
    successfully tested in the test stage.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建阶段，你使用一个安装了应用程序构建工具的基础镜像。你将主机机器上的源代码复制进来，并运行`build`命令。你可以添加测试阶段来运行单元测试，该测试阶段使用安装了测试框架的基础镜像，从构建阶段复制编译后的二进制文件，并运行测试。最终阶段从一个只安装了应用程序运行时的基础镜像开始，并从测试阶段成功测试过的构建阶段复制二进制文件。
- en: This approach makes your application truly portable. You can run the app in
    a container anywhere, but you can also build the app anywhere—Docker is the only
    prerequisite. Your build server just needs Docker installed; new team members
    get set up in minutes, and the build tools are all centralized in Docker images,
    so there’s no chance of getting out of sync.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使您的应用程序真正可移植。您可以在任何地方运行应用程序，也可以在任何地方构建应用程序——Docker是唯一的前提条件。您的构建服务器只需要安装Docker；新团队成员可以在几分钟内设置好，构建工具都集中存储在Docker镜像中，因此不会出现不同步的情况。
- en: All the major application frameworks already have public images on Docker Hub
    with the build tools installed, and there are separate images with the application
    runtime. You can use these images directly or wrap them in your own images. You’ll
    get the benefit of using all the latest updates with images that are maintained
    by the project teams.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要的应用程序框架已经在Docker Hub上有了带有构建工具的公共镜像，并且还有带有应用程序运行时的单独镜像。您可以直接使用这些镜像，或者将它们包装在您自己的镜像中。您将获得使用由项目团队维护的最新更新的好处。
- en: 'A.2 App walkthrough: Java source code'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 应用程序概述：Java源代码
- en: We’ll move on to a real example now, with a simple Java Spring Boot application
    that we’ll build and run using Docker. You don’t need to be a Java developer or
    have any Java tools installed on your machine to use this app; everything you
    need will come in Docker images. If you don’t work with Java, you should still
    read through this section—it describes a pattern that works for other compiled
    languages like .NET Core and Erlang.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将转向一个真实示例，我们将使用Docker构建和运行一个简单的Java Spring Boot应用程序。您不需要是Java开发者或在自己的机器上安装任何Java工具来使用此应用程序；您所需的一切都将包含在Docker镜像中。如果您不使用Java，您也应该阅读本节——它描述了一个适用于其他编译语言（如.NET
    Core和Erlang）的模式。
- en: 'The source code is in the repository for the book, at the folder path `ch04/
    exercises/image-of-the-day`. The application uses a fairly standard set of tools
    for Java: Maven, which is used to define the build process and fetch dependencies,
    and OpenJDK, which is a freely distributable Java runtime and developer kit. Maven
    uses an XML format to describe the build, and the Maven command line is called
    `mvn`. That should be enough information to make sense of the application Dockerfile
    in listing A.2.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码位于书籍的仓库中，路径为`ch04/exercises/image-of-the-day`。应用程序使用了一套相当标准的Java工具：Maven，用于定义构建过程和获取依赖项，以及OpenJDK，它是一个可自由分发的Java运行时和开发工具包。Maven使用XML格式来描述构建，Maven命令行称为`mvn`。这些信息应该足以理解列表A.2中的应用程序Dockerfile。
- en: Listing A.2 Dockerfile for building a Java app with Maven
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.2 使用Maven构建Java应用的Dockerfile
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Almost all the Dockerfile instructions here are ones you’ve seen before, and
    the patterns are familiar from examples that you’ve built. It’s a multi-stage
    Dockerfile, which you can tell because there’s more than one `FROM` instruction,
    and the steps are laid out to get maximum benefit from Docker’s image layer cache.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的大多数Dockerfile指令都是您之前见过的，模式与您构建的示例中的模式相似。这是一个多阶段Dockerfile，您可以通过存在多个`FROM`指令来判断，步骤安排旨在从Docker的镜像层缓存中获得最大好处。
- en: 'The first stage is called `builder`. Here’s what happens in the builder stage:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个阶段被称为`builder`。以下是构建阶段发生的情况：
- en: It uses the `diamol/maven` image as the base. That image has the OpenJDK Java
    development kit installed, as well as the Maven build tool.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用`diamol/maven`镜像作为基础。该镜像已安装了OpenJDK Java开发工具包，以及Maven构建工具。
- en: The builder stage starts by creating a working directory in the image and then
    copying in the `pom.xml` file, which is the Maven definition of the Java build.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建阶段首先在镜像中创建一个工作目录，然后复制`pom.xml`文件，这是Maven对Java构建的定义。
- en: The first `RUN` statement executes a Maven command, fetching all the application
    dependencies. This is an expensive operation, so it has its own step to make use
    of Docker layer caching. If there are new dependencies, the XML file will change
    and the step will run. If the dependencies haven’t changed, the layer cache is
    used.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个`RUN`语句执行Maven命令，获取所有应用程序依赖项。这是一个昂贵的操作，因此它有自己的步骤来利用Docker层缓存。如果有新的依赖项，XML文件将更改，该步骤将运行。如果依赖项没有更改，则使用层缓存。
- en: Next the rest of the source code is copied in—`COPY` `.` `.` means “copy all
    files and directories from the location where the Docker build is running, into
    the working directory in the image.”
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，将剩余的源代码复制进来——`COPY` `.` `.`表示“从Docker构建运行的位置，将所有文件和目录复制到镜像中的工作目录。”
- en: The last step of the builder is to run `mvn` `package`, which compiles and packages
    the application. The input is a set of Java source code files, and the output
    is a Java application package called a JAR file.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建的最后一步是运行`mvn package`，它编译并打包应用程序。输入是一组Java源代码文件，输出是一个名为JAR文件的Java应用程序包。
- en: When this stage completes, the compiled application will exist in the builder
    stage filesystem. If there are any problems with the Maven build—if the network
    is offline and fetching dependencies fails, or if there is a coding error in the
    source—the `RUN` instruction will fail, and the whole build fails.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个阶段完成后，编译的应用程序将存在于构建阶段的文件系统中。如果Maven构建过程中有任何问题——如果网络离线且获取依赖失败，或者源代码中存在编码错误——`RUN`指令将失败，整个构建将失败。
- en: 'If the builder stage completes successfully, Docker goes on to execute the
    final stage, which produces the application image:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建阶段成功完成，Docker将继续执行最终阶段，该阶段生成应用程序镜像：
- en: It starts from `diamol/openjdk`, which is packaged with the Java 11 runtime,
    but none of the Maven build tools.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从`diamol/openjdk`开始，其中包含Java 11运行时，但没有包含任何Maven构建工具。
- en: This stage creates a working directory and copies in the compiled JAR file from
    the builder stage. Maven packages the application and all its Java dependencies
    in this single JAR file, so this is all that’s needed from the builder.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个阶段创建了一个工作目录并将构建阶段的编译JAR文件复制进来。Maven将应用程序及其所有Java依赖项打包在这个单一的JAR文件中，因此构建阶段只需要这个。
- en: The application is a web server that listens on port 80, so that port is explicitly
    listed in the `EXPOSE` instruction, which tells Docker that this port can be published.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序是一个监听80端口的Web服务器，因此该端口在`EXPOSE`指令中明确列出，告诉Docker该端口可以发布。
- en: The `ENTRYPOINT` instruction is an alternative to the `CMD` instruction—it tells
    Docker what to do when a container is started from the image, in this case running
    Java with the path to the application JAR.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`指令是`CMD`指令的替代方案——它告诉Docker从镜像启动容器时要做什么，在这种情况下是运行Java并指定应用程序JAR的路径。'
- en: 'Try it now Browse to the Java application source code and build the image:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 浏览到Java应用程序源代码并构建镜像：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There’s a lot of output from this build because you’ll see all the logs from
    Maven, fetching dependencies, and running through the Java build. Figure A.5 shows
    an abbreviated section of my build.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你会看到Maven、获取依赖和Java构建的所有日志，所以这个构建会有很多输出。图A.5显示了构建的一个简略部分。
- en: '![](../Images/A-5.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/A-5.jpg)'
- en: Figure A.5 Output from running a Maven build in Docker
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.5 Docker中运行Maven构建的输出
- en: So what have you just built? It’s a simple REST API that wraps access to NASA’s
    Astronomy Picture of the Day service ([https://apod.nasa.gov](https://apod.nasa.gov)).
    The Java app fetches the details of today’s picture from NASA and caches it, so
    you can make repeated calls to this application without repeatedly hitting NASA’s
    service.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你刚刚构建了什么？它是一个简单的REST API，它封装了对NASA每日天文图片服务的访问（[https://apod.nasa.gov](https://apod.nasa.gov)）。Java应用程序从NASA获取当天图片的详细信息并将其缓存，这样你就可以重复调用此应用程序，而无需反复调用NASA的服务。
- en: The Java API is just one part of the full application you’ll be running in this
    chapter—it will actually use multiple containers, and they need to communicate
    with each other. Containers access each other across a virtual network, using
    the virtual IP address that Docker allocates when it creates the container. You
    can create and manage virtual Docker networks through the command line.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Java API只是本章中你将运行的全应用的一部分——它实际上会使用多个容器，并且它们需要相互通信。容器通过虚拟网络访问彼此，使用Docker在创建容器时分配的虚拟IP地址。你可以通过命令行创建和管理虚拟Docker网络。
- en: 'Try it now Create a Docker network for containers to communicate with each
    other:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 为容器创建一个用于相互通信的Docker网络：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you see an error from that command, it’s because your setup already has a
    Docker network called `nat`, and you can ignore the message. Now when you run
    containers you can explicitly connect them to that Docker network using the `-network`
    flag, and any containers on that network can reach each other using the container
    names.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到该命令的错误，那是因为你的设置已经有一个名为`nat`的Docker网络，你可以忽略该消息。现在当你运行容器时，你可以使用`-network`标志显式地将它们连接到该Docker网络，并且该网络上的任何容器都可以通过容器名称相互访问。
- en: 'Try it now Run a container from the image, publishing port 80 to the host computer,
    and connecting to the `nat` network:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 从镜像运行容器，将端口80发布到主机计算机，并连接到`nat`网络：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now you can browse to http://localhost:800/image and you’ll see some JSON details
    about NASA’s image of the day. On the day I ran the container, the image was from
    a solar eclipse—figure A.6 shows the details from my API.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以浏览到 http://localhost:800/image，你会看到关于 NASA 当日图像的一些 JSON 详细信息。在我运行容器的那天，图像来自日食——图
    A.6 显示了我 API 的详细信息。
- en: '![](../Images/A-6.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 A.6](../Images/A-6.jpg)'
- en: Figure A.6 The cached details from NASA in my application container
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.6 我的应用容器中缓存的来自 NASA 的详细信息
- en: The actual application in this container isn’t important (but don’t remove it
    yet-we’ll be using it later in the chapter). What’s important is that you can
    build this on any machine with Docker installed, just by having a copy of the
    source code with the Dockerfile. You don’t need any build tools installed, you
    don’t need a specific version of Java—you just clone the code repo, and you’re
    a couple of Docker commands away from running the app.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在此容器中的实际应用程序并不重要（但请不要删除它——我们将在本章后面使用它）。重要的是，你可以在安装了 Docker 的任何机器上构建它，只需有一个包含
    Dockerfile 的源代码副本即可。你不需要安装任何构建工具，也不需要特定的 Java 版本——你只需克隆代码仓库，然后通过几个 Docker 命令就可以运行应用程序。
- en: 'One other thing to be really clear on here: the build tools are not part of
    the final application image. You can run an interactive container from your new
    `image-of-the-day` Docker image, and you’ll find there’s no `mvn` command in there.
    Only the contents of the final stage in the Dockerfile get made into the application
    image; anything you want from previous stages needs to be explicitly copied in
    that final stage.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另一件需要非常清楚的事情：构建工具不是最终应用程序图像的一部分。你可以从新的 `image-of-the-day` Docker 图像运行一个交互式容器，你会发现里面没有
    `mvn` 命令。只有 Dockerfile 中的最终阶段的全部内容被制作成应用程序图像；任何你想要从先前阶段的内容都需要在最终阶段显式复制。
- en: 'A.3 App walkthrough: Node.js source code'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 应用程序操作流程：Node.js 源代码
- en: We’re going to go through another multi-stage Dockerfile, this time for a Node.js
    application. Organizations are increasingly using diverse technology stacks, so
    it’s good to have an understanding of how different builds look in Docker. Node.js
    is a great option because of its popularity, and also because it’s an example
    of a different type of build—this pattern also works with other scripted languages
    like Python, PHP, and Ruby. The source code for this app is at the folder path
    `ch04/exercises/ access-log`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将浏览另一个多阶段 Dockerfile，这次是为 Node.js 应用程序。随着组织越来越多地使用多样化的技术栈，了解不同的构建在 Docker
    中的外观是很有帮助的。Node.js 是一个很好的选择，因为它很受欢迎，而且它也是一个不同类型构建的例子——这种模式也适用于其他脚本语言，如 Python、PHP
    和 Ruby。此应用程序的源代码位于文件夹路径 `ch04/exercises/ access-log`。
- en: Java applications are compiled, so the source code gets copied into the build
    stage, and that generates a JAR file. The JAR file is the compiled app, and it
    gets copied into the final application image, but the source code is not. It’s
    the same with .NET Core, where the compiled artifacts are DLLs (Dynamic Link Libraries).
    Node.js is different—it uses JavaScript, which is an interpreted language, so
    there’s no compilation step. Dockerized Node.js apps need the Node.js runtime
    and the source code in the application image.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Java 应用程序是编译的，因此源代码被复制到构建阶段，从而生成一个 JAR 文件。JAR 文件是编译后的应用程序，它被复制到最终应用程序图像中，但源代码不是。对于
    .NET Core 也是如此，编译后的工件是 DLL（动态链接库）。Node.js 是不同的——它使用 JavaScript，这是一种解释型语言，因此没有编译步骤。容器化的
    Node.js 应用程序需要在应用程序图像中包含 Node.js 运行时和源代码。
- en: 'There’s still a need for a multi-stage Dockerfile though: it optimizes dependency
    loading. Node.js uses a tool called npm (the Node package manager) to manage dependencies.
    Listing A.3 shows the full Dockerfile for this chapter’s Node.js application.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，仍然需要一个多阶段 Dockerfile：它优化了依赖项加载。Node.js 使用一个名为 npm（Node 包管理器）的工具来管理依赖项。附录
    A.3 列出了本章 Node.js 应用程序的完整 Dockerfile。
- en: Listing A.3 Dockerfile for building a Node.js app with npm
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 A.3 构建 Node.js 应用程序的 Dockerfile
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The goal here is the same as for the Java application—to package and run the
    app with only Docker installed, without having to install any other tools. The
    base image for both stages is `diamol/node`, which has the Node.js runtime and
    npm installed. The builder stage in the Dockerfile copies in the `package.json`
    files, which describe all the application’s dependencies. Then it runs `npm` `install`
    to download the dependencies. There’s no compilation, so that’s all it needs to
    do.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标与 Java 应用程序相同——仅安装 Docker 就可以打包和运行应用程序，无需安装任何其他工具。两个阶段的基镜像都是 `diamol/node`，其中包含
    Node.js 运行时和 npm。Dockerfile 中的构建阶段复制 `package.json` 文件，这些文件描述了应用程序的所有依赖项。然后它运行
    `npm install` 来下载依赖项。没有编译，所以这就是它需要做的。
- en: This application is another REST API. In the final application stage, the steps
    expose the HTTP port and specify the `node` command line as the startup command.
    The last thing is to create a working directory and copy in the application artifacts.
    The downloaded dependencies are copied from the builder stage, and the source
    code is copied from the host computer. The `src` folder contains the JavaScript
    files, including `server.js`, which is the entry point started by the Node.js
    process.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序是另一个 REST API。在最终的应用程序阶段，步骤暴露 HTTP 端口并指定 `node` 命令行作为启动命令。最后要做的是创建一个工作目录并将应用程序工件复制进去。下载的依赖项从构建阶段复制过来，源代码从主机计算机复制过来。`src`
    文件夹包含 JavaScript 文件，包括 `server.js`，这是由 Node.js 进程启动的入口点。
- en: We have a different technology stack here, with a different pattern for packaging
    the application. The base images, tools, and commands for a Node.js app are all
    different from a Java app, but those differences are captured in the Dockerfile.
    The process for building and running the app is exactly the same.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有不同的技术堆栈，用于打包应用程序的模式也不同。Node.js 应用程序的基镜像、工具和命令都与 Java 应用程序不同，但这些差异都记录在
    Dockerfile 中。构建和运行应用程序的过程完全相同。
- en: 'Try it now Browse to the Node.js application source code and build the image:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '现在试试 Browse to the Node.js application source code and build the image:'
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You’ll see a whole lot of output from npm (which may show some error and warning
    messages too, but you can ignore those). Figure A.7 shows part of the output from
    my build. The packages that are downloaded get saved in the Docker image layer
    cache, so if you work on the app and just make code changes, the next build you
    run will be super fast.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到 npm（可能还会显示一些错误和警告消息，但您可以忽略这些）的大量输出。图 A.7 显示了我构建的部分输出。下载的软件包被保存在 Docker
    镜像层缓存中，所以如果您只对应用程序进行代码更改，下一次构建将非常快。
- en: '![](../Images/A-7.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/A-7.jpg)'
- en: Figure A.7 Building a multi-stage Dockerfile for a Node.js application
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.7 为 Node.js 应用程序构建多阶段 Dockerfile
- en: The Node.js app you’ve just built is not at all interesting, but you should
    still run it to check that it’s packaged correctly. It’s a REST API that other
    services can call to write logs. There’s an HTTP `POST` endpoint for recording
    a new log, and a `GET` endpoint that shows how many logs have been recorded.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚构建的 Node.js 应用程序并不有趣，但您仍然应该运行它以检查它是否正确打包。这是一个 REST API，其他服务可以调用它来记录日志。有一个
    HTTP `POST` 端点用于记录新的日志，还有一个 `GET` 端点显示记录了多少日志。
- en: 'Try it now Run a container from the log API image, publishing port 80 to host
    and connecting it to the same `nat` network:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '现在试试 Run a container from the log API image, publishing port 80 to host and
    connecting it to the same `nat` network:'
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now browse to http://localhost:801/stats and you’ll see how many logs the service
    has recorded. Figure A.8 shows I have zero logs so far—Firefox nicely formats
    the API response, but you may see the raw JSON in other browsers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，浏览到 http://localhost:801/stats，您将看到服务记录了多少日志。图 A.8 显示我目前还没有任何日志——Firefox
    很好地格式化了 API 响应，但您可能在其他浏览器中看到原始 JSON。
- en: '![](../Images/A-8.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/A-8.jpg)'
- en: Figure A.8 Running the Node.js API in a container
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.8 在容器中运行 Node.js API
- en: The log API is running in Node.js version 10.16, but just like with the Java
    example, you don’t need any versions of Node.js or any other tools installed to
    build and run this app. The workflow in this Dockerfile downloads dependencies
    and then copies the script files into the final image. You can use the exact same
    approach with Python, using Pip for dependencies, or Ruby using Gems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 日志 API 正在 Node.js 版本 10.16 上运行，但就像 Java 示例一样，您不需要安装任何版本的 Node.js 或其他工具来构建和运行此应用程序。此
    Dockerfile 中的工作流程下载依赖项，然后将脚本文件复制到最终镜像中。您可以使用完全相同的方法使用 Python，使用 Pip 进行依赖项管理，或使用
    Ruby 的 Gems。
- en: 'A.4 App walkthrough: Go source code'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.4 应用程序概述：Go 源代码
- en: We’ve got one last example of a multi-stage Dockerfile—for a web application
    written in Go. Go is a modern, cross-platform language that compiles to native
    binaries. That means you can compile your apps to run on any platform (Windows,
    Linux, Intel, or Arm), and the compiled output is the complete application. You
    don’t need a separate runtime installed like you do with Java, .NET Core, Node.js,
    or Python, and that makes for extremely small Docker images.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个多阶段Dockerfile的例子——这是一个用Go编写的Web应用。Go是一种现代、跨平台的编程语言，可以编译成本地二进制文件。这意味着你可以编译你的应用以在任何平台上运行（Windows、Linux、Intel或Arm），编译输出是完整的应用程序。你不需要像Java、.NET
    Core、Node.js或Python那样安装单独的运行时，这使得Docker镜像非常小。
- en: There are a few other languages that also compile to native binaries—Rust and
    Swift are popular—but Go has the widest platform support, and it’s also a very
    popular language for cloud-native apps (Docker itself is written in Go). Building
    Go apps in Docker means using a multi-stage Dockerfile approach similar to the
    one you used for the Java app, but there are some important differences. Listing
    A.4 shows the full Dockerfile.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几种其他语言也可以编译成本地二进制文件——Rust和Swift很受欢迎，但Go具有最广泛的平台支持，它也是云原生应用（Docker本身是用Go编写的）非常流行的语言。在Docker中构建Go应用意味着使用类似于为Java应用使用的方法的多阶段Dockerfile方法，但有一些重要的区别。列表A.4显示了完整的Dockerfile。
- en: Listing A.4 Dockerfile for building a Go application from source
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.4 从源代码构建Go应用的Dockerfile
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Go compiles to native binaries, so each stage in the Dockerfile uses a different
    base image. The builder stage uses `diamol/golang`, which has all the Go tools
    installed. Go applications don’t usually fetch dependencies, so this stage goes
    straight to building the application (which is just one code file, `main.go`).
    The final application stage uses a minimal image, which just has the smallest
    layer of operating system tools, called `diamol/base`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Go编译成本地二进制文件，因此Dockerfile中的每个阶段都使用不同的基础镜像。构建阶段使用`diamol/golang`，其中安装了所有Go工具。Go应用通常不获取依赖项，因此这个阶段直接构建应用程序（仅有一个代码文件，`main.go`）。最终的应用程序阶段使用最小镜像，它只包含最小的操作系统工具层，称为`diamol/base`。
- en: The Dockerfile captures some configuration settings as environment variables
    and specifies the startup command as the compiled binary. The application stage
    ends by copying in the HTML file the application serves from the host and the
    web server binary from the builder stage. Binaries need to be explicitly marked
    as executable in Linux, which is what the final `chmod` command does (this has
    no effect on Windows).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile捕获了一些配置设置作为环境变量，并指定启动命令为编译后的二进制文件。应用阶段通过从主机复制应用所服务的HTML文件和构建阶段的Web服务器二进制文件结束。在Linux中，二进制文件需要显式标记为可执行，这就是最终`chmod`命令的作用（在Windows上没有影响）。
- en: 'Try it now Browse to the Go application source code and build the image:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧 浏览到Go应用源代码并构建镜像：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This time there won’t be a lot of compiler output, because Go is quiet and only
    writes logs when there are failures. You can see my abbreviated output in figure
    A.9.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这次不会有太多的编译器输出，因为Go很安静，只有在失败时才写入日志。你可以在图A.9中看到我简化的输出。
- en: '![](../Images/A-9.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图A-9](../Images/A-9.jpg)'
- en: Figure A.9 Building a Go application in a multi-stage Dockerfile
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.9 在多阶段Dockerfile中构建Go应用
- en: This Go application does do something useful, but before you run it, it’s worth
    taking a look at the size of the images that go in and come out.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Go应用确实做了些有用的事情，但在运行它之前，看看输入和输出的镜像大小是值得的。
- en: 'Try it now Compare the Go application image size with the Go toolset image:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧 比较Go应用镜像大小与Go工具集镜像：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Many Docker commands let you filter the output. This command lists all images
    and filters the output to only include images with a reference of `diamol/golang`
    or `image-gallery`—the reference is really just the image name. When you run this,
    you’ll see how important it is to choose the right base images for your Dockerfile
    stages:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Docker命令允许您过滤输出。此命令列出所有镜像，并过滤输出以仅包括具有`diamol/golang`或`image-gallery`引用的镜像——引用实际上只是镜像名称。当你运行这个命令时，你会看到选择正确的Dockerfile阶段的基础镜像是多么重要：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: On Linux, the image with all the Go tools installed comes in at over 770 MB;
    the actual Go application image is only 25 MB. Remember, that’s the virtual image
    size, so a lot of those layers can be shared between different images. The important
    saving isn’t so much the disk space, but all the software that *isn’t* in the
    final image. The application doesn’t need any of the Go tools at runtime. By using
    a minimal base image for the application, we’re saving nearly 750 MB of software,
    which is a huge reduction in the surface area for potential attacks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，安装了所有 Go 工具的镜像超过 770 MB；实际的 Go 应用程序镜像只有 25 MB。记住，这是虚拟镜像大小，所以很多层可以在不同的镜像之间共享。重要的节省并不是磁盘空间，而是最终镜像中不存在的所有软件。应用程序在运行时不需要任何
    Go 工具。通过为应用程序使用最小的基础镜像，我们节省了近 750 MB 的软件，这大大减少了潜在攻击的表面积。
- en: Now you can run the app. This ties together your work in this chapter, because
    the Go application actually uses the APIs from the other applications you’ve built.
    You should make sure you have those containers running, with the correct names
    from the earlier try-it-now exercises. If you run `docker` `container` `ls`, you
    should see two containers from this chapter—the Node.js container called `accesslog`
    and the Java container called `iotd`. When you run the Go container, it will use
    the APIs from the other containers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行该应用。这总结了本章的工作，因为 Go 应用程序实际上使用了你构建的其他应用的 API。你应该确保那些容器正在运行，并且具有之前“试试看”练习中正确的名称。如果你运行
    `docker` `container` `ls`，你应该看到本章的两个容器——名为 `accesslog` 的 Node.js 容器和名为 `iotd`
    的 Java 容器。当你运行 Go 容器时，它将使用其他容器的 API。
- en: 'Try it now Run the Go application image, publishing the host port and connecting
    to the `nat` network:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试它 运行 Go 应用程序镜像，发布主机端口并连接到 `nat` 网络：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can browse to http://localhost:802 and you’ll see NASA’s Astronomy Picture
    of the Day. Figure A.10 shows the image when I ran my containers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以浏览到 http://localhost:802，你会看到 NASA 的每日天文图片。图 A.10 显示了我运行容器时的图像。
- en: '![](../Images/A-10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 A.10](../Images/A-10.jpg)'
- en: Figure A.10 The Go web application, showing data fetched from the Java API
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.10 Go 网络应用，显示从 Java API 获取的数据
- en: Right now you’re running a distributed application across three containers.
    The Go web application calls the Java API to get details of the image to show,
    and then it calls the Node.js API to log that the site has been accessed. You
    didn’t need to install any tools for any of those languages to build and run all
    the apps; you just needed the source code and Docker.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你正在运行一个跨越三个容器的分布式应用。Go 网络应用调用 Java API 获取要显示的图像详情，然后调用 Node.js API 记录网站已被访问。你不需要为任何这些语言安装任何工具来构建和运行所有应用；你只需要源代码和
    Docker。
- en: Multi-stage Dockerfiles make your project entirely portable. You might use Jenkins
    to build your apps right now, but you could try AppVeyor’s managed CI service
    or Azure DevOps without having to write any new pipeline code—they all support
    Docker, so your pipeline is just `docker` `image` `build`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段 Dockerfile 使你的项目完全可移植。你可能现在使用 Jenkins 来构建你的应用，但你可以尝试 AppVeyor 的托管 CI 服务或
    Azure DevOps，而无需编写任何新的管道代码——它们都支持 Docker，所以你的管道只是 `docker` `image` `build`。
- en: A.5 Understanding multi-stage Dockerfiles
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.5 理解多阶段 Dockerfile
- en: We’ve covered a lot of ground in this chapter, and I’m going to end with some
    key points so you’re really clear on how multi-stage Dockerfiles work, and why
    it’s incredibly useful to build your apps inside containers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中覆盖了很多内容，我将用一些关键点结束，以便你真正清楚地了解多阶段 Dockerfile 的工作原理，以及为什么在容器内构建你的应用是极其有用的。
- en: The first point is about standardization. I know when you run the exercises
    for this chapter that your builds will succeed and your apps will work because
    you’re using the exact same set of tools that I’m using. It doesn’t matter what
    operating system you have or what’s installed on your machine—all the builds run
    in Docker containers, and the container images have all the correct versions of
    the tools. In your real projects you’ll find that this hugely simplifies on-boarding
    for new developers, eliminates the maintenance burden for build servers, and removes
    the potential for breakages where users have different versions of tools.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点是关于标准化。我知道当你运行本章的练习时，你的构建将会成功，你的应用将会工作，因为你正在使用与我完全相同的工具集。无论你有什么操作系统，或者你的机器上安装了什么，所有的构建都在
    Docker 容器中运行，容器镜像包含了所有正确的工具版本。在你的真实项目中，你会发现这极大地简化了新开发者的入职流程，消除了构建服务器的维护负担，并消除了用户拥有不同版本工具时可能出现的故障风险。
- en: The second point is performance. Each stage in a multi-stage build has its own
    cache. Docker looks for a match in the image layer cache for each instruction;
    if it doesn’t find one, the cache is broken and all the rest of the instructions
    are executed—but only for that stage. The next stage starts again from the cache.
    You’ll be spending time structuring your Dockerfiles carefully, and when you get
    the optimization done, you’ll find 90% of your build steps use the cache.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是性能。多阶段构建中的每个阶段都有自己的缓存。Docker 会为每条指令在镜像层缓存中查找匹配项；如果没有找到，缓存就会损坏，并且所有其余的指令都将执行——但仅限于该阶段。下一个阶段将从缓存重新开始。你将花费时间仔细结构你的
    Dockerfile，当你完成优化后，你会发现 90% 的构建步骤都使用了缓存。
- en: The final point is that multi-stage Dockerfiles let you fine-tune your build
    so the final application image is as lean as possible. This is not just for compilers-any
    tooling you need can be isolated in earlier stages, so the tool itself isn’t present
    in the final image. A good example is curl—a popular command-line tool you can
    use for downloading content from the internet. You might need that to download
    files your app needs, but you can do that in an early stage in your Dockerfile
    so curl itself isn’t installed in your application image. This keeps image size
    down, which means faster startup times, but it also means you have less software
    available in your application image, which means fewer potential exploits for
    attackers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是，多阶段 Dockerfile 允许你精细调整构建，使最终的应用程序镜像尽可能精简。这不仅仅是为了编译器——你需要用到的任何工具都可以在早期阶段隔离，因此工具本身不会出现在最终镜像中。一个好的例子是
    curl——一个流行的命令行工具，你可以用它从互联网上下载内容。你可能需要它来下载你的应用程序需要的文件，但你可以在 Dockerfile 的早期阶段完成这个操作，这样
    curl 本身就不会安装在你的应用程序镜像中。这可以降低镜像大小，意味着更快的启动时间，但也意味着你的应用程序镜像中可用的软件更少，这意味着攻击者有更少的潜在漏洞可以利用。
- en: A.6 Lab
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.6 实验室
- en: Lab time! You’re going to put into practice what you’ve learned about multi-stage
    builds and optimizing Dockerfiles. In the source code for the book, you’ll find
    a folder at `ch04/lab` which is your starting point. It’s a simple Go web server
    application, which already has a Dockerfile, so you can build and run it in Docker.
    But the Dockerfile is in dire need of optimizing, and that is your job.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 实验时间！你将把关于多阶段构建和优化 Dockerfile 的知识付诸实践。在本书的源代码中，你会在 `ch04/lab` 文件夹中找到一个起点。这是一个简单的
    Go 网络服务器应用程序，它已经有一个 Dockerfile，因此你可以在 Docker 中构建和运行它。但 Dockerfile 非常需要优化，这就是你的任务。
- en: 'There are specific goals for this lab:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验室有具体的目标：
- en: Start by building an image using the existing Dockerfile, and then optimize
    the Dockerfile to produce a new image.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，使用现有的 Dockerfile 构建一个镜像，然后优化 Dockerfile 以生成一个新的镜像。
- en: The current image is 800 MB on Linux and 5.2 GB on Windows. Your optimized image
    should be around 15 MB on Linux or 260 MB on Windows.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前镜像在 Linux 上为 800 MB，在 Windows 上为 5.2 GB。你的优化镜像在 Linux 上应约为 15 MB，在 Windows
    上约为 260 MB。
- en: If you change the HTML content with the current Dockerfile, the build executes
    seven steps.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用当前的 Dockerfile 更改 HTML 内容，构建将执行七个步骤。
- en: Your optimized Dockerfile should only execute a single step when you change
    the HTML.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你更改 HTML 时，你的优化 Dockerfile 应只执行一个步骤。
- en: 'As always, there’s a sample solution on the book’s GitHub repository. But this
    is one lab you should really try and find time to do, because optimizing Dockerfiles
    is a valuable skill you’ll use in every project. If you need it, though, my solution
    is here: [https://github.com/sixeyed/diamol/blob/master/ch04/lab/Dockerfile.optimized](https://github.com/sixeyed/diamol/blob/master/ch04/lab/Dockerfile.optimized).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，在本书的 GitHub 仓库中有示例解决方案。但这个实验室你真的应该尝试并抽出时间来做，因为优化 Dockerfile 是你在每个项目中都会用到的宝贵技能。如果你需要的话，我的解决方案在这里：[https://github.com/sixeyed/diamol/blob/master/ch04/lab/Dockerfile.optimized](https://github.com/sixeyed/diamol/blob/master/ch04/lab/Dockerfile.optimized)。
- en: No hints this time, although I would say this sample app looks very similar
    to one you’ve already built in this chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有提示，尽管我可以这么说，这个示例应用程序看起来非常类似于你在本章中已经构建的一个。
