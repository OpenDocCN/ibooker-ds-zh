- en: 6 Working with strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 处理字符串
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: UTF-8 encoding of Julia strings; byte versus character indexing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 字符串的 UTF-8 编码；字节与字符索引
- en: 'Manipulating strings: interpolation, splitting, using regular expressions,
    parsing'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串操作：插值、分割、使用正则表达式、解析
- en: Working with symbols
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理符号
- en: Using the InlineStrings.jl package to work with fixed-width strings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 InlineStrings.jl 包处理固定宽度字符串
- en: Using the PooledArrays.jl package to compress vectors of strings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PooledArrays.jl 包压缩字符串向量
- en: In this chapter, you will learn how to handle text data in the Julia language.
    Text data is stored in strings. *Strings* are one of the most common data types
    that you will encounter when doing data science projects, especially involving
    natural language processing tasks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在 Julia 语言中处理文本数据。文本数据存储在字符串中。*字符串* 是你在进行数据科学项目时最常遇到的数据类型之一，尤其是在涉及自然语言处理任务时。
- en: As an application of string processing, we will analyze movie genres that were
    given ratings by Twitter users. We want to understand which movie genre is most
    common and how the relative frequency of this genre changes with the movie year.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为字符串处理的实际应用，我们将分析被 Twitter 用户评分的电影类型。我们希望了解哪种电影类型最常见，以及这种类型的相对频率如何随电影年份变化。
- en: For this analysis, we will use the movies.dat file. The file URL is [http://mng.bz/9Vao](http://mng.bz/9Vao),
    and the file is shared on the GitHub repository [https://github.com/sidooms/MovieTweetings](https://github.com/sidooms/MovieTweetings)
    under an MIT license.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这次分析，我们将使用 movies.dat 文件。文件 URL 是 [http://mng.bz/9Vao](http://mng.bz/9Vao)，该文件在
    GitHub 仓库 [https://github.com/sidooms/MovieTweetings](https://github.com/sidooms/MovieTweetings)
    下以 MIT 许可证共享。
- en: 'We will analyze the movie genre data according to the following steps, which
    are described in the subsequent sections of this chapter and depicted in figure
    6.1:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据以下步骤分析电影类型数据，这些步骤在本章的后续部分中描述，并在图 6.1 中展示：
- en: Get the data from the web.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从网络获取数据。
- en: Read in the data in Julia.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Julia 中读取数据。
- en: Parse the original data to extract the year and genre list for each analyzed
    movie.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析原始数据以提取每部分析电影的年份和类型列表。
- en: Create frequency tables to find which movie genre is most common.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建频率表以找出哪种电影类型最常见。
- en: Create a plot of popularity of the most common genre by year.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按年份创建最常见类型的流行度图表。
- en: '![CH06_F01_Kaminski2](../Images/CH06_F01_Kaminski2.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F01_Kaminski2](../Images/CH06_F01_Kaminski2.png)'
- en: 'Figure 6.1 Steps of our analysis: each step lists the most important Julia
    functions used and the packages that provide them'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 分析步骤：每个步骤列出使用的重要 Julia 函数和提供它们的包
- en: Through the analysis, you will learn what it means that strings in Julia are
    UTF-8 encoded and how you should take this fact into account when working with
    strings.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析，你将了解 Julia 中的字符串是 UTF-8 编码的含义，以及你在处理字符串时应如何考虑这一事实。
- en: 'At the end of this chapter, we will discuss performance issues when working
    with strings. You’ll learn about the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们将讨论处理字符串时的性能问题。你将了解以下内容：
- en: Using symbols instead of strings when analyzing text data
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分析文本数据时使用符号而不是字符串
- en: Using fixed-width strings provided by the InlineStrings.jl package
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 InlineStrings.jl 包提供的固定宽度字符串
- en: Compressing vectors of strings by using the PooledArrays.jl package
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PooledArrays.jl 包压缩字符串向量
- en: 6.1 Getting and inspecting the data
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 获取和检查数据
- en: In most data science workflows, the first task you will face is getting the
    data and reading it in before you can start analyzing it. Therefore, in this section,
    we start with learning how to download the source file from the web and inspect
    its contents (for your convenience, the file is also stored in the GitHub repository
    with the source code for this book).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数数据科学工作流程中，你将面临的第一项任务是获取数据并在开始分析之前读取它。因此，在本节中，我们从学习如何从网络下载源文件并检查其内容开始（为了你的方便，该文件也存储在
    GitHub 仓库中，与本书的源代码一起）。
- en: 6.1.1 Downloading files from the web
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 从网络下载文件
- en: First, download the data, as shown in the next listing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，下载数据，如下所示。
- en: Listing 6.1 Fetching the movies.dat file from GitHub
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 从 GitHub 获取 movies.dat 文件
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We use the download function from the Downloads module that takes two arguments:
    the URL location of the file to fetch and the location path where it should be
    saved. In this case, we save the file as movies.dat in the working directory of
    Julia.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用来自 Downloads 模块的 download 函数，该函数接受两个参数：要获取的文件的 URL 位置以及它应该保存的位置路径。在这种情况下，我们将文件保存为
    movies.dat 到 Julia 的工作目录中。
- en: Downloading files on Julia versions earlier than 1.6
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 1.6 之前的版本中下载文件
- en: In Julia versions earlier than 1.6, the download function was available without
    having to use the Downloads module. Although this function is still available
    in Julia 1.7 (the version used in this book), it is deprecated, so I recommend
    you use the Downloads module.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 1.6 之前的版本中，下载功能无需使用 Downloads 模块即可使用。尽管这个功能在 Julia 1.7（本书使用的版本）中仍然可用，但它已被弃用，因此我建议您使用
    Downloads 模块。
- en: 'Observe that in the preceding example, both arguments of the download function
    are string literals. Notice two important points:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上面的示例中，download 函数的两个参数都是字符串字面量。请注意两个重要点：
- en: String literals are enclosed in double quotes (").
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串字面量用双引号（"）括起来。
- en: You can concatenate string literals by using the multiplication operator (*).
    In the preceding example, we split a long string into multiple lines of code and
    concatenated it by using * (in Python, you would use the addition operator (+)
    to concatenate strings).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用乘法运算符（*）连接字符串字面量。在上面的示例中，我们将一个长字符串拆分为多行代码，并通过使用 * 连接它们（在 Python 中，您会使用加法运算符（+）来连接字符串）。
- en: Let me briefly comment next on several standard features that Julia strings
    support.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我简要地评论一下 Julia 字符串支持的一些标准特性。
- en: 6.1.2 Using common techniques of string construction
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 使用字符串构造的常用技术
- en: 'The first convenient feature is that you can interpolate variables into strings
    by using $ inside a string literal. Here is an example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方便的特性是，您可以通过在字符串字面量中使用 $ 来将变量插入到字符串中。以下是一个示例：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this code, the value bound to variable x is interpolated into the string,
    as we write $x inside the string literal. You can also interpolate more complex
    expressions this way, but then you need to wrap them in parentheses:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，绑定到变量 x 的值被插入到字符串中，正如我们在字符串字面量中写入 $x 一样。您也可以以这种方式插入更复杂的表达式，但此时您需要将它们括在括号中：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The second feature is that you can use C’s traditional escaped input forms
    ([https://en.cppreference.com/w/cpp/language/escape](https://en.cppreference.com/w/cpp/language/escape))
    in string literals; for example, to create a string containing a newline, use
    the \n sequence. For instance, the string literal "a\nb" consists of three characters:
    a, followed by a newline, and finally b.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个特性是，您可以在字符串字面量中使用 C 的传统转义输入形式（[https://en.cppreference.com/w/cpp/language/escape](https://en.cppreference.com/w/cpp/language/escape)）；例如，要创建包含换行符的字符串，请使用
    \n 序列。例如，字符串字面量 "a\nb" 由三个字符组成：a，后面跟着一个换行符，最后是 b。
- en: 'In addition to standard escape sequences, Julia introduces two extra ones.
    To write $, you need to escape it with \$. Unescaped $ is used for interpolation,
    as I have explained. Here is an example of the \$ escape sequence at work, showing
    you that using just $ leads to an error:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准转义序列之外，Julia 还引入了两个额外的转义序列。要写入 $，您需要使用 \. 转义它。未转义的 $ 用于插值，如我之前解释的。以下是一个
    \$ 转义序列在起作用的示例，显示仅使用 $ 会导致错误：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Julia displays strings in an interactive session by using an escaped form.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Julia 通过使用转义形式在交互会话中显示字符串。
- en: 'The second extension is \ immediately followed by a newline. This sequence
    allows you to split long strings into multiple lines. Therefore, instead of using
    * in listing 6.1, we could have written this to get the same result:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个扩展是 \ 紧接着一个换行符。这个序列允许您将长字符串拆分为多行。因此，我们可以在列表 6.1 中使用 *，而不是这样写以获得相同的结果：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, the newline following the \ and any leading whitespace (typically
    used for code indentation) in the following line are ignored, as you can see here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，\ 后面的换行符以及下一行中的任何前导空白（通常用于代码缩进）都被忽略，正如您在这里看到的：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Sometimes you might want to avoid both special handling of C’s escaped input
    forms and interpolation. You can easily avoid them by using the raw prefix in
    front of the string literal (these literals are then called *raw string literals*).
    I use this feature most often when I work on Windows and need to write paths.
    Here is an example. If you try writing a standard Windows path in a standard string
    literal, most likely you will get an error:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能想避免C的转义输入形式的特殊处理和插值。你可以通过在字符串字面量前使用raw前缀轻松避免它们（这些字面量被称为*原始字符串字面量*）。我在Windows上工作时最常使用这个特性来编写路径。以下是一个例子。如果你尝试在一个标准的字符串字面量中写入标准的Windows路径，很可能会出错：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This error occurs because Julia treats \m as an invalid escape sequence. We
    can easily fix this problem with the raw prefix:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误发生是因为Julia将\m视为无效的转义序列。我们可以通过使用raw前缀轻松解决这个问题：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Everything works this time. Note that the string is still displayed as a standard
    string. Each \ character is displayed as \\ because this is the escape sequence
    interpreted as \ in standard strings. If you would like to print the undecorated
    text representation of the string, use the print function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这次一切正常。请注意，字符串仍然显示为标准字符串。每个\字符显示为\\，因为这是在标准字符串中解释为\的转义序列。如果你想打印字符串的未装饰文本表示，请使用print函数：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The second special string literal that you might encounter in Julia code is
    the triple quoted string. These literals begin and end with three quotes (""").
    They are typically used to create longer blocks of text that span multiple lines.
    We do not use these literals in this book, but if you are interested in the details,
    you can find them in the Julia Manual at [http://mng.bz/jAjp](http://mng.bz/jAjp).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia代码中，你可能会遇到第二种特殊的字符串字面量，即三引号字符串。这些字面量以三个引号（""")开始和结束。它们通常用于创建跨越多行的长文本块。在这本书中，我们不使用这些字面量，但如果你对细节感兴趣，可以在Julia手册中找到它们，网址为[http://mng.bz/jAjp](http://mng.bz/jAjp)。
- en: 'Now that you know the basics of creating string literals, let’s see how to
    read strings from disk. First, we check that the movies.dat file was downloaded
    by using the isfile function to see if the file is present in the current working
    directory:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了创建字符串字面量的基础知识，让我们看看如何从磁盘读取字符串。首先，我们使用isfile函数检查movies.dat文件是否已下载，以查看文件是否存在于当前工作目录中：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 6.1.3 Reading the contents of a file
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 读取文件内容
- en: The function returns true, which means that the file is present. Let’s read
    its contents line by line and bind the result to the movies variable in the next
    listing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回true，这意味着文件存在。让我们逐行读取其内容，并将结果绑定到下一列表中的movies变量。
- en: Listing 6.2 Reading the movies.dat file into a vector
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2 将movies.dat文件读入向量
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The readlines function reads all lines from the file as a vector of strings.
    Each string in the vector represents one line of our data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: readlines函数读取文件中的所有行，作为一个字符串向量。向量中的每个字符串代表我们数据中的一行。
- en: 'Looking at the data, we can see that each entry about a movie (line in a file)
    has the following structure:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 观察数据，我们可以看到关于每部电影（文件中的一行）的条目具有以下结构：
- en: '![CH06_UN01_Kaminski2](../Images/CH06_UN01_Kaminski2.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_UN01_Kaminski2](../Images/CH06_UN01_Kaminski2.png)'
- en: 'The first part is the movie’s numeric identifier of a movie. It is followed,
    after the :: separator, by the movie title. Next follows the movie year in parentheses.
    Finally, after the next :: separator, we have genres that match the movie. If
    we have several genres, they are separated by a pipe (|).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是电影的数字标识符。它由冒号（::）分隔符后跟电影标题。接下来是括号中的电影年份。最后，在下一个冒号分隔符之后，我们有与电影匹配的流派。如果我们有多个流派，它们由竖线（|）分隔。
- en: 6.2 Splitting strings
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 分割字符串
- en: When working with data, you often face a challenge because it has to be preprocessed
    before it can be used for analysis. The most basic type of preprocessing is splitting
    strings containing multiple pieces of information. This is the skill that you
    will learn in this section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理数据时，你经常会面临挑战，因为在使用它进行分析之前，必须先对其进行预处理。最基本的预处理类型是分割包含多个信息片段的字符串。这是你将在本节中学到的技能。
- en: 'For each movie, we’ll extract the year of the movie from this string along
    with a list of its genres. However, before we do that for all strings, I’ll show
    you how to do it on the first string in the list. We start by extracting it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每部电影，我们将从该字符串中提取电影的年份及其流派列表。然而，在我们对所有字符串这样做之前，我会向你展示如何对列表中的第一个字符串进行操作。我们首先提取它：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that we have used the first function to fetch the first element of the
    vector movies. The first function we will use to work with this string is split.
    It takes two arguments: the string to split and a delimiter on which the string
    should be split. By default, the delimiter is whitespace, but in our case, we
    will first want to use ::. Let’s try using the split function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了第一个函数来获取movies向量的第一个元素。我们将使用的第一个与字符串一起工作的函数是split。它接受两个参数：要分割的字符串和用于分割字符串的分隔符。默认情况下，分隔符是空白字符，但在这个例子中，我们首先想使用::。让我们尝试使用split函数：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The movie1_parts variable now holds a vector of three strings, as expected.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: movie1_parts变量现在包含三个字符串的向量，正如预期的那样。
- en: You might have noticed that the movies vector has the type Vector{String}, while
    the movie1_parts vector has the type Vector{SubString{String}}. This is because
    Julia, for efficiency, when splitting a string with the split function, does not
    copy the string but instead creates a SubString{String} object that points to
    the slice of the original string. Having this behavior is safe, as strings in
    Julia are immutable (we already talked about mutable and immutable types in chapter
    4). Therefore, once the string is created, its contents cannot be changed. Creation
    of a substring of a string is guaranteed to be a safe operation. In your code,
    if you want to create a SubString{String}, you can use the view function or the
    @view macro on a String.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，movies向量具有Vector{String}类型，而movie1_parts向量具有Vector{SubString{String}}类型。这是因为Julia为了效率，在split函数分割字符串时，不会复制字符串，而是创建一个指向原始字符串切片的SubString{String}对象。这种行为是安全的，因为Julia中的字符串是不可变的（我们已经在第4章中讨论了可变和不可变类型）。因此，一旦字符串被创建，其内容就不能被更改。创建字符串的子字符串是一个保证安全的操作。在你的代码中，如果你想创建一个SubString{String}，你可以使用view函数或String上的@view宏。
- en: 'Since String and SubString{String} are both strings, there must be a more general,
    abstract concept of a string in Julia. Indeed, there is:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于String和SubString{String}都是字符串，因此Julia中必须有一个更一般的字符串抽象概念。确实如此：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Both string types that we have encountered are subtypes of AbstractString. In
    Julia, AbstractString is the type representing all strings (in this chapter, we
    will soon discuss even more subtypes of this type).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的所有字符串类型都是AbstractString的子类型。在Julia中，AbstractString是表示所有字符串的类型（在本章中，我们很快将讨论这个类型的更多子类型）。
- en: When should AbstractString be used?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在什么情况下使用AbstractString？
- en: When annotating types of function arguments that should be strings, use AbstractString
    instead of String (unless you really require the String type, which is rare).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当注释函数参数的类型应为字符串时，使用AbstractString而不是String（除非你确实需要String类型，这种情况很少）。
- en: 'For instance, this is a good style of defining a function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个定义函数的好风格：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using a String instead of AbstractString in this definition is not recommended,
    as then this function would not work with SubString{String} arguments.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个定义中使用String而不是AbstractString是不推荐的，因为这样这个函数就不会与SubString{String}参数一起工作。
- en: 'The split function is one of many that are available in Base Julia for working
    with strings. You can find documentation for all of them in the “Strings” section
    of the Julia Manual ([https://docs.julialang.org/en/v1/base/strings/](https://docs.julialang.org/en/v1/base/strings/)).
    Here are several of the commonly used ones:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: split函数是Base Julia中用于处理字符串的许多函数之一。你可以在Julia手册的“字符串”部分找到它们的文档（[https://docs.julialang.org/en/v1/base/strings/](https://docs.julialang.org/en/v1/base/strings/)）。以下是一些常用的函数：
- en: string—Converts passed values to a string by using the print function
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: string—通过使用print函数将传递的值转换为字符串
- en: join—Joins elements of an iterator into a string, inserting the given delimiter
    between joined items
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: join—将迭代器的元素连接成一个字符串，在连接的项之间插入给定的分隔符
- en: occursin—Checks if the first argument is a substring of the second argument
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: occursin—检查第一个参数是否是第二个参数的子字符串
- en: contains—Checks if the second argument is a substring of the first argument
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: contains—检查第二个参数是否是第一个参数的子字符串
- en: replace—Finds in a given string passed patterns and replaces them with specified
    values
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: replace—在给定的字符串中查找传递的模式，并用指定的值替换它们
- en: strip—Strips leading and trailing characters (by default, whitespace) from a
    string (also related are lstrip and rstrip for stripping leading and trailing
    characters)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: strip—从字符串中删除前导和尾随字符（默认为空白字符）（相关的是lstrip和rstrip，用于删除前导和尾随字符）
- en: startswith—Checks if a given string starts with a passed prefix
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: startswith—检查给定的字符串是否以传递的前缀开始
- en: endswith—Checks if a given string ends with a passed suffix
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: endswith—检查给定的字符串是否以传递的后缀结束
- en: uppercase—Uppercases a string
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uppercase—将字符串转换为大写
- en: lowercase—Lowercases a string
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lowercase—将字符串转换为小写
- en: randstring—Creates random strings (defined in the Random module)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: randstring—创建随机字符串（在Random模块中定义）
- en: 6.3 Using regular expressions to work with strings
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 使用正则表达式处理字符串
- en: In the previous section, you learned to extract information from strings by
    using the split function when data is separated by a fixed character sequence.
    Now we move on to discussing how to use regular expressions to extract portions
    of a string following more general patterns.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何通过使用split函数从以固定字符序列分隔的数据中提取信息。现在我们继续讨论如何使用正则表达式来提取字符串中遵循更通用模式的片段。
- en: 'Once we have created the movie1_parts variable, we can split its second element
    into movie name and year:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了movie1_parts变量，我们可以将其第二个元素分割成电影名称和年份：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will accomplish this by using regular expressions (www.regular-expressions.info).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用正则表达式（www.regular-expressions.info）来完成这项任务。
- en: 6.3.1 Working with regular expressions
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 使用正则表达式
- en: 'The topic of how to write regular expressions is wide; I recommend *Mastering
    Regular Expressions* by Jeffrey E. F. Friedl (O’Reilly, 2006) if you want to learn
    more about it. Julia supports Perl-compatible regular expressions, as provided
    by the Perl-Compatible Regular Expressions (PCRE) library [(www.pcre.org](https://www.pcre.org/)).
    Here I show you the regular expression we will use and how to write regular expression
    literals in Julia:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如何编写正则表达式的主题非常广泛；如果你想要了解更多关于它的信息，我建议阅读Jeffrey E. F. Friedl的《精通正则表达式》（O’Reilly，2006）。Julia支持Perl兼容的正则表达式，由Perl-Compatible
    Regular Expressions (PCRE)库提供（[www.pcre.org](https://www.pcre.org/))。在这里，我将向你展示我们将使用的正则表达式以及如何在Julia中编写正则表达式字面量：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To create a regular expression literal, prefix a string literal with the letter
    r. The meaning of this regular expression is explained in figure 6.2\. Its most
    important part is that we create two capturing groups by using parentheses. A
    *capturing group* is a way to retrieve parts of the string that we match against
    a regular expression. In our example, we have designed two capturing groups: the
    first one will contain the movie name, and the second one will contain the movie
    year.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个正则表达式字面量，在字符串字面量前加上字母r。这个正则表达式的含义在图6.2中解释。它最重要的部分是我们通过使用括号创建了两个捕获组。一个*捕获组*是一种从与正则表达式匹配的字符串中检索部分内容的方法。在我们的例子中，我们设计了两个捕获组：第一个将包含电影名称，第二个将包含电影年份。
- en: '![CH06_F02_Kaminski2](../Images/CH06_F02_Kaminski2.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F02_Kaminski2](../Images/CH06_F02_Kaminski2.png)'
- en: Figure 6.2 Interpretation of the r"(.+) \((\d{4})\)$" regular expression
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 r"(.+) \((\d{4})\)" 正则表达式的解释
- en: 'You can easily match a regular expression against a string in Julia by using
    the match function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用match函数在Julia中轻松地将正则表达式与字符串匹配：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The m variable is bound to the object representing the result of matching the
    rx regular expression to the movie1_parts[2] string. When the object is displayed,
    we see that it has captured two groups, as expected. These groups can be easily
    retrieved from the m object by using indexing:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: m变量绑定到表示将rx正则表达式与movie1_parts[2]字符串匹配的结果的对象。当对象被显示时，我们可以看到它已经捕获了两组，正如预期的那样。这些组可以通过使用索引从m对象中轻松检索：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This approach is quite convenient. If we want to store the year as a number,
    we should parse it by using the parse function that we already discussed in chapter
    5:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常方便。如果我们想将年份存储为数字，我们应该使用我们在第5章中讨论过的parse函数来解析它：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This was a brief tutorial on regular expressions in Julia. I recommend you read
    the entire “Regular Expressions” section in the Julia Manual ([http://mng.bz/WMBw](http://mng.bz/WMBw))
    if you would like to learn more about how to use them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Julia中正则表达式的一个简要教程。如果你想要了解更多关于如何使用它们的信息，我建议你阅读Julia手册中的整个“正则表达式”部分（[http://mng.bz/WMBw](http://mng.bz/WMBw)）。
- en: 6.3.2 Writing a parser of a single line of movies.dat file
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 编写movies.dat文件单行内容的解析器
- en: We now have all the pieces to write a parser of a single line of the movies.dat
    file. I recommend defining this parser as a function. The next listing shows how
    you could define it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了所有编写movies.dat文件单行解析器的部件。我建议将这个解析器定义为函数。接下来的列表显示了如何定义它。
- en: Listing 6.3 Function parsing a single line of the movies.dat file
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 解析movies.dat文件单行内容的函数
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The parseline function takes a single line from our file and returns a NamedTuple
    containing the movie ID, name, year, and a list of genres. You can find all the
    parts of parsing of the line explained in sections 6.1.2 and 6.1.3\. I will just
    comment that the expression split(parts[3], "|")) takes the third element of the
    parts vector, which contains a list of genres separated by a pipe (|), and then
    splits it again.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: parseline 函数从我们的文件中取一行，并返回一个包含电影 ID、名称、年份和一系列类型的 NamedTuple。你可以在 6.1.2 和 6.1.3
    节中找到对行解析所有部分的解释。我只想评论一下，表达式 split(parts[3], "|")) 取得 parts 向量的第三个元素，它包含由管道（|）分隔的类型列表，然后再次分割它。
- en: 'Let’s see how the function works on the first line of our file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个函数是如何处理我们文件的第一行的：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The obtained result is correct and follows what we expected. For example, to
    get a string with the name of the first movie, we can write record1.name.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的结果是正确的，符合我们的预期。例如，要获取第一部电影的名字字符串，我们可以写 record1.name。
- en: 6.4 Extracting a subset from a string with indexing
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 使用索引从字符串中提取子集
- en: Before we move forward with our analysis of the movies.dat file, let’s pause
    for a moment to discuss how strings are indexed in Julia. String indexing is often
    used to extract a subset of a string.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续分析 movies.dat 文件之前，让我们暂停一下，讨论一下在 Julia 中字符串是如何索引的。字符串索引通常用于提取字符串的一个子集。
- en: 6.4.1 UTF-8 encoding of strings in Julia
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 Julia 中字符串的 UTF-8 编码
- en: To understand string indexing, you must know the fundamentals of UTF-8 encoding
    ([http://mng.bz/49jD](http://mng.bz/49jD)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解字符串索引，你必须了解 UTF-8 编码的基础 ([http://mng.bz/49jD](http://mng.bz/49jD))。
- en: '*UTF-8* is a standard describing how individual characters in a string are
    represented by bytes. Its special feature is that different characters can use
    1, 2, 3, or 4 bytes. This standard is the most frequently used today ([http://mng.bz/QnWR](http://mng.bz/QnWR)),
    and, in particular, is followed in Julia. You can check the sequence of bytes
    in a given string by using the codeunits function. The following listing shows
    examples of strings consisting of one character, but having a different number
    of code units.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*UTF-8* 是一个描述字符串中单个字符如何用字节表示的标准。它的特殊之处在于不同的字符可以使用 1、2、3 或 4 个字节。这个标准是目前最常用的
    ([http://mng.bz/QnWR](http://mng.bz/QnWR))，特别是在 Julia 中。你可以使用 codeunits 函数来检查给定字符串的字节序列。以下列表展示了由一个字符组成但具有不同字节数的字符串的例子。'
- en: Listing 6.4 UTF-8 encodings of single-character strings with different byte
    lengths
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 具有不同字节长度的单字符字符串的 UTF-8 编码
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To understand the implications of a single character possibly using up a varying
    number of bytes, let’s investigate the record1.name string that we created in
    section 6.3.2\. To reduce the output in our analysis, we will restrict it to the
    first word in this string, which is *Fantômas*. We see that it consists of eight
    characters, so we will extract them from our string by using the first function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解单个字符可能占用不同数量字节的影响，让我们调查一下我们在 6.3.2 节中创建的 record1.name 字符串。为了减少分析中的输出，我们将它限制在这个字符串的第一个单词上，即
    *Fantômas*。我们看到它由八个字符组成，因此我们将通过使用第一个函数从我们的字符串中提取这些字符：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first function in this case takes two arguments: a string and the number
    of characters to take from its front—eight, in our case. You might wonder if we
    could have treated a string as a collection of characters and extracted them by
    using indexing. Let’s try:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第一个函数接受两个参数：一个字符串和从其前面取出的字符数——在我们的例子中是八个。你可能想知道我们是否可以将字符串视为字符集合，并通过使用索引提取它们。让我们试试：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 6.4.2 Character vs. byte indexing of strings
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 字符串的字符索引与字节索引
- en: The code works but produces an unexpected result. For some reason, Julia strips
    the last letter from the name. Why? The problem is that string indexing in Julia
    uses not character but byte offsets, and the letter ô in UTF-8 is encoded using
    2 bytes. We can check this by using the eachindex function that you learned in
    chapter 5
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 代码运行正常，但产生了意外的结果。由于某种原因，Julia 从名字中删除了最后一个字母。为什么？问题在于 Julia 中的字符串索引使用的是字节偏移量，而不是字符偏移量，而在
    UTF-8 中，字母 ô 使用了 2 个字节进行编码。我们可以通过使用第 5 章中学到的 eachindex 函数来检查这一点。
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'or by using the codeunits function on the string consisting of a single letter
    ô:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过在单个字母 ô 的字符串上使用 codeunits 函数：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s have a look at the code units that the Fantômas string consists of:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Fantômas 字符串包含的字节单元：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Indeed, we see that ô has a byte index equal to 5, but the next letter m has
    a byte index equal to 7, since ô is encoded using 2 bytes. In figure 6.3, you
    can see the mapping of characters, bytes (code units), byte index, and character
    index for the Fantômas string.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们看到 ô 的字节索引等于 5，但下一个字母 m 的字节索引等于 7，因为 ô 使用了 2 个字节进行编码。在图 6.3 中，你可以看到 Fantômas
    字符串中字符、字节（代码单元）、字节索引和字符索引的映射。
- en: '![CH06_F03_Kaminski2](../Images/CH06_F03_Kaminski2.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F03_Kaminski2](../Images/CH06_F03_Kaminski2.png)'
- en: Figure 6.3 Mapping of characters, bytes (code units), byte index, and character
    index for the Fantômas string
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 Fantômas 字符串中字符、字节（代码单元）、字节索引和字符索引的映射
- en: This behavior of string indexing might at first be quite surprising. The reason
    for this behavior is that, depending on the context, you might want to perform
    either byte indexing or character indexing of your string, and Julia provides
    both options. Usually, when you need to parse nonstandard input data (for example,
    coming from an IoT sensor), you will need to work with bytes, and when you are
    processing standard text, you will need to work with characters.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串索引的这一行为可能一开始会相当令人惊讶。这种行为的理由是，根据上下文，你可能想要对你的字符串执行字节索引或字符索引，Julia提供了这两种选项。通常，当你需要解析非标准输入数据（例如，来自物联网传感器的数据）时，你需要与字节一起工作，当你处理标准文本时，你需要与字符一起工作。
- en: Therefore, you must always check when using a function to see whether it works
    with byte indices or character indices. You have already seen that indexing using
    square brackets uses byte indexing and that the function first uses character
    counts. In my blog post “The String, or There and Back Again” ([http://mng.bz/XaW1](http://mng.bz/XaW1)),
    I have created a glossary of the most commonly used functions when working with
    strings, including the kinds of indexing they use.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用函数时，你必须始终检查它是否使用字节索引或字符索引。你已经看到，使用方括号进行索引使用字节索引，而函数首先使用字符计数。在我的博客文章“字符串，或者来来回回”（[http://mng.bz/XaW1](http://mng.bz/XaW1)）中，我创建了一个在处理字符串时最常用函数的词汇表，包括它们使用的索引类型。
- en: Using character counts when working with strings
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符计数处理字符串
- en: In data science workflows, you will most commonly want to operate on strings
    using character counts, not byte indexing. Therefore, it is recommended that you
    do not index into strings using square brackets.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据科学工作流程中，你通常希望使用字符计数而不是字节索引来操作字符串。因此，建议你不要使用方括号索引字符串。
- en: 'For matching complex patterns, use regular expressions. For simpler scenarios,
    here is a list of the most useful functions that use character counts for working
    with strings with an example usage:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于匹配复杂的模式，请使用正则表达式。对于更简单的场景，以下是一个列表，列出了最有用的函数，这些函数使用字符计数来处理字符串，并附有示例用法：
- en: length("abc")—Returns the number of characters in a string; produces 3.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: length("abc")—返回字符串中的字符数；产生 3。
- en: chop("abcd", head=1, tail=2)—Removes a given number of characters from the head
    or tail of the string. In this case, we strip one character from head and two
    from tail, producing "b".
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: chop("abcd", head=1, tail=2)—从字符串的头部或尾部移除指定数量的字符。在这种情况下，我们从头部移除一个字符，从尾部移除两个字符，产生
    "b"。
- en: first("abc", 2)—Returns a string consisting of the first two characters in the
    string; produces "ab".
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: first("abc", 2)—返回字符串中的前两个字符组成的字符串；产生 "ab"。
- en: last("abc", 2)—Returns a string consisting of the last two characters in the
    string; produces "bc".
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: last("abc", 2)—返回字符串中的最后两个字符组成的字符串；产生 "bc"。
- en: 6.4.3 ASCII strings
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.3 ASCII字符串
- en: In one case, byte and character indexing are guaranteed to produce the same
    result. This happens when your string consists only of ASCII characters. The most
    important examples of such characters are the digits 0 to 9, lowercase letters
    a to z, uppercase letters A to Z, and common symbols like !, +, -, *, ), and (.
    Generally, any character that can be typed without using meta keys on a standard
    US keyboard is an ASCII character.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在一种情况下，字节索引和字符索引保证会产生相同的结果。这发生在你的字符串只包含 ASCII 字符时。这类字符的最重要例子是数字 0 到 9，小写字母 a
    到 z，大写字母 A 到 Z，以及常见的符号如 !, +, -, *, ), 和 (. 通常，任何可以在标准 US 键盘上不使用元键就能键入的字符都是 ASCII
    字符。
- en: 'An important feature of ASCII characters is that they are always represented
    by a single byte in UTF-8 encoding. In Julia, you can easily check whether your
    string consists of only ASCII characters by using the isascii function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII字符的一个重要特性是它们在 UTF-8 编码中总是由单个字节表示。在 Julia 中，你可以通过使用 isascii 函数轻松检查你的字符串是否只包含
    ASCII 字符：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the first case, the Hello world! string consists of only letters, a space,
    and an exclamation mark, which are all ASCII characters. In the second example,
    the ∀ and ≥ characters are not ASCII.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，Hello world!字符串仅由字母、一个空格和一个感叹号组成，这些都是ASCII字符。在第二个例子中，∀和≥字符不是ASCII字符。
- en: 6.4.4 The Char type
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.4 Char类型
- en: 'Before I wrap up this discussion about indexing, let me briefly mention that
    when you pick a single character from a string by using indexing, you do not get
    a single-character string, as in R or Python, but rather a separate character
    type that is called Char. Here is an example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我结束关于索引的讨论之前，让我简要地提一下，当你使用索引从字符串中选取单个字符时，你不会得到一个单字符字符串，就像在R或Python中那样，而是一个单独的字符类型，称为Char。以下是一个示例：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We do not need to work with single characters in this book, so I leave out all
    the details of how to use them. However, if you do a lot of natural language processing,
    I recommend reading the “Characters” section of the Julia Manual ([http://mng.bz/820B](http://mng.bz/820B)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不需要处理单个字符，所以我省略了如何使用它们的所有细节。然而，如果你做很多自然语言处理，我建议阅读Julia手册中的“Characters”部分（[http://mng.bz/820B](http://mng.bz/820B)）。
- en: 6.5 Analyzing genre frequency in movies.dat
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 在movies.dat中分析流派频率
- en: We are now ready to analyze movie genres in the movies.dat file. By doing this,
    you will learn how to create frequency tables, which are often used to summarize
    data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以分析movies.dat文件中的电影流派了。通过这样做，你将学习如何创建频率表，频率表通常用于总结数据。
- en: 'Recall that we want to perform two tasks: find which movie genres are most
    common and understand how the relative frequency of a genre changes with the movie
    year.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们想要执行两个任务：找出最常见的电影流派，并了解一个流派相对于电影年份的相对频率是如何变化的。
- en: 6.5.1 Finding common movie genres
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 查找常见的电影流派
- en: 'We start with the movies variable defined in listing 6.2 and process this vector
    by using the parseline function defined in listing 6.3:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第6.2节中定义的movies变量开始，并使用第6.3节中定义的parseline函数处理这个向量：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We add a dot (.) after the parseline function, which means that we are broadcasting
    it over all elements of the movies collection. As a result, we get a vector of
    named tuples describing the movies we want to analyze.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在parseline函数后添加一个点（.），这意味着我们将它广播到movies集合的所有元素上。结果，我们得到一个描述我们想要分析的电影的命名元组的向量。
- en: 'Let’s first find out which genre is the most frequent in our data set. We will
    do this task in two steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先找出在我们的数据集中哪种流派最频繁。我们将分两步完成这项任务：
- en: Create a single vector containing genres from all movies we analyze.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含我们分析的所有电影流派的单个向量。
- en: Create a frequency table of this vector by using the freqtable function from
    the FreqTables.jl package.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用FreqTables.jl包中的freqtable函数创建此向量的频率表。
- en: 'The first step is to create a single vector of movie genres. We could perform
    this task in several ways. Here we will use the append! function, which appends
    one vector to another vector in place. Our code will start with an empty vector
    that can store strings and consecutively append to it vectors containing genres
    of all movies. Here is the code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个包含所有电影流派的单个向量。我们可以以多种方式完成这项任务。在这里，我们将使用append!函数，该函数将一个向量附加到另一个向量上。我们的代码将从可以存储字符串的空向量开始，并连续将其包含所有电影流派向量的向量附加到它上。以下是代码：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The append! function takes two arguments. The first one is the vector to which
    we want to append data, and the second is the vector containing data to be appended.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: append!函数接受两个参数。第一个是我们想要附加数据的向量，第二个是包含要附加数据的向量。
- en: Note one important detail in this code. The genres variable is a vector that
    stores String values. On the other hand, as we already discussed, record.genres
    is a collection of SubString{String} values. When you perform the append! operation,
    the SubString{String} values are automatically converted to String. This causes
    allocation of new strings in memory (recall that the point of using SubString{String}
    in the split function is to avoid such allocations). Since our data is small,
    I have decided that this is not a problem, as the extra execution time and memory
    consumption caused by this approach are negligible in this case.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码中的一个重要细节。genres变量是一个存储String值的向量。另一方面，正如我们已经讨论过的，record.genres是一个包含SubString{String}值的集合。当你执行append!操作时，SubString{String}值会自动转换为String。这会导致在内存中分配新的字符串（回想一下，在split函数中使用SubString{String}的目的就是为了避免这种分配）。由于我们的数据量较小，我决定这不是问题，因为这种方法造成的额外执行时间和内存消耗在这个情况下是可以忽略不计的。
- en: 'Now we are ready to create a frequency table. We will perform this task in
    three steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备创建一个频率表。我们将分三步完成这项任务：
- en: Load the FreqTables.jl package.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 FreqTables.jl 包。
- en: Create a frequency table by using the freqtable function.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 freqtable 函数创建频率表。
- en: Sort the result in place by using the sort! function to find the least and most
    frequent genres.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 sort! 函数就地排序结果，以找到最频繁和最不频繁的类型。
- en: 'Here is the code that performs this task:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行此任务的代码：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that the freqtable function returns a nonstandard array of type NamedVector.
    This type allows you to use named indices. In our example, the names of the indices
    are genres. This type is defined in the NamedArrays.jl package, and you can find
    more information about how to work with it at [https://github.com/davidavdav/NamedArrays.jl](https://github.com/davidavdav/NamedArrays.jl).
    Here, let me just mention that you can get access to the indices’ names by using
    the names function and that sorting such arrays performs sorting on values (not
    on indices).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，freqtable 函数返回一个非标准数组，类型为 NamedVector。这种类型允许你使用命名索引。在我们的例子中，索引的名称是 genres。这种类型在
    NamedArrays.jl 包中定义，你可以在 [https://github.com/davidavdav/NamedArrays.jl](https://github.com/davidavdav/NamedArrays.jl)
    找到更多关于如何使用它的信息。在这里，让我只提一下，你可以通过使用 names 函数来获取索引的名称，并且对这样的数组进行排序是在值上排序（而不是在索引上）。
- en: 6.5.2 Understanding genre popularity evolution over the years
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 理解类型流行趋势随年份的变化
- en: 'We have learned that Drama is the most frequent genre. We are now ready to
    find out how often this genre is present as a function of the movie year. We will
    do this analysis in the following steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到戏剧是最常见的类型。我们现在准备找出这个类型作为电影年份函数的频率。我们将按以下步骤进行此分析：
- en: Extract the year of each movie to a vector.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每部电影的年份提取到一个向量中。
- en: For each movie, check whether it has Drama as one of its genres.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每部电影，检查它是否包含戏剧作为其类型之一。
- en: Create a frequency table of proportions of the occurrence of Drama in movie
    genres by year.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按年份创建戏剧在电影类型中出现的比例频率表。
- en: 'Here is the code that accomplishes this task:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完成此任务的代码：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this code, to create both years and has_drama vectors, we use comprehensions.
    To check whether Drama is one of the genres, we use the in operator that we discussed
    in chapter 5\. Finally, to calculate a frequency table of proportions, we use
    the proptable function from the FreqTables.jl package. We pass to it both year
    and has_data variables to create a cross-tabulation, and by passing margins=1,
    we are asking to compute the proportions over the first dimension (that is, rows).
    In this case, since the first variable passed to proptable is year and the second
    is has_drama, the proportions are calculated for each year. Observe that proptable
    automatically sorts its dimensions by the dimension values.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，为了创建年份和 has_drama 向量，我们使用列表推导。为了检查戏剧是否是其中一种类型，我们使用第 5 章中讨论的 in 操作符。最后，为了计算比例频率表，我们使用
    FreqTables.jl 包中的 proptable 函数。我们传递 year 和 has_data 变量以创建交叉表，并通过传递 margins=1，我们要求计算第一维度的比例（即行）。在这种情况下，由于传递给
    proptable 的第一个变量是 year，第二个是 has_drama，因此比例是按年份计算的。观察 proptable 自动按维度值对维度进行排序。
- en: The drama_prop table is nice but is not easy to analyze. Let’s create a plot
    of year against the proportion of the presence of Drama in the next listing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: drama_prop 表很好，但不容易分析。让我们在下一个列表中创建一个年份与戏剧在电影类型中存在比例的图表。
- en: Listing 6.5 Plotting the proportion of drama movies by year
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.5 按年份绘制戏剧电影的比例
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We extract the years from the first axes of the drama_prop matrix by using the
    names function. To get the proportion of Drama by year, we extract the second
    column by using drama_prop[:, 2]. We additionally opt out from showing a plot
    legend and create labels for the *x* and *y* axes. Figure 6.4 shows the result.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 names 函数从 drama_prop 矩阵的第一个轴提取年份。为了获取按年份的戏剧比例，我们使用 drama_prop[:, 2] 提取第二列。我们额外选择不显示图例，并为
    x 轴和 y 轴创建标签。图 6.4 显示了结果。
- en: '![CH06_F04_Kaminski2](../Images/CH06_F04_Kaminski2.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F04_Kaminski2](../Images/CH06_F04_Kaminski2.png)'
- en: Figure 6.4 In plotting the proportion of the Drama genre as a function of year,
    no significant trend is visible.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 在绘制戏剧类型按年份的比例时，没有明显的趋势可见。
- en: As you can see in figure 6.4, no strong trend seems to be present. So, the Drama
    genre seems stable over the years. However, we can see that the variability of
    the Drama probability decreases with the year. This is most likely because in
    the initial years, there were few movies. Checking this is your exercise.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如图6.4所示，似乎没有明显的趋势。因此，戏剧类型似乎在多年间保持稳定。然而，我们可以看到戏剧概率的变异性随着年份的推移而降低。这很可能是由于在最初几年中，电影很少。检查这一点是你的练习。
- en: Exercise 6.1 Create a plot of the number of movies by year, using the years
    variable.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.1 使用年份变量创建电影数量的图表。
- en: 6.6 Introducing symbols
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 引入符号
- en: In some data science scenarios, you want to use strings as labels or tags of
    objects—for example, to denote a color of a product. You typically do not want
    to manipulate these labels; the only operation you perform on them is comparison
    for equality, and you want it to be very fast.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些数据科学场景中，你希望使用字符串作为对象的标签或标记——例如，表示产品的颜色。你通常不希望操作这些标签；你在这上面进行的唯一操作是进行相等性比较，并且希望它非常快。
- en: Julia has a special type called Symbol, which is similar to a string, that has
    exactly these features. This section first explains how to create values that
    have a Symbol type and then discusses their pros and cons in comparison to strings.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Julia有一个特殊类型叫做Symbol，它类似于字符串，具有这些特性。本节首先解释如何创建具有Symbol类型的值，然后讨论它们与字符串相比的优缺点。
- en: 6.6.1 Creating symbols
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.1 创建符号
- en: Before I show you how to work with the Symbol type, you first need to learn
    how to construct these objects. You can create a value that has a Symbol type
    in two ways
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我向你展示如何使用Symbol类型之前，你首先需要学习如何构建这些对象。你可以通过两种方式创建具有Symbol类型的值
- en: 'The first is to call Symbol, passing it any value or sequence of values. Here
    are three examples:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是调用Symbol，传递给它任何值或值的序列。以下有三个例子：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'All three values bound to variables s1, s2, and s3 have the type Symbol:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到变量s1、s2和s3的所有三个值都具有Symbol类型：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note two important points in this example. First, when you pass several values
    to Symbol, as in Symbol("x", 1), their string representations are concatenated.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中要注意两个重要点。首先，当你向Symbol传递多个值，如Symbol("x", 1)时，它们的字符串表示形式会被连接起来。
- en: 'Second, and more importantly, you can see that symbols are displayed using
    two styles. The first style is :x and :x1, and the second is more verbose: Symbol("hello
    world!").'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，更重要的是，你可以看到符号以两种方式显示。第一种风格是:x和:x1，第二种风格更为冗长：Symbol("hello world!").
- en: You might wonder what rules govern this. The short style is used for printing
    a Symbol if it contains only characters that form a valid variable name. In this
    example, we use a space between the words hello and world, and since using a space
    in a variable name is not allowed, printing is done in the verbose form.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道什么规则支配着这一点。简短风格用于打印只包含构成有效变量名字符的Symbol。在这个例子中，我们在hello和world之间使用了一个空格，由于在变量名中使用空格是不允许的，所以打印是以冗长形式进行的。
- en: 'Here is one more example of the same rule at work:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是同样规则的一个更多例子：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Since 1 is not a valid variable name (it is an integer literal), we get the
    symbol printed in a verbose form.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于1不是一个有效的变量名（它是一个整数字面量），所以我们得到一个以冗长形式打印的符号。
- en: 'You might have guessed the second style that can be used to create symbols.
    If, and only if, the sequence of characters that we want to use to represent a
    Symbol is a valid variable name, we can prefix it with a colon (:) to create a
    Symbol value. Therefore, the following operations are valid:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了创建符号的另一种样式。如果我们想要用作Symbol表示的字符序列是一个有效的变量名，那么我们可以在其前加上冒号（:）来创建一个Symbol值。因此，以下操作是有效的：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, remember that this syntax is not correct if the sequence of characters
    is not a valid variable name. Here is an example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，记住如果字符序列不是一个有效的变量名，这种语法是不正确的。这里有一个例子：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We get an error. And here is a second example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个错误。这里是一个第二个例子：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we do not get an error, but instead of getting a Symbol, we get an integer
    1.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们没有得到错误，但得到的不是Symbol，而是一个整数1。
- en: 6.6.2 Using symbols
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.2 使用符号
- en: You know how to create a value that has a Symbol type. Now we’ll focus on working
    with them.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道如何创建一个具有Symbol类型的值。现在我们将专注于如何使用它们。
- en: 'As I have mentioned, the Symbol type looks similar to a string, but it is not
    one. We can check this by testing its supertype:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，Symbol类型看起来与字符串相似，但它不是。我们可以通过测试其超类型来检查这一点：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, we see that the type is Any, not AbstractString. This means that no functions
    that operate on strings will work with values having a Symbol type. The only operation
    that in practice is useful on symbols in typical data science workflows is an
    equality comparison. So, we can write this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到类型是 Any，而不是 AbstractString。这意味着没有操作字符串的函数会与具有 Symbol 类型的值一起工作。在典型的数据科学工作流程中，实际上有用的符号操作只有相等性比较。因此，我们可以这样写：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The point is that an equality comparison for symbols is fast, much faster than
    testing strings for equality. The next listing shows a simple benchmark, in which
    we look for a value in a vector of one million elements.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是符号的相等比较非常快，比测试字符串的相等性快得多。下面的列表显示了一个简单的基准测试，其中我们在包含一百万个元素的向量中查找一个值。
- en: Listing 6.6 Comparing the performance of working with String vs. Symbol
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 比较使用 String 与 Symbol 的性能
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Creates a vector of String values
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个字符串值向量
- en: ❷ Creates a vector of Symbol values
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个符号值向量
- en: ❸ Measures the performance of a value lookup in a vector of String values
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 测量在字符串值向量中查找值的性能
- en: ❹ Measures the performance of a value lookup in a vector of Symbol values
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 测量在符号值向量中查找值的性能
- en: 'Here we have two vectors: str consisting of String, and symb containing Symbol
    values. The benchmark results show that the lookup using symbols is, in this case,
    over 10 times faster than when we use strings.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个向量：包含字符串的 str 和包含符号值的 symb。基准测试结果表明，在这种情况下，使用符号的查找速度比使用字符串快10倍以上。
- en: You might ask how this is achieved. The trick is that Julia internally keeps
    a global pool of all symbols. If you introduce a new Symbol, Julia first checks
    whether it is already present in this pool, and if so, Julia reuses it. Therefore,
    when you compare two symbols, you can compare their address in memory without
    having to check their content.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问这是如何实现的。诀窍在于 Julia 内部维护一个全局符号池。如果你引入一个新的符号，Julia 首先检查它是否已经存在于这个池中，如果是，Julia
    会重用它。因此，当你比较两个符号时，你可以比较它们在内存中的地址，而不需要检查它们的内容。
- en: This behavior has two additional consequences. On one hand, defining many identical
    symbols does not allocate new memory, as they will point to the same reference
    value. On the other hand, once Symbol is allocated in the global pool, it stays
    there until the end of the Julia session, which sometimes might look like a memory
    leak in the Julia program if you create a very large number of unique symbols.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为有两个额外的后果。一方面，定义许多相同的符号不会分配新的内存，因为它们将指向相同的引用值。另一方面，一旦符号分配到全局池中，它将一直保留到 Julia
    会话结束，如果你创建了大量的唯一符号，这有时可能会在 Julia 程序中看起来像内存泄漏。
- en: Choosing between string and Symbol in your code
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中选择字符串和符号
- en: As a general recommendation, you should prefer strings over Symbol in your programs.
    Strings are more flexible and have multiple functions taking them as arguments.
    However, if you need to perform a lot of comparisons of string-like values in
    your program, but you do not expect to have to manipulate these values and you
    require maximum performance, you can consider using Symbol.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般建议，你应该在你的程序中优先使用字符串而不是符号。字符串更加灵活，并且有多个函数接受它们作为参数。然而，如果你需要在程序中进行大量类似字符串值的比较，但你预计不需要操作这些值并且需要最大性能，你可以考虑使用符号。
- en: Before I wrap up the discussion of symbols, let me note that in this section,
    I have concentrated on symbols being used as data. Another application of symbols
    in Julia is for *metaprogramming*—programmatic manipulation of Julia code. We
    do not cover this advanced topic in this book, but if you would like to learn
    more about it, I recommend the “Metaprogramming” section in the Julia Manual ([http://mng.bz/E0Dj](http://mng.bz/E0Dj))
    as a good place to start.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我结束对符号的讨论之前，让我指出，在本节中，我专注于符号作为数据的使用。符号在 Julia 中的另一个应用是用于 *元编程*——对 Julia 代码的程序性操作。我们在这本书中不涉及这个高级主题，但如果你想了解更多，我推荐从
    Julia 手册中的“元编程”部分开始学习（[http://mng.bz/E0Dj](http://mng.bz/E0Dj)）。
- en: 6.7 Using fixed-width string types to improve performance
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 使用固定宽度字符串类型来提高性能
- en: In many data science workflows, we work with strings consisting of only a few
    characters. Think of codes of US states that consist of two letters, or the standard
    US ZIP code that consists of five digits. If you happen to work with such strings,
    Julia provides an even more efficient storage format than the standard String
    or Symbol.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多数据科学工作流程中，我们处理仅由几个字符组成的字符串。想想美国各州的代码，由两个字母组成，或者标准的美国ZIP代码，由五个数字组成。如果你恰好处理这样的字符串，Julia提供了比标准String或Symbol更高效的存储格式。
- en: 6.7.1 Available fixed-width strings
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.1 可用的固定宽度字符串
- en: 'These advanced string types are defined in the InlineStrings.jl package. Just
    like the standard String type, these string types are UTF-8 encoded, but they
    differ from the standard String type in two ways:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这些高级字符串类型在InlineStrings.jl包中定义。就像标准String类型一样，这些字符串类型是UTF-8编码的，但它们在两个方面与标准String类型不同：
- en: As a benefit, they are as fast to work with as numbers (technically, they do
    not require being dynamically allocated in memory).
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为好处，它们与数字一样易于处理（技术上，它们不需要在内存中动态分配）。
- en: As a limitation, they have a fixed maximum size in bytes.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为限制，它们在字节上有固定的最大大小。
- en: 'The InlineStrings.jl package provides eight fixed-width string types:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: InlineStrings.jl包提供了八个固定宽度字符串类型：
- en: String1—Size up to 1 byte
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: String1—大小最多1字节
- en: String3—Size up to 3 bytes
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: String3—大小最多3字节
- en: String7—Size up to 7 bytes
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: String7—大小最多7字节
- en: String15—Size up to 15 bytes
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: String15—大小最多15字节
- en: String31—Size up to 31 bytes
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: String31—大小最多31字节
- en: String63—Size up to 63 bytes
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: String63—大小最多63字节
- en: String127—Size up to 127 bytes
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: String127—大小最多127字节
- en: String255—Size up to 255 bytes
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: String255—大小最多255字节
- en: 'In practice, if you want to use these strings, you can pick the appropriate
    type manually, but typically, it is recommended to automatically perform type
    selection. If you call the InlineString function on a string, it will be converted
    to the narrowest fixed-width string that it matches. Similarly, if you call the
    inlinestrings function on a collection of strings, an appropriate common narrowest
    type for all passed strings will be automatically selected. Here are some examples
    of these functions at work:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，如果你想使用这些字符串，你可以手动选择适当类型，但通常建议自动执行类型选择。如果你在字符串上调用InlineString函数，它将被转换为最窄的匹配固定宽度字符串。同样，如果你在字符串集合上调用inlinestrings函数，将自动选择所有传递字符串的适当最窄公共类型。以下是一些这些函数工作的示例：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this example, we can see that the "x" string can be encoded as String1 since
    the x character is represented by 1 byte in UTF-8 encoding. On the other hand,
    the ∀ character, as you have seen in listing 6.4, is represented using 3 bytes
    in UTF-8, so "∀" is converted to String3. In the last example of the sv variable,
    we have several strings, but none uses more than 7 bytes, while some are longer
    than 3 bytes. Therefore, as a result of the operation, we get a vector of String7
    values.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到“x”字符串可以编码为String1，因为x字符在UTF-8编码中用1个字节表示。另一方面，∀字符，如你在列表6.4中看到的，在UTF-8中用3个字节表示，所以“∀”被转换为String3。在sv变量的最后一个例子中，我们有几个字符串，但没有一个超过7个字节，而有些字符串长度超过3个字节。因此，作为操作的结果，我们得到一个String7值的向量。
- en: 6.7.2 Performance of fixed-width strings
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.2 固定宽度字符串的性能
- en: 'To show you the potential benefits of using the string types defined in the
    InlineStrings.jl package, let’s perform a simple experiment. We want to generate
    a vector of strings in two variants: one using the String type, and the other
    using the fixed-width string.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示使用在InlineStrings.jl包中定义的字符串类型的潜在好处，让我们进行一个简单的实验。我们想要生成两种字符串向量的字符串：一种使用String类型，另一种使用固定宽度字符串。
- en: Then we will perform two checks. In the first, we will see how much memory is
    required by the objects stored in both vectors. In the second, we will benchmark
    how fast Julia can sort these vectors. We start with setting up the data in the
    next listing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将执行两个检查。在第一个检查中，我们将看到存储在两个向量中的对象需要多少内存。在第二个检查中，我们将基准测试Julia对这些向量进行排序的速度。我们从设置下一列表中的数据开始。
- en: Listing 6.7 Setting up the data for performance comparison of different string
    types
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.7 设置不同字符串类型性能比较的数据
- en: '[PRE45]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Sets random number generator seed to ensure reproducibility of the example
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置随机数生成器种子以确保示例的可重复性
- en: ❷ Generates a vector of random strings of type String
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 生成String类型的随机字符串向量
- en: ❸ Converts the vector to a vector of values having the String3 type
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将向量转换为具有String3类型的值向量
- en: We first load the required packages Random and BenchmarkTools. Next, we set
    the seed of the Julia random number generator with the Random.seed!(1234) command.
    I perform this step to ensure that, if you are on the same version of Julia used
    to write this book, you will get the same data as is shown in listing 6.7.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先加载所需的包Random和BenchmarkTools。接下来，我们使用Random.seed!(1234)命令设置Julia随机数生成器的种子。我执行这一步是为了确保，如果你使用的是编写本书时使用的相同版本的Julia，你将得到与列表6.7中所示相同的数据。
- en: Then we generate a vector consisting of one million random strings of the String
    type, using a comprehension and the randstring function to generate random strings.
    We use the randstring(3) call to make sure our strings consist of three characters.
    Finally, using the inlinestrings function, we create a vector of String3 strings
    and bind it to the s2 variable. Since all our strings consist of three ASCII characters,
    the String3 type is automatically detected by the inlinestrings function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用列表推导和randstring函数生成一个包含一百万个随机String类型字符串的向量。我们使用randstring(3)调用确保我们的字符串由三个字符组成。最后，使用inlinestrings函数创建一个包含String3字符串的向量并将其绑定到s2变量。由于我们的所有字符串都由三个ASCII字符组成，String3类型会自动被inlinestrings函数检测到。
- en: 'Our test is to compare how much memory, in bytes, is used by all objects stored
    in vectors s1 and s2 by using the function Base.summarysize:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试是比较存储在向量s1和s2中的所有对象使用的内存量（以字节为单位），我们使用Base.summarysize函数：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this case, the s2 vector uses less than 25% of the memory used by the s1
    vector, as our strings are short and have a uniform length.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，s2向量使用的内存少于s1向量使用的25%，因为我们的字符串较短且长度一致。
- en: 'The second test checks the performance of sorting both the s1 and s2 vectors:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试检查了排序s1和s2向量时的性能：
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this case, we can see that sorting s2 is around 40 times faster than sorting
    s1.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以看到对s2进行排序的速度大约比s1快40倍。
- en: In part 2 of this book, you will learn that when getting your data from a CSV
    file, the Julia CSV reader can automatically detect that it is useful to use fixed-width
    strings instead of the standard String type. Therefore, in practice, it is usually
    enough to be aware of the existence and meaning of fixed-width strings, so that
    when you see them in a data frame, you are not surprised to encounter a column
    consisting of String3 strings.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第二部分，你将了解到当从CSV文件获取数据时，Julia CSV读取器可以自动检测使用固定宽度字符串而不是标准String类型是有用的。因此，在实践中，通常只需要意识到固定宽度字符串的存在和含义，这样当你在一个数据框中看到它们时，你不会对遇到由String3字符串组成的列感到惊讶。
- en: Exercise 6.2 Using the s1 vector from listing 6.7, create the s3 vector consisting
    of symbols representing the same strings contained in the s1 vector. Next, benchmark
    how fast you can sort the s3 vector. Finally, benchmark how fast you can de-duplicate
    the s1, s2, and s3 vectors by using the unique function.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.2 使用列表6.7中的s1向量，创建包含与s1向量中相同字符串的符号的s3向量。然后，基准测试你能够多快地对s3向量进行排序。最后，使用unique函数基准测试你能够多快地对s1、s2和s3向量进行去重。
- en: 6.8 Compressing vectors of strings with PooledArrays.jl
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 使用PooledArrays.jl压缩字符串向量
- en: The last scenario related to the efficiency of the storage of strings that we
    will discuss in this chapter is the compression of vectors of strings. *Compression*
    is used to save memory if you have large vectors containing few unique values
    relative to the number of elements stored in the vector.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的与字符串存储效率相关的最后一个场景是字符串向量的压缩。*压缩*用于在向量中包含相对较少的独特值相对于存储在向量中的元素数量时节省内存。
- en: 'Consider the following scenario. In 1936, the British statistician and biologist
    Ronald Fisher studied three species of Iris flower: *Iris setosa*, *Iris virginica*,
    and *Iris versicolor*. You likely have heard of this experiment if you’ve studied
    machine learning models; if not, you can find the reference to this data set at
    [https://archive.ics.uci.edu/ml/datasets/iris](https://archive.ics.uci.edu/ml/datasets/iris).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景。1936年，英国统计学家和生物学家罗纳德·费希尔研究了三种鸢尾花：*Iris setosa*、*Iris virginica*和*Iris
    versicolor*。如果你学习过机器学习模型，你可能听说过这个实验；如果没有，你可以在[https://archive.ics.uci.edu/ml/datasets/iris](https://archive.ics.uci.edu/ml/datasets/iris)找到这个数据集的引用。
- en: We will not analyze this data set in this book, as it is covered in many other
    resources, including *Practical Data Science with R* by Nina Zumel and John Mount
    (Manning, 2019). However, I will use the names of the flowers to show you the
    potential benefits of string compression. As an additional skill, you will learn
    to write data to a file. After we create the file, we will read it back as a vector
    of strings. Next, we will compress this vector and compare the memory footprint
    of uncompressed versus compressed data.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中分析这个数据集，因为它在许多其他资源中都有涵盖，包括Nina Zumel和John Mount合著的《实用数据科学R》（Manning,
    2019）。然而，我将使用花名来展示字符串压缩的潜在好处。作为一项额外的技能，你将学习如何将数据写入文件。在我们创建文件后，我们将将其作为字符串向量读回。接下来，我们将压缩这个向量，并比较未压缩和压缩数据的内存占用。
- en: 6.8.1 Creating a file containing flower names
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.1 创建包含花名的文件
- en: We will start by creating the file with the names of the flowers. Next, we will
    read this data back to a Vector of String values and to a PooledArray of such
    values to compare how much memory they occupy. As an additional skill, you will
    learn how to write data to a text file in Julia.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建包含花名的文件。然后，我们将这些数据读回到一个String值的Vector和一个这样的值的PooledArray中，以比较它们占用的内存量。作为一项额外的技能，你将学习如何在Julia中将数据写入文本文件。
- en: Here is the code that writes three million rows of data by repeating the names
    *Iris setosa*, *Iris virginica*, and *Iris versicolor* in it. The file in which
    we store the data is called iris.txt.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是写入三百万行数据的代码，通过在文件中重复写入*Iris setosa*、*Iris virginica*和*Iris versicolor*的名称。我们存储数据的文件称为iris.txt。
- en: Listing 6.8 Writing names of Iris flowers to a file
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8 将Iris花名写入文件
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We first use the open function to open the file iris.txt for writing. We indicate
    that we want to write to the file by passing w as a second positional argument.
    Observe that we use the do-end block notation that you learned in chapter 2\.
    In this notation, io is a name of the variable to which the opened file descriptor
    is bound. Then, inside the do-end block, you can write data to your file. The
    key value of using the do-end block is that the file descriptor is guaranteed
    to be closed after the operation is completed (even if an exception would be raised
    within the do-end block).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用open函数以写入模式打开iris.txt文件。我们通过传递w作为第二个位置参数来表示我们想要写入文件。注意，我们使用了你在第二章中学到的do-end块记法。在这个记法中，io是绑定打开的文件描述符的变量的名称。然后，在do-end块内部，你可以将数据写入你的文件。使用do-end块的关键价值在于，文件描述符在操作完成后保证被关闭（即使do-end块内部抛出异常）。
- en: In this case, we use the println function to write data to the file; the first
    argument passed is the file descriptor to which we want to write, and the second
    argument is data we want to be written. The println function inserts a newline
    character after it writes data to the file. If we wanted to avoid the newline
    character, we would use the print function instead.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用println函数将数据写入文件；第一个参数传递的是我们想要写入的文件描述符，第二个参数是我们想要写入的数据。println函数在写入数据到文件后会插入一个换行符。如果我们想要避免换行符，我们可以使用print函数代替。
- en: 'Let’s check to see if the file was indeed created before we proceed:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们检查文件是否确实已经创建：
- en: '[PRE49]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 6.8.2 Reading in the data to a vector and compressing it
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.2 将数据读入向量并压缩
- en: 'We have created the iris.txt file; now let’s read it back using the readlines
    function that you already learned in this chapter:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了iris.txt文件；现在让我们使用本章中已经学过的readlines函数来读取它：
- en: '[PRE50]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now compress this vector by using the PooledArray constructor from the PooledArrays.jl
    package:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过使用来自PooledArrays.jl包的PooledArray构造函数来压缩这个向量：
- en: '[PRE51]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We have created a vector that has the PooledVector type. First, let’s use the
    Base.summarysize function to check that the compressed vector indeed uses less
    memory than the uncompressed vector:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个具有PooledVector类型的向量。首先，让我们使用Base.summarysize函数来检查压缩向量确实比未压缩向量使用更少的内存：
- en: '[PRE52]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Notice that the memory size of the compressed object is 85% smaller than the
    uncompressed one. Let me explain how this compression is achieved.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，压缩对象的内存大小比未压缩对象小85%。让我解释一下这种压缩是如何实现的。
- en: 6.8.3 Understanding the internal design of PooledArray
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.3 理解PooledArray的内部设计
- en: To understand why compressed vectors can use less memory than uncompressed ones,
    figure 6.5 shows the most important elements of how PooledVector{String, UInt32,
    Vector{UInt32} is internally implemented.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么压缩向量可以使用比未压缩向量更少的内存，图 6.5 展示了 PooledVector{String, UInt32, Vector{UInt32}}
    内部实现的最重要元素。
- en: '![CH06_F05_Kaminski2](../Images/CH06_F05_Kaminski2.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F05_Kaminski2](../Images/CH06_F05_Kaminski2.png)'
- en: 'Figure 6.5 The PooledVector of strings contains a collection of integer references
    and two mappings: one from string values to integer references, and the other
    from integer references to string values. You can get a list of all fields of
    PooledArray by writing fieldnames(PooledArray).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 字符串的 PooledVector 包含一个整数引用集合和两个映射：一个是从字符串值到整数引用的映射，另一个是从整数引用到字符串值的映射。你可以通过编写
    fieldnames(PooledArray) 来获取 PooledArray 的所有字段列表。
- en: 'What is important is that the compressed pooled vector does not store the strings
    directly. Instead, it assigns an integer reference value to each unique string
    it stores. The invpool dictionary indicates the number assigned to each unique
    stored string:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，压缩池向量并不直接存储字符串。相反，它为存储的每个唯一字符串分配一个整数引用值。invpool 字典指示分配给每个唯一存储字符串的编号：
- en: '[PRE53]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this case, "Iris setosa" has been assigned to number 1, "Iris virginica"
    to number 2, and "Iris versicolor" to number 3.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，“Iris setosa”被分配为编号 1，“Iris virginica”为编号 2，“Iris versicolor”为编号 3。
- en: 'Observe that the assigned numbers start from 1\. Therefore, it is easy to encode
    the inverse mapping from numbers to values by using a vector. This is achieved
    in the pool field:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，分配的编号从 1 开始。因此，通过使用向量很容易编码从数字到值的逆映射。这是在 pool 字段中实现的：
- en: '[PRE54]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, if we want to find which string has been assigned number 1 in our compressed
    pooled vector, we just take the first element of the compressed.pool vector, which
    is "Iris setosa" in our case.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想在我们压缩的池向量中找到哪个字符串被分配了编号 1，我们只需取 compressed.pool 向量的第一个元素，在我们的例子中是 "Iris
    setosa"。
- en: 'It is crucial to observe that mappings in invpool and pool are consistent.
    As a result, if we take a reference number i, the following invariant is guaranteed
    to hold: compressed.invpool[compressed.pool[i]] is equal to i.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意 invpool 和 pool 中的映射是一致的。因此，如果我们取一个引用编号 i，以下不变量可以得到保证：compressed.invpool[compressed.pool[i]]
    等于 i。
- en: 'You are now ready to understand how compression is achieved. Note that the
    integer number assigned to the string uses less memory than the string itself.
    Therefore, instead of storing the strings, we store only the numbers assigned
    to them in the refs vector. Next, if the user wants to get an element of the compressed
    vector instead, the reference number of this element is retrieved from the refs
    vector, and then the actual value is looked up in the pool vector. Therefore,
    the following two lines of code are equivalent:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好理解压缩是如何实现的。请注意，分配给字符串的整数编号比字符串本身使用的内存少。因此，我们不是存储字符串，而是在 refs 向量中只存储分配给它们的编号。接下来，如果用户想要获取压缩向量的一个元素，则从
    refs 向量中检索该元素的引用编号，然后在 pool 向量中查找实际值。因此，以下两行代码是等价的：
- en: '[PRE55]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In our example, the integer reference numbers assigned to strings have the
    UInt32 type, so they use 4 bytes of memory, as explained in chapter 2\. On the
    other hand, our strings use more memory, which we again can check using the Base.summarysize
    function, this time broadcasting it over elements of the compressed.pool vector:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，分配给字符串的整数引用编号具有 UInt32 类型，因此它们使用 4 字节内存，正如第 2 章所述。另一方面，我们的字符串使用更多的内存，这我们可以再次使用
    Base.summarysize 函数来检查，这次是广播到 compressed.pool 向量的元素：
- en: '[PRE56]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We can see that these strings take up much more memory than 4 bytes. Additionally,
    we need to consider that apart from the raw size of the strings in the uncompressed
    vector, we additionally need to separately keep pointers to these vectors. Taking
    those two elements into consideration, you can now see the reason for the over
    seven-fold compression of the memory footprint of compressed versus uncompressed
    vectors.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这些字符串占用的内存比 4 字节多得多。此外，我们还需要考虑，除了未压缩向量中字符串的原始大小之外，我们还需要单独保留对这些向量的指针。考虑到这两个元素，你现在可以明白为什么压缩向量与未压缩向量相比，内存占用减少了七倍以上。
- en: 'I have spent so much time explaining how a pooled vector is implemented because
    it is important to help you understand when this data structure should be used.
    Using pooled vectors will be beneficial if you have a collection of strings with
    few unique values in comparison to the number of elements of the original collection.
    If this is not the case, you will not benefit from using the pooled vector, as
    instead of just storing the data, you’ll also need to store three objects: refs,
    pool, and invpool. It is crucial to note that pool and invpool have sizes proportional
    to the number of unique elements in a collection. So, they are small if there
    are few such unique values, but are quite large if there are many unique values.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我花费了这么多时间解释池化向量的实现方式，因为这很重要，可以帮助你理解何时应该使用这种数据结构。如果你有一组字符串，其中唯一值的数量与原始集合的元素数量相比很少，使用池化向量将会是有益的。如果不是这种情况，你将不会从使用池化向量中受益，因为你不仅需要存储数据，还需要存储三个对象：refs、pool
    和 invpool。重要的是要注意，pool 和 invpool 的大小与集合中唯一元素的数量成比例。因此，如果唯一值很少，它们会很小，但如果唯一值很多，它们会相当大。
- en: 'In conclusion, let’s construct a large vector containing all unique values
    by using the string function that you learned in chapter 5 and then compare the
    size of a normal vector storing such strings to the size of the pooled vector:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，让我们使用在第 5 章中学到的字符串函数构建一个包含所有唯一值的向量，然后比较存储此类字符串的正常向量的尺寸与池化向量的尺寸：
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As expected, since both the v1 and v2 vectors have all unique elements, the
    compressed vector v2 uses more than two times more memory than the uncompressed
    v1.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，由于 v1 和 v2 向量都包含所有唯一元素，压缩向量 v2 比未压缩的 v1 使用了超过两倍的内存。
- en: In a similar vein to fixed-width strings discussed in section 6.7, in part 2,
    you will learn that when getting your data from a CSV file, the Julia CSV reader
    can automatically detect that it is useful to use compressed vectors instead of
    standard vectors by analyzing how many unique values are present in data in relation
    to the number of stored elements.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 与第 6.7 节中讨论的固定宽度字符串类似，在第 2 部分中，你将了解到当从 CSV 文件获取数据时，Julia CSV 读取器可以通过分析数据中存在的唯一值数量与存储元素数量的关系，自动检测使用压缩向量而不是标准向量是有用的。
- en: If you are using pandas in Python and know about the Categorical type, or you’ve
    used factor in R, you might ask how they are related to PooledArrays.jl. The PooledArrays.jl
    objective is to provide compression only. It does not provide additional logic
    allowing you to work with categorical values (in a data science sense). In chapter
    13, you will learn about the CategoricalArrays.jl package, which provides a carefully
    designed implementation of categorical values for Julia. (If you would like to
    get a quick comparison of PooledArrays.jl and CategoricalArrays.jl, I recommend
    reading my “Categorical vs. Pooled Arrays” blog post at [http://mng.bz/N547](http://mng.bz/N547).)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Python 中的 pandas 并了解 Categorical 类型，或者你在 R 中使用过 factor，你可能会问它们与 PooledArrays.jl
    有何关联。PooledArrays.jl 的目标是仅提供压缩。它不提供额外的逻辑，允许你处理分类值（在数据科学的意义上）。在第 13 章中，你将学习到 CategoricalArrays.jl
    包，它为 Julia 提供了一个精心设计的分类值实现。（如果你想要快速比较 PooledArrays.jl 和 CategoricalArrays.jl，我建议阅读我的“分类值与池化数组”博客文章，链接为
    [http://mng.bz/N547](http://mng.bz/N547)。）
- en: 6.9 Choosing appropriate storage for collections of strings
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9 选择字符串集合的适当存储
- en: 'At this point, you might be overwhelmed by the number of options that Julia
    provides for storing collections of strings. Fortunately, as I have already hinted
    in sections 6.7 and 6.8, when reading in, for example, a CSV file, the reader
    automatically makes the right choice. However, it is useful to summarize the rules
    that can guide your choices if you want to make them yourself:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能会被 Julia 提供的用于存储字符串集合的选项数量所淹没。幸运的是，正如我在第 6.7 节和第 6.8 节中已经暗示的那样，在读取例如
    CSV 文件时，读取器会自动做出正确的选择。然而，如果你想要自己做出选择，总结一下可以指导你选择的规则是有用的：
- en: If your collection of strings is a few elements or you do not expect memory
    or performance to be crucial for your program, you can safely just use a standard
    String and store it in a standard collection type (for example, a Vector).
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的字符串集合只有几个元素，或者你预计内存或性能对你的程序不是关键因素，你可以安全地只使用标准的 String 并将其存储在标准集合类型中（例如，一个
    Vector）。
- en: 'If you have a lot of strings to store, you have the following choices:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有很多字符串需要存储，你有以下选择：
- en: If the number of unique values relative to the number of elements of your collection
    is small, you can still just use String, but store it in a PooledArray provided
    by the PooledArrays.jl package.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果唯一值相对于你的集合元素数量的比例较小，你仍然可以使用 String，但需要将其存储在 PooledArrays.jl 包提供的 PooledArray
    中。
- en: Otherwise, if your strings are short and have similar lengths, you can use fixed-width
    strings (String1, String3, String7, etc.) provided by the InlineStrings.jl package
    and store them in a standard collection (for example, a Vector).
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果你的字符串较短且长度相似，你可以使用 InlineStrings.jl 包提供的固定宽度字符串（String1, String3, String7
    等）并将它们存储在标准集合中（例如，一个 Vector）。
- en: Finally, if you have many strings that have many unique values, of which at
    least some are quite long, you need to make a final decision. If you are interested
    in treating these strings as labels and intend to only compare them for equality,
    use Symbol (remember that, technically, symbols are not strings, but if you want
    to only compare them, this most likely should not be an issue). Otherwise, use
    the standard String type. In both cases, you can use a standard collection (for
    example, a Vector).
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果你有很多具有许多唯一值的字符串，其中至少有一些相当长，你需要做出最终决定。如果你有兴趣将这些字符串作为标签处理，并且只想比较它们的相等性，使用
    Symbol（记住，技术上符号不是字符串，但如果你只想比较它们，这很可能不会是问题）。否则，使用标准的 String 类型。在这两种情况下，你都可以使用标准集合（例如，一个
    Vector）。
- en: 'As a summary, I will quote computer scientist Donald Knuth: “Premature optimization
    is the root of all evil.” How does this relate to our subject? Normally, when
    I start writing my Julia code, I most often use Vector{String} to store my strings
    (unless a package like CSV.jl automatically makes an optimal decision for me,
    as then I get optimization out of the box for free). Next, I check whether I run
    into any performance or memory bottlenecks (the simplest approach is to use the
    @time macro; more advanced profiling techniques are described in the Julia Manual
    at [https://docs.julialang.org/en/v1/manual/profile/](https://docs.julialang.org/en/v1/manual/profile/)),
    and if so, appropriately adjust the data types that are used.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 作为总结，我将引用计算机科学家唐纳德·克努特的话：“过早优化是所有罪恶的根源。”这与我们的主题有何关系？通常，当我开始编写 Julia 代码时，我通常最常使用
    Vector{String} 来存储我的字符串（除非像 CSV.jl 这样的包自动做出最优决策，那么我可以免费获得优化）。接下来，我会检查是否遇到任何性能或内存瓶颈（最简单的方法是使用
    @time 宏；更高级的剖析技术在第 1 版 Julia 手册的 [https://docs.julialang.org/en/v1/manual/profile/](https://docs.julialang.org/en/v1/manual/profile/)
    中描述），如果有，就适当地调整所使用的数据类型。
- en: An extremely convenient feature of multiple dispatch in Julia, discussed in
    chapter 3, is that changing the data types will not require rewriting the rest
    of your code. Provided you have not hardcoded concrete data types, but instead
    have properly used abstract types, like AbstractString, Julia will automatically
    handle changing the concrete implementation of the string container you decided
    to perform.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 中多分派的一个极其方便的特性，在第 3 章中讨论过，就是改变数据类型不会要求你重写代码的其他部分。只要你没有硬编码具体的数据类型，而是正确地使用了抽象类型，比如
    AbstractString，Julia 将会自动处理你决定执行的字符串容器的具体实现的变化。
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In Julia, you can use the download function from the Downloads module to download
    files from the web. This is an operation that you will frequently need to perform
    in practice.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Julia 中，你可以使用来自 Downloads 模块的 download 函数从网络上下载文件。这是一个在实践中你将经常需要执行的操作。
- en: You can concatenate strings by using the * character, so "a" * "b" produces
    "ab". This is often useful when you need to add a prefix or suffix to a string.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用 * 符号来连接字符串，所以 "a" * "b" 会产生 "ab"。这在需要给字符串添加前缀或后缀时非常有用。
- en: Using the $ character, you can interpolate values into a string. If you have
    a variable x bound to value 10, and you type "x = $x", you get "x = 10". This
    functionality is often used in practice, for example, to display intermediate
    results of computations.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 $ 符号，你可以将值插入到字符串中。如果你有一个变量 x 绑定了值为 10，并且你输入 "x = $x"，你会得到 "x = 10"。这种功能在实践中的应用很常见，例如，用于显示计算的中途结果。
- en: You can use raw string literals to avoid special treatment of \ and $ in string
    literals. This is useful when specifying paths in Windows. The raw"C:\DIR" literal
    is an example; if we omitted the raw prefix, we would get an error.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用原始字符串字面量来避免在字符串字面量中对 \ 和 $ 进行特殊处理。这在指定 Windows 中的路径时很有用。例如，raw"C:\DIR"
    字面量；如果我们省略了原始前缀，我们会得到一个错误。
- en: The readlines function can be used to read the contents of a file into a vector
    of strings, where each element of a resulting vector is a string representing
    a single line of the source file. This way of reading in files is convenient,
    as most text data is later parsed line by line.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: readlines 函数可以用来将文件的 内容读入一个字符串向量，其中结果向量的每个元素都是一个表示源文件单行的字符串。这种方式读取文件很方便，因为大多数文本数据最终都是按行解析的。
- en: The split function can be used to split a string into multiple strings on a
    specified delimiter. For example, split("a,b", ",") produces an ["a", "b"] vector.
    This kind of parsing of source data is often needed in practice.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 split 函数根据指定的分隔符将字符串分割成多个字符串。例如，split("a,b", ",") 产生一个 ["a", "b"] 向量。这种对源数据的解析在实际应用中很常见。
- en: A standard string type in Julia is String. However, since strings in Julia are
    immutable, some standard functions, when applied to a string of the String type,
    return a view into it that has the SubString{String} type. The benefit of such
    views is that they do not require allocating additional memory to store them.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 中的标准字符串类型是 String。然而，由于 Julia 中的字符串是不可变的，当将一些标准函数应用于 String 类型的字符串时，它们会返回一个具有
    SubString{String} 类型的视图。这种视图的好处是它们不需要分配额外的内存来存储。
- en: When you write your own functions that accept strings, specify AbstractString
    as a type parameter in the function definition to ensure that it will work with
    any string type that the user might want to pass. Because Julia has many string
    types, your functions should be implemented in a generic way.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你编写接受字符串的自定义函数时，在函数定义中指定 AbstractString 作为类型参数，以确保它将适用于用户可能想要传递的任何字符串类型。由于
    Julia 有许多字符串类型，因此你的函数应以通用方式实现。
- en: Julia has full support for working with regular expressions, which are useful
    in extracting information from string data. You can create regular expression
    literals by prefixing a string with r—for example, the r"a.a" pattern matches
    a three-character sequence that starts and ends with a and contains any character
    in the middle. Regular expressions are commonly used to extract data from text
    sources.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 完全支持使用正则表达式，这对于从字符串数据中提取信息很有用。你可以通过在字符串前加上 r 来创建正则表达式文字——例如，r"a.a" 模式匹配以
    a 开头和结尾的三个字符序列，中间包含任何字符。正则表达式通常用于从文本源中提取数据。
- en: You can use the parse function to convert strings to numbers; for example, parse(Int,
    "10") returns the integer 10. This functionality is often needed when processing
    numeric data stored in text files.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 parse 函数将字符串转换为数字；例如，parse(Int, "10") 返回整数 10。在处理存储在文本文件中的数值数据时，这种功能通常很有用。
- en: Strings in Julia use UTF-8 encoding, so each character can take up 1, 2, 3,
    or 4 bytes in a string. ASCII characters always use 1 byte in this encoding. Therefore,
    in general, the number of characters in a string can be less than the number of
    bytes in this string.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 中的字符串使用 UTF-8 编码，因此每个字符在字符串中可能占用 1、2、3 或 4 个字节。在这种编码中，ASCII 字符始终占用 1 个字节。因此，通常情况下，字符串中的字符数可能少于该字符串的字节数。
- en: When manipulating strings, you can use byte or character counts to refer to
    a concrete section of the string. For ASCII strings, these approaches are equivalent,
    but in general, they are not. You must always check whether the function you use
    operates on byte or character counts.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在操作字符串时，你可以使用字节或字符计数来引用字符串的某个具体部分。对于 ASCII 字符串，这些方法等效，但在一般情况下并不等效。你必须始终检查你使用的函数是操作字节计数还是字符计数。
- en: String indexing with square brackets—for example, "abc"[2:3]—uses byte indexing.
    Because strings in Julia are UTF-8 encoded, not all indices are valid for this
    kind of indexing.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方括号进行字符串索引——例如，"abc"[2:3]——使用字节索引。由于 Julia 中的字符串是 UTF-8 编码的，因此并非所有索引都适用于这种索引方式。
- en: Commonly used functions that use character indexing are length, chop, first,
    and last.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用的使用字符索引的函数有 length、chop、first 和 last。
- en: The FreqTables.jl package provides freqtable and proptable functions that allow
    you to easily create frequency tables from your data. These summaries of source
    data are commonly used in data science workflows.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreqTables.jl 包提供了 freqtable 和 proptable 函数，允许你轻松地从你的数据中创建频率表。这些源数据摘要在数据科学工作流程中很常见。
- en: Symbol is a special type that is not a string but is sometimes used when your
    strings are considered labels and you only need to compare them, while requiring
    that the comparison is performed fast.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号是一个特殊类型，它不是字符串，但在你的字符串被视为标签且只需要比较它们时，有时会用到。同时，要求比较操作快速执行。
- en: Symbols that are valid variable name identifiers can be conveniently created
    with a colon (:) prefix—for example, :some_symbol.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用冒号（:）前缀方便地创建有效的变量名标识符，例如，:some_symbol。
- en: 'The InlineStrings.jl package defines several fixed-width string types: String1,
    String3, String7, etc. If your strings are short and have a uniform length, such
    nonstandard string types will use less memory and will be faster to process in
    many operations such as sorting.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: InlineStrings.jl 包定义了几个固定宽度的字符串类型：String1, String3, String7 等。如果你的字符串较短且长度一致，这种非标准字符串类型将使用更少的内存，并且在许多操作（如排序）中处理速度更快。
- en: You can open files for writing by using the open function. You can then write
    to them by using, for example, the println function if you pass the file descriptor
    (indicating where the data should be written) as a first argument.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 open 函数打开文件进行写入。然后，你可以通过使用 println 函数（例如，如果你将文件描述符（指示数据应写入的位置）作为第一个参数传递）来写入它们。
- en: Values of the PooledArray type from the PooledArrays.jl package let you compress
    the memory size of collections of strings if you only have a few unique values
    in them. In such cases, using this functionality can save you a lot of RAM.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 PooledArrays.jl 包的 PooledArray 类型值允许你在其中只有少量唯一值时压缩字符串集合的内存大小。在这种情况下，使用此功能可以节省大量
    RAM。
- en: Julia provides several options for storing strings in collections, each with
    a slightly different performance and memory usage profile. This allows you to
    flexibly optimize your code against the structure of the data you process. Additionally,
    several standard Julia packages, like CSV.jl, will create nonstandard InlineStrings.jl
    strings or PooledVector automatically for you when reading in the data if they
    detect that they would be more efficient.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 提供了多种将字符串存储在集合中的选项，每种选项都有略微不同的性能和内存使用概况。这允许你根据处理的数据结构灵活优化你的代码。此外，当检测到使用这些字符串会更高效时，几个标准的
    Julia 包，如 CSV.jl，会在读取数据时自动为你创建非标准的 InlineStrings.jl 字符串或 PooledVector。
