- en: 3 Constraint-satisfaction problems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 约束满足问题
- en: A large number of problems that computational tools are used to solve can be
    broadly categorized as constraint-satisfaction problems (CSPs). CSPs are composed
    of variables with possible values that fall into ranges known as domains. Constraints
    between the variables must be satisfied in order for constraint-satisfaction problems
    to be solved. Those three core concepts--variables, domains, and constraints--are
    simple to understand, and their generality underlies the wide applicability of
    constraint-satisfaction problem solving.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多使用计算工具解决的问题可以广泛地归类为约束满足问题（CSPs）。CSPs由具有可能值的变量组成，这些值落在称为域的范围之内。为了解决约束满足问题，变量之间的约束必须得到满足。这三个核心概念——变量、域和约束——易于理解，它们的通用性是约束满足问题求解广泛适用的基础。
- en: Let’s consider an example problem. Suppose you are trying to schedule a Friday
    meeting for Joe, Mary, and Sue. Sue has to be at the meeting with at least one
    other person. For this scheduling problem, the three people--Joe, Mary, and Sue--may
    be the variables. The domain for each variable may be their respective hours of
    availability. For instance, the variable Mary has the domain 2 p.m., 3 p.m., and
    4 p.m. This problem also has two constraints. One is that Sue has to be at the
    meeting. The other is that at least two people must attend the meeting. A constraint-satisfaction
    problem solver will be provided with the three variables, three domains, and two
    constraints, and it will then solve the problem without having the user explain
    exactly how. Figure 3.1 illustrates this example.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例问题。假设你正在尝试为Joe、Mary和Sue安排一个周五的会议。Sue必须至少与另一个人一起参加会议。对于这个调度问题，三个人——Joe、Mary和Sue——可能是变量。每个变量的域可能是他们各自的可用时间。例如，变量Mary的域是下午2点、下午3点和下午4点。这个问题也有两个约束。一个是Sue必须参加会议。另一个是至少有两个人必须参加会议。约束满足问题求解器将提供三个变量、三个域和两个约束，然后它将解决问题，而不需要用户解释确切的方法。图3.1说明了这个例子。
- en: Programming languages like Prolog and Picat have facilities for solving constraint-satisfaction
    problems built in. The usual technique in other languages is to build a framework
    that incorporates a backtracking search and several heuristics to improve the
    performance of that search. In this chapter, we will first build a framework for
    CSPs that solves them using a simple recursive backtracking search. Then we will
    use the framework to solve several different example problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Prolog和Picat这样的编程语言内置了解决约束满足问题的功能。在其他语言中，通常的技术是构建一个框架，该框架包含回溯搜索和几个启发式算法来提高搜索性能。在本章中，我们将首先构建一个用于CSPs的框架，该框架使用简单的递归回溯搜索来解决问题。然后我们将使用该框架来解决几个不同的示例问题。
- en: '![3-1](../Images/3-1.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![3-1](../Images/3-1.png)'
- en: Figure 3.1 Scheduling problems are a classic application of constraint-satisfaction
    frameworks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 调度问题是约束满足框架的经典应用。
- en: 3.1 Building a constraint-satisfaction problem framework
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 构建约束满足问题框架
- en: Constraints will be defined as subclasses of a Constraint class. Each Constraint
    consists of the variables it constrains and a method that checks whether it is
    satisfied(). The determination of whether a constraint is satisfied is the main
    logic that goes into defining a specific constraint-satisfaction problem.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 约束将被定义为Constraint类的子类。每个约束由它约束的变量和一个检查它是否满足()的方法组成。约束是否满足的确定是定义特定约束满足问题的主要逻辑。
- en: The default implementation should be overridden. In fact, it must be, because
    we are defining our Constraint class as an abstract base class. Abstract base
    classes are not meant to be instantiated. Instead, only their subclasses that
    override and implement their abstract methods are for actual use.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 默认实现应该被覆盖。实际上，它必须被覆盖，因为我们正在将我们的Constraint类定义为抽象基类。抽象基类不应该被实例化。相反，只有它们的子类，这些子类覆盖并实现了它们的抽象方法，才是实际使用的。
- en: Listing 3.1 Constraint.java
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 Constraint.java
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: TIP It can be difficult to choose between an abstract class and an interface
    in Java. Only abstract classes can have instance variables. Since we have the
    variables instance variable, we opted for an abstract class here.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 在Java中，选择抽象类和接口可能会有困难。只有抽象类可以有实例变量。由于我们有实例变量，所以我们在这里选择了抽象类。
- en: The centerpiece of our constraint-satisfaction framework will be a class called
    CSP. CSP is the gathering point for variables, domains, and constraints. It uses
    generics to make itself flexible enough to work with any kind of variables and
    domain values (V keys and D domain values). Within CSP, the variables, domains,
    and constraints collections are of types that you would expect. The variables
    collection is a List of variables, domains is a Map mapping variables to lists
    of possible values (the domains of those variables), and constraints is a Map
    that maps each variable to a List of the constraints imposed on it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们约束满足框架的核心将是一个名为CSP的类。CSP是变量、域和约束的汇集点。它使用泛型使其足够灵活，可以与任何类型的变量和域值（V键和D域值）一起工作。在CSP内部，变量、域和约束集合的类型是你所期望的。变量集合是一个变量列表，域是一个将变量映射到可能值列表（这些变量的域）的Map，约束是一个将每个变量映射到对其施加的约束列表的Map。
- en: Listing 3.2 CSP.java
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 CSP.java
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The constructor creates the constraints Map. The addConstraint() method goes
    through all of the variables touched by a given constraint and adds itself to
    the constraints mapping for each of them. Both methods have basic error-checking
    in place and will raise an exception when a variable is missing a domain or a
    constraint is on a nonexistent variable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数创建约束Map。addConstraint()方法遍历给定约束影响的每个变量，并将自身添加到每个变量的约束映射中。这两个方法都有基本的错误检查，当变量缺少域或约束在不存在变量上时，将引发异常。
- en: How do we know if a given configuration of variables and selected domain values
    satisfies the constraints? We will call such a given configuration an assignment.
    In other words, an assignment is a specific domain value selected for each variable.
    We need a function that checks every constraint for a given variable against an
    assignment to see if the variable’s value in the assignment is consistent with
    the constraints. Here, we implement a consistent() function as a method on CSP.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道给定的变量配置和选定的域值配置是否满足约束？我们将这样的给定配置称为赋值。换句话说，赋值是每个变量选定的特定域值。我们需要一个函数来检查给定变量的每个约束与赋值，以查看赋值中的变量值是否与约束一致。在这里，我们实现了一个consistent()函数作为CSP的方法。
- en: Listing 3.3 CSP.java continued
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 CSP.java继续
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: consistent() goes through every constraint for a given variable (it will always
    be the variable that was just added to the assignment) and checks if the constraint
    is satisfied, given the new assignment. If the assignment satisfies every constraint,
    true is returned. If any constraint imposed on the variable is not satisfied,
    false is returned.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: consistent()遍历给定变量的每个约束（它将始终是刚刚添加到赋值中的变量）并检查在新的赋值下约束是否得到满足。如果赋值满足每个约束，则返回true。如果对变量的任何约束没有得到满足，则返回false。
- en: This constraint-satisfaction framework will use a simple backtracking search
    to find solutions to problems. Backtracking is the idea that once you hit a wall
    in your search, you go back to the last known point where you made a decision
    before the wall, and you choose a different path. If you think that sounds like
    depth-first search from chapter 2, you are perceptive. The backtracking search
    implemented in the following backtrackingSearch() method is a kind of recursive
    depth-first search, combining ideas you saw in chapters 1 and 2\. We also implement
    a helper method that just calls backtrackingSearch() with an empty initial Map.
    The helper method will be useful for starting a search.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束满足框架将使用简单的回溯搜索来找到问题的解决方案。回溯的思想是，一旦你在搜索中遇到障碍，你就回到最后一个已知点，在那里你在障碍之前做出了决定，然后你选择一条不同的路径。如果你认为这听起来像第二章中的深度优先搜索，你很敏锐。在下面的backtrackingSearch()方法中实现的回溯搜索是一种递归深度优先搜索，结合了你在第一章和第二章中看到的思想。我们还实现了一个辅助方法，它只是调用带有空初始Map的backtrackingSearch()。这个辅助方法将有助于开始搜索。
- en: Listing 3.4 CSP.java continued
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 CSP.java继续
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s walk through backtrackingSearch(), line by line:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析backtrackingSearch()：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The base case for the recursive search is having found a valid assignment for
    every variable. Once we have, we return the first instance of a solution that
    was valid. (We do not keep searching.)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 递归搜索的基本情况是找到了每个变量的有效赋值。一旦我们找到了，我们就返回第一个有效的解决方案实例。（我们不再继续搜索。）
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To select a new variable whose domain we will explore, we simply go through
    all of the variables and find the first that does not have an assignment. To do
    this, we create a Stream of variables filtered by whether they are yet in assignment,
    and we pull the first one that is not assigned using findFirst(). filter() takes
    a Predicate. A Predicate is a functional interface that describes a function that
    takes one argument and returns a boolean. Our predicate is a lambda expression
    (v -> !assignment.containsKey(v)) that returns true if assignment does not contain
    the argument, which in this case will be a variable for our CSP.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择一个我们将探索其域的新变量，我们只需遍历所有变量，找到第一个还没有分配的变量。为此，我们创建一个变量流，通过是否已分配来过滤变量，并使用findFirst()提取第一个未分配的变量。filter()需要一个谓词。谓词是一个描述接受一个参数并返回一个布尔值的函数的功能接口。我们的谓词是一个lambda表达式（v
    -> !assignment.containsKey(v)），如果assignment不包含参数，它将返回true，在这种情况下，它将是我们的CSP中的一个变量。
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We try assigning all possible domain values for that variable, one at a time.
    The new assignment for each is stored in a local map called localAssignment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试为该变量分配所有可能的域值，一次一个。每个新分配的结果都存储在一个名为localAssignment的本地映射中。
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the new assignment in localAssignment is consistent with all of the constraints
    (this is what consistent() checks for), we continue recursively searching with
    the new assignment in place. If the new assignment turns out to be complete (the
    base case), we return the new assignment up the recursion chain.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在localAssignment中的新分配与所有约束一致（这是consistent()检查的内容），我们则继续递归搜索，使用新分配的值。如果新分配最终被证明是完整的（基本案例），我们将新分配返回到递归链。
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, if we have gone through every possible domain value for a particular
    variable, and there is no solution utilizing the existing set of assignments,
    we return null, indicating no solution. This will lead to backtracking up the
    recursion chain to the point where a different prior assignment could have been
    made.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们已经遍历了特定变量的所有可能的域值，并且没有利用现有分配集的解决方案，我们返回null，表示没有解决方案。这将导致回溯到递归链的某个点，在那个点上可能做出了不同的先前分配。
- en: 3.2 The Australian map-coloring problem
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 澳大利亚地图着色问题
- en: Imagine you have a map of Australia that you want to color by state/territory
    (which we will collectively call regions). No two adjacent regions should share
    a color. Can you color the regions with just three different colors?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一张澳大利亚地图，你想按州/领地（我们将它们统称为区域）进行着色。相邻的区域不应共享相同的颜色。你能只用三种不同的颜色来着色这些区域吗？
- en: The answer is yes. Try it out on your own. (The easiest way is to print out
    a map of Australia with a white background.) As human beings, we can quickly figure
    out the solution by inspection and a little trial and error. It is a trivial problem,
    really, and a great first problem for our backtracking constraint-satisfaction
    solver. A solution to the problem is illustrated in figure 3.2.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的。自己试一试。（最简单的方法是打印一张澳大利亚地图，背景为白色。）作为人类，我们可以通过检查和一点试错快速找到解决方案。这实际上是一个简单的问题，也是我们回溯约束满足求解器的第一个好问题。问题的一个解决方案如图3.2所示。
- en: '![3-2](../Images/3-2.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![3-2](../Images/3-2.png)'
- en: Figure 3.2 In a solution to the Australian map-coloring problem, no two adjacent
    parts of Australia can be colored with the same color.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 在澳大利亚地图着色问题的解决方案中，澳大利亚的相邻部分不能着色相同的颜色。
- en: 'To model the problem as a CSP, we need to define the variables, domains, and
    constraints. The variables are the seven regions of Australia (at least the seven
    that we will restrict ourselves to): Western Australia, Northern Territory, South
    Australia, Queensland, New South Wales, Victoria, and Tasmania. In our CSP, they
    can be modeled with strings. The domain of each variable is the three different
    colors that can possibly be assigned. (We will use red, green, and blue.) The
    constraints are the tricky part. No two adjacent regions can be colored with the
    same color, so our constraints will be dependent on which regions border one another.
    We can use what are called binary constraints (constraints between two variables).
    Every two regions that share a border will also share a binary constraint indicating
    that they cannot be assigned the same color.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要将问题建模为CSP，我们需要定义变量、域和约束。变量是澳大利亚的七个区域（至少是我们将限制自己的七个区域）：西澳大利亚、北领地、南澳大利亚、昆士兰州、新南威尔士州、维多利亚州和塔斯马尼亚州。在我们的CSP中，它们可以用字符串来建模。每个变量的域是可以分配的三种不同颜色。（我们将使用红色、绿色和蓝色。）约束是难点。相邻的两个区域不能使用相同的颜色，因此我们的约束将取决于哪些区域相邻。我们可以使用所谓的二元约束（两个变量之间的约束）。共享边界的每个区域都将共享一个二元约束，表示它们不能分配相同的颜色。
- en: 'To implement these binary constraints in code, we need to subclass the Constraint
    class. The MapColoringConstraint subclass will take two variables in its constructor:
    the two regions that share a border. Its overridden satisfied() method will check
    first whether the two regions have domain values (colors) assigned to them; if
    either does not, the constraint is trivially satisfied until they do. (There cannot
    be a conflict when one does not yet have a color.) Then it will check whether
    the two regions are assigned the same color. Obviously, there is a conflict, meaning
    that the constraint is not satisfied, when they are the same.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中实现这些二元约束，我们需要对约束类进行子类化。MapColoringConstraint子类将在其构造函数中接受两个变量：共享边界的两个区域。它重写的satisfied()方法将首先检查这两个区域是否分配了域值（颜色）；如果任何一个没有分配，则约束在它们分配之前
    trivially 满足。（如果一个还没有颜色，则不可能存在冲突。）然后它将检查这两个区域是否分配了相同的颜色。显然，如果它们分配了相同的颜色，则存在冲突，这意味着约束不满足。
- en: The class is presented here in its entirety except for its main() driver. MapColoringConstraint
    itself is not generic, but it subclasses a parameterized version of the generic
    class Constraint that indicates both variables and domains are of type String.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了类的全部内容，除了其main()驱动程序。MapColoringConstraint本身不是泛型的，但它子类化了一个泛型类Constraint的参数化版本，该版本指示变量和域都是String类型。
- en: Listing 3.5 MapColoringConstraint.java
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 MapColoringConstraint.java
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have a way of implementing the constraints between regions, fleshing
    out the Australian map-coloring problem with our CSP solver is simply a matter
    of filling in domains and variables, and then adding constraints.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了实现区域之间约束的方法，使用我们的CSP求解器完善澳大利亚地图着色问题只是一个填充域和变量，然后添加约束的问题。
- en: Listing 3.6 MapColoringConstraint.java continued
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 MapColoringConstraint.java继续
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, backtrackingSearch() is called to find a solution.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用backtrackingSearch()来寻找解决方案。
- en: Listing 3.7 MapColoringConstraint.java continued
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 MapColoringConstraint.java继续
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A correct solution will include an assigned color for every region:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确的解决方案将包括为每个区域分配的颜色：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 3.3 The eight queens problem
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 八皇后问题
- en: A chessboard is an eight-by-eight grid of squares. A queen is a chess piece
    that can move on the chessboard any number of squares along any row, column, or
    diagonal. A queen is attacking another piece if, in a single move, it can move
    to the square the piece is on without jumping over any other piece. (In other
    words, if the other piece is in the line of sight of the queen, then it is attacked
    by it.) The eight queens problem poses the question of how eight queens can be
    placed on a chessboard without any queen attacking another queen. One of many
    potential solutions to the problem is illustrated in figure 3.3.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 象棋盘是一个由八个方格组成的八乘八网格。皇后是一种可以在棋盘上沿任何行、列或对角线移动任意数量的方格的棋子。如果皇后在一次移动中可以移动到另一个棋子所在的方格，而不跳过任何其他棋子，则它攻击另一个棋子。（换句话说，如果另一个棋子在皇后的视线范围内，则它被攻击。）八皇后问题提出了如何在棋盘上放置八个皇后，使得没有皇后攻击另一个皇后的疑问。该问题的许多潜在解决方案之一如图3.3所示。
- en: To represent squares on the chessboard, we will assign each an integer row and
    an integer column. We can ensure each of the eight queens is not in the same column
    by simply assigning them sequentially the columns 1 through 8\. The variables
    in our constraint-satisfaction problem can just be the column of the queen in
    question. The domains can be the possible rows (again, 1 through 8). Listing 3.8
    shows the end of our file, where we define these variables and domains.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示棋盘上的方格，我们将为每个方格分配一个整数行和一个整数列。我们可以通过简单地按顺序将列 1 到 8 分配给每个皇后来确保八个皇后不在同一列。我们的约束满足问题中的变量可以是所讨论的皇后的列。域可以是可能的行（再次强调，1
    到 8）。列表 3.8 展示了我们的文件末尾，其中我们定义了这些变量和域。
- en: '![3-3](../Images/3-3.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![3-3](../Images/3-3.png)'
- en: Figure 3.3 In a solution to the eight queens problem (there are many solutions),
    no two queens can be threatening each other.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 在八皇后问题的解决方案中（有多个解决方案），没有两个皇后会相互威胁。
- en: Listing 3.8 QueensConstraint.java
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 QueensConstraint.java
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To solve the problem, we will need a constraint that checks whether any two
    queens are on the same row or diagonal. (They were all assigned different sequential
    columns to begin with.) Checking for the same row is trivial, but checking for
    the same diagonal requires a little bit of math. If any two queens are on the
    same diagonal, the difference between their rows will be the same as the difference
    between their columns. Can you see where these checks take place in QueensConstraint?
    Note that the following code is at the top of our source file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决问题，我们需要一个约束来检查是否有任何两个皇后在同一行或对角线上。（它们最初都被分配了不同的连续列。）检查同一行是显而易见的，但检查同一对角线需要一点数学知识。如果任何两个皇后在同一对角线上，它们的行之间的差将等于它们的列之间的差。你能在
    QueensConstraint 中看到这些检查在哪里进行吗？请注意，以下代码位于我们的源文件顶部。
- en: Listing 3.9 QueensConstraint.java continued
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9 QueensConstraint.java 续
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All that is left is to add the constraint and run the search. We’re now back
    at the bottom of the file within the end of main().
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是添加约束并运行搜索。我们现在回到了文件底部的 main() 函数末尾。
- en: Listing 3.10 QueensConstraint.java continued
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10 QueensConstraint.java 续
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that we were able to reuse the constraint-satisfaction problem-solving
    framework that we built for map coloring fairly easily for a completely different
    type of problem. This is the power of writing code generically! Algorithms should
    be implemented in as broadly applicable a manner as possible unless a performance
    optimization for a particular application requires specialization.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们能够相当容易地重用我们为地图着色构建的约束满足问题解决框架来解决一个完全不同类型的问题。这就是编写通用代码的力量！除非特定应用需要性能优化而需要专业化，否则算法应该以尽可能广泛适用的方式实现。
- en: 'A correct solution will assign a column and row to every queen:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确的解决方案将为每个皇后分配一个列和行：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 3.4 Word search
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 单词搜索
- en: A word search is a grid of letters with hidden words placed along rows, columns,
    and diagonals. A player of a word-search puzzle attempts to find the hidden words
    by carefully scanning through the grid. Finding places to put the words so that
    they all fit on the grid is a kind of constraint-satisfaction problem. The variables
    are the words, and the domains are the possible locations of those words. The
    problem is illustrated in figure 3.4\. Our goal in this section is to generate
    a word-search puzzle, not to solve one.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 单词搜索是一种字母网格，隐藏的单词沿行、列和对角线放置。一个单词搜索谜题的玩家试图通过仔细扫描网格来寻找隐藏的单词。找到放置单词的位置，使它们都能适应网格，是一种约束满足问题。变量是单词，域是这些单词的可能位置。本节的目标是生成一个单词搜索谜题，而不是解决一个。
- en: '![3-4](../Images/3-4.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![3-4](../Images/3-4.png)'
- en: Figure 3.4 A classic word search, such as you might find in a children’s puzzle
    book
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 一个经典的单词搜索，你可能在儿童谜题书中找到
- en: For the purposes of expediency, our word search will not include words that
    overlap. You can improve it to allow for overlapping words as an exercise.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们的单词搜索将不包括重叠的单词。你可以作为一个练习将其改进为允许重叠的单词。
- en: The grid of this word-search problem is not entirely dissimilar from the mazes
    of chapter 2\. Some of the following data types should look familiar. WordGrid
    is analogous to Maze, and GridLocation is analogous to MazeLocation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单词搜索问题的网格与第 2 章中的迷宫并不完全不同。以下的一些数据类型应该看起来很熟悉。WordGrid 类似于 Maze，GridLocation
    类似于 MazeLocation。
- en: Listing 3.11 WordGrid.java
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.11 WordGrid.java
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Initially, we will fill the grid with random letters of the English alphabet
    (A-Z). We do this by generating random char codes (integers, effectively) equivalent
    to where the letters land in ASCII. We will also need a method to mark a word
    on the grid given a list of locations, and a method for displaying the grid.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们将使用随机英文字母（A-Z）填充网格。我们通过生成与字母在 ASCII 中的位置相对应的随机字符码（整数）来实现这一点。我们还需要一个方法来根据位置列表在网格上标记一个单词，以及一个用于显示网格的方法。
- en: Listing 3.12 WordGrid.java continued
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.12 WordGrid.java 继续内容
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To figure out where words can fit in the grid, we will generate their domains.
    The domain of a word is a list of lists of the possible locations of all of its
    letters (List<List<GridLocation>>). Words cannot go just anywhere, though. They
    must stay within a row, column, or diagonal that is within the bounds of the grid.
    In other words, they should not go off the end of the grid. The purpose of generateDomain()
    and its helper “fill” methods is to build these lists for every word.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定单词在网格中的位置，我们将生成它们的域。一个单词的域是一个列表的列表，包含所有字母的可能位置（List<List<GridLocation>>）。然而，单词不能随意放置。它们必须保持在网格范围内的行、列或对角线上。换句话说，它们不应该超出网格的末端。generateDomain()
    及其辅助的“fill”方法的目的就是为每个单词构建这些列表。
- en: Listing 3.13 WordGrid.java continued
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.13 WordGrid.java 继续内容
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For the range of potential locations of a word (along a row, column, or diagonal),
    for loops translate the range into a list of GridLocations. Because generateDomain()
    loops through every grid location from the top left through to the bottom right
    for every word, it involves a lot of computation. Can you think of a way to do
    it more efficiently? What if we looked through all of the words of the same length
    at once, inside the loop?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个单词的可能位置范围（沿行、列或对角线），for 循环将范围转换成一系列 GridLocations。因为 generateDomain() 遍历每个单词从左上角到右下角的每个网格位置，所以它涉及大量的计算。你能想到一种更高效的方法吗？如果我们一次在循环中查看所有相同长度的单词会怎样？
- en: To check if a potential solution is valid, we must implement a custom constraint
    for the word search. The satisfied() method of WordSearchConstraint simply checks
    whether any of the locations proposed for one word are the same as a location
    proposed for another word. It does this using a Set. Converting a List into a
    Set will remove all duplicates. If there are fewer items in a Set converted from
    a List than there were in the original List, that means the original List contained
    some duplicates. To prepare the data for this check, we will use a flatMap() to
    combine multiple sublists of locations for each word in the assignment into a
    single larger list of locations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个潜在解决方案是否有效，我们必须为单词搜索实现一个自定义约束。WordSearchConstraint 的 satisfied() 方法简单地检查一个单词提出的任何位置是否与另一个单词提出的任何位置相同。它是通过使用
    Set 来实现的。将 List 转换为 Set 将删除所有重复项。如果从 List 转换为 Set 的项目比原始 List 中的项目少，这意味着原始 List
    包含一些重复项。为了准备此检查的数据，我们将使用 flatMap() 将每个单词在任务中的多个位置子列表组合成一个更大的位置列表。
- en: Listing 3.14 WordSearchConstraint.java
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.14 WordSearchConstraint.java
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, we are ready to run it. For this example, we have five words (names,
    in this example) in a nine-by-nine grid. The solution we get back should contain
    mappings between each word and the locations where its letters can fit in the
    grid.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备运行它。对于此示例，我们有五个单词（在这个例子中是名字）在一个九乘九的网格中。我们得到的解决方案应该包含每个单词与其字母在网格中可以放置的位置之间的映射。
- en: Listing 3.15 WordSearchConstraint.java continued
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.15 WordSearchConstraint.java 继续内容
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There is a finishing touch in the code that fills the grid with words. Some
    words are randomly chosen to be reversed. This is valid, because this example
    does not allow overlapping words. Your ultimate output should look something like
    the following. Can you find Matthew, Joe, Mary, Sarah, and Sally?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中有一个填充网格的单词的细节。一些单词被随机选择为反向。这是有效的，因为此示例不允许单词重叠。你的最终输出应该类似于以下内容。你能找到 Matthew、Joe、Mary、Sarah
    和 Sally 吗？
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 3.5 SEND+MORE=MONEY
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 **SEND+MORE=MONEY**
- en: SEND+MORE=MONEY is a cryptarithmetic puzzle, meaning that it is about finding
    digits that replace letters to make a mathematical statement true. Each letter
    in the problem represents one digit (0-9). No two letters can represent the same
    digit. When a letter repeats, it means a digit repeats in the solution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**SEND+MORE=MONEY** 是一个密码学难题，意味着它关于找到数字来替换字母，使得一个数学陈述成立。问题中的每个字母代表一个数字（0-9）。没有两个字母可以代表相同的数字。当一个字母重复时，意味着解决方案中的数字也重复。'
- en: To solve this puzzle by hand, it helps to line up the words.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动解决这个谜题，排列单词很有帮助。
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It is absolutely solvable by hand, with a bit of algebra and intuition. But
    a fairly simple computer program can solve it faster by brute-forcing many possible
    solutions. Let’s represent SEND+MORE=MONEY as a constraint-satisfaction problem.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全可以通过手动解决，只需一点代数和直觉。但一个相当简单的计算机程序可以通过穷举许多可能的解决方案来更快地解决它。让我们将 SEND+MORE=MONEY
    表示为一个约束满足问题。
- en: Listing 3.16 SendMoreMoneyConstraint.java
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.16 SendMoreMoneyConstraint.java
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: SendMoreMoneyConstraint’s satisfied() method does a few things. First, it checks
    if multiple letters represent the same digits. If they do, that’s an invalid solution,
    and it returns false. Next, it checks if all letters have been assigned. If they
    have, it checks to see if the formula (SEND+MORE=MONEY) is correct with the given
    assignment. If it is, a solution has been found, and it returns true. Otherwise,
    it returns false. Finally, if all letters have not yet been assigned, it returns
    true. This is to ensure that a partial solution continues to be worked on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SendMoreMoneyConstraint 的 satisfied() 方法做了几件事情。首先，它检查多个字母是否代表相同的数字。如果是，则这是一个无效的解决方案，并返回
    false。接下来，它检查是否所有字母都已分配。如果已经分配，它检查给定的分配是否使公式（SEND+MORE=MONEY）正确。如果是，则找到了解决方案，并返回
    true。否则，它返回 false。最后，如果所有字母尚未分配，它返回 true。这是为了确保部分解决方案继续被处理。
- en: Let’s try running it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行它。
- en: Listing 3.17 SendMoreMoneyConstraint.java continued
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.17 SendMoreMoneyConstraint.java 继续阅读
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You will notice that we preassigned the answer for the letter M. This was to
    ensure that the answer doesn’t include a 0 for M, because if you think about it,
    our constraint has no notion of the concept that a number can’t start with zero.
    Feel free to try it out without that preassigned answer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们预先分配了字母 M 的答案。这是为了确保答案中不包含 M 的 0，因为如果你想想，我们的约束没有关于一个数字不能以零开头的概念。你可以自由尝试不使用预先分配的答案。
- en: 'The solution should look something like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案应该看起来像这样：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 3.6 Circuit board layout
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 电路板布局
- en: A manufacturer needs to fit certain rectangular chips onto a rectangular circuit
    board. Essentially, this problem asks, “How can several different-sized rectangles
    all fit snugly inside of another rectangle?” A constraint-satisfaction problem
    solver can find the solution. The problem is illustrated in figure 3.5.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 制造商需要将某些矩形芯片安装到矩形电路板上。本质上，这个问题是询问，“如何将几个不同大小的矩形都紧密地放入另一个矩形中？”一个约束满足问题求解器可以找到解决方案。这个问题在图
    3.5 中有说明。
- en: '![3-5](../Images/3-5.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![3-5](../Images/3-5.png)'
- en: Figure 3.5 The circuit board layout problem is very similar to the word-search
    problem, but the rectangles are of variable width.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 电路板布局问题与单词搜索问题非常相似，但矩形宽度是可变的。
- en: The circuit board layout problem is similar to the word-search problem. Instead
    of 1 × N rectangles (words), the problem presents M × N rectangles. Like in the
    word-search problem, the rectangles cannot overlap. The rectangles cannot be put
    on diagonals, so in that sense the problem is actually simpler than the word search.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 电路板布局问题类似于单词搜索问题。问题中不是 1 × N 的矩形（单词），而是 M × N 的矩形。就像在单词搜索问题中一样，矩形不能重叠。矩形不能放在对角线上，从这个意义上说，这个问题实际上比单词搜索问题简单。
- en: On your own, try rewriting the word-search solution to accommodate circuit board
    layout. You can reuse much of the code, including the code for the grid.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 亲自尝试将单词搜索解决方案重写以适应电路板布局。你可以重用大部分代码，包括网格的代码。
- en: 3.7 Real-world applications
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 现实世界应用
- en: As was mentioned in the introduction to this chapter, constraint-satisfaction
    problem solvers are commonly used in scheduling. Several people need to be at
    a meeting, and they are the variables. The domains consist of the open times on
    their calendars. The constraints may involve what combinations of people are required
    at the meeting.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言中提到的，约束满足问题求解器通常用于调度。几个人需要参加会议，他们是变量。域包括他们日历上的空闲时间。约束可能涉及会议所需的与会人员组合。
- en: Constraint-satisfaction problem solvers are also used in motion planning. Imagine
    a robot arm that needs to fit inside of a tube. It has constraints (the walls
    of the tube), variables (the joints), and domains (possible movements of the joints).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 约束满足问题求解器也用于运动规划。想象一个需要放入管子内的机器人臂。它有约束（管子的墙壁），变量（关节），以及域（关节的可能运动）。
- en: There are also applications in computational biology. You can imagine constraints
    between molecules required for a chemical reaction. And, of course, as is common
    with AI, there are applications in games. Writing a Sudoku solver is one of the
    following exercises, but many logic puzzles can be solved using constraint-satisfaction
    problem solving.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 计算生物学中也有应用。你可以想象化学反应所需的分子之间的约束。当然，正如人工智能的常见应用一样，在游戏中也有应用。编写一个数独求解器是以下练习之一，但许多逻辑谜题都可以使用约束满足问题解决方法来解决。
- en: 'In this chapter, we built a simple backtracking, depth-first search, problem-solving
    framework. But it can be greatly improved by adding heuristics (remember A*?)--intuitions
    that can aid the search process. A newer technique than backtracking, known as
    constraint propagation, is also an efficient avenue for real-world applications.
    For more information, check out chapter 6 of Stuart Russell and Peter Norvig’s
    Artificial Intelligence: A Modern Approach, third edition (Pearson, 2010).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个简单的回溯、深度优先搜索、问题解决框架。但通过添加启发式方法（还记得A*吗？）——这些可以辅助搜索过程的想法，它可以得到极大的改进。一种比回溯更新的技术，称为约束传播，也是现实应用中有效的方法之一。更多信息，请参阅Stuart
    Russell和Peter Norvig的《人工智能：现代方法》第三版（Pearson，2010年）第6章。
- en: The simple example frameworks we build in this book are not appropriate for
    production environments. If you need to solve a more sophisticated constraint
    problem in Java, you may consider the Choco framework, available at https://choco-solver.org.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本书构建的简单示例框架不适用于生产环境。如果你需要用Java解决更复杂的问题，你可以考虑使用Choco框架，可在https://choco-solver.org找到。
- en: 3.8 Exercises
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8 练习
- en: Revise WordSearchConstraint so that overlapping letters are allowed.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改WordSearchConstraint，以便允许重叠字母。
- en: Build the circuit board layout problem solver described in section 3.6, if you
    have not already.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还没有的话，构建第3.6节中描述的电路板布局问题求解器。
- en: Build a program that can solve Sudoku problems using this chapter’s constraint-satisfaction
    problem-solving framework.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，使用本章的约束满足问题解决框架来解决数独问题。
