- en: 4 Modeling a moving average process
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 建立移动平均过程模型
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Defining a moving average process
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义移动平均过程
- en: Using the ACF to identify the order of a moving average process
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ACF识别移动平均过程的阶数
- en: Forecasting a time series using the moving average model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用移动平均模型预测时间序列
- en: In the previous chapter, you learned how to identify and forecast a random walk
    process. We defined a random walk process as a series whose first difference is
    stationary with no autocorrelation. This means that plotting its ACF will show
    no significant coefficients after lag 0\. However, it is possible that a stationary
    process may still exhibit autocorrelation. In this case, we have a time series
    that can be approximated by a moving average model MA(*q*)), an autoregressive
    model AR(*p*)), or an autoregressive moving average model ARMA(*p*,*q*). In this
    chapter, we will focus on identifying and modeling using the moving average model.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何识别和预测随机游走过程。我们将随机游走过程定义为一种序列，其第一差分是平稳的且无自相关。这意味着在滞后0之后，其自相关函数（ACF）将不会显示任何显著的系数。然而，一个平稳过程仍然可能表现出自相关。在这种情况下，我们有一个可以近似为移动平均模型（MA(*q*)),自回归模型（AR(*p*)),或自回归移动平均模型（ARMA(*p*,*q*))的时间序列。在本章中，我们将重点关注使用移动平均模型进行识别和建模。
- en: Suppose that you want to forecast the volume of widget sales from the XYZ Widget
    Company. By predicting futures sales, the company will be able to better manage
    its production of widgets and avoid producing too many or too few. If not enough
    widgets are produced, the company will not be able to meet their clients’ demands,
    leaving customers unhappy. On the other hand, producing too many widgets will
    increase inventory. The widgets might become obsolete or lose their value, which
    will increase the business’s liabilities, ultimately making shareholders unhappy.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想预测XYZ小部件公司的销售量。通过预测未来销售，公司将能够更好地管理其小部件的生产，避免生产过多或过少。如果生产的小部件不足，公司将无法满足客户的需求，让客户不满意。另一方面，生产过多的小部件将增加库存。小部件可能会过时或失去价值，这将增加企业的负债，最终让股东不满意。
- en: In this example, we will study the sales of widgets over 500 days starting in
    2019\. The recorded sales over time are shown in figure 4.1\. Note that the volume
    of sales is expressed in thousands of US dollars.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将研究从2019年开始的500天内小部件的销售情况。随着时间的推移记录的销售量如图4.1所示。请注意，销售量以千美元的美元为单位表示。
- en: '![](../../OEBPS/Images/04-01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-01.png)'
- en: Figure 4.1 Volume of widget sales for the XYZ Widget Company over 500 days,
    starting on January 1, 2019\. This is fictional data, but it will be useful for
    learning how to identify and model a moving average process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1从2019年1月1日开始，XYZ小部件公司在500天内的销售量。这是虚构数据，但将有助于学习如何识别和建模移动平均过程。
- en: Figure 4.1 shows a long-term trend with peaks and troughs along the way. We
    can intuitively say that this time series is not a stationary process, since we
    can observe a trend over time. Furthermore, there is no apparent cyclical pattern
    in the data, so we can rule out any seasonal effects for now.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1显示了长期趋势，沿途有峰值和谷值。我们可以直观地说，这个时间序列不是一个平稳过程，因为我们可以在时间上观察到趋势。此外，数据中没有任何明显的周期性模式，因此我们现在可以排除任何季节性影响。
- en: In order to forecast the volume of widget sales, we need to identify the underlying
    process. To do so, we will apply the same steps that we covered in chapter 3 when
    working with a random walk process, shown again in figure 4.2.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预测小部件的销售量，我们需要识别潜在的过程。为此，我们将应用我们在第3章中处理随机游走过程时覆盖的相同步骤，如图4.2所示再次展示。
- en: '![](../../OEBPS/Images/04-02.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-02.png)'
- en: Figure 4.2 Steps for identifying a random walk
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2识别随机游走的步骤
- en: Once the data is gathered, we will test for stationarity. If it is not stationary,
    we will apply a transformation to make it stationary. Then, once the series is
    a stationary process, we will plot the autocorrelation function (ACF). In our
    example of forecasting widget sales, our process will show significant coefficients
    in the ACF plot, meaning that it cannot be approximated by the random walk model.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收集到数据，我们将对其进行平稳性检验。如果它不是平稳的，我们将应用转换使其平稳。然后，一旦序列成为平稳过程，我们将绘制自相关函数（ACF）。在我们的预测小部件销售的例子中，我们的过程将在ACF图中显示显著的系数，这意味着它不能被随机游走模型近似。
- en: In this chapter, we will discover that the volume of widget sales from the XYZ
    Widget Company can be approximated as a moving average process, and we will look
    at the definition of the moving average model. Then you’ll learn how to identify
    the order of the moving average process using the ACF plot. The order of this
    process determines the number of parameters for the model. Finally, we will apply
    the moving average model to forecast the next 50 days of widget sales.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将发现 XYZ 小部件公司的产品销量可以近似为移动平均过程，我们将探讨移动平均模型的定义。然后，你将学习如何使用 ACF 图识别移动平均过程的阶数。该过程的阶数决定了模型的参数数量。最后，我们将应用移动平均模型来预测未来
    50 天的产品销量。
- en: 4.1 Defining a moving average process
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 定义移动平均过程
- en: A *moving average process*, or the moving average (MA) model, states that the
    current value is linearly dependent on the current and past error terms. The error
    terms are assumed to be mutually independent and normally distributed, just like
    white noise.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均过程，或称为移动平均（MA）模型，表明当前值是当前和过去误差项的线性组合。误差项被假定为相互独立且服从正态分布，就像白噪声一样。
- en: A moving average model is denoted as MA(*q*), where *q* is the order. The model
    expresses the present value as a linear combination of the mean of the series
    μ, the present error term *ϵ[*t*]*, and past error terms ϵ[*t*–*q*]. The magnitude
    of the impact of past errors on the present value is quantified using a coefficient
    denoted as θ[q]. Mathematically, we express a general moving average process of
    order *q* as in equation 4.1.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均模型表示为 MA(*q*)，其中 *q* 是阶数。模型将当前值表示为序列均值 μ、当前误差项 *ϵ[*t*]* 和过去误差项 ϵ[*t*–*q*]
    的线性组合。过去误差对当前值的影响程度用系数 θ[q] 来量化。数学上，我们用方程 4.1 表达阶数为 *q* 的一般移动平均过程。
- en: '*y[t]* = μ + *ϵ[*t*]* + θ[1]ϵ[*t*–1] + θ[2]ϵ[*t*–2] +⋅⋅⋅+ θ[q]ϵ[*t*–*q*]'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = μ + *ϵ[*t*]* + θ[1]ϵ[*t*–1] + θ[2]ϵ[*t*–2] +⋅⋅⋅+ θ[q]ϵ[*t*–*q*]'
- en: Equation 4.1
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 4.1
- en: Moving average process
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均过程
- en: In a moving average (MA) process, the current value depends linearly on the
    mean of the series, the current error term, and past error terms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动平均（MA）过程中，当前值线性依赖于序列的均值、当前误差项和过去误差项。
- en: The moving average model is denoted as MA(*q*), where *q* is the order. The
    general expression of an MA(*q*) model is
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均模型表示为 MA(*q*)，其中 *q* 是阶数。MA(*q*) 模型的一般表达式为
- en: '*y[t]* = μ + *ϵ[*t*]* + θ[1]ϵ[*t*–1] + θ[2]ϵ[*t*–2] +⋅⋅⋅+ θ[q]ϵ[*t*–*q*]'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = μ + *ϵ[*t*]* + θ[1]ϵ[*t*–1] + θ[2]ϵ[*t*–2] +⋅⋅⋅+ θ[q]ϵ[*t*–*q*]'
- en: The order *q* of the moving average model determines the number of past error
    terms that affect the present value. For example, if it is of order 1, meaning
    that we have an MA(1) process, the model is expressed as in equation 4.2\. Here
    we can see that the present value *y[t]* is dependent on the mean μ, the present
    error term *ϵ[*t*]*, and the error term at the previous timestep θ[1]ϵ[*t*–1].
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均模型的阶数 *q* 决定了影响当前值的过去误差项的数量。例如，如果它是1阶，意味着我们有一个 MA(1) 过程，模型的表达式如方程 4.2 所示。在这里，我们可以看到当前值
    *y[t]* 依赖于均值 μ、当前误差项 *ϵ[*t*]* 和前一个时间步的误差项 θ[1]ϵ[*t*–1]。
- en: '*y[t]* = μ + *ϵ[*t*]* + θ[1]ϵ[*t*–1]'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = μ + *ϵ[*t*]* + θ[1]ϵ[*t*–1]'
- en: Equation 4.2
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 4.2
- en: If we have a moving average process of order 2, or MA(2), then *y[t]* is dependent
    on the mean of the series μ, the present error term *ϵ[*t*]*, the error term at
    the previous timestep θ[1]ϵ[*t*–1], and the error term two timesteps prior θ[2]ϵ[*t*–2],
    resulting in equation 4.3.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个二阶移动平均过程，或 MA(2)，那么 *y[t]* 依赖于序列的均值 μ、当前误差项 *ϵ[*t*]*、前一个时间步的误差项 θ[1]ϵ[*t*–1]
    和两个时间步之前的误差项 θ[2]ϵ[*t*–2]，结果如方程 4.3 所示。
- en: '*y[t]* = μ + *ϵ[*t*]* + θ[1]ϵ[*t*–1] + θ[2]ϵ[*t*–2]'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = μ + *ϵ[*t*]* + θ[1]ϵ[*t*–1] + θ[2]ϵ[*t*–2]'
- en: Equation 4.3
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 4.3
- en: Hence, we can see how the order *q* of the MA(*q*) process affects the number
    of past error terms that must be included in the model. The larger *q* is, the
    more past error terms affect the present value. Therefore, it is important to
    determine the order of the moving average process in order to fit the appropriate
    model—if we have a second-order moving average process, then a second-order moving
    average model will be used for forecasting.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到移动平均过程（MA(*q*））的阶数 *q* 如何影响模型中必须包含的过去误差项的数量。*q* 越大，过去误差项对当前值的影响就越大。因此，确定移动平均过程的阶数对于拟合适当的模型非常重要——如果我们有一个二阶移动平均过程，那么将使用二阶移动平均模型进行预测。
- en: 4.1.1 Identifying the order of a moving average process
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 识别移动平均过程的阶数
- en: To identify the order of a moving average process, we can extend the steps needed
    to identify a random walk, as shown in figure 4.3.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定移动平均过程的阶数，我们可以扩展识别随机游走所需的步骤，如图4.3所示。
- en: '![](../../OEBPS/Images/04-03.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-03.png)'
- en: Figure 4.3 Steps to identify the order of a moving average process
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 确定移动平均过程阶数步骤
- en: As usual, the first step is to gather the data. Then we test for stationarity.
    If our series is not stationary, we apply transformations, such as differencing,
    until the series is stationary. Then we plot the ACF and look for significant
    autocorrelation coefficients. In the case of a random walk, we will not see significant
    coefficients after lag 0\. On the other hand, if we see significant coefficients,
    we must check whether they become abruptly non-significant after some lag *q*.
    If that is the case, then we know that we have a moving average process of order
    *q*. Otherwise, we must follow a different set of steps to discover the underlying
    process of our time series.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，第一步是收集数据。然后我们测试数据的平稳性。如果我们的序列不是平稳的，我们将应用变换，例如差分，直到序列变得平稳。然后我们绘制自相关函数（ACF）并寻找显著的自相关系数。在随机游走的情况下，我们在滞后0之后将不会看到显著的系数。另一方面，如果我们看到显著的系数，我们必须检查它们是否在滞后某个时间点q之后突然变得不显著。如果是这种情况，那么我们知道我们有一个阶数为q的移动平均过程。否则，我们必须遵循不同的步骤来发现时间序列的潜在过程。
- en: Let’s put this in action using our data for the volume of widget sales for the
    XYZ Widget Company. The dataset contains 500 days of sales volume data starting
    on January 1, 2019\. We will follow the steps outlined in figure 4.3 and determine
    the order of the underlying moving average process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用XYZ Widget公司的widget销售额数据来实际操作。数据集包含从2019年1月1日开始的前500天的销售量数据。我们将遵循图4.3中概述的步骤，并确定潜在移动平均过程的阶数。
- en: 'The first step is to gather the data. This step has already been done for you,
    so this is a great time to load the data into a `DataFrame` using `pandas` and
    display the first five rows of data. At any point, you can refer to the source
    code for this chapter on GitHub: [https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH04](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH04).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是收集数据。这一步已经为你完成了，所以这是一个将数据加载到`DataFrame`中并显示前五行数据的好时机。在任何时候，你都可以参考GitHub上本章的源代码：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH04](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH04)。
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Read the CSV file into a DataFrame.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将CSV文件读入DataFrame。
- en: ❷ Display the first five rows of data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示前五行数据。
- en: You’ll see that the volume of sales is in the widget_sales column. Note that
    the volume of sales is in units of thousands of US dollars.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到销售额的量在widget_sales列中。请注意，销售额的量是以千美元为单位的。
- en: We can plot our data using `matplotlib`. Our values of interest are in the widget_
    sales columns, so that is what we pass into `ax.plot()`. Then we give the *x*-axis
    the label of “Time” and *y*-axis the label of “Widget sales (k$).” Next, we specify
    that the labels for the ticks on the *x*-axis should display the month of the
    year. Finally, we tilt the *x*-axis tick labels and remove extra whitespace around
    the figure using `plt.tight_layout()`. The result is figure 4.4.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`matplotlib`来绘制我们的数据。我们感兴趣的值在widget_sales列中，所以我们将其传递给`ax.plot()`。然后我们给*x*轴标记为“时间”和*y*轴标记为“Widget销售（k$）”。接下来，我们指定*x*轴上的刻度标签应显示月份。最后，我们使用`plt.tight_layout()`倾斜*x*轴的刻度标签并移除图周围的额外空白。结果是图4.4。
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Plot the volume of widget sales.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绘制widget销售额的量。
- en: ❷ Label the x-axis.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 标记x轴。
- en: ❸ Label the y-axis.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 标记y轴。
- en: ❹ Label the ticks on the x-axis.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 标记x轴的刻度。
- en: ❺ Tilt the labels on the x-axis ticks so that they display nicely.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 倾斜x轴刻度标签，以便它们显示得更好。
- en: ❻ Remove extra whitespace around the figure.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 移除图周围的额外空白。
- en: '![](../../OEBPS/Images/04-04.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-04.png)'
- en: Figure 4.4 Volume of widget sales for the XYZ Widget Company over 500 days,
    starting on January 1, 2019
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 从2019年1月1日开始，XYZ Widget公司500天内的widget销售额量
- en: The next step is to test for stationarity. We intuitively know that the series
    is not stationary, since there is an observable trend in figure 4.4\. Still, we
    will use the ADF test to make sure. Again, we’ll use the `adfuller` function from
    the `statsmodels` library and extract the ADF statistic and p-value. If the ADF
    statistic is a large negative number and the p-value is smaller than 0.05, our
    series is stationary. Otherwise, we must apply transformations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检验平稳性。我们直观地知道这个序列不是平稳的，因为图4.4中有一个可观察的趋势。尽管如此，我们仍将使用ADF测试来确保。再次，我们将使用`statsmodels`库中的`adfuller`函数，并提取ADF统计量和p值。如果ADF统计量是一个大的负数，且p值小于0.05，则我们的序列是平稳的。否则，我们必须应用变换。
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Run the ADF test on the volume of widget sales, which is stored in the widget_sales
    column.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对存储在`widget_sales`列中的小部件销售量运行ADF测试。
- en: ❷ Print the ADF statistic.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印ADF统计量。
- en: ❸ Print the p-value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 打印p值。
- en: This results in an ADF statistic of –1.51 and a p-value of 0.53\. Here, the
    ADF statistic is not a large negative number, and the p-value is greater than
    0.05\. Therefore, our time series is not stationary, and we must apply transformations
    to make it stationary.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致ADF统计量为-1.51，p值为0.53。在这里，ADF统计量不是一个大的负数，p值大于0.05。因此，我们的时间序列不是平稳的，我们必须应用变换使其平稳。
- en: In order to make our series stationary, we will try to stabilize the trend by
    applying a first-order differencing. We can do so by using the `diff` method from
    the `numpy` library. Remember that this method takes in a parameter `n` that specifies
    the order of differencing. In this case, because it is a first-order differencing,
    `n` will be equal to 1.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的序列平稳，我们将尝试通过应用一阶差分来稳定趋势。我们可以通过使用`numpy`库中的`diff`方法来实现。记住，此方法接受一个参数`n`，它指定了差分的阶数。在这种情况下，因为它是一阶差分，所以`n`将等于1。
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Apply first-order differencing on our data and store the result in widget_sales_diff.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在我们的数据上应用一阶差分，并将结果存储在`widget_sales_diff`中。
- en: We can optionally plot the differenced series to see if we have stabilized the
    trend. Figure 4.5 shows the differenced series. We can see that we successfully
    removed the long-term trend component of our series, as values are hovering around
    0 over the entire period.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以可选地绘制差分序列，以查看我们是否已经稳定了趋势。图4.5显示了差分序列。我们可以看到，我们成功地移除了序列中的长期趋势成分，因为值在整个样本期间都围绕着0。
- en: '![](../../OEBPS/Images/04-05.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-05.png)'
- en: Figure 4.5 Differenced volume of widget sales. The trend component has been
    stabilized, since values are hovering around 0 over our entire sample.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 小部件销售量的差分。由于值在整个样本期间都围绕着0，因此趋势成分已被稳定。
- en: Can you recreate figure 4.5?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你能重新创建图4.5吗？
- en: While optional, it is a good idea to plot your series as you apply transformations.
    This will give you a better intuition as to whether a series is stationary or
    not after a particular transformation. Try recreating figure 4.5 on your own.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然是可选的，但在应用变换时绘制你的序列是一个好主意。这将帮助你更好地理解在特定变换后序列是否平稳。尝试自己重新创建图4.5。
- en: Now that a transformation has been applied to our series, we can test for stationarity
    again using the ADF test. This time, make sure to run the test on the differenced
    data stored in the `widget_sales_diff` variable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对我们的序列应用了变换，我们可以再次使用ADF测试来检验平稳性。这次，确保在存储在`widget_sales_diff`变量中的差分数据上运行测试。
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Run the ADF test on the differenced time series.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对差分时间序列运行ADF测试。
- en: This gives an ADF statistic of –10.6 and a p-value of 7 × 10^(–19). Therefore,
    with a large negative ADF statistic and a p-value much smaller than 0.05, we can
    say that our series is stationary.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了ADF统计量为-10.6和p值为7 × 10^(–19)。因此，由于有一个大的负ADF统计量和远小于0.05的p值，我们可以断定我们的序列是平稳的。
- en: Our next step is to plot the autocorrelation function. The `statsmodels` library
    conveniently includes the `plot_acf` function. We simply pass in our differenced
    series and specify the number of lags in the `lags` parameter. Remember that the
    number of lags determines the range of values on the *x*-axis.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是绘制自相关函数。`statsmodels`库方便地包含了`plot_acf`函数。我们只需传入我们的差分序列，并在`lags`参数中指定滞后数。记住，滞后数决定了*x*轴上的值域。
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Plot the ACF of the differenced series.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绘制差分序列的ACF。
- en: The resulting ACF plot is shown in figure 4.6\. You’ll notice that there are
    significant coefficients up until lag 2\. Then they abruptly become non-significant,
    as they remain in the shaded area of the plot. This means that we have a stationary
    moving average process of order 2\. We can use a second-order moving average model,
    or MA(2) model, to forecast our stationary time series.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的 ACF 图如图 4.6 所示。您会注意到，直到滞后 2，系数是显著的。然后它们突然变得不显著，因为它们保持在图表的阴影区域内。这意味着我们有一个二阶平稳移动平均过程。我们可以使用二阶移动平均模型，或
    MA(2) 模型，来预测我们的平稳时间序列。
- en: '![](../../OEBPS/Images/04-06.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/04-06.png)'
- en: Figure 4.6 ACF plot of the differenced series. Notice how the coefficients are
    significant up until lag 2, and then they fall abruptly into the non-significance
    zone (shaded area) of the plot. There are some significant coefficients around
    lag 20, but this is likely due to chance, since they are non-significant between
    lags 3 and 20 and after lag 20.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 差分序列的 ACF 图。注意系数直到滞后 2 都是显著的，然后它们突然落入图表的非显著性区域（阴影区域）。在滞后 20 附近有一些显著的系数，但这很可能是由于偶然，因为它们在滞后
    3 到 20 之间以及滞后 20 之后都是不显著的。
- en: You can see how the ACF plot helps us determine the order of a moving average
    process. The ACF plot will show significant autocorrelation coefficients up until
    lag *q*, after which all coefficients will be non-significant. We can then conclude
    that we have a moving average process of order *q*, or an MA(*q*) process.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到 ACF 图如何帮助我们确定移动平均过程的阶数。ACF 图将显示直到滞后 *q* 的显著自相关系数，之后所有系数都将变得不显著。因此，我们可以得出结论，我们有一个阶数为
    *q* 的移动平均过程，或 MA(*q*) 过程。
- en: 4.2 Forecasting a moving average process
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 预测移动平均过程
- en: Once the order *q*of the moving average process is identified, we can fit the
    model to our training data and start forecasting. In our case, we discovered that
    the differenced volume of widget sales is a moving average process of order 2,
    or an MA(2) process.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了移动平均过程的阶数 *q*，我们就可以将模型拟合到我们的训练数据上并开始预测。在我们的案例中，我们发现销售量的差分是一个二阶移动平均过程，或
    MA(2) 过程。
- en: The moving average model assumes stationarity, meaning that our forecasts must
    be done on a stationary time series. Therefore, we will train and test our model
    on the differenced volume of widget sales. We will try two naive forecasting techniques
    and fit a second-order moving average model. The naive forecasts will serve as
    baselines to evaluate the performance of the moving average model, which we expect
    to be better than the baselines, since we previously identified our process to
    be a moving average process of order 2\. Once we obtain our forecasts for the
    stationary process, we will have to inverse-transform the forecasts, meaning that
    we must undo the process of differencing to bring the forecasts back to their
    original scale.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均模型假设平稳性，这意味着我们的预测必须在平稳时间序列上进行。因此，我们将训练和测试我们的模型在差分后的销售量数据上。我们将尝试两种简单的预测技术并拟合一个二阶移动平均模型。简单的预测将作为基准来评估移动平均模型的表现，我们预计它将优于基准，因为我们之前确定我们的过程是一个二阶移动平均过程。一旦我们获得了对平稳过程的预测，我们就必须对预测进行逆变换，这意味着我们必须撤销差分过程，将预测值恢复到原始尺度。
- en: In this scenario, we will allocate 90% of the data to the train set and reserve
    the other 10% for the test set, meaning that we must forecast 50 timesteps into
    the future. We will assign our differenced data to a `DataFrame` and then split
    the data.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将 90% 的数据分配给训练集，并保留其余 10% 作为测试集，这意味着我们必须预测未来的 50 个时间步。我们将差分数据分配给一个
    `DataFrame`，然后分割数据。
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Place the differenced data in a DataFrame.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将差分数据放入 DataFrame 中。
- en: ❷ The first 90% of the data goes in the training set.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 前 90% 的数据进入训练集。
- en: ❸ The last 10% of the data goes in the test set for prediction.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 最后 10% 的数据进入测试集进行预测。
- en: We’ve printed out the size of the train and test sets to remind you of the data
    point that we lose when we difference. The original dataset contained 500 data
    points, while the differenced series contains a total of 499 data points, since
    we differenced once.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已打印出训练集和测试集的大小，以提醒您我们在差分时丢失的数据点。原始数据集包含 500 个数据点，而差分序列包含总共 499 个数据点，因为我们进行了一次差分。
- en: Now we can visualize the forecasting period for the differenced and original
    series. Here we will make two subplots in the same figure. The result is shown
    in figure 4.7.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以可视化差分和原始序列的预测期。在这里，我们将在同一张图中制作两个子图。结果如图 4.7 所示。
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Make two subplots inside the same figure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶在同一张图内创建两个子图。
- en: '![](../../OEBPS/Images/04-07.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-07.png)'
- en: Figure 4.7 Forecasting period for the original and differenced series. Remember
    that our differenced series has one less data point than in its original state.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 原始序列和差分序列的预测期。请记住，我们的差分序列比原始状态少一个数据点。
- en: For the forecast horizon, the moving average model brings in a particularity.
    The MA(*q*) model does not allow us to forecast 50 steps into the future in one
    shot. Remember that the moving average model is linearly dependent on past error
    terms, and those terms are not observed in the dataset—they must therefore be
    recursively estimated. This means that for an MA(*q*) model, we can only forecast
    *q* steps into the future. Any prediction made beyond that point will not have
    past error terms, and the model will only predict the mean. Therefore, there is
    no added value in forecasting beyond *q* steps into the future, because the predictions
    will fall flat, as only the mean is returned, which is equivalent to a baseline
    model.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于预测范围，移动平均模型带来一个特殊性。MA(*q*)模型不允许我们一次性预测50步的未来。记住，移动平均模型是线性依赖于过去误差项的，而这些项在数据集中没有观察到——因此必须递归估计。这意味着对于MA(*q*)模型，我们只能预测*q*步的未来。任何超出这个点的预测将没有过去的误差项，模型将只预测平均值。因此，预测超过*q*步的未来没有增加价值，因为预测将变得平淡，因为只返回平均值，这相当于基线模型。
- en: To avoid simply predicting the mean beyond two timesteps into the future, we
    need to develop a function that will predict two timesteps or less at a time,
    until 50 predictions are made, so that we can compare our predictions against
    the observed values of the test set. This method is called *rolling forecasts*.
    On the first pass, we will train on the first 449 timesteps and predict timesteps
    450 and 451\. Then, on the second pass, we will train on the first 451 timesteps,
    and predict timesteps 452 and 453\. This is repeated until we finally predict
    the values at timesteps 498 and 499.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免简单地预测两个时间步之后的平均值，我们需要开发一个函数，该函数将一次预测两个时间步或更少，直到做出50个预测，这样我们就可以将我们的预测与测试集的观察值进行比较。这种方法称为*滚动预测*。在第一次遍历中，我们将训练前449个时间步，并预测时间步450和451。然后，在第二次遍历中，我们将训练前451个时间步，并预测时间步452和453。这样重复，直到我们最终预测时间步498和499的值。
- en: Forecasting using the MA(*q*) model
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MA(*q*)模型进行预测
- en: When using an MA(*q*) model, forecasting beyond *q* steps into the future will
    simply return the mean, because there are no error terms to estimate beyond *q*
    steps. We can use rolling forecasts to predict up to *q* steps at a time in order
    avoid predicting only the mean of the series.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用MA(*q*)模型时，预测超过*q*步的未来将简单地返回平均值，因为没有误差项可以估计超过*q*步。我们可以使用滚动预测来一次预测多达*q*步，以避免只预测序列的平均值。
- en: 'We will compare our fitted MA(2) model to two baselines: the historical mean
    and the last value. That way, we can make sure that an MA(2) model will yield
    better predictions than naive forecasts, which should be the case, since we know
    the stationary process is an MA(2) process.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将比较我们拟合的MA(2)模型与两个基线：历史平均值和最后一个值。这样，我们可以确保MA(2)模型将产生比朴素预测更好的预测，这是应该的，因为我们知道平稳过程是一个MA(2)过程。
- en: Note You do not have to forecast twosteps ahead when you perform rolling forecasts
    with an MA(2) model. You can forecast either one or two steps ahead repeatedly
    in order to avoid predicting only the mean. Similarly, with an MA(3) model, you
    could perform rolling forecasts with one-, two-, or three-step-ahead rolling forecasts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在使用MA(2)模型进行滚动预测时，您不需要预测两个时间步。您可以反复预测一个或两个时间步，以避免只预测平均值。同样，使用MA(3)模型，您可以进行一个、两个或三个时间步的滚动预测。
- en: To create these forecasts, we need a function that will repeatedly fit a model
    and generate forecasts over a certain window of time, until forecasts for the
    entire test set are obtained. This function is shown in listing 4.1.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这些预测，我们需要一个函数，该函数将反复拟合模型并在一定时间窗口内生成预测，直到获得整个测试集的预测。此函数在列表4.1中显示。
- en: 'First, we import the `SARIMAX` function from the `statsmodels` library. This
    function will allow us to fit an MA(2) model to our differenced series. Note that
    SARIMAX is a complex model that allows us to consider seasonal effects, autoregressive
    processes, non-stationary time series, moving average processes, and exogenous
    variables all in a single model. For now, we will disregard all factors except
    the moving average portion. We will gradually build on the moving average model
    and eventually reach the SARIMAX model in later chapters:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从 `statsmodels` 库中导入 `SARIMAX` 函数。这个函数将允许我们将 MA(2) 模型拟合到我们的差分序列中。请注意，SARIMAX
    是一个复杂的模型，它允许我们在单个模型中考虑季节效应、自回归过程、非平稳时间序列、移动平均过程和外生变量。现在，我们将不考虑所有因素，除了移动平均部分。我们将逐步构建移动平均模型，并在后面的章节中最终达到
    SARIMAX 模型：
- en: Next, we define our `rolling_forecast` function. It will take in a `DataFrame`,
    the length of the training set, the forecast horizon, a window size, and a method.
    The `DataFrame` contains the entire time series.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的 `rolling_forecast` 函数。它将接收一个 `DataFrame`、训练集的长度、预测范围、窗口大小和方法。`DataFrame`
    包含整个时间序列。
- en: The `train_len` parameter initializes the number of data points that can be
    used to fit a model. As predictions are done, we can update this to simulate the
    observation of new values and then use them to make the next sequence of forecasts.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`train_len` 参数初始化可以用于拟合模型的观测数据点的数量。随着预测的进行，我们可以更新这个值来模拟观察新值，然后使用它们来做出下一个预测序列。'
- en: The `horizon` parameter is equal to the length of the test set and represents
    how many values must be predicted.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`horizon` 参数等于测试集的长度，表示必须预测多少个值。'
- en: The `window` parameter specifies how many timesteps are predicted at a time.
    In our case, because we have an MA(2) process, the window will be equal to 2.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window` 参数指定了一次预测多少个时间步长。在我们的案例中，因为我们有一个 MA(2) 过程，所以窗口将等于 2。'
- en: The `method` parameter specifies what model to use. The same function allows
    us to generate forecasts from the naive methods and the MA(2) model.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method` 参数指定了要使用哪种模型。同一个函数允许我们从朴素方法和 MA(2) 模型生成预测。'
- en: Note the use of type hinting in the function declaration. This will help us
    avoid passing parameters of an unexpected type, which might cause our function
    to fail.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数声明中使用了类型提示。这有助于我们避免传递意外类型的参数，这可能会导致我们的函数失败。
- en: Then, each forecasting method is run in a loop. The loop starts at the end of
    the training set and continues until `total_len`, exclusive, with steps of `window`
    (`total_len` is the sum of `train_len` and `horizon`). This loop generates a list
    of 25 values, [450,451,452,...,497], but each pass generates two forecasts, thus
    returning a list of 50 forecasts for the entire test set.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个预测方法都在循环中运行。循环从训练集的末尾开始，一直持续到 `total_len`（不包括 `total_len`），步长为 `window`（`total_len`
    是 `train_len` 和 `horizon` 的总和）。这个循环生成一个包含 25 个值的列表，[450,451,452,...,497]，但每次通过都会生成两个预测，因此返回一个包含整个测试集的
    50 个预测的列表。
- en: Listing 4.1 A function for rolling forecasts on a horizon
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 在一个预测范围内进行滚动预测的函数
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ The function takes in a DataFrame containing the full simulated moving average
    process. We also pass in the length of the training set (800 in this case) and
    the horizon of the forecast (200). The next parameter specifies how many steps
    at a time we wish to forecast (2). Finally, we specify the method to use to make
    forecasts.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 该函数接收一个包含完整模拟移动平均过程的 DataFrame。我们还将训练集的长度（在本例中为 800）和预测范围（200）传递进去。下一个参数指定了我们希望一次预测多少步（2）。最后，我们指定用于进行预测的方法。
- en: ❷ The MA(q) model is part of the more complex SARIMAX model.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ MA(q) 模型是更复杂的 SARIMAX 模型的组成部分。
- en: ❸ The predicted_mean method allows us to retrieve the actual value of the forecast
    as defined by the statsmodels library.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `predicted_mean` 方法允许我们检索由 statsmodels 库定义的预测的实际值。
- en: 'Once it’s defined, we can use our function and forecast using three methods:
    the historical mean, the last value, and the fitted MA(2) model.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了它，我们就可以使用我们的函数并使用三种方法进行预测：历史平均值、最后一个值和拟合的 MA(2) 模型。
- en: First, we’ll first create a `DataFrame` to hold our predictions and name it
    `pred_df`. We can copy the test set, to include the actual values in `pred_df`,
    making it easier to evaluate the performance of our models.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个 `DataFrame` 来保存我们的预测，并将其命名为 `pred_df`。我们可以复制测试集，包括实际值在 `pred_df`
    中，这样更容易评估我们模型的表现。
- en: Then, we’ll specify some constants. In Python, it is a good practice to name
    constants in capital letters. `TRAIN_LEN` is simply the length of our training
    set, `HORIZON` is the length of the test set, which is 50 days, and `WINDOW` can
    be 1 or 2 because we are using an MA(2) model. In this case we will use a value
    of 2.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将指定一些常量。在Python中，将常量命名为大写字母是一种好习惯。`TRAIN_LEN`是训练集的长度，`HORIZON`是测试集的长度，这里是50天，`WINDOW`可以是1或2，因为我们使用的是MA(2)模型。在这种情况下，我们将使用2的值。
- en: Next, we’ll use our `rolling_forecast` function to generate a list of predictions
    for each method. Each list of predictions is then stored in its own column in
    `pred_df`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用我们的`rolling_forecast`函数为每种方法生成一系列预测。然后，每个预测列表将存储在`pred_df`的单独列中。
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now we can visualize our predictions against the observed values in the test
    set. Keep in mind that we are still working with the differenced dataset, so our
    predictions are also differenced values.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的预测与测试集中的观测值进行可视化。记住，我们仍在处理差分数据集，因此我们的预测也是差分值。
- en: For this figure, we will plot part of the training data to see the transition
    between the train and test sets. Our observed values will be a solid line, and
    we will label this curve as “actual.” Then we’ll plot the forecasts from the historical
    mean, those from the last observed value, and those from the MA(2) model. They
    will respectively be a dotted line, a dotted and dashed line, and a dashed line,
    with labels of “mean,” “last,” and “MA(2).” The result is shown in figure 4.8.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个图，我们将绘制部分训练数据以查看训练集和测试集之间的过渡。我们的观测值将是一条实线，我们将这条曲线标记为“实际”。然后我们将绘制来自历史平均值、最后观测值和MA(2)模型的预测。它们将分别是一条虚线、一条虚线和虚线，标记为“均值”、“最后”和“MA(2)”。结果如图4.8所示。
- en: '![](../../OEBPS/Images/04-08.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-08.png)'
- en: Figure 4.8 Forecasts of the differenced volume of widget sales. In a professional
    setting, it does not make sense to report differenced predictions. Therefore,
    we will undo the transformation later on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8展示了小部件销售差分量的预测。在专业环境中，报告差分预测是没有意义的。因此，我们将在稍后撤销这种转换。
- en: In figure 4.8 you’ll notice that the prediction coming from the historical mean,
    shown as a dotted line, is almost a straight line. This is expected; the process
    is stationary, so the historical mean should be stable over time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在图4.8中，你会注意到来自历史平均值的预测，以虚线表示，几乎是一条直线。这是预期的；过程是平稳的，因此历史平均值应该随时间保持稳定。
- en: The next step is to measure the performance of our models. To do so, we will
    calculate the mean squared error (MSE). Here we will use the `mean_squared_error`
    function from the `sklearn` package. We simply need to pass the observed values
    and the predicted values into the function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是衡量我们模型的性能。为了做到这一点，我们将计算均方误差（MSE）。在这里，我们将使用来自`sklearn`包的`mean_squared_error`函数。我们只需将观测值和预测值传递给该函数即可。
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This prints out an MSE of 2.56 for the historical mean method, 3.25 for the
    last value method, and 1.95 for the MA(2) model. Here our MA(2) model is the best-performing
    forecasting method, since its MSE is the lowest of the three methods. This is
    expected, because we previously identified a second-order moving average process
    for the differenced volume of widget sales, thus resulting in a smaller MSE compared
    to the naive forecasting methods. We can visualize the MSE for all forecasting
    techniques in figure 4.9.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这输出了历史平均值方法的均方误差为2.56，最后值方法的均方误差为3.25，MA(2)模型的均方误差为1.95。在这里，我们的MA(2)模型是表现最好的预测方法，因为它的均方误差是三种方法中最低的。这是预期的，因为我们之前已经识别出小部件销售差分量的二阶移动平均过程，因此与简单的预测方法相比，均方误差更小。我们可以在图4.9中可视化所有预测技术的均方误差。
- en: '![](../../OEBPS/Images/04-09.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-09.png)'
- en: Figure 4.9 MSE for each forecasting method on the differenced volume of widget
    sales. Here the MA(2) model is the champion, since its MSE is the lowest.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9展示了每种预测方法在小部件销售差分量上的均方误差。在这里，MA(2)模型是冠军，因为它的均方误差最低。
- en: Now that we have our champion model on the stationary series, we need to inverse-transform
    our predictions to bring them back to the original scale of the untransformed
    dataset. Recall that differencing is the result of the difference between a value
    at time *t* and its previous value, as shown in figure 4.10.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了在平稳序列上的冠军模型，我们需要将我们的预测逆变换，以便将它们恢复到未转换数据集的原始尺度。回想一下，差分是时间*t*处的值与其前一个值之间的差，如图4.10所示。
- en: '![](../../OEBPS/Images/04-10.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-10.png)'
- en: Figure 4.10 Visualizing a first-order difference
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 可视化一阶差分
- en: 'In order to reverse our first-order difference, we need to add an initial value
    *y*[0] to the first differenced value *y''*[1]. That way, we can recover *y*[1]
    in its original scale. This is what is demonstrated in equation 4.4:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反转我们的第一阶差分，我们需要将初始值*y*[0]加到第一个差分值*y'*[1]上。这样，我们就可以在原始尺度上恢复*y*[1]。这正是方程式4.4所展示的：
- en: '*y*[1] = *y*[0] + *y''*[1] = *y*[0] + *y*[1]– *y*[0] = *y*[1]'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[1] = *y*[0] + *y''*[1] = *y*[0] + *y*[1]– *y*[0] = *y*[1]'
- en: Equation 4.4
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式4.4
- en: Then *y*[2] can be obtained using a cumulative sum of the differenced values,
    as shown in equation 4.5.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用差分值的累积和来获得*y*[2]，如方程式4.5所示。
- en: '*y*[2] = *y*[0] + *y''*[1] + *y''*[2] = *y*[0] + *y*[1]– *y*[0] + *y*[2]– *y*[1]
    = (*y*[0]– *y*[0]) + (*y*[1]– *y*[1]) + *y*[2] = *y*[2]'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[2] = *y*[0] + *y''*[1] + *y''*[2] = *y*[0] + *y*[1]– *y*[0] + *y*[2]– *y*[1]
    = (*y*[0]– *y*[0]) + (*y*[1]– *y*[1]) + *y*[2] = *y*[2]'
- en: Equation 4.5
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式4.5
- en: Applying the cumulative sum once will undo a first-order differencing. In the
    case where the series was differenced twice to become stationary, we would need
    to repeat this process.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 应用一次累积和可以取消一阶差分。在序列经过两次差分以成为平稳的情况下，我们需要重复此过程。
- en: Thus, to obtain our predictions in the original scale of our dataset, we need
    to use the first value of the test as our initial value. Then we can perform a
    cumulative sum to obtain a series of 50 predictions in the original scale of the
    dataset. We will assign these predictions to the pred_widget_sales column.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了获得数据集原始尺度上的预测，我们需要使用测试的第一值作为我们的初始值。然后我们可以执行累积和以获得一系列50个原始尺度上的预测。我们将这些预测分配给pred_widget_sales列。
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Initialize an empty column to hold our predictions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始化一个空列来存储我们的预测。
- en: ❷ Inverse-transform the predictions to bring them back to the original scale
    of the dataset.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将预测值反变换回数据集的原始尺度。
- en: Let’s visualize our untransformed predictions against the recorded data. Remember
    that we are now using the original dataset stored in `df`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们可视化我们的未变换预测与记录的数据。记住，我们现在使用存储在`df`中的原始数据集。
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Plot the actual values.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绘制实际值。
- en: ❷ Plot the inverse-transformed predictions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 绘制反变换后的预测。
- en: You can see in figure 4.11 that our forecast curve, shown with a dashed line,
    follows the general trend of the observed values, although it does not predict
    bigger troughs and peaks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图4.11中看到，我们的预测曲线（用虚线表示）遵循观察值的总体趋势，尽管它没有预测更大的谷值和峰值。
- en: '![](../../OEBPS/Images/04-11.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-11.png)'
- en: Figure 4.11 Inverse-transformed MA(2) forecasts
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 反变换后的MA(2)预测
- en: The final step is to report the MSE on the original dataset. In a professional
    setting, we would not report the differenced predictions, because they do not
    make sense from a business perspective; we must report values and errors in the
    original scale of the data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在原始数据集上报告MSE。在专业环境中，我们不会报告差分预测，因为从业务角度来看它们没有意义；我们必须报告原始数据尺度上的值和误差。
- en: We can measure the mean absolute error (MAE) using the `mean_absolute_error`
    function from `sklearn`. We’ll use this metric because it is easy to interpret,
    as it returns the average of the absolute difference between the predicted and
    actual values, instead of a squared difference like the MSE.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`sklearn`中的`mean_absolute_error`函数来衡量平均绝对误差（MAE）。我们将使用这个指标，因为它易于解释，因为它返回预测值和实际值之间绝对差的平均值，而不是像MSE那样的平方差。
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This prints out an MAE of 2.32\. Therefore, our predictions are, on average,
    off by $2,320, either above or below the actual value. Remember that our data
    has units of thousands of dollars, so we multiply the MAE by 1,000 to express
    the average absolute difference.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出2.32的MAE。因此，我们的预测平均来说，偏离实际值2,320美元，要么高于实际值，要么低于实际值。记住，我们的数据单位是千美元，所以我们将MAE乘以1,000以表示平均绝对差。
- en: 4.3 Next steps
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 下一步
- en: In this chapter, we covered the moving average process and how it can be modeled
    by an MA(*q*) model, where *q* is the order. You learned that to identify a moving
    average process, you must study the ACF plot once it is stationary. The ACF plot
    will show significant peaks all the way to lag *q*, and the rest will not be significantly
    different from 0.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了移动平均过程以及如何通过MA(*q*)模型对其进行建模，其中*q*是阶数。你了解到，为了识别移动平均过程，你必须研究它在平稳后的ACF图。ACF图将显示到滞后*q*的所有显著峰值，其余的将不会与0有显著差异。
- en: However, it is possible that when studying the ACF plot of a stationary process,
    you’ll see a sinusoidal pattern, with negative coefficients and significant autocorrelation
    at large lags. For now you can simply accept that this is not a moving average
    process (see figure 4.12).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在研究平稳过程的ACF图时，你可能会看到正弦波模式，具有负系数和在大滞后处的显著自相关。现在你可以简单地接受这不是移动平均过程（见图4.12）。
- en: '![](../../OEBPS/Images/04-12.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-12.png)'
- en: Figure 4.12 Steps to identify the underlying process of a stationary time series
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 识别平稳时间序列潜在过程的步骤
- en: When we see a sinusoidal pattern in the ACF plot of a stationary process, this
    is a hint that an autoregressive process is at play, and we must use an AR(*p*)
    model to produce our forecast. Just like the MA(*q*) model, the AR(*p*) model
    will require us to identify its order. This time we will have to plot the *partial*
    autocorrelation function and see at which lag the coefficients suddenly become
    non-significant. The next chapter will focus entirely on the autoregressive process,
    how to identify its order, and how to forecast such a process.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在平稳过程的ACF图中看到正弦波模式时，这是一个提示表明存在自回归过程，我们必须使用AR(*p*)模型来生成预测。就像MA(*q*)模型一样，AR(*p*)模型将需要我们识别其阶数。这次我们将不得不绘制*偏自相关函数*，看看在哪个滞后系数突然变得不显著。下一章将完全专注于自回归过程，如何识别其阶数以及如何预测这样的过程。
- en: 4.4 Exercises
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 练习
- en: 'Take some time to test your knowledge and mastery of the MA(*q*) model with
    these exercises. The full solutions are available on GitHub: [https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH04](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH04).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 用这些练习检验一下你对MA(*q*)模型的知识和掌握程度。完整的解决方案可在GitHub上找到：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH04](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH04)。
- en: 4.4.1 Simulate an MA(2) process and make forecasts
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 模拟MA(2)过程并进行预测
- en: 'Simulate a stationary MA(2) process. To do so, use the `ArmaProcess` function
    from the `statsmodels` library and simulate the following process:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟一个平稳的MA(2)过程。为此，使用`statsmodels`库中的`ArmaProcess`函数模拟以下过程：
- en: '*y[t]* = 0.9*θ*[*t*–1] + 0.3*θ*[*t*–2]'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[t]* = 0.9*θ*[*t*–1] + 0.3*θ*[*t*–2]'
- en: For this exercise, generate 1,000 samples.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个练习，生成1,000个样本。
- en: '[PRE14]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Set the seed for reproducibility. Change the seed if you want to experiment
    with different values.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❶ 设置随机种子以确保可重复性。如果你想尝试不同的值，可以更改种子。
- en: Plot your simulated moving average.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制你的模拟移动平均图。
- en: Run the ADF test, and check if the process is stationary.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行ADF测试，检查过程是否平稳。
- en: Plot the ACF, and see if there are significant coefficients after lag 2.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制自相关函数（ACF），看看在滞后2之后是否有显著的系数。
- en: Separate your simulated series into train and test sets. Take the first 800
    timesteps for the train set, and assign the rest to the test set.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的模拟序列分为训练集和测试集。将前800个时间步长用于训练集，其余的分配给测试集。
- en: Make forecasts over the test set. Use the mean, last value, and an MA(2) model.
    Make sure you repeatedly forecast 2 timesteps at a time using the `recursive_
    forecast` function we defined.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试集上进行预测。使用均值、最后一个值和MA(2)模型。确保你使用我们定义的`recursive_forecast`函数反复预测2个时间步长。
- en: Plot your forecasts.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制你的预测图。
- en: Measure the MSE, and identify your champion model.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量均方误差（MSE），并确定你的冠军模型。
- en: Plot your MSEs in a bar plot.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在条形图中绘制你的MSE。
- en: 4.4.2 Simulate an MA(q) process and make forecasts
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 模拟MA(q)过程并进行预测
- en: Recreate the previous exercise, but simulate a moving average process of your
    choice. Try simulating a third-order or fourth-order moving average process. I
    recommend generating 10,000 samples. Be especially attentive to the ACF, and see
    if your coefficients become non-significant after lag *q*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 重新创建之前的练习，但模拟一个你选择的移动平均过程。尝试模拟三阶或四阶移动平均过程。我建议生成10,000个样本。特别关注ACF，看看你的系数在滞后 *q*
    之后是否变得不显著。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A moving average process states that the present value is linearly dependent
    on the mean, present error term, and past error terms. The error terms are normally
    distributed.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动平均过程表明，当前值线性依赖于均值、当前误差项和过去的误差项。误差项是正态分布的。
- en: You can identify the order *q* of a stationary moving average process by studying
    the ACF plot. The coefficients are significant up until lag *q* only.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过研究ACF图来识别平稳移动平均过程的阶数 *q*。系数仅在滞后 *q* 时显著。
- en: You can predict up to *q* steps into the future because the error terms are
    not observed in the data and must be recursively estimated.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以预测未来最多 *q* 步，因为误差项在数据中未被观察到，必须递归地估计。
- en: Predicting beyond *q* steps into the future will simply return the mean of the
    series. To avoid that, you can apply rolling forecasts.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测超过 *q* 步的未来将简单地返回序列的平均值。为了避免这种情况，你可以应用滚动预测。
- en: If you apply a transformation to the data, you must undo it to bring your predictions
    back to the original scale of the data.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将数据应用了转换，你必须撤销这个转换，以便将你的预测回到数据的原始尺度。
- en: The moving average model assumes the data is stationary. Therefore, you can
    only use this model on stationary data.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动平均模型假设数据是平稳的。因此，你只能在这个模型上使用平稳数据。
