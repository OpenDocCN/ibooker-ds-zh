- en: 10 Advanced React hooks for scaling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 高级 React 钩子用于扩展
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Structuring data flow with React Context
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Context 结构化数据流
- en: Managing complex state with reducers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 reducer 管理复杂状态
- en: Creating custom hooks for code reuse
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义钩子以实现代码复用
- en: So far, you’ve learned all you need to know to build small, simple React applications
    by yourself. You have all the knowledge and tools required to create stateful,
    interactive, and relevant React widgets with a few interconnected components—but
    only as long as you’re working on fairly small projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学到了自己构建小型、简单 React 应用程序所需的所有知识。你拥有创建具有状态、交互性和相关性的 React 小部件所需的所有知识和工具，只要你在处理相当小的项目。
- en: In the real world, your React applications will most likely be a lot bigger
    and more complex than any of the examples we’ve examined thus far. You could create
    small widgets (e.g., a BMI calculator) for a website that have just a couple of
    components and still do a good job, but those are few and far between and mostly
    relevant to the hobby developer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，你的 React 应用程序可能比我们迄今为止所检查的任何示例都要大得多、复杂得多。你可以为网站创建一些小部件（例如，BMI 计算器），它们只有几个组件，但仍能做得很好，但这些例子很少，并且主要与业余开发者相关。
- en: As a professional React engineer, you’ll more likely either be developing a
    larger application on your own or an even larger application as part of a team.
    As applications grow larger, component interfaces grow more complex, and working
    on the codebase requires more finesse.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名专业的 React 工程师，你更有可能要么独立开发一个较大的应用程序，要么作为团队的一部分开发一个更大的应用程序。随着应用程序的增大，组件接口变得更加复杂，对代码库的工作需要更多的技巧。
- en: 'A couple of things might start to become a problem if you develop your applications
    without structure or procedure:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有结构或程序地开发应用程序，以下几件事情可能会开始成为问题：
- en: Complex data flow can lead to an abundance of properties on all the components
    to transfer all the data required.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复杂的数据流可能导致所有组件上都有大量属性，以传输所需的所有数据。
- en: Intricate state flows can result in invalid states if attention is not paid
    carefully to synchronization of related state values.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有仔细注意相关状态值的同步，复杂的状态流可能导致无效的状态。
- en: Duplicated code can sometimes be hard to generalize if you only try to generalize
    whole components and not also parts of components.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你只尝试概括整个组件而不是组件的部分，重复的代码有时很难进行概括。
- en: All of these problems will arise regardless of whether you’re working on your
    own or in a larger team. These are scaling problems. What works at a small scale,
    doesn’t necessarily work at a large scale.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是独自工作还是在更大的团队中，所有这些问题都会出现。这些都是扩展问题。在小规模上有效的东西，不一定在大规模上有效。
- en: We saw similar scaling problems when we created more complex forms in chapter
    9\. When you have just 1 or 2 inputs, using a state value for each is fine. But
    if you have 5 or 10 inputs, having a separate state value for each is a nuisance
    and, frankly, bad software design. When concepts are applied to larger items,
    they are often tweaked to allow for better scaling.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第 9 章中创建更复杂的形式时，我们看到了类似的扩展问题。当你只有 1 或 2 个输入时，为每个输入使用状态值是可以的。但是，如果你有 5 或
    10 个输入，为每个输入拥有单独的状态值会变得麻烦，坦白说，这是糟糕的软件设计。当概念应用于更大的项目时，它们通常会被调整以允许更好的扩展。
- en: In this chapter, we’ll discuss tools that can greatly help you organize and
    structure your React application and React project as a whole to create better
    software and better developer experiences.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论可以帮助你组织和结构化你的 React 应用程序以及整个 React 项目的工具，以创建更好的软件和更好的开发者体验。
- en: 'The solutions to the preceding three scaling problems will be covered in this
    chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖前三个扩展问题的解决方案：
- en: You can make values available to components regardless of depth using React
    Context, which is a great way to organize complex data flow. We’ll cover this
    in section 10.1.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 React Context 使值对组件可用，无论深度如何，这是组织复杂数据流的好方法。我们将在第 10.1 节中介绍这一点。
- en: When you have multivalue state that is interdependent, you can perform state
    updates using a reducer, which is an idea borrowed from functional programming.
    We’ll cover this in section 10.2.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你有多值状态且相互依赖时，你可以使用 reducer 进行状态更新，这是一个从函数式编程中借用的想法。我们将在第 10.2 节中介绍这一点。
- en: Custom hooks are a great way to generalize both small and large chunks of business
    logic, and we’ll cover that in section 10.3\. Custom hooks are quickly becoming
    the main way of providing reusable functionality both internally in projects and
    also as open source libraries available on GitHub and/or npm.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义钩子是通用小型和大型业务逻辑的绝佳方式，我们将在第10.3节中介绍这一点。自定义钩子正迅速成为在项目内部以及作为GitHub和/或npm上可用的开源库提供可重用功能的主要方式。
- en: Note The source code for the examples in this chapter is available at [https://rq2e.com/ch10.](https://rq2e.com/ch10)
    But as you learned in chapter 2, you can instantiate all the examples directly
    from the command line using a single command.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章示例的源代码可在[https://rq2e.com/ch10.](https://rq2e.com/ch10)找到。但如你在第2章中学到的，你可以使用单个命令直接从命令行实例化所有示例。
- en: 10.1 Resolving values across components
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 在组件间解析值
- en: Let’s once again build an application that solves a real-world problem. This
    time, we’ll use a user dashboard, which is the screen you see after you log into
    some application. This dashboard shows a message that welcomes you by name, as
    well as a button in the top-left corner that displays your name and links to your
    settings page. The trick here is that the name is dynamic and will be returned
    to us by some backend. The end result is supposed to look like figure 10.1.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次构建一个解决现实世界问题的应用程序。这次，我们将使用用户仪表板，这是您登录某些应用程序后看到的屏幕。这个仪表板显示一条欢迎您的消息，以及位于右上角的一个按钮，显示您的姓名并链接到您的设置页面。这里的技巧是名称是动态的，将由某个后端返回给我们。最终结果应该看起来像图10.1。
- en: '![10-01](../Images/10-01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![10-01](../Images/10-01.png)'
- en: Figure 10.1 he desired end result for our user dashboard. The user’s name is
    displayed twice in this screenshot, which is the core of the problem here.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 我们用户仪表板期望的最终结果。在这个屏幕截图中，用户的姓名被显示两次，这是这里问题的核心。
- en: Let’s break this down into components. We want the top menu to be part of a
    header. The central welcome page is just one of many pages that can be displayed
    by our application. We know we’ll add more stuff in the future, so let’s add some
    extra layers in expectation of that. We’ll use a component approach as laid out
    in figure 10.2.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个结构分解成组件。我们希望顶部菜单是标题的一部分。中央欢迎页面只是我们应用程序可以显示的众多页面之一。我们知道我们将来会添加更多内容，所以让我们为了这个预期添加一些额外的层级。我们将使用图10.2中展示的组件方法。
- en: '![10-02](../Images/10-02.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![10-02](../Images/10-02.png)'
- en: Figure 10.2 Our component structure with the necessary placeholders needed for
    the name. Note how the "name" property is used twice, but still not passed along
    as a property anywhere.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 我们组件结构中包含必要的名称占位符。注意“名称”属性被使用两次，但仍然没有作为属性传递。
- en: However, as you can see in figure 10.2, we didn’t display how we got the name
    from the very top of the component tree, where it’s passed into the dashboard
    component all the way down to the two smaller components at the end that need
    to display it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如图10.2所示，我们没有展示如何从组件树的顶部获取名称，从那里它被传递到仪表板组件，一直到底部的两个较小的组件，它们需要显示这个名称。
- en: Using what we’ve done so far, we would need to pass the property through every
    component on its way to the component that needs it. If we did so, it would look
    like figure 10.3.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们迄今为止所做的工作，我们需要将属性传递给每个组件，直到它到达需要它的组件。如果我们这样做，它将看起来像图10.3。
- en: '![10-03](../Images/10-03.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![10-03](../Images/10-03.png)'
- en: Figure 10.3 Our component structure if we pass the name to every component that
    needs to pass it on. Five components need the name property, but only two of them
    display it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 如果我们将名称传递给所有需要传递的组件，我们的组件结构将如何。五个组件需要名称属性，但只有两个组件会显示它。
- en: But note, in this component tree, we’re passing the name property to both the
    Header and the Main component. Neither of those components needs this property
    by itself. The only reason why we have to pass this property to these two components
    is so that they can forward the property to yet another component. Nevertheless,
    this works and can be implemented, as shown in listing 10.1.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，在这个组件树中，我们将名称属性传递给了Header和Main组件。这两个组件本身都不需要这个属性。我们必须将这个属性传递给这两个组件的唯一原因是它们可以将属性转发给另一个组件。尽管如此，这可行，并且如列表10.1所示，它可以实现。
- en: Listing 10.1 Dashboard with a lot of name properties
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 带有许多名称属性的仪表板
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Did you know you can use emojis directly in React? You can!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 你知道你可以在React中直接使用表情符号吗？你可以！
- en: ❷ Passes a name property to a component that doesn't actually need to use the
    property itself
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将一个不需要使用该属性的属性传递给一个组件
- en: ❸ The component is only passed the property to be able to pass it on to another
    component.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 组件只传递属性，以便将其传递给另一个组件。
- en: 'Repository: rq10-dashboard-props'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq10-dashboard-props
- en: 'This example can be seen in repository rq10-dashboard-props. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq10-dashboard-props仓库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站浏览代码，直接在浏览器中查看应用程序的实际运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq10-dashboard-props](https://rq2e.com/rq10-dashboard-props)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq10-dashboard-props](https://rq2e.com/rq10-dashboard-props)'
- en: This is a reasonable approach, and it works. If you open this up in the browser,
    you see exactly what we wanted in figure 10.1.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个合理的方法，并且它有效。如果您在浏览器中打开它，您会看到我们想要的图10.1中的内容。
- en: 10.1.1 React Context
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 React Context
- en: Those properties being passed to components, only for them to be passed on to
    another component, doesn’t look like good software design. There must be a better
    way. What if we could have a storage object encapsulating a number of components
    that could feed data to all its child components when they asked for it without
    having any extra properties passed around?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性被传递给组件，只是为了将它们传递给另一个组件，这看起来并不是一个好的软件设计。一定有更好的方法。如果我们能有一个封装了多个组件的存储对象，当它们需要时，可以将其数据提供给所有子组件，而不需要传递任何额外的属性，会怎么样呢？
- en: Congratulations, we’ve just invented React Context. A context does exactly that—it
    wraps a number of components with a value that all descendant components can access
    without going through properties at all.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，我们刚刚发明了React Context。上下文正是如此——它使用值包裹了多个组件，所有子组件都可以访问这些值，而无需通过属性。
- en: Prop drilling
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 属性钻取
- en: The practice of adding properties to a component with the sole purpose of allowing
    that component to pass those properties on to other components, which might in
    turn only be necessary to allow those components to pass those properties on to
    yet another layer of components, is called *prop drilling*. You *drill* your *property*
    through many layers of components because you need to get it from the outside
    to the inside.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将属性添加到组件中的做法，唯一目的是允许该组件将这些属性传递给其他组件，而这些组件可能只需要将这些属性传递给另一层组件，这种做法被称为*属性钻取*。您通过许多组件层*钻取*您的*属性*，因为您需要从外部获取它到内部。
- en: Prop drilling can very quickly become a problem in large codebases, and React
    Context is one of the best tools to combat this. Without proper design patterns
    such as using context providers, you might end up with dozens of properties on
    some components, only added because they are needed further down the component
    tree.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型代码库中，属性钻取问题可能会很快出现，React Context是解决这个问题的最佳工具之一。如果没有适当的设计模式，例如使用上下文提供者，您可能会在一些组件上拥有数十个属性，仅仅是因为它们在组件树中需要进一步使用。
- en: This is obviously bad software design and one of the reasons React Context is
    so popular.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是糟糕的软件设计，也是React Context如此受欢迎的原因之一。
- en: A context in React consists of two parts. It needs a provider that contains
    the value you want to pass to any descendant component, and it needs a consumer
    that you use in each descendant component that wants access to the provided value.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: React中的上下文由两部分组成。它需要一个提供者，其中包含您想要传递给任何子组件的值，并且需要一个消费者，您在每个希望访问提供值的子组件中使用它。
- en: The context provider is a pretty simple React component. The consumer can most
    easily be created as a useContext hook. In essence, using a context looks something
    like figure 10.4.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文提供者是一个相当简单的React组件。消费者最容易被创建为一个useContext钩子。本质上，使用上下文看起来就像图10.4所示。
- en: '![10-04](../Images/10-04.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![10-04](../Images/10-04.png)'
- en: Figure 10.4 Passing a value from a provider to a consumer using the useContext
    hook
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 使用useContext钩子从提供者到消费者的值传递
- en: We need two pieces of the React Context API here. First, we need createContext
    to define the context, which we store in a variable. This variable is created
    outside any component and lives in the same places as other components, so it
    can be referenced just like any other component. Second, we need the useContext
    hook. This hook takes a reference to the context and returns the current context
    value. Let’s add a NameContext to our dashboard application from earlier to the
    component tree, as shown in figure 10.5.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们需要React Context API的两个部分。首先，我们需要createContext来定义上下文，我们将其存储在一个变量中。这个变量是在任何组件外部创建的，并且与其他组件位于同一位置，因此它可以像任何其他组件一样被引用。其次，我们需要useContext钩子。这个钩子接受上下文的引用，并返回当前的上下文值。让我们将一个NameContext添加到我们之前提到的仪表板应用程序的组件树中，如图10.5所示。
- en: '![10-05](../Images/10-05.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![10-05](../Images/10-05.png)'
- en: Figure 10.5 The dashboard application component tree with a context surrounding
    it all. The dash arrows show components that use the context and refer back to
    the current value as defined by the context provider.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 带有上下文的仪表板应用程序组件树。箭头表示使用上下文的组件，并回指由上下文提供者定义的当前值。
- en: That’s literally all it takes. We can implement this as shown in the following
    listing. We get the same result as before, but with a much nicer flow of data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上就是全部内容。我们可以像以下列表所示那样实现它。我们得到与之前相同的结果，但数据流更加顺畅。
- en: Listing 10.2 Dashboard with context
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2 带有上下文的仪表板
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Imports the two functions from the React package
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从React包中导入两个函数
- en: ❷ The context is created in the global scope, so we can access it from anywhere.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 上下文是在全局范围内创建的，因此我们可以从任何地方访问它。
- en: ❸ A lot of our components don't take any properties at all anymore.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们的大多数组件现在根本不再接受任何属性。
- en: ❹ The two components that need access to the name can do so by hooking into
    the context using useContext.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 需要访问名称的两个组件可以通过使用useContext钩子连接到上下文。
- en: ❺ In the dashboard component, we make sure to wrap the entire tree in a context
    provider with the name as the context value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在仪表板组件中，我们确保将整个树包裹在一个以名称为上下文值的context provider中。
- en: ❻ In the main application component, we initialize the entire dashboard with
    the name "Alice".
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在主应用程序组件中，我们使用名称 "Alice" 初始化整个仪表板。
- en: 'Repository: rq10-dashboard-context'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq10-dashboard-context
- en: 'This example can be seen in repository rq10-dashboard-context. You can use
    that repository by creating a new app based on the associated template:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq10-dashboard-context存储库中看到。你可以通过创建一个基于相关模板的新应用程序来使用该存储库：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq10-dashboard-context](https://rq2e.com/rq10-dashboard-context)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq10-dashboard-context](https://rq2e.com/rq10-dashboard-context)'
- en: 10.1.2 Context states
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 上下文状态
- en: Using a context to store a static value that is used throughout an application
    is definitely nice, but what’s even nicer is that we can store dynamic information
    there as well. The useContext hook is stateful, so if the context value changes,
    the useContext hook will cause the component using it to re-render automatically.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文存储在整个应用程序中使用的静态值确实很方便，但更方便的是我们还可以在那里存储动态信息。useContext 钩子是有状态的，所以如果上下文值发生变化，useContext
    钩子将导致使用它的组件自动重新渲染。
- en: Let’s imagine that same dashboard, but this time you’re an administrator who
    wants to be able to see what the dashboard looks like for any user in the database.
    As an administrator, you have a drop-down of users that you can see the dashboard
    for. We’ll implement this like figure 10.6, where the dashboard component is the
    same component as before (we just don’t show all of its child components to save
    space).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下同样的仪表板，但这次你是一个管理员，希望能够看到数据库中任何用户的仪表板外观。作为管理员，你有一个用户下拉菜单，可以看到仪表板。我们将像图10.6所示那样实现这一功能，其中仪表板组件与之前相同（我们只是没有显示所有子组件以节省空间）。
- en: '![10-06](../Images/10-06.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![10-06](../Images/10-06.png)'
- en: Figure 10.6 The admin dashboard allows the user to choose which user to see
    the dashboard for. The admin dashboard includes a select box and the regular user
    dashboard.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 管理员仪表板允许用户选择查看哪个用户的仪表板。管理员仪表板包括一个选择框和常规用户仪表板。
- en: 'We’ll use a simple select element to allow the user to select between the three
    users in the system: Alice, Bob, and Carol. We can use a simple useState for remembering
    the selected user and pass that on to the components as needed. Let’s extend the
    previous example with this new administrator dashboard.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的选择元素来允许用户在系统中的三个用户之间进行选择：Alice、Bob 和 Carol。我们可以使用简单的 useState 来记住选定的用户，并根据需要将其传递给组件。让我们用这个新的管理员仪表板扩展之前的例子。
- en: Listing 10.3 Administrator dashboard
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.3 管理员仪表板
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ We need to import the useState hook as well.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们还需要导入 useState 钩子。
- en: ❷ Everything inside the dashboard component is exactly as before.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 仪表板组件内部的一切都和之前一样。
- en: ❸ Creates a simple state, defaulting to Alice
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个简单的状态，默认为 Alice
- en: ❹ Uses a controlled select element to choose a user
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用受控选择元素来选择一个用户
- en: ❺ Passes the currently selected user to the dashboard component
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将当前选定的用户传递给仪表板组件
- en: 'Repository: rq10-dashboard-admin'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq10-dashboard-admin
- en: 'This example can be seen in repository rq10-dashboard-admin. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在 rq10-dashboard-admin 仓库中看到。你可以通过创建一个基于相关模板的新应用程序来使用那个仓库：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在浏览器中查看应用程序，或者下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq10-dashboard-admin](https://rq2e.com/rq10-dashboard-admin)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq10-dashboard-admin](https://rq2e.com/rq10-dashboard-admin)'
- en: If we try this in the browser, it looks like figure 10.7\. Go ahead and select
    a different name from the drop-down, and see the name correctly update in the
    dashboard in both the menu and the headline.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中尝试这个，它看起来就像图 10.7 所示。请尝试从下拉菜单中选择不同的名字，并看到名字在仪表板上的菜单和标题中正确更新。
- en: '![10-07](../Images/10-07.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![10-07](../Images/10-07.png)'
- en: Figure 10.7 The admin dashboard displaying the user dashboard for Carol, as
    we’ve selected her name in the admin drop-down in the top left
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 显示了用户仪表板，即 Carol 的仪表板，正如我们在左上角的管理员下拉菜单中选择了她的名字
- en: 10.1.3 React Context deconstructed
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3 React Context 解构
- en: 'At this point, let’s take a step back and look more at React Context in detail.
    As mentioned, to use React Context, you need to create a provider and a consumer.
    You can create consumers in two different ways: either as a hook or by using a
    *render prop*. But before you can do any of this, you need to create the context
    itself by using the function createContext, which exists in the React package:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，让我们退一步，更详细地看看 React Context。正如之前提到的，要使用 React Context，你需要创建一个提供者（provider）和一个消费者（consumer）。你可以以两种不同的方式创建消费者：要么作为一个钩子（hook），要么使用*渲染属性（render
    prop）*。但在你能够做任何这些之前，你需要通过使用函数 createContext 来创建上下文本身，这个函数存在于 React 包中：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are two things to note here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个需要注意的地方：
- en: It’s common to name the context variable with an uppercase letter as it kind
    of serves the purpose of a React component (or at least the properties on it do).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常我们会用大写字母命名上下文变量，因为它有点像 React 组件的作用（或者至少是它上面的属性）。
- en: createContext takes a single argument, which is the default value. We’ll get
    back to how that plays out in just a little bit.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: createContext 函数接受一个单一参数，即默认值。我们稍后会回到它是如何发挥作用的。
- en: Consuming a context
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 消费上下文
- en: 'When you have a context variable, for example, MyContext in the preceding snippet,
    it has two properties, which are what we care about: MyContext.Provider and MyContext.Consumer.
    We’ve already explained how you can consume a context using the useContext hook.
    You can do a similar thing with the MyContext.Consumer property, but it’s a bit
    trickier.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个上下文变量，例如，前一个片段中的 MyContext，它有两个属性，这是我们关心的：MyContext.Provider 和 MyContext.Consumer。我们已经解释了如何使用
    useContext 钩子来消费上下文。你也可以用 MyContext.Consumer 属性做类似的事情，但这稍微复杂一些。
- en: 'Let’s say we want to display a paragraph with the name provided by the nearest
    name context in a component named DisplayName. We can do that using the useContext
    hook:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在名为 DisplayName 的组件中显示由最近的名字上下文提供的名字段落。我们可以使用 useContext 钩子来实现这一点：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is pretty simple. We invoke the hook and get the current value back as
    a variable, which we can directly use in the component.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。我们调用钩子，并将当前值作为变量返回，我们可以在组件中直接使用它。
- en: 'If we try to do the same thing using the Consumer component, we have to invoke
    the consumer component with a function as the first and only child, and that function
    will be invoked with the value of the context:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用Consumer组件做同样的事情，我们必须用函数作为第一个也是唯一的子组件来调用Consumer组件，并且该函数将使用上下文的值被调用：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Passing a function that returns JSX as a child to a component is a render prop
    (as mentioned earlier) because it’s a property that can render JSX when invoked.
    You can probably see how this is a lot more work to type, and if we need to do
    some calculations or logic with the returned value, we have to restructure our
    component quite a bit.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回JSX的函数作为子组件传递给组件是一个渲染属性（如前所述），因为它是一个在调用时可以渲染JSX的属性。你可能已经看到这需要更多的工作来输入，如果我们需要对返回的值进行一些计算或逻辑处理，我们必须相当大幅度地重构我们的组件。
- en: Using the Consumer component is quite rare in functional codebases. It’s mainly
    used in older class-based projects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式代码库中使用Consumer组件相当罕见。它主要用于较老的基于类的项目中。
- en: Context composition
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文组合
- en: The provider is used to create a context that can be consumed. The consumer
    is used to consume the nearest provided context. Note that you can provide the
    same context many times throughout your application, and you can even provide
    the same context nested. You can also use the same context many times, even outside
    any provider.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Provider用于创建可以被消费的上下文。Consumer用于消费最近的提供上下文。请注意，你可以在整个应用程序中多次提供相同的上下文，甚至可以嵌套提供相同的上下文。你还可以在没有任何提供者的情况下多次使用相同的上下文。
- en: When you consume a context, you’ll get the value provided by the nearest provider
    going up the JSX document tree. If no provider exists above the consumer, you’ll
    get the default value as defined when the context was created. All of this is
    illustrated in figure 10.8.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你消费一个上下文时，你将得到从JSX文档树向上查找的最近提供者的值。如果消费者上方没有提供者，你将得到在创建上下文时定义的默认值。所有这些都在图10.8中得到了说明。
- en: 'Following are a few things to note in figure 10.8:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是图10.8中需要注意的一些事项：
- en: If you consume a context that doesn’t have a provider above it, as in TopComponent,
    you’ll get the default value from the definition of the context (0 in this case).
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你消费一个没有上层提供者的上下文，例如在TopComponent中，你将得到上下文定义中的默认值（在这种情况下为0）。
- en: If you consume a context that has multiple providers above it, as in BottomComponent,
    you’ll get the value from the nearest provider looking up through the document
    tree (e.g., 17 rather than 2 in this case).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你消费一个有多个提供者的上下文，例如在BottomComponent中，你将得到从最近的提供者通过文档树向上查找的值（例如，在这种情况下为17而不是2）。
- en: '![10-08](../Images/10-08.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![10-08](../Images/10-08.png)'
- en: Figure 10.8 You can have many providers and consumers of the same context.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 你可以有多个相同上下文的提供者和消费者。
- en: Nested context example
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套上下文示例
- en: You can imagine a use case for nested contexts for UI variables, such as an
    app where we have buttons with different border widths throughout the application.
    Our web application is a web shop with different items for purchase and pages
    about the business. We have some buttons in the header and another in the footer.
    We also have buttons to open the shopping cart in both the header and the footer.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象一个用于UI变量的嵌套上下文的用例，例如一个应用程序，其中我们有一些按钮在应用程序中具有不同的边框宽度。我们的Web应用程序是一个网上商店，有不同商品可供购买和关于业务的页面。我们在页眉和页脚中都有一些按钮。我们还在页眉和页脚中都有打开购物车的按钮。
- en: By default, all buttons have a border width of 1 pixel, but all buttons have
    a border width of 2 pixels in the footer. Furthermore, every button that leads
    to the shopping cart must always have a border width of 5 pixels because it’s
    an important button. Let’s sketch this system first, as shown in figure 10.9.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有按钮的边框宽度为1像素，但在页脚中所有按钮的边框宽度为2像素。此外，每个指向购物车的按钮必须始终具有5像素的边框宽度，因为它是一个重要的按钮。让我们首先绘制这个系统，如图10.9所示。
- en: '![10-09](../Images/10-09.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![10-09](../Images/10-09.png)'
- en: Figure 10.9 Our component tree for our shopping website. Note how we have both
    a default context value and several context providers throughout.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 我们购物网站的组件树。注意我们既有默认的上下文值，也有几个上下文提供者。
- en: Now, every button component will look up the component tree to find the nearest
    border context provider and use the border width taken from there. If no provider
    is found up the tree, the button will use the default value as defined in the
    original context creation. Let’s annotate the tree with all these lookups for
    the nearest provider in figure 10.10.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个按钮组件都会查找组件树以找到最近的边框上下文提供者，并使用那里获取的边框宽度。如果在树中没有找到提供者，按钮将使用在原始上下文创建中定义的默认值。让我们在图
    10.10 中用所有这些查找最近的提供者来注释树。
- en: '![10-10](../Images/10-10.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![10-10](../Images/10-10.png)'
- en: Figure 10.10 The component tree with the nearest provider (or the root) is marked
    with a heavier arrow for every button component, and the border width is resolved
    for that component.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 每个按钮组件的组件树（或根）都标记了一个更重的箭头，以表示最近的提供者（或根），并为该组件解析了边框宽度。
- en: Now that we have all the information we need, let’s implement this, as shown
    in listing 10.4\. Once we open this in the browser, we’re treated with figure
    10.11.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有需要的信息，让我们来实现它，如图 10.4 列表所示。一旦我们在浏览器中打开它，我们就会看到图 10.11。
- en: '![10-11](../Images/10-11.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![10-11](../Images/10-11.png)'
- en: Figure 10.11 Our shop website shows all the buttons with the correct widths
    exactly as designed. It doesn’t look good, but it’s what the client wanted for
    some reason!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 我们的商店网站显示了所有按钮，其宽度与设计完全一致。它看起来不太好，但出于某种原因，客户想要的就是这样！
- en: Listing 10.4 Border width by context
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 根据上下文设置边框宽度
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Creates the initial context with a default value of 1
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用默认值 1 创建初始上下文
- en: ❷ In the button component, we consume whatever value is provided by the nearest
    provider and use that as the border width property in CSS.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在按钮组件中，我们消费最近的提供者提供的任何值，并将其用作 CSS 中的边框宽度属性。
- en: ❸ Adds a border width provider around the button inside the cart button to provide
    this button with exactly 5 px
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在购物车按钮内部添加一个边框宽度提供者，为该按钮提供正好 5 px 的边框。
- en: ❹ We surround the footer with a provider that makes sure all the buttons inside
    by default will have 2 px borders, unless another, more specific provider tells
    them otherwise.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们在页脚周围包裹了一个提供者，确保默认情况下所有内部的按钮都将有 2 px 的边框，除非另一个更具体的提供者告诉它们否则。
- en: 'Repository: rq10-border-context'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq10-border-context
- en: 'This example can be seen in repository rq10-border-context. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在 repository rq10-border-context 中看到。你可以通过创建一个基于相关模板的新应用程序来使用那个存储库：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在你的浏览器中查看应用程序的运行情况，或者下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq10-border-context](https://rq2e.com/rq10-border-context)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq10-border-context](https://rq2e.com/rq10-border-context)'
- en: 10.2 How to handle complex state
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 如何处理复杂状态
- en: 'Let’s go back to our favorite example of all time: the counter with increment
    *and* decrement buttons! This time, we’ll use a different approach. Instead of
    using a regular useState hook to hold and manage the state value, we’ll use a
    reducer and the useReducer hook.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们所有时间中最喜欢的例子：带有增加和减少按钮的计数器！这次，我们将采用不同的方法。我们不会使用常规的 useState 钩子来持有和管理状态值，而是会使用
    reducer 和 useReducer 钩子。
- en: We’ll give you a quick introduction to how the useReducer hook works now just
    to get started on the example, but you’ll get more details in the following subsections.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将快速介绍 useReducer 钩子的工作原理，以便开始这个例子，但你将在接下来的小节中了解更多细节。
- en: 'The useReducer API looks like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: useReducer API 的样子如下：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These four elements go together somewhat, as shown in figure 10.12.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个元素在一定程度上是相互关联的，如图 10.12 所示。
- en: '![10-12](../Images/10-12.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![10-12](../Images/10-12.png)'
- en: Figure 10.12 The flow of data in a useReducer hook is somewhat similar to a
    regular useState hook, in that it starts with an initial value and then updates
    as the application progresses. But the way you update the internal state is more
    complex, in that you “reduce” the new state from the old one using functions and
    actions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 useReducer 钩子中的数据流在某种程度上类似于常规的 useState 钩子，因为它从初始值开始，然后随着应用程序的进展而更新。但更新内部状态的方式更复杂，因为你使用函数和动作“减少”新状态从旧状态。
- en: There are four separate parts to this. The state and initialState work just
    like they do for useState(). So, for our counter, the initial state will be 0,
    and the state will be whatever our counter has reached at that moment.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有四个独立的部分。状态和初始状态的工作方式与 useState() 相同。因此，对于我们的计数器，初始状态将是 0，状态将是那一刻计数器达到的任何值。
- en: The two new things in this single piece of code are the dispatch function and
    the reducer function. dispatch works as our enhanced setter function, which allows
    us to not set the value directly, but rather instruct the reducer function on
    how to set the value. The reducer function is hence a function that takes the
    current state and a dispatched action and returns a new state based on them. You
    invoke dispatch with an *action* object, which is then passed to the reducer along
    with the old state, and the reducer is expected to return the new state. For now,
    let’s implement this for our up-and-down counter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中引入的两个新事物是分发函数和还原函数。dispatch 作为我们的增强型设置函数，允许我们不是直接设置值，而是指导还原函数如何设置值。因此，还原函数是一个函数，它接受当前状态和分发动作，并根据它们返回新的状态。您使用动作对象调用
    dispatch，该对象随后与旧状态一起传递给还原函数，并期望还原函数返回新状态。现在，让我们为我们的上下计数器实现这一点。
- en: Listing 10.5 Counter component with reducer
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.5 带有还原器的计数器组件
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Creates a reducer function that takes the old state (the current value) and
    the action object, which has a type
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个还原函数，它接受旧状态（当前值）和动作对象，动作对象有一个类型
- en: ❷ Returns the old value plus or minus 1, depending on the type
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 根据类型返回旧值加或减 1
- en: ❸ Initializes the hook with the reducer function and the initial value, 0
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用还原函数和初始值 0 初始化钩子
- en: ❹ Invokes the dispatch function with the relevant action objects
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 调用带有相关动作对象的分发函数
- en: 'Repository: rq10-counter-reducer'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq10-counter-reducer
- en: 'This example can be seen in repository rq10-counter-reducer. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以在仓库 rq10-counter-reducer 中看到。您可以通过创建基于相关模板的新应用程序来使用该仓库：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站浏览代码，直接在浏览器中查看应用程序的实际运行情况，或下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq10-counter-reducer](https://rq2e.com/rq10-counter-reducer)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq10-counter-reducer](https://rq2e.com/rq10-counter-reducer)'
- en: '*É voilà*! We have once again re-implemented the counter. We did it in a much
    more complex and elaborate way, but this reducer concept can be utilized for more
    complex state scenarios, as you’ll see in the next subsection.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*这就是了*！我们再次实现了计数器。我们以更复杂和详尽的方式做到了这一点，但这个还原概念可以用于更复杂的状态场景，您将在下一小节中看到。'
- en: 10.2.1 Interdependent state
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 依赖状态
- en: Another problem that can come up as your application grows more complex is interdependent
    state. This happens when you have different values in state that are related,
    but aren’t just copies of each other. For instance, let’s imagine a simple component
    for loading some external content and displaying the content once loaded. Because
    this is external content, the load might fail. If so, we need to show an error
    message.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的应用程序变得更加复杂，可能会出现另一个问题，即依赖状态。当状态中有不同的值相互关联，但不是彼此的副本时，就会发生这种情况。例如，让我们想象一个简单的组件，用于加载一些外部内容并在加载完成后显示内容。因为这是外部内容，加载可能会失败。如果是这样，我们需要显示错误消息。
- en: The simple way to construct such a component is to have three different state
    values. One value represents the loading progress (is it loading, did loading
    succeed, did loading fail), another holds the result object if the loading succeeded,
    and the last state holds the error message if the load failed. We can picture
    this simple state flow in figure 10.13.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 构建此类组件的简单方法是有三个不同的状态值。一个值表示加载进度（是否正在加载，加载是否成功，加载是否失败），另一个持有加载成功的结果对象，最后一个状态持有加载失败时的错误消息。我们可以在图
    10.13 中想象这个简单的状态流。
- en: '![10-13](../Images/10-13.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![10-13](../Images/10-13.png)'
- en: Figure 10.13 The state flow in a simple loading component. The dashed boxes
    indicate the desired state at the given point in the program execution.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 简单加载组件中的状态流。虚线框表示程序执行给定点的期望状态。
- en: We have three different values that are interdependent, which means we only
    have semantic meaning for certain combinations of values. For instance, if the
    status is LOADING, it makes no sense for the error or result to be anything but
    null because we haven’t downloaded anything (or failed to do so) yet. Likewise,
    if the status is FAILURE, the result state can’t have a value because it just
    can’t.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个相互依赖的不同值，这意味着我们只有当值的某些组合有意义时才有语义意义。例如，如果状态是LOADING，错误或结果不应该是null就没有意义，因为我们还没有下载任何内容（或未能这样做）。同样，如果状态是FAILURE，结果状态不能有值，因为它根本不能有。
- en: As a developer, however, you must keep this relationship between the values
    in mind. We can’t directly code this relationship with simple state values when
    using useState(). We have to remember to clear the error and result states when
    reloading the external resource because, if we don’t, it can lead to the component
    being in an invalid state and not knowing what it’s supposed to show.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，作为一个开发者，你必须记住这些值之间的关系。当我们使用useState()时，我们不能直接用简单的状态值编码这个关系。我们必须记住在重新加载外部资源时要清除错误和结果状态，因为如果我们不这样做，可能会导致组件处于无效状态，不知道它应该显示什么。
- en: 'A better solution here is to create a single function that allows us to move
    between the different semantic states of the system rather than just the individual
    variables. For example, imagine what happens when loading fails if we have three
    separate variables and need to set two of them:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，更好的解决方案是创建一个单独的函数，使我们能够在不同语义状态之间移动，而不仅仅是单个变量。例如，想象一下，如果我们有三个单独的变量并且需要设置其中两个，当加载失败时会发生什么：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we adopted the recommended approach of calling a single function that changed
    the semantic state, we would instead do the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们采用了推荐的方法，即调用一个改变语义状态的单一函数，我们就会做以下操作：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The difference here is pretty big. The former syntax has a lot of room for error,
    whereas the latter is a much cleaner API with very little room to misinterpret
    what to do.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的区别很大。前者语法有很多错误的空间，而后者是一个更干净的API，几乎没有任何误解操作的空间。
- en: useReducer to the rescue
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: useReducer来拯救
- en: All of this is to say that this is exactly where useReducer comes into the picture.
    But instead of having a single primitive value as our state, we can hold an object
    of multiple values of state. We can then also use dispatched action objects to
    manipulate this entire object of state values as we need to.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是在说，这正是useReducer出现的地方。但我们的状态不再是单一的基本值，而是一个包含多个状态值的对象。然后我们也可以使用分发的动作对象来根据需要操纵这个整个状态值对象。
- en: So, let’s go back to our state flow diagram and look at which action objects
    we need to advance the state and what payload arguments they require to update
    the state values as needed (see figure 10.14). Now we just need to define the
    reducer function, which takes the existing state and an action object and then
    generates a new state based on that.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回到我们的状态流程图，看看我们需要哪些动作对象来推进状态，以及它们需要什么payload参数来按需更新状态值（见图10.14）。现在我们只需要定义reducer函数，它接受现有的状态和一个动作对象，然后根据这些生成一个新的状态。
- en: '![10-14](../Images/10-14.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![10-14](../Images/10-14.png)'
- en: Figure 10.14 The state flow with the desired action API. In this diagram, the
    dashed boxes indicate the action object that we’ll dispatch to the reducer to
    have the reducer update the internal state as desired.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 所需动作API的状态流程。在这个图中，虚线框表示我们将分发的动作对象发送到reducer，以便reducer更新内部状态。
- en: 'The overall structure of a reducer is commonly organized as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: reducer的整体结构通常组织如下：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So, for our particular use case, the action types are already defined as "INITIALIZE",
    "LOADING", "ERROR", and "SUCCESS". The following states result from each of these
    actions:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们的特定用例，动作类型已经定义为"INITIALIZE"、"LOADING"、"ERROR"和"SUCCESS"。以下是从每个这些动作产生的状态：
- en: When initializing, set the status to "INITIALIZE", and all other variables to
    null, regardless of their existing value.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当初始化时，将状态设置为"INITIALIZE"，并将所有其他变量设置为null，无论它们的现有值如何。
- en: When loading, set the status to "LOADING", and keep everything else as is.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当加载时，将状态设置为"LOADING"，并保持其他一切不变。
- en: When loading fails, set the status to "FAILURE", and set the error to the passed
    payload.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当加载失败时，将状态设置为"FAILURE"，并将错误设置为传递的payload。
- en: When loading succeeds, set the status to "SUCCESS", and set the result to the
    passed payload.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当加载成功时，将状态设置为"SUCCESS"，并将结果设置为传递的payload。
- en: 'Now, let’s implement that in the preceding reducer structure:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在先前的reducer结构中实现这一点：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ When we initialize, we clear everything regardless of what the state was before.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当我们初始化时，无论之前的状态如何，都会清除一切。
- en: ❷ When loading happens, we only change the status and nothing else.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当加载发生时，我们只更改状态，不做其他任何事情。
- en: ❸ When an error happens, we change the status and set the error.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当发生错误时，我们更改状态并设置错误。
- en: ❹ When loading succeeds, we change the status and set the result.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当加载成功时，我们更改状态并设置结果。
- en: Alright, let’s get back to the original purpose. We need a component that can
    load some data and display status along the way. We’ll use a reducer as defined
    previously to handle the state, but we’ll also change a few things.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们回到原始目的。我们需要一个可以加载一些数据并在过程中显示状态的组件。我们将使用之前定义的reducer来处理状态，但我们会更改一些事情。
- en: Listing 10.6 Loading component with reducer
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.6 带有reducer的加载组件
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ We’ve extracted the initial state to a variable rather than one of the options
    inside the reducer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们将初始状态提取到一个变量中，而不是reducer内部的选项之一。
- en: ❷ We now only expect actions of type LOADING, FAILURE, and SUCCESS.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们现在只期望类型为LOADING、FAILURE和SUCCESS的动作。
- en: ❸ We've added a default case to the switch to handle the case where some unknown
    nonsense is dispatched.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们在switch中添加了一个默认情况来处理发送了某些未知胡言乱语的情况。
- en: ❹ When the loading succeeds, we change the status and set the result.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当加载成功时，我们更改状态并设置结果。
- en: ❺ In an effect hook, we start by setting the status to LOADING by dispatching
    the proper action.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在一个效果钩子中，我们首先通过发送适当的动作将状态设置为LOADING。
- en: ❻ If the results are returned, we set them in the state by dispatching the SUCCESS
    action.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果返回结果，我们将通过发送SUCCESS动作在状态中设置它们。
- en: ❼ If some error occurs along the way, we dispatch an ERROR action with a message.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 如果在过程中发生某些错误，我们将发送一个包含消息的ERROR动作。
- en: ❽ With all of this out of the way, we can now destructure the state into the
    three variables we know it contains.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 在处理完所有这些之后，我们现在可以将状态解构为包含的三个变量。
- en: ❾ Finally, we display the proper message depending on the status variable using
    the values of error and result where necessary.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 最后，根据状态变量和必要的错误和结果值，显示适当的消息。
- en: 'Repository: rq10-reducer-load'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq10-reducer-load
- en: 'This example can be seen in repository rq10-reducer-load. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq10-reducer-load存储库中看到。你可以通过创建一个基于相关模板的新应用程序来使用该存储库：
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站浏览代码，在你的浏览器中直接查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq10-reducer-load](https://rq2e.com/rq10-reducer-load)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq10-reducer-load](https://rq2e.com/rq10-reducer-load)'
- en: If we spin this up in the browser, it works! Check out figure 10.15.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行它，它就起作用了！查看图10.15。
- en: '![10-15](../Images/10-15.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![10-15](../Images/10-15.png)'
- en: Figure 10.15 Our loading component in action—first in the loading state and
    second in the success state
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 我们正在运行的加载组件——首先是加载状态，然后是成功状态
- en: 'If we change the URL to something that doesn’t exist, for example, if we change
    it as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将URL更改为不存在的某个内容，例如，如果我们按照以下方式更改它：
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: our load will fail and we’ll instead see the error message shown in figure 10.16.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的加载失败，我们将看到图10.16中显示的错误消息。
- en: '![10-16](../Images/10-16.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![10-16](../Images/10-16.png)'
- en: Figure 10.16 If the load fails, an error message is displayed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 如果加载失败，将显示错误消息。
- en: One of the nice things about this reducer we’ve created is that it’s completely
    generalized. It doesn’t care what we’re loading or how we’re loading it. The reducer
    only manages the state around things that can be loaded and potentially fail to
    load. Those things can be data, images, videos, fonts, baby otters, or anything
    else.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的这个reducer的一个很好的特点是它完全通用。它不关心我们正在加载什么或如何加载它。reducer只管理可以加载和可能加载失败的事物的状态。这些事物可以是数据、图像、视频、字体、小海狸，或任何其他东西。
- en: What is a reducer?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是reducer？
- en: The term *reducer* comes from the software engineering model *MapReduce*, which
    is a way to think about data models and data streams regarding how to update your
    data models on the fly based on records in a data stream.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*reducer*来自软件工程模型*MapReduce*，这是一种关于数据模型和数据流的方法，它基于数据流中的记录来动态更新你的数据模型。
- en: Reducers are generally thought to be pure, simple, and side-effect-free functions
    that are deterministic and defined solely by their parameters. A reducer generally
    takes the current state of the world and some new record/action and updates the
    state of the world based on that.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Reducers通常被认为是纯的、简单的、无副作用的函数，它们是确定的，并且仅由它们的参数定义。Reducer通常接受世界的当前状态和一些新的记录/动作，并根据这些更新世界的状态。
- en: In large-scale computing and data analysis, reducers are used to quickly and
    efficiently traverse complex data structures.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模计算和数据分析中，reducers被用来快速有效地遍历复杂的数据结构。
- en: In React, *reducer* refers to the function or set of functions that converts
    the current state into a new state based on a given action. In React, we expect
    reducers to be pure, deterministic, and free of side effects as well.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，*reducer*指的是将当前状态转换为新的状态的功能或函数集，基于给定的动作。在React中，我们期望reducer是纯的、确定的，并且没有副作用。
- en: 10.3 Custom hooks
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 自定义钩子
- en: 'Let’s go back to the dashboard example earlier in this book. We had this bit
    of code in multiple locations:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到这本书前面提到的仪表板示例。我们在多个位置有这段代码：
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Even though this piece of code is quite simple, it does require you to combine
    the two pieces, useContext and NameContext, correctly. Instead, we can make it
    a bit easier by moving this functionality to a new function and replacing the
    preceding code with this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码相当简单，但它确实要求你正确地组合useContext和NameContext这两个部分。相反，我们可以通过将这个功能移动到一个新函数中，并用这个来替换前面的代码，使其变得更容易一些：
- en: '[PRE22]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Can we do this? Yes, of course, we can! We just create a custom function that
    does this work behind the scenes. So, this function uses the useContext hook to
    extract the current value from the NameContext context:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能这样做吗？当然可以！我们只需创建一个在幕后完成这项工作的自定义函数。所以，这个函数使用了useContext钩子从NameContext上下文中提取当前值：
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That’s it—simply generalizing functionality by moving the duplicated part of
    the code to a common function.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——通过将代码的重复部分移动到公共函数中来泛化功能。
- en: But there’s a twist here in that we’re generalizing functionality *based on
    a React hook* and there are *rules* for how we can use React hooks. First, we
    can’t use React hooks outside of functional components. Second, we can only use
    React hooks if we always use the same hooks in the same order.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个转折，那就是我们正在基于一个React钩子来泛化功能，并且有关于我们如何使用React钩子的规则。首先，我们不能在功能组件之外使用React钩子。其次，只有当我们始终以相同的顺序使用相同的钩子时，我们才能使用React钩子。
- en: This new function that we’ve created here, useName, also has to obey those rules.
    This function is now also a hook. It’s a custom hook, and you’ve just created
    the very first one in this book! Note that this hook is very simple and doesn’t
    take any arguments, but custom hooks can take arguments if they need to. You’ll
    see some custom hooks in the next subsection. Now let’s explore exactly what makes
    a function a custom hook, how you decide when and where to use custom hooks, and
    where you can find more of them.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建的新函数useName也必须遵守这些规则。这个函数现在也是一个钩子。它是一个自定义钩子，你刚刚在这本书中创建了第一个！请注意，这个钩子非常简单，不接收任何参数，但自定义钩子如果需要的话可以接收参数。你将在下一个子节中看到一些自定义钩子。现在让我们探讨究竟是什么让一个函数成为自定义钩子，你如何决定何时何地使用自定义钩子，以及你可以在哪里找到更多自定义钩子。
- en: 10.3.1 When is something a custom hook?
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 何时是自定义钩子？
- en: A custom hook is a function that uses a hook. A hook can be any built-in hook
    or a custom hook, so it almost seems like a self-referential definition, but it’s
    not. The whole thing starts with the 10 built-in hooks that we laid out earlier.
    If you create a function using any of those 10 hooks, then you’ve created a custom
    hook. If you create a function using any of those 10 hooks or using a custom hook
    that has used one of those 10 hooks, you’ve also created a custom hook, and so
    on. Thus, you do need to have one or more built-in hooks in there somewhere down
    the line for a function to be a custom hook. Some examples of this are shown in
    figure 10.17.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义钩子是一个使用钩子的函数。钩子可以是任何内置钩子或自定义钩子，所以这几乎像是一个自引用的定义，但事实并非如此。整个事情始于我们之前详细说明的10个内置钩子。如果你使用这10个钩子中的任何一个来创建一个函数，那么你就创建了一个自定义钩子。如果你使用这10个钩子中的任何一个或使用已经使用了这10个钩子的自定义钩子来创建一个函数，那么你也创建了一个自定义钩子，以此类推。因此，你确实需要在某个地方有一个或多个内置钩子，以便函数成为自定义钩子。图10.17展示了这一点的几个示例。
- en: '![10-17](../Images/10-17.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![10-17](../Images/10-17.png)'
- en: Figure 10.17 Examples of what a custom hook is and is not
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 自定义钩子是什么以及不是什么的示例
- en: Note the naming of the functions here. It’s a common practice to name all custom
    hooks as use* and name nothing else like that. However, there is no special magic
    associated with the naming itself. It’s up to you as a developer to make sure
    that your custom hook is named use*. Likewise, you must check that something named
    use* is in fact a custom hook.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的函数命名。将所有自定义钩子命名为use*是一种常见的做法，而不会用其他方式命名。然而，与命名本身相关的特殊魔法并不存在。这取决于你作为开发者确保你的自定义钩子被命名为use*。同样，你必须检查名为use*的东西确实是一个自定义钩子。
- en: 10.3.2 When should I use a custom hook?
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 我应该在什么时候使用自定义钩子？
- en: You should use a custom hook whenever you see the need for it. You can almost
    never make your code too streamlined and compact. Well, you can, but that limit
    is pretty far off.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在任何需要的时候使用自定义钩子。几乎永远不可能让你的代码过于流畅和紧凑。好吧，你可以，但那个限制相当遥远。
- en: 'You’ll often find that your custom hooks take one of two forms:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会发现你的自定义钩子有两种形式：
- en: You’re creating a custom hook for functionality that you’re going to need in
    multiple places.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在创建一个自定义钩子，你将在多个地方需要这个功能。
- en: You’re moving functionality to a custom hook to clean up a component and make
    it simpler to read.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在将功能移动到自定义钩子中，以清理组件并使其更易于阅读。
- en: Both of these goals are completely valid and you’ll often see developers using
    them both. The difference between the two is often found in the naming of the
    hooks. If the hook has a generic-sounding name, it’s probably a reusable functionality.
    If it has a very specific name, it’s probably just an extraction of complex logic
    to an external file to make the overview easier. Let’s get started with some examples
    from previous applications we’ve built in this book.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个目标都是完全有效的，你经常会看到开发者同时使用它们。两者之间的区别通常体现在钩子的命名上。如果一个钩子有一个听起来通用的名字，它可能是一个可重用的功能。如果一个钩子有一个非常具体的名字，它可能只是将复杂逻辑提取到外部文件以简化概览。让我们从本书中我们构建的一些先前应用中的一些例子开始。
- en: useToggle
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: useToggle
- en: 'Let’s look at one of our earlier components from chapter 6, where we had this
    excerpt of code in the interactive countdown:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第6章中我们的一些早期组件，其中在交互式倒计时中有这段代码摘录：
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This functionality of creating a Boolean flag in state and having a toggle function
    that allows the flag to alternate seems like a pretty general procedure.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态中创建一个布尔标志并有一个允许标志交替的切换函数，这似乎是一个相当通用的过程。
- en: 'Let’s generalize that into a hook that kind of looks like the regular useState
    hook, except that instead of a setter function, it returns a toggle function.
    Only Boolean values are allowed as state values:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个概念推广为一个看起来像常规的useState钩子的钩子，只不过它返回的是一个切换函数，而不是一个设置函数。状态值只允许为布尔值：
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note how this hook returns an array of a value and a function as the normal
    useState hook. This is a common pattern in custom hooks too, as it makes the custom
    hook familiar to work with. The value returned from the useToggle hook can be
    used in the same way as the value returned from the useState hook, but the function
    is different. Where the setter function returned by the useState hook can be used
    to set the value to any value, the toggle function returned by the useToggle hook
    can only be used to invert the current Boolean value—the toggle function doesn’t
    take an argument.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个钩子如何返回一个包含值和函数的数组，就像正常的useState钩子一样。这也是自定义钩子中的一种常见模式，因为它使得自定义钩子更容易使用。从useToggle钩子返回的值可以像从useState钩子返回的值一样使用，但函数是不同的。useState钩子返回的设置函数可以用来将值设置为任何值，而useToggle钩子返回的切换函数只能用来反转当前的布尔值——切换函数不接受任何参数。
- en: 'That’s all it takes. This is a nice generic toggle. We can apply it to our
    interactive countdown like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部。这是一个很好的通用切换器。我们可以将其应用于我们的交互式倒计时，如下所示：
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We didn’t save a lot of characters, but it looks a lot simpler now without the
    extra function in there. We also can use this hook elsewhere, if we need a stateful
    toggle for something else.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有保存很多字符，但现在没有那个额外功能，看起来要简单得多。我们还可以在其他地方使用这个钩子，如果我们需要为其他东西提供一个有状态的切换功能的话。
- en: useForm
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: useForm
- en: 'You might remember from chapter 9 that we had this functionality in our form
    component:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在第9章中，我们在表单组件中有这个功能：
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can also generalize this functionality into a custom hook that can be used,
    not just for this form with its six specific inputs, but for any form with any
    number of inputs:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将这个功能推广为一个自定义钩子，它可以用于不仅限于这个具有六个特定输入的表单，还可以用于任何具有任意数量输入的表单：
- en: '[PRE28]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can use that in our specific form as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的特定表单中如下使用它：
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That definitely looks nice and reusable.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来确实很棒且可重用。
- en: useLoader
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: useLoader
- en: 'Remember the reducer that we created earlier in this chapter? It was a generic
    hook for loading content of any type that allowed the component to specify whether
    loading was underway, successful, or failed. However, we didn’t actually make
    the reducer generic, but just kept it inside our component. The component looked
    like this before:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在本章早期创建的 reducer 吗？它是一个通用的钩子，用于加载任何类型的内容，允许组件指定加载是进行中、成功还是失败。然而，我们并没有真正使
    reducer 通用化，只是将其保留在我们的组件内部。组件在之前是这样的：
- en: '[PRE30]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can again extract the generic parts of the logic to an external hook and
    use that in the component. The hook would become the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将逻辑的通用部分提取到一个外部钩子中，并在组件中使用它。这个钩子将如下所示：
- en: '[PRE31]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we save the preceding snippet to the file useLoader.js located next to the
    original component, our component will be simplified to just this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的代码片段保存到与原始组件相邻的文件 useLoader.js 中，我们的组件将简化为如下所示：
- en: '[PRE32]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This separation of logic into two separate units makes both parts read a lot
    more clearly.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将逻辑分离成两个独立单元的做法使两部分都读起来更加清晰。
- en: useCounter
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: useCounter
- en: In this example, we extract our business logic inside a component to an external
    one just to make the original component easier to get an overview of without seeking
    to create generic functionality. Let’s take our counter component from earlier
    with increment and decrement buttons. We don’t need to use this specific functionality
    elsewhere; we’re seeking to make our component less cluttered.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将我们的业务逻辑从组件内部提取到一个外部组件中，只是为了使原始组件更容易获得概览，而不需要创建通用功能。让我们以我们之前带有增加和减少按钮的计数器组件为例。我们不需要在其他地方使用这个特定的功能；我们寻求使我们的组件更加简洁。
- en: 'Before, the component looked like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前，组件看起来是这样的：
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we extract the following part into a custom hook like
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将以下部分提取到一个自定义钩子中
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'and save the preceding snippet to the file useCounter.js located next to the
    original component, our component then becomes just this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 并将前面的代码片段保存到与原始组件相邻的文件 useCounter.js 中，我们的组件就变成了这样：
- en: '[PRE35]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now that’s a clean component! Just a single hook up top creates all the state
    values and callbacks needed to fulfill the responsibility, and the rest of the
    code in the component is the JSX.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是一个干净的组件！只需顶部的一个钩子就能创建所有必要的状态值和回调函数，以履行职责，而组件中的其余代码就是 JSX。
- en: 10.3.3 Where can I find custom hooks?
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 我在哪里可以找到自定义钩子？
- en: 'You can find custom hooks everywhere! Custom hooks are one of the best ways
    to expose complex logic rules, and you’ll find that many libraries and online
    utilities come in the form of custom hooks. Hooks are much more versatile than
    components because they don’t come with implicit ideas about semantics, UIs, or
    HTML elements. Custom hooks are pure functionality that you can apply in whatever
    way fits your application. Here’s an inexhaustive list of excellent custom hooks
    you can use directly in your application:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何地方找到自定义钩子！自定义钩子是暴露复杂逻辑规则的最佳方式之一，你会发现许多库和在线工具都是以自定义钩子的形式出现的。钩子比组件更灵活，因为它们不包含关于语义、UI
    或 HTML 元素的隐含想法。自定义钩子是纯功能，你可以以适合你应用的方式应用它们。以下是一个你可以直接在应用中使用的不完全列表的出色自定义钩子：
- en: '*useHooks* ([https://usehooks.com](https://usehooks.com))—A collection of various
    general-purpose hooks for everyday work.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*useHooks* ([https://usehooks.com](https://usehooks.com))—一个包含各种通用钩子的集合，用于日常工作。'
- en: '*Collection of React Hooks* ([https://nikgraf.github.io/react-hooks](https://nikgraf.github.io/react-hooks))—A
    huge library of more than 400 user-submitted hooks for all sorts of purposes.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*React Hooks 的集合* ([https://nikgraf.github.io/react-hooks](https://nikgraf.github.io/react-hooks))—一个包含400多个用户提交的、用于各种目的的钩子库。'
- en: '*React Aria* ([https://react-spectrum.adobe.com/react-aria](https://react-spectrum.adobe.com/react-aria))—An
    open source library of accessibility-specific hooks providing proper keyboard
    and pointer bindings for many different more or less complex widgets developed
    and maintained by Adobe'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*React Aria* ([https://react-spectrum.adobe.com/react-aria](https://react-spectrum.adobe.com/react-aria))—一个开源库，提供针对可访问性的钩子，为Adobe开发和维护的许多不同类型、复杂程度不一的控件提供适当的键盘和指针绑定'
- en: '*awesome-react-hooks* ([https://github.com/rehooks/awesome-react-hooks](https://github.com/rehooks/awesome-react-hooks))—A
    curated list of React hooks sorted by category with a short description for each'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*awesome-react-hooks* ([https://github.com/rehooks/awesome-react-hooks](https://github.com/rehooks/awesome-react-hooks))—一个按类别排序的
    React 钩子精选列表，每个钩子都有简短的描述'
- en: 10.4 Quiz
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 小测验
- en: Which of the following is the correct way to create a context provider for a
    context named StyleContext with the value style?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是创建名为 StyleContext 的上下文提供者的正确方式，其值为 style？
- en: '| a. |'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| a. |'
- en: '[PRE36]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '| b. |'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| b. |'
- en: '[PRE37]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '| c. |'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| c. |'
- en: '[PRE38]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '| d. |'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| d. |'
- en: '[PRE39]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: If you use the useContext hook with a context that does not have an associated
    provider above the component in question in the JSX document tree, the hook throws
    an error. *True* or *false*?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在一个没有相关提供者的 JSX 文档树中，使用 useContext 钩子与一个没有关联提供者的上下文，该钩子会抛出一个错误。*正确*还是*错误*？
- en: The useState hook is superior to the useReducer hook in every way, and anything
    you can do with the latter, you can do better with the useState hook. *True* or
    *false*?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态钩子比 useReducer 钩子更优越，你用后者能做的任何事情，你都可以用 useState 钩子做得更好。*正确*还是*错误*？
- en: If you define a custom hook, you have to register it as an *official* custom
    hook using a specific React function. *True* or *false*?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你定义了一个自定义钩子，你必须使用特定的 React 函数将其注册为*官方*自定义钩子。*正确*还是*错误*？
- en: Custom hooks are a great way to generalize functionality in your applications
    and make components simpler to read and use. *True* or *false*?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义钩子是使你的应用程序功能通用化的好方法，并使组件更容易阅读和使用。*正确*还是*错误*？
- en: Quiz answers
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问答答案
- en: '| 1 |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 1 |'
- en: '[PRE40]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: You always provide a context through the context’s .Provider property and you
    always provide the context value using the value property.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是通过上下文的 .Provider 属性提供上下文，并且你总是使用 value 属性提供上下文值。
- en: '*False*. The useContext hook will return the default value provided to createContext,
    if no associated provider is found.'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误*。如果没有找到相关提供者，useContext 钩子将返回 createContext 提供的默认值。'
- en: Mostly *false*, however, there are definitely situations where you want to use
    a useState hook over a useReducer hook. These two hooks serve slightly different
    purposes and are rarely in direct competition with each other.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数情况下*错误*，然而，确实有某些情况下你想要使用 useState 钩子而不是 useReducer 钩子。这两个钩子服务于稍微不同的目的，并且很少直接竞争。
- en: '*False*. Any function you define that makes use of another hook automatically
    becomes a custom hook. You don’t have to do anything else to make it work as a
    hook.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误*。任何你定义的利用另一个钩子的函数自动成为自定义钩子。你不需要做任何其他事情来使其作为钩子工作。'
- en: '*True*. Custom hooks are one of the primary ways to share complex business
    logic between components in an application, and even between different applications.
    Many React libraries expose their functionality in the form of custom hooks.'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*正确*。自定义钩子是共享应用程序中组件之间复杂业务逻辑的主要方式之一，甚至在不同应用程序之间。许多 React 库以自定义钩子的形式公开其功能。'
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: React Context and the useContext hook are extremely versatile and useful tools
    in your React developer toolbox.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Context 和 useContext 钩子是你在 React 开发者工具箱中极其灵活和有用的工具。
- en: React Context is the perfect tool to avoid prop drilling—the practice of passing
    properties to a component with the sole purpose of having the component pass the
    property on to the next component down the line. This is bad software design,
    and React Context helps you avoid this.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Context 是避免 prop drilling（将属性传递给组件的唯一目的是让该组件将属性传递给下一组件）的完美工具。这是糟糕的软件设计，React
    Context 帮助你避免这种情况。
- en: A React Context consumer (either through the .Consumer property or via the useContext
    hook) will get the current context value from the nearest React Context provider
    of the same type when looking up the component tree—or the default value if no
    provider is found.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在组件树中查找时，React Context 消费者（无论是通过 .Consumer 属性还是通过 useContext 钩子）将从相同类型的最近 React
    Context 提供者获取当前上下文值——如果没有找到提供者，则返回默认值。
- en: The useContext hook is recommended for any functional codebase over the .Consumer
    component property.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐在功能代码库中使用 useContext 钩子而不是 .Consumer 组件属性。
- en: React Context can be used for very complex data management in large applications
    with great success.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Context 可以在大型应用中非常成功地用于非常复杂的数据管理。
- en: Reducer hooks are ideal for managing complex state in your applications. They’re
    a great tool to handle interdependent variables and ensure that invalid state
    configurations aren’t possible.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束钩子是管理你应用程序中复杂状态的理想选择。它们是处理相互依赖变量和确保不可能出现无效状态配置的出色工具。
- en: Reducers are functions that reduce state to a new state based on a given action.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束器是基于给定操作将状态减少到新状态的功能。
- en: Reducers are pure and free of side effects in their nature.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束器在本质上是无副作用的纯函数。
- en: You can create custom hooks to generalize functionality.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以创建自定义钩子来通用化功能。
- en: Custom hooks are often a lot easier to generalize than whole components and
    are often the primary way to share business logic between parts of your application.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义钩子通常比整个组件更容易泛化，并且通常是你在应用程序的不同部分之间共享业务逻辑的主要方式。
- en: You can find a ton of custom hooks online in packages or for simple copy-paste.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在网上找到大量的自定义钩子，它们存在于各种包中，或者可以直接复制粘贴使用。
