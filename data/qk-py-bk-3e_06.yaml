- en: Chapter 5\. Lists, tuples, and sets
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章。列表、元组和集合
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Manipulating lists and list indices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作列表和列表索引
- en: Modifying lists
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改列表
- en: Sorting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序
- en: Using common list operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用常见的列表操作
- en: Handling nested lists and deep copies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理嵌套列表和深拷贝
- en: Using tuples
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元组
- en: Creating and using sets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用集合
- en: 'In this chapter, I discuss the two major Python sequence types: lists and tuples.
    At first, lists may remind you of arrays in many other languages, but don’t be
    fooled: lists are a good deal more flexible and powerful than plain arrays.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我讨论了Python的两种主要序列类型：列表和元组。一开始，列表可能会让你想起许多其他语言中的数组，但不要被误导：列表比普通的数组要灵活和强大得多。
- en: 'Tuples are like lists that can’t be modified; you can think of them as a restricted
    type of list or as a basic record type. I discuss the need for such a restricted
    data type later in the chapter. This chapter also discusses a newer Python collection
    type: sets. Sets are useful when an object’s membership in the collection, as
    opposed to its position, is important'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 元组就像不能修改的列表；你可以把它们看作是列表的一种受限类型或是一种基本记录类型。我在本章后面讨论了这种受限数据类型的需求。本章还讨论了一种较新的Python集合类型：集合。当集合中对象的成员资格（而不是其位置）很重要时，集合很有用。
- en: Most of the chapter is devoted to lists, because if you understand lists, you
    pretty much understand tuples. The last part of the chapter discusses the differences
    between lists and tuples in both functional and design terms.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容都致力于列表，因为如果你理解了列表，你基本上也就理解了元组。本章的最后部分讨论了列表和元组在功能和设计方面的区别。
- en: 5.1\. Lists are like arrays
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1. 列表就像数组
- en: 'A list in Python is much the same thing as an array in Java or C or any other
    language; it’s an ordered collection of objects. You create a list by enclosing
    a comma-separated list of elements in square brackets, like so:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的列表与Java或C或其他语言中的数组几乎相同；它是有序对象集合。你通过将逗号分隔的元素列表括在方括号中来创建列表，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that you don’t have to worry about declaring the list or fixing its size
    ahead of time. This line creates the list as well as assigns it, and a list automatically
    grows or shrinks as needed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不必担心提前声明列表或固定其大小。这一行创建了列表并为其赋值，列表会根据需要自动增长或缩小。
- en: '|  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Arrays in Python**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python中的数组**'
- en: A typed `array` module available in Python provides arrays based on C data types.
    Information on its use can be found in the *Python Library Reference*. I suggest
    that you look into it only if you really need the performance improvement. If
    a situation calls for numerical computations, you should consider using `NumPy`,
    mentioned in [chapter 4](kindle_split_015.html#ch04) and available at [www.scipy.org](http://www.scipy.org).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python中可用的类型化`array`模块基于C数据类型提供数组。有关其使用信息，请参阅*Python库参考*。我建议你只有在真正需要性能提升时才去查看它。如果需要数值计算，你应该考虑使用在第4章中提到的`NumPy`，它可在[www.scipy.org](http://www.scipy.org)找到。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Unlike lists in many other languages, Python lists can contain different types
    of elements; a list element can be any Python object. Here’s a list that contains
    a variety of elements:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他语言中的列表不同，Python列表可以包含不同类型的元素；列表元素可以是任何Python对象。以下是一个包含各种元素的列表：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Probably the most basic built-in list function is the `len` function, which
    returns the number of elements in a list:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最基础的内置列表函数是`len`函数，它返回列表中的元素数量：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the `len` function doesn’t count the items in the inner, nested list.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`len`函数不会计算嵌套列表中的项目。
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: len()'
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：len()
- en: 'What would `len()` return for each of the following`: [0]; []; [[1, 3, [4,
    5], 6], 7]`?'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下每个`len()`会返回什么：`[0]; []; [[1, 3, [4, 5], 6], 7]`？
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 5.2\. List indices
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2. 列表索引
- en: Understanding how list indices work will make Python much more useful to you.
    Please read the whole section!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 理解列表索引的工作方式将使Python对你更有用。请阅读整个章节！
- en: 'Elements can be extracted from a Python list by using a notation like C’s array
    indexing. Like C and many other languages, Python starts counting from 0; asking
    for element 0 returns the first element of the list, asking for element 1 returns
    the second element, and so forth. Here are a few examples:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用类似于C的数组索引的表示法从Python列表中提取元素。像C和许多其他语言一样，Python从0开始计数；请求元素0返回列表的第一个元素，请求元素1返回第二个元素，依此类推。以下是一些示例：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But Python indexing is more flexible than C indexing. If indices are negative
    numbers, they indicate positions counting from the end of the list, with –1 being
    the last position in the list, –2 being the second-to-last position, and so forth.
    Continuing with the same list x, you can do the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但Python的索引比C语言的索引更灵活。如果索引是负数，它们表示从列表末尾开始计数的位置，其中-1是列表中的最后一个位置，-2是倒数第二个位置，依此类推。继续使用相同的列表x，你可以执行以下操作：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For operations involving a single list index, it’s generally satisfactory to
    think of the index as pointing at a particular element in the list. For more advanced
    operations, it’s more correct to think of list indices as indicating positions
    *between* elements. In the list `["first", "second", "third", "fourth"]`, you
    can think of the indices as pointing like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及单个列表索引的操作，通常可以将索引视为指向列表中的特定元素。对于更高级的操作，更正确的方法是将列表索引视为指示元素*之间*的位置。在列表`["first",
    "second", "third", "fourth"]`中，你可以将索引视为如下所示：
- en: '| x =[ |   | "first", |   | "second", |   | "third", |   | "fourth" |   | ]
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| x =[ |   | "first", |   | "second", |   | "third", |   | "fourth" |   | ]
    |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| Positive indices | 0 |   | 1 |   | 2 |   | 3 |   |   |   |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 正数索引 | 0 |   | 1 |   | 2 |   | 3 |   |   |   |'
- en: '| Negative indices | –4 |   | –3 |   | –2 |   | –1 |   |   |   |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 负数索引 | –4 |   | –3 |   | –2 |   | –1 |   |   |   |'
- en: 'This is irrelevant when you’re extracting a single element, but Python can
    extract or assign to an entire sublist at once—an operation known as *slicing*.
    Instead of entering `list[index]` to extract the item just after `index`, enter
    `list[index1:index2]` to extract all items including `index1` and up to (but not
    including) `index2` into a new list. Here are some examples:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你提取单个元素时，这并不相关，但Python可以一次性提取或分配整个子列表——这种操作称为*切片*。要提取`index`之后的项，而不是输入`list[index]`，而是输入`list[index1:index2]`，以将包括`index1`和直到（但不包括）`index2`的所有项提取到一个新列表中。以下是一些示例：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It may seem reasonable that if the second index indicates a position in the
    list *before* the first index, this code would return the elements between those
    indices in reverse order, but this isn’t what happens. Instead, this code returns
    an empty list:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二个索引指示在第一个索引之前的列表中的位置，这似乎是合理的，这段代码应该返回这些索引之间的元素，但事实并非如此。相反，这段代码返回一个空列表：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When slicing a list, it’s also possible to leave out `index1` or `index2`.
    Leaving out `index1` means “Go from the beginning of the list,” and leaving out
    `index2` means “Go to the end of the list”:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当切片列表时，也可以省略`index1`或`index2`。省略`index1`意味着“从列表的开始处开始”，省略`index2`意味着“到列表的末尾”：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Omitting both indices makes a new list that goes from the beginning to the
    end of the original list—that is, copies the list. This technique is useful when
    you want to make a copy that you can modify without affecting the original list:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 省略两个索引将创建一个从列表开始到结束的新列表——即复制列表。当你想创建一个可以修改而不影响原始列表的副本时，这种技术很有用：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: List slices and indexes'
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：列表切片和索引
- en: Using what you know about the `len()` function and list slices, how would you
    combine the two to get the second half of a list when you don’t know what size
    it is? Experiment in the Python shell to confirm that your solution works.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你对`len()`函数和列表切片的了解，你如何将两者结合起来在不知道列表大小的情况下获取列表的后半部分？在Python shell中实验以确认你的解决方案有效。
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.3\. Modifying lists
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 修改列表
- en: 'You can use list index notation to modify a list as well as to extract an element
    from it. Put the index on the left side of the assignment operator:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用列表索引符号来修改列表，以及从中提取元素。将索引放在赋值运算符的左侧：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Slice notation can be used here too. Saying something like `lista[index1:index2]
    = listb` causes all elements of `lista` between `index1` and `index2` to be replaced
    by the elements in `listb`. `listb` can have more or fewer elements than are removed
    from `lista`, in which case the length of `lista` is altered. You can use slice
    assignment to do several things, as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 切片符号也可以在这里使用。例如，`lista[index1:index2] = listb`会导致`lista`在`index1`和`index2`之间的所有元素被`listb`中的元素替换。`listb`可以比从`lista`中移除的元素多或少，在这种情况下，`lista`的长度会改变。你可以使用切片赋值来完成几个操作，如下所示：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Appends list to end of list**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将列表追加到列表末尾**'
- en: '***2* Appends list to front of list**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将列表追加到列表前面**'
- en: '***3* Removes elements from list**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从列表中删除元素**'
- en: 'Appending a single element to a list is such a common operation that there’s
    a special `append` method for it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 向列表中追加单个元素是一个如此常见的操作，以至于有一个特殊的 `append` 方法用于它：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'One problem can occur if you try to append one list to another. The list gets
    appended as a single element of the main list:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将一个列表追加到另一个列表中，可能会出现一个问题。列表被追加为主列表的单个元素：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `extend` method is like the `append` method except that it allows you to
    add one list to another:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`extend` 方法类似于 `append` 方法，但它允许你将一个列表添加到另一个列表中：'
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There’s also a special `insert` method to insert new list elements between
    two existing elements or at the front of the list. `insert` is used as a method
    of lists and takes two additional arguments. The first additional argument is
    the index position in the list where the new element should be inserted, and the
    second is the new element itself:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个特殊的 `insert` 方法，可以在两个现有元素之间或列表开头插入新的列表元素。`insert` 是列表的一个方法，并接受两个额外的参数。第一个额外参数是列表中应插入新元素的位置索引，第二个是新元素本身：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`insert` understands list indices as discussed in [section 5.2](#ch05lev1sec2),
    but for most uses, it’s easiest to think of `list.insert(n, elem)` as meaning
    `insert elem` just before the *n*th element of list. `insert` is just a convenience
    method. Anything that can be done with `insert` can also be done with slice assignment.
    That is, `list.insert(n, elem)` is the same thing as `list[n:n] = [elem]` when
    `n` is nonnegative. Using `insert` makes for somewhat more readable code, and
    `insert` even handles negative indices:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert` 理解列表索引，如 [5.2 节](#ch05lev1sec2) 中所述，但对于大多数用途，将 `list.insert(n, elem)`
    理解为在列表的第 *n* 个元素之前插入 `elem` 更容易。`insert` 只是一个便利方法。任何可以用 `insert` 完成的操作也可以用切片赋值完成。也就是说，当
    `n` 为非负数时，`list.insert(n, elem)` 与 `list[n:n] = [elem]` 是相同的。使用 `insert` 可以使代码更易于阅读，并且
    `insert` 甚至可以处理负索引：'
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `del` statement is the preferred method of deleting list items or slices.
    It doesn’t do anything that can’t be done with slice assignment, but it’s usually
    easier to remember and easier to read:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`del` 语句是删除列表项或切片的首选方法。它执行的操作不能通过切片赋值完成，但它通常更容易记住且更容易阅读：'
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In general, `del list[n]` does the same thing as `list[n:n+1] = []`, whereas
    `del list[m:n]` does the same thing as `list[m:n] = []`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`del list[n]` 与 `list[n:n+1] = []` 做的是同样的事情，而 `del list[m:n]` 与 `list[m:n]
    = []` 做的是同样的事情。
- en: 'The `remove` method isn’t the converse of `insert`. Whereas `insert` inserts
    an element at a specified location, `remove` looks for the first instance of a
    given value in a list and removes that value from the list:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove` 方法不是 `insert` 的逆操作。与 `insert` 在指定位置插入元素不同，`remove` 在列表中查找给定值的第一个实例，并将其从列表中删除：'
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If `remove` can’t find anything to remove, it raises an error. You can catch
    this error by using the exception-handling abilities of Python, or you can avoid
    the problem by using `in` to check for the presence of something in a list before
    attempting to remove it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `remove` 找不到可以删除的内容，它将引发错误。你可以通过使用 Python 的异常处理能力来捕获此错误，或者通过在尝试删除之前使用 `in`
    来检查列表中是否存在某个内容来避免这个问题。
- en: 'The `reverse` method is a more specialized list modification method. It efficiently
    reverses a list in place:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse` 方法是一种更专业的列表修改方法。它有效地原地反转列表：'
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Modifying lists'
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：修改列表
- en: Suppose that you have a list 10 items long. How might you move the last three
    items from the end of the list to the beginning, keeping them in the same order?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含 10 个元素的列表。你如何将列表末尾的最后三个元素移动到列表开头，同时保持它们的顺序？
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 5.4\. Sorting lists
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4. 列表排序
- en: 'Lists can be sorted by using the built-in Python `sort` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以通过使用内置的 Python `sort` 方法进行排序：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This method does an in-place sort—that is, changes the list being sorted. To
    sort a list without changing the original list, you have two options. You can
    use the `sorted()` built-in function, discussed in [section 5.4.2](#ch05lev2sec2),
    or you can make a copy of the list and sort the copy:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法执行原地排序——即改变正在排序的列表。要排序列表而不改变原始列表，你有两种选择。你可以使用在 [5.4.2 节](#ch05lev2sec2) 中讨论的
    `sorted()` 内置函数，或者你可以复制列表并排序副本：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Sorting works with strings, too:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 排序也可以用于字符串：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `sort` method can sort just about anything because Python can compare just
    about anything. But there’s one caveat in sorting: The default key method used
    by `sort` requires all items in the list to be of comparable types. That means
    that using the `sort` method on a list containing both numbers and strings raises
    an exception:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 方法可以排序几乎任何东西，因为 Python 几乎可以比较任何东西。但在排序时有一个注意事项：`sort` 方法默认使用的键方法要求列表中的所有项都必须是可比较的类型。这意味着在包含数字和字符串的列表上使用
    `sort` 方法会引发异常：'
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Conversely, you can sort a list of lists:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以对列表的列表进行排序：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: According to the built-in Python rules for comparing complex objects, the sublists
    are sorted first by ascending first element and then by ascending second element.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 根据内置的 Python 比较复杂对象的规则，子列表首先按升序的第一个元素排序，然后按升序的第二个元素排序。
- en: '`sort` is even more flexible; it has an optional `reverse` parameter that causes
    the sort to be in reverse order when `reverse=True`, and it’s possible to use
    your own key function to determine how elements of a list are sorted.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 更加灵活；它有一个可选的 `reverse` 参数，当 `reverse=True` 时，排序将按逆序进行，并且可以使用你自己的键函数来确定列表元素的排序方式。'
- en: 5.4.1\. Custom sorting
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1\. 自定义排序
- en: To use custom sorting, you need to be able to define functions—something I haven’t
    talked about yet. In this section, I also discuss the fact that `len(string)`
    returns the number of characters in a string. String operations are discussed
    more fully in [chapter 6](kindle_split_017.html#ch06).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用自定义排序，你需要能够定义函数——这是我还没有讨论过的。在本节中，我还讨论了 `len(string)` 返回字符串中字符数的事实。字符串操作在[第
    6 章](kindle_split_017.html#ch06)中进行了更全面的讨论。
- en: By default, `sort` uses built-in Python comparison functions to determine ordering,
    which is satisfactory for most purposes. At times, though, you want to sort a
    list in a way that doesn’t correspond to this default ordering. Suppose that you
    want to sort a list of words by the number of characters in each word, as opposed
    to the lexicographic sort that Python normally carries out.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`sort` 使用内置的 Python 比较函数来确定排序顺序，这对于大多数目的来说都是令人满意的。然而，有时你想要以不对应默认排序的方式对列表进行排序。假设你想要按每个单词中的字符数对单词列表进行排序，而不是
    Python 通常执行的字典序排序。
- en: To do this, write a function that returns the value, or key, that you want to
    sort on, and use it with the `sort` method. That function in the context of `sort`
    is a function that takes one argument and returns the key or value that the `sort`
    function is to use.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，编写一个函数，返回你想要排序的值或键，然后与 `sort` 方法一起使用。在这个 `sort` 的上下文中，这个函数是一个接受一个参数并返回
    `sort` 函数将要使用的键或值的函数。
- en: For number-of-characters ordering, a suitable key function could be
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于按字符数排序，一个合适的键函数可以是
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This key function is trivial. It passes the length of each string back to the
    `sort` method, rather than the strings themselves.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个键函数很简单。它将每个字符串的长度传递回 `sort` 方法，而不是字符串本身。
- en: 'After you define the key function, using it is a matter of passing it to the
    `sort` method by using the `key` keyword. Because functions are Python objects,
    they can be passed around like any other Python objects. Here’s a small program
    that illustrates the difference between a default sort and your custom sort:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了键函数之后，使用它只需通过使用 `key` 关键字将其传递给 `sort` 方法。因为函数是 Python 对象，所以它们可以像任何其他 Python
    对象一样传递。以下是一个小型程序，说明了默认排序和自定义排序之间的区别：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first list is in lexicographical order (with uppercase coming before lowercase),
    and the second list is ordered by ascending number of characters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个列表是按字典序排序的（大写字母在前面），第二个列表是按字符数升序排序的。
- en: Custom sorting is very useful, but if performance is critical, it may be slower
    than the default. Usually, this effect is minimal, but if the key function is
    particularly complex, the effect may be more than desired, especially for sorts
    involving hundreds of thousands or millions of elements.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义排序非常有用，但如果性能至关重要，它可能比默认排序慢。通常，这种影响很小，但如果键函数特别复杂，影响可能会超过预期，尤其是在涉及数十万或数百万个元素的排序中。
- en: One particular place to avoid custom sorts is where you want to sort a list
    in descending, rather than ascending, order. In this case, use the `sort` method’s
    `reverse` parameter set to `True`. If for some reason you don’t want to do that,
    it’s still better to sort the list normally and then use the `reverse` method
    to invert the order of the resulting list. These two operations together—the standard
    sort and the reverse—will still be much faster than a custom sort.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特定的地方应该避免自定义排序，那就是当你想要按降序而不是升序对列表进行排序时。在这种情况下，使用 `sort` 方法的 `reverse` 参数设置为
    `True`。如果出于某种原因你不想这样做，仍然最好正常排序列表，然后使用 `reverse` 方法来反转结果列表的顺序。这两个操作——标准的排序和反转——仍然会比自定义排序快得多。
- en: 5.4.2\. The sorted() function
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2\. sorted() 函数
- en: 'Lists have a built-in method to sort themselves, but other iterables in Python,
    such as the keys of a dictionary, don’t have a `sort` method. Python also has
    the built-in function `sorted()`, which returns a sorted list from any iterable.
    `sorted()` uses the same `key` and `reverse` parameters as the sort method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表有一个内置的方法可以自行排序，但 Python 中的其他可迭代对象，如字典的键，没有 `sort` 方法。Python 还有一个内置函数 `sorted()`，它可以从任何可迭代对象返回一个排序后的列表。`sorted()`
    使用与排序方法相同的 `key` 和 `reverse` 参数：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Sorting lists'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：排序列表
- en: 'Suppose that you have a list in which each element is in turn a list: `[[1,
    2, 3], [2, 1, 3], [4, 0, 1]]`. If you wanted to sort this list by the second element
    in each list so that the result would be `[[4, 0, 1], [2, 1, 3], [1, 2, 3]]`,
    what function would you write to pass as the `key` value to the `sort()` method?'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个列表，其中每个元素本身也是一个列表：`[[1, 2, 3], [2, 1, 3], [4, 0, 1]]`。如果你想要根据每个列表中的第二个元素对这个列表进行排序，使得结果为
    `[[4, 0, 1], [2, 1, 3], [1, 2, 3]]`，你应该编写什么函数作为 `sort()` 方法的 `key` 值？
- en: '|  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.5\. Other common list operations
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5\. 其他常见的列表操作
- en: Several other list methods are frequently useful, but they don’t fall into any
    specific category.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些列表方法经常很有用，但它们不属于任何特定的类别。
- en: 5.5.1\. List membership with the in operator
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.1\. 使用 in 运算符进行列表成员资格
- en: 'It’s easy to test whether a value is in a list by using the `in` operator,
    which returns a Boolean value. You can also use the converse, the `not in` operator:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `in` 运算符很容易测试一个值是否在列表中，它返回一个布尔值。你还可以使用其逆运算符，即 `not in` 运算符：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 5.5.2\. List concatenation with the + operator
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.2\. 使用 + 运算符进行列表连接
- en: 'To create a list by concatenating two existing lists, use the `+` (list concatenation)
    operator, which leaves the argument lists unchanged:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过连接两个现有的列表来创建一个列表，请使用 `+`（列表连接）运算符，该运算符不会改变参数列表：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 5.5.3\. List initialization with the * operator
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.3\. 使用 * 运算符进行列表初始化
- en: 'Use the `*` operator to produce a list of a given size, which is initialized
    to a given value. This operation is a common one for working with large lists
    whose size is known ahead of time. Although you can use `append` to add elements
    and automatically expand the list as needed, you obtain greater efficiency by
    using `*` to correctly size the list at the start of the program. A list that
    doesn’t change in size doesn’t incur any memory reallocation overhead:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `*` 运算符生成一个给定大小的列表，该列表初始化为给定值。对于大小在事先已知的大型列表，这是一个常见的操作。虽然你可以使用 `append` 添加元素并自动扩展列表，但使用
    `*` 在程序开始时正确地设置列表大小可以获得更高的效率。一个大小不变的列表不会产生任何内存重新分配开销：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When used with lists in this manner, * (which in this context is called the
    *list multiplication operator*) replicates the given list the indicated number
    of times and joins all the copies to form a new list. This is the standard Python
    method for defining a list of a given size ahead of time. A list containing a
    single instance of `None` is commonly used in list multiplication, but the list
    can be anything:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当以这种方式与列表一起使用时，*（在这个上下文中称为 *列表乘法运算符*）会根据指示的次数复制给定的列表，并将所有副本连接起来形成一个新的列表。这是在事先定义给定大小的列表的标准
    Python 方法。在列表乘法中，通常使用包含单个实例的 `None` 的列表，但列表可以是任何内容：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 5.5.4\. List minimum or maximum with min and max
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.4\. 使用 min 和 max 进行列表的最小值或最大值
- en: 'You can use `min` and `max` to find the smallest and largest elements in a
    list. You’ll probably use `min` and `max` mostly with numerical lists, but you
    can use them with lists containing any type of element. Trying to find the maximum
    or minimum object in a set of objects of different types causes an error if comparing
    those types doesn’t make sense:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`min`和`max`来找到列表中的最小和最大元素。你可能会主要在数值列表中使用`min`和`max`，但也可以在包含任何类型元素的列表中使用它们。尝试在类型不同的对象集中找到最大或最小对象会导致错误，如果比较这些类型没有意义的话：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 5.5.5\. List search with index
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.5\. 使用索引进行列表搜索
- en: 'If you want to find where in a list a value can be found (rather than wanting
    to know only whether the value is in the list), use the `index` method. This method
    searches through a list looking for a list element equivalent to a given value
    and returns the position of that list element:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要找到值在列表中的位置（而不仅仅是知道值是否在列表中），请使用`index`方法。此方法遍历列表，寻找与给定值相等的列表元素，并返回该列表元素的位置：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Attempting to find the position of an element that doesn’t exist in the list
    raises an error, as shown here. This error can be handled in the same manner as
    the analogous error that can occur with the `remove` method (that is, by testing
    the list with `in` before using `index`).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试查找列表中不存在的元素的位置会引发错误，如下所示。这个错误可以像处理`remove`方法可能发生的类似错误一样进行处理（即在调用`index`之前用`in`测试列表）。
- en: 5.5.6\. List matches with count
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.6\. 使用count进行列表匹配
- en: '`count` also searches through a list, looking for a given value, but it returns
    the number of times that the value is found in the list rather than positional
    information:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`也会遍历列表，寻找给定的值，但它返回值在列表中出现的次数，而不是位置信息：'
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 5.5.7\. Summary of list operations
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.7\. 列表操作总结
- en: You can see that lists are very powerful data structures, with possibilities
    that go far beyond those of plain old arrays. List operations are so important
    in Python programming that it’s worth laying them out for easy reference, as shown
    in [table 5.1](#ch05table01).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到列表是非常强大的数据结构，其功能远超普通数组。列表操作在Python编程中非常重要，因此值得列出以便于参考，如[表5.1](#ch05table01)所示。
- en: Table 5.1\. List operations
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.1\. 列表操作
- en: '| List operation | Explanation | Example |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 列表操作 | 说明 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| [] | Creates an empty list | x = [] |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| [] | 创建一个空列表 | x = [] |'
- en: '| len | Returns the length of a list | len(x) |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| len | 返回列表的长度 | len(x) |'
- en: '| append | Adds a single element to the end of a list | x.append(''y'') |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| append | 将单个元素添加到列表的末尾 | x.append(''y'') |'
- en: '| extend | Adds another list to the end of the list | x.extend([''a'', ''b''])
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| extend | 将另一个列表添加到列表的末尾 | x.extend([''a'', ''b'']) |'
- en: '| insert | Inserts a new element at a given position in the list | x.insert(0,
    ''y'') |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| insert | 在列表的指定位置插入新元素 | x.insert(0, ''y'') |'
- en: '| del | Removes a list element or slice | del(x[0]) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| del | 删除列表元素或切片 | del(x[0]) |'
- en: '| remove | Searches for and removes a given value from a list | x.remove(''y'')
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| remove | 在列表中搜索并删除指定的值 | x.remove(''y'') |'
- en: '| reverse | Reverses a list in place | x.reverse() |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| reverse | 在原地对列表进行反转 | x.reverse() |'
- en: '| sort | Sorts a list in place | x.sort() |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| sort | 在原地对列表进行排序 | x.sort() |'
- en: '| + | Adds two lists together | x1 + x2 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| + | 将两个列表相加 | x1 + x2 |'
- en: '| * | Replicates a list | x = [''y''] * 3 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| * | 复制列表 | x = [''y''] * 3 |'
- en: '| min | Returns the smallest element in a list | min(x) |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| min | 返回列表中的最小元素 | min(x) |'
- en: '| max | Returns the largest element in a list | max(x) |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| max | 返回列表中的最大元素 | max(x) |'
- en: '| index | Returns the position of a value in a list | x.index[''y''] |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| index | 返回值在列表中的位置 | x.index[''y''] |'
- en: '| count | Counts the number of times a value occurs in a list | x.count(''y'')
    |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| count | 计算列表中值出现的次数 | x.count(''y'') |'
- en: '| sum | Sums the items (if they can be summed) | sum(x) |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| sum | 对项目进行求和（如果可以求和） | sum(x) |'
- en: '| in | Returns whether an item is in a list | ''y'' in x |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| in | 返回一个项目是否在列表中 | ''y'' in x |'
- en: Being familiar with these list operations will make your life as a Python coder
    much easier.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉这些列表操作将使你的Python编程生活更加轻松。
- en: '|  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: List Operations'
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：列表操作
- en: What would be the result of len([[1,2]] * 3)?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`len([[1,2]] * 3)`的结果会是什么？'
- en: What are two differences between using the `in` operator and a list’s `index()`
    method?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`in`运算符和列表的`index()`方法之间有什么两个区别？
- en: 'Which of the following will raise an exception?: `min(["a", "b", "c"])`; `max([1,
    2, "three"])`; `[1, 2, 3].count("one")`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个会引发异常？：`min(["a", "b", "c"])`; `max([1, 2, "three"])`; `[1, 2, 3].count("one")`
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: List operations'
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：列表操作
- en: If you have a list `x`, write the code to safely remove an item if—and only
    if—that value is in the list.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个列表 `x`，编写代码以安全地删除一个项目，仅当该值在列表中时。
- en: Modify that code to remove the element only if the item occurs in the list more
    than once.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 修改此代码，仅当项目在列表中多次出现时才删除该元素。
- en: '|  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 5.6\. Nested lists and deep copies
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6. 嵌套列表和深拷贝
- en: This section covers another advanced topic that you may want to skip if you’re
    just learning the language.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了一个你可能想要跳过的更高级的话题，如果你只是刚开始学习这门语言。
- en: 'Lists can be nested. One application of nesting is to represent two-dimensional
    matrices. The members of these matrices can be referred to by using two-dimensional
    indices. Indices for these matrices work as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以嵌套。嵌套的一个应用是表示二维矩阵。这些矩阵的成员可以通过使用二维索引来引用。这些矩阵的索引工作如下：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This mechanism scales to higher dimensions in the manner you’d expect.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此机制可以扩展到更高维度，正如你所期望的那样。
- en: 'Most of the time, this is all you need to concern yourself with. But you may
    run into an issue with nested lists; specifically the way that variables refer
    to objects and how some objects (such as lists) can be modified (are mutable).
    An example is the best way to illustrate:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你只需要关注这些。但你可能会遇到嵌套列表的问题；特别是变量引用对象的方式以及某些对象（如列表）可以被修改（是可变的）。以下是一个示例：
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[Figure 5.1](#ch05fig01) shows what this example looks like.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.1](#ch05fig01) 展示了此示例的外观。'
- en: Figure 5.1\. A list with its first item referring to a nested list
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1. 一个列表，其第一个元素引用一个嵌套列表
- en: '![](images/05fig01.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](images/05fig01.jpg)'
- en: 'Now the value in the nested list can be changed by using either the nested
    or the original variables:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过嵌套变量或原始变量来更改嵌套列表中的值：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'But if `nested` is set to another list, the connection between them is broken:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果 `nested` 设置为另一个列表，它们之间的连接就会断开：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[Figure 5.2](#ch05fig02) illustrates this condition.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.2](#ch05fig02) 阐述了此条件。'
- en: Figure 5.2\. The first item of the original list is still a nested list, but
    the nested variable refers to a different list.
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2. 原始列表的第一个元素仍然是一个嵌套列表，但嵌套变量引用的是不同的列表。
- en: '![](images/05fig02.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](images/05fig02.jpg)'
- en: 'You’ve seen that you can obtain a copy of a list by taking a full slice (that
    is, `x[:]`). You can also obtain a copy of a list by using the `+` or * operator
    (for example, `x + []` or `x * 1`). These techniques are slightly less efficient
    than the slice method. All three create what is called a *shallow* copy of the
    list, which is probably what you want most of the time. But if your list has other
    lists nested in it, you may want to make a *deep* copy. You can do this with the
    `deepcopy` function of the `copy` module:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，你可以通过取完整切片（即 `x[:]`）来获取列表的副本。你还可以通过使用 `+` 或 * 运算符（例如，`x + []` 或 `x * 1`）来获取列表的副本。这些技术比切片方法稍微低效一些。所有三种方法都创建了一个称为
    *浅拷贝* 的列表副本，这可能是你大多数时候想要的结果。但如果你的列表中嵌套了其他列表，你可能想要创建一个 *深拷贝*。你可以使用 `copy` 模块的 `deepcopy`
    函数来完成此操作：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See [figure 5.3](#ch05fig03) for an illustration.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 见 [图5.3](#ch05fig03) 以了解说明。
- en: Figure 5.3\. A shallow copy doesn’t copy nested lists.
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3. 浅拷贝不会复制嵌套列表。
- en: '![](images/05fig03.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](images/05fig03.jpg)'
- en: 'The lists pointed at by the original or shallow variables are connected. Changing
    the value in the nested list through either one of them affects the other:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 原始或浅拷贝变量指向的列表是相连的。通过其中任何一个修改嵌套列表中的值都会影响另一个：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The deep copy is independent of the original, and no change to it has any effect
    on the original list:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 深拷贝与原始对象独立，对其的任何更改都不会影响原始列表：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This behavior is the same for any other nested objects in a list that are modifiable
    (such as dictionaries).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为适用于任何其他可修改的嵌套对象（如字典）列表。
- en: Now that you’ve seen what lists can do, it’s time to look at tuples.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了列表能做什么，是时候看看元组了。
- en: '|  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: List copies'
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：列表副本
- en: 'Suppose that you have the following list: `x = [[1, 2, 3], [4, 5, 6], [7, 8,
    9]]` What code could you use to get a copy `y` of that list in which you could
    change the elements *without* the side effect of changing the contents of `x`?'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个以下列表：`x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]` 你可以使用什么代码来获取该列表的副本 `y`，其中你可以更改元素，而不会影响
    `x` 的内容？
- en: '|  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 5.7\. Tuples
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7. 元组
- en: '*Tuples* are data structures that are very similar to lists, but they can’t
    be modified; they can only be created. Tuples are so much like lists that you
    may wonder why Python bothers to include them. The reason is that tuples have
    important roles that can’t be efficiently filled by lists, such as keys for dictionaries.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组*是类似于列表的数据结构，但它们不能被修改；它们只能被创建。元组和列表如此相似，你可能想知道为什么Python要费力包含它们。原因在于元组有重要的角色，这些角色不能由列表有效地填充，例如作为字典的键。'
- en: 5.7.1\. Tuple basics
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.1\. 元组基础
- en: 'Creating a tuple is similar to creating a list: assign a sequence of values
    to a variable. A list is a sequence that’s enclosed by `[` and `]`; a tuple is
    a sequence that’s enclosed by `(` and `)`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 创建元组与创建列表类似：将一系列值分配给变量。列表是一个由`[`和`]`包围的序列；元组是一个由`(`和`)`包围的序列：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This line creates a three-element tuple.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码创建了一个包含三个元素的元组。
- en: 'After a tuple is created, using it is so much like using a list that it’s easy
    to forget that tuples and lists are different data types:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 元组创建后，使用它就像使用列表一样，很容易忘记元组和列表是不同的数据类型：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The main difference between tuples and lists is that tuples are immutable.
    An attempt to modify a tuple results in a confusing error message, which is Python’s
    way of saying that it doesn’t know how to set an item in a tuple:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 元组和列表之间的主要区别是元组是不可变的。尝试修改元组会导致一个令人困惑的错误信息，这是Python表示它不知道如何在元组中设置项的方式：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can create tuples from existing ones by using the `+` and `*` operators:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`+`和`*`运算符从现有的元组中创建新的元组：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A copy of a tuple can be made in any of the same ways as for lists:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的副本可以通过与列表相同的方式创建：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you didn’t read [section 5.6](#ch05lev1sec6), you can skip the rest of this
    paragraph. Tuples themselves can’t be modified. But if they contain any mutable
    objects (for example, lists or dictionaries), these objects may be changed if
    they’re still assigned to their own variables. Tuples that contain mutable objects
    aren’t allowed as keys for dictionaries.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有阅读[第5.6节](#ch05lev1sec6)，你可以跳过本段落的其余部分。元组本身不能被修改。但如果它们包含任何可变对象（例如，列表或字典），这些对象如果仍然分配给它们自己的变量，可能会被更改。包含可变对象的元组不允许作为字典的键。
- en: 5.7.2\. One-element tuples need a comma
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.2\. 单元素元组需要逗号
- en: A small syntactical point is associated with using tuples. Because the square
    brackets used to enclose a list aren’t used elsewhere in Python, it’s clear that
    `[]` means an empty list and that `[1]` means a list with one element. The same
    thing isn’t true of the parentheses used to enclose tuples. Parentheses can also
    be used to group items in expressions to force a certain evaluation order. If
    you say `(x + y)` in a Python program, do you mean that `x` and `y` should be
    added and then put into a one-element tuple, or do you mean that the parentheses
    should be used to force `x` and `y` to be added before any expressions to either
    side come into play?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元组有一个小的语法点。因为用于包围列表的方括号在Python的其他地方没有使用，所以`[]`表示一个空列表，而`[1]`表示一个只有一个元素的列表。对于用于包围元组的括号来说，情况并非如此。括号也可以用于在表达式中分组项，以强制执行特定的评估顺序。如果你在Python程序中写下`(x
    + y)`，你是想表示`x`和`y`应该相加然后放入一个只有一个元素的元组中，还是你想使用括号来强制`x`和`y`在任一侧的表达式发挥作用之前先相加？
- en: 'This situation is a problem only for tuples with one element, because tuples
    with more than one element always include commas to separate the elements, and
    the commas tell Python that the parentheses indicate a tuple, not a grouping.
    In the case of one-element tuples, Python requires that the element in the tuple
    be followed by a comma, to disambiguate the situation. In the case of zero-element
    (empty) tuples, there’s no problem. An empty set of parentheses must be a tuple
    because it’s meaningless otherwise:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况只对只有一个元素的元组有问题，因为包含多个元素的元组总是包含逗号来分隔元素，而逗号告诉Python括号表示一个元组，而不是分组。对于只有一个元素的元组，Python要求元组中的元素后面跟着一个逗号，以消除歧义。对于零元素（空）元组，没有问题。一个空括号集合必须是一个元组，因为否则它没有意义：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 5.7.3\. Packing and unpacking tuples
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.3\. 元组的打包和解包
- en: 'As a convenience, Python permits tuples to appear on the left side of an assignment
    operator, in which case variables in the tuple receive the corresponding values
    from the tuple on the right side of the assignment operator. Here’s a simple example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，Python允许元组出现在赋值运算符的左侧，在这种情况下，元组中的变量会从赋值运算符右侧的元组中接收相应的值。这里有一个简单的例子：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This example can be written even more simply, because Python recognizes tuples
    in an assignment context even without the enclosing parentheses. The values on
    the right side are packed into a tuple and then unpacked into the variables on
    the left side:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以写得更加简单，因为Python在赋值上下文中甚至没有括号也能识别元组。右侧的值被打包到一个元组中，然后解包到左侧的变量中：
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'One line of code has replaced the following four lines of code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一行代码替换了以下四行代码：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This technique is a convenient way to swap values between variables. Instead
    of saying
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术是交换变量之间值的一种方便方式。而不是说
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: simply say
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To make things even more convenient, Python 3 has an extended unpacking feature,
    allowing an element marked with `*` to absorb any number of elements not matching
    the other elements. Again, some examples make this feature clearer:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更加方便，Python 3有一个扩展的解包功能，允许用`*`标记的元素吸收任何数量的不匹配其他元素的元素。再次，一些例子可以使这个特性更清晰：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that the starred element receives all the surplus items as a list and that
    if there are no surplus elements, the starred element receives an empty list.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，带星号的元素接收所有剩余的项目作为一个列表，如果没有剩余元素，带星号的元素接收一个空列表。
- en: 'Packing and unpacking can also be performed by using list delimiters:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 打包和解包也可以通过使用列表分隔符来完成：
- en: '[PRE53]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 5.7.4\. Converting between lists and tuples
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.4. 在列表和元组之间转换
- en: 'Tuples can be easily converted to lists with the `list` function, which takes
    any sequence as an argument and produces a new list with the same elements as
    the original sequence. Similarly, lists can be converted to tuples with the `tuple`
    function, which does the same thing but produces a new tuple instead of a new
    list:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 元组可以很容易地通过`list`函数转换为列表，该函数接受任何序列作为参数，并产生一个与原始序列具有相同元素的新列表。同样，列表可以通过`tuple`函数转换为元组，该函数执行相同的事情，但产生一个新的元组而不是新的列表：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As an interesting side note, `list` is a convenient way to break a string into
    characters:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 作为有趣的一笔，`list`是分割字符串为字符的方便方式：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This technique works because `list` (and `tuple`) apply to any Python sequence,
    and a string is just a sequence of characters. (Strings are discussed fully in
    [chapter 6](kindle_split_017.html#ch06).)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术之所以有效，是因为`list`（以及`tuple`）适用于任何Python序列，而字符串只是字符序列的集合。（字符串将在[第6章](kindle_split_017.html#ch06)中详细讨论。）
- en: '|  |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Tuples'
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：元组
- en: Explain why the following operations aren’t legal for the tuple `x = (1, 2,
    3, 4):`
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 解释为什么以下操作对于元组`x = (1, 2, 3, 4)`是不合法的：
- en: '[PRE56]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If you had a tuple `x = (3, 1, 4, 2)`, how might you end up with `x` sorted?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个元组`x = (3, 1, 4, 2)`，您如何将其排序？
- en: '|  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.8\. Sets
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8. 集合
- en: A *set* in Python is an unordered collection of objects used when membership
    and uniqueness in the set are main things you need to know about that object.
    Like dictionary keys (discussed in [chapter 7](kindle_split_018.html#ch07)), the
    items in a set must be immutable and hashable. This means that ints, floats, strings,
    and tuples can be members of a set, but lists, dictionaries, and sets themselves
    can’t.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的*集合*是一个无序的对象集合，当您需要了解该对象在集合中的成员资格和唯一性时使用。像字典键（在第7章中讨论过）一样，集合中的项目必须是不可变的且可哈希的。这意味着整数、浮点数、字符串和元组可以是集合的成员，但列表、字典和集合本身不能。
- en: 5.8.1\. Set operations
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.8.1. 集合操作
- en: 'In addition to the operations that apply to collections in general, such as
    `in`, `len`, and iteration in `for` loops, sets have several set-specific operations:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 除了适用于集合的一般操作，如`in`、`len`和`for`循环中的迭代外，集合还有几个特定的集合操作：
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can create a set by using `set` on a sequence, such as a list ***1***. When
    a sequence is made into a set, duplicates are removed ***2***. After creating
    a set by using the `set` function, you can use `add` ***3*** and `remove` ***4***
    to change the elements in the set. The `in` keyword is used to check for membership
    of an object in a set ***5***. You can also use `|` ***6*** to get the union,
    or combination, of two sets, `&` to get their intersection ***7***, and `^` ***8***
    to find their symmetric difference—that is, elements that are in one set or the
    other but not both.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`set`在序列上创建一个集合，例如一个列表 ***1***。当将序列转换为集合时，会删除重复项 ***2***。使用`set`函数创建集合后，您可以使用`add`
    ***3*** 和`remove` ***4*** 来更改集合中的元素。`in`关键字用于检查对象在集合中的成员资格 ***5***。您还可以使用`|` ***6***
    来获取两个集合的并集，或组合，使用`&` ***7*** 来获取它们的交集，使用`^` ***8*** 来找到它们的对称差——即在一个集合中或在另一个集合中但不在两个集合中的元素。
- en: These examples aren’t a complete listing of set operations but are enough to
    give you a good idea of how sets work. For more information, refer to the official
    Python documentation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例并不是集合操作的完整列表，但足以让你对集合的工作方式有一个良好的了解。更多信息，请参考官方Python文档。
- en: 5.8.2\. Frozensets
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.8.2. Frozensets
- en: 'Because sets aren’t immutable and hashable, they can’t belong to other sets.
    To remedy that situation, Python has another set type, `frozenset`, which is just
    like a set but can’t be changed after creation. Because frozensets are immutable
    and hashable, they can be members of other sets:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因为集合不是不可变的且不可哈希的，所以它们不能属于其他集合。为了解决这个问题，Python有另一种集合类型，`frozenset`，它就像一个集合，但在创建后不能被更改。因为frozensets是不可变的且可哈希的，所以它们可以是其他集合的成员：
- en: '[PRE58]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '|  |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Sets'
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：集合
- en: 'If you were to construct a set from the following list, how many elements would
    the set have?: `[1, 2, 5, 1, 0, 2, 3, 1, 1, (1, 2, 3)]`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从以下列表中构建一个集合，这个集合将有多少个元素？：`[1, 2, 5, 1, 0, 2, 3, 1, 1, (1, 2, 3)]`
- en: '|  |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lab 5: Examining a List'
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 'Lab 5: 检查列表'
- en: 'In this lab, the task is to read a set of temperature data (the monthly high
    temperatures at Heathrow Airport for 1948 through 2016) from a file and then find
    some basic information: the highest and lowest temperatures, the mean (average)
    temperature, and the median temperature (the temperature in the middle if all
    the temperatures are sorted).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，任务是读取一组温度数据（1948年至2016年希思罗机场的月最高温度）从文件中，然后找到一些基本信息：最高和最低温度，平均（平均）温度，以及中位温度（如果所有温度都已排序，则位于中间的温度）。
- en: 'The temperature data is in the file lab_05.txt in the source code directory
    for this chapter. Because I haven’t yet discussed reading files, here’s the code
    to read the files into a list:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 温度数据位于本章源代码目录中的`lab_05.txt`文件中。因为我还没有讨论读取文件，所以这里提供了将文件读入列表的代码：
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You should find the highest and lowest temperature, the average, and the median.
    You’ll probably want to use the `min(), max(), sum(), len(),` and `sort()` functions/methods.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该找到最高和最低温度，平均值，以及中位数。你可能需要使用`min()`、`max()`、`sum()`、`len()`和`sort()`函数/方法。
- en: '|  |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Bonus
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 奖励
- en: Determine how many unique temperatures are in the list.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 确定列表中有多少个独特的温度。
- en: '|  |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Lists and tuples are structures that embody the idea of a sequence of elements,
    as are strings.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表和元组是体现元素序列概念的构造，就像字符串一样。
- en: Lists are like arrays in other languages, but with automatic resizing, slice
    notation, and many convenience functions.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表在其他语言中类似于数组，但具有自动调整大小、切片表示法和许多便利函数。
- en: Tuples are like lists but can’t be modified, so they use less memory and can
    be dictionary keys (see [chapter 7](kindle_split_018.html#ch07)).
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组就像列表，但不能修改，所以它们使用更少的内存，并且可以作为字典键（参见第7章[chapter 7](kindle_split_018.html#ch07)）。
- en: Sets are iterable collections, but they’re unordered and can’t have duplicate
    elements.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合是可迭代的集合，但它们是无序的，不能有重复的元素。
