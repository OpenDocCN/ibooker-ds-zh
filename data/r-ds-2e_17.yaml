- en: Chapter 14\. Strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。字符串
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: So far, you’ve used a bunch of strings without learning much about the details.
    Now it’s time to dive into them, learn what makes strings tick, and master some
    of the powerful string manipulation tools you have at your disposal.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经使用了大量的字符串，但没有学到太多细节。现在是时候深入研究它们，了解字符串的工作原理，并掌握一些强大的字符串操作工具了。
- en: 'We’ll begin with the details of creating strings and character vectors. You’ll
    then dive into creating strings from data, then the opposite: extracting strings
    from data. We’ll then discuss tools that work with individual letters. The chapter
    finishes with functions that work with individual letters and a brief discussion
    of where your expectations from English might steer you wrong when working with
    other languages.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建字符串和字符向量的详细信息开始。然后，你将深入学习如何从数据创建字符串，然后是相反操作：从数据中提取字符串。然后我们将讨论处理单个字母的工具。本章最后讨论处理单个字母的函数，并简要讨论在处理其他语言时，你对英语的期望可能会导致错误。
- en: We’ll keep working with strings in the next chapter, where you’ll learn more
    about the power of regular expressions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章继续使用字符串，您将更多地了解正则表达式的威力。
- en: Prerequisites
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: In this chapter, we’ll use functions from the stringr package, which is part
    of the core tidyverse. We’ll also use the babynames data since it provides some
    fun strings to manipulate.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用stringr包中的函数，这是核心tidyverse的一部分。我们还将使用babynames数据，因为它提供了一些有趣的字符串来操作。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can quickly tell when you’re using a stringr function because all stringr
    functions start with `str_`. This is particularly useful if you use RStudio because
    typing `str_` will trigger autocomplete, allowing you to jog your memory of the
    available functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以快速判断你是否在使用stringr函数，因为所有的stringr函数都以`str_`开头。如果你使用RStudio的话，这特别有用，因为输入`str_`将会触发自动完成，让你能够回忆起可用函数。
- en: '![str_c typed into the RStudio console with the autocomplete tooltip shown
    on top, which lists functions beginning with str_c. The function signature and
    beginning of the main page for the highlighted function from the autocomplete
    list are shown in a panel to its right.](assets/rds2_14in01.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![在RStudio控制台中键入str_c并显示自动完成提示，提示显示以str_c开头的函数列表。右侧面板显示了自动完成列表中突出显示的函数的函数签名和主页面的开头。](assets/rds2_14in01.png)'
- en: Creating a String
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建字符串
- en: We created strings in passing earlier in the book but didn’t discuss the details.
    First, you can create a string using either single quotes (`'`) or double quotes
    (`"`). There’s no difference in behavior between the two, so in the interest of
    consistency, the [tidyverse style guide](https://oreil.ly/_zF3d) recommends using
    `"`, unless the string contains multiple `"`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的早些时候就创建了字符串，但没有讨论细节。首先，你可以使用单引号(`'`)或双引号(`"`)来创建字符串。两者之间在行为上没有区别，因此为了一致性起见，[tidyverse风格指南](https://oreil.ly/_zF3d)建议使用`"`，除非字符串包含多个`"`。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you forget to close a quote, you’ll see `+`, the continuation prompt:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记关闭引号，你将看到`+`，即续行提示：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If this happens to you and you can’t figure out which quote to close, press
    Escape to cancel and try again.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，你无法确定哪个引号是要关闭的，请按Escape键取消然后重试。
- en: Escapes
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转义字符
- en: 'To include a literal single or double quote in a string, you can use `\` to
    “escape” it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要在字符串中包含字面的单引号或双引号，你可以使用`\`来“转义”它：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So if you want to include a literal backslash in your string, you’ll need to
    escape it: `"\\"`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你想在字符串中包含字面的反斜杠，你需要转义它：`"\\"`：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Beware that the printed representation of a string is not the same as the string
    itself because the printed representation shows the escapes (in other words, when
    you print a string, you can copy and paste the output to re-create that string).
    To see the raw contents of the string, use [`str_view()`](https://stringr.tidyverse.org/reference/str_view.xhtml):^([1](ch14.xhtml#idm44771296672656))
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字符串的打印表示与字符串本身不同，因为打印表示会显示转义（换句话说，当你打印一个字符串时，你可以复制并粘贴输出来重新创建该字符串）。要查看字符串的原始内容，请使用[`str_view()`](https://stringr.tidyverse.org/reference/str_view.xhtml):^([1](ch14.xhtml#idm44771296672656))
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Raw Strings
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始字符串
- en: 'Creating a string with multiple quotes or backslashes gets confusing quickly.
    To illustrate the problem, let’s create a string that contains the contents of
    the code block where we define the `double_quote` and `single_quote` variables:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含多个引号或反斜杠的字符串会很快令人困惑。为了说明这个问题，让我们创建一个包含代码块内容的字符串，其中定义了`double_quote`和`single_quote`变量：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That’s a lot of backslashes! (This is sometimes called [leaning toothpick syndrome](https://oreil.ly/Fs-YL).)
    To eliminate the escaping, you can instead use a *raw string*:^([2](ch14.xhtml#idm44771296567072))
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那是很多反斜杠！（有时这被称为[倾斜牙签综合症](https://oreil.ly/Fs-YL)。）为了消除转义，您可以使用*原始字符串*代替：^([2](ch14.xhtml#idm44771296567072))
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A raw string usually starts with `r"(` and finishes with `)"`. But if your string
    contains `)"`, you can instead use `r"[]"` or `r"{}"`, and if that’s still not
    enough, you can insert any number of dashes to make the opening and closing pairs
    unique, e.g., `` `r"--()--" ``, `` `r"---()---" ``, etc. Raw strings are flexible
    enough to handle any text.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串通常以`r"(`开始，以`)"`结束。但是，如果您的字符串包含`)"`，则可以使用`r"[]"`或`r"{}"`，如果这仍然不够，可以插入任意数量的破折号使开放和关闭对成对唯一，例如，``
    `r"--()--" ``, `` `r"---()---" ``, 等等。原始字符串足够灵活，可以处理任何文本。
- en: Other Special Characters
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他特殊字符
- en: As well as `\"`, `\'`, and `\\`, there are a handful of other special characters
    that may come in handy. The most common are `\n`, a new line, and `\t`, tab. You’ll
    also sometimes see strings containing Unicode escapes that start with `\u` or
    `\U`. This is a way of writing non-English characters that work on all systems.
    You can see the complete list of other special characters in [`?Quotes`](https://rdrr.io/r/base/Quotes.xhtml).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`\\"`、`\\'`和`\\\\`之外，还有一些其他可能会派上用场的特殊字符。最常见的是`\n`，表示换行，以及`\t`，表示制表符。有时您还会看到包含以`\u`或`\U`开头的Unicode转义序列的字符串。这是一种在所有系统上都能工作的写非英文字符的方式。您可以在[`“引用”`](https://rdrr.io/r/base/Quotes.xhtml)中查看其他特殊字符的完整列表。
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that [`str_view()`](https://stringr.tidyverse.org/reference/str_view.xhtml)
    uses a blue background for tabs to make them easier to spot. One of the challenges
    of working with text is that there’s a variety of ways that whitespace can end
    up in the text, so this background helps you recognize that something strange
    is going on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[`str_view()`](https://stringr.tidyverse.org/reference/str_view.xhtml)使用蓝色背景来突出显示制表符，以便更容易发现它们。处理文本的一个挑战是文本中可能存在各种空白字符，因此这种背景帮助您识别出正在发生某些奇怪的事情。
- en: Exercises
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Create strings that contain the following values:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含以下值的字符串：
- en: '`He said "That''s amazing!"`'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`他说：“那太神奇了！”`'
- en: '`\a\b\c\d`'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\a\b\c\d`'
- en: '`\\\\\\`'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\\\\\\`'
- en: Create the following string in your R session and print it. What happens to
    the special “\u00a0”? How does [`str_view()`](https://stringr.tidyverse.org/reference/str_view.xhtml)
    display it? Can you do a little Googling to figure out what this special character
    is?
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的R会话中创建以下字符串并打印它。特殊字符`\u00a0`会发生什么？[`str_view()`](https://stringr.tidyverse.org/reference/str_view.xhtml)如何显示它？您能查找一下这个特殊字符是什么吗？
- en: '[PRE9]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating Many Strings from Data
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据创建多个字符串
- en: Now that you’ve learned the basics of creating a string or two by “hand,” we’ll
    go into the details of creating strings from other strings. This will help you
    solve the common problem where you have some text you wrote that you want to combine
    with strings from a data frame. For example, you might combine “Hello” with a
    `name` variable to create a greeting. We’ll show you how to do this with [`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml)
    and [`str_glue()`](https://stringr.tidyverse.org/reference/str_glue.xhtml) and
    how you can use them with [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml).
    That naturally raises the question of what stringr functions you might use with
    [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml), so we’ll
    finish this section with a discussion of [`str_flatten()`](https://stringr.tidyverse.org/reference/str_flatten.xhtml),
    which is a summary function for strings.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了手工创建一个或两个字符串的基础知识，我们将详细介绍如何从其他字符串创建字符串。这将帮助您解决一个常见问题，即您有一些您编写的文本，希望将其与数据帧中的字符串结合起来。例如，您可以将“Hello”与`name`变量结合起来创建一个问候语。我们将展示您如何使用[`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml)和[`str_glue()`](https://stringr.tidyverse.org/reference/str_glue.xhtml)，以及如何将它们与[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)一起使用。这自然引出了您可能与[`summarise()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)一起使用的stringr函数的问题，因此我们将在本节结束时讨论[`str_flatten()`](https://stringr.tidyverse.org/reference/str_flatten.xhtml)，这是字符串的汇总函数。
- en: str_c()
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: str_c()
- en: '[`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml) takes any
    number of vectors as arguments and returns a character vector:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml)接受任意数量的向量作为参数，并返回一个字符向量：'
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml) is similar
    to the base [`paste0()`](https://rdrr.io/r/base/paste.xhtml) but is designed to
    be used with [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)
    by obeying the usual tidyverse rules for recycling and propagating missing values:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml) 类似于基础的 [`paste0()`](https://rdrr.io/r/base/paste.xhtml)，但设计用于与
    [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml) 结合使用，遵循通常的 tidyverse
    规则进行循环使用和传播缺失值：'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you want missing values to display in another way, use [`coalesce()`](https://dplyr.tidyverse.org/reference/coalesce.xhtml)
    to replace them. Depending on what you want, you might use it either inside or
    outside of [`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望以另一种方式显示缺失值，请使用 [`coalesce()`](https://dplyr.tidyverse.org/reference/coalesce.xhtml)
    进行替换。根据你的需求，你可以将它用在 [`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml)
    的内部或外部：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: str_glue()
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`str_glue()`'
- en: 'If you are mixing many fixed and variable strings with [`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml),
    you’ll notice that you type a lot of `"`s, making it hard to see the overall goal
    of the code. An alternative approach is provided by the [glue package](https://oreil.ly/NHBNe)
    via [`str_glue()`](https://stringr.tidyverse.org/reference/str_glue.xhtml).^([3](ch14.xhtml#idm44771296183072))
    You give it a single string that has a special feature: anything inside [`{}`](https://rdrr.io/r/base/Paren.xhtml)
    will be evaluated like it’s outside of the quotes:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用 [`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml) 混合许多固定和变量字符串时，会发现你需要输入许多
    `"`，这使得难以看到代码的整体目标。一个替代方法由 [glue 包](https://oreil.ly/NHBNe) 提供，通过 [`str_glue()`](https://stringr.tidyverse.org/reference/str_glue.xhtml)。^([3](ch14.xhtml#idm44771296183072))
    你只需提供一个具有特殊特性的单个字符串：任何在 [`{}`](https://rdrr.io/r/base/Paren.xhtml) 内的内容将会被评估，就像在引号外一样：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, [`str_glue()`](https://stringr.tidyverse.org/reference/str_glue.xhtml)
    currently converts missing values to the string `"NA"`, unfortunately making it
    inconsistent with [`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，[`str_glue()`](https://stringr.tidyverse.org/reference/str_glue.xhtml)
    目前将缺失值转换为字符串 `"NA"`，这使其与 [`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml)
    不一致，遗憾的是：
- en: 'You also might wonder what happens if you need to include a regular `{` or
    `}` in your string. You’re on the right track if you guess you’ll need to escape
    it somehow. The trick is that glue uses a slightly different escaping technique:
    instead of prefixing with a special character like `\`, you double up the special
    characters:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会想知道，如果需要在字符串中包含普通的 `{` 或 `}` 会发生什么。如果你猜想需要以某种方式转义它们，你是对的。诀窍在于 glue 使用略有不同的转义技术：你需要将特殊字符连续双写：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: str_flatten()
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`str_flatten()`'
- en: '[`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml) and [`str_glue()`](https://stringr.tidyverse.org/reference/str_glue.xhtml)
    work well with [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)
    because their output is the same length as their inputs. What if you want a function
    that works well with [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml),
    i.e., something that always returns a single string? That’s the job of [`str_flatten()`](https://stringr.tidyverse.org/reference/str_flatten.xhtml):^([4](ch14.xhtml#idm44771296091984))
    it takes a character vector and combines each element of the vector into a single
    string:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml) 和 [`str_glue()`](https://stringr.tidyverse.org/reference/str_glue.xhtml)
    与 [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml) 结合使用效果很好，因为它们的输出与它们的输入长度相同。如果你想要一个能够与
    [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml) 很好地配合的函数，即始终返回单个字符串的函数，那就是
    [`str_flatten()`](https://stringr.tidyverse.org/reference/str_flatten.xhtml)：^([4](ch14.xhtml#idm44771296091984))
    它接受一个字符向量，并将向量的每个元素组合成单个字符串：'
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This makes it work well with [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得它与 [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)
    很好地配合使用：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Exercises
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Compare and contrast the results of [`paste0()`](https://rdrr.io/r/base/paste.xhtml)
    with [`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml) for the
    following inputs:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较并对比 [`paste0()`](https://rdrr.io/r/base/paste.xhtml) 和 [`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml)
    的结果，针对以下输入：
- en: '[PRE17]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What’s the difference between [`paste()`](https://rdrr.io/r/base/paste.xhtml)
    and [`paste0()`](https://rdrr.io/r/base/paste.xhtml)? How can you re-create the
    equivalent of [`paste()`](https://rdrr.io/r/base/paste.xhtml) with [`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml)?
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`paste()`](https://rdrr.io/r/base/paste.xhtml)和[`paste0()`](https://rdrr.io/r/base/paste.xhtml)之间有什么区别？如何用[`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml)重新创建[`paste()`](https://rdrr.io/r/base/paste.xhtml)的等效操作？'
- en: 'Convert the following expressions from [`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml)
    to [`str_glue()`](https://stringr.tidyverse.org/reference/str_glue.xhtml) or vice
    versa:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下表达式从[`str_c()`](https://stringr.tidyverse.org/reference/str_c.xhtml)转换为[`str_glue()`](https://stringr.tidyverse.org/reference/str_glue.xhtml)或反之：
- en: '`str_c("The price of ", food, " is ", price)`'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`str_c("The price of ", food, " is ", price)`'
- en: '`str_glue("I''m {age} years old and live in {country}")`'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`str_glue("I''m {age} years old and live in {country}")`'
- en: '`str_c("\\section{", title, "}")`'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`str_c("\\section{", title, "}")`'
- en: Extracting Data from Strings
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从字符串中提取数据
- en: 'It’s common for multiple variables to be crammed together into a single string.
    In this section, you’ll learn how to use four tidyr functions to extract them:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 多个变量常常被挤在一个字符串中。在本节中，您将学习如何使用四个 tidyr 函数来提取它们：
- en: '`df |> separate_longer_delim(col, delim)`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`df |> separate_longer_delim(col, delim)`'
- en: '`df |> separate_longer_position(col, width)`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`df |> separate_longer_position(col, width)`'
- en: '`df |> separate_wider_delim(col, delim, names)`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`df |> separate_wider_delim(col, delim, names)`'
- en: '`df |> separate_wider_position(col, widths)`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`df |> separate_wider_position(col, widths)`'
- en: 'If you look closely, you can see there’s a common pattern here: `separate_`,
    then `longer` or `wider`, then `_`, then `delim` or `position`. That’s because
    these four functions are composed of two simpler primitives:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会发现这里有一个共同模式：`separate_`，然后是 `longer` 或 `wider`，然后 `_`，然后是 `delim`
    或 `position`。这是因为这四个函数由两个更简单的基元组成：
- en: Just like with [`pivot_longer()`](https://tidyr.tidyverse.org/reference/pivot_longer.xhtml)
    and [`pivot_wider()`](https://tidyr.tidyverse.org/reference/pivot_wider.xhtml),
    `_longer` functions make the input data frame longer by creating new rows, and
    `_wider` functions make the input data frame wider by generating new columns.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像[`pivot_longer()`](https://tidyr.tidyverse.org/reference/pivot_longer.xhtml)和[`pivot_wider()`](https://tidyr.tidyverse.org/reference/pivot_wider.xhtml)一样，
    `_longer` 函数通过创建新行使输入数据框变长，而 `_wider` 函数通过生成新列使输入数据框变宽。
- en: '`delim` splits up a string with a delimiter like `", "` or `" "`; `position`
    splits at specified widths, like `c(3, 5, 2)`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delim` 使用分隔符（例如 `", "` 或 `" "`）拆分字符串；`position` 根据指定的宽度（例如 `c(3, 5, 2)`）拆分。'
- en: We’ll return to the last member of this family, `separate_wider_regex()`, in
    [Chapter 15](ch15.xhtml#chp-regexps). It’s the most flexible of the `wider` functions,
    but you need to know something about regular expressions before you can use it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第 15 章](ch15.xhtml#chp-regexps)中再次回到这个家族的最后一位成员 `separate_wider_regex()`。它是
    `wider` 函数中最灵活的，但在使用之前需要了解一些正则表达式知识。
- en: The following two sections will give you the basic idea behind these separate
    functions, first separating into rows (which is a little simpler) and then separating
    into columns. We’ll finish off by discussing the tools that the `wider` functions
    give you to diagnose problems.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个部分将为您介绍这些分隔函数背后的基本思想，首先是分为行（稍微简单一些），然后是分为列。我们最后讨论 `wider` 函数提供的工具来诊断问题。
- en: Separating into Rows
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分为行
- en: 'Separating a string into rows tends to be most useful when the number of components
    varies from row to row. The most common case is requiring [`separate_longer_delim()`](https://tidyr.tidyverse.org/reference/separate_longer_delim.xhtml)
    to split based on a delimiter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串分成行通常在每行的组件数量不同时最有用。最常见的情况是需要 [`separate_longer_delim()`](https://tidyr.tidyverse.org/reference/separate_longer_delim.xhtml)
    根据分隔符进行拆分：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It’s rarer to see [`separate_longer_position()`](https://tidyr.tidyverse.org/reference/separate_longer_delim.xhtml)
    in the wild, but some older datasets do use a compact format where each character
    is used to record a value:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中较少见[`separate_longer_delim()`](https://tidyr.tidyverse.org/reference/separate_longer_delim.xhtml)，但某些旧数据集确实使用了一种紧凑的格式，其中每个字符用于记录一个值：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Separating into Columns
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分列
- en: 'Separating a string into columns tends to be most useful when there are a fixed
    number of components in each string, and you want to spread them into columns.
    They are slightly more complicated than their `longer` equivalents because you
    need to name the columns. For example, in the following dataset, `x` is made up
    of a code, an edition number, and a year, separated by `"."`. To use [`separate_wider_delim()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml),
    we supply the delimiter and the names in two arguments:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串分隔成列在每个字符串中有固定数量的组件且您希望将它们展开到列中时，通常是最有用的。它们比其`longer`等效稍微复杂，因为您需要命名列。例如，在以下数据集中，`x`由代码、版本号和年份组成，它们用`.`分隔。要使用[`separate_wider_delim()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)，我们提供分隔符和名称的两个参数：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If a specific piece is not useful, you can use an `NA` name to omit it from
    the results:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果特定的片段无用，您可以使用`NA`名称将其从结果中省略：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[`separate_wider_position()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)
    works a little differently because you typically want to specify the width of
    each column. So you give it a named integer vector, where the name gives the name
    of the new column, and the value is the number of characters it occupies. You
    can omit values from the output by not naming them:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[`separate_wider_position()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)的工作方式有些不同，因为您通常希望指定每列的宽度。因此，您给它一个命名的整数向量，其中名称给出新列的名称，而值是它占据的字符数。您可以通过不命名它们来从输出中省略值：'
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Diagnosing Widening Problems
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 诊断扩展问题
- en: '[`separate_wider_delim()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)^([5](ch14.xhtml#idm44771295456640))
    requires a fixed and known set of columns. What happens if some of the rows don’t
    have the expected number of pieces? There are two possible problems, too few or
    too many pieces, so [`separate_wider_delim()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)
    provides two arguments to help: `too_few` and `too_many`. Let’s first look at
    the `too_few` case with the following sample dataset:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[`separate_wider_delim()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)^([5](ch14.xhtml#idm44771295456640))需要一个固定和已知的列集。如果某些行没有预期数量的片段会发生什么？存在两种可能的问题，片段过少或者片段过多，因此[`separate_wider_delim()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)提供了两个参数来帮助：`too_few`和`too_many`。让我们首先看一下具有以下示例数据集的`too_few`情况：'
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You’ll notice that we get an error, but the error gives us some suggestions
    on how you might proceed. Let’s start by debugging the problem:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们收到了一个错误，但错误会给出一些关于如何继续的建议。让我们从调试问题开始：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you use the debug mode, you get three extra columns added to the output:
    `x_ok`, `x_pieces`, and `x_remainder` (if you separate a variable with a different
    name, you’ll get a different prefix). Here, `x_ok` lets you quickly find the inputs
    that failed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用调试模式时，将会在输出中添加三列额外的列：`x_ok`、`x_pieces`和`x_remainder`（如果您使用不同名称分隔变量，则会得到不同的前缀）。在这里，`x_ok`允许您快速找到失败的输入：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`x_pieces` tells us how many pieces were found, compared to the expected three
    (the length of `names`). `x_remainder` isn’t useful when there are too few pieces,
    but we’ll see it again shortly.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`x_pieces`告诉我们找到了多少个片段，与预期的三个（即`names`的长度）进行比较。当片段过少时，`x_remainder`并不有用，但我们很快会再次看到它。'
- en: Sometimes looking at this debugging information will reveal a problem with your
    delimiter strategy or suggest that you need to do more preprocessing before separating.
    In that case, fix the problem upstream and make sure to remove `too_few = "debug"`
    to ensure that new problems become errors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有时查看此调试信息将显示出与您的定界策略有关的问题，或者建议您在分隔之前需要进行更多预处理。在这种情况下，请修复上游问题，并确保删除`too_few =
    "debug"`以确保新问题变为错误。
- en: 'In other cases, you may want to fill in the missing pieces with `NA`s and move
    on. That’s the job of `too_few = "align_start"` and `too_few = "align_end"`, which
    allow you to control where the `NA`s should go:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，您可能希望用`NA`填补缺失的部分并继续前进。这就是`too_few = "align_start"`和`too_few = "align_end"`的作用，它们允许您控制`NA`的放置位置：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The same principles apply if you have too many pieces:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果片段过多，同样的原则适用：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But now, when we debug the result, you can see the purpose of `x_remainder`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，当我们调试结果时，您可以看到`x_remainder`的目的：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You have a slightly different set of options for handling too many pieces:
    you can either silently “drop” any additional pieces or “merge” them all into
    the final column:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 处理过多片段的选项略有不同：您可以悄悄地“丢弃”任何额外的片段，或者将它们全部“合并”到最后一列中：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Letters
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字母
- en: In this section, we’ll introduce you to functions that allow you to work with
    the individual letters within a string. You’ll learn how to find the length of
    a string, extract substrings, and handle long strings in plots and tables.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将介绍一些函数，允许您处理字符串中的每个字母。您将学习如何找出字符串的长度，提取子字符串，并处理图表和表格中的长字符串。
- en: Length
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长度
- en: '[`str_length()`](https://stringr.tidyverse.org/reference/str_length.xhtml)
    tells you the number of letters in the string:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[`str_length()`](https://stringr.tidyverse.org/reference/str_length.xhtml)
    告诉您字符串中的字母数：'
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You could use this with [`count()`](https://dplyr.tidyverse.org/reference/count.xhtml)
    to find the distribution of lengths of US baby names and then with [`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml)
    to look at the longest names, which happen to have 15 letters:^([6](ch14.xhtml#idm44771294893344))
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 [`count()`](https://dplyr.tidyverse.org/reference/count.xhtml) 查找美国婴儿姓名长度的分布，然后使用
    [`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml) 查看最长的姓名，这些姓名恰好有
    15 个字母:^([6](ch14.xhtml#idm44771294893344))
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Subsetting
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子集
- en: 'You can extract parts of a string using `str_sub(string, start, end)`, where
    `start` and `end` are the positions where the substring should start and end.
    The `start` and `end` arguments are inclusive, so the length of the returned string
    will be `end - start + 1`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `str_sub(string, start, end)` 提取字符串的部分，其中 `start` 和 `end` 是子字符串应该开始和结束的位置。`start`
    和 `end` 参数是包容的，因此返回字符串的长度将是 `end - start + 1`：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can use negative values to count back from the end of the string: -1 is
    the last character, -2 is the second to last character, etc.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用负值从字符串末尾开始计数：-1 是最后一个字符，-2 是倒数第二个字符，依此类推。
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that [`str_sub()`](https://stringr.tidyverse.org/reference/str_sub.xhtml)
    won’t fail if the string is too short: it will just return as much as possible:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[`str_sub()`](https://stringr.tidyverse.org/reference/str_sub.xhtml) 如果字符串过短不会失败：它将尽可能返回尽可能多的内容：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We could use [`str_sub()`](https://stringr.tidyverse.org/reference/str_sub.xhtml)
    with [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml) to find
    the first and last letters of each name:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 [`str_sub()`](https://stringr.tidyverse.org/reference/str_sub.xhtml)
    和 [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml) 找出每个名称的第一个和最后一个字母：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Exercises
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: When computing the distribution of the length of baby names, why did we use
    `wt = n`?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算婴儿姓名长度的分布时，为什么我们使用 `wt = n`？
- en: Use [`str_length()`](https://stringr.tidyverse.org/reference/str_length.xhtml)
    and [`str_sub()`](https://stringr.tidyverse.org/reference/str_sub.xhtml) to extract
    the middle letter from each baby name. What will you do if the string has an even
    number of characters?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 [`str_length()`](https://stringr.tidyverse.org/reference/str_length.xhtml)
    和 [`str_sub()`](https://stringr.tidyverse.org/reference/str_sub.xhtml) 提取每个婴儿姓名的中间字母。如果字符串长度为偶数，您会怎么做？
- en: Are there any major trends in the length of baby names over time? What about
    the popularity of first and last letters?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着时间的推移，婴儿姓名的长度有什么主要趋势？名字的首尾字母的受欢迎程度如何？
- en: Non-English Text
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非英文文本
- en: 'So far, we’ve focused on English language text, which is particularly easy
    to work with for two reasons. First, the English alphabet is relatively simple:
    there are just 26 letters. Second (and maybe more important), the computing infrastructure
    we use today was predominantly designed by English speakers. Unfortunately, we
    don’t have room for a full treatment of non-English languages. Still, we wanted
    to draw your attention to some of the biggest challenges you might encounter:
    encoding, letter variations, and locale-dependent functions.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们专注于英语文本，这在两个方面特别容易处理。首先，英语字母表相对简单：只有 26 个字母。其次（也许更重要的是），我们今天使用的计算基础设施主要由英语使用者设计。不幸的是，我们没有足够的空间来全面处理非英语语言。尽管如此，我们希望引起您对可能遇到的一些最大挑战的注意：编码、字母变体和依赖于地区的函数。
- en: Encoding
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码
- en: 'When working with non-English text, the first challenge is often the *encoding*.
    To understand what’s going on, we need to dive into how computers represent strings.
    In R, we can get at the underlying representation of a string using [`charToRaw()`](https://rdrr.io/r/base/rawConversion.xhtml):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理非英文文本时，第一个挑战通常是*编码*。要理解发生了什么，我们需要深入了解计算机如何表示字符串。在 R 中，我们可以使用 [`charToRaw()`](https://rdrr.io/r/base/rawConversion.xhtml)
    获取字符串的底层表示：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Each of these six hexadecimal numbers represents one letter: `48` is H, `61`
    is a, and so on. The mapping from hexadecimal number to character is the encoding,
    and in this case, the encoding is called ASCII. ASCII does a great job of representing
    English characters because it’s the *American* Standard Code for Information Interchange.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个十六进制数都代表一个字母：`48`代表H，`61`代表a，依此类推。从十六进制数到字符的映射称为编码，在这种情况下，编码称为ASCII。ASCII在表示英文字符方面表现出色，因为它是*美国*信息交换标准代码。
- en: 'Things aren’t so easy for languages other than English. In the early days of
    computing, there were many competing standards for encoding non-English characters.
    For example, there were two different encodings for Europe: Latin1 (aka ISO-8859-1)
    was used for Western European languages, and Latin2 (aka ISO-8859-2) was used
    for Central European languages. In Latin1, the byte `b1` is ±, but in Latin2,
    it’s ą! Fortunately, today there is one standard that is supported almost everywhere:
    UTF-8\. UTF-8 can encode just about every character used by humans today and many
    extra symbols like emojis.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非英语的语言来说，事情并不那么简单。在计算机的早期阶段，有许多竞争的编码标准用于编码非英语字符。例如，欧洲有两种不同的编码：Latin1（也称为ISO-8859-1）用于西欧语言，而Latin2（也称为ISO-8859-2）用于中欧语言。在Latin1中，字节`b1`是±，但在Latin2中，它是ą！幸运的是，今天几乎每个地方都支持一种标准：UTF-8。UTF-8可以编码今天人类使用的几乎每个字符，以及许多额外的符号，如表情符号。
- en: readr uses UTF-8 everywhere. This is a good default but will fail for data produced
    by older systems that don’t use UTF-8\. If this happens, your strings will look
    weird when you print them. Sometimes just one or two characters might be messed
    up; other times, you’ll get complete gibberish. For example, here are two inline
    CSVs with unusual encodings:^([7](ch14.xhtml#idm44771294565056))
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: readr在任何地方都使用UTF-8。这是一个很好的默认设置，但对于不使用UTF-8的旧系统生成的数据，可能会失败。如果发生这种情况，在打印字符串时，它们会看起来很奇怪。有时可能只会出现一两个字符混乱，而其他时候则会得到完全无法理解的内容。例如，这里有两个内联CSV示例，使用了不同的编码：^([7](ch14.xhtml#idm44771294565056))
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To read these correctly, you specify the encoding via the `locale` argument:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确地读取这些内容，您可以通过`locale`参数指定编码：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How do you find the correct encoding? If you’re lucky, it’ll be included somewhere
    in the data documentation. Unfortunately, that’s rarely the case, so readr provides
    [`guess_encoding()`](https://readr.tidyverse.org/reference/encoding.xhtml) to
    help you figure it out. It’s not foolproof and works better when you have lots
    of text (unlike here), but it’s a reasonable place to start. Expect to try a few
    different encodings before you find the right one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如何找到正确的编码？如果幸运的话，它可能包含在数据文档的某处。不幸的是，这种情况很少见，所以readr提供了[`guess_encoding()`](https://readr.tidyverse.org/reference/encoding.xhtml)来帮助您找到答案。它不是绝对可靠的，在处理少量文本时效果较差，但作为一个合理的起点是可以接受的。预计在找到正确编码之前，您可能需要尝试几种不同的编码。
- en: Encodings are a rich and complex topic; we’ve only scratched the surface here.
    If you’d like to learn more, we recommend reading the [detailed explanation](https://oreil.ly/v8ZQf).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 编码是一个丰富而复杂的主题；我们在这里只是浅尝辄止。如果您想了解更多信息，建议阅读[详细说明](https://oreil.ly/v8ZQf)。
- en: Letter Variations
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字母变体
- en: 'Working in languages with accents poses a significant challenge when determining
    the position of letters (e.g., with [`str_length()`](https://stringr.tidyverse.org/reference/str_length.xhtml)
    and [`str_sub()`](https://stringr.tidyverse.org/reference/str_sub.xhtml)) as accented
    letters might be encoded as a single individual character (e.g., ü) or as two
    characters by combining an unaccented letter (e.g., u) with a diacritic mark (e.g.,
    ¨). For example, this code shows two ways of representing ü that look identical:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用带有重音的语言时，确定字母位置（例如，使用[`str_length()`](https://stringr.tidyverse.org/reference/str_length.xhtml)和[`str_sub()`](https://stringr.tidyverse.org/reference/str_sub.xhtml)）是一个重要挑战，因为重音字母可以被编码为一个单独的字符（例如，ü），或者通过结合未带重音的字母（例如，u）与变音符号（例如，¨）来编码为两个字符。例如，此代码展示了两种看起来相同的表示ü的方式：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'But both strings differ in length, and their first characters are different:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但这两个字符串在长度上不同，并且它们的第一个字符也不同：
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, note that a comparison of these strings with `==` interprets these
    strings as different, while the handy [`str_equal()`](https://stringr.tidyverse.org/reference/str_equal.xhtml)
    function in stringr recognizes that both have the same appearance:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，使用`==`比较这些字符串时会将它们视为不同，而stringr中方便的[`str_equal()`](https://stringr.tidyverse.org/reference/str_equal.xhtml)函数会认识到它们具有相同的外观：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Locale-Dependent Functions
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖区域设置的函数
- en: Finally, there are a handful of stringr functions whose behavior depends on
    your *locale*. A locale is similar to a language but includes an optional region
    specifier to handle regional variations within a language. A locale is specified
    by a lowercase language abbreviation, optionally followed by a `_` and an uppercase
    region identifier. For example, “en” is English, “en_GB” is British English, and
    “en_US” is American English. If you don’t already know the code for your language,
    [Wikipedia](https://oreil.ly/c1P2g) has a good list, and you can see which are
    supported in stringr by looking at [`stringi::stri_locale_list()`](https://rdrr.io/pkg/stringi/man/stri_locale_list.xhtml).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一些 stringr 函数的行为取决于你的*语言环境*。语言环境类似于语言，但包括一个可选的地区标识符，以处理语言内的地区变化。语言环境由小写语言缩写指定，可选地跟着一个
    `_` 和一个大写地区标识符。例如，“en” 是英语，“en_GB” 是英国英语，“en_US” 是美国英语。如果你还不知道你的语言的代码，[Wikipedia](https://oreil.ly/c1P2g)
    有一个很好的列表，并且你可以查看哪些被 stringr 支持，通过查看 [`stringi::stri_locale_list()`](https://rdrr.io/pkg/stringi/man/stri_locale_list.xhtml)。
- en: 'Base R string functions automatically use the locale set by your operating
    system. This means that base R string functions do what you expect for your language,
    but your code might work differently if you share it with someone who lives in
    a different country. To avoid this problem, stringr defaults to English rules
    by using the “en” locale and requires you to specify the `locale` argument to
    override it. Fortunately, there are two sets of functions where the locale really
    matters: changing case and sorting.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 基础 R 字符串函数会自动使用操作系统设置的语言环境。这意味着基础 R 字符串函数会根据你的语言环境执行操作，但如果与其他国家的人共享代码，你的代码可能会有不同的运行结果。为了避免这个问题，stringr
    默认使用英语规则，通过使用 “en” 语言环境，并要求你指定 `locale` 参数来覆盖它。幸运的是，有两组函数特别依赖于语言环境：大小写转换和排序。
- en: 'The rules for changing cases differ among languages. For example, Turkish has
    two i’s: with and without a dot. Since they’re two distinct letters, they’re capitalized
    differently:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不同语言的大小写转换规则各不相同。例如，土耳其语有两个i：一个有点，一个没有点。因为它们是两个不同的字母，它们的大写形式也不同：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Sorting strings depends on the order of the alphabet, and the order of the
    alphabet is not the same in every language!^([8](ch14.xhtml#idm44771294301712))
    Here’s an example: in Czech, “ch” is a compound letter that appears after `h`
    in the alphabet.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对字符串进行排序依赖于字母表的顺序，而不是每种语言都相同！^([8](ch14.xhtml#idm44771294301712-marker)) 举个例子：在捷克语中，“ch”
    是一个复合字母，按照字母表的顺序，它出现在 `h` 之后。
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This also comes up when sorting strings with [`dplyr::arrange()`](https://dplyr.tidyverse.org/reference/arrange.xhtml),
    which is why it also has a `locale` argument.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [`dplyr::arrange()`](https://dplyr.tidyverse.org/reference/arrange.xhtml)
    对字符串进行排序时也会遇到这个问题，这也是它有 `locale` 参数的原因。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned about some of the power of the stringr package
    such as how to create, combine, and extract strings, and about some of the challenges
    you might face with non-English strings. Now it’s time to learn one of the most
    important and powerful tools for working with strings: regular expressions. Regular
    expressions are a concise but expressive language for describing patterns within
    strings and are the topic of the next chapter.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了 stringr 包的一些强大功能，如如何创建、组合和提取字符串，以及在处理非英语字符串时可能遇到的一些挑战。现在是时候学习处理字符串中最重要和最强大的工具之一了：正则表达式。正则表达式是一种简洁而表达力强的语言，用于描述字符串中的模式，并且是下一章的主题。
- en: ^([1](ch14.xhtml#idm44771296672656-marker)) Or use the base R function [`writeLines()`](https://rdrr.io/r/base/writeLines.xhtml).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch14.xhtml#idm44771296672656-marker)) 或者使用基础 R 函数 [`writeLines()`](https://rdrr.io/r/base/writeLines.xhtml)。
- en: ^([2](ch14.xhtml#idm44771296567072-marker)) Available in R 4.0.0 and newer.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch14.xhtml#idm44771296567072-marker)) 适用于 R 4.0.0 及更新版本。
- en: ^([3](ch14.xhtml#idm44771296183072-marker)) If you’re not using stringr, you
    can also access it directly with [`glue::glue()`](https://glue.tidyverse.org/reference/glue.xhtml).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch14.xhtml#idm44771296183072-marker)) 如果你不使用 stringr，也可以直接访问它，使用 [`glue::glue()`](https://glue.tidyverse.org/reference/glue.xhtml)。
- en: ^([4](ch14.xhtml#idm44771296091984-marker)) The base R equivalent is [`paste()`](https://rdrr.io/r/base/paste.xhtml)
    used with the `collapse` argument.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch14.xhtml#idm44771296091984-marker)) 基础 R 的等效函数是 [`paste()`](https://rdrr.io/r/base/paste.xhtml)，使用
    `collapse` 参数。
- en: ^([5](ch14.xhtml#idm44771295456640-marker)) The same principles apply to [`separate_wider_position()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)
    and [`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch14.xhtml#idm44771295456640-marker)) 相同的原则也适用于[`separate_wider_position()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)和[`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)。
- en: ^([6](ch14.xhtml#idm44771294893344-marker)) Looking at these entries, we’d guess
    that the babynames data drops spaces or hyphens and truncates after 15 letters.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch14.xhtml#idm44771294893344-marker)) 查看这些条目，我们猜测 babynames 数据会删除空格或连字符，并在
    15 个字母后截断。
- en: ^([7](ch14.xhtml#idm44771294565056-marker)) Here I’m using the special `\x`
    to encode binary data directly into a string.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch14.xhtml#idm44771294565056-marker)) 在这里，我正在使用特殊字符 `\x` 将二进制数据直接编码到字符串中。
- en: ^([8](ch14.xhtml#idm44771294301712-marker)) Sorting in languages that don’t
    have an alphabet, like Chinese, is more complicated still.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch14.xhtml#idm44771294301712-marker)) 在像中文这样没有字母的语言中进行排序，问题就更加复杂了。
