- en: 7 Forecasting non-stationary time series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 预测非平稳时间序列
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Examining the autoregressive integrated moving average model, or ARIMA(*p*,*d*,*q*)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查自回归积分移动平均模型，或ARIMA(*p*,*d*,*q*)
- en: Applying the general modeling procedure for non-stationary time series
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用非平稳时间序列的一般建模程序
- en: Forecasting using the ARIMA(*p*,*d*,*q*) model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ARIMA(*p*,*d*,*q*)模型进行预测
- en: In chapters 4, 5, and 6 we covered the moving average model, MA(*q*)); the autoregressive
    model, AR(*p*)); and the ARMA model, ARMA(*p*,*q*). We saw how these models can
    only be used for stationary time series, which required us to apply transformations,
    mainly differencing, and test for stationarity using the ADF test. In the examples
    that we covered, the forecasts from each model returned differenced values, which
    required us to reverse this transformation in order to bring the values back to
    the scale of the original data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章、第5章和第6章中，我们介绍了移动平均模型（MA(*q*)）、自回归模型（AR(*p*)）和自回归移动平均模型（ARMA(*p*,*q*)）。我们看到了这些模型只能用于平稳时间序列，这要求我们应用变换，主要是差分，并使用ADF测试来检验平稳性。在我们所涵盖的例子中，每个模型的预测都返回了差分值，这要求我们逆转这种变换，以便将值恢复到原始数据的尺度。
- en: Now we’ll add another component to the ARMA(*p*,*q*) model so we can forecast
    non-stationary time series. This component is the *integration order*, which is
    denoted by the variable *d*. This leads us to the *autoregressive integrated moving
    average* (ARIMA) model, or ARIMA(*p*,*d*,*q*). Using this model, we can take into
    account non-stationary time series and avoid the steps of modeling on differenced
    data and having to inverse transform the forecasts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向ARMA(*p*,*q*)模型添加另一个组件，以便我们可以预测非平稳时间序列。这个组件是积分阶数，用变量*d*表示。这导致我们得到自回归积分移动平均模型（ARIMA），或ARIMA(*p*,*d*,*q*)。使用这个模型，我们可以考虑非平稳时间序列，并避免在差分数据上建模的步骤以及需要逆转预测的变换。
- en: In this chapter, we’ll define the ARIMA(*p*,*d*,*q*) model and the order of
    integration *d*. Then we’ll add a step to our general modeling procedure. Figure
    7.1 shows the general modeling procedure as defined in chapter 6\. We must add
    a step to determine the order of integration in order to use this procedure with
    the ARIMA(*p*,*d*,*q*) model.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将定义ARIMA(*p*,*d*,*q*)模型和积分阶数*d*。然后我们将在我们的通用建模程序中添加一个步骤。图7.1显示了在第6章中定义的通用建模程序。我们必须添加一个步骤来确定积分阶数，以便使用ARIMA(*p*,*d*,*q*)模型。
- en: '![](../../OEBPS/Images/07-01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-01.png)'
- en: Figure 7.1 General modeling procedure using an ARMA(*p*, *q*) model. In this
    chapter, we will add another step to this procedure in order to accommodate the
    ARIMA(*p*,*d*,*q*) model.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 使用ARMA(*p*, *q*)模型的通用建模程序。在本章中，我们将为此程序添加另一个步骤，以便适应ARIMA(*p*,*d*,*q*)模型。
- en: Then we’ll apply our modified procedure to forecast a non-stationary time series,
    meaning that the series has a trend, or its variance is not constant over time.
    Specifically, we’ll revisit the dataset of Johnson & Johnson’s quarterly earnings
    per share (EPS) between 1960 and 1980, which we first studied in chapters 1 and
    2\. The series is shown in figure 7.2\. We’ll apply the ARIMA(*p*,*d*,*q*) model
    to forecast the quarterly EPS for 1 year.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将应用我们修改后的程序来预测一个非平稳时间序列，这意味着该序列具有趋势，或者其方差随时间变化而变化。具体来说，我们将重新研究1960年至1980年间强生公司每季度的每股收益（EPS）数据集，这是我们首次在第一章和第二章中研究的。该序列显示在图7.2中。我们将应用ARIMA(*p*,*d*,*q*)模型来预测1年的季度EPS。
- en: '![](../../OEBPS/Images/07-02.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-02.png)'
- en: Figure 7.2 Quarterly earnings per share (EPS) of Johnson & Johnson from 1960
    to 1980\. We worked with the same dataset in chapters 1 and 2.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 1960年至1980年强生公司每股收益（EPS）。我们在第1章和第2章中使用了相同的数据集。
- en: 7.1 Defining the autoregressive integrated moving average model
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 定义自回归积分移动平均模型
- en: An *autoregressive integrated moving average process* is the combination of
    an autoregressive process AR(*p*), integration I(*d*), and the moving average
    process MA(*q*).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归积分移动平均过程是自回归过程AR(*p*)、积分I(*d*)和移动平均过程MA(*q*)的组合。
- en: Just like the ARMA process, the ARIMA process states that the present value
    is dependent on past values, coming from the AR(*p*) portion, and past errors,
    coming from the MA(*q*) portion. However, instead of using the original series,
    denoted as *y[t]*, the ARIMA process uses the differenced series, denoted as *y'[t]*.
    Note that *y'[t]* can represent a series that has been differenced more than once.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 ARMA 过程一样，ARIMA 过程表明当前值依赖于过去值，来自 AR(*p*)部分，以及过去误差，来自 MA(*q*)部分。然而，ARIMA过程使用的是差分序列，表示为
    *y'[t]*，而不是原始序列，表示为 *y[t]*。请注意，*y'[t]* 可以代表已经差分多次的序列。
- en: Therefore, the mathematical expression of the ARIMA(*p*,*d*,*q*) process states
    that the present value of the differenced series *y'[t]* is equal to the sum of
    a constant C, past values of the differenced series φ[p]*y'*[*t*–*p*], the mean
    of the differenced series µ, past error terms θ[q]ϵ[*t*–*q*], and a current error
    term *ϵ[*t*]*, as shown in equation 7.1.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，ARIMA(*p*,*d*,*q*)过程的数学表达式表明，差分序列 *y'[t]* 的当前值等于一个常数 C，过去差分序列的值 φ[p]*y'*[*t*–*p*]，差分序列的均值
    µ，过去误差项 θ[q]ϵ[*t*–*q*]，以及当前误差项 *ϵ[*t*]* 的总和，如方程 7.1 所示。
- en: '*y''[t]* = C + φ[1]*y''*[*t*–1] +⋅⋅⋅ φ[p]*y''*[*t*–*p*] + θ[1]ϵ*''*[*t*–1]
    +⋅⋅⋅+ θ[q]ϵ''[*t*–*q*] + *ϵ[*t*]*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*y''[t]* = C + φ[1]*y''*[*t*–1] +⋅⋅⋅ φ[p]*y''*[*t*–*p*] + θ[1]ϵ*''*[*t*–1]
    +⋅⋅⋅+ θ[q]ϵ''[*t*–*q*] + *ϵ[*t*]*'
- en: Equation 7.1
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 7.1
- en: Just like in the ARMA process, the order *p* determines how many lagged values
    of the series are included in the model, while the order *q* determines how many
    lagged error terms are included in the model. However, in equation 7.1 you’ll
    notice that there is no order *d* explicitly displayed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 ARMA 过程中一样，阶数 *p* 决定了模型中包含多少个滞后值，而阶数 *q* 决定了模型中包含多少个滞后误差项。然而，在方程 7.1 中，你将注意到没有明确显示阶数
    *d*。
- en: Here, the order *d*is defined as the order of integration. Integration is simply
    the reverse of differencing. The order of integration is thus equal to the number
    of times a series has been differenced to become stationary.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，阶数 *d* 被定义为积分阶数。积分简单来说是差分的逆过程。因此，积分阶数等于一个序列被差分以变得平稳的次数。
- en: If we difference a series once and it becomes stationary, then *d* = 1. If a
    series is differenced twice to become stationary, then *d* = 2.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对一个序列进行一次差分后它变得平稳，那么 *d* = 1。如果一个序列被差分两次以变得平稳，那么 *d* = 2。
- en: Autoregressive integrated moving average model
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归积分移动平均模型
- en: An *autoregressive integrated moving average* (ARIMA) process is the combination
    of the AR(*p*) and MA(*q*) processes, but in terms of the differenced series.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**自回归积分移动平均** (ARIMA)过程是 AR(*p*)和 MA(*q*)过程的组合，但针对的是差分序列。'
- en: It is denoted as ARIMA(*p*,*d*,*q*), where *p* is the order of the AR(*p*) process,
    *d* is the order of integration, and *q* is the order of the MA(*q*) process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它表示为 ARIMA(*p*,*d*,*q*)，其中 *p* 是 AR(*p*)过程的阶数，*d* 是积分阶数，*q* 是 MA(*q*)过程的阶数。
- en: Integration is the reverse of differencing, and the order of integration *d*
    is equal to the number of times the series has been differenced to be rendered
    stationary.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 积分是差分的逆过程，积分阶数 *d* 等于序列被差分以实现平稳性的次数。
- en: The general equation of the ARIMA(*p*,*d*,*q*) process is
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA(*p*,*d*,*q*)过程的一般方程是
- en: '*y''[t]* = C + φ[1]*y''[t]*[–1] +⋅⋅⋅ φ*[p] y''[t–p]* + θ[1]ϵ''[*t*–1] +⋅⋅⋅+
    θ[*q*]ϵ''[*t*–*q*] + *ϵ[*t*]*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*y''[t]* = C + φ[1]*y''[t]*[–1] +⋅⋅⋅ φ*[p] y''[t–p]* + θ[1]ϵ''[*t*–1] +⋅⋅⋅+
    θ[*q*]ϵ''[*t*–*q*] + *ϵ[*t*]*'
- en: Note that *y'[t]* represents the differenced series, and it may have been differenced
    more than once.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*y'[t]* 代表差分序列，并且可能已经差分了多次。
- en: A time series that can be rendered stationary by applying differencing is said
    to be an *integrated* series. In the presence of a non-stationary integrated time
    series, we can use the ARIMA(*p*,*d*,*q*) model to produce forecasts.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过应用差分来实现平稳性的时间序列被称为**积分**序列。在存在非平稳积分时间序列的情况下，我们可以使用 ARIMA(*p*,*d*,*q*)模型进行预测。
- en: Thus, in simple terms, the ARIMA model is simply an ARMA model that can be applied
    on non-stationary time series. Whereas the ARMA(*p*,*q*) model requires the series
    to be stationary before fitting an ARMA(*p*,*q*) model, the ARIMA(*p*,*d*,*q*)
    model can be used on non-stationary series. We must simply find the order of integration
    *d*, which corresponds to the minimum number of times a series must be differenced
    to become stationary.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简单来说，ARIMA模型就是一个可以应用于非平稳时间序列的ARMA模型。而ARMA(*p*,*q*)模型在拟合ARMA(*p*,*q*)模型之前要求序列必须是平稳的，而ARIMA(*p*,*d*,*q*)模型则可以用于非平稳序列。我们只需找到积分阶数*d*，它对应于序列必须差分的最小次数以成为平稳。
- en: Therefore, we must add the step of finding the order of integration to our general
    modeling procedure before we apply it to forecast the quarterly EPS of Johnson
    & Johnson.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在将一般建模过程应用于预测Johnson & Johnson的季度每股收益之前，我们必须添加找到积分阶数这一步骤。
- en: 7.2 Modifying the general modeling procedure to account for non-stationary series
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 修改一般建模过程以考虑非平稳序列
- en: In chapter 6 we built a general modeling procedure that allowed us to model
    more complex time series, meaning that the series has both an autoregressive and
    a moving average component. This procedure involves fitting many ARMA(*p*,*q*)
    models and selecting the one with the lowest AIC. Then we study the model’s residuals
    to verify that they resemble white noise. If that is the case, the model can be
    used for forecasting. We can visualize the general modeling procedure in its present
    state in figure 7.3.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章中，我们建立了一个一般建模过程，使我们能够对更复杂的时间序列进行建模，这意味着序列既有自回归成分又有移动平均成分。这个过程涉及拟合许多ARMA(*p*,*q*)模型并选择AIC最低的那个。然后我们研究模型的残差以验证它们是否类似于白噪声。如果是这样，该模型可以用于预测。我们可以在图7.3中可视化当前状态的一般建模过程。
- en: '![](../../OEBPS/Images/07-03.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-03.png)'
- en: Figure 7.3 General modeling procedure using an ARMA(*p*, *q*) model. Now we
    must adapt it to apply to an ARIMA(*p*,*d*,*q*) model, allowing us to work with
    non-stationary time series.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 使用ARMA(*p*, *q*)模型的一般建模过程。现在我们必须将其修改为适用于ARIMA(*p*,*d*,*q*)模型，这样我们就可以处理非平稳时间序列。
- en: The next iteration of the general modeling procedure will include a step to
    determine the order of integration *d*. That way, we can apply the same procedure
    but using an ARIMA(*p*,*d*,*q*) model, which will allow us to forecast non-stationary
    time series.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一般建模过程的下一次迭代将包括一个确定积分阶数*d*的步骤。这样，我们可以应用相同的程序，但使用ARIMA(*p*,*d*,*q*)模型，这将使我们能够预测非平稳时间序列。
- en: From the previous section, we know that the order of integration *d* is simply
    the minimum number of times a series must be differenced to become stationary.
    Therefore, if a series is stationary after being differenced once, then *d* =
    1. If it is stationary after being differenced twice, then *d* = 2. In my experience,
    a time series rarely needs to be differenced more than twice to become stationary.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一节中，我们知道积分阶数*d*仅仅是序列必须差分的最小次数以成为平稳。因此，如果一个序列在差分一次后变得平稳，那么*d* = 1。如果它在差分两次后变得平稳，那么*d*
    = 2。根据我的经验，时间序列很少需要差分超过两次才能变得平稳。
- en: We can add a step such that when transformations are applied to the series,
    we set the value of *d* to the number of times the series was differenced. Then,
    instead of fitting many ARMA(*p*,*q*) models, we fit many ARIMA(*p*,*d*,*q*) models.
    The rest of the procedure remains the same, as we still use the AIC to select
    the best model and study its residuals. The resulting procedure is shown in figure
    7.4.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个步骤，当对序列应用变换时，我们将*d*的值设置为序列被差分的次数。然后，我们不再拟合许多ARMA(*p*,*q*)模型，而是拟合许多ARIMA(*p*,*d*,*q*)模型。其余的过程保持不变，因为我们仍然使用AIC来选择最佳模型并研究其残差。该过程如图7.4所示。
- en: Note that in the case where *d* = 0, it is equivalent to an ARMA(*p*,*q*) model.
    This also means that the series did not need to be differenced to be stationary.
    It must also be specified that the ARMA(*p*,*q*) model can only be applied on
    a stationary series, whereas the ARIMA(*p*,*d*,*q*) model can be applied on a
    series that has not been differenced.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当*d* = 0时，它等同于ARMA(*p*,*q*)模型。这也意味着序列不需要差分就可以成为平稳。还必须指出，ARMA(*p*,*q*)模型只能应用于平稳序列，而ARIMA(*p*,*d*,*q*)模型可以应用于未经差分的序列。
- en: Let’s apply our new general modeling procedure to forecast the quarterly earnings
    per share of Johnson & Johnson.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们新的一般建模过程应用于预测Johnson & Johnson的季度每股收益。
- en: 7.3 Forecasting a non-stationary times series
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 预测非平稳时间序列
- en: We are now going to apply the general modeling procedure displayed in figure
    7.4 to forecast the quarterly earnings per share (EPS) of Johnson & Johnson. We’ll
    use the same dataset that was introduced in chapters 1 and 2\. We will forecast
    1 year’s quarterly EPS, meaning that we must forecast four timesteps into the
    future, since there are four quarters in a year. The dataset covers the period
    between 1960 and 1980.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将应用图7.4中显示的通用建模过程来预测强生公司每季度的每股收益(EPS)。我们将使用第1章和第2章中介绍的数据集。我们将预测1年的季度EPS，这意味着我们必须预测四个时间步长到未来，因为一年有四个季度。数据集涵盖了1960年至1980年之间的时期。
- en: As always, the first step is to collect our data. Here it is done for us, so
    we can simply load it and display the series. The result is shown in figure 7.5.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，第一步是收集我们的数据。这里数据已经为我们准备好了，所以我们只需加载并显示序列。结果如图7.5所示。
- en: '![](../../OEBPS/Images/07-04.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-04.png)'
- en: Figure 7.4 General modeling procedure for using the ARIMA(*p*,*d*,*q*) model.
    Notice the addition of a step where we specify the parameter *d* for the ARIMA(*p*,*d*,*q*)
    model. Here, *d* is simply the minimum number of times a series must be differenced
    to become stationary.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 使用ARIMA(*p*,*d*,*q*)模型的通用建模过程。注意增加了一步，我们在这里指定ARIMA(*p*,*d*,*q*)模型的参数*d*。在这里，*d*是序列必须差分的最小次数，以成为平稳的。
- en: 'Note At any time, feel free to refer to the source for this chapter on GitHub:
    [https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH07](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH07).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在任何时候，都可以自由参考GitHub上本章的源代码：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH07](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH07)。
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](../../OEBPS/Images/07-05.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-05.png)'
- en: Figure 7.5 Quarterly earnings per share (EPS) of Johnson & Johnson between 1960
    and 1980
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 1960年至1980年间强生公司每季度的每股收益(EPS)
- en: Following our procedure, we must check if the data is stationary. Figure 7.5
    shows a positive trend, as the quarterly EPS tends to increase over time. Nevertheless,
    we can apply the augmented Dickey-Fuller (ADF) test to determine if it is stationary
    or not. By now you should be very comfortable with these steps, so they will be
    accompanied by minimal comments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们的程序，我们必须检查数据是否平稳。图7.5显示了一个正向趋势，因为每季度的每股收益(EPS)随着时间的推移而增加。尽管如此，我们可以应用增强迪基-富勒(ADF)测试来确定它是否平稳。到现在你应该非常熟悉这些步骤，所以它们将伴随着最少的注释。
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This block of code returns an ADF statistic of 2.74 with a p-value of 1.0\.
    Since the ADF statistic is not a large negative number, and the p-value is larger
    than 0.05, we cannot reject the null hypothesis, meaning that our series is not
    stationary.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码返回一个ADF统计量为2.74，p值为1.0。由于ADF统计量不是一个大的负数，且p值大于0.05，我们不能拒绝零假设，这意味着我们的序列不是平稳的。
- en: We need to determine how many times the series must be differenced to become
    stationary. This will then set the order of integration *d*. We can apply a first-order
    differencing and test for stationarity.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确定序列必须差分多少次才能变得平稳。这将然后设置积分阶数*d*。我们可以应用一阶差分并测试平稳性。
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Apply first-order differencing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 应用一阶差分。
- en: ❷ Test for stationarity.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试平稳性。
- en: This results in an ADF statistic of –0.41 and a p-value of 0.9\. Again, the
    ADF statistic is not a large negative number, and the p-value is larger than 0.05\.
    Therefore, we cannot reject the null hypothesis and we must conclude that after
    a first-order differencing, the series is not stationary.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致ADF统计量为-0.41，p值为0.9。同样，ADF统计量不是一个大的负数，且p值大于0.05。因此，我们不能拒绝零假设，我们必须得出结论，在第一次差分后，序列不是平稳的。
- en: 'Let’s try differencing again to see if the series becomes stationary:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试差分，看看序列是否变得平稳：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Take the differenced series and difference it again.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对差分序列再次进行差分。
- en: ❷ Test for stationarity.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试平稳性。
- en: This results in an ADF statistic of –3.59 and a p-value of 0.006\. Now that
    we have a p-value smaller than 0.05 and a large negative ADF statistic, we can
    reject the null hypothesis and conclude that our series is stationary. It took
    two rounds of differencing to make our data stationary, which means that our order
    of integration is 2, so *d* = 2.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致ADF统计量为-3.59，p值为0.006。现在我们有一个小于0.05的p值和一个大的负ADF统计量，我们可以拒绝零假设，并得出我们的序列是平稳的。需要两次差分才能使我们的数据平稳，这意味着我们的积分阶数为2，所以*d*
    = 2。
- en: Before we move on to fitting different combinations of ARIMA(*p*,*d*,*q*) models,
    we must separate our data into train and test sets. We will hold out the last
    year of data for testing. This means that we will fit the model with data from
    1960 to 1979 and predict the quarterly EPS in 1980 to evaluate the quality of
    our model against the observed values in 1980\. In figure 7.6 the testing period
    is the shaded area.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续拟合不同的ARIMA(*p*,*d*,*q*)模型组合之前，我们必须将我们的数据分为训练集和测试集。我们将保留最后一年数据用于测试。这意味着我们将使用1960年至1979年的数据来拟合模型，并预测1980年的季度EPS以评估我们模型的质量与1980年观察值相比。在图7.6中，测试期是阴影区域。
- en: '![](../../OEBPS/Images/07-06.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-06.png)'
- en: Figure 7.6 The train and test sets. The training period spans the years 1960
    to 1979 inclusively, while the test set is the quarterly EPS reported in 1980\.
    This test set corresponds to the last four data points of the dataset.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：训练集和测试集。训练期包括1960年至1979年，而测试集是1980年报告的季度EPS。这个测试集对应于数据集的最后四个数据点。
- en: To fit the many ARIMA(*p*,*d*,*q*) models, we’ll define the `optimize_ARIMA`
    function. It is almost identical to the `optimize_ARMA` function that we defined
    in chapter 6, only this time we’ll add the order of integration *d* as an input
    to the function. The remainder of the function stays the same, as we fit the different
    models and order them by ascending AIC in order to select the model with the lowest
    AIC. The `optimize_ARIMA` function is shown in the following listing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拟合许多ARIMA(*p*,*d*,*q*)模型，我们将定义`optimize_ARIMA`函数。它与我们在第6章中定义的`optimize_ARMA`函数几乎相同，只是这次我们将积分阶数*d*作为函数的输入。函数的其余部分保持不变，因为我们拟合不同的模型，并按升序AIC对它们进行排序，以选择AIC最低的模型。`optimize_ARIMA`函数如下所示。
- en: Listing 7.1 Function to fit all unique ARIMA(*p*,*d*,*q*) models
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1：拟合所有唯一的ARIMA(*p*,*d*,*q*)模型的函数
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The function takes as inputs the time series data, the list of unique (p,q)
    combinations, and the order of integration d.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数接受时间序列数据、唯一(p,q)组合列表和积分阶数d作为输入。
- en: ❷ Initialize an empty list to store each order (p,q) and its corresponding AIC
    as a tuple.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始化一个空列表以存储每个订单（p,q）及其对应的AIC作为元组。
- en: ❸ Iterate over each unique (p,q) combination. The use of tqdm_notebook will
    display a progress bar.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 遍历每个唯一的(p,q)组合。使用tqdm_notebook将显示进度条。
- en: ❹ Fit an ARIMA(p,d,q) model using the SARIMAX function. We specify simple_differencing=False
    to prevent differencing. We also specify disp=False to avoid printing convergence
    messages to the console.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用SARIMAX函数拟合ARIMA(p,d,q)模型。我们指定simple_differencing=False以防止差分。我们还指定disp=False以避免将收敛消息打印到控制台。
- en: ❺ Calculate the model’s AIC.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 计算模型的AIC。
- en: ❻ Append the (p,q) combination and AIC as a tuple to the results list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将(p,q)组合和AIC作为元组追加到结果列表中。
- en: ❼ Store the (p,q) combination and AIC in a DataFrame.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将(p,q)组合和AIC存储在DataFrame中。
- en: ❽ Label the columns of your DataFrame.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 标记DataFrame的列。
- en: ❾ Sort the DataFrame in ascending order of AIC values. The lower the AIC, the
    better the model.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 按AIC值升序排序DataFrame。AIC越低，模型越好。
- en: With the function in place, we can define a list of possible values for the
    orders *p* and *q*. In this case, we’ll try the values 0, 1, 2, and 3 for both
    orders and generate the list of unique (*p*,*q*) combinations.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数就位后，我们可以定义可能的p和q的值列表。在这种情况下，我们将尝试为两个顺序尝试0、1、2和3的值，并生成唯一的(*p*,*q*)组合列表。
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Create a list of possible values for p from 0 inclusively to 4 exclusively,
    with steps of 1.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个可能的p值列表，从0（包含）到4（不包含），步长为1。
- en: ❷ Create a list of possible values for q from 0 inclusively to 4 exclusively,
    with steps of 1.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个可能的q值列表，从0（包含）到4（不包含），步长为1。
- en: ❸ Set d to 2, as the series needed to be differenced twice to become stationary.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将d设置为2，因为序列需要差分两次才能成为平稳。
- en: ❹ Generate a list containing all unique combinations of (p,q).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 生成一个包含所有唯一(p,q)组合的列表。
- en: 'Note that we do not give a range of values for the parameter *d* because it
    has a very specific definition: it is the number of times a series must be differenced
    to become stationary. Hence, it must be set to a specific value, which in this
    case is 2.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有给出参数*d*的值范围，因为它有一个非常具体的定义：它是序列必须差分多少次才能成为平稳的次数。因此，它必须设置为特定的值，在这种情况下是2。
- en: Furthermore, *d* must be constant in order to compare models using the AIC.
    Varying *d* would change the likelihood function used in the calculation of the
    AIC value, so comparing models using the AIC as a criterion would not be valid
    anymore.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，*d*必须保持恒定，以便使用AIC比较模型。*d*的变化将改变用于计算AIC值的似然函数，因此使用AIC作为比较标准的模型比较将不再有效。
- en: We can now run the `optimize_ARIMA` function using the training set. The function
    returns a `DataFrame` with the model that has the lowest AIC at the top.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用训练集运行`optimize_ARIMA`函数。该函数返回一个`DataFrame`，其中包含具有最低AIC值的模型。
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The training set consists of all data points except the last four.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 训练集包括所有数据点，除了最后四个。
- en: ❷ Run the optimize_ARIMA function to obtain the model with the lowest AIC.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 运行optimize_ARIMA函数以获得具有最低AIC值的模型。
- en: ❸ Display the resulting DataFrame.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 显示结果DataFrame。
- en: The returned `DataFrame` shows that a value of 3 for both *p* and *q* results
    in the lowest AIC. Therefore, an ARIMA(3,2,3) model seems to be the most suitable
    for this situation. Now let’s assess the validity of the model by studying its
    residuals.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的`DataFrame`显示，*p*和*q*的值都为3时，AIC值最低。因此，ARIMA(3,2,3)模型似乎是最适合这种情况的。现在让我们通过研究其残差来评估模型的合理性。
- en: To do so, we’ll fit an ARIMA(3,2,3) model on the training set and display the
    residuals’ diagnostics using the `plot_diagnostics` method. The result is shown
    in figure 7.7.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将在训练集上拟合一个ARIMA(3,2,3)模型，并使用`plot_diagnostics`方法显示残差的诊断结果。结果如图7.7所示。
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Fit an ARIMA(3,2,3) model on the training set, since this model has the lowest
    AIC.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由于该模型具有最低的AIC值，因此在训练集上拟合一个ARIMA(3,2,3)模型。
- en: ❷ Display the residuals’ diagnostics.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示残差的诊断。
- en: '![](../../OEBPS/Images/07-07.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-07.png)'
- en: Figure 7.7 Diagnostics of the ARIMA(3,2,3) residuals. The Q-Q plot at the bottom
    left displays a fairly straight line with some deviation at the extremities.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 ARIMA(3,2,3)残差的诊断。左下角的Q-Q图显示了一条相当直的线，两端有一些偏差。
- en: In figure 7.7, the top-left plot shows the residuals over time. While there
    is no trend in the residuals, the variance does not seem to be constant, which
    is a discrepancy in comparison to white noise. At the top right is the distribution
    of the residuals. We can see it is fairly close to a normal distribution. The
    Q-Q plot leads us to the same conclusion, as it displays a line that is fairly
    straight, meaning that the residuals’ distribution is close to a normal distribution.
    Finally, by looking at the correlogram at the bottom right, we can see that a
    coefficient seems to be significant at lag 3\. However, since it is not preceded
    by any significant autocorrelation coefficients, we can assume that this is due
    to chance. Therefore, we can say that the correlogram shows no significant coefficients
    after lag 0, just like white noise.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在图7.7中，左上角的图显示了随时间变化的残差。虽然残差中没有趋势，但方差似乎并不恒定，这与白噪声相比存在差异。右上角是残差的分布。我们可以看到它相当接近正态分布。Q-Q图得出相同的结论，因为它显示了一条相当直的线，这意味着残差的分布接近正态分布。最后，通过观察右下角的自相关图，我们可以看到似乎在滞后3处有一个系数是显著的。然而，由于它没有先前的任何显著的自相关系数，我们可以假设这是由于偶然。因此，我们可以说自相关图在滞后0之后没有显示显著的系数，就像白噪声一样。
- en: Thus, from a qualitative standpoint, it seems that our residuals are close to
    white noise, which is a good sign, as it means that the model’s errors are random.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从定性的角度来看，我们的残差似乎接近白噪声，这是一个好兆头，因为它意味着模型的误差是随机的。
- en: The last step is to evaluate the residuals from a quantitative standpoint. We’ll
    thus apply the Ljung-Box test to determine whether the residuals are correlated.
    We’ll apply the test on the first 10 lags and study the p-values. If all p-values
    are greater than 0.05, we cannot reject the null hypothesis and we’ll conclude
    that the residuals are not correlated, just like white noise.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是定量评估残差。因此，我们将应用Ljung-Box测试来确定残差是否相关。我们将对前10个滞后应用测试，并研究p值。如果所有p值都大于0.05，我们不能拒绝零假设，我们将得出结论，残差不相关，就像白噪声一样。
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Store the model’s residuals in a variable.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将模型的残差存储在一个变量中。
- en: ❷ Apply the Ljung-Box test on the first 10 lags.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对前10个滞后应用Ljung-Box测试。
- en: Running the Ljung-Box test on the first 10 lags of the model’s residuals returns
    a list of p-values that are all larger than 0.05\. Therefore, we do not reject
    the null hypothesis, and we conclude that the residuals are not correlated, just
    like white noise.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型残差的前10个滞后上运行Ljung-Box测试返回一系列p值，这些p值都大于0.05。因此，我们无法拒绝零假设，我们得出结论，残差不相关，就像白噪声一样。
- en: Our ARIMA(3,2,3) model has passed all the checks, and it can now be used for
    forecasting. Remember that our test set is the last four data points, corresponding
    to the four quarterly EPS reported in 1980\. As a benchmark for our model, we
    will use the naive seasonal method. This means that we’ll take the EPS of the
    first quarter of 1979 and use it as a forecast for the EPS of the first quarter
    of 1980\. Then the EPS of the second quarter of 1979 will be used as a forecast
    for the EPS of the second quarter of 1980, and so on. Remember that we need a
    benchmark, or a baseline model, when modeling to determine whether the model we
    develop is better than a naive method. The performance of a model must always
    be assessed relative to a baseline model.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的ARIMA(3,2,3)模型已经通过了所有检查，现在可以用于预测。记住，我们的测试集是最后四个数据点，对应于1980年报告的四个季度EPS。作为我们模型的基准，我们将使用简单季节性方法。这意味着我们将使用1979年第一季度的EPS作为1980年第一季度的EPS的预测。然后，1979年第二季度的EPS将用于预测1980年第二季度的EPS，依此类推。记住，在建模时需要一个基准或基线模型，以确定我们开发的模型是否优于简单方法。模型的性能必须始终相对于基线模型来评估。
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ The test set corresponds to the last four data points.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 测试集对应于最后四个数据点。
- en: ❷ The naive seasonal forecast is implemented by selecting the quarterly EPS
    reported in 1979 and using the same values as a forecast for the year 1980.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 简单季节性预测是通过选择1979年报告的季度EPS并使用相同的值作为1980年的预测来实现的。
- en: With our baseline in place, we can now make forecasts using the ARIMA(3,2,3)
    model and store the results in the ARIMA_pred column.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立基准后，我们现在可以使用ARIMA(3,2,3)模型进行预测，并将结果存储在ARIMA_pred列中。
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Get the predicted values for the year 1980.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取1980年的预测值。
- en: ❷ Assign the forecasts to the ARIMA_pred column.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将预测值分配给ARIMA_pred列。
- en: Let’s visualize our forecasts to see how close the predictions from each method
    are to the observed values. The resulting plot is shown in figure 7.8.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们可视化我们的预测，看看每种方法的预测值与观察值有多接近。结果图如图7.8所示。
- en: '![](../../OEBPS/Images/07-08.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-08.png)'
- en: Figure 7.8 Forecasts of the quarterly EPS of Johnson & Johnson in 1980\. We
    can see that the predictions coming from the ARIMA(3,2,3) model, shown as a dashed
    line, almost perfectly overlap the observed data in 1980.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8展示了1980年Johnson & Johnson季度EPS的预测。我们可以看到，ARIMA(3,2,3)模型（以虚线表示）的预测几乎完美地与1980年的观察数据重叠。
- en: In figure 7.8 we can see the naive seasonal forecast as a dotted line and the
    ARIMA(3,2,3) forecasts as a dashed line. The ARIMA(3,2,3) model predicted the
    quarterly EPS with a very small error.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '在图7.8中，我们可以看到简单季节性预测以虚线表示，ARIMA(3,2,3)预测以虚线表示。ARIMA(3,2,3)模型以非常小的误差预测了季度EPS。 '
- en: We can quantify that error by measuring the mean absolute percentage error (MAPE)
    and display the metric for each forecasting method in a bar plot, as shown in
    figure 7.9.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过测量平均绝对百分比误差（MAPE）来量化这个误差，并在条形图中显示每种预测方法的指标，如图7.9所示。
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Define a function to compute the MAPE.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个计算MAPE的函数。
- en: ❷ Compute the MAPE for the naive seasonal method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算简单季节性方法的MAPE。
- en: ❸ Compute the MAPE for the ARIMA(3,2,3) model.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算ARIMA(3,2,3)模型的MAPE。
- en: '![](../../OEBPS/Images/07-09.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-09.png)'
- en: Figure 7.9 The MAPE for both forecasting methods. You can see that the ARIMA
    model has an error metric that is one fifth of the baseline.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9展示了两种预测方法的MAPE。你可以看到ARIMA模型具有一个误差指标，是基准值的五分之一。
- en: In figure 7.9, you can see that the MAPE for the naive seasonal forecast is
    11.56%, while the MAPE for the ARIMA(3,2,3) model is 2.19%, which roughly one
    fifth of the benchmark value. This means that our predictions are on average 2.19%
    off from the actual values. The ARIMA(3,2,3) model is clearly a better model than
    the naive seasonal method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在图7.9中，你可以看到简单季节性预测的MAPE为11.56%，而ARIMA(3,2,3)模型的MAPE为2.19%，大约是基准值的五分之一。这意味着我们的预测值平均偏离实际值2.19%。ARIMA(3,2,3)模型显然比简单季节性方法更好。
- en: 7.4 Next steps
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 下一步
- en: In this chapter, we covered the ARIMA(*p*,*d*,*q*) model, which allows us to
    model and forecast non-stationary time series.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 ARIMA(*p*,*d*,*q*)模型，它允许我们模拟和预测非平稳时间序列。
- en: The order of integration *d* defines how many times a series must be differenced
    to become stationary. This parameter then allows us to fit the model on the original
    series and get a forecast in the same scale, unlike the ARMA(*p*,*q*) model, which
    required the series to be stationary for the model to be applied and required
    us to reverse the transformations on the forecasts.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 积分阶数 *d* 定义了一个系列必须差分的次数，以使其平稳。该参数然后允许我们在原始系列上拟合模型，并得到相同尺度的预测，与 ARMA(*p*,*q*)模型不同，后者要求系列平稳才能应用模型，并要求我们对预测进行反向转换。
- en: To apply the ARIMA(*p*,*d*,*q*) model, we added an extra step to our general
    modeling procedure, which simply involves finding the value for the order of integration.
    This corresponds to the minimum number of times a series must be differenced to
    become stationary.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用 ARIMA(*p*,*d*,*q*)模型，我们在一般建模程序中添加了一个额外的步骤，这仅仅涉及找到积分阶数的值。这对应于一个系列必须差分的最小次数以使其平稳。
- en: 'Now we can add another layer to the ARIMA(*p*,*d*,*q*) model that allows us
    to consider yet another property of time series: seasonality. We have studied
    the Johnson & Johnson dataset enough times to realize that there are clear cyclical
    patterns in the series. To integrate the seasonality of a series in a model, we
    must use the *seasonal autoregressive integrated moving average* (SARIMA) model,
    or SARIMA(*p*,*d*,*q*)(*P*,*D*,*Q*)*[m]*. This will be the subject of the next
    chapter.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以给 ARIMA(*p*,*d*,*q*)模型添加另一个层，使我们能够考虑时间序列的另一个属性：季节性。我们已经足够多地研究了 Johnson
    & Johnson 数据集，以意识到该系列中存在明显的周期性模式。为了在模型中整合一个系列的季节性，我们必须使用*季节性自回归积分移动平均*（SARIMA）模型，或
    SARIMA(*p*,*d*,*q*)(*P*,*D*,*Q*)*[m]*。这将是下一章的主题。
- en: 7.5 Exercises
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 练习
- en: 'Now is the time to apply the ARIMA model on previous datasets that we have
    explored. The full solution to this exercise is available on GitHub: [https://github.com/marcopeix/
    TimeSeriesForecastingInPython/tree/master/CH07](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH07).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将 ARIMA 模型应用于我们之前探索过的数据集了。这个练习的完整解决方案可以在 GitHub 上找到：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH07](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH07)。
- en: 7.5.1 Apply the ARIMA(p,d,q) model on the datasets from chapters 4, 5, and 6
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.1 在第 4、5 和 6 章的数据集上应用 ARIMA(p,d,q)模型
- en: In chapters 4, 5, and 6, non-stationary time series were introduced to show
    you how to apply the MA(*q*), AR(*p*), and ARMA(*p*,*q*) models. In each chapter,
    we transformed the series to make it stationary, fit the model, made forecasts,
    and had to reverse the transformation on the forecasts to bring them back to the
    original scale of the data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4、5 和 6 章中，介绍了非平稳时间序列，以向您展示如何应用 MA(*q*)、AR(*p*) 和 ARMA(*p*,*q*)模型。在每个章节中，我们将系列转换为使其平稳，拟合模型，进行预测，并必须在预测上反向转换以将它们恢复到数据的原始尺度。
- en: 'Now that you know how to account for non-stationary time series, revisit each
    dataset and apply the ARIMA(*p*,*d*,*q*) model. For each dataset, do the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何处理非平稳时间序列，重新审视每个数据集，并应用 ARIMA(*p*,*d*,*q*)模型。对于每个数据集，执行以下操作：
- en: Apply the general modeling procedure.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用一般建模程序。
- en: Is an ARIMA(0,1,2) model suitable for the dataset in chapter 4?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ARIMA(0,1,2)模型适合第 4 章的数据集吗？
- en: Is an ARIMA(3,1,0) model suitable for the dataset in chapter 5?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ARIMA(3,1,0)模型适合第 5 章的数据集吗？
- en: Is an ARIMA(2,1,2) model suitable for the dataset in chapter 6?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ARIMA(2,1,2)模型适合第 6 章的数据集吗？
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The autoregressive integrated moving average model, denoted as ARIMA(*p*,*d*,*q*),
    is the combination of the autoregressive model AR(*p*), the order of integration
    *d*, and the moving average model MA(*q*).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自回归积分移动平均模型，表示为 ARIMA(*p*,*d*,*q*)，是自回归模型 AR(*p*)、积分阶数 *d* 和移动平均模型 MA(*q*)的组合。
- en: The ARIMA(*p*,*d*,*q*) model can be applied on non-stationary time series and
    has the added advantage of returning forecasts in the same scale as the original
    series.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARIMA(*p*,*d*,*q*)模型可以应用于非平稳时间序列，并且具有返回与原始系列相同尺度的预测的附加优势。
- en: The order of integration *d* is equal to the minimum number of times a series
    must be differenced to become stationary.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 积分阶数 *d* 等于一个系列必须差分的最小次数，以使其平稳。
- en: An ARIMA(*p*,0,*q*) model is equivalent to an ARMA(*p*,*q*) model.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARIMA(*p*,0,*q*)模型等同于 ARMA(*p*,*q*)模型。
