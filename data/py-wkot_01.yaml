- en: 1 Numeric types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 数字类型
- en: 'Whether you’re calculating salaries, bank interest, or cellular frequencies,
    it’s hard to imagine a program that doesn’t use numbers in one way or another.
    Python has three different numeric types: `int`, `float`, and `complex`. For most
    of us, it’s enough to know about (and work with) `int` (for whole numbers) and
    `float` (for numbers with a fractional component).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是计算工资、银行利息还是蜂窝频率，很难想象一个不使用数字的程序。Python 有三种不同的数字类型：`int`、`float`和`complex`。对我们大多数人来说，了解（并使用）`int`（用于整数）和`float`（用于带小数部分的数字）就足够了。
- en: Numbers are not only fundamental to programming, but also give us a good introduction
    to how a programming language operates. Understanding how variable assignment
    and function arguments work with integers and floats will help you to reason about
    more complex types, such as strings, tuples, and dicts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数字不仅是编程的基础，而且也为我们提供了一个很好的入门，了解编程语言是如何运行的。理解变量赋值和函数参数如何与整数和浮点数一起工作，将有助于你推理更复杂的数据类型，如字符串、元组和字典。
- en: This chapter contains exercises that work with numbers, as inputs and as outputs.
    Although working with numbers can be fairly basic and straightforward, converting
    between them, and integrating them with other data types, can sometimes take time
    to get used to.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含一些与数字相关的练习，这些数字既是输入也是输出。尽管处理数字可能相当基础和直接，但它们之间的转换以及与其他数据类型的集成有时可能需要一些时间来适应。
- en: Useful references
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的参考资料
- en: Table 1.1 What you need to know
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 你需要知道的内容
- en: '| Concept | What is it? | Example | To learn more |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 概念 | 它是什么？ | 示例 | 了解更多 |'
- en: '| `random` | Module for generating random numbers and selecting random elements
    | `number = random.randint(1, 100)` | [http://mng.bz/Z2wj](http://mng.bz/Z2wj)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| `random` | 用于生成随机数和选择随机元素的模块 | `number = random.randint(1, 100)` | [http://mng.bz/Z2wj](http://mng.bz/Z2wj)
    |'
- en: '| Comparisons | Operators for comparing values | `x < y` | [http://mng.bz/oPJj](http://mng.bz/oPJj)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 比较运算符 | 用于比较值的运算符 | `x < y` | [http://mng.bz/oPJj](http://mng.bz/oPJj) |'
- en: '| f-strings | Strings into which expressions can be interpolated | `f`''`It
    is currently {datetime.datetime .now()}''` | [http://mng.bz/1z6Z](http://mng.bz/1z6Z)
    and [http://mng.bz/PAm2](http://mng.bz/PAm2) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| f-strings | 可以插入表达式的字符串 | `f`''`It is currently {datetime.datetime .now()}''``
    | [http://mng.bz/1z6Z](http://mng.bz/1z6Z) 和 [http://mng.bz/PAm2](http://mng.bz/PAm2)
    |'
- en: '| `for` loops | Iterates over the elements of an iterable | `for i in range(10):
    print(i*i)` | [http://mng.bz/Jymp](http://mng.bz/Jymp) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `for` 循环 | 遍历可迭代对象的元素 | `for i in range(10): print(i*i)` | [http://mng.bz/Jymp](http://mng.bz/Jymp)
    |'
- en: '| `input` | Prompts the user to enter a string, and returns a string | `input(''Enter
    your name: '')` | [http://mng.bz/wB27](http://mng.bz/wB27) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `input` | 提示用户输入一个字符串，并返回一个字符串 | `input(''Enter your name: '')` | [http://mng.bz/wB27](http://mng.bz/wB27)
    |'
- en: '| `enumerate` | Helps us to number elements of iterables | `for index, item
    in enumerate(''abc''): print(f''{index}: {item}'')` | [http://mng.bz/qM1K](http://mng.bz/qM1K)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `enumerate` | 帮助我们对可迭代对象的元素进行编号 | `for index, item in enumerate(''abc''):
    print(f''{index}: {item}'')` | [http://mng.bz/qM1K](http://mng.bz/qM1K) |'
- en: '| `reversed` | Returns an iterator with the reversed elements of an iterable
    | `r = reversed(''abcd'')` | [http://mng.bz/7XYx](http://mng.bz/7XYx) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `reversed` | 返回一个包含可迭代对象反转元素的迭代器 | `r = reversed(''abcd'')` | [http://mng.bz/7XYx](http://mng.bz/7XYx)
    |'
- en: Exercise 1 ■ Number guessing game
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1 ■ 数字猜谜游戏
- en: 'This first exercise is designed to get your fingers warmed up for the rest
    of the book. It also introduces a number of topics that will repeat themselves
    over your Python career: loops, user input, converting types, and comparing values.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个练习是为了让你为本书的其余部分做好准备。它还介绍了一些将在你的 Python 职业生涯中反复出现的话题：循环、用户输入、类型转换和值比较。
- en: More specifically, programs all have to get input to do something interesting,
    and that input often comes from the user. Knowing how to ask the user for input
    not only is useful, but allows us to think about the type of data we’re getting,
    how to convert it into a format we can use, and what the format would be.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，所有程序都必须获取输入才能执行有趣的操作，而这个输入通常来自用户。知道如何向用户请求输入不仅很有用，而且还能让我们思考我们正在获取的数据类型，如何将其转换为我们可以使用的格式，以及该格式会是什么。
- en: 'As you might know, Python only provides two kinds of loops: `for` and `while`.
    Knowing how to write and use them will serve you well throughout your Python career.
    The fact that nearly every type of data knows how to work inside of a `for` loop
    makes such loops common and useful. If you’re working with database records, elements
    in an XML file, or the results from searching for text using regular expressions,
    you’ll be using `for` loops quite a bit.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Python只提供两种循环类型：`for`和`while`。了解如何编写和使用它们将使你在整个Python生涯中受益。几乎每种类型的数据都知道如何在`for`循环中工作，这使得这种循环变得常见且有用。如果你正在处理数据库记录、XML文件中的元素或使用正则表达式搜索文本的结果，你将相当多地使用`for`循环。
- en: For this exercise
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习
- en: Write a function (`guessing_game`) that takes no arguments.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个不带参数的函数（`guessing_game`）。
- en: When run, the function chooses a random integer between 0 and 100 (inclusive).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当运行时，该函数会在0到100（包括）之间选择一个随机整数。
- en: Then ask the user to guess what number has been chosen.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后要求用户猜测被选中的数字是什么。
- en: 'Each time the user enters a guess, the program indicates one of the following:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次用户输入一个猜测时，程序会指示以下之一：
- en: Too high
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 太高了
- en: Too low
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 太低了
- en: Just right
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刚好
- en: If the user guesses correctly, the program exits. Otherwise, the user is asked
    to try again.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户猜对了，程序就会退出。否则，用户会被要求再试一次。
- en: The program only exits after the user guesses correctly.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序只有在用户猜对后才会退出。
- en: We’ll use the `randint` ([http://mng.bz/mBEn](http://mng.bz/mBEn)) function
    in the `random` module to generate a random number. Thus, you can say
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`random`模块中的`randint`函数来生成随机数。因此，你可以这样说
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: and `number` will contain an integer from 10 to (and including) 30\. We can
    then do whatever we want with `number`--print it, store it, pass it to a function,
    or use it in a calculation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 并且`number`将包含一个从10到（包括）30的整数。然后我们可以对`number`做任何我们想做的事情——打印它、存储它、将其传递给一个函数或用它进行计算。
- en: 'We’ll also be prompting the user to enter text with the `input` function. We’ll
    actually be using `input` quite a bit in this book to ask the user to tell us
    something. The function takes a single string as an argument, which is displayed
    to the user. The function then returns the string containing whatever the user
    entered; for example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`input`函数提示用户输入文本。实际上，在这本书中，我们会多次使用`input`来让用户告诉我们一些信息。该函数接受一个字符串参数，并将其显示给用户。然后函数返回用户输入的字符串；例如：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Note* If the user simply presses Enter when presented with the `input` prompt,
    the value returned by `input` is an empty string, not `None`. Indeed, the return
    value from `input` will always be a string, regardless of what the user entered.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 如果用户在`input`提示时仅按下Enter键，`input`返回的值是一个空字符串，而不是`None`。实际上，无论用户输入了什么，`input`的返回值始终是一个字符串。'
- en: '*Note* In Python 2, you would ask the user for input using the `raw_input`
    function. Python 2’s `input` function was considered dangerous, since it would
    ask the user for input and then evaluate the resulting string using the `eval`
    function. (If you’re interested, see [http://mng.bz/6QGG](http://mng.bz/6QGG).)
    In Python 3, the dangerous function has gone away, and the safe one has been renamed
    `input`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 在Python 2中，你会使用`raw_input`函数来获取用户输入。Python 2的`input`函数被认为是有危险的，因为它会要求用户输入，然后使用`eval`函数评估返回的字符串。（如果你感兴趣，请参阅[http://mng.bz/6QGG](http://mng.bz/6QGG)。）在Python
    3中，这个危险的函数已经消失，而安全的函数已被重命名为`input`。'
- en: Working it out
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: At its heart, this program is a simple application of the comparison operators
    (`==`, `<`, and `>`) to a number, such that a user can guess the random integer
    that the computer has chosen. However, several aspects of this program merit discussion.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，这个程序是简单应用比较运算符（`==`、`<`和`>`）到数字上，这样用户就可以猜测计算机选择的随机整数。然而，这个程序有几个方面值得讨论。
- en: First and foremost, we use the `random` module to generate a random number.
    After importing `random`, we can then invoke `random.randint`, which takes two
    parameters, returning a random integer. In general, the `random` module is a useful
    tool whenever you need to choose a random value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先也是最重要的，我们使用`random`模块来生成随机数。在导入`random`之后，我们可以调用`random.randint`，它接受两个参数，返回一个随机整数。一般来说，`random`模块是在你需要选择一个随机值时非常有用的工具。
- en: Note that the maximum number in `random.randint` is inclusive. This is unusual
    in Python; most of the time, such ranges in Python are exclusive, meaning that
    the higher number is not included.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`random.randint`中的最大数是包含在内的。这在Python中是不寻常的；大多数情况下，Python中的这种范围是排他的，意味着较高的数字不包括在内。
- en: '*Tip* The `random` module doesn’t just generate random numbers. It also has
    functions to choose one or more elements from a Python sequence.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示* `random` 模块不仅生成随机数，它还有从 Python 序列中选择一个或多个元素的功能。'
- en: Now that the computer has chosen a number, it’s the user’s turn to guess what
    that number is. Here, we start an infinite loop in Python, which is most easily
    created with `while` `True`. Of course, it’s important that there be a way to
    break out of the loop; in this case, it will be when the user correctly guesses
    the value of `answer`. When that happens, the `break` command is used to exit
    from the innermost loop.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在计算机已经选择了一个数字，轮到用户猜测这个数字了。在这里，我们使用 `while True` 在 Python 中启动一个无限循环，这是通过 `while`
    `True` 最容易创建的。当然，重要的是要有一种方法可以跳出循环；在这种情况下，当用户正确猜测 `answer` 的值时，将使用 `break` 命令退出最内层的循环。
- en: 'The `input` ([http://mng.bz/wB27](http://mng.bz/wB27)) function always returns
    a string. This means that if we want to guess a number, we must turn the user’s
    input string into an integer. This is done in the same way as all conversions
    in Python: by using the target type as a function, passing the source value as
    a parameter. Thus `int(''5'')` will return the integer 5, whereas `str(5)` will
    return the string `''5''`. You can also create new instances of more complex types
    by invoking the class as a function, as in `list(''abc'')` or `dict([(''a'',`
    `1),` `(''b'',` `2),` `(''c'',` `3)])`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`input` ([http://mng.bz/wB27](http://mng.bz/wB27)) 函数总是返回一个字符串。这意味着如果我们想猜测一个数字，我们必须将用户的输入字符串转换为一个整数。这就像
    Python 中的所有转换一样完成：通过使用目标类型作为函数，传递源值作为参数。因此 `int(''5'')` 将返回整数 5，而 `str(5)` 将返回字符串
    `''5''`。你还可以通过将类作为函数调用创建更复杂类型的新实例，例如 `list(''abc'')` 或 `dict([(''a'', 1), (''b'',
    2), (''c'', 3)])`。'
- en: In Python 3, you can’t use `<` and `>` to compare different types. If you neglect
    to turn the user’s input into an integer, the program will exit with an error,
    saying that it can’t compare a string (i.e., the user’s input) with an integer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3 中，你不能使用 `<` 和 `>` 来比较不同类型。如果你忘记将用户的输入转换为整数，程序将因错误退出，表示它不能比较字符串（即用户的输入）和整数。
- en: '*Note* In Python 2, it wasn’t an error to compare objects of different types.
    But the results you would get were a bit surprising, if you didn’t know what to
    expect. That’s because Python would first compare them by type, and then compare
    them within that type. In other words, all integers were smaller than all lists,
    and all lists were smaller than all strings. Why would you ever want to use `<`
    and `>` on objects of different types? You probably wouldn’t, and I found that
    this functionality confused people more than it helped them. In Python 3, you
    can’t make such a comparison; trying to check with `1` `<` `[10,` `20,` `30]`
    will result in a `TypeError` exception.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 在 Python 2 中，比较不同类型的对象并不是一个错误。但如果你不知道期望的结果，你得到的结果可能会有些令人惊讶。这是因为 Python
    会首先按类型比较它们，然后在那个类型内进行比较。换句话说，所有整数都小于所有列表，所有列表都小于所有字符串。你为什么要比较不同类型的对象上的 `<` 和 `>`
    呢？你可能不会这样做，我发现这个功能比帮助人们更多是让人困惑。在 Python 3 中，你不能进行这样的比较；尝试使用 `1 < [10, 20, 30]`
    将会引发一个 `TypeError` 异常。'
- en: In this exercise, and the rest of this book, I use *f-strings* to insert values
    from variables into our strings. I’m a big fan of f-strings and encourage you
    to try them as well. (See the sidebar discussing f-strings later in this chapter.)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习以及本书的其余部分，我使用 *f-strings* 将变量中的值插入到我们的字符串中。我是 f-strings 的忠实粉丝，并鼓励你也尝试一下。（本章后面将讨论
    f-strings 的侧边栏。）
- en: Saved by the walrus
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 被海象救了
- en: 'People coming to Python from other languages are often surprised to find `while`
    `True` loops, in which we then trap user input and break. Isn’t there a better
    way? Some suggest using the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从其他语言转向 Python 的人通常会惊讶地发现 `while True` 循环，然后我们捕捉用户输入并跳出。难道没有更好的方法吗？有些人建议使用以下代码：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This makes a lot of sense--we’ll ask the user for their input and assign that
    to `s`. However, the value assigned to `s` will then be passed to `while`, which
    will evaluate it as a Boolean. If we get an empty string, then the Boolean value
    is `False`, and we exit from the loop.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有道理——我们将要求用户输入并分配给 `s`。然而，分配给 `s` 的值将被传递给 `while`，它将评估它作为一个布尔值。如果我们得到一个空字符串，那么布尔值就是
    `False`，然后我们退出循环。
- en: 'There’s just one problem with this code: it won’t work. That’s because assignment
    in Python is not an expression--that is, it doesn’t return a value. If it doesn’t
    return a value, then it can’t be used in a `while` loop.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有一个问题：它不会工作。那是因为Python中的赋值不是一个表达式——也就是说，它不会返回一个值。如果它不返回一个值，那么它就不能用在`while`循环中。
- en: As of Python 3.8, that has changed somewhat. This version introduced the “assignment
    expression” operator, which looks like `:=` (a colon followed by an equal sign).
    But no one really calls it the “assignment expression operator”; from early on,
    it’s been called the “walrus operator.” Also from early on, this operator has
    been highly controversial. Some people have said that it introduced unnecessary
    complexity and potential bugs into the language.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Python 3.8，情况有所改变。这个版本引入了“赋值表达式”运算符，其外观类似于 `:=`（一个冒号后跟一个等号）。但没有人真的称它为“赋值表达式运算符”；从一开始，它就被称为“海象运算符”。而且从一开始，这个运算符就极具争议。有些人说，它给语言引入了不必要的复杂性以及潜在的bug。
- en: 'Here’s how the previous loop would look in Python 3.8:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是之前的循环在Python 3.8中的样子：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the walrus operator in the language, we can finally be rid of `while` `True`
    loops and their potential for havoc! But wait--don’t we need to worry about the
    weird effects of assignment in a `while` loop’s condition? Maybe, and that’s part
    of the controversy. But I was convinced, in no small part, by the fact that regular
    assignment and the assignment operator are not interchangeable; where one can
    be used, the other cannot. I think that reduces the potential for abuse.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言中引入海象运算符后，我们终于可以摆脱`while` `True`循环及其潜在的破坏性！但是等等——我们不需要担心`while`循环条件中赋值的奇怪影响吗？也许吧，这也是争议的一部分。但我很大程度上被这样一个事实所说服，即常规赋值和赋值运算符是不可互换的；在一个可以使用的位置，另一个就不能使用。我认为这减少了滥用的可能性。
- en: 'If you want to learn more about the walrus operator, its controversy, and why
    it’s actually quite useful, I suggest that you watch the following talk from PyCon
    2019, in which Dustin Ingram makes an effective case for it: [http://mng.bz/nPxv](http://mng.bz/nPxv).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于海象运算符的信息，它的争议以及为什么它实际上非常有用，我建议你观看2019年PyCon上的以下演讲，其中Dustin Ingram对其进行了有效的辩护：[http://mng.bz/nPxv](http://mng.bz/nPxv)。
- en: 'You can also read more about this operator in PEP 572, where it was introduced
    and defined: [http://mng.bz/vxOx](http://mng.bz/vxOx).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在PEP 572中了解更多关于这个运算符的信息，它介绍了并定义了这个运算符：[http://mng.bz/vxOx](http://mng.bz/vxOx)。
- en: Solution
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    vx1q](http://mng.bz/vx1q).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中尝试这个代码的版本：[http://mng.bz/vx1q](http://mng.bz/vx1q)。
- en: '*Note* We’re going to assume, for the purposes of this exercise, that our user
    will only enter valid data, namely integers. Remember that the `int` function
    normally assumes that we’re giving it a decimal number, which means that its argument
    may contain only digits. If you really want to be pedantic, you can use the `str.isdigit`
    method ([http://mng.bz/oPVN](http://mng.bz/oPVN)) to check that a string contains
    only digits. Or you can trap the `ValueError` exception you’ll get if you run
    `int` on something that can’t be turned into an integer.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 在这个练习的目的上，我们将假设我们的用户只会输入有效数据，即整数。记住，`int`函数通常假设我们给它的是一个十进制数，这意味着它的参数可能只包含数字。如果你真的很挑剔，你可以使用`str.isdigit`方法([http://mng.bz/oPVN](http://mng.bz/oPVN))来检查一个字符串是否只包含数字。或者，你可以捕获当你对不能转换为整数的对象运行`int`时得到的`ValueError`异常。'
- en: Walk through your code using Python Tutor
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python Tutor 遍历你的代码
- en: In this book, I use many diagrams from the Python Tutor ([http://mng.bz/2XJX](http://mng.bz/2XJX)),
    an amazing online resource for teaching and learning Python. (I often use it in
    my in-person classes.) You can enter nearly any Python code into the site and
    then walk through its execution, piece by piece. Most of the solutions in this
    book have a link pointing to the code in the Python Tutor so that you can run
    it without typing it into the site.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我使用了来自Python Tutor([http://mng.bz/2XJX](http://mng.bz/2XJX))的许多图表，这是一个用于教授和学习Python的惊人在线资源。（我经常在面授课程中使用它。）你可以将几乎任何Python代码输入到网站上，然后逐个步骤地遍历其执行。这本书中的大多数解决方案都有一个链接指向Python
    Tutor中的代码，这样你就可以运行它而无需在网站上输入。
- en: In the Python Tutor, global variables (including functions and classes) are
    shown in the *global frame*. Remember that if you define a variable outside a
    function, you’ve created a global variable. Any variables you create inside a
    function are local variables--and are shown, in the Python Tutor, inside their
    own shaded boxes. Simple data structures, such as integers and strings, are shown
    alongside the variables pointing to them, whereas lists, tuples, and dicts are
    shown in graphical format.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python Tutor中，全局变量（包括函数和类）显示在*全局框架*中。记住，如果你在函数外部定义了一个变量，你就创建了一个全局变量。你函数内部创建的任何变量都是局部变量——在Python
    Tutor中，它们会在自己的阴影框内显示。简单数据结构，如整数和字符串，会与指向它们的变量并排显示，而列表、元组和字典则以图形格式显示。
- en: Screencast solution
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'You’ll often be getting input from users, and because it comes as a string,
    you’ll often need to convert it into other types, such as (in this exercise) integers.
    Here are some additional ideas for ways to practice this idea:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会从用户那里获取输入，由于它以字符串的形式出现，你通常需要将其转换为其他类型，例如（在本练习中）整数。以下是一些练习这个想法的额外想法：
- en: Modify this program, such that it gives the user only three chances to guess
    the correct number. If they try three times without success, the program tells
    them that they didn’t guess in time and then exits.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改这个程序，使其只给用户三次猜测正确数字的机会。如果他们尝试三次仍未成功，程序会告诉他们没有及时猜出，然后退出。
- en: Not only should you choose a random number, but you should also choose a random
    number base, from 2 to 16, in which the user should submit their input. If the
    user inputs “10” as their guess, you’ll need to interpret it in the correct number
    base; “10” might mean 10 (decimal), or 2 (binary), or 16 (hexadecimal).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不仅应该选择一个随机数，还应该选择一个从2到16的随机数基，用户应该在这个数基下提交他们的输入。如果用户输入“10”作为他们的猜测，你需要将其解释为正确的数基；“10”可能表示十进制中的10，或二进制中的2，或十六进制中的16。
- en: Try the same thing, but have the program choose a random word from the dictionary,
    and then ask the user to guess the word. (You might want to limit yourself to
    words containing two to five letters, to avoid making it too horribly difficult.)
    Instead of telling the user that they should guess a smaller or larger number,
    have them choose an earlier or later word in the dict.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试同样的事情，但让程序从字典中随机选择一个单词，然后要求用户猜测这个单词。（你可能想限制自己只猜测包含两个到五个字母的单词，以避免使其过于困难。）而不是告诉用户他们应该猜测一个更小或更大的数字，让他们选择字典中的更早或更晚的单词。
- en: f-strings
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: f-字符串
- en: Many people, when doing the “number guessing game” exercise, try to print a
    combination of a string and a number, such as “You guessed 5.” They quickly discover
    that Python doesn’t allow you to add (using `+`) strings and integers. How, then,
    can you include both types in the same line of output?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当许多人做“数字猜谜游戏”练习时，试图打印字符串和数字的组合，例如“你猜了5。”他们很快发现Python不允许你使用`+`操作符将字符串和整数相加。那么，你如何在同一行输出中包含这两种类型呢？
- en: 'This problem has long troubled newcomers to Python from other languages. The
    earliest method was to use the `%` operator on a string:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题长期以来一直困扰着从其他语言转向Python的新手。最早的方法是在字符串上使用`%`运算符：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While C programmers rejoiced at having something that worked like `printf`,
    everyone else found this technique to be frustrating. Among other things, `%`
    wasn’t super-intuitive for new developers, forced you to use parentheses when
    passing more than one argument, and didn’t let you reference repeated values easily.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当C语言程序员为拥有类似`printf`的功能而欢呼时，其他人却发现这种技术令人沮丧。其中，`%`符号对新开发者来说并不直观，在传递多个参数时被迫使用括号，而且无法轻松地引用重复的值。
- en: It was thus a vast improvement when the `str.format` method was introduced into
    Python, letting us say
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python中引入了`str.format`方法时，这无疑是一个巨大的改进，它让我们可以说
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Whereas I loved the use of `str.format`, many newcomers to Python found it a
    bit hard to use and very long. In particular, they didn’t like the idea of referencing
    variables on the left and giving values on the right. And the syntax inside of
    the curly braces was unique to Python, which was frustrating for all.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我喜欢使用`str.format`，但许多Python新手发现它有点难用，而且非常长。特别是，他们不喜欢在左边引用变量，在右边给出值的想法。而且大括号内的语法是Python特有的，这对所有人来说都很令人沮丧。
- en: 'Python 3.6 introduced *f-strings*, which are similar to the sort of double-quoted
    strings programmers in Perl, PHP, Ruby, and Unix shells have enjoyed for decades.
    f-strings work basically the same way as `str.format` but without having to pass
    parameters:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.6 引入了 *f 字符串*，这与 Perl、PHP、Ruby 和 Unix Shell 程序员几十年来所享受的双引号字符串类似。f 字符串基本上与
    `str.format` 的工作方式相同，但无需传递参数：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It’s actually even better than that. You can put whatever expression you want
    inside the curly braces, and it’ll be evaluated when the string is evaluated;
    for example
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它甚至比这还要好。你可以在花括号内放置任何你想要的表达式，当字符串被评估时，它将被评估；例如
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also affect the formatting of each data type by putting a code after
    a colon (`:`) inside of the curly braces. For example, you can force the string
    to be aligned left or right, on a field of 10 hash marks (`#`), with the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在花括号内冒号（`:`）后面放置代码来影响每种数据类型的格式。例如，你可以强制字符串左对齐或右对齐，在一个包含 10 个井号（`#`）的字段中，如下所示：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '❶ The format code #<10 means that the string should be placed, left-aligned,
    in a field of 10 characters, with # placed wherever the word doesn’t fill it.
    The format code #>10 means the same thing, but right-aligned.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ 格式代码 #<10 表示字符串应放置在 10 个字符的字段中，左对齐，井号放置在单词未填满的地方。格式代码 #>10 表示相同的意思，但右对齐。'
- en: I definitely encourage you to take a look at f-strings and to use them. They’re
    one of my favorite changes to Python from the last few years.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你查看 f 字符串并使用它们。它们是我过去几年最喜欢的 Python 改进之一。
- en: 'For more information on f-strings, check the following resources:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 f 字符串的更多信息，请查看以下资源：
- en: 'A comparison of Python formatting options, including f-strings: [http://mng.bz/
    Qygm](http://mng.bz/Qygm)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 格式化选项的比较，包括 f 字符串：[http://mng.bz/ Qygm](http://mng.bz/Qygm)
- en: 'A long article about f-strings and how they can be used: [http://mng.bz/XPAY](http://mng.bz/XPAY)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一篇关于 f 字符串及其如何使用的长篇文章：[http://mng.bz/XPAY](http://mng.bz/XPAY)
- en: 'The PEP in which f-strings were introduced: [http://mng.bz/1z6Z](http://mng.bz/1z6Z)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: f 字符串是在以下 PEP 中引入的：[http://mng.bz/1z6Z](http://mng.bz/1z6Z)
- en: What if you’re still using Python 2 and can’t use f-strings? Then you can and
    should still use `str.format`, a string method that works approximately the same
    way, but with less flexibility. Plus, you have to call the method, and reference
    the arguments by number or name.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍在使用 Python 2 并且不能使用 f 字符串怎么办？那么你仍然可以使用 `str.format`，这是一个字符串方法，它的工作方式大致相同，但灵活性较低。此外，你必须调用该方法，并通过数字或名称引用参数。
- en: Exercise 2 ■ Summing numbers
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2 ■ 求和数字
- en: One of my favorite types of exercises involves reimplementing functionality
    that we’ve seen elsewhere, either inside of Python or in Unix. That’s the background
    for this next exercise, in which you’ll reimplement the `sum` ([http://mng.bz/MdW2](http://mng.bz/MdW2))
    function that comes with Python. That function takes a sequence of numbers and
    returns the sum of those numbers. So if you were to invoke `sum([1,2,3])`, the
    result would be `6`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的练习类型之一是重新实现我们在 Python 或 Unix 中看到的功能。这就是下一个练习的背景，你将重新实现 Python 中的 `sum`
    ([http://mng.bz/MdW2](http://mng.bz/MdW2)) 函数。该函数接受一个数字序列并返回这些数字的总和。所以如果你调用 `sum([1,2,3])`，结果将是
    `6`。
- en: The challenge here is to write a `mysum` function that does the same thing as
    the built-in `sum` function. However, instead of taking a single sequence as a
    parameter, it should take a variable number of arguments. Thus, although you might
    invoke `sum([1,2,3])`, you’d instead invoke `mysum(1,2,3)` or `mysum(10,20,30,40,50)`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的挑战是编写一个 `mysum` 函数，它执行与内置 `sum` 函数相同的功能。然而，它应该接受可变数量的参数，而不是单个序列作为参数。因此，虽然你可能调用
    `sum([1,2,3])`，但你将调用 `mysum(1,2,3)` 或 `mysum(10,20,30,40,50)`。
- en: '*Note* The built-in `sum` function takes an optional second argument, which
    we’re ignoring here.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 内置的 `sum` 函数接受一个可选的第二个参数，这里我们忽略它。'
- en: And no, you shouldn’t use the built-in `sum` function to accomplish this! (You’d
    be amazed just how often someone asks me this question when I’m teaching courses.)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不，你不应该使用内置的 `sum` 函数来完成这个任务！（当你教课时，你会发现有人经常问我这个问题。）
- en: This exercise is meant to help you think about not only numbers, but also the
    design of functions. And in particular, you should think about the types of parameters
    functions can take in Python. In many languages, you can define functions multiple
    times, each with a different type signature (i.e., number of parameters, and parameter
    types). In Python, only one function definition (i.e., the last time that the
    function was defined) sticks. The flexibility comes from appropriate use of the
    different parameter types.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习旨在帮助你思考不仅数字，还有函数的设计。特别是，你应该考虑Python中函数可以接受哪些类型的参数。在许多语言中，你可以定义多个函数，每个函数具有不同的类型签名（即参数数量和参数类型）。在Python中，只有一个函数定义（即函数最后一次被定义）是有效的。灵活性来自于对不同的参数类型的适当使用。
- en: '*Tip* If you’re not familiar with it, you’ll probably want to look into the
    *splat* operator (asterisk), described in this Python tutorial: [http://mng.bz/aR4J](http://mng.bz/aR4J).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示* 如果你对它不熟悉，你可能想查看这篇Python教程中描述的 *splat* 操作符（即星号）：[http://mng.bz/aR4J](http://mng.bz/aR4J)。'
- en: Working it out
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: The `mysum` function is a simple example of how we can use Python’s “splat”
    operator (aka `*`) to allow a function to receive any number of arguments. Because
    we have prefaced the name `numbers` with `*`, we’re telling Python that this parameter
    should receive all of the arguments, and that `numbers` will always be a tuple.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysum` 函数是使用Python的“splat”操作符（也称为 `*`）的一个简单例子，它允许函数接收任意数量的参数。因为我们已经在 `numbers`
    名称前加上了 `*`，我们告诉Python这个参数应该接收所有参数，并且 `numbers` 将始终是一个元组。'
- en: Even if no arguments are passed to our function, `numbers` will still be a tuple.
    It’ll be an empty tuple, but a tuple nonetheless.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有参数传递给我们的函数，`numbers` 仍然是一个元组。它将是一个空元组，但仍然是一个元组。
- en: The splat operator is especially useful when you want to receive an unknown
    number of arguments. Typically, you’ll expect that all of the arguments will be
    of the same type, although Python doesn’t enforce such a rule. In my experience,
    you’ll then take the tuple (`numbers`, in this case) and iterate over each element
    with either a `for` loop or a list comprehension.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Splat操作符在你想接收未知数量的参数时特别有用。通常，你预期所有参数都将具有相同的类型，尽管Python不强制执行此规则。根据我的经验，你将取这个元组（在这种情况下是
    `numbers`）并使用 `for` 循环或列表推导式遍历每个元素。
- en: '*Note* If you’re retrieving elements from `*args` with numeric indexes, then
    you’re probably doing something wrong. Use individual, named parameters if you
    want to pick them off one at a time.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 如果你使用数字索引从 `*args` 中检索元素，那么你可能做错了。如果你想逐个选择它们，请使用单独的、命名的参数。 '
- en: Because we expect all of the arguments to be numeric, we set our `output` local
    variable to 0 at the start of the function, and then we add each of the individual
    numbers to it in a `for` loop. Once we have this function, we can invoke it whenever
    we want, on any list, set, or tuple of numbers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们预期所有参数都是数值类型，我们在函数开始时将 `output` 局部变量设置为0，然后使用 `for` 循环将每个单独的数字加到它上面。一旦我们有了这个函数，我们就可以在需要时调用它，对任何列表、集合或数字元组进行调用。
- en: While you might not use `sum` (or reimplement it) very often, `*args` is an
    extremely common way for a function to accept an unknown number of arguments.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能不会经常使用 `sum`（或重新实现它），但 `*args` 是函数接受未知数量参数的一种极其常见的方式。
- en: Turning iterables into arguments
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将可迭代对象转换为参数
- en: 'What if we have a list of numbers, such as `[1,2,3]`, and wish to use `mysum`
    with it? We can’t simply invoke `mysum([1,2,3])`; this will result in the `numbers`
    argument being a tuple whose first and only element is the list `[1,2,3]`, which
    looks like this: `([1,2,3],)`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个数字列表，例如 `[1,2,3]`，并且希望使用 `mysum` 函数处理它呢？我们不能简单地调用 `mysum([1,2,3])`；这将导致
    `numbers` 参数成为一个元组，其第一个也是唯一元素是列表 `[1,2,3]`，它看起来是这样的：`([1,2,3],)`。
- en: Python will iterate over our one-element tuple, trying to add `0` to `[1,2,3]`.
    This will result in a `TypeError` exception, with Python complaining that it can’t
    add an integer to a list.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Python会遍历我们的单元素元组，尝试将 `0` 加到 `[1,2,3]` 上。这将导致一个 `TypeError` 异常，Python会抱怨它不能将整数加到列表中。
- en: The solution in such a case is to preface the argument with `*` when we invoke
    the function. If we call `mysum(*[1,2,3])`, our list becomes three separate arguments,
    which will then allow the function to be called in the usual way.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，解决方案是在调用函数时在参数前加上 `*`。如果我们调用 `mysum(*[1,2,3])`，我们的列表就变成了三个独立的参数，这样函数就可以以通常的方式被调用了。
- en: This is generally true when invoking functions. If you have an iterable object
    and want to pass its elements to a function, just preface it with `*` in the function
    call.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常在调用函数时是正确的。如果你有一个可迭代的对象，并且想要将其元素传递给函数，只需在函数调用前加上`*`即可。
- en: Solution
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can work through this code in the Python Tutor at [http://mng.bz/nPQg](http://mng.bz/nPQg).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中运行这段代码，[http://mng.bz/nPQg](http://mng.bz/nPQg)。
- en: Screencast solution
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外的练习
- en: 'It’s extremely common to iterate over the elements of a list or tuple, performing
    an operation on each element and then (for example) summing them. Here are some
    examples:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代列表或元组的元素时，对每个元素执行操作，然后（例如）求和是非常常见的。以下是一些示例：
- en: The built-in version of `sum` takes an optional second argument, which is used
    as the starting point for the summing. (That’s why it takes a list of numbers
    as its first argument, unlike our `mysum` implementation.) So `sum([1,2,3],` `4)`
    returns 10, because 1+2+3 is 6, which would be added to the starting value of
    4\. Reimplement your `mysum` function such that it works in this way. If a second
    argument is not provided, then it should default to 0\. Note that while you can
    write a function in Python 3 that defines a parameter after `*args`, I’d suggest
    avoiding it and just taking two arguments--a list and an optional starting point.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的`sum`函数有一个可选的第二个参数，用作求和的起始点。（这就是为什么它将数字列表作为其第一个参数，而我们的`mysum`实现则不是。）所以`sum([1,2,3],
    4)`返回10，因为1+2+3等于6，这将加到起始值4上。重新实现你的`mysum`函数，使其以这种方式工作。如果没有提供第二个参数，则应默认为0。请注意，虽然你可以在Python
    3中编写一个函数，在`*args`之后定义一个参数，但我建议避免这样做，只接受两个参数--一个列表和一个可选的起始点。
- en: Write a function that takes a list of numbers. It should return the average
    (i.e., arithmetic mean) of those numbers.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数接受一个数字列表。它应该返回这些数字的平均值（即算术平均值）。
- en: Write a function that takes a list of words (strings). It should return a tuple
    containing three integers, representing the length of the shortest word, the length
    of the longest word, and the average word length.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数接受一个单词列表（字符串）。它应该返回一个包含三个整数的元组，分别代表最短单词的长度、最长单词的长度和平均单词长度。
- en: Write a function that takes a list of Python objects. Sum the objects that either
    are integers or can be turned into integers, ignoring the others.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数接受一个Python对象列表。计算那些是整数或可以转换为整数的对象的总和，忽略其他对象。
- en: Exercise 3 ■ Run timing
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3 ■ 跑步计时
- en: System administrators often use Python to perform a variety of tasks, including
    producing reports from user inputs and files. It’s not unusual to report how often
    a particular error message has occurred, or which IP addresses have accessed a
    server most recently, or which usernames are most likely to have incorrect passwords.
    Learning how to accumulate information over time and produce some basic reports
    (including average times) is thus useful and important. Moreover, knowing how
    to work with floating-point values, and the differences between them and integers,
    is important.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员经常使用Python执行各种任务，包括从用户输入和文件中生成报告。报告特定错误消息发生的频率、最近访问服务器的IP地址或最有可能有错误密码的用户名并不罕见。因此，学习如何随着时间的推移积累信息并生成一些基本报告（包括平均时间）是有用且重要的。此外，了解如何处理浮点值以及它们与整数的区别也很重要。
- en: For this exercise, then, we’ll assume that you run 10 km each day as part of
    your exercise regime. You want to know how long, on average, that run takes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我们将假设你每天作为锻炼计划的一部分跑10公里。你想要知道平均每次跑需要多长时间。
- en: Write a function (`run_timing`) that asks how long it took for you to run 10
    km. The function continues to ask how long (in minutes) it took for additional
    runs, until the user presses Enter. At that point, the function exits--but only
    after calculating and displaying the average time that the 10 km runs took.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数（`run_timing`），询问你跑10公里需要多长时间。该函数会继续询问额外跑步需要多长时间（以分钟为单位），直到用户按下Enter键。到那时，函数将退出--但在计算并显示10公里跑步的平均时间后。
- en: 'For example, here’s what the output would look like if the user entered three
    data points:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户输入了三个数据点，输出将如下所示：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the numeric inputs and outputs should all be floating-point values.
    This exercise is meant to help you practice converting inputs into appropriate
    types, along with tracking information over time. You’ll probably be tracking
    data that’s more sophisticated than running times and distances, but the idea
    of accumulating data over time is common in programs, and it’s important to see
    how to do this in Python.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，数值输入和输出都应该是浮点值。这个练习旨在帮助你练习将输入转换为适当的类型，并跟踪随时间推移的信息。你可能需要跟踪比运行时间和距离更复杂的数据，但随时间积累数据在程序中是常见的，并且了解如何在
    Python 中这样做很重要。
- en: Working it out
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: In the previous exercise, we saw that `input` is a function that returns a string,
    based on input from the user. In this case, however, the user might provide two
    types of input; they might enter a number, but they also might enter the empty
    string.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们看到了 `input` 是一个基于用户输入返回字符串的函数。然而，在这种情况下，用户可能提供两种类型的输入；他们可能输入一个数字，但也可能输入一个空字符串。
- en: 'Because empty strings, as well as the numeric 0, are considered to be `False`
    within an `if` statement, it’s common for Python programs to use an expression
    as shown in the solution:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因为空字符串以及数字 0 在 `if` 语句中被认为是 `False`，所以 Python 程序通常使用解决方案中所示的表达式：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It’s unusual, and would be a bit weird, to say
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 说起来不寻常，也会有点奇怪
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Although this works, it’s not considered good Python style, according to generally
    accepted conventions. Following these conventions can make your code more *Pythonic*,
    and thus more readable by other developers. In this case, using `not` in front
    of a variable that might be empty, and thus providing us with a `False` value
    in this context, is much more common.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可行，但根据普遍接受的约定，这并不被认为是好的 Python 风格。遵循这些约定可以使你的代码更“Pythonic”，因此其他开发者更容易阅读。在这种情况下，在可能为空的变量前使用
    `not`，并在这个上下文中提供 `False` 值，这更为常见。
- en: 'In a real-world Python application, if you’re taking input from the user and
    calling `float` ([http://mng.bz/gyYR](http://mng.bz/gyYR)), you should probably
    wrap it within `try` ([http://mng .bz/5aY1](http://mng.bz/5aY1)), in case the
    user gives you an illegal value:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的 Python 应用程序中，如果你从用户那里获取输入并调用 `float` ([http://mng.bz/gyYR](http://mng.bz/gyYR))，你应该可能将其包裹在
    `try` ([http://mng.bz/5aY1](http://mng.bz/5aY1)) 中，以防用户给你一个非法值：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Also remember that floating-point numbers are not completely accurate. They’re
    good enough for measuring the time it takes to run, but they’re a bad idea for
    any sensitive measurement, such as a scientific or financial calculation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，浮点数并不完全准确。它们对于测量运行时间足够好，但对于任何敏感的测量，如科学或金融计算，都不是一个好主意。
- en: If you didn’t know this already, then I suggest you go to your local interactive
    Python interpreter and ask it for the value of `0.1` `+` `0.2`. You might be surprised
    by the results. (You can also go to [http://mng.bz/6QGD](http://mng.bz/6QGD) and
    see how this works in other programming languages.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前不知道这一点，我建议你前往你当地的交互式 Python 解释器，并询问 `0.1` `+` `0.2` 的值。你可能会对结果感到惊讶。（你还可以访问
    [http://mng.bz/6QGD](http://mng.bz/6QGD) 并查看在其他编程语言中是如何工作的。）
- en: One common solution for this problem is to use integers. Instead of keeping
    track of dollars and cents (as a `float`), you can just keep track of cents (as
    an `int`).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的常见方法之一是使用整数。你不需要跟踪美元和美分（作为一个 `float`），只需跟踪美分（作为一个 `int`）即可。
- en: Gaining control with f-strings
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 f-string 掌握控制权
- en: 'If you want to print a floating-point number in Python, then you might want
    to use an f-string. Why? Because in this way, you can specify the number of digits
    that will be printed out. Here’s an example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 Python 中打印一个浮点数，那么你可能想使用 f-string。为什么？因为这样，你可以指定要打印的数字位数。以下是一个例子：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That’s probably not what you want. However, by putting `s` inside of an f-string,
    you can limit the output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是你想要的。然而，通过在 f-string 中放入 `s`，你可以限制输出：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, I’ve told the f-string that I want to take the value of `s` and then display
    it as a floating-point number (`f`) with a maximum of two digits after the decimal
    point. See the reference table (table 1.1) at the start of this chapter for the
    full documentation on f-strings and the formatting codes you can use for different
    data types.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我告诉 f-string 我想要取 `s` 的值，然后以最多两位小数的浮点数（`f`）形式显示它。请参阅本章开头处的参考表（表 1.1），以获取有关
    f-string 和可用于不同数据类型的格式化代码的完整文档。
- en: Solution
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Look, it’s an infinite loop! It might seem weird to have “while True,” and
    it’s a very bad idea to have such a loop without any “break” statement to exit
    when a condition is reached. But as a general way of getting an unknown number
    of inputs from the users, I think it’s totally fine.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 看看，这是一个无限循环！有 “while True” 可能看起来很奇怪，没有 “break” 语句来在达到条件时退出这样的循环是一个非常糟糕的想法。但作为从用户那里获取未知数量输入的一般方式，我认为这是完全可以接受的。
- en: ❷ If one_run is an empty string, stop.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果 one_run 是一个空字符串，停止。
- en: You can work through this code in the Python Tutor at [http://mng.bz/4A1g](http://mng.bz/4A1g).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://mng.bz/4A1g](http://mng.bz/4A1g) 的 Python Tutor 中运行这段代码。
- en: Screencast solution
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'Floating-point numbers are both necessary and potentially dangerous in the
    programming world; necessary because many things can only be represented with
    fractional numbers, but potentially dangerous because they aren’t exact. You should
    thus think about when and where you use them. Here are two exercises in which
    you’ll want to use `float`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程世界中，浮点数既是必要的也是潜在的危险的；必要是因为许多东西只能用分数表示，但潜在的危险是因为它们不是精确的。因此，你应该考虑何时何地使用它们。这里有两组练习，你将想要使用
    `float`：
- en: Write a function that takes a `float` and two integers (`before` and `after`).
    The function should return a `float` consisting of `before` digits before the
    decimal point and `after` digits after. Thus, if we call the function with `1234.5678`,
    `2` and `3`, the return value should be `34.567`.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数接受一个 `float` 和两个整数（`before` 和 `after`）。该函数应返回一个由小数点前 `before` 位数字和小数点后
    `after` 位数字组成的 `float`。因此，如果我们用 `1234.5678`、`2` 和 `3` 调用该函数，返回值应该是 `34.567`。
- en: Explore the `Decimal` class ([http://mng.bz/oPVr](http://mng.bz/oPVr)), which
    has an alternative floating-point representation that’s as accurate as any decimal
    number can be. Write a function that takes two strings from the user, turns them
    into `decimal` instances, and then prints the floating-point sum of the user’s
    two inputs. In other words, make it possible for the user to enter `0.1` and `0.2`,
    and for us to get `0.3` back.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 `Decimal` 类 ([http://mng.bz/oPVr](http://mng.bz/oPVr))，它有一个替代的浮点表示法，其精确度与任何十进制数一样。编写一个函数，该函数接受用户输入的两个字符串，将它们转换为
    `decimal` 实例，然后打印用户两个输入的浮点数和。换句话说，让用户能够输入 `0.1` 和 `0.2`，然后我们得到 `0.3`。
- en: Exercise 4 ■ Hexadecimal output
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4 ■ 十六进制输出
- en: Loops are everywhere in Python, and the fact that most built-in data structures
    are iterable makes it easy to work through them, one element at a time. However,
    we typically iterate over an object forward, from its first element to the last
    one. Moreover, Python doesn’t automatically provide us with the indexes of the
    elements. In this exercise, you’ll see how a bit of creativity, along with the
    built-in `reversed` and `enumerate` functions, can help you to get around these
    issues.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 循环在 Python 中无处不在，并且大多数内置数据结构都是可迭代的，这使得逐个元素地处理它们变得容易。然而，我们通常从前向后迭代一个对象，从它的第一个元素到最后一个元素。此外，Python
    并没有自动为我们提供元素的索引。在这个练习中，你会看到一点创意，以及内置的 `reversed` 和 `enumerate` 函数，如何帮助你解决这些问题。
- en: Hexadecimal numbers are fairly common in the world of computers. Actually, that’s
    not entirely true; some programmers use them all of the time. Other programmers,
    typically using high-level languages and doing things such as web development,
    barely even remember how to use them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机的世界里，十六进制数相当常见。实际上，这并不完全正确；一些程序员总是使用它们。其他程序员，通常使用高级语言，比如做网页开发，几乎甚至都不记得如何使用它们。
- en: Now, the fact is that I barely use hexadecimal numbers in my day-to-day work.
    And even if I were to need them, I could use Python’s built-in `hex` function
    ([http://mng .bz/nPxg](http://mng.bz/nPxg)) and `0x` prefix. The former takes
    an integer and returns a hex string; the latter allows me to enter a number using
    hexadecimal notation, which can be more convenient. Thus, `0x50` is 80, and `hex(80)`
    will return the string `0x50`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，事实是我在日常工作中几乎不用十六进制数。即使我需要它们，我也可以使用 Python 的内置 `hex` 函数 ([http://mng.bz/nPxg](http://mng.bz/nPxg))
    和 `0x` 前缀。前者接受一个整数并返回一个十六进制字符串；后者允许我使用十六进制表示法输入一个数字，这可能更方便。因此，`0x50` 是 80，而 `hex(80)`
    将返回字符串 `0x50`。
- en: For this exercise, you need to write a function (`hex_output`) that takes a
    hex number and returns the decimal equivalent. That is, if the user enters `50`,
    you’ll assume that it’s a hex number (equal to `0x50`) and will print the value
    `80` to the screen. And no, you shouldn’t convert the number all at once using
    the `int` function, although it’s permissible to use `int` one digit at a time.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，你需要编写一个函数（`hex_output`），它接受一个十六进制数并返回其十进制等效值。也就是说，如果用户输入`50`，你将假设它是一个十六进制数（等于`0x50`），并将值`80`打印到屏幕上。而且，你不应该一次性使用`int`函数来转换这个数字，尽管一次使用`int`转换一个数字位是允许的。
- en: This exercise isn’t meant to test your math skills; not only can you get the
    hex equivalent of integers with the `hex` function, but most people don’t even
    need that in their day-to-day lives. However, this does touch on the conversion
    (in various ways) across types that we can do in Python, thanks to the fact that
    sequences (e.g., strings) are iterable. Consider also the built-in functions that
    you can use to solve this problem even more easily than if you had to write things
    from scratch.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习并不是为了测试你的数学技能；你不仅可以用`hex`函数获取整数的十六进制等效值，而且大多数人甚至不需要在日常生活中用到这一点。然而，这确实触及了在Python中（以各种方式）跨类型转换的事实，这要归功于序列（例如，字符串）的可迭代性。同时，考虑一下你可以使用的内置函数，这些函数可以帮助你比从头开始编写代码更容易地解决这个问题。
- en: '*Tip* Python’s exponentiation operator is `**`. So the result of `2**3` is
    the integer `8`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示* Python的指数运算符是`**`。所以`2**3`的结果是整数`8`。'
- en: Working it out
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: A key aspect of Python strings is that they are sequences of characters, over
    which we can iterate in a `for` ([http://mng.bz/vxOJ](http://mng.bz/vxOJ)) loop.
    However, `for` loops in Python, unlike their C counterparts, don’t give us (or
    even use) the characters’ indexes. Rather, they iterate over the characters themselves.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Python字符串的一个关键特性是它们是字符序列，我们可以通过`for`([http://mng.bz/vxOJ](http://mng.bz/vxOJ))循环来迭代这些序列。然而，Python中的`for`循环与它们的C语言对应物不同，它们不会给我们（甚至使用）字符的索引。相反，它们遍历字符本身。
- en: If we want the numeric index of each character, we can use the built-in `enumerate`
    ([http://mng.bz/qM1K](http://mng.bz/qM1K)) function. This function returns a two-element
    tuple with each iteration; using Python’s multiple-assignment (“unpacking”) syntax,
    we can capture each of these values and stick them into our `power` and `digit`
    variables.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要每个字符的数字索引，我们可以使用内置的`enumerate`([http://mng.bz/qM1K](http://mng.bz/qM1K))函数。这个函数在每次迭代时返回一个包含两个元素的元组；使用Python的多个赋值（“解包”）语法，我们可以捕获这些值并将它们放入我们的`power`和`digit`变量中。
- en: 'Here’s an example of how we can use `enumerate` to print the first four letters
    of the alphabet, along with the letters’ indexes in the string:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，说明我们如何使用`enumerate`来打印字母表的前四个字母，以及这些字母在字符串中的索引：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Note* Why does Python have `enumerate` at all? Because in many other languages,
    such as C, `for` loops iterate over sequences of numbers, which are used to retrieve
    elements from a sequence. But in Python, our `for` loops retrieve the items directly,
    without needing any explicit index variable. `enumerate` thus produces the indexes
    based on the elements--precisely the opposite of how things work in other languages.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 为什么Python有`enumerate`？因为在许多其他语言中，例如C，`for`循环遍历数字序列，这些序列用于从序列中检索元素。但在Python中，我们的`for`循环直接检索项目，而不需要任何显式的索引变量。因此，`enumerate`根据元素生成索引——这与其他语言的运作方式正好相反。'
- en: You also see the use of `reversed` ([http://mng.bz/7XYx](http://mng.bz/7XYx))
    here, such that we start with the final digit and work our way up to the first
    digit. `reversed` is a built-in function that returns a new string whose value
    is the reverse of the old one. We could get the same result using slice syntax,
    `hexnum[::-1]`, but I find that many people are confused by this syntax. Also,
    the slice returns a new string, whereas `reversed` returns an iterator, which
    consumes less memory.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里也看到了`reversed`([http://mng.bz/7XYx](http://mng.bz/7XYx))的使用，这样我们就可以从最后一个数字开始，逐步工作到第一个数字。`reversed`是一个内置函数，它返回一个新字符串，其值是旧字符串的逆序。我们也可以使用切片语法`hexnum[::-1]`得到相同的结果，但我发现很多人对这种语法感到困惑。此外，切片返回一个新的字符串，而`reversed`返回一个迭代器，这消耗更少的内存。
- en: We need to convert each digit of our decimal number, which was entered as a
    string, into an integer. We do that with the built-in `int` ([http://mng.bz/4Ava](http://mng.bz/4Ava))
    function, which we can think of as creating a new instance of the `int` class
    or type. We also see that `int` takes two arguments. The first is mandatory and
    is the string we want to turn into an integer. The second is optional and contains
    the number base. Since we’re converting from hexadecimal (i.e., base 16), we pass
    `16` as the second argument.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将作为字符串输入的十进制数的每一位数字转换为整数。我们使用内置的`int` ([http://mng.bz/4Ava](http://mng.bz/4Ava))
    函数来完成这个操作，我们可以将其视为创建`int`类或类型的实例。我们还看到`int`接受两个参数。第一个是必需的，是我们想要转换为整数的字符串。第二个是可选的，包含数字基数。由于我们是从十六进制（即基数16）转换，我们将`16`作为第二个参数传递。
- en: Solution
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ reversed returns a new iterable, which returns another iterable’s elements
    in reverse order. By invoking enumerate on the output from reversed, we get each
    element of hexnum, one at a time, along with its index, starting with 0.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `reversed`返回一个新的可迭代对象，它以相反的顺序返回另一个可迭代对象的元素。通过对`reversed`的输出调用`enumerate`，我们逐个获取`hexnum`的每个元素及其索引，从0开始。
- en: ❷ Python’s ** operator is used for exponentiation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Python的**运算符用于指数运算。
- en: You can work through this code in the Python Tutor at [http://mng.bz/Qy8e](http://mng.bz/Qy8e).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中查看此代码：[http://mng.bz/Qy8e](http://mng.bz/Qy8e)。
- en: Screencast solution
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 观看此解决方案的简短视频教程：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超出练习范围
- en: Every Python developer should have a good understanding of the iterator protocol,
    which `for` loops and many functions use. Combining `for` loops with other objects,
    such as `enumerate` and slices, can help to make your code shorter and more maintainable.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Python开发者都应该对迭代器协议有一个良好的理解，因为`for`循环和许多函数都使用它。将`for`循环与其他对象（如`enumerate`和切片）结合使用，可以帮助使你的代码更短且更易于维护。
- en: Reimplement the solution for this exercise such that it doesn’t use the `int`
    function at all, but rather uses the built-in `ord` and `chr` functions to identify
    the character. This implementation should be more robust, ignoring characters
    that aren’t legal for the entered number base.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新实现此练习的解决方案，使其根本不使用`int`函数，而是使用内置的`ord`和`chr`函数来识别字符。这种实现应该更健壮，忽略对于输入的数字基数不合法的字符。
- en: 'Write a program that asks the user for their name and then produces a “name
    triangle”: the first letter of their name, then the first two letters, then the
    first three, and so forth, until the entire name is written on the final line.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个程序，提示用户输入他们的名字，然后生成一个“名字三角形”：名字的第一个字母，然后是前两个字母，然后是前三个字母，以此类推，直到在最后一行上写下整个名字。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: It’s hard to imagine a Python program that doesn’t use numbers. Whether as numeric
    indexes (into a string, list, or tuple), counting the number of times an IP address
    appears in a log file, or calculating interest rates on bank loans, you’ll be
    using numbers all of the time.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象一个不使用数字的Python程序。无论是作为数字索引（字符串、列表或元组中的索引）、计算日志文件中IP地址出现的次数，还是计算银行贷款的利率，你都会一直使用数字。
- en: Remember that Python is strongly typed, meaning that integers and strings (for
    example) are different types. You can turn strings into integers with `int`, and
    integers into strings with `str`. And you can turn either of these types into
    a floating-point number with `float`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 记住Python是强类型语言，这意味着整数和字符串（例如）是不同的类型。你可以使用`int`将字符串转换为整数，使用`str`将整数转换为字符串。你还可以使用`float`将这两种类型中的任何一种转换为浮点数。
- en: In this chapter, we saw a few ways we can work with numbers of different types.
    You’re unlikely to write programs that only use numbers in this way, but feeling
    confident about how they work and fit into the larger Python ecosystem is important.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了几种处理不同类型数字的方法。你不太可能只以这种方式编写程序，但对自己如何工作以及如何融入更大的Python生态系统有信心是很重要的。
