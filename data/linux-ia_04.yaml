- en: 'Chapter 4\. Archive management: Backing up or copying entire file systems'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 4 章\. 归档管理：备份或复制整个文件系统
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Why, what, and where to archive
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么、是什么以及在哪里归档
- en: Archiving files and file systems using `tar`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `tar` 归档文件和文件系统
- en: Searching for system files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索系统文件
- en: Securing files with object permissions and ownership
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象权限和所有权来保护文件
- en: Archiving entire partitions with `dd`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `dd` 归档整个分区
- en: Synchronizing remote archives with `rsync`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `rsync` 同步远程归档
- en: Through the book’s first chapters, you learned a lot about getting around both
    safely and efficiently in a Linux environment. You also learned to generate base
    working environments using the wonders of virtualization. From here on in, I’ll
    focus on building and maintaining the infrastructure elements you’ll need to get
    real stuff done.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几章中，你学习了如何在 Linux 环境中既安全又高效地操作。你还学会了利用虚拟化的奇妙之处来生成基础工作环境。从现在开始，我将专注于构建和维护你完成实际工作所需的基础设施元素。
- en: Building IT infrastructures without a good backup protocol is like mortgaging
    your home to invest in your brother-in-law’s, can’t-go-wrong, cold fusion invention.
    You know the odds are that it won’t end well. But before you can properly back
    up file systems and partitions, you’ll need to understand exactly how file systems
    and partitions work. After that? What tools are available? When should each be
    used, and how will you put everything back together again if disaster strikes?
    Stay tuned.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有良好的备份协议的情况下构建 IT 基础设施，就像抵押你的房子来投资你妹夫的、不会失败的超导聚变发明一样。你知道这种做法不太可能有好结果。但在你能够正确备份文件系统和分区之前，你需要确切了解文件系统和分区是如何工作的。之后呢？有哪些工具可用？何时应该使用每个工具，如果发生灾难，你将如何重新组装一切？请保持关注。
- en: 4.1\. Why archive?
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 为什么需要归档？
- en: 'Before we get to the why, just what is an *archive*? It’s nothing more than
    a single file containing a collection of objects: files, directories, or a combination
    of both. Bundling objects within a single file (as illustrated in [figure 4.1](#ch04fig01))
    sometimes makes it easier to move, share, or store multiple objects that might
    otherwise be unwieldy and disorganized.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论为什么之前，先来了解一下什么是 *归档*？它不过是一个包含一组对象的单个文件：文件、目录，或者两者的组合。将对象捆绑在单个文件中（如图 4.1
    所示）有时可以更容易地移动、共享或存储那些可能难以管理和组织的大量对象。
- en: Figure 4.1\. Files and directories can be bundled into an archive file and saved
    to the file system.
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1\. 文件和目录可以捆绑成一个归档文件并保存到文件系统中。
- en: '![](Images/04fig01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig01.jpg)'
- en: Imagine trying to copy a few thousand files spread across a dozen directories
    and subdirectories so your colleague across the network can see them too. Of course,
    using the proper command-line syntax arguments, anything can be done. (Remember
    `cp` from [chapter 1](kindle_split_009.xhtml#ch01)? And `-r`?) But making sure
    you copy only the files you’re after and not accidentally leaving anything out
    can be a challenge. Granted, you’ll still need to account for all those files
    at least one time as you build the archive. But once you’ve got everything wrapped
    up in a single archive file, it’s a whole lot easier to track. Archives it is,
    then.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下尝试复制散布在十几个目录和子目录中的几千个文件，以便你的网络另一端的同事也能看到它们。当然，使用正确的命令行语法参数，任何事都可以做到。（还记得第
    1 章（kindle_split_009.xhtml#ch01）中的 `cp` 吗？还有 `-r`？）但确保只复制你需要的文件，并且没有意外遗漏任何文件，这可能是一个挑战。当然，你至少需要一次计算所有这些文件，以便构建归档。但一旦你将所有内容都封装在一个归档文件中，跟踪起来就简单多了。所以，归档就是归档。
- en: But there are archives, and then there are archives. Which to choose? That depends
    on the kinds of files you’re looking to organize and on what you plan to do with
    them. You might need to create copies of directories and their contents so you
    can easily share or back them up. For that, `tar` is probably going to be your
    champion of choice. If, however, you need an exact copy of a partition or even
    an entire hard disk, then you’ll want to know about `dd`. And if you’re looking
    for an ongoing solution for regular system backups, then try `rsync`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但归档有归档，哪种归档适合你？这取决于你想要组织哪些类型的文件以及你计划如何使用它们。你可能需要创建目录及其内容的副本，以便你可以轻松地共享或备份它们。为此，`tar`
    可能将成为你的首选冠军。然而，如果你需要一个分区的精确副本，甚至是一个整个硬盘的副本，那么你需要了解 `dd`。如果你正在寻找一个用于常规系统备份的持续解决方案，那么尝试
    `rsync` 吧。
- en: Learning how to use those three tools and, more importantly, learning what real
    problems those three tools can solve for you will be the focus of the rest of
    this chapter. Along the way, we’ll take a bit of a detour to see how to protect
    the permissions and ownership attributes for the files in the archive as they
    move through the archive life cycle. Finally, we’ll take a peek at why Linux uses
    file permissions and file ownership in the first place.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何使用这三个工具，更重要的是，学习这三个工具可以为你解决哪些实际问题，将是本章剩余部分的重点。在这个过程中，我们将稍微偏离一下，看看如何保护存档中文件在存档生命周期中的权限和所有权属性。最后，我们将窥视一下为什么
    Linux 首先使用文件权限和文件所有权。
- en: 4.1.1\. Compression
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. 压缩
- en: One more note before we begin. Although the two are often used together, don’t
    confuse archiving with compression. *Compression*, as [figure 4.2](#ch04fig02)
    shows, is a software tool that applies a clever algorithm to a file or archive
    to reduce the amount of disk space it takes. Of course, when they’re compressed,
    files are unreadable, which is why the algorithm can also be applied in reverse
    to decompress them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前还有一个注意事项。尽管这两个经常一起使用，但不要将存档与压缩混淆。*压缩*，如图 4.2 所示，是一种软件工具，它将一种巧妙的算法应用于文件或存档以减少其占用的磁盘空间。当然，当文件被压缩后，它们是不可读的，这就是为什么算法也可以逆向应用以解压缩它们。
- en: Figure 4.2\. Object compression by eliminating statistical redundancy and/or
    removing less important parts of a file
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.2\. 通过消除统计冗余和/或删除文件中不太重要的部分来实现对象压缩
- en: '![](Images/04fig02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig02.jpg)'
- en: As you’ll see soon, applying compression to a tar archive is simple and doing
    so is a particularly good idea if you’re planning to transfer large archives over
    a network. Compression can reduce transmission times significantly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会看到，将压缩应用于 tar 存档非常简单，如果你计划通过网络传输大型存档，这样做尤其是个好主意。压缩可以显著减少传输时间。
- en: '4.1.2\. Archives: Some important considerations'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. 存档：一些重要考虑事项
- en: Two primary reasons you’ll want to create archives are to build reliable file
    system images and to create efficient data backups. This section describes those
    objectives.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要创建存档的两个主要原因是为了构建可靠的文件系统镜像和创建高效的数据备份。本节将描述这些目标。
- en: Images
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 镜像
- en: What’s an image? Remember those .ISO files you used to install Linux on a virtual
    machine back in [chapter 2](kindle_split_010.xhtml#ch02)? Those files were images
    of complete operating systems, specially organized to make it easy to copy the
    included files to a target computer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是镜像？还记得你在[第 2 章](kindle_split_010.xhtml#ch02)中用来在虚拟机上安装 Linux 的那些 .ISO 文件吗？这些文件是完整操作系统的镜像，特别组织以便于将包含的文件复制到目标计算机上。
- en: Images can also be created from all or parts of a live, working operating system
    (OS) so you can copy and paste the contents to a second computer. This effectively
    makes the second (copy) an exact clone of the first system in its current state.
    I’ve often done this to rescue a complex installation from a failing hard drive
    when I didn’t feel like building up the whole thing again from scratch on its
    new drive. It’s also great when you want to quickly provide identical system setups
    to multiple users, like student workstations in a classroom.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从活动的工作操作系统（OS）的所有或部分创建镜像，这样你就可以将内容复制粘贴到第二台计算机上。这实际上使得第二台（复制）计算机在其当前状态下成为第一系统的精确克隆。我经常这样做，从失败的硬盘上恢复复杂的安装，而不想在新硬盘上从头开始重建整个系统。当你想要快速向多个用户（如教室中的学生工作站）提供相同的系统设置时，这也非常棒。
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t even think about trying any of this with Windows. For all intents and
    purposes, the Windows registry architecture makes it impossible to separate an
    installed OS from its original hardware.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根本不要考虑在 Windows 上尝试这些操作。从所有目的和用途来看，Windows 注册表架构使得将安装的操作系统与其原始硬件分离变得不可能。
- en: '|  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Although we’re going to spend the rest of this chapter talking about backups
    rather than images, don’t worry. The tools we’d use for creating and restoring
    images are pretty much the same, so you’ll be fine either way.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在本章的剩余部分讨论备份而不是镜像，但请放心。我们用于创建和恢复镜像的工具基本上是相同的，所以无论哪种方式你都会没事的。
- en: Data backups
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据备份
- en: 'Backups should be a big part of your life. In fact, if you never worry about
    the health of your data, then either you’re a Zen master or you’re just not doing
    your job right. There’s so much scary stuff that can happen:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 备份应该是你生活中的一部分。实际上，如果你从不担心你数据的安全，那么要么你是一位禅宗大师，要么你只是没有正确地完成你的工作。可能会有很多可怕的事情发生：
- en: Hardware can—and will—fail. And it’ll usually happen right before you were planning
    to get to that big backup. Really.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件会失败——而且通常会在你计划进行大备份之前发生。真的。
- en: Fat fingers (by which I mean clumsy people) and keyboards can conspire to mangle
    configuration files, leaving you completely locked out of your encrypted system.
    Having a fallback copy available can save your job and, quite possibly, your life.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大拇指笨拙（我指的是笨拙的人）和键盘可能会串通起来破坏配置文件，让你完全无法访问加密系统。拥有一个备用副本可以保住你的工作，甚至可能保住你的生命。
- en: Data insecurely stored on cloud infrastructure providers like Amazon Web Services
    (AWS) can be suddenly and unpredictably lost. Back in 2014, this happened to a
    company called Code Spaces. The company’s improperly configured AWS account console
    was breached, and the attackers deleted most of its data. How did Code Spaces
    recover? Well, when was the last time you heard anything about Code Spaces?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在像亚马逊网络服务（AWS）这样的云基础设施提供商上的数据可能突然且不可预测地丢失。2014年，这种情况发生在一个名为Code Spaces的公司身上。该公司的AWS账户控制台配置不当，被攻击者入侵，他们删除了大部分数据。Code
    Spaces是如何恢复的？好吧，你最后一次听说Code Spaces是什么时候？
- en: Perhaps most terrifying of all, you could become the victim of a ransomware
    attack that encrypts or disables all your files unless you pay a large ransom.
    Got a reliable and recent backup? Feel free to tell the attackers just what you
    think.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能最可怕的是，你可能会成为勒索软件攻击的受害者，除非你支付一大笔赎金，否则你的所有文件都会被加密或禁用。你有一个可靠且最近的备份吗？你可以自由地告诉攻击者你的想法。
- en: 'Before moving on, I should mention that untested data backups may not actually
    work. In fact, there’s evidence to suggest that nearly half of the time they don’t.
    What’s the problem? There’s a lot that can go wrong: there could be flaws on your
    backup device, the archive file might become corrupted, or the initial backup
    itself might have been unable to properly process all of your files.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我应该提到，未经测试的数据备份可能实际上不起作用。事实上，有证据表明，几乎一半的时间它们都不会起作用。问题是什么？有很多可能出错的地方：你的备份设备可能有缺陷，存档文件可能已损坏，或者初始备份本身可能无法正确处理你所有的文件。
- en: 'Generating and monitoring log messages can help you spot problems, but the
    only way to be reasonably confident about a backup is to run a trial restore onto
    matching hardware. That will take energy, time, and money. But it sure beats the
    alternative. The best system administrators I’ve known all seem to share the same
    sentiment: “Paranoid is only the beginning.”'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 生成和监控日志消息可以帮助你发现问题，但唯一能够对备份有合理信心的方式是将试验性恢复到匹配的硬件上。这将需要能量、时间和金钱。但确实比替代方案好。我所认识的最好的系统管理员似乎都持有相同的观点：“偏执狂只是开始。”
- en: 4.2\. What to archive
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 要存档的内容
- en: 'If there aren’t too many files you want to back up and they’re not too large,
    you might as well transfer them to their storage destination as is. Use something
    like the SCP program you saw in [chapter 3](kindle_split_011.xhtml#ch03). This
    example uses SCP to copy the contents of my public encryption key into a file
    called authorized_keys on a remote machine:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要备份的文件不多，而且它们不是很大，你不妨直接将它们传输到它们的存储目的地。使用你在第3章中看到的类似SCP程序。以下示例使用SCP将我的公钥内容复制到远程机器上的名为authorized_keys的文件中：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Overwrites the current contents of the remote authorized_keys file**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 覆盖远程授权_keys 文件当前内容**'
- en: But if you want to back up many files spread across multiple directories (a
    complicated project with source code, for instance) or even entire partitions
    (like the OS you’re running right now), you’re going to need something with more
    bite.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想要备份分布在多个目录中的许多文件（例如，一个包含源代码的复杂项目）或甚至整个分区（如你现在运行的操作系统），你需要一个更有力的工具。
- en: Although we discussed disk partitions and pseudo files in [chapter 1](kindle_split_009.xhtml#ch01),
    if you want to develop some kind of intelligent backup policy, you’ll want to
    get a feel for what they look like. Suppose you’re planning a backup of a partition
    containing your company’s large accounting database; you probably won’t get too
    far without knowing how much space that partition takes up and how to find it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在第1章中讨论了磁盘分区和伪文件，但如果你想制定某种智能备份策略，你将想要了解它们的外观。假设你正在计划备份包含你公司大型会计数据库的分区；如果你不知道该分区占用了多少空间以及如何找到它，你可能不会走得太远。
- en: 'Let’s begin with the `df` command, which displays each partition that’s currently
    mounted on a Linux system, along with its disk usage and location on the file
    system. Adding the `-h` flag converts partition sizes to human readable formats
    like GB or MB, rather than bytes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `df` 命令开始，它显示 Linux 系统上当前挂载的每个分区，以及其磁盘使用量和在文件系统中的位置。添加 `-h` 标志将分区大小转换为人类可读的格式，如
    GB 或 MB，而不是字节：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* The root partition: the only normal partition on this system**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 根分区：本系统上唯一的正常分区**'
- en: '***2* Note the 0 bytes for disk usage. That (usually) indicates a pseudo file
    system.**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注意磁盘使用量为 0 字节。这（通常）表示一个伪文件系统。**'
- en: '***3* The /run directory contains files with runtime data generated during
    boot.**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* /run 目录包含在启动期间生成的运行时数据文件。**'
- en: The first partition listed is designated as /dev/sda2, which means that it’s
    the second partition on Storage Device A and that it’s represented as a system
    resource through the pseudo file system directory, /dev/. This happens to be the
    primary OS partition in this case. All devices associated with a system will be
    represented by a file in the /dev/ directory. (The partition used by your accounting
    software would appear somewhere on this list, perhaps designated using something
    like /dev/sdb1.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的第一个分区被指定为 /dev/sda2，这意味着它是存储设备 A 的第二个分区，并且它通过伪文件系统目录 /dev/ 表示为一个系统资源。在这种情况下，这恰好是主要的操作系统分区。与系统关联的所有设备都将由
    /dev/ 目录中的一个文件表示。（你的会计软件所使用的分区可能会出现在这个列表中，可能使用类似 /dev/sdb1 的方式指定。）
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Running `df` on an LXC container displays the partitions associated with the
    LXC host.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LXC 容器上运行 `df` 命令会显示与 LXC 主机关联的分区。
- en: '|  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: It’s important to distinguish between real and *pseudo* file systems (file systems
    whose files aren’t actually saved to disk but live in volatile memory and disappear
    when the machine shuts down). After all, there’s no point backing up files that
    represent an ephemeral hardware profile and, in any case, will be automatically
    replaced by the OS whenever, and wherever, the real file system is booted next.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '重要的是要区分真实和 *伪* 文件系统（文件系统中的文件实际上并没有保存到磁盘上，而是存在于易失性内存中，并在机器关闭时消失）。毕竟，备份代表短暂硬件配置的文件没有意义，而且无论如何，操作系统都会在启动时自动替换真实文件系统。 '
- en: 'It’s pretty simple to tell which partitions are used for pseudo files: if the
    file designation is tmpfs and the number of bytes reported in the Used column
    is 0, then the odds are you’re looking at a temporary rather than a normal file
    system.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易判断哪些分区用于伪文件：如果文件指定为 tmpfs 并且在“已用”列中报告的字节数为 0，那么你很可能在查看一个临时文件系统而不是正常文件系统。
- en: 'By the way, that `df` was run on an LXC container, which is why there’s only
    one real partition, `/`. Let’s see what it shows us when run on a physical computer:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，那个 `df` 命令是在 LXC 容器上运行的，这就是为什么只有一个真实分区，即 `/`。让我们看看它在物理计算机上运行时显示什么：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* This partition was created during installation to enable UEFI booting.**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这个分区是在安装期间创建的，以启用 UEFI 启动。**'
- en: '***2* sdb1 is a USB thumb drive containing an Ubuntu live boot image.**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* sdb1 是一个包含 Ubuntu live 启动镜像的 USB 指示棒驱动器。**'
- en: Notice the /dev/sda1 partition mounted at /boot/efi. This partition was created
    during the original Linux installation to permit system boots controlled by the
    UEFI firmware. UEFI has now largely replaced the old BIOS interface that was used
    for hardware initialization during system boot. Software installed on this partition
    allows UEFI integration with a Linux system. And /dev/sdb1 is a USB thumb drive
    that happened to be plugged into the back of my machine.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 /dev/sda1 分区挂载在 /boot/efi 上。这个分区是在原始 Linux 安装期间创建的，以便允许由 UEFI 固件控制的系统启动。UEFI
    现在已经很大程度上取代了在系统启动期间用于硬件初始化的旧 BIOS 接口。安装在这个分区上的软件允许 UEFI 与 Linux 系统集成。而 /dev/sdb1
    是一个恰好插在我机器后面的 USB 指示棒。
- en: When you’re dealing with production servers, you’ll often see separate partitions
    for directories like /var/ and /usr/. This is often done to make it easier to
    maintain the integrity and security of sensitive data, or to protect the rest
    of the system from being overrun by file bloat from, say, the log files on /var/log/.
    Whatever the reason, for any particular disk design, you’ll want to make informed
    decisions about what needs backing up and what doesn’t.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理生产服务器时，你经常会看到像/var/和/usr/这样的目录有单独的分区。这通常是为了更容易地维护敏感数据的完整性和安全性，或者为了保护系统免受来自如/var/log/日志文件的文件膨胀的影响。无论原因如何，对于任何特定的磁盘设计，你都会想要就哪些需要备份以及哪些不需要备份做出明智的决定。
- en: You’ll sometimes see the /boot/ directory given its own partition. I personally
    think this is a bad idea, and I’ve got scars to prove it. The problem is that
    new kernel images are written to /boot/ and, as your system is upgraded to new
    Linux kernel releases, the disk space required to store all those images increases.
    If, as is a standard practice, you assign only 500 MB to the boot partition, you’ll
    have six months or so before it fills up—at which point updates will fail. You
    may be unable to fully boot into Linux before manually removing some of the older
    files and then updating the GRUB menu. If that doesn’t sound like a lot of fun,
    then keep your /boot/ directory in the largest partition.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时会看到/boot/目录被分配了自己的分区。我个人认为这是一个坏主意，我有伤痕可以证明。问题是新的内核镜像被写入/boot/，随着你的系统升级到新的Linux内核版本，存储所有这些镜像所需的磁盘空间会增加。如果你像标准做法那样只分配500
    MB给引导分区，你将有大约六个月的时间来填满它——到那时更新将失败。在手动删除一些较旧的文件并更新GRUB菜单之前，你可能无法完全引导到Linux。如果你觉得这不是一件有趣的事情，那么请确保你的/boot/目录位于最大的分区中。
- en: 4.3\. Where to back up
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3. 备份的位置
- en: From an OS perspective, it doesn’t make a difference where you send your archives.
    Feel free to choose between legacy tape drives, USB-mounted SATA storage drives,
    network-attached storage (NAS), storage area networks (SAN), or a cloud storage
    solution. For more on that, see my book *Learn Amazon Web Services in a Month
    of Lunches* (Manning, 2017).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作系统的角度来看，你将存档发送到何处并没有区别。你可以自由选择使用传统的磁带驱动器、USB挂载的SATA存储驱动器、网络附加存储（NAS）、存储区域网络（SAN）或云存储解决方案。更多关于这一点，请参阅我的书籍《一个月午餐时间学会亚马逊网络服务》（Manning，2017年）。
- en: 'Whichever way you go, be sure to carefully follow best practices. In no particular
    order, your backups should all be:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种方式，都要确保仔细遵循最佳实践。不分先后，你的所有备份都应该：
- en: '*Reliable*—Use only storage media that are reasonably likely to retain their
    integrity for the length of time you intend to use them.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可靠*—只使用在预期使用时间内合理可能保持其完整性的存储介质。'
- en: '*Tested*—Test restoring as many archive runs as possible in simulated production
    environments.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试过*—在模拟的生产环境中尽可能测试尽可能多的存档运行。'
- en: '*Rotated*—Maintain at least a few historical archives older than the current
    backup in case the latest one should somehow fail.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*轮换*—保持至少几个比当前备份更早的历史存档，以防最新的存档以某种方式失败。'
- en: '*Distributed*—Make sure that at least some of your archives are stored in a
    physically remote location. In case of fire or other disaster, you don’t want
    your data to disappear along with the office.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分布式*—确保至少一些存档存储在物理上远程的位置。在发生火灾或其他灾难的情况下，你不想让数据随着办公室一起消失。'
- en: '*Secure*—Never expose your data to insecure networks or storage sites at any
    time during the process.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全*—在任何时候都不要将你的数据暴露在不安全的网络或存储站点上。'
- en: '*Compliant*—Honor all relevant regulatory and industry standards at all times.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*合规*—始终遵守所有相关的法规和行业标准。'
- en: '*Up to date*—What’s the point keeping archives that are weeks or months behind
    the current live version?'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最新*—保留与当前实时版本相差数周或数月的存档有什么意义？'
- en: '*Scripted*—Never rely on a human being to remember to perform an ongoing task.
    Automate it (read [chapter 5](kindle_split_013.xhtml#ch05)).'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*脚本化*—永远不要依赖人类记住执行持续的任务。自动化它（阅读[第5章](kindle_split_013.xhtml#ch05)）。'
- en: 4.4\. Archiving files and file systems using tar
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4. 使用tar存档文件和文件系统
- en: 'To successfully create your archive, there are three things that will have
    to happen:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功创建你的存档，必须发生以下三件事：
- en: Find and identify the files you want to include.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找并确定你想要包含的文件。
- en: Identify the location on a storage drive that you want your archive to use.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定你想要你的存档使用的存储驱动器上的位置。
- en: Add your files to an archive, and save it to its storage location.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的文件添加到存档中，并将其保存到其存储位置。
- en: 'Want to knock off all three steps in one go? Use `tar`. Call me a hopeless
    romantic, but I see poetry in a well-crafted `tar` command: a single, carefully
    balanced line of code accomplishing so much can be a thing of beauty.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 想一次性完成这三个步骤？使用`tar`。叫我一个无可救药的浪漫主义者吧，但我看到精心制作的`tar`命令中充满了诗意：一行精心平衡的代码就能完成这么多事情，可以是一件美丽的事物。
- en: 4.4.1\. Simple archive and compression examples
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1\. 简单归档和压缩示例
- en: 'This example copies all the files and directories within and below the current
    work directory and builds an archive file that I’ve cleverly named archivename.tar.
    Here I use three arguments after the `tar` command: the `c` tells tar to create
    a new archive, `v` sets the screen output to verbose so I’ll get updates, and
    `f` points to the filename I’d like the archive to get:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子会复制当前工作目录及其下所有的文件和目录，并构建一个我巧妙命名的archivename.tar的归档文件。在这里，我在`tar`命令后面使用了三个参数：`c`告诉tar创建一个新的归档，`v`设置屏幕输出为详细模式，这样我会收到更新，而`f`指向我想要归档的文件名：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* The verbose argument (v) lists the names of all the files added to the
    archive.**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 详细参数（v）会列出添加到归档中的所有文件名。**'
- en: '|  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `tar` command will never move or delete any of the original directories
    and files you feed it; it only makes archived copies. You should also note that
    using a dot (`.`) instead of an asterisk (`*`) in the previous command will include
    even hidden files (whose filenames begin with a dot) in the archive.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`tar`命令永远不会移动或删除你提供给它的原始目录和文件；它只制作归档副本。你还应该注意，在之前的命令中使用点（`.`）而不是星号（`*`）将包括归档中的隐藏文件（文件名以点开头）。'
- en: '|  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If you’re following along on your own computer (as you definitely should), then
    you’ll see a new file named archivename.tar. The .tar filename extension isn’t
    necessary, but it’s always a good idea to clearly communicate the purpose of a
    file in as many ways as possible.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在自己的电脑上跟着做（你绝对应该这样做），那么你会看到一个名为archivename.tar的新文件。`.tar`文件名扩展名不是必需的，但尽可能清楚地传达文件的目的总是一个好主意。
- en: 'You won’t always want to include all the files within a directory tree in your
    archive. Suppose you’ve produced some videos, but the originals are currently
    kept in directories along with all kinds of graphic, audio, and text files (containing
    your notes). The only files you need to back up are the final video clips using
    the .mp4 filename extension. Here’s how to do that:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不总是想要将目录树中的所有文件包含在归档中。假设你已经制作了一些视频，但原始文件目前保存在包含各种图形、音频和文本文件（包含你的笔记）的目录中。你唯一需要备份的文件是使用`.mp4`文件扩展名的最终视频剪辑。下面是如何做到这一点：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That’s excellent. But those video files are enormous. Wouldn’t it be nice to
    make that archive a bit smaller using compression? Say no more! Just run the previous
    command with the `z` (zip) argument. That will tell the gzip program to compress
    the archive. If you want to follow convention, you can also add a .gz extension
    in addition to the .tar that’s already there. Remember: clarity. Here’s how that
    would play out:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 那太棒了。但那些视频文件非常大。难道不好吗，通过压缩使那个归档文件变得更小？说吧！只需运行带有`z`（zip）参数的先前命令。这将告诉gzip程序压缩归档。如果你想遵循惯例，你还可以在已有的`.tar`扩展名之外添加`.gz`扩展名。记住：清晰。下面是如何实现这一点：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you try this out on your own .mp4 files and then run `ls -l` on the directory
    containing the new archives, you may notice that the .tar.gz file isn’t all that
    much smaller than the .tar file, perhaps 10% or so. What’s with that? Well, the
    .mp4 file format is itself compressed, so there’s a lot less room for gzip to
    do its stuff.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用自己的`.mp4`文件并然后在包含新归档的目录上运行`ls -l`，你可能注意到`.tar.gz`文件并没有比`.tar`文件小很多，可能只有10%左右。这是怎么回事？嗯，`.mp4`文件格式本身已经是压缩的，所以gzip压缩的空间就很小了。
- en: 'As tar is fully aware of its Linux environment, you can use it to select files
    and directories that live outside your current working directory. This example
    adds all the .mp4 files in the /home/myuser/Videos/ directory:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于tar完全了解其Linux环境，你可以使用它来选择存在于当前工作目录之外的文件和目录。这个例子添加了`/home/myuser/Videos/`目录中的所有`.mp4`文件：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because archive files can get big, it might sometimes make sense to break them
    down into multiple smaller files, transfer them to their new home, and then re-create
    the original file at the other end. The split tool is made for this purpose.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于归档文件可能会变得很大，有时将它们分解成多个较小的文件，将它们传输到新家，然后在另一端重新创建原始文件是有意义的。split工具就是为了这个目的而设计的。
- en: 'In this example, `-b` tells Linux to split the archivename.tar.gz file into
    1 GB-sized parts; *archivename* is any name you’d like to give the file. The operation
    then names each of the parts—archivename.tar.gz.partaa, archivename.tar.gz.partab,
    archivename .tar.gz.partac, and so on:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`-b` 告诉 Linux 将 archivename.tar.gz 文件分割成 1 GB 大小的部分；*archivename* 是你希望给文件起的任何名字。然后操作会给每个部分命名——archivename.tar.gz.partaa、archivename.tar.gz.partab、archivename.tar.gz.partac
    等等：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On the other side, you re-create the archive by reading each of the parts in
    sequence (`cat archivename.tar.gz.part*`), then redirect the output to a new file
    called archivename.tar.gz:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一边，你通过按顺序读取每个部分（`cat archivename.tar.gz.part*`），然后将输出重定向到一个名为 archivename.tar.gz
    的新文件来重新创建存档：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 4.4.2\. Streaming file system archives
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2\. 流式传输文件系统存档
- en: Here’s where the poetry starts. I’m going to show you how to create an archive
    image of a working Linux installation and stream it to a remote storage location—all
    within a single command ([figure 4.3](#ch04fig03)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里诗歌开始了。我将向你展示如何创建一个工作 Linux 安装程序的存档镜像并将其流式传输到远程存储位置——所有这些都在一个命令中完成 ([图 4.3](#ch04fig03))。
- en: Figure 4.3\. An archive is a file that can be copied or moved using normal Bash
    tools.
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.3\. 存档是一个可以使用正常 Bash 工具复制或移动的文件。
- en: '![](Images/04fig03.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig03.jpg)'
- en: 'Here’s the command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Rather than trying to explain all that right away, I’ll use smaller examples
    to explore it one piece at a time. Let’s create an archive of the contents of
    a directory called importantstuff that’s filled with, well, really important stuff:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是立即解释所有这些，我将使用更小的例子来逐步探索。让我们创建一个名为 importantstuff 的目录内容的存档，这个目录里装满了，嗯，真正重要的东西：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* You’ll need to enter the password for your account on the remote host.**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你需要输入远程主机上你账户的密码。**'
- en: Let me explain that example. Rather than entering the archive name right after
    the command arguments (the way you’ve done until now), I used a dash (`czvf -`).
    The dash outputs data to standard output. It lets you push the archive filename
    details back to the end of the command and tells tar to expect the source content
    for the archive instead. I then piped (`|`) the unnamed, compressed archive to
    an `ssh` login on a remote server where I was asked for my password. The command
    enclosed in quotation marks then executed `cat` against the archive data stream,
    which wrote the stream contents to a file called myfiles.tar.gz in my home directory
    on the remote host.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我解释一下这个例子。与之前的方式不同，我并没有在命令参数（你一直这样做）之后立即输入存档名称，而是使用了破折号（`czvf -`）。破折号将数据输出到标准输出。它让你将存档文件名细节推回到命令的末尾，并告诉
    tar 期望存档的源内容。然后我将未命名的、压缩的存档通过管道（`|`）传输到一个远程服务器上的 `ssh` 登录，我在那里被要求输入密码。然后，引号内的命令对存档数据流执行了
    `cat` 操作，将流内容写入远程主机上我主目录中的 myfiles.tar.gz 文件。
- en: As you can see in [figure 4.4](#ch04fig04), one advantage of generating archives
    this way is that you avoid the overhead of a middle step. There’s no need to even
    temporarily save a copy of the archive on the local machine. Imagine backing up
    an installation that fills 110 GB of its 128 GB of available space. Where would
    the archive go?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 4.4](#ch04fig04) 所示，以这种方式生成存档的一个优点是避免了中间步骤的开销。甚至不需要在本地机器上临时保存存档的副本。想象一下备份一个占用
    110 GB 可用空间的 128 GB 安装程序。存档将去哪里？
- en: Figure 4.4\. Streaming an archive as it’s created avoids the need to first save
    it to a local drive.
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4\. 在创建存档的同时进行流式传输，避免了首先将其保存到本地驱动器的需要。
- en: '![](Images/04fig04_alt.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig04_alt.jpg)'
- en: That was just a directory of files. Suppose you need to back up an active Linux
    OS to a USB drive so you can move it over to a separate machine and drop it into
    that machine’s main drive. Assuming there’s already a fresh installation of the
    same Linux version on the second machine, the next copy/paste operation will generate
    an exact replica of the first.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那只是一个文件目录。假设你需要将一个活动的 Linux 操作系统备份到 USB 驱动器，以便你可以将其移动到另一台机器并放入该机器的主驱动器中。假设第二台机器上已经安装了相同的
    Linux 版本的新安装，接下来的复制/粘贴操作将生成第一台机器的精确副本。
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This won’t work on a target drive that doesn’t already have a Linux file system
    installed. To handle that situation, as you’ll see shortly, you’ll need to use
    `dd`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这在尚未安装 Linux 文件系统的目标驱动器上不会工作。为了处理这种情况，正如你很快就会看到的，你需要使用 `dd`。
- en: '|  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The next example creates a compressed archive on the USB drive known as /dev/sdc1\.
    The `--one-file-system` argument excludes all data from any file system besides
    the current one. This means that pseudo partitions like /sys/ and /dev/ won’t
    be added to the archive. If there are other partitions that you want to include
    (as you’ll do for /usr/ and /var/ in this example), then they should be explicitly
    added. Finally, you can exclude data from the current file system using the `--exclude`
    argument:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例在名为 /dev/sdc1 的 USB 驱动器上创建一个压缩存档。`--one-file-system` 参数排除了除当前文件系统之外的所有文件系统的数据。这意味着像
    /sys/ 和 /dev/ 这样的伪分区不会被添加到存档中。如果你还想包含其他分区（如本例中的 /usr/ 和 /var/），则应明确添加它们。最后，你可以使用
    `--exclude` 参数排除当前文件系统的数据：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Excludes data from other partitions when building the archive**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在构建存档时排除其他分区的数据**'
- en: '***2* References /usr and /var partitions explicitly**'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 明确引用 /usr 和 /var 分区**'
- en: '***3* Excludes directories or files within a selected file system when necessary
    (poor old Andy)**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在必要时排除所选文件系统中的目录或文件（可怜的老 Andy）**'
- en: 'Now let’s go back to that full-service command example. Using what you’ve already
    learned, archive all the important directories of a file system and copy the archive
    file to a USB drive. It should make sense to you now:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到那个完整的命令示例。使用你已经学到的知识，归档文件系统的所有重要目录，并将存档文件复制到 USB 驱动器上。现在这应该对你来说是有意义的：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All that’s fine if the files you need to archive (and only those files) are
    agreeably hanging out together in a single directory hierarchy. But what if there
    are other files mixed in that you don’t want to include? Is there a way to aggregate
    only certain files without having to mess with the source files themselves? It’s
    time you learn about `find`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要归档的文件（仅限这些文件）都愉快地呆在单个目录层次结构中，那就没问题。但如果混合了其他你不想包含的文件呢？有没有一种方法可以聚合特定的文件，而无需修改源文件本身？是时候学习
    `find` 命令了。
- en: 4.4.3\. Aggregating files with find
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.3\. 使用 `find` 命令聚合文件
- en: The `find` command searches through a file system looking for objects that match
    rules you provide. The search outputs the names and locations of the files it
    discovers to what’s called *standard output* (stdout), which normally prints to
    the screen. But that output can just as easily be redirected to another command
    like `tar`, which would then copy those files to an archive.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令在文件系统中搜索匹配你提供的规则的对象。搜索输出它发现的文件名称和位置到所谓的 *标准输出*（stdout），通常打印到屏幕。但这个输出也可以很容易地重定向到另一个命令，如
    `tar`，然后它会将这些文件复制到存档中。'
- en: 'Here’s the story. Your server is hosting a website that provides lots of .mp4
    video files. The files are spread across many directories within the /var/www/html/
    tree, so identifying them individually would be a pain. Here’s a single command
    that will search the /var/www/html/ hierarchy for files with names that include
    the file extension .mp4\. When a file is found, `tar` will be executed with the
    argument `-r` to append (as opposed to overwrite) the video file to a file called
    videos.tar:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是故事。你的服务器托管了一个提供大量 .mp4 视频文件的网站。这些文件散布在 /var/www/html/ 树中的许多目录中，因此逐个识别它们会非常痛苦。这里有一个单独的命令，它将在
    /var/www/html/ 层次结构中搜索包含文件扩展名 .mp4 的文件。当找到文件时，`tar` 将使用参数 `-r` 来追加（而不是覆盖）视频文件到名为
    videos.tar 的文件中：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* The -iname flag returns both upper- and lowercase results; -name, on
    the other hand, searches for case-sensitive matches.**'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `-iname` 标志返回大小写不敏感的结果；另一方面，`-name` 搜索大小写敏感的匹配。**'
- en: '***2* The { } characters tell the find command to apply the tar command to
    each file it finds.**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 大括号 `{ }` 字符告诉 `find` 命令对其找到的每个文件应用 `tar` 命令。**'
- en: In this case, it’s a good idea to run `find` as `sudo`. Because you’re looking
    for files in system directories, it’s possible that some of them have restrictive
    permissions that could prevent `find` from reading and, thus, reporting them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，运行 `find` 命令作为 `sudo` 是一个好主意。因为你正在系统目录中查找文件，所以其中一些文件可能有限制性权限，这可能会阻止 `find`
    读取并因此报告它们。
- en: 'And, because we’re talking about `find`, I should also tell you about a similar
    tool called `locate` that will often be your first choice when you’re in a big
    hurry. By default, `locate` searches the entire system for files matching the
    string that you specify. In this case, `locate` will look for files whose names
    end with the string *video.mp4* (even if they have any kind of prefix):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为我们正在讨论`find`，我应该也告诉你一个类似的工具`locate`，当你非常匆忙时，它通常会是你的首选。默认情况下，`locate`会在整个系统中搜索与您指定的字符串匹配的文件。在这种情况下，`locate`将查找以字符串*video.mp4*结尾的文件（即使它们有任何前缀）：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you run `locate` head-to-head against `find`, `locate` will almost always
    return results far faster. What’s the secret? `locate` isn’t actually searching
    the file system itself, but simply running your search string against entries
    in a preexisting index. The catch is that if the index is allowed to fall out
    of date, the searches become less and less accurate. Normally the index is updated
    every time the system boots, but you can also manually do the job by running `updatedb`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`locate`与`find`直接比较，`locate`几乎总是会返回更快的结果。秘诀是什么？`locate`实际上并不是在搜索文件系统本身，而是在对现有索引中的条目运行你的搜索字符串。问题是，如果索引允许过时，搜索就会变得越来越不准确。通常索引会在系统启动时更新，但你也可以通过运行`updatedb`手动完成这项工作：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 4.4.4\. Preserving permissions and ownership...and extracting archives
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4. 保留权限和所有权...以及提取归档
- en: Did I miss anything? Actually, how to extract the files and directories from
    a tar archive so you can use them again. But before I get to that, there’s another
    bit of business I promised I’d take care of—making sure that your archive operations
    don’t corrupt file permissions and file-ownership attributes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我遗漏了什么吗？实际上，如何从tar归档中提取文件和目录以便再次使用。但在到达那里之前，还有另一项我承诺要处理的业务——确保你的归档操作不会损坏文件权限和文件所有权属性。
- en: Permissions
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 权限
- en: 'As you’ve seen, running `ls -l` lists the contents of a directory in long form,
    showing you (from right to left) the file’s name, age, and size. But it also repeats
    a name (root, in this example) and provides some rather cryptic strings made up
    of the letters *r*, *w*, and *x*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，运行`ls -l`以长格式列出目录内容，从右到左显示文件名、年龄和大小。但它也重复了一个名称（在这个例子中是root）并提供了一些由字母*r*、*w*和*x*组成的相当晦涩的字符串：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here’s where I decipher those two leftmost sections (as annotated in [figure
    4.5](#ch04fig05)). The 10 characters to the left are made up of four separate
    sections. The first dash (***1*** in the figure) means that the object being listed
    is a file. It would be replaced with a *d* if it were a directory. The next three
    characters ***2*** are a representation of the file’s permissions as they apply
    to its owner, the next three ***3*** are the permissions as they apply to its
    group, and the final three ***4*** represent the permissions all other users have
    over this file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我解读那两个最左侧部分的地方（如图4.5所示）。左侧的10个字符由四个独立的部分组成。第一个破折号（图中的**1**）表示所列出的对象是一个文件。如果是目录，则会被替换为*d*。接下来的三个字符**2**表示文件权限，这些权限适用于文件的所有者，接下来的三个字符**3**表示权限适用于文件所属的组，最后的三个字符**4**表示所有其他用户对此文件的权限。
- en: Figure 4.5\. A breakdown of the data displayed by the `ls -l` command
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5. `ls -l`命令显示的数据分解
- en: '![](Images/04fig05_alt.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](Images/04fig05_alt.jpg)'
- en: In this example, the file owner has full authority—including read (`r`), write
    (`w`), and execute (`x`) rights. Members of the group and those in others can
    read and execute, but not write.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，文件所有者拥有完全权限——包括读取（`r`）、写入（`w`）和执行（`x`）权限。组内成员和其他用户可以读取和执行，但不能写入。
- en: But what does all that really mean? Here, the file zcat is the script of a command-line
    program that reads compressed files. The permissions tell you that everyone has
    the right to read the script itself and to execute it (through something like
    `zcat myfile .zip`), but only the owner can edit (*w*) the file. If someone who’s
    logged in to a different user account were to try to edit the file, they’d get
    a No Write Permission warning.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但这一切究竟意味着什么呢？在这里，文件zcat是一个命令行程序的脚本，该程序读取压缩文件。权限告诉你每个人都有权读取脚本本身并执行它（通过类似`zcat
    myfile .zip`的方式），但只有所有者可以编辑（*w*）文件。如果某个登录到不同用户账户的人试图编辑文件，他们会收到无写入权限警告。
- en: 'If you want to change a file’s permissions, use the change mode (`chmod`) tool:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更改文件的权限，请使用更改模式（`chmod`）工具：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This example removes the ability of others (`o`) to read the file and adds write
    permissions for the group (`g`). A file’s owner would be represented by the letter
    *u* (for user).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例移除了其他人（`o`）读取文件的能力，并为组（`g`）添加了写权限。文件的所有者将由字母 *u*（代表用户）表示。
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**What’s a group?**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是组？**'
- en: 'You can think of a group much the same way you might think of a regular user
    account: the things that both can and cannot do or access are defined by file
    permissions. The difference is that no one can log in to a Linux system as a group.
    Then why create groups, and what purpose do they serve? Here’s the scoop.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将组想象成与常规用户账户相似的方式：两者都可以和不能做或访问的事情由文件权限定义。不同之处在于，没有人可以以组身份登录 Linux 系统。那么为什么创建组，它们有什么作用呢？下面是详细解释。
- en: 'Groups are a powerful and super-efficient way to organize resources. Here’s
    a simple example. Consider a company with a few dozen employees who need some
    kind of server access, but not necessarily to the same resources. You can create
    a couple of groups called dev and IT, for example. When users are initially given
    their accounts, all the developers would be added to the dev group, and all the
    sysadmins would be added to IT group. Now, let’s say that a system configuration
    file comes into use: rather than tediously adding file permissions for each of
    the 10 or 15 admins or so, you can give only the IT group access. All the IT group
    members will automatically be added, and all the developers will remain excluded.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 组是组织资源的一种强大且超级高效的方式。这里有一个简单的例子。考虑一家有几十名员工的公司，他们需要某种服务器访问权限，但不一定是相同的资源。例如，你可以创建几个组，称为
    dev 和 IT。当用户最初获得他们的账户时，所有开发者都会被添加到 dev 组，所有系统管理员都会被添加到 IT 组。现在，假设一个系统配置文件开始使用：而不是逐个为
    10 或 15 个管理员添加文件权限，你只需给 IT 组提供访问权限。所有 IT 组成员将自动添加，而所有开发者将保持被排除在外。
- en: Every system user along with many applications will automatically be given their
    own groups. That explains why files you create will normally be owned by *yourname*
    and be part of the *yourname* group. If you decide to stick around, you’ll see
    more implementations of groups in [chapter 9](kindle_split_017.xhtml#ch09).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统用户以及许多应用程序都将自动分配给他们自己的组。这就解释了为什么你创建的文件通常将由 *yourname* 拥有，并成为 *yourname*
    组的一部分。如果你决定留下来，你将看到更多关于第 9 章（[chapter 9](kindle_split_017.xhtml#ch09)）中组的实现。
- en: '|  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You’ll find two other systems for describing permissions in Linux: numeric
    and mask. Talking about mask would be a bit distracting at this point, and, in
    any case, mask isn’t used all that often. But you do need to understand the numeric
    system where each possible combination of permissions can be represented by a
    number between 0 and 7.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现 Linux 中还有两种描述权限的系统：数字和掩码。在这里讨论掩码可能会有些分散注意力，而且无论如何，掩码并不常用。但你需要了解数字系统，其中每个可能的权限组合都可以用一个介于
    0 和 7 之间的数字表示。
- en: How-to guides and command documentation will often tell you to give a file 644
    permissions (or something similar) in order for an operation to run successfully.
    For instance, invoking the private part of an encryption key pair will often not
    work unless it has permissions of either 400 or 600\. You’ll want to know how
    that works.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如何指南和命令文档通常会告诉你为了使操作成功运行，需要给文件设置 644 权限（或类似设置）。例如，调用加密密钥对的私有部分通常不会工作，除非它有 400
    或 600 的权限。你将想知道这是如何工作的。
- en: The read permission is always given the number 4; the write permission, number
    2; and execute, number 1\. A user with all three permissions is described by the
    number 7 (4+2+1=7). Read and write permissions, but not execute, is 6; read and
    execute but not write is 5, and no permissions at all is 0.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 读取权限始终被赋予数字 4；写权限，数字 2；执行权限，数字 1。拥有所有三种权限的用户用数字 7（4+2+1=7）表示。读取和写权限，但没有执行权限，是
    6；读取和执行，但没有写权限，是 5，没有任何权限是 0。
- en: 'To change an object’s permissions, you’d enter the final total scores for each
    category of user (that is, owner, group, and others). For example, updating the
    original status of the zcat file the way you did earlier using chmod `g+w` and
    `o-r` would require 755 (7 for the owner and then 5 for both group and others).
    Removing read permission from others would change that to 751, and adding write
    permissions to group would change that again to 771\. Here’s how you’d use `chmod`
    to apply that value:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改一个对象权限，你需要输入每个用户类别（即所有者、组和其他人）的最终总分。例如，使用 `chmod` 更新 zcat 文件的原有状态，就像你之前使用
    `g+w` 和 `o-r` 那样，需要 755（所有者7分，然后是组和其他人各5分）。从其他人那里移除读取权限将使其变为 751，而向组添加写入权限又将使其变为
    771。以下是使用 `chmod` 应用该值的方法：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s a quick chart to help you remember all those details:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速图表，帮助你记住所有这些细节：
- en: '| Permission | Character | Number |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 权限 | 字符 | 数字 |'
- en: '| --- | --- | --- |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Read | r | 4 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 读取 | r | 4 |'
- en: '| Write | w | 2 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 写入 | w | 2 |'
- en: '| Execute | x | 1 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 执行 | x | 1 |'
- en: Ownership
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 所有权
- en: 'What about those file ownership values? This one is straightforward: these
    are the values that define a file’s owner (*u*) and group (*g*). Check it out
    yourself. From your home directory, create a new file and then list the directory
    contents in long form. You’ll see that the values of both the owner and group
    match your user name. In this example, that’s `username`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 那些文件所有权值又是怎么回事呢？这个很简单：这些值定义了文件的所有者（*u*）和组（*g*）。你自己检查一下。从你的家目录中创建一个新文件，然后以长格式列出目录内容。你会发现所有者和组的值都匹配你的用户名。在这个例子中，是
    `username`：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I rarely go more than a couple of days without having to worry about file ownership.
    Suppose one of my users asks for a file. The file might be too large to email
    or might contain sensitive data that shouldn’t be emailed. The obvious solution
    is to copy it if I’m on the same server. If I’m on a different server, I can always
    use `scp` to transfer the file and then copy the file to the user’s home directory.
    But either way, I’ll need to use `sudo` to copy a file to the user’s directory,
    which means its owner will be root.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我很少连续几天不用担心文件所有权问题。假设我的一个用户请求一个文件。文件可能太大无法通过电子邮件发送，或者可能包含不应该通过电子邮件发送的敏感数据。显然的解决方案是，如果我在同一台服务器上，就复制它。如果我在不同的服务器上，我总是可以使用
    `scp` 来传输文件，然后将文件复制到用户的家目录。但无论如何，我需要使用 `sudo` 来将文件复制到用户的目录，这意味着它的所有者将是 root。
- en: 'Don’t believe me? Try creating a file using `sudo`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你不相信我？试着使用 `sudo` 创建一个文件：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Note that the owner and group for this file is root.**'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注意这个文件的所有者和组是 root。**'
- en: 'Well now, that’s going to be a real problem if my user ever needs to edit the
    file I was kind enough to send. Turns out that I wasn’t being so helpful after
    all—unless I do the job properly and change the file’s ownership using `chown`,
    which works much like the `chmod` command that you saw earlier. This example assumes
    that the account name of that other user is otheruser. Go ahead and create such
    an account using `sudo useradd otheruser`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果我的用户需要编辑我慷慨发送的文件，那可真是个大问题。结果证明，我并没有那么有帮助——除非我正确地完成工作，并使用 `chown` 命令更改文件的所有权，这个命令和您之前看到的
    `chmod` 命令非常相似。这个例子假设那个其他用户账户的名字是 otheruser。现在就使用 `sudo useradd otheruser` 创建这样一个账户吧：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Note the new file owner and group.**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注意新的文件所有者和组。**'
- en: 'That’s permissions and ownership. But what does it have to do with extracting
    your archives? Well, would you be upset if I told you that there was a good chance
    that all the files and directories restored after a catastrophic system crash
    would have the wrong permissions? I thought so. Think about it: you rebuild your
    system and invite all your users to log in once again, but they immediately start
    complaining that they can’t edit their own files!'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是权限和所有权。但是这与提取你的存档有什么关系呢？好吧，如果你听说在灾难性系统崩溃后恢复的所有文件和目录都有错误的权限，你会感到沮丧吗？我想你会的。想想看：你重建了系统，并邀请所有用户再次登录，但他们立即开始抱怨他们无法编辑自己的文件！
- en: 'I think it will be helpful for you to see all this for yourself. So you can
    work through these examples on your own, create a new directory and populate it
    with a few empty files and then, if there aren’t already any other user accounts
    on your system, create one:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为让你亲自看到这些内容会有所帮助。所以你可以自己完成这些例子，创建一个新的目录，并用几个空文件填充它，然后，如果你的系统上还没有其他用户账户，就创建一个：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* The && characters will execute a second command only if the first command
    was successful.**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 只有当第一个命令成功执行时，&& 字符才会执行第二个命令。**'
- en: 'Right now, all three files will be owned by you. Use `chown` to change the
    ownership of one of those files to your new user, and then use `ls -l` to confirm
    that one of the files now belongs to the new user:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，所有三个文件都将归你所有。使用 `chown` 将其中一个文件的拥有权更改为新用户，然后使用 `ls -l` 来确认其中一个文件现在属于新用户：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now create a tar archive including all the files in the current directory the
    way you did before:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个包含当前目录中所有文件的 tar 存档，就像你之前做的那样：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To extract the archive, run the `tar` command against the name of the archive,
    but this time with the argument `x` (for extract) rather than `c`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取存档，运行 `tar` 命令针对存档的名称，但这次使用参数 `x`（表示提取）而不是 `c`：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Extracting an archive overwrites any files with the same names in the current
    directory *without* warning. Here, that’s fine, but that won’t normally be the
    case.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前目录中提取存档会覆盖同名文件，而不会发出警告。在这里，这没问题，但通常不会是这样。
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Running `ls -l` once again will show something you don’t want to see. All three
    files are now owned by you...even file3:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '再次运行 `ls -l` 将会显示一些你不希望看到的内容。现在所有三个文件都归你所有...甚至包括 file3:'
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That’s not good, and I’m sure our friend newuser won’t be happy about it either.
    What’s the solution? Well, first of all, let’s try to figure out exactly what
    the problem is.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不好，我相信我们的朋友 newuser 也不会对此感到高兴。解决方案是什么？首先，让我们尝试找出确切的问题是什么。
- en: Generally, only users with administrator powers can work with resources in other
    users’ accounts. If I wanted to, say, transfer the ownership of one of my files
    to a colleague, because it requires a change to someone else’s account, I can’t
    do that. Generosity has its limits. Therefore, when I try to restore the files
    from the archive, saving them to the ownership of other users would be impossible.
    Restoring files with their original permissions presents a similar (although not
    identical) problem. The solution is to perform these operations as an administrator,
    using `sudo`. Now you know.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，只有具有管理员权限的用户才能在其他用户的账户中操作资源。如果我想，比如说，将我其中一个文件的拥有权转让给同事，因为这需要更改他人的账户，我无法做到。慷慨是有极限的。因此，当我尝试从存档中恢复文件，并将它们保存到其他用户的拥有权下时，这是不可能的。以原始权限恢复文件会带来类似（尽管不是完全相同）的问题。解决方案是以管理员身份执行这些操作，使用
    `sudo`。现在你明白了。
- en: 4.5\. Archiving partitions with dd
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5. 使用 dd 存档分区
- en: There’s all kinds of stuff you can do with `dd` if you research hard enough,
    but where it shines is in the ways it lets you play with partitions. Earlier,
    you used `tar` to replicate entire file systems by copying the files from one
    computer and then pasted them as is on top of a fresh Linux install of another
    computer. But because those file system archives weren’t complete images, they
    required a running host OS to serve as a base.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够努力地研究，你可以用 `dd` 做很多事情，但它最擅长的是让你玩转分区。之前，你使用 `tar` 通过从一台计算机复制文件并直接粘贴到另一台计算机的新
    Linux 安装上，来复制整个文件系统。但由于那些文件系统存档并不完整，它们需要一个运行的宿主操作系统作为基础。
- en: 'Using `dd`, on the other hand, can make perfect byte-for-byte images of, well,
    just about anything digital. But before you start flinging partitions from one
    end of the earth to the other, I should mention that there’s some truth to that
    old UNIX admin joke: *dd* stands for *Disk Destroyer*. If you type even one wrong
    character in a `dd` command, you can instantly and permanently wipe out an entire
    drive worth of valuable data. And yes, spelling counts.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用 `dd` 可以完美地创建几乎任何数字内容的字节数据镜像。但在你开始将分区从一个地球端传送到另一个地球端之前，我应该提到，那个古老的 UNIX
    管理员笑话确实有些真实性：*dd* 代表 *Disk Destroyer*。如果你在 `dd` 命令中输入哪怕一个错误的字符，你都可以瞬间永久地擦除整个驱动器上宝贵的所有数据。而且，拼写很重要。
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As always with `dd`, pause and think very carefully before pressing that Enter
    key!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `dd` 一样，在按下 Enter 键之前，请务必暂停并仔细思考！
- en: '|  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.5.1\. dd operations
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.1. dd 操作
- en: 'Now that you’ve been suitably warned, we’ll start with something straightforward.
    Suppose you want to create an exact image of an entire disk of data that’s been
    designated as /dev/sda. You’ve plugged in an empty drive (ideally having the same
    capacity as your /dev/sdb system). The syntax is simple: `if=` defines the source
    drive, and `of=` defines the file or location where you want your data saved:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经被适当地警告了，我们将从一些简单的事情开始。假设你想要创建一个指定为 /dev/sda 的整个数据磁盘的精确镜像。你已经插入了一个空驱动器（理想情况下，容量与你的
    /dev/sdb 系统相同）。语法很简单：`if=` 定义源驱动器，而 `of=` 定义你想要保存数据的文件或位置：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next example will create a .img archive of the /dev/sda drive and save
    it to the home directory of your user account:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例将创建`/dev/sda`驱动器的`.img`存档并将其保存到您的用户账户的主目录中：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Those commands created images of entire drives. You could also focus on a single
    partition from a drive. The next example does that and also uses `bs` to set the
    number of bytes to copy at a single time (4,096, in this case). Playing with the
    `bs` value can have an impact on the overall speed of a `dd` operation, although
    the ideal setting will depend on hardware and other considerations:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令创建了整个驱动器的图像。您也可以专注于驱动器中的一个单独分区。下一个示例就做了这件事，并且还使用了`bs`来设置每次复制时的字节数（在这个例子中是4,096）。调整`bs`值可能会影响`dd`操作的整体速度，尽管理想的设置将取决于硬件和其他考虑因素：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Restoring is simple: effectively, you reverse the values of `if` and `of`.
    In this case, `if=` takes the image that you want to restore, and `of=` takes
    the target drive to which you want to write the image:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复很简单：实际上，您只需反转`if`和`of`的值。在这种情况下，`if=`接受您想要恢复的镜像，而`of=`接受您想要写入镜像的目标驱动器：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You should always test your archives to confirm they’re working. If it’s a boot
    drive you’ve created, stick it into a computer and see if it launches as expected.
    If it’s a normal data partition, mount it to make sure the files both exist and
    are appropriately accessible.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终测试您的存档以确认它们是否正常工作。如果您创建的是启动驱动器，将其插入计算机并查看是否按预期启动。如果是一个普通的数据分区，将其挂载以确保文件存在且可适当访问。
- en: 4.5.2\. Wiping disks with dd
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.2. 使用dd擦除磁盘
- en: Years ago I had a friend who was responsible for security at his government’s
    overseas embassies. He once told me that each embassy under his watch was provided
    with an official government-issue hammer. Why? In case the facility was ever at
    risk of being overrun by unfriendlies, the hammer was to be used to destroy all
    their hard drives.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，我有一个朋友负责他政府海外大使馆的安全。他曾经告诉我，在他监管下的每个大使馆都配备了一根官方政府颁发的锤子。为什么？以防设施有被不友好势力占领的风险，锤子是用来摧毁所有硬盘的。
- en: What’s that? Why not just delete the data? You’re kidding, right? Everyone knows
    that deleting files containing sensitive data from storage devices doesn’t actually
    remove them. Given enough time and motivation, nearly anything can be retrieved
    from virtually any digital media, with the possible exception of the ones that
    have been well and properly hammered.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 那是什么？为什么不直接删除数据呢？你在开玩笑吧？众所周知，从存储设备中删除包含敏感数据的文件实际上并没有真正删除它们。只要有足够的时间和动机，几乎可以从任何数字媒体中恢复几乎所有内容，可能唯一的例外是那些经过良好且适当破坏的。
- en: 'You can, however, use `dd` to make it a whole lot more difficult for the bad
    guys to get at your old data. This command will spend some time writing millions
    and millions of zeros over every nook and cranny of the /dev/sda1 partition:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以使用`dd`使坏人更难获取您旧数据。这个命令将花费一些时间，在`/dev/sda1`分区的每个角落和缝隙中写入数百万个零：
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But it gets better. Using the /dev/urandom file as your source, you can write
    over a disk with random characters:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有更好的。使用`/dev/urandom`文件作为源，您可以写入随机字符覆盖磁盘：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 4.6\. Synchronizing archives with rsync
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6. 使用rsync同步存档
- en: One thing you already know about proper backups is that, to be effective, they
    absolutely have to happen regularly. One problem with that is that daily transfers
    of huge archives can place a lot of strain on your network resources. Wouldn’t
    it be nice if you only had to transfer the small handful of files that had been
    created or updated since the last time, rather than the whole file system? Done.
    Say hello to `rsync`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道关于正确备份的一件事是，为了有效，它们绝对必须定期进行。其中一个问题是，大量存档的每日传输会给您的网络资源带来很大压力。如果只需传输自上次以来创建或更新的少量文件，而不是整个文件系统，那岂不是很好？做到了。向您介绍`rsync`。
- en: 'I’m going to show you how to create a remote copy of a directory full of files
    and maintain the accuracy of the copy even after the local files change. (You’ll
    first need to make sure that the rsync package is installed on both the client
    and host machines you’ll be using.) To illustrate this happening between your
    own local machine and a remote server (perhaps an LXC container you’ve got running),
    create a directory and populate it with a handful of empty files:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向你展示如何创建一个包含文件的远程副本，并确保即使本地文件发生变化，副本的准确性也能得到保持。（你首先需要确保你将要使用的客户端和主机机器上都安装了
    rsync 软件包。）为了说明这个过程发生在你的本地机器和远程服务器之间（可能是一个你正在运行的 LXC 容器），创建一个目录并用一些空文件填充它：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Creates 10 files named file1 to file10**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建了10个名为 file1 到 file10 的文件**'
- en: 'Now use `ssh` to create a new directory on your remote server where the copied
    files will go, and then run `rsync` with the `-av` arguments. The `v` tells rsync
    to display a verbose list of everything it does. `a` is a bit more complicated,
    but also a whole lot more important. Specifying the `-a` super-argument will make
    `rsync` synchronize recursively (meaning that subdirectories and their contents
    will also be included) and preserve special files, modification times, and (critically)
    ownership and permissions attributes. I’ll bet you’re all-in for `-a`. Here’s
    the example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用 `ssh` 在你的远程服务器上创建一个新的目录，复制文件将放入其中，然后使用 `-av` 参数运行 `rsync`。`v` 参数告诉 `rsync`
    显示它所做的一切的详细列表。`a` 参数稍微复杂一些，但也很重要。指定 `-a` 超级参数将使 `rsync` 递归同步（这意味着子目录及其内容也将包括在内）并保留特殊文件、修改时间以及（至关重要）所有权和权限属性。我敢打赌你们都会选择
    `-a`。以下是一个例子：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* Specify a remote target directory following the colon (:).**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在冒号(:)后指定远程目标目录。**'
- en: '***2* The verbose argument displays the files that were copied.**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* verbose 参数会显示已复制的文件。**'
- en: If everything went as it should, head over to your remove server and list the
    contents of /syncdirectory/. There should be 10 empty files.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切如预期进行，前往你的远程服务器并列出 /syncdirectory/ 的内容。应该有10个空文件。
- en: 'To give `rsync` a proper test run, you could add a new file to the local mynewdir
    directory and use `nano` to, say, add a few words to one of the existing files.
    Then run the exact same `rsync` command as before. When it’s done, see if the
    new file and updated version of the old one have made it to the remote server:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给 `rsync` 一个适当的测试运行，你可以在本地的 mynewdir 目录中添加一个新文件，并使用 `nano` 添加一些文字到现有的某个文件中。然后运行之前完全相同的
    `rsync` 命令。完成后，看看新文件和旧文件的更新版本是否已经传到了远程服务器上：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Only the new/updated files are listed in the output.**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 只有新/更新的文件会在输出中列出。**'
- en: There’s a whole lot more `rsync` backup goodness waiting for you to discover.
    But, as with all the other tools I discuss in this book, you now have the basics.
    Where you go from here is up to you. In the next chapter, however, you’ll learn
    about automating backups using system schedulers. For now, there’s one final thought
    I’d like to share about backups.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多关于 `rsync` 备份的精彩功能等待你去发现。但是，就像我在这本书中讨论的所有其他工具一样，你现在已经掌握了基础知识。接下来你要走的方向取决于你自己。然而，在下一章中，你将学习如何使用系统调度器来自动化备份。现在，我还有一个关于备份的最终想法想要分享。
- en: 4.7\. Planning considerations
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7\. 计划考虑因素
- en: 'Careful consideration will go a long way to determine how much money and effort
    you invest in your backups. The more valuable your data is to you, the more reliable
    it should be. The goal is to measure the value of your data against these questions:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细考虑将大大有助于确定你在备份上投入多少金钱和精力。你的数据对你越有价值，它应该越可靠。目标是衡量你的数据价值与以下问题：
- en: How often should you create new archives, and how long will you retain old copies?
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该多久创建一次新的存档，以及你将保留旧副本多长时间？
- en: How many layers of validation will you build into your backup process?
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将在备份过程中构建多少层验证？
- en: How many concurrent copies of your data will you maintain?
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将维护多少个数据副本？
- en: How important is maintaining geographically remote archives?
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护地理位置上远程存档有多重要？
- en: 'Another equally important question: should you consider incremental or differential
    backups? Although you’re probably going to want to use `rsync` either way, the
    way you sequence your backups can have an impact on both the resources they consume
    and the availability of the archives they produce.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个同样重要的问题：你应该考虑增量备份还是差异备份？尽管你可能无论如何都会想使用 `rsync`，但你备份的顺序可能会影响它们消耗的资源以及产生的存档的可用性。
- en: Using a *differential* system, you might run a full backup once a week (Monday),
    and smaller and quicker differential backups on each of the next six days. The
    Tuesday backup will include only files changed since Monday’s backup. The Wednesday,
    Thursday, and Friday backups will each include all files changed since Monday.
    Friday’s backup will, obviously, take up more time and space than Tuesday’s. On
    the plus side, restoring a differential archive requires only the last full backup
    and the most recent differential backup.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *差异* 系统，您可能每周运行一次完整备份（周一），然后在接下来的六天中运行较小且较快的差异备份。周二的备份将仅包括自周一备份以来更改的文件。周三、周四和周五的备份将各自包括自周一以来更改的所有文件。周五的备份显然将比周二占用更多的时间和空间。优点是，恢复差异存档只需要最后一个完整备份和最近的差异备份。
- en: An *incremental* system might also perform full backups only on Mondays and
    can also run a backup covering only changed files on Tuesday. Wednesday’s backup,
    unlike the differential approach, will include only files added or changed since
    Tuesday, and Thursday’s will have only those changed since Wednesday. Incremental
    backups will be fast and efficient; but, as the updated data is spread across
    more files, restoring incremental archives can be time-consuming and complicated.
    This is illustrated in [figure 4.6](#ch04fig06).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *增量* 系统也可能只在周一进行完整备份，也可以在周二运行仅覆盖已更改文件的备份。周三的备份，与差异方法不同，将仅包括自周二以来添加或更改的文件，周四的备份将仅包括自周三以来更改的文件。增量备份将快速高效；但是，由于更新的数据分布在更多文件中，恢复增量存档可能既耗时又复杂。这如图
    4.6 所示。
- en: Figure 4.6\. The differences between incremental and differential backup systems
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.6\. 增量备份和差异备份系统之间的差异
- en: '![](Images/04fig06_alt.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig06_alt.jpg)'
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Not having good backups can ruin your morning.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有良好的备份可能会毁掉你的早晨。
- en: The `tar` command is generally used for archiving full or partial file systems,
    whereas `dd` is more suited for imaging partitions.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar` 命令通常用于存档完整或部分文件系统，而 `dd` 更适合于分区镜像。'
- en: Adding compression to an archive not only saves space on storage drives, but
    also bandwidth during a network transfer.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存档中添加压缩不仅可以节省存储驱动器上的空间，还可以在网络传输期间节省带宽。
- en: Directories containing pseudo file systems usually don’t need backing up.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含伪文件系统的目录通常不需要备份。
- en: You can incorporate the transfer of an archive into the command that generates
    it, optionally avoiding any need to save the archive locally.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将存档的传输集成到生成它的命令中，可选地避免需要本地保存存档。
- en: It’s possible—and preferred—to preserve the ownership and permissions attributes
    of objects restored from an archive.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留从存档中恢复的对象的所有权和权限属性是可能的——也是首选的。
- en: You can use `dd` to (fairly) securely wipe old disks.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `dd` （相当）安全地擦除旧磁盘。
- en: You can incrementally synchronize archives using `rsync`, greatly reducing the
    time and network resources needed for ongoing backups.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `rsync` 逐步同步存档，大大减少持续备份所需的时间和网络资源。
- en: Key terms
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键术语
- en: An *archive* is a specially formatted file in which file system objects are
    bundled.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *存档* 是一个特殊格式的文件，其中包含文件系统对象。
- en: '*Compression* is a process for reducing the disk space used by a file through
    the application of a compression algorithm.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*压缩* 是通过应用压缩算法来减少文件占用的磁盘空间的过程。'
- en: An *image* is an archive containing the files and directory structure necessary
    to re-create a source file system in a new location.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *图像* 是一个包含文件和目录结构，用于在新位置重新创建源文件系统的存档。
- en: '*Permissions* are the attributes assigned to an object that determine who may
    use it and how.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*权限* 是分配给对象的属性，它决定了谁可以使用它以及如何使用。'
- en: '*Ownership* is the owner and group that have authority over an object.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*所有权* 是拥有对象和组的所有者和组。'
- en: A *group* is an account used to manage permissions for multiple users.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *组* 是一个用于管理多个用户权限的账户。
- en: Security best practices
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全最佳实践
- en: Create an automated, reliable, tested, and secure recurring process for backing
    up all of your important data.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为备份所有重要数据创建一个自动的、可靠的、经过测试的、安全的定期过程。
- en: Where appropriate, separate file systems with sensitive data by placing them
    on their own partitions and mounting them to the file system at boot time.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适当的情况下，通过将它们放置在各自的分区并将它们在启动时挂载到文件系统上来分离包含敏感数据的文件系统。
- en: Always ensure that file permissions are accurate, and allow only the least access
    necessary.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是确保文件权限准确无误，并仅允许必要的最低访问权限。
- en: Never assume the data on an old storage drive is truly deleted.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要假设旧存储驱动器上的数据真正被删除。
- en: Command-line review
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行审查
- en: '`df -h` displays all currently active partitions with sizes shown in a human
    readable format.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`df -h` 显示所有当前活动分区，大小以人类可读的格式显示。'
- en: '`tar czvf archivename.tar.gz /home/myuser/Videos/*.mp4` creates a compressed
    archive from video files in a specified directory tree.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar czvf archivename.tar.gz /home/myuser/Videos/*.mp4` 从指定目录树中的视频文件创建一个压缩归档。'
- en: '`split -b 1G archivename.tar.gz archivename.tar.gz.part` splits a large file
    into smaller files of a set maximum size.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`split -b 1G archivename.tar.gz archivename.tar.gz.part` 将大文件拆分为最大大小为 1G 的较小文件。'
- en: '`find /var/www/ -iname "*.mp4" -exec tar -rvf videos.tar {} \;` finds files
    meeting a set criteria and streams their names to `tar` to include in an archive.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find /var/www/ -iname "*.mp4" -exec tar -rvf videos.tar {} \;` 查找满足特定标准的文件并将它们的名称流式传输到
    `tar` 以包含在归档中。'
- en: '`chmod o-r /bin/zcat` removes read permissions for others.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod o-r /bin/zcat` 移除其他人的读权限。'
- en: '`dd if=/dev/sda2 of=/home/username/partition2.img` creates an image of the
    sda2 partition and saves it to your home directory.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dd if=/dev/sda2 of=/home/username/partition2.img` 创建 sda2 分区的镜像并将其保存到您的家目录中。'
- en: '`dd if=/dev/urandom of=/dev/sda1` overwrites a partition with random characters
    to obscure the old data.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dd if=/dev/urandom of=/dev/sda1` 用随机字符覆盖分区以隐藏旧数据。'
- en: Test yourself
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试自己
- en: '**[1](#ch04qa2q0a1)**'
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch04qa2q0a1)**'
- en: ''
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of these arguments tells `tar` to compress an archive?
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个参数告诉 `tar` 压缩归档？
- en: ''
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`-a`'
  id: totrans-281
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-a`'
- en: '`-v`'
  id: totrans-282
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-v`'
- en: '`-z`'
  id: totrans-283
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-z`'
- en: '`-c`'
  id: totrans-284
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-c`'
- en: '**[2](#ch04qa2q0a2)**'
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch04qa2q0a2)**'
- en: ''
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of these partitions are you *least* likely to want to include in a backup
    archive?
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个分区你最不可能想要包含在备份归档中？
- en: ''
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: /var
  id: totrans-289
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: /var
- en: /run
  id: totrans-290
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: /run
- en: /
  id: totrans-291
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: /
- en: /home
  id: totrans-292
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: /home
- en: '**[3](#ch04qa2q0a3)**'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch04qa2q0a3)**'
- en: ''
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The second partition on the first storage drive on a system will usually be
    designated by which of the following?
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 系统上第一个存储驱动器的第二个分区通常由以下哪个指定？
- en: ''
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: /dev/sdb2
  id: totrans-297
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: /dev/sdb2
- en: /dev/srb0
  id: totrans-298
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: /dev/srb0
- en: /dev/sda2
  id: totrans-299
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: /dev/sda2
- en: /dev/sdb1
  id: totrans-300
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: /dev/sdb1
- en: '**[4](#ch04qa2q0a4)**'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](#ch04qa2q0a4)**'
- en: ''
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following will create a compressed archive of all the .mp4 files
    in a directory?
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个命令会在目录中创建所有 .mp4 文件的压缩归档？
- en: ''
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`tar cvf archivename.tar.gz *.mp4`'
  id: totrans-305
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tar cvf archivename.tar.gz *.mp4`'
- en: '`tar cvf *.mp4 archivename.tar.gz`'
  id: totrans-306
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tar cvf *.mp4 archivename.tar.gz`'
- en: '`tar czvf archivename.tar.gz *.mp4`'
  id: totrans-307
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tar czvf archivename.tar.gz *.mp4`'
- en: '`tar *.mp4 czvf archivename.tar`'
  id: totrans-308
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tar *.mp4 czvf archivename.tar`'
- en: '**[5](#ch04qa2q0a5)**'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5](#ch04qa2q0a5)**'
- en: ''
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following tools will help you put multiple file parts back together?
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个工具可以帮助你将多个文件部分重新组合在一起？
- en: ''
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`cat`'
  id: totrans-313
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cat`'
- en: '`split`'
  id: totrans-314
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`split`'
- en: '`|`'
  id: totrans-315
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`|`'
- en: '`part`'
  id: totrans-316
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`part`'
- en: '**[6](#ch04qa2q0a6)**'
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[6](#ch04qa2q0a6)**'
- en: ''
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What of the following will find all .mp4 files within the specified directories
    and add them to a `tar` archive?
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个命令会在指定的目录中查找所有 .mp4 文件并将它们添加到 `tar` 归档中？
- en: ''
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`find /var/www/ -iname "*" -exec tar -rvf videos.tar {} \;`'
  id: totrans-321
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`find /var/www/ -iname "*" -exec tar -rvf videos.tar {} \;`'
- en: '`find /var/www/ -iname "*.mp4" -exec tar -vf videos.tar {} \;`'
  id: totrans-322
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`find /var/www/ -iname "*.mp4" -exec tar -vf videos.tar {} \;`'
- en: '`find /var/www/ -iname "*.mp4" | tar -rvf videos.tar {} \;`'
  id: totrans-323
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`find /var/www/ -iname "*.mp4" | tar -rvf videos.tar {} \;`'
- en: '`find /var/www/ -iname "*.mp4" -exec tar -rvf videos.tar {} \;`'
  id: totrans-324
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`find /var/www/ -iname "*.mp4" -exec tar -rvf videos.tar {} \;`'
- en: '**[7](#ch04qa2q0a7)**'
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[7](#ch04qa2q0a7)**'
- en: ''
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following will give a file’s owner full rights, its group read
    and execute rights, and others only execute rights?
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个命令会给文件的所有者完全权限，组读执行权限，其他人只有执行权限？
- en: ''
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`chmod 752`'
  id: totrans-329
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chmod 752`'
- en: '`chmod 751`'
  id: totrans-330
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chmod 751`'
- en: '`chmod 651`'
  id: totrans-331
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chmod 651`'
- en: '`chmod 744`'
  id: totrans-332
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chmod 744`'
- en: '**[8](#ch04qa2q0a8)**'
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[8](#ch04qa2q0a8)**'
- en: ''
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will the command `dd if=sdadisk.img of=/dev/sdb` do?
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命令 `dd if=sdadisk.img of=/dev/sdb` 会做什么？
- en: ''
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Copy the contents of the /dev/sdb drive to a file called sdadisk.img
  id: totrans-337
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 /dev/sdb 驱动的所有内容复制到名为 sdadisk.img 的文件中
- en: Destroy all data on the network
  id: totrans-338
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 毁灭网络上的所有数据
- en: Copy an image called sdadisk.img to the /dev/sdb drive
  id: totrans-339
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为 sdadisk.img 的镜像复制到 /dev/sdb 驱动器
- en: Format the /dev/sdb drive and then move sdadisk.img to it
  id: totrans-340
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式化 /dev/sdb 驱动器并将 sdadisk.img 移动到其中
- en: Answer key
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 答案键
- en: '**[1.](#ch04qa1q1)**'
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1.](#ch04qa1q1)**'
- en: ''
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c
- en: '**[2.](#ch04qa1q2)**'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2.](#ch04qa1q2)**'
- en: ''
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b
- en: '**[3.](#ch04qa1q3)**'
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3.](#ch04qa1q3)**'
- en: ''
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c
- en: '**[4.](#ch04qa1q4)**'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4.](#ch04qa1q4)**'
- en: ''
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c
- en: '**[5.](#ch04qa1q5)**'
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5.](#ch04qa1q5)**'
- en: ''
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a
- en: '**[6.](#ch04qa1q6)**'
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[6.](#ch04qa1q6)**'
- en: ''
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d
- en: '**[7.](#ch04qa1q7)**'
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[7.](#ch04qa1q7)**'
- en: ''
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b
- en: '**[8.](#ch04qa1q8)**'
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[8.](#ch04qa1q8)**'
- en: ''
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c
