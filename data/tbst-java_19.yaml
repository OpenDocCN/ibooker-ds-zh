- en: Appendix D. Understanding Java threads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录D.理解Java线程
- en: In this appendix, we’ll discuss the basics of threads in a Java app. A thread
    is an independent sequential set of instructions your app runs. Operations on
    a given thread run concurrently with those on other threads. Any Java app today
    relies on having multiple threads, so it’s almost impossible not to get into investigation
    scenarios where you have to more deeply understand why specific threads don’t
    do what they should or don’t easily collaborate with other threads. That’s why
    you’ll find threads in several discussions throughout this book (especially chapters
    7 to 9, but also here and there in the first half of the book when we discuss
    debugging). To properly understand these discussions, you need to know some basics
    about threads. This appendix teaches you those elements that are essential for
    understanding other discussions we have throughout the book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们将讨论Java应用程序中线程的基本知识。线程是应用程序运行的独立指令序列。给定线程上的操作与其他线程上的操作并发运行。今天，任何Java应用程序都依赖于拥有多个线程，因此几乎不可能不遇到需要更深入理解为什么特定线程没有按预期工作或难以与其他线程协作的研究场景。这就是为什么您会在本书的多个讨论中找到线程（特别是第7章到第9章，但也在本书前半部分的其他地方，当我们讨论调试时）。为了正确理解这些讨论，您需要了解一些关于线程的基本知识。本附录向您介绍了理解本书中其他讨论所必需的元素。
- en: We’ll start with section D.1, where I’ll remind you of the threads’ big picture
    and why we use them in apps. We’ll continue in section D.2 with more details on
    how a thread executes by discussing its life cycle. Knowing the states of a thread’s
    life cycle and the possible transitions is necessary for investigating any thread-related
    issue. In section D.3, we’ll discuss thread synchronization, which is a way to
    control the executing threads. Faulty synchronization implementations introduce
    most of the problems you need to investigate and solve. In section D.4, we’ll
    discuss the most common thread-related issues.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从D.1节开始，我会提醒您线程的整体概念以及为什么我们在应用程序中使用它们。在D.2节中，我们将通过讨论线程的生命周期来详细介绍线程的执行方式。了解线程生命周期的状态和可能的转换对于调查任何与线程相关的问题都是必要的。在D.3节中，我们将讨论线程同步，这是一种控制执行线程的方式。错误的同步实现引入了您需要调查和解决的大多数问题。在D.4节中，我们将讨论最常见的与线程相关的问题。
- en: Threads are a complex subject, so I’ll only focus on the topics you need to
    know to understand the techniques presented in this book. I can’t promise to make
    you an expert in the subject in only a few pages, so you’ll find a few resources
    I recommend at the end of this appendix.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是一个复杂的话题，所以我只会关注您需要了解以理解本书中展示的技术。我无法保证在几页纸内让您成为该主题的专家，因此您会在本附录的末尾找到我推荐的一些资源。
- en: D.1 What is a thread?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.1 什么是线程？
- en: In this section, we discuss what threads are and how using multiple threads
    helps an app. A *thread* is an independent sequence of operations in a running
    process. Any process can have multiple threads that run concurrently, enabling
    your app to solve multiple tasks, potentially, in parallel. Threads are an essential
    component of how a language handles concurrency.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论线程是什么以及如何使用多个线程帮助应用程序。*线程*是运行进程中的一个独立操作序列。任何进程都可以有多个并发运行的线程，使您的应用程序能够解决多个任务，潜在地并行执行。线程是语言处理并发的一个基本组成部分。
- en: I like to visualize a multithreaded app as a group of sequence timelines as
    presented in figure D.1\. Notice that the app starts with one thread (the main
    thread). This thread launches other threads, which can start others, and so on.
    Remember that each thread is independent of the others. For example, the main
    thread can end its execution long before the app itself. The process stops when
    all its threads stop.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢将多线程应用程序想象成图D.1所示的一组序列时间线。请注意，应用程序从一个线程（主线程）开始。这个线程启动其他线程，这些线程可以再启动其他线程，依此类推。请记住，每个线程都是独立的。例如，主线程可以在应用程序本身结束之前很久就结束其执行。当所有线程停止时，进程停止。
- en: '![](../../OEBPS/Images/APPD_F01_Spilca3.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/APPD_F01_Spilca3.png)'
- en: Figure D.1 A multithreaded app visualized as a group of sequence timelines.
    Each arrow in the figure represents the timeline of a thread. An app starts with
    the main thread, which can launch other threads. Some threads run until the process
    ends, while others stop earlier. At a given time, an app can have one or more
    threads running in parallel.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图D.1 将多线程应用程序可视化为一组序列时间线。图中的每条箭头代表一个线程的时间线。应用程序从主线程开始，可以启动其他线程。一些线程一直运行到进程结束，而其他线程则提前停止。在某个特定时间，一个应用程序可以有一个或多个线程并行运行。
- en: Instructions on a given thread are always in a defined order. You always know
    that A will happen before B if instruction A is before instruction B on the same
    thread. But since two threads are independent of one another, you can’t say the
    same about two instructions A and B, each on a separate thread. In such a case,
    either A can execute before B, or vice versa (figure D.2). Sometimes we say that
    one case is more probable than another, but we can’t know how one flow will consistently
    execute.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 给定线程上的指令总是按照定义的顺序执行。如果您知道指令A在同一个线程上位于指令B之前，那么您总是知道A会在B之前发生。但由于两个线程相互独立，您不能对两个分别位于不同线程的指令A和B说同样的话。在这种情况下，A可以在B之前执行，或者反之亦然（图D.2）。有时我们可以说一种情况比另一种情况更可能，但我们不能知道哪种流程会持续执行。
- en: '![](../../OEBPS/Images/APPD_F02_Spilca3.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/APPD_F02_Spilca3.png)'
- en: Figure D.2 With two instructions on one thread, we can always know the exact
    order of execution. But because two threads are independent, if instructions are
    on different threads, we can’t know the order in which they will execute. At most,
    we can say that one scenario is more likely than another.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图D.2 在一个线程上有两个指令时，我们总能知道执行的确切顺序。但由于两个线程是独立的，如果指令位于不同的线程上，我们无法知道它们将执行的顺序。最多我们只能说一种情况比另一种情况更可能。
- en: In many cases, you’ll see thread execution visually represented by tools as
    sequence timelines. Figure D.3 shows the way VisualVM (a profiler tool we use
    throughout the book) presents the thread execution as sequence timelines.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您会看到工具将线程执行以序列时间线的方式可视化。图D.3显示了VisualVM（本书中使用的分析器工具）如何以序列时间线的方式呈现线程执行。
- en: '![](../../OEBPS/Images/APPD_F03_Spilca3.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/APPD_F03_Spilca3.png)'
- en: Figure D.3 VisualVM shows thread execution as sequence timelines. This visual
    representation makes the app’s execution easier to understand and helps you to
    investigate possible problems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图D.3 VisualVM以序列时间线的方式显示线程执行。这种视觉表示使得应用程序的执行更容易理解，并有助于您调查可能的问题。
- en: D.2 A thread’s life cycle
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.2 线程的生命周期
- en: Once you visualize the thread execution, another essential aspect in understanding
    their execution is knowing the thread life cycle. Throughout its execution, a
    thread goes through multiple states (figure D.4). When using a profiler (as discussed
    in chapters 6–9) or a thread dump (as discussed in chapter 10), we’ll often refer
    to the thread’s state, which is important when trying to figure out the execution.
    Knowing how a thread can transition from one state to another and how the thread
    behaves in each state is essential to following and investigating the app’s behavior.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您可视化了线程执行，了解线程生命周期是理解它们执行的关键。在整个执行过程中，线程会经历多个状态（图D.4）。当使用分析器（如第6章至第9章中讨论的）或线程转储（如第10章中讨论的）时，我们通常会参考线程的状态，这在试图了解执行时非常重要。了解线程如何从一个状态转换到另一个状态以及线程在每个状态下的行为对于跟踪和调查应用程序的行为至关重要。
- en: 'Figure D.4 visually presents the thread states and how a thread can transition
    from one state to another. We can identify the following main states for a Java
    thread:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图D.4直观地展示了线程状态以及线程如何从一个状态转换到另一个状态。我们可以识别Java线程的以下主要状态：
- en: '*New*—The thread is in this state right after its instantiation (before being
    started). While in this state, the thread is a simple Java object. The app can’t
    yet execute the instructions it defines.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*新建*—线程在其实例化后（在启动之前）处于此状态。在此状态下，线程是一个简单的Java对象。应用程序还不能执行它定义的指令。'
- en: '*Runnable*—The thread is in this state after its `start()` method has been
    called. In this state, the JVM can execute the instructions the thread defines.
    While in this state, the JVM will progressively move the thread between two substates:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可运行*—线程在其`start()`方法被调用后处于此状态。在此状态下，JVM可以执行线程定义的指令。在此状态下，JVM将逐步将线程在两个子状态之间移动：'
- en: '*Ready*—The thread doesn’t execute, but the JVM can put it in execution at
    any time.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备就绪*—线程不会执行，但JVM可以在任何时候将其放入执行状态。'
- en: '*Running*—The thread is in execution. A CPU currently executes instructions
    it defines.'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行*—线程正在执行。当前CPU正在执行它定义的指令。'
- en: '*Blocked*—The thread was started, but it was temporarily taken out of the runnable
    state, so the JVM can’t execute its instructions. This state helps us to control
    the thread execution by allowing us to temporarily “hide” the thread from the
    JVM so that it can’t execute it. While blocked, a thread can be in one of the
    following substates:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*阻塞*—线程已启动，但暂时被移出了可运行状态，因此JVM无法执行其指令。此状态帮助我们通过允许我们暂时“隐藏”线程从JVM中，使其无法执行，来控制线程的执行。在阻塞状态下，线程可以处于以下子状态之一：'
- en: '*Monitored*—The thread is paused by a monitor of a synchronized block (object
    controlling the access to a synchronized block) and waits to be released to execute
    that block.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*监视*—线程被同步块的监视器（控制对同步块访问的对象）暂停，并等待被释放以执行该块。'
- en: '*Waiting*—During the execution, a monitor’s `wait()` method was called, which
    caused the current thread to be paused. The thread remains blocked until the `notify()`
    or `notifyAll()` methods are called to allow the JVM to release the thread in
    execution.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等待*—在执行过程中，调用了监视器的`wait()`方法，这导致当前线程暂停。线程将保持阻塞状态，直到调用`notify()`或`notifyAll()`方法，允许JVM释放正在执行的线程。'
- en: '*Sleeping*—The `sleep()` method in the `Thread` class was called, which paused
    the current thread for a defined time. The time is given as a parameter to the
    `sleep()` method. The thread becomes runnable after this time passes.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*睡眠*—在`Thread`类中调用`sleep()`方法，将当前线程暂停一段时间。时间作为参数传递给`sleep()`方法。在这段时间过后，线程变为可运行状态。'
- en: '*Parked*—Almost the same as waiting, a thread will show as parked after someone
    calls the `park()` method, which blocks the current thread until the `unpark()`
    method is called.'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*已挂起*—几乎与等待相同，当有人调用`park()`方法后，线程将显示为已挂起，这会阻塞当前线程，直到调用`unpark()`方法。'
- en: '*Dead*—A thread is dead or terminated after it finishes its set of instructions,
    an `Error` or `Exception` halted it, or it was interrupted by another thread.
    Once dead, a thread cannot be started again.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*死亡*—线程在完成其指令集后死亡或终止，一个`Error`或`Exception`使其停止，或者它被另一个线程中断。一旦死亡，线程无法再次启动。'
- en: '![](../../OEBPS/Images/APPD_F04_Spilca3.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/APPD_F04_Spilca3.png)'
- en: Figure D.4 A thread life cycle. During its life, a thread goes through multiple
    states. First, the thread is new, and the JVM cannot run the instructions it defines.
    After starting the thread, it becomes runnable and starts to be managed by the
    JVM. The thread can be temporarily blocked during its life, and at the end of
    its life it goes to a dead state, from which it can’t be restarted.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图D.4 线程生命周期。在其生命周期中，线程会经历多个状态。首先，线程是新的，JVM无法运行它定义的指令。启动线程后，它变为可运行状态，并开始被JVM管理。线程在其生命周期中可以暂时被阻塞，在其生命周期的末尾，它进入死亡状态，从该状态无法重新启动。
- en: 'Figure D.4 also shows the possible transitions between thread states:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图D.4也显示了线程状态之间的可能转换：
- en: The thread goes from new to runnable once someone calls its `start()` method.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有人调用其`start()`方法时，线程从新状态变为可运行状态。
- en: Once in the runnable state, the thread oscillates between ready and running.
    The JVM decides which thread is executed and when.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦进入可运行状态，线程会在就绪和运行之间振荡。JVM决定哪个线程将被执行以及何时执行。
- en: 'Sometimes, the thread gets blocked. It can go into the blocked state in several
    ways:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，线程会被阻塞。它可以通过几种方式进入阻塞状态：
- en: The `sleep()` method in the `Thread` class is called, putting the current thread
    into a temporary blocked state.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Thread`类中调用`sleep()`方法，将当前线程置于一个临时的阻塞状态。
- en: Someone called the `join()` method, causing the current thread to wait for another
    one.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有人调用了`join()`方法，导致当前线程等待另一个线程。
- en: Someone called the `wait()` method of a monitor, pausing the execution of the
    current thread until the `notify()` or `notifyAll()` methods are called.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有人调用了监视器的`wait()`方法，暂停了当前线程的执行，直到调用`notify()`或`notifyAll()`方法。
- en: A monitor of a synchronized block paused the execution of a thread until another
    active thread finished the execution of the synchronized block.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个同步块的监视器暂停了线程的执行，直到另一个活动线程完成同步块的执行。
- en: The thread can go into a dead (terminated) state either when it finishes its
    execution or when another thread interrupts it. The JVM considers transitioning
    from the blocked state to the dead state unacceptable. If a blocked thread is
    interrupted by another, the transition is signaled with an `InterruptedException`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程可以在执行完毕或被其他线程中断时进入死（终止）状态。JVM认为从阻塞状态到终止状态的转换是不可接受的。如果阻塞线程被另一个线程中断，转换会通过`InterruptedException`信号表示。
- en: D.3 Synchronizing threads
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.3 同步线程
- en: In this section, we’ll discuss approaches to synchronizing threads, which developers
    use to control the threads in a multithreaded architecture. Incorrect synchronization
    is also the root cause of many problems you’ll have to investigate and solve.
    We’ll go through an overview of the most common ways used to synchronize threads.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论同步线程的方法，这是开发者在多线程架构中控制线程所使用的。不正确的同步也是许多你必须调查和解决的问题的根本原因。我们将概述同步线程最常用的方法。
- en: D.3.1 Synchronized blocks
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.3.1 同步块
- en: 'The simplest way to synchronize threads, and usually the first concept any
    Java developer learns about synchronizing threads is using a synchronized block
    of code. The purpose is to allow only one thread at a time through the synchronized
    code—to prohibit concurrent execution for a given piece of code. There are two
    options for this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 同步线程最简单的方法，通常是任何Java开发者学习同步线程的第一个概念，就是使用同步代码块。其目的是允许一次只有一个线程通过同步代码——禁止给定代码片段的并发执行。这里有两种选择：
- en: '*Block synchronization*—Applying the synchronized modifier on a given block
    of code'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*块同步*—在给定的代码块上应用synchronized修饰符'
- en: '*Method synchronization*—Applying the synchronized modifier on a method'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方法同步*—在方法上应用synchronized修饰符'
- en: 'The next code snippet shows an example of a synchronized block:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了同步块的例子：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ The object between the parentheses is the monitor of the synchronized block.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 括号中的对象是同步块的监视器。
- en: ❷ The synchronized block of instructions is defined between the curly braces.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 同步指令块被定义在大括号之间。
- en: 'The next code snippet shows you a method synchronization:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了方法同步的例子：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Synchronized modifier applied to the method
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 应用到方法上的synchronized修饰符
- en: ❷ The whole block of code of the method defined between the curly braces is
    synchronized.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义在大括号中的整个方法代码块是同步的。
- en: 'Both ways of using the `synchronized` keyword work the same, even if they look
    a bit different. You’ll find two important components of each synchronized block:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`synchronized`关键字这两种方式的效果相同，尽管它们看起来有些不同。你将发现每个同步块的两个重要组成部分：
- en: '*The monitor*—An object managing the execution of the synchronized instructions'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*监视器*—管理同步指令执行的对象'
- en: '*The block of instructions*—The actual instructions, which are synchronized'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指令块*—实际同步的指令'
- en: The method synchronization seems to be missing the monitor, but for this syntax
    the monitor is actually implied. For a nonstatic method, the instance “this” will
    be used as a monitor, while for a static method, the synchronized block will use
    the class’s type instance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 方法同步似乎缺少监视器，但对此语法来说，监视器实际上是隐含的。对于非静态方法，将使用实例“this”作为监视器，而对于静态方法，同步块将使用类的类型实例作为监视器。
- en: 'The monitor (which cannot be null) is the object that gives sense to a synchronized
    block. This object decides whether a thread can enter and execute the synchronized
    instructions. Technically, the rule is easy: once a thread enters the synchronized
    block, it acquires a lock on the monitor. No other thread will be accepted in
    the synchronized block until the one that has the lock releases it. To simplify
    things, let’s assume that a thread releases the lock only when it exits the synchronized
    block. Figure D.5 shows a visual example. Imagine the two synchronized blocks
    are in different parts of the app, but because they both use the same monitor,
    M1 (the same object instance), a thread can execute in only one of the blocks
    at a time. None of the instructions, A, B, or C, will be called concurrently (at
    least not from the presented synchronized blocks).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 监视器（不能为 null）是赋予同步块意义的对象。该对象决定一个线程是否可以进入并执行同步指令。技术上，规则很简单：一旦一个线程进入同步块，它就会在监视器上获得一个锁。直到拥有锁的线程释放它，其他线程将不会被接受进入同步块。为了简化，让我们假设线程仅在退出同步块时释放锁。图
    D.5 展示了一个视觉示例。想象两个同步块位于应用程序的不同部分，但由于它们都使用相同的监视器 M1（相同的对象实例），线程一次只能在一个块中执行。指令 A、B
    或 C 不会并发调用（至少不是从所提供的同步块中）。
- en: '![](../../OEBPS/Images/APPD_F05_Spilca3.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/APPD_F05_Spilca3.png)'
- en: Figure D.5 An example of using synchronized blocks. Multiple synchronized blocks
    of the app can use the same object instance as a monitor. When this happens, all
    threads are correlated such that only one active thread executes in all. In this
    image, if one thread enters the synchronized block, defining instructions A and
    B, no other thread can enter in the same block or in the one defining instruction
    C.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.5 使用同步块的示例。应用程序的多个同步块可以使用作为监视器的相同对象实例。当这种情况发生时，所有线程都是相关的，以至于只有一个活动线程在所有同步块中执行。在这张图片中，如果一个线程进入同步块，定义指令
    A 和 B，则其他线程不能进入相同的块或定义指令 C 的块。
- en: However, the app may define multiple synchronized blocks. The monitor links
    multiple synchronized blocks, but when two synchronized blocks use two different
    monitors (figure D.6), these blocks are not synchronized. In figure D.6, the first
    and the second synchronized blocks are also synchronized with each other since
    they use the same monitor. But these two blocks aren’t synchronized with the third.
    The result is that instruction D, defined in the third synchronized block, can
    execute concurrently with any of the instructions of the first two synchronized
    blocks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，应用程序可能定义多个同步块。监视器链接多个同步块，但当两个同步块使用两个不同的监视器（图 D.6）时，这些块不是同步的。在图 D.6 中，第一个和第二个同步块也是相互同步的，因为它们使用相同的监视器。但这两个块与第三个块不同步。结果是，定义在第三个同步块中的指令
    D 可以与第一个和第二个同步块中的任何指令并发执行。
- en: '![](../../OEBPS/Images/APPD_F06_Spilca3.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/APPD_F06_Spilca3.png)'
- en: Figure D.6 When two synchronized blocks don’t use the same object instance as
    the monitor, they are not synchronized. In this case, the second and the third
    synchronized blocks use different monitors. That means instructions from these
    two synchronized blocks can execute simultaneously.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.6 当两个同步块不使用作为监视器的相同对象实例时，它们不是同步的。在这种情况下，第二个和第三个同步块使用不同的监视器。这意味着这两个同步块中的指令可以同时执行。
- en: When investigating issues using tools such as a profiler or a thread dump, you
    need to understand the way in which a thread has been blocked. This information
    can shed light on what happens, why, or what causes a given thread not to execute.
    Figure D.7 shows how VisualVM (the profiler we use in chapters 7–9) shows that
    the monitor of a synchronized block blocked a thread.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用分析器或线程转储等工具调查问题时，你需要了解线程被阻塞的方式。这些信息可以阐明发生了什么，为什么，或者是什么原因导致某个线程无法执行。图 D.7
    展示了 VisualVM（我们在第 7-9 章中使用的分析器）如何显示同步块监视器阻塞了一个线程。
- en: '![](../../OEBPS/Images/APPD_F07_Spilca3.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/APPD_F07_Spilca3.png)'
- en: Figure D.7 VisualVM indicates the state of a thread. The Threads tab in the
    profiler provides a complete picture of what each thread does and, if a thread
    is blocked, what blocked that thread.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.7 VisualVM 显示了线程的状态。分析器中的线程选项卡提供了每个线程所做事情的完整情况，如果线程被阻塞，则显示阻塞该线程的原因。
- en: D.3.2 Using wait(), notify(), and notifyAll()
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.3.2 使用 wait()、notify() 和 notifyAll()
- en: Another way a thread can be blocked is if it is asked to wait for an undefined
    time. Using the `wait()` method of a monitor of a synchronized block, you can
    instruct a thread to wait indefinitely. Some other thread can then “tell” the
    one that’s waiting to continue its work. You can do this with the `notify()` or
    `notifyAll()` methods of the monitor. These methods are often used to improve
    an app’s performance by preventing a thread from executing if it doesn’t make
    sense to execute. At the same time, the wrong use of these methods can lead to
    deadlocks or situations where threads wait indefinitely without ever being released
    to execution.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种线程可能被阻塞的方式是如果它被要求等待一个不确定的时间。使用同步块监视器的 `wait()` 方法，您可以指示线程无限期地等待。然后，其他线程可以“告诉”等待的线程继续其工作。您可以使用监视器的
    `notify()` 或 `notifyAll()` 方法来做这件事。这些方法通常用于通过防止线程在不应该执行时执行来提高应用程序的性能。同时，这些方法的错误使用可能导致死锁或线程无限期等待而从未被释放到执行的情况。
- en: Remember that `wait()`, `notify()`, and `notifyAll()` make sense only when they
    are used in a synchronized block. These methods are behaviors of the synchronized
    block’s monitor, so you can’t use them without having a monitor. With the `wait()`method,
    the monitor blocks a thread for an undefined time. When blocking the thread, it
    also releases the lock it acquired so that other threads can enter blocks synchronized
    by that monitor. When the `notify()` method is called, the thread can again be
    executed. Figure D.8 summarizes the `wait()` and `notify()` methods.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`wait()`、`notify()` 和 `notifyAll()` 只有在它们被用于同步块时才有意义。这些方法是同步块监视器的行为，因此您不能在没有监视器的情况下使用它们。使用
    `wait()` 方法，监视器会阻塞线程一个不确定的时间。在阻塞线程的同时，它也会释放它所获得的锁，以便其他线程可以进入由该监视器同步的块。当调用 `notify()`
    方法时，线程可以再次被执行。图 D.8 总结了 `wait()` 和 `notify()` 方法。
- en: '![](../../OEBPS/Images/APPD_F08_Spilca3.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/APPD_F08_Spilca3.png)'
- en: Figure D.8 In some cases, a thread should pause from executing and wait for
    something to happen. To make a thread wait, the monitor of a synchronized block
    can call its `wait()` behavior. When the thread becomes executable again, the
    monitor can call the `notify()` or `notifyAll()` methods.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.8 在某些情况下，一个线程应该暂停执行并等待某个事件发生。为了使线程等待，同步块的监视器可以调用它的 `wait()` 行为。当线程再次可执行时，监视器可以调用
    `notify()` 或 `notifyAll()` 方法。
- en: Figure D.9 shows a more particular scenario. In chapter 7, we used an example
    of an app implementing a producer-consumer approach, in which multiple threads
    share a resource. The producer threads add values to the shared resource, and
    the consumer threads consume those values. But what happens if the shared resource
    no longer has value? The consumers would not benefit from executing at this time.
    Technically, they can still execute, but they have no value to consume, so allowing
    the JVM to execute them would cause unneeded resource consumption on the system.
    A better approach would be to “tell” the consumers to wait when the shared resource
    has no value and to continue their execution only after a producer added a new
    value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.9 展示了一个更具体的场景。在第 7 章中，我们使用了一个实现生产者-消费者方法的示例应用，其中多个线程共享一个资源。生产者线程向共享资源添加值，消费者线程消费这些值。但如果共享资源不再有值呢？消费者在此时执行将不会受益。技术上，它们仍然可以执行，但没有值可以消费，因此允许
    JVM 执行它们会导致系统不必要的资源消耗。更好的方法是在共享资源没有值时“告诉”消费者等待，并且只有在生产者添加了新的值后，才继续它们的执行。
- en: '![](../../OEBPS/Images/APPD_F09_Spilca3.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/APPD_F09_Spilca3.png)'
- en: Figure D.9 A use case for `wait()` and `notify()`. When a thread brings no value
    by executing in the current conditions, we can make it wait until further notice.
    In this case, a consumer should not execute when it has no value to consume. We
    can make the consumers wait, and a producer can tell them to continue only after
    it adds a new value to the shared resource.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.9 `wait()` 和 `notify()` 的一个用例。当一个线程在当前条件下执行没有带来任何值时，我们可以让它等待直到进一步的通知。在这种情况下，当消费者没有可消费的值时，它不应该执行。我们可以让消费者等待，并且只有当生产者在共享资源中添加了新的值后，才能告诉他们继续。
- en: D.3.3 Joining threads
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.3.3 线程的连接
- en: A quite common thread synchronization approach is joining threads by making
    a thread wait until another has finished its execution. What’s different from
    the wait/notify pattern is that the thread doesn’t wait to be notified. The thread
    simply waits for the other to finish its execution. Figure D.10 shows a scenario
    that could benefit from this synchronization technique.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一种相当常见的线程同步方法是让一个线程等待另一个线程完成其执行。与等待/通知模式不同的是，线程不需要等待被通知。线程只是简单地等待另一个线程完成其执行。图D.10展示了可能从这种同步技术中受益的场景。
- en: Suppose you have to implement some data processing based on data retrieved from
    two different independent sources. Usually, retrieving the data from the first
    data source takes about 5 seconds, and getting the data from the second data source
    takes about 8 seconds. If you execute the operations sequentially, the time needed
    to get all the data for processing is 5 + 8 = 13 seconds. But you know a better
    approach. Since the data sources are two independent databases, you can get the
    data from both at the same time if you use two threads. But then you need to make
    sure the thread that processes the data waits for both threads that retrieve data
    to finish before it can start. To achieve this, you make the processing thread
    join the threads that retrieve the data (figure D.10).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你必须根据从两个不同的独立来源检索到的数据实现一些数据处理。通常，从第一个数据源检索数据需要大约5秒，从第二个数据源获取数据需要大约8秒。如果你按顺序执行操作，获取所有数据处理所需的时间是5
    + 8 = 13秒。但是，你知道一个更好的方法。由于数据源是两个独立的数据库，如果你使用两个线程，你可以同时从两个数据源获取数据。但是，然后你需要确保处理数据的线程在开始之前等待检索数据的两个线程完成。为了实现这一点，你使处理线程加入检索数据的线程（图D.10）。
- en: '![](../../OEBPS/Images/APPD_F10_Spilca3.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/APPD_F10_Spilca3.png)'
- en: Figure D.10 In some cases, you can improve the app’s performance using multiple
    threads. But you need to make some threads wait for others since they depend on
    the execution result of those threads. You can make a thread wait for another
    using a join operation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图D.10在某些情况下，你可以使用多个线程来提高应用程序的性能。但是，你需要让一些线程等待其他线程，因为它们依赖于这些线程的执行结果。你可以使用join操作使一个线程等待另一个线程。
- en: Joining threads is, in many cases, a necessary synchronization technique. But
    when not used well, it can also cause problems. For example, if one thread is
    waiting for another, is stuck, or never ends, the one joining it will never execute.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，连接线程是一种必要的同步技术。但是，如果使用不当，它也可能导致问题。例如，如果一个线程正在等待另一个线程，它卡住了，或者永远不会结束，那么加入它的线程将永远不会执行。
- en: D.3.4 Blocking threads for a defined time
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.3.4 定义时间阻塞线程
- en: 'Sometimes a thread needs to wait for a given amount of time. In this case,
    the thread is in a “timed waiting” state or “sleeping.” The following operations
    are the most common to cause a thread to be timed waiting:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个线程需要等待给定的时间。在这种情况下，线程处于“定时等待”状态或“睡眠”状态。以下操作是最常见的导致线程定时等待的操作：
- en: '`sleep()`—You can always use the static `sleep()` method in the class `Thread`
    to make the thread currently executing the code wait for a fixed amount of time.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sleep()`—你可以始终使用`Thread`类中的静态`sleep()`方法来使当前正在执行代码的线程等待固定的时间。'
- en: '`wait(long timeout)`—The wait method with a timeout parameter can be used the
    same as the `wait()` method without any parameters, as discussed in section D.3.2\.
    However, if you provide a parameter, the thread will wait the given time if not
    notified earlier.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait(long timeout)`—具有超时参数的wait方法可以像D.3.2节中讨论的没有参数的`wait()`方法一样使用。然而，如果你提供了一个参数，如果在此之前没有收到通知，线程将等待给定的时间。'
- en: '`join(long timeout``)`—This operation works the same as the `join()` method
    we discussed in section D.3.3, but waits for the maximum timeout, which is given
    as a parameter.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join(long timeout)`—这个操作与我们在D.3.3节中讨论的`join()`方法的工作方式相同，但等待最大超时时间，该时间作为参数给出。'
- en: A common antipattern I often find in apps is the use of `sleep()` to make a
    thread wait instead of the `wait()` method we discussed in chapter 4\. Take the
    producer-consumer architecture we discussed as an example. You could use `sleep()`
    instead of `wait()`, but how long should a consumer sleep to ensure the producer
    has time to run and add values to the shared resource? We don’t have an answer
    to this question. For example, making the thread sleep for 100 milliseconds (as
    shown in figure D.11) can be too long or too short. In most cases, if you follow
    this approach, you end up not having the best performance.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我在应用程序中经常发现的一个常见反模式是使用`sleep()`来使线程等待，而不是我们在第4章中讨论的`wait()`方法。以我们讨论的生产者-消费者架构为例。你可以用`sleep()`代替`wait()`，但消费者应该睡眠多长时间以确保生产者有时间运行并添加值到共享资源？我们对此没有答案。例如，使线程睡眠100毫秒（如图D.11所示）可能太长或太短。在大多数情况下，如果你遵循这种方法，你最终得到的性能可能不是最好的。
- en: '![](../../OEBPS/Images/APPD_F11_Spilca3.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/APPD_F11_Spilca3.png)'
- en: Figure D.11 A timed waiting approach instead of `wait()` and `notify()` is usually
    not the best strategy. Whenever your code can determine when the thread can continue
    its execution, use `wait()` and `notify()` instead of `sleep()`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图D.11 使用定时等待方法代替`wait()`和`notify()`通常不是最佳策略。只要你的代码可以确定线程何时可以继续执行，就使用`wait()`和`notify()`代替`sleep()`。
- en: D.3.5 Synchronizing threads with blocking objects
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.3.5 使用阻塞对象同步线程
- en: The JDK offers an impressive suite of tools for synchronizing threads. Out of
    these, a few of the best-known classes used in multithreaded architectures are
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JDK提供了一套令人印象深刻的工具用于同步线程。在这些工具中，一些在多线程架构中使用的最知名的类包括
- en: '`Semaphore`—An object you can use to limit the number of threads that can execute
    a given block of code'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`信号量`—你可以用来限制可以执行给定代码块线程数量的对象'
- en: '`CyclicBarrier`—An object you can use to make sure at least a given number
    of threads are active to execute a given block of code'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`—你可以用来确保至少有给定数量的线程活跃以执行给定代码块的对象'
- en: '`Lock`—An object that provides more extensive synchronization options'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`锁`—一个提供更广泛同步选项的对象'
- en: '`Latch`—An object you can use to make some threads wait until certain logic
    in other threads is performed'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`闩锁`—你可以用来使一些线程等待，直到其他线程中的某些逻辑执行完毕的对象'
- en: These objects are higher-level implementations, each deploying a defined mechanism
    to simplify the implementation in certain scenarios. In most cases, these objects
    cause trouble because of the improper way they are used, and in many cases, developers
    overengineer the code with them. My advice is to use the simplest solution you
    can find to solve a problem and, before using any of these objects, make sure
    you properly understand how they work.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象是高级实现，每个都采用定义良好的机制来简化某些场景下的实现。在大多数情况下，这些对象由于使用不当而引起麻烦，而且在许多情况下，开发者会过度设计使用它们的代码。我的建议是使用你能找到的最简单的方法来解决问题，并且在使用这些对象之前，确保你正确理解它们的工作原理。
- en: D.4 Common issues in multithreaded architectures
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.4 多线程架构中的常见问题
- en: 'When investigating multithreaded architectures, you’ll identify common problems,
    which are root causes of various unexpected behavior (be it an unexpected output
    or a performance problem). Understanding these problems up front will help you
    to more quickly identify where a problem comes from and fix it. These issues are
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查多线程架构时，你会识别出常见的问题，这些问题是各种意外行为（无论是意外输出还是性能问题）的根本原因。提前理解这些问题将帮助你更快地确定问题的来源并修复它。这些问题如下：
- en: '*Race conditions*—Two or more threads compete for modifying a shared resource.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*竞态条件*—两个或更多线程竞争修改共享资源。'
- en: '*Deadlocks*—Two or more threads stick while waiting for each other.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*死锁*—两个或更多线程在等待对方时陷入僵局。'
- en: '*Livelocks*—Two or more threads fail to meet the conditions to stop and continuously
    run without executing any useful work.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*活锁*—两个或更多线程未能满足停止的条件，并且持续运行而不执行任何有用的工作。'
- en: '*Starvation*—A thread is continuously blocked while the JVM executes other
    threads. The thread never gets to execute the instructions it defines.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*饥饿*—当一个线程在JVM执行其他线程时持续被阻塞。该线程永远不会执行它定义的指令。'
- en: D.4.1 Race conditions
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.4.1 竞态条件
- en: 'Race conditions happen when multiple threads try to change the same resource
    concurrently. When this happens, we can encounter either unexpected results or
    exceptions. Generally, we use synchronization techniques to avoid these situations.
    Figure D.12 visually shows such a case. Threads T1 and T2 simultaneously attempt
    to change the value of variable x. Thread T1 tries to increment the value, while
    thread T2 tries to decrement it. This scenario may result in different outputs
    for repeated executions of the app. The following scenarios are possible:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个线程尝试并发更改同一资源时，会发生竞态条件。当这种情况发生时，我们可能会遇到意外结果或异常。通常，我们使用同步技术来避免这些情况。图 D.12 以视觉方式展示了这种情况。线程
    T1 和 T2 同时尝试更改变量 x 的值。线程 T1 尝试增加值，而线程 T2 尝试减少它。这种场景可能导致应用程序重复执行时产生不同的输出。以下是一些可能的情况：
- en: '*After the operations execute, x may be 5*—If T1 changed the value first, and
    T2 read the already changed value of the variable, or the other way around, the
    variable will still have a value of 5.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*操作执行后，x 可能是 5*——如果 T1 首先更改了值，而 T2 读取了已经更改的变量值，或者相反，变量仍然具有值 5。'
- en: '*After the operations execute, x may be 4*—If both threads read the value of
    x at the same time, but T2 wrote the value last, x will be (the value T2 read,
    5, minus 1).'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*操作执行后，x 可能是 4*——如果两个线程同时读取 x 的值，但 T2 是最后一个写入的，x 将是（T2 读取的值，5，减去 1）。'
- en: '*After the operations execute, x may be 6*—If both threads read the value of
    x at the same time, but T1 wrote the value last, x will be 6 (the value T1 read,
    5, plus 1).'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*操作执行后，x 可能是 6*——如果两个线程同时读取 x 的值，但 T1 是最后一个写入的，x 将是 6（T1 读取的值，5，加上 1）。'
- en: '![](../../OEBPS/Images/APPD_F12_Spilca3.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/APPD_F12_Spilca3.png)'
- en: Figure D.12 A race condition. Multiple threads concurrently try to change a
    shared resource. In this example, threads T1 and T2 try to change the value of
    variable x simultaneously, which can result in different outputs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.12 竞态条件。多个线程同时尝试更改共享资源。在这个例子中，线程 T1 和 T2 同时尝试更改变量 x 的值，这可能导致不同的输出。
- en: Such situations usually lead to unexpected output. With a multithreaded architecture
    where multiple execution flows are possible, such scenarios can be challenging
    to reproduce. Sometimes, they happen only in specific environments, which makes
    investigations difficult.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况通常会导致意外的输出。在可能存在多个执行流程的多线程架构中，这些情况可能很难重现。有时，它们只在特定环境中发生，这使得调查变得困难。
- en: D.4.2 Deadlocks
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.4.2 死锁
- en: Deadlocks are situations in which two or more threads pause and then wait for
    something from each other to continue their execution (figure D.13). Deadlocks
    cause an app, or at least part of it, to freeze, preventing certain capabilities
    from running.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁是两个或多个线程暂停并等待彼此的某些操作以继续执行的情况（见图 D.13）。死锁会导致应用程序（或至少其一部分）冻结，阻止某些功能运行。
- en: '![](../../OEBPS/Images/APPD_F13_Spilca3.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/APPD_F13_Spilca3.png)'
- en: Figure D.13 Example of a deadlock. In a case in which T1 waits for T2 to continue
    the execution and T2 waits for T1, the threads are in a deadlock. Neither can
    continue because they are waiting for the other.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.13 死锁示例。在 T1 等待 T2 继续执行而 T2 又等待 T1 的情况下，线程处于死锁状态。由于它们都在等待对方，因此都无法继续执行。
- en: Figure D.14 illustrates the way a deadlock can occur with code. In this example,
    one thread acquired a lock on resource A, and another, on resource B. But each
    thread also needs the resource acquired by the other thread to continue its execution.
    Thread T1 waits for thread T2 to release resource A, but at the same time, thread
    T2 waits for T1 to release resource B. Neither of the threads can continue since
    both wait for the other to release the resources they need, resulting in a deadlock.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.14 展示了死锁可以通过代码发生的方式。在这个例子中，一个线程获得了资源 A 的锁，另一个线程获得了资源 B 的锁。但是，每个线程也需要另一个线程所拥有的资源来继续其执行。线程
    T1 等待线程 T2 释放资源 A，但与此同时，线程 T2 正在等待线程 T1 释放资源 B。由于两个线程都在等待对方释放它们需要的资源，因此都无法继续执行，导致死锁。
- en: '![](../../OEBPS/Images/APPD_F14_Spilca3.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/APPD_F14_Spilca3.png)'
- en: 'Figure D.14 A deadlock. Thread T1 can’t enter the nested synchronized block
    because T2 has a lock on resource A. Thread T1 waits for T2 to release resource
    A so that it can continue its execution. But thread T2 is in a similar situation:
    it cannot continue its execution because T1 acquired a lock on resource B. Thread
    T2 waits for thread T1 to release resource B so that it can continue its execution.
    Since both threads wait for each other and neither can continue its execution,
    the threads are in a deadlock.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.14 死锁。线程 T1 无法进入嵌套的同步块，因为 T2 拥有资源 A 的锁。线程 T1 等待 T2 释放资源 A 以便它可以继续执行。但线程
    T2 处于类似的情况：它无法继续执行，因为 T1 获得了资源 B 的锁。线程 T2 等待线程 T1 释放资源 B 以便它可以继续执行。由于两个线程都在等待对方，并且都不能继续执行，因此线程处于死锁状态。
- en: The example presented in figure D.14 is simple, but it’s just a didactic one.
    A real-world scenario is usually much more difficult to investigate and understand
    and can involve more than two threads. Beware that synchronized blocks are not
    the only way threads can get stuck in a deadlock. The best way to understand such
    scenarios is using the investigation techniques you learned in chapters 7 to 9.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.14 中的示例很简单，但它只是一个教学示例。现实世界的情况通常更难调查和理解，可能涉及多个线程。请注意，同步块并不是线程陷入死锁的唯一方式。理解此类场景的最佳方式是使用你在第
    7 章到第 9 章中学到的调查技术。
- en: D.4.3 Livelocks
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.4.3 活锁
- en: Livelocks are more or less the opposite of deadlocks. When threads are in a
    livelock, the condition always changes in such a way that the threads continue
    their execution even though they should stop on a given condition. The threads
    can’t stop, and they continuously run, usually consuming the system’s resources
    without reason. Livelocks can cause performance issues in an app’s execution.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 活锁或多或少是死锁的反面。当线程处于活锁状态时，条件总是以某种方式改变，使得线程即使应该在给定条件下停止也会继续执行。线程无法停止，它们会持续运行，通常无理由地消耗系统的资源。活锁可能导致应用程序执行中的性能问题。
- en: Figure D.15 demonstrates a livelock with a sequence diagram. Two threads, T1
    and T2, run in a loop. To stop its execution, T1 makes a condition true before
    its last iteration. The next time T1 comes back to the condition, it expects it
    to be true and to stop. However, this doesn’t happen since another thread, T2,
    changed it back to false. T2 finds itself in the same situation. Each thread changes
    the condition so that it can stop, but at the same time, each change in the condition
    causes the other thread to continue running.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.15 展示了一个通过序列图表示的活锁。两个线程 T1 和 T2 在一个循环中运行。为了停止其执行，T1 在其最后一次迭代之前使一个条件为真。当
    T1 下次回到该条件时，它期望它为真并停止。然而，这并没有发生，因为另一个线程 T2 将其改回为假。T2 发现自己处于相同的情况。每个线程都会改变条件，以便它可以停止，但与此同时，每个条件的变化都会导致另一个线程继续运行。
- en: '![](../../OEBPS/Images/APPD_F15_Spilca3.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/APPD_F15_Spilca3.png)'
- en: Figure D.15 An example of a livelock. Two threads rely on a condition to stop
    their execution. But when changing the value of the condition so that they can
    stop, each thread causes the other to continue running. The threads cannot stop,
    and thus unnecessarily spend the system’s resources.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 D.15 活锁的一个例子。两个线程依赖于一个条件来停止它们的执行。但当改变条件的值以便它们可以停止时，每个线程都会导致另一个线程继续运行。线程无法停止，因此不必要地消耗了系统的资源。
- en: Just as with the deadlock example in chapter 4 (section 4.4.2), remember this
    is a simplified scenario. Livelocks can be caused by more complex scenarios in
    the real world, and more than two threads can be involved. Chapters 7 to 9 address
    several ways you can approach the investigation of such scenarios.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如第 4 章中的死锁示例（第 4.4.2 节）一样，请记住这是一个简化的场景。现实世界中的活锁可能由更复杂的情况引起，并且可能涉及多个线程。第 7 章到第
    9 章讨论了你可以用来调查此类场景的几种方法。
- en: D.4.4 Starvation
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.4.4 饥饿
- en: Another common problem, although less likely to occur in today’s apps, is starvation.
    Starvation is caused by a certain thread being constantly excluded from the execution
    even if it is runnable. The thread wants to execute its instructions, but the
    JVM continuously allows other threads to access the system’s resources. Because
    the thread cannot access the system’s resources and execute its defined set of
    instructions, we say that it is starving.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见问题，尽管在当今的应用中不太可能发生，是饥饿。饥饿是由于某个线程始终被排除在执行之外，即使它是可运行的。该线程想要执行其指令，但 JVM 持续允许其他线程访问系统的资源。因为线程无法访问系统的资源并执行其定义的指令集，所以我们说它是饥饿的。
- en: In the early JVM versions, such situations occurred when the developer set a
    much lower priority to a given thread. Today, the JVM implementations are much
    smarter in treating these cases, so (at least in my experience) starvation scenarios
    are less likely.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期JVM版本中，当开发者给某个线程设置一个非常低的优先级时，就会出现这种情况。如今，JVM实现对这些情况的处理要聪明得多，所以（至少在我的经验中）饥饿场景发生的可能性较小。
- en: D.5 Further reading
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.5 进一步阅读
- en: 'Threads are complex, and in this appendix we discussed the essential topics
    that will help you understand the techniques addressed throughout this book. But,
    for any Java developer, understanding how threads work in detail is a valuable
    skill. Here is a list of resources I recommend you read to learn about threads
    in depth:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 线程很复杂，在这篇附录中，我们讨论了帮助你理解本书中提到的技术的关键主题。但是，对于任何Java开发者来说，详细了解线程的工作原理是一项宝贵的技能。以下是我推荐您阅读的一些资源，以深入了解线程：
- en: '*Oracle Certified Professional Java SE 11 Developer Complete Study Guide* by
    Jeanne Boyarsky and Scott Selikoff (Sybex, 2020). Chapter 18 describes threads
    and concurrency, starting from zero and covering all the thread fundamentals OCP
    certification requires. I recommend you start with this book to learn threads.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*Oracle Certified Professional Java SE 11 Developer Complete Study Guide*》由Jeanne
    Boyarsky和Scott Selikoff（Sybex，2020）编著。第18章介绍了线程和并发，从零开始，涵盖了OCP认证所需的全部线程基础知识。我建议您从这本书开始学习线程。
- en: The second edition of *The Well-Grounded Java Developer* by Benjamin Evans,
    Jason Clark, and Martijn Verburg (Manning, 2022) teaches concurrency, from the
    fundamentals to performance tuning.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Benjamin Evans、Jason Clark和Martijn Verburg（Manning，2022）编著的《*The Well-Grounded
    Java Developer*》的第二版，从基础到性能调优，教授并发知识。
- en: '*Java Concurrency in Practice* by Brian Goetz et al. (Addison-Wesley, 2006)
    is an older book, but it hasn’t lost its value. This book is a must-read for any
    Java developer wanting to improve their threads and concurrency knowledge.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Brian Goetz等人编著的《*Java Concurrency in Practice*》（Addison-Wesley，2006）是一本较老的书，但它并没有失去其价值。任何想要提高自己线程和并发知识水平的Java开发者都应该阅读这本书。
