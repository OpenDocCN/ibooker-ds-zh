- en: 8  Persisting your data with MongoDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8  使用 MongoDB 持久化数据
- en: I have three favorite chapters in this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这本书中有三个最喜欢的章节。
- en: 'You''ve already passed my first favorite: Chapter 3, where we discuss the foundations
    of Express. I like that chapter because the goal is to really explain Express.
    In my opinion, it''s the most important chapter of the book, because it explains
    the framework conceptually.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经通过了我最喜欢的第一部分：第三章，我们讨论了 Express 的基础。我喜欢那一章，因为目标是真正地解释 Express。在我看来，这是本书最重要的章节，因为它从概念上解释了框架。
- en: Chapter 10 is the second of my three favorites. As you'll see, it discusses
    security, and I love putting a hacker hat on and trying to break Express applications.
    It's a lot of fun (and, incidentally, terribly important).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第 10 章是我三个最喜欢的章节中的第二个。正如你将看到的，它讨论了安全性，我喜欢戴上黑客帽子尝试破解 Express 应用程序。这很有趣（顺便说一下，非常重要）。
- en: This chapter is my final favorite. Why? Because after this chapter, your applications
    will feel real. No more dinky example apps. No more data that quickly disappears.
    Your Express applications will have user accounts, blog posts, friend requests,
    calendar appointments...all with the power of data persistence.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是我最喜欢的最后一章。为什么？因为在这章之后，你的应用程序将感觉真实。不再有微不足道的示例应用程序。不再有迅速消失的数据。你的 Express 应用程序将拥有用户账户、博客文章、好友请求、日历预约……所有这些都将得益于数据持久化。
- en: Nearly every application has some kind of data, be it blog posts or user accounts
    or cat pictures. As we've discussed, Express is generally an unopinionated framework.
    Fitting in with this unopinionated mantra, Express doesn't dictate how you store
    your data. So how should we approach it?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个应用程序都有某种类型的数据，无论是博客文章、用户账户还是猫的照片。正如我们讨论的那样，Express 通常是一个无意见的框架。与这个无意见的座右铭相符，Express
    并不规定你如何存储数据。那么我们应该如何处理这个问题呢？
- en: You could store your application's data in memory, by simply setting variables.
    For example, Chapter 3's guestbook example stored the guestbook entries in an
    array. While this is useful in very simple cases, it's got a number of disadvantages.
    For one, if your server stops (either because you manually stop it or because
    it crashes), your data is gone! And if you grow to hundreds of millions of data
    points, you'll run out of memory. This method also runs into issues when you have
    multiple servers running your application, because data can be on one machine
    but not the other.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单地设置变量来将应用程序的数据存储在内存中。例如，第三章的留言簿示例将留言簿条目存储在一个数组中。虽然这在非常简单的案例中很有用，但它有几个缺点。首先，如果你的服务器停止了（无论是你手动停止它还是它崩溃），你的数据就会丢失！如果你增长到数亿个数据点，你会耗尽内存。这种方法在多个服务器运行你的应用程序时也会遇到问题，因为数据可能在一个机器上，但在另一个机器上没有。
- en: You could try to store your application's data in files, by writing to a file
    or multiple files. This is how many databases work internally, after all. But
    that leaves you to figure out how to structure and query that data. How do you
    save your data? How do you efficiently get data out of those files when you need
    it? You might wind up building a database of your own, which is a huge headache.
    And once again, this doesn't magically work with multiple servers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试将应用程序的数据存储在文件中，通过写入文件或多个文件。毕竟，许多数据库就是这样在内部工作的。但这就需要你自己去思考如何结构和查询这些数据。你该如何保存数据？当你需要数据时，你该如何高效地从这些文件中获取数据？你可能会最终构建自己的数据库，这会是一个巨大的头疼问题。而且，这同样不会神奇地与多台服务器一起工作。
- en: 'We''ll need another plan. And that''s why we choose software designed for this
    purpose: a database. Our database of choice is something called MongoDB.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另一个计划。这就是为什么我们选择为这个目的设计的软件：数据库。我们选择的数据库是被称为 MongoDB 的东西。
- en: 'In this chapter, we''ll learn the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: ·  How MongoDB works
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ·  MongoDB 的工作原理
- en: ·  How to use Mongoose, an official MongoDB library
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何使用 Mongoose，一个官方的 MongoDB 库
- en: ·  How to securely create user accounts
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何安全地创建用户账户
- en: ·  How to use Passport for authentication
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何使用 Passport 进行身份验证
- en: Let's get real.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现实一点。
- en: 8.1     Why MongoDB?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1     为什么选择 MongoDB？
- en: MongoDB (often shortened to Mongo) is a popular database that's wiggled its
    way into the hearts of many Node developers. Its pairing with Express is beloved
    enough to have spawned the acronym "MEAN", for MongoDB, Express, Angular (a front-end
    JavaScript framework), and Node. In this book, we'll be discussing everything
    but the "A" of that acronym...the "MEN" stack, if you will.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB（通常简称为 Mongo）是一个流行的数据库，它已经巧妙地进入了众多 Node 开发者的心中。它与 Express 的搭配受到如此喜爱，以至于产生了“MEAN”这个缩写，代表
    MongoDB、Express、Angular（一个前端 JavaScript 框架）和 Node。在这本书中，我们将讨论除了那个缩写中的“A”以外的所有内容……即“MEN”栈。
- en: At this point, you may be saying, "There are a lot of choices for databases
    out there, like SQL or Apache Cassandra or Couchbase. Why choose MongoDB?" That's
    a good question!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能正在说：“现在有很多数据库可供选择，比如SQL、Apache Cassandra或Couchbase。为什么选择MongoDB？”这是一个好问题！
- en: In general, Web applications store their data in one of two kinds of databases: relational and non-relational.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Web应用程序将它们的数据存储在两种类型的数据库中之一：关系型和非关系型。
- en: Typically, relational databases are a lot like spreadsheets. Their data is structured,
    and each entry is generally a row in a table. They are a bit like strongly-typed
    languages such as Java, where each entry must fit into rigid requirements (called
    a schema). Most relational databases can be controlled with some derivative of
    SQL, the Structured Query Language; you likely have heard of MySQL or SQL Server
    or PostgreSQL. "Relational databases" and "SQL databases" are often terms used
    interchangeably.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，关系型数据库就像电子表格一样。它们的数据是有结构的，每个条目通常都是表格中的一行。它们有点像强类型语言，如Java，其中每个条目都必须符合严格的要求（称为模式）。大多数关系型数据库都可以用SQL（结构化查询语言）的某种变体来控制；你很可能听说过MySQL、SQL
    Server或PostgreSQL。“关系型数据库”和“SQL数据库”通常是可互换使用的术语。
- en: Non-relational databases, on the other hand, are often called "NoSQL" databases.
    (In reality, "NoSQL" just means "anything that isn't SQL", but it tends to refer
    to a certain class of database.) I like to imagine "NoSQL" as both a different
    technology and a fist-up cry against the status quo. Perhaps "NoSQL" is tattooed
    on a protester's arm. In any case, it's different from relational databases in
    that it is generally not structured like a spreadsheet. They are generally a bit
    less rigid than SQL databases. This is very much like JavaScript in this way;
    JavaScript is generally less rigid. In general, NoSQL databases "feel" a bit more
    like JavaScript than SQL databases.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，非关系型数据库通常被称为“NoSQL”数据库。（实际上，“NoSQL”仅仅意味着“不是SQL的任何东西”，但它往往指的是一类特定的数据库。）我喜欢想象“NoSQL”既是一种不同的技术，也是对现状的一种强烈抗议。也许“NoSQL”就像抗议者手臂上的纹身。无论如何，它与关系型数据库不同，因为它通常不像电子表格那样结构化。它们通常比SQL数据库要灵活一些。在这方面，它们非常类似于JavaScript；JavaScript通常也更灵活。总的来说，NoSQL数据库“感觉”上比SQL数据库更像JavaScript。
- en: For this reason, we choose a NoSQL database. The NoSQL database we'll choose
    is called MongoDB. But why choose that?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们选择了一个NoSQL数据库。我们将选择的NoSQL数据库叫做MongoDB。但为什么选择它呢？
- en: For one, MongoDB is popular. That isn't in itself a merit, but this has a few
    benefits. You won't have trouble finding help online. It's also useful to know;
    it's used in lots of places by lots of people. Mongo is also a mature project.
    It's been around since 2007 and is trusted by companies like eBay, Craigslist,
    and Orange. You won't be using buggy, unsupported software.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，MongoDB很受欢迎。这本身并不是优点，但它有几个好处。你不会在网上找不到帮助。它也被很多人用在很多地方。Mongo也是一个成熟的项目。它自2007年以来一直存在，并被eBay、Craigslist和Orange等公司所信任。你不会使用有缺陷的、不受支持的软件。
- en: Mongo is popular in part because it's mature, feature-filled, and reliable.
    It's written in performant C++ and is trusted by lots and lots of users.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Mongo之所以受欢迎，部分原因在于它成熟、功能丰富且可靠。它是用性能良好的C++编写的，并且被大量用户所信任。
- en: While Mongo isn't written in JavaScript, its native shell uses JavaScript. That
    means that when you open Mongo to play around in the command line, you send it
    commands with JavaScript. It's pretty nice to be able to "talk to" the database
    with a language you're already using!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Mongo不是用JavaScript编写的，但它的原生shell使用JavaScript。这意味着当你打开Mongo在命令行中玩耍时，你用JavaScript发送命令给它。能够用你已经使用的语言“与”数据库“交谈”是非常方便的！
- en: I also chose Mongo for this chapter because I think it's easier to learn than
    SQL for a JavaScript developer. SQL is a powerful programming language unto itself,
    but you already know JavaScript!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我还选择Mongo来写这一章，因为我认为它对于JavaScript开发者来说比SQL更容易学习。SQL本身是一种强大的编程语言，但你已经知道JavaScript了！
- en: I hardly believe that Mongo is the right choice for all Express applications.
    Relational databases are incredibly important and can be used well with Express,
    and other NoSQL databases like CouchDB are also powerful. But Mongo fits well
    with the Express ecosystem and is relatively easy to learn (compared to SQL),
    which is why I choose it for this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我几乎不相信Mongo是所有Express应用程序的正确选择。关系型数据库非常重要，并且可以很好地与Express一起使用，其他NoSQL数据库如CouchDB也非常强大。但Mongo与Express生态系统很好地配合，并且相对容易学习（与SQL相比），这就是为什么我选择它来写这一章。
- en: NOTE If you're like me, you know SQL and want to use it for use SQL for some
    Express projects. This chapter will discuss Mongo, but if you're looking for a
    helpful SQL tool, check out Sequelize at http://sequelizejs.com/. It interfaces
    with many SQL databases and has a number of helpful features.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你像我一样，你知道SQL并想为一些Express项目使用它。本章将讨论Mongo，但如果你在寻找一个有用的SQL工具，请查看Sequelize，网址为http://sequelizejs.com/。它与许多SQL数据库接口，并具有许多有用的功能。
- en: In this chapter, we'll deal heavily with a module called Mongoose; for your
    reference as you read, Mongoose is to MongoDB as Sequelize is to SQL. Keep that
    in mind if you want to use SQL!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将大量使用一个名为Mongoose的模块；在你阅读时作为参考，Mongoose对于MongoDB就像Sequelize对于SQL一样。如果你想使用SQL，请记住这一点！
- en: 8.1.1  How Mongo works
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 Mongo的工作原理
- en: Before we start, let's talk about how Mongo works.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们谈谈Mongo是如何工作的。
- en: Most applications have one database, like MongoDB. These databases are hosted
    by servers. A Mongo server can have many databases on it, but there is generally
    one database per application. If you're only developing one application on your
    computer, you'll likely only have one Mongo database. (These databases can be
    replicated across multiple servers, but you treat them as if it's one database.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都有一个数据库，比如MongoDB。这些数据库由服务器托管。一个Mongo服务器可以拥有许多数据库，但通常每个应用程序只有一个数据库。如果你只在你的电脑上开发一个应用程序，你很可能只有一个Mongo数据库。（这些数据库可以在多个服务器之间复制，但你可以将其视为一个数据库。）
- en: To access these databases, you'll run a MongoDB server. Clients will talk to
    these servers, viewing and manipulating the database. There are client libraries
    for most programming languages; these libraries are called drivers and let you
    talk to the database in your favorite programming language. In this book, we'll
    be using the Node.js driver for MongoDB.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问这些数据库，你将运行一个MongoDB服务器。客户端将与这些服务器通信，查看和操作数据库。大多数编程语言都有客户端库；这些库被称为驱动程序，并允许你使用你喜欢的编程语言与数据库通信。在这本书中，我们将使用MongoDB的Node.js驱动程序。
- en: Every database will have one or more collections. I like to think of collections
    as fancy arrays. A blog application might have a collection for blog posts, or
    a social network might have a collection for user profiles. They're like arrays
    in that they're just giant lists, but you can also query them ("give me all users
    in this collection older than age 18", for example) much more easily than arrays.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据库都将有一个或多个集合。我喜欢将集合想象成高级数组。一个博客应用程序可能有一个用于博客文章的集合，或者一个社交网络可能有一个用于用户资料的集合。它们就像数组一样，只是巨大的列表，但你也可以比数组更容易地查询它们（例如，“给我这个集合中所有年龄大于18岁的用户”等）。
- en: Every collection will have any number of documents. Documents aren't technically
    stored as JSON, but you can think of them that way; they're basically objects
    with various properties. Documents are things like users and blog posts; there
    is one document per thing. Documents don't have to have the same properties, even
    if they're in the same collection—you could theoretically have a collection filled
    with completely different objects (although you seldom do this in practice).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合都将包含任意数量的文档。文档实际上并不是以JSON的形式存储的，但你可以这样想；它们基本上是具有各种属性的物体。文档是像用户和博客文章这样的东西；每件事物都有一个文档。文档不必具有相同的属性，即使它们在同一个集合中——理论上你可以有一个完全不同的对象的集合（尽管在实践中很少这样做）。
- en: Documents look a lot like JSON, but they're technically something called Binary
    JSON, or BSON. You almost never deal with BSON directly; rather, you'll translate
    to and from JavaScript objects. The specifics of BSON encoding and decoding are
    a little different from JSON. BSON also supports a few types that JSON does not,
    like dates, timestamps, and undefined values.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 文档看起来很像JSON，但技术上它们是被称为二进制JSON，或BSON的东西。你几乎从不直接处理BSON；相反，你将将其转换为JavaScript对象。BSON编码和解码的具体细节与JSON略有不同。BSON还支持JSON不支持的一些类型，如日期、时间戳和未定义的值。
- en: 'Here''s a diagram that shows how things are put together:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个显示事物如何组合的图：
- en: '![](../Images/08_01.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_01.png)'
- en: Figure 8.1 Hierarchy of Mongo's databases, collections, and documents
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 Mongo数据库、集合和文档的层次结构
- en: 'One last important point: Mongo adds a unique `_id` property to every document.
    Because these IDs are unique, two documents are the same if they have the same `_id` property,
    and you can''t store two documents with the same ID in the same collection. This
    is a miscellaneous point but an important one that we''ll come back to!'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个重要的一点：Mongo为每个文档添加一个唯一的`_id`属性。因为这些ID是唯一的，如果两个文档具有相同的`_id`属性，则它们是相同的，并且你无法在同一个集合中存储具有相同ID的两个文档。这是一个杂项但重要的点，我们稍后会再次提到！
- en: 8.1.2  For you SQL users out there…
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 对于那些SQL用户来说...
- en: If you come from a relational/SQL background, many of Mongo's structures map
    one-to-one with structures from the SQL world. (If you're not familiar with SQL,
    you can skip this section!)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自关系型/SQL背景，Mongo的许多结构都与SQL世界的结构一一对应。（如果你不熟悉SQL，可以跳过这一部分！）
- en: Documents in Mongo correspond with rows or records in SQL. In an application
    with users, each user would correspond to one document in Mongo or one row in
    SQL. In contrast to SQL, Mongo doesn't enforce any schema at the database layer,
    so it's not invalid in Mongo to have a user without a last name or an email address
    that's a number.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mongo中，文档对应于SQL中的行或记录。在一个用户应用程序中，每个用户在Mongo中对应一个文档或SQL中的一个行。与SQL不同，Mongo在数据库层不强制执行任何模式，因此在Mongo中有一个没有姓氏或电子邮件地址是数字的用户是有效的。
- en: Collections in Mongo correspond to SQL's tables. Mongo's collections contain
    many documents, where SQL's tables contain many rows. Once again, Mongo's collections
    don't enforce a schema, which is unlike SQL. In addition, these documents can
    embed other documents, unlike in SQL—blog posts could contain the comments, which
    would likely be two tables in SQL. In a blog application, there would be one Mongo
    collection for blog posts or one SQL table. Each Mongo collection contains many
    documents, where each SQL table contains many rows or records.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mongo中，集合对应于SQL中的表。Mongo的集合包含许多文档，而SQL的表包含许多行。再次强调，Mongo的集合不强制执行模式，这与SQL不同。此外，这些文档可以嵌入其他文档，这与SQL不同——博客文章可以包含评论，这在SQL中可能对应两个表。在一个博客应用程序中，会有一个Mongo集合用于博客文章或一个SQL表。每个Mongo集合包含许多文档，而每个SQL表包含许多行或记录。
- en: Databases in Mongo are very similar to databases in SQL. Generally, there is
    one database per application. Mongo databases can contain many collections, where
    SQL databases can contain many tables. A social networking site would likely have
    just one of these databases in SQL, Mongo, or another type of database.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mongo中，数据库与SQL中的数据库非常相似。通常，每个应用程序有一个数据库。Mongo数据库可以包含许多集合，而SQL数据库可以包含许多表。一个社交网络网站可能只有一个这些数据库，无论是SQL、Mongo还是其他类型的数据库。
- en: For a full list of "translations" from SQL terminology to MongoDB terminology
    (queries, too!), check out the official SQL to MongoDB Mapping Chart at [http://docs.mongodb.org/manual/reference/sql-comparison/index.html](http://docs.mongodb.org/manual/reference/sql-comparison/index.html).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看从SQL术语到MongoDB术语（包括查询）的完整“翻译”列表，请查看官方的SQL到MongoDB映射图表[http://docs.mongodb.org/manual/reference/sql-comparison/index.html](http://docs.mongodb.org/manual/reference/sql-comparison/index.html)。
- en: 8.1.3  Setting up Mongo
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 设置Mongo
- en: You'll want to install Mongo locally so that you can use it while you're developing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你会想要在本地安装Mongo，这样你就可以在开发时使用它。
- en: If you're on OSX and aren't sure you want to use the command line, I'm a big
    fan of Mongo.app. Instead of wrangling the command line, you simply launch an
    application that runs in the menu bar at the top right of your screen. You can
    tell when it's running and when it's not, easily start up a console, and shut
    it down effortlessly. You can download it at [http://mongoapp.com/](http://mongoapp.com/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用OSX并且不确定是否想使用命令行，我非常推崇Mongo.app。你不需要处理命令行，只需启动一个运行在屏幕右上角菜单栏中的应用程序。你可以轻松地判断它是否正在运行，启动控制台，并轻松关闭它。你可以在[http://mongoapp.com/](http://mongoapp.com/)下载它。
- en: If you're on OSX and would prefer to use the command line, you can use the Homebrew
    package manager to install MongoDB with a simple `brew install mongodb`. If you're
    using MacPorts, `sudo port install mongodb` will do the job. If you're not using
    a package manager and you don't want to use Mongo.app, you can download it from
    the MongoDB downloads page at [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用OSX并希望使用命令行，可以使用Homebrew包管理器通过简单的`brew install mongodb`命令安装MongoDB。如果你使用MacPorts，`sudo
    port install mongodb`将完成工作。如果你不使用包管理器并且不想使用Mongo.app，你可以从MongoDB下载页面[http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)下载它。
- en: If you're on Ubuntu Linux, Mongo's website has helpful instructions at [http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/](http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/).
    If you're using a Debian distribution like Mint (or Debian!), check out the official
    documentation at[http://docs.mongodb.org/manual/tutorial/install-mongodb-on-debian/](http://docs.mongodb.org/manual/tutorial/install-mongodb-on-debian/).
    Other Linux users can check out [http://docs.mongodb.org/manual/tutorial/install-mongodb-on-linux/](http://docs.mongodb.org/manual/tutorial/install-mongodb-on-linux/).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Ubuntu Linux，Mongo的网站上有有用的说明[http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/](http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/)。如果您使用的是类似Mint（或Debian）的Debian发行版，请查看官方文档[http://docs.mongodb.org/manual/tutorial/install-mongodb-on-debian/](http://docs.mongodb.org/manual/tutorial/install-mongodb-on-debian/)。其他Linux用户可以查看[http://docs.mongodb.org/manual/tutorial/install-mongodb-on-linux/](http://docs.mongodb.org/manual/tutorial/install-mongodb-on-linux/)。
- en: If you're a Windows user or on any of the OSes I didn't mention above, the MongoDB
    downloads page will help you. You can either download it from their website or
    scroll down to the bottom of that page to see other package managers that have
    Mongo. Take a look at [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads).
    If you can, make sure you download the 64-bit version; the 32-bit version has
    a limit on storage space.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Windows用户或上述未提及的任何操作系统用户，MongoDB下载页面将帮助您。您可以从他们的网站下载，或者滚动到该页面的底部查看其他拥有Mongo的包管理器。查看[http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)。如果可能，请确保下载64位版本；32位版本的存储空间有限。
- en: Throughout this book, we'll assume that your MongoDB database is at `localhost:27017/test`.
    Port 27017 is the default port and the default database is one called "test",
    but your results may vary. If you can't connect to your database, check your specific
    installation for help.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将假设您的MongoDB数据库位于`localhost:27017/test`。端口27017是默认端口，默认数据库是名为"test"的数据库，但您的结果可能会有所不同。如果您无法连接到数据库，请检查您的特定安装以获取帮助。
- en: 8.2     Talking to MongoDB from Node with Mongoose
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2     使用Mongoose从Node与MongoDB通信
- en: We'll need a library that will let us talk to MongoDB from Node, and therefore
    from Express. There are a number of lower-level modules, but we'd like something
    easy-to-use and feature-filled. What should we use?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个库，让我们能够从Node和Express与MongoDB通信。有许多底层模块，但我们希望使用起来简单且功能丰富。我们应该使用什么？
- en: 'Look no further than Mongoose (at http://mongoosejs.com/), an officially-supported
    library for talking to MongoDB from Node.js. To quote its documentation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不必再寻找其他资源，Mongoose（在http://mongoosejs.com/）是一个官方支持的从Node.js与MongoDB通信的库。正如其文档所述：
- en: Mongoose provides a straight-forward, schema-based solution to modeling your
    application data and includes built-in type casting, validation, query building,
    business logic hooks and more, out of the box.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose提供了一个基于模式的简单解决方案来建模您的应用程序数据，并包括内置的类型转换、验证、查询构建、业务逻辑钩子等，无需额外配置。
- en: In other words, Mongoose gives us much more than simply talking to the database.
    Let's learn how it works by creating a simple website with user accounts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Mongoose为我们提供了与数据库通信之外的功能。让我们通过创建一个简单的带有用户账户的网站来了解它是如何工作的。
- en: 8.2.1  Setting up your project
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1  设置您的项目
- en: In order to learn the topics in this chapter, we'll develop a very simple social
    network application. This app will let users register new profiles, edit those
    profiles, and browse each others' profiles. We'll call it "Learn About Me", for
    lack of a creative name. We'll call it "LAM" for short.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习本章的主题，我们将开发一个非常简单的社交网络应用程序。这个应用程序将允许用户注册新资料，编辑这些资料，并浏览彼此的资料。由于缺乏创意名称，我们将其称为"Learn
    About Me"。为了方便起见，我们将简称为"LAM"。
- en: 'Our site will have a few pages on it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们网站将包含几个页面：
- en: ·  The homepage, which will list all users. Clicking on a user in the list will
    take you to their profile page.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ·  主页将列出所有用户。点击列表中的用户将带您进入他们的个人资料页面。
- en: ·  The profile page will show the user's display name (or username if no display
    name is defined), the date they joined the site, and their biography.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ·  个人资料页面将显示用户的显示名称（如果没有定义显示名称，则为用户名），他们加入网站的日期以及他们的个人简介。
- en: ·  The user will be able to sign up for a new account, log into accounts, and
    log out.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ·  用户将能够注册新账户，登录账户，并注销。
- en: ·  After signing up, users will be able to edit their display names and biographies,
    but only when they're logged in.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ·  注册后，用户将能够编辑他们的显示名称和个人简介，但仅当他们登录时。
- en: 'As always, create a new directory for this project. As always, we''ll need
    to create a package file with metadata about our project and its dependencies.
    Create a `package.json` file and put this inside:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，为这个项目创建一个新的目录。像往常一样，我们需要创建一个包含有关我们的项目和其依赖项的元数据的包文件。创建一个`package.json`文件，并将其放入其中：
- en: Listing 8.1 package.json for LAM
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 LAM的package.json
- en: '`{` `  "name": "learn-about-me",` `  "private": true,` `  "scripts": {` `   
    "start": "node app"` `  },` `  "dependencies": {` `    "bcrypt-nodejs": "0.0.3", 
    #B` `    "body-parser": "^1.6.5",` `    "connect-flash": "^0.1.1",` `    "cookie-parser":
    "^1.3.2",` `    "ejs": "^1.0.0",` `    "express": "^4.8.5",` `    "express-session":
    "^1.7.6",` `    "mongoose": "^3.8.15",` `    "passport": "^0.2.0",` `    "passport-local":
    "^1.0.0"` `  }``}`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "name": "learn-about-me",` `  "private": true,` `  "scripts": {` `   
    "start": "node app"` `  },` `  "dependencies": {` `    "bcrypt-nodejs": "0.0.3", 
    #B` `    "body-parser": "^1.6.5",` `    "connect-flash": "^0.1.1",` `    "cookie-parser":
    "^1.3.2",` `    "ejs": "^1.0.0",` `    "express": "^4.8.5",` `    "express-session":
    "^1.7.6",` `    "mongoose": "^3.8.15",` `    "passport": "^0.2.0",` `    "passport-local":
    "^1.0.0"` `  }``}`'
- en: '#B There''s a different module called "bcrypt" which builds a bunch of C code.
    It is probably faster but it can be a little harder to install. If you need speed,
    it''s a drop-in replacement.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 有一个名为“bcrypt”的不同模块，它生成大量的C代码。它可能更快，但安装可能稍微困难一些。如果您需要速度，它是一个即插即用的替代品。'
- en: After you've created this file, run `npm install` to install our slew of dependencies.
    We'll see what each of these dependencies do as we chug through the rest of the
    chapter, so if any of them are unclear, don't worry! As usual, we've set this
    up so that `npm start` will start our app (which we'll save into `app.js`).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此文件后，运行`npm install`以安装我们的依赖项。随着我们继续本章的其余部分，我们将看到每个依赖项的作用，所以如果其中任何一个不清楚，请不要担心！像往常一样，我们已经设置好，`npm
    start`将启动我们的应用程序（我们将将其保存到`app.js`中）。
- en: Now it's time to start putting things into databases!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始将东西放入数据库了！
- en: 8.2.2  Creating a user model
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 创建用户模型
- en: 'As we''ve discussed, MongoDB stores everything in BSON, which is a binary format.
    A simple "hello world" BSON document might look like this internally:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，MongoDB将所有内容存储在BSON中，这是一种二进制格式。一个简单的“hello world”BSON文档可能看起来像这样：
- en: '`\x16\x00\x00\x00\x02hello\x00\x06\x00\x00\x00world\x00\x00`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`\x16\x00\x00\x00\x02hello\x00\x06\x00\x00\x00world\x00\x00`'
- en: A computer can deal with all that mumbo-jumbo, but that's hard to read for humans
    like us. We want something that's more amenable to us, which is why developers
    have created the concept of a database model. A model is a representation of a
    database record as a nice object in your programming language of choice. In this
    case, our models will be JavaScript objects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机可以处理所有这些乱七八糟的东西，但对于我们这样的人来说很难阅读。我们想要一些更适合我们的东西，这就是为什么开发者创建了数据库模型的概念。模型是数据库记录在您选择的编程语言中的良好对象的表示。在这种情况下，我们的模型将是JavaScript对象。
- en: Models can serve as a simple object that stores database values, but they often
    have things like data validation, extra methods, and more. As we'll see, Mongoose
    has a lot of those features.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 模型可以作为存储数据库值的简单对象，但它们通常具有数据验证、额外方法和更多功能。正如我们将看到的，Mongoose有很多这样的功能。
- en: 'In this example, we''ll be building a model for users. Before we start, we
    should consider the properties User objects should have:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将构建一个用户模型。在我们开始之前，我们应该考虑User对象应该具有哪些属性：
- en: ·  Username, a unique name. This will be required.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ·  用户名，一个唯一的名称。这将需要。
- en: ·  Password. This will also be required.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ·  密码。这也会被要求。
- en: ·  Time joined, a record of when the user joined the site.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ·  加入时间，记录用户加入网站的时间。
- en: ·  Display name, name that's displayed instead of the username. This will be
    optional.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ·  显示名称，代替用户名显示的名称。这将可选。
- en: ·  Biography, an optional bunch of text that's displayed on the user's profile
    page.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ·  个人简介，用户个人资料页面上显示的一组可选文本。
- en: To specify this in Mongoose, we must define a schema, which contains information
    about properties, methods, and more. (Personally, I don't think "Schema" is the
    right word; it's a lot more like a class or a prototype.) It's pretty easy to
    translate the English above into Mongoose code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Mongoose中指定这一点，我们必须定义一个模式，它包含有关属性、方法和更多信息。 (我个人认为“模式”这个词不正确；它更像是一个类或原型。) 将上面的英文翻译成Mongoose代码相当简单。
- en: 'Create a folder called `models` in the root of your project, and create a new
    file called `user.js` inside that folder. To start, put the following contents:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在您项目的根目录下创建一个名为`models`的文件夹，并在该文件夹内创建一个名为`user.js`的新文件。首先，将以下内容放入其中：
- en: Listing 8.2 Defining the user schema (in models/user.js)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2 定义用户模式（在models/user.js中）
- en: '`var mongoose = require("mongoose");` `var userSchema = mongoose.Schema({`
    `  username: { type: String, required: true, unique: true },` `  password: { type:
    String, required: true },` `  createdAt: { type: Date, default: Date.now },` ` 
    displayName: String,` `  bio: String``});`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`var mongoose = require("mongoose");` `var userSchema = mongoose.Schema({`
    `  username: { type: String, required: true, unique: true },` `  password: { type:
    String, required: true },` `  createdAt: { type: Date, default: Date.now },` ` 
    displayName: String,` `  bio: String``});`'
- en: After we require Mongoose, it's pretty straightforward to define our fields.
    As you can see, we define the username as `username`, the password as `password`,
    the time joined as `createdAt`, the display name as `displayName`, and the biography
    as `bio`. Notice that some fields are required, some are unique, some have default
    values, and others are simply a declaration of their types.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们引入Mongoose之后，定义字段就相当直接了。正如你所看到的，我们将用户名定义为`username`，密码定义为`password`，加入时间为`createdAt`，显示名为`displayName`，个人简介为`bio`。注意，一些字段是必需的，一些是唯一的，一些有默认值，而其他只是声明了它们的类型。
- en: 'Once we''ve created the schema with the properties, we can add some methods
    to it. The first we''ll add is simple: get the user''s name. If the user has defined
    a display name, return that; otherwise, return their username. Here''s how we''ll
    add that:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了具有属性的架构，我们就可以向其添加一些方法。我们将添加的第一个方法是简单的：获取用户的名字。如果用户定义了显示名，则返回该显示名；否则，返回他们的用户名。以下是添加该方法的步骤：
- en: Listing 8.3 Adding a simple method to the user model (in models/user.js)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3 向用户模型添加简单方法（在models/user.js中）
- en: '`…`   `userSchema.methods.name = function() {` `  return this.displayName ||
    this.username;``};`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`…` `userSchema.methods.name = function() {` `  return this.displayName ||
    this.username;``};`'
- en: We'll also want to make sure we store the password securely. We could store
    the password in plain text in our database, but that has a number of security
    issues. What if someone hacked our database? They'd get all the passwords! We
    also want to be responsible administrators and not be able to see our users passwords
    in the clear. In order to ensure that we never store the "real" password, we'll
    apply a one-way hash to it using the Bcrypt algorithm.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要确保我们安全地存储密码。我们可以在数据库中以纯文本形式存储密码，但这存在许多安全问题。如果有人黑入我们的数据库怎么办？他们会得到所有的密码！我们还想成为负责任的管理员，不能看到用户密码的明文。为了确保我们永远不会存储“真实”的密码，我们将使用Bcrypt算法对其进行单向哈希。
- en: 'First, to start using Bcrypt, add the `require` statement to the top of your
    file. Bcrypt works by running a part of the algorithm many times to give you a
    secure hash, but that number of times is configurable. The higher the number,
    the more secure the hash but the longer it will take. We''ll use a value of 10
    for now, but we could increase that number for higher security (but, once again,
    slower speed):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要开始使用Bcrypt，请将`require`语句添加到文件顶部。Bcrypt通过多次运行算法的一部分来生成一个安全的哈希值，但这个次数是可以配置的。数字越高，哈希值越安全，但所需时间也越长。我们现在使用10这个值，但我们可以增加这个数字以获得更高的安全性（但，再次强调，速度会变慢）：
- en: Listing 8.4 Requiring Bcrypt (in models/user.js)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 引入Bcrypt（在models/user.js中）
- en: '`var bcrypt = require("bcrypt-nodejs");` `var SALT_FACTOR = 10;`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`var bcrypt = require("bcrypt-nodejs");` `var SALT_FACTOR = 10;`'
- en: 'Next, after you''ve defined your schema, we''ll define a pre-save action. Before
    we save our model to the database, we''ll run some code that will hash the password.
    Here''s how that looks:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在你定义了架构之后，我们将定义一个预保存操作。在我们将模型保存到数据库之前，我们将运行一些代码来哈希密码。以下是它的样子：
- en: Listing 8.5 Our pre-save action to hash the password (in models/user.js)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 我们预保存操作以哈希密码（在models/user.js中）
- en: '`…`   `var noop = function() {};                                 #1`   `userSchema.pre("save",
    function(done) {                   #2` `  var user = this;                                       
    #3` `  if (!user.isModified("password")) {                     #4` `    return
    done();                                        #4` `  }                                                      
    #4` `  bcrypt.genSalt(SALT_FACTOR, function(err, salt) {       #5` `    if (err)
    { return done(err); }` `    bcrypt.hash(user.password, salt, noop,` `    [CA]function(err,
    hashedPassword) {                   #6` `      if (err) { return done(err); }`
    `      user.password = hashedPassword;                     #7` `      done();                                            
    #7` `    });` `  });``});`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`…` `var noop = function() {};` `#1` `userSchema.pre("save", function(done)
    {` `  var user = this;` `  if (!user.isModified("password")) {` `    return done();`
    `  }` `  bcrypt.genSalt(SALT_FACTOR, function(err, salt) {` `    if (err) { return
    done(err); }` `    bcrypt.hash(user.password, salt, noop,` `    [CA]function(err,
    hashedPassword) {` `      if (err) { return done(err); }` `      user.password
    = hashedPassword;` `      done();` `    });` `  });` `});`'
- en: '#1 We''ll need this do-nothing function for use with the bcrypt module.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们需要一个什么也不做的函数来与bcrypt模块一起使用。'
- en: '#2 We''ll define a function that will be run before our model is saved.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们将定义一个在模型保存之前运行的函数。'
- en: '#3 Because we''ll be using inner functions, we''ll save a reference to the
    user.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 因为我们将使用内部函数，所以我们将保存对用户的引用。'
- en: '#4 Skip this logic if the user hasn''t modified their password.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 如果用户没有修改他们的密码，则跳过此逻辑。'
- en: '#5 We''ll generate a salt for our hash, and call the inner function once completed.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 我们将为散列生成一个盐，并在完成后调用内部函数。'
- en: '#6 Next, we''ll hash the user''s password with that generated salt.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 接下来，我们将使用生成的盐散列用户的密码。'
- en: '#7 Store the password and continue on with the saving!'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 存储密码并继续保存操作！'
- en: Now, we never have to call any fancy logic to hash the password for the database—it'll
    happen every time we save the model into Mongo.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们再也不需要调用任何复杂的逻辑来对数据库中的密码进行散列——每次我们将模型保存到Mongo时，它都会自动发生。
- en: 'Finally, we''ll need to write some code to compare the real password to a password
    guess. When a user logs in, we''ll need to make sure the password they typed is
    correct. Let''s define another method on the model to do this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要编写一些代码来比较实际密码和密码猜测。当用户登录时，我们需要确保他们输入的密码是正确的。让我们在模型上定义另一个方法来完成这个任务：
- en: Listing 8.6 Checking the user's password (in models/user.js)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.6 检查用户的密码（在models/user.js中）
- en: '`…`   `userSchema.methods.checkPassword = function(guess, done) {` `  bcrypt.compare(guess,
    this.password, function(err, isMatch) {   #1` `    done(err, isMatch);` `  });``};`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`…` `userSchema.methods.checkPassword = function(guess, done) {` `  bcrypt.compare(guess,
    this.password, function(err, isMatch) {` `    done(err, isMatch);` `  });` `};`'
- en: '#1 For complicated security reasons (called "timing attacks" if you''re interested),
    we''ll use Bcrypt''s compare function rather than something like a === check.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 由于复杂的保密原因（如果你感兴趣，可以称为“时间攻击”），我们将使用Bcrypt的比较函数而不是像a ===检查这样的东西。'
- en: Now we'll be storing our users' passwords securely!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将安全地存储用户的密码！
- en: 'Once we''ve defined our schema with its properties and methods, we''ll need
    to attach that schema to an actual model. It only takes one line to do this, and
    because we''re defining this user model in a file, we''ll make sure to export
    it into`module.exports` so other files can `require` it. Here''s how we do that:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了具有其属性和方法的模式，我们还需要将此模式附加到实际模型上。这只需要一行代码，因为我们是在文件中定义此用户模型，所以我们会确保将其导出到`module.exports`，以便其他文件可以`require`它。以下是我们的操作方法：
- en: Listing 8.7 Creating and exporting the user model (in models/user.js)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7 创建并导出用户模型（在models/user.js中）
- en: '`…`   `var User = mongoose.model("User", userSchema);``module.exports = User;`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`…` `var User = mongoose.model("User", userSchema);` `module.exports = User;`'
- en: 'That''s how you define a user model! Here''s what the full file will look like
    when you''re done:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是定义用户模型的方法！完成时，整个文件将看起来像这样：
- en: Listing 8.8 Finished models/user.js
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.8 完成的models/user.js
- en: '`var bcrypt = require("bcrypt-nodejs");` `var mongoose = require("mongoose");`
      `var SALT_FACTOR = 10;`   `var userSchema = mongoose.Schema({` `  username:
    { type: String, required: true, unique: true },` `  password: { type: String,
    required: true },` `  createdAt: { type: Date, default: Date.now },` `  displayName:
    String,` `  bio: String,` `});`   `var noop = function() {};`   `userSchema.pre("save",
    function(done) {`   `  var user = this;`   `  if (!user.isModified("password"))
    {` `    return done();` `  }`   `  bcrypt.genSalt(SALT_FACTOR, function(err, salt)
    {` `    if (err) { return done(err); }` `    bcrypt.hash(user.password, salt,
    noop, function(err, hashedPassword) {` `      if (err) { return done(err); }`
    `      user.password = hashedPassword;` `      done();` `    });` `  });`   `});`
      `userSchema.methods.checkPassword = function(guess, done) {` `  bcrypt.compare(guess,
    this.password, function(err, isMatch) {` `    done(err, isMatch);` `  });` `};`
      `userSchema.methods.name = function() {` `  return this.displayName || this.username;`
    `};`   `var User = mongoose.model("User", userSchema);`  `module.exports = User;`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`var bcrypt = require("bcrypt-nodejs");` `var mongoose = require("mongoose");`
    `var SALT_FACTOR = 10;` `var userSchema = mongoose.Schema({` `  username: { type:
    String, required: true, unique: true },` `  password: { type: String, required:
    true },` `  createdAt: { type: Date, default: Date.now },` `  displayName: String,`
    `  bio: String,` `});` `var noop = function() {};` `userSchema.pre("save", function(done)
    {` `  var user = this;` `  if (!user.isModified("password")) {` `    return done();`
    `  }` `  bcrypt.genSalt(SALT_FACTOR, function(err, salt) {` `    if (err) { return
    done(err); }` `    bcrypt.hash(user.password, salt, noop, function(err, hashedPassword)
    {` `      if (err) { return done(err); }` `      user.password = hashedPassword;`
    `      done();` `    });` `  });` `});` `userSchema.methods.checkPassword = function(guess,
    done) {` `  bcrypt.compare(guess, this.password, function(err, isMatch) {` `   
    done(err, isMatch);` `  });` `};` `userSchema.methods.name = function() {` ` 
    return this.displayName || this.username;` `};` `var User = mongoose.model("User",
    userSchema);` `module.exports = User;`'
- en: 8.2.3  Using our model
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 使用我们的模型
- en: Now that we've defined our model, we'll want to...well, use it! We'll want to
    do things like list users, edit profiles, and register new accounts. While defining
    the model and its schema can be a little hairy, using it could hardly be easier;
    let's see how.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的模型，我们想要...嗯，使用它！我们想要做一些像列出用户、编辑资料和注册新账户的事情。虽然定义模型及其模式可能有点棘手，但使用它几乎不可能更简单；让我们看看如何。
- en: 'In order to start using it, let''s first create a simple `app.js` in the root
    of our project which will set up our app. This is incomplete and we''ll come back
    and fill in some more later, but for now, here''s what we''ll do:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用它，我们首先在项目的根目录中创建一个简单的 `app.js` 文件，这将设置我们的应用程序。这个文件目前是不完整的，我们稍后会回来补充更多内容，但现在，我们将做以下事情：
- en: Listing 8.9 app.js, to start
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 app.js，开始
- en: '`var express = require("express");                     #1` `var mongoose =
    require("mongoose");                   #1` `var path = require("path");                      
        #1` `var bodyParser = require("body-parser");              #1` `var cookieParser
    = require("cookie-parser");          #1` `var session = require("express-session");            
    #1` `var flash = require("connect-flash");                 #1`   `var routes =
    require("./routes");                     #2`   `var app = express();`   `mongoose.connect("mongodb://localhost:27017/test");  
    #3`   `app.set("port", process.env.PORT || 3000);`   `app.set("views", path.join(__dirname,
    "views"));` `app.set("view engine", "ejs");`   `app.use(bodyParser.urlencoded({
    extended: false }));   #4` `app.use(cookieParser());                              
    #4` `app.use(session({                                      #4` `  secret: "TKRv0IJs=HYqrvagQ#&!F!%V]Ww/4KiVs$s,<<MX", 
    #4` `  resave: true,                                        #4` `  saveUninitialized:
    true                              #4` `}));                                                  
    #4` `app.use(flash());                                      #4`   `app.use(routes);`
      `app.listen(app.get("port"), function() {` `  console.log("Server started on
    port " + app.get("port"));``});`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");                     #1` `var mongoose =
    require("mongoose");                   #1` `var path = require("path");                      
    #1` `var bodyParser = require("body-parser");              #1` `var cookieParser
    = require("cookie-parser");          #1` `var session = require("express-session");            
    #1` `var flash = require("connect-flash");                 #1` `var routes = require("./routes");                    
    #2` `var app = express();` `mongoose.connect("mongodb://localhost:27017/test");  
    #3` `app.set("port", process.env.PORT || 3000);` `app.set("views", path.join(__dirname,
    "views"));` `app.set("view engine", "ejs");` `app.use(bodyParser.urlencoded({
    extended: false }));   #4` `app.use(cookieParser());                              
    #4` `app.use(session({                                      #4` `  secret: "TKRv0IJs=HYqrvagQ#&!F!%V]Ww/4KiVs$s,<<MX", 
    #4` `  resave: true,                                        #4` `  saveUninitialized:
    true                              #4` `}));                                                  
    #4` `app.use(flash());                                  #4` `app.use(routes);`
    `app.listen(app.get("port"), function() {` `  console.log("Server started on port
    " + app.get("port"));``});`'
- en: '#1 Require everything we need, including Mongoose.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 需要所有我们需要的东西，包括 Mongoose。'
- en: '#2 We''ll put all of our routes in another file.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们将把所有的路由放在另一个文件中。'
- en: '#3 Connect to our MongoDB server in the test database.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 连接到测试数据库中的我们的 MongoDB 服务器。'
- en: '#4 Use four middlewares. We''ll explain these in much more detail in a moment.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 使用四个中间件。我们将在稍后详细解释这些。'
- en: 'Above, we''ve specified that we''re going to be using an external routes file.
    Let''s define that too. Create `routes.js` in the root of your project:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们指定我们将使用一个外部路由文件。让我们也定义一下。在项目的根目录中创建 `routes.js`：
- en: Listing 8.10 routes.js, to start
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 routes.js，开始
- en: '`var express = require("express");`   `var User = require("./models/user");`
      `var router = express.Router();`   `router.use(function(req, res, next) {` ` 
    res.locals.currentUser = req.user;       #1` `  res.locals.errors = req.flash("error"); 
    #1` `  res.locals.infos = req.flash("info");    #1` `  next();` `});`   `router.get("/",
    function(req, res, next) {` `  User.find()                                 #2`
    `  .sort({ createdAt: "descending" })          #2` `  .exec(function(err, users)
    {                #2` `    if (err) { return next(err); }` `    res.render("index",
    { users: users });` `  });` `});`  `module.exports = router;`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var User = require("./models/user");`
    `var router = express.Router();` `router.use(function(req, res, next) {` `  res.locals.currentUser
    = req.user;       #1` `  res.locals.errors = req.flash("error");  #1` `  res.locals.infos
    = req.flash("info");    #1` `  next();` `});` `router.get("/", function(req, res,
    next) {` `  User.find()                                 #2` `  .sort({ createdAt:
    "descending" })          #2` `  .exec(function(err, users) {                #2`
    `    if (err) { return next(err); }` `    res.render("index", { users: users });`
    `  });` `});` `module.exports = router;`'
- en: '#1 We''ll come back to this, but this sets a few useful variables for our templates.
    If you don''t understand it yet, don''t worry—it''ll return.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们会回过头来讨论这个问题，但这是为我们的模板设置一些有用的变量。如果你现在还不理解，不要担心——它很快就会回来。'
- en: '#2 This queries the users collection, returning the newest users first.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这个查询返回用户集合，首先返回最新的用户。'
- en: These two files have a few new things we haven't seen before.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件包含了一些我们之前没有见过的内容。
- en: First, we're connecting to our Mongo database with Mongoose, using `mongoose.connect`.
    We simply pass an address and Mongoose does the rest. Depending on how you've
    installed MongoDB, this URL might be different—for example, the server could be
    at `localhost:12345/learn_about_me_db`. Without this line, we won't be able to
    interact with the database at all!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 Mongoose 通过 `mongoose.connect` 连接到我们的 Mongo 数据库。我们只需传递一个地址，Mongoose
    就会完成剩下的工作。根据你如何安装 MongoDB，这个 URL 可能不同——例如，服务器可能在 `localhost:12345/learn_about_me_db`。没有这一行，我们将无法与数据库进行任何交互！
- en: Second, we're grabbing a list of users with `User.find`. Then we sort these
    results by the `createdAt` property, and then we run the query with `exec`. We
    don't actually run the query until `exec` is called. As we'll see, we can also
    specify a callback in `find` to skip having to use `exec`, but then we can't do
    things like sorting.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们使用 `User.find` 获取用户列表。然后我们按 `createdAt` 属性对这些结果进行排序，然后通过 `exec` 运行查询。实际上，我们只有在调用
    `exec` 时才会运行查询。正如我们将看到的，我们也可以在 `find` 中指定一个回调，以避免使用 `exec`，但那样我们就不能进行排序等操作。
- en: 'Let''s create the homepage view. Create the `views` directory, where we''ll
    put three files inside. The first will be `_header.ejs`, which is the HTML that
    will appear at the beginning of every page:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建主页视图。创建一个名为 `views` 的目录，我们将在这里放置三个文件。第一个将是 `_header.ejs`，这是将出现在每个页面开头的
    HTML：
- en: Listing 8.11 views/_header.ejs
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 views/_header.ejs
- en: '`<!DOCTYPE html>` `<html>`   `<head>`   `<meta charset="utf-8">` `<title>Learn
    About Me</title>` `<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap`
    `[CA]/3.3.1/css/bootstrap.min.css">`   `</head>`   `<body>`   `<div class="navbar
    navbar-default navbar-static-top" role="navigation">`   `  <div class="container">`
      `    <div class="navbar-header">` `      <a class="navbar-brand" href="/">Learn
    About Me</a>` `    </div>`   `    <ul class="nav navbar-nav navbar-right">   
    #1` `      <% if (currentUser) { %>                  #1` `        <li>                                   
    #1` `          <a href="/edit">                      #1` `            Hello, <%=
    currentUser.name() %>    #1` `          </a>                                 
    #1` `        </li>                                   #1` `        <li><a href="/logout">Log
    out</a></li>  #1` `      <% } else { %>                            #1` `       
    <li><a href="/login">Log in</a></li>    #1` `        <li><a href="/signup">Sign
    up</a></li>  #1` `      <% } %>                                   #1` `    </ul>                                      
    #1`   `  </div>`   `</div>`   `<div class="container">`   `  <% errors.forEach(function(error)
    { %>` `    <div class="alert alert-danger" role="alert">` `      <%= error %>`
    `    </div>` `  <% }) %>`   `  <% infos.forEach(function(info) { %>` `    <div
    class="alert alert-info" role="alert">` `      <%= info %>` `    </div>``  <%
    }) %>`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`<!DOCTYPE html>` `<html>` `<head>` `<meta charset="utf-8">` `<title>了解我</title>`
    `<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap` `[CA]/3.3.1/css/bootstrap.min.css">`
    `<head>` `<body>` `<div class="navbar navbar-default navbar-static-top" role="navigation">`
    `<div class="container">` `<div class="navbar-header">` `<a class="navbar-brand"
    href="/">了解我</a>` `<div>` `<ul class="nav navbar-nav navbar-right">` `<% if (currentUser)
    { %>` `<li>` `<a href="/edit">` `<%= currentUser.name() %>` `<a>` `<li>` `<a href="/logout">登出</a></li>`
    `<% } else { %>` `<li>` `<a href="/login">登录</a></li>` `<li>` `<a href="/signup">注册</a></li>`
    `<% } %>` `<ul>` `<div>` `<div class="container">` `<% errors.forEach(function(error)
    { %>` `<div class="alert alert-danger" role="alert">` `<%= error %>` `<div>` `<%
    }) %>` `<% infos.forEach(function(info) { %>` `<div class="alert alert-info" role="alert">`
    `<%= info %>` `<div>` `<% }) %>` `<div>`'
- en: '#1 We''ll change the navbar if the user is logged in. We don''t have this code
    yet, so the user will always appear to be logged out.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 如果用户已登录，我们将更改导航栏。我们还没有这个代码，所以用户看起来总是未登录。'
- en: 'You may notice that this file starts with an underscore. It''s not `header.ejs`,
    it''s `_header.ejs`. This is a common convention: views that aren''t rendered
    directly start with underscores. You''d never render the header directly—another
    view would include the header.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到这个文件以下划线开头。它不是 `header.ejs`，而是 `_header.ejs`。这是一个常见的约定：不直接渲染的视图以下划线开头。你永远不会直接渲染头部——另一个视图将包含头部。
- en: 'Next, let''s create the footer in `_footer.ejs`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `_footer.ejs` 中创建页脚：
- en: Listing 8.12 views/_footer.ejs
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.12 views/_footer.ejs
- en: '`</div>` `</body>``</html>`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`</div>` `</body>` `</html>`'
- en: Finally, create `index.ejs` which is the actual homepage. This will pull from
    the `users` variable that we're passed when we render this view.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建 `index.ejs`，这是实际的首页。这将从我们渲染此视图时传递给我们的 `users` 变量中获取。
- en: Listing 8.13 views/index.ejs
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.13 views/index.ejs
- en: '`<% include _header %>`   `<h1>Welcome to Learn About Me!</h1>`   `<% users.forEach(function(user)
    { %>`   `  <div class="panel panel-default">` `    <div class="panel-heading">`
    `      <a href="/users/<%= user.username %>">` `        <%= user.name() %>` `     
    </a>` `    </div>` `    <% if (user.bio) { %>` `      <div class="panel-body"><%=
    user.bio %></div>` `    <% } %>` `  </div>`   `<% }) %>`  `<% include _footer
    %>`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`<% include _header %>` `<h1>欢迎来到了解我！</h1>` `<% users.forEach(function(user)
    { %>` `<div class="panel panel-default">` `<div class="panel-heading">` `<a href="/users/<%=
    user.username %>">` `<%= user.name() %>` `<a>` `<div>` `<% if (user.bio) { %>`
    `<div class="panel-body"><%= user.bio %></div>` `<% } %>` `<div>` `<% }) %>` `<%
    include _footer %>`'
- en: 'If you save everything, start up your MongoDB server, and `npm start`, and
    visit `localhost:3000` in your browser, you won''t see much, but you''ll see a
    homepage that looks something like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存了所有内容，启动你的 MongoDB 服务器，并运行 `npm start`，然后在浏览器中访问 `localhost:3000`，你不会看到太多，但你将看到一个看起来像这样的首页：
- en: '![](../Images/08_02.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_02.png)'
- en: Figure 8.2 The empty LAM homepage
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 空的 LAM 首页
- en: If you're not getting any errors, that's great! That means you're querying your
    Mongo database and getting all of the users in there...there just happen to be
    0 users at the moment!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有收到任何错误，那真是太好了！这意味着你正在查询你的 Mongo 数据库，并且获取了其中的所有用户...只是目前恰好没有用户！
- en: 'Let''s add two more routes to our page: one for the signup page and one to
    do the actual signing up. In order to use that, we''ll need to make sure we use
    the `body-parser` middleware to parse form data. Here''s what those will look
    like:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在页面上添加两个额外的路由：一个用于注册页面，另一个用于实际注册。为了使用它，我们需要确保我们使用`body-parser`中间件来解析表单数据。下面是它们的样式：
- en: Listing 8.14 Adding body-parser middleware (to app.js)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.14 向app.js添加body-parser中间件
- en: '`var bodyParser = require("body-parser");               #1`   `…`   `app.use(bodyParser.urlencoded({
    extended: false }));   #1`  `…`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`var bodyParser = require("body-parser");               #1`  `…`  `app.use(bodyParser.urlencoded({
    extended: false }));   #1`  `…`'
- en: '#1 Require and use the body-parser middleware in our app.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 在我们的应用程序中需要并使用body-parser中间件。'
- en: Listing 8.15 Adding signup routes (in routes.js)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.15 向routes.js添加注册路由
- en: '`…`   `router.get("/signup", function(req, res) {` `  res.render("signup");`
    `});`   `router.post("/signup", function(req, res, next) {`   `  var username
    = req.body.username;                            #1` `  var password = req.body.password;                           
    #1`   `  User.findOne({ username: username }, function(err, user) {   #2`   `   
    if (err) { return next(err); }` `    if (user) {                                               
    #3` `      req.flash("error", "User already exists");               #3` `     
    return res.redirect("/signup");                          #3` `    }                                                         
    #3`   `    var newUser = new User({                                   #4` `     
    username: username,                                      #4` `      password:
    password                                       #4` `    });                                                       
    #4` `    newUser.save(next);                                        #5`   `  });`
    `}, passport.authenticate("login", {            #6` `  successRedirect: "/",`
    `  failureRedirect: "/signup",` `  failureFlash: true``})););`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`…`  `router.get("/signup", function(req, res) {`  `  res.render("signup");`
     `});`  `router.post("/signup", function(req, res, next) {`  `  var username =
    req.body.username;                            #1`  `  var password = req.body.password;                           
    #1`  `  User.findOne({ username: username }, function(err, user) {   #2`  `   
    if (err) { return next(err); }`  `    if (user) {                                               
    #3`  `      req.flash("error", "用户已存在");               #3`  `      return res.redirect("/signup");                       
    #3`  `    }                                                  #3`  `    var newUser
    = new User({                                   #4`  `      username: username,                                     
    #4`  `      password: password               #4`  `    });                                               
    #4`  `    newUser.save(next);                                        #5`  `  });`
     `}, passport.authenticate("login", {            #6`  `  successRedirect: "/",`
     `  failureRedirect: "/signup",`  `  failureFlash: true` `});`);`'
- en: '#1 body-parser populates req.body, which we see here contains the username
    and password for signup. Setting extended to false makes the parsing simpler and
    more secure, for reasons we''ll see in Chapter 10.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 `body-parser`填充`req.body`，我们在这里可以看到它包含注册的用户名和密码。将`extended`设置为`false`使解析更简单、更安全，原因我们将在第10章中看到。'
- en: '#2 We call findOne to just return one user. We want a match on usernames here.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们调用`findOne`来只返回一个用户。我们在这里希望匹配用户名。'
- en: '#3 If we find a user, we should bail out because that username already exists.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 如果我们找到一个用户，我们应该退出，因为该用户名已经存在。'
- en: '#4 Create a new instance of the User model with the username and password.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 创建一个新的用户模型实例，包含用户名和密码。'
- en: '#5 Save the new user to the database and continue onto the next request handler
    (below).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 将新用户保存到数据库中，并继续到下一个请求处理器（下面）。'
- en: '#6 When we''re all done, we should authenticate the user.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 当我们全部完成时，我们应该验证用户。'
- en: 'The code above effectively saves new users to our database! Let''s add a user
    interface to this by creating `views/signup.ejs`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码有效地将新用户保存到我们的数据库中！让我们通过创建`views/signup.ejs`来添加一个用户界面：
- en: Listing 8.16 views/signup.ejs
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.16 views/signup.ejs
- en: '`<% include _header %>`   `<h1>Sign up</h1>`   `<form action="/signup" method="post">`
    `  <input name="username" type="text" class="form-control" placeholder="Username"
    required autofocus>` `  <input name="password" type="password" class="form-control"
    placeholder="Password" required>` `  <input type="submit" value="Sign up" class="btn
    btn-primary btn-block">` `</form>`  `<% include _footer %>`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`<% include _header %>`  `<h1>注册</h1>`  `<form action="/signup" method="post">`
     `  <input name="username" type="text" class="form-control" placeholder="用户名"
    required autofocus>`  `  <input name="password" type="password" class="form-control"
    placeholder="密码" required>`  `  <input type="submit" value="注册" class="btn btn-primary
    btn-block">`  `</form>`  `<% include _footer %>`'
- en: Now, when you submit this form, it'll talk to the server code and sign up a
    new user! Start up the server with `npm start` and go to the sign up page (at `localhost:3000/signup`).
    Create a few accounts and you'll see them appear on the homepage!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你提交这个表单时，它会与服务器代码通信并注册一个新用户！使用`npm start`启动服务器，然后转到注册页面（在`localhost:3000/signup`）。创建几个账户，你会在主页上看到它们！
- en: '![](../Images/08_03.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_03.png)'
- en: Figure 8.3 An early LAM homepage, after creating a few users
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 创建几个用户后的早期LAM主页
- en: '![](../Images/08_04.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_04.png)'
- en: Figure 8.4 The LAM signup page
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 LAM注册页面
- en: 'The last bit of business before we have to code logging in and logging out
    is the viewing of profiles. We''ll add just one more route for that, and that''ll
    look like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们不得不编写登录和登出代码之前，最后一项业务是查看个人资料。我们将为这个功能添加一个额外的路由，它看起来像这样：
- en: Listing 8.17 The profiles route (in routes.js)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.17 个人资料路由（在routes.js中）
- en: '`…`   `router.get("/users/:username", function(req, res, next) {` `  User.findOne({
    username: req.params.username }, function(err, user) {` `    if (err) { return
    next(err); }` `    if (!user) { return next(404); }` `    res.render("profile",
    { user: user });` `  });` `});``…`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`…`   `router.get("/users/:username", function(req, res, next) {`   `  User.findOne({
    username: req.params.username }, function(err, user) {`   `    if (err) { return
    next(err); }`   `    if (!user) { return next(404); }`   `    res.render("profile",
    { user: user });`   `  });`   `});``…`'
- en: 'Once again, we''ll be using `findOne`, but in this case we''ll actually pass
    the user we find into the view. Speaking of, `profile.ejs` will look something
    like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将使用`findOne`，但在这个情况下，我们将实际将找到的用户传递到视图中。说到这里，`profile.ejs`将看起来像这样：
- en: Listing 8.18 views/profile.ejs
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.18 视图/profile.ejs
- en: '`<% include _header %>`   `<% if ((currentUser) && (currentUser.id === user.id))
    { %>` `  <a href="/edit" class="pull-right">Edit your profile</a>` `<% } %>`  
    `<h1><%= user.name() %></h1>` `<h2>Joined on <%= user.createdAt %></h2>`   `<%
    if (user.bio) { %>` `  <p><%= user.bio %></p>` `<% } %>`  `<% include _footer
    %>`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`<% include _header %>`   `<% if ((currentUser) && (currentUser.id === user.id))
    { %>`   `  <a href="/edit" class="pull-right">编辑你的个人资料</a>`   `<% } %>`   `<h1><%=
    user.name() %></h1>`   `<h2>加入时间 <%= user.createdAt %></h2>`   `<% if (user.bio)
    { %>`   `  <p><%= user.bio %></p>`   `<% } %>`   `  `<% include _footer %>`'
- en: '#1 This references currentUser, a variable that will appear once we add login
    and logout. For now, this will always evaluate to false.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这引用了currentUser变量，一旦我们添加了登录和登出功能，这个变量就会出现。目前，这始终评估为false。'
- en: 'Now we can view user profiles! Check it out in Figure 8.5:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查看用户个人资料了！如图8.5所示查看：
- en: '![](../Images/08_05.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_05.png)'
- en: Figure 8.5 The LAM profile page
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 LAM个人资料页面
- en: Now we can create and view user profiles. Next, we'll need to add login and
    logout so that users can edit their existing profiles. Let's see how that works!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建和查看用户个人资料了。接下来，我们需要添加登录和登出功能，以便用户可以编辑他们现有的个人资料。让我们看看这是如何工作的！
- en: 8.3     Authenticating users with Passport
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3     使用Passport认证用户
- en: In this chapter, we've been creating "Learn About Me", a website that lets users
    create and browse profiles. We've implemented the homepage, the "view profile"
    page, and even signup!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直在创建“了解我”，一个允许用户创建和浏览个人资料的网站。我们已经实现了主页、“查看个人资料”页面，甚至还有注册功能！
- en: But right now, our app knows nothing "special" about our User model. They have
    no authentication, so they might as well be Cake models or Burrito models -- you
    can view and create them just like you could another object. We'll want to implement
    user authentication. We'll need a login page, the notion of a currently logged-in
    user (which you've seen as currentUser in a few places), and the actual verification
    of passwords.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 但目前，我们的应用程序对用户模型没有任何“特殊”的了解。它们没有认证，所以它们可以像蛋糕模型或玉米卷模型一样——你可以像查看和创建其他对象一样查看和创建它们。我们将需要实现用户认证。我们需要一个登录页面，当前登录用户的概念（你已经在几个地方看到了currentUser），以及实际验证密码。
- en: 'For this, we''ll choose Passport. To quote its documentation, "Passport is
    authentication middleware for Node. It is designed to serve a singular purpose:
    authenticate requests." We''ll be dropping this middleware into our application,
    writing a little code to wire up our users, and we''ll be in business! Passport
    takes away a lot of the headache for us.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个，我们将选择Passport。正如其文档所述，“Passport是Node的认证中间件。它旨在服务于单一目的：认证请求。”我们将把这个中间件放入我们的应用程序中，编写一些代码来连接我们的用户，然后我们就可以开始工作了！Passport为我们省去了很多麻烦。
- en: It's important to remember that Passport doesn't dictate how you authenticate
    your users; it's only there to provide helpful boilerplate code. It's like Express
    in that way. In this chapter, we'll look at how to use Passport to authenticate
    users stored in a MongoDB database, but Passport supports authentication with
    providers like Facebook, Google, Twitter, and over 100 more. It's extremely modular
    and powerful!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，Passport 并不规定你如何验证用户；它只是提供有用的样板代码。在这方面，它与 Express 类似。在本章中，我们将探讨如何使用
    Passport 验证存储在 MongoDB 数据库中的用户，但 Passport 支持与 Facebook、Google、Twitter 以及 100 多个其他提供者的身份验证。它极其模块化和强大！
- en: 8.3.1  Setting up Passport
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1  设置 Passport
- en: 'When setting up Passport, you''ll need to do three things:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置 Passport 时，你需要做三件事：
- en: 1.  Set up the Passport middleware; this is pretty easy.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  设置 Passport 中间件；这相当简单。
- en: 2.  Tell Passport how to serialize and deserialize users. This is a short amount
    of code that effectively translates a user's session into an actual user object.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  告诉 Passport 如何序列化和反序列化用户。这是一小段代码，它有效地将用户的会话转换为实际的用户对象。
- en: 3.  Tell Passport how to authenticate users. In this case, this is the bulk
    of our code, which will instruct Passport how to talk to our Mongo database.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  告诉 Passport 如何验证用户。在这种情况下，这是我们代码的主体部分，它将指导 Passport 如何与我们的 MongoDB 数据库通信。
- en: Let's get started.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: SETTING UP THE PASSPORT MIDDLEWARE
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 PASSPORT 中间件
- en: 'In order to initialize Passport, you''ll need to set up three official Express
    middlewares, a third-party middleware, and then two Passport middlewares. For
    your reference, they are:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化 Passport，你需要设置三个官方 Express 中间件、一个第三方中间件以及两个 Passport 中间件。供你参考，它们是：
- en: '`1.` `body-parser`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`1.` `body-parser`'
- en: '`2.` `cookie-parser`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`2.` `cookie-parser`'
- en: '`3.` `express-session`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`3.` `express-session`'
- en: '`4.` `connect-flash`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`4.` `connect-flash`'
- en: '`5.` `passport.initialize`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`5.` `passport.initialize`'
- en: '`6.` `passport.session`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`6.` `护照会话`'
- en: We've already included some of these middlewares: `body-parser`, `cookie-parser`, `express-session`,
    and `connect-flash`. The first one is for parsing HTML forms. `cookie-parser` and `express-session` handle
    user sessions; the former is for parsing cookies from browsers and the latter
    is for storing sessions across different browsers. We also use `connect-flash` for
    showing error messages.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了一些这些中间件：`body-parser`、`cookie-parser`、`express-session` 和 `connect-flash`。第一个用于解析
    HTML 表单。`cookie-parser` 和 `express-session` 处理用户会话；前者用于解析来自浏览器的 cookies，后者用于在不同浏览器之间存储会话。我们还使用
    `connect-flash` 来显示错误信息。
- en: 'After that, make sure you `require` Passport and then you''ll use two middleware
    functions it provides. Put these at the top of your application (and make sure
    you `require` them, too):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，确保你 `require` Passport，然后你将使用它提供的两个中间件函数。将这些放在你的应用程序顶部（并确保你也 `require` 它们）：
- en: Listing 8.19 Setting up the middleware for Passport (in app.js)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.19 在 app.js 中设置 Passport 的中间件
- en: '`var bodyParser = require("body-parser");` `var cookieParser = require("cookie-parser");`
    `var flash = require("connect-flash");` `var passport = require("passport");`
    `var session = require("express-session");`   `…`   `app.use(bodyParser.urlencoded({
    extended: false }));` `app.use(cookieParser());` `app.use(session({` `  secret:
    "TKRv0IJs=HYqrvagQ#&!F!%V]Ww/4KiVs$s,<<MX",   #1` `  resave: true,                                        
    #2` `  saveUninitialized: true                               #3` `}));` `app.use(flash());`
      `app.use(passport.initialize());` `app.use(passport.session());`  `…`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`var bodyParser = require("body-parser");` `var cookieParser = require("cookie-parser");`
    `var flash = require("connect-flash");` `var passport = require("passport");`
    `var session = require("express-session");` `…` `app.use(bodyParser.urlencoded({
    extended: false }));` `app.use(cookieParser());` `app.use(session({` `  secret:
    "TKRv0IJs=HYqrvagQ#&!F!%V]Ww/4KiVs$s,<<MX",   #1` `  resave: true,                                          
    #2` `  saveUninitialized: true                               #3` `}));` `app.use(flash());`
    `app.use(passport.initialize());` `app.use(passport.session());` `…`'
- en: '#1 The session needs something called a "session secret", which allows each
    session to be encrypted from the clients. This deters hackers from hacking into
    users'' cookies. It needs to be a bunch of random characters (not necessarily
    what I have above!).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 会话需要一个名为 "session secret" 的东西，它允许每个会话从客户端加密。这阻止黑客攻击用户的 cookies。它需要是一堆随机字符（不一定是上面我有的那些！）。'
- en: '#2 The session middleware requires this option to be set, which forces the
    session to be updated even when it hasn''t been modified.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 会话中间件需要设置此选项，这会强制会话在未修改的情况下更新。'
- en: '#3 saveUninitialized is another required option. This also resets sessions
    but resets ones that are uninitialized.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 saveUninitialized 是另一个必需的选项。这也重置会话，但重置的是未初始化的会话。'
- en: 'Once you''ve set that up, you''ll be ready to move on to the next step: telling
    Passport how to extract users from the session.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好之后，你就可以继续下一步：告诉 Passport 如何从会话中提取用户。
- en: SERIALIZING AND DESERIALIZING USERS
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化和反序列化用户
- en: 'Passport needs to know how to serialize and deserialize users. In other words,
    we''ll need to translate a user''s session into an actual user object, and vice-versa.
    Passport''s documentation does a better job describing it than I could:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 需要知道如何序列化和反序列化用户。换句话说，我们需要将用户的会话转换为实际的用户对象，反之亦然。Passport 的文档比我能描述的做得更好：
- en: In a typical web application, the credentials used to authenticate a user will
    only be transmitted during the login request. If authentication succeeds, a session
    will be established and maintained via a cookie set in the user's browser.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的网络应用程序中，用于验证用户的凭证仅在登录请求期间传输。如果身份验证成功，将通过用户浏览器中设置的 cookie 建立并维护一个会话。
- en: Each subsequent request will not contain credentials, but rather the unique
    cookie that identifies the session. In order to support login sessions, Passport
    will serialize and deserialize `user` instances to and from the session.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 每个后续请求将不包含凭证，而是包含标识会话的唯一 cookie。为了支持登录会话，Passport 将将 `user` 实例序列化和反序列化到会话中。
- en: 'To keep our code separated, we''ll be defining a new file called `setuppassport.js`.
    This file will export a single function that will, not surprisingly, set up this
    Passport stuff. Create `setuppassport.js` and require it from `app.js`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的代码分离，我们将定义一个新的文件，名为 `setuppassport.js`。这个文件将导出一个函数，该函数将设置这个 Passport 东西。创建
    `setuppassport.js` 并从 `app.js` 中 `require` 它：
- en: Listing 8.20 Requiring and using Passport setup (in app.js)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.20 在 app.js 中引入和使用 Passport 设置
- en: '`…`   `var setUpPassport = require("./setuppassport");`   `…`   `var app =
    express();` `mongoose.connect("mongodb://localhost:27017/test");` `setUpPassport();`
     `…`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`…` `var setUpPassport = require("./setuppassport");` `…` `var app = express();`
    `mongoose.connect("mongodb://localhost:27017/test");` `setUpPassport();` `…`'
- en: Now, let's fill in our Passport setup.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们填写我们的 Passport 设置。
- en: Because all of our user models have a unique `_id` property, we'll use that
    as our "translation". First, make sure you `require` your User model. Next, instruct
    Passport how to serialize and deserialize users from their ID. This code can be
    placed before or after the Passport middleware; place it where you'd like!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们所有的用户模型都有一个唯一的 `_id` 属性，我们将使用它作为我们的“转换”。首先，确保你已经 `require` 了你的用户模型。接下来，指导
    Passport 如何从其 ID 中序列化和反序列化用户。这段代码可以放在 Passport 中间件之前或之后；放在你想要的位置！
- en: Listing 8.21 Serializing and deserializing users (in setuppassport.js)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.21 序列化和反序列化用户（在 setuppassport.js 中）
- en: '`var passport = require("passport");`   `var User = require("./models/user");`
      `module.exports = function() {`   `  passport.serializeUser(function(user, done)
    {  #1` `    done(null, user._id);                        #1` `  });`   `  passport.deserializeUser(function(id,
    done) {  #2` `    User.findById(id, function(err, user) {      #2` `      done(err,
    user);                           #2` `    });``  });`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`var passport = require("passport");` `var User = require("./models/user");`
    `module.exports = function() {` `  passport.serializeUser(function(user, done)
    {  #1` `    done(null, user._id);                        #1` `  });` `  passport.deserializeUser(function(id,
    done) {  #2` `    User.findById(id, function(err, user) {      #2` `      done(err,
    user);                           #2` `    });` `  });`'
- en: '#1 serializeUser should turn a user object into an ID. We call done with no
    error and the user''s ID.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 `serializeUser` 应将用户对象转换为 ID。我们调用 `done` 并不带错误和用户 ID。'
- en: '#2 deserializeUser should turn the ID into a user object. Once we''re done,
    we call done with any errors and the user object.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 `deserializeUser` 应将 ID 转换为用户对象。一旦完成，我们调用 `done` 并带任何错误和用户对象。'
- en: 'Now, once the session is dealt with, it''s time to do the hard part: the actual
    authentication.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦处理了会话，就到了做困难的部分：实际的身份验证。
- en: THE REAL AUTHENTICATION
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的身份验证
- en: The final part of Passport is setting up something called a strategy. Some strategies
    include authentication with sites like Facebook or Google; the strategy we'll
    use is called a local strategy. In short, that means the authentication is up
    to us, which means we'll have to write a little bit of Mongoose code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 的最后一部分是设置一个称为策略的东西。一些策略包括与 Facebook 或 Google 等网站进行身份验证；我们将使用的策略称为本地策略。简而言之，这意味着身份验证由我们来完成，这意味着我们不得不编写一些
    Mongoose 代码。
- en: 'First, require the Passport local strategy into a variable called `LocalStrategy`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 Passport 本地策略引入到一个名为 `LocalStrategy` 的变量中：
- en: Listing 8.22 Requiring the Passport LocalStrategy (in setuppassport.js)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.22 在 setuppassport.js 中引入 Passport LocalStrategy
- en: '`…` `var LocalStrategy = require("passport-local").Strategy;``…`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`…` `var LocalStrategy = require("passport-local").Strategy;``…`'
- en: 'Next, you''ll need to tell Passport how to use that local strategy. Our authentication
    code will run through the following steps:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要告诉Passport如何使用该本地策略。我们的认证代码将通过以下步骤运行：
- en: 1.  Look for a user with the supplied username.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  查找具有提供的用户名的用户。
- en: 2.  If no user exists, then our user isn't authenticated; say that we're done
    with the message "No user has that username!"
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  如果没有用户存在，则我们的用户未认证；可以说我们已完成，信息为“没有用户有那个用户名！”
- en: 3.  If the user does exist, compare their real password with the password we
    supply. If the password matches, return the current user. If it doesn't, return
    "Invalid password."
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  如果用户存在，比较他们的真实密码与我们提供的密码。如果密码匹配，则返回当前用户。如果不匹配，则返回“无效密码。”
- en: 'Now, let''s take that English and translate it into Passport code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这段英文翻译成Passport代码：
- en: Listing 8.23 Our Passport local strategy (in setuppassport.js)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.23 我们的Passport本地策略（在setuppassport.js中）
- en: '`…`   `passport.use("login", new LocalStrategy(                             
    #1` `[CA]function(username, password, done) {                              #1`
    `  User.findOne({ username: username }, function(err, user) {          #2` `   
    if (err) { return done(err); }` `    if (!user) {                                                     
    #3` `      return done(null, false,                                        #3`
    `      [CA]{ message: "No user has that username!" });                 #3` `   
    }                                                                 #3` `    user.checkPassword(password,
    function(err, isMatch) {` `      if (err) { return done(err); }` `      if (isMatch)
    {` `        return done(null, user);                            #4` `      } else
    {` `        return done(null, false,` `        [CA]{ message: "Invalid password."
    });              #5` `      }` `    });` `  });` `}));``…`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`…`   `passport.use("login", new LocalStrategy(                             
    #1` `[CA]function(username, password, done) {                              #1`
    `  User.findOne({ username: username }, function(err, user) {          #2` `   
    if (err) { return done(err); }` `    if (!user) {                                                     
    #3` `      return done(null, false,                                        #3`
    `      [CA]{ message: "No user has that username!" });                 #3` `   
    }                                                                 #3` `    user.checkPassword(password,
    function(err, isMatch) {` `      if (err) { return done(err); }` `      if (isMatch)
    {` `        return done(null, user);                            #4` `      } else
    {` `        return done(null, false,` `        [CA]{ message: "Invalid password."
    });              #5` `      }` `    });` `  });` `}));``…`'
- en: '#1 This is how we tell Passport to use a local strategy.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这是告诉Passport使用本地策略的方式。'
- en: '#2 Use a MongoDB query we''ve seen before to get one user.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用我们之前见过的MongoDB查询来获取一个用户。'
- en: '#3 If there is no user with the supplied username, return false with an error
    message. Call the checkPassword method we defined earlier in our User model.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 如果没有用户具有提供的用户名，则返回带有错误信息的false。调用我们在User模型中之前定义的checkPassword方法。'
- en: '#4 If it is a match, return the current user with no error.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 如果匹配，则不带错误返回当前用户。'
- en: '#5 If it''s not a match, return false with an error message.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 如果不匹配，则返回带有错误信息的false。'
- en: As you can see, you instantiate a `LocalStrategy`. Once you do that, you call
    the done callback whenever you're done! You'll return the user object if it's
    found, and `false` otherwise.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您实例化了一个`LocalStrategy`。一旦这样做，您就可以在完成时调用done回调！如果找到了用户对象，您将返回该对象，否则返回`false`。
- en: THE ROUTES AND THE VIEWS
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 路由和视图
- en: 'Finally, let''s set up the rest of the views. We''ll still need:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们设置其余的视图。我们仍然需要：
- en: ·  Logging in
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ·  登录
- en: ·  Logging out
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ·  登出
- en: ·  Profile editing (when you're logged in)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ·  个人资料编辑（当你登录时）
- en: 'Let''s start with logging in. The GET route will be really straight-forward,
    and just render the view:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从登录开始。GET路由将非常直接，只需渲染视图：
- en: Listing 8.24 GET /login (in routes.js)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.24 GET /login（在routes.js中）
- en: '`…`   `router.get("/login", function(req, res) {` `  res.render("login");`
    `});``…`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`…`   `router.get("/login", function(req, res) {` `  res.render("login");`
    `});``…`'
- en: 'And this is what the view, at `login.ejs`, will look like. It''ll just be a
    simple form accepting a username and password, and then sending a POST request
    to `/login`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是视图，在`login.ejs`中看起来会是什么样子。它将只是一个简单的表单，接受用户名和密码，然后向`/login`发送POST请求：
- en: Listing 8.25 views/login.ejs
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.25 视图/login.ejs
- en: '`<% include _header %>`   `<h1>Log in</h1>`   `<form action="/login" method="post">`
    `  <input name="username" type="text" class="form-control"` `  [CA]placeholder="Username"
    required autofocus>` `  <input name="password" type="password" class="form-control"`
    `  [CA]placeholder="Password" required>` `  <input type="submit" value="Log in"
    class="btn btn-primary btn-block">` `</form>`  `<% include _footer %>`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`<% include _header %>`   `<h1>登录</h1>`   `<form action="/login" method="post">`   ` 
    <input name="username" type="text" class="form-control"`   `  [CA]placeholder="用户名"
    required autofocus>`   `  <input name="password" type="password" class="form-control"`   ` 
    [CA]placeholder="密码" required>`   `  <input type="submit" value="登录" class="btn
    btn-primary btn-block">`   `</form>`   `  <% include _footer %>`'
- en: 'Next, we''ll define the handler for a POST to `/login`. This will deal with
    Passport''s authentication. Make sure to `require` it at the top of your file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义对 `/login` 的 POST 请求的处理程序。这将处理 Passport 的认证。确保在文件顶部 `require` 它：
- en: Listing 8.26 Do the login (in routes.js)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.26 执行登录（在 routes.js 中）
- en: '`var passport = require("passport");`   `…`   `router.post("/login", passport.authenticate("login",
    {` `  successRedirect: "/",` `  failureRedirect: "/login",` `  failureFlash: true   
           #1` `}));``…`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`var passport = require("passport");`   `…`   `router.post("/login", passport.authenticate("login",
    {`   `  successRedirect: "/",`   `  failureRedirect: "/login",`   `  failureFlash:
    true           #1`   `}));``…`'
- en: '#1 This sets an error message with connect-flash if the user fails to log in.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 如果用户登录失败，则使用 connect-flash 设置错误消息。'
- en: '`passport.authenticate` returns a request handler function which we pass instead
    one we write ourselves. This lets us redirect to the right spot, depending on
    whether the user successfully logged in or not.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`passport.authenticate` 返回一个请求处理器函数，我们将其传递而不是自己编写。这让我们可以根据用户是否成功登录来重定向到正确的位置。'
- en: 'Logging out is also trivial with Passport. All you have to do is call `req.logout`,
    a new function added by Passport:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Passport，登出也非常简单。你只需要调用 Passport 添加的新函数 `req.logout`：
- en: Listing 8.27 Logging out (in routes.js)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.27 登出（在 routes.js 中）
- en: '`…`   `router.get("/logout", function(req, res) {` `  req.logout();` `  res.redirect("/");`
    `});``…`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`…`   `router.get("/logout", function(req, res) {`   `  req.logout();`   ` 
    res.redirect("/");`   `});``…`'
- en: 'Passport will populate `req.user` and `connect-flash` will populate some flash
    values. We added this code awhile ago, but take a look at it now; because you''ll
    likely understand it better:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 将填充 `req.user`，而 `connect-flash` 将填充一些闪存值。我们之前添加了这段代码，但现在来看看它；因为你可能会更好地理解它：
- en: Listing 8.28 Passing data to views (in routes.js)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.28 将数据传递到视图中（在 routes.js 中）
- en: '`…`   `router.use(function(req, res, next) {` `  res.locals.currentUser = req.user;        
    #1` `  res.locals.errors = req.flash("error");` `  res.locals.infos = req.flash("info");`
    `  next();` `});`  `…`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`…`   `router.use(function(req, res, next) {`   `  res.locals.currentUser =
    req.user;         #1`   `  res.locals.errors = req.flash("error");`   `  res.locals.infos
    = req.flash("info");`   `  next();`   `});`   `…`'
- en: '#1 Every view will now have access to currentUser, which pulls from req.user,
    which is populated by Passport.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 每个视图现在都可以访问到 currentUser，它从 req.user 中获取，由 Passport 填充。'
- en: Now all we have is the edit page, and look at this! We can log in and log out.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只有编辑页面，看看这个！我们可以登录和登出。
- en: Next, let's make some utility middleware that ensures users are authenticated.
    We won't actually use this middleware yet; we'll just define it so that other
    routes down the line can use it. We'll call it `ensureAuthenticated`, and we'll
    redirect to the login page if the user isn't authenticated.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一些确保用户已认证的实用中间件。我们实际上不会使用这个中间件；我们只是定义它，以便后续的路由可以使用它。我们将它命名为 `ensureAuthenticated`，如果用户未认证，我们将重定向到登录页面。
- en: Listing 8.29 Middleware for determining if the user is authenticated (in routes.js)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.29 用于确定用户是否认证的中间件（在 routes.js 中）
- en: '`…`   `function ensureAuthenticated(req, res, next) {` `  if (req.isAuthenticated())
    {                                    #1` `    next();` `  } else {` `    req.flash("info",
    "You must be logged in to see this page.");` `    res.redirect("/login");` ` 
    }` `}``…`'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`…`   `function ensureAuthenticated(req, res, next) {`   `  if (req.isAuthenticated())
    {                                    #1`   `    next();`   `  } else {`   `   
    req.flash("info", "您必须登录才能查看此页面.");`   `    res.redirect("/login");`   `  }`   `}`   `…`'
- en: '#1 req.isAuthenticated is a function provided by Passport.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 req.isAuthenticated 是 Passport 提供的函数。'
- en: Now, let's use this middleware to create the "Edit profile" page.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个中间件来创建“编辑个人资料”页面。
- en: 'When we GET the edit page, we''ll just render the view, but we want to make
    sure the user is authenticated before we do that. All we have to do is pass `ensureAuthenticated` to
    our route, and then it''s business as usual. Here''s how we''d do that:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们获取编辑页面时，我们只需渲染视图，但在做之前，我们想确保用户已经认证。我们只需将`ensureAuthenticated`传递给我们的路由，然后一切照旧。以下是这样做的方法：
- en: Listing 8.30 GET /edit (in router.js)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.30 GET /edit (在router.js中)
- en: '`…`   `router.get("/edit", ensureAuthenticated, function(req, res) {    #1`
    `  res.render("edit");` `});``…`'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`…` `router.get("/edit", ensureAuthenticated, function(req, res) {    #1` ` 
    res.render("edit");` `});` `…`'
- en: '#1 First, we ensure that the user is authenticated, then we run our request
    handler if they haven''t been redirected.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 首先，我们确保用户已经认证，然后如果他们没有被重定向，我们运行我们的请求处理程序。'
- en: As you can see, everything is as we've seen before, except we place our middleware
    right before our request handler.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一切如我们所见，只是我们在请求处理程序之前放置了我们的中间件。
- en: 'Let''s define the edit view now. This will be in `edit.ejs`, and be a simple
    form that allows users to change their display name and biography:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义编辑视图。这将位于`edit.ejs`中，是一个简单的表单，允许用户更改他们的显示名称和传记：
- en: Listing 8.31 views/edit.ejs
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.31 视图/edit.ejs
- en: '`<% include _header %>`   `<h1>Edit your profile</h1>`   `<form action="/edit"
    method="post">` `  <input name="displayname" type="text" class="form-control"`
    `  [CA]placeholder="Display name"` `  [CA]value="<%= currentUser.displayName ||
    "" %>">` `  <textarea name="bio" class="form-control"` `  [CA]placeholder="Tell
    us about yourself!">` `  [CA]<%= currentUser.bio || "" %></textarea>` `  <input
    type="submit" value="Update" class="btn` `  [CA]btn-primary btn-block">` `</form>`
     `<% include _footer %>`'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`<% include _header %>` `<h1>编辑您的个人资料</h1>` `<form action="/edit" method="post">`
    `  <input name="displayname" type="text" class="form-control"` `  [CA]placeholder="显示名称"`
    `  [CA]value="<%= currentUser.displayName || "" %>">` `  <textarea name="bio"
    class="form-control"` `  [CA]placeholder="告诉我们关于您自己的事情！">` `  [CA]<%= currentUser.bio
    || "" %></textarea>` `  <input type="submit" value="更新" class="btn"` `  [CA]btn-primary
    btn-block">` `</form>` `<% include _footer %>`'
- en: Now, let's handle that form with a POST handler. This will also ensure authentication
    with `ensureAuthenticated`, and will otherwise update our model and save it to
    our MongoDB database.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用POST处理程序来处理那个表单。这也会确保使用`ensureAuthenticated`进行认证，否则将更新我们的模型并将其保存到我们的MongoDB数据库中。
- en: Listing 8.32 POST /edit (in routes.js)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.32 POST /edit (在routes.js中)
- en: '`…`   `router.post("/edit", ensureAuthenticated, function(req, res, next) { 
    #A` `  req.user.displayName = req.body.displayname;` `  req.user.bio = req.body.bio;`
    `  req.user.save(function(err) {` `    if (err) {` `      next(err);` `      return;`
    `    }` `    req.flash("info", "Profile updated!");` `    res.redirect("/edit");`
    `  });` `});`  `…`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`…` `router.post("/edit", ensureAuthenticated, function(req, res, next) { 
    #A` `  req.user.displayName = req.body.displayname;` `  req.user.bio = req.body.bio;`
    `  req.user.save(function(err) {` `    if (err) {` `      next(err);` `      return;`
    `    }` `    req.flash("info", "个人资料已更新！");` `    res.redirect("/edit");` `  });`
    `});` `…`'
- en: '#A Normally, this would be a PUT request, but browsers only support GET and
    POST in HTML forms.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 通常，这应该是一个PUT请求，但浏览器只支持HTML表单中的GET和POST。'
- en: There's nothing fancy here; all we do is update the user in our MongoDB database.
    Remember that Passport populates `req.user` for us.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的地方；我们只是更新了MongoDB数据库中的用户。记住，Passport会为我们填充`req.user`。
- en: Suddenly, we have our profile editor!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 突然，我们有了我们的个人资料编辑器！
- en: '![](../Images/08_06.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_06.png)'
- en: Figure 8.6 Profile editor
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 个人资料编辑器
- en: Now that we can edit profiles, create some fake users and edit their profiles.
    Check out Learn About Me, our mostly-finished app!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够编辑个人资料了，创建一些假用户并编辑他们的个人资料。查看我们的基本完成的应用程序“了解我”！
- en: '![](../Images/08_07.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_07.png)'
- en: Figure 8.7 The LAM homepage
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 LAM主页
- en: And now you have a real app!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个真正的应用程序了！
- en: 8.4     Summary
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4     总结
- en: 'In this chapter you learned:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了：
- en: '·  How MongoDB works: it''s a database that lets you store JavaScript-style
    objects'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ·  MongoDB是如何工作的：它是一个允许你存储JavaScript风格对象的数据库
- en: ·  How to use Mongoose, an official MongoDB library for controlling the database
    with Node
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何使用Mongoose，一个官方的MongoDB库，用Node控制数据库
- en: ·  How to securely create user accounts using bcrypt
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何使用bcrypt安全地创建用户账户
- en: ·  How to use Passport for user authentication
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何使用Passport进行用户认证
