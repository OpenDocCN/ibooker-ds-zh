- en: 4 Externalized configuration management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 外部化配置管理
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Configuring Spring with properties and profiles
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性和配置文件配置 Spring
- en: Applying external configuration with Spring Boot
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 应用外部配置
- en: Implementing a configuration server with Spring Cloud Config Server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Config Server 实现配置服务器
- en: Configuring applications with Spring Cloud Config Client
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Config Client 配置应用程序
- en: 'In the previous chapter, we built a RESTful application for managing a catalog
    of books. As part of the implementation, we defined some data to configure certain
    aspects of the application (in an application.yml file), such as the Tomcat thread
    pool and connection timeout. The next step might be to deploy the application
    to different environments: first in a test environment, then staging, and finally
    in production. What if you needed a different Tomcat configuration for each of
    these environments? How would you achieve that?'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个用于管理图书目录的 RESTful 应用程序。作为实现的一部分，我们定义了一些数据来配置应用程序的某些方面（在 application.yml
    文件中），例如 Tomcat 线程池和连接超时。下一步可能是在不同的环境中部署应用程序：首先在测试环境中，然后是预发布，最后是生产环境。如果你需要为这些环境中的每一个都使用不同的
    Tomcat 配置怎么办？你将如何实现这一点？
- en: Traditional applications were usually packaged as a bundle, including the source
    code and a series of configuration files containing data for different environments,
    with the appropriate configuration being selected through a flag at runtime. The
    implication was that you had to make a new application build every time you needed
    to update the configuration data for a specific environment. A variant of this
    process was to create a different build for each environment, meaning that you
    had no guarantee whether what you ran in a staging environment would work the
    same way in production because they were different artifacts.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 传统应用程序通常被打包成一个包，包括源代码和一系列包含不同环境数据的配置文件，通过运行时的一个标志来选择适当的配置。这意味着每次你需要更新特定环境的配置数据时，都必须创建一个新的应用程序构建。这个过程的一个变体是为每个环境创建不同的构建，这意味着你无法保证在预发布环境中运行的内容在生产环境中是否以相同的方式工作，因为它们是不同的工件。
- en: '*Configuration* is defined as everything likely to change between deployments
    (as per the 15-Factor methodology), like credentials, resource handles, and URLs
    to backing services. An application deployed in multiple locations will likely
    have different needs in each location and require different configurations. A
    key aspect of cloud native applications is that the application artifact will
    stay immutable across environments. No matter which environment you deploy it
    to, the application build will not be changed.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*配置* 被定义为在部署之间可能需要更改的所有内容（根据 15-Factor 方法），如凭证、资源句柄和后端服务的 URL。在多个位置部署的应用程序可能在每个位置都有不同的需求，并需要不同的配置。云原生应用程序的一个关键方面是应用程序工件将在各个环境中保持不可变。无论你将其部署到哪个环境，应用程序构建都不会改变。'
- en: Each release you deploy is a combination of build and configuration. The same
    build can be deployed to different environments with different configuration data,
    as shown in figure 4.1.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你部署的每个版本都是构建和配置的组合。相同的构建可以部署到具有不同配置数据的不同环境中，如图 4.1 所示。
- en: '![04-01](../Images/04-01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![04-01](../Images/04-01.png)'
- en: Figure 4.1 Each release you deploy is a combination of build and configuration,
    which is different for each environment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 每次部署的每个版本都是构建和配置的组合，这因环境而异。
- en: Anything that might need to change across deployments should be configurable.
    For example, you’ll probably want to change feature flags, credentials for accessing
    backing services, resource handles for databases, or URLs to external APIs, all
    depending on the environment to which you’re deploying the application. Cloud
    native applications favor externalized configuration so that you can replace it
    without having to rebuild your code. Regarding credentials, it’s even more critical
    not to store them with your application code. There have been countless data breaches
    because of companies including credentials in a repository that went public by
    accident. Make sure you won’t be one of them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可能需要在部署之间更改的内容都应该可配置。例如，你可能想要更改功能标志、访问后端服务的凭证、数据库的资源句柄或外部 API 的 URL，所有这些都取决于你部署应用程序的环境。云原生应用程序倾向于外部化配置，这样你就可以在不重新构建代码的情况下替换它。至于凭证，不将其与应用程序代码一起存储更为关键。由于公司不小心将凭证包含在公开的存储库中，已经发生了无数的数据泄露。确保你不是其中之一。
- en: In Spring, configuration data is abstracted as properties (key/value pairs)
    defined in different sources, such as property files, JVM system properties, and
    system environment variables. This chapter covers various aspects of configuring
    Spring applications that are relevant in a cloud native context. I’ll first present
    the main concepts behind how Spring handles configuration, including properties
    and profiles, and how you can apply externalized configuration with Spring Boot.
    Then I’ll show you how to set up a configuration server with Spring Cloud Config
    Server, using a Git repository as the backend for storing your configuration data.
    Finally, you’ll learn how to use the config server to configure a Spring Boot
    application by relying on Spring Cloud Config Client.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，配置数据被抽象为定义在不同源中的属性（键/值对），例如属性文件、JVM系统属性和系统环境变量。本章涵盖了在云原生环境中与配置相关的各个方面。我首先将介绍Spring处理配置背后的主要概念，包括属性和配置文件，以及如何使用Spring
    Boot应用外部化配置。然后，我将向您展示如何使用Git仓库作为后端存储配置数据来设置配置服务器。最后，您将学习如何通过依赖Spring Cloud Config
    Client来使用配置服务器配置Spring Boot应用。
- en: By the end of this chapter, you’ll be able to configure your cloud native Spring
    applications in different ways, depending on your needs and the type of configuration
    data you have. Table 4.1 summarizes the three main strategies for defining configuration
    data for cloud native applications covered in this chapter. Chapter 14 will further
    extend the subjects covered here, including secrets management and how to use
    ConfigMaps and Secrets in Kubernetes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够根据您的需求和拥有的配置数据类型以不同的方式配置您的云原生Spring应用。表4.1总结了本章中涵盖的为云原生应用定义配置数据的三种主要策略。第14章将进一步扩展本章所涵盖的主题，包括密钥管理以及如何在Kubernetes中使用ConfigMaps和Secrets。
- en: Note The source code for the examples in this chapter is available in the Chapter04/04-begin
    and Chapter04/04-end folders, which contain the initial and final states of the
    project ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中示例的源代码可在Chapter04/04-begin和Chapter04/04-end文件夹中找到，这些文件夹包含项目的初始状态和最终状态（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)）。
- en: Table 4.1 Cloud native applications can be configured according to different
    strategies. You will likely use them all, depending on the type of configuration
    data and the application requirements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 云原生应用可以根据不同的策略进行配置。根据配置数据类型和应用需求，你可能会使用它们全部。
- en: '| Configuration strategy | Characteristics |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 配置策略 | 特点 |'
- en: '| Property files packaged with the application |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 随应用程序打包的属性文件 |'
- en: These files can act as specifications of what configuration data the application
    supports.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些文件可以作为应用程序支持哪些配置数据的规范。
- en: These are useful for defining sensible default values, mainly oriented to the
    development environment.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些对于定义合理的默认值非常有用，主要面向开发环境。
- en: '|'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Environment variables |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 环境变量 |'
- en: Environment variables are supported by any operating system, so they are great
    for portability.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量被任何操作系统支持，因此它们非常适合便携性。
- en: Most programming languages allow you access to the environment variables. In
    Java you can access them with the System.getenv() method. In Spring you can also
    rely on the Environment abstraction.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数编程语言都允许你访问环境变量。在Java中，你可以使用System.getenv()方法访问它们。在Spring中，你也可以依赖Environment抽象。
- en: These are useful for defining configuration data that depends on the infrastructure
    and platform where the application is deployed, such as active profiles, hostnames,
    service names, and port numbers.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些对于定义依赖于应用程序部署的基础设施和平台的配置数据非常有用，例如活动配置文件、主机名、服务名称和端口号。
- en: '|'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Configuration service |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 配置服务 |'
- en: Provides configuration data persistence, auditing, and accountability.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供配置数据持久性、审计和问责制。
- en: Allows secrets management by using encryption or dedicated secret vaults.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许通过加密或专用密钥库进行密钥管理。
- en: This is useful for defining configuration data specific to the application,
    such as connection pools, credentials, feature flags, thread pools, and URLs to
    third-party services.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这对于定义特定于应用程序的配置数据非常有用，例如连接池、凭证、功能标志、线程池以及第三方服务的URL。
- en: '|'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '4.1 Configuration in Spring: Properties and profiles'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 Spring中的配置：属性和配置文件
- en: The term *configuration* can have different meanings depending on the context.
    When discussing the Spring Framework’s core features and its ApplicationContext,
    configuration refers to which beans (Java objects registered in Spring) have been
    defined to be managed by the Spring container and are injected where needed. For
    example, you can define beans in an XML file (XML configuration), in a @Configuration
    class (Java configuration), or by relying on annotations like @Component (annotation-driven
    configuration).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *配置* 可以根据上下文有不同的含义。当讨论Spring框架的核心特性和其ApplicationContext时，配置指的是哪些bean（在Spring中注册的Java对象）被定义为由Spring容器管理，并在需要的地方注入。例如，您可以在XML文件（XML配置）中定义bean，在
    @Configuration 类（Java配置）中定义，或者通过依赖注解如 @Component（注解驱动配置）。
- en: In this book, unless specified otherwise, whenever I mention *configuration*,
    I don’t mean the previous concept, but rather everything that’s likely to change
    between deployments, as defined by the 15-Factor methodology.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，除非另有说明，每次提到 *配置* 时，我都不指代先前的概念，而是指在部署之间可能发生变化的所有内容，如15-Factor方法所定义的。
- en: Spring provides you with a convenient Environment abstraction that gives you
    access to any configuration data, no matter its source. The two key aspects of
    a Spring application environment are *properties* and *profiles*. You have already
    worked with properties in the previous chapter. Profiles are a tool for labeling
    logical groups of beans or configuration data that should be loaded at runtime
    only if a given profile is enabled. Figure 4.2 shows the main aspects of a Spring
    application environment.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 为您提供了一个方便的环境抽象，无论配置数据的来源如何，都能让您访问任何配置数据。Spring 应用程序环境的关键两个方面是 *属性* 和
    *配置文件*。您已经在上一章中处理过属性。配置文件是用于标记逻辑分组中的bean或配置数据的一个工具，这些bean或配置数据在运行时只有当指定的配置文件被启用时才加载。图4.2展示了Spring应用程序环境的主要方面。
- en: '![04-02](../Images/04-02.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![04-02](../Images/04-02.png)'
- en: 'Figure 4.2 The Environment interface gives access to the two key aspects of
    any Spring application configuration: properties and profiles.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 环境接口提供了访问任何Spring应用程序配置的两个关键方面：属性和配置文件。
- en: This section will cover the fundamental aspects of properties and profiles for
    cloud native applications, including how to define custom properties and when
    to use profiles.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍云原生应用程序的属性和配置文件的基本方面，包括如何定义自定义属性以及何时使用配置文件。
- en: '4.1.1 Properties: Key/value pairs for configuration'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 属性：配置的关键/值对
- en: 'Properties are key/value pairs supported in Java as first-class citizens with
    java.util .Properties. They play an essential role in many applications for storing
    configuration parameters outside of the compiled Java code. Spring Boot automatically
    loads them from different sources. When the same property is defined in multiple
    sources, there are rules that determine which one takes precedence. For example,
    if you specify a value for the server.port property both in a property file and
    a command-line argument, the latter takes precedence over the former. The following
    is a prioritized list of some of the most common property sources, starting with
    the highest priority:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是Java中作为一等公民支持的关键/值对，由 java.util.Properties 提供。它们在许多应用程序中扮演着至关重要的角色，用于在编译的Java代码之外存储配置参数。Spring
    Boot会自动从不同的来源加载它们。当相同的属性在多个来源中定义时，有一些规则决定了哪个具有优先权。例如，如果您在属性文件和命令行参数中为 server.port
    属性指定了值，则后者将优先于前者。以下是一些最常见的属性来源的优先级列表，从最高优先级开始：
- en: '@TestPropertySource annotations on test classes'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试类上的 @TestPropertySource 注解
- en: Command-line arguments
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令行参数
- en: JVM System properties from System.getProperties()
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自 System.getProperties() 的JVM系统属性
- en: OS environment variables from System.getenv()
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自 System.getenv() 的操作系统环境变量
- en: Configuration data files
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置数据文件
- en: '@PropertySource annotations on @Configuration classes'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '@PropertySource 注解在 @Configuration 类上'
- en: Default properties from SpringApplication.setDefaultProperties
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SpringApplication.setDefaultProperties 的默认属性
- en: For the complete list, you can refer to the Spring Boot documentation ([https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的列表，您可以参考Spring Boot文档([https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot))。
- en: 'Configuration data files can be further prioritized, starting with the highest
    priority:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 配置数据文件可以进一步按优先级排序，从最高优先级开始：
- en: Profile-specific application properties from application-{profile}.properties
    and application-{profile}.yml files packaged outside your JAR
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自打包在 JAR 外部的 application-{profile}.properties 和 application-{profile}.yml 文件针对特定配置文件的应用程序属性
- en: Application properties from application.properties and application.yml files
    packaged outside your JAR
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自打包在 JAR 外部的 application.properties 和 application.yml 文件的应用程序属性
- en: Profile-specific application properties from application-{profile}.properties
    and application-{profile}.yml files packaged inside your JAR
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自打包在 JAR 内部的 application-{profile}.properties 和 application-{profile}.yml 文件针对特定配置文件的应用程序属性
- en: Application properties from application.properties and application.yml files
    packaged inside your JAR
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自打包在 JAR 内部的 application.properties 和 application.yml 文件的应用程序属性
- en: 'The beauty of property handling in Spring is that you don’t need to know the
    specific property source to get a value: the Environment abstraction lets you
    access any property defined in any source through a unified interface. And if
    the same property is defined in multiple sources, it returns the one with the
    highest priority. You can even add your own custom sources and assign a priority
    to them.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 中属性处理的美妙之处在于，您不需要知道具体的属性源就能获取值：Environment 抽象让您可以通过统一的接口访问任何源中定义的属性。如果相同的属性在多个源中定义，它将返回优先级最高的那个。您甚至可以添加自己的自定义源并为它们分配优先级。
- en: Note Spring Framework has built-in support for properties defined according
    to the Properties format. On top of that, Spring Boot adds support for defining
    properties using the YAML format. YAML is a superset of JSON that provides more
    flexibility than the simpler Properties format. The official website describes
    YAML as “a human-friendly data serialization language for all programming languages”
    ([https://yaml.org](https://yaml.org)). Feel free to choose either approach in
    your applications. All the examples in the book will use YAML.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Spring 框架内置了对按照 Properties 格式定义的属性的支撑。在此基础上，Spring Boot 还增加了使用 YAML 格式定义属性的支持。YAML
    是 JSON 的超集，它比简单的 Properties 格式提供了更多的灵活性。官方网站将 YAML 描述为“一种适用于所有编程语言的、人性化的数据序列化语言”
    ([https://yaml.org](https://yaml.org))。您可以在应用程序中自由选择任一方法。本书中的所有示例都将使用 YAML。
- en: Using application properties
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用应用程序属性
- en: 'There are a few ways to access properties from a Java class, as shown in figure
    4.3\. The most generic approach is based on the Environment interface, which you
    can autowire wherever you need access to an application property. For example,
    you can use it to access the value for the server.port property as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从 Java 类中访问属性，如图 4.3 所示。最通用的方法是基于 Environment 接口，您可以在需要访问应用程序属性的地方自动装配它。例如，您可以使用它来访问
    server.port 属性的值，如下所示：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![04-03](../Images/04-03.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![04-03](../Images/04-03.png)'
- en: Figure 4.3 You can access Spring properties in different ways.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 您可以通过不同的方式访问 Spring 属性。
- en: 'Properties can also be injected without explicitly invoking the Environment
    object. Just like you use the @Autowired annotation for injecting Spring beans,
    you can apply the @Value annotation to inject property values:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 属性也可以在不显式调用 Environment 对象的情况下注入。就像您使用 @Autowired 注解来注入 Spring Bean 一样，您可以将
    @Value 注解应用于注入属性值：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can configure the application using properties without hardcoding values
    inside the code, which is one of our goals. But when using the Environment object
    or the @Value annotation, you still have a hardcoded value that can become difficult
    to manage: the property key. A more robust and maintainable option, which is also
    the one recommended by the Spring team, is to use special beans marked with the
    @ConfigurationProperties annotation to hold configuration data. We’ll explore
    this feature in the next section while you learn how to define custom properties.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用属性配置应用程序，而不需要在代码中硬编码值，这是我们的一项目标。但是，当使用 Environment 对象或 @Value 注解时，您仍然有一个硬编码的值，这可能变得难以管理：属性键。一个更健壮且易于维护的选项，也是
    Spring 团队推荐的选项，是使用带有 @ConfigurationProperties 注解的特殊 Bean 来保存配置数据。我们将在下一节中探讨这个特性，同时您将学习如何定义自定义属性。
- en: Defining custom properties
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自定义属性
- en: Spring Boot comes bundled with tons of properties for configuring any aspect
    of your application, depending on which starter dependency you import into your
    project. Sooner or later, though, you’ll find you need to define your own properties.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 随带了大量用于配置应用程序任何方面的属性，具体取决于您将哪个启动器依赖项导入到项目中。但迟早，您会发现您需要定义自己的属性。
- en: 'Let’s consider the Catalog Service application we have been working on. In
    chapter 2, we defined an HTTP endpoint that returned a welcome message to users.
    We now have a new requirement to implement: the welcome message should be configurable.
    This is probably not the most useful functionality, but it will help me illustrate
    the different configuration options.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下我们一直在工作的目录服务应用程序。在第 2 章中，我们定义了一个 HTTP 端点，它向用户返回一个欢迎消息。我们现在有一个新的需求要实现：欢迎消息应该是可配置的。这可能不是最有用的功能，但它将帮助我展示不同的配置选项。
- en: The first thing to do is tell Spring Boot to scan the application context for
    configuration data beans. We can do so by adding the @ConfigurationPropertiesScan
    annotation to the CatalogServiceApplication class in your Catalog Service project
    (catalog-service).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首件事是告诉 Spring Boot 扫描应用程序上下文以查找配置数据 bean。我们可以通过将 @ConfigurationPropertiesScan
    注解添加到你的目录服务项目（catalog-service）中的 CatalogServiceApplication 类来实现这一点。
- en: Listing 4.1 Enabling scanning of configuration data beans
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 启用配置数据 bean 的扫描
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Loads configuration data beans in the Spring context
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 Spring 上下文中加载配置数据 bean
- en: Note Instead of making Spring scan the application context, searching for configuration
    data beans, you can directly specify which ones Spring should consider by using
    the @EnableConfigurationProperties annotation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你不必让 Spring 扫描应用程序上下文以查找配置数据 bean，你可以直接使用 @EnableConfigurationProperties
    注解来指定 Spring 应该考虑哪些 bean。
- en: 'Next, you can define a new com.polarbookshop.catalogservice.config package,
    and create a PolarProperties class annotated with @ConfigurationProperties to
    mark it as a holder of configuration data. The @ConfigurationProperties annotation
    takes a prefix argument, combined with a field name, to produce the final property
    key. Spring Boot will try to map all properties with that prefix to fields in
    the class. In this case, there’s only one property mapped to the bean: polar.greeting.
    Optionally, you can add a description for each property using JavaDoc comments
    that can be converted into metadata, as I’ll show you in a minute.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以定义一个新的 com.polarbookshop.catalogservice.config 包，并创建一个 PolarProperties
    类，使用 @ConfigurationProperties 注解来标记它作为配置数据的持有者。@ConfigurationProperties 注解接受一个前缀参数，结合字段名，生成最终的属性键。Spring
    Boot 将尝试将具有该前缀的所有属性映射到类中的字段。在这种情况下，只有一个属性映射到该 bean：polar.greeting。可选地，你可以为每个属性添加描述，使用
    JavaDoc 注释，这些注释可以转换为元数据，就像我稍后要展示的那样。
- en: Listing 4.2 Defining custom properties in a Spring bean
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 在 Spring bean 中定义自定义属性
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Marks the class as a source for configuration properties starting with the
    prefix “polar”
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将类标记为以“polar”前缀开始的配置属性的源
- en: ❷ Field for the custom polar.greeting (prefix + field name) property, parsed
    as String
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 解析为 String 的自定义 polar.greeting（前缀 + 字段名）属性字段
- en: Optionally, you can add a new dependency on the Spring Boot Configuration Processor
    in your build.gradle file. That will automatically generate metadata for the new
    properties and store them in META-INF/spring-configuration-metadata.json when
    building the project. The IDE can pick them up, show you the description message
    for each property, and help you with autocompletion and type checks. Remember
    to refresh or reimport the Gradle dependencies after the new addition.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以在你的 build.gradle 文件中添加一个新的依赖项，即 Spring Boot 配置处理器。这样，在构建项目时，它会自动为新的属性生成元数据，并将它们存储在
    META-INF/spring-configuration-metadata.json 中。IDE 可以识别这些元数据，显示每个属性的描述信息，并帮助你进行自动补全和类型检查。记得在添加新依赖后刷新或重新导入
    Gradle 依赖。
- en: Listing 4.3 Adding dependency for the Spring Boot Configuration Processor
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 添加 Spring Boot 配置处理器依赖项
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Configures Gradle to use the Configuration Processor when building the project
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 Gradle 在构建项目时使用配置处理器
- en: Now you can trigger the metadata generation by building your project (./gradlew
    clean build). At this point you can go ahead and define a default value for the
    polar.greeting property in the application.yml file. While you are inserting the
    new property, your IDE should provide you with an autocompletion option and type
    check, as shown in figure 4.4.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过构建你的项目（./gradlew clean build）来触发元数据生成。在这个阶段，你可以在 application.yml 文件中为
    polar.greeting 属性定义一个默认值。当你插入新属性时，你的 IDE 应该提供自动补全选项和类型检查，如图 4.4 所示。
- en: Listing 4.4 Defining a value for a custom property in Catalog Service
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 在目录服务中定义自定义属性的值
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![04-04](../Images/04-04.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![04-04](../Images/04-04.png)'
- en: Figure 4.4 Using the Spring Boot Configuration Processor, the JavaDoc comment
    from your custom property bean is converted into metadata that’s used by your
    IDE to provide useful information, autocompletion, and a type check.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 使用Spring Boot配置处理器，你的自定义属性Bean的JavaDoc注释被转换为IDE用于提供有用信息、自动完成和类型检查的元数据。
- en: In listing 4.2, the greeting field will be mapped to the polar.greeting property,
    for which you have just defined a value in application.yml.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表4.2中，问候字段将被映射到polar.greeting属性，你已经在application.yml中为该属性定义了一个值。
- en: Using custom properties
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义属性
- en: Classes or records annotated with @ConfigurationProperties are standard Spring
    beans, so you can inject them wherever you need them. Spring Boot initializes
    all the configuration beans at startup and populates them with the data provided
    through any of the supported configuration data sources. In the case of Catalog
    Service, the data will be populated from the application.yml file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用@ConfigurationProperties注解的类或记录是标准的Spring Bean，因此你可以将它们注入到你需要的地方。Spring Boot在启动时初始化所有配置Bean，并通过任何支持的配置数据源提供的数据填充它们。在目录服务的情况下，数据将从application.yml文件中填充。
- en: The new requirement for Catalog Service is to make the welcome message returned
    by the root endpoint configurable via the polar.greeting property. Open the HomeController
    class and update the handler method to get the message from the custom property
    instead of using a fixed value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 新的要求是使目录服务的根端点返回的欢迎消息可以通过polar.greeting属性进行配置。打开HomeController类，并更新处理方法以从自定义属性获取消息，而不是使用固定值。
- en: Listing 4.5 Using custom properties from a configuration properties bean
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5 使用配置属性Bean的自定义属性
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Bean to access the custom properties injected via constructor autowiring
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过构造函数自动装配注入自定义属性的Bean
- en: ❷ Uses the welcome message from the configuration data bean
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用配置数据Bean的欢迎消息
- en: 'You can now build and run the application to verify that it works as intended
    (./gradlew bootRun). Then open a Terminal window, and send a GET request to the
    root endpoint exposed by Catalog Service. The result should be the message you
    configured in application.yml for the polar.greeting property:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以构建并运行应用程序以验证它是否按预期工作（./gradlew bootRun）。然后打开一个终端窗口，向目录服务公开的根端点发送GET请求。结果应该是你在application.yml中为polar.greeting属性配置的消息：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note Property files packaged with your application code are useful for defining
    sensible default values for your configuration data. They can also act as specifications
    for what configuration properties your application supports.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：与应用程序代码打包的属性文件对于定义配置数据的合理默认值很有用。它们还可以作为应用程序支持的配置属性规范的说明。
- en: 'The following section will cover the other key aspect modeled by the Spring
    Environment abstraction: profiles, and how to use them for cloud native applications.
    Before moving on, you can stop the application with Ctrl-C.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将介绍由Spring环境抽象建模的另一个关键方面：配置文件，以及如何使用它们来为云原生应用程序。在继续之前，你可以使用Ctrl-C停止应用程序。
- en: '4.1.2 Profiles: Feature flags and configuration groups'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 配置文件：功能标志和配置组
- en: Sometimes you might want to load a bean into the Spring context only under specific
    conditions. For example, you might want to define a bean responsible for generating
    test data only when you’re working locally or testing the application. Profiles
    are logical groups of beans that are loaded into the Spring context only if the
    specified profile is active. Spring Boot also extends this concept to property
    files, allowing you to define groups of configuration data that are loaded only
    if a specific profile is active.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能希望在特定条件下将一个Bean加载到Spring上下文中。例如，你可能只想在你本地工作或测试应用程序时定义一个负责生成测试数据的Bean。配置文件是逻辑上的Bean组，只有当指定的配置文件处于活动状态时，这些Bean才会被加载到Spring上下文中。Spring
    Boot也将这一概念扩展到属性文件，允许你定义只有当特定配置文件处于活动状态时才会加载的配置数据组。
- en: You can activate zero, one, or more profiles at a time. All beans not assigned
    to a profile will always be activated. Beans assigned to the default profile are
    only activated when no other profile is active.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以同时激活零个、一个或多个配置文件。所有未分配给配置文件的Bean始终会被激活。分配给默认配置文件的Bean只有在没有其他配置文件处于活动状态时才会被激活。
- en: 'This section presents Spring profiles in the context of two different use cases:
    feature flags and configuration groups.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本节在两个不同的用例的背景下介绍Spring配置文件：功能标志和配置组。
- en: Using profiles as feature flags
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置文件作为功能标志
- en: The first use case for profiles is for loading groups of beans only if a specified
    profile is active. The deployment environment shouldn’t influence the reasoning
    behind the groupings too much. A common mistake is using profiles like dev or
    prod to load beans conditionally. If you do that, the application will be coupled
    to the environment, which is usually not what we want for a cloud native application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件的第一个用途是仅在指定的配置文件活动时加载豆类组。部署环境不应过多地影响分组背后的推理。一个常见的错误是使用像dev或prod这样的配置文件来条件性地加载豆类。如果你这样做，应用程序将与环境耦合，这对于云原生应用程序通常不是我们想要的。
- en: Consider the case where you deploy applications to three different environments
    (development, test, and production) and define three profiles to load certain
    beans conditionally (dev, test, and prod). At some point you decide to add a staging
    environment, where you also want to enable the beans marked with the prod profile.
    What do you do? You have two options. Either you activate the prod profile in
    the staging environment (which doesn’t make much sense), or you update the source
    code to add a staging profile, and assign it to the beans marked as prod (which
    prevents your application from being immutable and deployable to any environment
    without any change to the source code). Instead, I recommend using profiles as
    feature flags when they’re associated with groups of beans to be loaded conditionally.
    Consider what functionality a profile provides, and name it accordingly, rather
    than thinking about where it will be enabled.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个情况，你将应用程序部署到三个不同的环境（开发、测试和生产）并定义三个配置文件来条件性地加载某些豆类（dev、test和prod）。在某个时候，你决定添加一个预发布环境，你同样希望启用标记为prod配置文件的豆类。你该怎么办？你有两个选择。要么在预发布环境中激活prod配置文件（这并没有太多意义），要么更新源代码以添加预发布配置文件，并将其分配给标记为prod的豆类（这会阻止你的应用程序不可变且无需更改源代码即可部署到任何环境）。相反，我建议当配置文件与要条件加载的豆类组相关联时，将其用作功能标志。考虑配置文件提供的功能，并相应地命名它，而不是考虑它将在哪里启用。
- en: You might still have cases where a bean that handles infrastructural concerns
    is required in specific platforms. For example, you might have certain beans that
    should only be loaded when the application is deployed to a Kubernetes environment
    (no matter whether it is for staging or production). In that case, you could define
    a kubernetes profile.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能仍然有一些情况需要特定的平台中处理基础设施问题的豆类。例如，你可能有一些豆类，只有在应用程序部署到Kubernetes环境时才应该加载（无论它是预发布还是生产）。在这种情况下，你可以定义一个kubernetes配置文件。
- en: In chapter 3 we built the Catalog Service application to manage books. Whenever
    you run it locally, there are no books in the catalog yet, and you need to add
    some explicitly if you want to work with the application. A better option would
    be to let the application generate some test data at startup, but only when it’s
    needed (for example, in a development or test environment). Loading test data
    can be modeled as a feature that you enable or disable through configuration.
    You could define a testdata profile to toggle the loading of this test data. In
    that way, you’ll keep the profiles independent from the deployment environment,
    and you can use them as feature flags with no constraint on the deployment environment
    whatsoever. Let’s do that.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们构建了目录服务应用程序来管理书籍。每次你在本地运行它时，目录中还没有任何书籍，如果你想使用该应用程序，需要显式地添加一些。更好的选择是让应用程序在启动时生成一些测试数据，但仅在需要时（例如，在开发或测试环境中）。加载测试数据可以建模为一个可以通过配置启用或禁用的功能。你可以定义一个测试数据配置文件来切换此测试数据的加载。这样，你将保持配置文件与部署环境独立，并且你可以无任何约束地将其用作功能标志。让我们这样做。
- en: First, add a new com.polarbookshop.catalogservice.demo package to your Catalog
    Service project, and create a BookDataLoader class. You can instruct Spring to
    load this class only when the testdata profile is active by applying the @Profile
    annotation. Then you can use the BookRepository we implemented in chapter 3 to
    save the data. Finally, the @EventListener(ApplicationReadyEvent.class) annotation
    will trigger the test data generation after the application has completed the
    startup phase.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，向你的目录服务项目添加一个新的com.polarbookshop.catalogservice.demo包，并创建一个BookDataLoader类。你可以通过应用@Profile注解来指示Spring仅在测试数据配置文件活动时加载这个类。然后你可以使用我们在第3章中实现的BookRepository来保存数据。最后，@EventListener(ApplicationReadyEvent.class)注解将在应用程序完成启动阶段后触发测试数据生成。
- en: Listing 4.6 Loading book test data when the testdata profile is active
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 当测试数据配置文件激活时加载书籍测试数据
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Assigns the class to the testdata profile. It will be registered only when
    the testdata profile is active.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将类分配给测试数据配置文件。它只有在测试数据配置文件激活时才会被注册。
- en: ❷ The test data generation is triggered when an ApplicationReadyEvent is sent—that
    is when the application startup phase is completed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当发送 ApplicationReadyEvent 时触发测试数据生成——即应用程序启动阶段完成时。
- en: In your development environment, you can use the spring.profiles.active property
    to set the testdata profile as active. You could set it in the application.yml
    file for the Catalog Service project, but it’s not ideal to have the test data
    feature enabled by default. What if you forget to overwrite it in production?
    A better option is configuring it specifically for the local development environment
    when running the bootRun task. You can achieve that by adding the following code
    to the build.gradle file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的开发环境中，您可以使用 spring.profiles.active 属性将测试数据配置文件设置为激活状态。您可以在 Catalog Service
    项目的 application.yml 文件中设置它，但默认启用测试数据功能并不是最佳选择。如果忘记在生产环境中覆盖它怎么办？更好的选择是在运行 bootRun
    任务时专门为本地开发环境配置它。您可以通过在 build.gradle 文件中添加以下代码来实现这一点。
- en: Listing 4.7 Defining the active profiles for the development environment
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 定义开发环境的激活配置文件
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let’s verify that it works. Build and run the application (./gradlew bootRun).
    You’ll see a message in the application logs listing all the active profiles (in
    this case, it’s just testdata, but there can be more), as shown in figure 4.5.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证它是否工作。构建并运行应用程序（./gradlew bootRun）。您将在应用程序日志中看到一条消息，列出所有激活的配置文件（在这种情况下，只是
    testdata，但可能有更多），如图 4.5 所示。
- en: '![04-05](../Images/04-05.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![04-05](../Images/04-05.png)'
- en: Figure 4.5 The logs for Catalog Service when the “testdata” profile is active
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 当“testdata”配置文件激活时 Catalog Service 的日志
- en: 'Then you can send a request to the application to fetch all the books in the
    catalog:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以向应用程序发送请求以获取目录中的所有书籍：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It should return the test data we created in listing 4.6\. When you’re done,
    stop the application with Ctrl-C.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 应返回列表 4.6 中创建的测试数据。当您完成时，使用 Ctrl-C 停止应用程序。
- en: Note Instead of using profiles as feature flags, a more scalable and structured
    approach is defining custom properties to configure functionality, and relying
    on annotations such as @ConditionalOnProperty and @ConditionalOnCloudPlatform
    to control when certain beans should be loaded into the Spring application context.
    That’s one of the foundations of Spring Boot auto-configuration. For example,
    you could define a polar.testdata.enabled custom property and use the @ConditionalOnProperty(name
    = "polar.testdata .enabled", havingValue = "true") annotation on the BookDataLoader
    class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：与其使用配置文件作为功能标志，不如定义自定义属性来配置功能，并依赖于如 @ConditionalOnProperty 和 @ConditionalOnCloudPlatform
    这样的注解来控制何时将某些 bean 加载到 Spring 应用程序上下文中。这是 Spring Boot 自动配置的基础之一。例如，您可以定义一个 polar.testdata.enabled
    自定义属性，并在 BookDataLoader 类上使用 @ConditionalOnProperty(name = "polar.testdata .enabled",
    havingValue = "true") 注解。
- en: Next, I’ll show you how to use profiles to group configuration data.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将向您展示如何使用配置文件来分组配置数据。
- en: Using profiles as configuration groups
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置文件作为配置组
- en: The Spring Framework’s profile functionality allows you to register some beans
    only if a given profile is active. Likewise, Spring Boot lets you define configuration
    data that is loaded only when a specific profile is active. A common way to do
    that is inside a property file named with the profile as a suffix. In the case
    of the Catalog Service, you could create a new application-dev.yml file and define
    a value for the polar.greeting property, which would be used by Spring Boot only
    if the dev profile was active. Profile-specific property files take precedence
    over the non-specific property files, so the value defined in application-dev.yml
    would take precedence over the one in application.yml.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架的配置文件功能允许您仅在给定配置文件激活时注册一些 bean。同样，Spring Boot 允许您定义仅在特定配置文件激活时加载的配置数据。一种常见的方法是在以配置文件命名的属性文件中定义配置数据。在
    Catalog Service 的例子中，您可以创建一个新的 application-dev.yml 文件，并定义 polar.greeting 属性的值，该值只有在
    dev 配置文件激活时才会被 Spring Boot 使用。特定配置文件的属性文件优先于非特定属性文件，因此 application-dev.yml 中定义的值将优先于
    application.yml 中的值。
- en: In the context of property files, profiles are used to group configuration data,
    and they can be mapped to deployment environments without facing the same issues
    we analyzed in the previous section when using profiles as feature flags. But
    that applies only as long as you don’t package the profile-specific property files
    with the application. The 15-Factor methodology recommends not batching configuration
    values into groups named after environments and bundled with the application source
    code because it wouldn’t scale. As a project grows, new environments might be
    created for different stages; developers might create their own custom environments
    to try out new functionality. You can quickly end up with way too many configuration
    groups, implemented like Spring profiles and requiring new builds. Instead, you’ll
    want to keep them outside the application, such as in a dedicated repository served
    by a configuration server, as you’ll see later in this chapter. The only exception
    is for defaults and development-oriented configuration.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性文件的情况下，配置文件用于分组配置数据，并且它们可以映射到部署环境，而不会遇到我们在上一节中分析使用配置文件作为功能标志时遇到的问题。但这仅在你没有将特定配置文件的属性文件捆绑到应用程序中时适用。15-Factor
    方法建议不要将配置值批处理到以环境命名并捆绑到应用程序源代码中的组中，因为这不会扩展。随着项目的增长，可能会为不同的阶段创建新的环境；开发者可能会创建自己的自定义环境来尝试新功能。你可能会迅速拥有过多的配置组，就像实现
    Spring 配置文件一样，并需要新的构建。相反，你希望将它们保留在应用程序外部，例如在由配置服务器提供服务的专用存储库中，正如你将在本章后面看到的那样。唯一的例外是默认值和面向开发的配置。
- en: The following section will cover how Spring Boot addresses externalized configuration.
    You’ll learn how to use command-line arguments, JVM system properties, and environment
    variables to provide configuration data from the outside while using the same
    application build.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将介绍 Spring Boot 如何处理外部化配置。你将学习如何使用命令行参数、JVM 系统属性和环境变量从外部提供配置数据，同时使用相同的应用程序构建。
- en: '4.2 Externalized configuration: One build, multiple configurations'
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 外部化配置：一次构建，多种配置
- en: Property files bundled with the application source code are useful for defining
    some sensible defaults. Still, if you need to provide different values depending
    on the environment, you’ll need something else. Externalized configuration allows
    you to configure your application depending on where it’s deployed while consistently
    using the same immutable build for your application code. The critical aspect
    is that you don’t change your application after you build and package it. If any
    configuration change is needed (for example, different credentials or database
    handles), it’s done from the outside.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与应用程序源代码捆绑的属性文件对于定义一些合理的默认值很有用。然而，如果你需要根据环境提供不同的值，你将需要其他东西。外部化配置允许你根据应用程序部署的位置来配置应用程序，同时始终使用相同的不可变构建来构建应用程序代码。关键方面是你在构建和打包应用程序后不要更改应用程序。如果需要任何配置更改（例如，不同的凭证或数据库句柄），则从外部进行更改。
- en: The 15-Factor methodology promotes storing configuration in the environment,
    and Spring Boot provides several ways to achieve that. You can use one of the
    higher priority property sources to override the default values, depending on
    where the application is deployed. In this section you’ll see how to use command-line
    arguments, JVM properties, and environment variables to configure a cloud native
    application without rebuilding it. Figure 4.6 illustrates how the precedence rules
    work for overriding a Spring property.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 15-Factor 方法提倡在环境中存储配置，Spring Boot 提供了多种实现方式。你可以使用优先级较高的属性源来覆盖默认值，具体取决于应用程序部署的位置。在本节中，你将了解如何使用命令行参数、JVM
    属性和环境变量来配置云原生应用程序，而无需重新构建它。图 4.6 展示了如何根据优先级规则覆盖 Spring 属性。
- en: '![04-06](../Images/04-06.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![04-06](../Images/04-06.png)'
- en: Figure 4.6 Spring Boot evaluates all property sources according to a precedence
    list. In the end, each property will have the value defined from the source with
    the highest precedence.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 展示了 Spring Boot 根据优先级列表评估所有属性源。最终，每个属性都将具有从最高优先级源定义的值。
- en: 'Let’s consider the Catalog Service application. First, you need to package
    the application as a JAR artifact. You can do so from a Terminal window, navigating
    to the project’s root folder and running the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑 Catalog Service 应用程序。首先，你需要将应用程序打包成一个 JAR 文件。你可以在终端窗口中这样做，导航到项目的根文件夹，并运行以下命令：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We’re not relying on Gradle to run the application this time because I want
    to demonstrate how you can change the application configuration while using the
    same immutable JAR artifact (that is, changing the configuration without rebuilding
    the application). You can run it as a standard Java application:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们不依赖 Gradle 来运行应用程序，因为我想要演示如何在使用相同的不可变 JAR 艺术品（即，不重新构建应用程序的情况下）更改应用程序配置。你可以将其作为标准
    Java 应用程序运行：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You haven’t overridden any properties yet, so the root endpoint will return
    the polar.greeting value defined in the application.yml file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你还没有覆盖任何属性，因此根端点将返回在 application.yml 文件中定义的 polar.greeting 值：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the following sections you’ll see how to provide a different value for the
    polar .greeting property. Remember to terminate the Java process (Ctrl-C) before
    moving on to new examples.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，你将了解如何为 polar .greeting 属性提供不同的值。记住在进入新的示例之前终止 Java 进程（Ctrl-C）。
- en: 4.2.1 Configuring an application through command-line arguments
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 通过命令行参数配置应用程序
- en: 'By default, Spring Boot converts any command-line argument to a property key/value
    pair and includes it in the Environment object. In a production application, that
    is the property source with the highest precedence. Using the same JAR you built
    earlier, you can specify a command-line argument to customize the application
    configuration:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Boot 将任何命令行参数转换为属性键/值对，并将其包含在 Environment 对象中。在生产应用程序中，这是具有最高优先级的属性源。使用你之前构建的相同
    JAR，你可以指定一个命令行参数来自定义应用程序配置：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The command-line argument has the same name as the Spring property, prefixed
    with the familiar -- for CLI arguments. This time the application will use the
    message defined in the command-line argument, since it takes precedence over property
    files:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数具有与 Spring 属性相同的名称，前面带有熟悉的 -- 用于 CLI 参数。这次应用程序将使用命令行参数中定义的消息，因为它比属性文件具有更高的优先级：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 4.2.2 Configuring an application through JVM system properties
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 通过 JVM 系统属性配置应用程序
- en: 'JVM system properties can override Spring properties much like command-line
    arguments, but they have a lower priority. It’s all part of externalizing the
    configuration, so you don’t need to build a new JAR artifact—you can still use
    the one packaged earlier. Terminate the Java process from the previous example
    (Ctrl-C) and run the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 系统属性可以像命令行参数一样覆盖 Spring 属性，但它们的优先级较低。这全部是外部化配置的一部分，因此你不需要构建新的 JAR 艺术品——你仍然可以使用之前打包的那个。终止上一个示例中的
    Java 进程（Ctrl-C），然后运行以下命令：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The JVM system property has the same name as the Spring property, prefixed
    with the usual -D for JVM arguments. This time the application will use the message
    defined as a JVM system property, since it takes precedence over property files:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 系统属性具有与 Spring 属性相同的名称，前面带有 JVM 参数的常规 -D。这次应用程序将使用作为 JVM 系统属性定义的消息，因为它比属性文件具有更高的优先级：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What if you specify both a JVM system property and a CLI argument? The precedence
    rules will ensure Spring uses the value specified as a command-line argument,
    since it takes precedence over JVM properties.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了 JVM 系统属性和 CLI 参数，会发生什么？优先级规则将确保 Spring 使用作为命令行参数指定的值，因为它比 JVM 属性具有更高的优先级。
- en: 'Once again, terminate the previous Java process (Ctrl-C) and run the following
    command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 再次终止上一个 Java 进程（Ctrl-C）并运行以下命令：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The result, as you can imagine, will be the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，结果将是以下内容：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both CLI arguments and JVM properties let you externalize the configuration
    and keep the application build immutable. However, they require different commands
    to run the application, which might result in errors at deployment time. A better
    approach is using environment variables, as recommended by the 15-Factor methodology.
    Before moving on to the next section, terminate the current Java process (Ctrl-C).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 参数和 JVM 属性都允许你外部化配置并保持应用程序构建不可变。然而，它们需要不同的命令来运行应用程序，这可能会导致部署时出现错误。一个更好的方法是使用环境变量，这是
    15-Factor 方法论所推荐的。在进入下一节之前，终止当前的 Java 进程（Ctrl-C）。
- en: 4.2.3 Configuring an application through environment variables
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 通过环境变量配置应用程序
- en: Environment variables defined in the operating system are commonly used for
    externalized configuration, and they are the recommended option according to the
    15-Factor methodology. One of the advantages of environment variables is that
    every operating system supports them, making them portable across any environment.
    Furthermore, most programming languages provide features for accessing environment
    variables. For example, in Java, you can do that by calling the System.getenv()
    method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统中定义的环境变量通常用于外部化配置，并且根据 15-Factor 方法论，它们是推荐选项。环境变量的一个优点是每个操作系统都支持它们，这使得它们可以在任何环境中移植。此外，大多数编程语言都提供了访问环境变量的功能。例如，在
    Java 中，你可以通过调用 System.getenv() 方法来实现。
- en: In Spring, you are not required to read environment variables from the surrounding
    system explicitly. Spring automatically reads them during the startup phase and
    adds them to the Spring Environment object, making them accessible, just like
    any other property. For example, if you run a Spring application in an environment
    where the MY_ENV_VAR variable is defined, you can access its value either from
    the Environment interface or using the @Value annotation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring 中，你不需要明确地从周围系统中读取环境变量。Spring 在启动阶段自动读取它们，并将它们添加到 Spring 环境对象中，使它们可访问，就像任何其他属性一样。例如，如果你在一个定义了
    MY_ENV_VAR 变量的环境中运行 Spring 应用程序，你可以通过环境接口或使用 @Value 注解来访问其值。
- en: On top of that, Spring Boot extends the Spring Framework functionality by allowing
    you to use environment variables to override Spring properties automatically.
    For command-line arguments and JVM system properties, you used the same naming
    convention as the Spring property. However, environment variables have some naming
    constraints dictated by the operating system. For example, on Linux, the common
    syntax consists of having all capital letters and words separated by an underscore.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Spring Boot 通过允许你使用环境变量来自动覆盖 Spring 属性来扩展 Spring 框架的功能。对于命令行参数和 JVM 系统属性，你使用了与
    Spring 属性相同的命名约定。然而，环境变量有一些由操作系统规定的命名约束。例如，在 Linux 上，常见的语法是全部使用大写字母，单词之间用下划线分隔。
- en: You can turn a Spring property key into an environment variable by making all
    the letters uppercase and replacing any dot or dash with an underscore. Spring
    Boot will map it correctly to the internal syntax. For example, a POLAR_GREETING
    environment variable is recognized as the polar.greeting property. This feature
    is called *relaxed binding*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将所有字母转换为大写，并用下划线替换任何点或破折号，将 Spring 属性键转换为环境变量。Spring Boot 将正确地将其映射到内部语法。例如，POLAR_GREETING
    环境变量被识别为 polar.greeting 属性。这个特性被称为 *宽松绑定*。
- en: 'In the Catalog Service application, you can override the polar.greeting property
    with the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录服务应用程序中，你可以使用以下命令覆盖 polar.greeting 属性：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip On Windows, you can achieve the same result by running $env:POLAR_ GREETING="Welcome
    to the catalog from ENV"; java -jar build/libs/ catalog-service-0.0.1-SNAPSHOT.jar
    from a PowerShell console.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在 Windows 上，你可以在 PowerShell 控制台中运行 $env:POLAR_GREETING="Welcome to the catalog
    from ENV"; java -jar build/libs/catalog-service-0.0.1-SNAPSHOT.jar 来达到相同的结果。
- en: 'During the startup phase of Catalog Service, Spring Boot will read the variables
    defined in the surrounding environment, recognize that POLAR_GREETING can be mapped
    to the polar.greeting property, and store its value in the Spring Environment
    object, overriding the value defined in application.yml. The result will be the
    following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录服务启动阶段，Spring Boot 将读取周围环境中定义的变量，识别 POLAR_GREETING 可以映射到 polar.greeting 属性，并将其值存储在
    Spring 环境对象中，覆盖 application.yml 中定义的值。结果如下：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After testing the application, stop the process with Ctrl-C. If you ran the
    application from Windows PowerShell, remember to unset the environment variable
    with Remove-Item Env:\POLAR_GREETING.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试完应用程序后，使用 Ctrl-C 停止进程。如果你是从 Windows PowerShell 运行应用程序，请记住使用 Remove-Item Env:\POLAR_GREETING
    来取消设置环境变量。
- en: When you use environment variables for storing configuration data, you don’t
    have to change the command to run your application (as you did for CLI arguments
    and JVM properties). Spring will automatically read environment variables from
    the context where it’s deployed. This approach is less error-prone and fragile
    than using CLI arguments or JVM system properties.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用环境变量来存储配置数据时，你不需要更改运行应用程序的命令（就像你为 CLI 参数和 JVM 属性所做的那样）。Spring 将自动从其部署的上下文中读取环境变量。这种方法比使用
    CLI 参数或 JVM 系统属性更不易出错且更稳定。
- en: Note You can use environment variables to define configuration values that depend
    on the infrastructure or platform where the application is deployed, such as profiles,
    port numbers, IP addresses, and URLs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以使用环境变量来定义依赖于应用程序部署的基础设施或平台的配置值，例如配置文件、端口号、IP地址和URL。
- en: Environment variables work seamlessly on virtual machines, OCI containers, and
    Kubernetes clusters. However, they might not be enough. In the next section, I’ll
    go through some of the issues affecting environment variables and how Spring Cloud
    Config can help address them.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量在虚拟机、OCI容器和Kubernetes集群上无缝工作。然而，它们可能不足以满足需求。在下一节中，我将介绍影响环境变量的某些问题以及Spring
    Cloud Config如何帮助解决这些问题。
- en: 4.3 Centralized configuration management with Spring Cloud Config Server
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 使用Spring Cloud Config Server进行集中式配置管理
- en: 'With environment variables, you can externalize your application’s configuration
    and follow the 15-Factor methodology. However, there are some issues they cannot
    handle:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用环境变量，你可以将应用程序的配置外部化，并遵循15-Factor方法。然而，它们无法处理一些问题：
- en: Configuration data is as important as the application code, so it should be
    handled with the same care and attention, starting from its persistence. Where
    should you store configuration data?
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置数据与应用程序代码一样重要，因此它应该从持久化开始就得到同样的关注和重视。你应该在哪里存储配置数据？
- en: Environment variables don’t provide granular access control features. How can
    you control access to configuration data?
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量不提供细粒度的访问控制功能。你如何控制对配置数据的访问？
- en: Configuration data will evolve and require changes, just like application code.
    How should you keep track of the revisions to configuration data? How should you
    audit the configuration used in a release?
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置数据将像应用程序代码一样演变并需要更改。你应该如何跟踪配置数据的修订？你应该如何审计发布中使用的配置？
- en: After changing your configuration data, how can you make your application read
    it at runtime without requiring a full restart?
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在更改配置数据后，你如何使应用程序在运行时读取它，而无需完全重启？
- en: When the number of application instances increases, it can be challenging to
    handle configuration in a distributed fashion for each instance. How can you overcome
    such challenges?
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序实例的数量增加时，以分布式方式为每个实例处理配置可能具有挑战性。你如何克服这些挑战？
- en: Neither Spring Boot properties nor environment variables support configuration
    encryption, so you can’t safely store passwords. How should you manage secrets?
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot属性和环境变量都不支持配置加密，因此你不能安全地存储密码。你应该如何管理机密？
- en: The Spring ecosystem offers many options to address those issues. We can categorize
    them into three groups.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Spring生态系统提供了许多选项来解决这些问题。我们可以将它们分为三类。
- en: '*Configuration services*—The Spring Cloud project provides modules you can
    use to run your own configuration services and configure your Spring Boot applications.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置服务*——Spring Cloud项目提供了模块，你可以使用它们来运行自己的配置服务并配置你的Spring Boot应用程序。'
- en: Spring Cloud Alibaba provides a configuration service using Alibaba Nacos as
    the data store.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Alibaba 使用 Alibaba Nacos 作为数据存储提供配置服务。
- en: Spring Cloud Config provides a configuration service backed by a pluggable data
    source, such as a Git repository, a data store, or HashiCorp Vault.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Config 提供了一个配置服务，该服务由可插拔的数据源支持，例如Git仓库、数据存储或HashiCorp Vault。
- en: Spring Cloud Consul provides a configuration service using HashiCorp Consul
    as the data store.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Consul 使用 HashiCorp Consul 作为数据存储提供配置服务。
- en: Spring Cloud Vault provides a configuration service using HashiCorp Vault as
    the data store.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Vault 使用 HashiCorp Vault 作为数据存储提供配置服务。
- en: Spring Cloud Zookeeper provides a configuration service using Apache Zookeeper
    as the data store.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Zookeeper 使用 Apache Zookeeper 作为数据存储提供配置服务。
- en: '*Cloud vendor services*—If you run your applications on a platform provided
    by a cloud vendor, you might consider using one of their configuration services.
    Spring Cloud provides integration with the main cloud vendor configuration services
    that you can use to configure your Spring Boot applications.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*云服务提供商服务*——如果你在云服务提供商提供的平台上运行应用程序，你可能考虑使用他们提供的配置服务之一。Spring Cloud 提供了与主要云服务提供商配置服务的集成，你可以使用它来配置你的
    Spring Boot 应用程序。'
- en: Spring Cloud AWS provides integration with AWS Parameter Store and AWS Secrets
    Manager.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud AWS 提供了与 AWS Parameter Store 和 AWS Secrets Manager 的集成。
- en: Spring Cloud Azure provides integration with Azure Key Vault.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Azure 提供了与 Azure Key Vault 的集成。
- en: Spring Cloud GCP provides integration with GCP Secret Manager.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud GCP提供了与GCP Secret Manager的集成。
- en: '*Cloud platform services*—When running your applications on a Kubernetes platform,
    you can seamlessly use ConfigMaps and Secrets to configure Spring Boot.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*云平台服务*——当在Kubernetes平台上运行应用程序时，您可以使用ConfigMaps和Secrets无缝地配置Spring Boot。'
- en: This section will show you how to set up a centralized configuration server
    with Spring Cloud Config that’s responsible for delivering configuration data
    stored in a Git repository to all applications. Chapter 14 will cover more advanced
    configuration topics, including secrets management and Kubernetes features like
    ConfigMaps and Secrets. Many of the features and patterns you’ll use with Spring
    Cloud Config are easily applicable to the other solutions involving configuration
    services and cloud vendor services.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示如何使用Spring Cloud Config设置一个集中配置服务器，该服务器负责将存储在Git仓库中的配置数据传递给所有应用程序。第14章将涵盖更高级的配置主题，包括密钥管理以及Kubernetes功能，如ConfigMaps和Secrets。您将使用Spring
    Cloud Config的许多功能和模式很容易地应用于涉及配置服务和云供应商服务的其他解决方案。
- en: Note Your choice of configuration service will depend on your infrastructure
    and requirements. For example, suppose you’re running your workloads on Azure
    already, and you need a GUI to manage configuration data. In that case, it might
    make sense to use Azure Key Vault rather than running a configuration service
    yourself. If you want to version-control your configuration data with Git, Spring
    Cloud Config or Kubernetes ConfigMaps and Secrets would be a better choice. You
    might even compromise and use a managed Spring Cloud Config service offered by
    vendors like Azure or VMware Tanzu.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您选择的配置服务将取决于您的基础设施和需求。例如，假设您已经在Azure上运行工作负载，并且需要一个图形用户界面来管理配置数据。在这种情况下，使用Azure
    Key Vault而不是自己运行配置服务可能更有意义。如果您想使用Git来版本控制配置数据，Spring Cloud Config或Kubernetes ConfigMaps和Secrets将是一个更好的选择。您甚至可以妥协，使用由Azure或VMware
    Tanzu等供应商提供的托管Spring Cloud Config服务。
- en: 'The idea of centralized configuration is built around two main components:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 集中配置的想法围绕两个主要组件构建：
- en: A data store for configuration data, providing persistence, versioning, and
    possibly access control
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置数据的数据存储，提供持久性、版本控制和可能访问控制
- en: A server sitting on top of the data store to manage configuration data and serve
    it to multiple applications
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位于数据存储之上以管理配置数据并将其提供给多个应用程序的服务器
- en: Imagine having many applications deployed in different environments. A configuration
    server could manage configuration data for all of them from a centralized place,
    and that configuration data might be stored in different ways. For example, you
    could use a dedicated Git repository for storing non-sensitive data and use HashiCorp
    Vault to store your secrets. No matter how the data is stored, a configuration
    server will deliver it to different applications through a unified interface.
    Figure 4.7 shows how centralized configuration works.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在多个不同的环境中部署了许多应用程序。一个配置服务器可以从集中位置管理所有这些应用程序的配置数据，并且这些配置数据可能以不同的方式存储。例如，您可以使用专门的Git仓库来存储非敏感数据，并使用HashiCorp
    Vault来存储您的机密。无论数据如何存储，配置服务器将通过统一的接口将其传递给不同的应用程序。图4.7显示了集中配置的工作方式。
- en: '![04-07](../Images/04-07.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![04-07](../Images/04-07.png)'
- en: Figure 4.7 A centralized configuration server manages external properties for
    many applications across all environments.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 一个集中配置服务器管理所有环境中许多应用程序的外部属性。
- en: It’s clear from figure 4.7 that the configuration server becomes a backing service
    for all the applications, which means it’s at risk of being a single point of
    failure. If it’s suddenly unavailable, all the applications will probably fail
    to start up. This risk can be easily mitigated by scaling the config server, as
    you would with other applications requiring high availability. When using a configuration
    server, it’s fundamental to deploy at least two replicas.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从图4.7中可以看出，配置服务器成为所有应用程序的后备服务，这意味着它可能存在单点故障的风险。如果它突然不可用，所有应用程序可能都无法启动。这种风险可以通过扩展配置服务器来轻松缓解，就像您对需要高可用性的其他应用程序所做的那样。在使用配置服务器时，至少部署两个副本是基本的。
- en: Note You can use a centralized configuration server for configuration data that
    doesn’t depend on the specific infrastructure or deployment platform, such as
    credentials, feature flags, URLs to third-party services, thread pools, and timeouts.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以使用集中式配置服务器来存储不依赖于特定基础设施或部署平台的配置数据，例如凭证、功能标志、第三方服务的 URL、线程池和超时。
- en: We’ll use Spring Cloud Config Server to set up a centralized configuration server
    for the Polar Bookshop system. The project also provides a client library (Spring
    Cloud Config Client) that you can use to integrate Spring Boot applications with
    the config server.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Spring Cloud Config Server 为 Polar Bookshop 系统设置一个集中式配置服务器。该项目还提供了一个客户端库（Spring
    Cloud Config Client），您可以使用它将 Spring Boot 应用程序与配置服务器集成。
- en: Let’s start by defining a repository for storing configuration data.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一个用于存储配置数据的仓库。
- en: 4.3.1 Using Git to store your configuration data
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 使用 Git 存储您的配置数据
- en: The config server will be responsible for providing configuration data to Spring
    applications. Before setting that up, though, we need a way to store and keep
    track of that data. Spring Cloud Config Server integrates with many different
    backend solutions to store configuration data. One of the most common choices
    is a Git repository.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务器将负责为 Spring 应用程序提供配置数据。在设置之前，我们需要一种存储和跟踪这些数据的方法。Spring Cloud Config Server
    与许多不同的后端解决方案集成，以存储配置数据。最常见的选项之一是 Git 仓库。
- en: First, create a new config-repo Git repository (for the final result, you can
    refer to Chapter04/04-end/config-repo). The repository can be local or remote,
    but for this example I recommend initializing a remote one on GitHub, just like
    you did for the application repositories. I’m using main as the default branch
    name.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的 config-repo Git 仓库（对于最终结果，您可以参考第04章/04-end/config-repo）。该仓库可以是本地的或远程的，但在这个例子中，我建议在
    GitHub 上初始化一个远程仓库，就像您为应用程序仓库所做的那样。我使用 main 作为默认分支名称。
- en: Inside the config repo, you can store properties directly in Spring format as
    *.properties or *.yml files.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置仓库内部，您可以直接以 *.properties 或 *.yml 文件格式存储属性。
- en: Continuing with the Catalog Service example, let’s define an external property
    for the welcome message. Navigate to the config-repo folder and create a catalog-service.yml
    file. Then define a value for the polar.greeting property used by the Catalog
    Service.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用目录服务示例，让我们定义一个用于欢迎信息的外部属性。导航到 config-repo 文件夹，并创建一个 catalog-service.yml
    文件。然后为 Catalog 服务使用的 polar.greeting 属性定义一个值。
- en: Listing 4.8 Defining a new message for when the config server is used
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.8 定义当使用配置服务器时的新消息
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, create a catalog-service-prod.yml file, and define a different value for
    the polar.greeting property to be used only when the prod profile is active.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个 catalog-service-prod.yml 文件，并为 polar.greeting 属性定义一个不同的值，仅在 prod 配置文件活跃时使用。
- en: Listing 4.9 Defining a new message for when the prod profile is active
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.9 定义当 prod 配置文件活跃时的新消息
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, commit and push your changes to the remote repository.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将您的更改提交并推送到远程仓库。
- en: 'How does Spring Cloud Config resolve the correct configuration data for each
    application? How should you organize the repository to host properties for multiple
    applications? The library relies on three parameters to identify which property
    file to use to configure a specific application:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config 如何为每个应用程序解析正确的配置数据？您应该如何组织仓库以托管多个应用程序的属性？该库依赖于三个参数来识别用于配置特定应用程序的属性文件：
- en: '{application}—The name of the application as defined by the spring .application.name
    property.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '{application}—由 spring.application.name 属性定义的应用程序名称。'
- en: '{profile}—One of the active profiles defined by the spring.profiles.active
    property.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '{profile}—由 spring.profiles.active 属性定义的活跃配置文件之一。'
- en: '{label}—A discriminator defined by the specific configuration data repository.
    In the case of Git, it can be a tag, a branch name, or a commit ID. It’s useful
    for identifying a versioned set of config files.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '{label}—由特定的配置数据仓库定义的区分器。在 Git 的情况下，它可以是标签、分支名称或提交 ID。它对于识别配置文件的版本化集合很有用。'
- en: 'Depending on your needs, you can organize the folder structure using different
    combinations, such as these:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的需求，您可以使用不同的组合来组织文件夹结构，例如这些：
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For each application, you can either use property files named after the application
    itself and placed in the root folder (e.g., /catalog-service.yml or /catalog-service-prod.yml)
    or use the default naming and put them in a subfolder named after the application
    (e.g., /catalog-service/application.yml or /catalog-service/application-prod.yml).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个应用程序，你可以使用以应用程序本身命名的属性文件，并将其放置在根目录中（例如，/catalog-service.yml 或 /catalog-service-prod.yml），或者使用默认命名并将它们放在以应用程序命名的子目录中（例如，/catalog-service/application.yml
    或 /catalog-service/application-prod.yml）。
- en: You can also put application.yml or application-{profile}.yml files in the root
    folder to define default values for all applications. They can be used as a fallback
    whenever there is no more specific property source. Spring Cloud Config Server
    will always return the properties from the most specific path, using the application
    name, active profiles, and Git labels.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 application.yml 或 application-{profile}.yml 文件放在根目录中，为所有应用程序定义默认值。当没有更具体的属性源时，它们可以用作后备。Spring
    Cloud Config Server 将始终返回最具体路径的属性，使用应用程序名称、活动配置文件和 Git 标签。
- en: The *label* concept is particularly interesting when using Git as the backend
    for the config server. For example, you could create long-lived branches of your
    config repo for different environments or short-lived branches while testing specific
    features. Spring Cloud Config Server can use the label information to return the
    correct configuration data from the right Git branch, tag, or commit ID.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Git 作为配置服务后端时，*标签* 概念特别有趣。例如，你可以为不同的环境创建配置仓库的长久分支，或者在测试特定功能时创建短暂分支。Spring
    Cloud Config Server 可以使用标签信息从正确的 Git 分支、标签或提交 ID 返回正确的配置数据。
- en: Now that you have a Git repository in place for your configuration data, it’s
    time to set up a config server to manage them.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为配置数据设置了一个 Git 仓库，是时候设置一个配置服务器来管理它们了。
- en: 4.3.2 Setting up a configuration server
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 设置配置服务器
- en: Spring Cloud Config Server is a project that lets you set up a configuration
    server with minimal effort. It’s a standard Spring Boot application with specific
    properties that enable the configuration server functionality and the Git repository
    as the configuration data backend. The Polar Bookshop system will use this server
    to provide configuration to the Catalog Service application. Figure 4.8 illustrates
    the architecture of the solution.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config Server 是一个项目，让你以最小的努力设置配置服务器。它是一个具有特定属性的标准化 Spring Boot
    应用程序，这些属性启用了配置服务器功能以及将 Git 仓库作为配置数据后端。Polar Bookshop 系统将使用此服务器为 Catalog Service
    应用程序提供配置。图 4.8 展示了解决方案的架构。
- en: '![04-08](../Images/04-08.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![04-08](../Images/04-08.png)'
- en: Figure 4.8 A centralized configuration server, backed by a Git repository, provides
    configuration to the Catalog Service application.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 由 Git 仓库支持的集中式配置服务器为 Catalog Service 应用程序提供配置。
- en: Now, on to the code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看代码。
- en: Bootstrapping the project
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 项目引导
- en: The Polar Bookshop system needs a Config Service application to provide centralized
    configuration. You can initialize the project from Spring Initializr ([https://start.spring.io/](https://start.spring.io/))
    and store the result in a new config-service Git repository. The parameters for
    the initialization are shown in figure 4.9.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Polar Bookshop 系统需要一个配置服务应用程序来提供集中式配置。你可以从 Spring Initializr ([https://start.spring.io/](https://start.spring.io/))
    初始化项目，并将结果存储在一个新的 config-service Git 仓库中。初始化的参数如图 4.9 所示。
- en: '![04-09](../Images/04-09.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![04-09](../Images/04-09.png)'
- en: Figure 4.9 The parameters for initializing the Config Service project from Spring
    Initializr
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 从 Spring Initializr 初始化 Config Service 项目的参数
- en: Tip You may prefer to avoid manually generating the project through the Spring
    Initializr website. In the begin folder for this chapter, you can find a curl
    command that you can run in a Terminal window to download a zip file containing
    all the code you need to get started.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：你可能更喜欢避免通过 Spring Initializr 网站手动生成项目。在本章的开始文件夹中，你可以找到一个可以在终端窗口中运行的 curl
    命令，用于下载包含所有启动所需代码的 zip 文件。
- en: In the generated build.gradle file, you can see how the management of Spring
    Cloud dependencies works differently than for Spring Boot. All Spring Cloud projects
    follow an independent release train that relies on a bill of materials (BOM) to
    manage all the dependencies. Spring Cloud release trains are named after a year
    (for example, 2021.0.3) rather than adopting a semantic version strategy (for
    example, the Spring Boot version is 2.7.3).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的 build.gradle 文件中，你可以看到 Spring Cloud 依赖项的管理方式与 Spring Boot 不同。所有 Spring
    Cloud 项目都遵循一个独立的发布列车，该列车依赖于一个物料清单（BOM）来管理所有依赖项。Spring Cloud 发布列车以年份命名（例如，2021.0.3），而不是采用语义版本策略（例如，Spring
    Boot 版本是 2.7.3）。
- en: Listing 4.10 The Gradle configuration for Config Service
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 Config Service 的 Gradle 配置
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Defines the Spring Cloud version to use
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义要使用的 Spring Cloud 版本
- en: ❷ BOM for Spring Cloud dependency management
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Spring Cloud 依赖项管理的 BOM
- en: 'These are the main dependencies:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是主要的依赖项：
- en: '*Spring Cloud Config Server* (org.springframework.cloud:spring-cloud-config-server)—Provides
    libraries and utilities to build a configuration server on top of Spring Web.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Cloud Config Server*（org.springframework.cloud:spring-cloud-config-server）—提供库和实用工具，在
    Spring Web 上构建配置服务器。'
- en: '*Spring Boot Test* (org.springframework.boot:spring-boot-starter-test)—Provides
    several libraries and utilities to test applications, including Spring Test, JUnit,
    AssertJ, and Mockito. It’s automatically included in every Spring Boot project.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Boot Test*（org.springframework.boot:spring-boot-starter-test）—提供了一些库和实用工具来测试应用程序，包括
    Spring Test、JUnit、AssertJ 和 Mockito。它自动包含在每一个 Spring Boot 项目中。'
- en: Enabling the configuration server
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 启用配置服务器
- en: Turning the project you initialized earlier into a functioning configuration
    server doesn’t require too many steps. The only thing you need to do in Java is
    add the @EnableConfigServer annotation on a configuration class, such as ConfigServiceApplication.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 将你之前初始化的项目转变为一个功能性的配置服务器不需要太多步骤。在 Java 中，你只需要在配置类（如 ConfigServiceApplication）上添加
    @EnableConfigServer 注解。
- en: Listing 4.11 Enabling configuration server in Spring Boot
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.11 在 Spring Boot 中启用配置服务器
- en: '[PRE26]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Activates the configuration server implementation in the Spring Boot application
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 Spring Boot 应用程序中激活配置服务器实现
- en: That was it on the Java side.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Java 端就到这里了。
- en: Configuring the configuration server
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 配置配置服务器
- en: The next step is configuring the behavior of the config server. Yes, that’s
    right. Even a configuration server needs configuration! First of all, Spring Cloud
    Config Server runs on an embedded Tomcat server, so you can configure connection
    timeouts and thread pools as you did for Catalog Service.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是配置配置服务器的行为。没错，即使是配置服务器也需要配置！首先，Spring Cloud Config Server 在一个嵌入的 Tomcat
    服务器上运行，因此你可以像为 Catalog Service 配置的那样配置连接超时和线程池。
- en: You previously initialized a Git repository to host configuration data, so you
    should now instruct Spring Cloud Config Server where to find it. You can do so
    in an application.yml file located in the src/main/resources path of your Config
    Service project (rename the autogenerated application.properties file as application.yml).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前初始化了一个 Git 仓库来托管配置数据，因此你现在应该指导 Spring Cloud Config Server 在哪里找到它。你可以在位于 Config
    Service 项目 src/main/resources 路径的应用程序.yml 文件中这样做（将自动生成的 application.properties
    文件重命名为 application.yml）。
- en: The spring.cloud.config.server.git.uri property should point to where you defined
    the config repo. If you followed along with what I did, it will be on GitHub,
    and the default branch will be called main. You can configure which branch the
    config server should consider by default by setting the spring.cloud.config.server.git
    .default-label property. Remember that, when using Git repositories, the label
    concept is an abstraction over Git branches, tags, or commit IDs.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: spring.cloud.config.server.git.uri 属性应指向你定义的配置仓库位置。如果你跟随我做的步骤，它将在 GitHub 上，默认分支将被称为
    main。你可以通过设置 spring.cloud.config.server.git .default-label 属性来配置配置服务器默认应考虑的分支。记住，当使用
    Git 仓库时，标签概念是 Git 分支、标签或提交 ID 的抽象。
- en: Listing 4.12 Configuring integration between config server and config repo
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.12 配置配置服务器和配置仓库之间的集成
- en: '[PRE27]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ The port that the Config Service application will listen on
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Config Service 应用程序将监听的端口
- en: ❷ A name for the current application
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当前应用程序的名称
- en: ❸ The URL to the remote Git repository to use as the configuration data backend.
    For example, https://github.com/ PolarBookshop/config-repo.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 用于配置数据后端的远程 Git 仓库的 URL。例如，https://github.com/PolarBookshop/config-repo。
- en: ❹ By default, the server will return configuration data from the “main” branch.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 默认情况下，服务器将从“main”分支返回配置数据。
- en: Warning The configuration I used for Config Service assumes the config repo
    is publicly available on GitHub. When you use private repositories (which is often
    true for real-world applications), you need to specify how to authenticate with
    the code repository provider by using additional configuration properties. For
    more information, refer to the official Spring Cloud Config documentation ([https://spring.io/projects/spring-cloud-config](https://spring.io/projects/spring-cloud-config)).
    I’ll further discuss handling credentials in chapter 14\.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：我用于配置服务的配置假设配置仓库在GitHub上公开可用。当您使用私有仓库（这在实际应用中通常是真实的）时，您需要通过使用额外的配置属性来指定如何通过代码仓库提供商进行身份验证。有关更多信息，请参阅官方Spring
    Cloud Config文档（[https://spring.io/projects/spring-cloud-config](https://spring.io/projects/spring-cloud-config)）。我将在第14章进一步讨论处理凭证的问题。
- en: 4.3.3 Making the configuration server resilient
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 使配置服务器具有弹性
- en: The Config Service might become a single point of failure in your system. If
    all the applications rely on it to fetch configuration data, you need to ensure
    it’s highly available. The first step toward that goal is deploying multiple instances
    of Config Service in a production environment. If one of them stops working for
    some reason, another replica can provide the required configuration. In chapter
    7, you’ll learn more about scaling applications and how to make that work in Kubernetes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务可能会成为您系统中的单点故障。如果所有应用程序都依赖于它来获取配置数据，您需要确保它具有高可用性。实现这一目标的第一步是在生产环境中部署多个配置服务实例。如果其中一个因某种原因停止工作，另一个副本可以提供所需的配置。在第7章中，您将了解更多关于扩展应用程序以及如何在Kubernetes中实现这一点的内容。
- en: However, scaling the Config Service is not enough. Since it’s using a remote
    Git repository as the configuration data backend, you’ll need to make that interaction
    more resilient too. First, you can define a timeout to prevent the config server
    from waiting too long to establish a connection with the remote repository. You
    can do so with the spring.cloud.config.server.git.timeout property.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅扩展配置服务是不够的。由于它使用远程Git仓库作为配置数据后端，您还需要使这种交互更加弹性。首先，您可以定义一个超时时间，以防止配置服务器等待太长时间与远程仓库建立连接。您可以通过设置spring.cloud.config.server.git.timeout属性来实现这一点。
- en: Spring Cloud Config is implemented to clone the remote repository locally upon
    the first request for configuration data. I recommend using the spring.cloud.config
    .server.git.clone-on-start property so that the repo clone happens at startup.
    Even though it makes the startup phase a bit slower, it makes your deployment
    fail faster if there’s any difficulty communicating with the remote repository,
    rather than waiting for the first request to find out that something is wrong.
    Also, it makes the first request from a client faster.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config在首次请求配置数据时会在本地克隆远程仓库。我建议使用spring.cloud.config.server.git.clone-on-start属性，以便在启动时进行仓库克隆。尽管这会使启动阶段稍微慢一些，但如果与远程仓库通信有任何困难，它会使部署更快地失败，而不是等待第一次请求发现有问题。此外，它还会使客户端的第一次请求更快。
- en: The local copy of the repository improves the config server’s fault tolerance
    because it ensures it can return configuration data to the client applications
    even if the communication with the remote repository is temporarily failing (for
    example, if GitHub is down or there’s a problem with the network). However, if
    the config server hasn’t cloned the repository locally yet, there’s no fallback
    in place. That’s why it’s better to fail fast at startup and investigate the issue
    right away.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库的本地副本提高了配置服务器的容错能力，因为它确保即使在与远程仓库的通信暂时失败的情况下（例如，GitHub宕机或网络问题），它也能向客户端应用程序返回配置数据。然而，如果配置服务器尚未在本地克隆仓库，则没有设置回退机制。这就是为什么在启动时快速失败并立即调查问题会更好。
- en: When a local copy of the repository is created successfully, there’s a chance
    the local repo may get changed independently of the remote repo. You can ensure
    your config server always uses the same data that’s defined in the remote repository
    by setting the spring.cloud.config.server.git.force-pull property so that a fresh
    copy is pulled whenever the local copy is corrupted, and any local changes are
    discarded. By default, the local repository is cloned in a folder with a random
    name. If needed, you can control where it is cloned through the spring.cloud.config.server.git
    .basedir property. For Config Service, we’ll rely on the default behavior.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当成功创建本地仓库副本时，本地仓库可能会独立于远程仓库发生变化。你可以通过设置 spring.cloud.config.server.git.force-pull
    属性来确保配置服务器始终使用远程仓库中定义的相同数据，这样当本地副本损坏时，就会拉取一个新的副本，并且任何本地更改都会被丢弃。默认情况下，本地仓库是在一个随机命名的文件夹中克隆的。如果需要，你可以通过
    spring.cloud.config.server.git .basedir 属性来控制其克隆位置。对于配置服务，我们将依赖默认行为。
- en: You can update the application.yml file for the Config Service application as
    follows and make it more resilient to faults affecting interactions with the code
    repository service (in this case, GitHub).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式更新 Config Service 应用程序的应用程序.yml 文件，并使其对影响与代码仓库服务（在本例中为 GitHub）交互的故障具有更强的容错能力。
- en: Listing 4.13 Making Config Service more resilient
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 使配置服务更具容错能力
- en: '[PRE28]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Time limit to establish a connection with the remote repository
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 与远程仓库建立连接的时间限制
- en: ❷ Clones the remote repository locally on startup
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在启动时在本地克隆远程仓库
- en: ❸ Forces pulling the remote repository and discarding any local changes
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 强制拉取远程仓库并丢弃任何本地更改
- en: In the next section we’ll verify that Config Service is working correctly.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将验证配置服务是否正常工作。
- en: 4.3.4 Understanding the configuration server REST API
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.4 理解配置服务器 REST API
- en: 'Spring Cloud Config Server works seamlessly with Spring Boot applications,
    providing properties in their native formats through a REST API. You can try it
    out fairly easily. Build and run Config Service (./gradlew bootRun), open a Terminal
    window, and make an HTTP GET request to /catalog-service/default:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config Server 与 Spring Boot 应用程序无缝协作，通过 REST API 提供其原生格式的属性。你可以相当容易地尝试它。构建并运行
    Config Service（./gradlew bootRun），打开一个终端窗口，并对 /catalog-service/default 发起 HTTP
    GET 请求：
- en: '[PRE29]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The result is the configuration that’s returned when no Spring profile is active.
    You can try fetching the configuration for the scenario where the prod profile
    is active as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是当没有激活任何 Spring 配置文件时返回的配置。你可以尝试以下方式获取当 prod 配置文件激活时的配置：
- en: '[PRE30]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As shown in figure 4.10, the result is the configuration defined for the Catalog
    Service application in catalog-service.yml and catalog-service-prod.yml, where
    the latter takes precedence over the former because the prod profile is specified.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 4.10 所示，结果是为 Catalog Service 应用程序在 catalog-service.yml 和 catalog-service-prod.yml
    中定义的配置，其中后者优先于前者，因为指定了 prod 配置文件。
- en: '![04-10](../Images/04-10.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![04-10](../Images/04-10.png)'
- en: Figure 4.10 The configuration server exposes a REST API to fetch configuration
    data based on the application name, profile, and label. This image shows the result
    for the /catalog-service/prod endpoint.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 配置服务器通过 REST API 暴露了一个基于应用程序名称、配置文件和标签获取配置数据的接口。此图像显示了 /catalog-service/prod
    端点的结果。
- en: When you are done testing the application, stop its execution with Ctrl-C.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成应用程序的测试后，使用 Ctrl-C 停止其执行。
- en: 'Spring Cloud Config Server exposes properties through a series of endpoints
    using different combinations of the {application}, {profile}, and {label} parameters:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config Server 通过一系列端点使用不同的组合方式暴露属性，包括 {application}、{profile} 和
    {label} 参数：
- en: '[PRE31]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You won’t need to call these endpoints from your application when using Spring
    Cloud Config Client (it does that for you), but it’s useful to know how the server
    exposes configuration data. A configuration server built with Spring Cloud Config
    Server exposes a standard REST API that any application can access over a network.
    You can use the same server for applications built with other languages and frameworks
    and use the REST API directly.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Spring Cloud Config Client 时，你不需要从应用程序中调用这些端点（它为你做了），但了解服务器如何暴露配置数据是有用的。使用
    Spring Cloud Config Server 构建的配置服务器暴露了一个标准 REST API，任何应用程序都可以通过网络访问。你可以使用相同的服务器为使用其他语言和框架构建的应用程序提供服务，并直接使用
    REST API。
- en: In chapter 14, I’ll address more aspects of how to handle configuration. For
    example, Spring Cloud Config has a few features for encrypting properties containing
    secrets before storing them in a Git repository. Also, multiple backend solutions
    can be used as configuration data repositories, meaning that you could save all
    the non-sensitive properties in Git and use HashiCorp Vault to store secrets.
    Furthermore, the REST API itself should be protected, and I’ll talk about that
    as well. I will address all those critical aspects from a security point of view—considering
    these issues is necessary before deploying to production.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 14 章，我将讨论如何处理配置的更多方面。例如，Spring Cloud Config 在将属性存储在 Git 仓库之前，具有加密包含机密属性的功能。此外，可以使用多个后端解决方案作为配置数据仓库，这意味着您可以将所有非敏感属性保存到
    Git 中，并使用 HashiCorp Vault 来存储机密。此外，REST API 本身应该受到保护，我还会讨论这一点。我将从安全角度讨论所有这些关键方面——在部署到生产之前考虑这些问题是必要的。
- en: For now, let’s complete our solution and update Catalog Service to integrate
    with the Config Service application.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们完成我们的解决方案，并更新目录服务以集成配置服务应用程序。
- en: 4.4 Using a configuration server with Spring Cloud Config Client
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 使用 Spring Cloud Config Client 配置服务器
- en: The Config Service application built in the previous section is a server that
    exposes configuration through a REST API. In general, applications would interact
    with this API, but you can use Spring Cloud Config Client for Spring applications.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中构建的配置服务应用程序是一个通过 REST API 公开配置的服务器。通常，应用程序会与该 API 交互，但您可以使用 Spring Cloud
    Config Client 为 Spring 应用程序提供服务。
- en: This section will teach you how to use Spring Cloud Config Client and integrate
    Catalog Service with the config server. You’ll see how to make the interaction
    more robust and how to refresh the client’s configuration when new changes are
    pushed to the config repo.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将指导您如何使用 Spring Cloud Config Client 并将目录服务与配置服务器集成。您将了解如何使交互更加健壮，以及当新更改推送到配置仓库时如何刷新客户端的配置。
- en: 4.4.1 Setting up a configuration client
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 设置配置客户端
- en: The first thing you’ll need to do to integrate a Spring Boot application with
    a config server is add a new dependency to Spring Cloud Config Client. Update
    the build.gradle file for the Catalog Service project (catalog-service) as follows.
    Remember to refresh or reimport the Gradle dependencies after the new addition.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Spring Boot 应用程序与配置服务器集成，您首先需要为 Spring Cloud Config Client 添加一个新的依赖项。按照以下方式更新目录服务项目（catalog-service）的
    build.gradle 文件。请记住，在添加新内容后，刷新或重新导入 Gradle 依赖项。
- en: Listing 4.14 Adding dependency for Spring Cloud Config Client
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.14 为 Spring Cloud Config Client 添加依赖
- en: '[PRE32]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We now need to instruct Catalog Service to fetch its configuration from the
    Config Service. You can do that via the spring.config.import property by passing
    configserver: as the property value. You probably don’t want the config server
    running in your local environment when working with client applications like Catalog
    Service, and in that case you can make the interaction optional with the optional:
    prefix (optional:configserver:). If the config server is not running when you
    start Catalog Service, the application will log a warning, but it won’t stop working.
    Be careful not to make this optional in production, or you’ll risk using the wrong
    configuration.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们需要指示目录服务从配置服务获取其配置。您可以通过传递 configserver: 作为属性值通过 spring.config.import
    属性来实现。当与目录服务之类的客户端应用程序一起工作时，您可能不希望在本地环境中运行配置服务器，在这种情况下，您可以使用 optional: 前缀来使交互可选（可选：configserver:）。如果启动目录服务时配置服务器没有运行，应用程序将记录一条警告，但不会停止工作。请注意，在生产环境中不要使此选项可选，否则您可能会使用错误的配置。'
- en: Next, Catalog Service needs to know the URL to contact the Config Service. You
    have two options. Either you can add it to the spring.config.import property (optional:configserver:http://localhost:8888)
    or rely on the more specific spring .cloud.config.uri property. We’ll use the
    second option so we only need to change the URL value when deploying the application
    in different environments.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，目录服务需要知道联系配置服务的 URL。您有两个选择。您可以将它添加到 spring.config.import 属性中（可选：configserver:http://localhost:8888）或者依赖于更具体的
    spring.cloud.config.uri 属性。我们将使用第二种选项，这样我们只需要在部署应用程序到不同环境时更改 URL 值。
- en: Since the config server uses the application name to return the correct configuration
    data, you’ll also need to set the spring.application.name property to catalog-service.
    Remember the {application} parameter? That’s where the spring .application.name
    value is used.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 由于配置服务器使用应用程序名称来返回正确的配置数据，你还需要设置 spring.application.name 属性为 catalog-service。还记得
    {application} 参数吗？那里就是 spring .application.name 值被使用的地方。
- en: Open the application.yml file for your Catalog Service project and apply the
    following configuration.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 Catalog Service 项目的 application.yml 文件并应用以下配置。
- en: Listing 4.15 Instructing Catalog Service to get config from Config Service
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.15 指示 Catalog Service 从 Config Service 获取配置
- en: '[PRE33]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ The name of the application, used by the config server to filter the configuration
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 应用程序名称，由配置服务器用于过滤配置
- en: ❷ Imports configuration data from a config server when available
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当可用时从配置服务器导入配置数据
- en: ❸ The URL of the configuration server
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 配置服务器的 URL
- en: Let’s go ahead and verify that it works correctly. The Catalog Service application
    contains a polar.greeting property with the value “Welcome to the local book catalog!”
    When using a configuration server, the centralized properties take precedence
    over the local ones, so the value you defined in the config-repo repository will
    be used instead.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续验证它是否正确工作。Catalog Service 应用程序包含一个 polar.greeting 属性，其值为“欢迎使用本地图书目录！”当使用配置服务器时，集中式属性优先于本地属性，因此将使用在
    config-repo 仓库中定义的值。
- en: 'First, run Config Service (./gradlew bootRun). Then package Catalog Service
    as a JAR artifact (./gradlew bootJar) and run it as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，运行 Config Service（./gradlew bootRun）。然后打包 Catalog Service 为 JAR 文件（./gradlew
    bootJar）并按以下方式运行：
- en: '[PRE34]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, in another Terminal window, send a GET request to the root endpoint:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个终端窗口中，向根端点发送一个 GET 请求：
- en: '[PRE35]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As expected, the welcome message returned by the application is the one defined
    in the config-repo repository, specifically in the catalog-service.yml file.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，应用程序返回的欢迎消息是在 config-repo 仓库中定义的，具体在 catalog-service.yml 文件中。
- en: 'You can also try running the application with the prod profile enabled. Stop
    Catalog Service with Ctrl-C, and then start the application again with prod as
    an active profile:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以尝试启用 prod 配置文件运行应用程序。使用 Ctrl-C 停止 Catalog Service，然后以 prod 作为活动配置文件重新启动应用程序：
- en: '[PRE36]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The expected result is now the message defined in the catalog-service-prod.yml
    file in the config-repo repository:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的结果是现在使用 config-repo 仓库中 catalog-service-prod.yml 文件中定义的消息：
- en: '[PRE37]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once again, stop the previous application’s execution with Ctrl-C.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 Ctrl-C 停止之前应用的执行。
- en: The following section will cover how you can make the interaction between application
    and config server more fault-tolerant.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将介绍如何使应用程序与配置服务器之间的交互更加容错。
- en: 4.4.2 Making the configuration client resilient
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 使配置客户端更加健壮
- en: When the integration with the config server is not optional, the application
    fails to start up if it cannot contact a config server. If the server is up and
    running, you could still experience issues due to the distributed nature of the
    interaction. Therefore it’s a good idea to define some timeouts to make the application
    fail faster. You can use the spring.cloud.config.request-connect-timeout property
    to control the time limit for establishing a connection with the config server.
    The spring.cloud.config.request-read-timeout property lets you limit the time
    spent reading configuration data from the server.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当与配置服务器的集成不是可选的时，如果应用程序无法联系到配置服务器，它将无法启动。如果服务器正在运行，你可能会因为交互的分布式特性而遇到问题。因此，定义一些超时以使应用程序更快地失败是一个好主意。你可以使用
    spring.cloud.config.request-connect-timeout 属性来控制与配置服务器建立连接的时间限制。spring.cloud.config.request-read-timeout
    属性让你可以限制从服务器读取配置数据所花费的时间。
- en: Open the application.yml file for your Catalog Service project and apply the
    following configuration to make the interaction with Config Service more resilient.
    Once again, there’s no universal rule for setting up timeouts. Depending on your
    architecture and infrastructure characteristics, you might need to adjust these
    values.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 Catalog Service 项目的 application.yml 文件，并应用以下配置以使与 Config Service 的交互更加健壮。再次强调，设置超时没有通用的规则。根据你的架构和基础设施特性，你可能需要调整这些值。
- en: Listing 4.16 Making Spring Cloud Config Client more resilient
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.16 使 Spring Cloud Config 客户端更加健壮
- en: '[PRE38]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Timeout on waiting to connect to the config server (ms)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 等待连接到配置服务器的超时时间（毫秒）
- en: ❷ Timeout on waiting to read configuration data from the config server (ms)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 等待从配置服务器读取配置数据的超时时间（毫秒）
- en: Even if Config Service is replicated, there’s still a chance it will be temporarily
    unavailable when a client application like Catalog Service starts up. In that
    scenario, you can leverage the *retry* pattern and configure the application to
    try again to connect with the config server before giving up and failing. The
    retry implementation for Spring Cloud Config Client is based on Spring Retry,
    so you’ll need to add a new dependency to the build.gradle file for your Catalog
    Service project. Remember to refresh or reimport the Gradle dependencies after
    the new addition.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 即使配置服务被复制，当客户端应用程序（如目录服务）启动时，仍然有可能暂时不可用。在这种情况下，您可以利用 *重试* 模式，并配置应用程序在放弃并失败之前再次尝试连接到配置服务器。Spring
    Cloud Config 客户端的重试实现基于 Spring Retry，因此您需要将一个新的依赖项添加到目录服务项目的 build.gradle 文件中。请记住，在添加新内容后刷新或重新导入
    Gradle 依赖项。
- en: Listing 4.17 Adding dependency for Spring Retry in Catalog Service
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.17 在目录服务中添加 Spring Retry 依赖
- en: '[PRE39]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In chapter 8, I’ll explain the retry pattern in detail. For now, I’ll show you
    how to configure Catalog Service so that it retries connecting to Config Service
    a few times before failing (spring.cloud.config.retry.max-attempts). Each connection
    attempt is delayed according to an exponential backoff strategy, computed as the
    current delay multiplied by the value of the spring.cloud.config.retry.multiplier
    property. The initial delay is configured by spring.cloud.config.retry.initial-interval,
    and each delay cannot exceed the value of spring.cloud.config.retry.max-interval.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 章中，我将详细解释重试模式。现在，我将向您展示如何配置目录服务，使其在失败之前尝试连接到配置服务几次（spring.cloud.config.retry.max-attempts）。每次连接尝试都会根据指数退避策略延迟，该策略的计算方式为当前延迟乘以
    spring.cloud.config.retry.multiplier 属性的值。初始延迟由 spring.cloud.config.retry.initial-interval
    配置，并且每次延迟不能超过 spring.cloud.config.retry.max-interval 的值。
- en: You can add the retry configuration to the application.yml file in the Catalog
    Service project.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将重试配置添加到目录服务项目中的 application.yml 文件。
- en: Listing 4.18 Applying retry pattern to Spring Cloud Config Client
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.18 将重试模式应用于 Spring Cloud Config 客户端
- en: '[PRE40]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Makes a failure to connect to the config server fatal
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将连接到配置服务器的失败设置为致命错误
- en: ❷ Maximum number of attempts
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 最大尝试次数
- en: ❸ Initial retry interval for backoff (ms)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 退避的初始重试间隔（毫秒）
- en: ❹ Maximum retry interval for backoff (ms)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 退避的最大重试间隔（毫秒）
- en: ❺ Multiplier to compute the next interval
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 计算下一个间隔的乘数
- en: The retry behavior is enabled only when the spring.cloud.config.fail-fast property
    is set to true. You probably don’t want to retry in your local environment if
    the config server is down, especially considering we made it an optional backing
    service. Feel free to test the application’s behavior when retrying the connection
    with the config server down, but remember to set the fail-fast property back to
    false if you want to keep it optional in your local environment. In production
    you can set it to true using one of the strategies covered in this chapter. When
    you’re done testing the applications, stop both of them with Ctrl-C.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 spring.cloud.config.fail-fast 属性设置为 true 时，才会启用重试行为。如果配置服务器宕机，您可能不想在本地环境中进行重试，尤其是考虑到我们将其设置为可选的后端服务。您可以自由测试当配置服务器宕机时重试连接的应用程序行为，但请记住，如果您想在本地环境中保持其为可选，请将
    fail-fast 属性设置回 false。在生产环境中，您可以使用本章中介绍的一种策略将其设置为 true。测试完应用程序后，使用 Ctrl-C 停止它们。
- en: You are now ready to use the Config Service to configure any application you
    want. However, there’s still an aspect I haven’t covered yet. How can we change
    the configuration at runtime?
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用配置服务来配置您想要的任何应用程序。然而，还有一个方面我还没有涉及。我们如何能够在运行时更改配置呢？
- en: 4.4.3 Refreshing configuration at runtime
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 在运行时刷新配置
- en: What happens when new changes are pushed to the Git repository that’s backing
    the Config Service? For a standard Spring Boot application, you would have to
    restart it when you change a property (either in a property file or an environment
    variable). However, Spring Cloud Config gives you the possibility to refresh configuration
    in client applications at runtime. Whenever a new change is pushed to the configuration
    repository, you can signal all the applications integrated with the config server,
    and they will reload the parts affected by the configuration change. Spring Cloud
    Config offers different options for doing that.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当将新更改推送到支持 Config 服务的 Git 仓库时会发生什么？对于标准的 Spring Boot 应用程序，当您更改属性（无论是在属性文件中还是在环境变量中）时，您必须重新启动它。然而，Spring
    Cloud Config 给您在运行时刷新客户端应用程序配置的可能性。每当将新更改推送到配置仓库时，您都可以向与配置服务器集成的所有应用程序发出信号，它们将重新加载受配置更改影响的部分。Spring
    Cloud Config 提供了不同的选项来实现这一点。
- en: In this section, I’ll show you a simple refresh option consisting of sending
    a special POST request to a running Catalog Service instance to trigger the reloading
    of the configuration data that has changed (*hot reload*). Figure 4.11 shows how
    it works.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示一个简单的刷新选项，即向运行的 Catalog Service 实例发送特殊的 POST 请求以触发已更改的配置数据的重新加载（*热重载*）。图
    4.11 展示了它是如何工作的。
- en: '![04-11](../Images/04-11.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![04-11](../Images/04-11.png)'
- en: Figure 4.11 After changing the configuration in the Git repository backing the
    Config Service, a signal is sent to Catalog Service to refresh the parts of the
    application using the configuration.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 在更改支持 Config 服务的 Git 仓库中的配置后，向 Catalog Service 发送信号以刷新使用配置的应用程序部分。
- en: This functionality is one of those *administrative processes* described by the
    15-Factor methodology introduced in chapter 2\. In this case, the strategy adopted
    for managing the process was to embed it in the applications themselves, with
    the ability to activate it by calling a specific HTTP endpoint.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能是第 2 章中介绍的 15-Factor 方法论中描述的 *管理流程* 之一。在这种情况下，管理流程的策略是将其嵌入到应用程序本身中，通过调用特定的
    HTTP 端点来激活它。
- en: Note In production, you’ll probably want a more automated and efficient way
    of refreshing configuration than explicitly triggering each application instance.
    When a remote Git repository backs your config server, you can configure a webhook
    that notifies the config server automatically whenever new changes are pushed
    to the repository. In turn, the config server can notify all client applications
    through a message broker like RabbitMQ, using Spring Cloud Bus. Chapter 14 will
    cover more scenarios for refreshing configuration in production.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在生产环境中，您可能需要一个比显式触发每个应用程序实例更自动化和高效的方式来刷新配置。当远程 Git 仓库支持配置服务器时，您可以在配置服务器上配置一个
    webhook，每当将新更改推送到仓库时，它会自动通知配置服务器。反过来，配置服务器可以通过使用 Spring Cloud Bus 这样的消息代理来通知所有客户端应用程序。第
    14 章将涵盖更多关于生产环境中配置刷新的场景。
- en: Enabling configuration refresh
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 启用配置刷新
- en: After committing and pushing the new configuration changes to the remote Git
    repository, you can send a POST request to a client application through a specific
    endpoint that will trigger a RefreshScopeRefreshedEvent inside the application
    context. You can rely on the Spring Boot Actuator project to expose the refresh
    endpoint by adding a new dependency in the build.gradle file for the Catalog Service
    project. Remember to refresh or reimport the Gradle dependencies after the new
    addition.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在将新的配置更改提交并推送到远程 Git 仓库后，您可以通过一个特定的端点向客户端应用程序发送 POST 请求，这将触发应用程序上下文中的 RefreshScopeRefreshedEvent。您可以通过在
    Catalog Service 项目的 build.gradle 文件中添加一个新的依赖项来依赖 Spring Boot Actuator 项目公开刷新端点。请记住，在添加新内容后刷新或重新导入
    Gradle 依赖项。
- en: Listing 4.19 Adding dependency for Spring Boot Actuator in Catalog Service
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.19 在 Catalog Service 中添加 Spring Boot Actuator 依赖项
- en: '[PRE41]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The Spring Boot Actuator library configures an /actuator/refresh endpoint that
    triggers a refresh event. By default, the endpoint is not exposed, so you have
    to enable it explicitly in the application.yml file of your Catalog Service project
    (catalog-service).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Actuator 库配置了一个 /actuator/refresh 端点，该端点触发刷新事件。默认情况下，该端点未公开，因此您必须在
    Catalog Service 项目（catalog-service）的应用程序.yml 文件中显式启用它。
- en: Listing 4.20 Making Spring Boot Actuator expose the refresh endpoint
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.20 使 Spring Boot Actuator 公开刷新端点
- en: '[PRE42]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Exposes the /actuator/refresh endpoint through HTTP
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过 HTTP 公开 /actuator/refresh 端点
- en: Note I will discuss Spring Boot Actuator extensively in chapter 13, so don’t
    worry if you don’t fully understand the preceding configuration. For now, it’s
    enough to know that Spring Boot Actuator provides many useful endpoints for monitoring
    and managing applications in production.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我将在第13章中详细讨论Spring Boot Actuator，所以如果你不完全理解前面的配置，请不要担心。现在，你只需要知道Spring Boot
    Actuator提供了许多用于在生产环境中监控和管理应用程序的有用端点。
- en: 'The refresh event, RefreshScopeRefreshedEvent, will have no effect if there
    is no component listening. You can use the @RefreshScope annotation on any bean
    you’d like to be reloaded whenever a refresh is triggered. Here’s the nice part:
    since you defined your custom properties through a @ConfigurationProperties bean,
    it is already listening to RefreshScopeRefreshedEvent by default, so you don’t
    need to make any changes to your code. When a refresh is triggered, the PolarProperties
    bean will be reloaded with the latest configuration available. Let’s see if it
    works.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有组件监听，刷新事件RefreshScopeRefreshedEvent将没有任何效果。你可以在任何你希望刷新时重新加载的bean上使用@RefreshScope注解。这里有个好消息：由于你通过@ConfigurationProperties
    bean定义了自定义属性，它默认已经监听RefreshScopeRefreshedEvent，所以你不需要对你的代码进行任何更改。当触发刷新时，PolarProperties
    bean将使用最新的配置重新加载。让我们看看它是否工作。
- en: Changing configuration at runtime
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时更改配置
- en: In this final section, I’ll show you how to change configuration at runtime.
    First, make sure you have both the Config Service and Catalog Service up and running
    (./gradlew bootRun). Then open the config-repo repository hosting the configuration
    data and change the value of the polar.greeting property in the config-repo/ catalog-service.yml
    file.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我将向你展示如何运行时更改配置。首先，确保配置服务和目录服务都在运行（./gradlew bootRun）。然后打开托管配置数据的config-repo仓库，并在config-repo/catalog-service.yml文件中更改polar.greeting属性的值。
- en: Listing 4.21 Updating the welcome message value in the config repo
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.21 在配置仓库中更新欢迎信息值
- en: '[PRE43]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Next, commit and push the changes.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，提交并推送更改。
- en: Config Service will now return the new property value. You can check that by
    running the http :8888/catalog-service/default command. However, no signal has
    been sent yet to Catalog Service. If you try running the http :9001/ command,
    you will still get the old “Welcome to the catalog from the config server” message.
    Let’s trigger a refresh.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务现在将返回新的属性值。你可以通过运行http :8888/catalog-service/default命令来检查这一点。然而，尚未向目录服务发送任何信号。如果你尝试运行http
    :9001/命令，你仍然会得到旧的“欢迎来到配置服务器目录”消息。让我们触发一个刷新。
- en: 'Go ahead and send a POST request to the Catalog Service application at the
    /actuator/refresh endpoint:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 继续发送一个POST请求到位于/actuator/refresh端点的目录服务应用程序：
- en: '[PRE44]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This request will trigger a RefreshScopeRefreshedEvent event. The PolarProperties
    bean, because it’s annotated with @ConfigurationProperties, will react to the
    event and read the new configuration data. Let’s verify that:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求将触发一个RefreshScopeRefreshedEvent事件。由于PolarProperties bean上注有@ConfigurationProperties，它将响应事件并读取新的配置数据。让我们验证一下：
- en: '[PRE45]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Finally, stop the execution of both applications with Ctrl-C.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用Ctrl-C停止两个应用程序的执行。
- en: Good job! You have just updated the configuration of an application at runtime
    without restarting it, without rebuilding the application, and ensuring the traceability
    of changes. It’s perfect for the cloud. In chapter 14, you’ll learn more advanced
    techniques for managing configuration that you’ll need in production, including
    secrets management, ConfigMaps, and Secrets.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你刚刚在运行时更新了应用程序的配置，而没有重新启动它，也没有重新构建应用程序，并确保了变更的可追溯性。这对于云环境来说非常完美。在第14章中，你将学习更多在生产环境中管理配置的高级技术，包括密钥管理、ConfigMaps和Secrets。
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The Spring Environment abstraction provides a unified interface for accessing
    properties and profiles.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring环境抽象提供了一个统一的接口，用于访问属性和配置文件。
- en: Properties are key/value pairs used to store configuration.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性是用于存储配置的键/值对。
- en: Profiles are logical groups of beans registered only when a specific profile
    is active.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件是逻辑组，仅在特定配置文件激活时注册的bean。
- en: Spring Boot collects properties from different sources according to precedence
    rules. From the highest to the lowest precedence, properties can be defined in
    command-line arguments, JVM system variables, OS environment variables, profile-specific
    property files, and generic property files.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot根据优先级规则从不同的来源收集属性。从最高优先级到最低优先级，属性可以在命令行参数、JVM系统变量、OS环境变量、特定配置文件的属性文件和通用属性文件中定义。
- en: Spring beans can access properties from the Environment object by injecting
    the value with the @Value annotation, or from a bean mapped to a set of properties
    with the @ConfigurationProperties annotation.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Bean 可以通过使用 @Value 注解注入值，或通过使用 @ConfigurationProperties 注解映射到一组属性的 Bean
    来访问 Environment 对象中的属性。
- en: The active profiles can be defined with the spring.profiles.active property.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 spring.profiles.active 属性来定义活动配置文件。
- en: The @Profile annotation marks beans or configuration classes to be considered
    only when the specified profile is active.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@Profile 注解标记了仅在指定配置文件活动时才应考虑的 Bean 或配置类。'
- en: Properties, as managed in Spring Boot, provide externalized configuration as
    defined by the 15-Factor methodology, but that’s not enough.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Spring Boot 中管理的属性，提供了由 15-Factor 方法定义的外部化配置，但这还不够。
- en: A configuration server handles aspects like secret encryption, configuration
    traceability, versioning, and context refreshing at runtime with no restart.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置服务器处理诸如密钥加密、配置可追溯性、版本控制和运行时上下文刷新等方面，无需重启即可完成。
- en: A configuration server can be set up with the Spring Cloud Config Server library.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 Spring Cloud Config Server 库来设置配置服务器。
- en: The configuration itself can be stored according to different strategies, such
    as in a dedicated Git repository.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置本身可以根据不同的策略进行存储，例如在专门的 Git 仓库中。
- en: The config server uses the application name, active profiles, and Git-specific
    labels to identify which configuration should be provided to which application.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置服务器使用应用程序名称、活动配置文件和 Git 特定标签来识别应向哪个应用程序提供哪个配置。
- en: A Spring Boot application can be configured through a config server using the
    Spring Cloud Config Client library.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 Spring Cloud Config Client 库通过配置服务器配置 Spring Boot 应用程序。
- en: '@ConfigurationProperties beans are configured to listen to RefreshScopeRefreshedEvent
    events.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@ConfigurationProperties Bean 被配置为监听 RefreshScopeRefreshedEvent 事件。'
- en: RefreshScopeRefreshedEvent events can be triggered after a new change is pushed
    to the configuration repository, so that the client application reloads the context
    using the latest configuration data.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将新更改推送到配置仓库后，可以触发 RefreshScopeRefreshedEvent 事件，以便客户端应用程序使用最新的配置数据重新加载上下文。
- en: Spring Boot Actuator defines an /actuator/refresh endpoint that you can use
    to trigger the event manually.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot Actuator 定义了一个 /actuator/refresh 端点，您可以使用它来手动触发事件。
