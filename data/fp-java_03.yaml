- en: Chapter 4\. Recursion, corecursion, and memoization
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章：递归、尾递归和记忆化
- en: '***This chapter covers***'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Understanding recursion and corecursion
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解递归和尾递归
- en: Working with recursive functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与递归函数一起工作
- en: Composing a huge number of functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合大量函数
- en: Speeding up functions with memoization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用记忆化加速函数
- en: The previous chapter introduced powerful methods and functions, but some shouldn’t
    be used in production because they can overflow the stack and crash the application
    (or at least the thread in which they’re called). These “dangerous” methods and
    functions are mainly explicitly recursive, but not always. You’ve seen that composing
    functions can also overflow the stack, and this can occur even with nonrecursive
    functions, although this isn’t common.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了强大的方法和函数，但其中一些不应该在生产中使用，因为它们可能会溢出栈并导致应用程序崩溃（或者至少是调用它们的线程）。这些“危险”的方法和函数主要是显式递归的，但并不总是如此。你已经看到，组合函数也可能溢出栈，即使是非递归函数也可能发生这种情况，尽管这种情况并不常见。
- en: In this chapter, you’ll learn how to turn stack-based functions into heap-based
    functions. This is necessary because the stack is a limited memory area. For recursive
    functions to be safe, you have to implement them in such a way that they use the
    heap (the main memory area) instead of the limited stack space. To understand
    the problem completely, you must first understand the difference between recursion
    and corecursion.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何将基于栈的函数转换为基于堆的函数。这是必要的，因为栈是一个有限的内存区域。为了使递归函数安全，你必须以这种方式实现它们，即它们使用堆（主内存区域）而不是有限的栈空间。为了完全理解这个问题，你必须首先理解递归和尾递归之间的区别。
- en: 4.1\. Understanding corecursion and recursion
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1. 理解尾递归和递归
- en: '*Corecursion* is composing computing steps by using the output of one step
    as the input of the next one, starting with the first step. *Recursion* is the
    same operation, but starting with the last step. In recursion, you have to delay
    evaluation until you encounter a base condition (corresponding to the first step
    of corecursion).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*尾递归*是通过使用一个步骤的输出作为下一个步骤的输入来组合计算步骤，从第一个步骤开始。*递归*是相同的操作，但以最后一个步骤开始。在递归中，你必须延迟评估直到遇到基本条件（对应于尾递归的第一个步骤）。'
- en: 'Let’s say you have only two instructions in your programming language: incrementation
    (adding 1 to a value) and decrementation (subtracting 1 from a value). As an example,
    you’ll implement addition by composing these instructions.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的编程语言中只有两个指令：增量（给一个值加1）和减量（从一个值减1）。作为一个例子，你将通过组合这些指令来实现加法。
- en: 4.1.1\. Exploring corecursive and recursive addition examples
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1. 探索尾递归和递归加法示例
- en: 'To add two numbers, x and y, you can do the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要将两个数字 x 和 y 相加，你可以这样做：
- en: If y = 0, return x.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `y` 等于 0，则返回 `x`。
- en: Otherwise, increment x, decrement y, and start again.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，增加 `x`，减少 `y`，然后重新开始。
- en: 'This can be written in Java as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以写成以下 Java 代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s a simpler approach:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更简单的方法：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There’s no problem with using the parameters `x` and `y` directly, because
    in Java, all parameters are passed by value. Also note that you use post-decrementation
    to simplify coding. You could have used pre-decrementation by slightly changing
    the condition, thus switching from iterating from `y` to `1`, to iterating from
    `y - 1` to `0`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用参数 `x` 和 `y` 没有问题，因为在 Java 中，所有参数都是按值传递的。此外，请注意，你使用了后减量来简化编码。你可以通过稍微改变条件来使用前减量，从而将迭代从
    `y` 到 `1` 转换为从 `y - 1` 到 `0`：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The recursive version is trickier, but still simple:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 递归版本更复杂，但仍然简单：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Both approaches seem to work, but if you try the recursive version with big
    numbers, you may have a surprise. Although this version,
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法似乎都有效，但如果你尝试使用大数字的递归版本，可能会感到惊讶。尽管这个版本，
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: produces the expected result of 10,003, switching the parameters, like this,
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 产生预期的结果 10,003，切换参数，如下所示，
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: produces a `StackOverflowException`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 产生 `StackOverflowException`。
- en: 4.1.2\. Implementing recursion in Java
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2. 在 Java 中实现递归
- en: To understand what’s happening, you must look at how Java handles method calls.
    When a method is called, Java suspends what it’s currently doing and pushes the
    environment on the stack to make a place for executing the called method. When
    this method returns, Java pops the stack to restore the environment and resume
    program execution. If you call one method after another, the stack always holds
    at most one of these method call environments.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解正在发生的事情，你必须看看 Java 如何处理方法调用。当一个方法被调用时，Java 暂停当前正在做的事情，并将环境推送到栈上以为执行被调用方法腾出空间。当这个方法返回时，Java
    弹出栈以恢复环境并继续程序执行。如果你一个接一个地调用方法，栈始终最多只保留一个这些方法调用环境。
- en: But methods aren’t composed only by calling them one after the other. Methods
    call methods. If `method1` calls `method2` as part of its implementation, Java
    again suspends the `method1` execution, pushes the current environment on the
    stack, and starts executing `method2`. When `method2` returns, Java pops the last
    pushed environment from the stack and resumes execution (of `method1` in this
    case). When `method1` completes, Java again pops the last environment from the
    stack and resumes what it was doing before calling this method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但方法不仅仅是由一个接一个地调用它们组成的。方法可以调用其他方法。如果 `method1` 在其实现中调用 `method2`，Java 会再次挂起 `method1`
    的执行，将当前环境推送到栈上，并开始执行 `method2`。当 `method2` 返回时，Java 从栈中弹出最后推送的环境并恢复程序执行（在这种情况下是
    `method1`）。当 `method1` 完成时，Java 再次从栈中弹出最后的环境并恢复调用此方法之前的状态。
- en: Method calls may be deeply nested, and this nesting depth does have a limit,
    which is the size of the stack. In current situations, the limit is somewhere
    around a few thousand levels, and it’s possible to increase this limit by configuring
    the stack size. But because the same stack size is used for all threads, increasing
    the stack size generally wastes space. The default stack size varies from 320
    KB to 1024 KB, depending on the version of Java and the system used. For a 64-bit
    Java 8 program with minimal stack usage, the maximum number of nested method calls
    is about 7,000\. Generally, you won’t need more, except in specific cases. One
    such case is recursive method calls.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用可能深度嵌套，这种嵌套深度确实有一个限制，那就是栈的大小。在当前情况下，这个限制大约在几千层左右，可以通过配置栈大小来增加这个限制。但是，因为所有线程都使用相同的栈大小，所以增加栈大小通常会造成空间的浪费。默认的栈大小从
    320 KB 到 1024 KB 不等，这取决于 Java 的版本和所使用的系统。对于一个使用最小栈空间的 64 位 Java 8 程序，嵌套方法调用的最大数量大约是
    7,000。通常情况下，你不会需要更多，除非在特定情况下。其中一种情况就是递归方法调用。
- en: 4.1.3\. Using tail call elimination
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3\. 使用尾调用消除
- en: Pushing the environment on the stack is typically necessary in order to resume
    computation after the called method returns, but not always. When the call to
    a method is the last thing the calling method does, there’s nothing to resume
    when the method returns, so it should be OK to resume directly with the caller
    of the current method instead of the current method itself. A method call occurring
    in the last position, meaning it’s the last thing to do before returning, is called
    a *tail call*. Avoiding pushing the environment to the stack to resume method
    processing after a tail call is an optimization technique known as *tail call
    elimination* (TCE). Unfortunately, Java doesn’t use TCE.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在被调用方法返回后恢复计算通常需要在栈上推送环境，但这并不总是必要的。当对方法的调用是调用方法做的最后一件事时，方法返回时就没有什么可以恢复的，所以可以直接用当前方法的调用者而不是当前方法本身来恢复。在最后位置发生的方法调用，意味着它是返回前的最后一件事，被称为
    *尾调用*。避免在尾调用后推送环境到栈上以恢复方法处理是一种称为 *尾调用消除* (TCE) 的优化技术。不幸的是，Java 不使用 TCE。
- en: Tail call elimination is sometimes called *tail call optimization* (TCO). TCE
    is generally an optimization, and you can live without it. But when it comes to
    recursive function calls, TCE is no longer an optimization. It’s a necessary feature.
    That’s why TCE is a better term than TCO when it comes to handling recursion.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尾调用消除有时被称为 *尾调用优化* (TCO)。TCE 通常是一种优化，没有它也可以生存。但是，当涉及到递归函数调用时，TCE 就不再是一种优化了。它是一个必要特性。这就是为什么在处理递归时，TCE
    比 TCO 是一个更好的术语。
- en: 4.1.4\. Using tail recursive methods and functions
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.4\. 使用尾递归方法和函数
- en: Most functional languages have TCE. But TCE isn’t enough to make every recursive
    call possible. To be a candidate for TCE, the recursive call must be the last
    thing the method has to do.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数函数式语言都有 TCE。但 TCE 并不足以使每个递归调用都成为可能。要成为 TCE 的候选者，递归调用必须是方法必须做的最后一件事。
- en: 'Consider the following method, which is computing the sum of the elements of
    a list:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下方法，它是计算列表元素之和的：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This method uses the `head` and `tail` methods from [chapter 3](kindle_split_010.xhtml#ch03).
    The recursive call to the `sum` method isn’t the last thing the method has to
    do. The four last things the method does are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用了第 3 章（[chapter 3](kindle_split_010.xhtml#ch03)）中的 `head` 和 `tail` 方法。对
    `sum` 方法的递归调用不是方法必须做的最后一件事。方法做的最后四件事如下：
- en: Calls the `head` method
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `head` 方法
- en: Calls the `tail` method
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `tail` 方法
- en: Calls the `sum` method
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `sum` 方法
- en: Adds the result of `head` and the result of `sum`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `head` 的结果和 `sum` 的结果相加
- en: 'Even if you had TCE, you wouldn’t be able to use this method with lists of
    10,000 elements. But you can rewrite this method in order to put the call to `sum`
    in the tail position:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你有 TCE，你也不能用这个方法处理包含 10,000 个元素列表。但你可以重写这个方法，以便将 `sum` 的调用放在尾部位置：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the `sumTail` method is tail recursive and can be optimized through TCE.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sumTail` 方法是尾递归的，可以通过 TCE 进行优化。
- en: 4.1.5\. Abstracting recursion
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.5. 抽象递归
- en: 'So far, so good, but why bother with all this if Java doesn’t have TCE? Well,
    Java doesn’t have it, but you can do without it. All you need to do is the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但为什么要在 Java 没有TCE的情况下还费心去做这些呢？好吧，Java 没有它，但你也可以不用它。你只需要做以下事情：
- en: Represent unevaluated method calls
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示未评估的方法调用
- en: Store them in a stack-like structure until you encounter a terminal condition
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将它们存储在类似栈的结构中，直到遇到终止条件
- en: Evaluate the calls in “last in, first out” (LIFO) order
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照后进先出（LIFO）的顺序评估调用
- en: Most examples of recursive methods use the factorial function. Other examples
    use the Fibonacci series. The factorial method presents no particular interest
    beside being recursive. The Fibonacci series is more interesting, and we’ll come
    back to it later. To start with, you’ll use the much simpler recursive addition
    method shown at the beginning of this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数递归方法的例子都使用阶乘函数。其他例子使用斐波那契数列。除了是递归的之外，阶乘方法没有特别有趣的地方。斐波那契数列更有趣，我们稍后会回到它。首先，你将使用本章开头所示的这个非常简单的递归加法方法。
- en: Recursive and corecursive functions are both functions where `f(n)` is a composition
    of `f(n - 1)`, `f(n - 2)`, `f(n - 3)`, and so on, until a terminal condition is
    encountered (generally `f(0)` or `f(1)`). Remember that in traditional programming,
    composing generally means composing the results of an evaluation. This means that
    composing function `f(a)` and `g(a)` consists of evaluating `g(a)` and then using
    the result as input to `f`. But it doesn’t have to be done that way. In [chapter
    2](kindle_split_009.xhtml#ch02), you developed a `compose` method to compose functions,
    and a `higherCompose` function to do the same thing. Neither evaluated the composed
    functions. They only produced another function that could be applied later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 递归和核心递归函数都是函数，其中 `f(n)` 是 `f(n - 1)`、`f(n - 2)`、`f(n - 3)` 等的复合，直到遇到终止条件（通常是
    `f(0)` 或 `f(1)`）。记住，在传统的编程中，组合通常意味着组合评估的结果。这意味着组合函数 `f(a)` 和 `g(a)` 包括评估 `g(a)`，然后使用结果作为
    `f` 的输入。但不必这样做。在第 2 章（[chapter 2](kindle_split_009.xhtml#ch02)）中，你开发了一个 `compose`
    方法来组合函数，以及一个 `higherCompose` 函数来做同样的事情。它们都没有评估组合函数。它们只产生了一个稍后可以应用的其他函数。
- en: Recursion and corecursion are similar, but there’s a difference. You create
    a list of function calls instead of a list of functions. With corecursion, each
    step is terminal, so it may be evaluated in order to get the result and use it
    as input for the next step. With recursion, you start from the other end, so you
    have to put non-evaluated calls in the list until you find a terminal condition,
    from which you can process the list in reverse order. You stack the steps until
    the last one is found, and then you process the stack in reverse order (last in,
    first out), again evaluating each step and using the result as the input for the
    next (in fact, the previous) one.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 递归和核心递归相似，但存在差异。你创建的是一个函数调用的列表，而不是函数的列表。在核心递归中，每一步都是终止的，因此它可以按顺序评估以获得结果，并将其用作下一步的输入。在递归中，你从另一端开始，因此你必须将未评估的调用放入列表中，直到找到终止条件，然后你可以按相反的顺序处理列表。你将步骤堆叠，直到找到最后一个，然后按相反的顺序（后进先出）处理堆栈，再次评估每个步骤，并将结果用作下一个（实际上，上一个）步骤的输入。
- en: The problem is that Java uses the thread stack for both recursion and corecursion,
    and its capacity is limited. Typically, the stack overflows after 6,000 to 7,000
    steps. What you have to do is create a function or a method returning a non-evaluated
    step. To represent a step in the calculation, you’ll use an abstract class called
    `TailCall` (because you want to represent a call to a method that appears in the
    tail position).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于Java既使用线程栈进行递归又进行尾递归，其容量是有限的。通常，在6,000到7,000步之后栈会溢出。你必须创建一个返回未评估步骤的函数或方法。为了表示计算中的步骤，你将使用一个名为`TailCall`的抽象类（因为你想要表示出现在尾位置的函数调用）。
- en: This `TailCall` abstract class has two subclasses. One represents an intermediate
    call, when the processing of one step is suspended to call the method again for
    evaluating the next step. This is represented by a subclass named `Suspend`. It’s
    instantiated with `Supplier<TailCall>>`, which represents the next recursive call.
    This way, instead of putting all `TailCalls` in a list, you’ll construct a linked
    list by linking each tail call to the next. The benefit of this approach is that
    such a linked list is a stack, offering constant time insertion as well as constant
    time access to the last inserted element, which is optimal for a LIFO structure.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`TailCall`抽象类有两个子类。一个代表中间调用，当某一步的处理被暂停以再次调用方法来评估下一步时。这由一个名为`Suspend`的子类表示。它使用`Supplier<TailCall>`实例化，代表下一个递归调用。这样，你不会将所有的`TailCalls`放入一个列表中，而是通过将每个尾调用链接到下一个来构建一个链表。这种方法的好处是这样一个链表是一个栈，提供常数时间的插入以及常数时间的对最后一个插入元素的访问，这对于后进先出（LIFO）结构是最优的。
- en: 'The second subclass represents the last call, which is supposed to return the
    result, so you’ll call it `Return`. It won’t hold a link to the next `TailCall`,
    because there’s nothing next, but it’ll hold the result. Here’s what you get:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个子类代表最后的调用，它应该返回结果，因此你将调用它为`Return`。它不会保留指向下一个`TailCall`的链接，因为没有后续的调用，但它会保留结果。以下是你会得到的内容：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To handle these classes, you’ll need some methods: one to return the result,
    one to return the next call, and one helper method to determine whether a `TailCall`
    is a `Suspend` or a `Return`. You could avoid this last method, but you’d have
    to use `instanceof` to do the job, which is ugly. The three methods are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理这些类，你需要一些方法：一个用于返回结果，一个用于返回下一个调用，以及一个辅助方法用于确定一个`TailCall`是`Suspend`还是`Return`。你可以避免最后一个方法，但你需要使用`instanceof`来完成这项工作，这看起来很糟糕。这三个方法如下：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `resume` method has no implementation in `Return` and will throw a runtime
    exception. The user of your API shouldn’t be in a situation to call this method,
    so if it’s eventually called, it’ll be a bug and you’ll stop the application.
    In the `Suspend` class, this method will return the next `TailCall`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`resume`方法在`Return`中没有实现，并且会抛出一个运行时异常。你的API用户不应该处于调用此方法的情况，所以如果最终调用了它，那将是一个错误，你将停止应用程序。在`Suspend`类中，此方法将返回下一个`TailCall`。'
- en: The `eval` method returns the result stored in the `Return` class. In the first
    version, it’ll throw a runtime exception if called on the `Suspend` class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`方法返回存储在`Return`类中的结果。在第一个版本中，如果对`Suspend`类调用它，它将抛出一个运行时异常。'
- en: The `isSuspend` method returns `true` in `Suspend`, and `false` in `Return`.
    The following listing shows this first version.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`isSuspend`方法在`Suspend`中返回`true`，在`Return`中返回`false`。以下列表显示了第一个版本。'
- en: Listing 4.1\. The `TailCall` interface and its two implementations
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. `TailCall` 接口及其两个实现
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To make the recursive method `add` work with any number of steps (within the
    limits of available memory!), you have a few changes to make. Starting with your
    original method,
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使递归方法`add`能够与任何数量的步骤（在可用内存的范围内）一起工作，你需要进行一些修改。从你的原始方法开始，
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: you need to make the modifications shown in the following listing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做出以下列表中显示的修改。
- en: Listing 4.2\. The modified recursive method
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2\. 修改后的递归方法
- en: '![](Images/100fig01_alt.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/100fig01_alt.jpg)'
- en: This method returns a `TailCall<Integer>` instead of an `int`![](Images/num-01.jpg).
    This return value may be a `Return<Integer>` if you’ve reached a terminal condition
    ![](Images/num-02.jpg), or a `Suspend <Integer>` if you haven’t ![](Images/num-03.jpg).
    The `Return` is instantiated with the result of the computation (which is `x`,
    because `y` is `0`), and the `Suspend` is instantiated with a `Supplier <TailCall<Integer>>`,
    which is the next step of the computation in terms of execution sequence, or the
    previous in terms of calling sequence. It’s important to understand that `Return`
    corresponds to the last step in terms of the method call, but to the first step
    in terms of evaluation. Also note that we’ve slightly changed the evaluation,
    replacing `++x` and `--y` with `x + 1` and `y – 1`. This is necessary because
    we’re using a closure, which works only if closed-over variables are effectively
    final. This is cheating, but not too much. We could have created and called two
    methods, `dec` and `inc`, using the original operators.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个 `TailCall<Integer>` 而不是 `int`！[](Images/num-01.jpg)。此返回值可能是一个 `Return<Integer>`，如果你已经达到终止条件！[](Images/num-02.jpg)，或者是一个
    `Suspend<Integer>`，如果你还没有！[](Images/num-03.jpg)。`Return` 使用计算结果（即 `x`，因为 `y` 是
    `0`）进行实例化，而 `Suspend` 使用一个 `Supplier<TailCall<Integer>>` 进行实例化，这是从执行序列的角度来看计算的下一步，或者从调用序列的角度来看的上一步。重要的是要理解
    `Return` 在方法调用方面对应于最后一步，但在评估方面对应于第一步。此外，请注意，我们稍微改变了评估，将 `++x` 和 `--y` 替换为 `x +
    1` 和 `y – 1`。这是必要的，因为我们正在使用闭包，它只适用于封闭的变量实际上是最终变量。这是作弊，但不是太严重。我们可以创建并调用两个方法，`dec`
    和 `inc`，使用原始运算符。
- en: This method returns a chain of `TailCall` instances, all being `Suspend` instances
    except the last one, which is a `Return`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个 `TailCall` 实例的链，除了最后一个实例外，所有实例都是 `Suspend` 实例，最后一个实例是 `Return`。
- en: 'So far, so good, but this method isn’t a drop-in replacement for the original
    one. Not a big deal! The original method was used as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但这个方法并不是原始方法的直接替代品。这不是什么大问题！原始方法的使用方式如下：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can use the new method like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样使用新方法：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Doesn’t it look nice? If you feel frustrated, I understand. You thought you
    would just use a new method in place of the old one in a transparent manner. You
    seem to be far from this. But you can make things much better with a little effort.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错吗？如果你感到沮丧，我理解。你以为你只是用一种透明的方式用新方法替换旧方法。你似乎离这个目标还很远。但只要你稍加努力，就可以让事情变得更好。
- en: 4.1.6\. Using a drop-in replacement for stack-based recursive methods
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.6\. 使用基于堆栈的递归方法的替代方案
- en: 'In the beginning of the previous section, I said that the user of your recursive
    API would have no opportunity to mess with the `TailCall` instances by calling
    `resume` on a `Return` or `eval` on a `Suspend`. This is easy to achieve by putting
    the evaluation code in the `eval` method of the `Suspend` class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的开头，我说过，你的递归 API 的用户没有机会通过在 `Return` 上调用 `resume` 或在 `Suspend` 上调用 `eval`
    来干扰 `TailCall` 实例。通过将评估代码放在 `Suspend` 类的 `eval` 方法中，这很容易实现：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now you can get the result of the recursive call in a much simpler and safer
    way:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以以更简单、更安全的方式获取递归调用的结果：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But this isn’t what you want. You want to get rid of this call to the `eval`
    method. This can be done with a helper method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不是你想要的。你想要移除对 `eval` 方法的调用。这可以通过一个辅助方法来完成：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now you can call the `add` method exactly as the original one. You can make
    your recursive API easier to use by providing static factory methods to instantiate
    `Return` and `Suspend`, which also allows you to make the `Return` and `Suspend`
    internal subclasses private:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以像原始方法一样调用 `add` 方法。你可以通过提供静态工厂方法来实例化 `Return` 和 `Suspend`，使你的递归 API 更易于使用，这也允许你将
    `Return` 和 `Suspend` 的内部子类设置为私有：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The following listing shows the complete `TailCall` class. It adds a private
    no-args constructor to prevent extension by other classes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了完整的 `TailCall` 类。它添加了一个无参数的私有构造函数，以防止其他类扩展。
- en: Listing 4.3\. The complete `TailCall` class
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 完整的 `TailCall` 类
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that you have a stack-safe tail recursive method, can you do the same thing
    with a function?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个堆栈安全的尾递归方法，你能用函数做到同样的事情吗？
- en: 4.2\. Working with recursive functions
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 使用递归函数
- en: In theory, recursive functions shouldn’t be more difficult to create than methods,
    if functions are implemented as methods in an anonymous class. But lambdas aren’t
    implemented as methods in anonymous classes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，如果函数作为匿名类中的方法实现，递归函数的创建不应该比方法更困难。但 lambda 并不是在匿名类中作为方法实现的。
- en: 'The first problem is that, in theory, lambdas can’t be recursive. But this
    is theory. In fact, you learned a trick to work around this problem in [chapter
    2](kindle_split_009.xhtml#ch02). A statically defined recursive `add` function
    looks like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题在于，从理论上讲，lambda 表达式不能是递归的。但这只是理论。实际上，你在[第2章](kindle_split_009.xhtml#ch02)中学习了一个技巧来绕过这个问题。一个静态定义的递归
    `add` 函数看起来是这样的：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, `ContainingClass` stands for the name of the class in which the function
    is defined. Or you may prefer an instance function instead of a static one:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ContainingClass` 代表定义函数的类的名称。或者你可能更喜欢一个实例函数而不是静态函数：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: But here, you have the same problem you had with the `add` method. You must
    call `eval` on the result. You could use the same trick, with a helper method
    alongside the recursive implementation. But you should make the whole thing self-contained.
    In other languages, such as Scala, you can define helper functions locally, inside
    the main function. Can you do the same in Java?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里，你遇到了与 `add` 方法相同的问题。你必须对结果调用 `eval`。你可以使用同样的技巧，与递归实现一起使用一个辅助方法。但你应该使整个事情自包含。在其他语言中，例如
    Scala，你可以在主函数内部局部定义辅助函数。你能在 Java 中做到同样的事情吗？
- en: 4.2.1\. Using locally defined functions
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 使用局部定义的函数
- en: Defining a function inside a function isn’t directly possible in Java. But a
    function written as a lambda is a class. Can you define a local function in that
    class? In fact, you can’t. You can’t use a static function, because a local class
    can’t have static members, and anyway, they have no name. Can you use an instance
    function? No, because you need a reference to `this`. And one of the differences
    between lambdas and anonymous classes is the `this` reference. Instead of referring
    to the anonymous class instance, the `this` reference used in a lambda refers
    to the enclosing instance.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，在函数内部定义一个函数是不可能的。但一个写成 lambda 表达式的函数是一个类。你能在那个类中定义一个局部函数吗？实际上，你不能。你不能使用静态函数，因为局部类不能有静态成员，而且它们没有名字。你能使用实例函数吗？不，因为你需要一个对
    `this` 的引用。而 lambda 表达式和匿名类之间的一个区别是 `this` 引用。与引用匿名类实例不同，lambda 表达式中使用的 `this`
    引用指向封装实例。
- en: The solution is to declare a local class containing an instance function, as
    shown in the following listing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是声明一个包含实例函数的局部类，如下所示。
- en: Listing 4.4\. A standalone tail recursive function
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. 一个独立的尾递归函数
- en: '![](Images/104fig01_alt.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/104fig01_alt.jpg)'
- en: 'This function may be used as a normal function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以用作一个普通函数：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 4.2.2\. Making functions tail recursive
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 使函数尾递归
- en: 'Previously, I said that a simple recursive functional method computing the
    sum of elements in a list couldn’t be handled safely because it isn’t tail recursive:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我说过，一个简单的递归函数，用于计算列表中元素的总和，不能安全地处理，因为它不是尾递归：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You saw that you had to transform the method as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到你需要将方法转换如下：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The principle is quite simple, although it’s sometimes tricky to apply. It consists
    of using an accumulator holding the result of the computation. This accumulator
    is added to the parameters of the method. Then the function is transformed into
    a helper method called by the original one with the initial value of the accumulator.
    It’s important to make this process nearly instinctive, because you’ll have to
    use it each time you want to write a recursive method or function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 原则相当简单，尽管有时应用起来可能有些棘手。它包括使用一个累加器来保存计算的结果。这个累加器被添加到方法参数中。然后，函数被转换为一个辅助方法，由原始方法调用，并使用累加器的初始值。这个过程几乎要成为本能，因为每次你想编写递归方法或函数时，你都需要使用它。
- en: It may be OK to change a method into two methods. After all, methods don’t travel,
    so you only have to make the main method public and the helper method (the one
    doing the job) private. The same is true for functions, because the call to the
    helper function by the main function is a closure. The main reason to prefer a
    locally defined helper function over a private helper method is to avoid name
    clashes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个方法变成两个方法可能是可以的。毕竟，方法不会移动，所以你只需要将主方法设为公共的，将辅助方法（执行工作的那个）设为私有的。对于函数来说也是如此，因为主函数对辅助函数的调用是一个闭包。相比于私有辅助方法，更倾向于使用局部定义的辅助函数的主要原因是为了避免名称冲突。
- en: A current practice in languages that allow locally defined functions is to call
    all helper functions with a single name, such as `go` or `process`. This can’t
    be done with nonlocal functions (unless you have only one function in each class).
    In the previous example, the helper function for `sum` was called `sumTail`. Another
    current practice is to call the helper function with the same name as the main
    function with an appended underscore, such as `sum_`. Whatever system you choose,
    it’s useful to be consistent. In the rest of this book, I’ll use the underscore
    to denote tail recursive helper functions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在允许局部定义函数的语言中，当前的做法是使用单个名称调用所有辅助函数，例如`go`或`process`。对于非局部函数来说，这是不可能的（除非每个类中只有一个函数）。在先前的例子中，`sum`的辅助函数被命名为`sumTail`。另一种当前的做法是使用与主函数相同的名称调用辅助函数，并在后面添加下划线，例如`sum_`。无论你选择哪种系统，保持一致性都是有用的。在这本书的其余部分，我将使用下划线来表示尾递归辅助函数。
- en: '4.2.3\. Doubly recursive functions: the Fibonacci example'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3\. 双重递归函数：斐波那契数列示例
- en: No book about recursive functions can avoid the Fibonacci series function. Although
    it’s totally useless to most of us, it’s ubiquitous and fun. Let’s start with
    the requirements, in case you’ve never met this function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 任何关于递归函数的书籍都无法避免斐波那契数列函数。虽然这对我们大多数人来说毫无用处，但它无处不在且很有趣。让我们从需求开始，以防你从未遇到过这个函数。
- en: 'The Fibonacci series is a suite of numbers, and each number is the sum of the
    two previous ones. This is a recursive definition. You need a terminal condition,
    so the full requirements are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列是一组数字，每个数字都是前两个数字的和。这是一个递归定义。你需要一个终止条件，所以完整的需求如下：
- en: f (0) = 0
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: f (0) = 0
- en: f (1) = 1
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: f (1) = 1
- en: f (*n*) = f (*n* – 1) + f (*n* – 2)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: f (*n*) = f (*n* – 1) + f (*n* – 2)
- en: This isn’t the original Fibonacci series, in which the first two numbers are
    equal to 1\. Each number is supposed to be a function of its position in the series,
    and that position starts at 1\. In computing, you generally prefer to start at
    0\. Anyway, this doesn’t change the problem.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是原始的斐波那契数列，其中前两个数等于1。每个数都应该是其在该数列中的位置的函数，而这个位置从1开始。在计算机科学中，你通常更喜欢从0开始。无论如何，这并不改变问题。
- en: 'Why is this function so interesting? Instead of answering this question right
    now, let’s try a naive implementation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个函数如此有趣？我们不急于回答这个问题，而是尝试一个朴素实现：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let’s write a simple program to test this method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写一个简单的程序来测试这个方法：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you run this test program, you’ll get the first 10 (or 9, according to the
    original definition) Fibonacci numbers:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个测试程序，你会得到前10个（或根据原始定义的9个）斐波那契数：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Based on what you know about naive recursion in Java, you may think that this
    method will succeed in calculating `f(n)` for `n`, up to 6,000 to 7,000 before
    overflowing the stack. Well, let’s check it. Replace `int n = 10` with `int n
    = 6000` and see what happens. Launch the program and take a coffee break. When
    you return, you’ll realize that the program is still running. It will have reached
    somewhere around 1,836,311,903 (your mileage may vary—you could get a negative
    number!), but it’ll never finish. No stack overflow, no exception—just hanging
    in the wild. What’s happening?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 基于你对Java中朴素递归的了解，你可能认为这个方法在计算`f(n)`时，对于`n`的值达到6,000到7,000之前会因栈溢出而失败。好吧，让我们来验证一下。将`int
    n = 10`替换为`int n = 6000`，看看会发生什么。启动程序，喝杯咖啡休息一下。当你回来时，你会发现程序仍在运行。它将达到大约1,836,311,903（你的结果可能会有所不同——你可能会得到一个负数！），但它永远不会结束。没有栈溢出，没有异常——只是在野外悬挂。发生了什么？
- en: The problem is that each call to the function creates two recursive calls. So
    to calculate `f(n)`, you need 2*n* recursive calls. Let’s say your method needs
    10 nanoseconds to execute. (Just guessing, but you’ll see soon that it doesn’t
    change anything.) Calculating `f(5000)` will take 2^(5000) × 10 nanoseconds. Do
    you have any idea how long this is? This program will never terminate because
    it would need longer than the expected duration of the solar system (if not the
    universe!).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于每次函数调用都会创建两个递归调用。所以为了计算`f(n)`，你需要2*n*次递归调用。假设你的方法需要10纳秒来执行。（只是猜测，但很快你就会看到这不会改变任何事情。）计算`f(5000)`将需要2^(5000)
    × 10纳秒。你有什么想法吗？这个程序永远不会终止，因为它需要比太阳系（如果不是宇宙！）预期的持续时间更长的时间。
- en: 'To make a usable Fibonacci function, you have to change it to use a single
    tail recursive call. There’s also another problem: the results are so big that
    you’ll soon get an arithmetic overflow, resulting in negative numbers.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可用的斐波那契函数，你必须将其修改为使用单个尾递归调用。还有一个问题：结果数值太大，你很快就会得到算术溢出，导致出现负数。
- en: Exercise 4.1
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 4.1
- en: Create a tail recursive version of the Fibonacci functional method.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建斐波那契函数方法的尾递归版本。
- en: Hint
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The accumulator solution is the way to go. But there are two recursive calls,
    so you’ll need two accumulators.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 累加器解决方案是可行的。但是有两个递归调用，所以你需要两个累加器。
- en: Solution 4.1
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 4.1
- en: 'Let’s first write the signature of the helper method. It’ll take two `BigInteger`
    instances as accumulators, and one for the original argument, and it’ll return
    a `BigInteger`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先写出辅助方法的签名。它将接受两个 `BigInteger` 实例作为累加器，一个用于原始参数，并返回一个 `BigInteger`：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You must deal with the terminal conditions. If the argument is `0`, you return
    `0`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须处理终端条件。如果参数是 `0`，你返回 `0`：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the argument is `1`, you return the sum of the two accumulators:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是 `1`，你返回两个累加器的和：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Eventually, you have to deal with recursion. You must do the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你必须处理递归。你必须做以下事情：
- en: Take accumulator 2 and make it accumulator 1.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将累加器 2 变为累加器 1。
- en: Create a new accumulator 2 by adding the two previous accumulators.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将前两个累加器相加创建一个新的累加器 2。
- en: Subtract 1 from the argument.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从参数中减去 1。
- en: Recursively call the function with the three computed values as its arguments.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归调用函数，其参数为三个计算出的值。
- en: 'Here’s the transcription in code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的转录：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last thing to do is to create the main method that calls this helper method
    with the initial values of the accumulators:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是创建主方法，该方法使用累加器的初始值调用此辅助方法：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is only one possible implementation. You may organize accumulators, initial
    values, and conditions in a slightly different manner, as long as it works. Now
    you can call `fib(5000)`, and it’ll give you the result in a couple of nanoseconds.
    Well, it’ll take a few dozen milliseconds, but only because printing to the console
    is a slow operation. We’ll come back to this shortly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是可能的一种实现。你可以以稍微不同的方式组织累加器、初始值和条件，只要它有效。现在你可以调用 `fib(5000)`，它将在几纳秒内给出结果。好吧，它将花费几十毫秒，但这只是因为打印到控制台是一个慢操作。我们很快就会回到这个问题。
- en: The result is impressive, whether it’s the result of the computation (1,045
    digits!) or the increase in speed due to the transformation of a dual recursive
    call into a single one. But you still can’t use the method with values higher
    than 7,500.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 结果令人印象深刻，无论是计算结果（1,045 位数字！）还是由于将双重递归调用转换为单个调用而带来的速度提升。但你仍然不能使用大于 7,500 的值。
- en: Exercise 4.2
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 4.2
- en: Turn this method into a stack-safe recursive one.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 将此方法转换为栈安全的递归方法。
- en: Solution 4.2
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 4.2
- en: 'This should be easy. The following code shows the needed changes:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很简单。以下代码显示了所需的变化：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You may now compute `fib(10000)` and count the digits in the result!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以计算 `fib(10000)` 并计算结果中的数字数量！
- en: 4.2.4\. Making the list methods stack-safe and recursive
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.4\. 使列表方法栈安全和递归
- en: In the previous chapter, you developed functional methods to work on lists.
    Some of these methods were naively recursive, so they couldn’t be used in production.
    It’s time to fix this.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你开发了用于处理列表的功能方法。其中一些方法是原始递归的，因此不能在生产中使用。现在是时候修复这个问题了。
- en: Exercise 4.3
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 4.3
- en: Create a stack-safe recursive version of the `foldLeft` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个栈安全的 `foldLeft` 方法递归版本。
- en: Solution 4.3
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 4.3
- en: 'The naively recursive version of the `foldLeft` method was tail recursive:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`foldLeft` 方法的原始递归版本是尾递归的：'
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Turning it into a fully recursive method is easy:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为完全递归方法很容易：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Exercise 4.4
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 4.4
- en: Create a fully recursive version of the recursive `range` method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建递归 `range` 方法的完全递归版本。
- en: Hint
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Beware of the direction of list construction (`append` or `prepend`).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意列表构建的方向（`append` 或 `prepend`）。
- en: Solution 4.4
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 4.4
- en: 'The `range` method isn’t tail recursive:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 方法不是尾递归的：'
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You have to first create a tail recursive version, using an accumulator. Here,
    you need to return a list, so the accumulator will be a list, and you’ll start
    with an empty list. But you must build the list in reverse order:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须首先创建一个使用累加器的尾递归版本。在这里，你需要返回一个列表，所以累加器将是一个列表，并且你将从一个空列表开始。但你必须以相反的顺序构建列表：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then you must turn this method into a main method and a helper method by using
    true recursion:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你必须通过使用真正的递归来将这个方法转换为主方法和辅助方法：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The fact that you had to reverse the operation is important. Can you see why?
    If not, try the next exercise.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须反转操作的事实很重要。你能看出为什么吗？如果不能，尝试下一个练习。
- en: Exercise 4.5 (hard)
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 4.5（困难）
- en: Create a stack-safe recursive version of the `foldRight` method.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个安全的递归版本的 `foldRight` 方法。
- en: Solution 4.5
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 4.5
- en: 'The stack-based recursive version of the `foldRight` method is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`foldRight` 方法的基于栈的递归版本如下：'
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This method isn’t tail recursive, so let’s first create a tail recursive version.
    You might end up with this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法不是尾递归的，所以让我们首先创建一个尾递归版本。你可能会得到以下结果：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Unfortunately, this doesn’t work! Can you see why? If not, test this version
    and compare the result with the standard version. You can compare the two versions
    by using the test designed in the previous chapter:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这不起作用！你能看出为什么吗？如果不能，测试这个版本，并将结果与标准版本进行比较。你可以通过使用前一章设计的测试来比较这两个版本：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You’ll get the following result:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到以下结果：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This shows that the list is processed in reverse order. One easy solution is
    to reverse the list in the main method before calling the helper method. If you
    apply this trick while making the method stack-safe and recursive, you’ll get
    this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明列表是按逆序处理的。一个简单的解决方案是在调用辅助方法之前在主方法中反转列表。如果你在使方法安全递归的同时应用这个技巧，你会得到以下结果：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In [chapter 5](kindle_split_012.xhtml#ch05), you’ll develop the process of
    reversing the list by implementing `foldLeft` in terms of `foldRight`, and `foldRight`
    in terms of `foldLeft`. But this shows that the recursive implementation of `foldRight`
    won’t be optimal because `reverse` is an O(*n*) operation: the time needed to
    execute it is proportional to the number of elements in the list, because you
    must traverse the list. By using reverse, you double this time by traversing the
    list twice. The conclusion is that when considering using `fold-Right`, you should
    do one of the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 章 [kindle_split_012.xhtml#ch05] 中，你将通过实现 `foldLeft` 来实现反转列表的过程，以及 `foldRight`
    来实现 `foldLeft`。但这表明 `foldRight` 的递归实现不会是最优的，因为 `reverse` 是一个 O(*n*) 操作：执行它所需的时间与列表中的元素数量成正比，因为你必须遍历列表。通过使用
    `reverse`，你通过遍历列表两次而将这个时间加倍。结论是，在考虑使用 `fold-Right` 时，你应该做以下之一：
- en: Not care about performance
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不关心性能
- en: Change the function (if possible) and use `foldLeft`
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （如果可能）更改函数并使用 `foldLeft`
- en: Use `foldRight` only with small lists
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只使用小列表的 `foldRight`
- en: Use an imperative implementation
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令式实现
- en: 4.3\. Composing a huge number of functions
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 组合大量函数
- en: 'In [chapter 2](kindle_split_009.xhtml#ch02), you saw that you’ll overflow the
    stack if you try to compose a huge number of functions. The reason is the same
    as for recursion: because composing functions results in methods calling methods.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章 [kindle_split_009.xhtml#ch02] 中，你看到如果你尝试组合大量函数，你会溢出栈。原因与递归相同：因为组合函数会导致方法调用方法。
- en: Having to compose more than 7,000 functions may be something you don’t expect
    to do soon. On the other hand, there’s no reason not to make it possible. If it’s
    possible, someone will eventually find something useful to do with it. And if
    it’s not useful, someone will certainly find something fun to do with it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 需要组合超过 7,000 个函数可能不是你很快就会期望做的事情。另一方面，没有理由不使其成为可能。如果可能，最终有人会发现用它做些有用的事情。如果它没有用，有人肯定会找到一些有趣的事情来做。
- en: Exercise 4.6
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 4.6
- en: Write a function, `composeAll`, taking as its argument a list of functions from
    `T` to `T` and returning the result of composing all the functions in the list.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，`composeAll`，它接受一个从 `T` 到 `T` 的函数列表作为其参数，并返回列表中所有函数的组合结果。
- en: Solution 4.6
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 4.6
- en: 'To get the result you want, you can use a right fold, taking as its arguments
    the list of functions, the `identity` function (obtained by a call to the statically
    imported `Function.identity()` method), and the `compose` method written in [chapter
    2](kindle_split_009.xhtml#ch02):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到你想要的结果，你可以使用右折叠，将函数列表、通过静态导入的 `Function.identity()` 方法获得的 `identity` 函数和第
    2 章 [kindle_split_009.xhtml#ch02] 中编写的 `compose` 方法作为其参数：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To test this method, you can statically import all the methods from your `Collection-Utilities`
    class (developed in [chapter 3](kindle_split_010.xhtml#ch03)) and write the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个方法，你可以静态导入你的 `Collection-Utilities` 类（在第 3 章 [kindle_split_010.xhtml#ch03]
    中开发）中的所有方法，并编写以下内容：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you don’t feel comfortable with this kind of code, it’s equivalent to, but
    much more readable than, this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个类型的代码感到不舒服，它等同于，但比这个更易读：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Running this code displays 500, as it’s the result of composing 500 functions
    incrementing their argument by 1\. What happens if you replace 500 with 10,000?
    You’ll get a `StackOverflowException`. The reason should be obvious.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码显示500，因为它是通过组合500个函数，每次递增它们的参数1得到的。如果你将500替换为10,000会发生什么？你会得到一个`StackOverflowException`。原因应该是显而易见的。
- en: By the way, on the machine I used for this test, the program breaks for a list
    of 2,856 functions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，在我用于这个测试的机器上，程序在2,856个函数的列表上崩溃了。
- en: Exercise 4.7
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 4.7
- en: Fix this problem so you can compose an (almost) unlimited number of functions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这个问题，这样你就可以组合（几乎）无限数量的函数。
- en: Solution 4.7
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 4.7
- en: 'The solution to this problem is simple. Instead of composing the functions
    by nesting them, you have to compose their results, always staying at the higher
    level. This means that between each call to a function, you’ll return to the original
    caller. If this isn’t clear, imagine the imperative way to do this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案很简单。你不必通过嵌套函数来组合函数，而必须组合它们的结果，始终保持在更高的级别。这意味着在每次调用函数之间，你将返回到原始调用者。如果这还不清楚，想象一下强制性的方法来做这件事：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here, `identity` means the identity element of the given function. This isn’t
    composing functions, but composing function applications. At the end of the loop,
    you’ll get a `T` and not a `Function<T, T>`. But this is easy to fix. You create
    a function from `T` to `T`, which has the following implementation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`identity`表示给定函数的单位元素。这不是组合函数，而是组合函数应用。在循环结束时，你会得到一个`T`而不是`Function<T, T>`。但这很容易修复。你创建一个从`T`到`T`的函数，其实现如下：
- en: '![](Images/112fig01_alt.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/112fig01_alt.jpg)'
- en: 'You can’t use `x` directly, because it would create a closure, so it should
    be effectively final. That’s why you make a copy of it. This code works fine,
    except for two things. The first is that it doesn’t look functional. This can
    be fixed easily by using a fold. It can be either a left fold or a right fold:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接使用`x`，因为它会创建一个闭包，所以它应该是一个有效的最终值。这就是为什么你需要复制它。这段代码运行良好，除了两件事。第一点是它看起来不像是函数式的。这可以通过使用折叠来轻松修复。它可以是左折叠或右折叠：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You’re using a method reference for the `composeAllViaFoldRight` implementation.
    This is equivalent to the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`composeAllViaFoldRight`实现中使用了方法引用。这等同于以下内容：
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you have trouble understanding how it works, think about the analogy with
    `sum`. When you defined `sum`, the list was a list of integers. The initial value
    (`x` here) was `0`; `a` and `b` were the two parameters to add; and the addition
    was defined as `a + b`. Here, the list is a list of functions; the initial value
    is the identity function; `a` and `b` are functions; and the implementation is
    defined as `b.apply(a)` or `a.apply(b)`. In the `foldLeft` version, `b` is the
    function coming from the list, and `a` is the current result. In the `foldRight`
    version, `a` is the function coming from the list, and `b` is the current result.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你难以理解它是如何工作的，想想与`sum`的类比。当你定义`sum`时，列表是一个整数列表。初始值（这里的`x`）是`0`；`a`和`b`是两个要加的参数；加法被定义为`a
    + b`。在这里，列表是一个函数列表；初始值是单位函数；`a`和`b`是函数；实现被定义为`b.apply(a)`或`a.apply(b)`。在`foldLeft`版本中，`b`是从列表中来的函数，而`a`是当前结果。在`foldRight`版本中，`a`是从列表中来的函数，而`b`是当前结果。
- en: To see this in action, refer to the unit tests in the code available from the
    book’s site ([https://github.com/fpinjava/fpinjava](https://github.com/fpinjava/fpinjava)).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个动作，请参考从书籍网站提供的代码中的单元测试（[https://github.com/fpinjava/fpinjava](https://github.com/fpinjava/fpinjava))。
- en: Exercise 4.8
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 4.8
- en: The code has two problems, and you fixed only one. Can you see another problem
    and fix it?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有两个问题，而你只修复了一个。你能看到另一个问题并修复它吗？
- en: Hint
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'The second problem isn’t visible in the result because the functions you’re
    composing are specific. They are, in fact, a single function from integer to integer.
    The order in which they’re composed is irrelevant. Try to use the `composeAll`
    method with the following function list:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题在结果中不可见，因为你在组合的函数是特定的。实际上，它们是从整数到整数的单个函数。它们组合的顺序无关紧要。尝试使用以下函数列表的`composeAll`方法：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Solution 4.8
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 4.8
- en: 'We’ve implemented `andThenAll` rather than `composeAll`! To get the correct
    result, you first have to reverse the list:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了`andThenAll`而不是`composeAll`！为了得到正确的结果，你首先必须反转列表：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 4.4\. Using memoization
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4\. 使用记忆化
- en: In [section 4.2.3](#ch04lev2sec9), you implemented a function to display a series
    of Fibonacci numbers. One problem with this implementation of the Fibonacci series
    is that you want to print the string representing the series up to `f(n)`, which
    means you have to compute `f(1)`, `f(2)`, and so on, until `f(n)`. But to compute
    `f(n)`, you have to recursively compute the function for all preceding values.
    Eventually, to create the series up to `n`, you’ll have computed `f(1) n` times,
    `f(2) n – 1` times, and so on. The total number of computations will then be the
    sum of the integers 1 to *n*. Can you do better? Could you possibly keep the computed
    values in memory so you don’t have to compute them again if they’re needed several
    times?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4.2.3 节](#ch04lev2sec9) 中，你实现了一个函数来显示斐波那契数列的一系列数字。斐波那契数列实现的一个问题是，你想要打印表示序列直到
    `f(n)` 的字符串，这意味着你必须计算 `f(1)`、`f(2)` 等等，直到 `f(n)`。但为了计算 `f(n)`，你必须递归地计算所有先前值的函数。最终，为了创建到
    `n` 的序列，你将计算 `f(1)` `n` 次，`f(2)` `n – 1` 次，依此类推。那么，总的计算次数将是整数 1 到 *n* 的和。你能做得更好吗？你能否可能将计算过的值保存在内存中，这样在需要多次使用时就不必再次计算它们？
- en: 4.4.1\. Memoization in imperative programming
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1\. 命令式编程中的记忆化
- en: 'In imperative programming, you wouldn’t even have this problem, because the
    obvious way to proceed would be as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，你甚至不会遇到这个问题，因为明显的处理方式如下：
- en: '![](Images/114fig01_alt.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/114fig01_alt.jpg)'
- en: Although this program concentrates most of the problems that FP is supposed
    to avoid or to solve, it works and is much more efficient than your functional
    version. The reason is memoization.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个程序集中了FP应该避免或解决的问题，但它运行良好，并且比你的函数式版本更高效。原因是记忆化。
- en: '*Memoization* is a technique that keeps in memory the result of a computation
    so it can be returned immediately if you have to redo the same computation in
    the future. Applied to functions, memoization makes the functions memorize the
    results of previous calls, so they can return the results much faster if they’re
    called again with the same arguments.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*记忆化* 是一种技术，它将计算结果保存在内存中，以便在将来必须重新执行相同的计算时可以立即返回。应用于函数，记忆化使得函数记住之前调用的结果，因此如果它们再次以相同的参数调用，它们可以更快地返回结果。'
- en: This might seem incompatible with functional principles, because a memoized
    function maintains a state. But it isn’t, because the result of the function is
    the same when it’s called with the same argument. (You could even argue that it’s
    more the same, because it isn’t computed again!) The side effect of storing the
    results must not be visible from outside the function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来与函数式原则不兼容，因为记忆化的函数维护了一个状态。但实际上并非如此，因为当它以相同的参数调用时，函数的结果是相同的。（你甚至可以争论说它更相同，因为它不再重新计算了！）存储结果的副作用必须从函数外部不可见。
- en: In imperative programming, this might not even be noticed. Maintaining state
    is the universal way of computing results, so memoization isn’t even noticed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，这甚至可能不会被注意到。维护状态是计算结果的通用方式，因此记忆化甚至不会被注意到。
- en: 4.4.2\. Memoization in recursive functions
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2\. 递归函数中的记忆化
- en: Recursive functions often use memoization implicitly. In your example of the
    recursive Fibonacci function, you wanted to return the series, so you calculated
    each number in the series, leading to unnecessary recalculations. A simple solution
    is to rewrite the function in order to directly return the string representing
    the series.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数通常隐式地使用记忆化。在你的递归斐波那契函数示例中，你想要返回序列，所以你计算序列中的每个数字，导致不必要的重新计算。一个简单的解决方案是重写函数，以便直接返回表示序列的字符串。
- en: Exercise 4.9
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 4.9
- en: Write a stack-safe tail recursive function taking an integer `n` as its argument
    and returning a string representing the values of the Fibonacci numbers from `0`
    to `n`, separated by a comma and a space.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个安全的尾递归函数，该函数接受一个整数 `n` 作为其参数，并返回一个表示从 `0` 到 `n` 的斐波那契数列值的字符串，值之间用逗号和空格分隔。
- en: Hint
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: One solution is to use `StringBuilder` as the accumulator. `StringBuilder` isn’t
    a functional structure because it’s mutable, but this mutation won’t be visible
    from the outside. Another solution is to return a list of numbers and then transform
    it into a `String`. This solution is easier, because you can abstract the problem
    of the separators by first returning a list and then writing a function to turn
    the list into a comma-separated string.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是使用 `StringBuilder` 作为累加器。`StringBuilder` 不是一个函数式结构，因为它可变，但这种变化对外部是不可见的。另一种解决方案是返回一个数字列表，然后将其转换为
    `String`。这个解决方案更容易，因为你可以通过首先返回一个列表，然后编写一个函数将列表转换为以逗号分隔的字符串来抽象分隔符的问题。
- en: Solution 4.9
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 4.9
- en: The following listing shows the solution using `List` as the accumulator.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了使用 `List` 作为累加器的解决方案。
- en: Listing 4.5\. Recursive Fibonacci with implicit memoization
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5. 带隐式记忆化的递归斐波那契
- en: '![](Images/115fig01_alt.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/115fig01_alt.jpg)'
- en: Recursion or corecursion?
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 递归或核心递归？
- en: This example demonstrates the use of implicit memoization. Don’t conclude that
    this is the best way to solve the problem. Many problems are much easier to solve
    when twisted. So let’s twist this one.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了隐式记忆化的使用。不要认为这是解决问题的最佳方式。当问题被扭曲时，许多问题都更容易解决。所以让我们来扭曲这个问题。
- en: Instead of a suite of numbers, you could see the Fibonacci series as a suite
    of pairs (tuples). Instead of trying to generate this,
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将斐波那契数列看作是一系列对（元组），而不是一系列数字。而不是尝试生成这个，
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'you could try to produce this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试产生这个：
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In this series, each tuple can be constructed from the previous one. The second
    element of tuple `n` becomes the first element of tuple `n + 1`. The second element
    of tuple `n + 1` is equal to the sum of the two elements of tuple `n`. In Java,
    you can write a function for this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系列中，每个元组都可以从前一个元组构建。元组 `n` 的第二个元素成为元组 `n + 1` 的第一个元素。元组 `n + 1` 的第二个元素等于元组
    `n` 的两个元素之和。在 Java 中，你可以为这个操作编写一个函数：
- en: '[PRE53]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can now replace the recursive method with a corecursive one:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以用核心递归方法替换递归方法：
- en: '[PRE54]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `iterate` method takes a seed, a function, and a number *n*, and creates
    a list of length *n* by applying the function to each element to compute the next
    one. Here’s its signature:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterate` 方法接受一个种子、一个函数和一个数字 *n*，通过将函数应用于每个元素来计算下一个元素，创建一个长度为 *n* 的列表。这是它的签名：'
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This method is available in the `fpinjava-common` module.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在 `fpinjava-common` 模块中可用。
- en: 4.4.3\. Automatic memoization
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.3. 自动记忆化
- en: Memoization isn’t mainly used for recursive functions. It can be used to speed
    up any function. Think about how you perform multiplication. If you need to multiply
    234 by 686, you’ll probably need a pen and some paper, or a calculator. But if
    you’re asked to multiply 9 by 7, you can answer immediately, without doing any
    computation. This is because you use a memoized multiplication. A memoized function
    works the same way, although it needs to make the computation only once to retain
    the result.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化不仅仅用于递归函数。它可以用于加速任何函数。想想你是如何进行乘法的。如果你需要将 234 乘以 686，你可能需要笔和纸，或者计算器。但如果你被要求将
    9 乘以 7，你可以立即回答，而不需要进行任何计算。这是因为你使用了记忆化的乘法。记忆化的函数以同样的方式工作，尽管它只需要进行一次计算来保留结果。
- en: 'Imagine you have a functional method `doubleValue` that multiplies its argument
    by 2:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你有一个函数式方法 `doubleValue`，它将其参数乘以 2：
- en: '[PRE56]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You could memoize this method by storing the result into a map:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将结果存储到映射中来实现对这个方法的记忆化：
- en: '![](Images/117fig01_alt.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/117fig01_alt.jpg)'
- en: 'In Java 8, this can be made much shorter:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 8 中，这可以缩短很多：
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you prefer using functions (which is likely, given the subject of this book),
    you can apply the same principle:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用函数（鉴于本书的主题，这很可能是你想要的），你可以应用同样的原则：
- en: '[PRE58]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'But two problems arise:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 但出现了两个问题：
- en: You have to repeat this modification for all functions you want to memoize.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须为所有你想记忆化的函数重复此修改。
- en: The map you use is exposed to the outside.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用的映射暴露在外部。
- en: 'The second problem is easy to address. You can put the method or the function
    in a separate class, including the map, with private access. Here’s an example
    in the case of a method:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题很容易解决。你可以将方法或函数放在一个单独的类中，包括映射，并使用私有访问。以下是一个方法的例子：
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can then instantiate that class and use it each time you want to compute
    a value:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以实例化这个类，并在每次需要计算一个值时使用它：
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'With this solution, the map is no longer accessible from the outside. You can’t
    do the same for functions, because functions can’t have static members. One possibility
    is to pass the map to the function as an additional argument. This can be done
    through a closure:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种解决方案，映射不再可以从外部访问。你不能对函数做同样的事情，因为函数不能有静态成员。一种可能性是将映射作为额外的参数传递给函数。这可以通过闭包来完成：
- en: '[PRE61]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can use this function as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用此函数如下：
- en: '[PRE62]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This gives no advantage compared to the method solution. But you can also use
    this function in more idiomatic examples, such as this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这与方法解决方案相比没有优势。但你也可以在更符合习惯的例子中使用这个函数，例如这个：
- en: '[PRE63]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This is equivalent to using the method version with the following syntax:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这与使用以下语法的函数版本等效：
- en: '[PRE64]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The requirements
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要求
- en: 'What you need is a way to do the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的是一种方法来做以下事情：
- en: '[PRE65]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Then you can use the memoized function as a drop-in replacement for the original
    one. All values returned by function `g` will be calculated through the original
    function `f` the first time, and returned from the cache for all subsequent accesses.
    By contrast, if you create a third function,
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用缓存函数作为原始函数的替代品。函数`g`返回的所有值第一次都会通过原始函数`f`计算，并在后续访问中从缓存中返回。相比之下，如果你创建第三个函数，
- en: '[PRE66]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: the values cached by `g` won’t be returned by `h`; `g` and `h` will use separate
    caches.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`g`缓存的值不会被`h`返回；`g`和`h`将使用单独的缓存。'
- en: Implementation
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现
- en: The `Memoizer` class is simple and is shown in the following listing.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`Memoizer`类很简单，如下所示。'
- en: Listing 4.6\. The `Memoizer` class
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6\. `Memoizer`类
- en: '![](Images/119fig01_alt.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/119fig01_alt.jpg)'
- en: The following listing shows how this class can be used. The program simulates
    a long computation to show the result of memoizing the function.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何使用这个类。程序模拟了长时间的计算，以显示缓存函数的结果。
- en: Listing 4.7\. Demonstrating the memoizer
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.7\. 展示缓存器
- en: '![](Images/119fig02_alt.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/119fig02_alt.jpg)'
- en: 'Running the `automaticMemoizationExample` method on my computer produces the
    following result:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的电脑上运行`automaticMemoizationExample`方法会产生以下结果：
- en: '[PRE67]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note that the exact result will depend on the speed of your computer.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，确切的结果将取决于你电脑的速度。
- en: You can now make memoized functions out of ordinary ones by calling a single
    method, but to use this technique in production, you’d have to handle potential
    memory problems. This code is acceptable if the number of possible inputs is low,
    so you can keep all results in memory without causing memory overflow. Otherwise,
    you can use soft references or weak references to store memoized values.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过调用一个单一的方法将普通函数转换为缓存函数，但要在生产环境中使用这项技术，你必须处理潜在的内存问题。如果可能的输入数量很少，这段代码是可以接受的，因此你可以将所有结果保存在内存中而不会导致内存溢出。否则，你可以使用软引用或弱引用来存储缓存值。
- en: Memoization of “multiargument” functions
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: “多参数”函数的缓存
- en: 'As I said before, there’s no such thing in this world as a function with several
    arguments. Functions are applications of one set (the source set) to another set
    (the target set). They can’t have several arguments. Functions that appear to
    have several arguments are one of these:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，这个世界上没有多参数的函数。函数是将一个集合（源集合）应用于另一个集合（目标集合）的应用。它们不能有多个参数。看似有多个参数的函数是以下之一：
- en: Functions of tuples
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组函数
- en: Functions returning functions returning functions ... returning a result
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回函数的函数……返回结果
- en: In either case, you’re concerned only with functions of one argument, so you
    can easily use your `Memoizer` class.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，你只关心单参数的函数，因此你可以轻松地使用你的`Memoizer`类。
- en: Using functions of tuples is probably the simplest choice. You could use the
    `Tuple` class written in previous chapters, but to store tuples in maps, you’d
    have to implement `equals` and `hashcode`. Besides this, you’d have to define
    tuples for two elements (pairs), tuples for three elements, and so on. Who knows
    where to stop?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元组的函数可能是最简单的选择。你可以使用前面章节中编写的`Tuple`类，但为了在映射中存储元组，你必须实现`equals`和`hashcode`。除此之外，你还必须定义两个元素的元组（对），三个元素的元组，等等。谁知道在哪里停止？
- en: 'The second option is much easier. You have to use the curried version of the
    functions, as you did in previous chapters. Memoizing curried functions is easy,
    although you can’t use the same simple form as previously. You have to memoize
    each function:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择要简单得多。你必须使用函数的柯里化版本，就像你在前面的章节中所做的那样。缓存柯里化函数很容易，尽管你不能使用之前的那种简单形式。你必须缓存每个函数：
- en: '[PRE68]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You can use the same technique to memoize a function of three arguments:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的技巧来记忆化一个有三个参数的函数：
- en: '[PRE69]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The following listing shows an example of using this memoized function of three
    arguments.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了使用这个记忆化三个参数的函数的例子。
- en: Listing 4.8\. Testing a memoized function of three arguments for performance
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.8\. 测试三个参数的记忆化函数的性能
- en: '[PRE70]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This program produces the following output:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序产生了以下输出：
- en: '[PRE71]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This shows that the first access to the `longCalculation` method has taken 3,000
    milliseconds, and the second has returned immediately.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明第一次访问`longCalculation`方法花费了3,000毫秒，而第二次则立即返回。
- en: On the other hand, using a function of a tuple may seem easier after you have
    the `Tuple` class defined. The following listing shows an example of `Tuple3`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在定义了`Tuple`类之后，使用元组函数可能看起来更容易。以下列表展示了`Tuple3`的例子。
- en: Listing 4.9\. An implementation of `Tuple3`
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.9\. `Tuple3`的实现
- en: '[PRE72]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The following listing shows an example of testing a memoized function taking
    `Tuple3` as its argument.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了使用`Tuple3`作为参数的记忆化函数的测试例子。
- en: Listing 4.10\. A memoized function of `Tuple3`
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10\. 一个记忆化的`Tuple3`函数
- en: '[PRE73]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Are memoized functions pure?
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 记忆化函数是纯函数吗？
- en: Memoizing is about maintaining state between function calls. A memoized function
    is a function whose behavior is dependent on the current state. But it’ll always
    return the same value for the same argument. Only the time needed to return the
    value will be different. So the memoized function is still a pure function if
    the original function is pure.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化是关于在函数调用之间保持状态。一个记忆化的函数是一个其行为依赖于当前状态的函数。但它在相同的参数下总是会返回相同的值。只有返回值所需的时间会不同。所以，如果原始函数是纯函数，那么记忆化的函数仍然是一个纯函数。
- en: A variation in time may be a problem. A function like the original Fibonacci
    function needing many years to complete may be called *nonterminating*, so an
    increase in time may create a problem. On the other hand, making a function faster
    shouldn’t be a problem. If it is, there’s a much bigger problem somewhere else!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 时间上的变化可能是一个问题。像原始的斐波那契函数这样的函数可能需要很多年才能完成，可能被称为*非终止的*，所以时间的增加可能会造成问题。另一方面，使函数更快不应该是一个问题。如果是，那么其他地方可能有一个更大的问题！
- en: 4.5\. Summary
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5\. 总结
- en: A recursive function is a function that’s defined by referencing itself.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归函数是定义为引用自身的函数。
- en: In Java, recursive methods push the current computation state onto the stack
    before recursively calling themselves.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 中，递归方法在递归调用自身之前将当前计算状态推入栈中。
- en: The Java default stack size is limited. It can be configured to a larger size,
    but this generally wastes space because all threads use the same stack size.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 的默认栈大小是有限的。它可以配置为更大的大小，但通常这会浪费空间，因为所有线程都使用相同的栈大小。
- en: Tail recursive functions are functions in which the recursive call is in the
    last (tail) position.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾递归函数是递归调用位于最后（尾端）位置的函数。
- en: In some languages, recursive functions are optimized using tail call elimination
    (TCE).
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些语言中，递归函数通过尾调用消除（TCE）进行优化。
- en: Java doesn’t implement TCE, but it’s possible to emulate it.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 不实现 TCE，但可以模拟它。
- en: Lambdas may be made recursive.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 可以被递归。
- en: Memoization allows functions to remember their computed values in order to speed
    up later accesses.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆化允许函数记住它们的计算值，以便加快后续访问。
- en: Memoization can be made automatic.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆化可以自动进行。
