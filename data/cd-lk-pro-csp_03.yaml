- en: 2 .NET and how it compiles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 .NET 及其编译方式
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Compiling C# to native code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 C# 编译成本地代码
- en: Reading and understanding Intermediate Language
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读和理解中间语言
- en: In 2020, Microsoft released .NET 5, an all-encompassing software development
    platform. Before that, in the late 1990s and early 2000s, Microsoft created the
    .NET Framework, which was the precursor to .NET 5\. The original use case for
    the .NET Framework was developing enterprise Windows applications. In fact, we’ll
    use the .NET Framework to examine exactly such a codebase in chapters 3 and 4\.
    The .NET Framework ties together a large collection of libraries. Although the
    .NET Framework and C# are frequently used together, we do encounter use cases
    for the .NET Framework without C# (most notably, using a different .NET language).
    The two most important pillars of the .NET Framework are the Framework Class Library
    (FCL; a humongous class library that is the backbone of the .NET Framework) and
    the Common Language Runtime (CLR; the runtime environment of .NET that contains
    the JIT compiler, garbage collector, primitive data types, and more). In other
    words, the FCL contains all the libraries you are likely to use, and the CLR executes
    the code. Later on, Microsoft introduced .NET Core, aimed at multiplatform development.
    See figure 2.1 for where this chapter falls in the book’s scheme.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2020 年，微软发布了全功能的软件开发平台 .NET 5。在此之前，在 1990 年代末和 2000 年代初，微软创建了 .NET Framework，它是
    .NET 5 的前身。.NET Framework 的原始用途是开发企业级 Windows 应用程序。实际上，我们将在第 3 章和第 4 章中使用 .NET
    Framework 来检查这样的代码库。.NET Framework 将大量库连接在一起。尽管 .NET Framework 和 C# 经常一起使用，但我们确实遇到过不使用
    C# 的 .NET Framework 用例（最显著的是使用不同的 .NET 语言）。.NET Framework 的两个最重要的支柱是框架类库（FCL；这是一个庞大的类库，是
    .NET Framework 的骨架）和公共语言运行时（CLR；包含 JIT 编译器、垃圾回收器、原始数据类型等 .NET 的运行环境）。换句话说，FCL
    包含了你可能使用的所有库，而 CLR 执行代码。后来，微软推出了旨在多平台开发的 .NET Core。参见图 2.1 了解本章在本书结构中的位置。
- en: '![](../Images/02_01.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02_01.png)'
- en: Figure 2.1 So far, you’ve learned about what to expect in this book. In this
    chapter, we’ll dive into what .NET and its flavors are. By discussing the .NET
    ecosystem, we’ll gain a baseline understanding that will serve us well in the
    rest of the book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 到目前为止，你已经了解了本书的预期内容。在本章中，我们将深入了解 .NET 及其变体。通过讨论 .NET 生态系统，我们将获得一个基准理解，这将有助于我们在本书的其余部分。
- en: In this chapter, we’ll discuss a couple of features of .NET 5 and contrast them
    against implementations (and sometimes the lack thereof) in other platforms such
    as Java, Python, and Go. After that, we’ll learn about the C# compilation process
    by showing how a C# method is translated from C# to Common Intermediate Language
    (CIL) to native code. These fundamental building blocks allow us to have a solid
    foundation in our knowledge of the C# language and the .NET ecosystem. If you
    are already familiar with C# and .NET, this chapter is bound to have some repetition
    for you. If nothing else, I suggest you read through section 2.3\. The discussion
    on the C# compilation process is deeper than what you find in most resources and
    is assumed knowledge in some advanced C# resources. To test your knowledge of
    the respective topics, sections 2.2 and 2.3 have exercises for you to try.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 .NET 5 的几个特性，并将它们与其他平台（如 Java、Python 和 Go）的实现（有时是没有实现）进行对比。之后，我们将通过展示一个
    C# 方法是如何从 C# 转换为通用中间语言（CIL）再到本地代码的过程来学习 C# 的编译过程。这些基本构建块使我们能够在 C# 语言和 .NET 生态系统方面的知识上打下坚实的基础。如果你已经熟悉
    C# 和 .NET，那么本章对你来说可能有些重复。至少，我建议你阅读第 2.3 节。关于 C# 编译过程的讨论比大多数资源中的内容都要深入，并且在一些高级
    C# 资源中被视为基础知识。为了测试你对相关主题的了解，第 2.2 节和第 2.3 节为你提供了练习题。
- en: 2.1 What is the .NET Framework?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 什么是 .NET Framework？
- en: In the beginning . . . there was the .NET Framework—the old-school way of using
    .NET. The .NET Framework was introduced in the early 2000s by Microsoft. Developers
    could use C# with it to write enterprise desktop applications. Because Microsoft
    had an intrinsic interest in targeting Windows, the .NET Framework works only
    on Windows and relies on many Windows APIs to perform graphic operations. If you
    work on any desktop application written in C# before late 2020 (and the introduction
    of .NET 5), I guarantee you it was written using .NET Framework.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始……是 .NET Framework——使用 .NET 的传统方式。.NET Framework 由微软在 2000 年代初引入。开发者可以使用
    C# 与之配合编写企业桌面应用程序。由于微软对针对 Windows 有内在兴趣，.NET Framework 只能在 Windows 上运行，并依赖于许多
    Windows API 来执行图形操作。如果你在 2020 年晚些时候（以及 .NET 5 的引入）之前从事任何用 C# 编写的桌面应用程序，我保证它使用的是
    .NET Framework。
- en: The .NET Framework has gone through various iterations over time, but the most
    recent release (July 2019) is 4.8.0\. There will be no further releases of the
    .NET Framework because it’s been replaced with .NET 5, but its many legacy applications
    will live on. A lot of the material covered in this book applies to .NET Framework.
    In fact, we’ll see a .NET Framework application in chapters 3 and 4.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework 随着时间的推移经历了多次迭代，但最新的版本（2019 年 7 月）是 4.8.0。由于已被 .NET 5 取代，因此将不再发布
    .NET Framework 的后续版本，但它的许多遗留应用程序将继续存在。本书中涵盖的许多内容都适用于 .NET Framework。实际上，我们将在第
    3 章和第 4 章中看到一个 .NET Framework 应用程序。
- en: 2.2 What is .NET 5?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 什么是 .NET 5？
- en: 'In this section, we’ll talk about what .NET 5 is and why it exists. Since 2016,
    .NET has existed as two major streams: .NET Framework and .NET Core. The new .NET
    5 combines these two streams (as well as different auxiliary streams such as Xamarin
    and Unity), as shown in figure 2.2\. In effect, .NET 5 is a rebranding of .NET
    Core as it forms the basis for a new .NET. We should therefore see .NET 5 as not
    just another iteration of the .NET Framework or .NET Core but rather as a reboot
    and merger of previous technologies.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论 .NET 5 是什么以及为什么它存在。自 2016 年以来，.NET 存在为两大主要分支：.NET Framework 和 .NET
    Core。新的 .NET 5 将这两个分支（以及如 Xamarin 和 Unity 这样的不同辅助分支）合并在一起，如图 2.2 所示。实际上，.NET 5
    是将 .NET Core 重命名，因为它构成了新 .NET 的基础。因此，我们应该将 .NET 5 视为不仅仅是 .NET Framework 或 .NET
    Core 的另一个迭代，而更是一个重启和合并了之前技术的过程。
- en: Housing all .NET technologies under one umbrella gives you access to all the
    tools and use cases you want. You can develop enterprise software, websites, video
    games, Internet of Things (IoT), embedded applications running on Windows/macOS/
    Linux, ARM processors (ARM32/64), machine learning services (ML.NET), applications,
    cloud services, and mobile apps, all throughout the same framework. And because
    the .NET Framework adheres to the .NET Standard, all existing codebases and libraries
    should be compatible with .NET 5 (as long as .NET 5 supports the underlying packages
    and features used by the codebase).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有 .NET 技术置于一个统一的框架下，你可以访问所有你想要的工具和用例。你可以开发企业软件、网站、视频游戏、物联网（IoT）、在 Windows/macOS/Linux
    上运行的嵌入式应用程序、ARM 处理器（ARM32/64）、机器学习服务（ML.NET）、应用程序、云服务和移动应用，这一切都在同一个框架中完成。并且由于
    .NET Framework 遵循 .NET 标准规范，所有现有的代码库和库都应该与 .NET 5 兼容（只要 .NET 5 支持代码库使用的底层包和功能）。
- en: '![](../Images/02_02.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02_02.png)'
- en: 'Figure 2.2 .NET 5 merges .NET Framework 4 with ARM32/64, Xamarin, .NET Core
    3, Unity, and ML.NET. This allows us to use all those .NET variations under one
    umbrella: .NET 5.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 .NET 5 将 .NET Framework 4 与 ARM32/64、Xamarin、.NET Core 3、Unity 和 ML.NET
    合并。这使得我们可以在一个统一的框架下使用所有这些 .NET 变体：.NET 5。
- en: '.NET 5, just like the .NET Framework and .NET Core, is an implementation of
    the .NET Standard—a specification that has been used to develop a variety of implementations
    of .NET: .NET 5, .NET Framework, .NET Core, Mono (the cross-platform technology
    that .NET Core is built on), Unity (video game development), and Xamarin (iOS
    and Android development). These have different use cases but are inherently very
    similar. Developing an implementation against the .NET Standard means that code
    sharing between implementations is as seamless as possible.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 5，就像 .NET Framework 和 .NET Core 一样，是 .NET 标准的实现——这是一个用于开发各种 .NET 实现的规范：.NET
    5、.NET Framework、.NET Core、Mono（.NET Core 所基于的跨平台技术）、Unity（视频游戏开发）和 Xamarin（iOS
    和 Android 开发）。这些实现有不同的用途，但本质上非常相似。针对 .NET 标准开发意味着实现之间的代码共享尽可能无缝。
- en: The .NET Standard contains information on what APIs are available for use when
    interacting with the CLR (the runtime on which C# depends). Before the .NET Standard,
    we had no real way of making sure that our code or library would work across .NET
    implementations, besides using Portable Class Libraries (PCL). PCLs are libraries
    that can be shared among projects but can target only a specific version of a
    .NET implementation (or “profile”). Today we call these PCLs “profile-based PCLs.”
    Libraries targeting a .NET implementation adhering to the .NET Standard are also
    PCLs, but instead of targeting a specific implementation, they target a version
    of the .NET Standard. To differentiate between profile-based PCLs, we call these
    “.NET Standard-based PCLs.” The .NET Standard encapsulates a lot of the Windows
    APIs used by libraries written in the pre–.NET Standard era (and, therefore, profile-based
    PCLs). As a result, we can use those libraries in any .NET Standard implementation
    of .NET without a problem. The first version of the .NET Framework to implement
    the .NET Standard was 4.5.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: .NET标准包含有关与CLR（C#所依赖的运行时）交互时可用哪些API的信息。在.NET标准之前，我们除了使用可移植类库（PCL）之外，没有真正的方法来确保我们的代码或库能够在.NET实现之间工作。PCL是可以在不同项目之间共享的库，但只能针对.NET实现的一个特定版本（或“配置文件”）。今天我们称这些PCL为“基于配置文件的PCL”。针对遵循.NET标准的.NET实现的库也是PCL，但它们不是针对特定实现，而是针对.NET标准的某个版本。为了区分基于配置文件的PCL，我们称这些为“基于.NET标准的PCL”。.NET标准封装了在.NET标准时代之前编写的库所使用的许多Windows
    API（因此，基于配置文件的PCL）。因此，我们可以在任何.NET标准实现的.NET中无问题地使用这些库。第一个实现.NET标准的.NET Framework版本是4.5。
- en: In keeping with Microsoft’s push for open source software, .NET 5 and all its
    related repositories are open source and available on GitHub ([https://github.com/
    dotnet](https://github.com/dotnet)). For more information on new features slated
    to be included in new versions of .NET, see the CoreFX roadmap at [https://github.com/dotnet/corefx/milestones](https://github.com/dotnet/corefx/milestones).
    You can access the .NET Standard at [https://github.com/dotnet/standard](https://github.com/dotnet/standard).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循微软对开源软件的推动，.NET 5及其所有相关仓库都是开源的，可在GitHub上找到（[https://github.com/dotnet](https://github.com/dotnet)）。有关新版本.NET中计划包含的新功能的更多信息，请参阅CoreFX路线图[https://github.com/dotnet/corefx/milestones](https://github.com/dotnet/corefx/milestones)。您可以通过[https://github.com/dotnet/standard](https://github.com/dotnet/standard)访问.NET标准。
- en: Exercises
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 2.1
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.1
- en: Which one of the following operating systems is not supported by .NET 5?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个操作系统不受.NET 5支持？
- en: a. Windows
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: a. Windows
- en: b. macOS
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: b. macOS
- en: c. Linux
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: c. Linux
- en: d. AmigaOS
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: d. AmigaOS
- en: Exercise 2.2
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.2
- en: What does the term “CLR” stand for?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: “CLR”这个术语代表什么？
- en: a. Creative License Resources
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: a. 创意许可资源
- en: b. Class Library Reference
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: b. 类库参考
- en: c. Common Language Runtime
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: c. 常见语言运行时
- en: Exercise 2.3
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.3
- en: 'Fill in the blanks: The .NET Standard is a(n) __________, which dictates implementation
    details for all .NET platforms to enable code sharing.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 填空：.NET标准是一个(n) __________，它规定了所有.NET平台实现细节，以实现代码共享。
- en: a. implementation
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: a. 实现
- en: b. precursor
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: b. 前身
- en: c. tool
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: c. 工具
- en: d. specification
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: d. 规范
- en: 2.3 How CLI-compliant languages are compiled
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 如何编译符合CLI的语言
- en: 'In this section, you’ll get an in-depth look at how C# (and other Common Language
    Infrastructure–compliant languages; see section 2.3.2) compiles. Knowing the entire
    compilation story prepares you to take advantage of all of C#’s features while
    understanding some of the pitfalls related to memory and execution. The C# compilation
    process knows three states (C#, Intermediate Language, and native code) and two
    stages, as shown in figure 2.3: going from C# to Common Intermediate Language
    and going from Intermediate Language to native code.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将深入了解C#（以及其他符合通用语言基础设施（Common Language Infrastructure）的语言；参见2.3.2节）的编译过程。了解整个编译过程可以帮助您充分利用C#的所有功能，同时了解一些与内存和执行相关的陷阱。C#的编译过程知道三个状态（C#、中间语言和本地代码）和两个阶段，如图2.3所示：从C#到通用中间语言，再到本地代码。
- en: '![](../Images/02_03.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02_03.png)'
- en: Figure 2.3 The complete C# compilation process. It goes from C# code to Common
    Intermediate Language to native code. Understanding the compilation process gives
    us knowledge about some of the internal choices made around C# and .NET.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 完整的C#编译过程。它从C#代码到通用中间语言，再到本地代码。理解编译过程使我们能够了解C#和.NET内部的一些选择。
- en: NOTE Native code is sometimes referred to as *machine code*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本地代码有时被称为*机器代码*。
- en: By looking at what it takes to go from one step to the other and follow a method
    as the compiler and CLR compile the high-level C# code down to runnable native
    code, we gain an understanding of the complex machine that is C# and .NET 5\.
    A good understanding of this process is often a resource gap found in beginner
    resources, but advanced resources require you to understand this.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察从一步到另一步需要什么，并遵循编译器和 CLR 将高级 C# 代码编译成可执行原生代码的方法，我们能够理解 C# 和 .NET 5 的复杂机器。对这一过程的理解通常是初学者资源中发现的资源差距，但高级资源要求你理解这一点。
- en: 'We use a combination of static compilation and JIT compilation to compile C#
    to native code as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用静态编译和即时编译的组合将 C# 编译成原生代码，如下所示：
- en: After a developer writes the C# code, they compile their code. This results
    in Common Intermediate Language stored within Portable Executable (PE for 32 bit,
    PE+ for 64 bit) files such as .exe and .dll files for Windows. These files are
    distributed or deployed to users.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者编写完 C# 代码后，他们会编译他们的代码。这会在可移植可执行文件（PE 文件，32 位为 PE，64 位为 PE+）中存储通用中间语言（CIL），例如
    .exe 和 .dll 文件，用于 Windows。这些文件被分发或部署给用户。
- en: 'When we launch a .NET program, the operating system invokes the Common Language
    Runtime. The Common Language Runtime JIT compiles the CIL to the native code appropriate
    for the platform it is running on. This allows CLI-compliant languages to run
    on a lot of platforms and compiler types. However, it would be amiss not to mention
    the major negative implication of using a virtual machine and JIT compiler to
    run your code: performance.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们启动 .NET 程序时，操作系统调用公共语言运行时（CLR）。公共语言运行时的即时编译器将 CIL 编译成适合其运行平台的原生代码。这允许 CLI
    兼容的语言在许多平台和编译器类型上运行。然而，不提一下使用虚拟机和即时编译器运行代码的主要负面影响：性能。
- en: A statically compiled program has a leg up at execution time because you don’t
    need to wait on a runtime to compile the code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 静态编译的程序在执行时具有优势，因为你不需要等待运行时来编译代码。
- en: DEFINITION Static and JIT compilation are two commonly used ways of compiling
    code. C# uses a combination of static compilation and JIT compilation. This entails
    that the code is compiled down to bytecode at the last possible moment. Static
    compilation compiles all the source code ahead of time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 静态编译和即时编译是两种常用的代码编译方式。C# 使用静态编译和即时编译的组合。这意味着代码在最后可能的时刻被编译成字节码。静态编译在编译前将所有源代码编译完成。
- en: '2.3.1 Step 1: C# code (high-level)'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 步骤 1：C# 代码（高级）
- en: The first time I encountered the Pythagorean theorem was in 2008\. I was in
    the Dutch version of high school and saw in the mathematics textbook that we would
    cover the Pythagorean theorem that year. A couple of days later, late at night,
    I was in the car with my father. We had been driving for a while, so the conversation
    had reached a natural slow point. In a completely out-of-character moment, I asked
    him, “What is the Pythagorean theorem?” The question clearly took him aback because
    I had shown little academic interest, especially in mathematics, at that point
    in time. For the next ten minutes, he attempted to explain to me, somebody with
    the mathematical abilities of a grapefruit, what the Pythagorean theorem was.
    I was surprised I actually understood what he was talking about, and now, years
    later, it has proven to be an excellent resource to show you the first step in
    the C# compilation process.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次遇到勾股定理是在 2008 年。当时我在荷兰高中版本的学校，看到数学课本中提到我们那年会学习勾股定理。几天后的深夜，我和父亲在车里。我们已经开了一段时间车，所以对话自然慢了下来。在一个完全不合时宜的时刻，我问了他，“什么是勾股定理？”这个问题显然让他很惊讶，因为我当时对学术几乎没有兴趣，尤其是在数学方面。接下来的十分钟，他试图向我解释，一个数学能力相当于葡萄柚的人，什么是勾股定理。我惊讶地发现我实际上理解了他所说的内容，现在，多年以后，这已经证明是展示
    C# 编译过程第一步的一个极好的资源。
- en: 'In this section, we’ll look at the first step in the C# compilation process:
    compiling C# code, as shown in figure 2.4\. The program we’ll follow through the
    compilation process is the Pythagorean theorem. The reason for using a program
    representing the Pythagorean theorem to teach you that the C# compilation process
    is straightforward: we can condense the Pythagorean theorem to a couple of lines
    of code that are understandable with a high school level of mathematical knowledge.
    This lets us focus on the compilation story instead of on implementation details.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看 C# 编译过程的第一个步骤：编译 C# 代码，如图 2.4 所示。我们将跟随编译过程的是勾股定理。使用代表勾股定理的程序来向您展示
    C# 编译过程是直截了当的原因是：我们可以将勾股定理压缩为几行代码，这些代码可以用高中水平的数学知识理解。这使得我们可以专注于编译故事而不是实现细节。
- en: '![](../Images/02_04.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02_04.png)'
- en: 'Figure 2.4 The C# compilation process, step 1: C# code. This is the static
    compilation phase.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 C# 编译过程，步骤 1：C# 代码。这是静态编译阶段。
- en: NOTE If a quick refresher is in order, the Pythagorean theorem states that *a*²
    + *b*² = *c*². We commonly apply the Pythagorean theorem to discovering the length
    of a right-angled triangle’s hypotenuse by taking the square root of the resulting
    value, which is the sum of the squared lengths of the two sides adjacent to the
    right-angled triangle.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果需要快速复习，勾股定理表明 *a*² + *b*² = *c*²。我们通常将勾股定理应用于通过取结果的平方根来发现直角三角形斜边的长度，该结果为直角三角形相邻两边的平方长度的和。
- en: We’ll start by writing a simple method that proves the Pythagorean theorem when
    given two arguments, as shown in the next listing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的、当给定两个参数时证明勾股定理的方法开始，如下一列表所示。
- en: Listing 2.1 Pythagorean theorem (high level)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 勾股定理（高级）
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '❶ We declare a method with a public access modifier, returning a floating-point
    number, called Pythagoras, that expects two floating-point (double) arguments:
    sideLengthA and sideLengthB.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们声明一个具有公共访问修饰符的方法，返回一个浮点数，名为 Pythagoras，它期望两个浮点数（double）参数：sideLengthA 和
    sideLengthB。
- en: ❷ We perform the Pythagorean theorem and assign the result to a variable called
    squaredLength.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们执行勾股定理并将结果赋值给一个名为 squaredLength 的变量。
- en: If we run this code and give it the arguments of `[3, 8],` we see that the result
    is 73, which is correct. Alternatively, because we are using 64-bit floating-point
    numbers (doubles), we can also test argument sets like. The result is 12037.7057.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码并给它 `[3, 8]` 的参数，我们看到结果是 73，这是正确的。或者，因为我们使用的是 64 位浮点数（doubles），我们也可以测试类似集合的参数。结果是
    12037.7057。
- en: Access modifiers, assemblies, and namespaces
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符、程序集和命名空间
- en: 'C# knows six access modifiers (from most open to most restrictive): public,
    protected internal, internal, protected, protected private, and private. The two
    you use the most in daily life are public and private. *Public* signifies availability
    across all classes and projects (this is the concept of “exported” in some languages;
    unlike some of those programming languages, the capitalization of a method name
    does not matter when it comes to access modifiers in C#), and *private* means
    visible only from the current class.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: C# 知道六个访问修饰符（从最开放到最限制）：公共、受保护内部、内部、受保护、受保护私有和私有。您在日常生活中使用最多的两个是公共和私有。*公共* 表示对所有类和项目的可用性（这是某些语言中“导出”的概念；与某些编程语言不同，在
    C# 中，方法名称的大小写对访问修饰符没有影响），而 *私有* 表示仅在当前类中可见。
- en: The other four (internal, protected, protected internal, and private protected)
    are used less often but good to know. *Internal* gives access to all classes in
    its own assembly, and *protected* limits access to only classes that derive from
    the original class. That leaves *internal protected*. This access modifier is
    a combination of the internal and protected access modifiers. It grants access
    to derived classes and its own assembly. *Private protected* gives access within
    its own assembly but only to the code in the same class or in a derived class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 其他四个（内部、受保护的、受保护的内部和私有受保护的）使用较少，但了解它们是有好处的。*内部* 允许对其自己的程序集内的所有类进行访问，而 *受保护的*
    限制了对从原始类派生的类的访问。这留下了 *内部受保护的*。这个访问修饰符是内部和受保护的访问修饰符的组合。它允许派生类及其自己的程序集进行访问。*私有受保护的*
    允许在其自己的程序集内进行访问，但仅限于同一类或派生类中的代码。
- en: '![](../Images/02_04_UN01.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02_04_UN01.png)'
- en: C# access modifiers from open to restricted. Using the correct access modifier
    helps with encapsulating our data and protecting our classes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: C# 访问修饰符从开放到受限。使用正确的访问修饰符有助于封装我们的数据并保护我们的类。
- en: 'Now we compile the code. Let us assume that the method in listing 2.1 is part
    of a class called `HelloPythagoras`, which is part of a project and solution also
    called `HelloPythagoras`. To compile a .NET 5 (or .NET Framework/.NET Core solution)
    to Intermediate Language stored in a PE/PE+ file, you can either use the build
    or compiler button in your IDE or run the following command in your command line:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们编译代码。假设列表 2.1 中的方法是一个名为 `HelloPythagoras` 的类的部分，该类是名为 `HelloPythagoras`
    的项目和解决方案的一部分。要将 .NET 5（或 .NET Framework/.NET Core 解决方案）编译成存储在 PE/PE+ 文件中的中间语言，您可以使用
    IDE 中的构建或编译器按钮，或者在命令行中运行以下命令：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A solution file ends with the file extension .sln. The command to create our
    solution follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案文件以 .sln 扩展名结尾。创建我们的解决方案的命令如下：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After we run the command, the compiler launches. First, the compiler restores
    all the required dependency packages through the NuGet package manager. Then the
    command-line tool compiles the project and stores the output in a new folder called
    bin. Within the bin folder are two potential options for further folders, debug
    and release, depending on the mode we set the compiler to (you can define your
    own modes if you want to). By default, the compiler compiles in debug mode. Debug
    mode contains all the debug information (stored in .pdb files) that you need to
    step through an application with breakpoints.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行命令后，编译器启动。首先，编译器通过 NuGet 包管理器恢复所有必需的依赖项包。然后，命令行工具编译项目并将输出存储在一个名为 bin 的新文件夹中。在
    bin 文件夹中，根据我们设置的编译器模式（如果您想的话，可以定义自己的模式），有两个潜在的文件夹选项，即调试和发布。默认情况下，编译器以调试模式编译。调试模式包含所有调试信息（存储在
    .pdb 文件中），这些信息是您使用断点逐步通过应用程序所需的。
- en: To compile in release mode through the command line, append the `--Configuration
    release` flag to the command. Alternatively, in Visual Studio, select debug or
    release mode from the drop-down list. This is the easiest, quickest, and the likeliest
    way you will compile your code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过命令行以发布模式编译，请将 `--Configuration release` 标志附加到命令中。或者，在 Visual Studio 中，从下拉列表中选择调试或发布模式。这是您编译代码最容易、最快且最可能的方式。
- en: '| ![](../Images/LightBulb.png)   |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| ![灯泡](../Images/LightBulb.png)   |'
- en: Debug and release build modes
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和发布构建模式
- en: In daily life, the practical difference between the debug and release modes
    are performance and security. By including references to the .pdb files in the
    debug build’s output code, the runtime has to iterate over more code to do the
    same logic than you would in a release mode where those references are not present.
    As a result, the Intermediate Language required to model that code is larger and
    takes longer to compile when compared to release mode.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常生活中，调试和发布模式之间的实际区别在于性能和安全。通过在调试构建的输出代码中包含对 .pdb 文件的引用，运行时必须迭代更多代码来完成相同的逻辑，这比在发布模式中要复杂，因为在发布模式中这些引用不存在。因此，与发布模式相比，建模该代码所需的中间语言更大，编译时间更长。
- en: Additionally, if you include debugging information, somebody with malicious
    intent could potentially use that information to their advantage and have an easier
    window into your codebase. This is not to say that compiling in release mode removes
    any need for good security practices. Intermediate Language can easily be decompiled
    (whether originally compiled in debug or release mode) to something similar to
    the original source code. If you want to appropriately protect your source code,
    consider looking into obfuscators (Dotfuscator, .NET Reactor) and threat models.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您包含调试信息，心怀恶意的人可能会利用这些信息，从而更容易地访问您的代码库。这并不是说在发布模式下编译就消除了对良好安全实践的任何需求。中间语言可以很容易地反编译（无论最初是在调试还是发布模式下编译），变成与原始源代码类似的东西。如果您想适当地保护您的源代码，请考虑研究混淆器（Dotfuscator、.NET
    Reactor）和威胁模型。
- en: A good rule of thumb is to develop using debug mode and test with both debug
    and release modes. Often this takes the form of testing locally under debug mode
    and doing user acceptance testing in a dedicated environment with a release build.
    Because the code between modes is slightly different, you may find bugs in the
    release mode that you don’t find in the debug mode. You do not want to be in a
    situation where you tested only the debug build and find a blocking bug in the
    release build right before your deadline.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的经验法则是使用调试模式进行开发，并使用调试和发布模式进行测试。通常，这包括在调试模式下本地测试，并在具有发布构建的专用环境中进行用户验收测试。因为不同模式之间的代码略有不同，你可能会在发布模式下发现调试模式下没有发现的错误。你不想处于只测试了调试构建，而在截止日期前发现发布构建中存在阻止性错误的境地。
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: At this point, the C# high-level code is compiled into an executable file containing
    the Intermediate Language code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，C# 高级代码被编译成一个包含中间语言代码的可执行文件。
- en: '2.3.2 Step 2: Common Intermediate Language (assembly level)'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 步骤 2：公共中间语言（汇编级别）
- en: From a day-to-day perspective, your job is done. The code is in an executable
    form, and you can wrap up your ticket or user story. From a technological perspective,
    the journey is just getting started. The C# code is statically compiled down to
    Common Intermediate Language, as shown in figure 2.5, but IL cannot be run by
    the operating system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从日常工作的角度来看，你的工作已经完成。代码已经以可执行形式存在，你可以关闭你的工单或用户故事。从技术角度来看，旅程才刚刚开始。C# 代码被静态编译成公共中间语言，如图
    2.5 所示，但 IL 不能由操作系统运行。
- en: '![](../Images/02_05.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.5](../Images/02_05.png)'
- en: 'Figure 2.5 The C# compilation process, step 2: Intermediate Language. Here
    we go from static to just-in-time compilation.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 C# 编译过程，步骤 2：中间语言。我们从静态编译转换到即时编译。
- en: 'But how do you get from IL to native code? The missing piece is the Common
    Language Runtime (CLR). This part of .NET 5 translates Common Intermediate Language
    to native code. It is the “runtime” of .NET. We can compare the CLR to the Java
    Virtual Machine (JVM). The CLR has been part of .NET since the very beginning.
    It is also good to note that with the movement toward .NET Core and .NET 5, a
    new implementation of the CLR is taking the place of the old CLR: CoreCLR. The
    explanations in this book regarding the CLR are valid for both the traditional
    CLR and CoreCLR, and the term CLR is used for both the regular Common Language
    Runtime and CoreCLR.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但你是如何从 IL 转换到本地代码的呢？缺失的部分是公共语言运行时（CLR）。.NET 5 的这部分将公共中间语言转换为本地代码。它是 .NET 的“运行时”。我们可以将
    CLR 与 Java 虚拟机（JVM）进行比较。CLR 一直是 .NET 的一部分。值得注意的是，随着向 .NET Core 和 .NET 5 的转变，一个新的
    CLR 实现正在取代旧的 CLR：CoreCLR。本书中关于 CLR 的解释适用于传统的 CLR 和 CoreCLR，术语 CLR 适用于常规的公共语言运行时和
    CoreCLR。
- en: Any code that is written using an implementation of a technical standard called
    Common Language Infrastructure (CLI), such as .NET 5, can be compiled down to
    Common Intermediate Language. The CLI describes the infrastructure behind.NET,
    whose specific flavors are implementations of the CLI themselves, and gives languages
    a basis around which to form their type system. Because the CLR can take any piece
    of Intermediate Language (IL), and the .NET compiler can generate this IL from
    any CLI-compliant language, we can have IL code generated from mixed-source code.
    C#, Visual Basic, and F# are the most common .NET programming languages, but a
    bunch more are also available. See table 2.1 for a roundup of these acronyms.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用称为公共语言基础设施（CLI）的技术标准实现的代码，例如 .NET 5，都可以编译成公共中间语言。CLI 描述了 .NET 背后的基础设施，其具体风味是
    CLI 的实现本身，并为语言提供了一个形成其类型系统的基础。因为 CLR 可以接受任何中间语言（IL）片段，而 .NET 编译器可以从任何 CLI 兼容的语言生成这种
    IL，所以我们可以从混合源代码生成 IL 代码。C#、Visual Basic 和 F# 是最常用的 .NET 编程语言，但还有更多可供选择。请参阅表 2.1
    以了解这些缩写的汇总。
- en: Until 2017, Microsoft also supported J#, a CLI-compliant implementation of Java.
    Theoretically, you could download the compatible compiler and use J#, but you
    would miss out on some modern Java features in exchange for developing on the
    .NET platform.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 2017 年，微软还支持 J#，这是 Java 的 CLI 兼容实现。理论上，你可以下载兼容的编译器并使用 J#，但为了在 .NET 平台上开发，你将错过一些现代
    Java 功能。
- en: NOTE The CLR is an immensely complicated piece of software. If you want to know
    more about the (traditional, Windows-based) CLR, see Jeffrey Richter’s *CLR via
    C#* (4th edition; Microsoft Press, 2012).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：CLR 是一个极其复杂的软件组件。如果你想了解更多关于（传统、基于 Windows 的）CLR 的信息，请参阅 Jeffrey Richter 的
    *CLR via C#*（第 4 版；Microsoft Press，2012）。
- en: Because the compiler embeds IL in files, we need to use a disassembler to view
    the CIL. All .NET flavors come with Microsoft’s own dissembler called ILDASM (Intermediate
    Language Disassembler). To use ILDASM, we need to run the Developer Command Prompt
    for Visual Studio, which is installed alongside Visual Studio. This is a command-prompt
    environment that gives us access to .NET tools. Be aware that ILDASM is available
    only for Windows.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因为编译器将 IL 嵌入文件中，我们需要使用反汇编器来查看 CIL。所有 .NET 版本都包含 Microsoft 自己的反汇编器，称为 ILDASM（中间语言反汇编器）。要使用
    ILDASM，我们需要运行 Visual Studio 的开发者命令提示符，它与 Visual Studio 一起安装。这是一个命令提示符环境，它为我们提供了访问
    .NET 工具的权限。请注意，ILDASM 仅适用于 Windows。
- en: Table 2.1 .NET acronyms summarized
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 .NET 缩写总结
- en: '| Acronym | Expansion | Description |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 缩写 | 全称 | 描述 |'
- en: '| CLR | Common Language Runtime | The .NET virtual machine runtime. The CLR
    manages critical things like code execution, garbage collection, threads, and
    memory allocations. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| CLR | 通用语言运行时 | .NET 虚拟机运行时。CLR 管理诸如代码执行、垃圾回收、线程和内存分配等关键任务。 |'
- en: '| CLI | Common Language Infrastructure | A specification describing what executable
    code in the .NET ecosystem looks like and how it should be executed. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| CLI | 通用语言基础设施 | 描述 .NET 生态系统中可执行代码的外观及其执行方式的规范。 |'
- en: '| CIL | Common Intermediate Language | A language that can be JIT compiled
    by the CLR to execute CLI-compliant code. This is what C# compiles down to in
    the first compilation stage. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| CIL | 通用中间语言 | 一种可以被 CLR JIT 编译以执行 CLI 兼容代码的语言。这是 C# 在第一次编译阶段编译成的内容。 |'
- en: '| IL | Intermediate Language | Another term for CIL. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| IL | 中间语言 | CIL 的另一个术语。 |'
- en: '| MSIL | Microsoft Intermediate Language | Another term for CIL. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| MSIL | 微软中间语言 | CIL 的另一个术语。 |'
- en: 'Once in the developer command prompt, we can invoke ILDASM on our compiled
    file and specify an output file as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入开发者命令提示符，我们就可以在我们的编译文件上调用 ILDASM，并指定一个输出文件，如下所示：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we do not specify an output file, the command-line tool launches the GUI
    for ILDASM. In there, you can also view the IL code of the disassembled executable.
    The output file can be of whatever file extension you want, because it is a simple
    binary text file. Note that in the .NET Framework, ILDASM operates against the
    .exe file, not the .dll. .NET 5 and .NET Core use the .dll file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有指定输出文件，命令行工具将启动 ILDASM 的 GUI。在那里，你还可以查看反汇编可执行文件的 IL 代码。输出文件可以是任何你想要的文件扩展名，因为它是一个简单的二进制文本文件。请注意，在
    .NET Framework 中，ILDASM 针对的是 .exe 文件，而不是 .dll。.NET 5 和 .NET Core 使用 .dll 文件。
- en: When we open the HelloPythagoras.il file in a text editor or look at the ILDASM
    GUI, a file filled with mysterious code opens. This is the IL code. We focus on
    the IL for the Pythagoras method (if compiled in debug mode), as shown next.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在文本编辑器中打开 HelloPythagoras.il 文件或查看 ILDASM 图形用户界面时，一个充满神秘代码的文件就会打开。这就是 IL
    代码。我们关注的是 Pythagoras 方法（如果以调试模式编译）的 IL，如下所示。
- en: Listing 2.2 Pythagorean theorem (Common Intermediate Language)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 斐波那契定理（通用中间语言）
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you have ever worked in or seen assembly-level programming, you might notice
    some similarities. Common Intermediate Language is definitely harder to read and
    more “close to the metal” than regular C# code, but it is not as mysterious as
    it might look. By stepping through the IL line by line, you see that this is just
    a different syntax for programming concepts you already know. The IL code generated
    by the compiler on your machine may look slightly different (especially the numbers
    used with the `ldarg` opcode), but the functionality and types of opcodes should
    be the same.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经从事或见过汇编级编程，你可能会注意到一些相似之处。通用中间语言（Common Intermediate Language）确实比常规 C# 代码更难阅读，并且更“接近金属”，但它并不像看起来那么神秘。通过逐行查看
    IL，你会发现这仅仅是编程概念的不同语法，而你已经熟悉这些概念。由你的机器上的编译器生成的 IL 代码可能看起来略有不同（特别是使用 `ldarg` 操作码的数字），但操作码的功能和类型应该是相同的。
- en: 'The very first thing we see is the method declaration, shown next:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的第一件事是方法声明，如下所示：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can easily see that the method is private, static, and returns a 64-bit floating-point
    number (known as a *double* in C#). We can also see that the method is named `Pythagoras`
    and takes in two arguments called `sideLengthA` and `sideLengthB`, both 64-bit
    floating-point numbers. The two terms that seem odd are `hidebysig` and `cil managed`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地看到，该方法是私有的、静态的，并返回一个64位浮点数（在C#中称为*double*）。我们还可以看到，该方法名为`Pythagoras`，接受两个名为`sideLengthA`和`sideLengthB`的参数，它们都是64位浮点数。看起来奇怪的术语是`hidebysig`和`cil
    managed`。
- en: First, the term `hidebysig` tells us that the Pythagoras method hides every
    other method with the same method signature. When omitted, the method hides all
    methods with the same name (not limited to signature match). Second, `cil managed`
    means that this code is Common Intermediate Language and that we are running in
    managed mode. The other side of the coin would be unmanaged. This refers to whether
    the CLR can execute the method, potentially has manual memory handling, and has
    all the metadata that the CLR requires. By default, all your code runs in managed
    mode unless you explicitly tell it not to by enabling the compiler “unsafe” flag
    and designating code as “unsafe.”
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，术语`hidebysig`告诉我们，毕达哥拉斯方法会隐藏具有相同方法签名的其他方法。当省略时，该方法会隐藏所有具有相同名称的方法（不仅限于签名匹配）。其次，`cil
    managed`意味着此代码是公共中间语言，并且我们正在托管模式下运行。硬币的另一面是未托管。这指的是CLR是否可以执行该方法，可能需要手动处理内存，并且具有CLR所需的全部元数据。默认情况下，所有代码都在托管模式下运行，除非你通过启用编译器的“不安全”标志并指定代码为“不安全”来明确告诉它不要这样做。
- en: 'Moving on to the method itself, we can split the method into two parts: the
    setup (constructor) and execution (the logic). First, let’s look at the constructor,
    shown next:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看方法本身，我们可以将方法分为两部分：设置（构造函数）和执行（逻辑）。首先，让我们看看构造函数，如下所示：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are some unfamiliar terms here. To start, `.maxstack 3` tells us that
    the maximum allowed elements on the memory stack during execution is three. The
    static compiler automatically generates this number and tells the CLR JIT compiler
    how many elements to reserve for the method. This part of the method code is important—imagine
    not being able to tell the CLR how much memory we need. It may decide to reserve
    all available stack space on the system, or not reserve any at all. Either scenario
    would be catastrophic.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些不熟悉的术语。首先，`.maxstack 3`告诉我们，在执行过程中，内存堆栈上允许的最大元素数是三个。静态编译器自动生成这个数字，并告诉CLR
    JIT编译器为该方法保留多少元素。这个方法代码的部分很重要——想象一下，如果我们不能告诉CLR我们需要多少内存，它可能会决定在系统上保留所有可用的堆栈空间，或者根本不保留任何空间。任何一种情况都会是灾难性的。
- en: Next up is
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we declare a variable in a CLI-compliant programming language, the compiler
    assigns the variable a scope and initializes the variable’s value to a default
    value at compile time. The `locals` keyword tells us the scope of the variables
    declared in this code block are local in scope (scoped to the method, not the
    class), whereas `init` means that we are initializing the declared variables to
    their default values. The compiler assigns it to `null` or a zeroed-out value,
    depending on whether the variable is a reference or value type.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在CLI兼容的编程语言中声明一个变量时，编译器会在编译时为该变量分配一个作用域，并将变量的值初始化为默认值。`locals`关键字告诉我们，在此代码块中声明的变量的作用域是局部的（作用域限于方法，而不是类），而`init`意味着我们正在将声明的变量初始化为其默认值。编译器将其分配给`null`或零值，具体取决于变量是引用类型还是值类型。
- en: 'Expanding the `.locals init (...)` code block reveals the variables we are
    declaring and initializing as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`.locals init (...)`代码块，我们可以看到我们声明并初始化的变量如下：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The IL declares two local variables and initializes them to zero values: `squaredLength`
    and `V_1`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: IL声明了两个局部变量，并将它们初始化为零值：`squaredLength`和`V_1`。
- en: 'Now, you might say, hang on a second! We only declared one local variable in
    our C# code: `squaredLength.` What is this `V_1` business? Have a look at the
    following C# code again:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会说，等等！在我们的C#代码中，我们只声明了一个局部变量：`squaredLength`。这个`V_1`是什么意思？再次查看以下C#代码：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We explicitly declared only one local variable. However, we are returning `squaredLength`
    by value rather than by reference. This means that under the hood, a new variable
    is declared, initialized, and assigned the value of `squaredLength`. This is `V_1`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们明确声明了仅有一个局部变量。然而，我们是通过值而不是通过引用返回`squaredLength`。这意味着在底层，会声明一个新的变量，初始化并分配给`squaredLength`的值。这就是`V_1`。
- en: 'To summarize, we looked at the method signature and the setup. Now we can dive
    into the weeds of the logic. Let’s also split the following part up into two sections—the
    evaluation of the Pythagorean theorem and the returning of the resulting value:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们研究了方法签名和设置。现在我们可以深入逻辑的细节。让我们也将以下部分分为两个部分——勾股定理的评估和返回结果值：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To start, we see an operation (we also call these operations *opcodes*) called
    `nop`. This is also called the “Do Nothing Operation” or “No Operation” because,
    on its own, a `nop` operation does nothing. They are widely used in IL and assembly
    code to enable breakpoint debugging. Along with the PDB file that is generated
    in debug builds, the CLR can inject instructions to stop program execution at
    a `nop` operation. This allows us to “step through” code at runtime.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到一个操作（我们也将这些操作称为 *opcodes*）称为 `nop`。这也被称为“什么都不做的操作”或“无操作”，因为单独的 `nop`
    操作本身不做任何事情。它们在 IL 和汇编代码中广泛使用，以启用断点调试。与在调试构建中生成的 PDB 文件一起，CLR 可以注入指令，在 `nop` 操作处停止程序执行。这允许我们在运行时“单步执行”代码。
- en: 'Next up, we look at the evaluation of the Pythagorean theorem itself, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下勾股定理本身的评估，如下所示：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following two operations are a doubleheader: two `ldarg.0` operations.
    The first operation (`IL_0001`) loads the first `sideLengthA` occurrence onto
    the stack. The second operation (`IL_0002`) loads the second `sideLengthA` occurrence
    onto the stack as well.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个操作是一个双重头：两个 `ldarg.0` 操作。第一个操作（`IL_0001`）将第一个 `sideLengthA` 出现在栈上加载。第二个操作（`IL_0002`）也将第二个
    `sideLengthA` 出现在栈上加载。
- en: 'After we have loaded the first mathematical evaluation’s arguments onto the
    stack, the IL code calls the following multiplication operation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将第一个数学评估参数加载到栈上之后，IL 代码调用以下乘法操作：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This results in the two arguments loaded during `IL_0001` and `IL_0002` being
    multiplied and stored into a new element on the stack. The garbage collector now
    purges the previous (now unused) stack elements from the stack.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致在 `IL_0001` 和 `IL_0002` 中加载的两个参数被相乘并存储到栈上的一个新元素中。垃圾收集器现在从栈中清除先前（现在不再使用）的栈元素。
- en: 'We repeat this process for the squaring of the `sideLengthB` arguments as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下方式重复此过程以对 `sideLengthB` 参数进行平方：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So now we have elements in the stack containing the values of `sideLengthA2`
    and `sideLengthB2`. To fulfill the Pythagorean theorem, and our code, we have
    to add these two values and store them in `squaredLength``.` This is done in `IL_0007`
    and `IL_0008`, as shown next:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在栈中包含 `sideLengthA2` 和 `sideLengthB2` 的值。为了满足勾股定理和我们的代码，我们必须将这些两个值相加并将它们存储在
    `squaredLength` 中。这是在 `IL_0007` 和 `IL_0008` 中完成的，如下所示：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Similar to the `mul` operations (`IL_0003` and `IL_0006`), the `add` operation
    (`IL_0007`) evaluates the addition of the previously stored arguments and places
    the resulting value into an element on the stack. The IL takes this element and
    stores it into the `squaredLength` variable we initialized in the setup (`[0]
    float64 squaredLength`) through the `stloc.0` command (`IL_0008`). The `stloc.0`
    operation pops a value from the stack and stores it at the variable on index 0.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `mul` 操作（`IL_0003` 和 `IL_0006`）类似，`add` 操作（`IL_0007`）评估先前存储的参数之和，并将结果值放置在栈上的一个元素中。IL
    将此元素存储到我们在设置中初始化的 `squaredLength` 变量中（`[0] float64 squaredLength`）通过 `stloc.0`
    命令（`IL_0008`）。`stloc.0` 操作从栈中弹出一个值并将其存储在索引 0 的变量中。
- en: 'We have now fully evaluated and stored the Pythagorean theorem result into
    a variable. All that remains is to return the value from the method, as shown
    next, just like we promised in our original method signature:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全评估并将勾股定理的结果存储到一个变量中。剩下的只是从方法中返回值，正如我们在原始方法签名中承诺的那样，如下所示：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First, we load the value of the variable at location 0 into memory (`IL_0009`).
    In the previous segment, we ended with storing the value of the Pythagorean theorem
    into the variable at location 0, so that must be `squaredLength`. But, as mentioned
    earlier, we are passing the variable by value, not by reference, so we create
    a copy of `squaredLength` to return out of the method with. Luckily, we declared
    and initialized a variable just for this purpose at index 1: `V_1 ([1] float64
    V_1)`. We store the value into index 1 through the `stloc.1` operation (`IL_000a`).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将位于位置0的变量的值加载到内存中（`IL_0009`）。在上一个段中，我们将毕达哥拉斯定理的值存储到位置0的变量中，所以那必须是`squaredLength`。但是，如前所述，我们是按值传递变量，而不是按引用传递，因此我们创建了一个`squaredLength`的副本以从方法中返回。幸运的是，我们在索引1处声明并初始化了一个变量专门用于此目的：`V_1
    ([1] float64 V_1)`。我们通过`stloc.1`操作（`IL_000a`）将值存储到索引1中。
- en: 'Next up, we see another strange operation: `br.s IL_000d` (`IL_000b`). This
    is a branching operator that signifies that the return value is calculated and
    stored away for returning. The IL uses a branching operator for debugging purposes.
    A branching operator is similar to a `nop` operation. All different branches of
    your code (conditionals with other return values) jump to the `br.s` operator
    when return is called. The `br.s` operator takes up two bytes and, therefore,
    has two IL locations (`IL_000b` and `IL_000d`); one opcode usually takes up one
    byte. Because the `br.s` operator has a size of two bytes, `IL_000c` (`ldloc.1`)
    is wrapped in the branching operator. This allows the debugger to stop executing
    at the loading of the stored return value and manipulate it, if necessary.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到另一个奇怪的操作：`br.s IL_000d`（`IL_000b`）。这是一个分支操作符，表示返回值已计算并存储以供返回。IL使用分支操作符进行调试目的。分支操作符类似于`nop`操作。当调用返回时，所有不同的代码分支（具有其他返回值的条件）都会跳转到`br.s`操作符。`br.s`操作符占用两个字节，因此有两个IL位置（`IL_000b`和`IL_000d`）；一个操作码通常占用一个字节。因为`br.s`操作符的大小为两个字节，所以`IL_000c`（`ldloc.1`）被包含在分支操作符中。这允许调试器在加载存储的返回值时停止执行，并在必要时对其进行操作。
- en: 'Finally, we are ready to return out of the method through `IL_000c` and `IL_000e`
    as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备通过`IL_000c`和`IL_000e`从方法中返回，如下所示：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `ldloc.1` (`IL_000c`) operation loads the previously stored return value.
    This is followed by the `ret` operator, which takes the value we loaded at `IL_000c`
    and returns it from the method. See the entire code sample in listing 2.3.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldloc.1`（`IL_000c`）操作加载之前存储的返回值。这之后跟着`ret`操作符，它将我们在`IL_000c`加载的值从方法中返回。请参见列表2.3中的整个代码示例。'
- en: That brings us to the end of the section. Hopefully, you are now a bit more
    comfortable with the nitty-gritty parts of the static compilation step of C# and
    .NET.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了本节的结尾。希望你现在对C#和.NET静态编译步骤的细节部分有了更多的了解。
- en: Listing 2.3 The IL source code of the Pythagorean theorem method
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 毕达哥拉斯定理方法的IL源代码
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Start of a method that is private, static, returns a double, and hides other
    methods with the same signature
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 方法的开始，该方法是私有的、静态的、返回double类型，并隐藏具有相同签名的其他方法
- en: ❷ The method is called Pythagoras. It expects two arguments of type float64
    (double).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 该方法被称为毕达哥拉斯方法。它期望两个类型为float64（双精度浮点数）的参数。
- en: ❸ This is a CIL (Common Intermediate Language) method and runs in managed mode.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这是一个CIL（通用中间语言）方法，在托管模式下运行。
- en: ❹ The maximum number of simultaneous elements needed on the stack is three.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 在栈上需要的最大元素数量是三个。
- en: '❺ Two local variables of type float64 are declared and initialized: squaredLength
    at index 0 and V_1 at index 1.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 声明并初始化了两个类型为float64的局部变量：索引0的squaredLength和索引1的V_1。
- en: ❻ A “do nothing” operation; used by debuggers for breakpoints
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 一个“不做任何事”的操作；由调试器用于设置断点
- en: ❼ The first sideLengthA argument is loaded into memory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 第一个sideLengthA参数被加载到内存中。
- en: ❽ The two sideLengthA values loaded into memory are multiplied and stored in
    a stack element.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 被加载到内存中的两个sideLengthA值相乘并存储在栈元素中。
- en: ❾ The first sideLengthB argument is loaded into memory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 第一个sideLengthB参数被加载到内存中。
- en: ❿ The two sideLengthB values loaded into memory are multiplied and stored in
    a stack element.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 被加载到内存中的两个sideLengthB值相乘并存储在栈元素中。
- en: ⓫ The squared values of sideLengthA and sideLengthB are added together and stored
    in a stack element.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ sideLengthA和sideLengthB的平方值相加并存储在栈元素中。
- en: '⓬ The squared values previously stored in a stack element are stored in a new
    stack element designated for the variable at index 0: squaredLength.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 之前存储在栈元素中的平方值被存储在为新索引0的变量指定的新的栈元素中：squaredLength。
- en: ⓭ The value for squaredLength is loaded into memory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 将squaredLength的值加载到内存中。
- en: '⓮ The previously loaded-into-memory value of squaredLength is stored in the
    stack element for the variable with index 1: V_1.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ⓮ 将之前加载到内存中的squaredLength的值存储在索引为1的变量对应的堆栈元素中：V_1。
- en: ⓯ The branching operator; signifies the completion of the method and storage
    of the return value
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ⓯ 分支操作符；表示方法的完成和返回值的存储
- en: ⓰ The return value (variable V_1) is loaded into memory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ⓰ 返回值（变量V_1）被加载到内存中。
- en: ⓱ We return out of the method with the value of V_1.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ⓱ 我们使用V_1的值从方法中返回。
- en: '2.3.3 Step 3: Native code (processor level)'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 步骤3：本地代码（处理器级别）
- en: The last step in the compilation process is the conversion from Common Intermediate
    Language to native code, shown in figure 2.6, which the processor can actually
    run. Until now, the code has been statically compiled, but that changes here.
    When .NET 5 executes an application, the CLR launches and scans the executable
    files for the IL code. Then, the CLR invokes the JIT compiler to convert the IL
    into native code as it runs. Native code is the lowest level of code that is (somewhat)
    human-readable. A processor can execute this code directly because of the inclusion
    of predefined operations (opcodes), similar to how Common Intermediate Language
    includes the IL operation codes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程的最后一步是将通用中间语言转换为本地代码，如图2.6所示，这是处理器可以实际运行的代码。到目前为止，代码已经被静态编译，但在这里发生了变化。当.NET
    5执行应用程序时，CLR启动并扫描可执行文件中的IL代码。然后，CLR调用JIT编译器在运行时将IL转换为本地代码。本地代码是（某种程度上）可读性最低的代码级别。由于包含了预定义的操作（操作码），处理器可以直接执行此代码，这与通用中间语言包含IL操作码的方式类似。
- en: '![](../Images/02_06.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02_06.png)'
- en: 'Figure 2.6 The C# compilation process, step 3: native code. This is the JIT
    phase of the process.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 C#编译过程，步骤3：本地代码。这是过程的JIT阶段。
- en: JIT compiling our code comes at a performance cost, but also means that we can
    execute .NET-based code on any platform supported by the CLR and a compiler. We
    can see this in practice with .NET Core and the new CoreCLR. The CoreCLR can JIT-compile
    Intermediate Language to Windows, macOS, and Linux, as shown in figure 2.7.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: JIT编译我们的代码会带来性能成本，但也意味着我们可以在CLR和编译器支持的任何平台上执行.NET代码。我们可以通过.NET Core和新的CoreCLR来看到这一点。CoreCLR可以将中间语言JIT编译为Windows、macOS和Linux，如图2.7所示。
- en: '![](../Images/02_07.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02_07.png)'
- en: Figure 2.7 CoreCLR can JIT-compile for targets such as Linux, Windows, and macOS.
    This allows for cross-platform execution of C# code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 CoreCLR可以为Linux、Windows和macOS等目标进行JIT编译。这允许C#代码跨平台执行。
- en: Because of the JIT nature of this compilation step, viewing the actual native
    code is a bit tricky. The only way to view native code generated from your Intermediate
    Language would be to use a command-line tool called `ngen`, which comes preinstalled
    with .NET 5\. This tool allows you to generate so-called native images containing
    native code from the Common Intermediate Language stored in a PE file ahead of
    time. The CLR stores native code output in a subfolder of %SystemRoot%/Assembly/
    NativeAssembly (only available on Windows). Be aware, however, that you cannot
    use the regular file explorer to navigate here, nor would the resulting output
    be legible. After running `ngen`, the CLR sees that the IL is already compiled
    (statically) to native code and executes based on that. This comes with the expected
    performance boost; however, the native code and IL code can get out of sync when
    a new build is released and have unexpected side effects if the CLR decides to
    use the older statically compiled native image instead of recompiling the new,
    updated code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JIT编译步骤的性质，查看实际的本地代码有点棘手。查看从您的中间语言生成的本地代码的唯一方法是通过一个名为`ngen`的命令行工具，该工具预装在.NET
    5中。此工具允许您生成所谓的本地图像，其中包含存储在PE文件中的通用中间语言中的本地代码。CLR将本地代码输出存储在%SystemRoot%/Assembly/NativeAssembly的子文件夹中（仅在Windows上可用）。但是请注意，您不能使用常规文件资源管理器来导航到此位置，并且生成的输出也不易阅读。运行`ngen`后，CLR会看到IL已经被编译（静态）为本地代码，并基于此执行。这带来了预期的性能提升；然而，当发布新构建时，本地代码和IL代码可能会不同步，如果CLR决定使用旧的静态编译的本地图像而不是重新编译新的、更新的代码，可能会产生意外的副作用。
- en: In day-to-day operations, you likely don’t touch IL all that much or are overly
    concerned about the IL-to-native-code compilation. However, understanding the
    compilation process is a fundamental block of knowledge because it sheds light
    on design decisions in .NET 5 that we’ll encounter throughout the book.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常操作中，你可能不太会接触到 IL，或者过分关注 IL 到本地代码的编译。然而，理解编译过程是基础知识的一个基本组成部分，因为它揭示了我们在本书中会遇到
    .NET 5 的设计决策。
- en: Exercises
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 2.4
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 2.4
- en: What are the steps and order of the .NET compilation process?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 编译过程的步骤和顺序是什么？
- en: a. NET code -> Intermediate Language -> Native code
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: a. NET 代码 -> 中间语言 -> 本地代码
- en: b. Intermediate Language -> .NET code -> Native code
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: b. 中间语言 -> .NET 代码 -> 本地代码
- en: c. .NET code -> Native code
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: c. .NET 代码 -> 本地代码
- en: d. Java -> JVM
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: d. Java -> JVM
- en: Exercise 2.5
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 2.5
- en: 'Fill in the blanks: A __________ compiler compiles the code right before it
    is needed, whereas code compiled ahead of time was done through a __________ compiler.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 填空：一个 __________ 编译器在代码需要之前编译代码，而预先编译的代码是通过一个 __________ 编译器完成的。
- en: a. static
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: a. 静态
- en: b. JIT
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: b. JIT
- en: c. dynamic
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: c. 动态
- en: Exercise 2.6
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 2.6
- en: Where is Intermediate Language stored?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 中间语言存储在哪里？
- en: a. DOCX files
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: a. DOCX 文件
- en: b. Text files
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: b. 文本文件
- en: c. HTML files
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: c. HTML 文件
- en: d. Font files
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: d. 字体文件
- en: e. Portable Executable files
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: e. 可移植可执行文件
- en: Exercise 2.7
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 2.7
- en: 'Fill in the blank: If we have to make a copy of a stack element to pass around
    a variable, that variable is a __________ type.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 填空：如果我们必须复制堆栈元素以传递变量，那么这个变量是一个 __________ 类型。
- en: a. reference
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: a. 引用
- en: b. pirate
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: b. 海盗
- en: c. value
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: c. 值
- en: d. nullable
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: d. 可空
- en: Exercise 2.8
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 2.8
- en: 'Fill in the blank: If we can manipulate a variable value through a pointer
    to an element on the heap, that variable is a _________ type.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 填空：如果我们可以通过堆中元素的指针来操作变量值，那么这个变量是一个 _________ 类型。
- en: a. reference
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: a. 引用
- en: b. pirate
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: b. 海盗
- en: c. value
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: c. 值
- en: d. nullable
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: d. 可空
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: .NET 5 consumes and rebrands .NET Core and .NET Framework (and other .NET implementations)
    and effectively becomes .NET Core 4 in all but name.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 5 消耗并重新品牌化 .NET Core 和 .NET Framework（以及其他 .NET 实现），实际上除了名称外，都成为 .NET Core
    4。
- en: .NET uses a combination of static and JIT (“just-in-time”) compilation. This
    allows for faster execution when compared to a fully JIT language and cross-platform
    execution.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 使用静态和即时编译（“即时”）的组合。与完全即时编译的语言相比，这允许更快的执行，并且支持跨平台执行。
- en: 'The C# compilation process has three states of being: (1) C# code, (2) Intermediate
    Language code, and (3) native code.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 编译过程有三个状态：（1）C# 代码，（2）中间语言代码和（3）本地代码。
- en: 'The C# compilation process has two steps: C# to Intermediate Language (static
    compilation) and Intermediate Language to native code (JIT compilation).'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 编译过程有两个步骤：C# 到中间语言（静态编译）和中间语言到本地代码（即时编译）。
- en: Intermediate Language is stored in portable executable files (such as .exe and
    .dll on Windows). The CLR scans these files for the embedded IL and executes it,
    JIT compiling it to the appropriate native code.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间语言存储在可移植可执行文件中（例如 Windows 上的 .exe 和 .dll）。CLR 扫描这些文件以查找嵌入的 IL 并执行它，将其即时编译为适当的本地代码。
- en: The Common Language Runtime is invoked on the launch of a .NET application and
    JIT compiles the Intermediate Language code to native code.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当启动 .NET 应用程序时，公共语言运行时被调用，并将中间语言代码即时编译为本地代码。
- en: A 64-bit floating-point number is of type “double” in C#.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 中，64 位浮点数是“double”类型。
- en: 'C# has six separate access modifiers: public, protected internal, internal,
    protected, protected private, and private. These are used to control access to
    your methods.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 有六个不同的访问修饰符：public、protected internal、internal、protected、protected private
    和 private。这些用于控制对方法的访问。
- en: The command line can compile C# through the `dotnet build [solution file path]`
    command. You can also compile through an IDE such as Visual Studio.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行可以通过 `dotnet build [解决方案文件路径]` 命令编译 C#。你也可以通过 Visual Studio 等集成开发环境进行编译。
- en: The Common Language Infrastructure is a technical standard that provides a base
    for all languages targeting .NET. This allows us to use languages such as F# and
    VB.NET along with C#.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共语言基础设施是一个技术标准，为所有针对 .NET 的语言提供基础。这使我们能够使用 F#、VB.NET 和 C# 等语言。
- en: Intermediate Language commands translate roughly to bytecode opcodes.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间语言命令大致对应于字节码操作码。
