- en: Part 1\. Up to speed with Groovy
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分. 熟悉 Groovy
- en: 'Welcome to [part 1](#part01): “Up to speed with Groovy.” This section is made
    up of four chapters, covering topics that are independent of any particular application.
    In the first chapter I try to help you make the business and technical case for
    Groovy. The second chapter is a tutorial by example in how to use Groovy to solve
    small but interesting problems. Combined with [appendix B](kindle_split_024.html#app02)
    it should give you the Groovy background you need to understand the rest of the
    book.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[第一部分](#part01)：“熟悉 Groovy。”本节由四个章节组成，涵盖与任何特定应用程序无关的主题。在第一章中，我试图帮助你为 Groovy
    制造商业和技术案例。第二章通过示例教程展示了如何使用 Groovy 解决一些小但有趣的问题。结合[附录 B](kindle_split_024.html#app02)，它应该为你提供理解本书其余部分所需的
    Groovy 背景。
- en: The third chapter reviews how closely Groovy and Java work together. It covers
    running Groovy scripts programmatically from Java, as well as other ways the two
    languages can be mixed. The easiest way to integrate the two languages is just
    to make classes in each, instantiate them, and invoke their methods. This chapter
    provides examples of doing exactly that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 第三章回顾了 Groovy 和 Java 如何紧密合作。它涵盖了从 Java 程序化运行 Groovy 脚本，以及其他两种语言可以混合的方式。将两种语言集成最简单的方法就是为每个语言创建类，实例化它们，并调用它们的方法。本章提供了实现这一点的示例。
- en: The final chapter in this part reviews idiomatic Groovy features that can be
    particularly helpful when working with Java problems. From POGOs to AST transformations
    to the Groovy JDK, this chapter shows many ways that Groovy can simplify Java
    development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分的最后一章回顾了在处理 Java 问题时特别有帮助的惯用 Groovy 特性。从 POGOs 到 AST 转换到 Groovy JDK，本章展示了
    Groovy 可以简化 Java 开发的许多方式。
- en: Chapter 1\. Why add Groovy to Java?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一章. 为什么要在 Java 中添加 Groovy？
- en: '*This chapter covers*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章内容涵盖*'
- en: Issues with Java
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 的问题
- en: Groovy features that help Java
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助 Java 的 Groovy 特性
- en: Common use cases for Java and how Groovy makes them simpler
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 和 Groovy 的常见用例以及 Groovy 如何使它们更简单
- en: For all of its flaws (and we’ll be reviewing them shortly), Java is still the
    dominant object-oriented programming language in the industry today. It’s everywhere,
    especially on the server side, where it’s used to implement everything from web
    applications to messaging systems to the basic infrastructure of servers. It’s
    therefore not surprising that there are more Java developers and more Java development
    jobs available than for any other programming language. As a language, Java is
    an unmitigated success story.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在诸多缺陷（我们很快就会对其进行回顾），Java 仍然是当今行业中的主导面向对象编程语言。它无处不在，尤其是在服务器端，它被用于实现从网络应用程序到消息系统再到服务器基本基础设施的一切。因此，并不令人惊讶的是，Java
    开发者和 Java 开发工作比其他任何编程语言都要多。作为一个语言，Java 是一个无与伦比的成功故事。
- en: If Java is so ubiquitous and so helpful, why switch to anything else? Why not
    continue using Java everywhere a Java Virtual Machine (JVM) is available?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Java 如此普遍且如此有用，为什么还要切换到其他任何东西？为什么不在任何提供 Java 虚拟机 (JVM) 的地方继续使用 Java？
- en: In this book, the answer to that question is, go right ahead. Where Java works
    for you and gets the job done, by all means continue to use it. I expect that
    you already have a Java background and don’t want to lose all that hard-earned
    experience. Still, there are problems that Java solves easily, and problems that
    Java makes difficult. For those difficult issues, consider an alternative.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，对那个问题的回答是，尽管如此。在 Java 对你有所帮助并完成任务的地方，无论如何都要继续使用它。我预计你已经具备 Java 背景，并且不想失去所有辛苦赚来的经验。然而，有些问题是
    Java 可以轻松解决的，而有些问题是 Java 使之变得困难的。对于这些困难问题，考虑一个替代方案。
- en: 'That alternative is Groovy. In this chapter I’ll review some of the issues
    with Java that lead to problems for developers and discuss how Groovy can help
    alleviate them. I’ll also show a range of tools, provided as part of the Groovy
    ecosystem, that can make pure Java development easier. In the long run, I suggest
    a blended approach: let Java do what it does well, and let Groovy help where Java
    has difficulties.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那个替代方案是 Groovy。在本章中，我将回顾一些导致开发者遇到问题的 Java 问题，并讨论 Groovy 如何帮助缓解这些问题。我还会展示一系列作为
    Groovy 生态系统一部分的工具，这些工具可以使纯 Java 开发更加容易。从长远来看，我建议采用混合方法：让 Java 做它擅长的事情，让 Groovy
    在 Java 难以处理的地方提供帮助。
- en: 'Throughout, this will be the mantra:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，这将是一个口号：
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Guiding Principle
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 指导原则
- en: Java is great for tools, libraries, and infrastructure. Groovy is great for
    everything else.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Java 适用于工具、库和基础设施。Groovy 适用于其他一切。
- en: '|  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Use Java where Java works well, and use Groovy where it makes your life easier.
    Nobody is ever going to rewrite, say, the Spring Framework, in Groovy. There’s
    no need. Groovy works beautifully with Spring, as I’ll discuss in detail in [chapter
    7](kindle_split_019.html#ch07). Likewise, the JVM is everywhere. That’s a good
    thing, because wherever Java can run, so can Groovy, as shown in [figure 1.1](#ch01fig01).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java表现良好的地方使用Java，在它使你的生活更轻松的地方使用Groovy。没有人会重写，比如说，Spring框架，用Groovy。没有必要。Groovy与Spring配合得很好，我将在第7章详细讨论。同样，JVM无处不在。这是一个好事，因为Java可以运行的地方，Groovy也可以运行，如图1.1所示。
- en: Figure 1.1\. Groovy generates bytecodes for the Java Virtual Machine. Either
    compile them ahead of time or let the `groovy` command generate them from source.
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1\. Groovy为Java虚拟机生成字节码。可以提前编译它们，或者让`groovy`命令从源代码生成它们。
- en: '![](01fig01_alt.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig01_alt.jpg)'
- en: I’ll discuss the practical details in the next chapter, but at its base Groovy
    *is* Java. Groovy scripts and classes compile to bytecodes that can be freely
    intermixed with compiled Java classes. From a runtime point of view, running compiled
    Groovy means just adding a single JAR file to your environment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在下一章讨论实际细节，但就其基础而言，Groovy *确实是* Java。Groovy脚本和类编译成字节码，这些字节码可以自由地与编译后的Java类混合使用。从运行时角度来看，运行编译后的Groovy只需将一个JAR文件添加到你的环境中即可。
- en: One of the goals of this book is to identify opportunities where Groovy can
    significantly help Java developers. To do that, let me first review where Java
    might have some issues that need help.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的一个目标是在Groovy可以显著帮助Java开发者的机会中识别出来。为了做到这一点，让我首先回顾一下Java可能存在哪些需要帮助的问题。
- en: 1.1\. Issues with Java
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1\. Java的问题
- en: A perfect storm swept through the development world in the mid- to late-1990s,
    which ultimately resulted in moving the primary development language from C++
    to Java. Java is effectively the next-generation language in the C++ family. Its
    syntax shares much in common with C and C++. Language constructs that caused intermediate-level
    developers problems, like memory management and pointer arithmetic, were handled
    automatically or removed from programmer control altogether. The language was
    small (as hard as that might be to imagine now), easy to write, and, above all,
    free. Just download a JDK, access the library docs (making available clean, up-to-date,
    hyperlinked library documentation was quite the innovation at the time), and start
    coding. The leading browser of the day, Netscape, even had a JVM built right into
    it. Combined with the whole Write Once, Run Anywhere mantra, Java carried the
    day.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在1990年代中后期，一场完美的风暴席卷了开发世界，最终导致将主要开发语言从C++迁移到Java。Java实际上是C++家族中的下一代语言。它的语法与C和C++有很多相似之处。语言结构，如内存管理和指针算术，这些结构给中级开发者带来了问题，现在被自动处理或完全从程序员控制中移除。语言本身很小（尽管现在想象起来可能很难），易于编写，最重要的是，它是免费的。只需下载一个JDK，访问库文档（在当时，提供干净、最新、超链接的库文档是一项相当大的创新），然后开始编码。当时的领先浏览器Netscape甚至内置了JVM。结合“一次编写，到处运行”的口号，Java取得了胜利。
- en: 'A lot of time has passed since then. Java has grown considerably, and decisions
    made early in its development now complicate development rather than simplify
    it. What sorts of decisions were those? Here’s a short, though hardly exhaustive,
    list:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起已经过去了很长时间。Java已经发展壮大，早期开发中做出的决策现在反而使开发变得复杂，而不是简化。那些决策是什么？以下是一个简短但并不详尽的列表：
- en: Java is statically typed.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java是静态类型的。
- en: All methods in Java must be contained within a class.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java中所有方法都必须包含在类中。
- en: Java forbids operator overloading.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java禁止操作符重载。
- en: The default access for attributes and methods is “package private.”
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性和方法的默认访问权限是“包私有”。
- en: Java treats primitives differently from classes.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java对待原始类型和类的方式不同。
- en: Over time Java also accumulated inconsistencies. For example, arrays have a
    `length` property, strings have a `length` method, collections have a `size` method,
    and node lists (in XML) have a `getLength` method. Groovy provides a `size` method
    for all of them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，Java也积累了一些不一致性。例如，数组有一个`length`属性，字符串有一个`length`方法，集合有一个`size`方法，而节点列表（在XML中）有一个`getLength`方法。Groovy为它们都提供了一个`size`方法。
- en: Java also lacks metaprogramming capabilities.^([[1](#ch01fn01)]) That’s not
    a flaw, but it limits Java’s ability to create domain-specific languages (DSLs).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Java还缺乏元编程能力.^([[1](#ch01fn01)]) 这不是缺陷，但它限制了Java创建领域特定语言（DSLs）的能力。
- en: ¹ That’s for a variety of good reasons, many of which relate to performance.
    Metaprogramming depends on dynamic capabilities like reflection, which was very
    slow when Java was first released. Groovy in 1998 on Java 1.2 would have been
    a daunting prospect at best.
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 这有多种很好的理由，其中许多与性能相关。元编程依赖于动态能力，如反射，当Java最初发布时，反射非常慢。1998年的Groovy在Java 1.2上最多是一个令人畏惧的前景。
- en: There are other issues as well, but this list will give us a good start. Let’s
    look at a few of these items individually.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他问题，但这个列表将为我们提供一个良好的起点。让我们单独看看这些项目中的几个。
- en: 1.1.1\. Is static typing a bug or a feature?
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1\. 静态类型是缺陷还是特性？
- en: When Java was created, the thinking in the industry was that static typing—the
    fact that you must declare the type of every variable—was a benefit. The combination
    of static typing and dynamic binding meant that developers had enough structure
    to let the compiler catch problems right away, but still had enough freedom to
    implement and use polymorphism. Polymorphism lets developers override methods
    from superclasses and change their behavior in subclasses, making reuse by inheritance
    practical. Even better, Java is dynamically bound by default, so you can override
    anything you want unless the keyword `final` is applied to a method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java被创造出来时，行业中的思考是静态类型——你必须声明每个变量的类型——是一种优势。静态类型和动态绑定的结合意味着开发者有足够的结构来让编译器立即捕捉到问题，但仍然有足够的自由来实现和使用多态。多态允许开发者覆盖超类中的方法并在子类中改变其行为，使通过继承的重用变得可行。更好的是，Java默认是动态绑定的，所以你可以覆盖任何你想要的东西，除非方法上应用了关键字`final`。
- en: Static typing makes Integrated Development Environments useful too, because
    they can use the types to prompt developers for the correct fields and methods.
    IDEs like Eclipse and NetBeans, both powerful and free, became pervasive in the
    industry partly as a result of this convenience.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型也使得集成开发环境（IDE）变得有用，因为它们可以使用类型来提示开发者使用正确的字段和方法。像Eclipse和NetBeans这样的IDE，既强大又免费，在行业中变得普遍，部分原因就是这种便利性。
- en: So what’s wrong with static typing? If you want an earful ask any Smalltalk
    developer. More practically, under Java’s dynamic binding restrictions (that you
    can’t override anything unless two classes are related by inheritance), static
    typing is overly restrictive. Dynamically typed languages have much more freedom
    to let one object stand in for another.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，静态类型有什么问题呢？如果你想听到一些不满，可以问任何Smalltalk开发者。更实际地说，在Java的动态绑定限制（除非两个类通过继承相关联，否则你不能覆盖任何东西）下，静态类型过于限制。动态类型语言有更多的自由，让一个对象代表另一个对象。
- en: 'As a simple example, consider arrays and strings. Both are data structures
    that collect information: arrays collect objects, and strings collect characters.
    Both have the concept of appending a new element to the existing structure. Say
    we have a class that includes an array and we want to test the class’s methods.
    We’re not interested in testing the behavior of arrays. We know they work. But
    our class has a dependency on the array.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个简单的例子来说明，考虑数组和字符串。两者都是收集信息的数据结构：数组收集对象，字符串收集字符。两者都有向现有结构中添加新元素的概念。假设我们有一个包含数组的类，我们想要测试这个类的功能。我们并不关心测试数组的操作。我们知道它们是有效的。但我们的类依赖于这个数组。
- en: What we need is some kind of mock object to represent the array during testing.
    If we have a language with dynamic typing, and all we are invoking is the `append`
    method on it using character arguments, we can supply a string wherever we have
    an array and everything will still work.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要某种类型的模拟对象来代表数组进行测试。如果我们有一个具有动态类型的语言，并且我们只是在它上面调用`append`方法并使用字符参数，我们可以在有数组的地方提供一个字符串，一切仍然会正常工作。
- en: 'In Java one object can only stand in for another if the two classes are related
    by inheritance or if both implement the same interface. A static reference can
    only be assigned to an object of that type or one of its subclasses, or a class
    that implements that interface if the reference is of interface type. In a dynamically
    typed language, however, we can have any classes stand in for another, as long
    as they implement the methods we need. In the dynamic world this is known as *duck
    typing*: if it walks like a duck and it quacks like a duck, it’s a duck. See [figure
    1.2](#ch01fig02).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，一个对象只能代表另一个对象，如果这两个类通过继承相关联，或者如果它们都实现了相同的接口。静态引用只能分配给该类型或其子类的对象，或者如果引用是接口类型，则可以分配给实现该接口的类。然而，在动态类型语言中，只要它们实现了我们需要的方法，任何类都可以代表另一个类。在动态世界中，这被称为*鸭子类型*：如果它像鸭子走路，如果它像鸭子嘎嘎叫，那么它就是一只鸭子。参见[图1.2](#ch01fig02)。
- en: Figure 1.2\. Arrays and strings from a duck-typing point of view. Each is a
    collection with an `append` method. If that’s all we care about, they’re the same.
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.2\. 从鸭子类型的角度看数组和字符串。每个都是具有`append`方法的集合。如果我们只关心这一点，它们就是相同的。
- en: '![](01fig02_alt.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig02_alt.jpg)'
- en: 'We don’t care that a string is not an array as long as it has the `append`
    method we need. This example also shows another feature of Groovy that was left
    out of Java: operator overloading. In Groovy all operators are represented by
    methods that can be overridden. For example, the + operator uses a `plus()` method
    and * uses `multiply()`. In the previous figure the << operator represents the
    `leftShift()` method, which is implemented as `append` for both arrays and strings.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 只要字符串有我们需要的`append`方法，我们就不会介意它不是一个数组。这个例子还展示了Groovy的一个特性，这个特性在Java中没有被包含：操作符重载。在Groovy中，所有操作符都由可以重写的方法表示。例如，+操作符使用`plus()`方法，*使用`multiply()`。在之前的图中，`<<`操作符代表`leftShift()`方法，它对于数组和字符串都实现为`append`。
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Groovy Feature
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Groovy特性
- en: Groovy features like optional typing and operator overloading give developers
    greater flexibility in far less code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy的特性，如可选类型和操作符重载，为开发者提供了在更少的代码中更大的灵活性。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Regarding optional typing, Groovy gives you the best of both worlds. If you
    know the type of a variable, feel free to specify it. If you don’t know or you
    don’t care, feel free to use the `def` keyword.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可选类型，Groovy为你提供了两者的最佳选择。如果你知道变量的类型，请随意指定它。如果你不知道或者不在乎，请随意使用`def`关键字。
- en: 1.1.2\. Methods must be in a class, even if you don’t need or want one
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2\. 方法必须在类中，即使你不需要或想要一个
- en: Some time ago, Steve Yegge wrote a very influential blog post called “Execution
    in the Kingdom of the Nouns.”^([[2](#ch01fn02)]) In it he described a world where
    nouns rule and verbs are second-class citizens. It’s an entertaining post and
    I recommend reading it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，史蒂夫·耶格（Steve Yegge）写了一篇非常有影响力的博客文章，名为“在名词王国中的执行”。^([[2](#ch01fn02)]) 在这篇文章中，他描述了一个名词统治、动词是二等公民的世界。这是一篇有趣的博客文章，我推荐阅读。
- en: '² Read the post from March 30, 2006 at Steve Yegge’s blog: [http://mng.bz/E4MB](http://mng.bz/E4MB).'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 阅读史蒂夫·耶格（Steve Yegge）博客上2006年3月30日的文章：[http://mng.bz/E4MB](http://mng.bz/E4MB)。
- en: Java is firmly rooted in that world. In Java all methods (verbs) must reside
    inside classes (nouns). You can’t have a method by itself. It has to be in a class
    somewhere. Most of the time that’s not a big issue, but consider, for example,
    sorting strings.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Java在这个世界中根深蒂固。在Java中，所有方法（动词）都必须位于类（名词）内部。你不能单独拥有一个方法。它必须位于某个类的内部。大多数时候这并不是一个大问题，但考虑一下，例如，对字符串进行排序。
- en: Unlike Groovy, Java does not have native support for collections. Although collections
    have been a part of Java from the beginning in the form of arrays and the original
    `java.util.Vector` and `java.util.Hashtable` classes, a formal collections framework
    was added to the Java 2 Standard Edition, version 1.2\. In addition to giving
    Java a small but useful set of fundamental data structures, such as lists, sets,
    and maps, the framework also introduced iterators that separated the way you moved
    through a collection from its underlying implementation. Finally, the framework
    introduced a set of polymorphic algorithms that work on the collections.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与Groovy不同，Java没有对集合的原生支持。尽管集合从Java一开始就存在，以数组以及原始的`java.util.Vector`和`java.util.Hashtable`类的形式存在，但正式的集合框架是在Java
    2标准版，版本1.2中添加的。除了为Java提供了一组小但有用的基本数据结构，如列表、集合和映射之外，该框架还引入了迭代器，它将你遍历集合的方式与其底层实现分离开来。最后，该框架引入了一套多态算法，这些算法可以在集合上工作。
- en: With all that in place we can assemble a collection of strings and sort them
    as shown in the following listing. First a collection of strings must be instantiated,
    then populated, and finally sorted.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些准备就绪之后，我们可以按照以下列表所示组装一个字符串集合并对它们进行排序。首先需要实例化一个字符串集合，然后填充数据，最后进行排序。
- en: Listing 1.1\. Sorting strings using the `Collections.sort` method
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.1\. 使用`Collections.sort`方法排序字符串
- en: '![](007fig01_alt.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](007fig01_alt.jpg)'
- en: The collections framework supplies interfaces, like `List`, and implementation
    classes, like `ArrayList`. The `add` method is used to populate the list. Then
    the `java.util` `.Collections` utility class includes static methods for, among
    other things, sorting and searching lists. Here I’m using the single-argument
    `sort` method, which sorts its argument according to its natural sort. The assumption
    is that the elements of the list are from a class that implements the `java.util.Comparable`
    interface. That interface includes the `compareTo` method, which returns a negative
    number if its argument is greater than the current object, a positive number if
    the argument is less than the current object, and zero otherwise. The `String`
    class implements `Comparable` as a lexicographical sort, which is alphabetical,
    but sorts capital letters ahead of lowercase letters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架提供了接口，如`List`，以及实现类，如`ArrayList`。`add`方法用于填充列表。然后`java.util`包中的`.Collections`实用类包括静态方法，用于排序和搜索列表。在这里，我使用单参数`sort`方法，该方法根据其自然排序对参数进行排序。假设列表的元素来自实现`java.util.Comparable`接口的类。该接口包括`compareTo`方法，如果其参数大于当前对象，则返回负数；如果参数小于当前对象，则返回正数；否则返回零。`String`类实现了`Comparable`作为字典序排序，即字母顺序，但将大写字母排在小写字母之前。
- en: We’ll look at a Groovy equivalent to this in a moment, but let’s consider another
    issue first. What if you want to sort the strings by length rather than alphabetically?
    The `String` class is a library class, so I can’t edit it to change the implementation
    of the `compareTo` method. It’s also marked final, so I can’t just extend it and
    override the `compareTo` implementation. For cases like this, however, the `Collections.sort`
    method is overloaded to take a second argument, of type `java.util.Comparator`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将查看与此对应的Groovy代码，但首先让我们考虑另一个问题。如果你想要按长度而不是按字母顺序对字符串进行排序怎么办？`String`类是一个库类，所以我不能编辑它来更改`compareTo`方法的实现。它也被标记为`final`，所以我不能简单地扩展它并覆盖`compareTo`实现。然而，对于这种情况，`Collections.sort`方法被重载，可以接受一个类型为`java.util.Comparator`的第二个参数。
- en: The next listing shows a second sort of our list of strings, this time using
    the comparator, implemented as an anonymous inner class. Instead of using a `main`
    method as in the previous example, here’s a `StringSorter` class that sorts strings
    either using the default sort or by length.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了我们对字符串列表的第二次排序，这次使用的是作为匿名内部类实现的比较器。与上一个示例中的`main`方法不同，这里有一个`StringSorter`类，它可以使用默认排序或按长度对字符串进行排序。
- en: Listing 1.2\. A Java class to sort strings
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.2\. 一个用于排序字符串的Java类
- en: '![](008fig01_alt.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](008fig01_alt.jpg)'
- en: Here we see a consequence of the triumph of the nouns over the verbs. The `Comparator`
    interface has a `compare` method, and all we want to do is to supply our own implementation
    of that method to `Collections.sort`. We can’t implement a method, however, without
    including it in a class. In this case, we supply our own implementation (sort
    by length in decreasing order) via the awkward Java construct known as an anonymous
    inner class. To do so, we type the word `new` followed by the name of the interface
    we’re implementing (in this case, `Comparator`), open a brace, and stuff in our
    implementation, all as the second argument to the `sort` method. It’s an ugly,
    awkward syntax, whose only redeeming feature is that you do eventually get used
    to it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了名词战胜动词的胜利。`Comparator`接口有一个`compare`方法，我们只想为`Collections.sort`提供我们自己的方法实现。然而，我们无法在不将其包含在一个类中的情况下实现一个方法。在这种情况下，我们通过一个称为匿名内部类的尴尬的Java结构提供自己的实现（按长度降序排序）。为此，我们输入单词`new`，然后是我们要实现的接口的名称（在这种情况下，`Comparator`），打开一个花括号，并在`sort`方法的第二个参数中放入我们的实现。这是一个丑陋、尴尬的语法，它唯一的优点是，你最终会习惯它。
- en: 'Here’s the Groovy equivalent in script form:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Groovy脚本形式的等价代码：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First of all, I’m taking advantage of Groovy’s native support for collections
    by simply defining and populating a list as though it’s an array. The `strings`
    variable is in fact a reference to an instance of `java.util.ArrayList`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我通过简单地定义和填充列表，就像它是一个数组一样，利用Groovy对集合的原生支持。`strings`变量实际上是对`java.util.ArrayList`实例的引用。
- en: Next, I sort the strings using the two-argument version of `Collections.sort`.
    The interesting part is that the second argument to the `sort` method is a closure
    (between the braces), which is then “coerced” to implement `Comparable` using
    the `as` operator.^([[3](#ch01fn03)])
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我使用`Collections.sort`的两个参数版本对字符串进行排序。有趣的部分是，`sort`方法的第二个参数是一个闭包（在括号内），然后使用`as`运算符将其“强制”实现`Comparable`。^([[3](#ch01fn03)])
- en: ³ Closure coercion like this is discussed further in [chapter 4](kindle_split_014.html#ch04).
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 如此的闭包强制转换将在[第4章](kindle_split_014.html#ch04)中进一步讨论。
- en: The closure is intended to be the implementation of the `compare(String,String)`
    method analogous to that shown in the previous Java listing. Here I show the two
    dummy arguments, `s1` and `s2`, to the left of the arrow, and then use them on
    the right side. I provide the closure as the implementation of the `Comparator`
    interface. If the interface had several methods and I wanted to supply different
    implementations for each method, I would provide a map with the names of the methods
    as the keys and the corresponding closures as the values.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包旨在实现`compare(String, String)`方法，类似于之前Java列表中展示的那样。在这里，我在箭头左侧展示了两个虚拟参数`s1`和`s2`，然后在右侧使用它们。我将闭包作为`Comparator`接口的实现。如果接口有几个方法，并且我想为每个方法提供不同的实现，我将提供一个以方法名称为键、相应闭包为值的映射。
- en: Finally, I use the so-called spread-dot operator to invoke the `size` method
    on each element of the sorted collection, which returns a list of results. In
    this case I’m asking for the length of each string in the collection and comparing
    the results to the expected values.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我使用所谓的扩展点运算符来调用排序集合中每个元素的`size`方法，它返回一个结果列表。在这种情况下，我要求获取集合中每个字符串的长度，并将结果与预期值进行比较。
- en: By the way, the Groovy script didn’t require any imports, either. Java automatically
    imports the `java.lang` package. Groovy also automatically brings in `java.util`,
    `java.net`, `java.io`, `groovy.lang`, `groovy.util`, `java.math.BigInteger`, and
    `java` `.math.BigDecimal`. It’s a small thing, but convenient.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，Groovy脚本也不需要任何导入。Java自动导入`java.lang`包。Groovy还自动引入了`java.util`、`java.net`、`java.io`、`groovy.lang`、`groovy.util`、`java.math.BigInteger`和`java.math.BigDecimal`。这是一件小事，但很方便。
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Groovy Feature
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Groovy特性
- en: Native syntax for collections and additional automatic imports reduces both
    the amount of required code and its complexity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的原生语法和额外的自动导入减少了所需的代码量和其复杂性。
- en: '|  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'If you’ve used Groovy before you probably know that there’s actually an even
    simpler way to do the sort. I don’t need to use the `Collections` class at all.
    Instead, Groovy has added a `sort` method to `java.util.Collection` itself. The
    default version does a natural sort, and a one-argument version takes a closure
    to do the sorting. In other words, the entire sort can be reduced to a single
    line:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过Groovy，你可能知道实际上有一个更简单的方法来进行排序。我根本不需要使用`Collections`类。相反，Groovy已经将`sort`方法添加到了`java.util.Collection`本身。默认版本执行自然排序，一个参数版本的`sort`方法接受一个闭包来进行排序。换句话说，整个排序可以简化为单行：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The closure tells the `sort` method to use the result of the `size()` method
    on each element to do the sorting, with the minus sign implying that here I’m
    asking for descending order.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包告诉`sort`方法使用每个元素的`size()`方法的结果来进行排序，负号表示这里我要求降序排序。
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Groovy Feature
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Groovy特性
- en: Groovy’s additions to the JDK simplify its use, and Groovy closures eliminate
    artificial wrappers like anonymous inner classes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy对JDK的扩展简化了其使用，Groovy闭包消除了匿名内部类等人工包装。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'There were two major productivity improvements in this section. First, there
    are all the methods Groovy added to the Java libraries, known as the Groovy JDK.
    I’ll return to those methods frequently. Second, I take advantage of Groovy’s
    ability to treat methods as objects themselves, called closures. I’ll have a lot
    to say about closures in the upcoming chapters, but the last example illustrated
    one advantage of them: you almost never need anonymous inner classes.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中有两个主要的生产力提升。首先，Groovy添加到Java库中的所有方法，称为Groovy JDK。我会在接下来的章节中经常提到这些方法。其次，我利用Groovy将方法本身作为对象处理的能力，称为闭包。我将在接下来的章节中有很多关于闭包的讨论，但最后一个例子展示了它们的一个优点：你几乎永远不需要匿名内部类。
- en: Incidentally, in the closure I used an additional Groovy feature to protect
    myself. The question mark after the word `it` is the safe de-reference operator.
    If the reference is null it invokes the `size` method here. If not it returns
    `null` and avoids the `Null-PointerException`. That tiny bit of syntax wins over
    more Java developers to Groovy than I ever would have believed.^([[4](#ch01fn04)])
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，在闭包中，我使用了额外的Groovy特性来保护自己。`it`这个词后面的问号是安全的解引用操作符。如果引用为null，它将在这里调用`size`方法。如果不为null，它将返回`null`并避免`NullPointerException`。这个小小的语法比我想象的更能吸引更多的Java开发者转向Groovy。^([[4](#ch01fn04)])
- en: ⁴ Sometimes they get tears in their eyes. “Really?” they say. “I don’t have
    to put in all those null checks?” It’s touching how happy they are.
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 有时候他们会眼含泪水。“真的吗？”他们说。“我不用做所有那些null检查？”他们如此高兴，真是感人。
- en: 1.1.3\. Java is overly verbose
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3\. Java过于冗长
- en: The following listing shows a simple POJO. In this case I have a class called
    `Task`, perhaps part of a project management system. It has attributes to represent
    the name, priority, and start and end dates of the task.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了一个简单的POJO。在这种情况下，我有一个名为`Task`的类，可能是项目管理系统的一部分。它具有表示任务名称、优先级和开始和结束日期的属性。
- en: Listing 1.3\. A Java class representing a task
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.3\. 表示任务的Java类
- en: '![](011fig01_alt.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](011fig01_alt.jpg)'
- en: We have private fields and public getter and setter methods, along with whatever
    constructors we need. We also add a typical override of the `toString` method.
    I could probably use an override of `equals` and `hashCode` as well, but I left
    those out for simplicity.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有私有字段和公共的获取器和设置器方法，以及我们需要的任何构造函数。我们还添加了一个典型的重写`toString`方法。我可能还可以使用重写`equals`和`hashCode`，但为了简单起见，我省略了这些。
- en: Most of this code can be generated by an IDE, but it still makes for a long
    listing, and I haven’t added the necessary `equals` and `hashCode` overrides yet.
    That’s a lot of code for what’s essentially a dumb data structure.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码可以由IDE生成，但这仍然是一个很长的列表，我还没有添加必要的`equals`和`hashCode`重写。这实际上是一个愚蠢的数据结构，却需要这么多代码。
- en: 'The analogous Plain Old Groovy Object (POGO) is shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了类似的普通旧格罗ovy对象（POGO）：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Seriously, that’s the whole class, and it does include overrides of the `equals`
    and `hashCode` methods. Groovy classes are public by default, as are Groovy methods.
    Attributes are private by default. Access to an attribute is done through dynamically
    generated getter and setter methods, so even though it looks like we’re dealing
    with individual fields we’re actually going through getter and setter methods.
    Also, Groovy automatically provides a map-based constructor that eliminates the
    need for lots of overloaded constructors. The `@EqualsAndHashCode` annotation
    represents an Abstract Syntax Tree (AST) transformation that generates the associated
    methods. Finally, I use a Groovy string with its parameter substitution capabilities
    to convert a task into a string.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 严肃地说，这就是整个类，它确实包括重写`equals`和`hashCode`方法。Groovy类默认是公开的，Groovy方法也是如此。属性默认是私有的。属性的访问是通过动态生成的获取器和设置器方法完成的，所以尽管看起来我们是在处理单个字段，但实际上我们是通过获取器和设置器方法来处理的。此外，Groovy自动提供了一个基于映射的构造函数，消除了需要大量重载构造函数的需求。`@EqualsAndHashCode`注解代表一个抽象语法树（AST）转换，它生成相关的方法。最后，我使用Groovy字符串及其参数替换功能将任务转换为字符串。
- en: '|  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Groovy Feature
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 格罗ovy特性
- en: Groovy’s dynamic generation capabilities drastically reduce the amount of code
    required in a class, letting you focus on the essence rather than the ceremony.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy的动态生成能力大大减少了类中所需的代码量，让你能够关注本质而不是仪式。
- en: '|  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Java also includes checked exceptions, which are a mixed blessing at best. The
    philosophy is to catch (no pun intended) problems early in the development cycle,
    which is also supposed to be an advantage to static typing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Java 还包括检查型异常，这最多算是一种双刃剑。其哲学是在开发周期的早期就捕捉（无意中用了双关语）问题，这也被认为是静态类型的一个优势。
- en: 1.1.4\. Groovy makes testing Java much easier
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.4\. Groovy 使 Java 测试变得容易
- en: Just because a class compiles doesn’t mean it’s implemented correctly. Just
    because you’ve prepared for various exceptions doesn’t mean the code works properly.
    You’ve still got to test it, or you don’t really know.^([[5](#ch01fn05)])
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就算一个类能编译，并不意味着它实现了正确。就算你为各种异常做了准备，并不意味着代码能正常工作。你仍然需要测试它，否则你真的不知道。[5](#ch01fn05)
- en: ⁵ My favorite example of this comes from a friend who used to teach C++ back
    when that language was shiny and new. He looked at a student’s code, and it was
    a mess. Then he noticed the first line was `/*` and the last line was `*/`. He
    said, “You commented out your entire program.” The student shrugged and said,
    “That’s the only way I could get it to compile!”
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[5](#ch01fn05) 我最喜欢的例子来自一个朋友，他曾经在上世纪 C++ 语言还非常新潮的时候教 C++。他看了一个学生的代码，一团糟。然后他注意到第一行是
    `/*`，最后一行是 `*/`。他说：“你注释掉了整个程序。”学生耸了耸肩说：“这是我能让它编译的唯一方法！”'
- en: One of the most important productivity improvements of the past decade or so
    has been the rise of automated testing tools. Java has tools like JUnit and its
    descendants, which make both writing and running tests automated and easy.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 过去十年左右最重要的生产力提升之一是自动化测试工具的兴起。Java 有 JUnit 和其衍生工具，它们使编写和运行测试自动化且简单。
- en: Testing is another area where Groovy shines. First, the base Groovy libraries
    include `GroovyTestCase`, which extends JUnit’s `TestCase` class and adds a range
    of helpful methods, such as `testArrayEquals`, `testToString`, and even `shouldFail`.
    Next, Groovy’s metaprogramming capabilities have given rise to simple DSLs for
    testing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是 Groovy 发挥作用的另一个领域。首先，基本的 Groovy 库包括 `GroovyTestCase`，它扩展了 JUnit 的 `TestCase`
    类并添加了一系列有用的方法，例如 `testArrayEquals`、`testToString`，甚至 `shouldFail`。接下来，Groovy 的元编程能力催生了用于测试的简单
    DSL。
- en: One particularly nice example is the Spock framework, which I’ll discuss in
    [chapter 6](kindle_split_017.html#ch06) on testing. Spock is lean and expressive,
    with blocks like `given`, `expect`, and `when`/`then`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别好的例子是 Spock 框架，我将在 [第 6 章](kindle_split_017.html#ch06) 中讨论测试。Spock 精简且表达力强，有
    `given`、`expect` 和 `when`/`then` 这样的块。
- en: As an example, consider sorting strings, as implemented in Java and discussed
    earlier. In [listing 1.3](#ch01ex03) I presented a Java class that sorted strings
    both lexicographically and by decreasing length. Now I’d like to test that, and
    to do so I’m going to use the Spock testing framework from Groovy.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以排序字符串为例，这是在 Java 中实现的，前面已经讨论过。在 [列表 1.3](#ch01ex03) 中，我展示了一个 Java 类，它可以按字典顺序和递减长度对字符串进行排序。现在我想测试这一点，为此我将使用
    Groovy 的 Spock 测试框架。
- en: A Spock test that checks both sorting methods is shown in the following listing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了检查两种排序方法的 Spock 测试。
- en: Listing 1.4\. A Spock test that checks each Java sorting method
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.4\. 检查每个 Java 排序方法的 Spock 测试
- en: '![](012fig01_alt.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](012fig01_alt.jpg)'
- en: In the Spock test the Java class under test is instantiated as an attribute.
    I populate the data using the native collection in Groovy, even though the class
    under test is written in Java and the methods take Java lists as arguments.^([[6](#ch01fn06)])
    I have two tests, and in each case, even without knowing anything about Spock,
    it should be clear what the tests are doing. I’m taking advantage of Groovy capabilities
    like optional parentheses and the spread-dot operator, which applies to a list
    and returns a list with the specified properties only.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spock 测试中，被测试的 Java 类作为属性实例化。我使用 Groovy 的原生集合来填充数据，尽管被测试的类是用 Java 编写的，并且方法接受
    Java 列表作为参数。[6](#ch01fn06) 我有两个测试，在每种情况下，即使不了解 Spock，也应该清楚测试在做什么。我正在利用 Groovy
    的可选括号和扩展点操作符，它适用于列表并返回具有指定属性的唯一列表。
- en: ⁶ Applying Groovy tests to Java code is discussed in [chapter 6](kindle_split_017.html#ch06).
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 [第 6 章](kindle_split_017.html#ch06) 中讨论了将 Groovy 测试应用于 Java 代码。
- en: The test passes, and I can use the same test with the Groovy implementation.
    The point, though, is that I can add a Groovy test to a Java system without any
    problems.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过了，我可以用相同的测试与 Groovy 实现一起使用。然而，重要的是，我可以在没有任何问题的前提下，向 Java 系统中添加一个 Groovy
    测试。
- en: 1.1.5\. Groovy tools simplify your build
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.5\. Groovy 工具简化了你的构建
- en: Another area where Groovy helps Java is in the build process. I’ll have a lot
    to say about Groovy build mechanisms in [chapter 5](kindle_split_016.html#ch05),
    but here I’ll just mention a couple of ways they help Java. If you’re accustomed
    to using Apache Ant for building systems, Groovy adds execution and compilation
    tasks to Ant. Another option is to use `AntBuilder`, which allows you to write
    Ant tasks using Groovy syntax.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy帮助Java的另一个领域是在构建过程中。我将在第5章中详细讨论Groovy的构建机制，但在这里我将只提到它们如何帮助Java的几种方式。如果你习惯于使用Apache
    Ant构建系统，Groovy为Ant添加了执行和编译任务。另一个选项是使用`AntBuilder`，它允许你使用Groovy语法编写Ant任务。
- en: 'That’s actually a common theme in Groovy, which I should emphasize:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是Groovy的一个常见主题，我应该强调：
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Groovy Feature
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Groovy特性
- en: Groovy augments and enhances existing Java tools, rather than replacing them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy增强并扩展了现有的Java工具，而不是取代它们。
- en: '|  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If your company has moved from Ant to Maven you’re using a tool that works at
    a higher level of abstraction and manages dependencies for you. In [chapter 5](kindle_split_016.html#ch05)
    two ways are provided to add Groovy to a Maven build. The Groovy ecosystem, however,
    provides another alternative.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的公司已经从Ant迁移到Maven，你正在使用一个工作在更高抽象层次并为你管理依赖项的工具。在第5章中提供了两种将Groovy添加到Maven构建的方法。然而，Groovy生态系统提供了另一种选择。
- en: In [chapter 5](kindle_split_016.html#ch05) I discuss the latest Groovy killer
    app, Gradle. Gradle does dependency management based on Maven repositories (though
    it uses Ivy under the hood) and defines build tasks in a manner similar to Ant,
    but it’s easy to set up and run. Maven is very powerful, but it has a lot of trouble
    with projects that weren’t designed from the beginning with it in mind. Maven
    is a very opinionated framework, and customization is done through plugins. Ultimately,
    in Maven the build file is written in XML. Gradle is all about customization,
    and because the build file is written in Groovy you have the entire power of the
    Groovy language available to you.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章中，我讨论了最新的Groovy杀手级应用Gradle。Gradle基于Maven仓库进行依赖项管理（尽管底层使用Ivy），并以类似于Ant的方式定义构建任务，但它易于设置和运行。Maven非常强大，但它与那些一开始就没有考虑到它的项目有很多麻烦。Maven是一个非常具有意见的框架，并且通过插件进行定制。最终，在Maven中，构建文件是用XML编写的。Gradle完全是关于定制的，并且因为构建文件是用Groovy编写的，所以你可以使用Groovy语言的全部功能。
- en: 'That fact that Gradle build files are written in Groovy doesn’t limit it to
    Groovy projects, though. If your Java project is in fact written in Maven form
    and has no external dependencies, here’s your entire Gradle build file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Gradle构建文件是用Groovy编写的，但这并不限制它只能用于Groovy项目。如果你的Java项目实际上是用Maven形式编写的，并且没有外部依赖项，那么这就是你的整个Gradle构建文件：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Applying the Java plugin defines a whole set of tasks, from compile to test
    to JAR. If that one line of code is in a file called build.gradle, then just type
    `gradle` `build` at the command line and a whole host of activities ensue. If
    you’re (hopefully) going to do some testing, you’ll need to add a dependency on
    JUnit, or even Spock. The resulting build file is shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 应用Java插件定义了一系列任务，从编译到测试再到JAR。如果这一行代码在一个名为build.gradle的文件中，那么只需在命令行中输入`gradle
    build`，就会引发一系列活动。如果你（希望如此）要进行一些测试，你需要添加JUnit或Spock的依赖。生成的构建文件如下所示：
- en: '![](013fig01_alt.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](013fig01_alt.jpg)'
- en: 'Now running gradle build results in a series of stages:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行gradle build会导致一系列阶段：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The result is a nice, hyperlinked set of documentation of all the test cases,
    plus a JAR file for deployment.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含所有测试用例的漂亮、超链接的文档集，以及一个用于部署的JAR文件。
- en: Of course, if there’s a plugin called `java`, there’s a plugin called `groovy`.
    Better yet, the Groovy plugin includes the Java plugin and, as usual, augments
    and improves it. If your project is similar to the ones discussed in this book,
    in that it combines Groovy and Java classes and uses each where most helpful,
    then all you need is the Groovy plugin and you’re ready to go. There are many
    other plugins available, including `eclipse` and `web`. I’ll talk about them in
    [chapter 5](kindle_split_016.html#ch05) on build processes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果有一个名为`java`的插件，那么还有一个名为`groovy`的插件。更好的是，Groovy插件包括Java插件，并且像往常一样，增强并改进它。如果你的项目与本书中讨论的项目类似，即它结合了Groovy和Java类，并在最有帮助的地方使用它们，那么你只需要Groovy插件就可以开始了。还有许多其他插件可用，包括`eclipse`和`web`。我将在第5章中讨论它们，关于构建过程。
- en: In this section I reviewed several of the features built into Java and how they
    can lead to code that’s more verbose and complicated than necessary. I demonstrated
    how Groovy can streamline implementations and even augment existing Java tools
    to make them easier to use and more powerful. I’ll show more details throughout
    the book. First I want to list some of the additional capabilities Groovy brings
    to Java in the next section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我回顾了Java中内置的一些功能以及它们如何导致代码比必要的更冗长和复杂。我展示了Groovy如何简化实现，甚至增强现有的Java工具，使其更容易使用且更强大。我将在整本书中展示更多细节。首先，我想在下一节中列出Groovy为Java带来的额外功能。
- en: 1.2\. Groovy features that help Java
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2\. Groovy对Java的帮助
- en: I’ve actually been discussing these all along, but let me make a few specific
    points here. First, the Groovy version of a Java class is almost always simpler
    and cleaner. Groovy is far less verbose and generally easier to read.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我实际上一直在讨论这些内容，但让我在这里提出一些具体观点。首先，Groovy版本的Java类几乎总是更简单、更干净。Groovy的语法远没有Java那么冗长，通常更容易阅读。
- en: As true as that statement is, though, it’s a bit misleading. I’m not advocating
    rewriting all your Java code in Groovy. Quite the contrary; if your existing Java
    code works, that’s great, although you might want to consider adding test cases
    in Groovy if you don’t already have them. In this book, I’m more interested in
    helping Java than replacing it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个说法是真实的，但它有点误导。我并不主张将所有的Java代码重写为Groovy。恰恰相反；如果你的现有Java代码工作得很好，那太好了，尽管你可能想要考虑添加Groovy测试用例，如果你还没有的话。在这本书中，我更感兴趣的是帮助Java而不是取代它。
- en: 'What does Groovy offer Java? Here’s a short list of topics that are discussed
    in much more detail in the rest of the book:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy为Java提供了什么？以下是在本书其余部分详细讨论的短列表主题：
- en: '**1**.  *Groovy adds new capabilities to existing Java classes.* Groovy includes
    a Groovy JDK, which documents the methods added by Groovy to the Java libraries.
    The various `sort` methods added to the `Collection` interface that I used for
    strings was a simple example. You can also use Java classes with Groovy and add
    features like operator overloading to Java. These and related topics will be discussed
    in [chapter 4](kindle_split_014.html#ch04).'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  *Groovy为现有的Java类添加了新功能。* Groovy包括一个Groovy JDK，它记录了Groovy添加到Java库中的方法。我使用字符串的`Collection`接口中添加的`sort`方法是一个简单的例子。你还可以使用Java类与Groovy一起，并为Java添加如操作符重载等功能。这些以及相关主题将在第4章（[kindle_split_014.html#ch04]）中讨论。'
- en: '**2**.  *Groovy uses Java libraries.* Practically every Groovy class relies
    on the Java libraries, with or without Groovy additions. That means virtually
    every Groovy class is already an integration story, mixing Groovy and Java together.
    One nice use case for Groovy is to experiment with Java libraries you haven’t
    used before.'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  *Groovy使用Java库。* 几乎每个Groovy类都依赖于Java库，无论是带有还是不带Groovy的扩展。这意味着几乎每个Groovy类都已经是一个集成故事，将Groovy和Java结合在一起。Groovy的一个很好的用途是尝试使用你之前没有使用过的Java库。'
- en: '**3**.  *Groovy makes working with* *XML and JSON easy.* Here’s an area where
    Groovy shines. Groovy includes classes called `MarkupBuilder`, which makes it
    easy to generate XML, and `JsonBuilder`, which produces JSON objects. It also
    has classes called `XmlParser` and `XmlSlurper`, which convert XML data structures
    into DOM structures in memory, and `JsonSlurper`, to parse JSON data. These will
    be used throughout the book, especially in [chapter 9](kindle_split_021.html#ch09)
    on RESTful web services.'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  *Groovy使处理* *XML和JSON变得容易。* 这是在Groovy中表现优异的领域。Groovy包括名为`MarkupBuilder`的类，它使得生成XML变得容易，以及名为`JsonBuilder`的类，它生成JSON对象。它还包括名为`XmlParser`和`XmlSlurper`的类，它们将XML数据结构转换为内存中的DOM结构，以及`JsonSlurper`来解析JSON数据。这些将在整本书中使用，特别是在第9章（[RESTful
    Web服务](kindle_split_021.html#ch09)）中。'
- en: '**4**.  *Groovy includes simplified data source manipulation.* The `groovy.sql.Sql`
    class provides a very simple way to work with relational databases. I’ll talk
    about this in [chapter 8](kindle_split_020.html#ch08) on databases, [chapter 7](kindle_split_019.html#ch07)
    on working with the Spring framework, and [chapter 9](kindle_split_021.html#ch09)
    on RESTful web services.'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  *Groovy包括简化的数据源操作。* `groovy.sql.Sql` 类提供了一种非常简单的方式来处理关系数据库。我将在第8章（[数据库](kindle_split_020.html#ch08)）、第7章（[使用Spring框架](kindle_split_019.html#ch07)）和第9章（[RESTful
    Web服务](kindle_split_021.html#ch09)）中详细讨论这一点。'
- en: '**5**.  *Groovy’s metaprogramming streamlines development.* The builder classes
    are an example of Groovy metaprogramming. I’ll show examples of DSLs in several
    chapters.'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**.  *Groovy的元编程简化了开发。* 构建器类是Groovy元编程的一个例子。我将在几个章节中展示DSL的示例。'
- en: '**6**.  *Groovy tests work for Java code.* The Spock testing tool, demonstrated
    in this chapter and extensively discussed in [chapter 6](kindle_split_017.html#ch06)
    on testing, is a great way to test Java systems.'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**.  *Groovy测试适用于Java代码。* 本章演示并广泛讨论的Spock测试工具，在第6章（[kindle_split_017.html#ch06](https://wiki.example.org/kindle_split_017.html#ch06)）关于测试的内容中，是测试Java系统的一个很好的方法。'
- en: '**7**.  *Groovy build tools work on Java (and mixed) projects.* In [chapter
    5](kindle_split_016.html#ch05) on enhancing build processes, I’ll talk about `AntBuilder`,
    how to add Groovy to Maven builds, and Gradle.'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**7**.  *Groovy构建工具适用于Java（和混合）项目。* 在第5章（[kindle_split_016.html#ch05](https://wiki.example.org/kindle_split_016.html#ch05)）关于增强构建过程的内容中，我将讨论`AntBuilder`，如何将Groovy添加到Maven构建中，以及Gradle。'
- en: '**8**.  *Groovy projects like Grails* *and Griffon make developing web and
    desktop applications easier.* The Grails project is a complete-stack, end-to-end
    framework for building web applications, based on Spring and Hibernate. Griffon
    brings the same convention-over-configuration ideas to desktop development. Grails
    is discussed in [chapter 8](kindle_split_020.html#ch08) on databases and [chapter
    10](kindle_split_022.html#ch10) on web applications.'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**8**.  *像Grails* *和Griffon这样的Groovy项目使开发Web和桌面应用程序变得更容易。* Grails项目是一个基于Spring和Hibernate的完整栈、端到端框架，用于构建Web应用程序。Griffon将相同的约定优于配置思想引入桌面开发。Grails在第8章（[kindle_split_020.html#ch08](https://wiki.example.org/kindle_split_020.html#ch08)）关于数据库和第10章（[kindle_split_022.html#ch10](https://wiki.example.org/kindle_split_022.html#ch10)）关于Web应用程序中进行了讨论。'
- en: When looking at the sorts of problems Java developers typically encounter, this
    list will be a source of ideas for making implementations simpler, easier to read
    and understand, and faster to implement.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看Java开发者通常遇到的问题时，这个列表将成为简化实现、使其更容易阅读和理解、更快实施的想法的来源。
- en: 1.3\. Java use cases and how Groovy helps
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3. Java用例以及Groovy如何帮助
- en: The examples I’ve discussed so far are all code-level simplifications. They’re
    very helpful, but I can do more than that. Groovy developers work on the same
    sorts of problems that Java developers do, so many higher-level abstractions have
    been created to make addressing those problems easier.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我迄今为止讨论的示例都是代码级别的简化。它们非常有帮助，但我可以做得更多。Groovy开发者处理的问题与Java开发者类似，因此已经创建了多个高级抽象，以使解决问题变得更简单。
- en: In this book I’m also going to survey the various types of problems that Java
    developers face on a regular basis, from accessing and implementing web services
    to using object-relational mapping tools to improving your build process. In each
    case I’ll examine how adding Groovy can make your life easier as a developer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我还将调查Java开发者日常面临的各种类型的问题，从访问和实现Web服务到使用对象关系映射工具以及改进构建过程。在每种情况下，我将探讨添加Groovy如何使您作为开发者的生活变得更轻松。
- en: Here’s a list of some of the areas I’ll discuss as we go along, and I’ll give
    you a brief idea of how Groovy will help. This will also provide a lightweight
    survey of the upcoming chapters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进的过程中，以下是一些我将讨论的领域，我将简要介绍Groovy如何帮助。这还将提供对即将到来的章节的轻量级概述。
- en: 1.3.1\. Spring framework support for Groovy
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.1. Spring框架对Groovy的支持
- en: One of the most successful open source projects in the Java industry today is
    the Spring framework. It’s the Swiss Army chainsaw of projects; it’s pervasive
    throughout the Java world and has tools for practically every purpose.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 目前Java行业中最为成功的开源项目之一是Spring框架。它是项目的瑞士军刀；它在Java世界中无处不在，并为几乎每个目的都提供了工具。
- en: No one is ever going to suggest rewriting Spring in Groovy. It works fine in
    Java as it is. Nor is there any need to “port” it to Groovy. As far as Spring
    is concerned, compiled Groovy classes are just another set of bytecodes. Groovy
    can use Spring as though it’s just another library.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人会建议用Groovy重写Spring。它现在在Java中运行得很好。也没有必要将其“移植”到Groovy。就Spring而言，编译后的Groovy类只是一组字节码。Groovy可以使用Spring，就像使用另一个库一样。
- en: The developers of Spring, however, are well aware of Groovy and built in special
    capabilities for working with it. Spring bean files can contain *inline scripted*
    Groovy beans. Spring also allows you to deploy Groovy source code, rather than
    compiled versions, as so-called *refreshable* beans. Spring periodically checks
    the source code of refreshable beans for changes and, if it finds any, rebuilds
    them and uses the updated versions. This is a very powerful capability, as [chapter
    7](kindle_split_019.html#ch07) on working with Spring will show.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Spring的开发者对Groovy非常了解，并为其构建了特殊的功能以支持其使用。Spring的bean文件可以包含*内联脚本*的Groovy bean。Spring还允许你部署Groovy源代码，而不是编译版本，作为所谓的*可刷新*bean。Spring定期检查可刷新bean的源代码以查找更改，如果发现任何更改，则重新构建它们并使用更新版本。这是一个非常强大的功能，正如[第7章](kindle_split_019.html#ch07)中关于使用Spring的内容将展示的那样。
- en: Finally, the developers of the Grails project also created a class called `BeanBuilder`,
    which is used to script Spring beans in Groovy. That brings Groovy capabilities
    to Spring bean files much the way Gradle enhances XML build files.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Grails项目的开发者还创建了一个名为`BeanBuilder`的类，用于在Groovy中脚本化Spring bean。这就像Gradle增强XML构建文件一样，将Groovy的功能带到了Spring
    bean文件中。
- en: 1.3.2\. Simplified database access
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.2. 简化数据库访问
- en: Virtually all Java developers work with databases. Groovy has a special set
    of classes to make database integration easy, and I’ll review them in [chapter
    8](kindle_split_020.html#ch08) on databases. I also show an example of working
    with a MongoDB database through a Groovy library that wraps the corresponding
    Java API.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有Java开发者都与数据库打交道。Groovy有一套特殊的类，可以轻松实现数据库集成，我将在[第8章](kindle_split_020.html#ch08)关于数据库的章节中对其进行回顾。我还展示了通过一个封装相应Java
    API的Groovy库与MongoDB数据库交互的示例。
- en: I’ll also borrow from the Grails world and discuss GORM, the Grails Object-Relational
    Mapping tool, a DSL for configuring Hibernate. In fact, GORM has been refactored
    to work with a variety of persistence mechanisms, including NoSQL databases like
    MongoDB, Neo4J, Redis, and more.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将借鉴Grails世界的经验，讨论GORM，即Grails对象关系映射工具，这是一个用于配置Hibernate的DSL。实际上，GORM已经被重构以支持各种持久化机制，包括MongoDB、Neo4J、Redis等NoSQL数据库。
- en: 1.3.3\. Building and accessing web services
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.3. 构建和访问Web服务
- en: Another area of active development today is in web services. Java developers
    work with both SOAP-based and RESTful services, the former involving auto-generated
    proxies and the latter using HTTP as much as possible. REST is covered in [chapter
    9](kindle_split_021.html#ch09), and SOAP-based web services are discussed in appendix
    C, available as a free download. In both cases, if a little care is applied, the
    existing Java tools work just fine with Groovy implementations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，另一个活跃的开发领域是Web服务。Java开发者使用基于SOAP和RESTful的服务，前者涉及自动生成的代理，后者尽可能使用HTTP。REST在[第9章](kindle_split_021.html#ch09)中有介绍，基于SOAP的Web服务在附录C中讨论，该附录可免费下载。在这两种情况下，如果稍加注意，现有的Java工具与Groovy实现配合得很好。
- en: 1.3.4\. Web application enhancements
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.4. Web应用增强
- en: Groovy includes a “groovlet” class, which acts like a Groovy-based servlet.
    It receives HTTP requests and returns HTTP responses, and it includes pre-built
    objects for requests, responses, sessions, and more. One of the most successful
    instances of Groovy and Java integration, and arguably the killer app for Groovy,
    is the Grails framework, which brings extraordinary productivity to web applications.
    Both are covered in [chapter 10](kindle_split_022.html#ch10) on web development.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy包含一个“groovlet”类，它类似于基于Groovy的servlet。它接收HTTP请求并返回HTTP响应，并包括请求、响应、会话等预构建对象。Groovy和Java集成最成功的实例之一，可以说是Groovy的杀手级应用，是Grails框架，它为Web应用带来了非凡的生产力。这两者都在[第10章](kindle_split_022.html#ch10)关于Web开发的章节中有介绍。
- en: In each of these use cases, Groovy can work with existing Java tools, libraries,
    and infrastructure. In some situations, Groovy will simplify the required code.
    In other cases, the integration is more deeply embedded and will provide capabilities
    far beyond what Java alone includes. In all of them, the productivity gains will
    hopefully be both obvious and dramatic.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些用例中，Groovy可以与现有的Java工具、库和基础设施协同工作。在某些情况下，Groovy将简化所需的代码。在其他情况下，集成将更加深入，并将提供远超Java本身所包含的功能。在所有这些情况下，希望生产力的提升既明显又显著。
- en: 1.4\. Summary
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4. 摘要
- en: Java is a large, powerful language, but it’s showing its age. Decisions made
    early in its development are not necessarily appropriate now, and over time it
    has accumulated problems and inconsistencies. Still, Java is everywhere, and its
    tools, libraries, and infrastructure are both useful and convenient.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Java是一种庞大、强大的语言，但它已经显露出它的年龄。在其早期开发中做出的决策现在可能并不一定合适，随着时间的推移，它已经积累了问题和不一致性。尽管如此，Java无处不在，它的工具、库和基础设施既有用又方便。
- en: In this chapter I reviewed some of the issues that are part of the Java development
    world, from its verbosity to anonymous inner classes to static typing. Most Java
    developers are so accustomed to these “problems” that they see them as features
    as much as bugs. Add a little bit of Groovy, however, and the productivity gains
    can be considerable. I demonstrated that simply using Groovy native collections
    and the methods Groovy adds to the standard Java libraries reduced huge sections
    of code down to a few lines. I also listed the Groovy capabilities that will be
    a rich source of ideas for simplifying Java development.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我回顾了Java开发世界中的一些问题，从其冗长性到匿名内部类再到静态类型。大多数Java开发者已经习惯了这些“问题”，以至于他们把它们看作是特性而不是错误。然而，添加一点Groovy，生产力的提升可以相当可观。我演示了仅仅使用Groovy原生集合和Groovy添加到标准Java库中的方法，可以将大量代码缩减到几行。我还列出了Groovy的功能，这将是一个简化Java开发的丰富思想来源。
- en: As powerful as Groovy is (and as fun as it is to use), I still don’t recommend
    replacing your existing Java with Groovy. In this book I advocate a blended approach.
    The philosophy is to use Java wherever it is appropriate, which mostly means using
    its tools and libraries and deploying to its infrastructure. I add Groovy to Java
    wherever it helps the most. In the next chapter I’ll begin that journey by examining
    class-level integration of Java and Groovy.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Groovy（以及使用Groovy的乐趣）非常强大，但我仍然不建议用Groovy替换现有的Java。在这本书中，我提倡一种混合方法。哲学是在适当的地方使用Java，这通常意味着使用其工具和库，并将其部署到其基础设施上。我在Java中最有帮助的地方添加Groovy。在下一章中，我将通过检查Java和Groovy在类级别的集成开始这段旅程。
- en: Chapter 2\. Groovy by example
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2章 通过示例学习Groovy
- en: '*This chapter covers*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Basic Groovy syntax
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本Groovy语法
- en: Collections and closures
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合和闭包
- en: Using the Groovy JDK
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Groovy JDK
- en: As the previous chapter stated, this book isn’t intended to be an exhaustive
    reference for Groovy, but a certain minimum level of Groovy proficiency is necessary.
    While some people learn best through short, simple code examples illustrating
    each concept, others prefer to see basic concepts combined to solve actual problems.
    For those who prefer snippets of code for each feature I’ve provided [appendix
    B](kindle_split_024.html#app02), a Groovy tutorial arranged by feature.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，这本书并不是旨在成为Groovy的全面参考，但至少需要一定的Groovy熟练程度。虽然有些人通过简短、简单的代码示例来学习每个概念，但其他人更喜欢看到基本概念结合解决实际问题。对于那些喜欢每个功能都有代码片段的人来说，我提供了[附录B](kindle_split_024.html#app02)，一个按功能排列的Groovy教程。
- en: In this chapter, I’ll instead walk through a few small but non-trivial Groovy
    examples. Hopefully this will help communicate not only the syntax of the language,
    but some of the standard Groovy idioms as well. Some of the examples will be used
    again in other chapters in the book, but are used here as illustrations of basic
    Groovy practices.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将通过几个小型但非平凡的Groovy示例进行说明。希望这不仅能帮助传达语言的语法，还能传达一些标准的Groovy惯用法。一些示例将在本书的其他章节中再次使用，但在这里作为基本Groovy实践的说明。
- en: 2.1\. Hello, Groovy
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1. 你好，Groovy
- en: 'Because every programming language book is required by law to include a “Hello,
    World!” program, here’s Groovy’s version:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每本编程语言书籍都依法必须包含一个“Hello, World!”程序，所以这里是Groovy的版本：
- en: '[PRE5]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In Java you compile with `javac` and execute the resulting bytecodes with `java`.
    In Groovy you can compile with `groovyc` and execute with `groovy`, but you don’t
    actually have to compile first. The `groovy` command can run with a source code
    argument, and it will compile first and then execute. Groovy is a compiled language,
    but you don’t have to separate the steps, though most people do. When you use
    an IDE, for example, every time you save a Groovy script or class, it is compiled.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，您使用`javac`进行编译，并使用`java`执行生成的字节码。在Groovy中，您可以使用`groovyc`进行编译，并使用`groovy`执行，但实际上您并不需要先进行编译。`groovy`命令可以与源代码参数一起运行，它将首先编译然后执行。Groovy是一种编译型语言，但您不需要分离步骤，尽管大多数人都会这样做。例如，当您使用IDE时，每次保存Groovy脚本或类，它都会被编译。
- en: The single line shown earlier is a complete program. Unlike with Java, you don’t
    need to put all Groovy code into a class. Groovy supports running scripts. Everything
    is still Java bytecodes under the hood, so what happens is that Groovy scripts
    eventually become the body of the `main` method in a class that extends `groovy.lang.Script`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的单行就是一个完整的程序。与Java不同，你不需要将所有Groovy代码放入一个类中。Groovy支持运行脚本。在底层，所有内容仍然是Java字节码，所以发生的情况是Groovy脚本最终成为扩展`groovy.lang.Script`类的`main`方法体。
- en: 'Note two additional differences in syntax between Groovy and Java:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Groovy 和 Java 之间语法上的两个额外差异：
- en: '***Semicolons are optional.*** You can add them, and it’s appropriate to use
    them if you have more than one statement on a line, but they’re not normally necessary.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***分号是可选的。*** 你可以添加它们，如果你一行中有多个语句，使用它们是合适的，但通常并不必要。'
- en: '***Parentheses are often optional.*** The `println` command is actually a method
    call, and the `String` is the argument to the method. Because there’s no ambiguity,
    you can leave out the parentheses. It’s not wrong to include them, though, if
    you want.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***括号通常是可选的。*** `println` 命令实际上是一个方法调用，而 `String` 是传递给方法的参数。因为没有任何歧义，你可以省略括号。不过，如果你想包含它们，也没有错。'
- en: '|  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Optional Parentheses
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可选的括号
- en: Parentheses are optional until they aren’t. Simple method calls normally omit
    them, but if there’s any uncertainty, add them. Groovy is all about simplicity
    and understandability.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 括号在需要之前是可选的。简单的函数调用通常省略括号，但如果存在任何不确定性，请添加它们。Groovy的一切都关于简洁和可理解性。
- en: '|  |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: Now that the “Hello, World!” example is out of the way, I can move on to something
    a bit more interesting. One helpful use case for Groovy is that it makes a nice
    client for RESTful web services like Google Chart.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在“Hello, World!”示例已经完成，我可以继续进行一些更有趣的内容。Groovy的一个有用用例是它能够很好地作为RESTful网络服务（如Google
    Chart）的客户端。
- en: 2.2\. Accessing Google Chart Tools
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 访问 Google 图表工具
- en: One of the APIs that Google makes available is a RESTful web service known as
    the Chart API, or, more formally, Google Chart Tools Image API.^([[1](#ch02fn01)])
    The documentation is located at [https://developers.google.com/chart/image/](https://developers.google.com/chart/image/).
    The chart tools provide a rich API for JavaScript users, but the inputs are ultimately
    URLs with query parameters.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌提供的一个API是名为Chart API的RESTful网络服务，或者更正式地，称为Google Chart Tools Image API.^([[1](#ch02fn01)])
    文档位于[https://developers.google.com/chart/image/](https://developers.google.com/chart/image/)。这些图表工具为JavaScript用户提供了一个丰富的API，但输入最终是带有查询参数的URL。
- en: ¹ Google officially deprecated the image charts portion of Google Chart Tools
    on April 20, 2012\. As of summer, 2013, the API still works. It is used here both
    as a nice, self-contained example and as a simple application that illustrates
    many Groovy features. Other examples of accessing publicly available services
    are given throughout the book.
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ Google于2012年4月20日正式弃用了Google Chart Tools中的图像图表部分。截至2013年夏季，该API仍然可用。这里既作为一个良好且自包含的示例，也作为一个简单应用，展示了Groovy的许多特性。书中还提供了其他访问公开服务的示例。
- en: 'A developer sends a request to the base URL [https://chart.apis.google.com/chart](https://chart.apis.google.com/chart)
    and appends query parameters to specify the type of chart, its size, the data,
    and any labels. Because that API also needs a “Hello, World” example, here’s the
    URL for a three-dimensional pie chart:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者向基本 URL [https://chart.apis.google.com/chart](https://chart.apis.google.com/chart)
    发送请求，并附加查询参数以指定图表类型、大小、数据以及任何标签。因为该 API 还需要一个“Hello, World”示例，以下是三维饼图的 URL：
- en: '[PRE6]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This URL would be all on one line but is written out here (and in the documentation)
    for illustration purposes. After the base URL, the parameters list the chart type
    (`cht`) as a 3D pie chart, the chart size (`chs`) as 250 by 100 pixels, the chart
    data (`chd`) as 60 and 40 in simple text format, and the chart labels (`chl`)
    “Hello” and “World.” Type that URL into a browser and the resulting image is returned,
    as shown in [figure 2.1](#ch02fig01).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个URL本可以全部放在一行中，但在这里（以及文档中）将其展开是为了说明目的。在基本URL之后，参数列表中指定图表类型（`cht`）为3D饼图，图表大小（`chs`）为250x100像素，图表数据（`chd`）以简单的文本格式表示为60和40，以及图表标签（`chl`）“Hello”和“World。”将此URL输入浏览器，返回的结果图像如图2.1所示。[图2.1](#ch02fig01)。
- en: Figure 2.1\. The Google Chart API “Hello, World” example
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1\. Google图表API的“Hello, World”示例
- en: '![](02fig01.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig01.jpg)'
- en: The URL shown is hard-wired to produce the chart in [figure 2.1](#ch02fig01).
    To make this more general, I’ll show how to produce the URL from strings, lists,
    maps, closures, and builders.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的 URL 是硬编码来生成[图 2.1](#ch02fig01)中的图表。为了使其更通用，我将展示如何从字符串、列表、映射、闭包和构建器生成 URL。
- en: '|  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: GOAL
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 目标
- en: Write a Groovy script to generate the “Hello, World” 3D pie chart as a desktop
    application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Groovy 脚本以生成“Hello, World”3D饼图作为桌面应用程序。
- en: '|  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In the process, I’ll discuss
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我将讨论
- en: String manipulation
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串操作
- en: Lists and maps
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表和映射
- en: Processing data using closures
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用闭包处理数据
- en: Groovy builder classes
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Groovy 构建器类
- en: In this case I’ll implement the steps in a simple script; later, it could be
    converted to a class for integration purposes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将使用简单的脚本实现这些步骤；稍后，它可能被转换为类以进行集成。
- en: 2.2.1\. Assembling the URL with query string
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1\. 使用查询字符串组装 URL
- en: 'To start, I need a variable to represent the base URL. In a Groovy script you
    don’t actually have to declare any types at all. If you declare a type the variable
    becomes local to the script. If not, it becomes part of the “binding,” which is
    discussed in the next chapter. Here, because I know the URL will be contained
    in a string before I convert it, I’ll declare the variable to be of type `java.lang.String`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我需要一个变量来表示基本 URL。在 Groovy 脚本中，你实际上根本不需要声明任何类型。如果你声明了一个类型，变量就会成为脚本的局部变量。如果没有，它就成为了“绑定”的一部分，这在下一章中会讨论。在这里，因为我知道在转换之前
    URL 将包含在一个字符串中，所以我将声明该变量为 `java.lang.String` 类型：
- en: '[PRE7]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Groovy is optionally typed. This means you can specify a type if you want to,
    or you can use the keyword `def` if you don’t know or care. There’s some debate
    among developers about when to use `def` and when to specify a type. Dierk Koenig,
    lead author on the superb *Groovy in Action* (Manning, 2007), says it this way:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 是可选类型的。这意味着你可以根据需要指定类型，或者如果你不知道或不在乎，可以使用关键字 `def`。在开发人员中关于何时使用 `def`
    和何时指定类型有一些争议。Dierk Koenig，优秀书籍《Groovy in Action》（Manning，2007）的主编，是这样说的：
- en: '|  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Using def
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 def
- en: If you think of a type, type it (from Dierk Koenig). In other words, if you
    know a variable will be a `String`, or a `Date`, or an `Employee`, use that type
    of variable.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想到一个类型，就输入它（来自 Dierk Koenig）。换句话说，如果你知道一个变量将是 `String`、`Date` 或 `Employee`，就使用那种类型的变量。
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'In my own experience, I used to use `def` a lot, but as time goes by I use
    it less and less. I agree with Dierk, with the addition that when I’m tempted
    to use `def` I often pause a moment and try to think of an actual type before
    using it. Other developers have other styles, though. That’s the beauty of an
    optionally typed language: there’s room for everybody.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的个人经验中，我过去经常使用 `def`，但随着时间的推移，我使用它的次数越来越少。我同意 Dierk 的观点，并补充说，当我倾向于使用 `def`
    时，我经常停下来片刻，并在使用它之前尝试想出一个实际类型。尽管其他开发人员有其他风格。这就是可选类型语言的美妙之处：每个人都有空间。
- en: 'I now need to append the query parameters to this URL. Rather than write the
    query string directly I’m going to use a typical idiom for this type of application,
    which is to build a map and then generate the query string from the map parameters.
    With that in mind, here’s the map of parameters:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在需要将查询参数追加到这个 URL 上。而不是直接编写查询字符串，我将使用这种类型应用程序的典型惯用语，即构建一个映射，然后从映射参数生成查询字符串。考虑到这一点，以下是参数映射：
- en: '[PRE8]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In Groovy you create a map with square brackets, and each entry consists of
    keys and values separated by a colon. The keys are assumed to be strings by default.
    The values can be anything. By default, the `params` variable is an instance of
    `java.util` `.LinkedHashMap`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Groovy 中，你使用方括号创建一个映射，每个条目由冒号分隔的键和值组成。默认情况下，键被认为是字符串。值可以是任何东西。默认情况下，`params`
    变量是 `java.util.LinkedHashMap` 的实例。
- en: '|  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Collections
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 集合
- en: Groovy has native syntax for lists and maps. Map keys are assumed to be strings.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 有原生的列表和映射语法。映射键默认为字符串。
- en: '|  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Each corresponding value is surrounded by single quotes. In Groovy, single-quoted
    strings are instances of `java.lang.String`. Double-quoted strings are “interpolated”
    strings, known (unfortunately) as `GString`s. I’ll show an example of string interpolation
    later in this program.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对应的值都由单引号包围。在 Groovy 中，单引号字符串是 `java.lang.String` 的实例。双引号字符串是“插值”字符串，不幸的是被称为
    `GString`s。我将在本程序稍后展示一个字符串插值的例子。
- en: To transform the map into a query string I first need to convert each of the
    map entries into strings of the form “key=value,” and then I need to concatenate
    them all together using ampersands as separators.^([[2](#ch02fn02)]) The first
    step is accomplished by using a special method added to all Groovy collections,
    known as `collect`. The `collect` method takes a closure as an argument, applies
    the closure to each element of the collection, and returns a new collection containing
    the results.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要将映射转换为查询字符串，我首先需要将映射中的每个条目转换为“key=value”形式的字符串，然后使用带符号的`&`作为分隔符将它们全部连接起来.^([[2](#ch02fn02)])
    第一步是通过使用添加到所有Groovy集合中的特殊方法完成的，称为`collect`。`collect`方法接受一个闭包作为参数，将闭包应用于集合的每个元素，并返回一个包含结果的新集合。
- en: ² I also need to URL-encode the map entries, but in this case they’re already
    fine. In other examples of RESTful web services I’ll demonstrate the encoding
    process.
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 我还需要对映射条目进行URL编码，但在这个例子中它们已经很好了。在其他RESTful Web服务的例子中，我将演示编码过程。
- en: Closures are introduced in the next sidebar and discussed extensively throughout
    the book, but for the moment think of them as blocks of code representing the
    body of a function, which may take dummy arguments. In the case of `collect`,
    when applied to a map, the closure can take either one or two arguments. If the
    closure takes one argument, the argument represents a `Map.Entry`; with two arguments,
    the first is the key and the second is the value for each entry.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包将在下一侧边栏中介绍，并在整本书中广泛讨论，但在此刻，请将它们视为代表函数主体的代码块，可能包含占位符参数。在`collect`的情况下，当应用于映射时，闭包可以接受一个或两个参数。如果闭包接受一个参数，则该参数表示`Map.Entry`；如果有两个参数，则第一个是每个条目的键，第二个是值。
- en: 'To transform the map into a list of `key=value` pairs, the following two-argument
    closure works in the `collect` method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要将映射转换为`key=value`对的列表，以下两个参数的闭包在`collect`方法中工作：
- en: '[PRE9]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Groovy, if the last argument to any method is a closure you can put the closure
    outside the parentheses. In this case the only argument to collect is a closure,
    so even the optional parentheses are omitted.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在Groovy中，如果任何方法的最后一个参数是闭包，你可以将闭包放在括号外面。在这种情况下，`collect`的唯一参数是闭包，因此甚至省略了可选的括号。
- en: '|  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What is a closure**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是闭包**'
- en: A closure is a block of code, delimited by curly braces, which can be treated
    as an object. The arrow notation is used to specify dummy arguments. In the closure
    applied to the map in the current example, the two dummy arguments are `k` and
    `v`, which represent the key and value of each entry. The expression on the right
    side of the arrow says to substitute each key and value into a `GString` separated
    by an equals sign. This `collect` method takes each entry in the map and converts
    it into a string with the key assigned to the value, and produces a list of results.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是一段代码块，由花括号分隔，可以被视为一个对象。箭头符号用于指定占位符参数。在当前示例中应用于映射的闭包中，两个占位符参数是`k`和`v`，分别代表每个条目的键和值。箭头右侧的表达式表示用等号将每个键和值替换到`GString`中。这个`collect`方法将映射中的每个条目转换为将键分配给值的字符串，并生成一个结果列表。
- en: '|  |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The result of the operation is shown here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的结果如下所示：
- en: '[PRE10]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This process is illustrated in [figure 2.2](#ch02fig02).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程如图2.2所示。
- en: Figure 2.2\. Apply `collect` to a map to convert it into a list, where each
    entry is transformed into a string.
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2\. 将`collect`应用于映射以将其转换为列表，其中每个条目都转换为字符串。
- en: '![](02fig02.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig02.jpg)'
- en: 'To create the query string, use another method added by Groovy to collections,
    called `join`. The `join` method takes a single argument that’s used as the separator
    when assembling the elements into a string. To create a query string, invoke `join`
    with an ampersand as an argument:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建查询字符串，请使用Groovy为集合添加的另一种方法，称为`join`。`join`方法接受一个参数，用作将元素组装成字符串时的分隔符。要创建查询字符串，请使用带符号的`&`作为参数调用`join`方法：
- en: '[PRE11]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result is the needed query string, as shown here:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是所需的查询字符串，如下所示：
- en: '[PRE12]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here’s the entire process so far, taking the base URL and the parameter map,
    and building the Google Chart URL:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，整个过程如下，从基本URL和参数映射开始，构建Google Chart URL：
- en: '[PRE13]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result of all this manipulation is actually a string, not a URL. Before
    converting it to a URL, let me first verify that the process worked. Normally
    this would require a test, as discussed extensively in [chapter 6](kindle_split_017.html#ch06)
    on testing. Here, however, I’ll just use the Groovy `assert` keyword, which takes
    a boolean expression as an argument. If the expression is true, nothing is returned,
    but if not, you get the error printed to the console. In this case I’ll use the
    `contains` method from the `Map` interface to check that each of the entries from
    the `params` map appears in the query string in the proper format:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作的结果实际上是一个字符串，而不是 URL。在将其转换为 URL 之前，让我首先验证这个过程是否成功。通常这需要测试，正如在第 6 章[测试](kindle_split_017.html#ch06)中广泛讨论的那样。然而，在这里，我将使用
    Groovy 的 `assert` 关键字，它接受一个布尔表达式作为参数。如果表达式为真，则不返回任何内容，如果不为真，则错误信息将打印到控制台。在这种情况下，我将使用
    `Map` 接口的 `contains` 方法来检查 `params` 映射中的每个条目是否以正确的格式出现在查询字符串中：
- en: '[PRE14]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|  |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The assert keyword
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 断言关键字
- en: Groovy asserts are an easy way to verify correctness. An assert returns nothing
    if the expression is true, and prints a detailed error message if it’s not.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 断言是一种验证正确性的简单方法。如果表达式为真，则断言返回无内容，如果不为真，则打印详细的错误消息。
- en: '|  |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: One of the advantages of the `join` method is that you don’t have to worry about
    accidentally adding an ampersand at the beginning or end of the string. It only
    adds the separator internally.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`join` 方法的优点之一是您不必担心在字符串的开始或结尾不小心添加一个 & 符号。它只在内部添加分隔符。'
- en: Note also that this is a case where the parentheses (on the `join` method) are
    needed. In Groovy, if you leave off the parentheses when calling a method with
    no arguments the compiler assumes you are asking for the corresponding getter
    or setter method. Because I want the `join()` method (and not `getJoin()`, which
    doesn’t exist), I need the parentheses.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这也是一个需要括号（在 `join` 方法上）的情况。在 Groovy 中，如果您在调用无参数的方法时省略括号，编译器会假设您正在请求相应的 getter
    或 setter 方法。因为我想要 `join()` 方法（而不是不存在的 `getJoin()`），所以我需要括号。
- en: 2.2.2\. Transmitting the URL
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2\. 传输 URL
- en: The Groovy JDK adds the `toURL()` method to the `String` class. As you might
    imagine, this method converts an instance of `java.lang.String` into an instance
    of `java.net.URL`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy JDK 向 `String` 类添加了 `toURL()` 方法。正如您所想象的，此方法将 `java.lang.String` 实例转换为
    `java.net.URL` 实例。
- en: '|  |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The Groovy JDK**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**Groovy JDK**'
- en: Groovy adds many helpful methods to existing Java library classes. Many, many
    times I’ve found methods added to, say, `String`, `Date`, or `Collection` that
    I always wished were in Java all along. The set of methods added by Groovy is
    known as the Groovy JDK and has its own set of JavaDocs. The Groovy JDK documentation
    is available via a link from the Groovy home page.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 向现有的 Java 库类添加了许多有用的方法。我多次发现添加到 `String`、`Date` 或 `Collection` 等类的方法，我一直希望这些方法在
    Java 中就有。Groovy 添加的方法集合被称为 Groovy JDK，并有自己的 JavaDocs 集合。Groovy JDK 文档可通过 Groovy
    主页上的链接获取。
- en: The Groovy JDK is discussed in more detail in [chapter 3](kindle_split_013.html#ch03).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy JDK 的详细讨论可以在[第 3 章](kindle_split_013.html#ch03)中找到。
- en: '|  |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To send an HTTP GET request to a URL and retrieve the results, convert the
    string to a URL and invoke another Groovy JDK method, the `getText()` method,
    added to `java.net.URL`. In other words, the data on a web page can be retrieved
    from this code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 URL 发送 HTTP GET 请求并检索结果，将字符串转换为 URL 并调用添加到 `java.net.URL` 的另一个 Groovy JDK
    方法，即 `getText()` 方法。换句话说，网页上的数据可以通过以下代码检索：
- en: '[PRE15]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here I’m deliberately using the `text` property of the URL class, knowing that
    the effect will be to invoke the `getText()` `method`. There’s nothing wrong with
    actually calling `getText`, but this is more idiomatic Groovy.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我故意使用 URL 类的 `text` 属性，知道这将调用 `getText()` 方法。实际上调用 `getText` 没有问题，但这更符合
    Groovy 的习惯。
- en: Normally this would be exactly the code I want, and I use this technique in
    some of the examples in the chapters on web services, but in this particular case
    the result isn’t text. Google Chart takes the URL generated here and returns a
    binary image, so converting it to text isn’t very helpful.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这将是我想写的代码，我在关于 Web 服务的章节中的一些示例中使用了这种技术，但在这个特定的情况下，结果不是文本。Google 图表将这里生成的 URL
    转换为二进制图像，因此将其转换为文本并不很有帮助。
- en: '|  |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Groovy Properties
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Groovy 属性
- en: Accessing properties in Groovy automatically invokes the associated getter or
    setter method.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Groovy 中访问属性会自动调用相关的 getter 或 setter 方法。
- en: '|  |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Next I’ll build a Swing user interface that includes the image in a `javax.swing`
    `.ImageIcon`. This will give me a chance to illustrate a builder, which is a great
    illustration of Groovy metaprogramming.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将构建一个包含 `javax.swing` `.ImageIcon` 中的图像的 Swing 用户界面。这将给我一个机会来展示构建器，这是 Groovy
    元编程的一个很好的示例。
- en: 2.2.3\. Creating a UI with SwingBuilder
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3\. 使用 SwingBuilder 创建 UI
- en: In Groovy every class has a metaclass. A metaclass is another class that manages
    the actual invocation process. If you invoke a method on a class that doesn’t
    exist, the call is ultimately intercepted by a method in the metaclass called
    `methodMissing`. Likewise, accessing a property that doesn’t exist eventually
    calls `propertyMissing` in the metaclass. Customizing the behavior of `methodMissing`
    and `propertyMissing` is the heart of Groovy runtime metaprogramming.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Groovy 中，每个类都有一个元类。元类是另一个管理实际调用过程的类。如果你对一个不存在的方法调用类，调用最终会被元类中的 `methodMissing`
    方法拦截。同样，访问一个不存在的属性最终会在元类中调用 `propertyMissing`。自定义 `methodMissing` 和 `propertyMissing`
    的行为是 Groovy 运行时元编程的核心。
- en: 'Groovy metaprogramming is a large subject, but here I’ll demonstrate one of
    its helpful results: the creation of builder classes. In a builder, the call to
    `methodMissing` does something specific for that type of builder.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 元编程是一个庞大的主题，但在这里我将演示其一个有用的结果：构建器类的创建。在构建器中，对 `methodMissing` 的调用为该类型的构建器执行特定操作。
- en: Here I’ll illustrate a Swing builder. This is a class that intercepts names
    of components and constructs a Swing user interface out of the results. This is
    actually easier to demonstrate than to explain. I’ll start, however, by adding
    some imports to the Google Chart script I’ve been constructing so far:^([[3](#ch02fn03)])
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我将展示一个 Swing 构建器。这是一个拦截组件名称的类，并从结果中构建 Swing 用户界面。这实际上比解释更容易展示。但是，我首先将向迄今为止构建的
    Google Chart 脚本中添加一些导入：^([[3](#ch02fn03)])
- en: ³ That’s another one of the “Duh! Why didn’t we do that all along?” type of
    revelations that Java developers get all the time when they first learn Groovy.
    Why is it we only import `java.lang` in Java programs? Why not import lots of
    typical packages? Wouldn’t that make coding easier? Groovy says yes.
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 这又是 Java 开发者在第一次学习 Groovy 时经常得到的“哦！我们为什么一直没这么做？”类型的启示之一。为什么 Java 程序中我们只导入
    `java.lang`？为什么不导入许多典型的包？这不会让编码更容易吗？Groovy 说可以。
- en: '[PRE16]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Automatic imports**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动导入**'
- en: You may have noticed that I haven’t yet needed any import statements at all.
    Java automatically imports the `java.lang` package. Groovy imports `java.lang`,
    as well as `java.util`, `java.io`, `java.net`, `groovy.lang`, `groovy.util`, `java.math.Big-Integer`,
    and `java.math.BigDecimal`.³
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我还没有需要任何导入语句。Java 自动导入 `java.lang` 包。Groovy 导入 `java.lang`，以及 `java.util`、`java.io`、`java.net`、`groovy.lang`、`groovy.util`、`java.math.BigInteger`
    和 `java.math.BigDecimal`。³
- en: '|  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this script I’m importing three classes from the Java standard library. The
    first two imports use the `as` operator to build an alias for the respective classes.
    That way the code that uses `BorderLayout` and `WindowConstants` can just write
    `BL` or `WC` instead. I’m also adding in the `ImageIcon` class, which will hold
    the image returned by Google Chart. The import from the Groovy library is `SwingBuilder`,
    which will be used to construct the Swing UI.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我正在从 Java 标准库导入三个类。前两个导入使用 `as` 操作符为相应的类构建别名。这样，使用 `BorderLayout` 和 `WindowConstants`
    的代码就可以直接写 `BL` 或 `WC`。我还添加了 `ImageIcon` 类，它将保存 Google Chart 返回的图像。从 Groovy 库导入的是
    `SwingBuilder`，它将被用来构建 Swing UI。
- en: '|  |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The as keyword
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`as` 关键字'
- en: The `as` keyword has several uses, one of which is to provide an alias for imported
    classes. The `as` keyword corresponds to the `asType` method, which was added
    to `java.lang.Object` as part of the Groovy JDK.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`as` 关键字有几个用途，其中之一是为导入的类提供别名。`as` 关键字对应于添加到 Groovy JDK 中的 `java.lang.Object`
    的 `asType` 方法。'
- en: '|  |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the case of `SwingBuilder` you invoke methods that don’t exist on the builder
    but that are translated to the corresponding Swing API. For example, by calling
    the `frame` method you’re actually instantiating the `JFrame` class. Giving it
    a map-like argument of `visible:true` corresponds to calling the `setVisible`
    method with a `true` argument.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SwingBuilder` 的情况下，你调用构建器上不存在的方法，但这些方法会被转换成相应的 Swing API。例如，通过调用 `frame`
    方法，你实际上是在实例化 `JFrame` 类。传递一个类似映射的参数 `visible:true` 相当于调用 `setVisible` 方法并传递一个
    `true` 参数。
- en: 'Here’s the code that uses the builder. Each method not in `SwingBuilder` is
    translated to the proper method call on the Swing library class:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用构建器的代码。不在`SwingBuilder`中的每个方法都被翻译为对Swing库类的适当方法调用：
- en: '[PRE17]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `edt` method on `SwingBuilder` builds a GUI using the event dispatch thread.
    It takes a closure as an argument, and this is where the fun starts. The first
    statement inside the closure is a call to the `frame` method, but the fact is,
    there’s no frame method in `SwingBuilder`. The builder’s metaclass intercepts
    that call (via `methodMissing`) and interprets it as a request to instantiate
    the `javax.swing.JFrame` class. The `frame` method here lists a series of map
    entries, which are intended to supply values for the title, visibility, and close
    operation on the `JFrame`. The builder interprets them as calls to `setTitle`,
    `setVisible`, and `setDefaultCloseOperation` on the `JFrame` instance.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwingBuilder`上的`edt`方法使用事件调度线程构建GUI。它接受一个闭包作为参数，从这里开始有趣的部分。闭包内的第一条语句是对`frame`方法的调用，但事实上，`SwingBuilder`中没有`frame`方法。构建器的元类拦截了这个调用（通过`methodMissing`），并将其解释为实例化`javax.swing.JFrame`类的请求。这里的`frame`方法列出了一系列映射条目，这些条目旨在为`JFrame`的标题、可见性和关闭操作提供值。构建器将它们解释为对`JFrame`实例的`setTitle`、`setVisible`和`setDefaultCloseOperation`的调用。'
- en: After the parentheses there’s another closure. That’s interpreted to mean I’m
    about to supply components that will be added to the `JFrame` instance. The next
    call is to the `label` method, which of course doesn’t exist. The Swing builder
    knows to generate a `JLabel` instance as a result, call its `setIcon` method with
    a new `ImageIcon` holding the image returned by Google Chart, and place the `JLabel`
    in the center of a `BorderLayout`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号之后还有一个闭包。这表示我即将提供将被添加到`JFrame`实例中的组件。下一个调用是对`label`方法的调用，当然这个方法不存在。Swing构建器知道要生成一个`JLabel`实例，用包含Google图表返回的图像的新`ImageIcon`调用其`setIcon`方法，并将`JLabel`放置在`BorderLayout`的中心。
- en: Finally, after the frame closure I invoke the `pack` method on `JFrame` to make
    the resulting GUI just big enough to hold the image. The next listing contains
    the complete script (without the asserts, just to keep the listing short).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`frame`闭包之后，我调用`JFrame`上的`pack`方法，使生成的GUI刚好足够容纳图像。下一个列表包含完整的脚本（没有断言，以保持列表简短）。
- en: Listing 2.1\. Building a Swing UI 3D pie chart using Google Chart
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.1\. 使用Google图表构建Swing UI 3D饼图
- en: '[PRE18]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The resulting image is shown in [figure 2.3](#ch02fig03).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图像显示在[图2.3](#ch02fig03)中。
- en: Figure 2.3\. The “Hello, World” Swing user interface, holding the image returned
    by Google Chart
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3\. “Hello, World” Swing用户界面，包含由Google图表返回的图像
- en: '![](02fig03.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig03.jpg)'
- en: '|  |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Lessons Learned (Google Chart)**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**经验教训（Google图表）**'
- en: Groovy variables can have types, or you can use the `def` keyword if you don’t
    know or don’t care. The keyword `def` can also be used as a method return type
    or argument.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovy变量可以有类型，或者如果你不知道或者不在乎，可以使用`def`关键字。关键字`def`也可以用作方法返回类型或参数。
- en: Groovy has native syntax for lists and maps. This example used a Groovy map;
    lists are used in many other examples throughout the book.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovy具有列表和映射的本地语法。这个例子使用了Groovy映射；列表在本书的其他许多例子中也被使用。
- en: Closures are like anonymous function bodies with parameters.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 闭包类似于带有参数的匿名函数体。
- en: The `collect` method transforms a collection by applying a closure to each element
    and returning the resulting list.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`collect`方法通过将闭包应用于每个元素并返回结果列表来转换集合。'
- en: The Groovy JDK adds many methods to the standard Java API.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovy JDK向标准Java API添加了许多方法。
- en: Groovy parsers and builders simplify working with many APIs.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovy解析器和构建器简化了与许多API的工作。
- en: '|  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The next example demonstrates Groovy’s XML parsing and generation capabilities,
    database manipulation, regular expressions, groovlets, and more.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了Groovy的XML解析和生成能力、数据库操作、正则表达式、groovlets等。
- en: 2.3\. Groovy Baseball
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3\. Groovy棒球
- en: '[Figure 2.4](#ch02fig04) shows a web application I call Groovy Baseball. For
    a given date during baseball season the page creates a Google Map that displays
    the results of all Major League Baseball games on that day, using info markers
    centered on the stadium of the home team. Game results are also listed in a small
    table. A calendar widget is provided so the user can select an alternative date,
    which updates the page via an Ajax call.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.4](#ch02fig04)显示了我在其中创建的Web应用程序，我称之为Groovy棒球。在棒球赛季的特定日期，该页面创建一个Google地图，显示当天所有大联盟棒球比赛的比分，使用以主场为中心的信息标记。比赛结果也列在一个小表中。提供了一个日历小部件，用户可以通过Ajax调用选择不同的日期，从而更新页面。'
- en: Figure 2.4\. Groovy Baseball is a web application that shows the results of
    MLB games on a given date.
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4\. Groovy棒球是一个显示特定日期MLB比赛结果的Web应用程序。
- en: '![](02fig04_alt.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig04_alt.jpg)'
- en: Some of the functionality is provided by JavaScript via the Google Maps API,
    which creates the map and adds the markers. Also, the set of game results for
    a given day is acquired via an Ajax call using the prototype JavaScript library.
    I’ll show the code for that later. In the meantime I want to highlight the Groovy
    parts of this application.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 部分功能由JavaScript通过Google Maps API提供，该API创建地图并添加标记。对于给定日期的比赛结果集，通过使用原型JavaScript库的Ajax调用获取。稍后我将展示该代码。同时，我想强调这个应用程序的Groovy部分。
- en: The application is simple but it has a fair number of moving parts, so I’ll
    build it in stages. The first task is to collect the geographic information for
    the individual MLB stadiums and save it in a database, as illustrated in [figure
    2.5](#ch02fig05).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序简单，但它有相当多的动态部分，所以我将分阶段构建它。第一个任务是收集个别MLB球场的地理信息，并将其保存到数据库中，如图2.5所示。
- en: Figure 2.5\. Building Groovy Baseball, [part 1](kindle_split_010.html#part01)—geocoding
    stadium data and saving in DB
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.5\. 构建Groovy棒球，[第一部分](kindle_split_010.html#part01)—地理编码球场数据并将其保存到数据库中
- en: '![](02fig05_alt.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig05_alt.jpg)'
- en: In this part of the process, I’ll cover
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程的这部分，我将涵盖
- en: Plain Old Groovy Objects
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的Groovy对象
- en: Accessing a RESTful web service
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问RESTful Web服务
- en: The `groovy.sql.Sql` class
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groovy.sql.Sql`类'
- en: The next step is to access the online box scores and parse the resulting XML
    files, illustrated in [figure 2.6](#ch02fig06).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是访问在线比分板并解析生成的XML文件，如图2.6所示。
- en: Figure 2.6\. Building Groovy Baseball, [part 2](kindle_split_015.html#part02)—extracting
    box score data and creating output POGOs
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.6\. 构建Groovy棒球，[第二部分](kindle_split_015.html#part02)—提取比分数据并创建输出POGOs
- en: '![](02fig06_alt.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig06_alt.jpg)'
- en: During this stage, I’ll discuss
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我将讨论
- en: Reading from a database
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中读取
- en: Downloading information over the internet
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在互联网上下载信息
- en: Parsing XML
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析XML
- en: Finally, I need to send the resulting data to the view layer in a form it can
    understand, as shown in [figure 2.7](#ch02fig07).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我需要将结果数据以视图层能理解的形式发送，如图2.7所示。[figure 2.7](#ch02fig07)。
- en: Figure 2.7\. Building Groovy Baseball, [part 3](kindle_split_018.html#part03)—drive
    system and generate XML
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.7\. 构建Groovy棒球，[第三部分](kindle_split_018.html#part03)—驱动系统并生成XML
- en: '![](02fig07_alt.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig07_alt.jpg)'
- en: During this stage, I’ll cover
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我将涵盖
- en: Using a groovlet
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用groovlet
- en: Generating XML
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成XML
- en: I’ll begin the process with [part 1](kindle_split_010.html#part01), creating
    POGOs and saving data in a database.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从[第一部分](kindle_split_010.html#part01)开始这个过程，创建POGO并将数据保存到数据库中。
- en: 2.3.1\. Database data and Plain Old Groovy Objects
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1\. 数据库数据和简单的Groovy对象
- en: The game results on the web page are centered on the home stadiums of each game.
    Google Maps places markers based on the latitude and longitude of a given location.
    Because stadiums don’t tend to move much, it’s worth it to compute those locations
    ahead of time and save them in some kind of persistence structure. In this case
    I used a MySQL database, but any database would do.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 网页上的比赛结果集中在每场比赛的主场。Google Maps根据给定位置的纬度和经度放置标记。因为球场不太可能移动，所以提前计算这些位置并将它们保存在某种持久化结构中是值得的。在这种情况下，我使用了MySQL数据库，但任何数据库都适用。
- en: I’ll build a script here to collect the necessary info for each MLB stadium,
    compute its latitude and longitude, and store them in a database table. I’ll start
    with a class to represent a stadium.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里构建一个脚本来收集每个MLB球场的必要信息，计算其纬度和经度，并将它们存储在数据库表中。我将从一个表示球场的类开始。
- en: The Stadium POGO
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 体育场POGO
- en: In Java we would call this class a Plain Old Java Object, or POJO. In Groovy
    I’ll use a Plain Old Groovy Object, or POGO, instead. The following listing shows
    the `Stadium` class.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，我们会称这个类为普通 Java 对象，简称 POJO。在 Groovy 中，我会使用普通 Groovy 对象，简称 POGO。下面的列表展示了
    `Stadium` 类。
- en: 'Listing 2.2\. `Stadium.groovy`: a POGO to hold stadium information'
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. `Stadium.groovy`：一个用于存储球场信息的 POGO
- en: '[PRE19]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you’re used to Java, what’s conspicuous here is what’s absent. The lack of
    semicolons is probably not surprising at this point. What may be a surprise is
    that there are no public or private access modifiers anywhere. In Groovy, if you
    don’t specify an access modifier, attributes are assumed to be private, and methods
    are assumed to be public.^([[4](#ch02fn04)])
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了 Java，这里引人注目的是缺少了什么。分号的存在可能在这个时候并不令人惊讶。可能令人惊讶的是，任何地方都没有公共或私有访问修饰符。在 Groovy
    中，如果你没有指定访问修饰符，属性将被假定为私有的，方法将被假定为公共的.^([[4](#ch02fn04)])
- en: ⁴ That’s another “duh” moment. The default access in Java is “package private,”
    which means the member is accessible from any other class in the same subdirectory.
    In roughly 15 years of Java coding I’ve used this access deliberately maybe twice,
    and both times there were reasonable alternatives. I can understand trying to
    create some sort of friend access, but why make it the default? Once again, Groovy
    does what makes sense.
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 这又是一个“duh”时刻。Java 中的默认访问是“包私有”，这意味着成员可以从同一子目录中的任何其他类访问。在大概 15 年的 Java 编码中，我可能故意使用过这种访问方式两次，而且两次都有合理的替代方案。我可以理解尝试创建某种友元访问，但为什么将其作为默认值？再次强调，Groovy
    做的是有意义的。
- en: You might also note that there are no constructors in the `Stadium` class. In
    Java, if you don’t add a constructor, the compiler gives you a default constructor
    for free. In Groovy, however, you get not only the default, but also a map-based
    constructor that allows you to set any combination of attribute values by supplying
    them as key-value pairs.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到，`Stadium` 类中没有构造函数。在 Java 中，如果你没有添加构造函数，编译器会免费为你提供一个默认构造函数。然而，在 Groovy
    中，你不仅得到默认的构造函数，还有一个基于映射的构造函数，允许你通过提供键值对来设置任何组合的属性值。
- en: 'With this in mind, here’s the first part of the script to populate a database
    table with the `Stadium` locations:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，以下是用于将 `Stadium` 位置填充到数据库表中的脚本的第一部分：
- en: '[PRE20]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `stadiums` variable is initialized to an empty `java.util.ArrayList`. The
    left-shift operator has been implemented in `Collection` to be an append method,
    so the rest of the listing instantiates each of the MLB stadiums and appends it
    to the list.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`stadiums` 变量被初始化为一个空的 `java.util.ArrayList`。左移运算符在 `Collection` 中被实现为一个追加方法，所以列表中的其余部分实例化了每个
    MLB 球场并将其追加到列表中。'
- en: Each constructor sets the `name` of the stadium, as well as its `city`, `state`,
    and the three-letter `team` abbreviation. What are missing are the `latitude`
    and `longitude` values. To supply those I use the Google geocoder, which is another
    RESTful web service provided by Google, similar to the Google Chart API discussed
    in the previous section.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 每个构造函数都会设置球场的 `name`、`city`、`state` 以及三个字母的 `team` 简称。缺少的是 `latitude` 和 `longitude`
    值。为了提供这些值，我使用了 Google 地理编码器，这是 Google 提供的另一个 RESTful 网络服务，类似于前一部分讨论的 Google 图表
    API。
- en: '|  |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: POGO
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: POGO
- en: Plain Old Groovy Objects are like POJOs, but with auto-generated getters, setters,
    and map-based constructors.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 普通 Groovy 对象类似于 POJO，但具有自动生成的获取器、设置器和基于映射的构造函数。
- en: '|  |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Geocoding
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 地理编码
- en: The Google Geocoding API is documented at [https://developers.google.com/maps/documentation/geocoding/](https://developers.google.com/maps/documentation/geocoding/).
    A geocoder transforms an address into a latitude and longitude. To use the Google
    geocoder you need to assemble a URL that includes the address information. According
    to the documentation, the URL has the form
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Google 地理编码 API 的文档位于 [https://developers.google.com/maps/documentation/geocoding/](https://developers.google.com/maps/documentation/geocoding/)。地理编码器将地址转换为纬度和经度。要使用
    Google 地理编码器，你需要组装一个包含地址信息的 URL。根据文档，URL 的格式如下
- en: '[PRE21]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here the value of `output` is either `xml` or `json`, depending on which type
    of data you want back.^([[5](#ch02fn05)]) The `parameters` property contains the
    address, as well as a `sensor` value. Here’s the sample from the documentation,
    which (naturally enough) uses the address of Google’s headquarters in Mountain
    View, CA:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `output` 的值是 `xml` 或 `json`，取决于你想要返回哪种类型的数据.^([[5](#ch02fn05)]) `parameters`
    属性包含地址以及一个 `sensor` 值。以下是文档中的示例，它自然地使用了加利福尼亚州山景城 Google 总部地址：
- en: ⁵ True REST advocates prefer that content negotiation be done in an `Accept`
    header on the HTTP request. Here Google does it through separate URIs.
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 真正的REST倡导者更倾向于在HTTP请求的`Accept`头中进行内容协商。在这里，谷歌通过单独的URI来实现这一点。
- en: '[PRE22]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you intend to access the geocoder using JavaScript, I would say to use `json`
    (JavaScript Object Notation) for the output value. Because I’m working with Groovy,
    and Groovy works well with XML, I’ll use the `xml` value. The query string contains
    two parameters. The first is the address, which holds URL-encoded values of the
    street, city, and state (separated by `“,”)`. The other parameter is called `sensor`,
    whose value is true if the request is coming from a GPS-enabled device and false
    otherwise.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用JavaScript访问地理编码器，我会建议使用`json`（JavaScript对象表示法）作为输出值。因为我使用Groovy，并且Groovy与XML配合得很好，所以我将使用`xml`值。查询字符串包含两个参数。第一个是地址，它包含街道、城市和州的URL编码值（用`“,”`分隔）。另一个参数称为`sensor`，如果请求来自具有GPS功能的设备，则其值为true，否则为false。
- en: 'I’ll start the geocoding process by setting a variable to the base URL:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过设置一个变量到基本URL来开始地理编码过程：
- en: '[PRE23]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To assemble the query string, consider a list containing the stadium name,
    city, and state:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要组装查询字符串，考虑一个包含体育场名称、城市和州的列表：
- en: '[PRE24]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Each of these values could potentially include spaces, apostrophes, or other
    symbols that wouldn’t be legal in a URL. I therefore need to URL-encode each of
    the values. As I showed in the last section, applying the `collect` method to
    a list returns a new list containing the transformed values. In this case, the
    transformation I want is to use the `encode` method in the `java.net.URLEncoder`,
    as shown:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值中任何一个都可能包含空格、撇号或其他在URL中不合法的符号。因此，我需要将每个值进行URL编码。正如我在上一节中所示，将`collect`方法应用于列表返回一个包含转换后值的新列表。在这种情况下，我想要的转换是使用`java.net.URLEncoder`中的`encode`方法，如下所示：
- en: '[PRE25]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you use a closure without specifying a dummy parameter, as here, each element
    of the list is assigned to a variable called `it.` The body of the closure executes
    the static `encode` method on the name, city, and state, using the UTF-8 encoding
    scheme. The result is a list containing the encoded values. Finally, the values
    of the list are joined into a string using “`,`” as a separator.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这里没有指定占位符参数的闭包，每个列表元素将被分配给一个名为`it`的变量。闭包的主体使用UTF-8编码方案在名称、城市和州上执行静态`encode`方法。结果是包含编码值的列表。最后，使用“`,`”作为分隔符将列表的值连接成一个字符串。
- en: 'That takes care of assembling the address. Forming a complete query string
    is done using the same closure used in the Google Chart listing. The complete
    process so far is shown here:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了地址的组装。使用与谷歌图表列表中相同的闭包来形成完整的查询字符串。到目前为止的完整过程如下所示：
- en: '[PRE26]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|  |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Building a query string**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建查询字符串**'
- en: The combination of parameter map, `collect` closure, and `join` method is a
    convenient way to build a query string. A developer can store the parameters in
    any order, or accept them from the user (as in a Grails application), and turn
    them into a query string with a minimum of effort.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 参数映射、`collect`闭包和`join`方法的组合是构建查询字符串的一种方便方式。开发者可以以任何顺序存储参数，或者从用户那里接受它们（如在Grails应用程序中），并以最小的努力将它们转换为查询字符串。
- en: '|  |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The result of all this string manipulation is to create a full URL, similar
    to the one shown in the previous example, which can be transmitted to the Google
    geocoder.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些字符串操作的结果是创建一个完整的URL，类似于前一个示例中显示的URL，它可以被传输到谷歌地理编码器。
- en: 'Now comes the fun part. The geocoder returns a fairly extensive block of XML
    (not shown here, but available online in the Google geocoder documentation at
    [https://developers.google.com/maps/documentation/geocoding/#XML](https://developers.google.com/maps/documentation/geocoding/#XML)).
    Processing the XML using Java would be quite verbose. Fortunately, XML is nothing
    to Groovy. The entire process of transmitting the URL to the Google geocoder and
    parsing the result into a DOM tree takes one line:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进行有趣的部分了。地理编码器返回一个相当大的XML块（此处未显示，但可在谷歌地理编码器文档的[https://developers.google.com/maps/documentation/geocoding/#XML](https://developers.google.com/maps/documentation/geocoding/#XML)在线找到）。使用Java处理XML将会非常冗长。幸运的是，对于Groovy来说，XML不是什么大问题。将URL传输到谷歌地理编码器并将结果解析为DOM树的过程只需要一行代码：
- en: '[PRE27]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Groovy has two classes for parsing XML. One is called `XmlParser`, and the
    other is `XmlSlurper`. Both convert XML into a DOM tree. The underlying structure
    and process are somewhat different, but from a practical point of view the slurper
    is more efficient and takes less memory, so that’s what I’ll use here. Extracting
    the results I need is a simple matter of walking the tree. I could paste in a
    copy of the XML output to show you the structure, but it’s easy enough to understand
    if you see the Groovy parsing code:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 有两个用于解析 XML 的类。一个是 `XmlParser`，另一个是 `XmlSlurper`。两者都将 XML 转换为 DOM 树。底层结构和过程有些不同，但从实际角度来看，slurper
    更高效且占用更少的内存，所以我将在这里使用它。提取所需的结果只是简单地遍历树。我可以粘贴一个 XML 输出的副本来显示结构，但如果你看到 Groovy 解析代码，这很容易理解：
- en: '[PRE28]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ⁶ Try *that* in Java. Nothing sells Groovy to Java developers like working with
    XML.
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ 在 Java 中试试 *那个*。没有什么能像与 XML 一起工作那样让 Java 开发者喜欢 Groovy。
- en: In other words, the slurper returns the root of the DOM tree, which is assigned
    to a variable called `response`. The root has a child element called `result`,
    which has a child called `geometry`, which has a child called `location`, which
    then has two children, one called `lat` and the other called `lng`. Sometimes
    the geocoder returns multiple results, so I used the array index 0 on `result`
    to use only the first one. Because everything in XML is a `String` and I want
    to assign the results to double values in `Sta``dium`, I finally use the `toDouble`
    method added to `String` to do the conversion.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，slurper 返回 DOM 树的根，并将其分配给一个名为 `response` 的变量。根有一个名为 `result` 的子元素，它有一个名为
    `geometry` 的子元素，它有一个名为 `location` 的子元素，然后它有两个子元素，一个名为 `lat`，另一个名为 `lng`。有时地理编码器会返回多个结果，所以我使用了
    `result` 的数组索引 0 来只使用第一个。因为 XML 中的所有内容都是 `String`，而我想要将结果分配给 `Stadium` 中的双精度值，所以我最终使用添加到
    `String` 的 `toDouble` 方法来进行转换。
- en: '|  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Parsing XML
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解析 XML
- en: Whether you use an `XmlParser` or an `XmlSlurper`, extracting data from XML
    means just walking the tree.^([[7](#ch02fn07)])
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用 `XmlParser` 还是 `XmlSlurper`，从 XML 中提取数据只是遍历树。[^7](#ch02fn07)]
- en: ⁷ Parsing (actually, slurping) JSON is just as easy. The book source code for
    [chapter 2](#ch02) includes another example that accesses and parses JSON data.
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷ 解析（实际上是slurping）JSON同样简单。本书源代码的 [第 2 章](#ch02) 包含另一个示例，该示例访问并解析 JSON 数据。
- en: '|  |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The following listing shows the complete `Geocoder` class, with its method `fillInLatLng`
    that takes a `Stadium` as an argument and fills in the latitude and longitude
    values.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了完整的 `Geocoder` 类，其中包含其 `fillInLatLng` 方法，该方法接受一个 `Stadium` 参数并填充纬度和经度值。
- en: Listing 2.3\. `Geocoder.groovy`, which uses the Google geocoder to compute lat
    and lng
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.3\. `Geocoder.groovy`，它使用 Google 地理编码器计算纬度和经度
- en: '[PRE29]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The groovy.sql.Sql class
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`groovy.sql.Sql` 类'
- en: 'Returning to the original problem, I want to store the stadium information
    in a database. I’m now going to take advantage of a very useful class in the Groovy
    library, `groovy.sql.Sql`. This class connects to a database and allows you to
    execute SQL against it. To begin the process, here’s how the `Sql` class is instantiated:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到原始问题，我想将体育场信息存储在数据库中。我现在将利用 Groovy 库中的一个非常有用的类，`groovy.sql.Sql`。这个类连接到数据库，并允许你对它执行
    SQL。为了开始这个过程，这是如何实例化 `Sql` 类的：
- en: '[PRE30]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `Sql` class has a static `newInstance` method, whose arguments are the
    JDBC URL, the username and password, and the driver class. The result is a connection
    to the database. Next, I drop the stadium table if it already exists:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sql` 类有一个静态的 `newInstance` 方法，其参数包括 JDBC URL、用户名和密码以及驱动类。结果是数据库的连接。接下来，如果
    stadium 表已经存在，我将删除它：'
- en: '[PRE31]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `execute` method takes a SQL string and runs it against the database. Here
    again, I’m taking advantage of the optional parentheses.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute` 方法接受一个 SQL 字符串并在数据库上运行它。在这里，我再次利用了可选的括号。'
- en: 'The next step is to create the table to hold the stadium information:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个用于存储体育场信息的表：
- en: '[PRE32]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The three single quotes represent a multiline string in Groovy. Three double
    quotes would be a multiline `GString`, which I could use for parameter substitution,
    but they’re not needed in this particular case.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 三个单引号代表 Groovy 中的多行字符串。三个双引号将是一个多行 `GString`，我可以用它来进行参数替换，但在这个特定情况下不需要。
- en: 'Now that the table has been constructed it’s time to populate the table with
    stadium data:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表已经构建好了，是时候用体育场数据填充表了：
- en: '[PRE33]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After instantiating the geocoder I walk through each stadium in the collection,
    assigning each to the dummy variable `s`. For each one, after computing the latitude
    and longitude, I execute an `insert` statement contained within three double quotes,
    where I substitute the values I need from the stadium using the standard `${...}`
    notation.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化地理编码器后，我遍历集合中的每个体育馆，将每个分配给虚拟变量 `s`。对于每一个，在计算纬度和经度之后，我执行一个包含在三个双引号内的 `insert`
    语句，其中使用标准的 `${...}` 符号替换从体育馆中需要的值。
- en: 'All that remains is to do some kind of sanity check to make sure that the values
    received are reasonable. Here are some `assert` statements to do just that:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是进行某种合理性检查，以确保接收到的值是合理的。以下是一些用于此目的的 `assert` 语句：
- en: '[PRE34]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first `assert` statement checks that the total number of rows in the table
    matches the number of stadiums in the collection. The next statement invokes the
    `eachRow` method on the connection, selecting just the latitude and longitude,
    and assigning the dummy variable `row` to each of the rows in the result set.
    The two contained `assert` statements verify that the latitudes are between 25
    and 48 and that the longitudes are between -123 and -71.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `assert` 语句检查表中的总行数是否与集合中的体育馆数量匹配。下一个语句在连接上调用 `eachRow` 方法，仅选择经纬度，并将虚拟变量
    `row` 分配给结果集中的每一行。两个包含的 `assert` 语句验证纬度在 25 到 48 之间，经度在 -123 到 -71 之间。
- en: '|  |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The Sql class
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Sql 类
- en: The `groovy.sql.Sql` class removes almost all the ceremony surrounding raw JDBC
    and adds convenience methods as well.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`groovy.sql.Sql` 类几乎消除了原始 JDBC 的所有仪式，并添加了便利的方法。'
- en: '|  |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The complete script is shown in the next listing.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本在下一部分列出。
- en: Listing 2.4\. `populate_stadium_data.groovy`
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.4\. `populate_stadium_data.groovy`
- en: '![](ch02ex04-0.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](ch02ex04-0.jpg)'
- en: '![](ch02ex04-1.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](ch02ex04-1.jpg)'
- en: This script collects all the latitude and longitude values for each MLB stadium,
    creates a database table to hold them, and populates the table. It only has to
    be run once, and the application can then use the table. In the process of reviewing
    the code I used a `Stadium` POGO, a list, a couple of `collect` methods with closures,
    an example that used the `URLEncoder` class from Java in a Groovy script, and
    database manipulation through the `groovy.sql.Sql` class.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本收集每个 MLB 体育馆的所有经纬度值，创建一个数据库表来存储它们，并填充该表。它只需运行一次，然后应用程序就可以使用该表。在审查代码的过程中，我使用了
    `Stadium` POGO、一个列表、几个带有闭包的 `collect` 方法、一个在 Groovy 脚本中使用 Java 的 `URLEncoder`
    类的示例，以及通过 `groovy.sql.Sql` 类进行数据库操作。
- en: The next step is to collect box score data from a site maintained by Major League
    Baseball, and generate XML information that can be sent to a view page.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从美国职业棒球大联盟维护的网站上收集比分数据，并生成可以发送到视图页面的 XML 信息。
- en: 2.3.2\. Parsing XML
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 解析 XML
- en: Major League Baseball continuously updates the results of baseball games online.
    The information is kept in XML format in links descending from [http://gd2.mlb.com/components/game/mlb/](http://gd2.mlb.com/components/game/mlb/).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 美国职业棒球大联盟持续在线更新棒球比赛的结果。信息以 XML 格式保存在从 [http://gd2.mlb.com/components/game/mlb/](http://gd2.mlb.com/components/game/mlb/)
    下降的链接中。
- en: On the site the games are arranged by date. Drilling down from the base URL
    requires links of the form `"year_${year}/month_${month}/day_${day}/"`*,* where
    the year is four digits, and the month and day are two digits each. The games
    for that date are listed as individual links. For example, [figure 2.8](#ch02fig08)
    shows links for each game played on May 5, 2007.^([[8](#ch02fn08)])
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在网站上，比赛按日期排列。从基本 URL 深入需要形式为 `"year_${year}/month_${month}/day_${day}/"` 的链接，其中年份是四位数字，月份和日期各为两位数字。该日期的比赛作为单独的链接列出。例如，[图
    2.8](#ch02fig08) 显示了 2007 年 5 月 5 日每场比赛的链接。[^([8](#ch02fn08))]
- en: ⁸ By an astonishing coincidence, May 5 is my son’s birthday.
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸ 令人惊讶的是，5 月 5 日也是我儿子的生日。
- en: Figure 2.8\. Links to baseball games played on May 5, 2007
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.8\. 2007 年 5 月 5 日举行的棒球比赛的链接
- en: '![](02fig08_alt.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig08_alt.jpg)'
- en: The link for each individual game has the form
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独比赛的链接形式为
- en: '[PRE35]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `year`, `month`, and `day` values are as expected. The values for `away`
    and `home` are three-letter lowercase abbreviations for each team, and the value
    of `num` represents the game number that day (1 for the first game, 2 for the
    second game of a double header). The links for each game contain a series of files,
    but the one I’m interested in is called boxscore.xml.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`year`、`month`和`day`的值符合预期。`away`和`home`的值是每个队伍的三字母小写缩写，`num`的值代表那天比赛的编号（第一场比赛为1，双头赛的第二场比赛为2）。每个比赛的链接包含一系列文件，但我感兴趣的是名为boxscore.xml的文件。'
- en: To retrieve the box score information I’ll create a class called `GetGameData`.
    This class will have attributes for the base URL and the team abbreviations, as
    shown. The next listing shows a portion of this class.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索得分板信息，我将创建一个名为`GetGameData`的类。这个类将具有基础URL和队伍缩写的属性，如所示。下一个列表显示了该类的一部分。
- en: Listing 2.5\. A portion of `GetGameData`, showing the attributes and initialization
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.5\. `GetGameData`的一部分，显示属性和初始化
- en: '![](ch02ex05-0.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![第二章示例5-0](ch02ex05-0.jpg)'
- en: '![](ch02ex05-1.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![第二章示例5-1](ch02ex05-1.jpg)'
- en: The key-value pairs in the `abbrevs` map hold the three-letter abbreviations
    for each team and the city name, respectively.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`abbrevs`映射中的键值对分别持有每个队伍的三字母缩写和城市名称。'
- en: The next step is to process the actual box scores. Here’s some sample data,
    taken at random. The random date I’ve chosen is October 28, 2007.^([[9](#ch02fn09)])
    The next listing shows the box score in XML form, truncated to show the typical
    elements without showing them all.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是处理实际的得分板。以下是一些随机选取的样本数据。我选择的随机日期是2007年10月28日.^([[9](#ch02fn09)]) 下一个列表显示了XML形式的得分板，截断以显示典型元素，而不显示所有元素。
- en: ⁹ Just happens to be the day the Red Sox won the World Series in 2007.
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹ 正好是红袜队在2007年赢得世界大赛的那一天。
- en: 'Listing 2.6\. boxscore.xml: the box score from game 4 of the 2007 World Series'
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.6\. boxscore.xml：2007年世界大赛第4场比赛的得分板
- en: '[PRE36]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The root element is `<boxscore>`, which has several attributes. It has a child
    element called `<linescore>`, which shows the scoring in each inning. Then there
    are `<pitching>` and `<batting>` elements for the home team and away team, respectively.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 根元素是`<boxscore>`，它有几个属性。它有一个名为`<linescore>`的子元素，显示每局的得分。然后是`<pitching>`和`<batting>`元素，分别代表主队和客队。
- en: This isn’t a terribly complex XML file, but if you had to process it using Java
    the code would quickly get involved. Using Groovy, as shown previously, all you
    have to do is walk the tree.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个特别复杂的XML文件，但如果您必须使用Java处理它，代码会很快变得复杂。使用前面展示的Groovy，您只需遍历树即可。
- en: 'Parsing this data uses the same approach as parsing the geocoded data in the
    last section. Here I need to assemble the URL based on the month, day, and year
    and then parse the box score file:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 解析这些数据与上一节中解析地理编码数据的做法相同。在这里，我需要根据月份、日期和年份组装URL，然后解析得分板文件：
- en: '[PRE37]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After parsing the file I can walk the tree to extract the team names and scores:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 解析文件后，我可以遍历树以提取队伍名称和得分：
- en: '[PRE38]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The dots represent child elements, as before, and this time the @ symbols imply
    attributes.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 点号代表子元素，如前所述，这次@符号表示属性。
- en: '|  |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Parsing XML
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解析XML
- en: Dots traverse from parent elements to children, and @ signs represent attribute
    values.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 点号从父元素遍历到子元素，而@符号代表属性值。
- en: '|  |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**XML, regular expressions, and the Groovy Truth**'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '**XML、正则表达式和Groovy的真理**'
- en: 'To do some slightly more interesting processing, consider determining the winning
    and losing pitchers. The XML contains that information in a `note` attribute of
    the `pitcher` element. I can process that using a regular expression, assuming
    it exists at all:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行一些稍微有趣的处理，可以考虑确定获胜和失败的投手。XML在`pitcher`元素的`note`属性中包含该信息，我可以使用正则表达式处理，假设它确实存在：
- en: '[PRE39]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: First I select all the `pitcher` elements for both teams. Then I want to examine
    the `pitcher` elements to find out who won and lost and if anyone was assigned
    a save. In the XML this information is kept in a `note` annotation in the `pitcher`
    element, which may or may not exist.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我选择两队的所有`pitcher`元素。然后，我想检查`pitcher`元素以找出谁获胜和失败，以及是否有人被分配了救援。在XML中，这些信息保存在`pitcher`元素的`note`注释中，这可能存在也可能不存在。
- en: 'In the `if` statement, therefore, I check to see if a `note` attribute is present.
    Here I’m using the “Groovy Truth,” which means that non-null references evaluate
    to true. So do non-empty strings or collections, non-zero numbers, and, of course,
    the boolean literal `true`. If the `note` element is present, I then use the so-called
    “slashy” syntax to check to see if the note matches a regular expression: `p.@note
    =~ /W|L|S/`. If there’s a match I print out the values.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`if`语句中，我检查是否存在`note`属性。在这里，我使用“Groovy真理”，这意味着非空引用评估为真。同样，非空字符串或集合、非零数字以及当然，布尔字面量`true`也是如此。如果存在`note`元素，然后我使用所谓的“斜线”语法来检查该注释是否与正则表达式匹配：`p.@note
    =~ /W|L|S/`。如果匹配，则打印出值。
- en: '|  |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Generating Game Results
  id: totrans-442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成游戏结果
- en: Before I show the complete method I need one more section. For the Groovy Baseball
    application I’m not interested in console output. Rather, I want to assemble the
    game results into a format that can be processed in the view layer by JavaScript.
    That means I need to return an object that can be converted into XML (or JSON).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在我展示完整方法之前，我还需要一个部分。对于Groovy棒球应用程序，我对控制台输出不感兴趣。相反，我想将游戏结果组装成可以在视图层由JavaScript处理的格式。这意味着我需要返回一个可以转换为XML（或JSON）的对象。
- en: 'Here’s a class called `GameResult` for that purpose:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个名为`GameResult`的类用于此目的：
- en: '[PRE40]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|  |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Closure Return Values
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 闭包返回值
- en: The last expression in a closure is returned automatically.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包中的最后一个表达式会自动返回。
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This POGO is a simple wrapper for the home and away teams and the home and away
    scores, as well as for the stadium. The stadium is needed because it contains
    the latitude and longitude values I need for the Google Map. The following listing
    now shows the complete `getGame` method in the `GetGameData` class shown in [listing
    2.5](#ch02ex05).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这个POGO是主队和客队以及主队和客队得分以及球场的简单包装。球场是必需的，因为它包含我需要的用于Google地图的纬度和经度值。下面的列表现在显示了`GetGameData`类中[列表2.5](#ch02ex05)所示的完整`getGame`方法。
- en: Listing 2.7\. The `getGame` method in `GetGameData.groovy`
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.7\. `GetGameData.groovy`中的`getGame`方法
- en: '![](040fig01_alt.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![图片](040fig01_alt.jpg)'
- en: The method uses an `XmlSlurper` to convert the XML box score into a DOM tree,
    extracts the needed information, and creates and returns an instance of the `Game-Result`
    class.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用一个`XmlSlurper`将XML比赛得分转换为DOM树，提取所需信息，并创建并返回`Game-Result`类的实例。
- en: There’s one other method in the `GetGameData` class, which is the one used to
    parse the web page listing the games for that day. This is necessary because due
    to rain-outs and other postponements there’s no way to know ahead of time which
    games will actually be played on a given day.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetGameData`类中还有一个其他的方法，这是用来解析当天比赛列表网页的。这是必要的，因为由于雨停和其他推迟，事先无法知道哪场比赛将在某一天实际进行。
- en: Parsing HTML is always a dicey proposition, especially because it may not be
    well-formed. There are third-partly libraries to do it,^([[10](#ch02fn10)]) but
    the mechanism shown here works. It also demonstrates regular-expression mapping
    in Groovy. The `getGames` method from `GetGameData` is shown in the next listing.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 解析HTML总是一个冒险的提议，尤其是因为它可能不是良好形成的。有第三方库来做这件事^([[10](#ch02fn10)])，但这里显示的机制是有效的。它还展示了Groovy中的正则表达式映射。下一个列表显示了`GetGameData`中的`getGames`方法。
- en: ^(10) See, for example, the NekoHTML parser at [http://nekohtml.sourceforge.net/](http://nekohtml.sourceforge.net/).
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10) 例如，请参阅[NekoHTML解析器](http://nekohtml.sourceforge.net/)。
- en: Listing 2.8\. The `getGames` method from `GetGameData`
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.8\. `GetGameData`中的`getGames`方法
- en: '![](041fig01_alt.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![图片](041fig01_alt.jpg)'
- en: The `=~` method in Groovy returns an instance of `java.util.regex.Matcher`.
    The parentheses in the regular expression are groups, which let me extract the
    away team abbreviation, the home team abbreviation, and the game number from the
    URL. I use those to call the `getGames` method from [listing 2.7](#ch02ex07) and
    put the results into a collection of `GameResult` instances.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy中的`=~`方法返回一个`java.util.regex.Matcher`实例。正则表达式中的括号是分组，这让我可以从URL中提取客队缩写、主队缩写和比赛编号。我使用这些来调用[列表2.7](#ch02ex07)中的`getGames`方法，并将结果放入`GameResult`实例的集合中。
- en: Testing
  id: totrans-460
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试
- en: All that’s left is to test the complete `GetGameData` class. A JUnit test to
    do so is shown in the next listing.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是测试完整的`GetGameData`类。下一个列表显示了用于此目的的JUnit测试。
- en: 'Listing 2.9\. `GetGameDataTests.groovy`: a JUnit 4 test case'
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.9\. `GetGameDataTests.groovy`：JUnit 4测试用例
- en: '![](041fig02_alt.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![图片](041fig02_alt.jpg)'
- en: This is a standard JUnit 4 test case. I have much more to say about Groovy testing
    capabilities in [chapter 6](kindle_split_017.html#ch06) on testing, but here’s
    a simple example. There’s nothing inherently Groovy about this class except that
    (1) I used the map-based constructor to instantiate the fixture, (2) optional
    parentheses were left out wherever possible, and (3) no explicit `public` or `private`
    keywords were needed. Otherwise, this is just a regular test case, and it works
    as usual.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的 JUnit 4 测试用例。我在第 6 章（kindle_split_017.html#ch06）关于测试的章节中有更多关于 Groovy
    测试能力的话要说，但这里有一个简单的例子。这个类除了以下三点以外没有固有的 Groovy 特性：（1）我使用了基于映射的构造函数来实例化测试用例，（2）尽可能省略了可选的括号，（3）不需要显式的
    `public` 或 `private` 关键字。否则，这只是一个普通的测试用例，并且像往常一样工作。
- en: What have I discussed in this section?
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本节中讨论了什么？
- en: Groovy has a convenient syntax for maps.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Groovy 为映射提供了方便的语法。
- en: XML parsing and extracting data are easy, as in the previous section.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，XML 解析和提取数据都很简单。
- en: Groovy has a slashy syntax for regular expressions.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Groovy 有用于正则表达式的斜线语法。
- en: Groovy classes work with JUnit tests.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Groovy 类与 JUnit 测试一起工作。
- en: There’s one final piece of the puzzle needed, which is the driver used to call
    the system for each date. I use a “groovlet” for this purpose in the next section.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要解决一个最终的问题，那就是用于调用每个日期的系统的驱动程序。在下一节中，我使用一个“groovlet”来完成这个目的。
- en: 2.3.3\. HTML builders and groovlets
  id: totrans-471
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3. HTML 构建器和 groovlets
- en: The classes used so far access XML box score information and convert it into
    a series of game result objects. For the view layer, however, I need objects in
    a form that can be processed by JavaScript. There are several ways to accomplish
    this, but one of them is to use an XML builder to write out the information in
    XML form.^([[11](#ch02fn11)])
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止使用的类访问 XML 比赛得分信息并将其转换为一系列比赛结果对象。然而，对于视图层，我需要可以由 JavaScript 处理的对象。有几种方法可以实现这一点，但其中之一是使用
    XML 构建器以 XML 形式写出信息.^([[11](#ch02fn11)])
- en: ^(11) The data could just as easily be written in JSON format. Other JSON examples
    are used throughout the book.
  id: totrans-473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（11）数据也可以很容易地以 JSON 格式编写。本书中使用了其他 JSON 示例。
- en: Generating XML
  id: totrans-474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成 XML
- en: The standard Groovy library includes a class called `groovy.xml.MarkupBuilder`,^([[12](#ch02fn12)])
    which is one of several builders (much like the `SwingBuilder` shown at the beginning
    of this chapter) in the standard library. Each of the builders intercepts method
    calls that don’t exist (so-called *pretended* methods) and constructs nodes out
    of them to make a tree structure. The tree is then exported appropriately for
    that kind of builder.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Groovy 库包括一个名为 `groovy.xml.MarkupBuilder` 的类，^([[12](#ch02fn12)]), 它是标准库中几个构建器之一（类似于本章开头展示的
    `SwingBuilder`）。每个构建器都会拦截不存在的方法调用（所谓的 *假想* 方法）并从中构建节点以形成树结构。然后，根据该类型的构建器适当地导出树。
- en: ^(12) I would bet that if this class were created today, it would be called
    `XmlBuilder` instead.
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（12）我敢打赌，如果这个类今天被创建，它会被命名为 `XmlBuilder`。
- en: 'This is actually easier to see than to explain. Consider the `GameResult` class
    from the previous section, which held the home and away team names and scores
    and a reference to a `Stadium` object. Here’s the syntax for creating XML out
    of that object:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上比解释更容易看到。考虑前一个节段的 `GameResult` 类，它包含了主队和客队名称、比分以及一个指向 `Stadium` 对象的引用。以下是创建
    XML 的语法：
- en: '[PRE41]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After instantiating the `MarkupBuilder` and calling the reference `builder`,
    the second line invokes the `games` method on it. It may not look like a method,
    but recall that in Groovy, if a closure is the last argument to a method it can
    be placed outside the parentheses, and here I’m using optional parentheses. Of
    course, there’s no method called `games` in `MarkupBuilder`. That makes it a pretended
    method, and the builder intercepts that method call and creates a node out of
    it. In a `MarkupBuilder` that means it will ultimately create an XML element called
    `games`. The closure syntax implies that the next elements will be child elements
    of `games`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化 `MarkupBuilder` 并调用引用 `builder` 之后，第二行在它上面调用了 `games` 方法。它可能看起来不像一个方法，但请记住，在
    Groovy 中，如果闭包是方法的最后一个参数，它可以放在括号外面，这里我使用了可选的括号。当然，`MarkupBuilder` 中没有名为 `games`
    的方法。这使得它成为一个假想的方法，构建器拦截这个方法调用并从中创建一个节点。在 `MarkupBuilder` 中，这意味着它最终会创建一个名为 `games`
    的 XML 元素。闭包语法暗示下一个元素将是 `games` 的子元素。
- en: Inside the closure the code iterates over each contained result, assigning it
    to the dummy variable `g`. For each `GameResult` `g`, the builder creates an element
    called `game`. The parentheses on `game` imply that `game` will contain attributes.
    In this case, each `game` has an `outcome`, a `lat`, and a `lng`.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在闭包内部，代码遍历每个包含的结果，将其分配给虚拟变量 `g`。对于每个 `GameResult` `g`，构建器创建一个名为 `game` 的元素。`game`
    上的括号表示 `game` 将包含属性。在这种情况下，每个 `game` 都有一个 `outcome`、一个 `lat` 和一个 `lng`。
- en: 'Here’s the output of the `MarkupBuilder`:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `MarkupBuilder` 的输出：
- en: '[PRE42]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If there had been a dozen games that day there would a `<game>` element for
    each one of them. The bottom line is that in Groovy, generating XML is about as
    easy as parsing it.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 如果那天有十二场比赛，那么每场比赛都会有一个 `<game>` 元素。总之，在 Groovy 中，生成 XML 与解析 XML 一样简单。
- en: Server-side processing with groovlets
  id: totrans-484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 groovlets 进行服务器端处理
- en: To drive the whole system I need a server-side component that receives the needed
    date and calls the `GetGameData` class to retrieve the games, which are then returned
    in XML form. Groovy has a component known as a *groovlet* to make that all easy.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 为了驱动整个系统，我需要一个服务器端组件，它接收所需日期并调用 `GetGameData` 类来检索游戏，然后以 XML 格式返回。Groovy 有一个名为
    *groovlet* 的组件，可以轻松实现这一切。
- en: 'A groovlet is a script that is executed by a class called `groovy.servlet.GroovyServlet`.
    This class is part of the Groovy standard library. Like any servlet, it needs
    to be declared in the web.xml deployment descriptor for a web application and
    mapped to a particular URL pattern. In this case I chose the pattern *.groovy.
    Here’s the excerpt from the deployment descriptor:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: Groovlet 是一个由名为 `groovy.servlet.GroovyServlet` 的类执行的脚本。这个类是 Groovy 标准库的一部分。像任何
    servlet 一样，它需要在 web.xml 部署描述符中声明，并映射到特定的 URL 模式。在这种情况下，我选择了模式 *.groovy。以下是部署描述符的摘录：
- en: '[PRE43]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The Groovy Baseball application will therefore send all URLs ending in .groovy
    through the `GroovyServlet`, which will execute them. Groovlets executed this
    way are deployed as source code rather than as compiled classes under WEB-INF.^([[13](#ch02fn13)])
    Groovlets also contain a set of implicit objects representing the request, response,
    input parameters, and more.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Groovy Baseball 应用程序将发送所有以 .groovy 结尾的 URL 通过 `GroovyServlet`，它将执行它们。以这种方式执行的
    groovlets 作为源代码部署，而不是在 WEB-INF 下的编译类。[^[[13](#ch02fn13])] Groovlets 还包含一组表示请求、响应、输入参数等隐式对象。
- en: ^(13) The details are discussed in [chapter 10](kindle_split_022.html#ch10)
    on web applications.
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^[13] 详细内容请参阅第 10 章[关于网络应用](kindle_split_022.html#ch10)。
- en: The following listing contains the complete content of the groovlet that drives
    the Groovy Baseball system.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含驱动 Groovy Baseball 系统的 groovlet 的完整内容。
- en: 'Listing 2.10\. `GameServlet.groovy`: a groovlet for Groovy Baseball'
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.10\. `GameServlet.groovy`：Groovy Baseball 的 groovlet
- en: '![](044fig01_alt.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](044fig01_alt.jpg)'
- en: The groovlet can set response headers, here setting the output to XML. Input
    parameters populate a map of strings called `params`, which can be accessed in
    the usual way. The URL requires two-digit days and two-digit months, so a zero
    is prepended when necessary. After retrieving the games for that date the output
    is generated using the implicit `MarkupBuilder`. There’s no need to instantiate
    a `MarkupBuilder` in this case, because groovlets already contain one, called
    `html`.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: Groovlet 可以设置响应头，这里设置为输出 XML 格式。输入参数填充一个名为 `params` 的字符串映射，可以通过常规方式访问。URL 需要两位数的日期和两位数的月份，因此当需要时会在前面添加零。在检索到该日期的游戏后，使用隐式的
    `MarkupBuilder` 生成输出。在这种情况下，不需要实例化 `MarkupBuilder`，因为 groovlets 已经包含一个，称为 `html`。
- en: The groovlet is called from a regular web page, using a URL of the form [http://.../groovybaseball/GroovyService.groovy?month=10&day=28&year=2007](http://.../groovybaseball/GroovyService.groovy?month=10&day=28&year=2007).
    The XML data is written to the output stream, which can then be processed by JavaScript.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: Groovlet 是从一个常规网页中调用的，使用形式为 [http://.../groovybaseball/GroovyService.groovy?month=10&day=28&year=2007](http://.../groovybaseball/GroovyService.groovy?month=10&day=28&year=2007)
    的 URL。XML 数据被写入输出流，然后可以被 JavaScript 处理。
- en: '|  |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Lessons learned (Groovy Baseball)**'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '**Groovy Baseball 的经验教训**'
- en: POGOs have private attributes and public methods by default. Public getters
    and setters are auto-generated for each attribute.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: POGOs 默认具有私有属性和公共方法。每个属性都会自动生成公共的获取器和设置器。
- en: POGOs include a map-based constructor that can be used to set any or all of
    the attributes in any combination.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: POGOs 包含一个基于映射的构造函数，可以用来设置任何或所有属性的任何组合。
- en: Closures and methods in Groovy return their last evaluated expressions automatically.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovy中的闭包和方法会自动返回它们的最后一个评估表达式。
- en: The `XmlSlurper` class makes parsing XML simple and returns the root of the
    resulting DOM tree. Values can be extracted by walking the tree.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`XmlSlurper`类使得解析XML变得简单，并返回结果DOM树的根。可以通过遍历树来提取值。'
- en: The `MarkupBuilder` class produces XML.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MarkupBuilder`类生成XML。'
- en: The `groovy.sql.Sql` class is a simple façade for dealing with relational databases.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`groovy.sql.Sql`类是处理关系数据库的简单外观。'
- en: Groovlets are simple Groovy scripts that respond to HTTP requests.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovlets是响应HTTP请求的简单Groovy脚本。
- en: All Groovy exceptions are unchecked.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有Groovy异常都是未检查的。
- en: '|  |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The rest of the system is just HTML and JavaScript, so it’s beyond the scope
    of a Groovy discussion. The complete source code for the application is contained
    in the GitHub repository for the book.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的其余部分只是HTML和JavaScript，因此超出了Groovy讨论的范围。应用程序的完整源代码包含在本书的GitHub存储库中。
- en: 2.4\. Summary
  id: totrans-507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4\. 摘要
- en: This chapter is a tutorial on Groovy for Java developers, using example applications
    rather than a series of features. What’s remarkable is how much Groovy simplifies
    the code. POGOs are a minimal yet more flexible version of POJOs. The `groovy.sql.Sql`
    class makes JDBC practical for reasonably small applications. The Groovy JDK adds
    many convenience methods, like `toURL` and `getText`, which make existing Java
    classes easier to use. The combination of maps, closures, and the `join` method
    makes it simple to build URLs for web services. Finally, the difference between
    working with XML in Java and working with XML in Groovy is staggering. Whenever
    I have to work with XML in any form I always look for a way to add a Groovy module
    to handle the details.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是面向Java开发者的Groovy教程，通过示例应用程序而不是一系列功能来介绍。令人印象深刻的是Groovy如何简化代码。POGs是POJOs的一个最小化且更灵活的版本。`groovy.sql.Sql`类使得JDBC对于合理规模的应用变得实用。Groovy
    JDK添加了许多便利方法，如`toURL`和`getText`，这些方法使得现有的Java类更容易使用。map、闭包和`join`方法的组合使得构建Web服务的URL变得简单。最后，Java中处理XML与Groovy中处理XML之间的差异令人震惊。每次我必须以任何形式处理XML时，我总是寻找添加Groovy模块来处理细节的方法。
- en: In the next chapter we’ll examine mechanisms to integrate Java and Groovy together
    in more detail.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地探讨将Java和Groovy集成在一起的方法。
- en: Chapter 3\. Code-level integration
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章\. 代码级集成
- en: '*This chapter covers*'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Calling Groovy scripts from Java using JSR 223
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSR 223从Java调用Groovy脚本
- en: Calling Groovy scripts from Java using Groovy library classes
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Groovy库类从Java调用Groovy脚本
- en: In [chapter 1](kindle_split_011.html#ch01) I reviewed many of Java’s arguable
    weaknesses and drawbacks and suggested ways that Groovy might help ameliorate
    them. Because that chapter was intended to be introductory, I only suggested how
    Groovy can help, without showing a lot of code examples.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](kindle_split_011.html#ch01)中，我回顾了许多Java的可争议的弱点和缺点，并建议Groovy可能有助于改善它们。因为那一章旨在作为介绍，所以我只建议Groovy如何帮助，而没有展示很多代码示例。
- en: This chapter begins an examination of Java and Groovy integration in detail.
    In this chapter I’ll start using Groovy and Java together in fundamental ways,
    without worrying about frameworks or addressing any particular use case. A guide
    to the techniques discussed in this chapter is shown in [figure 3.1](#ch03fig01).
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始详细探讨Java和Groovy的集成。在本章中，我将开始以基本方式使用Groovy和Java，而不必担心框架或解决任何特定的用例。本章讨论的技术指南如图3.1所示[图3.1](#ch03fig01)。
- en: Figure 3.1\. Guide to integration features. Groovy can be accessed with Java
    classes alone using the JSR 223 script engine. If you are willing to add some
    Groovy library classes to Java, the `Eval, GroovyShell`, and `Binding` classes
    make working with scripts easy. The best way to combine Groovy and Java is using
    classes for both languages.
  id: totrans-516
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1\. 集成功能指南。仅使用Java类即可通过JSR 223脚本引擎访问Groovy。如果您愿意将一些Groovy库类添加到Java中，`Eval`、`GroovyShell`和`Binding`类使得处理脚本变得容易。将Groovy和Java结合起来的最佳方式是使用两种语言中的类。
- en: '![](03fig01.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig01.jpg)'
- en: 3.1\. Integrating Java with other languages
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. 将Java与其他语言集成
- en: Combining Java with other languages has always been a challenge. Java historically
    hasn’t played well with others.^([[1](#ch03fn01)]) The only API designed from
    the beginning for Java to call functions written in other languages is JNI, the
    Java Native Interface, which is awkward to use even in the best of circumstances.^([[2](#ch03fn02)])
    The past few years, however, have seen the rise of entire families of languages
    that compile directly to bytecodes that run on the JVM, from Groovy to Scala to
    Clojure, as well as bridge languages like Jython or JRuby that allow you to run
    code written in Python or Ruby on the JVM. From the point of view of these “alternative”
    JVM-based languages, Java’s real contribution isn’t the language itself, but rather
    the virtual machine and the associated Java libraries. JVM-based languages take
    advantage of the Java infrastructure and try to handle any Java-specific drawbacks.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 将Java与其他语言结合一直是一个挑战。Java历史上与其他语言配合得并不好.^([[1](#ch03fn01)]) 从一开始就为Java调用其他语言编写的函数设计的唯一API是JNI，即Java本地接口，即使在最佳情况下使用起来也很繁琐.^([[2](#ch03fn02)])
    然而，在过去的几年里，我们看到从Groovy到Scala到Clojure等一系列直接编译为在JVM上运行的字节码的语言兴起，以及像Jython或JRUBY这样的桥梁语言，允许你在JVM上运行用Python或Ruby编写的代码。从这些“替代”基于JVM的语言的角度来看，Java真正的贡献不是语言本身，而是虚拟机及其相关的Java库。基于JVM的语言利用Java基础设施，并试图处理任何Java特定的缺点。
- en: ¹ Of course, this is true of most languages.
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 当然，这一点对大多数语言都适用。
- en: ² Once, back in the late 1990s, I had to build a Java Swing user interface in
    front of an engineering system written in Fortran. I used JNI to go from Java
    to C and then from C to Fortran. The results were like putting a notch into a
    wooden beam and saying, “I want you to break right here.”
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 曾经在20世纪90年代末晚期，我不得不在用Fortran编写的工程系统前面构建一个Java Swing用户界面。我使用了JNI从Java到C，然后从C到Fortran。结果就像在木梁上开一个缺口，然后说，“我希望你就在这里断裂。”
- en: '|  |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: JVM
  id: totrans-523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JVM
- en: Ultimately, Java’s biggest contribution isn’t the language; it’s the virtual
    machine.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，Java最大的贡献不是语言本身；而是虚拟机。
- en: '|  |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Whenever a new capability is integrated into Java’s basic infrastructure, a
    Java Specification Request (JSR) is created to provide a standard implementation
    mechanism. In the integration case, the JSR in question is JSR 223, Scripting
    for the Java Platform ([http://jcp.org/en/jsr/detail?id=223](http://jcp.org/en/jsr/detail?id=223)).
    The purpose of the JSR is to allow other (presumably scripting) languages to be
    invoked from Java. Although most of this book will assume that you’re mixing Java
    and Groovy on a class-by-class basis, for the sake of completeness I’ll review
    here how to call a Groovy script from Java, both using the JSR technique and using
    library classes provided by Groovy for that purpose.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 每当Java的基本基础设施集成新的功能时，就会创建一个Java规范请求（JSR）来提供一个标准的实现机制。在集成案例中，相关的JSR是JSR 223，Java平台脚本编程([http://jcp.org/en/jsr/detail?id=223](http://jcp.org/en/jsr/detail?id=223))。JSR的目的在于允许其他（可能是脚本）语言从Java中调用。尽管本书的大部分内容将假设你是在类级别上混合使用Java和Groovy，为了完整性，我将在此回顾如何从Java调用Groovy脚本，既使用JSR技术，也使用Groovy为此目的提供的库类。
- en: Groovy is much closer to Java than the script integration story suggests, however.
    As I’ll demonstrate in the section on calling Java from Groovy rather than the
    other way around, virtually every Groovy program of any size uses Java already.
    Groovy code can instantiate a Java class, call a method Groovy added to it (the
    so-called Groovy JDK highlighted in [chapter 4](kindle_split_014.html#ch04), [section
    4.3](kindle_split_014.html#ch04lev1sec3)), and call additional Java methods on
    the result. The question then becomes, what does Groovy bring to Java? How can
    you simplify your development tasks by adding Groovy to Java systems? I’ll address
    that question in the rest of the chapter (and, indeed, in the rest of the book).
    Let’s start, though, with the scripting story. How do you combine Java and Groovy
    in the same system when Groovy consists of scripts rather than classes, and you
    want to isolate any Java integration code?
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 与 Java 的关系比脚本集成故事所暗示的要近得多。正如我将在从 Groovy 调用 Java 而不是相反方向的章节中演示的那样，几乎任何规模的
    Groovy 程序都已经使用了 Java。Groovy 代码可以实例化一个 Java 类，调用添加到其中的 Groovy 方法（所谓 Groovy JDK，在第
    4 章中突出显示[kindle_split_014.html#ch04]，第 4.3 节[kindle_split_014.html#ch04lev1sec3]），并且可以在结果上调用额外的
    Java 方法。那么问题就变成了，Groovy 为 Java 带来了什么？如何通过添加 Groovy 到 Java 系统中来简化你的开发任务？我将在本章的其余部分（以及本书的其余部分）中回答这个问题。不过，让我们先从脚本故事开始。当
    Groovy 由脚本而不是类组成，并且你想要隔离任何 Java 集成代码时，如何在同一个系统中结合 Java 和 Groovy？
- en: 3.2\. Executing Groovy scripts from Java
  id: totrans-528
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2. 从 Java 执行 Groovy 脚本
- en: The assumption in the first couple of sections of this chapter is that you’ve
    written or acquired some Groovy scripts and wish to use them in your Java system
    in a way that’s minimally invasive. Perhaps you’re using the scripts to implement
    business logic in Groovy because it changes so frequently (a technique referred
    to as Liquid Heart by Dierk Koenig, lead author of *Groovy in Action* [Manning,
    2007]). Perhaps you’re replacing Perl scripts with Groovy because anything you
    can do in Perl you can do in Groovy, with the added bonus that you can integrate
    with existing Java systems. Perhaps you’re following one of the original intents
    of the JSR, which is to use a scripting language to generate user interfaces while
    letting Java handle the back-end functionality. In any case, I want to demonstrate
    how to invoke those scripts from a Java system as easily as possible.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前几节中的假设是，你已经编写或获取了一些 Groovy 脚本，并希望以最小侵入性的方式在 Java 系统中使用它们。也许你正在使用这些脚本在 Groovy
    中实现业务逻辑，因为它们变化如此频繁（Dierk Koenig，*Groovy in Action* 的主要作者，将其称为液体心脏技术[Manning, 2007]）。也许你正在用
    Groovy 替换 Perl 脚本，因为你可以用 Groovy 做任何用 Perl 可以做的事情，并且还有一个额外的优点，那就是你可以与现有的 Java 系统集成。也许你正在遵循
    JSR 的原始意图之一，即使用脚本语言生成用户界面，同时让 Java 处理后端功能。无论如何，我想演示如何尽可能容易地从 Java 系统中调用这些脚本。
- en: One of the interesting features of Groovy is that, unlike in Java, you don’t
    have to put all Groovy code into a class. You can just put all your Groovy code
    into a file called practically anything you like, as long as the file extension
    is .groovy, and then you can execute the scripts with the `groovy` command. One
    possible sweet spot for Groovy is to write short, simple programs without the
    clutter of creating a class with a `main` method in it, and here I’ll show how
    to incorporate scripts like that into a Java application.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 的一个有趣特性是，与 Java 不同，你不必将所有 Groovy 代码放入一个类中。你只需将所有 Groovy 代码放入一个名为你喜欢的任何名称的文件中，只要文件扩展名是
    .groovy，然后你可以使用 `groovy` 命令执行脚本。Groovy 的一个可能的优势是编写简短、简单的程序，而不需要创建一个包含 `main` 方法的类，在这里我将展示如何将此类脚本集成到
    Java 应用程序中。
- en: In keeping with the standard I’ll start with a technique based on JSR 223, Scripting
    for the Java Platform, which allows you to invoke Groovy purely from Java library
    calls. Then I’ll show that if you use a couple of classes from the Groovy API
    you can simplify the integration. Finally, I’ll show that if you can change from
    scripts to classes for your Groovy code, nearly all the complexity can be eliminated.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 按照标准，我将从一个基于 JSR 223 的技术开始，即 Java 平台脚本，它允许你仅通过 Java 库调用调用 Groovy。然后我将展示，如果你使用
    Groovy API 中的几个类，你可以简化集成。最后，我将展示，如果你可以将你的 Groovy 代码从脚本更改为类，几乎可以消除所有复杂性。
- en: Incidentally, assuming any Groovy scripts are compiled, at runtime treat the
    combined application as though it’s all Java. All the integration strategies I
    plan to discuss in this chapter involve deciding where and how to use Groovy to
    make your life easier. Once you have the combined system, though, the deployment
    story is really simple, as the sidebar demonstrates.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，假设任何 Groovy 脚本都已编译，在运行时将组合应用程序视为全部是 Java。我在本章中计划讨论的所有集成策略都涉及决定在哪里以及如何使用
    Groovy 来使你的生活更轻松。然而，一旦你有了组合系统，部署故事就非常简单，正如侧边栏所示。
- en: '|  |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Groovy and Java together at runtime**'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行时 Groovy 和 Java 一起**'
- en: At *runtime*, compiled Groovy and compiled Java both result in bytecodes for
    the JVM. To execute code that combines them, all that’s necessary is to add a
    single JAR file to the system. Compiling and testing your code requires the Groovy
    compiler and libraries, but at runtime all you need is one JAR.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *运行时*，编译后的 Groovy 和编译后的 Java 都会为 JVM 生成字节码。要执行结合它们的代码，只需要将一个 JAR 文件添加到系统中。编译和测试你的代码需要
    Groovy 编译器和库，但在运行时你只需要一个 JAR。
- en: That JAR comes with your Groovy distribution in the embeddable subdirectory.
    Suppose, for example, your Groovy installation is version 2.1.5\. Then on your
    disk in the Groovy installation directory you have the structure shown in the
    following figure, and the JAR file you need is groovy-all-2.1.5.jar.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 JAR 文件包含在你的 Groovy 发行版中的可嵌入子目录中。例如，假设你的 Groovy 安装版本是 2.1.5。那么在你的磁盘上 Groovy
    安装目录中，你有以下结构，你需要的是 groovy-all-2.1.5.jar。
- en: '![](049fig01_alt.jpg)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![](049fig01_alt.jpg)'
- en: Add the groovy-all JAR to your system, and you can run it with the `java` command.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 将 groovy-all JAR 添加到你的系统中，你就可以使用 `java` 命令来运行它。
- en: In the rest of the text, I’ll refer to this JAR file as the “groovy-all” JAR.
    If this JAR is added to your classpath you can execute combined Groovy and Java
    applications with the standard `java` command. If you add a Groovy module to a
    web application, add the groovy-all JAR to the WEB-INF//lib directory and everything
    will work normally.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本的其余部分，我将把这个 JAR 文件称为“groovy-all” JAR。如果你把这个 JAR 添加到你的类路径中，你可以使用标准的 `java`
    命令来执行 Groovy 和 Java 的组合应用程序。如果你把一个 Groovy 模块添加到一个 Web 应用程序中，请将 groovy-all JAR
    添加到 WEB-INF/lib 目录，一切都将正常工作。
- en: 'Here’s a minimal demonstration just to prove the point. Consider the “Hello,
    World!” application written in Groovy, which, unlike in Java, is a one-liner:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的演示，只是为了证明这个观点。考虑用 Groovy 编写的“Hello, World!”应用程序，与 Java 不同，它是一行代码：
- en: '[PRE44]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If I saved this into a file called hello_world.groovy I could execute the script
    using the `groovy` command, which would compile it and run it all in one process.
    To run it using the `java` command, however, first I have to compile it with `groovyc`
    and then execute the resulting bytecodes, making sure the groovy-all JAR is in
    the classpath. The two-step process is shown. Note that the `java` command should
    be all on one line:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我把这个保存到一个名为 hello_world.groovy 的文件中，我可以用 `groovy` 命令来执行脚本，它会编译并运行它。但是，要使用
    `java` 命令来运行它，我必须首先用 `groovyc` 编译它，然后执行生成的字节码，确保 groovy-all JAR 在类路径中。这个过程分为两步。注意，`java`
    命令应该在一行上：
- en: '[PRE45]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: I needed the `groovyc` command in order to compile the script, but I was able
    to execute it using plain old `java` (as long as the groovy-all JAR was in the
    execution classpath).
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要 `groovyc` 命令来编译脚本，但我能够使用普通的 `java` 命令（只要 groovy-all JAR 在执行类路径中）来执行它。
- en: '|  |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: At the API level, to call a Groovy script from Java you have a few alternatives.
    I’ll first show the “hardest” way possible, using the JSR-223 API. The API associated
    with JSR 223 is designed to allow Java programs to invoke scripts written in other
    languages.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在 API 层面，要从 Java 调用一个 Groovy 脚本，你有几种选择。我将首先展示“最困难”的方法，使用 JSR-223 API。与 JSR 223
    相关的 API 设计用于允许 Java 程序调用用其他语言编写的脚本。
- en: I’m calling this “[the hard way](#ch03note06)” because it doesn’t take advantage
    of anything provided by Groovy other than the script itself. I’ll use the layers
    of indirection provided by the Java API, which separates the Groovy code from
    the Java code that invokes it. Later you’ll start mixing Java and Groovy by combining
    classes and methods, and you’ll find that’s much easier. Still, it’s worth seeing
    how to use the JSR, especially because, after all, it is the standard. Also, even
    if it’s technically the hard way, it’s really not all that hard.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 我称之为“[困难的方式](#ch03note06)”是因为它没有利用Groovy提供的任何东西，除了脚本本身。我将使用Java API提供的间接层，它将Groovy代码与调用它的Java代码分开。稍后，你将通过组合类和方法开始混合Java和Groovy，你会发现这要容易得多。尽管如此，了解如何使用JSR仍然值得，特别是因为它毕竟是标准。此外，尽管在技术上这是困难的方式，但实际上并不那么困难。
- en: 3.2.1\. Using JSR223 scripting for the Java Platform API
  id: totrans-548
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. 使用JSR223脚本为Java平台API
- en: Built into Java SE 6 and above, the API for JSR 223, Scripting for the Java
    Platform, is a standard mechanism you can use to call scripts written in other
    languages. The advantage to this approach is that it avoids introducing anything
    specific to Groovy into the calling Java program. If you already have Groovy scripts
    and you just want to call them from inside Java, this is a good way to go.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 内置于Java SE 6及更高版本中，JSR 223的API，即Java平台的脚本，是一个标准机制，你可以用它来调用用其他语言编写的脚本。这种方法的优势在于它避免了在调用Java程序中引入任何特定于Groovy的内容。如果你已经有了Groovy脚本，并且只想在Java内部调用它们，这是一个不错的选择。
- en: '|  |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: JSR 223
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JSR 223
- en: The JSR allows you to call Groovy scripts using purely Java classes.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: JSR允许你使用纯Java类调用Groovy脚本。
- en: '|  |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The JSR defines an API based on a `javax.script.ScriptEngine` instance. As is
    common with many Java libraries, the API also includes a factory interface, in
    this case called `javax.script.ScriptEngineFactory`, for retrieving `ScriptEngine`
    instances. The API also specifies a `javax.script.ScriptEngineManager` class,
    which retrieves metadata about the available `ScriptEngineFactory` instances.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: JSR定义了一个基于`javax.script.ScriptEngine`实例的API。与许多Java库一样，该API还包括一个工厂接口，在这种情况下称为`javax.script.ScriptEngineFactory`，用于检索`ScriptEngine`实例。该API还指定了一个`javax.script.ScriptEngineManager`类，它检索有关可用的`ScriptEngineFactory`实例的元数据。
- en: In many Java APIs you use a factory to acquire the object you need. For example,
    parsing XML with a SAX parser is done by first getting an instance of the `SAXParserFactory`
    and then using it to acquire a new SAX parser. The same is true for DOM builders,
    XSLT transformation engines, and many others. In each case, if you want to use
    a particular implementation other than the built-in default, you need to specify
    an environment variable, a method argument, or some other way of letting Java
    know you’re planning to do something different. You also need to make the alternative
    implementation available in your classpath.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多Java API中，你使用一个工厂来获取你需要的对象。例如，使用SAX解析器解析XML是通过首先获取`SAXParserFactory`的实例，然后使用它来获取一个新的SAX解析器来完成的。对于DOM构建器、XSLT转换引擎以及许多其他情况也是如此。在每种情况下，如果你想使用除内置默认实现之外的特定实现，你需要指定一个环境变量、方法参数或其他方式让Java知道你打算做不同的事情。你还需要在类路径中提供替代实现。
- en: The first issue, therefore, is to determine whether the script engine used for
    Groovy code is available by default and, if not, how to acquire it. Using the
    Java 7 JDK from Oracle I can determine which factories are already embedded. The
    following listing retrieves all the available factories from the manager and prints
    some of their properties.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首要问题是确定用于Groovy代码的脚本引擎是否默认可用，如果不可用，如何获取它。使用Oracle的Java 7 JDK，我可以确定哪些工厂已经内置。以下列表从管理器检索所有可用的工厂并打印它们的一些属性。
- en: Listing 3.1\. Finding all the available script engine factories
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.1\. 查找所有可用的脚本引擎工厂
- en: '![](050fig01_alt.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![](050fig01_alt.jpg)'
- en: With a nod toward better practices than simply using `System.out.println` statements,
    I set up a simple logger. Then I retrieved all the available factories from the
    manager and printed the language name and engine name. Finally, I printed all
    the available names for each factory, which shows all the available aliases that
    can be used to retrieve them.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比简单地使用`System.out.println`语句更好的实践，我设置了一个简单的日志记录器。然后我从管理器检索所有可用的工厂并打印语言名称和引擎名称。最后，我打印出每个工厂的所有可用名称，这显示了所有可以用来检索它们的别名。
- en: 'The results are shown here, truncated for readability:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下，为了可读性进行了截断：
- en: '[PRE46]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The output shows that by default there’s only one factory available, and its
    purpose is to execute JavaScript (or, more formally, ECMAScript). This factory
    can be retrieved using any of the names on the last line, but there’s only one
    factory available, and it has nothing to do with Groovy.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示默认情况下只有一个工厂可用，其目的是执行 JavaScript（或者更正式地，ECMAScript）。这个工厂可以通过最后一行上的任何名称检索，但只有一个工厂可用，它与
    Groovy 没有关系。
- en: 'Fortunately, making a Groovy script engine factory available is easy. One of
    the features of the `ScriptEngineManager` class is that it detects new factories
    using the same extension mechanism used for JAR files. In other words, all you
    have to do is to add the Groovy libraries to your classpath via the groovy-all
    JAR. Once you do that, the same program produces the additional output shown here:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使 Groovy 脚本引擎工厂可用很容易。`ScriptEngineManager` 类的一个特性是它使用与 JAR 文件相同的扩展机制来检测新的工厂。换句话说，你所要做的就是通过
    groovy-all JAR 将 Groovy 库添加到你的类路径中。一旦这样做，相同的程序就会产生这里所示的增加输出：
- en: '[PRE47]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this case the script engine reports that the Groovy language version is 2.1.3
    and the engine version is 2.0.^([[3](#ch03fn00)])
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，脚本引擎报告 Groovy 语言版本为 2.1.3，引擎版本为 2.0.^([[3](#ch03fn00)])
- en: ³ I did use the Groovy 2.1.5 compiler, but the script engine still reports 2.1.3\.
    It doesn’t affect the results, though.
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 我确实使用了 Groovy 2.1.5 编译器，但脚本引擎仍然报告为 2.1.3。尽管如此，这并不影响结果。
- en: In this particular API, even though a factory is now available, you don’t need
    to use it to acquire the script engine. Instead, the `ScriptEngineManager` class
    has a method to retrieve the factory by supplying its name (either `groovy` or
    `Groovy`, as shown in the previous output) in the form of a `String`. From the
    `ScriptEngine` I can then execute Groovy scripts using the script engine’s `eval`
    method. The process is illustrated in [figure 3.2](#ch03fig02).
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的 API 中，尽管现在有工厂可用，但你不需要使用它来获取脚本引擎。相反，`ScriptEngineManager` 类有一个方法可以通过提供其名称（如前一个输出所示，可以是
    `groovy` 或 `Groovy`）作为 `String` 来检索工厂。然后，我可以从 `ScriptEngine` 使用脚本引擎的 `eval` 方法执行
    Groovy 脚本。这个过程在 [图 3.2](#ch03fig02) 中得到了说明。
- en: Figure 3.2\. Using the JSR 223 `ScriptEngine` to invoke a Groovy script. Java
    creates a `ScriptEngineManager`, which then yields a `ScriptEngine`. After supplying
    parameters to the engine, its `eval` method is invoked to execute a Groovy script.
  id: totrans-568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.2\. 使用 JSR 223 的 `ScriptEngine` 调用 Groovy 脚本。Java 创建一个 `ScriptEngineManager`，然后生成一个
    `ScriptEngine`。在向引擎提供参数后，其 `eval` 方法被调用以执行一个 Groovy 脚本。
- en: '![](03fig02_alt.jpg)'
  id: totrans-569
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2](03fig02_alt.jpg)'
- en: The next listing demonstrates the API in action in a simple “Hello, World!”
    Groovy script.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了 API 在一个简单的“Hello, World!” Groovy 脚本中的实际应用。
- en: Listing 3.2\. Using the `ScriptEngine` to execute a simple Groovy script
  id: totrans-571
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 使用 `ScriptEngine` 执行简单的 Groovy 脚本
- en: '![](052fig01_alt.jpg)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2](052fig01_alt.jpg)'
- en: 'I retrieve the Groovy script engine by calling the `getEngineByName` method.
    I then use two different overloads of the `eval` method: one that takes a `String`
    argument and one that takes an implementation of the `java.io.Reader` interface.
    In the first case, the supplied string needs to be the actual scripting code.
    For the reader, though, I use a `FileReader` wrapped around the “Hello, Groovy!”
    script. The output is what you would expect in each case.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过调用 `getEngineByName` 方法检索 Groovy 脚本引擎。然后，我使用 `eval` 方法的两种不同的重载：一个接受 `String`
    参数，另一个接受 `java.io.Reader` 接口的实现。在前一种情况下，提供的字符串需要是实际的脚本代码。对于读取器，我使用一个包装在“Hello,
    Groovy!”脚本中的 `FileReader`。输出是每种情况下都可以预期的。
- en: Supplying Parameters to a Groovy Script
  id: totrans-574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向 Groovy 脚本提供参数
- en: What if the Groovy script took input parameters and returned data? In the Groovy
    scripting world this is handled through a *binding*. When I discuss the `GroovyShell`
    in the next section I’ll show that there’s actually a class in the Groovy API
    called `Binding`, but here I’ll do the binding implicitly through the Java API.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Groovy 脚本接受输入参数并返回数据呢？在 Groovy 脚本编写世界中，这通过 *绑定* 来处理。在下一节中，当我讨论 `GroovyShell`
    时，我会展示 Groovy API 中实际上有一个名为 `Binding` 的类，但在这里我将通过 Java API 隐式地执行绑定。
- en: A binding is a collection of variables at a scope that makes them visible inside
    a script. In the JSR 223 API, the `ScriptEngine` class itself acts as a binding.
    It has both a `put` and a `get` method that can be used to add variables to scripts
    and retrieve the results from them.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定是在某个作用域内的一组变量集合，使得它们在脚本内部可见。在 JSR 223 API 中，`ScriptEngine` 类本身就是一个绑定。它具有 `put`
    和 `get` 方法，可以用来向脚本添加变量并从它们中检索结果。
- en: To illustrate this, let’s do something a bit less trivial and possibly more
    practical. Instead of doing a simple “Hello, World!” script, consider the Google
    geocoder, in its version 2 form.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们做一些不那么平凡、可能更有实际意义的事情。不要做一个简单的“Hello, World!”脚本，考虑 Google 地理编码器，以它的版本
    2 形式。
- en: '|  |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Groovy Sweet Spot
  id: totrans-579
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Groovy 甜点
- en: Groovy scripts are an easy way to experiment with new libraries.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 脚本是一种轻松尝试新库的方法。
- en: '|  |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: A geocoder is an application that converts addresses to latitude/longitude pairs.
    Google has had a publicly available geocoder for years. In this section I’ll use
    version 2, which requires a key (available through a free registration), but which
    gives me the chance to show some interesting Groovy features. When I discuss XML
    processing later in this chapter I’ll use version 3 of the geocoder instead. That
    version no longer requires a key, but it doesn’t make the results available in
    the same comma-separated form I’ll use here.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 地理编码器是一种将地址转换为经纬度对的应用程序。谷歌已经公开提供地理编码器多年。在本节中，我将使用版本 2，它需要一个密钥（通过免费注册获得），但这也给了我展示一些有趣的
    Groovy 特性的机会。当我在本章后面讨论 XML 处理时，我将使用地理编码器的版本 3。该版本不再需要密钥，但它不会以我在这里使用的相同逗号分隔的形式提供结果。
- en: The documentation for version 2 of the Google geocoder can be found at [http://mng.bz/Pg8S](http://mng.bz/Pg8S).
    Version 2 is currently deprecated but still works. I’m using it here because it’s
    familiar from the previous chapter, so you can focus on the input/output parts
    of the script, and because it also lets me demonstrate multiple return values.^([[4](#ch03fn04)])
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: Google 地理编码器版本 2 的文档可以在 [http://mng.bz/Pg8S](http://mng.bz/Pg8S) 找到。版本 2 目前已弃用但仍然有效。我在这里使用它是因为它来自上一章，这样你可以专注于脚本的输入/输出部分，并且因为它还让我展示了多个返回值^([[4](#ch03fn04)])。
- en: ⁴ Another reason to show the version 2 geocoder is because the Google Maps API
    for Android still uses it.
  id: totrans-584
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 展示版本 2 地理编码器的另一个原因是 Android 的 Google 地图 API 仍然使用它。
- en: 'In order to use the geocoder, the basic idea is to transmit an address as a
    parameter in an HTTP `GET` request and process the results. As shown in [chapter
    2](kindle_split_012.html#ch02), using the Google geocoder takes the following
    steps:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用地理编码器，基本思路是将地址作为 HTTP `GET` 请求中的参数进行传输并处理结果。如 [第 2 章](kindle_split_012.html#ch02)
    所示，使用 Google 地理编码器需要以下步骤：
- en: '**1**.  Convert a list containing the street, city, and state into a URL-encoded
    string whose values are separated by “,”.'
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 将包含街道、城市和州的列表转换为以“，”分隔的 URL 编码字符串。'
- en: '**2**.  Convert a map with the key’s address and sensor into a query string.'
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 将包含地址和传感器的键的映射转换为查询字符串。'
- en: '**3**.  Transmit the resulting URL to the Google geocoder.'
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 将生成的 URL 传输到 Google 地理编码器。'
- en: '**4**.  Parse the results into the desired values.'
  id: totrans-589
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 将结果解析为所需的值。'
- en: 'The first step uses the `collect` method from Groovy, which takes a closure
    as an argument, applies the closure to each element of a collection, and returns
    a new collection containing the results. I take the resulting collection and joined
    each of its elements into a single string, using “,” as a separator:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步使用 Groovy 的 `collect` 方法，该方法接受一个闭包作为参数，将闭包应用于集合的每个元素，并返回一个包含结果的新集合。我将结果集合取出来，并将每个元素连接成一个单独的字符串，使用“，”作为分隔符：
- en: '[PRE48]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|  |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Undeclared variables
  id: totrans-593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 未声明的变量
- en: The street, city, and state are not declared in the script. This adds them to
    the binding, making them available to the caller.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 街道、城市和州在脚本中没有声明。这会将它们添加到绑定中，使它们对调用者可用。
- en: '|  |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'To build a query string I add all the required parameters to a map called `params`.
    I’m also requesting comma-separated values for the output, which is not available
    in the version 3 geocoder:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个查询字符串，我将所有必需的参数添加到一个名为 `params` 的映射中。我还请求以逗号分隔的输出值，这在版本 3 的地理编码器中不可用：
- en: '[PRE49]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The value of `sensor` should be `true` if this request is coming from a GPS-enabled
    device and `false` otherwise. The `key` is determined at registration (version
    3 doesn’t require a key). The `output` is here set to CSV, so that the result
    is a string of comma-separated values composed of the response code (hopefully
    200), the magnification level, and the latitude and longitude.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此请求来自具有 GPS 功能的设备，则 `sensor` 的值应为 `true`，否则为 `false`。`key` 在注册时确定（版本 3 不需要密钥）。`output`
    在这里设置为 CSV，因此结果是一个由逗号分隔的值字符串，由响应代码（希望是 200）、放大级别以及纬度和经度组成。
- en: 'To convert the map into a query string, the `collect` method is used again.
    On a map, if a `collect` is applied with a two-argument closure, the method automatically
    separates the keys from the values. What I want here is to replace expressions
    like `key:value` with strings like `key=value`. The complete URL is then found
    by concatenating the query string to the base URL:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 要将映射转换为查询字符串，再次使用 `collect` 方法。在映射中，如果使用两个参数的闭包应用 `collect`，方法会自动将键和值分开。我想要的是将
    `key:value` 这样的表达式替换为 `key=value` 这样的字符串。然后将查询字符串连接到基本 URL 上，得到完整的 URL：
- en: '[PRE50]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Finally, I take advantage of the Groovy JDK. In the Groovy JDK the `String`
    class contains a method called `toURL`, which converts the `String` into an instance
    of `java.net.URL`. The `URL` class in the Groovy JDK includes a `getText` method,
    which I can invoke as a `text` property.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我利用 Groovy JDK。在 Groovy JDK 中，`String` 类包含一个名为 `toURL` 的方法，它将 `String` 转换为
    `java.net.URL` 实例。Groovy JDK 中的 `URL` 类包括一个 `getText` 方法，我可以作为 `text` 属性调用它。
- en: '|  |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Property access
  id: totrans-603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 属性访问
- en: In Groovy, the standard idiom is to access a property, which is automatically
    converted to a getter or setter method.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Groovy 中，标准习惯是访问一个属性，它会被自动转换为 getter 或 setter 方法。
- en: '|  |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The code to retrieve the desired CSV string is
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 获取所需 CSV 字符串的代码是
- en: '[PRE51]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now I can use the `split` method on String, which divides the string at the
    commas and returns a list containing the elements. I can then take advantage of
    Groovy’s cool multivalued return capability to assign each value to an output
    variable.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以对字符串使用 `split` 方法，它会在逗号处分割字符串并返回一个包含元素的列表。然后，我可以利用 Groovy 的酷炫多值返回功能，将每个值分配给一个输出变量。
- en: 'The complete script is shown next and displayed graphically in [figure 3.3](#ch03fig03):'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本如下，并在[图 3.3](#ch03fig03)中图形化展示：
- en: '[PRE52]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Figure 3.3\. The Groovy script for accessing the Google V2 geocoder
  id: totrans-611
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.3\. 访问 Google V2 地理编码器的 Groovy 脚本
- en: '![](03fig03_alt.jpg)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig03_alt.jpg)'
- en: Running this script requires me to supply the street, city, and state information,
    and then retrieve the output latitude and longitude. I want to use Java to supply
    the input values and process the output, but first I’ll show a typical result,
    which can then be used as a test case. To avoid being too U.S.-centric I’ll use
    the address for the Royal Observatory in Greenwich, England. That makes the values
    for `street`, `city`, and `state` “Blackheath Avenue,” “Greenwich,” and “UK,”
    respectively.^([[5](#ch03fn05)]) Executing the script results in the output
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本需要我提供街道、城市和州的信息，然后检索输出纬度和经度。我想使用 Java 提供输入值并处理输出，但首先我会展示一个典型结果，然后可以作为测试用例使用。为了避免过于以美国为中心，我将使用位于英国格林尼治的皇家天文台的地址。这使得
    `street`、`city` 和 `state` 的值分别为“Blackheath Avenue”、“Greenwich”和“UK”。^([[5](#ch03fn05)])
    执行脚本的结果如下
- en: ⁵ Clearly the word “state” is to be interpreted broadly. Supply a country name
    for state, and it works all over the world.
  id: totrans-614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 显然，“状态”一词应被广泛解释。提供一个国家名称作为状态，它将在全球范围内工作。
- en: '[PRE53]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The Royal Observatory was originally the arbitrarily chosen location of the
    prime meridian, so the value of the longitude should be pretty close to zero,
    and it is. The input address isn’t as precise as it might be, and the observatory
    address doesn’t define the actual prime meridian any more, but the results are
    pretty impressive anyway. The resulting test case as part of a JUnit 4 test is
    shown in the next listing.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 皇家天文台最初是任意选择的子午线位置，因此经度的值应该非常接近零，确实如此。输入地址并不像可能的那样精确，天文台的地址也不再定义实际的子午线，但结果仍然相当令人印象深刻。作为
    JUnit 4 测试的一部分，下一个列表显示了生成的测试用例。
- en: Listing 3.3\. A JUnit test case to check the JSR 223 script engine results
  id: totrans-617
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3\. 一个用于检查 JSR 223 脚本引擎结果的 JUnit 测试用例
- en: '![](055fig01_alt.jpg)'
  id: totrans-618
  prefs: []
  type: TYPE_IMG
  zh: '![](055fig01_alt.jpg)'
- en: The result is the same as running the Groovy script by itself using Groovy.
    Setting the values of the input variables is trivial. The output variables need
    to be cast to the `String` type and then converted to `double`s, but again the
    process is straightforward. If your goal is to execute an external Groovy script
    from Java without introducing any Groovy dependencies at all (other than adding
    the groovy-all JAR to your classpath), this mechanism works just fine.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与单独使用 Groovy 运行 Groovy 脚本相同。设置输入变量的值是微不足道的。输出变量需要转换为 `String` 类型，然后转换为 `double`，但这个过程同样简单。如果你的目标是完全从
    Java 中执行外部 Groovy 脚本（除了将 groovy-all JAR 添加到类路径之外，不引入任何 Groovy 依赖），这个机制工作得很好。
- en: In the next section I want to relax that requirement. If you’re willing to use
    some classes from the Groovy standard library, life gets simpler.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我想放宽这个要求。如果你愿意使用一些来自 Groovy 标准库的类，生活就会变得简单。
- en: 3.2.2\. Working with the Groovy Eval class
  id: totrans-621
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. 使用 Groovy Eval 类
- en: There are two special classes in the Groovy library, `groovy.util.Eval` and
    `groovy` `.lang.GroovyShell`, specifically designed for executing scripts. In
    this section I’ll show examples using the `Eval` class, and in the next section
    I’ll show `GroovyShell`. In each case, the goal is still to invoke external Groovy
    scripts from Java.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 库中有两个特殊类，`groovy.util.Eval` 和 `groovy.lang.GroovyShell`，专门设计用于执行脚本。在本节中，我将使用
    `Eval` 类的示例，在下一节中，我将展示 `GroovyShell`。在每种情况下，目标仍然是调用 Java 中的外部 Groovy 脚本。
- en: The `Eval` class is a utility class (all its methods are static) for executing
    operations that take none, one, two, or three parameters. The relevant methods
    are shown in [table 3.1](#ch03table01).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '`Eval` 类是一个实用工具类（所有方法都是静态的），用于执行接受零个、一个、两个或三个参数的操作。相关方法在 [表 3.1](#ch03table01)
    中显示。'
- en: Table 3.1\. Static methods in `groovy.util.Eval` for executing Groovy from Java
  id: totrans-624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 3.1\. `groovy.util.Eval` 中用于从 Java 执行 Groovy 的静态方法
- en: '| Eval.me | Overloaded to take a String expression or an expression with a
    String symbol and an Object |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
  zh: '| Eval.me | 重载以接受一个字符串表达式或一个包含字符串符号和对象的表达式 |'
- en: '| Eval.x | One argument: the value of x |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '| Eval.x | 一个参数：x 的值 |'
- en: '| Eval.xy | Two arguments, x and y |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '| Eval.xy | 两个参数，x 和 y |'
- en: '| Eval.xyz | Three arguments, x, y, and z |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '| Eval.xyz | 三个参数，x、y 和 z |'
- en: To demonstrate the methods I’ll add additional tests to the JUnit test case.
    The test is written in Java, so I’ll automatically call Groovy from Java.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这些方法，我将在 JUnit 测试用例中添加额外的测试。测试是用 Java 编写的，所以我将自动从 Java 调用 Groovy。
- en: The following listing shows four tests, one for each of the static methods in
    the `Eval` class.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了四个测试，每个测试对应于 `Eval` 类中的静态方法。
- en: Listing 3.4\. JUnit 4 test class verifying results of calling `Eval` methods
    from Java
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.4\. JUnit 4 测试类验证从 Java 调用 `Eval` 方法的结果
- en: '![](056fig01_alt.jpg)'
  id: totrans-632
  prefs: []
  type: TYPE_IMG
  zh: '![](056fig01_alt.jpg)'
- en: In each test the Groovy script to be evaluated is included as a string. Unlike
    the `ScriptEngine` there’s no overload for instances of `Reader`, so to execute
    a script in a separate file would require reading the file into a string. The
    methods also assume that the input variables are called `x`, `y`, and `z`, which
    might be asking too much. Still, it’s interesting that this mechanism exists at
    all.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试中，要评估的 Groovy 脚本都包含为一个字符串。与 `ScriptEngine` 不同，没有为 `Reader` 实例提供重载，因此要执行一个单独文件中的脚本，需要将文件读入一个字符串。这些方法还假设输入变量被命名为
    `x`、`y` 和 `z`，这可能要求过多。尽管如此，这个机制的存在本身就很令人感兴趣。
- en: In addition to illustrating the mechanics of calling Groovy scripts from Java,
    the tests also demonstrate operator overloading in the `String` class. The minus
    operator in Groovy corresponds to the `minus` method in `String`. Its implementation
    to remove the first instance of its argument from the given string is used with
    strings to remove instances of substrings. In Groovy, strings can be contained
    within either single or double quotes. Single-quoted strings are regular Java
    strings, and double-quoted strings are parameterized strings, diplomatically called
    Groovy strings, but formally called, unfortunately, `GString`s.^([[6](#ch03fn06)])
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 除了说明从 Java 调用 Groovy 脚本的机制外，这些测试还展示了 `String` 类中的运算符重载。Groovy 中的减号运算符对应于 `String`
    中的 `minus` 方法。其实现用于从给定字符串中移除其参数的第一个实例，与字符串一起使用以移除子字符串的实例。在 Groovy 中，字符串可以包含在单引号或双引号内。单引号字符串是常规的
    Java 字符串，双引号字符串是参数化字符串，礼貌地称为 Groovy 字符串，但正式名称不幸地是 `GString`.^([[6](#ch03fn06)])
- en: ⁶ To make matters worse, simple parameters are injected into `GString`s using
    a dollar sign. This has led to far too many “insert a $ into a GString” jokes.
    To me, this is a clear demonstration that we don’t have enough women in computer
    science. Don’t you think that if there had been one woman on the team at the time,
    she could have said, “Hey, that’s a funny joke, but let’s not build it into the
    standard library that’s going to be used by everybody forever?” After all, it’s
    hard enough to get a language named Groovy taken seriously by the Fortune 500
    without going there, too. For my part, I call them Groovy strings, which is what
    the class should have been called all along. It is a funny joke, though—for about
    10 minutes.
  id: totrans-635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ 要更糟糕的是，简单的参数使用美元符号注入到`GString`中。这导致了太多的“在GString中插入一个$”笑话。对我来说，这是一个明显的证明，我们计算机科学领域女性不足。你不认为如果当时团队中有一个女性，她可能会说，“嘿，那是个有趣的笑话，但让我们不要将其构建成将被所有人永久使用的标准库中吗？”毕竟，在没有这样做的情况下，让Groovy语言被《财富》500强认真对待已经足够困难了。就我而言，我称它们为Groovy字符串，这正是这个类本应被称呼的。虽然这是个有趣的笑话，但也就持续了大约10分钟。
- en: The process of using `Eval` from Java is shown in [figure 3.4](#ch03fig04).
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java中的`Eval`的过程在[图3.4](#ch03fig04)中展示。
- en: Figure 3.4\. Java calls the me, `x, xy`, or `xyz` method in the Groovy `Eval`
    class to execute a script.
  id: totrans-637
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4\. Java在Groovy的`Eval`类中调用`me`、`x`、`xy`或`xyz`方法来执行脚本。
- en: '![](03fig04_alt.jpg)'
  id: totrans-638
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig04_alt.jpg)'
- en: The `Eval` class is convenient and simple, but often it’s too simple. It rests
    on a more powerful foundation, the `GroovyShell` class, which I’ll discuss next.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '`Eval`类方便且简单，但通常过于简单。它建立在更强大的基础之上，即`GroovyShell`类，我将在下一节中讨论它。'
- en: 3.2.3\. Working with the GroovyShell class
  id: totrans-640
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.3\. 使用`GroovyShell`类
- en: The `GroovyShell` class is used for scripts that aren’t restricted to the special
    cases described in the previous section on `Eval`. The class `groovy.lang.GroovyShell`
    can be used to execute scripts, particularly when combined with a `Binding`.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroovyShell`类用于那些不受上一节中描述的`Eval`特殊情况的限制的脚本。`groovy.lang.GroovyShell`类可以用来执行脚本，尤其是当与`Binding`结合使用时。'
- en: 'Unlike `Eval`, the `GroovyShell` class does not contain only static methods.
    It needs to be instantiated before invoking its `evaluate` method. As a simple
    example, consider adding the following test to the previous set of test cases:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Eval`类不同，`GroovyShell`类不仅包含静态方法。在调用其`evaluate`方法之前，需要先实例化它。作为一个简单的例子，可以考虑向之前的测试用例集中添加以下测试：
- en: '[PRE54]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `evaluate` method is heavily overloaded. The version I’m using here takes
    a string representing the script to be evaluated. Other overloads take a `java.io.File`
    or a `java.io.Reader` instance, with various additional arguments. There are overloads
    that take a `java.io.InputStream` as well, but they’re deprecated due to possible
    encoding issues.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '`evaluate`方法重载很多。我在这里使用的是接受一个表示要评估脚本的字符串的版本。其他重载接受一个`java.io.File`或`java.io.Reader`实例，以及各种附加参数。还有一些重载接受`java.io.InputStream`作为参数，但由于可能的编码问题，它们已被弃用。'
- en: So far, using the `GroovyShell` looks a lot like using the `ScriptEngine` class,
    though you can instantiate it directly in this case. To deal with input and output
    variables, however, the `GroovyShell` uses the `groovy.lang.Binding` class to
    provide a map of input and output variables.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，使用`GroovyShell`看起来很像使用`ScriptEngine`类，尽管在这种情况下可以直接实例化它。然而，为了处理输入和输出变量，`GroovyShell`使用`groovy.lang.Binding`类提供一个输入和输出变量的映射。
- en: The next listing shows the `Binding` and `GroovyShell` classes in action. It’s
    another test to add to the growing JUnit 4 test case.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了`Binding`和`GroovyShell`类的实际应用。这是要添加到不断增长的JUnit 4测试用例集中的另一个测试。
- en: Listing 3.5\. Using `GroovyShell` and `Binding` to invoke the Google geocoder
  id: totrans-647
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.5\. 使用`GroovyShell`和`Binding`调用Google地理编码器
- en: '![](058fig01_alt.jpg)'
  id: totrans-648
  prefs: []
  type: TYPE_IMG
  zh: '![图片](058fig01_alt.jpg)'
- en: Passing parameters into the script is easy enough using the `setVariable` method
    on the `Binding`. The binding is then used as an argument to the `GroovyShell`
    constructor. The script is run from Java using the `evaluate` method as usual,
    and the results are extracted by getting the output variables from the shell.
    Using a `GroovyShell` and `Binding` is illustrated in [figure 3.5](#ch03fig05).
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Binding`上的`setVariable`方法将参数传递到脚本中很容易。然后，绑定被用作`GroovyShell`构造函数的参数。脚本通常使用`evaluate`方法从Java中运行，并通过从shell中获取输出变量来提取结果。使用`GroovyShell`和`Binding`的示例在[图3.5](#ch03fig05)中展示。
- en: Figure 3.5\. Java code sets variables in the `Binding`, which is used in the
    `GroovyShell` to execute Groovy code. The results are returned via the `getVariable`
    method in the `Binding`.
  id: totrans-650
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.5\. Java代码在`Binding`中设置变量，该变量用于`GroovyShell`执行Groovy代码。结果通过`Binding`中的`getVariable`方法返回。
- en: '![](03fig05_alt.jpg)'
  id: totrans-651
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig05_alt.jpg)'
- en: There’s more to the `GroovyShell` than I’m presenting here. I can use the `parse`
    method, rather than `evaluate`, to parse the script and retrieve a reference to
    the generated `Script` object. That way I can set the binding variables and rerun
    the script without having to recompile every time. `GroovyShell` also works with
    a hierarchy of classloaders and configurations. Allthough all of that is interesting,
    it doesn’t really add a lot to the integration story, so I’ll refer you to Dierk
    Koenig’s most excellent *Groovy in Action* for details.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroovyShell`的功能远不止我这里所展示的。我可以使用`parse`方法而不是`evaluate`来解析脚本并检索生成的`Script`对象的引用。这样，我可以在不每次都需要重新编译的情况下设置绑定变量并重新运行脚本。`GroovyShell`还可以与类加载器和配置的层次结构一起工作。尽管所有这些都很有趣，但它们并没有真正为集成故事增添很多内容，所以我会将你引荐到Dierk
    Koenig的杰出的*Groovy in Action*以获取详细信息。'
- en: '|  |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The Hard Way
  id: totrans-654
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 困难方式
- en: Use the `ScriptEngine` class from Java, or the `Eval` and `GroovyS``hell` classes
    from Groovy, along with a `Binding` if necessary, to call Groovy scripts from
    Java.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java中的`ScriptEngine`类，或者Groovy中的`Eval`和`GroovyShell`类，如果需要的话，还可以使用`Binding`，从Java中调用Groovy脚本。
- en: '|  |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Between the `ScriptEngine`, `Eval`, and `GroovyShell` classes, hopefully you’ll
    agree that there are a variety of ways to execute Groovy scripts from Java. Collectively
    I still refer to this as “the hard way,” though it isn’t terribly hard, but it’s
    awfully indirect compared to the easy way. From now on I’ll stop trying to maintain
    the artificial separation of Java code from Groovy code. In order to make progress
    all I need to do is put the Groovy code into a class.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ScriptEngine`、`Eval`和`GroovyShell`类之间，希望你会同意，从Java执行Groovy脚本有各种方法。总的来说，我仍然称这为“困难的方式”，尽管它并不特别困难，但与简单的方式相比，它非常间接。从现在开始，我将停止尝试维持Java代码和Groovy代码之间的人工分离。为了取得进展，我只需要将Groovy代码放入一个类中。
- en: 3.2.4\. Calling Groovy from Java the easy way
  id: totrans-658
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.4\. 从Java简单调用Groovy
- en: All the techniques I’ve discussed so far—using the JSR 223 `ScriptEngine`, or
    using the Groovy API classes `Eval` and `GroovyShell`—work just fine but feel
    overly complicated. Groovy is supposed to simplify your life, so although the
    mechanisms shown in the previous section all work, for most use cases there’s
    an easier way.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我讨论的所有技术——使用JSR 223 `ScriptEngine`，或者使用Groovy API类`Eval`和`GroovyShell`——都运行得很好，但感觉过于复杂。Groovy应该简化你的生活，所以尽管上一节中展示的所有机制都有效，但对于大多数用例来说，还有更简单的方法。
- en: The easiest way to call Groovy from Java is to put the Groovy code in a class
    and compile it. Then Java code can instantiate the class and invoke its methods
    the normal way.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java调用Groovy的最简单方法是将其放入一个类中并编译它。然后Java代码可以实例化该类并正常调用其方法。
- en: '|  |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The Easy Way
  id: totrans-662
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简单方式
- en: To call Groovy from Java, put the Groovy code in a class, compile it as usual,
    and then instantiate it and invoke methods as though it was Java.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Java调用Groovy，将Groovy代码放入一个类中，像往常一样编译它，然后实例化它并像调用Java一样调用其方法。
- en: '|  |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Let’s return, once again, to the geocoder. This time, however, I’ll refactor
    it into a class that can be instantiated, with methods that can be invoked from
    outside. The process is shown in [figure 3.6](#ch03fig06).
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回到地理编码器。然而，这次，我将它重构为一个可以被实例化的类，具有可以从外部调用的方法。这个过程在[图3.6](#ch03fig06)中展示。
- en: Figure 3.6\. Mixing Java and Groovy classes. The Java app instantiates a Location
    and supplies it with street, city, and state values. It sends the new Location
    to the Groovy geocoder, whose `fillInLatLng` method supplies the latitude and
    longitude, which can then be retrieved by Java again.
  id: totrans-666
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.6\. 混合Java和Groovy类。Java应用程序实例化一个Location对象，并向其提供街道、城市和州的信息。它将新的Location对象发送到Groovy地理编码器，其`fillInLatLng`方法提供纬度和经度，然后Java可以再次检索。
- en: '![](03fig06.jpg)'
  id: totrans-667
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig06.jpg)'
- en: As the figure shows, the Java application will use a `Location` class to store
    all the needed attributes. It will supply the `street`, `city`, and `state` fields
    as input parameters, but the `Location` class will also include `latitude` and
    `longitude` fields that will be updated by the Groovy geocoder. The geocoder itself
    will be written in Groovy, because it’s easy to write the RESTful web service
    client code that way.^([[7](#ch03fn07)])
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，Java 应用程序将使用 `Location` 类来存储所有需要的属性。它将提供 `street`、`city` 和 `state` 字段作为输入参数，但
    `Location` 类还将包括 `latitude` 和 `longitude` 字段，这些字段将由 Groovy 地理编码器更新。地理编码器本身将用 Groovy
    编写，因为用这种方式编写 RESTful 网络服务客户端代码很容易.^([[7](#ch03fn07)])
- en: ⁷ Note this is just like the geocoder with the `Stadium` class used in [chapter
    2](kindle_split_012.html#ch02) when I discussed the Groovy Baseball application.
    The differences here are the CSV output and that I’m invoking the Groovy implementation
    from Java.
  id: totrans-669
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷ 注意这与第 2 章中使用的 `Stadium` 类的地理编码器非常相似，当时我讨论了 Groovy 棒球应用程序。这里的区别是 CSV 输出，以及我从
    Java 中调用 Groovy 实现的情况。
- en: 'Here’s the new `Location` class, which could be written in either Java or Groovy.
    This time, to keep the code simple I’ll use a Groovy POGO:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的 `Location` 类，它可以写成 Java 或 Groovy。这次，为了使代码简单，我将使用 Groovy POGO：
- en: '[PRE55]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `Location` class encapsulates the address information in strings and provides
    double variables for the latitude and longitude values that will be set using
    the geocoder. Speaking of the geocoder, the next listing shows a revised version
    that wraps the script into a class.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '`Location` 类封装了地址信息为字符串，并为使用地理编码器设置的纬度和经度值提供了双精度浮点变量。说到地理编码器，下一个列表显示了将脚本包装成类的修订版。'
- en: Listing 3.6\. A Groovy class for geocoding
  id: totrans-673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.6\. 一个用于地理编码的 Groovy 类
- en: '[PRE56]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `fillInLatLong` method takes a `Location` as an argument. Strictly speaking,
    I didn’t have to declare a type for the parameter at all. I could have relied
    on duck typing within the method and just been careful not to call it with anything
    other than an object with street, city, and state properties. Still, I’m building
    the service with a `Location` in mind, so it doesn’t hurt to say so.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillInLatLong` 方法接受一个 `Location` 作为参数。严格来说，我根本不需要为参数声明类型。我可以在方法内部依赖鸭子类型，并小心不要用除了具有街道、城市和州属性的对象之外的其他任何东西调用它。尽管如此，我是在考虑
    `Location` 的前提下构建服务的，所以这样说并无害处。'
- en: The `addressFields` variable uses the ternary operator to determine whether
    or not a street has been supplied when returning the collection of address components.
    Note that I’m appealing to the so-called “Groovy truth” here, in that I don’t
    need to compare `loc.street` to `null` or an empty string explicitly. Any non-blank
    value of the `street` field as part of the `loc` argument will return true, so
    it will be added to the collection.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '`addressFields` 变量使用三元运算符来确定在返回地址组件集合时是否提供了街道。请注意，我在这里依赖于所谓的“Groovy 真实性”，即我无需显式地将
    `loc.street` 与 `null` 或空字符串进行比较。`loc` 参数作为街道字段的一部分的任何非空值都将返回 true，因此它将被添加到集合中。'
- en: The rest of the class is the same as the previous script, though to make the
    class more useful I went to the trouble of converting the string results to doubles
    before returning the location.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 类的其余部分与之前的脚本相同，尽管为了使类更有用，我费尽心思在返回位置之前将字符串结果转换为双精度浮点数。
- en: One final issue is notable, and it highlights an important difference between
    a script and a class. All of the variables, whether they are local variables or
    attributes, have to be declared. There are no undefined variables, so there’s
    also no binding to worry about any more.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题是值得注意的，它突出了脚本和类之间的重要区别。所有变量，无论是局部变量还是属性，都必须声明。没有未定义的变量，因此也不再需要担心任何绑定。
- en: 'How do I use these classes (`Geocoder` and `Location`) from Java? Just instantiate
    them and call methods as usual. In the previous section I started accumulating
    JUnit 4 tests into a test class. Here’s another test to add to that set:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 我如何从 Java 中使用这些类（`Geocoder` 和 `Location`）？只需实例化它们，并像往常一样调用方法。在前一节中，我开始将 JUnit
    4 测试积累到一个测试类中。这里还有一个要添加到该集合的测试：
- en: '[PRE57]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It doesn’t get much easier than that. I don’t need to instantiate a script engine
    or worry about Groovy shells or class loaders. Just instantiate and populate a
    `Location`, instantiate a `Geocoder`, and invoke the desired method.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比这更容易了。我不需要实例化脚本引擎或担心 Groovy 壳或类加载器。只需实例化和填充一个 `Location`，实例化一个 `Geocoder`，并调用所需的方法。
- en: From now on all of the examples I show will do integration the easy way. Again,
    this isn’t a value judgment against all the techniques demonstrated earlier in
    the chapter. If you want to call an existing Groovy script from Java, or you’re
    required to keep Java and Groovy code separate in your application, the previous
    mechanisms all work. Freely intermixing classes the way this script does, however,
    is very easy.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我将展示的所有示例都将使用简单的方式进行集成。再次强调，这并不是对章节中先前展示的所有技术的价值判断。如果你想要从 Java 调用一个现有的
    Groovy 脚本，或者你需要在应用程序中保持 Java 和 Groovy 代码的分离，那么先前的机制仍然有效。然而，像这个脚本一样自由混合类是非常容易的。
- en: One last issue remains before I start looking at how Groovy might help Java.
    So far in this chapter the goal was always to call Groovy from Java. What about
    the other direction? How do you call Java from Groovy?
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始探讨 Groovy 如何帮助 Java 之前，还有一个问题需要解决。到目前为止，本章的目标始终是从 Java 调用 Groovy。那么反方向呢？如何从
    Groovy 调用 Java？
- en: 3.2.5\. Calling Java from Groovy
  id: totrans-684
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.5\. 从 Groovy 调用 Java
- en: Actually, this is so easy it hardly deserves a section at all. I’ve already
    shown it more than once. Remember the earlier example using the Google V2 geocoder
    (reproduced here for convenience)?
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这太简单了，几乎不值得作为一个章节。我已经多次展示了它。还记得之前使用 Google V2 地理编码器的例子（为了方便在此重现）？
- en: '![](062fig01_alt.jpg)'
  id: totrans-686
  prefs: []
  type: TYPE_IMG
  zh: '![图片](062fig01_alt.jpg)'
- en: The integration is already here through the use of the library class and various
    Java methods. I needed to pass the address to Google in URL-encoded form. To do
    that I ran each element of the address (street, city, and state) through the `java.net.URL-Encoder`,
    using its `encode` method. In other words, the Groovy script used a Java library
    class and called one of its methods.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用库类和各种 Java 方法，集成已经存在。我需要以 URL 编码形式将地址传递给 Google。为此，我将地址的每个元素（街道、城市和州）通过
    `java.net.URLEncoder` 的 `encode` 方法进行编码。换句话说，Groovy 脚本使用了 Java 库类并调用了其方法之一。
- en: '|  |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lessons learned (integration)**'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习到的经验（集成）**'
- en: '**1**.  Groovy scripts can be called with Java alone using the JSR 223 script
    engine.'
  id: totrans-690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. Groovy 脚本可以使用 Java 的 JSR 223 脚本引擎调用。'
- en: '**2**.  The Groovy `Eval` class makes calling scripts involving zero, one,
    two, or three arguments simple.'
  id: totrans-691
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. Groovy 的 `Eval` 类使得调用涉及零、一、二或三个参数的脚本变得简单。'
- en: '**3**.  The `GroovyShell` and `Binding` classes are used to programmatically
    set input variables, invoke a script, and retrieve its result.'
  id: totrans-692
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 使用 `GroovyShell` 和 `Binding` 类可以编程设置输入变量，调用脚本，并检索其结果。'
- en: '**4**.  The easiest way to call Groovy from Java is to make a Groovy class,
    compile it, instantiate it in Java, and call the methods as usual.'
  id: totrans-693
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 从 Java 调用 Groovy 最简单的方法是创建一个 Groovy 类，编译它，然后在 Java 中实例化它，并像往常一样调用方法。'
- en: '|  |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The combination of Java and Groovy is also emphasized in [Figure 3.3](#ch03fig03),
    shown with the original listing. In that figure each Java method and each Groovy
    method is indicated with arrows.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: Java 和 Groovy 的结合也在 [图 3.3](#ch03fig03) 中得到强调，如图所示，原始列表中每个 Java 方法以及每个 Groovy
    方法都用箭头表示。
- en: The fact that the script mixes both Java and Groovy is true of practically any
    Groovy script. Groovy rests on the foundation of the Java libraries. It enhances
    those libraries, as you’ll see in [section 4.3](kindle_split_014.html#ch04lev1sec3)
    on the Groovy JDK, but there’s no need to re-invent the flat tire.^([[8](#ch03fn08)])
    Groovy is perfectly happy to use any Java classes you supply, and it makes many
    of them better.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本混合了 Java 和 Groovy 的做法几乎适用于任何 Groovy 脚本。Groovy 建立在 Java 库的基础上。正如你将在 [4.3 节](kindle_split_014.html#ch04lev1sec3)
    中看到的，它增强了这些库，但不需要重新发明轮子。[8](#ch03fn08)] Groovy 完全可以使用你提供的任何 Java 类，并且使许多类变得更好。
- en: ⁸ Re-inventing the flat tire is what happens when you try to re-invent the wheel
    and get it wrong.
  id: totrans-697
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸ 重新发明轮子却做错了，这就是重新发明平轮胎的情况。
- en: '|  |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Compile with groovyc
  id: totrans-699
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 groovyc 编译
- en: Whenever you mix Java and Groovy, compile everything with `groovyc`. Let `groovyc`
    handle all the cross-compiler issues.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你混合使用 Java 和 Groovy 时，请使用 `groovyc` 编译所有内容。让 `groovyc` 处理所有跨编译器问题。
- en: '|  |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the next chapter I’ll look at some of the ways Groovy improves Java.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将探讨 Groovy 如何改进 Java 的几种方法。
- en: '|  |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Don’t separate Groovy and Java classes**'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要将 Groovy 和 Java 类分开**'
- en: The natural tendency when using two different languages is to separate the two
    codebases and compile them independently. With Groovy and Java that can lead to
    all sorts of problems, especially when cyclic dependencies are involved (in other
    words, Java class `A` uses Groovy class `B`, which invokes another method from
    Java class `A`, and so on). Maven projects in particular lead you down this path,
    because their default layouts naturally suggest putting Java code under src/main/java
    and Groovy code under src/main/groovy. The idea then is to use `javac` to compile
    the Java code and `groovyc` to compile the Groovy code.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两种不同的语言时，自然的倾向是将两个代码库分开，并独立编译它们。使用Groovy和Java可能会导致各种问题，尤其是在涉及循环依赖时（换句话说，Java类`A`使用Groovy类`B`，它又调用了Java类`A`的另一个方法，依此类推）。特别是Maven项目会引导你走这条路，因为它们的默认布局自然建议将Java代码放在`src/main/java`下，将Groovy代码放在`src/main/groovy`下。然后的想法是使用`javac`编译Java代码，使用`groovyc`编译Groovy代码。
- en: Although you probably can get that to work, it makes life much more difficult
    than it needs to be. The developers of Groovy have worked hard on the cross-compilation
    issue for years. It’s better for us, as users of both languages, to take advantage
    of their progress.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能能让它工作，但这会让生活变得比必要的更困难。Groovy的开发者多年来一直在努力解决交叉编译的问题。对我们这些两种语言的使用者来说，利用他们的进步会更好。
- en: The simplest way to compile Groovy and Java in the same project is to let the
    `groovyc` compiler handle both codebases. Groovy knows all about Java and is quite
    capable of handling it. Any compiler flags you would normally send to `javac`
    work just fine in `groovyc` as well. This is actually a good general principle.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个项目中编译Groovy和Java的最简单方法是由`groovyc`编译器处理这两个代码库。Groovy对Java了如指掌，并且完全能够处理它。你通常发送给`javac`的任何编译器标志在`groovyc`中也同样适用。这实际上是一个好的通用原则。
- en: In the projects in this book I’ll let `groovyc` do all the work. I’ll show specific
    examples of this in [chapter 5](kindle_split_016.html#ch05), but you can safely
    assume I’m using `groovyc` throughout.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的项目中，我会让`groovyc`做所有的工作。我会在[第5章](kindle_split_016.html#ch05)中展示具体的例子，但你可以安全地假设我会在整个过程中使用`groovyc`。
- en: '|  |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 3.3\. Summary
  id: totrans-710
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 摘要
- en: This chapter is about basic Groovy / Java integration, regardless of use case.
    After reviewing all the different ways to call Groovy from Java, from the JSR-223
    `Script-Engine` to the `GroovyShell` and `Eval` classes in Groovy, I switched
    to the easy way, which is to put Groovy in a class and use it like any other library
    class. This easy blend of Java and Groovy will be used from now on.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于基本的Groovy/Java集成，无论使用案例如何。在回顾了从JSR-223 `Script-Engine`到Groovy中的`GroovyShell`和`Eval`类等各种从Java调用Groovy的不同方法之后，我转向了简单的方法，即将Groovy放入一个类中，像使用任何其他库类一样使用它。这种简单的Java和Groovy混合将从现在开始使用。
- en: Next I reviewed many ways that Groovy can help Java at the basic level, from
    POJO enhancements to AST transformations to building XML and more. I’ll use these
    techniques in future chapters wherever they can help. I’ll also review other helpful
    techniques along the way, though these are most of the major ones.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我回顾了许多Groovy在基本级别帮助Java的方法，从POJO增强到AST转换到构建XML等。我将在未来的章节中使用这些技术，只要它们有帮助。我还会在途中回顾其他有用的技术，尽管这些是大多数主要的技术。
- en: Chapter 4\. Using Groovy features in Java
  id: totrans-713
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章\. 在Java中使用Groovy特性
- en: '*This chapter covers*'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Basic code-level simplifications
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的代码级别简化
- en: Useful AST transformations
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的AST转换
- en: XML processing
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML处理
- en: In [chapter 1](kindle_split_011.html#ch01) I reviewed many of Java’s arguable
    weaknesses and drawbacks and suggested ways that Groovy might help ameliorate
    them. Because that chapter was intended to be introductory I only suggested how
    Groovy can help, without showing a lot of code examples. Now that I’ve established
    how easy it is to add Groovy classes to Java applications, when is it helpful
    to do so? What features, if any, does Groovy bring to Java systems that make them
    easier to develop?
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](kindle_split_011.html#ch01)中，我回顾了许多Java的争议性弱点和缺点，并提出了Groovy可能有助于改善它们的方法。因为那一章旨在作为介绍，所以我只建议Groovy如何帮助，而没有展示很多代码示例。现在，既然我已经建立了将Groovy类添加到Java应用程序中的简便性，那么何时这样做是有帮助的呢？Groovy为Java系统带来了哪些特性，使得它们更容易开发？
- en: A guide to the techniques covered in this chapter is shown in [figure 4.1](#ch04fig01).
    I’ll review several Groovy advantages, like POGOs, operator overloading, the Groovy
    JDK, AST transformations, and how to use Groovy to work with XML and JSON data.
    To start, I’ll show that from Groovy code POJOs can be treated as though they
    were POGOs.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的技术指南如图4.1所示。[我将回顾几个Groovy的优势，如POGs、操作符重载、Groovy JDK、AST转换，以及如何使用Groovy处理XML和JSON数据。首先，我会展示从Groovy代码中，POJOs可以被视为POGs。]
- en: Figure 4.1\. Groovy features that can be added to Java classes
  id: totrans-720
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1\. 可添加到Java类中的Groovy特性
- en: '![](04fig01.jpg)'
  id: totrans-721
  prefs: []
  type: TYPE_IMG
  zh: '![04fig01.jpg](04fig01.jpg)'
- en: 4.1\. Treating POJOs like POGOs
  id: totrans-722
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 将POJOs视为POGs
- en: POGOs have more capabilities than POJOs. For example, all POGOs have a map-based
    constructor that’s very convenient for setting properties. The interesting thing
    is that even if a class is written in Java, many of the same conveniences apply
    as long as it’s accessed from Groovy.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: POGOs比POJOs具有更多功能。例如，所有POGs都有一个基于映射的构造函数，这对于设置属性非常方便。有趣的是，即使一个类是用Java编写的，只要从Groovy访问，许多便利性仍然适用。
- en: Consider a simple POJO representing a person, possibly created as part of a
    domain model in Java, shown in the next listing. To keep it simple I’ll only include
    an ID and a name. I’ll put in a `toString` override as well but won’t include
    the inevitable `equals` and `hashCode` overrides.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的POJO，代表一个人，可能是在Java的领域模型中创建的，如下一列表所示。为了保持简单，我只包括ID和名称。我还会添加一个`toString`重写，但不会包括不可避免的`equals`和`hashCode`重写。
- en: Listing 4.1\. A simple POJO representing a person
  id: totrans-725
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.1\. 代表一个人的简单POJO
- en: '[PRE58]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Any typical Java persistence layer has dozens of classes just like this, which
    map to relational database tables ([figure 4.2](#ch04fig02)).
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 任何典型的Java持久层都有数十个这样的类，它们映射到关系数据库表（[图4.2](#ch04fig02)）。
- en: Figure 4.2\. Groovy adds a map-based constructor to Java classes, regardless
    of what constructors are already included.
  id: totrans-728
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2\. Groovy为Java类添加了基于映射的构造函数，无论已经包含哪些构造函数。
- en: '![](04fig02_alt.jpg)'
  id: totrans-729
  prefs: []
  type: TYPE_IMG
  zh: '![04fig02_alt.jpg](04fig02_alt.jpg)'
- en: 'If I instantiate this class from Groovy I can use a map-based^([[1](#ch04fn01)])
    constructor to do so, even though the Java version already specifies two constructors
    and neither is the one I want. The following Groovy script creates some `Person`
    instances using three different mechanisms, none of which appear in the Java class:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我从Groovy中实例化这个类，我可以使用基于映射的构造函数（[[1](#ch04fn01)]）来这样做，尽管Java版本已经指定了两个构造函数，而且都不是我想要的。以下Groovy脚本使用三种不同的机制创建了一些`Person`实例，这些机制在Java类中都没有出现：
- en: ¹ The term *map-based* refers to the fact that the attributes are set using
    the key-value notation used in Groovy maps. The constructor doesn’t actually use
    a map to do its job.
  id: totrans-731
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹术语*基于映射*指的是使用Groovy映射中使用的键值符号设置属性。构造函数实际上并没有使用映射来完成其工作。
- en: '[PRE59]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The instances `buffy` and `faith` are created using the map-based constructor,
    first setting only the `name`, and then setting both the `name` and the `id`.
    I’m then able to verify, using Groovy’s built-in `assert` method (omitting its
    optional parentheses), that the person’s properties are set correctly.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffy`和`faith`实例是使用基于映射的构造函数创建的，首先只设置`name`，然后设置`name`和`id`。然后我能够使用Groovy的内置`assert`方法（省略其可选的括号）验证人的属性是否设置正确。'
- en: 'Incidentally, all the `assert` statements that seem to be accessing private
    properties of the class directly really aren’t. Groovy goes through the getter
    and setter methods provided in the Java class when it looks like properties are
    being accessed or assigned. I can prove this by modifying the implementation of
    the getter method to return more than just the name:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，所有看似直接访问类私有属性的`assert`语句实际上并不是。当看起来正在访问或分配属性时，Groovy会通过Java类中提供的getter和setter方法进行操作。我可以通过修改getter方法的实现来证明这一点，使其返回不仅仅是名称：
- en: '[PRE60]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now I have to modify each of the asserts to include the string "`from` `getter:`
    " for them to still return true.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我必须修改每个断言，包括字符串"`from getter:`"，以便它们仍然返回true。
- en: The third person, `willow`, is constructed using the `as` operator in Groovy.
    This operator has several uses, one of which is to coerce a map into an object
    as shown here. In this case the operator instantiates a person and supplies the
    map as properties for the resulting instance.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个人`willow`是使用Groovy中的`as`运算符构建的。这个运算符有几个用途，其中之一是将映射强制转换为对象，如这里所示。在这种情况下，运算符实例化一个人，并将映射作为属性提供给结果实例。
- en: 'Moving on, I can also add the person instances to a Groovy collection, which
    isn’t all that surprising but has some nice additional benefits. For example,
    Groovy collections support operator overloading, making it easy to add additional
    persons and have additional methods for searching:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我还可以将人实例添加到Groovy集合中，这并不令人惊讶，但有一些额外的优点。例如，Groovy集合支持运算符重载，这使得添加额外的个人和具有额外搜索方法变得容易：
- en: '[PRE61]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Groovy has a native syntax for collections, which simplifies Java code. Putting
    the references inside square brackets creates an instance of the `java.util.ArrayList`
    class and adds each element to the collection. Then, in the `assert` statement,
    I used the so-called “spread-dot” operator to extract the `name` property from
    each instance and return a list of the results (in other words, the spread-dot
    operator behaves the same way `collect` does). By the way, I restored the `getName`
    method to its original form, which returns just the attribute value.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy有一个用于集合的本地语法，这简化了Java代码。将引用放在方括号内创建了一个`java.util.ArrayList`类的实例，并将每个元素添加到集合中。然后，在`assert`语句中，我使用了所谓的“扩展点”运算符来从每个实例中提取`name`属性，并返回一个结果列表（换句话说，扩展点运算符的行为与`collect`相同）。顺便说一句，我将`getName`方法恢复到其原始形式，它只返回属性值。
- en: I was able to use operator overloading to add `willow` to the `slayers` collection,
    resulting in the `characters` collection. Finally, I took advantage of the fact
    that in Groovy, the `java.util.Collection` interface has been augmented to have
    a `findAll` method that returns all instances in the collection matching the condition
    in the provided closure. In this case the closure contains a regular expression
    that matches any repeated lowercase letter.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 我能够使用运算符重载将`willow`添加到`slayers`集合中，从而得到`characters`集合。最后，我利用了在Groovy中，`java.util.Collection`接口已经被扩展，具有一个`findAll`方法，该方法返回所有匹配提供的闭包中条件的集合实例。在这种情况下，闭包包含一个匹配任何重复小写字母的正则表达式。
- en: Many existing Java applications have extensive domain models. As you can see,
    Groovy code can work with them directly, even treating them as POGOs and giving
    you a poor-man’s search capability.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现有的Java应用程序拥有广泛的领域模型。正如你所看到的，Groovy代码可以直接与它们一起工作，甚至可以将它们视为POGOs，并为你提供一种简陋的搜索能力。
- en: 'Now to demonstrate a capability Groovy can add to Java that Java doesn’t even
    support: operator overloading.'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来展示Groovy可以添加到Java中，而Java甚至不支持的功能：运算符重载。
- en: 4.2\. Implementing operator overloading in Java
  id: totrans-744
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 在Java中实现运算符重载
- en: So far I’ve used the fact that both the + and – operators have been overloaded
    in the `String` class. The overloaded + operator in `String` should be familiar
    to Java developers, because it’s the only overloaded operator in all of Java;
    it does concatenation for strings and addition for numerical values. Java developers
    can’t overload operators however they want.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经使用了这样一个事实：在`String`类中，`+`和`-`运算符都被重载了。`String`中的重载`+`运算符对于Java开发者来说应该是熟悉的，因为它是Java中唯一的重载运算符；它用于字符串的连接和数值的加法。然而，Java开发者并不能随意重载运算符。
- en: That’s different in Groovy. In Groovy all operators are represented by methods,
    like the `plus` method for + or the `minus` method for—. You can overload^([[2](#ch04fn02)])
    any operator by implementing the appropriate method in your Groovy class. What
    isn’t necessarily obvious, though, is that you can implement the correct method
    in a Java class, too, and if an instance of that class is used in Groovy code,
    the operator will work there as well (see [figure 4.3](#ch04fig03)).
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 在Groovy中情况不同。在Groovy中，所有运算符都由方法表示，就像`plus`方法用于`+`运算符或`minus`方法用于减法运算符一样。你可以通过在Groovy类中实现适当的方法来重载任何运算符。然而，不一定明显的是，你还可以在Java类中实现正确的方法，如果该类的实例在Groovy代码中使用，运算符也会在那里工作（参见[图4.3](#ch04fig03)）。
- en: ² Incidentally, changing the behavior of operators this way is normally called
    operator *overloading*, because the same operator has different behavior in different
    classes. Arguably, though, what I’m actually doing is operator *overriding*. Effectively
    they’re the same thing here, so I’ll use the terms interchangeably.
  id: totrans-747
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 顺便提一下，以这种方式改变运算符的行为通常被称为运算符*重载*，因为同一个运算符在不同的类中有不同的行为。然而，可以说，我实际上做的是运算符*重写*。实际上，在这里它们是同一件事，所以我会交替使用这些术语。
- en: Figure 4.3\. Groovy operators are implemented as methods, so if the Java class
    contains the right methods, Groovy scripts can use the associated operators on
    their instances.
  id: totrans-748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '图4.3\. Groovy运算符被实现为方法，所以如果Java类包含正确的方法，Groovy脚本就可以在其实例上使用相关的运算符。 '
- en: '![](04fig03_alt.jpg)'
  id: totrans-749
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig03_alt.jpg)'
- en: 'To demonstrate this I’ll create a Java class that wraps a map. A `Department`
    contains a collection of `Employee` instances and will have a `hire` method to
    add them and a `layOff` method to remove them (hopefully not very often). I’ll
    implement operator overloading through three methods: `plus`, `minus`, and `leftShift`.
    Intuitively, `plus` will add a new employee, `minus` will remove an existing employee,
    and `leftShift` will be an alternative way to add. All three methods will allow
    chaining, meaning that they’ll return the modified `Department` instance.'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我将创建一个Java类，它封装一个映射。`Department`包含一组`Employee`实例，并将有一个`hire`方法来添加它们，以及一个`layOff`方法来移除它们（希望不会太频繁）。我将通过三个方法实现运算符重载：`plus`、`minus`和`leftShift`。直观地，`plus`将添加一个新员工，`minus`将移除现有员工，而`leftShift`将是一种添加的替代方式。所有三个方法都将允许链式调用，这意味着它们将返回修改后的`Department`实例。
- en: 'Here’s the `Employee` class, which is just the `Person` POJO by another name:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Employee`类，它只是另一个名字的`Person` POJO：
- en: '[PRE62]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now for the `Department` class, shown in the following listing, which maintains
    the employee collection in a `Map` keyed to the employee `id` values.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`Department`类，如下所示，它在一个以员工`id`值为键的`Map`中维护员工集合。
- en: Listing 4.2\. A `Department` with a map of `Employees` and operator overriding
  id: totrans-754
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.2\. 一个包含`Employees`映射和运算符重载的`Department`
- en: '![](068fig01_alt.jpg)'
  id: totrans-755
  prefs: []
  type: TYPE_IMG
  zh: '![](068fig01_alt.jpg)'
- en: By the way, notice that the `plus` method doesn’t add two `Department` instances;
    rather, it adds an `Employee` to a `Department`. Groovy only cares about the name
    of the method for the operator.^([[3](#ch04fn03)])
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，请注意，`plus`方法不是添加两个`Department`实例；相反，它将一个`Employee`添加到`Department`中。Groovy只关心方法名来执行运算符.^([[3](#ch04fn03)])
- en: ³ As an example from the Groovy JDK, the `java.util.Date` class has a `plus`
    method that takes an integer representing the number of days. See also the `multiply`
    method in `Collection` that takes an integer.
  id: totrans-757
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 作为Groovy JDK的一个例子，`java.util.Date`类有一个`plus`方法，它接受一个表示天数的整数。还可以参考`Collection`中的`multiply`方法，它也接受一个整数。
- en: To test this I’ll use the Spock testing framework. As in [chapter 1](kindle_split_011.html#ch01),
    I’ll present the test without going into much detail about the Spock framework
    itself, which I’ll deal with in [chapter 6](kindle_split_017.html#ch06). Fortunately,
    Spock tests are easy to read even if you don’t know the details. The next listing
    shows a Spock test that’s focused on just the operator methods.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我将使用Spock测试框架。正如[第1章](kindle_split_011.html#ch01)中所述，我将展示测试，而不会过多地详细介绍Spock框架本身，这将在[第6章](kindle_split_017.html#ch06)中处理。幸运的是，即使不了解细节，Spock测试也很容易阅读。下一个列表显示了一个专注于运算符方法的Spock测试。
- en: Listing 4.3\. A Spock test to check the operator overloading methods in a Java
    class
  id: totrans-759
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.3\. 检查Java类中运算符重载方法的Spock测试
- en: '[PRE63]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The Spock test is written in Groovy, so I can use +, –, and << and know that
    the associated methods will be used, even though they’re implemented in a Java
    class.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: Spock测试是用Groovy编写的，因此我可以使用+、-和<<，并且知道将使用相关的方法，即使它们是在Java类中实现的。
- en: The list of operators that can be overridden in Groovy includes `plus`, `minus`,
    and `leftShift`, as shown in the listing, and many others as well. You can implement
    array-like access through an index by implementing `getAt`, for example. Pre-and
    post-increment are implemented through the `next` and `previous` methods, respectively.
    The spaceship operator, <=>, is implemented through `compareTo`. You can even
    override the dot operator, believe it or not. The cool part is that you can implement
    these methods in either POJOs or POGOs, and Groovy will take advantage of them
    either way.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy中可以重载的运算符列表包括`plus`、`minus`和`leftShift`，如列表所示，以及许多其他运算符。你可以通过实现`getAt`等来通过索引实现类似数组的访问。通过`next`和`previous`方法分别实现前置和后置递增。通过`compareTo`实现关系运算符`<=>`。甚至可以重载点运算符，信不信由你。酷的地方在于，你可以在POJOs或POGs中实现这些方法，Groovy会利用它们。
- en: 'The next feature of Groovy that simplifies Java is one I’ve taken advantage
    of several times already: the Groovy JDK.'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy的下一个简化Java的功能是我已经多次利用过的：Groovy JDK。
- en: '4.3\. Making Java library classes better: the Groovy JDK'
  id: totrans-764
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 使Java库类更好的方法：Groovy JDK
- en: Every Groovy class contains a metaclass. In addition to providing information
    about a class, the metaclass contains methods that come into play if a method
    or property that doesn’t exist is accessed through an instance. By intercepting
    those method or property “missing” failures, developers can provide whatever they
    want.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Groovy类都包含一个元类。除了提供有关类的信息外，元类还包含在通过实例访问不存在的方法或属性时发挥作用的方法。通过拦截那些方法或属性“缺失”失败，开发者可以提供他们想要的任何内容。
- en: One application of this is for Groovy to add methods to existing classes. This
    is especially useful when you want to add methods to classes where you cannot
    change the source code. As mentioned earlier, Groovy makes extensive use of the
    existing Java standard libraries. It does not, however, simply use them as it
    finds them. In many cases, a range of new methods has been added to the Java libraries
    to make them easier and more powerful.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 这种应用之一是Groovy向现有类添加方法。当你想要向无法更改源代码的类添加方法时，这特别有用。如前所述，Groovy广泛使用了现有的Java标准库。然而，它并不是简单地使用它们。在许多情况下，已经向Java库添加了一系列新方法，以便使它们更容易、更强大。
- en: Collectively the set of enhanced Java libraries is known as the Groovy JDK.
    Groovy has two sets of Javadoc documentation. One is the Groovy API, which contains
    information about the included Groovy libraries. The other is the Groovy JDK,
    which shows only those methods and properties that have been added to the standard
    Java libraries, in order to, as the saying goes, make them groovier (see [figure
    4.4](#ch04fig04)).
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 一起，这些增强的Java库集合被称为Groovy JDK。Groovy有两套Javadoc文档。一个是Groovy API，其中包含有关包含的Groovy库的信息。另一个是Groovy
    JDK，它只显示已添加到标准Java库中的方法和属性，以便，正如俗话所说，使它们更加“Groovy”（见图4.4）。
- en: Figure 4.4\. Groovy adds convenience methods to classes in the Java standard
    library.
  id: totrans-768
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.4\. Groovy向Java标准库中的类添加便利方法。
- en: '![](04fig04_alt.jpg)'
  id: totrans-769
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig04_alt.jpg)'
- en: For example, Groovy adds many methods to the `java.util.Collection` interface,
    including `collect`, `count`, `find`, `findAll`, `leftShift`, `max`, `min`, `sort`,
    and `sum`. These methods are then available in any Groovy collection, whether
    they include objects from Java or Groovy.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Groovy向`java.util.Collection`接口添加了许多方法，包括`collect`、`count`、`find`、`findAll`、`leftShift`、`max`、`min`、`sort`和`sum`。这些方法随后在任何Groovy集合中都是可用的，无论它们是否包含Java或Groovy的对象。
- en: I’ve already spent a fair amount of time on collections, though, and I’ll revisit
    them frequently in the book. So to choose an example from a different Java class,
    let’s illustrate why it’s a bad idea to use basic authentication over HTTP.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我已经在集合上花费了不少时间，但我在书中会经常回顾它们。因此，为了从一个不同的Java类中选择一个例子，让我们说明为什么在HTTP上使用基本身份验证是个糟糕的主意。
- en: In basic authentication a username and password are transmitted in encoded form
    to a server. Basic authentication concatenates the username and the password together,
    separated by a colon, performs a Base 64 encoding on the resulting string, and
    sends the result as part of the authenticated HTTP request header.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本身份验证中，用户名和密码以编码形式发送到服务器。基本身份验证将用户名和密码通过冒号连接起来，对生成的字符串进行Base 64编码，并将结果作为认证的HTTP请求头的一部分发送。
- en: There’s a big difference, however, between encoding and encrypting. Encoded
    strings can just as easily be decoded. Groovy makes it easy to demonstrate this,
    because the Groovy JDK adds a method called `encodeBase64` to, of all things,
    byte arrays. It also adds a `decodeBase64` method to `String`. The following listing
    demonstrates both.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编码和解密之间有很大的区别。编码后的字符串同样可以被解码。Groovy使得演示这一点变得容易，因为Groovy JDK为字节数组添加了一个名为`encodeBase64`的方法。它还向`String`添加了一个`decodeBase64`方法。下面的列表演示了这两个方法。
- en: Listing 4.4\. Base 64 encoding and decoding username/password information
  id: totrans-774
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.4\. 基于Base 64编码和解码用户名/密码信息
- en: '![](072fig01_alt.jpg)'
  id: totrans-775
  prefs: []
  type: TYPE_IMG
  zh: '![图片](072fig01_alt.jpg)'
- en: There’s a lot going on in this short script. First, a username and password
    are assembled into a Groovy string. Then the `getBytes` method is invoked on the
    combined string, which encodes the string into a sequence of bytes using the default
    character encoding. That method is from Java. The result is a byte array. Check
    the Groovy JDK and you’ll find that Groovy has added the method `encodeBase64`
    to `byte`[], which returns an instance of `groovy.lang.Writable`. Here I just
    use its `toString` method (from Java, of course, though it’s overridden in the
    Groovy class) to see the resulting values. In effect I went from Java to Groovy
    to Java in one chained method call.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的脚本中有很多事情在进行。首先，用户名和密码被组合成一个 Groovy 字符串。然后对组合字符串调用 `getBytes` 方法，使用默认字符编码将字符串编码成一系列字节。这个方法来自
    Java。结果是字节数组。检查 Groovy JDK，你会发现 Groovy 为 `byte[]` 添加了 `encodeBase64` 方法，它返回一个
    `groovy.lang.Writable` 实例。在这里，我只是使用它的 `toString` 方法（当然，来自 Java，尽管在 Groovy 类中被覆盖）来查看结果值。实际上，我在一个链式方法调用中从
    Java 到 Groovy 再到 Java。
- en: To go the other direction, first I use the `decodeBase64` method that Groovy
    adds to `java.lang.String`, which returns a `byte`[] again. Then `String` has
    a constructor that takes a byte array, and I use the `split` method from Java
    to separate the username from the password again and verify that they haven’t
    been modified by the transformations.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行相反的操作，首先我使用 Groovy 添加到 `java.lang.String` 的 `decodeBase64` 方法，它再次返回一个 `byte[]`。然后
    `String` 有一个构造函数，它接受一个字节数组，我使用 Java 的 `split` 方法再次将用户名和密码分开，并验证它们在转换过程中没有被修改。
- en: Other than showing how the Groovy JDK adds new methods to standard Java data
    types, this example also demonstrates that encoded text isn’t encrypted. Anyone
    who intercepts the request and accesses the encoded header can extract the username
    and password. Using basic authentication therefore is not at all secure if the
    requests are transmitted over an unencrypted connection, like HTTP. At a minimum
    the request should be sent over HTTPS instead.^([[4](#ch04fn04)])
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 除了展示 Groovy JDK 如何向标准 Java 数据类型添加新方法之外，这个例子还表明编码文本并没有加密。任何拦截请求并访问编码头的人都可以提取用户名和密码。因此，如果请求是通过未加密的连接（如
    HTTP）传输的，使用基本身份验证就完全不安全。至少，请求应该通过 HTTPS 传输.^([[4](#ch04fn04)])
- en: ⁴ For several years Twitter supported basic authentication as part of its RESTful
    API. Hopefully all the many Twitter clients who used it transmitted their authentication
    over secure sockets. If not you might want to consider changing your password.
    These days Twitter has switched to OAuth, which may be overly complicated but
    is much better than basic authentication.
  id: totrans-779
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 几年来，Twitter 作为其 RESTful API 的一部分支持基本身份验证。希望所有使用它的许多 Twitter 客户端都通过安全套接字传输了它们的身份验证。如果没有，你可能需要考虑更改你的密码。如今，Twitter
    已经切换到 OAuth，这可能过于复杂，但比基本身份验证要好得多。
- en: There are lots and lots of useful methods in the Groovy JDK. As another example,
    date manipulation is always painful in Java.^([[5](#ch04fn05)]) Groovy doesn’t
    necessarily fix the many problems, but the Groovy JDK adds several methods to
    make date-related classes more powerful. Here’s an example, which hopefully will
    be both interesting and at least mildly amusing to some readers.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy JDK 中有很多有用的方法。作为另一个例子，日期操作在 Java 中总是很痛苦.^([[5](#ch04fn05)]) Groovy 并不一定解决了许多问题，但
    Groovy JDK 为与日期相关的类添加了几个方法，使它们更强大。以下是一个示例，希望对一些读者来说既有趣又至少有点乐趣。
- en: '⁵ Java 8 is supposed to fix this, at long last. In the meantime, the open source
    date/time library of choice in the Java world is Joda time: [http://joda-time.sourceforge.net/](http://joda-time.sourceforge.net/).'
  id: totrans-781
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ Java 8 终于要解决这个问题了。在此期间，Java 世界中首选的开源日期/时间库是 Joda 时间：[http://joda-time.sourceforge.net/](http://joda-time.sourceforge.net/).
- en: In the United States and Canada, February 2 is known as Groundhog Day. On Groundhog
    Day, the groundhog is supposed to emerge from his hole and look for his shadow.
    If he doesn’t see it he’ll stay out of the burrow, and winter is nearly over.
    If he sees his shadow, he goes back to sleep in his burrow, and we’ll sadly have
    to suffer through six more weeks of winter.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国和加拿大，2 月 2 日被称为土拨鼠日。在土拨鼠日，土拨鼠会从它的洞里出来寻找它的影子。如果它看不到影子，它就会待在洞里，冬天就快结束了。如果它看到了自己的影子，它就会回到洞里睡觉，我们就不幸地要再忍受六个星期的冬天。
- en: Let’s check the math on that, though, as shown in the next listing.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下下一个列表中的数学，如图所示。
- en: Listing 4.5\. GroundHog Day—an example of `Date` and `Calendar` in the Groovy
    JDK
  id: totrans-784
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5\. 土拨鼠日——Groovy JDK 中 `Date` 和 `Calendar` 的一个示例
- en: '![](073fig01_alt.jpg)'
  id: totrans-785
  prefs: []
  type: TYPE_IMG
  zh: '![](073fig01_alt.jpg)'
- en: I get an instance of the `Calendar` class by accessing its `instance` property.
    Of course, there’s no instance property in `Calendar`, but the syntax actually
    means that I invoke the static `getInstance` method with no arguments. Then I
    call `set` with the appropriate arguments for Groundhog Day and the first day
    of spring. Extracting a `Date` instance from the `Calendar` is done through the
    `getTime` method (sigh^([[6](#ch04fn06)])), which again is invoked by accessing
    the `time` property. So far this is straight Java, except that I’m invoking methods
    via properties and omitting optional parentheses.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过访问其 `instance` 属性来获取 `Calendar` 类的实例。当然，`Calendar` 中没有 `instance` 属性，但这个语法实际上意味着我使用无参数调用静态的
    `getInstance` 方法。然后我使用适合土拨鼠日和春天第一天的适当参数调用 `set`。从 `Calendar` 中提取 `Date` 实例是通过
    `getTime` 方法完成的（ sigh^([[6](#ch04fn06)]))，这同样是通过访问 `time` 属性来调用的。到目前为止，这完全是 Java，除了我通过属性调用方法并省略了可选的括号。
- en: ⁶ Seriously, couldn’t the method `getDate` have been used to extract a `Date`
    from a `Calendar`?
  id: totrans-787
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ 真的，就不能使用 `getDate` 方法从一个 `Calendar` 中提取一个 `Date` 吗？
- en: I can subtract dates, though, because the Groovy JDK shows that the `minus`
    method in `Date` returns the number of days between them. The `Date` class has
    a `next` method and a `previous` method and implements `compareTo`. Those are
    the requirements necessary for a class to be used as part of a range, so I can
    check the math by invoking the `size` method on a range. The size of a range counts
    both ends, so I have to correct for the potential off-by-one error by subtracting
    one.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我可以进行日期相减，因为 Groovy JDK 显示 `Date` 中的 `minus` 方法返回它们之间的天数。`Date` 类有一个 `next`
    方法和一个 `previous` 方法，并实现了 `compareTo`。这些都是一个类作为范围的一部分使用所必需的要求，因此我可以通过在范围上调用 `size`
    方法来检查数学。范围的尺寸计算两端，所以我必须通过减去一来纠正潜在的偏移量错误。
- en: The bottom line is that there are six weeks and four days between Groundhog
    Day and the first day of spring (March 20). In other words, if the groundhog sees
    his shadow the resulting six more weeks of winter is actually a (slightly) early
    spring anyway.^([[7](#ch04fn07)])
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，从土拨鼠日到春天的第一天（3月20日）之间有六个星期和四天。换句话说，如果土拨鼠看到了自己的影子，接下来的六个星期冬天的结果实际上是一个（稍微）早春。^([[7](#ch04fn07)])
- en: ⁷ Yes, that’s a long way to go for a gag, but it does clearly show a mix of
    Java and Groovy that takes advantage of both Groovy JDK methods and operator overloading.
    The joke is just a side benefit.
  id: totrans-790
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷ 是的，为了一个玩笑走这么远的路，但这确实清楚地展示了 Java 和 Groovy 的混合使用，利用了 Groovy JDK 方法和运算符重载。这个笑话只是一个额外的好处。
- en: One last convenience should be noted here. In Java, arrays have a `length` property,
    strings have a `length` method, collections have a `size` method, `NodeList`s
    have a `getLength` method, and so on. In Groovy you can invoke `size` on all of
    them to get the proper behavior. In this case the Groovy JDK has been used to
    correct a historical inconsistency in Java.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还应注意的是一个便利之处。在 Java 中，数组有 `length` 属性，字符串有 `length` 方法，集合有 `size` 方法，`NodeList`s
    有 `getLength` 方法，等等。在 Groovy 中，你可以对它们中的任何一个调用 `size` 来获得适当的行为。在这种情况下，Groovy JDK
    已被用来纠正 Java 中的历史不一致性。
- en: The Groovy JDK is full of helpful methods. Even if your application is planning
    to use only Java library classes I encourage you to check the Groovy JDK for possible
    simplifications and enhancements.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy JDK 中充满了有用的方法。即使你的应用程序计划只使用 Java 库类，我也鼓励你检查 Groovy JDK，看看是否有可能的简化或增强。
- en: I mentioned runtime metaprogramming, which is done through the metaclass. One
    of the more interesting features of Groovy, though, is compile-time metaprogramming
    done through AST transformations, which is the subject of the next section.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到了运行时元编程，这是通过元类完成的。然而，Groovy 中更有趣的一个特性是通过 AST 转换进行的编译时元编程，这是下一节的主题。
- en: 4.4\. Cool AST transformations
  id: totrans-794
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4\. 令人印象深刻的 AST 转换
- en: Groovy 1.6 introduced Abstract Syntax Tree (AST) transformations. The idea is
    to place annotations on Groovy classes and invoke the compiler, which builds a
    syntax tree as usual and then modifies it in interesting ways. Writing AST transformations
    is done through various builder classes, but that’s not my primary concern here.
    Instead I want to show some of the AST transformations that Groovy provides in
    the standard library and demonstrate that they can be applied to Java classes,
    too.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 1.6 引入了抽象语法树（AST）转换。其思路是在 Groovy 类上放置注解并调用编译器，编译器会像往常一样构建一个语法树，然后以有趣的方式修改它。编写
    AST 转换是通过各种构建器类完成的，但这不是我的主要关注点。相反，我想展示一些 Groovy 标准库中提供的 AST 转换，并证明它们也可以应用于 Java
    类。
- en: 4.4.1\. Delegating to contained objects
  id: totrans-796
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1\. 将代理委托给包含对象
- en: Let’s start with delegation. Current design principles tend to favor delegation
    over inheritance, viewing inheritance as too highly coupled. Instead of extending
    a class in order to support all its methods, with delegation you wrap an instance
    of one class inside another. You then implement all the same methods in the outer
    class that the contained class provides, delegating each call to the corresponding
    method on the contained object. In this way your class has the same interface
    as the contained object but is not otherwise related to it.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从代理开始。当前的设计原则倾向于优先考虑代理而不是继承，认为继承耦合度太高。不是通过扩展一个类来支持所有其方法，而是使用代理，你将一个类的实例包裹在另一个类中。然后你在外部类中实现所有包含类提供的方法，并将每个调用委托给包含对象上的相应方法。这样，你的类具有与包含对象相同的接口，但除此之外与它没有其他关系。
- en: Writing all those “pass-through” methods can be a pain, though. Groovy introduced
    the `@Delegate` annotation to take care of all that work for you.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 写所有这些“透传”方法可能会很痛苦。Groovy 引入了 `@Delegate` 注解来为你处理所有这些工作。
- en: Phones keep getting more and more powerful, so that the term *phone* is now
    something of a misnomer. The current generation of “smart phones” includes a camera,
    a browser, a contact manager, a calendar, and more.^([[8](#ch04fn08)]) If you’ve
    already developed classes for all the components, you can then build a smart phone
    by delegation. The interesting part is that the component classes can be in Java,
    and the container in Groovy.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 手机变得越来越强大，以至于“手机”这个词现在有点名不副实。当前一代的“智能手机”包括相机、浏览器、联系人管理器、日历等等。[8](#ch04fn08)
    如果你已经为所有组件开发了类，那么你可以通过代理来构建智能手机。有趣的部分是，组件类可以是 Java，容器可以是 Groovy。
- en: '⁸ Here’s a good quote attributed to Bjarne Stroustrup, inventor of C++: “I’ve
    always wished for my computer to be as easy to use as my telephone; my wish has
    come true because I can no longer figure out how to use my telephone.”'
  id: totrans-800
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸ 这里有一个归功于 C++ 发明者 Bjarne Stroustrup 的好引用：“我一直希望我的电脑像我的电话一样容易使用；我的愿望实现了，因为我现在再也想不出如何使用我的电话了。”
- en: 'Consider a trivial `Camera` class in Java:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的 Java `Camera` 类：
- en: '[PRE64]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here also is a `Phone` class, in Java.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个 `Phone` 类，用 Java 编写。
- en: '[PRE65]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now here’s a `SmartPhone` class in Groovy that uses the `@Delegate` annotation
    to expose the component methods through the `SmartPhone` class (see [figure 4.5](#ch04fig05)):'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看 Groovy 中的一个 `SmartPhone` 类，它使用 `@Delegate` 注解来通过 `SmartPhone` 类公开组件方法（见[图
    4.5](#ch04fig05)）：
- en: '[PRE66]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Figure 4.5\. The `@Delegate` AST transformation exposes all methods in the delegates
    through the composite object. The transformation only works in Groovy classes,
    but the delegates themselves can be in Groovy, Java, or both.
  id: totrans-807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.5\. `@Delegate` AST 转换通过组合对象公开了所有代理中的方法。这个转换只在 Groovy 类中起作用，但代理本身可以是 Groovy、Java
    或两者都是。
- en: '![](04fig05_alt.jpg)'
  id: totrans-808
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig05_alt.jpg)'
- en: A JUnit test (written in Groovy this time) demonstrates the delegated methods
    in the next listing.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 JUnit 测试（这次是用 Groovy 编写的）演示了下一个列表中的代理方法。
- en: Listing 4.6\. A JUnit test in Groovy to demonstrate the delegated methods
  id: totrans-810
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.6\. Groovy 中的一个 JUnit 测试，用于演示代理方法
- en: '[PRE67]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Simply add whatever components are needed, and the `@Delegate` annotation will
    expose their methods through the `SmartPhone` class. I could also add smart phone-specific
    methods as desired. The @`Delegate` annotation makes including capabilities easy,
    and the components themselves can be written in Java or Groovy, whichever is more
    convenient. The only requirement is that the `SmartPhone` class itself must be
    written in Groovy, because only the Groovy compiler understands the AST transformation.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地添加所需的任何组件，`@Delegate` 注解将通过 `SmartPhone` 类公开它们的方法。我也可以添加所需的智能手机特定方法。@`Delegate`
    注解使得包括功能变得容易，组件本身可以是 Java 或 Groovy，哪个更方便都可以。唯一的要求是 `SmartPhone` 类本身必须用 Groovy
    编写，因为只有 Groovy 编译器理解 AST 转换。
- en: I’ll have another practical example of @`Delegate` later, in appendix C on SOAP-based
    web services (available for free download), but for now let’s move on to making
    objects that can’t be changed.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在附录 C 中提供一个关于基于 SOAP 的 Web 服务的 @`Delegate` 的实际例子，但现在是时候继续创建不可变对象了。
- en: 4.4.2\. Creating immutable objects
  id: totrans-814
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2\. 创建不可变对象
- en: With the rise of multi-core machines, programs that handle concurrency well
    are becoming more and more important. One mechanism for handling operations in
    a thread-safe manner is to use immutable objects as much as possible whenever
    shared information is required.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 随着多核机器的兴起，处理并发性良好的程序变得越来越重要。处理操作的一种线程安全机制是尽可能使用不可变对象来共享信息。
- en: Unlike C++, Java has no built-in way to make it impossible to modify an object.
    There’s no “const” keyword in Java, and applying the combination of `static` and
    `final` to a reference only makes the reference a constant, not the object it
    references. The only way to make an object immutable in Java is to remove all
    ways to change it.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++不同，Java没有内置的方式使对象无法修改。Java中没有“const”关键字，将`static`和`final`组合应用于引用仅使引用成为常量，而不是它引用的对象。在Java中使对象不可变的唯一方法是移除所有改变它的方法。
- en: This turns out to be a lot harder than it sounds. Taking out all setter methods
    is a good first step, but there are other requirements. Making a class support
    immutability requires that
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上比听起来要困难得多。移除所有setter方法是一个好的开始，但还有其他要求。使一个类支持不可变性需要
- en: All mutable methods (setters) must be removed.
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有可变方法（setter）都必须移除。
- en: The class should be marked `final`.
  id: totrans-819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类应该被标记为`final`。
- en: Any contained fields should be `private` and `final`.
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何包含的字段都应该是`private`和`final`。
- en: Mutable components like arrays should defensively be copied on the way in (through
    constructors) and the way out (through getters).
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变组件（如数组）应该在输入（通过构造函数）和输出（通过getter）时进行防御性复制。
- en: '`equals`, `hashCode`, and `toString` should all be implemented through fields.'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals`、`hashCode`和`toString`都应该通过字段实现。'
- en: That sounds like work. Fortunately Groovy has an @`Immutable` AST transformation,
    which does everything for you (see [figure 4.6](#ch04fig06)).
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是一项工作。幸运的是，Groovy有一个`@``Immutable` AST转换，它可以为你做所有事情（见[图 4.6](#ch04fig06)）。
- en: Figure 4.6\. The `@Immutable` AST transformation results in an immutable object
    that can be used in both Java and Groovy clients.
  id: totrans-824
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.6\. `@``Immutable` AST转换产生了一个不可变对象，该对象可以在Java和Groovy客户端中使用。
- en: '![](04fig06.jpg)'
  id: totrans-825
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig06.jpg)'
- en: The `@Immutable` transformation can only be applied to Groovy classes, but those
    classes can then be used in Java applications. I’ll start by showing how the @`Immutable`
    annotation works and what its limitations are, and then use an immutable object
    in a Java class.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '`@``Immutable`转换只能应用于Groovy类，但那些类可以用于Java应用程序。我将首先展示`@``Immutable`注解的工作方式和其局限性，然后在一个Java类中使用不可变对象。'
- en: 'Here’s an immutable point class. It contains two fields, `x` and `y`, which
    represent the location of the point in a two-dimensional space:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不可变点类。它包含两个字段，`x`和`y`，它们代表点在二维空间中的位置：
- en: '[PRE68]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The @`Immutable` annotation is applied to the class itself. It still allows
    the properties to be set through a constructor, but once set the properties can
    no longer be modified. The next listing shows a Spock test to demonstrate that
    fact.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '`@``Immutable`注解应用于类本身。它仍然允许通过构造函数设置属性，但一旦设置，属性就再也不能修改。下一个列表展示了Spock测试来演示这一点。'
- en: Listing 4.7\. Testing the `ImmutablePoint` class
  id: totrans-830
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.7\. 测试`ImmutablePoint`类
- en: '![](077fig01_alt.jpg)'
  id: totrans-831
  prefs: []
  type: TYPE_IMG
  zh: '![](077fig01_alt.jpg)'
- en: In the test the `ImmutablePoint` class is instantiated by specifying the values
    of `x` and `y` as constructor arguments. This is necessary, because there are
    no set methods available. I can access the properties through the regular dynamically
    generated get methods, but if I try to modify a property the attempt will throw
    a `ReadOnlyPropertyException`.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，通过指定构造函数参数`x`和`y`的值来实例化`ImmutablePoint`类。这是必要的，因为没有可用的设置方法。我可以通过常规动态生成的get方法访问属性，但如果我尝试修改一个属性，尝试将抛出`ReadOnlyPropertyException`。
- en: 'The @`Immutable` annotation is very powerful, but it has limitations. You can
    only apply it to classes that contain primitives or certain library classes, like
    `String` or `Date`. It also works on classes that contain properties that are
    also immutable. For example, here’s an `ImmutableLine`, which contains two `ImmutablePoint`
    instances:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '`@``Immutable`注解非常强大，但它也有局限性。你只能将其应用于包含原始数据类型或某些库类（如`String`或`Date`）的类。它也适用于包含也是不可变属性的类。例如，这里有一个`ImmutableLine`类，它包含两个`ImmutablePoint`实例：'
- en: '[PRE69]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `start` and `end` fields are both of type `ImmutablePoint`. I’ve added a
    method to return a dependent `length` property, which is computed using the Pythagorean
    theorem in the usual manner. This means I can access the `length` property of
    an `Immut``ableLine` and the access will go through the `getLength` method, but
    because there’s no setter I can’t change the value from outside. The corresponding
    test for this class is shown in the following listing.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`和`end`字段都是`ImmutablePoint`类型。我添加了一个方法来返回一个依赖的`length`属性，它使用通常的方式通过勾股定理计算。这意味着我可以访问`Immut`ableLine`的`length`属性，访问将通过`getLength`方法进行，但由于没有设置器，所以我不能从外部更改该值。这个类的对应测试如下所示。'
- en: Listing 4.8\. A Spock test for the `ImmutableLine` class
  id: totrans-836
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.8\. `ImmutableLine`类的Spock测试
- en: '![](078fig01_alt.jpg)'
  id: totrans-837
  prefs: []
  type: TYPE_IMG
  zh: '![078fig01_alt.jpg](078fig01_alt.jpg)'
- en: In order to create an `ImmutableLine` I need to first create a pair of `ImmutablePoint`
    instances that can be used in the `ImmutableLine` constructor. The first test
    checks that the contained points are set properly and then checks the `getLength`
    implementation by accessing the `length` “field.” Finally, I make sure that I
    can’t reassign the `start` or `end` properties of the line.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个`ImmutableLine`，我需要首先创建一对`ImmutablePoint`实例，这些实例可以用在`ImmutableLine`构造函数中。第一个测试检查包含的点是否被正确设置，然后通过访问`length`“字段”来检查`getLength`实现。最后，我确保不能重新分配线的`start`或`end`属性。
- en: 'Taking this one step further, what happens if the class contains a collection?
    The @`Immutable` annotation will cause the collection to be wrapped by one of
    its unmodifiable alternatives. For example, let’s say that a path is a collection
    of lines, so here’s the definition of an `ImmutablePath`:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一步进一步，如果类中包含一个集合会发生什么？`@Immutable`注解将导致该集合被其不可修改的替代品之一包装。例如，假设路径是一系列线的集合，所以这里是`ImmutablePath`的定义：
- en: '[PRE70]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This time I can’t just declare the segments variable using `def`. If I want
    the @`Immutable` annotation to work I need to specify that I’m using some sort
    of collection. On the right-hand side of the `segments` definition I still just
    have `[]`, which normally means an instance of `java.util.ArrayList`. In this
    case, however, what I actually get (by printing `segments.class.name`) is `java.util.Collections$UnmodifiableRandomAccessList`,
    believe it or not. The `Collections` class has utility methods like `unmodifiableList`
    that take a regular list and return a new list that can’t be changed, but to be
    honest I wouldn’t have necessarily expected it to be a `RandomAccessList` in this
    case. It doesn’t make any difference what the actual class is, of course, as long
    as the contract is maintained.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我无法仅使用`def`声明segments变量。如果我想让`@Immutable`注解工作，我需要指定我正在使用某种类型的集合。在`segments`定义的右侧，我仍然只有`[]`，这通常意味着一个`java.util.ArrayList`的实例。然而，实际上我得到的是`java.util.Collections$UnmodifiableRandomAccessList`，信不信由你。`Collections`类有像`unmodifiableList`这样的实用方法，它接受一个常规列表并返回一个新的不可变列表，但说实话，我并不一定期望在这种情况下它是一个`RandomAccessList`。当然，只要契约得到维护，实际的类是什么并不重要。
- en: Speaking of that contract, those unmodifiable methods in `Collections` don’t
    remove the available mutator methods. Instead, they wrap them and throw an `Unsupported-``OperationException`
    if they’re accessed. That’s arguably a strange way to implement an interface,
    but so be it. The Spock test for this class is shown in the following listing.
    Everything works as expected. It takes some doing to build up all the immutable
    objects needed to create an `ImmutablePath` instance, but once everything is set
    it all works.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这个契约，`Collections`中的不可修改方法并没有移除可用的修改器方法。相反，它们将它们包装起来，如果访问它们，则抛出`UnsupportedOperationException`。这可以说是实现接口的一种奇怪方式，但就是这样。这个类的Spock测试如下所示。构建所有必要的不可变对象以创建`ImmutablePath`实例需要一些工作，但一旦设置好，一切都会正常工作。
- en: Listing 4.9\. A Spock test for the `ImmutablePath` class
  id: totrans-843
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.9\. `ImmutablePath`类的Spock测试
- en: '[PRE71]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Everything I’ve shown about the @`Immutable` annotation so far falls in the
    category of the good news. Now for the bad news, though again it’s not all that
    bad. First, the @`Immutable` annotation, like many of the AST transformations,
    wreaks havoc on Integrated Development Environments (IDEs). The transformations
    occur at compile time, which the IDEs have a hard time anticipating. Even though
    everything I’ve done so far is legal and works just fine, my IDE^([[9](#ch04fn09)])
    continually struggled with it. At this point the IDE issues are mostly annoying,
    but fixing them is legitimately a Hard Problem and probably won’t go away soon.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我所展示的关于`@``Immutable`注解的内容都属于好消息的范畴。然而，现在要说的是坏消息，尽管这并不是那么糟糕。首先，`@``Immutable`注解，就像许多AST转换一样，对集成开发环境（IDEs）造成了破坏。这些转换发生在编译时，这使得IDEs很难预测。尽管我到目前为止所做的一切都是合法的并且运行良好，但我的IDE^([[9](#ch04fn09)])仍然不断为此挣扎。到目前为止，IDE的问题主要很烦人，但修复这些问题确实是一个难题，而且可能不会很快消失。
- en: ⁹ Most of the code in this chapter was written using Groovy / Grails Tool Suite
    (STS) version 3.2.
  id: totrans-846
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹本章的大部分代码都是使用Groovy / Grails工具套件（STS）版本3.2编写的。
- en: The next problem occurs when I try to use my `ImmutablePoint` in a Java program.
    How am I supposed to assign the `x` and `y` values? Groovy gives me a map-based
    constructor that I’ve been using so far, but Java won’t see that.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题出现在我尝试在Java程序中使用我的`ImmutablePoint`时。我该如何分配`x`和`y`的值呢？Groovy给了我一个基于映射的构造函数，我到目前为止一直在使用，但Java看不到这一点。
- en: Fortunately, the developers of @`Immutable` anticipated that problem. The transformation
    also generates a tuple constructor that takes each of the properties in the order
    they’re defined. In this case, it’s as though the `ImmutablePoint` class has a
    two-argument constructor that takes doubles representing `x` and `y` in that order.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`@``Immutable`的开发者预见到了这个问题。转换还生成一个元组构造函数，它按照定义的顺序接受每个属性。在这种情况下，`ImmutablePoint`类似乎有一个接受表示`x`和`y`的双精度浮点数的两个参数的构造函数。
- en: 'Here’s a JUnit 4 test (written in Java, so it’s an example of Java/Groovy integration
    itself) that takes advantage of that constructor:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个JUnit 4测试（用Java编写的，所以它本身就是一个Java/Groovy集成的例子）利用了那个构造函数：
- en: '[PRE72]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This, again, works just fine. At the moment, my IDE even understands that the
    two-argument constructor exists, which is pretty sweet. I’m using the three-argument
    version of the `Assert.assertEquals` method, by the way, because I’m comparing
    doubles, and for that you need to specify a precision.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样运行得很好。目前，我的IDE甚至理解存在两个参数的构造函数，这真的很棒。顺便说一下，我正在使用`Assert.assertEquals`方法的三个参数版本，因为我正在比较双精度浮点数，而这需要指定一个精度。
- en: There’s also no need to try to check for immutability, because from the Java
    point of view the class has no methods to invoke that might change `x` or `y`.
    Unlike the `getX` and `getY` methods shown, there are no corresponding setters.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从Java的角度来看，这个类没有可能改变`x`或`y`的方法，因此没有必要尝试检查不可变性。与展示的`getX`和`getY`方法不同，没有相应的setter方法。
- en: 'As I say, this all works, but if you’re trying to use the generated constructor
    and your system refuses to believe that one exists, there’s a simple workaround.
    Simply add a factory class in Groovy that can instantiate the points in the usual
    way:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我说的，这一切都运行得很好，但如果你试图使用生成的构造函数，而你的系统拒绝相信它存在，有一个简单的解决方案。只需在Groovy中添加一个可以以常规方式实例化点的工厂类：
- en: '[PRE73]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now the Java client can instantiate `ImmutablePointFactory` and then invoke
    the `newImmutablePoint` factory method, supplying the desired `x` and `y` values.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Java客户端可以实例化`ImmutablePointFactory`，然后调用`newImmutablePoint`工厂方法，提供所需的`x`和`y`值。
- en: Everything works, that is, until you succumb to the temptation to follow standard
    practices in the Java API and make the factory class a singleton. That’s the subject
    of the next subsection.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都运行得很好，也就是说，直到你屈服于遵循Java API中标准实践的诱惑，将工厂类做成单例。这就是下一小节的主题。
- en: 4.4.3\. Creating singletons
  id: totrans-857
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.3\. 创建单例
- en: When a new Java developer first discovers the wide, wonderful world of design
    patterns, one of the first ones they tend to encounter is Singleton. It’s an easy
    pattern to learn, because it’s easy to implement and only involves a single class.
    If you only want one instance of a class, make the constructor private, add a
    `static final` instance variable of the class type, and add a static getter method
    to retrieve it. How cool is that?
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 当一位新的 Java 开发者首次发现广阔、美妙的设计模式世界时，他们往往会遇到 Singleton。这是一个容易学习的模式，因为它易于实现，并且只涉及一个类。如果您只想有一个类的实例，请将构造函数设为私有，添加一个
    `static final` 类型的实例变量，并添加一个静态获取方法来检索它。这有多酷？
- en: Unfortunately, our poor new developer has wandered into a vast jungle, full
    of monsters to attack the unwary. First of all, implementing a true singleton
    isn’t nearly as easy as it sounds. If nothing else, there are thread safety issues
    to worry about, and because it seems no Java program is every truly thread-safe
    the results get ugly fast.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们可怜的新开发者误入了一个充满怪物、攻击那些不小心的人的广阔丛林。首先，实现一个真正的 Singleton 并不像听起来那么简单。至少，还有线程安全问题需要担心，而且由于似乎没有
    Java 程序是完全线程安全的，结果很快就变得很糟糕。
- en: Then there’s the fact that a small but very vocal contingent of developers view
    the whole Singleton design pattern as an anti-pattern. They trash it for a variety
    of reasons, and they tend to be harsh in their contempt for both the pattern and
    anyone foolish or naïve enough to use it.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，还有这样一个事实，一小部分但非常直言不讳的开发者认为整个 Singleton 设计模式是一个反模式。他们出于各种原因对其进行抨击，并且他们往往对这种模式和任何愚蠢或天真到足以使用它的人都非常严厉。
- en: Fortunately I’m not here to resolve that issue. My job is to show you how Groovy
    can help you as a Java developer, and I can do that here. As you may have anticipated
    based on the title of this section, there’s an AST transformation called @`Singleton`.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我并不是来解决这个问题。我的工作是向您展示 Groovy 如何帮助您作为 Java 开发者，我可以在这里做到这一点。根据本节标题的标题，这里有一个名为
    @`Singleton` 的 AST 转换。
- en: 'To use it all I have to do is add the annotation to my class. Here I’ve added
    it to the `ImmutablePointFactory` from earlier:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我只需将注释添加到我的类中。这里我将它添加到了之前的 `ImmutablePointFactory`：
- en: '[PRE74]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Again, I can’t resist saying it: that was easy. The result is that the class
    now contains a static property called `instance`, which contains, naturally enough,
    the one and only instance of the class. Also, everything is implemented in as
    correct a manner as possible by the author^([[10](#ch04fn10)]) of the transformation.
    In Groovy code I can now write the following:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我忍不住要说：这很简单。结果是，这个类现在包含一个名为 `instance` 的静态属性，它自然地包含该类的一个且仅有一个实例。此外，转换的作者以尽可能正确的方式实现了所有内容。[^10](#ch04fn10)。在
    Groovy 代码中，我现在可以编写以下内容：
- en: '^(10) Paul King, one of the coauthors of *Groovy in Action* (Manning, 2007)
    and a fantastic developer. Let me be blunt about this: everything Paul King writes
    is good. He tends to add his presentations to SlideShare.net as well, so go read
    them as soon as humanly possible.'
  id: totrans-865
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[^10] Paul King，*Groovy in Action*（Manning，2007）的合著者之一，是一位出色的开发者。让我坦白地说：Paul
    King 写的每一篇东西都是好的。他倾向于将他的演示文稿添加到 SlideShare.net，所以请尽可能快地去阅读它们。'
- en: '[PRE75]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: That works just fine. It’s when I try to do the same thing in Java that I run
    into problems. Again, the compiler understands, but I’ve never been able to coax
    my IDE into believing that the factory class has a `public` `static` field called
    `instance` in it.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很正常。问题在于当我尝试在 Java 中做同样的事情时，我遇到了问题。再次，编译器理解，但我从未能够说服我的 IDE 相信工厂类中有一个名为 `public`
    `static` 的字段 `instance`。
- en: Still, the annotation works and the IDEs will eventually understand how to deal
    with it. In fact, all the cool new AST transformations work, and I encourage you
    to consider them significant shortcuts to writing applications.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，注释仍然有效，IDEs 最终会理解如何处理它。实际上，所有酷炫的新 AST 转换都有效，我鼓励您考虑它们是编写应用程序的显著快捷方式。
- en: There are other AST transformations available and more being written all the
    time. I encourage you to keep an eye on them in case one comes along that can
    simplify your code the same way the ones just discussed do.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他 AST 转换可用，并且还在不断编写中。我鼓励您密切关注它们，以防出现可以以与刚刚讨论的相同方式简化您的代码的转换。
- en: As cool as AST transformations are, though, our last task is so much easier
    to do in Groovy than in Java that it practically sells Groovy to Java developers
    all by itself. That issue is parsing and generating XML.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管AST转换很酷，但我们的最后一个任务在Groovy中比在Java中容易得多，这几乎让Groovy本身就能吸引Java开发者。这个问题是解析和生成XML。
- en: 4.5\. Working with XML
  id: totrans-871
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5. 处理XML
- en: Way back in the late 90s, when XML was young, new, and still popular (as hard
    to imagine as that may be now), the combination of XML and Java was expected to
    be a very productive one. Java was the portable language (write once, run anywhere,
    right?), and XML was the portable data format. Unfortunately, if you’ve ever tried
    working with XML through the Java built-in APIs you know the results have fallen
    far short of the promise. Why are the Java APIs for working with XML so painful
    to use?
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 回到20世纪90年代末，当XML还年轻、新鲜且仍然流行（尽管现在看起来很难想象），XML和Java的结合被认为将是非常有成效的。Java是一种可移植的语言（一次编写，到处运行，对吧？），而XML是一种可移植的数据格式。不幸的是，如果你曾经尝试通过Java内置的API来处理XML，你就会知道结果远远没有达到预期。为什么Java处理XML的API使用起来如此痛苦？
- en: 'Here’s a trivial example. I have a list of books in XML format, as shown here:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子。我有一份XML格式的书籍列表，如下所示：
- en: '[PRE76]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: ^(11) I had to find some way to include my book in that august company, just
    to bask in the reflected glory.
  id: totrans-875
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（11）我必须找到一种方法，让我的书加入那个显赫的行列，仅仅是为了沐浴在反射的荣光中。
- en: 'Now assume that my task is to print the title of the second book. What could
    be easier? Here’s one Java solution, based on parsing the data into a document
    object model (DOM) tree and finding the right element:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我的任务是打印第二本书的标题。还有什么比这更容易的吗？这是一个基于将数据解析为文档对象模型（DOM）树并找到正确元素的Java解决方案：
- en: '[PRE77]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This is actually the short version of the required program. To make it any shorter
    I’d have to collapse the exception handling into catching just `Exception`, or
    add a `throws` clause to the `main` method.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是所需程序的简短版本。为了使其更短，我必须将异常处理折叠为仅捕获`Exception`，或者向`main`方法添加`throws`子句。
- en: Many APIs in Java are designed around a set of interfaces, with the assumption
    that there will be many different alternative implementations. In the Java API
    for XML Processing (JAXP) world there are many parsers available, so the API is
    dominated by interfaces. Of course, you can’t instantiate an interface, so using
    the API comes down to factories and factory methods.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Java API都是围绕一组接口设计的，假设将会有许多不同的替代实现。在Java API for XML Processing（JAXP）的世界里，有许多解析器可用，因此API主要由接口主导。当然，你不能实例化一个接口，因此使用API归结为工厂和工厂方法。
- en: To parse the XML file using a simple DOM parser, therefore, I first need to
    acquire the relevant factory, using its `newInstance` method. Then I use the factory
    method `newDocumentBuilder`, which is admittedly a really good name for a factory
    method. Parsing the file is then done through the `parse` method, as expected.
    Inside the DOM parser the tree is constructed using, interestingly enough, a SAX
    parser, which is why I need to prepare for SAX exceptions.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使用简单的DOM解析器解析XML文件，我首先需要获取相关的工厂，使用其`newInstance`方法。然后我使用工厂方法`newDocumentBuilder`，这确实是一个很好的工厂方法的名字。然后，通过`parse`方法解析文件，正如预期的那样。在DOM解析器内部，树是通过一个SAX解析器构建的，这也是为什么我需要准备SAX异常。
- en: Assuming I get that far, the result at that point is a reference to the DOM
    tree. Finding my answer by traversing the tree is quite frankly out of the question.
    Traversals are highly sensitive to the presence of white-space nodes, and the
    available methods (`getFirstChild`, `getNextSibling`, and the like) aren’t really
    a direct method to my answer. If whoever put together the XML file had been kind
    enough to assign each element an ID I could have used the great `getElementByID`
    method to extract the node I need, but no such luck there. Instead I’m reduced
    to collecting the relevant nodes using `getElementsByTagName`, which doesn’t return
    something from the `Collections` framework as you might expect, but a `NodeList`
    instead. The `NodeList` class has an `item` method that takes an integer representing
    the zero-based index of the node I want, and at long last I have my title node.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我做到了这一步，那么此时的结果是 DOM 树的引用。通过遍历树来找到我的答案坦白说是不可能的。遍历对空白节点的高度敏感，并且可用的方法（`getFirstChild`、`getNextSibling`
    等等）并不是直接得到答案的方法。如果谁整理了 XML 文件，并且足够友好地为每个元素分配了一个 ID，我就可以使用伟大的 `getElementByID`
    方法来提取我需要的节点，但很不幸没有这样的运气。相反，我只能通过 `getElementsByTagName` 收集相关的节点，它不会像你预期的那样返回 `Collections`
    框架中的内容，而是一个 `NodeList`。`NodeList` 类有一个 `item` 方法，它接受一个整数，代表我想要的节点的零基索引，最终我得到了我的标题节点。
- en: Then there’s the final indignity, which is that the value of a node is not the
    character content I want. No, I have to retrieve the first text child of the node,
    and only then can I get the value, which returns the text I needed.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有最后的侮辱，那就是节点的值并不是我想要的字符内容。不，我必须检索节点的第一个文本子节点，然后才能得到值，这返回了我需要的文本。
- en: '|  |'
  id: totrans-883
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**XML and Groovy**'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '**XML 和 Groovy**'
- en: I was once teaching a class about Java and XML, and one of the exercises was
    to extract a nested value. After taking the students through the awkward, ugly,
    Java solution, a woman in the back raised her hand.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经教过一门关于 Java 和 XML 的课程，其中一项练习是提取嵌套值。在让学生们通过那个笨拙、丑陋的 Java 解决方案后，教室后面的一位女士举手发言。
- en: “I kept waiting for you to say, ‘this is the hard way,’” she said, “and now
    here’s the easy way, but you never got to the easy way.”
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: “我一直等着你说，‘这是困难的方法，’”她说，“现在这里有简单的方法，但你从未提到简单的方法。”
- en: In reply I had to say, “Want to see the easy way? Let’s look at the Groovy solution
    to this problem.”
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，我不得不说，“想看看简单的方法吗？让我们看看这个问题的 Groovy 解决方案。”
- en: '[PRE78]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: How’s that for easy? I instantiated an `XmlSlurper`, called its `parse` method
    on the XML file, and just walked the tree to the value I want.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 这难道不简单吗？我实例化了一个 `XmlSlurper`，在 XML 文件上调用它的 `parse` 方法，然后直接走到我想要的值。
- en: If I ever need to parse or generate XML I always add a Groovy module to do it.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我需要解析或生成 XML，我总是会添加一个 Groovy 模块来完成这项工作。
- en: '|  |'
  id: totrans-891
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s look at another, somewhat more practical, example. Remember the Google
    geocoder used in [chapter 3](kindle_split_013.html#ch03)? When the geocoder went
    to version 3, Google removed the requirement to register for a key (good) but
    also removed the CSV output type (unfortunate). Now the only available output
    types are either JSON or XML. Google also changed the URL for accessing the web
    service (pretty typical when versioning a web service, actually), embedding the
    two available output types into the new URLs. In [chapter 9](kindle_split_021.html#ch09)
    on RESTful web services I’ll have a lot more to say about the choice of output
    types (formally known as *content negotiation*), but here the type is embedded
    in the URL.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个，相对更实用的例子。还记得第 3 章（[kindle_split_013.html#ch03](https://example.org/kindle_split_013.html#ch03)）中使用的
    Google 地理编码器吗？当地理编码器升级到版本 3 时，Google 移除了注册密钥的要求（好事），但也移除了 CSV 输出类型（不幸）。现在可用的输出类型只有
    JSON 或 XML。Google 还更改了访问 Web 服务的 URL（实际上在版本化 Web 服务时很典型），将两种可用的输出类型嵌入到新的 URL 中。在第
    9 章（[kindle_split_021.html#ch09](https://example.org/kindle_split_021.html#ch09)）关于
    RESTful Web 服务中，我将有很多关于输出类型选择（正式称为 *内容协商*）的讨论，但在这里类型是嵌入到 URL 中的。
- en: From a Java point of view, working with JSON output is a bit of a complication
    because it requires an external library to parse the JSON data. That’s not too
    much of a burden because there are several good JSON libraries available, but
    you still have to pick one and learn to use it. We’ve already talked about how
    involved it is to work with XML data in Java, so that’s not a great alternative
    either.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java 的角度来看，处理 JSON 输出有点复杂，因为它需要一个外部库来解析 JSON 数据。这并不是太大的负担，因为有几个好的 JSON 库可用，但你仍然需要选择一个并学习如何使用它。我们已经讨论了在
    Java 中处理 XML 数据是多么复杂，所以这也不是一个好的替代方案。
- en: Groovy, however, eats XML for lunch. Let’s see just how easy it is for Groovy
    to access the new geocoder and extract the returned latitude and longitude data.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Groovy 对 XML 来说却是小菜一碟。让我们看看 Groovy 访问新的地理编码器并提取返回的经纬度数据有多容易。
- en: 'First, here’s a sample of the XML output returned from the web service for
    the input address of Google’s home office:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是一个从网络服务返回的 XML 输出样本，用于 Google 家办公室的输入地址：
- en: '[PRE79]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'A lot of child elements have been omitted from this response in order to focus
    on what I actually want. The latitude and longitude values are buried deep inside
    the output. Of course, digging to that point is easy enough for Groovy. Here’s
    a script that creates the required HTTP request, transmits it to Google, and extracts
    the response, all in less than a dozen lines:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 为了专注于我真正想要的内容，已经从这个响应中省略了很多子元素。经纬度值深藏在输出中。当然，对于 Groovy 来说，挖掘到那个点很容易。以下是一个脚本，它创建所需的
    HTTP 请求，将其发送到 Google，并提取响应，所有这些都在不到一打行代码内完成：
- en: '[PRE80]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The code strongly resembles the version 2 client presented earlier, in that
    I have a base URL for the service (note that it includes the response type, XML,
    as part of the URL) and a parameters map that I convert into a query string. Transmitting
    the request and parsing the result is done in one line of code, because the `XmlSlurper`
    class has a `parse` method that takes a URL. Then extracting the latitude and
    longitude is simply a matter of walking the tree.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与前面展示的版本 2 客户端非常相似，因为我有一个服务的基本 URL（注意，它将响应类型 XML 作为 URL 的一部分包含在内）和一个参数映射，我将它转换为查询字符串。发送请求和解析结果是在一行代码中完成的，因为
    `XmlSlurper` 类有一个接受 URL 的 `parse` 方法。然后，提取经纬度只是遍历树的一个简单问题。
- en: Several times I’ve written applications that took this script, after converting
    it to a class that used a `Location` like before, and added it as a service. The
    code savings over the corresponding Java version is just too great to ignore.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 几次我编写了应用程序，将这个脚本转换为使用 `Location` 的类，并将其添加为服务。与相应的 Java 版本相比，代码节省的量实在太大，不容忽视。
- en: Parsing is one thing, but what about generation? For that, Groovy provides a
    builder class called `groovy.xml.MarkupBuilder`.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 解析是一回事，但生成呢？为此，Groovy 提供了一个名为 `groovy.xml.MarkupBuilder` 的构建器类。
- en: 'Consider another POJO representing a `Song`, as shown here:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一个表示 `Song` 的 POJO，如下所示：
- en: '[PRE81]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `Song` class, implemented in Java, contains an `id` and strings for the
    `title`, `artist`, and `year`. The rest is just constructors, getters, and setters.
    In a real system the class would also probably have overrides of `toString`, `equals`,
    and `hashCode`, but I don’t need that here.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `Song` 类的 Java 包含一个 `id` 和 `title`、`artist`、`year` 的字符串。其余的只是构造函数、获取器和设置器。在实际系统中，这个类可能还会覆盖
    `toString`、`equals` 和 `hashCode` 方法，但在这里我不需要这些。
- en: How should `Song` instances be represented in XML? One simple idea would be
    to treat the ID as an attribute of the song, and have `title`, `artist`, and `year`
    as child elements. In the following listing I show part of a Groovy class that
    converts `Song` instances to XML and back.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '`Song` 实例应该如何在 XML 中表示？一个简单的想法是将 ID 作为歌曲的属性处理，并将 `title`、`artist` 和 `year`
    作为子元素。在下面的列表中，我展示了部分 Groovy 类，该类将 `Song` 实例转换为 XML 并反向转换。'
- en: Listing 4.10\. Converting songs to XML and back
  id: totrans-906
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10\. 将歌曲转换为 XML 并反向转换
- en: '![](ch04ex10-0.jpg)'
  id: totrans-907
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04ex10-0.jpg)'
- en: '![](ch04ex10-1.jpg)'
  id: totrans-908
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04ex10-1.jpg)'
- en: 'The `SongXMLConverter` class has four methods: one to convert a single song
    to XML, one to convert XML to a single song, and two to do the same for a collection
    of songs. Converting from XML to `Song` instances is done with the `XmlSlurper`
    illustrated earlier. The only new part is that the slurper accesses the song ID
    value using the `@id` notation, where the `@` is used to retrieve an attribute.
    [Figure 4.7](#ch04fig07) shows the job of the `XmlSlurper`, or its analogous class,
    `XmlParser`.'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '`SongXMLConverter` 类有四个方法：一个用于将单个歌曲转换为 XML，一个用于将 XML 转换为单个歌曲，以及两个用于将歌曲集合转换为
    XML。从 XML 转换为 `Song` 实例是通过前面展示的 `XmlSlurper` 完成的。唯一的新部分是，slurper 使用 `@id` 表示法访问歌曲
    ID 值，其中 `@` 用于检索属性。[图 4.7](#ch04fig07) 展示了 `XmlSlurper` 或其类似类 `XmlParser` 的任务。'
- en: Figure 4.7\. Using an `XmlSlurper` or `XmlParser` to populate an object from
    XML data
  id: totrans-910
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.7\. 使用 `XmlSlurper` 或 `XmlParser` 从 XML 数据填充对象
- en: '![](04fig07.jpg)'
  id: totrans-911
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig07.jpg)'
- en: Going the other direction, from song to XML, is done with a `MarkupBuilder`.
    The `MarkupBuilder` class writes to standard output by default. In this class
    I want to return the XML as a string, so I used the overloaded `MarkupBuilder`
    constructor that takes a `java.io.Writer` as an argument. I supply a `StringWriter`
    to the constructor, build the XML, and then convert the output to a `String` using
    the normal `toString` method.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 从歌曲到 XML 的反向转换使用 `MarkupBuilder` 完成。`MarkupBuilder` 类默认写入标准输出。在这个类中，我想返回一个字符串形式的
    XML，因此我使用了带有一个 `java.io.Writer` 参数的重载 `MarkupBuilder` 构造函数。我向构造函数提供了一个 `StringWriter`，构建
    XML，然后使用正常的 `toString` 方法将输出转换为字符串。
- en: 'Once I have a `MarkupBuilder` I write out the song’s properties as though I
    was building the XML itself. Let’s focus on the conversion of a single song to
    XML form, as shown next:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我有了 `MarkupBuilder`，我就将歌曲的属性写出来，就像我正在构建 XML 一样。让我们专注于将单个歌曲转换为 XML 格式的转换，如下所示：
- en: '[PRE82]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The job of the `MarkupBuilder` is illustrated in [figure 4.8](#ch04fig08).
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarkupBuilder` 的作用在[图 4.8](#ch04fig08)中展示。'
- en: Figure 4.8\. Generating an XML representation of an object using a `groovy.xml.MarkupBuilder`
  id: totrans-916
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.8\. 使用 `groovy.xml.MarkupBuilder` 生成对象的 XML 表示形式
- en: '![](04fig08_alt.jpg)'
  id: totrans-917
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig08_alt.jpg)'
- en: This is an example of Groovy’s metaprogramming capabilities, though it doesn’t
    look like it at first. The idea is that inside the builder, whenever I write the
    name of a method that doesn’t exist, the builder interprets it as an instruction
    to create an XML element. For example, I invoke the `song` method on the builder
    with the argument being a map with a key called `id` and a value being the song’s
    ID. The builder doesn’t have a `song` method, of course, so it interprets the
    method call as a command to build an element called `song`, and the argument is
    an instruction to add an `id` attribute to the `song` element whose value is the
    song ID. Then, when it encounters the curly brace it interprets that as an instruction
    to begin child elements.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Groovy 元编程能力的示例，尽管一开始看起来并不像。想法是，在构建器内部，每当我写一个不存在的函数名时，构建器将其解释为创建 XML 元素的指令。例如，我通过传递一个键为
    `id`、值为歌曲 ID 的映射作为参数，在构建器上调用 `song` 方法。当然，构建器没有 `song` 方法，因此它将方法调用解释为构建一个名为 `song`
    的元素的命令，并将参数解释为向 `song` 元素添加一个 `id` 属性的指令，其值为歌曲 ID。然后，当它遇到花括号时，将其解释为开始子元素的指令。
- en: 'I have three more method calls: one to `title`, one to `artist`, and one to
    `year`. The lack of parentheses can be misleading in this case, but each is actually
    a method call. Once again the builder interprets each of the non-existent methods
    as commands to create XML elements, and the arguments this time, because they’re
    not in map form, become character data contained in the elements. The result of
    the builder process is the XML shown next:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 我还有三个方法调用：一个用于 `title`，一个用于 `artist`，一个用于 `year`。在这种情况下，括号的缺失可能会造成误导，但实际上每个都是方法调用。再次强调，构建器将每个不存在的解释为创建
    XML 元素的命令。这次，由于它们不是以映射形式存在，因此它们成为包含在元素中的字符数据。构建器处理的结果是下面的 XML：
- en: '[PRE83]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The method that converts a list of songs into a larger XML file just does the
    same thing for each song.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 将歌曲列表转换为更大的 XML 文件的方法对每首歌曲都做了同样的事情。
- en: '|  |'
  id: totrans-922
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Lessons learned (XML)**'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '**XML 学习经验**'
- en: Groovy’s `XmlParser` and `XmlSlurper` make parsing XML trivial, and values can
    be extracted by walking the resulting DOM tree.
  id: totrans-924
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovy 的 `XmlParser` 和 `XmlSlurper` 使得解析 XML 变得非常简单，可以通过遍历生成的 DOM 树来提取值。
- en: Generating XML is just as easy, using `MarkupBuilder`.
  id: totrans-925
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `MarkupBuilder` 生成 XML 一样简单。
- en: '|  |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Groovy Sweet Spot
  id: totrans-928
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Groovy Sweet Spot
- en: Groovy is excellent at parsing and generating XML. If your Java application
    works with XML, strongly consider delegating to a Groovy module.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 在解析和生成 XML 方面非常出色。如果你的 Java 应用程序与 XML 一起工作，强烈考虑委托给 Groovy 模块。
- en: '|  |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 4.6\. Working with JSON data
  id: totrans-931
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6\. 处理 JSON 数据
- en: Groovy processes JSON data as easily as it processes XML. To conclude this chapter,
    let me present a trivial example of JSON response data from a web service.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 处理 JSON 数据与处理 XML 一样容易。为了结束本章，让我给出一个来自网络服务的 JSON 响应数据的简单示例。
- en: 'The service is known as ICNDB: the Internet Chuck Norris Database. It is located
    at [http://icndb.com](http://icndb.com) and has a RESTful API for retrieving the
    associated jokes. If you send an HTTP GET request to [http://api.icndb.com/jokes/random?limitTo=[nerdy]](http://api.icndb.com/jokes/random?limitTo=[nerdy])
    you get back a string in JSON form.'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务被称为 ICNDB：互联网 Chuck Norris 数据库。它位于 [http://icndb.com](http://icndb.com)，并提供
    RESTful API 以检索相关的笑话。如果您向 [http://api.icndb.com/jokes/random?limitTo=[nerdy]](http://api.icndb.com/jokes/random?limitTo=[nerdy])
    发送 HTTP GET 请求，您将收到一个 JSON 格式的字符串。
- en: Groovy makes it easy to send a GET request. In the Groovy JDK the `String` class
    has a `toURL` method, which converts it to an instance of `java.net.URL`. Then
    the Groovy JDK adds a method to the URL class called `getText`. Accessing the
    web service is therefore as simple as
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 使得发送 GET 请求变得简单。在 Groovy JDK 中，`String` 类有一个 `toURL` 方法，它将其转换为 `java.net.URL`
    的实例。然后 Groovy JDK 向 URL 类添加了一个名为 `getText` 的方法。因此，访问网络服务就像这样
- en: '[PRE84]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Executing this returns a JSON object of the form
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作返回一个类似以下格式的 JSON 对象
- en: '[PRE85]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In all the Google geocoder demonstrations I’ve used so far in this book I introduced
    the `XmlSlurper` class, whose `parse` method takes the URL in string form and
    automatically converts the result to a DOM tree. Since version 1.8, Groovy also
    includes a `JsonSlurper`, but it doesn’t have as many overloads of the `parse`
    method as the `XmlSlurper` does. It does, however, contain a `parseText` method,
    which can process the `jsonTxt` returned from the previous code.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我已经使用过的所有 Google 地理编码演示中，我介绍了 `XmlSlurper` 类，其 `parse` 方法接受字符串形式的 URL 并自动将结果转换为
    DOM 树。从版本 1.8 开始，Groovy 也包括了一个 `JsonSlurper`，但它 `parse` 方法的重载比 `XmlSlurper` 少。然而，它确实包含一个
    `parseText` 方法，可以处理前一段代码返回的 `jsonTxt`。
- en: If I add that to the earlier lines, the complete ICNDB script is shown in the
    next listing.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将这些添加到前面的行中，完整的 ICNDB 脚本将在下一列表中显示。
- en: Listing 4.11\. `chuck_norris.groovy`, which processes data from ICNDB
  id: totrans-940
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.11\. `chuck_norris.groovy`，处理 ICNDB 的数据
- en: '[PRE86]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `parseText` method on `JsonSlurper` converts the JSON data into Groovy maps
    and lists. I then access the `value` property of the `json` object, which is a
    contained JSON object. It has a `joke` property, which contains the string I’m
    looking for.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonSlurper` 上的 `parseText` 方法将 JSON 数据转换为 Groovy 的映射和列表。然后我访问 `json` 对象的
    `value` 属性，它是一个包含的 JSON 对象。它有一个 `joke` 属性，其中包含我正在寻找的字符串。'
- en: 'The result of executing this script is something like this:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此脚本的结果类似于以下内容：
- en: '[PRE87]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Just as generating XML is done by scripting the output through a `MarkupBuilder`,
    generating JSON data uses the `groovy.json.JsonBuilder` class. See the GroovyDocs
    for `JsonBuilder` for a complete example.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 正如通过 `MarkupBuilder` 脚本输出生成 XML 一样，生成 JSON 数据使用 `groovy.json.JsonBuilder` 类。请参阅
    GroovyDocs 中的 `JsonBuilder` 以获取完整示例。
- en: '|  |'
  id: totrans-946
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Lessons learned (JSON)**'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习到的经验（JSON**）'
- en: The `JsonSlurper` class has a `parseText` method for working with JSON formatted
    strings.
  id: totrans-948
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JsonSlurper` 类有一个 `parseText` 方法，用于处理 JSON 格式的字符串。'
- en: The `JsonBuilder` class generates JSON strings using the same mechanism as the
    `XmlSlurper`.
  id: totrans-949
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JsonBuilder` 类使用与 `XmlSlurper` 相同的机制生成 JSON 字符串。'
- en: '|  |'
  id: totrans-950
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This completes the tour of Groovy features that can be added to Java applications
    regardless of use case.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了对可以添加到 Java 应用程序中的 Groovy 特性的浏览，无论使用场景如何。
- en: '|  |'
  id: totrans-952
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Lessons learned (Groovy features used in Java)**'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习到的经验（在 Java 中使用的 Groovy 特性**）'
- en: When Groovy access a POJO it can use the map-based constructor as though it
    were a POGO.
  id: totrans-954
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Groovy 访问 POJO 时，它可以像访问 POGO 一样使用基于映射的构造函数。
- en: Every operator in Groovy delegates to a method, and if that method is implemented
    in a Java class the operator in Groovy will still use it. This means you can do
    operator overloading even in a Java class.
  id: totrans-955
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovy 中的每个运算符都委托给一个方法，如果该方法在 Java 类中实现，Groovy 中的运算符仍然会使用它。这意味着您甚至可以在 Java 类中进行运算符重载。
- en: The Groovy JDK documents all the methods that Groovy adds to the Java standard
    API through metaprogramming.
  id: totrans-956
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovy JDK 通过元编程记录了 Groovy 添加到 Java 标准 API 中的所有方法。
- en: Groovy AST transformations can only be applied to Groovy classes, but the classes
    can be mixed with Java in interesting ways. This chapter includes examples of
    `@Delegate`, `@Immutable`, and `@Singleton`.
  id: totrans-957
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovy AST 转换只能应用于 Groovy 类，但这些类可以以有趣的方式与 Java 混合。本章包括 `@Delegate`、`@Immutable`
    和 `@Singleton` 的示例。
- en: '|  |'
  id: totrans-958
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 4.7\. Summary
  id: totrans-959
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7\. 摘要
- en: This chapter reviewed many ways that Groovy can help Java at the basic level,
    from POJO enhancements to AST transformations to building XML and more. I’ll use
    these techniques in future chapters wherever they can help. I’ll also review other
    helpful techniques along the way, though these are most of the major ones.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 本章回顾了许多Groovy在基本层面上帮助Java的方法，从POJO增强到AST转换，再到构建XML等。我将在未来的章节中使用这些技术，只要它们能有所帮助。我还会在途中回顾其他有用的技术，尽管这些是大多数主要的技术。
- en: 'The next couple of chapters, however, change the focus. Although mixing Java
    and Groovy is easy and is a major theme of this book, some companies are reluctant
    to add Groovy to production code until their developers have a certain minimum
    comfort level with the language. As it happens, there are two major areas where
    Groovy can strongly impact and simplify Java projects without being integrated
    directly. The first of those is one of the major pain points in enterprise development:
    the build process. The other is testing, which is valued more highly the better
    the developer.'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，接下来的几章将改变焦点。尽管混合使用Java和Groovy很容易，这也是本书的一个主要主题，但一些公司不愿意在生产代码中添加Groovy，直到他们的开发者对这种语言达到一定的最低舒适度。事实上，有两个主要领域Groovy可以强烈影响并简化Java项目，而不需要直接集成。其中一个是企业开发中的主要痛点之一：构建过程。另一个是测试，开发者越好，测试的价值就越高。
- en: By covering these two techniques early in the book I can then use, for example,
    Gradle builds and Spock tests when I attack the use cases Java developers typically
    encounter, like web services, database manipulation, or working with the Spring
    framework.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在本书早期介绍这两项技术，我就可以在攻击Java开发者通常遇到的使用案例时，例如Web服务、数据库操作或与Spring框架协同工作时，使用Gradle构建和Spock测试。
