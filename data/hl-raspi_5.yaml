- en: Appendix C. Solutions to chapter challenges
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录 C. 章节挑战的解决方案
- en: In this appendix, you’ll find answers to the challenges presented at the end
    of each chapter. For challenges that require more lines of code than will fit
    on a page, I provide hints and snippets of code. The complete programs for the
    solutions are found in the code download that goes with this book. Comments are
    included in the code to help you understand the design and function of the programs.
    The solutions to the challenges are organized by chapter. Let’s begin!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个附录中，你可以找到每个章节末尾提出的挑战的答案。对于需要比一页能容纳的更多代码行的挑战，我提供了提示和代码片段。解决方案的完整程序可以在与本书配套的代码下载中找到。代码中包含注释，以帮助您理解程序的设计和功能。挑战的解决方案按章节组织。让我们开始吧！
- en: Chapter 1
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一章
- en: 'At the end of the first chapter, you go on a scavenger hunt:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章结束时，你将进行一次寻宝游戏：
- en: '***Squirrel*** —To find the squirrel game, choose Menu > Games > Python Games.
    After you select how you would like sound (audio) to be output, you’ll see a list
    of Python games. The squirrel game is near the middle of the list. Win the game,
    and achieve Omega Squirrel.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***松鼠*** —要找到松鼠游戏，请选择菜单 > 游戏 > Python 游戏。选择你希望如何输出声音（音频）后，你将看到一系列 Python 游戏。松鼠游戏位于列表中间附近。赢得游戏，并实现欧米茄松鼠。'
- en: '***Calculator*** —Select Menu > Accessories > Calculator. 89 × 34 is 3,026.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***计算器*** —选择菜单 > 附件 > 计算器。89 × 34 等于 3,026。'
- en: '***Shutdown*** —Shut down or restart your Raspberry Pi by choosing Menu > Shutdown.
    The shutdown menu lets you choose to shut down, reboot, or log out.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***关机*** —通过选择菜单 > 关机来关闭或重新启动你的树莓派。关机菜单允许你选择关闭、重启或注销。'
- en: '***Black desktop*** —To change the desktop background to black, right-click
    anywhere on the desktop and select Desktop Preferences. In the Desktop Preferences
    window, look in the middle of the screen for a Background Color label. Click the
    white box to select a new background color. Click OK to select the color, and
    then click Close to close the Desktop Preferences window.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***黑色桌面*** —要将桌面背景更改为黑色，请右键单击桌面上的任何位置，然后选择桌面首选项。在桌面首选项窗口中，屏幕中间查找背景颜色标签。单击白色框以选择新的背景颜色。单击“确定”以选择颜色，然后单击“关闭”以关闭桌面首选项窗口。'
- en: '***Scratch bonus*** —To open Scratch, select Menu > Programming > Scratch.
    When Scratch opens, construct a program by dragging blocks into the script area
    for your cat sprite. [Figure C.1](#app03fig01) shows an example of a dancing cat
    program that makes the cat dance back and forth 10 times when the space bar is
    pressed.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Scratch 奖励*** —要打开 Scratch，请选择菜单 > 编程 > Scratch。当 Scratch 打开时，通过将程序块拖动到脚本区域为你的猫精灵构建一个程序。[图
    C.1](#app03fig01) 展示了一个示例，当按下空格键时，猫会来回跳舞 10 次。'
- en: Figure C.1\. Make the cat dance in Scratch by dragging program blocks into the
    script area.
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 C.1\. 通过将程序块拖动到脚本区域，使猫在 Scratch 中跳舞。
- en: '![](c0fig01.jpg)'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](c0fig01.jpg)'
- en: Chapter 2
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二章
- en: The challenges in this chapter are about displaying characters to the screen
    and doing some mathematics.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的挑战是关于在屏幕上显示字符和一些数学运算。
- en: The Matrix
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 矩阵
- en: 'Create a screen full of 1s and 0s by using the `print` function and the multiplication
    operator like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `print` 函数和乘法运算符创建一个由 1 和 0 组成的屏幕，如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Building a brick wall
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 建造砖墙
- en: 'To solve this one, create a variable named `brick` and give it a string of
    characters like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，创建一个名为 `brick` 的变量，并给它一个如下的字符字符串：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To make the bricks look like raspberries, you could try
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要让砖块看起来像树莓，你可以尝试
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Use your imagination to visualize that this is a sideways raspberry brick. The
    bracket is the leaf on top of the raspberry.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 用你的想象力来想象这是一个侧放的树莓砖。括号是树莓顶部的叶子。
- en: Pi electrons
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: π电子
- en: 'You’re trying to figure out how many electrons per second it takes to equal
    1 amp flowing into your Raspberry Pi. The calculation using Python looks like
    this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在尝试计算每秒需要多少个电子才能等于流入你的树莓派中的 1 安培。使用 Python 的计算如下：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The answer is 6,250,000,000,000,000,000\. That’s a lot of electrons!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 6,250,000,000,000,000,000。那可是一大堆电子！
- en: Chapter 3
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三章
- en: These challenges are about gathering input, joining together strings, and displaying
    text to the screen.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些挑战是关于收集输入、合并字符串和在屏幕上显示文本。
- en: Knight’s Tale Creator 3000
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 骑士传说创作者 3000
- en: 'To make this program, you want to first print a title and then gather a series
    of words from the player:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作这个程序，你首先需要打印一个标题，然后从玩家那里收集一系列单词：
- en: '![](264fig01_alt.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](264fig01_alt.jpg)'
- en: 'Next, you join the input words with the story. You can do this sentence by
    sentence to make the code a bit easier to follow:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将输入单词与故事连接起来。你可以逐句这样做，以使代码更容易理解：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, let’s join the sentences and display the tale to the screen:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将句子连接起来，并将故事显示在屏幕上：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Subliminal messages
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 潜意识信息
- en: 'You’re trying to create a message that’s hidden in a large display of characters.
    You start by asking for the person’s name and something they would like:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你试图创建一个隐藏在大量字符显示中的信息。你首先询问人的名字和他们想要的东西：
- en: '![](264fig02_alt.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](264fig02_alt.jpg)'
- en: 'Next, create a pattern of letters, numbers, and symbols in which you’ll hide
    the message:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个由字母、数字和符号组成的模式，你将在其中隐藏信息：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, you create the full message by making it read “You really want to
    buy [player_name] a [thing]”, but hide it by printing out on the screen the pattern
    of characters before and after the message:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你通过在屏幕上打印出消息前后字符的模式来创建完整的消息：“你真的很想为[player_name]买[thing]”，但将其隐藏：
- en: '![](265fig01_alt.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](265fig01_alt.jpg)'
- en: Chapter 4
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第四章
- en: This chapter’s challenge is about using some of your new skills, like `if`/`then`
    (or conditional) statements, as well as toolboxes like the `random` module.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的挑战是关于使用你的一些新技能，如`if`/`then`（或条件）语句，以及像`random`模块这样的工具箱。
- en: Rock, Paper, Scissors!
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 石头、纸牌、剪刀！
- en: 'For this challenge, you start by importing the `random` module, creating a
    title, and defining any variables you’re going to need:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个挑战，你首先导入`random`模块，创建一个标题，并定义你将要需要的任何变量：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, you want to display the title and then start a `while` loop that will
    gather the player’s choice and get a random computer choice:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你想要显示标题，然后启动一个`while`循环，该循环将收集玩家的选择并获取一个随机的电脑选择：
- en: '![](265fig02_alt.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](265fig02_alt.jpg)'
- en: 'You then want to display the two choices and use an `if` statement to test
    whether the player and computer choices are the same. If not, you want to check
    whether you have one of the following Player versus Computer combinations:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来想要显示两个选择，并使用一个`if`语句来测试玩家和电脑的选择是否相同。如果不相同，你想要检查你是否拥有以下玩家对电脑的组合之一：
- en: Rock (Player) beats scissors (Computer)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 石头（玩家）胜过剪刀（电脑）
- en: Scissors (Player) beats paper (Computer)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪刀（玩家）胜过纸牌（电脑）
- en: Paper (Player) beats rock (Computer)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纸牌（玩家）胜过石头（电脑）
- en: 'You program all this inside the `while` loop because you want it to be repeated
    as long as the player wants to play. At the end of the loop, the player is asked
    if they want to play again:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你将所有这些都在`while`循环中编程，因为你想要它重复，直到玩家想要再玩。在循环的末尾，玩家被问是否想要再玩一次：
- en: '![](266fig01_alt.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](266fig01_alt.jpg)'
- en: You create a large `if` statement that tests whether `player_choice` and `computer_choice`
    form one of the winning combinations. Each of the combinations is wrapped in parentheses,
    and you use `or` between them. This ensures that if any one of the combinations
    is correct, the winning message will be displayed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个大的`if`语句，用于测试`player_choice`和`computer_choice`是否形成以下获胜组合之一。每个组合都被括号括起来，你使用`or`在它们之间。这确保了如果任何一个组合是正确的，获胜信息将被显示。
- en: Chapter 5
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第五章
- en: Introducing dramatic pauses
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 介绍戏剧性停顿
- en: You were given some good hints about how to do this in [chapter 5](kindle_split_014.html#ch05).
    Rather than display too much code here, I suggest that you head over to the code
    download to see what this looks like.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第五章（kindle_split_014.html#ch05）中得到了一些关于如何做到这一点的良好提示。在这里不显示太多代码，我建议你前往代码下载区查看其外观。
- en: Random demise
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 随机死亡
- en: 'In this challenge, you’re creating a more random and exciting end for your
    adventurer, Raspi. For this, you need to import the `random` module at the top
    of your program, define some new variables for the different endings, and create
    a list of the endings. This will allow you to have the computer pick a number:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个挑战中，你正在为你的冒险家Raspi创建一个更随机和有趣的结局。为此，你需要在程序顶部导入`random`模块，定义一些用于不同结局的新变量，并创建一个结局列表。这将允许电脑选择一个数字：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You use triple quotation marks, called *string literals*, to make strings that
    span multiple lines. You also store the three different endings in a list called
    `endings`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用三引号，称为*字符串字面量*，来创建跨越多行的字符串。你还将三个不同的结局存储在一个名为`endings`的列表中。
- en: 'Finally, to solve this challenge, change the `wrong_answer` function to get
    a random number, select an ending, and then display it to the screen:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了解决这个挑战，将`wrong_answer`函数更改为获取一个随机数，选择一个结局，并将其显示在屏幕上：
- en: '![](267fig01_alt.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](267fig01_alt.jpg)'
- en: Check the code download to see how it all works together.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码下载以了解它们是如何一起工作的。
- en: Play again?
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 再玩一次？
- en: 'To add a play-again option, add a new variable at the top of your program and
    set it equal to `"Y"` to start:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加再玩一次选项，在程序顶部添加一个新变量，并将其设置为 `"Y"` 以开始：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, put all of your cave-selection logic in a `while` loop. The `while` loop
    will depend on the value of `play_again`, but you’ll use the string function `upper()`
    to make the `play_again` value all uppercase. This helps if the user accidentally
    enters `y` instead of `Y`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将所有你的洞穴选择逻辑放入 `while` 循环中。`while` 循环将取决于 `play_again` 的值，但你会使用字符串函数 `upper()`
    将 `play_again` 值全部转换为大写。这有助于用户不小心输入 `y` 而不是 `Y`：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At the end of the `while` loop, you also need to ask the user if they want
    to play again. Store their response in the `play_again` variable:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 循环结束时，你还需要询问用户是否想要再玩一次。将他们的响应存储在 `play_again` 变量中：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another part of this challenge is adding a scream sound (or any other sound
    you want). First, make sure you import the `os` module and set up a variable with
    a sound file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战的另一个部分是添加尖叫声（或任何你想要的其他声音）。首先，确保你导入了 `os` 模块，并设置一个包含声音文件的变量：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add a new line to the `wrong_answer` function that calls OMXPlayer and tells
    it to play the scream sound:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `wrong_answer` 函数中添加一行新代码，调用 OMXPlayer 并告诉它播放尖叫声：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the program to test it out! Add it to all the other game-over endings in
    the game to make it even more fun!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序以测试它！将其添加到游戏中所有其他游戏结束部分，使其更加有趣！
- en: '|  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you have speakers or headphones connected, or you won’t hear anything.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的扬声器或耳机已连接，否则你将听不到任何声音。
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Chapter 6
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第六章
- en: Wave pattern
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 波形模式
- en: 'Let’s turn on each LED one by one. Then, when they’re all on, you’ll turn them
    off one by one. Each light is turned on or off by setting its state to `HIGH`
    (on) or `LOW` (off). You create the sequence by adding a time delay between each
    command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个开启每个 LED。然后，当它们都开启后，你将逐个关闭它们。每个灯光通过将其状态设置为 `HIGH`（开启）或 `LOW`（关闭）来开启或关闭。你通过在每条命令之间添加时间延迟来创建序列：
- en: '![](268fig01_alt.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](268fig01_alt.jpg)'
- en: You can adjust the sleep time to get a faster or slower animation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调整睡眠时间以获得更快或更慢的动画。
- en: Simon says
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Simon says
- en: 'In this challenge, you’re creating a program that blinks lights in a pattern
    like the classic game *Simon*. As before, the program requires that the GPIO and
    time modules be imported and the GPIO pins be set up properly. See the code download
    for the full code listing. Start by defining the `simon_says` function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个挑战中，你需要创建一个程序，使灯光按照经典游戏 *Simon* 的模式闪烁。和之前一样，程序需要导入 GPIO 和时间模块，并正确设置 GPIO
    引脚。请参阅代码下载以获取完整的代码列表。首先定义 `simon_says` 函数：
- en: '![](269fig01_alt.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](269fig01_alt.jpg)'
- en: 'This creates a list with all the colors and loops through them one by one.
    For each one, the function checks its value and turns on and off the LED of that
    color. To use the function, you call it and give it the pattern you want to create,
    along with some helpful messages:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个包含所有颜色的列表，并逐个遍历它们。对于每一个，函数都会检查其值并开启和关闭该颜色的 LED。要使用该函数，你需要调用它，并给它你想要创建的模式，以及一些有用的信息：
- en: '![](270fig01_alt.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](270fig01_alt.jpg)'
- en: Go, Simon, go!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 去吧，Simon，出发！
- en: Random blinking
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 随机闪烁
- en: 'This challenge is about blinking LEDs on and off for random amounts of time
    between 0 and 3 seconds. Let’s see how to do it. I won’t show the top part of
    the program with the typical setup of the GPIO pins; refer to the code download
    for the full code listing. At the top of your program, don’t forget to import
    the `random` module so you can use it to generate random numbers:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战是关于在 0 到 3 秒之间随机闪烁 LED 的。让我们看看如何做到这一点。我不会展示程序的上半部分，即 GPIO 引脚的典型设置；请参阅代码下载以获取完整的代码列表。在程序顶部，别忘了导入
    `random` 模块，以便你可以使用它来生成随机数：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To accomplish this challenge, you need to create two variables and store in
    them a random number between 0 and 3\. These variables are the amount of time
    the lights should stay on and off:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个挑战，你需要创建两个变量，并将介于 0 和 3 之间的随机数存储在它们中。这些变量是灯光应该开启和关闭的时间长度：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, you can use the random time with the `sleep` function to make the light
    blink. Put this inside a loop, making sure that each time through the loop, new
    random on and off times are created:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用 `sleep` 函数和随机时间来使灯光闪烁。将此放在循环中，确保每次通过循环时都创建新的随机开启和关闭时间：
- en: '![](271fig01_alt.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](271fig01_alt.jpg)'
- en: The off and on times change each time through the loop. Enjoy some fun blinking!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭和开启时间每次通过循环时都会改变。享受一些有趣的闪烁吧！
- en: Chapter 7
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第七章
- en: The chapter challenges involve using your Guessing Game and controlling the
    RGB LED.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本章挑战涉及使用你的猜测游戏和控制RGB LED。
- en: Game winner
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 游戏赢家
- en: 'Let’s write a function to quickly flash the RGB LED three different colors.
    Define a new function called `winning_flash`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数来快速闪烁RGB LED三种不同的颜色。定义一个新的函数叫做`winning_flash`：
- en: '![](271fig02_alt.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](271fig02_alt.jpg)'
- en: If you need help figuring out where to add this function and call it in your
    code, check the code download for more answers. You add it to the `if` statement
    when `guess` is equal to `number_in_my_head` so you get a wonderful flashing celebration
    when you win.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助确定在哪里添加这个函数并在代码中调用它，请查看代码下载以获取更多答案。你需要在`guess`等于`number_in_my_head`时添加到`if`语句中，这样你就能在获胜时得到一个精彩的闪烁庆祝。
- en: Easter egg
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复活节彩蛋
- en: 'To make an Easter egg in your program, you need to have the code check to see
    whether the player entered a certain value instead of the usual number guess.
    Edit the main portion of the logic for the LED Guessing Game program to first
    check whether the secret word was entered. If it wasn’t, the program continues
    to convert the input text into an integer and check whether the guess was correct,
    too high, or too low. If the player enters the word *Spam*, you call an `easter_egg`
    function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的程序中创建一个复活节彩蛋，你需要让代码检查玩家是否输入了特定的值而不是通常的数字猜测。编辑LED猜测游戏程序的主要逻辑部分，首先检查是否输入了秘密单词。如果没有，程序将继续将输入文本转换为整数，并检查猜测是否正确、过高或过低。如果玩家输入了单词*Spam*，你将调用一个`easter_egg`函数：
- en: '![](272fig01_alt.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](272fig01_alt.jpg)'
- en: As a special bonus, you can create an `easter_egg` function that displays a
    Spam song or whatever message you’d like.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项特别奖励，你可以创建一个显示Spam歌曲或你想要的任何信息的`easter_egg`函数。
- en: '![](273fig01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](273fig01.jpg)'
- en: 'In the `easter_egg` function, you call a `crazy_flash` function. The one shown
    here makes the RGB LED quickly flash purple and green. It’s similar to how you
    created the `winning_flash` function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`easter_egg`函数中，你调用一个`crazy_flash`函数。这里展示的函数会使RGB LED快速闪烁紫色和绿色。这与你创建的`winning_flash`函数类似：
- en: '![](273fig02_alt.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](273fig02_alt.jpg)'
- en: Create your own `easter_egg` and `crazy_flash` functions, or see the code download
    for example ones that you can modify.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你自己的`easter_egg`和`crazy_flash`函数，或者查看代码下载以获取可以修改的示例。
- en: Warmer and colder
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更热和更冷
- en: 'Let’s alter the guessing game to flash slower if you’re colder or further from
    the correct answer, and flash faster if you’re warmer or closer to the correct
    answer. Add some calculations so that `blink_time` is determined by the difference
    between the guess and the correct answer:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感觉更冷或者离正确答案更远，就让我们把猜测游戏中的闪烁速度放慢；如果你感觉更热或者离正确答案更近，就加快闪烁速度。添加一些计算，使得`blink_time`由猜测值与正确答案之间的差异决定：
- en: '![](274fig01_alt.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](274fig01_alt.jpg)'
- en: 'The `abs` function gets the absolute value—the distance a number is from zero.
    You need to do this because you can’t tell your Pi to sleep for a negative amount
    of time. That would be silly! You make this addition for both cases: when the
    player’s guess is higher and lower than the actual number. You divide the numbers
    by 10 to speed up `blink_time` and make sure your light isn’t blinking too slowly.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`abs`函数获取绝对值——一个数字与零之间的距离。你需要这样做，因为你不能告诉你的Pi设备睡眠负数时间。那会很愚蠢！你需要在两种情况下都进行这个加法：当玩家的猜测值高于或低于实际数字时。你将数字除以10来加快`blink_time`，并确保你的灯光不会闪烁得太慢。'
- en: Finally, a nice touch is to add extra information to the game instructions so
    the player knows the blinking speed gives them a hint about how close or far they
    are. See the code download for an example.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个很好的细节是向游戏说明中添加额外信息，让玩家知道闪烁速度可以给他们提供接近或远离答案的提示。查看代码下载以获取示例。
- en: Darth Vader surprise
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Darth Vader惊喜
- en: Using what you learned in [chapter 7](kindle_split_017.html#ch07) and a couple
    of new things, let’s see if you can make a Darth Vader image pop up on the screen
    when you lose the game. You’ll need an internet connection for the next few steps.
    Download a good Darth Vader image from the web, and make sure to save it to the
    home\pi folder where your Python programs are located. Take special note of the
    filename.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你在[第7章](kindle_split_017.html#ch07)中学到的知识和一些新东西，让我们看看你能否在游戏中失败时在屏幕上弹出Darth
    Vader的图像。接下来的几个步骤你需要一个互联网连接。从网上下载一张好的Darth Vader图像，并确保将其保存到你的Python程序所在的home\pi文件夹中。特别注意文件名。
- en: 'After downloading the image, install the `fim` image-viewing software on your
    Raspberry Pi:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下载图片后，在你的Raspberry Pi上安装`fim`图片查看软件：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you include a line at the top of the program to import the `os` module.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在程序顶部包含一行来导入`os`模块。
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'When it’s done, test that `fim` works from Terminal:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，在终端中测试`fim`是否工作：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When `fim` is running, you need to press Esc (escape) to exit.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当`fim`正在运行时，你需要按Esc（escape）键退出。
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: When you exit `fim`, the screen will display remnants of the image. It’s a funny
    issue, which you can fix by grabbing one of your windows by the title bar and
    swiping it around the screen to erase the image remnants and return it to the
    normal Raspbian desktop appearance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你退出`fim`时，屏幕将显示图像的残留部分。这是一个有趣的问题，你可以通过抓住你的窗口的标题栏并在屏幕上滑动它来擦除图像残留并恢复到正常的Raspbian桌面外观。
- en: 'In the Guessing Game, because you need to call `fim` from your Python program,
    add a line to import the `os` module at the top of the program:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在猜谜游戏中，因为你需要从你的Python程序中调用`fim`，所以在程序顶部添加一行来导入`os`模块：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, edit the `game_over` function to display the image. The `game_over` function
    is called only when the player guesses incorrectly five times:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑`game_over`函数以显示图像。`game_over`函数仅在玩家猜错五次时调用：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice that you use `fim` with the `–a` option to display Darth Vader. This
    option automatically scales the image to fill the full screen. Here are some commands
    you can use to rotate or resize the image when it’s displayed on the screen:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你使用带有`–a`选项的`fim`来显示达斯·维德。此选项会自动调整图像以填充整个屏幕。以下是一些你可以在屏幕上显示图像时使用的命令来旋转或调整图像大小：
- en: '| Option | Result |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| Option | 结果 |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| +/- | Zoom in/out |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| +/- | 放大/缩小 |'
- en: '| A | Automatically scale |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| A | 自动缩放 |'
- en: '| F | Flip |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| F | 翻转 |'
- en: '| M | Mirror |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| M | 镜像 |'
- en: '| R/r | Rotate 10 degrees clockwise / counterclockwise |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| R/r | 顺时针/逆时针旋转10度 |'
- en: '| Esc/q | Quit |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| Esc/q | 退出 |'
- en: Test it to see if it works!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一下看看是否工作！
- en: Chapter 8
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第8章
- en: Let’s see what fun things you can do with buttons.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你能用按钮做些什么有趣的事情。
- en: Double button press surprise
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 双击按钮惊喜
- en: This challenge involves taking the project from the chapter and making something
    new and different happen when both buttons are pressed at the same time. In this
    case, you’ll make your Pi play a percussion sound to go with your vocals and music.
    You don’t need to change any of the wiring because you already have the two buttons.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战涉及从章节中获取项目，并在同时按下两个按钮时使项目发生新的不同的事情。在这种情况下，你将让你的Pi播放打击乐声音，以配合你的声音和音乐。你不需要更改任何接线，因为你已经有了两个按钮。
- en: 'First let’s add some code at the top of the program to create a path to where
    the sound effects are stored:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在程序顶部添加一些代码来创建存储音效的路径：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next get a list of effects from the folder and store the list in a variable,
    `sounds_effects`. Put this next to where you load the other lists:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从文件夹中获取效果列表，并将列表存储在变量`sounds_effects`中。将此放在加载其他列表的旁边：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, you need to tell your program to check whether button 1 and button
    2 are pressed. You’re going to modify the main game loop to first check if both
    are being pressed. You use the `if`/`elif` statement for this. Use the Boolean
    “and” operator—the ampersand (`&`)—to make this `if` statement true only if both
    button 1 and button 2 are pressed. If they aren’t, the statement will next check
    button 1, and finally it will check button 2:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要让程序检查按钮1和按钮2是否被按下。你将修改主游戏循环，首先检查两个按钮是否都被按下。你使用`if`/`elif`语句来做这件事。使用布尔“与”运算符（`&`）来使这个`if`语句仅在按钮1和按钮2都被按下时为真。如果不是，该语句将接下来检查按钮1，最后检查按钮2：
- en: '![](276fig01_alt.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](276fig01_alt.jpg)'
- en: Let’s test to see if it works! Check out the code download if you need further
    details on the program.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下看看是否工作！如果你需要关于程序的更多详细信息，请查看代码下载。
- en: Yoda Magic 8 Ball
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 约达魔法8球
- en: Before you dive into the programming for this challenge, you need to work on
    the hardware. Because this challenge needs only one button, remove button 2 from
    the breadboard, along with its jumper wires and resistor. Your breadboard should
    have one button now, connected to GPIO 6.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编写这个挑战的编程代码之前，你需要处理硬件。因为这个挑战只需要一个按钮，所以从面包板上移除按钮2及其跳线电阻。现在你的面包板上应该只剩下一个按钮，连接到GPIO
    6。
- en: 'Next, gather a set of Yoda sounds. You can download sounds from Soundboard
    once you create a free account. For this example solution, you’ll use five sound
    files, but feel free to use any ones you want. Make sure they’re MP3 sound files
    so they’ll work with OMXPlayer. The Yoda sound files in this example solution
    are as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，收集一组尤达声音。一旦您创建了一个免费账户，您就可以从Soundboard下载声音。对于这个示例解决方案，您将使用五个声音文件，但请随意使用您想要的任何文件。确保它们是MP3声音文件，这样它们才能与OMXPlayer一起工作。本示例解决方案中的尤达声音文件如下：
- en: Fear in You.mp3
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fear in You.mp3
- en: I am strong.mp3
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I am strong.mp3
- en: No.mp3
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: No.mp3
- en: Patience.mp3
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Patience.mp3
- en: Use the Force.mp3
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Use the Force.mp3
- en: Much like the classic Magic 8 Ball game, the answers are sometimes clear and
    other times strange or unclear.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与经典的魔法8球游戏类似，答案有时清晰，有时奇怪或不清晰。
- en: 'As in the DJ Raspi project, you need to import several modules for this project,
    set up your Pi’s GPIO pin for input (detecting electrical signals), and create
    some variables. Most notably, you need to create a variable for the folder with
    your Yoda sound files:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如DJ Raspi项目一样，您需要为此项目导入几个模块，设置Pi的GPIO引脚用于输入（检测电信号），并创建一些变量。最值得注意的是，您需要为包含您的尤达声音文件的文件夹创建一个变量：
- en: '![](277fig01_alt.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](277fig01_alt.jpg)'
- en: 'Use the same `get_MP3_sounds` and `play_random_sound` functions from your DJ
    Raspi project. One slight improvement you can make to the `play_random_sound`
    function is to hide the messages that OMXPlayer displays on the screen (they make
    it harder to read what the game is telling you to do). Change this one line to
    divert all the output messages to an empty or null location:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自您的DJ Raspi项目的相同`get_MP3_sounds`和`play_random_sound`函数。您可以对`play_random_sound`函数进行的一个小改进是隐藏OMXPlayer在屏幕上显示的消息（它们使得阅读游戏告诉您做什么变得更困难）。将这一行更改为将所有输出消息重定向到空或空位置：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a great example of being able to reuse code! Next, you’ll gather the
    list of MP3 Yoda sounds from the folder.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个能够重用代码的绝佳例子！接下来，您将从文件夹中收集MP3尤达声音列表。
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After printing out a nice title, you then show instructions to the player and
    enter the main loop that checks whether the button was pressed. In this loop,
    you call the `play_random_sound` function so the Raspberry Pi responds with an
    answer to the player’s question:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印出漂亮的标题后，然后向玩家展示说明并进入主循环，该循环检查按钮是否被按下。在这个循环中，您调用`play_random_sound`函数，这样树莓派就会对玩家的提问做出回答：
- en: '![](278fig01_alt.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](278fig01_alt.jpg)'
- en: Enjoy making your future decisions with the help of Yoda!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在尤达的帮助下享受做出您未来决策的乐趣！
