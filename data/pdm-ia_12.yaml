- en: 9 Podman as a service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 Podman 作为服务
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Running Podman as a service
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以服务形式运行 Podman
- en: Podman service support for two REST APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 服务支持两个 REST API
- en: Python libraries podman-py and docker-py for managing Podman containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于管理 Podman 容器的 Python 库 podman-py 和 docker-py
- en: Support for `docker-compose`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 `docker-compose`
- en: Remote command-line communication with the Podman service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Podman 服务进行远程命令行通信
- en: Managing SSH communications with remote Podman instances
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理与远程 Podman 实例的 SSH 通信
- en: In previous chapters, you learned about the Podman command line. The problem
    with this is sometimes you want to work with containers from a remote system.
    Similarly, you might want to write code in a scripting language to interact with
    containers. Docker, being written as a client-server application, supports a popular
    remote API, which led to the creation of libraries written in Python and JavaScript
    to access the daemon. Docker-py is a popular Python library used to interact with
    the Docker daemon.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了 Podman 命令行。问题是有时你想要从远程系统与容器一起工作。同样，你可能想用脚本语言编写代码来与容器交互。Docker 作为客户端-服务器应用程序编写，支持流行的远程
    API，这导致了用 Python 和 JavaScript 编写的库的创建，用于访问守护进程。Docker-py 是一个流行的 Python 库，用于与 Docker
    守护进程交互。
- en: Many CI/CD, GUI, and remote management systems have been built to manage Docker
    containers. Code editors like Visual Studio even have built-in plug-ins that talk
    directly to the Docker API. Advanced tools like `docker-compose` led to a new
    programming language that is used to orchestrate multiple containers on a host
    by interacting with the Docker daemon.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 已经构建了许多 CI/CD、GUI 和远程管理系统来管理 Docker 容器。像 Visual Studio 这样的代码编辑器甚至有内置的插件，可以直接与
    Docker API 通信。像 `docker-compose` 这样的高级工具导致了一种新的编程语言的出现，该语言通过与 Docker 守护进程交互来在主机上编排多个容器。
- en: Podman provides similar features and can be run as a service. Podman supports
    running the Podman service in rootless as well as rootful mode. In this chapter,
    you will learn about the service and how to interact with it. You will write a
    simple program in Python that uses the docker-py and newer podman-py libraries
    to interact with the Podman service. You will learn how to set up remote Docker-based
    tools, including `docker-compose`, to actually use the Podman service, with no
    Docker daemon available.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 提供类似的功能，可以作为服务运行。Podman 支持以无根模式以及有根模式运行 Podman 服务。在本章中，你将了解服务以及如何与之交互。你将编写一个简单的
    Python 程序，使用 docker-py 和较新的 podman-py 库与 Podman 服务进行交互。你将学习如何设置基于 Docker 的远程工具，包括
    `docker-compose`，以实际使用 Podman 服务，即使没有可用的 Docker 守护进程。
- en: Note The Podman service is only supported on Linux. Because the Podman service
    launches Linux containers, it only runs on Linux machines. Windows and Mac versions
    of Podman communicate with the Podman service over the REST API to launch containers.
    For more information on Podman on Mac, see appendix E, and for Windows, see appendix
    F.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Podman 服务仅在 Linux 上受支持。因为 Podman 服务启动 Linux 容器，所以它只能在 Linux 机器上运行。Podman
    的 Windows 和 Mac 版本通过 REST API 与 Podman 服务通信以启动容器。有关 Podman 在 Mac 上的更多信息，请参阅附录
    E，有关 Windows 的更多信息，请参阅附录 F。
- en: The Podman command has a `--remote` option that allows you to interact with
    the Podman service, either on the local machine or, most often, on a remote machine.
    You will learn to set up the Podman connections to make interacting with remote
    services easy and secure. But first you need to know how to enable the Podman
    service.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 命令有一个 `--remote` 选项，允许你与 Podman 服务交互，无论是在本地机器上还是在远程机器上。你将学习如何设置 Podman
    连接，以便轻松且安全地与远程服务交互。但首先你需要知道如何启用 Podman 服务。
- en: 9.1 Introducing the Podman service
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 Podman 服务的介绍
- en: The Podman project supports a REST (or RESTful) API. The `podman` `system` `service`
    command creates a listening service that answers API calls for Podman. The service
    can be run in rootful or rootless mode. This command offers an optional argument
    to specify a URI on which the Podman service will listen. For example, the unix:///tmp/
    podman.sock URI tells Podman to listen on the /tmp/podman.sock UNIX domain socket.
    The tcp:localhost:10000 URI socket tells Podman to listen on TCP socket, port
    `10000`. By default, Podman listens on a UNIX domain socket under the /run directory
    (table 9.1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 项目支持 REST（或 RESTful）API。`podman` `system` `service` 命令创建一个监听服务，用于响应 Podman
    的 API 调用。该服务可以在有根模式或无根模式下运行。此命令提供了一个可选参数，用于指定 Podman 服务将监听的 URI。例如，unix:///tmp/podman.sock
    URI 告诉 Podman 在 /tmp/podman.sock UNIX 域套接字上监听。tcp:localhost:10000 URI 套接字告诉 Podman
    在 TCP 套接字、端口 `10000` 上监听。默认情况下，Podman 在 /run 目录下的 UNIX 域套接字上监听（表 9.1）。
- en: 'Note If you are not familiar with REST API or remote APIs in general, I recommend
    that you read “What is a REST API?” by Red Hat: [https://www.redhat.com/en/topics/api/what-is-a-rest-api](https://www.redhat.com/en/topics/api/what-is-a-rest-api).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您不熟悉 REST API 或一般远程 API，我建议您阅读 Red Hat 的“什么是 REST API？”：[https://www.redhat.com/en/topics/api/what-is-a-rest-api](https://www.redhat.com/en/topics/api/what-is-a-rest-api)。
- en: Podman running as a service in this case is different from having a centralized
    daemon, like Docker does, in multiple ways. The biggest difference is that the
    Podman command can run without the service and interacts with containers and images
    created by the service. Other container tools can interact with the storage and
    containers without going through the service. The service also exits when there
    are no connections to it. You could even run multiple services at the same time
    on the same datastore (although I would not recommend this). The Docker daemon
    forces all interaction with containers and images to go through the daemon. Table
    9.1 shows the default locations where the Podman service listens for incoming
    connections.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Podman 作为服务运行与像 Docker 那样拥有集中式守护进程的方式在多个方面不同。最大的区别是 Podman 命令可以在没有服务的情况下运行，并与由服务创建的容器和镜像交互。其他容器工具可以在不通过服务的情况下与存储和容器交互。当没有连接到服务时，服务也会退出。您甚至可以在同一数据存储上同时运行多个服务（尽管我不推荐这样做）。Docker
    守护进程强制所有与容器和镜像的交互都通过守护进程进行。表 9.1 显示了 Podman 服务监听传入连接的默认位置。
- en: Table 9.1 Default locations for the podman.socket
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 podman.socket 的默认位置
- en: '| Mode | Default location |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 默认位置 |'
- en: '| Rootful | unix:///run/podman/podman.sock |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 有根 | unix:///run/podman/podman.sock |'
- en: '| Rootless | unix://$XDG_RUNTIME_DIR/podman/podman.sockexample unix:///run/user/1000/podman/podman.sock)
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 无根 | unix://$XDG_RUNTIME_DIR/podman/podman.sock（例如 unix:///run/user/1000/podman/podman.sock）
    |'
- en: Although the Podman service can be set up to run on a TCP socket as well, I
    caution you to be very careful because there is no authorization or additional
    security built into the service to prevent hackers from gaining access. The service
    relies on the SSH service to gain remote access to the Podman service, and this
    approach is recommended.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Podman 服务也可以设置为在 TCP 套接字上运行，但我警告您要非常小心，因为服务中没有任何授权或额外的安全措施来防止黑客获取访问权限。服务依赖于
    SSH 服务来获取对 Podman 服务的远程访问，并且这种方法是推荐的。
- en: 'The Podman service was designed to run as an on-demand service, exiting 5 seconds
    after the last connection. This time limit avoids a long-running daemon that uses
    system resources even when the service is not being used. While the Podman service
    could launch a separate process for each connection, this could become a bottleneck.
    Try this out by running the following command; after 5 seconds you will see the
    command exit. If you had active connections to the service, it would continue
    to run:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 服务被设计为按需服务，在最后一个连接后退出，5秒后结束。这个时间限制避免了即使服务未被使用，长时间运行的守护进程也会占用系统资源。虽然 Podman
    服务可以为每个连接启动一个单独的进程，但这可能会成为瓶颈。通过运行以下命令来尝试一下；5秒后，您将看到命令退出。如果您与服务有活跃的连接，它将继续运行：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can specify the timeout for this exit in seconds with the `--time` option.
    Specifying `--time` `0` causes the `podman` `system` `service` command to run
    until you stop it. Most users never interact directly with the Podman system service
    to activate the service but rely on systemd services to manage it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `--time` 选项指定退出超时时间（以秒为单位）。指定 `--time` `0` 将导致 `podman` `system` `service`
    命令运行，直到您停止它。大多数用户从不直接与 Podman 系统服务交互以激活服务，而是依赖于 systemd 服务来管理它。
- en: 9.1.1 Systemd services
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 系统服务
- en: Podman provides multiple systemd unit files for running Podman as a service.
    Because Podman was not designed as a daemon, and the developers did not want to
    always have a long-running daemon, they decided to take advantage of systemd socket
    activation. This allows the Podman service to be launched as an on-demand service.
    Figure 9.1 shows how systemd listens on the Podman socket and then launches the
    Podman service when it receives a connection.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 提供了多个 systemd 单元文件，用于以服务形式运行 Podman。由于 Podman 并未设计为守护进程，并且开发者不希望总是有一个长时间运行的守护进程，他们决定利用
    systemd 套接字激活。这允许 Podman 服务作为按需服务启动。图 9.1 展示了 systemd 如何监听 Podman 套接字，并在收到连接时启动
    Podman 服务。
- en: '![](../../OEBPS/Images/09-01.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/09-01.png)'
- en: Figure 9.1 Podman service running under systemd
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 在 systemd 下运行的 Podman 服务
- en: 'The Podman package provides two podman.socket unit files: one for rootful Podman
    and the other for rootless Podman. Table 9.2 defines the location of the systemd
    socket files to be used in rootful and rootless mode.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 软件包提供了两个 podman.socket 单元文件：一个用于有根 Podman，另一个用于无根 Podman。表 9.2 定义了在有根和无根模式下使用的
    systemd 套接字文件的位置。
- en: Table 9.2 Podman socket unit files
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.2 Podman 套接字单元文件
- en: '| Mode | Systemd socket file |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | Systemd 套接字文件 |'
- en: '| Rootful | /usr/lib/systemd/system/podman.socket |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 有根 | /usr/lib/systemd/system/podman.socket |'
- en: '| Rootless | /usr/lib/systemd/user/podman.socket |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 无根 | /usr/lib/systemd/user/podman.socket |'
- en: These two socket activation services tell systemd to listen on the default UNIX
    domain socket listed in table 9.1\. When a process connects to the socket, systemd
    launches the matching service, which runs the `podman` `system` `service` command.
    Systemd then hands the socket off to the service. After the Podman service completes
    the API request, it waits for another connection. If no connection happens for
    5 seconds, Podman exits, freeing up the resources it was using. If a new connection
    comes in, systemd repeats the process and launches a new instance of the Podman
    service.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个套接字激活服务告诉 systemd 监听表 9.1 中列出的默认 UNIX 域套接字。当进程连接到套接字时，systemd 启动匹配的服务，该服务运行
    `podman` `system` `service` 命令。然后 systemd 将套接字传递给服务。当 Podman 服务完成 API 请求后，它等待另一个连接。如果
    5 秒内没有连接发生，Podman 将退出，释放其使用的资源。如果出现新的连接，systemd 重复此过程并启动 Podman 服务的另一个实例。
- en: 'In the rest of this chapter, you will be interacting with the Podman service,
    so you need to start running it. You can enable and start the Podman socket on
    your machine using the `--user` option, which tells systemd to enable the user
    service (or rootless mode service):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，你将交互使用 Podman 服务，因此你需要开始运行它。你可以使用 `--user` 选项在你的机器上启用并启动 Podman 套接字，这告诉
    systemd 启用用户服务（或无根模式服务）：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can see that the podman.sock has been created in your `XDG_RUNTIME_DIR`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 podman.sock 已在你的 `XDG_RUNTIME_DIR` 中创建：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this point, the systemd is listening on the socket, and there is no Podman
    process running. When a packet comes into the service, systemd launches the Podman
    service process to handle the connection.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，systemd 正在监听套接字，但没有 Podman 进程在运行。当服务接收到数据包时，systemd 启动 Podman 服务进程来处理连接。
- en: 'To try out the service, you can run the following `curl` command to probe for
    the version on the Podman service:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试该服务，你可以运行以下 `curl` 命令来探测 Podman 服务的版本：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that you have the service running, it’s time to investigate the APIs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经运行了服务，是时候调查 API 了。
- en: 9.2 Podman-supported APIs
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 Podman 支持的 API
- en: The Podman service provides two APIs over the same socket (table 9.1). The compatibility
    API targets the latest released version of the Docker API, implementing all endpoints,
    except the Swarm APIs. The Podman team treats any problem concerning a difference
    with the Docker API as a bug. If the API works against the Docker daemon, it must
    work against the Podman service.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 服务在相同的套接字（表 9.1）上提供两个 API。兼容 API 面向 Docker API 的最新发布版本，实现了所有端点，除了 Swarm
    API。Podman 团队将任何与 Docker API 差异相关的问题视为一个错误。如果 API 对 Docker 守护进程有效，则它必须对 Podman
    服务有效。
- en: The Podman Libpod API provides support for Podman’s unique features, such as
    pods. While it would be great for all projects to support the native Libpod API,
    it takes time to transition, and it may be impossible for older, no-longer-maintained
    projects based on the Docker API.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Podman Libpod API 提供了对 Podman 独特功能的支持，例如 pods。虽然所有项目都支持本机 Libpod API 将是件好事，但过渡需要时间，并且对于基于
    Docker API 的较老且不再维护的项目来说可能是不可能的。
- en: I recommend that all new users of Podman work with the Libpod API, but if you
    are using legacy code or want to develop code that will work with both Podman
    and Docker, then you should use the compatibility API. Table 9.3 lists the two
    different REST APIs provided by Podman.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议所有新的 Podman 用户使用 Libpod API，但如果你正在使用遗留代码或想要开发既可与 Podman 也可与 Docker 一起工作的代码，那么你应该使用兼容
    API。表 9.3 列出了 Podman 提供的两个不同的 REST API。
- en: Table 9.3 Podman-supported APIs
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.3 Podman 支持的 API
- en: '| Mode | Description | Documentation |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 描述 | 文档 |'
- en: '| Compatibility | A compatibility layer offering support for the Docker v1.40
    API | [https://docs.docker.com/engine/api/](https://docs.docker.com/engine/api/)
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 兼容性 | 提供对 Docker v1.40 API 支持的兼容层 | [https://docs.docker.com/engine/api/](https://docs.docker.com/engine/api/)
    |'
- en: '| Libpod | A Podman-native Libpod layer | [https://docs.podman.io/en/latest/_static/api.xhtml](https://docs.podman.io/en/latest/_static/api.xhtml)
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| Libpod | Podman 原生的 Libpod 层 | [https://docs.podman.io/en/latest/_static/api.xhtml](https://docs.podman.io/en/latest/_static/api.xhtml)
    |'
- en: The easiest way to interact with the remote API is via the `curl` command. Examine
    the list of images available with the `curl` command and the `jq` command to pretty-print
    the JSON code. Also notice the `libpod` field in the URL. This field tells Podman
    to use its native API.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与远程 API 交互的最简单方法是使用 `curl` 命令。检查使用 `curl` 命令和 `jq` 命令可用的图像列表，并注意 URL 中的 `libpod`
    字段。此字段告诉 Podman 使用其原生 API。
- en: Listing 9.1 The default output when connecting `curl` to the Podman socket
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 将 `curl` 连接到 Podman 套接字时的默认输出
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The image you have been working on
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 你一直在工作的镜像
- en: 'You can also run the Docker API by eliminating the `libpod` field. For this
    command, you get the same output because the APIs have the same output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过消除 `libpod` 字段来运行 Docker API。对于这个命令，你得到相同的输出，因为 API 有相同的输出：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An example in which the APIs differ is listing pods, since Docker does not support
    the concept of a pod, the `compat` API does not have interfaces for it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 API 不同的例子是列出 pods，因为 Docker 不支持 pod 的概念，所以 `compat` API 没有针对它的接口。
- en: 'First, create a pod for the test by running the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过运行以下命令为测试创建一个 pod：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, use the Libpod pods or JSON API to see JSON related to the pod you just
    created:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 Libpod pods 或 JSON API 来查看与你刚刚创建的 pod 相关的 JSON：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you try the same query against the Docker API endpoint, it fails with a Not
    Found error.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试对 Docker API 端点执行相同的查询，它将因找不到错误而失败。
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is because the Docker API and Docker itself do not understand pods. While
    you can do a lot of testing with the API directly with tools like `curl`, it is
    better to have higher-level languages to interact with the API, such as Python.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Docker API 和 Docker 本身都不理解 pods。虽然你可以使用 `curl` 等工具直接通过 API 进行大量测试，但使用像
    Python 这样的高级语言与 API 交互会更好。
- en: 9.3 Python libraries for interacting with Podman
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 与 Podman 交互的 Python 库
- en: 'Python is arguably the most popular scripting language on Linux platforms.
    Almost every Linux system has Python installed by default. Just like the API,
    there are two very similar Python libraries available: the docker-py library,
    which works with the compatibility library, and podman-py, which supports the
    newer Libpod API. This section uses some Python commands and might require a limited
    knowledge of Python but is easy enough for you to follow along if you have limited
    experience.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python 可以说是 Linux 平台上最受欢迎的脚本语言。几乎每个 Linux 系统都默认安装了 Python。就像 API 一样，有两个非常相似的
    Python 库可用：与兼容库一起工作的 docker-py 库，以及支持较新 Libpod API 的 podman-py。本节将使用一些 Python
    命令，可能需要有限的 Python 知识，但如果你经验有限，也足够你跟随。
- en: 9.3.1 Using docker-py with the Podman API
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 使用 docker-py 与 Podman API 一起使用
- en: The most popular Python package for interacting with containers is docker-py
    ([https://github.com/docker/docker-py](https://github.com/docker/docker-py)).
    Docker-py is a Python bindings library used originally to communicate with the
    Docker daemon. It can also communicate with the Podman compatibility service.
    The Docker-py library allows you to run the same containers as the Podman command,
    except you can do it from Python.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与容器交互最流行的 Python 包是 docker-py ([https://github.com/docker/docker-py](https://github.com/docker/docker-py)).
    Docker-py 是一个最初用于与 Docker 守护进程通信的 Python 绑定库。它也可以与 Podman 兼容服务通信。Docker-py 库允许你运行与
    Podman 命令相同的容器，但你可以在 Python 中完成这项操作。
- en: Thousands of tools and examples built on docker-py exist and are running in
    production. These tools have been used for CI/CD systems as well as GUIs, management
    tools, and debugging tools. For these commands, you can use the Podman `compat`
    API, which works fine with docker-py.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 基于docker-py构建了数千个工具和示例，并在生产环境中运行。这些工具已被用于 CI/CD 系统、GUI、管理工具和调试工具。对于这些命令，你可以使用
    Podman `compat` API，它与 docker-py 一起工作得很好。
- en: Usually, you can install docker-py with `apt-get` or `dnf` `install`. It is
    also available via PyPI. Consult the install commands for your Linux platform.
    On RPM-based systems, the package is called `python-docker`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以使用 `apt-get` 或 `dnf install` 安装 docker-py。它也通过 PyPI 提供。请咨询您 Linux 平台的安装命令。在基于
    RPM 的系统上，该软件包称为 `python-docker`。
- en: 'On my Red Hat-based system, I install it using the following `dnf` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的基于 Red Hat 的系统上，我使用以下 `dnf` 命令安装它：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After docker-py is installed, you can start using it to interact with the Podman
    service. Imagine you want to build a Python script to interact with the Podman
    service to list the currently available images. Notice I have to reset the `DockerClient`
    URL to point at the Podman socket. You might have to modify the location of podman.sock
    on your system:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 docker-py 安装后，你可以开始使用它来与 Podman 服务交互。想象一下，你想要编写一个 Python 脚本来与 Podman 服务交互，列出当前可用的镜像。注意我必须将
    `DockerClient` 的 URL 重置为指向 Podman 套接字。你可能需要修改系统上 podman.sock 的位置：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the images.py script, and see the images installed on your box:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 images.py 脚本，查看你盒子上安装的镜像：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is inconvenient to have to fully specify the path to the Podman socket inside
    the Python script, but luckily, Docker tools support a special environment variable
    called `DOCKER_HOST`. You can set `DOCKER_HOST` to point at the socket that implements
    the Docker API.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 脚本中完全指定 Podman 套接字的路径是不方便的，但幸运的是，Docker 工具支持一个名为 `DOCKER_HOST` 的特殊环境变量。你可以设置
    `DOCKER_HOST` 以指向实现 Docker API 的套接字。
- en: 'First, set the `DOCKER_HOST` environment variable to point at podman.sock:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `DOCKER_HOST` 环境变量设置为指向 podman.sock：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, change the script to use the `docker.from_env()` function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将脚本更改为使用 `docker.from_env()` 函数：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the new script, and you see that it uses the `DOCKER_HOST` environment
    variable to discover the Podman service socket:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行新的脚本，你会看到它使用 `DOCKER_HOST` 环境变量来发现 Podman 服务套接字：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note On many Linux distributions, the `podman-docker` package is available locally.
    When you install this package, it installs a Docker script that redirects Docker
    commands to run Podman commands. It also links all of the Docker man pages to
    Podman man pages. Finally, it sets up a symbolic link between the docker.sock
    and the podman.sock for rootful containers, allowing Docker tools to use /var/run/podman/podman.sock,
    with no environment modifications.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在许多 Linux 发行版中，`podman-docker` 包是本地可用的。当你安装此包时，它会安装一个 Docker 脚本，该脚本将 Docker
    命令重定向为运行 Podman 命令。它还将所有 Docker man 页链接到 Podman man 页。最后，它为 rootful 容器在 docker.sock
    和 podman.sock 之间设置符号链接，允许 Docker 工具使用 /var/run/podman/podman.sock，无需修改环境变量。
- en: The great thing is that this `DOCKER_HOST` trick can be used with most docker-py
    scripts that have been written over the years, and you can easily switch your
    scripts from using the Docker daemon to using the Podman service. If you want
    to use more advanced Podman features, you need to use the podman-py package.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 优点在于这个 `DOCKER_HOST` 技巧可以用于大多数多年来编写的 docker-py 脚本，并且你可以轻松地将你的脚本从使用 Docker 守护进程切换到使用
    Podman 服务。如果你想使用更高级的 Podman 功能，你需要使用 podman-py 包。
- en: 9.3.2 Using podman-py with the Podman API
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 使用 podman-py 与 Podman API
- en: Podman-py ([https://github.com/containers/podman-py](https://github.com/containers/podman-py)),
    like docker-py, is a Python bindings library used to communicate with the Podman
    service. The podman-py library is newer than the docker-py library and supports
    all of the advanced features of Podman using the Libpod API.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Podman-py ([https://github.com/containers/podman-py](https://github.com/containers/podman-py))，像
    docker-py 一样，是一个用于与 Podman 服务通信的 Python 绑定库。podman-py 库比 docker-py 库更新，并使用 Libpod
    API 支持Podman的所有高级功能。
- en: The Podman Python library uses the default locations of the podman.sock and
    connects to it automatically. When run as non-root, the library connects to the
    rootless socket located in /run/user/$UID/podman/podman.sock. Running Python with
    the Podman library as root connects automatically to /run/podman/podman.sock.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Podman Python 库使用 podman.sock 的默认位置并自动连接到它。当以非 root 用户运行时，库连接到位于 /run/user/$UID/podman/podman.sock
    的无根套接字。以 root 用户运行 Python 并使用 Podman 库时，会自动连接到 /run/podman/podman.sock。
- en: 'Similarly to docker-py, on my system I can install the podman-py library via
    the `python-podman` package:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与 docker-py 类似，在我的系统上，我可以通过 `python-podman` 包安装 podman-py 库：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now build a functionally similar script, podman-images.py, using the podman-py
    library. This time you don’t need to worry about the location of the Podman socket.
    The podman-py library connects to the default location:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建一个功能相似的脚本，podman-images.py，使用 podman-py 库。这次你不需要担心 Podman 套接字的位置。podman-py
    库连接到默认位置：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the script, and you will see the same results as the docker-py example,
    but this library uses the Libpod API:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，你将看到与 docker-py 示例相同的结果，但这个库使用的是 Libpod API：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you want to show advanced features, like information on all the pods in
    the Podman database, call the `pod.lists()` function, and iterate through each
    pod:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要展示高级功能，例如 Podman 数据库中所有 pod 的信息，调用 `pod.lists()` 函数，并遍历每个 pod：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see with the Python bindings, you could begin to build a Python version
    of Podman, which can communicate with the remote socket.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用 Python 绑定，你可以开始构建一个 Python 版本的 Podman，它可以与远程套接字进行通信。
- en: 9.3.3 Which Python library should you use?
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3 应该使用哪个 Python 库？
- en: The developers of the podman-py library based their design on the docker-py
    library to make it easier for developers to transition. If you want to build an
    application that works with Podman and Docker, the only choice is docker-py because
    podman-py does not work with Docker. If you want to take advantage of advanced
    features of Podman, you have to use podman-py. Podman-py is under heavy development,
    but docker-py has a huge installed base. Podman-py works out of the box with rootful
    and rootless Podman service, while if you use docker-py you have to set the `DOCKER_
    HOST` environment variable to point at the podman.socket. Table 9.4 compares the
    features of the podman-py and docker-py libraries to help you understand when
    to use a particular library.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: podman-py 库的开发者基于 docker-py 库进行设计，以便于开发者过渡。如果你想要构建一个与 Podman 和 Docker 兼容的应用程序，唯一的选择是
    docker-py，因为 podman-py 不与 Docker 兼容。如果你想要利用 Podman 的高级功能，你必须使用 podman-py。Podman-py
    正在积极开发中，但 docker-py 拥有庞大的安装基础。Podman-py 可以与 rootful 和 rootless Podman 服务无缝工作，而如果你使用
    docker-py，你必须设置 `DOCKER_ HOST` 环境变量以指向 podman.socket。表 9.4 比较了 podman-py 和 docker-py
    库的功能，以帮助你了解何时使用特定的库。
- en: Table 9.4 Podman-py vs. docker-py
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.4 Podman-py 与 docker-py 对比
- en: '| Support | Podman-py | Docker-py |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 支持 | Podman-py | Docker-py |'
- en: '| Podman service | ✔ | ✔ |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| Podman 服务 | ✔ | ✔ |'
- en: '| Docker daemon | ✘ | ✔ |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| Docker 守护进程 | ✘ | ✔ |'
- en: '| Supports pods | ✔ | ✘ |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 支持 pods | ✔ | ✘ |'
- en: '| Advanced Podman features | ✔ | ✘ |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 高级 Podman 功能 | ✔ | ✘ |'
- en: Using the low-level Python libraries docker-py and podman-py for communicating
    with container engine daemons and services, engineers developed higher-level tools
    to orchestrate and manage containers. The most popular of these is `docker-compose`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用低级别的 Python 库 docker-py 和 podman-py 与容器引擎守护进程和服务进行通信，工程师开发了高级工具来编排和管理容器。其中最受欢迎的是
    `docker-compose`。
- en: 9.4 Using docker-compose with the Podman service
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 使用 Podman 服务与 docker-compose
- en: In the previous chapters, you have seen how to manage containers with the Podman
    command line as well as how to manage multiple containers using Kubernetes YAML
    launched with `podman` `play` `kube`. You were introduced to launching containers
    with Kubernetes. In this section, you will work with yet another orchestration
    tool, `docker-compose` ([https://docs.docker.com/compose](https://docs.docker.com/compose)),
    often referred to as just `compose`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经看到了如何使用 Podman 命令行管理容器，以及如何使用 `podman` `play` `kube` 启动 Kubernetes
    YAML 来管理多个容器。你已经介绍了使用 Kubernetes 启动容器。在本节中，你将使用另一个编排工具，`docker-compose` ([https://docs.docker.com/compose](https://docs.docker.com/compose))，通常简称为
    `compose`。
- en: '`compose` is one of the most popular tools for launching containers. The `compose`
    tool predates Kubernetes and concentrates on orchestrating multiple containers
    on a single node, whereas Kubernetes orchestrates multiple containers on multiple
    nodes. `compose`, like Kubernetes, uses a YAML file for its container definitions.
    One of the reasons `compose` was created was that building complex command lines
    to run multiple containers can be complicated. Using a structured language like
    YAML makes it easier to support running complex applications with multiple containers
    on a single node.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose` 是启动容器中最受欢迎的工具之一。`compose` 工具早于 Kubernetes，专注于在单个节点上编排多个容器，而 Kubernetes
    则在多个节点上编排多个容器。`compose`，就像 Kubernetes 一样，使用 YAML 文件来定义其容器。`compose` 被创建的一个原因是因为构建复杂的命令行来运行多个容器可能很复杂。使用结构化语言如
    YAML 使得支持在单个节点上运行具有多个容器的复杂应用程序变得更加容易。'
- en: '`compose` has a huge user base, and it is likely you might want to run a `compose`
    YAML file in your infrastructure. If you don’t believe this will happen, you can
    skip this section.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose` 拥有庞大的用户群，你可能会想在你的基础设施中运行一个 `compose` YAML 文件。如果你不相信这会发生，你可以跳过这一节。'
- en: The `compose` tool was written using docker-py and launches containers by using
    the Docker REST API. Since Podman now supports the `compat` REST API, it also
    supports using `docker-compose` to launch Podman containers. Because Podman works
    in rootless as well as rootful mode, you can even use `docker-compose` to launch
    rootless Podman containers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose` 工具是用 docker-py 编写的，并通过使用 Docker REST API 启动容器。由于 Podman 现在支持 `compat`
    REST API，它也支持使用 `docker-compose` 启动 Podman 容器。因为 Podman 既可以以无根模式工作，也可以以有根模式工作，您甚至可以使用
    `docker-compose` 启动无根 Podman 容器。'
- en: 'In the rest of this section, you will create a `compose` YAML file just to
    get a feel for how the `compose` command works with the Podman service. You first
    need to install `docker-compose`. On my Fedora system, I can do this with the
    following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，您将创建一个 `compose` YAML 文件，只是为了了解 `compose` 命令如何与 Podman 服务一起工作。您首先需要安装
    `docker-compose`。在我的 Fedora 系统上，我可以使用以下命令完成此操作：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Make sure the Podman systemd socket-activated service is running by running
    the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令确保 Podman systemd socket-activated 服务正在运行：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Verify the system service is running by hitting the ping endpoint, and see if
    you get a response. This step needs to be successful before you can proceed further.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过ping端点检查系统服务是否正在运行，并查看是否收到响应。在您继续下一步之前，此步骤必须成功。
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since `docker-compose` supports the `DOCKER_HOST` environment variable, make
    sure it is set using this command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `docker-compose` 支持使用 `DOCKER_HOST` 环境变量，请确保使用以下命令设置它：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As was stated earlier in this section, `compose` supports its own YAML file,
    which is different than the Kubernetes YAML described in chapter 8.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节前面所述，`compose` 支持其自己的 YAML 文件，这与第8章中描述的 Kubernetes YAML 不同。
- en: 'First, create a directory called example, and then navigate into it. Move the
    html directory you have been using into the example directory:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 example 的目录，然后进入它。将您一直在使用的 html 目录移动到 example 目录中：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You need to create the docker-compose.yaml file in the example directory you
    have been working in. The YAML file will create a container called `myapp` based
    on quay.io/ rhatdan/myimage:latest. Set up the container to use volumes from the
    host ./html directory as well as a built-in volume, `myapp_vol`, used just for
    the example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您一直在工作的示例目录中创建 docker-compose.yaml 文件。该 YAML 文件将基于 quay.io/rhatdan/myimage:latest
    创建一个名为 `myapp` 的容器。设置容器使用来自主机 ./html 目录的卷以及一个内置卷 `myapp_vol`，该卷仅用于示例：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now clean up the images and containers you have on your system to make sure
    you are starting from a clean slate. Run the following commands to do that:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，清理您系统上的镜像和容器，以确保您从一个干净的状态开始。运行以下命令来完成此操作：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To show how `compose` interacts with the Podman service, launch the container
    with the `compose` command. Notice that `compose` tells Podman to pull down the
    image. Then `compose` tells Podman to create a container named `example_myapp_1`
    along with a volume named `example_myapp_vol`, which will be volume mounted into
    the container along with the ./html directory.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要展示 `compose` 如何与 Podman 服务交互，请使用 `compose` 命令启动容器。注意，`compose` 会告诉 Podman 下载镜像。然后
    `compose` 会告诉 Podman 创建一个名为 `example_myapp_1` 的容器，以及一个名为 `example_myapp_vol` 的卷，该卷将与
    ./html 目录一起挂载到容器中。
- en: Listing 9.2 The output of executing `docker-compose` against the Podman socket
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 执行 `docker-compose` 对 Podman 套接字的输出
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Pulling the myimage image
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 拉取 myimage 镜像
- en: ❷ Creating the example_myapp_1 container
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建 example_myapp_1 容器
- en: 'In a different terminal, run the `podman` `ps` command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的终端中运行 `podman ps` 命令：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now check to see if Podman created a volume:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查 Podman 是否创建了一个卷：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Go back to the original window, and enter Ctrl-C to stop `docker-compose`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到原始窗口，并按 Ctrl-C 停止 `docker-compose`：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will shut down the container:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将关闭容器：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you execute the `podman` `ps` `-a` command, you will see that the container
    still exists but is not running:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行 `podman ps -a` 命令，您将看到容器仍然存在，但未运行：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, if you run `docker-compose` `down`, it will tell Podman to remove the
    container from the system:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您运行 `docker-compose down`，它将告诉 Podman 从系统中删除容器：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Verify all containers are gone with the `podman` `ps` `-a` command again:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 `podman ps -a` 命令验证所有容器都已消失：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, Podman works nicely with `docker-compose` to orchestrate containers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Podman 与 `docker-compose` 一起很好地工作，以编排容器。
- en: Tip While `docker-compose` works nicely with the Podman service, I think if
    you are starting a fresh project, it is better to work with Kubernetes YAML and
    `podman` `play` `kube` because this allows you to more easily move your containers
    into Kubernetes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：虽然 `docker-compose` 与 Podman 服务配合得很好，但我认为如果您正在启动一个全新的项目，最好使用 Kubernetes
    YAML 和 `podman` `play` `kube`，因为这可以使您更容易地将容器移动到 Kubernetes。
- en: As you have seen, the Podman service is useful for allowing remote processes
    to manipulate your pods and containers. Even the Podman command can be used as
    a client and communicate with the Podman service.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Podman 服务对于允许远程进程操作您的 pods 和容器非常有用。甚至 Podman 命令也可以用作客户端并与 Podman 服务进行通信。
- en: 9.5 podman - -remote
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 podman - -remote
- en: As you scale out applications, you probably want to run your containerized applications
    on multiple machines. You could `ssh` into each box and run Podman commands locally
    to manage the environment, or you could write code to use the Python library described
    in section 9.4\. The Podman developers also built client support into the Podman
    command. You can use the `podman` command to directly connect to these remote
    Podman services and manage the container environment on the remote machines.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当您扩展应用程序时，您可能希望在多台机器上运行容器化的应用程序。您可以通过 `ssh` 登录到每个盒子并在本地运行 Podman 命令来管理环境，或者您可以编写代码来使用
    9.4 节中描述的 Python 库。Podman 开发者还在 Podman 命令中构建了客户端支持。您可以使用 `podman` 命令直接连接到这些远程
    Podman 服务并管理远程机器上的容器环境。
- en: The Podman command has a special option, `--remote`, allowing it to communicate
    with the socket-activated Podman service. Instead of executing the commands and
    containers as a child of the Podman process, it communicates with the service
    over the REST API.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 命令有一个特殊选项，`--remote`，允许它与通过套接字激活的 Podman 服务进行通信。它不是作为 Podman 进程的子进程执行命令和容器，而是通过
    REST API 与服务进行通信。
- en: '![](../../OEBPS/Images/09-02.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/09-02.png)'
- en: Figure 9.2 `podman` `--remote` connecting to local podman.socket
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 `podman` `--remote` 连接到本地 podman.socket
- en: Because Podman is a tool for running Linux containers, the `complete` `podman`
    command can only be run on Linux. The Podman developers wanted to support other
    operating systems, at least in client mode. To support running Podman on non-Linux
    machines, Podman can be built in two different ways. Up until now, you have been
    working with the fully fledged Podman, which has the `--remote` option. The Podman
    executable can be compiled with only support for communicating with the Podman
    service. Podman built this way is often called `podman-remote`. The `podman-remote`
    command is the command that is shipped on some operating systems, like Mac and
    Windows (covered more fully in appendixes E and F). If you have been testing Podman
    on a Mac or Windows machine while reading this book, then you have already been
    using `podman-remote`, which transparently communicates with the Podman service
    running in a VM or on a different machine.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Podman 是运行 Linux 容器的工具，因此 `complete` `podman` 命令只能在 Linux 上运行。Podman 开发者希望支持其他操作系统，至少在客户端模式下。为了在非
    Linux 机器上运行 Podman，Podman 可以以两种不同的方式构建。到目前为止，您一直在使用具有 `--remote` 选项的完整 Podman。Podman
    可执行文件可以编译成仅支持与 Podman 服务通信的形式。以这种方式构建的 Podman 通常被称为 `podman-remote`。`podman-remote`
    命令是某些操作系统（如 Mac 和 Windows，在附录 E 和 F 中有更全面的介绍）中提供的命令。如果您在阅读这本书的同时在 Mac 或 Windows
    机器上测试 Podman，那么您已经在使用 `podman-remote`，它透明地与在虚拟机或不同机器上运行的 Podman 服务进行通信。
- en: 9.5.1 Local connections
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1 本地连接
- en: As previously mentioned, the `podman` `--remote` command connects, by default,
    to the local podman.socket, referred to as a local connection (figure 9.2). Try
    out `podman` `--remote` with the Podman system service you enabled in section
    9.1.1\. Notice how the `podman` `--remote` version shows you the version of the
    Podman client as well as the Podman server; in this case, they are the same executable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`podman` `--remote` 命令默认连接到本地的 podman.socket，称为本地连接（图 9.2）。尝试使用在 9.1.1
    节中启用的 Podman 系统服务运行 `podman` `--remote`。注意 `podman` `--remote` 版本向您显示了 Podman
    客户端和 Podman 服务器的版本；在这种情况下，它们是相同的可执行文件。
- en: Listing 9.3 The output of `podman` `--remote` executing the version API
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 执行 `podman` `--remote` 的版本 API 的输出
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Client version of Podman
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Podman 的客户端版本
- en: ❷ Server version of Podman
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Podman 的服务器版本
- en: 'You can use the exact same commands to start the container:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用完全相同的命令来启动容器：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can imagine, it is not that useful in this mode, since you can run Podman
    without the `--remote` option and manage the same container environment. Local
    connections are mainly used for testing of the API, especially in continuous integration
    (CI) systems. `podman` `--remote` becomes much more interesting when you use it
    to communicate with truly remote machines.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想，在这种模式下并不那么有用，因为您可以在不使用`--remote`选项的情况下运行Podman，并管理相同的容器环境。本地连接主要用于API的测试，尤其是在持续集成（CI）系统中。当您使用`podman`
    `--remote`与真正远程的机器进行通信时，它变得更有趣。
- en: 9.5.2 Remote connections
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.2 远程连接
- en: The main purpose of the `podman` `--remote` command is allowing you to manipulate
    pods and containers on a separate machine using the Podman service. Install Podman
    on a Linux machine or VM, which also has the SSH daemon running. On the local
    operating system, when you run a Podman command, Podman connects to the server
    via SSH. It then connects to the Podman service by using systemd socket activation
    and communicating with our REST API, as shown in figure 9.3.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman` `--remote`命令的主要目的是允许您使用Podman服务在另一台机器上操作pods和容器。在Linux机器或VM上安装Podman，该机器也运行着SSH守护进程。在本地操作系统上，当您运行Podman命令时，Podman通过SSH连接到服务器。然后，它通过systemd套接字激活连接到Podman服务，并通过我们的REST
    API进行通信，如图9.3所示。'
- en: '![](../../OEBPS/Images/09-03.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/09-03.png)'
- en: Figure 9.3 `podman --remote` connecting over SSH to the server machine
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 `podman --remote`通过SSH连接到服务器机器
- en: The command-line interface of Podman with the `--remote` option is exactly the
    same as the regular Podman commands. When you run the Podman commands, it feels
    like you are running the containers locally; however, the container processes
    are running on the remote machine. There are a few options that are not supported
    in remote mode, listed in table 9.5.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`--remote`选项的Podman命令行界面与常规的Podman命令完全相同。当您运行Podman命令时，感觉就像您是在本地运行容器；然而，容器进程是在远程机器上运行的。有一些选项在远程模式下不支持，列于表9.5中。
- en: Table 9.5 Options not supported by the `podman --remote` command
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.5 `podman --remote`命令不支持选项
- en: '| Options | Explanation |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 说明 |'
- en: '| `--env-host` | The environment on two different machines makes little sense
    to share; in some cases these can be two different operating systems, like Windows
    and Macs talking to a Linux Podman service. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `--env-host` | 在两台不同的机器上共享环境几乎没有意义；在某些情况下，这些可能是不同的操作系统，例如Windows和Mac与Linux
    Podman服务进行通信。 |'
- en: '| `--group-add=keep-groups` | The `--group-add` option works in `--remote`
    mode, but the `keep-groups` special flag does not. The `keep-groups` flag tells
    Podman to leak the groups that the current process has access to into the container.
    Since this is a client-server procedure, the leaking is impossible. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `--group-add=keep-groups` | `--group-add`选项在`--remote`模式下工作，但`keep-groups`特殊标志不行。`keep-groups`标志告诉Podman将当前进程可访问的组泄露到容器中。由于这是一个客户端-服务器过程，泄露是不可能的。
    |'
- en: '| `--http-proxy` | The `--http-proxy` option tells Podman to use the HTTP proxy
    environment variables off of the client machine and leak them into the server.
    Since the proxy is normally set up on the server, the `--http-proxy` option is
    not allowed with the `--remote` option. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `--http-proxy` | `--http-proxy`选项告诉Podman使用客户端机器上的HTTP代理环境变量，并将它们泄露到服务器。由于代理通常设置在服务器上，因此不允许与`--remote`选项一起使用`--http-proxy`选项。
    |'
- en: '| `--preserve-fds` | The `--preserve-fds` option leaks file descriptors from
    the calling process into the container; since this is a remote connection, there
    is no way to leak the file descriptors. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `--preserve-fds` | `--preserve-fds`选项会将调用进程的文件描述符泄露到容器中；由于这是一个远程连接，没有方法可以泄露文件描述符。
    |'
- en: '| `--volume` | This is supported, except that the source volume will come from
    the remote machine, not necessarily the one that is running the `podman` command
    (unless they are on the same machine). If you are using a VM, you need to mount
    the directory on the host machine into the VM first; then Podman inside of the
    VM sees the mount and mounts it into the container. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `--volume` | 这是支持的，但源卷将来自远程机器，不一定是从运行`podman`命令的机器（除非它们在同一台机器上）。如果您正在使用VM，您需要首先将宿主机的目录挂载到VM中；然后VM内部的Podman看到挂载并将其挂载到容器中。
    |'
- en: '| `--latest`, `-l` | Since there are potentially multiple different users talking
    to the same server at the same time, the concept of `--latest` was too racy, so
    it is not supported. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `--latest`, `-l` | 由于可能同时有多个不同的用户在与同一服务器通信，`--latest`的概念太冒险，因此不支持。 |'
- en: Podman commands are executed on the server. From the client’s point of view,
    it seems like Podman runs locally. Now you need to complete the configuration
    of the Podman service on the remote server.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 命令在服务器上执行。从客户端的角度来看，Podman 好像是在本地运行。现在您需要完成远程服务器上 Podman 服务的配置。
- en: Enabling SSHD connections
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 SSHD 连接
- en: 'For the Podman client to communicate with the server, you need to enable and
    start the SSH daemon on your Linux machine, if it is not already enabled:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了 Podman 客户端能够与服务器通信，您需要在您的 Linux 机器上启用并启动 SSH 守护进程，如果它尚未启用的话：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that the SSHD daemon is running, you need to enable the Podman service on
    the remote machine.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 SSHD 守护进程正在运行，您需要在远程机器上启用 Podman 服务。
- en: Enabling the Podman service on the server machine
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器机器上启用 Podman 服务
- en: 'Before performing any Podman client commands, you must enable the podman.sock
    systemd service on the Linux server or VM. In these examples, you are running
    Podman as a normal, unprivileged user. For rootless Podman on a server to run
    properly, enable this socket permanently using the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何 Podman 客户端命令之前，您必须在 Linux 服务器或虚拟机上启用 podman.sock systemd 服务。在这些示例中，您是以普通、非特权用户身份运行
    Podman 的。为了使服务器上的无根 Podman 正确运行，请使用以下命令永久启用此套接字：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Normally, when you log out of a system, systemd stops all processes on the
    system. You need to tell systemd to allow the remote users processes to `linger`
    for rootless mode:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当您从系统中注销时，systemd 会停止系统上的所有进程。您需要告诉 systemd 允许远程用户进程在无根模式下 `linger`：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This also tells systemd to start listening on this socket at boot time. Once
    you have the service running on one system, you can verify the socket is listening
    with a Podman command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这也告诉 systemd 在启动时监听此套接字。一旦在一个系统上运行了该服务，您可以使用 Podman 命令验证套接字是否正在监听：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Note You can enable the rootful `podman` service with the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以使用以下命令启用根有 `podman` 服务：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The previous `enable-linger` command is only for rootless mode. Now that you
    have the remote service enabled and running along with the SSHD daemon, you can
    go back to the client machine.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `enable-linger` 命令仅适用于无根模式。现在您已经启用了远程服务并使其与 SSHD 守护进程一起运行，您可以回到客户端机器。
- en: 9.5.3 Setting up SSH on the client machine
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.3 在客户端机器上设置 SSH
- en: 'Remote Podman uses SSH to communicate between the client and server when they
    are on separate machines. By default, SSH will ask you to provide the usernames
    and passwords on each command, unless you set up SSH keys. To set up your SSH
    connection, you need to generate an SSH key pair from your client machine. If
    you have existing SSH keys, you can just use them; it’s even better if you already
    have shared keys with the server. On my Linux system, I can generate SSH keys
    with a command like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 远程 Podman 使用 SSH 在客户端和服务器之间进行通信，当它们位于不同的机器上时。默认情况下，SSH 会要求您在每次命令中提供用户名和密码，除非您设置了
    SSH 密钥。要设置您的 SSH 连接，您需要从您的客户端机器生成一个 SSH 密钥对。如果您已经有了现有的 SSH 密钥，您可以直接使用它们；如果您已经与服务器共享了密钥，那就更好了。在我的
    Linux 系统上，我可以用以下类似的命令生成 SSH 密钥：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once you have finished generating your keys, you can set up trust between the
    client and server machine with the `ssh-copy-id` command or some similar command.
    The public key, by default, will be in your home directory under $HOME/.ssh/id_ed25519
    .pub. You need to copy the contents of id_ed25519.pub and append it into ~/.ssh/
    authorized_keys on the Linux server. See [https://red.ht/3HuxPT6](https://red.ht/3HuxPT6)
    for more information on configuring your SSH environment:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 生成密钥完成后，您可以使用 `ssh-copy-id` 命令或类似命令在客户端和服务器机器之间设置信任。默认情况下，公钥将位于您的家目录下 $HOME/.ssh/id_ed25519.pub。您需要将
    id_ed25519.pub 的内容复制并追加到 Linux 服务器上的 ~/.ssh/authorized_keys。有关配置您的 SSH 环境的更多信息，请参阅
    [https://red.ht/3HuxPT6](https://red.ht/3HuxPT6)：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you do not wish to use SSH keys, you will be prompted with each Podman command
    for your login password. Now that you have shared your SSH keys with the server,
    the next step is configuring the connection with Podman.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用 SSH 密钥，每次执行 Podman 命令时都会提示您输入登录密码。现在您已经与服务器共享了 SSH 密钥，下一步是配置 Podman
    的连接。
- en: 9.5.4 Configuring a connection
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.4 配置连接
- en: 'The `podman` `system` `connection` command allows you to manage SSH connections
    to be used by the `podman` `--remote` command. You can add a connection by using
    the `podman` `system` `connection` `add` command; name the connection `server1`.
    The default identity file will be chosen, or you can use the `-–identity` option
    to specify the SSH key to use. Finally, you need to specify the full SSH URL for
    the Podman socket. This includes the user account, `myuser`, and IP address, as
    well as the path to the Podman socket for the user account:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman` `system` `connection` 命令允许您管理用于 `podman` `--remote` 命令的 SSH 连接。您可以使用
    `podman` `system` `connection` `add` 命令添加连接，将连接命名为 `server1`。默认将选择身份文件，或者您可以使用
    `-–identity` 选项指定要使用的 SSH 密钥。最后，您需要指定 Podman 套接字的完整 SSH URL。这包括用户账户 `myuser`、IP
    地址以及用户账户的 Podman 套接字路径：'
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This Podman command adds a remote connection to Podman. Since this was the first
    connection added, Podman marks the connection as the default.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Podman 命令向 Podman 添加远程连接。由于这是第一个添加的连接，Podman 将该连接标记为默认连接。
- en: 'List the available connections with the `podman` `system` `connection` `list`
    command. Notice that the `*` after the connection name indicates it is the default
    connection:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `podman` `system` `connection` `list` 命令列出可用的连接。注意，连接名称后面的 `*` 表示它是默认连接：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now you can test the connection with `podman` `info`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用 `podman` `info` 测试连接：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note You can use the `--connection` `(-c)` if you have more than one connection
    and want to choose the non-default `man` `podman-system-connection` for all possible
    options.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您有多个连接并且想为所有可能的选项选择非默认的 `man` `podman-system-connection`，可以使用 `--connection`
    `(-c)` 选项。
- en: You can use the `podman` option or the `podman-remote` clients to manage containers
    running on Linux servers or VMs. The communication between client and server relies
    heavily on SSH connections, and the use of SSH keys is encouraged. Once you have
    Podman installed on your remote server, you need to set up a connection using
    `podman` `system` `connection` `add`, which can then be used by subsequent Podman
    commands. Table 9.6 lists the available Podman system commands.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `podman` 选项或 `podman-remote` 客户端来管理在 Linux 服务器或虚拟机上运行的容器。客户端与服务器之间的通信高度依赖于
    SSH 连接，并鼓励使用 SSH 密钥。一旦您在远程服务器上安装了 Podman，您需要使用 `podman` `system` `connection`
    `add` 命令设置连接，然后后续的 Podman 命令可以使用该连接。表 9.6 列出了可用的 Podman 系统命令。
- en: Table 9.6 Podman system commands
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.6 Podman 系统命令
- en: '| Command | Man page | Description |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 手册页 | 描述 |'
- en: '| `connection` | `podman-system-connection(1)` | Manages remote SSH destinations
    |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `connection` | `podman-system-connection(1)` | 管理远程 SSH 目标 |'
- en: '| `df` | `podman-system-df(1)` | Shows Podman’s disk usage |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `df` | `podman-system-df(1)` | 显示 Podman 的磁盘使用情况 |'
- en: '| `info` | `podman-system-info(1)` | Displays Podman system information |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `info` | `podman-system-info(1)` | 显示 Podman 系统信息 |'
- en: '| `migrate` | `podman-system-migrate(1)` | Migrates containers to a new user
    namespace |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `migrate` | `podman-system-migrate(1)` | 将容器迁移到新的用户命名空间 |'
- en: '| `prune` | `podman-system-prune(1)` | Removes unused pod, container, volume,
    and image data |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `prune` | `podman-system-prune(1)` | 删除未使用的 pod、容器、卷和镜像数据 |'
- en: '| `renumber` | `podman-system-renumber(1)` | Migrates lock numbers |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `renumber` | `podman-system-renumber(1)` | 迁移锁号 |'
- en: '| `reset` | `podman-system-reset(1)` | Resets Podman storage |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `reset` | `podman-system-reset(1)` | 重置 Podman 存储 |'
- en: '| `service` | `podman-system-service(1)` | Runs the API service |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `service` | `podman-system-service(1)` | 运行 API 服务 |'
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Podman can be run as a REST API service.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 可以作为 REST API 服务运行。
- en: Podman supports two REST API endpoints.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 支持两个 REST API 端点。
- en: The Podman socket supports two APIs.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 套接字支持两个 API。
- en: Compatibility mode or Docker mode allows Docker client tools to work with Podman.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容模式或 Docker 模式允许 Docker 客户端工具与 Podman 一起工作。
- en: Podman mode allows remote clients to take advantage of advanced Podman features.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 模式允许远程客户端利用 Podman 的高级功能。
- en: Podman-py is a Python bindings library used to communicate with the Podman service.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman-py 是一个用于与 Podman 服务通信的 Python 绑定库。
- en: Docker-py is a Python bindings library used to communicate with the Podman compatibility
    service.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker-py 是一个用于与 Podman 兼容服务通信的 Python 绑定库。
- en: Podman supports running `docker-compose` with the compatibility service to orchestrate
    `compose` containers on a single node.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 支持使用兼容服务运行 `docker-compose`，以在单个节点上编排 `compose` 容器。
- en: The `podman` `--remote` command communicates with the Podman service over SSH
    to manage containers.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman` `--remote` 命令通过 SSH 与 Podman 服务通信，以管理容器。'
- en: The `podman` `system` `connect` command manages SSH connections to remote Podman
    services, making it easier to manage containers in your environment.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman` `system` `connect` 命令管理对远程 Podman 服务的 SSH 连接，使得管理您环境中的容器更加便捷。'
