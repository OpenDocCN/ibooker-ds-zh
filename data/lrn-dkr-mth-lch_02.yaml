- en: 2 Understanding Docker and running Hello World
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 理解Docker和运行Hello World
- en: 'It’s time to get hands-on with Docker. In this chapter you’ll get lots of experience
    with the core feature of Docker: running applications in containers. I’ll also
    cover some background that will help you understand exactly what a container is,
    and why containers are such a lightweight way to run apps. Mostly you’ll be following
    try-it-now exercises, running simple commands to get a feel for this new way of
    working with applications.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候亲自动手使用Docker了。在这一章中，你将获得大量使用Docker核心功能（在容器中运行应用程序）的经验。我还会介绍一些背景知识，这将帮助你确切地了解什么是容器，以及为什么容器是运行应用程序如此轻量级的方式。大部分时间你将跟随“试试看”练习，运行简单的命令，以获得这种新的应用程序工作方式的感觉。
- en: 2.1 Running Hello World in a container
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 在容器中运行Hello World
- en: 'Let’s get started with Docker the same way we would with any new computing
    concept: running Hello World. You have Docker up and running from chapter 1, so
    open your favorite terminal--that could be Terminal on the Mac or a Bash shell
    on Linux, and I recommend PowerShell in Windows.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以运行Hello World的方式开始使用Docker，就像我们开始任何新的计算概念一样：运行Hello World。你从第一章开始就有Docker在运行，所以打开你最喜欢的终端--这可能是Mac上的Terminal或Linux上的Bash
    shell，我推荐Windows上的PowerShell。
- en: You’re going to send a command to Docker, telling it to run a container that
    prints out some simple “Hello, World” text.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将向Docker发送一个命令，告诉它运行一个打印一些简单“Hello, World”文本的容器。
- en: 'Try it now Enter this command, which will run the Hello World container:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧 输入以下命令，这将运行Hello World容器：
- en: '`docker container run diamol/ch02-hello-diamol`'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container run diamol/ch02-hello-diamol`'
- en: When we’re done with this chapter, you’ll understand exactly what’s happening
    here. For now, just take a look at the output. It will be something like figure
    2.1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成这一章时，你会确切地了解这里发生了什么。现在，只需看看输出。它将类似于图2.1。
- en: '![](../Images/2-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-1.jpg)'
- en: Figure 2.1 The output from running the Hello World container. You can see Docker
    downloading the application package (called an “image”), running the app in a
    container, and showing the output.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 运行Hello World容器的输出。你可以看到Docker正在下载应用程序包（称为“镜像”），在一个容器中运行应用程序，并显示输出。
- en: There’s a lot in that output. I’ll trim future code listings to keep them short,
    but this is the very first one, and I wanted to show it in full so we can dissect
    it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中有很多内容。我将缩短未来的代码列表以保持它们简短，但这是第一个，我想完整地展示它，这样我们就可以分析它。
- en: First of all, what’s actually happened? The `docker` `container` `run` command
    tells Docker to run an application in a container. This application has already
    been packaged to run in Docker and has been published on a public site that anyone
    can access. The container package (which Docker calls an “image”) is named `diamol/
    ch02-hello-diamol` (I use the acronym diamol throughout this book--it stands for
    Docker In A Month Of Lunches). The command you’ve just entered tells Docker to
    run a container from that image.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，实际上发生了什么？`docker` `container` `run` 命令告诉Docker在一个容器中运行一个应用程序。这个应用程序已经被打包以在Docker中运行，并且已经发布在一个任何人都可以访问的公共网站上。容器包（Docker称之为“镜像”）的名称为`diamol/
    ch02-hello-diamol`（我在整本书中都会使用这个缩写diamol--它代表Docker In A Month Of Lunches）。你刚刚输入的命令告诉Docker从这个镜像中运行一个容器。
- en: 'Docker needs to have a copy of the image locally before it can run a container
    using the image. The very first time you run this command, you won’t have a copy
    of the image, and you can see that in the first output line: `unable` `to` `find`
    `image` `locally` . Then Docker downloads the image (which Docker calls “pulling”),
    and you can see that the image has been downloaded.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Docker在运行使用该镜像的容器之前，需要在本地有一个该镜像的副本。第一次运行这个命令时，你不会有该镜像的副本，你可以在第一行输出中看到：`unable`
    `to` `find` `image` `locally` 。然后Docker下载该镜像（Docker称之为“pull”），你可以看到该镜像已经被下载。
- en: 'Now Docker starts a container using that image. The image contains all the
    content for the application, along with instructions telling Docker how to start
    the application. The application in this image is just a simple script, and you
    see the output which starts `Hello` `from` `Chapter` `2!` It writes out some details
    about the computer it’s running on:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Docker使用该镜像启动一个容器。该镜像包含了应用程序的所有内容，以及告诉Docker如何启动应用程序的指令。这个镜像中的应用程序只是一个简单的脚本，你可以看到输出结果，它启动了`Hello`
    `from` `Chapter` `2!` 它写出了关于它在上面运行的计算机的一些详细信息：
- en: The machine name, in this example `e5943557213b`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器名称，在这个例子中是`e5943557213b`
- en: The operating system, in this example `Linux` `4.9.125-linuxkit` `x86_64`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统，在这个例子中是`Linux` `4.9.125-linuxkit` `x86_64`
- en: The network address, in this example `172.17.0.2`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络地址，在这个例子中是`172.17.0.2`
- en: 'I said your output will be “something like this”--it won’t be exactly the same,
    because some of the information the container fetches depends on your computer.
    I ran this on a machine with a Linux operating system and a 64-bit Intel processor.
    If you run it using Windows containers, the `I''m` `running` `on` line will show
    this instead:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我说你的输出将“类似于这样”——它不会完全相同，因为容器获取的一些信息取决于你的计算机。我在一个运行Linux操作系统和64位Intel处理器的机器上运行了这个命令。如果你使用Windows容器运行它，`I'm`
    `running` `on`行将显示以下内容：
- en: '` ---------------------` ` I''m running on:` ` Microsoft Windows [Version 10.0.17763.557]`
    ` ---------------------`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '` ---------------------` ` 我在以下系统上运行:` ` Microsoft Windows [Version 10.0.17763.557]`
    ` ---------------------`'
- en: 'If you’re running on a Raspberry Pi, the output will show that it’s using a
    different processor ( `armv7l` is the codename for ARM’s 32-bit processing chip,
    and `x86_64` is the code for Intel’s 64-bit chip):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用树莓派，输出将显示它使用的是不同的处理器（`armv7l`是ARM 32位处理器的代号，而`x86_64`是Intel 64位处理器的代号）：
- en: '` ---------------------` ` I''m running on:` ` Linux 4.19.42-v7+ armv7l` ` ---------------------`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '` ---------------------` ` 我在以下系统上运行:` ` Linux 4.19.42-v7+ armv7l` ` ---------------------`'
- en: This is a very simple example application, but it shows the core Docker workflow.
    Someone packages their application to run in a container (I did it for this app,
    but you will do it yourself in the next chapter), and then publishes it so it’s
    available to other users. Then anyone with access can run the app in a container.
    Docker calls this build, share, run.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的示例应用程序，但它展示了Docker的核心工作流程。有人将他们的应用程序打包到容器中运行（我为这个应用程序做了这件事，但你在下一章中会自己做），然后发布它，使其可供其他用户使用。然后任何有权访问的人都可以在容器中运行该应用程序。Docker称这为构建、共享、运行。
- en: It’s a hugely powerful concept, because the workflow is the same no matter how
    complicated the application is. In this case it was a simple script, but it could
    be a Java application with several components, configuration files, and libraries.
    The workflow would be exactly the same. And Docker images can be packaged to run
    on any computer that supports Docker, which makes the app completely portable--portability
    is one of Docker’s key benefits.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常强大的概念，因为无论应用程序有多复杂，工作流程都是相同的。在这种情况下，它是一个简单的脚本，但它也可以是一个具有多个组件、配置文件和库的Java应用程序。工作流程将完全相同。而且Docker镜像可以打包在支持Docker的任何计算机上运行，这使得应用程序完全可移植——可移植性是Docker的关键优势之一。
- en: What happens if you run another container using the same command?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用相同的命令运行另一个容器会发生什么？
- en: 'Try it now Repeat the exact same Docker command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看，重复执行完全相同的Docker命令：
- en: '`` `docker container run diamol/ch02-hello-diamol` ``'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `docker container run diamol/ch02-hello-diamol` ``'
- en: 'You’ll see similar output to the first run, but there will be differences.
    Docker already has a copy of the image locally so it doesn’t need to download
    the image first; it gets straight to running the container. The container output
    shows the same operating system details, because you’re using the same computer,
    but the computer name and the IP address of the container will be different:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到与第一次运行类似的输出，但会有所不同。Docker已经在本地有了一个镜像的副本，因此它不需要首先下载镜像；它直接运行容器。容器输出显示了相同的操作系统详细信息，因为你使用的是同一台计算机，但容器的计算机名和IP地址将不同：
- en: '`*---------------------*` `Hello from Chapter 2!` `---------------------` `My
    name is:` `858a26ee2741` `---------------------` `Im running on:` `Linux 4.9.125-linuxkit
    x86_64` `---------------------` `My address is:` `inet addr:172.17.0.5 Bcast:172.17.255.255
    Mask:255.255.0.0` `---------------------`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`*---------------------*` `Hello from Chapter 2!` `---------------------` `My
    name is:` `858a26ee2741` `---------------------` `Im running on:` `Linux 4.9.125-linuxkit
    x86_64` `---------------------` `My address is:` `inet addr:172.17.0.5 Bcast:172.17.255.255
    Mask:255.255.0.0` `---------------------`'
- en: Now my app is running on a machine with the name `858a26ee2741` and the IP address
    `172.17.0.5` . The machine name will change every time, and the IP address will
    often change, but every container is running on the same computer, so where do
    these different machine names and network addresses come from? We’ll dig into
    a little theory next to explain that, and then it’s back to the exercises.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我的应用程序正在名为`858a26ee2741`的机器上运行，IP地址为`172.17.0.5`。机器名会每次改变，IP地址也经常改变，但每个容器都在同一台计算机上运行，那么这些不同的机器名和网络地址是从哪里来的？我们将在下一部分理论中探讨这一点，然后回到练习。
- en: 2.2 So what is a container?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 容器是什么？
- en: 'A Docker container is the same idea as a physical container--think of it like
    a box with an application in it. Inside the box, the application seems to have
    a computer all to itself: it has its own machine name and IP address, and it also
    has its own disk drive (Windows containers have their own Windows Registry too).
    Figure 2.2 shows how the app is boxed by the container.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器与物理容器有相同的概念——想象它就像一个装有应用程序的盒子。在盒子内部，应用程序似乎拥有自己的计算机：它有自己的机器名和IP地址，它还有一个自己的磁盘驱动器（Windows容器还有自己的Windows注册表）。图2.2显示了应用程序是如何被容器封装的。
- en: '![](../Images/2-2.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-2.jpg)'
- en: Figure 2.2 An app inside the container environment
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 容器环境中的应用程序
- en: Those things are all virtual resources--the hostname, IP address, and filesystem
    are created by Docker. They’re logical objects that are managed by Docker, and
    they’re all joined together to create an environment where an application can
    run. That’s the “box” of the container.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是虚拟资源——主机名、IP地址和文件系统都是由Docker创建的。它们是由Docker管理的逻辑对象，它们都被组合在一起，以创建一个应用程序可以运行的环境。这就是容器的“盒子”。
- en: The application inside the box can’t see anything outside the box, but the box
    is running on a computer, and that computer can also be running lots of other
    boxes. The applications in those boxes have their own separate environments (managed
    by Docker), but they all share the CPU and memory of the computer, and they all
    share the computer’s operating system. You can see in figure 2.3 how containers
    on the same computer are isolated.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 盒子内的应用程序看不到盒子外面的任何东西，但盒子是在计算机上运行的，而这个计算机也可以运行许多其他盒子。这些盒子中的应用程序拥有它们各自独立的环境（由Docker管理），但它们都共享计算机的CPU和内存，并且它们都共享计算机的操作系统。您可以在图2.3中看到同一台计算机上的容器是如何隔离的。
- en: '![](../Images/2-3.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-3.jpg)'
- en: Figure 2.3 Multiple containers on one computer share the same OS, CPU, and memory.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 一台计算机上的多个容器共享相同的操作系统、CPU和内存。
- en: 'Why is this so important? It fixes two conflicting problems in computing: isolation
    and density. Density means running as many applications on your computers as possible,
    to utilize all the processor and memory that you have. But apps may not work nicely
    with other apps--they might use different versions of Java or .NET, they may use
    incompatible versions of tools or libraries, or one might have a heavy workload
    and starve the others of processing power. Applications really need to be isolated
    from each other, and that stops you running lots of them on a single computer,
    so you don’t get density.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么如此重要呢？它解决了计算中的两个相互冲突的问题：隔离和密度。密度意味着尽可能在您的计算机上运行尽可能多的应用程序，以利用您拥有的所有处理器和内存。但是应用程序可能与其他应用程序不兼容——它们可能使用不同的Java或.NET版本，它们可能使用不兼容的工具或库版本，或者其中一个可能具有繁重的工作负载，从而耗尽其他应用程序的处理能力。应用程序确实需要相互隔离，这阻止了您在单个计算机上运行大量应用程序，因此您无法获得密度。
- en: The original attempt to fix that problem was to use virtual machines (VMs).
    Virtual machines are similar in concept to containers, in that they give you a
    box to run your application in, but the box for a VM needs to contain its own
    operating system--it doesn’t share the OS of the computer where the VM is running.
    Compare figure 2.3, which shows multiple containers, with figure 2.4, which shows
    multiple VMs on one computer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 解决该问题的最初尝试是使用虚拟机（VM）。虚拟机在概念上与容器相似，因为它们为你提供了一个运行应用程序的盒子，但虚拟机的盒子需要包含自己的操作系统——它不会共享虚拟机运行所在计算机的操作系统。比较图2.3，它显示了多个容器，与图2.4，它显示了同一台计算机上的多个虚拟机。
- en: '![](../Images/2-4.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-4.jpg)'
- en: Figure 2.4 Multiple VMs on one computer each have their own OS.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 一台计算机上的多个虚拟机各自拥有自己的操作系统。
- en: That may look like a small difference in the diagrams, but it has huge implications.
    Every VM needs its own operating system, and that OS can use gigabytes of memory
    and lots of CPU time--soaking up compute power that should be available for your
    applications. There are other concerns too, like licensing costs for the OS and
    the maintenance burden of installing OS updates. VMs provide isolation at the
    cost of density.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这在图中可能看起来只是微小的差异，但它有着巨大的影响。每个虚拟机（VM）都需要自己的操作系统，而这个操作系统可能需要使用数GB的内存和大量的CPU时间——消耗了本应可用于应用程序的计算能力。还有其他一些问题，比如操作系统的许可费用和维护更新时的负担。虚拟机以牺牲密度为代价提供了隔离。
- en: 'Containers give you both. Each container shares the operating system of the
    computer running the container, and that makes them extremely lightweight. Containers
    start quickly and run lean, so you can run many more containers than VMs on the
    same hardware--typically five to ten times as many. You get density, but each
    app is in its own container, so you get isolation too. That’s another key feature
    of Docker: efficiency.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 容器为你提供了这两者。每个容器都共享运行容器的计算机的操作系统，这使得它们非常轻量级。容器启动迅速且运行高效，因此你可以在同一硬件上运行比虚拟机更多的容器——通常是五到十倍。你得到了密度，但每个应用程序都在自己的容器中，因此你也得到了隔离。这是Docker的另一个关键特性：效率。
- en: Now you know how Docker does its magic. In the next exercise we’ll work more
    closely with containers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了Docker是如何施展其魔法的。在下一个练习中，我们将更紧密地与容器一起工作。
- en: 2.3 Connecting to a container like a remote computer
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 像远程计算机一样连接到容器
- en: The first container we ran just did one thing--the application printed out some
    text and then it ended. There are plenty of situations where one thing is all
    you want to do. Maybe you have a whole set of scripts that automate some process.
    Those scripts need a specific set of tools to run, so you can’t just share the
    scripts with a colleague; you also need to share a document that describes setting
    up all the tools, and your colleague needs to spend hours installing them. Instead,
    you could package the tools and the scripts in a Docker image, share the image,
    and then your colleague can run your scripts in a container with no extra setup
    work.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行的第一个容器只做了一件事——应用程序打印了一些文本然后结束。有很多情况下，你只想要做一件事。也许你有一套完整的脚本来自动化某个过程。这些脚本需要特定的工具集来运行，所以你不能只是与同事分享脚本；你还需要分享一个描述设置所有工具的文档，而你的同事需要花费数小时来安装它们。相反，你可以将工具和脚本打包到Docker镜像中，分享镜像，然后你的同事可以在不需要额外设置工作的情况下在容器中运行你的脚本。
- en: You can work with containers in other ways too. Next you’ll see how you can
    run a container and connect to a terminal inside the container, just as if you
    were connecting to a remote machine. You use the same `docker` `container` `run`
    command, but you pass some additional flags to run an interactive container with
    a connected terminal session.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以以其他方式使用容器。接下来，你将看到如何运行一个容器并连接到容器内部的终端，就像你连接到远程机器一样。你使用相同的`docker` `container`
    `run`命令，但你需要传递一些额外的标志来运行一个带有连接终端会话的交互式容器。
- en: 'Try it now Run the following command in your terminal session:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '现在试试 Run the following command in your terminal session:'
- en: '`docker container run --interactive --tty diamol/base`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container run --interactive --tty diamol/base`'
- en: The `--interactive` flag tells Docker you want to set up a connection to the
    container, and the `--tty` flag means you want to connect to a terminal session
    inside the container. The output will show Docker pulling the image, and then
    you’ll be left with a command prompt. That command prompt is for a terminal session
    inside the container, as you can see in figure 2.5.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`--interactive`标志告诉Docker你想要设置与容器的连接，而`--tty`标志意味着你想要连接到容器内部的终端会话。输出将显示Docker正在拉取镜像，然后你将留下一个命令提示符。这个命令提示符是容器内部的终端会话，如图2.5所示。'
- en: '![](../Images/2-5.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-5.jpg)'
- en: Figure 2.5 Running an interactive container and connecting to the container’s
    terminal.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 运行交互式容器并连接到容器的终端。
- en: 'The exact same Docker command works in the same way on Windows, but you’ll
    drop into a Windows command-line session instead:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与Windows上的Docker命令完全相同，但你会进入一个Windows命令行会话：
- en: '` Microsoft Windows [Version 10.0.17763.557]` `(c) 2018 Microsoft Corporation.
    All rights reserved.`   ` C:\>`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '` Microsoft Windows [版本 10.0.17763.557]` `(c) 2018 Microsoft Corporation. All
    rights reserved.` ` C:\>`'
- en: Either way, you’re now inside the container and you can run any commands that
    you can normally run in the command line for the operating system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，你现在都在容器内部，你可以运行在命令行中通常可以运行的任何操作系统命令。
- en: 'Try it now Run the commands `hostname` and `date` and you’ll see details of
    the container’s environment:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '现在试试 Run the commands `hostname` and `date` and you’ll see details of the container’s
    environment:'
- en: '`/ # hostname` `f1695de1f2ec` `/ # date` `Thu Jun 20 12:18:26 UTC 2019`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ # hostname` `f1695de1f2ec` `/ # date` `Thu Jun 20 12:18:26 UTC 2019`'
- en: You’ll need some familiarity with your command line if you want to explore further,
    but what you have here is a local terminal session connected to a remote machine--the
    machine just happens to be a container that is running on your computer. For instance,
    if you use Secure Shell (SSH) to connect to a remote Linux machine, or Remote
    Desktop Protocol (RDP) to connect to a remote Windows Server Core machine, you’ll
    get exactly the same experience as you have here with Docker.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要进一步探索，你需要对你的命令行有所熟悉，但这里你所拥有的是一个连接到远程机器的本地终端会话——这个机器恰好是一个运行在你电脑上的容器。例如，如果你使用安全外壳（SSH）连接到远程Linux机器，或者使用远程桌面协议（RDP）连接到远程Windows
    Server Core机器，你将获得与这里使用Docker完全相同的体验。
- en: Remember that the container is sharing your computer’s operating system, which
    is why you see a Linux shell if you’re running Linux and a Windows command line
    if you’re using Windows. Some commands are the same for both (try `ping` `google.com`
    ), but others have different syntax (you use `ls` to list directory contents in
    Linux, and `dir` in Windows).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，容器是共享你的电脑操作系统的，这就是为什么如果你运行Linux，你会看到一个Linux shell；如果你使用Windows，你会看到一个Windows命令行。有些命令对两者都相同（试试
    `ping` `google.com` ），但有些则有不同的语法（在Linux中，你使用 `ls` 来列出目录内容，而在Windows中，你使用 `dir`）。
- en: Docker itself has the same behavior regardless of which operating system or
    processor you’re using. It’s the application inside the container that sees it’s
    running on an Intel-based Windows machine or an Arm-based Linux one. You manage
    containers with Docker in the same way, whatever is running inside them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用的是哪种操作系统或处理器，Docker本身都有相同的行为。是容器内的应用程序看到它正在运行在基于Intel的Windows机器上，或者基于Arm的Linux机器上。无论容器内运行的是什么，你都可以用Docker以相同的方式管理容器。
- en: 'Try it now Open up a new terminal session, and you can get details of all the
    running containers with this command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试打开一个新的终端会话，你可以使用这个命令获取所有运行容器的详细信息：
- en: '`docker container ls`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container ls`'
- en: 'The output shows you information about each container, including the image
    it’s using, the container ID, and the command Docker ran inside the container
    when it started--this is some abbreviated output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了每个容器的信息，包括它所使用的镜像、容器ID以及Docker在容器启动时运行的命令——这是部分缩略输出：
- en: '` CONTAINER ID IMAGE        COMMAND  CREATED        STATUS` ` f1695de1f2ec
    diamol/base "/bin/sh" 16 minutes ago Up 16 minutes`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '` CONTAINER ID IMAGE        COMMAND  CREATED        STATUS` ` f1695de1f2ec
    diamol/base "/bin/sh" 16 minutes ago Up 16 minutes`'
- en: If you have a keen eye, you’ll notice that the container ID is the same as the
    hostname inside the container. Docker assigns a random ID to each container it
    creates, and part of that ID is used for the hostname. There are lots of `docker`
    `container` commands that you can use to interact with a specific container, which
    you can identify using the first few characters of the container ID you want.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一双敏锐的眼睛，你会注意到容器ID与容器内部的hostname相同。Docker为它创建的每个容器分配一个随机ID，其中一部分用于hostname。有许多
    `docker` `container` 命令可以用来与特定的容器交互，你可以使用你想要识别的容器ID的前几个字符来识别。
- en: 'Try it now `docker` `container` `top` lists the processes running in the container.
    I’m using `f1` as a short form of the container ID `f1695de1f2ec` :'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试 `docker` `container` `top` 命令列出了容器中运行的进程。我正在使用 `f1` 作为容器ID `f1695de1f2ec`
    的简称：
- en: '` > docker container top f1` ` PID     USER     TIME     COMMAND` ` 69622  
    root     0:00     /bin/sh`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '` > docker container top f1` ` PID     USER     TIME     COMMAND` ` 69622  
    root     0:00     /bin/sh`'
- en: If you have multiple processes running in the container, Docker will show them
    all. That will be the case for Windows containers, which always have several background
    processes running in addition to the container application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器中运行着多个进程，Docker会显示它们所有。对于Windows容器来说，情况也是如此，除了容器应用程序外，它们总是有几个后台进程在运行。
- en: 'Try it now `docker` `container` `logs` displays any log entries the container
    has collected:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试 `docker` `container` `logs` 命令，它会显示容器收集到的任何日志条目：
- en: '` > docker container logs f1` ` / # hostname` ` f1695de1f2ec`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '` > docker container logs f1` ` / # hostname` ` f1695de1f2ec`'
- en: Docker collects log entries using the output from the application in the container.
    In the case of this terminal session, I see the commands I ran and their results,
    but for a real application you would see your code’s log entries. For example,
    a web application may write a log entry for every HTTP request processed, and
    these will show in the container logs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用容器中应用程序的输出收集日志条目。在这个终端会话的情况下，我看到我运行的命令及其结果，但对于一个真实的应用程序，你会看到你的代码的日志条目。例如，一个Web应用程序可能会为每个处理的HTTP请求写入一个日志条目，这些条目将显示在容器日志中。
- en: 'Try it now `docker` `container` `inspect` shows you all the details of a container:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试这个命令：`docker container inspect`会显示一个容器的所有详细信息：
- en: '`> docker container inspect f1` `[` `    {` `         "Id": "f1695de1f2ecd493d17849a709ffb78f5647a0bcd9d10f0d97ada0fcb7b05e98",`
    `         "Created": "2019-06-20T12:13:52.8360567Z"`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`> docker container inspect f1` `[` `    {` `         "Id": "f1695de1f2ecd493d17849a709ffb78f5647a0bcd9d10f0d97ada0fcb7b05e98",`
    `         "Created": "2019-06-20T12:13:52.8360567Z"`'
- en: The full output shows lots of low-level information, including the paths of
    the container’s virtual filesystem, the command running inside the container,
    and the virtual Docker network the container is connected to--this can all be
    useful if you’re tracking down a problem with your application. It comes as a
    large chunk of JSON, which is great for automating with scripts, but not so good
    for a code listing in a book, so I’ve just shown the first few lines.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的输出显示了大量的底层信息，包括容器虚拟文件系统的路径、容器内运行的命令以及容器连接到的虚拟Docker网络--如果你在追踪应用程序的问题时，这些信息都可能很有用。它以大量JSON的形式出现，非常适合用脚本自动化，但不太适合在书中的代码列表中，所以我只展示了前几行。
- en: These are the commands you’ll use all the time when you’re working with containers,
    when you need to troubleshoot application problems, when you want to check if
    processes are using lots of CPU, or if you want to see the networking Docker has
    set up for the container.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与容器一起工作时，需要解决应用程序问题，想要检查进程是否使用了大量CPU，或者想要查看Docker为容器设置的联网情况时，你将经常使用这些命令。
- en: There’s another point to these exercises, which is to help you realize that
    as far as Docker is concerned, containers all look the same. Docker adds a consistent
    management layer on top of every application. You could have a 10-year-old Java
    app running in a Linux container, a 15-year-old .NET app running in a Windows
    container, and a brand-new Go application running on a Raspberry Pi. You’ll use
    the exact same commands to manage them-- `run` to start the app, `logs` to read
    out the logs, `top` to see the processes, and `inspect` to get the details.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的另一个目的是帮助你意识到，从Docker的角度来看，所有容器看起来都是一样的。Docker在每个应用程序之上添加了一个一致的管理层。你可以在Linux容器中运行一个10年的Java应用程序，在一个Windows容器中运行一个15年的.NET应用程序，在一个树莓派上运行一个全新的Go应用程序。你将使用完全相同的命令来管理它们--`run`来启动应用程序，`logs`来读取日志，`top`来查看进程，以及`inspect`来获取详细信息。
- en: You’ve now seen a bit more of what you can do with Docker; we’ll finish with
    some exercises for a more useful application. You can close the second terminal
    window you opened (where you ran `docker` `container` `logs`), go back to the
    first terminal, which is still connected to the container, and run `exit` to close
    the terminal session.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了更多你可以用Docker做到的事情；我们将以一些练习来结束，以使应用更加有用。你可以关闭你打开的第二个终端窗口（在那里你运行了`docker
    container logs`），回到第一个终端，它仍然连接到容器，并运行`exit`来关闭终端会话。
- en: 2.4 Hosting a website in a container
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 在容器中托管网站
- en: So far we’ve run a few containers. The first couple ran a task that printed
    some text and then exited. The next used interactive flags and connected us to
    a terminal session in the container, which stayed running until we exited the
    session. `docker` `container` `ls` will show that you have no containers, because
    the command only shows running containers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经运行了一些容器。前几个容器运行了一个打印一些文本然后退出的任务。下一个使用了交互标志，并连接我们到容器中的终端会话，该会话一直运行，直到我们退出会话。`docker
    container ls`将显示你没有容器，因为该命令只显示正在运行的容器。
- en: 'Try it now Run `docker` `container` `ls` `--all` , which shows all containers
    in any status:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试这个命令：`docker container ls --all`，它会显示所有状态的容器：
- en: '`> docker container ls --all` `CONTAINER ID IMAGE                    COMMAND
                        CREATED              STATUS` `f1695de1f2ec diamol/base    
             "/bin/sh"                   About an hour ago    Exited (0)` `858a26ee2741
    diamol/ch02-hello-diamol "/bin/sh -c ./cmd.sh"       3 hours ago          Exited
    (0)` `2cff9e95ce83 diamol/ch02-hello-diamol "/bin/sh -c ./cmd.sh"       4 hours
    ago          Exited (0)`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`> docker container ls --all` `CONTAINER ID IMAGE                    COMMAND
                        CREATED              STATUS` `f1695de1f2ec diamol/base    
             "/bin/sh"                   About an hour ago    Exited (0)` `858a26ee2741
    diamol/ch02-hello-diamol "/bin/sh -c ./cmd.sh"       3 hours ago          Exited
    (0)` `2cff9e95ce83 diamol/ch02-hello-diamol "/bin/sh -c ./cmd.sh"       4 hours
    ago          Exited (0)`'
- en: The containers have the status `Exited`. There are a couple of key things to
    understand here.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的状态为`Exited`。这里有几个关键点需要理解。
- en: First, containers are running only while the application inside the container
    is running. As soon as the application process ends, the container goes into the
    exited state. Exited containers don’t use any CPU time or memory. The “Hello World”
    container exited automatically as soon as the script completed. The interactive
    container we were connected to exited as soon as we exited the terminal application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，容器仅在容器内的应用程序运行时才会运行。一旦应用程序进程结束，容器就会进入退出状态。当脚本完成后，“Hello World”容器会自动退出。我们连接的交互式容器在我们退出终端应用程序后立即退出。
- en: Second, containers don’t disappear when they exit. Containers in the exited
    state still exist, which means you can start them again, check the logs, and copy
    files to and from the container’s filesystem. You only see running containers
    with `docker` `container` `ls`, but Docker doesn’t remove exited containers unless
    you explicitly tell it to do so. Exited containers still take up space on disk
    because their filesystem is kept on the computer’s disk.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，容器在退出后不会消失。处于退出状态的容器仍然存在，这意味着你可以再次启动它们，检查日志，并将文件复制到容器文件系统。你只能通过`docker container
    ls`看到正在运行的容器，但Docker不会删除退出状态的容器，除非你明确告诉它这样做。退出状态的容器仍然占用磁盘空间，因为它们的文件系统保留在计算机的磁盘上。
- en: 'So what about starting containers that stay in the background and just keep
    running? That’s actually the main use case for Docker: running server applications
    like websites, batch processes, and databases.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于启动那些在后台运行并持续运行的容器，又是怎样的情况呢？这实际上是Docker的主要用途：运行服务器应用程序，如网站、批处理和数据库。
- en: 'Try it now Here’s a simple example, running a website in a container:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就试试吧，这里有一个简单的例子，在一个容器中运行网站：
- en: '`docker container run --detach --publish 8088:80 diamol/ch02-hello- diamol-web`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container run --detach --publish 8088:80 diamol/ch02-hello- diamol-web`'
- en: This time the only output you’ll see is a long container ID, and you get returned
    to your command line. The container is still running in the background.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，你唯一会看到的输出是一个长的容器ID，然后你会回到你的命令行。容器仍在后台运行。
- en: 'Try it now Run `docker` `container` `ls` and you’ll see that the new container
    has the status `Up` :'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就试试吧，运行`docker container ls`，你会看到新容器状态为`Up`：
- en: '`> docker container ls` `CONTAINER ID IMAGE                        COMMAND
                      CREATED        STATUS                 PORTS                NAMES`
    `e53085ff0cc4 diamol/ch02-hello-diamol-web "bin\\httpd.exe -DFOR..." 52 seconds
    ago Up 50 seconds 443/tcp, 0.0.0.0:8088->80/tcp reverent_dubinsky`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`> docker container ls` `CONTAINER ID IMAGE                        COMMAND
                      CREATED        STATUS                 PORTS                NAMES`
    `e53085ff0cc4 diamol/ch02-hello-diamol-web "bin\\httpd.exe -DFOR..." 52 seconds
    ago Up 50 seconds 443/tcp, 0.0.0.0:8088->80/tcp reverent_dubinsky`'
- en: 'The image you’ve just used is `diamol/ch02-hello-diamol-web` . That image includes
    the Apache web server and a simple HTML page. When you run this container, you
    have a full web server running, hosting a custom website. Containers that sit
    in the background and listen for network traffic (HTTP requests in this case)
    need a couple of extra flags in the `container` `run` command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚使用的镜像为`diamol/ch02-hello-diamol-web`。这个镜像包含了Apache网络服务器和一个简单的HTML页面。当你运行这个容器时，你将有一个完整的网络服务器在运行，托管一个自定义网站。位于后台并监听网络流量（在这种情况下是HTTP请求）的容器需要在`container
    run`命令中添加一些额外的标志：
- en: '`--detach`--Starts the container in the background and shows the container
    ID'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--detach`--在后台启动容器并显示容器ID'
- en: '`--publish`--Publishes a port from the container to the computer'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--publish`--将容器的一个端口发布到计算机'
- en: Running a detached container just puts the container in the background so it
    starts up and stays hidden, like a Linux daemon or a Windows service. Publishing
    ports needs a little more explanation. When you install Docker, it injects itself
    into your computer’s networking layer. Traffic coming into your computer can be
    intercepted by Docker, and then Docker can send that traffic into a container.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一个分离的容器只是将容器置于后台，使其启动并保持隐藏，就像Linux守护进程或Windows服务一样。发布端口需要更多的解释。当你安装Docker时，它会将自己注入到你的计算机的网络层。进入你的计算机的流量可以被Docker拦截，然后Docker可以将这些流量发送到容器。
- en: Containers aren’t exposed to the outside world by default. Each has its own
    IP address, but that’s an IP address that Docker creates for a network that Docker
    manages--the container is not attached to the physical network of the computer.
    Publishing a container port means Docker listens for network traffic on the computer
    port, and then sends it into the container. In the preceding example, traffic
    sent to the computer on port 8088 will get sent into the container on port 80--you
    can see the traffic flow in figure 2.6.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 容器默认情况下不会暴露给外部世界。每个容器都有自己的IP地址，但这是一个Docker为Docker管理的网络创建的IP地址——容器没有连接到计算机的物理网络。发布容器端口意味着Docker会在计算机端口上监听网络流量，然后将它发送到容器。在先前的例子中，发送到端口8088的计算机上的流量将被发送到端口80的容器中——你可以在图2.6中看到流量流向。
- en: '![](../Images/2-6.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-6.jpg)'
- en: Figure 2.6 The physical and virtual networks for computers and containers
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 计算机和容器的物理和虚拟网络
- en: In this example my computer is the machine running Docker, and it has the IP
    address `192.168.2.150` . That’s the IP address for my physical network, and it
    was assigned by the router when my computer connected. Docker is running a single
    container on that computer, and the container has the IP address `172.0.5.1` .
    That address is assigned by Docker for a virtual network managed by Docker. No
    other computers in my network can connect to the container’s IP address, because
    it only exists in Docker, but they can send traffic into the container, because
    the port has been published.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我的电脑是运行Docker的机器，它的IP地址是 `192.168.2.150`。这是我的物理网络的IP地址，当我的电脑连接时由路由器分配。Docker在该电脑上运行了一个容器，该容器的IP地址是
    `172.0.5.1`。这个地址是由Docker为Docker管理的虚拟网络分配的。我的网络中的其他电脑无法连接到容器的IP地址，因为它只存在于Docker中，但它们可以向容器发送流量，因为端口已经被发布。
- en: Try it now Browse to *http://localhost:8088* on a browser. That’s an HTTP request
    to the local computer, but the response (see figure 2.7) comes from the container.
    (One thing you definitely won’t learn from this book is effective website design.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 在浏览器中浏览到 *http://localhost:8088*。这是一个对本地计算机的HTTP请求，但响应（见图2.7）来自容器。（这本书绝对不会教你有效的网站设计。）
- en: '![](../Images/2-7.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/2-7.jpg)'
- en: Figure 2.7 The web application served from a container on the local machine
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 在本地机器上由容器提供服务的Web应用程序
- en: This is a very simple website, but even so, this app still benefits from the
    portability and efficiency that Docker brings. The web content is packaged with
    the web server, so the Docker image has everything it needs. A web developer can
    run a single container on their laptop, and the whole application--from the HTML
    to the web server stack--will be exactly the same as if an operator ran the app
    on 100 containers across a server cluster in production.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的网站，但即便如此，这个应用程序仍然受益于Docker带来的可移植性和效率。网页内容与网页服务器打包在一起，因此Docker镜像包含了它所需的一切。网页开发者可以在他们的笔记本电脑上运行一个容器，整个应用程序——从HTML到网页服务器堆栈——将和在生产环境中由操作员在服务器集群上运行的100个容器上运行的应用程序完全相同。
- en: The application in this container keeps running indefinitely, so the container
    will keep running too. You can use the `docker` `container` commands we’ve already
    used to manage it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器中的应用程序会无限期地运行，因此容器也会持续运行。你可以使用我们之前使用的 `docker` `container` 命令来管理它。
- en: 'Try it now `docker` `container` `stats` is another useful one: it shows a live
    view of how much CPU, memory, network, and disk the container is using. The output
    is slightly different for Linux and Windows containers:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 `docker` `container` `stats`，这也是一个很有用的命令：它显示了容器正在使用的CPU、内存、网络和磁盘的使用情况。对于Linux和Windows容器，输出略有不同：
- en: '`> docker container stats e53` `CONTAINER ID NAME CPU % PRIV WORKING SET NET
    I/O` `BLOCK I/O` `e53085ff0cc4 reverent_dubinsky 0.36% 16.88MiB 250kB / 53.2kB`
    `19.4MB / 6.21MB`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`> docker container stats e53` `CONTAINER ID NAME CPU % PRIV WORKING SET NET
    I/O` `BLOCK I/O` `e53085ff0cc4 reverent_dubinsky 0.36% 16.88MiB 250kB / 53.2kB`
    `19.4MB / 6.21MB`'
- en: When you’re done working with a container, you can remove it with `docker` `container`
    `rm` and the container ID, using the `--force` flag to force removal if the container
    is still running.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成与容器的操作后，你可以使用 `docker` `container` `rm` 和容器 ID 来删除它，如果容器仍在运行，可以使用 `--force`
    标志强制删除。
- en: We’ll end this exercise with one last command that you’ll get used to running
    regularly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个你将习惯定期运行的最后一个命令结束这个练习。
- en: 'Try it now Run this command to remove all your containers:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '现在试试 Run this command to remove all your containers:'
- en: '`docker container rm --force $(docker container ls --all --quiet)`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container rm --force $(docker container ls --all --quiet)`'
- en: The `$()` syntax sends the output from one command into another command--it
    works just as well on Linux and Mac terminals, and on Windows PowerShell. Combining
    these commands gets a list of all the container IDs on your computer, and removes
    them all. This is a good way to tidy up your containers, but use it with caution,
    because it won’t ask for confirmation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`$()` 语法将一个命令的输出传递给另一个命令--它在 Linux 和 Mac 终端以及 Windows PowerShell 上都同样有效。结合这些命令可以获取你电脑上所有容器的
    ID 列表，并删除它们。这是一种整理容器的不错方法，但请谨慎使用，因为它不会要求确认。'
- en: 2.5 Understanding how Docker runs containers
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 理解 Docker 运行容器的方式
- en: We’ve done a lot of try-it-now exercises in this chapter, and you should be
    happy now with the basics of working with containers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经进行了很多“试试看”练习，现在你应该对使用容器的基本操作感到满意了。
- en: In the first try-it-now for this chapter, I talked about the build, share, run
    workflow that is at the core of Docker. That workflow makes it very easy to distribute
    software--I’ve built all the sample container images and shared them, knowing
    you can run them in Docker and they will work the same for you as they do for
    me. A huge number of projects now use Docker as the preferred way to release software.
    You can try a new piece of software--say, Elasticsearch, or the latest version
    of SQL Server, or the Ghost blogging engine--with the same type of `docker` `container`
    `run` commands you’ve been using here.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个“试试看”中，我谈到了 Docker 核心的构建、共享、运行工作流程。这个工作流程使得软件的分发变得非常容易--我已经构建了所有示例容器镜像并分享了它们，知道你可以在
    Docker 中运行它们，并且它们对你和我都会产生相同的效果。现在有大量的项目使用 Docker 作为发布软件的首选方式。你可以尝试新的软件--比如，Elasticsearch、SQL
    Server 的最新版本，或者 Ghost 博客引擎--使用你在这里使用过的相同类型的 `docker` `container` `run` 命令。
- en: We’re going to end with a little more background, so you have a solid understanding
    of what’s actually happening when you run applications with Docker. Installing
    Docker and running containers is deceptively simple--there are actually a few
    different components involved, which you can see in figure 2.8.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一些额外的背景知识结束本章，这样你就能对使用 Docker 运行应用程序时实际发生的事情有一个扎实的理解。安装 Docker 和运行容器看似简单--实际上涉及几个不同的组件，如图
    2.8 所示。
- en: The Docker Engine is the management component of Docker. It looks after the
    local image cache, downloading images when you need them, and reusing them if
    they’re already downloaded. It also works with the operating system to create
    containers, virtual networks, and all the other Docker resources. The Engine is
    a background process that is always running (like a Linux daemon or a Windows
    service).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 引擎是 Docker 的管理组件。它负责本地镜像缓存，当你需要时下载镜像，如果已经下载则重用它们。它还与操作系统协同工作以创建容器、虚拟网络以及其他
    Docker 资源。引擎是一个始终在后台运行的进程（类似于 Linux 守护进程或 Windows 服务）。
- en: The Docker Engine makes all the features available through the Docker API, which
    is just a standard HTTP-based REST API. You can configure the Engine to make the
    API accessible only from the local computer (which is the default), or make it
    available to other computers on your network.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 引擎通过 Docker API 提供所有功能，这是一个基于标准的 HTTP REST API。你可以配置引擎，使其 API 只在本地计算机上可用（这是默认设置），或者使其对网络上的其他计算机可用。
- en: The Docker command-line interface (CLI) is a client of the Docker API. When
    you run Docker commands, the CLI actually sends them to the Docker API, and the
    Docker Engine does the work.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 命令行界面（CLI）是 Docker API 的客户端。当你运行 Docker 命令时，CLI 实际上会将它们发送到 Docker API，然后
    Docker 引擎执行工作。
- en: It’s good to understand the architecture of Docker. The only way to interact
    with the Docker Engine is through the API, and there are different options for
    giving access to the API and securing it. The CLI works by sending requests to
    the API.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Docker 的架构是很好的。与 Docker 引擎交互的唯一方式是通过 API，并且有不同选项可以用来访问 API 和保护它。CLI 通过向 API
    发送请求来工作。
- en: So far we’ve used the CLI to manage containers on the same computer where Docker
    is running, but you can point your CLI to the API on a remote computer running
    Docker and control containers on that machine--that’s what you’ll do to manage
    containers in different environments, like your build servers, test, and production.
    The Docker API is the same on every operating system, so you can use the CLI on
    your Windows laptop to manage containers on your Raspberry Pi, or on a Linux server
    in the cloud.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用 CLI 来管理运行 Docker 的同一台计算机上的容器，但你可以将你的 CLI 指向运行 Docker 的远程计算机上的 API，并控制该机器上的容器——这就是你管理不同环境中的容器（如你的构建服务器、测试和生产环境）的方法。Docker
    API 在每个操作系统上都是相同的，因此你可以使用你的 Windows 笔记本电脑上的 CLI 来管理你的 Raspberry Pi 上的容器，或者云中的
    Linux 服务器上的容器。
- en: '![](../Images/2-8.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 2-8](../Images/2-8.jpg)'
- en: Figure 2.8 The components of Docker
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 Docker 的组件
- en: The Docker API has a published specification, and the Docker CLI is not the
    only client. There are several graphical user interfaces that connect to the Docker
    API and give you a visual way to interact with your containers. The API exposes
    all the details about containers, images, and the other resources Docker manages
    so it can power rich dashboards like the one in figure 2.9.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Docker API 有一个已发布的规范，Docker CLI 不仅仅是唯一的客户端。有几个图形用户界面连接到 Docker API，并为你提供了一个与容器交互的视觉方式。API
    揭示了关于容器、镜像和其他 Docker 管理的资源的所有细节，因此它可以支持如图 2.9 所示的丰富仪表板。
- en: '![](../Images/2-9.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 2-9](../Images/2-9.jpg)'
- en: Figure 2.9 Docker Universal Control Plane, a graphical user interface for containers
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 Docker 通用控制平面，容器图形用户界面
- en: This is Universal Control Plane (UCP), a commercial product from the company
    behind Docker ( *[https://docs.docker.com/ee/ucp/](https://docs.docker.com/ee/ucp/)*
    ). Portainer is another option, which is an open source project. Both UCP and
    Portainer run as containers themselves, so they’re easy to deploy and manage.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通用控制平面（UCP），Docker 背后公司的商业产品（*[https://docs.docker.com/ee/ucp/](https://docs.docker.com/ee/ucp/)*）。Portainer
    是另一个选择，它是一个开源项目。UCP 和 Portainer 都作为容器本身运行，因此它们易于部署和管理。
- en: We won’t be diving any deeper into the Docker architecture than this. The Docker
    Engine uses a component called containerd to actually manage containers, and containerd
    in turn makes use of operating system features to create the virtual environment
    that is the container.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会比这更深入地探讨 Docker 架构。Docker 引擎使用一个名为 containerd 的组件来实际管理容器，而 containerd 又利用操作系统功能来创建容器所代表的虚拟环境。
- en: 'You don’t need to understand the low-level details of containers, but it is
    good to know this: containerd is an open source component overseen by the Cloud
    Native Computing Foundation, and the specification for running containers is open
    and public; it’s called the Open Container Initiative (OCI).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要理解容器的底层细节，但了解这一点是好的：containerd 是一个由云原生计算基金会监管的开源组件，运行容器的规范是开放和公共的；它被称为开放容器倡议（OCI）。
- en: Docker is by far the most popular and easy to use container platform, but it’s
    not the only one. You can confidently invest in containers without being concerned
    that you’re getting locked in to one vendor’s platform.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是迄今为止最受欢迎且易于使用的容器平台，但它不是唯一的。你可以放心地投资容器，而不用担心你会被锁定在某个供应商的平台。
- en: '2.6 Lab: Exploring the container filesystem'
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 实验室：探索容器文件系统
- en: This is the first lab in the book, so here’s what it’s all about. The lab sets
    you a task to achieve by yourself, which will really help you cement what you’ve
    learned in the chapter. There will be some guidance and a few hints, but mostly
    this is about you going further than the prescriptive try-it-now exercises and
    finding your own way to solve the problem.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的第一个实验室，所以这就是它的全部内容。实验室为你设定了一个任务，让你自己完成，这将真正帮助你巩固你在本章中学到的知识。会有一些指导和几个提示，但大部分是关于你超越规定的“现在试试”练习，找到自己的解决问题的方法。
- en: 'Every lab has a sample solution on the book’s GitHub repository. It’s worth
    spending some time trying it out yourself, but if you want to check my solution
    you can find it here: *[https://github.com/sixeyed/diamol/tree/master/ch02/lab](https://github.com/sixeyed/diamol/tree/master/ch02/lab)*
    .'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实验室在本书的 GitHub 仓库中都有一个示例解决方案。花些时间自己尝试一下是值得的，但如果你想检查我的解决方案，你可以在这里找到：*[https://github.com/sixeyed/diamol/tree/master/ch02/lab](https://github.com/sixeyed/diamol/tree/master/ch02/lab)*。
- en: 'Here we go: your task is to run the website container from this chapter, but
    replace the `index.html` file so when you browse to the container you see a different
    homepage (you can use any content you like). Remember that the container has its
    own filesystem, and in this application, the website is serving files that are
    on the container’s filesystem.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始吧：你的任务是运行本章中的网站容器，但替换 `index.html` 文件，这样当你浏览到容器时，你会看到一个不同的主页（你可以使用你喜欢的任何内容）。记住，容器有自己的文件系统，在这个应用程序中，网站正在提供位于容器文件系统上的文件。
- en: 'Here are some hints to get you going:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示来帮助你开始：
- en: You can run `docker` `container` to get a list of all the actions you can perform
    on a container.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过运行 `docker` `container` 来获取您可以在容器上执行的所有操作的列表。
- en: Add `--help` to any `docker` command, and you’ll see more detailed help text.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何 `docker` 命令中添加 `--help`，你将看到更详细的帮助文本。
- en: In the `diamol/ch02-hello-diamol-web` Docker image, the content from the website
    is served from the directory `/usr/local/apache2/htdocs` (that’s `C:\usr\local\apache2\htdocs`
    on Windows).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `diamol/ch02-hello-diamol-web` Docker 镜像中，网站内容是从目录 `/usr/local/apache2/htdocs`（在
    Windows 上是 `C:\usr\local\apache2\htdocs`）提供的。
- en: Good luck :)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你好运 :)
