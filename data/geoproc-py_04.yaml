- en: Chapter 5\. Filtering data with OGR
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章. 使用OGR过滤数据
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Efficiently selecting features using attribute values
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性值高效选择特性
- en: Using spatial location to select features
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空间位置选择特性
- en: Joining attribute tables from different layers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不同层连接属性表
- en: Back in [chapter 3](kindle_split_011.html#ch03), you learned how to iterate
    through all of the features in a layer and use attribute values for each one to
    determine if it was interesting. You’ve got easier ways to throw out features
    that you don’t want, however, and that’s where filters come in. With filters you
    can easily select features that match specific criteria, such as all animal GPS
    locations from a certain day or all crabapple trees from a city tree inventory.
    Filters also let you limit features by spatial extent, so you could limit your
    crabapple trees to a specific neighborhood, or GPS locations to those within a
    kilometer of an animal feeding station. Filtering your data like this makes it
    easy to extract or process only the features you’re interested in. I’ve used these
    techniques to extract features such as city boundaries for a single county from
    a larger dataset, or to extract highways and freeways from road datasets, while
    ignoring the smaller residential roads.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](kindle_split_011.html#ch03)中，你学习了如何遍历一个层中的所有特性，并使用每个特性的属性值来确定它是否有趣。然而，你有更简单的方法来丢弃不需要的特性，这就是过滤器的作用所在。使用过滤器，你可以轻松选择符合特定标准的特性，例如某一天的所有动物GPS位置或城市树木清单中的所有苹果树。过滤器还允许你通过空间范围限制特性，因此你可以将苹果树限制在特定的社区内，或将GPS位置限制在动物喂食站一公里范围内。以这种方式过滤数据可以轻松提取或处理你感兴趣的特性。我已使用这些技术从更大的数据集中提取城市边界等特性，或从道路数据集中提取高速公路和快速路，同时忽略较小的住宅道路。
- en: You can also use SQL queries to join attribute tables together from different
    layers. For example, if you had a layer containing all of the locations of your
    store franchises and each feature had an attribute denoting the city that the
    store was in, then you could join this layer with one containing cities. If the
    city layer contained demographic information for each city, then that data would
    be associated with the store data, and you could easily compare demographics between
    stores.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用SQL查询将来自不同层的属性表连接起来。例如，如果你有一个包含所有商店分店位置的层，并且每个特性都有一个表示商店所在城市的属性，那么你可以将这个层与包含城市的层连接起来。如果城市层包含每个城市的人口统计信息，那么这些数据将与商店数据相关联，你就可以轻松地比较不同商店之间的统计数据。
- en: '|  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-8
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: SQL is short for Structured Query Language, although you’ll rarely see it written
    out like that. If you’ve used a relational database, then you’ve probably used
    SQL, even if you didn’t realize it. For example, if you build a graphical query
    in Microsoft Access, it still builds a SQL query behind the scenes, and you can
    see it if you switch to SQL View. SQL is featured more prominently in other database
    software such as PostgreSQL.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SQL代表结构化查询语言，尽管你很少看到它以这种方式书写。如果你使用过关系型数据库，那么你可能已经使用过SQL，即使你没有意识到。例如，如果你在Microsoft
    Access中构建了一个图形查询，它仍然在后台构建一个SQL查询，如果你切换到SQL视图，你就可以看到它。SQL在其他数据库软件中（如PostgreSQL）更为突出。
- en: '|  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.1\. Attribute filters
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1. 属性过滤器
- en: 'If you need to limit the features by values contained in one or more attribute
    fields, then you want an attribute filter. To set one of these filters, you need
    to come up with a conditional statement that’s much like the `WHERE` clause in
    a SQL statement. You compare the value of an attribute field to another value,
    and then all features where that comparison is true are returned. The standard
    logical operators, such as `=`, `!=`, `<>`, `>`, `<`, `>=`, and `<=,` allow you
    to use statements such as the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要通过一个或多个属性字段中的值来限制特性，那么你需要一个属性过滤器。要设置这样的过滤器，你需要提出一个类似于SQL语句中的`WHERE`子句的条件语句。你将一个属性字段的值与另一个值进行比较，然后返回所有比较结果为真的特性。标准的逻辑运算符，如`=`,
    `!=`, `<>`, `>`, `<`, `>=`, 和 `<=`，允许你使用以下之类的语句：
- en: '![](089fig01_alt.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](089fig01_alt.jpg)'
- en: You can probably guess what these comparisons do; they all test for equality
    or inequality. Notice that if you’re comparing strings, you need to put quotes
    around the string values, but they can be either single or double. Make sure they’re
    different from the quotes you use to surround the entire query string, or else
    you’ll end your string prematurely and get a syntax error. Don’t use quotes with
    numbers, because that turns them into string values, and you won’t get the comparison
    you were expecting. Another thing you might have noticed is that you use a single
    equal sign to test for equality, which isn’t the way programming languages typically
    work. But that’s the way SQL does things, so who are we to argue? In addition,
    if you want to test if something doesn’t equal another value, you can use either
    `!=` or `<>`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经猜到了这些比较的作用；它们都测试的是相等或不相等。请注意，如果您正在比较字符串，您需要在字符串值周围加上引号，但它们可以是单引号或双引号。确保它们与您用于包围整个查询字符串的引号不同，否则您将提前结束字符串并得到语法错误。不要在数字周围使用引号，因为这会将它们转换为字符串值，您将不会得到预期的比较结果。您可能还注意到，您使用单个等号来测试相等，这与编程语言通常的做法不同。但这是
    SQL 的做法，所以我们有什么理由争论呢？此外，如果您想测试某个值是否不等于另一个值，您可以使用 `!=` 或 `<>`。
- en: 'You can also combine statements using `AND` or `OR`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 `AND` 或 `OR` 来组合语句：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first of these selects features with a population value greater than 25,000
    but less than 50,000\. The second selects features that either have a population
    greater than 50,000 or are county seats (or both).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选择具有超过 25,000 但少于 50,000 人口的区域。第二个选择的是人口超过 50,000 或是县首府（或两者都是）的区域。
- en: 'Conditions can be negated using `NOT`, and `NULL` is used to indicate a null
    or no data value in the attribute table:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `NOT` 来否定条件，`NULL` 用于在属性表中指示空或无数据值：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That first example selects features that either have a population less than
    50,000 or aren’t county seats. Again, a feature will be selected if it meets one
    or both of those conditions. The second example selects features that have a value
    for the `County` attribute.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例选择的是人口少于 50,000 或不是县首府的区域。再次强调，如果一个区域满足上述一个或两个条件，它将被选中。第二个示例选择的是具有 `County`
    属性值的区域。
- en: 'If you want to check if a value is between two other values, you can use `BETWEEN`
    instead of two different comparisons joined with `AND`. For example, the following
    two statements are equivalent, and both select features with a population between
    25,000 and 50,000:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想检查一个值是否介于两个其他值之间，您可以使用 `BETWEEN` 而不是使用两个不同的比较并用 `AND` 连接。例如，以下两个语句是等价的，并且都选择人口在
    25,000 到 50,000 之间的区域：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You have an easy way to check if a value is equal to one of several different
    values. Once again, both of these select features where the `Type_code` value
    is 4, 3, or 7:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一种简单的方法来检查一个值是否等于几个不同的值。再次强调，这两个选择功能 `Type_code` 的值是 4、3 或 7：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This also works for strings:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于字符串：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Last, you can compare strings using the normal logical operators (*a* is less
    than *c*), or you can do fancier, case-insensitive, string matching using `LIKE`.
    This allows you to use wildcards to match any character in a string. An underscore
    matches any single character and a percent sign matches any number of characters.
    [Table 5.1](#ch05table01) shows examples, and this is how you’d use them:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用正常的逻辑运算符（*a* 小于 *c*）来比较字符串，或者您可以使用更复杂的、不区分大小写的字符串匹配，使用 `LIKE`。这允许您使用通配符来匹配字符串中的任何字符。下划线匹配任何单个字符，百分号匹配任意数量的字符。[表
    5.1](#ch05table01) 展示了示例，以下是使用方法：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Table 5.1\. Match examples using the LIKE operator
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.1\. 使用 LIKE 运算符的匹配示例
- en: '| Pattern | Matches | Doesn’t match |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 匹配 | 不匹配 |'
- en: '| --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| _eattle | Seattle | Seattle WA |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| _eattle | Seattle | Seattle WA |'
- en: '| Seattle% | Seattle, Seattle WA | North Seattle |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Seattle% | Seattle, Seattle WA | North Seattle |'
- en: '| %Seattle% | Seattle, Seattle WA, North Seattle | Tacoma |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| %Seattle% | Seattle, Seattle WA, North Seattle | Tacoma |'
- en: '| Sea%le | Seattle | Seattle WA |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| Sea%le | Seattle | Seattle WA |'
- en: '| Sea_le | Seatle (note misspelling) | Seattle |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| Sea_le | Seatle (note misspelling) | Seattle |'
- en: 'If you want to read more about the SQL syntax available in OGR, check out the
    online documentation at [http://www.gdal.org/ogr_sql.html](http://www.gdal.org/ogr_sql.html)
    and [http://www.gdal.org/ogr_sql_sqlite.html](http://www.gdal.org/ogr_sql_sqlite.html).
    But for now, let’s see how to put this newfound information to use. It will definitely
    be more fun if you fire up a Python interactive window for testing this out, because
    you can use the `VectorPlotter` class to interactively draw your selections. After
    configuring an interactive vector plotter, open the global data folder and grab
    the low-resolution countries layer:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于OGR中可用的SQL语法，请查看[http://www.gdal.org/ogr_sql.html](http://www.gdal.org/ogr_sql.html)和[http://www.gdal.org/ogr_sql_sqlite.html](http://www.gdal.org/ogr_sql_sqlite.html)上的在线文档。但现在，让我们看看如何使用这些新获得的信息。如果你为测试而启动Python交互式窗口，这肯定会更有趣，因为你可以使用`VectorPlotter`类来交互式地绘制你的选择。配置交互式矢量绘图器后，打开全球数据文件夹，获取低分辨率国家图层：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then plot out the features, but be patient if it takes it a few seconds to draw
    the output shown in [figure 5.1](#ch05fig01), since it has a fair amount of data
    to plot. Remember that setting `fill=False` tells it to draw only country outlines.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后绘制特征，但如果绘制输出[图5.1](#ch05fig01)需要几秒钟，请耐心等待，因为它有相当多的数据需要绘制。记住，设置`fill=False`告诉它只绘制国家轮廓。
- en: Figure 5.1\. The ne_50m_admin_0_countries shapefile layer in the global data
    folder, with no filters applied
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1\. 全球数据文件夹中的ne_50m_admin_0_countries形状文件图层，未应用过滤器
- en: '![](05fig01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig01.jpg)'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now inspect the layer attributes by printing out the names of the first few
    features:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过打印前几个特征的名字来检查图层属性：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice that the feature IDs (FIDs) are in order and also the fact that there
    are 241 features in the layer. Now find out how many of those are in Asia by using
    an attribute filter. To do this, pass a conditional statement to `SetAttributeFilter`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意特征ID（FID）是有序的，以及该图层中有241个特征。现在使用属性过滤器找出其中有多少在亚洲。为此，将条件语句传递给`SetAttributeFilter`：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now the layer thinks it has only 53 features. The zero that got spit out when
    you called `SetAttributeFilter` means that the query executed successfully. Now
    that you have selected the countries in Asia, try drawing them in yellow; your
    result should look like [figure 5.2](#ch05fig02):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在图层认为它只有53个特征。当你调用`SetAttributeFilter`时输出的零表示查询执行成功。现在你已经选择了亚洲国家，尝试用黄色绘制它们；你的结果应该像[图5.2](#ch05fig02)所示：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Figure 5.2\. An attribute filter that selects countries in Asia has been applied
    to the countries layer shown in [figure 5.1](#ch05fig01), and the results are
    plotted on top of the original.
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2\. 已将选择亚洲国家的属性过滤器应用于[图5.1](#ch05fig01)中显示的国家图层，并将结果绘制在原始图之上。
- en: '![](05fig02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig02.jpg)'
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Note to Print Book Readers: Color Graphics'
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意：印刷版书籍读者：彩色图形
- en: Many graphics in this book are best viewed in color. The eBook versions display
    the color graphics, so they should be referred to as you read. To get your free
    eBook in PDF, ePub, and Kindle formats, go to [https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python)
    to register your print book.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多图形最好以彩色查看。电子书版本显示彩色图形，因此阅读时应参考这些版本。要获取免费电子书（PDF、ePub和Kindle格式），请访问[https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python)注册您的印刷版书籍。
- en: '|  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can look a little more closely at what’s happening with the filter by printing
    attributes for the first few features:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过打印前几个特征的特征来更仔细地查看过滤器发生的情况：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Huh. Now you’re missing a bunch of FIDs. That’s because those features aren’t
    in Asia, so they’re ignored while iterating through the layer. Getting features
    by specific FID doesn’t honor the filter, however, because features aren’t truly
    being deleted, and therefore the FID values don’t change. You can prove it to
    yourself by getting a feature or two using FIDs:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 哎。现在你丢失了一大批FID。这是因为这些特征不在亚洲，所以在遍历图层时被忽略了。然而，通过特定的FID获取特征并不尊重过滤器，因为特征并没有真正被删除，因此FID值没有改变。你可以通过使用FID获取一个或两个特征来证明这一点：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can see from this that even though Angola doesn’t show up when you iterate
    through the filtered layer, it’s still there. It should be obvious to you now
    that looping through a filtered layer using specific FIDs is a bad idea and you
    won’t get the desired results. Instead, you need to iterate through the layer
    using a `for` loop.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这一点看出，即使安哥拉在遍历过滤图层时没有显示出来，它仍然存在。现在您应该很明显，使用特定的FID遍历过滤图层是一个坏主意，您不会得到期望的结果。相反，您需要使用`for`循环遍历图层。
- en: If you set another attribute filter, it doesn’t create a subset of the currently
    filtered features. Instead, the new filter is applied to the entire layer. To
    illustrate this, try applying a new filter that selects the countries in South
    America, and then draw them in blue, which results in the shading you see in [figure
    5.3](#ch05fig03).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您设置另一个属性过滤器，它不会创建当前过滤特性的子集。相反，新过滤器应用于整个图层。为了说明这一点，尝试应用一个新的过滤器，该过滤器选择南美洲的国家，并将它们用蓝色绘制出来，这会导致您在[图5.3](#ch05fig03)中看到的着色效果。
- en: Figure 5.3\. An attribute filter that selects countries in South America has
    been applied to the countries layer and the results plotted on top of the previous
    data from [figure 5.2](#ch05fig02).
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3. 已将选择南美洲国家的属性过滤器应用于国家图层，并将结果绘制在[图5.2](#ch05fig02)中的先前数据之上。
- en: '![](05fig03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig03.jpg)'
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can, however, use both attribute and spatial filters together to refine
    your results, and you’ll see an example of that in the next section. To clear
    out the attribute filter and get all 241 features back, simply pass `None` to
    `SetAttributeFilter`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以将属性和空间过滤器一起使用来细化您的结果，您将在下一节中看到一个例子。要清除属性过滤器并恢复所有241个特性，只需将`None`传递给`SetAttributeFilter`：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Removing the filter also resets the current feature back to the beginning, as
    if you had just opened the layer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 移除过滤器也会将当前特性重置到开始位置，就像您刚刚打开图层一样。
- en: 5.2\. Spatial filters
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2. 空间过滤器
- en: Spatial filters let you limit the features by spatial extent rather than attribute
    value. These filters can be used to select features within another geometry or
    inside a bounding box. For example, if you had a dataset of global cities with
    no attribute indicating the country that the cities are in, but you had another
    dataset with the same spatial reference system that contained the boundary of
    Germany, you could use a spatial filter to select the German cities.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 空间过滤器允许您通过空间范围而不是属性值来限制特征。这些过滤器可以用来选择另一个几何体内部的特性或边界框内的特性。例如，如果您有一个全球城市的数据集，没有属性表明这些城市所在的国界，但您还有一个具有相同空间参考系统的数据集，其中包含德国的国界，您可以使用空间过滤器来选择德国的城市。
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Spatial reference systems and spatial filters**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**空间参考系统和空间过滤器**'
- en: The geometries or coordinates used for spatial filtering must use the same spatial
    reference system as the layer you’re trying to filter. Why is this? Pretend for
    a moment that you have a layer that uses a Universal Transverse Mercator (UTM)
    spatial reference system. Coordinates in that layer would be large numbers, much
    different than the latitude and longitude values we’re all familiar with. This
    means that they wouldn’t align if plotted on top of each other, and they’d appear
    to have non-overlapping spatial extents. For example, the UTM easting and northing
    coordinates for the capitol building in Salt Lake City, UT, are approximately
    425045 and 4514422, but the corresponding longitude and latitude are -111.888
    and 40.777\. Those coordinates are awfully different from each other, and they
    wouldn’t overlay on each other unless one of them was transformed to the same
    spatial reference system as the other.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 用于空间过滤的几何体或坐标必须使用与您试图过滤的图层相同的空间参考系统。为什么是这样？假设您有一个使用通用横轴墨卡托（UTM）空间参考系统的图层。该图层中的坐标将是大数字，与我们所有人都熟悉的纬度和经度值大不相同。这意味着如果它们叠加在一起，它们就不会对齐，并且它们看起来似乎没有重叠的空间范围。例如，盐湖城首府的UTM东西坐标大约为425045和4514422，但相应的经度和纬度是-111.888和40.777。这些坐标彼此之间非常不同，除非其中一个被转换到与另一个相同的空间参考系统，否则它们不会重叠。
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try selecting cities in Germany using the natural earth shapefiles. After setting
    up a vector plotter in an interactive window, open the folder data source and
    get the countries layer. Then use an attribute filter to limit the countries to
    Germany and grab the corresponding feature and geometry:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用自然地球形状文件选择德国的城市。在交互式窗口中设置矢量绘图器后，打开数据源文件夹并获取国家图层。然后使用属性过滤器将国家限制为德国，并获取相应的要素和几何形状：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can assume, in this case, that the attribute filter will return one and
    only one feature, so using `GetNextFeature` will get the first and only feature
    in the filtered results. Then you grab the geometry and clone it so that you can
    use the geometry even after the feature is removed from memory. Oh, and you also
    plot the world countries before applying the filter so that you have context for
    the cities later on. Now open the populated places layer and plot all cities (see
    [figure 5.4](#ch05fig04)) as yellow dots:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以假设属性过滤器将返回一个且仅有一个要素，因此使用 `GetNextFeature` 将获取过滤结果中的第一个且唯一的要素。然后获取几何形状并克隆它，这样即使要素从内存中移除后，也可以使用该几何形状。哦，并且你还在应用过滤器之前绘制了世界国家，这样在稍后就可以为城市提供上下文。现在打开人口地点图层，并将所有城市（见[图5.4](#ch05fig04)）绘制为黄色点：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Figure 5.4\. All of the cities in the populated_places layer in the natural
    earth dataset
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.4\. 自然地球数据集中人口地点图层中的所有城市
- en: '![](05fig04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig04.jpg)'
- en: 'The call to `GetFeatureCount` indicates there are 1,249 city features in the
    full layer. Now try applying a spatial filter by passing the `germany` geometry
    that you got earlier to `SetSpatialFilter,` and then plot the resulting cities
    as large dots:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFeatureCount` 调用表明在完整图层中有1,249个城市要素。现在尝试通过传递之前获取的 `germany` 几何形状到 `SetSpatialFilter`，然后以大点形式绘制结果城市：'
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now the layer claims to have only five features, so five cities fall within
    the German boundary polygon. You can also see from your plot that the circles
    fall in the correct geographical area. You can use the Zoom to rectangle tool
    on the bottom of the plot window to zoom in on Germany if you’d like ([figure
    5.5](#ch05fig05)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在图层声称只有五个要素，因此五个城市位于德国边界多边形内。你还可以从你的绘图中看到，圆圈位于正确的地理区域内。如果你想要放大查看德国，可以使用绘图窗口底部的“缩放至矩形”工具（[图5.5](#ch05fig05)）。
- en: Figure 5.5\. A spatial filter has been applied to the populated_places layer
    to limit the features to those within the boundaries of Germany. These filtered
    points are shown in as large dots.
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.5\. 已将空间过滤器应用于人口地点图层，以限制要素仅限于德国边界内。这些过滤点以大点形式显示。
- en: '![](05fig05.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig05.jpg)'
- en: '|  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**To clone or not to clone?**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**克隆与否？**'
- en: 'Geometry objects have a `Clone` function, which makes a copy of the object.
    Why would you want to use this? When you get a geometry from a feature, that geometry
    is still associated with that feature. If that feature is then deleted (or the
    variable is populated with a different feature), then the geometry is no longer
    useable. In fact, if you try to use it, Python will crash instead of spit out
    an error. This problem is easy to solve, however, by cloning the geometry. Now
    you can store a copy of the feature or geometry that’s no longer associated with
    other objects and will live on even if the parent objects disappear. Want to see
    this in action? Try this in an interactive window:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 几何对象有一个 `Clone` 函数，它创建对象的副本。你为什么想使用它？当你从一个要素获取几何形状时，该几何形状仍然与该要素相关联。如果该要素随后被删除（或变量被填充了不同的要素），那么该几何形状就不再可用。实际上，如果你尝试使用它，Python
    将崩溃而不是输出错误。然而，通过克隆几何形状可以轻松解决这个问题。现在你可以存储不再与其它对象关联的要素或几何形状的副本，即使父对象消失，这些副本仍然存在。想看看这个动作吗？尝试在交互式窗口中这样做：
- en: '![](096fig01_alt.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](096fig01_alt.jpg)'
- en: In this example, the `geom` variable holds a `Geometry` object that’s still
    owned by the `Feature` object stored in the `feat` variable, but the `geom_clone`
    variable holds a geometry that has been disassociated from that feature. After
    you populate the `feat` variable with a different feature, you can still use the
    `geom_clone` geometry, but not the object stored in the `geom` variable, because
    you no longer have a handle to the feature that it came from.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`geom` 变量持有由存储在 `feat` 变量中的 `Feature` 对象拥有的 `Geometry` 对象，但 `geom_clone`
    变量持有与该要素已断开关联的几何形状。在你用不同的要素填充 `feat` 变量后，你仍然可以使用 `geom_clone` 几何形状，但不能使用存储在 `geom`
    变量中的对象，因为你不再有来自该要素的句柄。
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In each case, the data source has gone out of scope or been deleted before you
    try to use the layer. But the layer is associated with the data source and becomes
    unusable once the data source is gone, the same way a geometry becomes unusable
    if its parent feature disappears. You should never close your data source if you
    still need access to the layer.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，数据源在你尝试使用图层之前就已经超出范围或被删除了。但是，图层与数据源相关联，一旦数据源消失，图层就变得不可用，就像如果其父特征消失，几何体变得不可用一样。如果你仍然需要访问图层，永远不要关闭你的数据源。
- en: '|  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'As promised, you now get to combine a spatial and an attribute query. Further
    refine your selection by finding the cities with a population over 1,000,000,
    and draw them as the squares shown in [figure 5.6](#ch05fig06):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如承诺的那样，你现在可以结合空间和属性查询。通过找到人口超过100万的城市来进一步细化你的选择，并将它们绘制成[图5.6](#ch05fig06)中显示的方块：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Figure 5.6\. An attribute filter has been combined with a spatial filter to
    select the German cities with a population greater than 1,000,000 people. The
    selected features are shown as squares instead of circles.
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.6\. 属性过滤器与空间过滤器相结合，以选择人口超过100万人的德国城市。选定的特征以方块而不是圆圈的形式显示。
- en: '![](05fig06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![05fig06.jpg](05fig06.jpg)'
- en: 'Judging from these results, there are three German cities with populations
    of more than 1,000,000 people. [Figure 5.6](#ch05fig06) shows the output plot
    zoomed in on Germany so you can see these features. But what if you decide that
    you want to know how many cities exist in the entire world with a population that
    large? All you have to do is remove the spatial filter by passing `None` to `SetSpatialFilter`.
    Note that the attribute filter will still be in effect. Go ahead and try it, drawing
    the results as triangles:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些结果来看，有三个德国城市的人口超过100万。[图5.6](#ch05fig06)显示了放大后的德国输出图，你可以看到这些特征。但如果你决定想知道世界上有多少个城市的人口达到如此规模？你只需要通过将`None`传递给`SetSpatialFilter`来移除空间过滤器。请注意，属性过滤器仍然有效。现在就试试吧，用三角形绘制结果：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: And now you know where the largest cities in the world are ([figure 5.7](#ch05fig07)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了世界上最大城市的位置（[图5.7](#ch05fig07)）。
- en: Figure 5.7\. The spatial filter has been removed, but the attribute filter is
    still in effect, so now all of the cities in the world with a population of more
    than 1,000,000 are drawn as triangles over the top of the original dots for all
    cities.
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.7\. 空间过滤器已被移除，但属性过滤器仍然有效，因此现在所有人口超过100万的世界城市都作为三角形绘制在所有城市原始点之上。
- en: '![](05fig07.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![05fig07.jpg](05fig07.jpg)'
- en: 'You’re not completely out of luck if you’d like to filter features spatially
    but don’t have a geometry to use. You can also use a rectangular extent by providing
    the minimum and maximum x and y coordinates:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在空间上过滤特征但没有可用的几何体，你还可以通过提供最小和最大的x和y坐标来使用矩形范围：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can use this to select the countries that fall within the box shown in
    [figure 5.8](#ch05fig08). Again, start by plotting all of the countries:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个信息来选择[图5.8](#ch05fig08)中显示的框内的国家。再次，先绘制所有国家：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Figure 5.8\. The minimum and maximum x and y values for the rectangle surrounding
    Australia can be used to set a spatial extent on the global countries layer.
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.8\. 澳大利亚周围矩形的最大和最小x和y值可以用来设置全球国家图层上的空间范围。
- en: '![](05fig08_alt.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![05fig08_alt.jpg](05fig08_alt.jpg)'
- en: 'Now plug in the bounding coordinates shown in [figure 5.8](#ch05fig08):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入[图5.8](#ch05fig08)中显示的边界坐标：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now you should have a plot that looks similar to [figure 5.9](#ch05fig09), with
    Australia and a few surrounding countries shaded in.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该有一个看起来类似于[图5.9](#ch05fig09)的图表，澳大利亚及其周边的一些国家被阴影覆盖。
- en: Figure 5.9\. The shaded countries were selected using the rectangular extent
    shown in [figure 5.8](#ch05fig08).
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.9\. 使用[图5.8](#ch05fig08)中显示的矩形范围选定了阴影覆盖的国家。
- en: '![](05fig09.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![05fig09.jpg](05fig09.jpg)'
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: To clear a spatial filter, whether it was created with a geometry or a bounding
    box, pass `None` to `SetSpatialFilter`. You can’t clear the filter using `SetSpatialFilterRect`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要清除空间过滤器，无论是用几何体还是边界框创建的，都通过将`None`传递给`SetSpatialFilter`。你不能使用`SetSpatialFilterRect`来清除过滤器。
- en: '|  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.3\. Using SQL to create temporary layers
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 使用SQL创建临时图层
- en: 'If you’re familiar with SQL, or are willing to learn, you can create more-complicated
    queries and do fun stuff using the `ExecuteSQL` function on a data source. This
    function applies to a data source instead of a layer because it allows you to
    use multiple layers if desired. It requires a SQL query and can optionally use
    a geometry as a spatial filter. In addition, you can also specify a different
    SQL dialect, but more on that later. Here’s the signature:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉 SQL 或愿意学习，您可以使用数据源上的 `ExecuteSQL` 函数创建更复杂的查询并做一些有趣的事情。此函数适用于数据源而不是层，因为它允许您在需要时使用多个层。它需要一个
    SQL 查询，并可选择使用一个几何体作为空间过滤器。此外，您还可以指定不同的 SQL 方言，但关于这一点稍后讨论。以下是签名：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`statement` is the SQL statement to use.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statement` 是要使用的 SQL 语句。'
- en: '`spatialFilter` is an optional geometry to use as a spatial filter on the results.
    The default is no filter.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spatialFilter` 是一个可选的几何对象，用作结果上的空间过滤器。默认情况下没有过滤器。'
- en: '`dialect` is a string specifying the SQL dialect to use. Available options
    are `OGRSQL` and `SQLite`. The default is to use the OGR dialect unless the data
    source has its own SQL engine (such as a SpatiaLite database).'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dialect` 是一个字符串，用于指定要使用的 SQL 方言。可用选项是 `OGRSQL` 和 `SQLite`。默认情况下，使用 OGR 方言，除非数据源有自己的
    SQL 引擎（例如 SpatiaLite 数据库）。'
- en: 'This function is different from the filtering functions in that it returns
    a new layer containing the result set rather than only filtering features out
    of the existing layer. Let’s look at a few examples using this technique, starting
    with a simple one that returns global countries sorted by population in descending
    order:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与过滤函数不同，因为它返回一个包含结果集的新层，而不是仅从现有层中过滤出特征。让我们通过几个示例来了解这个技术，从一个简单的示例开始，该示例返回按人口降序排列的全球国家：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see from these results, the three most populous countries in the
    world are China, India, and the United States, in that order. The query returns
    each country’s name and population attributes because you request them in the
    SQL statement. You also use the special `ogr_geom_area` field to get the area
    of each geometry ([table 5.2](#ch05table02)), and the FID and geometry itself
    are returned automatically. This example uses the default OGR SQL dialect because
    shapefiles don’t have any built-in SQL support.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这些结果中看到的，世界上人口最多的三个国家按顺序是中国、印度和美国。查询返回每个国家的名称和人口属性，因为您在 SQL 语句中请求了它们。您还使用了特殊的
    `ogr_geom_area` 字段来获取每个几何体的面积（[表 5.2](#ch05table02)），FID 和几何体本身会自动返回。此示例使用默认的
    OGR SQL 方言，因为 shapefiles 没有任何内置的 SQL 支持。
- en: Table 5.2\. Special fields used in the OGR SQL dialect
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.2\. OGR SQL 方言中使用的特殊字段
- en: '| Field | Returns |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 返回值 |'
- en: '| --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| FID | The feature ID. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| FID | 特征 ID。 |'
- en: '| OGR_GEOMETRY | An OGR geometry type constant (see [table 3.1](kindle_split_011.html#ch03table01)).
    This is especially useful for data formats that support multiple geometry types
    in one layer. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| OGR_GEOMETRY | OGR 几何类型常量（见 [表 3.1](kindle_split_011.html#ch03table01)）。这对于在一个层中支持多种几何类型的数据格式特别有用。
    |'
- en: '| OGR_GEOM_WKT | The well-known text (WKT) representation of the feature’s
    geometry. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| OGR_GEOM_WKT | 特征几何的已知文本（WKT）表示形式。 |'
- en: '| OGR_GEOM_AREA | The area of the feature’s geometry. Returns zero for geometries
    with no area (for example, points or lines). |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| OGR_GEOM_AREA | 特征几何的面积。对于没有面积（例如，点或线）的几何体返回零。 |'
- en: '| OGR_STYLE | The style string for the feature, if it exists. Very few applications
    use this. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| OGR_STYLE | 如果存在，则返回特征的样式字符串。很少应用程序使用此功能。 |'
- en: 'If you’re querying a data source that has its own SQL support, that native
    SQL version will be used. For example, if you have the SQLite driver, you could
    get the same information from the natural_earth_50m.sqlite database using the
    SQLite version of SQL. This dialect also allows you to limit the number of returned
    features, so you could limit the result set to the three countries with the highest
    populations:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在查询具有自己的 SQL 支持的数据源，则将使用该原生 SQL 版本。例如，如果您有 SQLite 驱动程序，您可以使用 SQLite 版本的
    SQL 从 natural_earth_50m.sqlite 数据库中获取相同的信息。此方言还允许您限制返回的特征数量，因此您可以限制结果集为人口最多的三个国家：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This time you could print attributes for the entire layer, because only three
    features are returned. You should also notice that now you use the `area` function
    instead of a special field name, and if you don’t rename it with the `AS area`
    syntax, then it would be called `area(geometry)` instead. You also have to specifically
    request the geometry because the SpatiaLite engine doesn’t return the geometry
    by default.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这次你可以为整个图层打印属性，因为只返回了三个特征。你也应该注意，现在你使用的是`area`函数而不是特殊的字段名，如果你不使用`AS area`语法重命名它，那么它将被调用为`area(geometry)`。你还得特别请求几何形状，因为SpatiaLite引擎默认不返回几何形状。
- en: 'You can also use `ExecuteSQL` to join attributes from multiple layers. Take
    a look at this code and see if you can figure out what it’s doing:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`ExecuteSQL`将多个图层的属性连接起来。看看这段代码，看看你是否能弄清楚它在做什么：
- en: '![](101fig01_alt.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![101fig01_alt.jpg](101fig01_alt.jpg)'
- en: The first thing to notice is that you use the ne_50m_populated_places and ne_50m_admin_0_countries
    shapefiles and rename them to `pp` and `c,` respectively. You do this by putting
    the alias directly after the layer name. This isn’t necessary, of course, but
    does make your SQL a lot shorter because those layer names are pretty long. You
    also link these two layers together by using a join, which allows you to link
    tables using a shared attribute. Here you use a LEFT JOIN to keep all records
    in the table on the left (populated places), and if a matching record exists in
    the table on the right (countries), then you’ll also get data from that record.
    But how does it figure out what matches? That’s where the `ON` clause comes in.
    For each feature in `pp`, it takes the `adm0_a3` attribute value and tries to
    find a feature in the countries layer that has the same value for its `adm0_a3`
    field. See [figure 5.10](#ch05fig10) for an illustration.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要注意的是你使用了ne_50m_populated_places和ne_50m_admin_0_countries形状文件，并将它们分别重命名为`pp`和`c`。你是通过在图层名称后直接放置别名来做到这一点的。当然，这不是必需的，但这确实使你的SQL语句变得更短，因为那些图层名称相当长。你还通过使用连接将这两个图层链接在一起，这允许你使用共享属性来链接表。在这里，你使用LEFT
    JOIN来保留左表（人口地点）中的所有记录，并且如果右表（国家）中存在匹配的记录，那么你也会从该记录中获取数据。但是它是如何确定匹配的呢？这就是`ON`子句发挥作用的地方。对于`pp`中的每个要素，它都会取`adm0_a3`属性值，并尝试在具有相同`adm0_a3`字段值的countries图层中找到一个要素。参见[图5.10](#ch05fig10)以了解插图。
- en: Figure 5.10\. An illustration of a SQL query that selects records from the populated
    places table where adm0cap equals 1, and then gets related data from the countries
    table based on the adm0_a3 field in both tables.
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.10。一个SQL查询的插图，该查询从人口地点表中选择 adm0cap 等于1的记录，然后根据两个表中的 adm0_a3 字段获取相关数据。
- en: '![](05fig10_alt.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![05fig10_alt.jpg](05fig10_alt.jpg)'
- en: Now that you know what tables the data are coming from, go back to the beginning
    of the SQL statement and look at what attribute fields are being requested. You
    ask for the `NAME` and `POP_MIN` fields from the populated places layer, as well
    as the `NAME` and `POP_EST` fields from the countries layer. Because the fields
    from the two layers have the same names, it makes sense to rename them so that
    you can tell what’s what. Last, you use a `WHERE` clause to limit the results
    to features that represent capital cities (adm0cap = 1).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了数据来自哪些表，回到SQL语句的开始部分，看看正在请求哪些属性字段。你从人口地点图层请求了`NAME`和`POP_MIN`字段，以及从国家图层请求了`NAME`和`POP_EST`字段。因为两个图层中的字段具有相同的名称，所以重命名它们是有意义的，这样你就可以知道是什么。最后，你使用`WHERE`子句将结果限制在代表首都的要素（adm0cap
    = 1）上。
- en: 'This technique is handy if you want to see related data from multiple layers
    at the same time. Without this, you could query city populations and country populations
    separately, but now you can see the country’s population right beside the city’s.
    To see this, look at the layer returned by this query:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要同时查看多个图层的相关数据，这个技术就很有用。如果没有这个，你可能需要分别查询城市人口和国家人口，但现在你可以在城市旁边看到国家的人口。要查看这一点，请查看此查询返回的图层：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'I didn’t print the geometry column because it wouldn’t fit comfortably on the
    page, but because this uses the OGR SQL dialect, the geometry is returned automatically.
    But which one: the city or the country? It’s the city, because that’s the main
    table being used in the join, and corresponding country information is returned
    only if it existed for a city. You could plot the layer to prove it to yourself
    if you’d like.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有打印几何列，因为它不会舒适地适应页面，但因为这个使用了OGR SQL方言，几何体会被自动返回。但哪个：城市还是国家？是城市，因为这是连接中使用的主要表，并且只有当城市存在相应的国家信息时才会返回国家信息。如果你愿意，你可以绘制图层来证明这一点。
- en: 'Now check out a similar example using the SQLite dialect, but still shapefile
    data sources (you could use a SQLite database, of course, but I want to prove
    that the SQLite dialect will work with other data source types). See if you can
    spot the differences:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看一个使用SQLite方言的类似示例，但仍然是shapefile数据源（当然，你也可以使用SQLite数据库，但我想要证明SQLite方言可以与其他数据源类型一起工作）。看看你是否能发现差异：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The most obvious difference is the inclusion of the `dialect` parameter to the
    `ExecuteSQL` function. But you also add one thing to the SQL that doesn’t work
    with the OGR dialect. This time the results are limited to cities in South America
    by checking the value of the continent field in the countries layer. The OGR dialect
    doesn’t support using fields from the joined table in the `WHERE` clause, so the
    only attributes allowed would be ones from the populated places layer. Also, because
    you need to specifically request geometries if you want them when using the SQLite
    dialect, no geometries are returned by this particular query. You could add them
    in by specifying `pp.geometry` along with the other fields.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的区别是`ExecuteSQL`函数中包含了`dialect`参数。但你还在SQL中添加了一项与OGR方言不兼容的内容。这次结果被限制在南美洲的城市，通过检查国家层中的大陆字段值。OGR方言不支持在`WHERE`子句中使用连接表中的字段，因此允许的属性只能是来自人口地点层的属性。另外，因为在使用SQLite方言时，如果你想返回几何体，需要特别请求，所以这个特定的查询没有返回任何几何体。你可以通过指定`pp.geometry`以及其他字段来添加它们。
- en: 'If your version of OGR was built with SpatiaLite support (not only SQLite),
    you can also manipulate geometries within your SQL. Be warned that this could
    take a while, depending on what you try to do. As an example, if you have SpatiaLite
    support, try merging all of the counties in California into one big geometry.
    Start with drawing the individual counties so you have something to compare your
    results with:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的OGR版本是带有SpatiaLite支持（不仅仅是SQLite）构建的，你还可以在SQL中操作几何体。警告：这可能会花费一些时间，具体取决于你尝试做什么。作为一个例子，如果你有SpatiaLite支持，尝试将加利福尼亚州的所有县合并成一个大的几何体。从绘制单个县开始，这样你就可以比较你的结果了：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will draw a map of the counties in California, as shown in [figure 5.11](#ch05fig11)A.
    Now try using the SpatiaLite `st_union` function to merge all of the county polygons
    into one, as shown in [figure 5.11](#ch05fig11)B:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这将绘制出加利福尼亚州的县地图，如图[图5.11](#ch05fig11)A所示。现在尝试使用SpatiaLite的`st_union`函数将所有县的多边形合并成一个，如图[图5.11](#ch05fig11)B所示：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Figure 5.11\. Part A, on the left, shows the counties in California drawn individually.
    Part B, on the other hand, shows the result of running the SpatiaLite `st_union`
    function on the counties. They’re all joined together into one geometry.
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.11。部分A（左侧）显示了加利福尼亚州各个县的单独绘制。另一方面，部分B显示了在县上运行SpatiaLite `st_union`函数的结果。它们都被合并成了一个几何体。
- en: '![](05fig11_alt.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig11_alt.jpg)'
- en: 'Geometry operations also work with data sources that have their own native
    SQL flavor and the ability to perform geometry manipulations. SpatiaLite and PostGIS
    are two obvious examples of this. For example, this is how you’d do the same thing
    with a PostGIS data source:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 几何操作也适用于具有自己原生SQL风格和执行几何操作能力的数据源。SpatiaLite和PostGIS是这一点的两个明显例子。例如，这是使用PostGIS数据源完成相同操作的方法：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Don’t worry if you want to perform operations like this but aren’t using PostGIS
    or SpatiaLite, because you’ll learn how to do it without databases in the next
    chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要执行此类操作但不是使用PostGIS或SpatiaLite，不要担心，因为下一章你将学习如何在没有数据库的情况下完成它。
- en: 5.4\. Taking advantage of filters
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4. 利用过滤器
- en: 'Remember back in [chapter 3](kindle_split_011.html#ch03) when you copied all
    of the capital cities in a global shapefile into a new shapefile? You looped through
    each feature in the shapefile, checked the appropriate attribute, and copied the
    feature if it was a capital city. This whole process can be made much easier if
    the features you want can be selected with filters. Do you remember the `CopyLayer`
    method that was introduced in [section 4.2.4](kindle_split_012.html#ch04lev2sec6)?
    As a reminder, it copies an existing layer into a new data source. How do you
    think you could use this to do something similar to the code back in [listing
    3.3](kindle_split_011.html#ch03ex03), but much easier? Think about this problem
    for a minute and then look at the next example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在[第3章](kindle_split_011.html#ch03)中，你将全球形状文件中的所有首都复制到一个新的形状文件中吗？你遍历形状文件中的每个要素，检查相应的属性，如果它是首都就复制该要素。如果想要选择的要素可以通过过滤器进行选择，整个过程可以变得容易得多。你还记得在[第4.2.4节](kindle_split_012.html#ch04lev2sec6)中引入的
    `CopyLayer` 方法吗？作为提醒，它会将现有层复制到新的数据源中。你认为如何使用这个方法来执行类似于[列表3.3](kindle_split_011.html#ch03ex03)中的代码，但更简单？思考一下这个问题，然后看看下一个例子：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here the call to `CopyLayer` makes a copy of `in_lyr` in the `ds` data source.
    In this case, it happens to be the same data source as the original layer, but
    it could be any data source. Because you’ve already set an attribute filter on
    `in_lyr`, only the filtered features are copied. That’s certainly easier than
    checking each one.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`CopyLayer` 的调用在 `ds` 数据源中复制了 `in_lyr`。在这种情况下，它恰好与原始层相同的数据源，但它可以是任何数据源。因为你已经在
    `in_lyr` 上设置了属性过滤器，所以只有过滤后的要素被复制。这当然比逐个检查要简单得多。
- en: 'If you only want certain attributes, you could use a layer created using `ExecuteSQL`.
    Write a SQL query that pulls out the attributes you want and copy the results
    to a new layer:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想获取某些属性，可以使用通过 `ExecuteSQL` 创建的层。编写一个 SQL 查询以提取你想要的属性，并将结果复制到一个新的层中：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It should be obvious by now that you can simplify your life by taking advantage
    of filters and the `ExecuteSQL` function whenever possible.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该很明显，你可以通过尽可能利用过滤器和 `ExecuteSQL` 函数来简化你的生活。
- en: 5.5\. Summary
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5. 概述
- en: Attribute filters can be used to efficiently select specific features based
    on their attribute values.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性过滤器可以用来根据属性值高效地选择特定的要素。
- en: Spatial filters allow you to select features based on their location by using
    a bounding polygon or coordinates for a bounding box. The coordinates to set a
    spatial filter must use the same spatial reference system as the data to be filtered.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间过滤器允许你通过使用边界多边形或边界框的坐标来根据要素的位置选择要素。设置空间过滤器时必须使用与要过滤的数据相同的空间参考系统。
- en: Spatial and attribute filters can be combined.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间和属性过滤器可以组合使用。
- en: You can use SQL queries to create temporary layers made up of multiple layers
    joined on attribute values.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 SQL 查询创建由多个层通过属性值连接而成的临时层。
- en: You can’t use objects once their owners go out of scope, so if you want to use
    a geometry after you’ve lost the handle to its feature, make sure you clone the
    geometry. Always keep your data source open if you want access to the layers.
    If you break one of these rules, Python will crash and burn.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦对象的所有者超出作用域，就不能再使用对象，所以如果你在失去要素句柄后还想使用几何体，确保你克隆了该几何体。如果你想访问层，始终保持数据源打开。如果你违反了这些规则之一，Python
    将崩溃并燃烧。
