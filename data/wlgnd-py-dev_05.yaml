- en: 4 The object of conversation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 对话的对象
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Object-oriented APIs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象的API
- en: Objects with classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有类别的对象
- en: Inheritance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Polymorphism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Composition
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: When having a conversation, particularly one with any complexity, it’s helpful
    if everyone in the conversation has the same context. It would be difficult to
    have conversations if every time someone began a new sentence they had to present
    the full context of the conversation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行对话时，尤其是复杂对话，如果对话中的每个人都拥有相同的上下文，那就很有帮助。如果每次有人开始新句子时都必须呈现整个对话的上下文，那么进行对话将会很困难。
- en: From the standpoint of software functions, the context is the current state
    of the information the functions are working with. In the previous chapter, we
    talked about creating function signatures where the data state is passed around
    to the function calls in consistent ways.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从软件函数的角度来看，上下文是函数正在处理的信息的当前状态。在前一章中，我们讨论了创建函数签名，其中数据状态以一致的方式传递给函数调用。
- en: Utilizing function signatures is a useful and powerful way to conduct conversations
    between functions that work on stateful data. It becomes a little more complicated
    if the same functions are being passed multiple, distinct stateful data contexts.
    The data and the functions that work on that data are separate from each other,
    and it’s up to the developer to keep them organized and connected. Python provides
    another layer of abstraction to reduce complexity by using the object-oriented
    programming model.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 利用函数签名是进行在处理状态数据的功能函数之间进行交流的有用且强大的方式。如果相同的函数被传递多个不同的状态数据上下文，这会变得稍微复杂一些。数据和操作这些数据的功能是分开的，开发者需要负责保持它们的组织和连接。Python通过使用面向对象编程模型提供另一层抽象，以减少复杂性。
- en: 4.1 Object-oriented programming (OOP)
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 面向对象编程（OOP）
- en: The ability to place functions into modules provides many opportunities for
    structuring an API. The type and order of the parameters passed to the functions
    that make up an API offer possibilities to make your API more discoverable and
    useful.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数放入模块的能力为API的结构化提供了许多机会。传递给组成API的函数的参数的类型和顺序为使你的API更具可发现性和实用性提供了可能性。
- en: Using the concepts of single responsibility and keeping functions to manageable
    lengths makes it more likely your API will consist of multiple functions. Users
    of the API’s functionality—which may itself call other API functions, further
    modifying the data or state—produce the result returned to the user.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单一责任和保持函数长度可管理的概念，使你的API更有可能由多个函数组成。API功能的使用者——这些使用者可能本身会调用其他API函数，进一步修改数据或状态——产生返回给用户的最终结果。
- en: Often, the data structures passed between functions are collection objects,
    lists, sets, and dictionaries. These objects are powerful, and taking advantage
    of what they offer is important in Python development. By themselves, data structures
    don’t do anything, but the functions they are passed to know what to do with the
    data structures they receive as input.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在函数之间传递的数据结构是集合对象，如列表、集合和字典。这些对象功能强大，在Python开发中利用它们提供的是很重要的。单独来看，数据结构并不做任何事情，但传递给它们的函数知道如何处理它们接收到的数据结构作为输入。
- en: Because everything in Python is an object, you can create interesting objects
    using OOP. One of the goals of creating objects is to encapsulate data and the
    methods that act on that data into one entity. Conceptually, you’re making something
    with the functionality you designed and implemented. You can think about what
    you create as an object, or thing, that has behavior. Creating classes is how
    you design these objects, connecting data and functionality to them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python中的一切都是对象，你可以使用面向对象编程创建有趣的对象。创建对象的一个目标是将数据和作用于这些数据的方法封装到一个实体中。从概念上讲，你正在使用你设计和实现的功能制作某物。你可以将你创建的内容视为具有行为的对象或事物。创建类是设计这些对象的方式，将数据和功能连接到它们。
- en: 4.1.1 Class definition
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 类定义
- en: Python provides OOP by defining classes that can be instantiated into actual
    objects when needed. Instantiation is the act of taking something from a definition
    (the class) to reality. You could say the blueprint for a house is the class definition,
    and building the house instantiates it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过定义可以在需要时实例化为实际对象的类来提供面向对象编程。实例化是将定义（类）从概念变为现实的行为。你可以把房子的蓝图看作是类定义，而建造房子则是实例化它。
- en: 'Here’s a simple class definition for a `Person` class from the `examples/CH_04/example_01`
    application code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个来自`examples/CH_04/example_01`应用程序代码的`Person`类的简单类定义：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This class definition creates a `Person` template containing a person’s first,
    middle, and last names. It also provides the `full_name()` method to obtain the
    person’s full name based on the information passed to the object by its initialing
    `__init__()` method. A function associated with a class is often referred to as
    a *method*. This is a convention to make a distinction between a module function
    and one that’s part of a class. Creating and using an object instantiated from
    the `Person` class looks like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类定义创建了一个包含一个人的姓、名和姓的`Person`模板。它还提供了一个`full_name()`方法，根据通过其初始化`__init__()`方法传递给对象的信息来获取人的全名。与类相关联的函数通常被称为*方法*。这是一个约定，用于区分模块函数和类的一部分。创建和使用从`Person`类实例化的对象看起来是这样的：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `self` parameter that is passed as the first parameter of every method of
    the `Person` class is the reference to the `Person` instance just created. In
    this way, your code can create as many `Person` instances as needed, and each
    will be distinct because the `self` value of each will reference a particular
    instance and the state attributes (data) it contains.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`Person`类每个方法的第一参数传递的`self`参数是刚刚创建的`Person`实例的引用。这样，你的代码可以创建所需数量的`Person`实例，并且每个实例都是独特的，因为每个`self`值将引用特定的实例及其包含的状态属性（数据）。
- en: This class can be represented visually in UML (Unified Modeling Language) as
    well, as shown by figure 4.1\. UML is a way to present the design of systems visually.
    It’s
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类也可以用UML（统一建模语言）来可视化表示，如图4.1所示。UML是一种以视觉方式展示系统设计的方法。它是
- en: not necessary to use UML diagrams when designing and building a system, but
    it can be useful to introduce abstract concepts that are difficult to present
    concisely with text documentation alone.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和构建系统时，不一定需要使用UML图，但它可以有助于介绍那些仅用文本文档难以简洁表达的概念。
- en: '![](../../OEBPS/Images/CH04_F01_Farrell.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F01_Farrell.png)'
- en: Figure 4.1 UML diagram of the `Person` class
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 `Person`类的UML图
- en: The UML diagram for the `Person` class shows the name of the class, the attributes
    it contains, and the methods it provides. The plus-sign character (`+)` in front
    of the attribute and method names indicates they are public. In Python, attributes
    and methods of a class are always public and have no notion of protected or private
    access.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类的UML图显示了类的名称、它包含的属性以及它提供的方法。属性和方法名称前的加号字符（`+`）表示它们是公共的。在Python中，类的属性和方法始终是公共的，没有受保护或私有访问的概念。'
- en: 'Python’s class design relies on the idea “We’re all adults here,” and the developers
    who use your classes will behave accordingly. Using plain attributes should be
    the default when designing your classes. You’ll see later how class properties
    can gain control of how attributes are accessed and used. A simple use case for
    the `Person` class is presented in the `examples/CH_04/example_01` application:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python的类设计依赖于“我们都是成年人”的想法，使用你的类进行开发的开发者将相应地行事。在设计类时，使用普通属性应该是默认的。你将在后面看到类属性如何获得控制属性访问和使用的方式。`Person`类的一个简单用例在`examples/CH_04/example_01`应用程序中给出：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code creates four instances of the `Person` class, each representing a
    different person and exercising all the variations of the constructor. The `for`
    loop iterates through the list of `Person` object instances and calls the `full_name()`
    method of each. Notice the `full_name()` method is not passed any state data;
    it uses the data attributes associated with the class instance. The `self` parameter
    of the `full_name()` method definition is what gives the method access to the
    individual attributes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了四个`Person`类的实例，每个实例代表不同的人，并使用了构造函数的所有变体。`for`循环遍历`Person`对象实例的列表，并调用每个实例的`full_name()`方法。注意，`full_name()`方法没有传递任何状态数据；它使用与类实例相关联的数据属性。`full_name()`方法定义中的`self`参数是使方法能够访问个体属性的原因。
- en: 4.1.2 Drawing with class
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 使用类绘图
- en: The remaining examples you’re going to build are object-oriented applications
    that animate some shapes on the screen.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要构建的剩余示例都是面向对象的应用程序，它们在屏幕上动画化一些形状。
- en: Tip Readers who have experience with OOP will probably recognize the analogy—a
    generic shape from which specific shapes, like rectangles and squares, are inherited.
    This analogy has been used to present object-oriented techniques for a long time
    and has become somewhat contrived. I acknowledge that, but I am using it anyway
    because it has advantages.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：有面向对象编程经验的读者可能会认识到这个类比——一个通用形状，从这个形状中可以继承出特定形状，如矩形和正方形。这个类比已经用于展示面向对象技术很长时间了，并且已经变得有些牵强。我承认这一点，但仍然在使用它，因为它有优势。
- en: The concept of shapes is familiar enough outside of programming that readers
    can relate to them and to the idea that new shapes can be derived from them. Additionally,
    a program that moves shapes around on a computer screen is also familiar to most
    readers. The idea of moving shapes having speed and direction and staying within
    the boundaries of an onscreen window are well-known behaviors for computer-rendered
    graphics.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 形状的概念在编程之外已经足够熟悉，读者可以与之以及从它们派生出新形状的想法联系起来。此外，在计算机屏幕上移动形状的程序对大多数读者来说也很熟悉。移动形状具有速度和方向，并保持在屏幕窗口边界内的想法是计算机渲染图形的众所周知的行为。
- en: 'Because of this familiarity with shapes, the cognitive demand of learning about
    the object-oriented program can be focused on just that, not on any abstract quality
    of the object itself. For this reason, I’m asking you to bear with the contrived
    nature of the examples to see the larger picture. Each of the examples that follow
    expands upon the previous one to present the following concepts:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对形状的熟悉，学习面向对象程序的认知需求可以集中在这一点上，而不是对象的任何抽象属性上。因此，我要求你忍受示例的虚构性质，以看到更大的图景。以下每个示例都是在前一个示例的基础上扩展的，以展示以下概念：
- en: '*Inheritance*—Parent/child relationships between classes'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*继承*—类之间的父/子关系'
- en: '*Polymorphism*—Using an object as if it had multiple forms'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多态*—将对象用作具有多种形式'
- en: '*Composition*—Giving attributes and behavior to a class through means other
    than inheritance'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组合*—通过除继承之外的方式给类赋予属性和行为'
- en: To create the drawing application, you’ll be using the arcade module available
    in the Python Package Index ([https://pypi.org/project/arcade/](https://pypi.org/project/arcade/)).
    This module provides the framework to build a drawing surface on the computer
    screen and draw and animate objects on that drawing surface.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建绘图应用程序，你将使用Python包索引中可用的arcade模块([https://pypi.org/project/arcade/](https://pypi.org/project/arcade/))。此模块提供了在计算机屏幕上构建绘图表面并在此绘图表面上绘制和动画对象的框架。
- en: The first thing to do is to define a class for a rectangle to draw on the screen.
    The UML diagram in figure 4.2 shows the attributes encapsulated in the class necessary
    to render a rectangle onscreen; `x`, `y`, `width`, and `height` define the position
    of the rectangle on the screen and the dimensions to use when drawing it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首件事是定义一个用于在屏幕上绘制的矩形的类。图4.2中的UML图显示了类中封装的属性，这些属性是绘制屏幕上的矩形所必需的；`x`、`y`、`width`和`height`定义了矩形在屏幕上的位置以及绘制时使用的尺寸。
- en: '![](../../OEBPS/Images/CH04_F02_Farrell.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F02_Farrell.png)'
- en: Figure 4.2 UML diagram for the `Rectangle` class
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 `Rectangle`类的UML图
- en: 'All of these attributes are initialized during the instantiation of a `Rectangle`
    object:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些属性都是在`Rectangle`对象实例化期间初始化的：
- en: '`pen_color,` `fill_color`—Defines the colors used to outline the rectangle
    and fill it'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pen_color,` `fill_color`—定义了用于勾勒矩形和填充它的颜色'
- en: '`dir_x,` `dir_y`—Defines the direction of movement relative to the screen’s
    x and y axes; these are either 1 or –1'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir_x,` `dir_y`—定义了相对于屏幕x和y轴的运动方向；这些值可以是1或-1'
- en: '`speed_x,` `speed_y`—Defines the speed at which the rectangle is moving in
    pixels per update'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`speed_x,` `speed_y`—定义了矩形在每次更新中移动的速度（以像素为单位）'
- en: 'Figure 4.2 also includes the definition of three methods that the class supports:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2还包括了类支持的三种方法的定义：
- en: '`set_pen_color()`—Provides a mechanism to set the pen color used to draw the
    `Rectangle` instance object'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_pen_color()`—提供了一种机制来设置用于绘制`Rectangle`实例对象的笔颜色'
- en: '`set_fill_color()`—Provides a mechanism to set the fill color used to fill
    a `Rectangle` instance object'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_fill_color()`—提供了一种机制来设置用于填充`Rectangle`实例对象的填充颜色'
- en: '`draw()`—Draws a `Rectangle` object instance on the screen'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw()`—在屏幕上绘制`Rectangle`对象实例'
- en: 'This UML diagram is converted to a Python class definition in code. Here’s
    the `Rectangle` class based on the previous diagram from the `examples/CH_04/example_02`
    application:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此 UML 图被转换为代码中的 Python 类定义。以下是基于之前 `examples/CH_04/example_02` 应用程序中图示的 `Rectangle`
    类：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This class defines a simple `Rectangle` object. The object is initialized with
    the x and y coordinates, width and height, pen and fill colors, direction, and
    speed of motion of the rectangle. In the arcade module, the screen origin is in
    the lower-left corner, which is how most of us think about the x and y axes on
    paper, but it’s different from many other screen-rendering tools.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此类定义了一个简单的 `Rectangle` 对象。对象通过 x 和 y 坐标、宽度、高度、笔和填充颜色、方向以及矩形运动的速度初始化。在 `arcade`
    模块中，屏幕原点位于左下角，这是我们大多数人认为的纸张上的 x 和 y 轴，但它与许多其他屏幕渲染工具不同。
- en: Tip The 0, 0 origin location in the upper-left-hand corner of a drawing screen
    is there for historical reasons that involve how computer graphics were generated
    back in the day.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：绘图屏幕左上角的 0, 0 原点位置是出于历史原因，这与当时计算机图形是如何生成的有关。
- en: 'Modifying the values of the `x` and `y` attributes moves the `Rectangle` around
    the screen, as maintained by the arcade module and the instance of the `Window`
    class in the application. The `Window` class has two methods used to animate the
    objects on the screen: `on_update()` and `on_draw``()`. The first updates the
    position of all the objects to render on the screen, and the second draws those
    updated objects on the screen. The `on_update()` method is called for every refresh
    iteration and is where the application modifies the position of the rectangles
    in the `self.rectangles` collection. The `on_update()` method looks like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `x` 和 `y` 属性的值会移动屏幕上的 `Rectangle`，这是由 `arcade` 模块和应用程序中 `Window` 类的实例维护的。`Window`
    类有两个用于在屏幕上动画对象的方法：`on_update()` 和 `on_draw()`。第一个更新所有要在屏幕上渲染的对象的位置，第二个在屏幕上绘制这些更新后的对象。`on_update()`
    方法在每次刷新迭代时被调用，并且是应用程序修改 `self.rectangles` 集合中矩形位置的地方。`on_update()` 方法看起来如下所示：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code iterates through the collection of rectangles and updates the position
    of each one by its `x` and `y` speed values, changing its position on the screen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码遍历矩形集合，通过其 `x` 和 `y` 速度值更新每个矩形的位罝，改变其在屏幕上的位置。
- en: 'The updated rectangles are drawn on the screen by the Window instance method
    `on_draw``()`, which looks like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的矩形是通过窗口实例方法 `on_draw()` 绘制到屏幕上的，其看起来如下所示：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Every time the `on_draw()` method is called, the screen clears and the `self
    .rectangles` collection is iterated through, and each rectangle has its `draw()`
    method called.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `on_draw()` 方法时，屏幕会清除，并遍历 `self.rectangles` 集合，调用每个矩形的 `draw()` 方法。
- en: The `Rectangle` class has behavior defined by the methods `set_pen_color()`,
    `set_fill_color()`, and `draw()`. These methods use and alter the state data encapsulated
    by the class definition. They provide the API you interact with when using the
    class. Using the methods abstracts away having to modify the state data directly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle` 类通过 `set_pen_color()`、`set_fill_color()` 和 `draw()` 方法定义了行为。这些方法使用并修改由类定义封装的状态数据。它们提供了当你使用类时与之交互的
    API。使用这些方法可以抽象出直接修改状态数据的需要。'
- en: 'Look at the `set_pen_color()` and `set_fill_color()` methods and you’ll see
    they return `self`. Returning `self` can be useful for chaining methods of the
    class together into a series of operations. Here’s an example from `examples/CH_04/example_02.py`
    using the `Rectangle` class. This code changes the pen and fill colors when the
    arcade schedule functionality code is called every second:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 观察 `set_pen_color()` 和 `set_fill_color()` 方法，你会发现它们返回 `self`。返回 `self` 可以在类的方法链中串联一系列操作，非常有用。以下是从
    `examples/CH_04/example_02.py` 中使用 `Rectangle` 类的一个示例。此代码在每秒调用 `arcade` 调度功能代码时更改笔和填充颜色：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`The change_colors() method of the Window instance is called by an arcade schedule
    function every second. It iterates through the collection of rectangles and calls
    the set_pen_color() and set_fill_color() in a chained manner to set random colors
    picked from the globally defined COLOR_PALETTE list.`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Window` 实例的 `change_colors()` 方法每秒由 `arcade` 调度函数调用。它遍历矩形集合，并以链式方式调用 `set_pen_color()`
    和 `set_fill_color()`，以设置从全局定义的 `COLOR_PALETTE` 列表中随机选择的颜色。'
- en: When the `examples/CH_04/example_02` application runs, it creates a window on
    the screen as shown in figure 4.3\. The application animates a vertically aligned
    rectangle up and right at a 45-degree angle. It also changes the pen and fill
    colors of the rectangle every second the application runs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `examples/CH_04/example_02` 应用程序运行时，它会在屏幕上创建一个窗口，如图4.3所示。应用程序以45度角垂直向上和向右动画一个矩形。它还会在应用程序运行每秒钟更改矩形的笔和填充颜色。
- en: '![](../../OEBPS/Images/CH04_F03_Farrell.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F03_Farrell.png)'
- en: Figure 4.3 Screenshot of the rectangle on the Window drawing surface
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 窗口绘制表面的矩形截图
- en: Properties
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 属性
- en: As mentioned earlier, direct access to the attributes of a class should often
    be the default. The `Rectangle` example follows this practice. However, there
    are situations where you’ll want more control over how the attributes of a class
    are used or changed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，直接访问类的属性通常应该是默认的。`Rectangle` 示例遵循了这一做法。然而，有些情况下，你可能希望对类属性的用法或更改有更多的控制。
- en: The definition of the `Rectangle` class includes attributes for the x and y
    origin of the rectangle, which helps draw it in the window. That window has dimensions,
    and if you run the `examples/CH_04/example_02` application long enough, you’ll
    see the rectangle move off the screen.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle` 类的定义包括矩形的x和y原点属性，这有助于在窗口中绘制它。那个窗口有尺寸，如果你运行 `examples/CH_04/example_02`
    应用程序足够长的时间，你会看到矩形移出屏幕。'
- en: Currently, the origin of a `Rectangle` instance is set to any integer value.
    No known screen has a resolution as large as the range of integer values, and
    none at all deal with negative numbers directly. The window declared in the application
    has a width range from 0 to 600 pixels and a height range from 0 to 800 pixels.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`Rectangle` 实例的来源被设置为任何整数值。已知没有任何屏幕的分辨率能达到整数值的范围，而且没有任何屏幕直接处理负数。应用程序中声明的窗口宽度范围从0到600像素，高度范围从0到800像素。
- en: The boundaries of where `Rectangle` objects can be drawn should be constrained
    to within those window dimensions. Constraining the values of `x` and `y` means
    having code in place to limit the values that can be assigned to them. Your goal
    is to make the rectangle bounce around within the screen window.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle` 对象可以绘制的边界应该限制在窗口尺寸内。限制 `x` 和 `y` 的值意味着要有代码来限制可以分配给它们的值。你的目标是让矩形在屏幕窗口内弹跳。'
- en: If you’re accustomed to other languages supporting OOP, you might be familiar
    with getters and setters. These are methods provided by the developer to control
    access to attributes of a class instance. These methods also give the developer
    a place to insert behavior when the attributes are retrieved or modified. The
    behavior you want to insert when setting or getting the `x` and `y` values is
    to limit the range of values to which those attributes can be set.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了支持OOP的其他语言，你可能熟悉getter和setter。这些是由开发者提供的方法，用于控制对类实例属性的访问。这些方法还允许开发者在属性检索或修改时插入行为。当你设置或获取
    `x` 和 `y` 值时，你想要插入的行为是限制可以设置给这些属性的值范围。
- en: 'Adding getter and setter methods to the rectangle’s `x` and `y` attributes
    could be done by defining methods like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过定义如下方法将getter和setter方法添加到矩形的 `x` 和 `y` 属性中：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using these getter and setter functions also means changing the example code
    from
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些getter和setter函数也意味着更改示例代码从
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`to this:`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`to this:`'
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In my opinion, using getters and setters works but sacrifices readability when
    compared to the direct attribute access version/syntax. By using Python property
    decorators, you can control how class attributes are accessed and modified while
    still using the direct attribute access syntax. The `Rectangle` class can be modified
    to use property decorators offering this behavior. The updated portion of the
    `Rectangle` class from example program `examples/CH_04/example_03` is shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，使用getter和setter是可行的，但与直接属性访问版本/语法相比，牺牲了可读性。通过使用Python属性装饰器，你可以在使用直接属性访问语法的同时控制类属性的访问和修改。`Rectangle`
    类可以被修改为使用提供此行为的属性装饰器。这里展示了从示例程序 `examples/CH_04/example_03` 中更新的 `Rectangle` 类的部分内容：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first element to notice is that the attributes `x` and `y` are prefixed
    with a single underscore (`_`) character. Using the underscore this way is a convention
    to indicate the attribute should be considered private and not accessed directly.
    It doesn’t enforce any notion of a private attribute, however.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个需要注意的元素是属性`x`和`y`前面有一个单下划线（`_`）前缀。使用下划线的方式是一种约定，表示属性应该被视为私有，并且不应直接访问。然而，这并不强制执行任何私有属性的概念。
- en: 'The second element to notice is the new decorated methods in the class. For
    example, the two new methods for accessing the `self._x` attribute are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个需要注意的元素是类中的新装饰方法。例如，访问`self._x`属性的两个新方法如下：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `@property` decorator over the first `def` `x(self)` function defines the
    getter functionality—in this case, just returning the value of `self._x`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`def x(self)`函数上使用`@property`装饰器定义了getter功能——在这种情况下，只是返回`self._x`的值。
- en: 'The `@x.setter` decorator over the second `def` `x(self,` `value)` function
    defines the setter functionality. Inside the function, `self._x` is constrained
    to within the screen x-axis minimum and maximum dimensions. If setting the value
    of `self._x` would place any part of the rectangle outside the screen area, the
    direction of travel is negated to start it moving in the opposite direction. Having
    these decorated methods in the `Rectangle` class means code like this works again:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个`def x(self, value)`函数上使用`@x.setter`装饰器定义了setter功能。在函数内部，`self._x`被限制在屏幕x轴的最小和最大维度内。如果设置`self._x`的值将矩形的任何部分放置在屏幕区域之外，移动方向将被否定，以开始向相反方向移动。在`Rectangle`类中有这些装饰方法意味着像这样的代码又可以工作了：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The program statement appears to be setting the `Rectangle` instance x attribute
    directly, but the decorated methods are called instead. The `+=` operation calls
    the getter method to retrieve the current value of `self._x`, adds 1 to that value,
    and uses the setter method to set `self._x` to that new value. If the resulting
    change places the rectangle outside of the screen dimensions, the direction of
    travel along the x-axis is reversed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 程序语句看起来是直接设置`Rectangle`实例的x属性，但实际调用的是装饰方法。`+=`操作调用getter方法来检索`self._x`的当前值，将1加到这个值上，并使用setter方法将`self._x`设置为这个新值。如果这种变化将矩形放置在屏幕尺寸之外，x轴上的移动方向将被反转。
- en: The beautiful part of this is you can define your classes using direct attribute
    access initially. If it becomes necessary to constrain or control access to an
    attribute, you can define getter and setter property methods. Existing code using
    your class doesn’t have to change at all. From the point of view of the caller,
    the API of the class is the same.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分的美妙之处在于你可以最初使用直接属性访问来定义你的类。如果需要约束或控制对属性的访问，你可以定义getter和setter属性方法。使用你的类的现有代码根本不需要更改。从调用者的角度来看，类的API是相同的。
- en: 'Take note of another feature of using setter and getter decorated methods:
    you don’t need to create both setter and getter decorated functions on attributes.
    You can create only a getter, which produces a read-only attribute. Likewise,
    you can create only a setter, which produces a write-only attribute. There is
    also an `@deleter` decorator to delete an attribute, but this feature is rarely
    used.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用setter和getter装饰方法的一个特性：你不需要在属性上创建setter和getter装饰函数。你可以只创建一个getter，它会产生一个只读属性。同样，你也可以只创建一个setter，它会产生一个只写属性。还有一个`@deleter`装饰器用于删除属性，但这个特性很少使用。
- en: Decorators
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器
- en: Before moving on, let’s talk about decorators. In Python, a decorator is a way
    to extend or modify the behavior of a function without changing the function itself.
    Decorating a function sounds confusing, but an example will help make the intent
    clear. As has been stated before, functions are objects in Python. This means
    functions can be passed to and returned from other functions as parameters like
    any other object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们谈谈装饰器。在Python中，装饰器是一种在不改变函数本身的情况下扩展或修改函数行为的方法。装饰函数听起来可能有些令人困惑，但一个例子将有助于阐明意图。如前所述，函数在Python中是对象。这意味着函数可以作为参数传递给其他函数，就像任何其他对象一样。
- en: 'The function defined here demonstrates the use of decorators:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义的函数演示了装饰器的使用：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the function is called, it uses the delay parameter to emulate some complex
    task that takes time to perform. It then returns the string `task` `done` when
    the function ends.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被调用时，它使用延迟参数来模拟一些需要时间才能完成的复杂任务。当函数结束时，它返回字符串`task done`。
- en: 'Suppose logging information about execution time is required, before and after
    this function is called, that includes the amount of time it takes to execute.
    This could be done by adding the logging information to the function itself, but
    that creates code maintenance issues, as every function to be timed would have
    to be updated if the timing code changes. You can instead create a decorator function
    to wrap `complex_task` with the desired new functionality. The decorator function
    looks like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设需要在函数调用前后记录执行时间的信息，包括执行所需的时间量。这可以通过将日志信息添加到函数本身来实现，但这会引发代码维护问题，因为如果计时代码发生变化，需要更新的函数将很多。你可以创建一个装饰器函数来包装
    `complex_task` 并添加所需的新功能。装饰器函数看起来像这样：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code looks odd because the `timing_decorator` function defines another
    function inside itself called `wrapper`. The `timing_decorator` outer function
    also returns the `wrapper` inner function. This is perfectly fine Python syntax
    because functions are objects; the `wrapper` function is created and returned
    when the outer `timing_decorator` function is executed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来有些奇怪，因为 `timing_decorator` 函数在其内部定义了另一个名为 `wrapper` 的函数。外部的 `timing_decorator`
    函数也返回了 `wrapper` 内部函数。这完全符合 Python 语法，因为函数是对象；当外部的 `timing_decorator` 函数执行时，`wrapper`
    函数被创建并返回。
- en: The `func` parameter of the `timing_decorator` is the function object being
    decorated. The `delay` parameter of the `wrapper` function is the parameter passed
    to the decorated function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`examples/CH_04/example_04` 程序演示了直接包装任务和使用装饰器语法，运行时产生以下输出：'
- en: 'The code inside the `wrapper` function will execute, including calling the
    decorated `func` object. The following example will help clarify what’s happening:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapper` 函数内部的代码将会执行，包括调用装饰的 `func` 对象。以下示例将有助于阐明正在发生的情况：'
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here the `complex_task` function object is passed to the `timing_decorator`
    function. Notice there are no parentheses on `complex_task`; the function object
    itself is being passed, not the results of calling the function. The new variable
    `new_complex_ task` is assigned the return value of `timing_decorator,` and because
    it returns the wrapper function, `new_complex_task` is a function object.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`complex_task` 函数对象被传递给 `timing_decorator` 函数。注意 `complex_task` 上没有括号；传递的是函数对象本身，而不是函数调用的结果。新变量
    `new_complex_task` 被分配了 `timing_decorator` 的返回值，因为它返回的是包装函数，所以 `new_complex_task`
    是一个函数对象。
- en: 'The print statement calls `new_complex_task,` passing it a delay value and
    printing the following information:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 打印语句调用 `new_complex_task`，并传递一个延迟值，打印以下信息：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This output shows the functionality added by `timing_decorator` and the original
    functionality of `complex_task` that is executed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示了 `timing_decorator` 添加的功能以及 `complex_task` 的原始功能，该功能被执行。
- en: 'The example is interesting but not that useful, as every invocation of `complex_
    task` would have to be passed as a parameter to `timing_decorator` to obtain the
    additional timing functionality. Python supports a syntactic shortcut that makes
    this easier by adding `@timing_decorator` right before the definition of the `complex_
    task` function. This addition has the effect of “decorating” `complex_task` and
    creating a callable instance of the now-wrapped function. The code is shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很有趣，但并不那么有用，因为每次调用 `complex_task` 都必须作为参数传递给 `timing_decorator` 以获得额外的计时功能。Python
    支持一种语法快捷方式，通过在 `complex_task` 函数定义之前添加 `@timing_decorator` 来简化这个过程。这个添加的效果是“装饰”
    `complex_task` 并创建一个现在已包装函数的可调用实例。代码如下所示：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `examples/CH_04/example_04` program demonstrates wrapping the task directly
    and using the decorator syntax, and when run, it produces this output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`timing_decorator` 的 `func` 参数是要装饰的函数对象。`wrapper` 函数的 `delay` 参数是传递给装饰函数的参数。'
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The output shows `complex_task` running, but it also indicates that `@timing_
    decorated` has wrapped `complex_task` with additional functionality that is also
    running and generating log messages about the elapsed time. The `complex_task`
    code hasn’t changed to provide this; the `wrapper` function inside `timing_decorator`
    does this work. The win here is that any function or method with the same signature
    as `complex_task` can be decorated with the `@timing_decorator` to generate timing
    information.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了 `complex_task` 的运行情况，但也表明 `@timing_decorator` 已将 `complex_task` 包装了额外的功能，这些功能也在运行并生成关于经过时间的日志消息。`complex_task`
    代码没有改变以提供这些功能；`timing_decorator` 内部的 `wrapper` 函数执行这项工作。这里的优势是，任何与 `complex_task`
    有相同签名的函数或方法都可以用 `@timing_decorator` 装饰以生成计时信息。
- en: 4.1.3 Inheritance
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 继承
- en: Being able to merge data and the behavior relevant to that data into classes
    gives you very expressive ways to structure your programs. When building classes,
    situations arise where functionality is common to more than one class. As a developer,
    it becomes part of our nature to follow the DRY (don’t repeat yourself) principle.
    You can follow this principle when creating objects in Python by using inheritance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将数据及其相关行为合并到类中，为你提供了非常灵活的方式来组织你的程序。在构建类时，会出现功能在多个类中是共通的情况。作为开发者，遵循DRY（不要重复自己）原则已经成为我们天性的一部分。在Python中创建对象时，你可以通过使用继承来遵循这一原则。
- en: Tip As a developer, it pays not to repeat yourself, as repetition opens the
    door to introducing mistakes or differences in the code. If the code you use repeatedly
    is right, then it’s right everywhere. If you repeat code, rewrite it; it can be
    right in some places and wrong elsewhere. This makes it hard to find and fix.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：作为开发者，避免重复是很有益的，因为重复会为引入错误或代码中的差异打开大门。如果你使用的重复代码是正确的，那么它在任何地方都是正确的。如果你重复代码，就重新编写它；它可能在某些地方是正确的，在其他地方是错误的。这使得查找和修复错误变得困难。
- en: Like actual parents and their children, attributes and behaviors are inherited
    from the parent but aren’t exact duplicates. When talking about OOP class design,
    the terms *parent* and *child* are used because the metaphor works well. The terms
    *base class* and *derived class* are also used to indicate the parent–child relationship.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 就像真正的父母和他们的孩子一样，属性和行为是从父类继承下来的，但并不是完全相同的副本。在谈论面向对象（OOP）类设计时，使用“父类”和“子类”这些术语是因为这个隐喻非常适用。同时，也使用“基类”和“派生类”来表示父类和子类之间的关系。
- en: You’ll also see words like *superclass* used to refer to the parent and *subclass*
    to refer to the child. These are terms applied to the relationship between objects
    when talking about inheritance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到像“超类”（*superclass*）这样的词用来指代父类，“子类”（*subclass*）用来指代子类。这些术语是在讨论继承时应用于对象之间关系时使用的。
- en: 'One of the reasons to use inheritance is to add attributes and behavior unique
    to the child, possibly modifying those inherited from the parent. It’s also useful
    to derive multiple children from a parent class, each with its own set of unique
    attributes and behaviors but still imbued with characteristics from the parent.
    Creating an inheritance relationship between two classes in Python is performed
    like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承的一个原因是为子类添加独特的属性和行为，可能修改从父类继承而来的那些。从父类派生多个子类也很有用，每个子类都有其独特的属性和行为，但仍然具有来自父类的特征。在Python中创建两个类之间的继承关系是这样进行的：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `ParentClass` definition creates a root-level class definition. The definition
    of the `ChildClass` includes the class inherited from inside the parentheses.
    In the example, it inherits from `ParentClass`. The `pass` statement in both class
    definitions is a nop (no operation) in Python and is necessary to make the class
    definitions syntactically correct but without functionality.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParentClass`的定义创建了一个根级别的类定义。`ChildClass`的定义包括括号内继承的类。在示例中，它从`ParentClass`继承。在两个类定义中的`pass`语句在Python中是一个无操作（nop），它是使类定义在语法上正确但无功能所必需的。'
- en: In the `examples/CH_04/example_02` code, a `Rectangle` class was created with
    a position on the screen, a pen color to draw with, and a color to fill the rectangle.
    What if you wanted to create other shapes, like squares and circles? Each shape
    would have a position and dimension on the screen and a pen and fill color.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`examples/CH_04/example_02`代码中，创建了一个具有屏幕位置、用于绘制的笔颜色以及填充矩形颜色的`Rectangle`类。如果你想要创建其他形状，比如正方形和圆形呢？每个形状在屏幕上都有一个位置和尺寸，以及笔和填充颜色。
- en: The direct approach would be to create complete, standalone `Square` and `Circle`
    class definitions and draw instances of each on the screen. Each class would have
    all of the attributes and methods of the `Rectangle` class but with a different
    `draw()` method to draw that unique shape. Creating separate classes for `Square`
    and `Circle` would work for the relatively small number of shapes involved but
    wouldn’t scale well if many more shapes were required.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 直接的方法是创建完整的、独立的`Square`和`Circle`类定义，并在屏幕上绘制每个类的实例。每个类都会拥有`Rectangle`类的所有属性和方法，但具有不同的`draw()`方法来绘制独特的形状。为`Square`和`Circle`创建单独的类对于涉及相对较少的形状来说是可行的，但如果需要更多的形状，则扩展性不好。
- en: This presents an opportunity to use inheritance to gather the attributes and
    their associated behavior into a parent class you could call `Shape`. This `Shape`
    parent class would be used to collect the common attributes and methods in one
    place. Any shape drawn onscreen would be a child of the `Shape` parent.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个使用继承将属性及其相关行为聚集到可以称为 `Shape` 的父类中的机会。这个 `Shape` 父类将用于在一个地方收集公共属性和方法。屏幕上绘制的任何形状都将成为
    `Shape` 父类的子类。
- en: You’ll start by reproducing the functionality of the `examples/CH_04/example_03`
    application by making use of inheritance. The examples that follow are from the
    `examples/CH_04/example_04` application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先通过利用继承来重现 `examples/CH_04/example_03` 应用程序的功能。接下来的示例来自 `examples/CH_04/example_04`
    应用程序。
- en: Figure 4.4 shows that the attributes and methods of the `Rectangle` class definition
    have moved to the `Shape` class, and the `Rectangle` now inherits from it. The
    `Shape` name in italics indicates it’s abstract and shouldn’t be instantiated
    directly. The `draw()` method is also in italic because it exists in the `Shape`
    definition but has no functionality of its own. The functionality must be provided
    by the child class—in this case, `Rectangle`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 显示了 `Rectangle` 类定义的属性和方法已移动到 `Shape` 类，并且 `Rectangle` 现在从它继承。斜体中的 `Shape`
    名称表示它是抽象的，不应直接实例化。`draw()` 方法也是斜体，因为它存在于 `Shape` 定义中，但没有自己的功能。功能必须由子类提供——在这个例子中，是
    `Rectangle`。
- en: 'Because the `Shape` class is essentially what the `Rectangle` was, the code
    isn’t shown; instead, the updated `Rectangle` class is shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Shape` 类本质上就是之前的 `Rectangle`，所以这里没有显示代码；相反，这里显示了更新的 `Rectangle` 类：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](../../OEBPS/Images/CH04_F04_Farrell.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F04_Farrell.png)'
- en: Figure 4.4 The UML diagram showing the relationship between the `Shape` and
    `Rectangle` classes
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 显示 `Shape` 和 `Rectangle` 类之间关系的 UML 图
- en: The first line of the `Rectangle` class has been modified to include `Shape`
    within parentheses. This is how the `Rectangle` class inherits from the `Shape`
    class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle` 类的第一行已经被修改，包括括号内的 `Shape`。这就是 `Rectangle` 类从 `Shape` 类继承的方式。'
- en: The rectangle has been refactored to have only a unique `draw()` method to draw
    itself on the screen. The `draw()` method overrides the empty abstract method
    provided by the `Shape` class. Everything else is managed and maintained by the
    `Shape` class. Even the `__init__()` initializer has been removed because the
    initializer from the `Shape` class is sufficient.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形已经被重构，只有一个独特的 `draw()` 方法来在屏幕上绘制自己。`draw()` 方法覆盖了由 `Shape` 类提供的空抽象方法。其他一切均由
    `Shape` 类管理和维护。甚至 `__init__()` 初始化器也被移除了，因为 `Shape` 类的初始化器已经足够。
- en: It’s reasonable to question the advantage of splitting the original `Rectangle`
    into two new classes, `Shape` and `Rectangle`. You’ll see this in the next examples
    when `Square` and `Circle` shapes are added to the application. Figure 4.5 shows
    that running the application presents a screen exactly as seen previously—a single
    rectangle bouncing around the screen and changing colors.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 询问将原始 `Rectangle` 类拆分为两个新类 `Shape` 和 `Rectangle` 的优势是合理的。你将在下一个示例中看到，当 `Square`
    和 `Circle` 形状被添加到应用程序中时。图 4.5 显示运行应用程序呈现的屏幕与之前看到的一模一样——一个矩形在屏幕上弹跳并改变颜色。
- en: '![](../../OEBPS/Images/CH04_F05_Farrell.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F05_Farrell.png)'
- en: Figure 4.5 Screenshot of the rectangle on the window drawing surface
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 窗口绘图表面的矩形截图
- en: Multiple shapes
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 多种形状
- en: Now that you have an inheritance structure defined, you can use it to create
    multiple kinds of shapes with different attributes and behaviors. Adding a `Square`
    and a `Circle` class to the inheritance structure is straightforward. Each additional
    class inherits from a parent class providing common attributes and methods that
    are useful to the new child class.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了继承结构，你可以使用它来创建具有不同属性和行为的多种形状。将 `Square` 和 `Circle` 类添加到继承结构中是直接的。每个额外的类都从提供常用属性和方法作为新子类有用性的父类继承。
- en: Figure 4.6 shows a few interesting elements of the inheritance structure. Notice
    the `Square` class inherits from `Rectangle` instead of `Shape`. This is because
    a square is a special case of a rectangle with the height and width equal to each
    other.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 显示了继承结构的一些有趣元素。注意 `Square` 类是从 `Rectangle` 继承，而不是从 `Shape` 继承。这是因为正方形是矩形的一个特例，其高度和宽度相等。
- en: '![](../../OEBPS/Images/CH04_F06_Farrell.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F06_Farrell.png)'
- en: Figure 4.6 The relationships between the shapes drawn on the screen
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 屏幕上绘制的形状之间的关系
- en: 'This brings up a concept about inheritance and the relationships between objects.
    As just mentioned, a `Square` IS-A `Rectangle`, and a `Rectangle` IS-A `Shape`,
    which means a `Square` IS-A `Shape` as well. Here is the class definition code
    for the `Square` class:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个关于继承和对象之间关系概念的问题。正如刚才提到的，`Square`是`Rectangle`的一个实例，`Rectangle`是`Shape`的一个实例，这意味着`Square`也是`Shape`的一个实例。以下是`Square`类的类定义代码：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Square` class has an `__init__()` method even though its parent class,
    the `Rectangle` class, doesn’t. The `Square` provides this unique `__init__()`
    method because it only needs to get a single-dimension value—`size`—and not height
    and width. It then uses the parameters in the `__init__()` method when it makes
    a call to `super().__init__()`. Because the `Rectangle` class doesn’t have an
    `__init__()` method, the `super().__init__()` calls the `Shape` class constructor,
    passing the `size` parameter for both `height` and `width` to set the attribute
    dimensions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`Square`的父类`Rectangle`类没有`__init__()`方法，`Square`类也有一个`__init__()`方法。`Square`提供这个独特的`__init__()`方法，因为它只需要一个单维值——`size`——而不是高度和宽度。然后它使用`__init__()`方法中的参数，在调用`super().__init__()`时。因为`Rectangle`类没有`__init__()`方法，所以`super().__init__()`调用`Shape`类构造函数，将`size`参数传递给`height`和`width`以设置属性维度。
- en: The `super()` method is how to explicitly call the `__init__()` method of the
    child’s parent class. The `Square` class doesn’t need to provide a `draw()` method,
    as the one inherited from the parent `Rectangle` class works fine but with the
    height and width attributes having the same value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`super()`方法是显式调用子类父类的`__init__()`方法的方式。`Square`类不需要提供`draw()`方法，因为它从父`Rectangle`类继承的方法已经足够好，只是高度和宽度属性具有相同的值。'
- en: 'The `Circle` IS-A `Shape` because it inherits directly from the `Shape` class.
    The code that creates the `Circle` class is shown here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Circle`是`Shape`的一个实例，因为它直接从`Shape`类继承。创建`Circle`类的代码如下：'
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Like the `Square` class, the `Circle` supplies its own `__init__()` method so
    the caller can provide a radius for the circle. The `radius` parameter is used
    in the `super().__init__()` call to set the height and width dimensions of the
    area that the circle will be drawn within. Unlike the `Square` class, the `Circle`
    class does provide a unique `draw()` method because it calls different drawing
    functions in the arcade module to draw itself onscreen. When the `CH_04/example_05`
    application runs, it creates a window with three different shapes bouncing around
    within the window and changing colors. Initially, it looks similar to figure 4.7.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Square`类类似，`Circle`类也提供了自己的`__init__()`方法，以便调用者可以为圆提供半径。`radius`参数在`super().__init__()`调用中使用，以设置圆将在其中绘制的区域的高度和宽度维度。与`Square`类不同，`Circle`类确实提供了一个独特的`draw()`方法，因为它在arcade模块中调用不同的绘图函数来在屏幕上绘制自身。当`CH_04/example_05`应用程序运行时，它创建了一个窗口，窗口内有三个不同形状在窗口内弹跳并改变颜色。最初，它看起来类似于图4.7。
- en: '![](../../OEBPS/Images/CH04_F07_Farrell.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F07_Farrell.png)'
- en: Figure 4.7 All three shapes drawn onscreen
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 屏幕上绘制的所有三个形状
- en: Object-oriented genealogies
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的家谱
- en: Inheritance in OOP is a feature that allows you to create useful and powerful
    class hierarchies. Keep in mind that just like human genealogies, the descendants
    become less and less like the root parent class as you descend the tree.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的继承是一个允许你创建有用且强大的类层次结构的功能。记住，就像人类的家谱一样，随着你向下追溯树状结构，后代会越来越不像根父类。
- en: Large hierarchies of classes can become complex to use and understand, and the
    root class functionality can become wholly obscured in distant child classes.
    In my work, I’ve never gone beyond three levels in any parent–child relationships
    in the class hierarchies I’ve built.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 大型的类层次结构可能会变得复杂，难以使用和理解，根类的功能可能会在遥远的子类中完全被掩盖。在我的工作中，我从未在我的构建的类层次结构中超过三个级别的父-子关系。
- en: 4.1.4 Polymorphism
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 多态
- en: Another feature of inheritance, called polymorphism, can be useful when creating
    class hierarchies. The word *polymorphism* means “many forms,” and in relation
    to programming, it means calling a method of multiple objects by the same method
    name but getting different behavior depending on which instance of an object is
    used.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的另一个特性，称为多态，在创建类层次结构时可能很有用。多态这个词的意思是“多种形式”，在编程中，它意味着通过相同的方法名调用多个对象的方法，但根据使用的对象实例不同，会得到不同的行为。
- en: The `examples/CH_04/example_05` application has already taken advantage of polymorphism
    when rendering the different shapes in the window. Each of the shapes in the program
    supports a `draw()` method. The `Rectangle` class provides a `draw()` method to
    render itself on the application screen. The `Square` class uses the inherited
    `Rectangle` `draw()` method but with a constraint on the height and width to create
    a `Square`. The `Circle` class provides its own `draw()` method to render itself.
    The `Shape` root parent class also provides an abstract `draw()` method that has
    no functionality.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`examples/CH_04/example_05` 应用程序在渲染窗口中的不同形状时已经利用了多态性。程序中的每个形状都支持一个 `draw()`
    方法。`Rectangle` 类提供了一个 `draw()` 方法来在应用程序屏幕上渲染自身。`Square` 类使用继承的 `Rectangle` `draw()`
    方法，但限制了高度和宽度以创建一个 `Square`。`Circle` 类提供了一个自己的 `draw()` 方法来渲染自身。`Shape` 根父类还提供了一个没有功能的抽象
    `draw()` 方法。'
- en: 'Because the `Rectangle`, `Square,` and `Circle` classes all have an IS-A relationship
    with the `Shape` class, they all can be considered instances of `Shape` and use
    the methods provided by the class. This is what happens in the `Display` class
    when the `on_update``()`, `on_draw``()`, and `change_colors()` methods are called.
    The `Display` class has a collection of shapes in the `self.shapes` `=` `[]` list
    created in the `__init__()` method. For example, here is the code in the `on_draw()`
    method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Rectangle`、`Square` 和 `Circle` 类都与 `Shape` 类存在 IS-A 关系，所以它们都可以被视为 `Shape`
    的实例，并可以使用该类提供的方法。这就是在 `Display` 类中调用 `on_update()`、`on_draw()` 和 `change_colors()`
    方法时发生的情况。`Display` 类在 `__init__()` 方法中创建了一个包含形状的 `self.shapes` `=` `[]` 列表。例如，以下是
    `on_draw()` 方法中的代码：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code is called every time the system wants to draw the objects on the screen,
    which is approximately 60 times a second when using the arcade module. The code
    takes advantage of polymorphism to iterate through the list of shapes and call
    the `draw()` method of each one. It doesn’t matter that each shape is different;
    they all support a `draw()` method, and all the shapes are rendered onscreen.
    Any number of different shapes could be derived from the `Shape` class, and so
    long as they support a `draw()` method that renders the shape on the screen, the
    mentioned loop would work.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统想要在屏幕上绘制对象时，会调用此代码，使用 arcade 模块时，大约每秒60次。代码利用多态性遍历形状列表，并调用每个形状的 `draw()`
    方法。每个形状的不同并不重要；它们都支持 `draw()` 方法，并且所有形状都显示在屏幕上。可以从 `Shape` 类派生出任意数量的不同形状，只要它们支持一个在屏幕上渲染形状的
    `draw()` 方法，上述循环就会工作。
- en: Real-world objects shouldn’t constrain object design
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界的对象不应该限制对象设计
- en: It is common to use analogies to real-world objects or concepts when writing
    about inheritance. The examples presented do exactly this, using the idea of shapes,
    rectangles, squares, and circles. Using concepts already familiar to you is a
    useful metaphor because they are things you know already. There are plenty of
    other new concepts presented when talking about inheritance; using familiar ideas
    reduces the cognitive load while learning.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述继承时，使用现实世界中的对象或概念进行类比是很常见的。所提供的示例正是这样做的，使用了形状、矩形、正方形和圆的概念。使用你已经熟悉的概念是一个有用的隐喻，因为它们是你已经知道的东西。在讨论继承时，还会介绍许多其他新的概念；使用熟悉的想法可以减少学习时的认知负担。
- en: However, this metaphor can get in the way of creating useful hierarchies of
    classes in your applications. Because we’ve been talking about things that have
    behavior like actual objects in the real world, it can color how you think about
    your class design. The objects you create from the classes you design don’t have
    to model real-world objects. Many of the objects that are useful to model with
    classes have no analog in the real world, and adhering to the analogy too strictly
    can hinder the work you’re trying to accomplish.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个隐喻可能会妨碍你在应用程序中创建有用的类层次结构。因为我们一直在谈论具有现实世界中实际对象行为的事物，这可能会影响你对类设计的思考。你从设计的类中创建的对象不需要模拟现实世界中的对象。许多有用的类模型对象在现实世界中没有对应物，过于严格地遵循类比可能会阻碍你试图完成的工作。
- en: 4.1.5 Composition
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.5 组合
- en: In the inheritance section, you saw the relationships between the `Rectangle`,
    `Square`, `Circle``,` and `Shape` classes. These relationships allowed the child
    classes to inherit attributes and behavior from their parent class. This creates
    the idea that a `Rectangle` IS-A `Shape`, and a `Square` IS-A `Rectangle`, which
    also means a `Square` IS-A `Shape` as well.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在继承部分，你看到了`Rectangle`、`Square`、`Circle`和`Shape`类之间的关系。这些关系允许子类从其父类继承属性和行为。这产生了`Rectangle`是`Shape`的IS-A关系，`Square`是`Rectangle`的IS-A关系，这也意味着`Square`也是`Shape`的IS-A关系。
- en: These relationships also imply a certain similarity between attributes and behaviors
    of the parent classes and the child classes that inherit from them. But this isn’t
    the only way to incorporate attributes and behavior into classes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关系还暗示了父类和从它们继承的子类的属性和行为之间的一定相似性。但这并不是将属性和行为纳入类中的唯一方法。
- en: Look at the `Shape` class; it has two attributes for pen and fill color. These
    two attributes provide color to the shape and are distinguished from each other
    by their names. But they offer the same thing—a color, most likely from a palette
    of colors the system can create. This means the color is a common attribute within
    the `Shape` itself and is expressed twice.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`Shape`类；它有两个用于笔和填充颜色的属性。这两个属性为形状提供颜色，并且通过它们的名称区分彼此。但它们提供的是相同的东西——一种颜色，很可能是系统可以创建的颜色调色板中的颜色。这意味着颜色是`Shape`本身的一个公共属性，并且被表达两次。
- en: It’s possible with inheritance to handle this and add to the hierarchy in the
    examples by creating a `Color` class with pen and fill color attributes and then
    having the `Shape` class inherit from it. This would work, but the inheritance
    feels awkward. You can make a `Shape` have an IS-A relationship to a `Color` class
    in code, but logically it doesn’t make sense. A shape is not a color, and it doesn’t
    fit the mental IS-A model of an inheritance structure.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承可以处理这个问题，并通过创建具有笔和填充颜色属性的`Color`类并在其中继承`Shape`类来在示例中添加到层次结构中。这会起作用，但继承感觉有些不自然。你可以在代码中使`Shape`类与`Color`类有IS-A关系，但从逻辑上讲，这并不合理。形状不是颜色，它不符合继承结构中IS-A的心理模型。
- en: Instead of trying to force inheritance to provide the desired behavior, you
    can use composition. You’ve already been using composition when giving classes
    attributes that are integers and strings. You can take this further and create
    custom classes to be used as attributes, composing behavior into your own classes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是试图通过继承来强制提供所需的行为，你可以使用组合。你已经在使用组合，当给类属性赋予整数和字符串时。你可以更进一步，创建自定义类作为属性，将行为组合到自己的类中。
- en: Creating a new class `Color` provides a consistent abstraction for color in
    the application. It has a class-level definition for the colors supported and
    has a mechanism to allow only defined colors to be set. The `Color` class is connected
    to the `Shape` class as a composite, indicated in figure 4.8 by the connecting
    line with the filled black-diamond symbol.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`Color`类为应用程序中的颜色提供了一致的抽象。它有一个类级别的颜色定义，并有一个机制来允许只设置定义的颜色。`Color`类作为组合与`Shape`类连接，如图4.8中用填充黑色菱形符号的连接线所示。
- en: 'Here is what the `Color` class looks like from the `examples/CH_04/example_06`
    application program:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`Color`类在`examples/CH_04/example_06`应用程序程序中的样子：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](../../OEBPS/Images/CH04_F08_Farrell.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F08_Farrell.png)'
- en: Figure 4.8 The UML diagrams for the classes, including the composited `Color`
    class
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 类的UML图，包括组合的`Color`类
- en: The `Color` class moves the allowable color list within the scope of the class
    and out of the global module namespace. It’s also a Python data class, which can
    make defining simple classes that are mostly data easier to implement. The class
    provides getter and setter property decorators to make using the color within
    the class more straightforward.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color`类将允许的颜色列表移动到类的范围内，并从全局模块命名空间中移出。它也是一个Python数据类，这使得定义主要是数据的简单类更容易实现。该类提供了获取器和设置器属性装饰器，使得在类中使用颜色更加直接。'
- en: 'The `Shape` class is modified to use the `Color` class for the pen and fill
    color attributes. The updated `__init__()` method for the class is shown here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shape`类被修改为使用`Color`类作为笔和填充颜色属性。这里显示了类的更新后的`__init__()`方法：'
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The attribute names for pen and fill color have been simplified to just `pen`
    and `fill` because they are both `Color` class instances. The initial default
    values have been set to black for the pen and light gray for the fill colors.
    Adding the `Colo`r class to the `Shape` class this way creates a HAS-A relationship;
    a `Shape` class has `Color` attributes but isn’t a color itself.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 笔和填充颜色的属性名称已经被简化为仅`pen`和`fill`，因为它们都是`Color`类的实例。初始默认值已设置为笔的颜色为黑色，填充颜色为浅灰色。以这种方式将`Color`类添加到`Shape`类中创建了一个HAS-A关系；`Shape`类具有`Color`属性，但它本身并不是一个颜色。
- en: 'The `set_pen_color()` and `set_fll_color()` methods have also been modified
    to use the new `pen` and `fill` attributes. Setting a color for the pen now looks
    like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_pen_color()`和`set_fll_color()`方法也已被修改为使用新的`pen`和`fill`属性。设置笔的颜色现在看起来是这样的：'
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running the `examples/CH_04/example_06` application produces a screen exactly
    like you’ve seen before—three shapes bouncing around the window and changing colors
    every second. The use of composition gives you a way to add attributes and behavior
    to a class without having to create contrived inheritance hierarchies.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`examples/CH_04/example_06`应用程序会产生一个与之前看到的屏幕完全一样的效果——三个形状在窗口中弹跳，并且每秒改变颜色。使用组合为你提供了一种在不创建人为的继承层次结构的情况下向类添加属性和行为的方法。
- en: 4.2 Closing thoughts
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 结束语
- en: Creating classes and class hierarchies gives you a way to create code that’s
    clean and well-controlled in its usage. Classes are another avenue to give your
    users an API into application functionality.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类和类层次结构为你提供了一种创建干净且使用受控的代码的方式。类是向用户提供应用程序功能API的另一种途径。
- en: A class definition also can be used to create namespaces and control scope.
    A module provides a namespace, and classes defined within that module create more
    namespaces within it. The attributes and methods of a class are within the scope
    of instance objects created from the class.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义也可以用来创建命名空间和控制作用域。一个模块提供了一个命名空间，在该模块中定义的类创建了更多的命名空间。类的属性和方法在由该类创建的实例对象的作用域内。
- en: You’ve moved closer to particular elements of the developer domain and are now
    using binoculars to gain more detailed views of those domains. We’ll continue
    to scan useful and powerful domains for insights on our journey.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经接近了开发者领域的特定元素，现在正在使用双筒望远镜来获得这些领域的更详细视图。我们将继续在我们的旅程中扫描有用的和强大的领域，以获得洞察力。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: OOP gives you the ability to encapsulate data together with the functionality
    that acts on that data. This gives objects “behaviors” that make thinking about
    how those objects react and interact with other objects a little easier.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）让你能够将数据与其上的功能封装在一起。这给对象带来了“行为”，使得思考这些对象如何与其他对象反应和交互变得稍微容易一些。
- en: Python creates the structure of objects using class definitions. A class gives
    the object a look and feel; an instance of a class is the realization of a class
    in your code. Like a cookie cutter defines what a cookie is, the cookie is the
    instance of what the cookie cutter defines.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python使用类定义来创建对象的架构。一个类给对象提供了一个外观和感觉；类的实例是你在代码中对类的实现。就像饼干模具定义了饼干是什么一样，饼干是饼干模具定义的实例。
- en: Like namespaces, classes can create hierarchal structures by using inheritance
    from a parent class to a child class. A child class inherits attributes and features
    from its parent and can add new, unique features of its own.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于命名空间，类可以通过从父类到子类的继承来创建层次结构。子类从其父类继承属性和功能，并可以添加自己独特的新功能。
- en: Using composition, attributes and functionality can be added to a class design
    without creating awkward or illogical inheritance structures.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组合，可以在不创建尴尬或不合逻辑的继承结构的情况下向类设计添加属性和功能。
- en: You’ve learned about classes, inheritance, and creating class hierarchies. Using
    classes is a powerful way to take advantage of code reuse and adhere to the DRY
    principle.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经学习了关于类、继承以及创建类层次结构的内容。使用类是利用代码重用并遵循DRY原则的强大方式。
- en: By using composition, you can add additional attributes and features to definitions
    that don’t come from inheritance and thus avoid awkward and illogical inheritance
    hierarchies.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用组合，你可以向定义中添加额外的属性和功能，这些属性和功能不是来自继承，从而避免尴尬和不合逻辑的继承层次结构。
