- en: Chapter 7\. Implementing queries in a microservice architecture
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章\. 在微服务架构中实现查询
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: The challenges of querying data in a microservice architecture
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服务架构中查询数据的挑战
- en: When and how to implement queries using the API composition pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时以及如何使用API组合模式实现查询
- en: When and how to implement queries using the Command query responsibility segregation
    (CQRS) pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时以及如何使用命令查询责任分离（CQRS）模式实现查询
- en: Mary and her team were just starting to get comfortable with the idea of using
    sagas to maintain data consistency. Then they discovered that transaction management
    wasn’t the only distributed data-related challenge they had to worry about when
    migrating the FTGO application to microservices. They also had to figure out how
    to implement queries.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 玛丽和她的团队刚开始习惯于使用sagas来维护数据一致性。然后他们发现，在将FTGO应用程序迁移到微服务时，他们不仅要担心事务管理，还要解决如何实现查询的问题。
- en: In order to support the UI, the FTGO application implements a variety of query
    operations. Implementing these queries in the existing monolithic application
    is relatively straightforward, because it has a single database. For the most
    part, all the FTGO developers needed to do was write SQL SELECT statements and
    define the necessary indexes. As Mary discovered, writing queries in a microservice
    architecture is challenging. Queries often need to retrieve data that’s scattered
    among the databases owned by multiple services. You can’t, however, use a traditional
    distributed query mechanism, because even if it were technically possible, it
    violates encapsulation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持UI，FTGO应用程序实现了各种查询操作。在现有的单体应用程序中实现这些查询相对简单，因为它有一个单一的数据库。大多数情况下，FTGO开发者需要做的只是编写SQL
    SELECT语句并定义必要的索引。正如玛丽发现的，在微服务架构中编写查询是具有挑战性的。查询通常需要检索分散在多个服务拥有的数据库中的数据。然而，你不能使用传统的分布式查询机制，因为即使技术上可行，它也违反了封装原则。
- en: Consider, for example, the query operations for the FTGO application described
    in [chapter 2](kindle_split_010.xhtml#ch02). Some queries retrieve data that’s
    owned by just one service. The `findConsumerProfile()` query, for example, returns
    data from `Consumer Service`. But other FTGO query operations, such as `findOrder()`
    and `findOrderHistory()`, return data owned by multiple services. Implementing
    these query operations is not as straightforward.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以例如FTGO应用程序在[第2章](kindle_split_010.xhtml#ch02)中描述的查询操作为例。一些查询检索仅由一个服务拥有的数据。例如，`findConsumerProfile()`查询从`Consumer
    Service`返回数据。但其他FTGO查询操作，如`findOrder()`和`findOrderHistory()`，返回由多个服务拥有的数据。实现这些查询操作并不像想象中那么简单。
- en: 'There are two different patterns for implementing query operations in a microservice
    architecture:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中实现查询操作有两种不同的模式：
- en: '***The API composition pattern*—** This is the simplest approach and should
    be used whenever possible. It works by making clients of the services that own
    the data responsible for invoking the services and combining the results.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***API组合模式***——**这是最简单的方法，应尽可能使用。它通过使拥有数据的服务的客户端负责调用服务并组合结果来实现**。'
- en: '***The Command query responsibility segregation (CQRS) pattern*—** This is
    more powerful than the API composition pattern, but it’s also more complex. It
    maintains one or more view databases whose sole purpose is to support queries.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***命令查询责任分离（CQRS）模式***——**这比API组合模式更强大，但也更复杂。它维护一个或多个仅用于支持查询的视图数据库**。'
- en: After discussing these two patterns, I will talk about how to design CQRS views,
    followed by the implementation of an example view. Let’s start by taking a look
    at the API composition pattern.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了这两种模式之后，我将讨论如何设计CQRS视图，然后是示例视图的实现。让我们先看看API组合模式。
- en: 7.1\. Querying using the API composition pattern
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. 使用API组合模式进行查询
- en: The FTGO application implements numerous query operations. Some queries, as
    mentioned earlier, retrieve data from a single service. Implementing these queries
    is usually straightforward—although later in this chapter, when I cover the CQRS
    pattern, you’ll see examples of single service queries that are challenging to
    implement.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: FTGO应用程序实现了许多查询操作。正如之前提到的，一些查询是从单个服务中检索数据的。实现这些查询通常很简单——尽管在本章的后面部分，当我介绍CQRS模式时，你会看到一些难以实现的单一服务查询示例。
- en: There are also queries that retrieve data from multiple services. In this section,
    I describe the `findOrder()` query operation, which is an example of a query that
    retrieves data from multiple services. I explain the challenges that often crop
    up when implementing this type of query in a microservice architecture. I then
    describe the API composition pattern and show how you can use it to implement
    queries such as `findOrder()`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 也有查询操作可以从多个服务中检索数据。在本节中，我描述了`findOrder()`查询操作，这是一个从多个服务中检索数据的查询示例。我解释了在微服务架构中实现此类查询时经常出现的挑战。然后，我描述了API组合模式，并展示了如何使用它来实现`findOrder()`等查询。
- en: 7.1.1\. The findOrder() query operation
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1\. findOrder()查询操作
- en: The `findOrder()` operation retrieves an order by its primary key. It takes
    an `orderId` as a parameter and returns an `OrderDetails` object, which contains
    information about the order. As shown in [figure 7.1](#ch07fig01), this operation
    is called by a frontend module, such as a mobile device or a web application,
    that implements the *Order Status* view.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOrder()`操作通过主键检索订单。它接受一个`orderId`作为参数，并返回一个包含订单信息的`OrderDetails`对象。如图7.1所示，此操作由实现*订单状态*视图的前端模块（如移动设备或Web应用程序）调用。'
- en: Figure 7.1\. The `findOrder()` operation is invoked by a FTGO frontend module
    and returns the details of an `Order`.
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1\. `findOrder()`操作由FTGO前端模块调用，并返回`Order`的详情。
- en: '![](Images/07fig01_alt.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig01_alt.jpg)'
- en: The information displayed by the *Order Status* view includes basic information
    about the order, including its status, payment status, status of the order from
    the restaurant’s perspective, and delivery status, including its location and
    estimated delivery time if in transit.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*订单状态*视图显示的信息包括订单的基本信息，包括其状态、支付状态、从餐厅角度的订单状态以及配送状态，包括其位置和预计配送时间（如果正在途中）。'
- en: 'Because its data resides in a single database, the monolithic FTGO application
    can easily retrieve the order details by executing a single SELECT statement that
    joins the various tables. In contrast, in the microservices-based version of the
    FTGO application, the data is scattered around the following services:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其数据驻留在单个数据库中，单体FTGO应用程序可以轻松通过执行一个连接各种表的单一SELECT语句来检索订单详情。相比之下，在基于微服务的FTGO应用程序版本中，数据分散在以下服务中：
- en: '**`Order Service`—** Basic order information, including the details and status'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`订单服务`—** 基本订单信息，包括细节和状态'
- en: '**`Kitchen Service`—** Status of the order from the restaurant’s perspective
    and the estimated time it will be ready for pickup'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`厨房服务`—** 从餐厅的角度看订单的状态以及预计取餐准备时间'
- en: '**`Delivery Service`—** The order’s delivery status, estimated delivery information,
    and its current location'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`配送服务`—** 订单的配送状态、预计配送信息和当前位置'
- en: '**`Accounting Service`—** The order’s payment status'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`会计服务`—** 订单的支付状态'
- en: Any client that needs the order details must ask all of these services.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 任何需要订单详情的客户都必须询问所有这些服务。
- en: 7.1.2\. Overview of the API composition pattern
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2\. API组合模式的概述
- en: 'One way to implement query operations, such as `findOrder()`, that retrieve
    data owned by multiple services is to use the API composition pattern. This pattern
    implements a query operation by invoking the services that own the data and combining
    the results. [Figure 7.2](#ch07fig02) shows the structure of this pattern. It
    has two types of participants:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实现查询操作，例如`findOrder()`，以检索多个服务拥有的数据的一种方法是通过使用API组合模式。该模式通过调用拥有数据的服务并组合结果来执行查询操作。[图7.2](#ch07fig02)展示了该模式的结构。它有两种类型的参与者：
- en: '***An API composer*—** This implements the query operation by querying the
    provider services.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***API作曲家*—** 通过查询提供者服务来实现查询操作。'
- en: '***A provider service*—** This is a service that owns some of the data that
    the query returns.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***提供者服务*—** 这是拥有查询返回的一些数据的服务。'
- en: Figure 7.2\. The API composition pattern consists of an API composer and two
    or more provider services. The API composer implements a query by querying the
    providers and combining the results.
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2\. API组合模式由一个API作曲家和两个或更多提供者服务组成。API作曲家通过查询提供者并组合结果来执行查询。
- en: '![](Images/07fig02_alt.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig02_alt.jpg)'
- en: '[Figure 7.2](#ch07fig02) shows three provider services. The API composer implements
    the query by retrieving data from the provider services and combining the results.
    An API composer might be a client, such as a web application, that needs the data
    to render a web page. Alternatively, it might be a service, such as an API gateway
    and its Backends for frontends variant described in [chapter 8](kindle_split_016.xhtml#ch08),
    which exposes the query operation as an API endpoint.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.2](#ch07fig02) 展示了三个提供者服务。API composer 通过从提供者服务检索数据并合并结果来实现查询。API composer
    可能是一个客户端，例如需要数据来渲染网页的 Web 应用程序。或者，它可能是一个服务，例如 API 网关及其在 [第 8 章](kindle_split_016.xhtml#ch08)
    中描述的前端后端变体，它将查询操作作为 API 端点公开。'
- en: '|  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pattern: API composition**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：API 组合**'
- en: Implement a query that retrieves data from several services by querying each
    service via its API and combining the results. See [http://microservices.io/patterns/data/api-composition.html](http://microservices.io/patterns/data/api-composition.html).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个查询，通过通过每个服务的 API 查询每个服务并合并结果来检索来自几个服务的数据。参见 [http://microservices.io/patterns/data/api-composition.html](http://microservices.io/patterns/data/api-composition.html)。
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Whether you can use this pattern to implement a particular query operation depends
    on several factors, including how the data is partitioned, the capabilities of
    the APIs exposed by the services that own the data, and the capabilities of the
    databases used by the services. For instance, even if the *Provider services*
    have APIs for retrieving the required data, the aggregator might need to perform
    an inefficient, in-memory join of large datasets. Later on, you’ll see examples
    of query operations that can’t be implemented using this pattern. Fortunately,
    though, there are many scenarios where this pattern is applicable. To see it in
    action, we’ll look at an example.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否可以使用此模式实现特定的查询操作取决于多个因素，包括数据如何分区、拥有数据的服务的 API 的功能以及服务使用的数据库的功能。例如，即使 *Provider
    services* 有用于检索所需数据的 API，聚合器可能需要执行低效的内存中连接大型数据集。稍后，您将看到无法使用此模式实现的查询操作的示例。幸运的是，尽管如此，有许多场景适用此模式。为了看到它在实际中的应用，我们将查看一个示例。
- en: 7.1.3\. Implementing the findOrder() query operation using the API composition
    pattern
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.3\. 使用 API 组合模式实现 findOrder() 查询操作
- en: The `findOrder()` query operation corresponds to a simple primary key-based
    equijoin query. It’s reasonable to expect that each of the *Provider services*
    has an API endpoint for retrieving the required data by `orderId`. Consequently,
    the `findOrder()` query operation is an excellent candidate to be implemented
    by the API composition pattern. The *API composer* invokes the four services and
    combines the results together. [Figure 7.3](#ch07fig03) shows the design of the
    `Find Order Composer`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOrder()` 查询操作对应于一个简单的基于主键的等值连接查询。可以合理地预期每个 *Provider services* 都有一个 API
    端点，可以通过 `orderId` 检索所需数据。因此，`findOrder()` 查询操作是 API 组合模式的绝佳候选。*API composer* 调用四个服务并将结果合并在一起。[图
    7.3](#ch07fig03) 展示了 `Find Order Composer` 的设计。'
- en: Figure 7.3\. Implementing `findOrder()` using the API composition pattern
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.3\. 使用 API 组合模式实现 `findOrder()`
- en: '![](Images/07fig03_alt.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig03_alt.jpg)'
- en: In this example, the *API composer* is a service that exposes the query as a
    REST endpoint. The *Provider services* also implement REST APIs. But the concept
    is the same if the services used some other interprocess communication protocol,
    such as gRPC, instead of HTTP. The `Find Order Composer` implements a REST endpoint
    `GET /order/{orderId}`. It invokes the four services and joins the responses using
    the `orderId`. Each *Provider service* implements a REST endpoint that returns
    a response corresponding to a single aggregate. The `OrderService` retrieves its
    version of an `Order` by primary key and the other services use the `orderId`
    as a foreign key to retrieve their aggregates.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，*API composer* 是一个将查询暴露为 REST 端点服务的服务。*Provider services* 也实现了 REST API。但如果使用的是其他进程间通信协议，如
    gRPC 而不是 HTTP，概念是相同的。`Find Order Composer` 实现了一个 REST 端点 `GET /order/{orderId}`。它通过
    `orderId` 调用四个服务并将响应合并。每个 *Provider service* 实现了一个 REST 端点，返回与单个聚合对应的响应。`OrderService`
    通过主键检索其版本的 `Order`，而其他服务使用 `orderId` 作为外键来检索它们的聚合。
- en: As you can see, the API composition pattern is quite simple. Let’s look at a
    couple of design issues you must address when applying this pattern.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，API 组合模式相当简单。让我们看看在应用此模式时必须解决的一些设计问题。
- en: 7.1.4\. API composition design issues
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.4\. API组合设计问题
- en: 'When using this pattern, you have to address a couple of design issues:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此模式时，您必须解决几个设计问题：
- en: Deciding which component in your architecture is the query operation’s *API
    composer*
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定您的架构中哪个组件是查询操作*API作曲家*
- en: How to write efficient aggregation logic
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写高效的聚合逻辑
- en: Let’s look at each issue.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个问题。
- en: Who plays the role of the API composer?
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 谁扮演API作曲家的角色？
- en: One decision that you must make is who plays the role of the query operation’s
    *API composer*. You have three options. The first option, shown in [figure 7.4](#ch07fig04),
    is for a client of the services to be the *API composer*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须做出的一个决定是，谁扮演查询操作*API作曲家*的角色。您有三个选项。第一种选项，如图7.4所示，是让服务客户端成为*API作曲家*。
- en: Figure 7.4\. Implementing API composition in a client. The client queries the
    provider services to retrieve the data.
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.4\. 在客户端实现API组合。客户端查询提供者服务以检索数据。
- en: '![](Images/07fig04_alt.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig04_alt.jpg)'
- en: A frontend client such as a web application, that implements the `Order Status`
    view and is running on the same LAN, could efficiently retrieve the order details
    using this pattern. But as you’ll learn in [chapter 8](kindle_split_016.xhtml#ch08),
    this option is probably not practical for clients that are outside of the firewall
    and access services via a slower network.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前端客户端，如运行在同一局域网上的Web应用程序，实现了`订单状态`视图，可以使用此模式高效地检索订单详情。但正如您将在第8章中了解到的那样，此选项对于在防火墙之外且通过较慢网络访问服务的客户端可能不太实用。
- en: The second option, shown in [figure 7.5](#ch07fig05), is for an API gateway,
    which implements the application’s external API, to play the role of an *API composer*
    for a query operation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选项，如图7.5所示，是为API网关，它实现了应用程序的外部API，在查询操作中扮演*API作曲家*的角色。
- en: Figure 7.5\. Implementing API composition in the API gateway. The API queries
    the provider services to retrieve the data, combines the results, and returns
    a response to the client.
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.5\. 在API网关中实现API组合。API查询提供者服务以检索数据，合并结果，并将响应返回给客户端。
- en: '![](Images/07fig05_alt.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig05_alt.jpg)'
- en: This option makes sense if the query operation is part of the application’s
    external API. Instead of routing a request to another service, the API gateway
    implements the API composition logic. This approach enables a client, such as
    a mobile device, that’s running outside of the firewall to efficiently retrieve
    data from numerous services with a single API call. I discuss the API gateway
    in [chapter 8](kindle_split_016.xhtml#ch08).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查询操作是应用程序外部API的一部分，则此选项是有意义的。而不是将请求路由到另一个服务，API网关实现了API组合逻辑。这种方法使运行在防火墙之外，例如移动设备等客户端，能够通过单个API调用高效地从多个服务中检索数据。我在第8章中讨论了API网关。
- en: The third option, shown in [figure 7.6](#ch07fig06), is to implement an *API
    composer* as a standalone service.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种选项，如图7.6所示，是将*API作曲家*实现为一个独立的服务。
- en: Figure 7.6\. Implement a query operation used by multiple clients and services
    as a standalone service.
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.6\. 将多个客户端和服务使用的查询操作实现为一个独立的服务。
- en: '![](Images/07fig06_alt.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig06_alt.jpg)'
- en: You should use this option for a query operation that’s used internally by multiple
    services. This operation can also be used for externally accessible query operations
    whose aggregation logic is too complex to be part of an API gateway.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多个服务内部使用的查询操作，您应该使用此选项。此操作也可以用于外部可访问的查询操作，其聚合逻辑过于复杂，不适合作为API网关的一部分。
- en: API composers should use a reactive programming model
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: API作曲家应使用响应式编程模型
- en: When developing a distributed system, minimizing latency is an ever-present
    concern. Whenever possible, an *API composer* should call provider services in
    parallel in order to minimize the response time for a query operation. The `Find
    Order Aggregator` should, for example, invoke the four services concurrently because
    there are no dependencies between the calls. Sometimes, though, an *API composer*
    needs the result of one *Provider service* in order to invoke another service.
    In this case, it will need to invoke some—but hopefully not all—of the *provider
    services* sequentially.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发分布式系统时，最小化延迟是一个持续存在的担忧。尽可能的情况下，**API composer**应该并行调用提供者服务以最小化查询操作的响应时间。例如，“查找订单聚合器”应该并发调用四个服务，因为调用之间没有依赖关系。然而，有时**API
    composer**需要某个**Provider服务**的结果来调用另一个服务。在这种情况下，它将需要按顺序调用一些——但希望不是所有——的**提供者服务**。
- en: The logic to efficiently execute a mixture of sequential and parallel service
    invocations can be complex. In order for an *API composer* to be maintainable
    as well as performant and scalable, it should use a reactive design based on Java
    `CompletableFuture`’s, RxJava observables, or some other equivalent abstraction.
    I discuss this topic further in [chapter 8](kindle_split_016.xhtml#ch08) when
    I cover the API gateway pattern.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 高效执行顺序和并行服务调用的逻辑可能很复杂。为了使**API composer**既易于维护又具有高性能和可扩展性，它应该使用基于Java `CompletableFuture`、RxJava可观察对象或其他等效抽象的响应式设计。我在第[8章](kindle_split_016.xhtml#ch08)中进一步讨论了这个主题，当时我介绍了API网关模式。
- en: 7.1.5\. The benefits and drawbacks of the API composition pattern
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.5. API组合模式的利弊
- en: 'This pattern is a simple and intuitive way to implement query operations in
    a microservice architecture. But it has some drawbacks:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式是实现微服务架构中查询操作的一种简单直观的方法。但它也有一些缺点：
- en: Increased overhead
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加开销
- en: Risk of reduced availability
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少可用性的风险
- en: Lack of transactional data consistency
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务数据一致性不足
- en: Let’s take a look at them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看它们。
- en: Increased overhead
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 增加开销
- en: One drawback of this pattern is the overhead of invoking multiple services and
    querying multiple databases. In a monolithic application, a client can retrieve
    data with a single request, which will often execute a single database query.
    In comparison, using the API composition pattern involves multiple requests and
    database queries. As a result, more computing and network resources are required,
    increasing the cost of running the application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的另一个缺点是调用多个服务和查询多个数据库的开销。在单体应用中，客户端可以通过单个请求检索数据，这通常执行单个数据库查询。相比之下，使用API组合模式涉及多个请求和数据库查询。因此，需要更多的计算和网络资源，从而增加了应用程序的运行成本。
- en: Risk of reduced availability
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 减少可用性的风险
- en: Another drawback of this pattern is reduced availability. As described in [chapter
    3](kindle_split_011.xhtml#ch03), the availability of an operation declines with
    the number of services that are involved. Because the implementation of a query
    operation involves at least three services—the *API composer* and at least two
    provider services—its availability will be significantly less than that of a single
    service. For example, if the availability of an individual service is 99.5%, then
    the availability of the `findOrder()` endpoint, which invokes four provider services,
    is 99.5%^((4+1)) = 97.5%!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的另一个缺点是可用性降低。如第[3章](kindle_split_011.xhtml#ch03)中所述，操作的可用性随着涉及的服务数量而下降。因为查询操作的实现至少涉及三个服务——**API
    composer**和至少两个提供者服务——其可用性将显著低于单个服务。例如，如果单个服务的可用性为99.5%，那么调用四个提供者服务的`findOrder()`端点的可用性为99.5%^((4+1))
    = 97.5%！
- en: There are couple of strategies you can use to improve availability. The first
    strategy is for the *API composer* to return previously cached data when a *Provider
    service* is unavailable. An *API composer* sometimes caches the data returned
    by a *Provider service* in order to improve performance. It can also use this
    cache to improve availability. If a provider is unavailable, the *API composer*
    can return data from the cache, though it may be potentially stale.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用几种策略来提高可用性。第一种策略是在**API composer**无法访问**Provider服务**时返回之前缓存的资料。**API composer**有时会缓存**Provider服务**返回的数据以提高性能。它也可以使用这个缓存来提高可用性。如果提供者不可用，**API
    composer**可以从缓存中返回数据，尽管这些数据可能已经过时。
- en: Another strategy for improving availability is for the *API composer* to return
    incomplete data. For example, imagine that `Kitchen Service` is temporarily unavailable.
    The *API Composer* for the `findOrder()` query operation could omit that service’s
    data from the response, because the UI can still display useful information. You’ll
    see more details on API design, caching, and reliability in [chapter 8](kindle_split_016.xhtml#ch08).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 提高可用性的另一种策略是让*API composer*返回不完整的数据。例如，假设`Kitchen Service`暂时不可用。`findOrder()`查询操作的*API
    Composer*可以省略该服务的数据，因为UI仍然可以显示有用的信息。你将在第8章（kindle_split_016.xhtml#ch08）中看到更多关于API设计、缓存和可靠性的细节。
- en: Lack of transactional data consistency
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 缺乏事务性数据一致性
- en: Another drawback of the API composition pattern is the lack of data consistency.
    A monolithic application typically executes a query operation using a single database
    transaction. ACID transactions—subject to the fine print about isolation levels—ensure
    that an application has a consistent view of the data, even if it executes multiple
    database queries. In contrast, the API composition pattern executes multiple database
    queries against multiple databases. There’s a risk, therefore, that a query operation
    will return inconsistent data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: API组合模式的另一个缺点是缺乏数据一致性。一个单体应用程序通常使用单个数据库事务来执行查询操作。ACID事务——受隔离级别细节的影响——确保应用程序对数据有一个一致的观点，即使它执行多个数据库查询。相比之下，API组合模式针对多个数据库执行多个数据库查询。因此，查询操作可能会返回不一致的数据。
- en: For example, an `Order` retrieved from `Order Service` might be in the `CANCELLED`
    state, whereas the corresponding `Ticket` retrieved from `Kitchen Service` might
    not yet have been cancelled. The *API composer* must resolve this discrepancy,
    which increases the code complexity. To make matters worse, an *API composer*
    might not always be able to detect inconsistent data, and will return it to the
    client.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从`Order Service`检索的`Order`可能处于`CANCELLED`状态，而对应的从`Kitchen Service`检索的`Ticket`可能尚未被取消。*API
    composer*必须解决这种差异，这增加了代码的复杂性。更糟糕的是，*API composer*可能无法始终检测到不一致的数据，并将其返回给客户端。
- en: Despite these drawbacks, the API composition pattern is extremely useful. You
    can use it to implement many query operations. But there are some query operations
    that can’t be efficiently implemented using this pattern. A query operation might,
    for example, require the *API composer* to perform an in-memory join of large
    datasets.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些缺点，API组合模式仍然非常有用。你可以用它来实现许多查询操作。但有些查询操作无法有效地使用此模式实现。例如，一个查询操作可能需要*API composer*对大型数据集进行内存中的连接。
- en: It’s usually better to implement these types of query operations using the CQRS
    pattern. Let’s take a look at how this pattern works.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好使用CQRS模式来实现这些类型的查询操作。让我们看看这个模式是如何工作的。
- en: 7.2\. Using the CQRS pattern
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 使用CQRS模式
- en: 'Many enterprise applications use an RDBMS as the transactional system of record
    and a text search database, such as Elasticsearch or Solr, for text search queries.
    Some applications keep the databases synchronized by writing to both simultaneously.
    Others periodically copy data from the RDBMS to the text search engine. Applications
    with this architecture leverage the strengths of multiple databases: the transactional
    properties of the RDBMS and the querying capabilities of the text database.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 许多企业应用程序使用关系数据库管理系统（RDBMS）作为事务性记录系统，并使用文本搜索数据库，如Elasticsearch或Solr，进行文本搜索查询。一些应用程序通过同时写入两个数据库来保持数据库同步。其他应用程序定期从RDBMS复制数据到文本搜索引擎。具有这种架构的应用程序利用多个数据库的优势：RDBMS的事务属性和文本数据库的查询能力。
- en: '|  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Command query responsibility segregation**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：命令查询责任分离**'
- en: Implement a query that needs data from several services by using events to maintain
    a read-only view that replicates data from the services. See [http://microservices.io/patterns/data/cqrs.html](http://microservices.io/patterns/data/cqrs.html).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用事件来维护只读视图并复制来自服务的数据，实现需要从多个服务获取数据的查询。请参阅[http://microservices.io/patterns/data/cqrs.html](http://microservices.io/patterns/data/cqrs.html)。
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: CQRS is a generalization of this kind of architecture. It maintains one or more
    view databases—not just text search databases—that implement one or more of the
    application’s queries. To understand why this is useful, we’ll look at some queries
    that can’t be efficiently implemented using the API composition pattern. I’ll
    explain how CQRS works and then talk about the benefits and drawbacks of CQRS.
    Let’s take a look at when you need to use CQRS.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS是这种架构的泛化。它维护一个或多个视图数据库——不仅仅是文本搜索数据库——这些数据库实现了应用程序的一个或多个查询。为了理解为什么这很有用，我们将查看一些无法使用API组合模式有效实现的查询。我将解释CQRS是如何工作的，然后讨论CQRS的优点和缺点。让我们看看何时需要使用CQRS。
- en: 7.2.1\. Motivations for using CQRS
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1. 使用CQRS的动机
- en: The API composition pattern is a good way to implement many queries that must
    retrieve data from multiple services. Unfortunately, it’s only a partial solution
    to the problem of querying in a microservice architecture. That’s because there
    are multiple service queries the API composition pattern can’t implement efficiently.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: API组合模式是实现必须从多个服务检索数据的许多查询的好方法。不幸的是，它只是微服务架构中查询问题的一个部分解决方案。这是因为API组合模式无法有效实现多个服务查询。
- en: What’s more, there are also single service queries that are challenging to implement.
    Perhaps the service’s database doesn’t efficiently support the query. Alternatively,
    it sometimes makes sense for a service to implement a query that retrieves data
    owned by a different service. Let’s take a look at these problems, starting with
    a multi-service query that can’t be efficiently implemented using API composition.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些难以实现的单一服务查询。也许服务的数据库不支持查询效率。或者，有时一个服务实现一个检索不同服务拥有的数据的查询是有意义的。让我们看看这些问题，从无法使用API组合有效实现的跨服务查询开始。
- en: Implementing the findOrderHistory() query operation
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现findOrderHistory()查询操作
- en: 'The `findOrderHistory()` operation retrieves a consumer’s order history. It
    has several parameters:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOrderHistory()`操作检索消费者的订单历史。它有几个参数：'
- en: '**`consumerId`—** Identifies the consumer'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`consumerId`——** 识别消费者'
- en: '**`pagination`—** Page of results to return'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`pagination`——** 返回的结果页'
- en: '**`filter`—** Filter criteria, including the max age of the orders to return,
    an optional order status, and optional keywords that match the restaurant name
    and menu items'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`filter`——** 过滤条件，包括返回订单的最大年龄、可选的订单状态以及可选的关键字，这些关键字匹配餐厅名称和菜单项'
- en: This query operation returns an `OrderHistory` object that contains a summary
    of the matching orders sorted by increasing age. It’s called by the module that
    implements the `Order History` view. This view displays a summary of each order,
    which includes the order number, order status, order total, and estimated delivery
    time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询操作返回一个包含按年龄递增排序的匹配订单摘要的`OrderHistory`对象。它由实现`Order History`视图的模块调用。此视图显示每个订单的摘要，包括订单编号、订单状态、订单总额和预计配送时间。
- en: On the surface, this operation is similar to the `findOrder()` query operation.
    The only difference is that it returns multiple orders instead of just one. It
    may appear that the *API composer* only has to execute the same query against
    each *Provider service* and combine the results. Unfortunately, it’s not that
    simple.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上，这个操作与`findOrder()`查询操作相似。唯一的区别是它返回多个订单而不是一个。看起来*API composer*只需要对每个*Provider
    service*执行相同的查询并合并结果。不幸的是，事情并不那么简单。
- en: That’s because not all services store the attributes that are used for filtering
    or sorting. For example, one of the `findOrderHistory()` operation’s filter criteria
    is a keyword that matches against a menu item. Only two of the services, `Order
    Service` and `Kitchen Service`, store an `Order`’s menu items. Neither `Delivery
    Service` nor `Accounting Service` stores the menu items, so can’t filter their
    data using this keyword. Similarly, neither `Kitchen Service` nor `Delivery Service`
    can sort by the `orderCreationDate` attribute.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为并非所有服务都存储用于过滤或排序的属性。例如，`findOrderHistory()`操作的一个过滤条件是匹配菜单项的关键字。只有两个服务，`Order
    Service`和`Kitchen Service`，存储`Order`的菜单项。`Delivery Service`和`Accounting Service`都不存储菜单项，因此不能使用此关键字过滤它们的数据。同样，`Kitchen
    Service`和`Delivery Service`也不能按`orderCreationDate`属性排序。
- en: There are two ways an *API composer* could solve this problem. One solution
    is for the *API composer* to do an in-memory join, as shown in [figure 7.7](#ch07fig07).
    It retrieves all orders for the consumer from `Delivery Service` and `Accounting
    Service` and performs a join with the orders retrieved from `Order Service` and
    `Kitchen Service`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*API composer*可以解决这个问题的两种方式。一种解决方案是*API composer*进行内存中的连接，如图7.7所示。它检索来自`Delivery
    Service`和`Accounting Service`的所有订单，并与来自`Order Service`和`Kitchen Service`检索到的订单进行连接。
- en: Figure 7.7\. API composition can’t efficiently retrieve a consumer’s orders,
    because some providers, such as `Delivery Service`, don’t store the attributes
    used for filtering.
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.7。API组合无法有效地检索消费者的订单，因为一些提供者，如`Delivery Service`，没有存储用于过滤的属性。
- en: '![](Images/07fig07_alt.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片7.7](Images/07fig07_alt.jpg)'
- en: The drawback of this approach is that it potentially requires the *API composer*
    to retrieve and join large datasets, which is inefficient.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，它可能需要*API composer*检索和连接大量数据集，这是低效的。
- en: The other solution is for the *API composer* to retrieve matching orders from
    `Order Service` and `Kitchen Service` and then request orders from the other services
    by ID. But this is only practical if those services have a bulk fetch API. Requesting
    orders individually will likely be inefficient because of excessive network traffic.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是*API composer*从`Order Service`和`Kitchen Service`检索匹配的订单，然后通过ID请求其他服务的订单。但这只有在那些服务有批量检索API的情况下才是实用的。由于网络流量过大，逐个请求订单可能会效率低下。
- en: Queries such as `findOrderHistory()` require the *API composer* to duplicate
    the functionality of an RDBMS’s query execution engine. On one hand, this potentially
    moves work from the less scalable database to the more scalable application. On
    the other hand, it’s less efficient. Also, developers should be writing business
    functionality, not a query execution engine.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`findOrderHistory()`的查询需要*API composer*复制RDBMS查询执行引擎的功能。一方面，这可能会将工作从可扩展性较低的数据库移动到可扩展性较高的应用程序。另一方面，这效率较低。此外，开发者应该编写业务功能，而不是查询执行引擎。
- en: Next I show you how to apply the CQRS pattern and use a separate datastore,
    which is designed to efficiently implement the `findOrderHistory()` query operation.
    But first, let’s look at an example of a query operation that’s challenging to
    implement, despite being local to a single service.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将向您展示如何应用CQRS模式并使用一个单独的数据存储，该数据存储旨在有效地实现`findOrderHistory()`查询操作。但在那之前，让我们看看一个查询操作，尽管它位于单个服务中，但实现起来具有挑战性。
- en: 'A challenging single service query: findAvailableRestaurants()'
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 具有挑战性的单个服务查询：`findAvailableRestaurants()`
- en: As you’ve just seen, implementing queries that retrieve data from multiple services
    can be challenging. But even queries that are local to a single service can be
    difficult to implement. There are a couple of reasons why this might be the case.
    One is because, as discussed shortly, sometimes it’s not appropriate for the service
    that owns the data to implement the query. The other reason is that sometimes
    a service’s database (or data model) doesn’t efficiently support the query.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您刚才看到的，实现从多个服务中检索数据的查询可能具有挑战性。但即使是针对单个服务的本地查询也可能很难实现。这可能有几个原因。一方面，正如稍后讨论的，有时拥有数据的服务的实现查询可能并不合适。另一个原因是，有时一个服务的数据库（或数据模型）不支持查询的效率。
- en: Consider, for example, the `findAvailableRestaurants()` query operation. This
    query finds the restaurants that are available to deliver to a given address at
    a given time. The heart of this query is a geospatial (location-based) search
    for restaurants that are within a certain distance of the delivery address. It’s
    a critical part of the order process and is invoked by the UI module that displays
    the available restaurants.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以`findAvailableRestaurants()`查询操作为例。这个查询操作找到在特定时间可以配送至指定地址的餐厅。这个查询的核心是针对位于配送地址一定距离内的餐厅的地理空间（基于位置）搜索。它是订单流程的关键部分，并由显示可用餐厅的UI模块调用。
- en: The key challenge when implementing this query operation is performing an efficient
    geospatial query. How you implement the `findAvailableRestaurants()` query depends
    on the capabilities of the database that stores the restaurants. For example,
    it’s straightforward to implement the `findAvailableRestaurants()` query using
    either MongoDB or the Postgres and MySQL geospatial extensions. These databases
    support geospatial datatypes, indexes, and queries. When using one of these databases,
    `Restaurant Service` persists a `Restaurant` as a database record that has a `location`
    attribute. It finds the available restaurants using a geospatial query that’s
    optimized by a geospatial index on the `location` attribute.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此查询操作时的主要挑战是执行高效的地理空间查询。如何实现`findAvailableRestaurants()`查询取决于存储餐厅的数据库的功能。例如，使用MongoDB或Postgres和MySQL的地理空间扩展来实现`findAvailableRestaurants()`查询非常直接。这些数据库支持地理空间数据类型、索引和查询。当使用这些数据库之一时，`Restaurant
    Service`将`Restaurant`作为一个具有`location`属性的数据库记录持久化。它通过在`location`属性上的地理空间索引优化来执行地理空间查询以找到可用的餐厅。
- en: If the FTGO application stores restaurants in some other kind of database, implementing
    the `findAvailableRestaurant()` query is more challenging. It must maintain a
    replica of the restaurant data in a form that’s designed to support the geospatial
    query. The application could, for example, use the Geospatial Indexing Library
    for DynamoDB ([https://github.com/awslabs/dynamodb-geo](https://github.com/awslabs/dynamodb-geo))
    that uses a table as a geospatial index. Alternatively, the application could
    store a replica of the restaurant data in an entirely different type of database,
    a situation very similar to using a text search database for text queries.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果FTGO应用程序在某种其他类型的数据库中存储餐厅信息，实现`findAvailableRestaurant()`查询将更具挑战性。它必须以支持地理空间查询的形式维护餐厅数据的副本。例如，应用程序可以使用DynamoDB的地理空间索引库([https://github.com/awslabs/dynamodb-geo](https://github.com/awslabs/dynamodb-geo))，该库使用表作为地理空间索引。或者，应用程序可以将餐厅数据的副本存储在完全不同类型的数据库中，这种情况与使用文本搜索数据库进行文本查询非常相似。
- en: The challenge with using replicas is keeping them up-to-date whenever the original
    data changes. As you’ll learn below, CQRS solves the problem of synchronizing
    replicas.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用副本的挑战在于，每当原始数据发生变化时，都需要保持副本的更新。正如你下面将要学到的，CQRS解决了同步副本的问题。
- en: The need to separate concerns
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 需要分离关注点
- en: Another reason why single service queries are challenging to implement is that
    sometimes the service that owns the data shouldn’t be the one that implements
    the query. The `findAvailableRestaurants()` query operation retrieves data that
    is owned by `Restaurant Service`. This service enables restaurant owners to manage
    their restaurant’s profile and menu items. It stores various attributes of a restaurant,
    including its name, address, cuisines, menu, and opening hours. Given that this
    service owns the data, it makes sense, at least on the surface, for it to implement
    this query operation. But data ownership isn’t the only factor to consider.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 单一服务查询难以实现的另一个原因是，有时拥有数据的服务不应该是实现查询的服务。`findAvailableRestaurants()`查询操作检索由`Restaurant
    Service`拥有的数据。该服务使餐厅老板能够管理他们的餐厅资料和菜单项。它存储餐厅的各种属性，包括其名称、地址、菜系、菜单和营业时间。鉴于该服务拥有数据，至少表面上，它实现此查询操作是有意义的。但数据所有权并不是唯一需要考虑的因素。
- en: You must also take into account the need to separate concerns and avoid overloading
    services with too many responsibilities. For example, the primary responsibility
    of the team that develops `Restaurant Service` is enabling restaurant managers
    to maintain their restaurants. That’s quite different from implementing a high-volume,
    critical query. What’s more, if they were responsible for the `findAvailableRestaurants()`
    query operation, the team would constantly live in fear of deploying a change
    that prevented consumers from placing orders.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须考虑到需要分离关注点，避免因过多的责任而使服务过载。例如，开发`Restaurant Service`团队的 主要责任是使餐厅经理能够维护他们的餐厅。这与实现高流量、关键查询截然不同。更重要的是，如果他们负责`findAvailableRestaurants()`查询操作，团队将不断生活在担心部署更改阻止消费者下订单的恐惧中。
- en: It makes sense for `Restaurant Service` to merely provide the restaurant data
    to another service that implements the `findAvailableRestaurants()` query operation
    and is most likely owned by the `Order Service` team. As with the `findOrderHistory()`
    query operation, and when needing to maintain geospatial index, there’s a requirement
    to maintain an eventually consistent replica of some data in order to implement
    a query. Let’s look at how to accomplish that using CQRS.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Restaurant Service`来说，仅仅将餐厅数据提供给另一个实现`findAvailableRestaurants()`查询操作的服务是有意义的，而这个服务很可能由`Order
    Service`团队拥有。正如`findOrderHistory()`查询操作一样，在需要维护地理空间索引时，需要维护一些数据的最终一致副本以实现查询。让我们看看如何使用CQRS来完成这个任务。
- en: 7.2.2\. Overview of CQRS
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2. CQRS概述
- en: 'The examples described in [section 7.2.1](#ch07lev2sec6) highlighted three
    problems that are commonly encountered when implementing queries in a microservice
    architecture:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在[7.2.1节](#ch07lev2sec6)中描述的示例突出了在微服务架构中实现查询时常见的三个问题：
- en: Using the API composition pattern to retrieve data scattered across multiple
    services results in expensive, inefficient in-memory joins.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用API组合模式检索分散在多个服务中的数据会导致昂贵的、低效的内存连接。
- en: The service that owns the data stores the data in a form or in a database that
    doesn’t efficiently support the required query.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有数据的该服务以某种形式或数据库存储数据，该数据库不支持所需的查询操作。
- en: The need to separate concerns means that the service that owns the data isn’t
    the service that should implement the query operation.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要分离关注点意味着拥有数据的该服务不应该是实现查询操作的服务。
- en: The solution to all three of these problems is to use the CQRS pattern.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这三个问题的解决方案是使用CQRS模式。
- en: CQRS separates commands from queries
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: CQRS将命令与查询分离
- en: 'Command Query Responsibility Segregation, as the name suggests, is all about
    *segregation*, or the separation of concerns. As [figure 7.8](#ch07fig08) shows,
    it splits a persistent data model and the modules that use it into two parts:
    the command side and the query side. The command side modules and data model implement
    create, update, and delete operations (abbreviated CUD—for example, HTTP POSTs,
    PUTs, and DELETEs). The query-side modules and data model implement queries (such
    as HTTP GETs). The query side keeps its data model synchronized with the command-side
    data model by subscribing to the events published by the command side.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 命令查询责任分离（Command Query Responsibility Segregation），正如其名称所暗示的，完全是关于*分离*，即关注点的分离。如图7.8[图7.8](#ch07fig08)所示，它将持久数据模型及其使用的模块分为两部分：命令端和查询端。命令端模块和数据模型实现创建、更新和删除操作（简称CUD——例如，HTTP
    POSTs、PUTs和DELETEs）。查询端模块和数据模型实现查询（例如HTTP GETs）。查询端通过订阅命令端发布的事件来保持其数据模型与命令端数据模型的同步。
- en: Figure 7.8\. On the left is the non-CQRS version of the service, and on the
    right is the CQRS version. CQRS restructures a service into command-side and query-side
    modules, which have separate databases.
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.8.左侧是非CQRS版本的服务，右侧是CQRS版本。CQRS将服务重构为命令端和查询端模块，它们具有独立的数据库。
- en: '![](Images/07fig08_alt.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig08_alt.jpg)'
- en: Both the non-CQRS and CQRS versions of the service have an API consisting of
    various CRUD operations. In a non-CQRS-based service, those operations are typically
    implemented by a domain model that’s mapped to a database. For performance, a
    few queries might bypass the domain model and access the database directly. A
    single persistent data model supports both commands and queries.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务的非CQRS和CQRS版本都有一个由各种CRUD操作组成的API。在非CQRS基于的服务中，这些操作通常由映射到数据库的领域模型实现。为了性能，一些查询可能会绕过领域模型直接访问数据库。单一持久数据模型支持命令和查询。
- en: In a CQRS-based service, the command-side domain model handles CRUD operations
    and is mapped to its own database. It may also handle simple queries, such as
    non-join, primary key-based queries. The command side publishes domain events
    whenever its data changes. These events might be published using a framework such
    as Eventuate Tram or using event sourcing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于CQRS的服务中，命令端领域模型处理CRUD操作，并映射到其自己的数据库。它也可能处理简单的查询，例如非连接、基于主键的查询。命令端在其数据更改时发布领域事件。这些事件可能通过Eventuate
    Tram或事件溯源等框架发布。
- en: A separate query model handles the nontrivial queries. It’s much simpler than
    the command side because it’s not responsible for implementing the business rules.
    The query side uses whatever kind of database makes sense for the queries that
    it must support. The query side has event handlers that subscribe to domain events
    and update the database or databases. There may even be multiple query models,
    one for each type of query.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个独立的查询模型处理非平凡查询。它比命令端简单得多，因为它不负责实现业务规则。查询端使用对它必须支持的查询有意义的任何类型的数据库。查询端有事件处理器，它们订阅领域事件并更新数据库或数据库。甚至可能有多个查询模型，每个模型对应于查询的一种类型。
- en: CQRS and query-only services
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: CQRS 和仅查询服务
- en: Not only can CQRS be applied within a service, but you can also use this pattern
    to define query services. A query service has an API consisting of only query
    operations—no command operations. It implements the query operations by querying
    a database that it keeps up-to-date by subscribing to events published by one
    or more other services. A query-side service is a good way to implement a view
    that’s built by subscribing to events published by multiple services. This kind
    of view doesn’t belong to any particular service, so it makes sense to implement
    it as a standalone service. A good example of such a service is `Order History
    Service`, which is a query service that implements the `findOrderHistory()` query
    operation. As [figure 7.9](#ch07fig09) shows, this service subscribes to events
    published by several services, including `Order Service`, `Delivery Service`,
    and so on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以在服务内部应用 CQRS，而且还可以使用此模式来定义查询服务。查询服务有一个仅包含查询操作的 API——没有命令操作。它通过查询一个数据库来实现查询操作，该数据库通过订阅一个或多个其他服务发布的事件来保持最新。查询端服务是实施通过订阅多个服务发布的事件构建的视图的好方法。这种视图不属于任何特定服务，因此将其作为独立服务实现是有意义的。此类服务的良好示例是
    `订单历史服务`，这是一个实现 `findOrderHistory()` 查询操作的查询服务。如图 7.9 所示，此服务订阅了包括 `订单服务`、`配送服务`
    等在内的多个服务发布的事件。
- en: Figure 7.9\. The design of `Order History Service`, which is a query-side service.
    It implements the `findOrderHistory()` query operation by querying a database,
    which it maintains by subscribing to events published by multiple other services.
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.9。`订单历史服务` 的设计，它是一个查询端服务。它通过查询数据库来实现 `findOrderHistory()` 查询操作，该数据库通过订阅多个其他服务发布的事件来维护。
- en: '![](Images/07fig09_alt.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9](Images/07fig09_alt.jpg)'
- en: '`Order History Service` has event handlers that subscribe to events published
    by several services and update the `Order History View Database`. I describe the
    implementation of this service in more detail in [section 7.4](#ch07lev1sec4).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`订单历史服务` 有事件处理器，它们订阅由多个服务发布的事件，并更新 `订单历史视图数据库`。我在 [第 7.4 节](#ch07lev1sec4)
    中更详细地描述了此服务的实现。'
- en: A query service is also a good way to implement a view that replicates data
    owned by a single service yet because of the need to separate concerns isn’t part
    of that service. For example, the FTGO developers can define an `Available Restaurants
    Service`, which implements the `findAvailableRestaurants()` query operation described
    earlier. It subscribes to events published by `Restaurant Service` and updates
    a database designed for efficient geospatial queries.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 查询服务也是实现一个复制单个服务拥有的数据的视图的好方法，但由于需要分离关注点，它并不属于该服务的一部分。例如，FTGO 开发者可以定义一个 `可用餐厅服务`，该服务实现了前面描述的
    `findAvailableRestaurants()` 查询操作。它订阅由 `餐厅服务` 发布的事件，并更新一个专为高效地理空间查询设计的数据库。
- en: In many ways, CQRS is an event-based generalization of the popular approach
    of using RDBMS as the system of record and a text search engine, such as Elasticsearch,
    to handle text queries. What’s different is that CQRS uses a broader range of
    database types—not just a text search engine. Also, CQRS query-side views are
    updated in near real time by subscribing to events.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，CQRS 是一种基于事件的通用方法，它将流行的使用 RDBMS 作为记录系统以及文本搜索引擎（如 Elasticsearch）来处理文本查询的方法进行了扩展。不同之处在于，CQRS
    使用了更广泛的数据库类型——不仅仅是文本搜索引擎。此外，CQRS 查询端视图通过订阅事件在近实时更新。
- en: Let’s now look at the benefits and drawbacks of CQRS.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 CQRS 的优点和缺点。
- en: 7.2.3\. The benefits of CQRS
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3. CQRS 的优点
- en: 'CQRS has both benefits and drawbacks. The benefits are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 既有优点也有缺点。其优点如下：
- en: Enables the efficient implementation of queries in a microservice architecture
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使微服务架构中查询的高效实现成为可能
- en: Enables the efficient implementation of diverse queries
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使多样化查询的高效实现成为可能
- en: Makes querying possible in an event sourcing-based application
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于事件源的应用中实现查询成为可能
- en: Improves separation of concerns
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高了关注点的分离
- en: Enables the efficient implementation of queries in a microservice architecture
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在微服务架构中实现查询的高效实现
- en: One benefit of the CQRS pattern is that it efficiently implements queries that
    retrieve data owned by multiple services. As described earlier, using the API
    composition pattern to implement queries sometimes results in expensive, inefficient
    in-memory joins of large datasets. For those queries, it’s more efficient to use
    an easily queried CQRS view that pre-joins the data from two or more services.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 模式的一个好处是它有效地实现了检索多个服务拥有的数据的查询。如前所述，使用 API 组合模式来实现查询有时会导致大型数据集昂贵的、低效的内存连接。对于这些查询，使用一个易于查询的
    CQRS 视图（预先连接来自两个或更多服务的数据）更有效率。
- en: Enables the efficient implementation of diverse queries
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 允许高效地实现多样化的查询
- en: Another benefit of CQRS is that it enables an application or service to efficiently
    implement a diverse set of queries. Attempting to support all queries using a
    single persistent data model is often challenging and in some cases impossible.
    Some NoSQL databases have very limited querying capabilities. Even when a database
    has extensions to support a particular kind of query, using a specialized database
    is often more efficient. The CQRS pattern avoids the limitations of a single datastore
    by defining one or more views, each of which efficiently implements specific queries.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 的另一个好处是它允许应用程序或服务高效地实现一系列不同的查询。尝试使用单个持久数据模型来支持所有查询通常具有挑战性，在某些情况下甚至不可能。一些
    NoSQL 数据库的查询能力非常有限。即使数据库有扩展来支持特定类型的查询，使用专用数据库通常更有效率。CQRS 模式通过定义一个或多个视图来避免单个数据存储的限制，每个视图都有效地实现了特定的查询。
- en: Enables querying in an event sourcing-based application
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在基于事件源的应用中实现查询
- en: CQRS also overcomes a major limitation of event sourcing. An event store only
    supports primary key-based queries. The CQRS pattern addresses this limitation
    by defining one or more views of the aggregates, which are kept up-to-date, by
    subscribing to the streams of events that are published by the event sourcing-based
    aggregates. As a result, an event sourcing-based application invariably uses CQRS.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 还克服了事件源的一个主要限制。事件存储只支持基于主键的查询。CQRS 模式通过定义一个或多个聚合视图来解决这个问题，这些视图通过订阅基于事件源聚合发布的事件流来保持最新状态。因此，基于事件源的应用不可避免地使用
    CQRS。
- en: Improves separation of concerns
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提高了关注点的分离
- en: Another benefit of CQRS is that it separates concerns. A domain model and its
    corresponding persistent data model don’t handle both commands and queries. The
    CQRS pattern defines separate code modules and database schemas for the command
    and query sides of a service. By separating concerns, the command side and query
    side are likely to be simpler and easier to maintain.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 的另一个好处是它分离了关注点。领域模型及其对应的持久数据模型不处理命令和查询。CQRS 模式为服务的命令和查询方面定义了单独的代码模块和数据库模式。通过分离关注点，命令方面和查询方面可能更简单且更容易维护。
- en: Moreover, CQRS enables the service that implements a query to be different than
    the service that owns the data. For example, earlier I described how even though
    `Restaurant Service` owns the data that’s queried by the `findAvailableRestaurants`
    query operation, it makes sense for another service to implement such a critical,
    high-volume query. A CQRS query service maintains a view by subscribing to the
    events published by the service or services that own the data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CQRS 允许实现查询的服务与拥有数据的服务不同。例如，我之前描述了尽管 `Restaurant Service` 拥有 `findAvailableRestaurants`
    查询操作所查询的数据，但由另一个服务实现这样一个关键、高流量的查询是有意义的。CQRS 查询服务通过订阅拥有数据的服务或服务发布的事件来维护一个视图。
- en: 7.2.4\. The drawbacks of CQRS
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.4. CQRS 的缺点
- en: 'Even though CQRS has several benefits, it also has significant drawbacks:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 CQRS 有几个好处，但它也有显著的缺点：
- en: More complex architecture
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更复杂的架构
- en: Dealing with the replication lag
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理复制延迟
- en: Let’s look at these drawbacks, starting with the increased complexity.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些缺点，首先是复杂性增加。
- en: More complex architecture
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更复杂的架构
- en: One drawback of CQRS is that it adds complexity. Developers must write the query-side
    services that update and query the views. There is also the extra operational
    complexity of managing and operating the extra datastores. What’s more, an application
    might use different types of databases, which adds further complexity for both
    developers and operations.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS的一个缺点是它增加了复杂性。开发者必须编写更新和查询视图的查询端服务。还有管理和操作额外数据存储的额外操作复杂性。更重要的是，一个应用程序可能使用不同类型的数据库，这给开发者和运维都增加了进一步的复杂性。
- en: Dealing with the replication lag
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理复制延迟
- en: Another drawback of CQRS is dealing with the “lag” between the command-side
    and the query-side views. As you might expect, there’s delay between when the
    command side publishes an event and when that event is processed by the query
    side and the view updated. A client application that updates an aggregate and
    then immediately queries a view may see the previous version of the aggregate.
    It must often be written in a way that avoids exposing these potential inconsistencies
    to the user.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS的另一个缺点是处理命令端和查询端视图之间的“延迟”。正如你可能预料的那样，当命令端发布事件和该事件被查询端处理以及视图更新之间的延迟。一个更新聚合并立即查询视图的客户端应用可能会看到聚合的旧版本。它必须经常以避免向用户暴露这些潜在的不一致性为前提来编写。
- en: One solution is for the command-side and query-side APIs to supply the client
    with version information that enables it to tell that the query side is out-of-date.
    A client can poll the query-side view until it’s up-to-date. Shortly I’ll discuss
    how the service APIs can enable a client to do this.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是命令端和查询端API向客户端提供版本信息，使其能够知道查询端已过时。客户端可以轮询查询端视图，直到它是最新的。我很快就会讨论服务API如何使客户端能够做到这一点。
- en: A UI application such as a native mobile application or single page JavaScript
    application can handle replication lag by updating its local model once the command
    is successful without issuing a query. It can, for example, update its model using
    data returned by the command. Hopefully, when a user action triggers a query,
    the view will be up-to-date. One drawback of this approach is that the UI code
    may need to duplicate server-side code in order to update its model.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 像原生移动应用或单页JavaScript应用这样的UI应用可以通过在命令成功后更新其本地模型一次来处理复制延迟，而不发出查询。例如，它可以使用命令返回的数据更新其模型。希望当用户操作触发查询时，视图将是最新的。这种方法的缺点是UI代码可能需要复制服务器端代码以更新其模型。
- en: As you can see, CQRS has both benefits and drawbacks. As mentioned earlier,
    you should use the API composition whenever possible and use CQRS only when you
    must.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，CQRS既有优点也有缺点。如前所述，你应该尽可能使用API组合，并在必须时才使用CQRS。
- en: Now that you’ve seen the benefits and drawbacks of CQRS, let’s now look at how
    to design CQRS views.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了CQRS的优点和缺点，让我们现在看看如何设计CQRS视图。
- en: 7.3\. Designing CQRS views
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3. 设计CQRS视图
- en: A CQRS view module has an API consisting of one more query operations. It implements
    these query operations by querying a database that it maintains by subscribing
    to events published by one or more services. As [figure 7.10](#ch07fig10) shows,
    a view module consists of a view database and three submodules.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS视图模块有一个由一个或多个查询操作组成的API。它通过订阅一个或多个服务发布的事件来维护它所查询的数据库，从而实现这些查询操作。如图7.10所示，视图模块由一个视图数据库和三个子模块组成。
- en: Figure 7.10\. The design of a CQRS view module. Event handlers update the view
    database, which is queried by the Query API module.
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.10。CQRS视图模块的设计。事件处理程序更新视图数据库，该数据库被查询API模块查询。
- en: '![](Images/07fig10.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig10.jpg)'
- en: The data access module implements the database access logic. The event handlers
    and query API modules use the data access module to update and query the database.
    The event handlers module subscribes to events and updates the database. The query
    API module implements the query API.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 数据访问模块实现了数据库访问逻辑。事件处理程序模块和查询API模块使用数据访问模块来更新和查询数据库。事件处理程序模块订阅事件并更新数据库。查询API模块实现了查询API。
- en: 'You must make some important design decisions when developing a view module:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发视图模块时，你必须做出一些重要的设计决策：
- en: You must choose a database and design the schema.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须选择一个数据库并设计模式。
- en: When designing the data access module, you must address various issues, including
    ensuring that updates are idempotent and handling concurrent updates.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计数据访问模块时，你必须解决各种问题，包括确保更新是幂等的以及处理并发更新。
- en: When implementing a new view in an existing application or changing the schema
    of an existing application, you must implement a mechanism to efficiently build
    or rebuild the view.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有应用程序中实现新的视图或更改现有应用程序的模式时，您必须实现一个机制来高效地构建或重建视图。
- en: You must decide how to enable a client of the view to cope with the replication
    lag, described earlier.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须决定如何使视图的客户端能够处理前面描述的复制延迟。
- en: Let’s look at each of these issues.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些问题中的每一个。
- en: 7.3.1\. Choosing a view datastore
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1. 选择视图数据存储
- en: A key design decision is the choice of database and the design of the schema.
    The primary purpose of the database and the data model is to efficiently implement
    the view module’s query operations. It’s the characteristics of those queries
    that are the primary consideration when selecting a database. But the database
    must also efficiently implement the update operations performed by the event handlers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键的设计决策是数据库的选择和模式的设计。数据库和数据模型的主要目的是高效地实现视图模块的查询操作。在选择数据库时，主要考虑的是这些查询的特性。但是，数据库也必须高效地实现事件处理器执行的操作更新。
- en: SQL vs. NoSQL databases
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: SQL 与 NoSQL 数据库
- en: 'Not that long ago, there was one type of database to rule them all: the SQL-based
    RDBMS. As the Web grew in popularity, though, various companies discovered that
    an RDBMS couldn’t satisfy their web scale requirements. That led to the creation
    of the so-called NoSQL databases. A *NoSQL database* typically has a limited form
    of transactions and less general querying capabilities. For certain use cases,
    these databases have certain advantages over SQL databases, including a more flexible
    data model and better performance and scalability.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 不久以前，有一种类型的数据库可以统治一切：基于 SQL 的关系型数据库管理系统（RDBMS）。然而，随着网络的普及，各种公司发现 RDBMS 无法满足它们的
    Web 规模需求。这导致了所谓的 NoSQL 数据库的创建。一个 *NoSQL 数据库* 通常具有有限的交易形式和较少的通用查询能力。对于某些用例，这些数据库在
    SQL 数据库之上具有某些优势，包括更灵活的数据模型、更好的性能和可扩展性。
- en: A NoSQL database is often a good choice for a CQRS view, which can leverage
    its strengths and ignore its weaknesses. A CQRS view benefits from the richer
    data model, and performance of a NoSQL database. It’s unaffected by the limitations
    of a NoSQL database, because it only uses simple transactions and executes a fixed
    set of queries.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 CQRS 视图，通常选择一个 NoSQL 数据库是一个不错的选择，这样可以利用其优势并忽略其弱点。CQRS 视图受益于 NoSQL 数据库更丰富的数据模型和性能。它不受
    NoSQL 数据库限制的影响，因为它只使用简单的交易并执行一组固定的查询。
- en: Having said that, sometimes it makes sense to implement a CQRS view using a
    SQL database. A modern RDBMS running on modern hardware has excellent performance.
    Developers, database administrators, and IT operations are, in general, much more
    familiar with SQL databases than they are with NoSQL databases. As mentioned earlier,
    SQL databases often have extensions for non-relational features, such as geospatial
    datatypes and queries. Also, a CQRS view might need to use a SQL database in order
    to support a reporting engine.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如此，有时使用 SQL 数据库来实现 CQRS 视图是有意义的。在现代硬件上运行的现代关系型数据库管理系统（RDBMS）具有出色的性能。开发者、数据库管理员和
    IT 运营人员通常比 NoSQL 数据库更熟悉 SQL 数据库。如前所述，SQL 数据库通常具有非关系型功能的扩展，例如地理空间数据类型和查询。此外，CQRS
    视图可能需要使用 SQL 数据库来支持报告引擎。
- en: As you can see in [table 7.1](#ch07table01), there are lots of different options
    to choose from. And to make the choice even more complicated, the differences
    between the different types of database are starting to blur. For example, MySQL,
    which is an RDBMS, has excellent support for JSON, which is one of the strengths
    of MongoDB, a JSON-style document-oriented database.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[表 7.1](#ch07table01)中可以看到的，有很多不同的选项可供选择。而且为了使选择更加复杂，不同类型数据库之间的差异开始变得模糊。例如，MySQL，作为一个关系型数据库管理系统（RDBMS），对
    JSON 的支持非常出色，这是 MongoDB（一个 JSON 风格的面向文档的数据库）的一个优势。
- en: Table 7.1\. Query-side view stores
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 7.1. 查询端视图存储
- en: '| If you need | Use | Example |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 如果您需要 | 使用 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| PK-based lookup of JSON objects | A document store such as MongoDB or DynamoDB,
    or a key value store such as Redis | Implement order history by maintaining a
    MongoDB document containing the per-customer. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 基于主键的 JSON 对象查找 | 例如 MongoDB 或 DynamoDB 这样的文档存储，或如 Redis 这样的键值存储 | 通过维护包含每个客户的
    MongoDB 文档来实现订单历史记录。|'
- en: '| Query-based lookup of JSON objects | A document store such as MongoDB or
    DynamoDB | Implement customer view using MongoDB or DynamoDB. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 基于查询的 JSON 对象查找 | 例如 MongoDB 或 DynamoDB 这样的文档存储 | 使用 MongoDB 或 DynamoDB 实现客户视图。|'
- en: '| Text queries | A text search engine such as Elasticsearch | Implement text
    search for orders by maintaining a per-order Elasticsearch document. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 文本查询 | 如 Elasticsearch 这样的文本搜索引擎 | 通过维护每个订单的 Elasticsearch 文档来实现订单的文本搜索。|'
- en: '| Graph queries | A graph database such as Neo4j | Implement fraud detection
    by maintaining a graph of customers, orders, and other data. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 图查询 | 如 Neo4j 这样的图数据库 | 通过维护客户、订单和其他数据的图来实现欺诈检测。|'
- en: '| Traditional SQL reporting/BI | An RDBMS | Standard business reports and analytics.
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 传统 SQL 报告/BI | RDBMS | 标准的商业报告和分析。|'
- en: Now that I’ve discussed the different kinds of databases you can use to implement
    a CQRS view, let’s look at the problem of how to efficiently update a view.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我已经讨论了你可以用来实现 CQRS 视图的数据库类型，让我们看看如何高效地更新视图的问题。
- en: Supporting update operations
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 支持更新操作
- en: Besides efficiently implementing queries, the view data model must also efficiently
    implement the update operations executed by the event handlers. Usually, an event
    handler will update or delete a record in the view database using its primary
    key. For example, soon I’ll describe the design of a CQRS view for the `findOrderHistory()`
    query. It stores each `Order` as a database record using the `orderId` as the
    primary key. When this view receives an event from `Order Service`, it can straightforwardly
    update the corresponding record.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了高效地实现查询外，视图数据模型还必须高效地实现事件处理器执行更新操作。通常，事件处理器将使用其主键在视图数据库中更新或删除记录。例如，我很快将描述
    `findOrderHistory()` 查询的 CQRS 视图设计。它使用 `orderId` 作为主键将每个 `Order` 存储为数据库记录。当这个视图从
    `Order Service` 接收到事件时，它可以直接更新相应的记录。
- en: Sometimes, though, it will need to update or delete a record using the equivalent
    of a foreign key. Consider, for instance, the event handlers for `Delivery*` events.
    If there is a one-to-one correspondence between a `Delivery` and an `Order`, then
    `Delivery.id` might be the same as `Order.id`. If it is, then `Delivery*` event
    handlers can easily update the order’s database record.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，它可能需要使用外键的等效方式来更新或删除记录。例如，考虑 `Delivery*` 事件的处理器。如果一个 `Delivery` 与一个 `Order`
    之间存在一对一的对应关系，那么 `Delivery.id` 可能与 `Order.id` 相同。如果是这样，那么 `Delivery*` 事件处理器可以轻松地更新订单的数据库记录。
- en: But suppose a `Delivery` has its own primary key or there is a one-to-many relationship
    between an `Order` and a `Delivery`. Some `Delivery*` events, such as the `DeliveryCreated`
    event, will contain the `orderId`. But other events, such as a `DeliveryPickedUp`
    event, might not. In this scenario, an event handler for `DeliveryPickedUp` will
    need to update the order’s record using the `deliveryId` as the equivalent of
    a foreign key.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设 `Delivery` 有自己的主键，或者 `Order` 与 `Delivery` 之间存在一对多关系。某些 `Delivery*` 事件，如
    `DeliveryCreated` 事件，将包含 `orderId`。但其他事件，如 `DeliveryPickedUp` 事件，可能不会。在这种情况下，`DeliveryPickedUp`
    事件处理器需要使用 `deliveryId` 作为外键的等效方式来更新订单的记录。
- en: Some types of database efficiently support foreign-key-based update operations.
    For example, if you’re using an RDBMS or MongoDB, you create an index on the necessary
    columns. However, non-primary key-based updates are not straightforward when using
    other NOSQL databases. The application will need to maintain some kind of database-specific
    mapping from a foreign key to a primary key in order to determine which record
    to update. For example, an application that uses DynamoDB, which only supports
    primary key-based updates and deletes, must first query a DynamoDB secondary index
    (discussed shortly) to determine the primary keys of the items to update or delete.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类型的数据库有效地支持基于外键的更新操作。例如，如果你使用的是 RDBMS 或 MongoDB，你将在必要的列上创建索引。然而，当使用其他 NoSQL
    数据库时，非主键的更新并不直接。应用程序需要维护某种数据库特定的映射，从外键到主键，以便确定要更新的记录。例如，使用仅支持基于主键的更新和删除的 DynamoDB
    的应用程序必须首先查询 DynamoDB 的辅助索引（稍后讨论），以确定要更新或删除的项目的主键。
- en: 7.3.2\. Data access module design
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2. 数据访问模块设计
- en: The event handlers and the query API module don’t access the datastore directly.
    Instead they use the data access module, which consists of a data access object
    (DAO) and its helper classes. The DAO has several responsibilities. It implements
    the update operations invoked by the event handlers and the query operations invoked
    by the query module. The DAO maps between the data types used by the higher-level
    code and the database API. It also must handle concurrent updates and ensure that
    updates are idempotent.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器和查询API模块不直接访问数据存储。相反，它们使用数据访问模块，该模块由一个数据访问对象（DAO）及其辅助类组成。DAO有几个职责。它实现了由事件处理器调用的更新操作和由查询模块调用的查询操作。DAO在高级代码使用的数据类型和数据库API之间进行映射。它还必须处理并发更新并确保更新是幂等的。
- en: Let’s look at these issues, starting with how to handle concurrent updates.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些问题，从如何处理并发更新开始。
- en: Handling concurrency
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理并发
- en: Sometimes a DAO must handle the possibility of multiple concurrent updates to
    the same database record. If a view subscribes to events published by a single
    aggregate type, there won’t be any concurrency issues. That’s because events published
    by a particular aggregate instance are processed sequentially. As a result, a
    record corresponding to an aggregate instance won’t be updated concurrently. But
    if a view subscribes to events published by multiple aggregate types, then it’s
    possible that multiple events handlers update the same record simultaneously.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有时DAO必须处理对同一数据库记录进行多次并发更新的可能性。如果一个视图订阅了单个聚合类型发布的事件，将不会出现任何并发问题。这是因为特定聚合实例发布的事件是顺序处理的。因此，对应于聚合实例的记录不会同时更新。但是，如果一个视图订阅了多个聚合类型发布的事件，那么可能多个事件处理器会同时更新相同的记录。
- en: For example, an event handler for an `Order*` event might be invoked at the
    same time as an event handler for a `Delivery*` event for the same order. Both
    event handlers then simultaneously invoke the DAO to update the database record
    for that `Order.` A DAO must be written in a way that ensures that this situation
    is handled correctly. It must not allow one update to overwrite another. If a
    DAO implements updates by reading a record and then writing the updated record,
    it must use either pessimistic or optimistic locking. In the next section you’ll
    see an example of a DAO that handles concurrent updates by updating database records
    without reading them first.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个针对 `Order*` 事件的处理器可能同时被同一个订单的 `Delivery*` 事件的处理器调用。然后这两个事件处理器同时调用DAO来更新该
    `Order` 的数据库记录。DAO必须以正确处理这种情况的方式编写。它不能允许一个更新覆盖另一个更新。如果DAO通过读取记录然后写入更新后的记录来实现更新，它必须使用悲观锁或乐观锁。在下一节中，您将看到一个通过不先读取数据库记录来更新数据库记录以处理并发更新的DAO的示例。
- en: Idempotent event handlers
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 幂等事件处理器
- en: 'As mentioned in [chapter 3](kindle_split_011.xhtml#ch03), an event handler
    may be invoked with the same event more than once. This is generally not a problem
    if a query-side event handler is idempotent. An event handler is idempotent if
    handling duplicate events results in the correct outcome. In the worst case, the
    view datastore will temporarily be out-of-date. For example, an event handler
    that maintains the `Order History` view might be invoked with the (admittedly
    improbable) sequence of events shown in [figure 7.11](#ch07fig11): `DeliveryPickedUp`,
    `DeliveryDelivered`, `DeliveryPickedUp`, and `DeliveryDelivered`. After delivering
    the `DeliveryPickedUp` and `DeliveryDelivered` events the first time, the message
    broker, perhaps because of a network error, starts delivering the events from
    an earlier point in time, and so redelivers `DeliveryPickedUp` and `DeliveryDelivered`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第3章](kindle_split_011.xhtml#ch03)所述，一个事件处理器可能被同一个事件多次调用。如果查询端事件处理器是幂等的，这通常不是问题。一个事件处理器是幂等的，如果处理重复事件会导致正确的结果。在最坏的情况下，视图数据存储将暂时过时。例如，维护
    `Order History` 视图的事件处理器可能被（虽然可能性极低）以下事件序列调用：`DeliveryPickedUp`、`DeliveryDelivered`、`DeliveryPickedUp`
    和 `DeliveryDelivered`。在第一次发送 `DeliveryPickedUp` 和 `DeliveryDelivered` 事件后，消息代理，可能是因为网络错误，开始从较早的时间点发送事件，因此重新发送
    `DeliveryPickedUp` 和 `DeliveryDelivered`。
- en: Figure 7.11\. The `DeliveryPickedUp` and `DeliveryDelivered` events are delivered
    twice, which causes the order state in view to be temporarily out-of-date.
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.11. `DeliveryPickedUp` 和 `DeliveryDelivered` 事件被发送了两次，这导致视图中的订单状态暂时过时。
- en: '![](Images/07fig11_alt.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11](Images/07fig11_alt.jpg)'
- en: After the event handler processes the second `DeliveryPickedUp` event, the `Order
    History` view temporarily contains the out-of-date state of the `Order` until
    the `DeliveryDelivered` is processed. If this behavior is undesirable, then the
    event handler should detect and discard duplicate events, like a non-idempotent
    event handler.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件处理器处理第二个`DeliveryPickedUp`事件之后，`订单历史`视图暂时包含`订单`的过时状态，直到处理了`DeliveryDelivered`。如果这种行为不可取，那么事件处理器应该检测并丢弃重复的事件，就像非幂等事件处理器一样。
- en: An event handler isn’t idempotent if duplicate events result in an incorrect
    outcome. For example, an event handler that increments the balance of a bank account
    isn’t idempotent. A non-idempotent event handler must, as explained in [chapter
    3](kindle_split_011.xhtml#ch03), detect and discard duplicate events by recording
    the IDs of events that it has processed in the view datastore.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重复的事件导致结果不正确，则事件处理器不是幂等的。例如，增加银行账户余额的事件处理器不是幂等的。非幂等事件处理器必须，如第3章所述，通过记录它在视图数据存储中处理的事件的ID来检测和丢弃重复的事件。
- en: In order to be reliable, the event handler must record the event ID and update
    the datastore atomically. How to do this depends on the type of database. If the
    view database store is a SQL database, the event handler could insert processed
    events into a `PROCESSED_EVENTS` table as part of the transaction that updates
    the view. But if the view datastore is a NoSQL database that has a limited transaction
    model, the event handler must save the event in the datastore “record” (for example,
    a MongoDB document or DynamoDB table item) that it updates.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可靠，事件处理器必须记录事件ID并以原子方式更新数据存储。如何做这取决于数据库类型。如果视图数据库存储是SQL数据库，事件处理器可以在更新视图的事务中插入已处理的事件到`PROCESSED_EVENTS`表。但如果视图数据存储是具有有限事务模型的NoSQL数据库，事件处理器必须在它更新的数据存储“记录”（例如，MongoDB文档或DynamoDB表项）中保存事件。
- en: It’s important to note that the event handler doesn’t need to record the ID
    of every event. If, as is the case with Eventuate, events have a monotonically
    increasing ID, then each record only needs to store the `max(eventId)` that’s
    received from a given aggregate instance. Furthermore, if the record corresponds
    to a single aggregate instance, then the event handler only needs to record `max(eventId)`.
    Only records that represent joins of events from multiple aggregates must contain
    a map from `[aggregate type, aggregate id]` to `max(eventId)`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，事件处理器不需要记录每个事件的ID。如果，像Eventuate那样，事件具有单调递增的ID，那么每个记录只需要存储从给定的聚合实例接收到的`max(eventId)`。此外，如果记录对应于单个聚合实例，那么事件处理器只需要记录`max(eventId)`。只有代表来自多个聚合的事件连接的记录必须包含从`[aggregate
    type, aggregate id]`到`max(eventId)`的映射。
- en: 'For example, you’ll soon see that the DynamoDB implementation of the `Order
    History` view contains items that have attributes for tracking events that look
    like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你很快就会看到`订单历史`视图的DynamoDB实现包含具有跟踪事件的属性，这些属性看起来像这样：
- en: '[PRE0]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This view is a join of events published by various services. The name of each
    of these event-tracking attributes is `«aggregateType»«aggregateId»`, and the
    value is the `eventId`. Later on, I describe how this works in more detail.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图是各种服务发布的事件的连接。这些事件跟踪属性的名称是`«aggregateType»«aggregateId»`，其值是`eventId`。稍后我将更详细地描述它是如何工作的。
- en: Enabling a client application to use an eventually consistent view
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 启用客户端应用程序使用最终一致视图
- en: As I said earlier, one issue with using CQRS is that a client that updates the
    command side and then immediately executes a query might not see its own update.
    The view is eventually consistent because of the unavoidable latency of the messaging
    infrastructure.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，使用CQRS的一个问题是，更新命令端并立即执行查询的客户端可能看不到自己的更新。视图最终一致是因为消息基础设施不可避免的延迟。
- en: The command and query module APIs can enable the client to detect an inconsistency
    using the following approach. A command-side operation returns a token containing
    the ID of the published event to the client. The client then passes the token
    to a query operation, which returns an error if the view hasn’t been updated by
    that event. A view module can implement this mechanism using the duplicate event-detection
    mechanism.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 命令和查询模块API可以使客户端通过以下方法检测不一致。命令端操作返回一个包含已发布事件ID的令牌给客户端。然后客户端将令牌传递给查询操作，如果视图尚未被该事件更新，则查询操作返回错误。视图模块可以使用重复事件检测机制实现此机制。
- en: 7.3.3\. Adding and updating CQRS views
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.3. 添加和更新 CQRS 视图
- en: CQRS views will be added and updated throughout the lifetime of an application.
    Sometimes you need to add a new view to support a new query. At other times you
    might need to re-create a view because the schema has changed or you need to fix
    a bug in code that updates the view.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 视图将在应用程序的生命周期内添加和更新。有时你需要添加一个新的视图来支持新的查询。在其他时候，你可能需要重新创建视图，因为模式已更改或需要修复更新视图的代码中的错误。
- en: 'Adding and updating views is conceptually quite simple. To create a new view,
    you develop the query-side module, set up the datastore, and deploy the service.
    The query side module’s event handlers process all the events, and eventually
    the view will be up-to-date. Similarly, updating an existing view is also conceptually
    simple: you change the event handlers and rebuild the view from scratch. The problem,
    however, is that this approach is unlikely to work in practice. Let’s look at
    the issues.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和更新视图在概念上相当简单。要创建一个新的视图，你需要开发查询模块，设置数据存储，并部署服务。查询模块的事件处理器处理所有事件，最终视图将是最新的。同样，更新现有视图在概念上也很简单：你更改事件处理器并从头开始重建视图。然而，问题在于这种方法在实践中可能不起作用。让我们看看问题所在。
- en: Build CQRS views using archived events
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用归档事件构建 CQRS 视图
- en: One problem is that message brokers can’t store messages indefinitely. Traditional
    message brokers such as RabbitMQ delete a message once it’s been processed by
    a consumer. Even more modern brokers such as Apache Kafka, that retain messages
    for a configurable retention period, aren’t intended to store events indefinitely.
    As a result, a view can’t be built by only reading all the needed events from
    the message broker. Instead, an application must also read older events that have
    been archived in, for example, AWS S3\. You can do this by using a scalable big
    data technology such as Apache Spark.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是消息代理不能无限期地存储消息。传统的消息代理，如 RabbitMQ，一旦消费者处理了消息就会删除该消息。甚至更现代的代理，如 Apache Kafka，虽然可以保留消息一段时间，但并不是为了无限期地存储事件。因此，不能仅通过从消息代理中读取所有所需事件来构建视图。相反，应用程序还必须读取存档在例如
    AWS S3 中的较旧事件。你可以通过使用可扩展的大数据技术，如 Apache Spark，来实现这一点。
- en: Build CQRS views incrementally
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 逐步构建 CQRS 视图
- en: Another problem with view creation is that the time and resources required to
    process all events keep growing over time. Eventually, view creation will become
    too slow and expensive. The solution is to use a two-step incremental algorithm.
    The first step periodically computes a snapshot of each aggregate instance based
    on its previous snapshot and events that have occurred since that snapshot was
    created. The second step creates a view using the snapshots and any subsequent
    events.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 视图创建的另一个问题是，处理所有事件所需的时间和资源会随着时间的推移而不断增加。最终，视图创建将变得过于缓慢且成本高昂。解决方案是使用两步增量算法。第一步基于每个聚合实例的先前快照以及自该快照创建以来发生的事件，定期计算每个聚合实例的快照。第二步使用这些快照和任何后续事件创建视图。
- en: 7.4\. Implementing a CQRS view with AWS DynamoDB
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4. 实现使用 AWS DynamoDB 的 CQRS 视图
- en: Now that we’ve looked at the various design issues you must address when using
    CQRS, let’s consider an example. This section describes how to implement a CQRS
    view for the `findOrderHistory()` operation using DynamoDB. AWS DynamoDB is a
    scalable, NoSQL database that’s available as a service on the Amazon cloud. The
    DynamoDB data model consists of tables that contain items that, like JSON objects,
    are collections of hierarchical name-value pairs. AWS DynamoDB is a fully managed
    database, and you can scale the throughput capacity of a table up and down dynamically.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了在使用 CQRS 时必须解决的各个设计问题，让我们考虑一个例子。本节描述了如何使用 DynamoDB 实现针对 `findOrderHistory()`
    操作的 CQRS 视图。AWS DynamoDB 是一种可扩展的 NoSQL 数据库，可在亚马逊云上作为一项服务提供。DynamoDB 数据模型由包含项的表组成，这些项类似于
    JSON 对象，是层次结构化的名称-值对的集合。AWS DynamoDB 是一个完全管理的数据库，你可以动态地上下调整表的吞吐量容量。
- en: 'The CQRS view for the `findOrderHistory()` consumes events from multiple services,
    so it’s implemented as a standalone `Order View Service`. The service has an API
    that implements two operations: `findOrderHistory()` and `findOrder()`. Even though
    `findOrder()` can be implemented using API composition, this view provides this
    operation for free. [Figure 7.12](#ch07fig12) shows the design of the service.
    `Order History Service` is structured as a set of modules, each of which implements
    a particular responsibility in order to simplify development and testing. The
    responsibility of each module is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOrderHistory()` 的 CQRS 视图从多个服务消费事件，因此它被实现为一个独立的 `Order View Service`。该服务有一个
    API，实现了两个操作：`findOrderHistory()` 和 `findOrder()`。尽管 `findOrder()` 可以通过 API 组合来实现，但这个视图免费提供了这个操作。[图
    7.12](#ch07fig12) 展示了该服务的架构。`Order History Service` 被构建为一组模块，每个模块都实现特定的职责，以简化开发和测试。每个模块的职责如下：'
- en: '`OrderHistoryEventHandlers`—Subscribes to events published by the various services
    and invokes the `OrderHistoryDAO`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderHistoryEventHandlers`—订阅由各种服务发布的事件并调用 `OrderHistoryDAO`'
- en: '`OrderHistoryQuery API` *module*—Implements the REST endpoints described earlier'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderHistoryQuery API` *模块*—实现了之前描述的 REST 端点'
- en: '`OrderHistoryDataAccess`—Contains the `OrderHistoryDAO`, which defines the
    methods that update and query the `ftgo-order-history` DynamoDB table and its
    helper classes'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderHistoryDataAccess`—包含 `OrderHistoryDAO`，它定义了更新和查询 `ftgo-order-history`
    DynamoDB 表及其辅助类的方法'
- en: '`ftgo-order-history` *DynamoDB table*—The table that stores the orders'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ftgo-order-history` *DynamoDB 表*—存储订单的表'
- en: Figure 7.12\. The design of `OrderHistoryService`. `OrderHistoryEventHandlers`
    updates the database in response to events. The `OrderHistoryQuery` module implements
    the query operations by querying the database. These two modules use the `OrderHistoryDataAccess`
    module to access the database.
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.12\. `OrderHistoryService` 的设计。`OrderHistoryEventHandlers` 在响应事件时更新数据库。`OrderHistoryQuery`
    模块通过查询数据库来实现查询操作。这两个模块使用 `OrderHistoryDataAccess` 模块来访问数据库。
- en: '![](Images/07fig12_alt.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig12_alt.jpg)'
- en: Let’s look at the design of the event handlers, the DAO, and the DynamoDB table
    in more detail.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看事件处理器、DAO 和 DynamoDB 表的设计。
- en: 7.4.1\. The OrderHistoryEventHandlers module
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.1\. `OrderHistoryEventHandlers` 模块
- en: This module consists of the event handlers that consume events and update the
    DynamoDB table. As the following listing shows, the event handlers are simple
    methods. Each method is a one-liner that invokes an `OrderHistoryDao` method with
    arguments that are derived from the event.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块由消费事件并更新 DynamoDB 表的事件处理器组成。如下所示，事件处理器是简单的函数。每个方法都是一行代码，它调用 `OrderHistoryDao`
    方法，并使用从事件中派生的参数。
- en: Listing 7.1\. Event handlers that call the `OrderHistoryDao`
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. 调用 `OrderHistoryDao` 的事件处理器
- en: '[PRE1]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each event handler has a single parameter of type `DomainEventEnvelope`, which
    contains the event and some metadata describing the event. For example, the `handleOrderCreated()`
    method is invoked to handle an `OrderCreated` event. It calls `orderHistoryDao.addOrder()`
    to create an `Order` in the database. Similarly, the `handleDeliveryPickedUp()`
    method is invoked to handle a `DeliveryPickedUp` event. It calls `orderHistoryDao.notePickedUp()`
    to update the status of the `Order` in the database.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件处理器有一个类型为 `DomainEventEnvelope` 的单个参数，它包含事件和一些描述事件的元数据。例如，`handleOrderCreated()`
    方法被调用来处理 `OrderCreated` 事件。它调用 `orderHistoryDao.addOrder()` 在数据库中创建一个 `Order`。同样，`handleDeliveryPickedUp()`
    方法被调用来处理 `DeliveryPickedUp` 事件。它调用 `orderHistoryDao.notePickedUp()` 更新数据库中 `Order`
    的状态。
- en: Both methods call the helper method `makeSourceEvent()`, which constructs a
    `SourceEvent` containing the type and ID of the aggregate that emitted the event
    and the event ID. In the next section you’ll see that `OrderHistoryDao` uses `SourceEvent`
    to ensure that update operations are idempotent.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 两个方法都调用辅助方法 `makeSourceEvent()`，该方法构建一个包含发出事件的聚合类型和 ID 以及事件 ID 的 `SourceEvent`。在下一节中，您将看到
    `OrderHistoryDao` 使用 `SourceEvent` 来确保更新操作是幂等的。
- en: Let’s now look at the design of the DynamoDB table and after that examine `OrderHistoryDao`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看 DynamoDB 表的设计，然后检查 `OrderHistoryDao`。
- en: 7.4.2\. Data modeling and query design with DynamoDB
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.2\. 使用 DynamoDB 进行数据建模和查询设计
- en: 'Like many NoSQL databases, DynamoDB has data access operations that are much
    less powerful than those that are provided by an RDBMS. Consequently, you must
    carefully design how the data is stored. In particular, the queries often dictate
    the design of the schema. We need to address several design issues:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多 NoSQL 数据库一样，DynamoDB 的数据访问操作比 RDBMS 提供的弱得多。因此，您必须仔细设计数据的存储方式。特别是，查询通常决定了模式的设计。我们需要解决几个设计问题：
- en: Designing the `ftgo-order-history` table
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计 `ftgo-order-history` 表
- en: Defining an index for the `findOrderHistory` query
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `findOrderHistory` 查询定义索引
- en: Implementing the `findOrderHistory` query
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `findOrderHistory` 查询
- en: Paginating the query results
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页查询结果
- en: Updating orders
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新订单
- en: Detecting duplicate events
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测重复事件
- en: We’ll look at each one in turn.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐一查看每个问题。
- en: Designing the ftgo-order-history table
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设计 ftgo-order-history 表
- en: The DynamoDB storage model consists of tables, which contain items, and indexes,
    which provide alternative ways to access a table’s items (discussed shortly).
    An *item* is a collection of named attributes. An *attribute value* is either
    a scalar value such as a string, a multivalued collection of strings, or a collection
    of named attributes. Although an item is the equivalent to a row in an RDBMS,
    it’s a lot more flexible and can store an entire aggregate.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB 存储模型由表组成，其中包含项目，以及索引，它们提供了访问表项目的替代方式（稍后讨论）。一个*项目*是一组命名属性。一个*属性值*可以是字符串等标量值，也可以是字符串的多值集合，或者是一组命名属性。尽管一个项目在关系型数据库管理系统（RDBMS）中相当于一行，但它要灵活得多，可以存储整个聚合。
- en: This flexibility enables the `OrderHistoryDataAccess` module to store each `Order`
    as a single item in a DynamoDB table called `ftgo-order-history`. Each field of
    the `Order` class is mapped to an item attribute, as shown in [figure 7.13](#ch07fig13).
    Simple fields such as `orderCreationTime` and `status` are mapped to single-value
    item attributes. The `lineItems` field is mapped to an attribute that is a list
    of maps, one map per time line. It can be considered to be a JSON array of objects.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性使得 `OrderHistoryDataAccess` 模块能够将每个 `Order` 作为单个项目存储在名为 `ftgo-order-history`
    的 DynamoDB 表中。`Order` 类的每个字段都映射到一个项目属性，如图 7.13 所示。[图 7.13](#ch07fig13)。简单的字段，如
    `orderCreationTime` 和 `status`，映射到单值项目属性。`lineItems` 字段映射到一个列表属性，其中每个时间线对应一个映射。它可以被视为对象的
    JSON 数组。
- en: Figure 7.13\. Preliminary structure of the DynamoDB `OrderHistory` table
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.13\. DynamoDB `OrderHistory` 表的初步结构
- en: '![](Images/07fig13_alt.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig13_alt.jpg)'
- en: An important part of the definition of a table is its primary key. A DynamoDB
    application inserts, updates, and retrieves a table’s items by primary key. It
    would seem to make sense for the primary key to be `orderId.` This enables `Order
    History Service` to insert, update, and retrieve an order by `orderId`. But before
    finalizing this decision, let’s first explore how a table’s primary key impacts
    the kinds of data access operations it supports.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 表定义的一个重要部分是其主键。DynamoDB 应用程序通过主键插入、更新和检索表的项目。主键似乎是 `orderId`。这使得 `Order History
    Service` 能够通过 `orderId` 插入、更新和检索订单。但在最终确定这个决定之前，让我们首先探讨表的主键如何影响它支持的数据访问操作类型。
- en: Defining an index for the findOrderHistory query
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为 findOrderHistory 查询定义索引
- en: This table definition supports primary key-based reads and writes of `Orders`.
    But it doesn’t support a query such as `findOrderHistory()` that returns multiple
    matching orders sorted by increasing age. That’s because, as you will see later
    in this section, this query uses the DynamoDB `query()` operation, which requires
    a table to have a composite primary key consisting of two scalar attributes. The
    first attribute is a partition key. The *partition key* is so called because DynamoDB’s
    Z-axis scaling (described in [chapter 1](kindle_split_009.xhtml#ch01)) uses it
    to select an item’s storage partition. The second attribute is the *sort* key.
    A `query()` operation returns those items that have the specified partition key,
    have a sort key in the specified range, and match the optional filter expression.
    It returns items in the order specified by the sort key.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此表定义支持基于主键的`Orders`的读取和写入。但它不支持返回按年龄递增排序的多个匹配订单的`findOrderHistory()`查询。这是因为，正如你将在本节后面看到的那样，此查询使用DynamoDB的`query()`操作，该操作要求表具有由两个标量属性组成的复合主键。第一个属性是分区键。所谓的分区键是因为DynamoDB的Z轴扩展（在第1章中描述）用它来选择一个项目的存储分区。第二个属性是*排序*键。`query()`操作返回具有指定分区键、具有指定范围内的排序键并匹配可选过滤表达式的项目。它按排序键指定的顺序返回项目。
- en: The `findOrderHistory()` query operation returns a consumer’s orders sorted
    by increasing age. It therefore requires a primary key that has the `consumerId`
    as the partition key and the `orderCreationDate` as the sort key. But it doesn’t
    make sense for `(consumerId, orderCreationDate)` to be the primary key of the
    `ftgo-order-history` table, because it’s not unique.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOrderHistory()`查询操作返回按年龄递增排序的消费者订单。因此，它需要一个具有`consumerId`作为分区键和`orderCreationDate`作为排序键的主键。但`(consumerId,
    orderCreationDate)`作为`ftgo-order-history`表的主键没有意义，因为它不是唯一的。'
- en: The solution is for `findOrderHistory()` to query what DynamoDB calls a *secondary
    index* on the `ftgo-order-history` table. This index has `(consumerId, orderCreationDate)`
    as its non-unique key. Like an RDBMS index, a DynamoDB index is automatically
    updated whenever its table is updated. But unlike a typical RDBMS index, a DynamoDB
    index can have non-key attributes. *Non-key attributes* improve performance because
    they’re returned by the query, so the application doesn’t have to fetch them from
    the table. Also, as you’ll soon see, they can be used for filtering. [Figure 7.14](#ch07fig14)
    shows the structure of the table and this index.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是让`findOrderHistory()`查询DynamoDB在`ftgo-order-history`表上称为*二级索引*的内容。此索引的非唯一键为`(consumerId,
    orderCreationDate)`。像RDBMS索引一样，DynamoDB索引在其表更新时自动更新。但与典型的RDBMS索引不同，DynamoDB索引可以具有非键属性。*非键属性*可以提高性能，因为它们由查询返回，所以应用程序不需要从表中获取它们。此外，正如你很快就会看到的那样，它们可以用于过滤。[图7.14](#ch07fig14)显示了表和此索引的结构。
- en: Figure 7.14\. The design of the `OrderHistory` table and index
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.14. `OrderHistory`表和索引的设计
- en: '![](Images/07fig14_alt.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig14_alt.jpg)'
- en: The index is part of the definition of the `ftgo-order-history` table and is
    called `ftgo-order-history-by-consumer-id-and-creation-time`. The index’s attributes
    include the primary key attributes, `consumerId` and `orderCreationTime`, and
    non-key attributes, including `orderId` and `status`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 该索引是`ftgo-order-history`表定义的一部分，称为`ftgo-order-history-by-consumer-id-and-creation-time`。索引的属性包括主键属性`consumerId`和`orderCreationTime`，以及非键属性，包括`orderId`和`status`。
- en: The `ftgo-order-history-by-consumer-id-and-creation-time` index enables the
    `OrderHistoryDaoDynamoDb` to efficiently retrieve a consumer’s orders sorted by
    increasing age.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`ftgo-order-history-by-consumer-id-and-creation-time`索引使`OrderHistoryDaoDynamoDb`能够高效地检索按年龄递增排序的消费者订单。'
- en: Let’s now look at how to retrieve only those orders that match the filter criteria.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看如何检索仅匹配过滤条件的那些订单。
- en: Implementing the findOrderHistory query
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现findOrderHistory查询
- en: The `findOrderHistory()` query operation has a `filter` parameter that specifies
    the search criteria. One filter criterion is the maximum age of the orders to
    return. This is easy to implement because the DynamoDB `Query` operation’s *key
    condition expression* supports a range restriction on the sort key. The other
    filter criteria correspond to non-key attributes and can be implemented using
    a *filter expression*, which is a Boolean expression. A DynamoDB `Query` operation
    returns only those items that satisfy the filter expression. For example, to find
    `Orders` that are `CANCELLED`, the `OrderHistoryDaoDynamoDb` uses a query expression
    `orderStatus = :orderStatus`, where `:orderStatus` is a placeholder parameter.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOrderHistory()`查询操作有一个`filter`参数，它指定了搜索条件。一个过滤器条件是返回的订单的最大年龄。这很容易实现，因为DynamoDB的`Query`操作的支持对排序键的范围限制的*键条件表达式*。其他过滤器条件对应于非键属性，可以使用*过滤器表达式*实现，这是一个布尔表达式。DynamoDB的`Query`操作只返回满足过滤器表达式的项目。例如，为了找到`已取消`的`Orders`，`OrderHistoryDaoDynamoDb`使用查询表达式`orderStatus
    = :orderStatus`，其中`:orderStatus`是一个占位符参数。'
- en: The keyword filter criteria is more challenging to implement. It selects orders
    whose restaurant name or menu items match one of the specified keywords. The `OrderHistoryDaoDynamoDb`
    enables the keyword search by tokenizing the restaurant name and menu items and
    storing the set of keywords in a set-valued attribute called `keywords`. It finds
    the orders that match the keywords by using a filter expression that uses the
    `contains()` function, for example `contains(keywords, :keyword1) OR contains(keywords,
    :keyword2)`, where `:keyword1` and `:keyword2` are placeholders for the specified
    keywords.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字过滤器条件更难实现。它选择那些餐厅名称或菜单项与指定的关键字之一匹配的订单。`OrderHistoryDaoDynamoDb`通过将餐厅名称和菜单项进行分词并将关键字集合存储在一个名为`keywords`的集合值属性中来启用关键字搜索。它通过使用包含`contains()`函数的过滤器表达式来找到匹配关键字的订单，例如`contains(keywords,
    :keyword1) OR contains(keywords, :keyword2)`，其中`:keyword1`和`:keyword2`是特定关键字的占位符。
- en: Paginating the query results
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分页查询结果
- en: Some consumers will have a large number of orders. It makes sense, therefore,
    for the `findOrderHistory()` query operation to use pagination. The DynamoDB `Query`
    operation has an operation `pageSize` parameter, which specifies the maximum number
    of items to return. If there are more items, the result of the query has a non-null
    `LastEvaluatedKey` attribute. A DAO can retrieve the next page of items by invoking
    the query with the `exclusiveStartKey` parameter set to `LastEvaluatedKey`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一些消费者会有大量的订单。因此，对于`findOrderHistory()`查询操作使用分页是有意义的。DynamoDB的`Query`操作有一个`pageSize`参数，它指定了要返回的最大项目数。如果有更多项目，查询的结果将包含一个非空的`LastEvaluatedKey`属性。一个DAO可以通过设置`exclusiveStartKey`参数为`LastEvaluatedKey`来调用查询以检索下一页的项目。
- en: As you can see, DynamoDB doesn’t support position-based pagination. Consequently,
    `Order History Service` returns an opaque pagination token to its client. The
    client uses this pagination token to request the next page of results.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，DynamoDB不支持基于位置的分页。因此，`Order History Service`向其客户端返回一个不透明的分页令牌。客户端使用这个分页令牌来请求下一页的结果。
- en: Now that I’ve described how to query DynamoDB for orders, let’s look at how
    to insert and update them.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经描述了如何查询DynamoDB中的订单，让我们看看如何插入和更新它们。
- en: Updating orders
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新订单
- en: 'DynamoDB supports two operations for adding and updating items: `PutItem()`
    and `UpdateItem()`. The `PutItem()` operation creates or replaces an entire item
    by its primary key. In theory, `OrderHistoryDaoDynamoDb` could use this operation
    to insert and update orders. One challenge, however, with using `PutItem()` is
    ensuring that simultaneous updates to the same item are handled correctly.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB支持两种用于添加和更新项目的操作：`PutItem()`和`UpdateItem()`。`PutItem()`操作通过其主键创建或替换整个项目。理论上，`OrderHistoryDaoDynamoDb`可以使用此操作来插入和更新订单。然而，使用`PutItem()`的一个挑战是确保对同一项目的并发更新被正确处理。
- en: Consider, for example, the scenario where two event handlers simultaneously
    attempt to update the same item. Each event handler calls `OrderHistoryDaoDynamoDb`
    to load the item from DynamoDB, change it in memory, and update it in DynamoDB
    using `PutItem()`. One event handler could potentially overwrite the change made
    by the other event handler. `OrderHistoryDaoDynamoDb` can prevent lost updates
    by using DynamoDB’s optimistic locking mechanism. But an even simpler and more
    efficient approach is to use the `UpdateItem()` operation.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑两个事件处理器同时尝试更新同一项目的场景。每个事件处理器都会调用`OrderHistoryDaoDynamoDb`从DynamoDB加载项目，在内存中更改它，并使用`PutItem()`在DynamoDB中更新它。一个事件处理器可能会覆盖另一个事件处理器所做的更改。`OrderHistoryDaoDynamoDb`可以通过使用DynamoDB的乐观锁定机制来防止更新丢失。但一个更简单、更有效的方法是使用`UpdateItem()`操作。
- en: The `UpdateItem()` operation updates individual attributes of the item, creating
    the item if necessary. Since different event handlers update different attributes
    of the `Order` item, using `UpdateItem` makes sense. This operation is also more
    efficient because there’s no need to first retrieve the order from the table.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateItem()`操作更新项目的单个属性，如果需要则创建项目。由于不同的事件处理器更新`Order`项目的不同属性，因此使用`UpdateItem`是有意义的。此操作也更高效，因为不需要首先从表中检索订单。'
- en: One challenge with updating the database in response to events is, as mentioned
    earlier, detecting and discarding duplicate events. Let’s look at how to do that
    when using DynamoDB.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应事件更新数据库时遇到的挑战之一，如前所述，是检测和丢弃重复事件。让我们看看在使用DynamoDB时如何做到这一点。
- en: Detecting duplicate events
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检测重复事件
- en: All of `Order History Service`’s event handlers are idempotent. Each one sets
    one or more attributes of the `Order` item. `Order History Service` could, therefore,
    simply ignore the issue of duplicate events. The downside of ignoring the issue,
    though, is that `Order` item will sometimes be temporarily out-of-date. That’s
    because an event handler that receives a duplicate event will set an `Order` item’s
    attributes to previous values. The `Order` item won’t have the correct values
    until later events are redelivered.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order History Service`的所有事件处理器都是幂等的。每个处理器都会设置`Order`项目的单个或多个属性。因此，`Order History
    Service`可以简单地忽略重复事件的问题。然而，忽略问题的缺点是`Order`项目有时会暂时过时。这是因为接收重复事件的处理器会将`Order`项目的属性设置为以前的值。`Order`项目将不会具有正确的值，直到稍后的事件重新传递。'
- en: As described earlier, one way to prevent data from becoming out-of-date is to
    detect and discard duplicate events. `OrderHistoryDaoDynamoDb` can detect duplicate
    events by recording in each item the events that have caused it to be updated.
    It can then use the `UpdateItem()` operation’s conditional update mechanism to
    only update an item if an event isn’t a duplicate.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，防止数据过时的方法之一是检测和丢弃重复事件。`OrderHistoryDaoDynamoDb`可以通过在每一项中记录导致其更新的事件来检测重复事件。然后，它可以使用`UpdateItem()`操作的条件更新机制，仅在事件不是重复事件时更新项目。
- en: 'A conditional update is only performed if a *condition expression* is true.
    A *condition expression* tests whether an attribute exists or has a particular
    value. The `OrderHistoryDaoDynamoDb` DAO can track events received from each aggregate
    instance using an attribute called `«aggregateType»«aggregateId»` whose value
    is the highest received event ID. An event is a duplicate if the attribute exists
    and its value is less than or equal to the event ID. The `OrderHistoryDaoDynamoDb`
    DAO uses this condition expression:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当*条件表达式*为真时才执行条件更新。*条件表达式*测试属性是否存在或具有特定值。`OrderHistoryDaoDynamoDb` DAO可以使用一个名为`«aggregateType»«aggregateId»`的属性来跟踪从每个聚合实例接收的事件，其值是接收到的最高事件ID。如果属性存在且其值小于或等于事件ID，则事件是重复的。`OrderHistoryDaoDynamoDb`
    DAO使用以下条件表达式：
- en: '[PRE2]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The *condition expression* only allows the update if the attribute doesn’t exist
    or the `eventId` is greater than the last processed event ID.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件表达式* 仅允许在属性不存在或`eventId`大于最后处理的事件ID时进行更新。'
- en: 'For example, suppose an event handler receives a `DeliveryPickup` event whose
    ID is `123323-343434` from a `Delivery` aggregate whose ID is `3949384394-039434903`.
    The name of the tracking attribute is `Delivery3949384394-039434903`. The event
    handler should consider the event to be a duplicate if the value of this attribute
    is greater than or equal to `123323-343434`. The `query()` operation invoked by
    the event handler updates the `Order` item using this condition expression:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设事件处理器接收来自 ID 为 `3949384394-039434903` 的 `Delivery` 聚合的 ID 为 `123323-343434`
    的 `DeliveryPickup` 事件。跟踪属性名为 `Delivery3949384394-039434903`。如果此属性值大于或等于 `123323-343434`，事件处理器应认为该事件是重复的。事件处理器调用的
    `query()` 操作使用此条件表达式更新 `Order` 项：
- en: '[PRE3]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that I’ve described the DynamoDB data model and query design, let’s take
    a look at `OrderHistoryDaoDynamoDb`, which defines the methods that update and
    query the `ftgo-order-history` table.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经描述了 DynamoDB 数据模型和查询设计，让我们看看 `OrderHistoryDaoDynamoDb`，它定义了更新和查询 `ftgo-order-history`
    表的方法。
- en: 7.4.3\. The OrderHistoryDaoDynamoDb class
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.3\. `OrderHistoryDaoDynamoDb` 类
- en: The `OrderHistoryDaoDynamoDb` class implements methods that read and write items
    in the `ftgo-order-history` table. Its update methods are invoked by `OrderHistoryEventHandlers`,
    and its query methods are invoked by `OrderHistoryQuery API`. Let’s take a look
    at some example methods, starting with the `addOrder()` method.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderHistoryDaoDynamoDb` 类实现了在 `ftgo-order-history` 表中读写项的方法。它的更新方法由 `OrderHistoryEventHandlers`
    调用，而它的查询方法由 `OrderHistoryQuery API` 调用。让我们看看一些示例方法，从 `addOrder()` 方法开始。'
- en: The addOrder() method
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`addOrder()` 方法'
- en: 'The `addOrder()` method, which is shown in [listing 7.2](#ch07ex02), adds an
    order to the `ftgo-order-history` table. It has two parameters: `order` and `sourceEvent`.
    The `order` parameter is the `Order` to add, which is obtained from the `OrderCreated`
    event. The `sourceEvent` parameter contains the `eventId` and the type and ID
    of the aggregate that emitted the event. It’s used to implement the conditional
    update.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [列表 7.2](#ch07ex02) 所示的 `addOrder()` 方法将订单添加到 `ftgo-order-history` 表中。它有两个参数：`order`
    和 `sourceEvent`。`order` 参数是要添加的 `Order`，它从 `OrderCreated` 事件中获取。`sourceEvent`
    参数包含 `eventId` 以及发出事件的聚合的类型和 ID。它用于实现条件更新。
- en: Listing 7.2\. The `addOrder()` method adds or updates an `Order`
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. `addOrder()` 方法添加或更新一个 `Order`
- en: '[PRE4]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* The primary key of the Order item to update**'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 要更新的 Order 项的主键**'
- en: '***2* The update expression that updates the attributes**'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 更新属性的表达式**'
- en: '***3* The values of the placeholders in the update expression**'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 更新表达式中占位符的值**'
- en: The `addOrder()` method creates an `UpdateSpec`, which is part of the AWS SDK
    and describes the update operation. After creating the `UpdateSpec`, it calls
    `idempotentUpdate()`, a helper method that performs the update after adding a
    condition expression that guards against duplicate updates.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`addOrder()` 方法创建一个 `UpdateSpec`，它是 AWS SDK 的一部分，用于描述更新操作。在创建 `UpdateSpec`
    之后，它调用 `idempotentUpdate()`，这是一个辅助方法，在添加防止重复更新的条件表达式后执行更新。'
- en: The notePickedUp() method
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`notePickedUp()` 方法'
- en: The `notePickedUp()` method, shown in [listing 7.3](#ch07ex03), is called by
    the event handler for the `DeliveryPickedUp` event. It changes the `deliveryStatus`
    of the `Order` item to `PICKED_UP`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [列表 7.3](#ch07ex03) 所示的 `notePickedUp()` 方法由 `DeliveryPickedUp` 事件的处理器调用。它将
    `Order` 项的 `deliveryStatus` 更改为 `PICKED_UP`。
- en: Listing 7.3\. The `notePickedUp()` method changes the order status to `PICKED_UP`
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. `notePickedUp()` 方法将订单状态更改为 `PICKED_UP`
- en: '[PRE5]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This method is similar to `addOrder()`. It creates an `UpdateItemSpec` and invokes
    `idempotentUpdate()`. Let’s look at the `idempotentUpdate()` method.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法类似于 `addOrder()`。它创建一个 `UpdateItemSpec` 并调用 `idempotentUpdate()`。让我们看看 `idempotentUpdate()`
    方法。
- en: The idempotentUpdate() method
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`idempotentUpdate()` 方法'
- en: The following listing shows the `idempotentUpdate()` method, which updates the
    item after possibly adding a condition expression to the `UpdateItemSpec` that
    guards against duplicate updates.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 `idempotentUpdate()` 方法，该方法在可能向 `UpdateItemSpec` 添加条件表达式以防止重复更新后更新项。
- en: Listing 7.4\. The `idempotentUpdate()` method ignores duplicate events
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4\. `idempotentUpdate()` 方法忽略重复事件
- en: '[PRE6]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the `sourceEvent` is supplied, `idempotentUpdate()` invokes `SourceEvent.addDuplicateDetection()`
    to add to `UpdateItemSpec` the condition expression that was described earlier.
    The `idempotentUpdate()` method catches and ignores the `ConditionalCheckFailedException`,
    which is thrown by `updateItem()` if the event was a duplicate.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了 `sourceEvent`，`idempotentUpdate()` 将调用 `SourceEvent.addDuplicateDetection()`
    将之前描述的条件表达式添加到 `UpdateItemSpec` 中。`idempotentUpdate()` 方法捕获并忽略由 `updateItem()`
    抛出的 `ConditionalCheckFailedException`，如果事件是重复的。
- en: Now that we’ve seen the code that updates the table, let’s look at the query
    method.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了更新表的代码，让我们看看查询方法。
- en: The findOrderHistory() method
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`findOrderHistory()` 方法'
- en: 'The `findOrderHistory()` method, shown in [listing 7.5](#ch07ex05), retrieves
    the consumer’s orders by querying the `ftgo-order-history` table using the `ftgo-order-history-by-consumer-id-and-creation-time`
    secondary index. It has two parameters: `consumerId` specifies the consumer, and
    `filter` specifies the search criteria. This method creates `QuerySpec`—which,
    like `UpdateSpec`, is part of the AWS SDK—from its parameters, queries the index,
    and transforms the returned items into an `OrderHistory` object.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [列表 7.5](#ch07ex05) 所示的 `findOrderHistory()` 方法通过查询 `ftgo-order-history` 表并使用
    `ftgo-order-history-by-consumer-id-and-creation-time` 次级索引来检索消费者的订单。它有两个参数：`consumerId`
    指定消费者，`filter` 指定搜索条件。此方法从其参数创建 `QuerySpec`（与 `UpdateSpec` 一样，是 AWS SDK 的一部分），查询索引并将返回的项目转换为
    `OrderHistory` 对象。
- en: Listing 7.5\. The `findOrderHistory()` method retrieves a consumer’s matching
    orders
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5\. `findOrderHistory()` 方法检索消费者的匹配订单
- en: '[PRE7]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Specifies that query must return the orders in order of increasing age**'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 指定查询必须按年龄递增的顺序返回订单**'
- en: '***2* The maximum age of the orders to return**'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 返回订单的最大年龄**'
- en: '***3* Construct a filter expression and placeholder value map from the OrderHistoryFilter.**'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 从 `OrderHistoryFilter` 构建一个过滤器表达式和占位符值映射。'
- en: '***4* Limit the number of results if the caller has specified a page size.**'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4** 如果调用者指定了页面大小，则限制结果数量。**'
- en: '***5* Create an Order from an item returned by the query.**'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5** 从查询返回的项目创建一个订单。**'
- en: After building a `QuerySpec`, this method then executes a query and builds an
    `OrderHistory`, which contains the list of `Orders`, from the returned items.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 `QuerySpec` 之后，此方法然后执行查询并从返回的项目构建一个 `OrderHistory`，其中包含 `Orders` 列表。
- en: The `findOrderHistory()` method implements pagination by serializing the value
    returned by `getLastEvaluatedKey()` into a JSON token. If a client specifies a
    start token in `OrderHistoryFilter`, then `findOrderHistory()` serializes it and
    invokes `withExclusiveStartKey()` to set the start key.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOrderHistory()` 方法通过将 `getLastEvaluatedKey()` 返回的值序列化为 JSON 令牌来实现分页。如果客户端在
    `OrderHistoryFilter` 中指定了一个起始令牌，那么 `findOrderHistory()` 将会序列化它并调用 `withExclusiveStartKey()`
    来设置起始键。'
- en: As you can see, you must address numerous issues when implementing a CQRS view,
    including picking a database, designing the data model that efficiently implements
    updates and queries, handling concurrent updates, and dealing with duplicate events.
    The only complex part of the code is the DAO, because it must properly handle
    concurrency and ensure that updates are idempotent.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在实现 CQRS 视图时，你必须解决许多问题，包括选择数据库、设计高效实现更新和查询的数据模型、处理并发更新以及处理重复事件。代码中唯一复杂的部分是
    DAO，因为它必须正确处理并发并确保更新是幂等的。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Implementing queries that retrieve data from multiple services is challenging
    because each service’s data is private.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现从多个服务检索数据的查询具有挑战性，因为每个服务的数据是私有的。
- en: 'There are two ways to implement these kinds of query: the API composition pattern
    and the Command query responsibility segregation (CQRS) pattern.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现这类查询有两种方式：API 组合模式和命令查询责任分离（CQRS）模式。
- en: The API composition pattern, which gathers data from multiple services, is the
    simplest way to implement queries and should be used whenever possible.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个服务中收集数据的 API 组合模式是实现查询的最简单方式，应尽可能使用。
- en: A limitation of the API composition pattern is that some complex queries require
    inefficient in-memory joins of large datasets.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 组合模式的一个限制是，一些复杂的查询需要在大数据集上进行低效的内存连接。
- en: The CQRS pattern, which implements queries using view databases, is more powerful
    but more complex to implement.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CQRS 模式，通过使用视图数据库来实现查询，功能更强大但实现起来更复杂。
- en: A CQRS view module must handle concurrent updates as well as detect and discard
    duplicate events.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CQRS 视图模块必须处理并发更新以及检测和丢弃重复事件。
- en: CQRS improves separation of concerns by enabling a service to implement a query
    that returns data owned by a different service.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CQRS 通过允许一个服务实现返回不同服务所拥有数据的查询，从而提高了关注点的分离。
- en: Clients must handle the eventual consistency of CQRS views.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端必须处理 CQRS 视图的最终一致性。
