- en: 11 I’ve got something to say
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 我有一些话要说
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating and modifying MyBlog content posts
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和修改 MyBlog 内容帖子
- en: Creating and displaying content posts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和显示内容帖子
- en: Creating and displaying post comments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和显示帖子评论
- en: Notifying users about posts and comments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知用户关于帖子和评论的信息
- en: Handling errors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误
- en: At long last, we’re at the point of adding content to the MyBlog application.
    Everything we’ve done so far to build the application has been aimed at creating
    the infrastructure to enable posting content to the blog.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 终于，我们到了向 MyBlog 应用程序添加内容的时候了。到目前为止，我们为构建应用程序所做的一切都是为了创建基础设施，以便将内容发布到博客上。
- en: You’ve created a database to persist information the MyBlog application manages
    over time. In addition, you’ve created users with roles so those users can register
    with and use the application. You’ve also modularized the application using Flask
    Blueprints to help manage the app’s growing complexity, which adds structure and
    control to the application to help you and your users create and manage content
    on the MyBlog application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一个数据库来持久化存储 MyBlog 应用程序随时间管理的信息。此外，你创建了具有角色的用户，以便这些用户可以注册并使用应用程序。你还使用
    Flask Blueprints 对应用程序进行模块化，以帮助管理应用程序不断增长复杂性，这为应用程序增加了结构和控制，帮助你和你的用户在 MyBlog 应用程序上创建和管理内容。
- en: Let’s establish a naming convention to help us discuss content. Content is the
    engaging information a user writes and other users read and comment on. Content
    has an author, a creation timestamp, an update timestamp, and a title. The author,
    timestamps, and title are all associated with the content and its metadata. We’ll
    gather this information into what we’ll call a *post*, like on a bulletin board,
    where a user “posts” information they want others to read.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制定一个命名约定，以帮助我们讨论内容。内容是用户编写的吸引人的信息，其他用户阅读并对其发表评论。内容有一个作者、创建时间戳、更新时间戳和标题。作者、时间戳和标题都与内容及其元数据相关联。我们将将这些信息汇总到我们称之为“帖子”的东西中，就像在公告板上，用户“发布”他们希望其他人阅读的信息。
- en: 11.1 MyBlog posts
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 MyBlog 帖子
- en: A MyBlog `Post` object gathers the content and all the information associated
    with it in one place. The `Post` object is persisted in the database to be accessed,
    searched, and managed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: A MyBlog `Post` 对象将内容及其所有相关信息汇总在一个地方。`Post` 对象持久化存储在数据库中，以便访问、搜索和管理。
- en: Before getting too far into creating content, I want to talk about one of the
    MyBlog design goals—the presentation of content. The content presented by the
    MyBlog application is stored as plain text. However, that text can contain markdown
    syntax to enhance the presentation of the content. Markdown is a way to include
    plain ASCII characters in text content used during presentation to render text
    in bold or italics, include header sections in the visually rendered content,
    and generate many other features.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入创建内容之前，我想谈谈 MyBlog 设计目标之一——内容的展示。MyBlog 应用程序展示的内容以纯文本形式存储。然而，该文本可以包含 Markdown
    语法以增强内容的展示。Markdown 是一种在展示过程中包含纯 ASCII 字符的文本内容的方式，用于将文本以粗体或斜体形式渲染，在视觉内容中包含标题部分，并生成许多其他功能。
- en: 'To achieve this, we’ll be using the `Flask-PageDown` module created by Miguel
    Grinberg. This module takes care of presenting MyBlog markdown content correctly.
    It also provides tools to use markdown text and preview how it will be rendered
    interactively. You can find information about the `Flask-PageDown` module here:
    [https://blog.miguelgrinberg.com/post/flask-pagedown-markdown-editor-extension-for-flask-wtf.](https://blog.miguelgrinberg.com/post/flask-pagedown-markdown-editor-extension-for-flask-wtf)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用由米格尔·格林伯格创建的 `Flask-PageDown` 模块。此模块负责正确展示 MyBlog Markdown 内容。它还提供了使用
    Markdown 文本并交互式预览其渲染方式的功能。您可以在以下位置找到有关 `Flask-PageDown` 模块的信息：[https://blog.miguelgrinberg.com/post/flask-pagedown-markdown-editor-extension-for-flask-wtf.](https://blog.miguelgrinberg.com/post/flask-pagedown-markdown-editor-extension-for-flask-wtf)
- en: Tip Miguel Grinberg is a software engineer who writes about Python and Flask
    on his blog and publishes books and modules useful to a well-grounded Python developer.
    His work is well worth checking out.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 米格尔·格林伯格是一位软件工程师，他在自己的博客上撰写关于 Python 和 Flask 的文章，并发布了对经验丰富的 Python 开发者有用的书籍和模块。他的工作非常值得一看。
- en: 11.1.1 Modeling the database
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 模型数据库
- en: The `Post` object is another SQLAlchemy class defining the structure of the
    post database table where the information is persisted. Because users who register
    with the MyBlog application can create multiple posts, there is a one-to-many
    relationship between users and posts. Figure 11.1 is the ERD (entity relationship
    diagram) between the existing `User` and new `Post` tables. Next, we’ll create
    the SQLAlchemy model the MyBlog Python application uses to communicate with the
    database and the `Post` table.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post` 对象是另一个 SQLAlchemy 类，它定义了持久化信息的帖子数据库表的结构。因为注册 MyBlog 应用的用户可以创建多个帖子，所以用户和帖子之间存在一对一或多对一的关系。图
    11.1 是现有 `User` 表和新的 `Post` 表之间的 ERD（实体关系图）。接下来，我们将创建 MyBlog Python 应用程序用于与数据库和
    `Post` 表通信的 SQLAlchemy 模型。'
- en: SQLAlchemy Post class
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy `Post` 类
- en: You’ll create the `Post` class to model the `Post` table as you’ve done for
    other models in the MyBlog application. The `Post` class inherits from the `db.Model`
    class to give it SQLAlchemy functionality. It also uses the `get_uuid()` function
    to create UUID primary key values.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建 `Post` 类来模拟 `Post` 表，就像你在 MyBlog 应用程序中对其他模型所做的那样。`Post` 类从 `db.Model` 类继承，以赋予其
    SQLAlchemy 功能。它还使用 `get_uuid()` 函数来创建 UUID 主键值。
- en: '![](../../OEBPS/Images/CH11_F01_Farrell.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH11_F01_Farrell.png)'
- en: Figure 11.1 The ERD shows the one-to-zero or multiple relationships between
    users and their posts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 ERD 显示了用户与其帖子之间的一对零或一对多关系。
- en: 'Here’s the `Post` class definition from `examples/CH_11/examples/01/app/models.py`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是来自 `examples/CH_11/examples/01/app/models.py` 的 `Post` 类定义：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Connects the model to the table named Post, as defined in the ERD diagram
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将模型连接到 ERD 图中定义的名为 `Post` 的表
- en: ② Creates the primary key for the table using the get_uuid() function
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用 `get_uuid()` 函数为表创建主键
- en: ③ Creates the foreign key relationship to the user table and user_uid value
    and indexes this column for faster querying
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建与用户表和用户 `uid` 值的外键关系，并为该列创建索引以加快查询速度
- en: ④ Marks the created field so the database will automatically add a UTC timestamp
    when the record is created
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 标记创建字段，以便数据库在记录创建时自动添加 UTC 时间戳
- en: ⑤ Marks the updated field so the database will automatically update the UTC
    timestamp when the record is updated
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 标记更新字段，以便数据库在记录更新时自动更新 UTC 时间戳
- en: 'The `Post` class creates a structure to manage the content, user (author),
    title, and audit information. Because we’ve established a relationship between
    the `Post` class and the `User` class, we need to modify the `User` class to take
    advantage of this relationship:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post` 类创建了一个结构来管理内容、用户（作者）、标题和审计信息。因为我们已经在 `Post` 类和 `User` 类之间建立了关系，所以我们需要修改
    `User` 类以利用这种关系：'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① The new posts attribute, which is a relationship to the Post class
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ① 新增的 `posts` 属性，它是与 `Post` 类的关系
- en: The newly added `posts` attribute of the `User` class creates an association
    between the `User` and `Post` class. The `posts` attribute doesn’t exist in the
    `User` table; it is created and managed by SQLAlchemy. The `posts` attribute is
    created when instances of the `User` class are created in response to database
    queries.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的 `User` 类的 `posts` 属性在 `User` 表中创建了一个与 `Post` 类的关联。`posts` 属性在 `User` 表中不存在；它是由
    SQLAlchemy 创建和管理的。当响应数据库查询创建 `User` 类的实例时，会创建 `posts` 属性。
- en: The use of *posts* plural is intentional, as the `db.relationship()` definition
    connects the single user to the many possible posts. The `posts` attribute is
    a Python list containing zero or more possible posts that the user can create.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *posts* 复数是有意为之，因为 `db.relationship()` 定义将单个用户连接到许多可能的帖子。`posts` 属性是一个包含零个或多个可能帖子的
    Python 列表，用户可以创建这些帖子。
- en: The first parameter of the `db.relationship()` definition is `"Post"`. It is
    a string because the `Post` class is defined after the `User` class definition,
    and the use of a string causes SQLAlchemy to resolve the relationship at run time.
    It connects to the `Post` class using the `user_uid` attribute defined in the
    `Post` class as a `ForeignKey` to the "`user.user_uid`" attribute of the user
    table.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.relationship()` 定义的第一个参数是 `"Post"`。它是一个字符串，因为 `Post` 类是在 `User` 类定义之后定义的，使用字符串会导致
    SQLAlchemy 在运行时解析关系。它通过 `Post` 类中定义的 `ForeignKey` 作为 `user.user_uid` 属性的 `ForeignKey`
    来连接到 `Post` 类。'
- en: 'The second parameter to `db.relationship()` is `backref=db.backref ("user",`
    `lazy="joined")`, which handles two elements:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.relationship()` 的第二个参数是 `backref=db.backref("user", lazy="joined")`，它处理两个元素：'
- en: Creates an attribute named `"user"` on instances of `Post` classes that refer
    back to the parent user. SQLAlchemy maintains the `"user"` attribute.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Post`类的实例上创建一个名为`"user"`的属性，它引用父用户。SQLAlchemy维护`"user"`属性。
- en: Indicates that the relationship between `User` and `Posts` should use `"joined"`
    in the same select statement so the posts associated with a user are available
    immediately rather than requiring additional queries to retrieve them.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表明`User`和`Posts`之间的关系应在相同的select语句中使用`"joined"`，以便与用户关联的帖子可以立即可用，而不是需要额外的查询来检索它们。
- en: With the new `Post` and updated `User` class definitions, we can persist content
    and retrieve it in a consistent, structured way. Now we need to build a system
    to create and display that content.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新的`Post`和更新的`User`类定义，我们可以以一致、结构化的方式持久化内容并检索它。现在我们需要构建一个创建和显示该内容的系统。
- en: 11.2 Change of direction
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 方向改变
- en: Before proceeding much further, I should point out that the remainder of this
    book changes its presentation pattern. Previous chapters included extensive or
    complete code samples because I felt they were helpful to see the new concepts
    implemented. There are new concepts still to come, but they also include blocks
    of boilerplate code that you’ve seen before.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步进行之前，我应该指出，本书的剩余部分将改变其展示模式。之前的章节包含了大量的或完整的代码示例，因为我觉得它们有助于看到新概念的实施。还有新的概念要介绍，但它们也包括您之前见过的样板代码块。
- en: Presenting blocks of code in a book makes for dry reading and doesn’t further
    the aims of the chapter, which are to introduce new ideas and how to implement
    them. So, rather than reviewing large code sections, we’ll focus on what the code
    provides and refer to the specific code in the GitHub repository that accompanies
    this book.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在书中呈现代码块会使阅读变得枯燥，并且不利于章节的目标，即介绍新想法及其实现方式。因此，我们不会审查大量的代码部分，而是将重点放在代码提供的内容上，并参考此书附带的GitHub仓库中的具体代码。
- en: 11.3 Content Blueprint
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 内容蓝图
- en: At the beginning of this chapter, we discussed the benefits of having the infrastructure
    in place. We’re going to take advantage of that infrastructure—in a cognitive
    sense because of what you know, and in an actual sense because of the structure
    you’ve built for the MyBlog application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们讨论了拥有基础设施的好处。我们将利用这个基础设施——从认知上讲是因为您所知道的内容，从实际意义上讲是因为您为MyBlog应用程序构建的结构。
- en: You’re going to build a `Content` Blueprint to manage the MyBlog content. In
    every way, this is like the `Auth` Blueprint; it isolates functionality into a
    separate module, making it easier to think and work in the context of the content
    domain. Doing so puts into practice the idea of the separation of concerns.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您将构建一个名为`Content`的蓝图来管理MyBlog的内容。在各个方面，这都类似于`Auth`蓝图；它将功能隔离到单独的模块中，使得在内容域的上下文中思考和工作的更容易。这样做就是实践了关注点分离的理念。
- en: 'As you did for the `auth` Blueprint, you’ll add a new package directory named
    *content* under the app package. This directory has an `__init__.py` file containing
    the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像为`auth`蓝图所做的那样，您将在应用程序包下添加一个名为*content*的新包目录。此目录包含一个`__init__.py`文件，其中包含以下代码：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code is conceptually identical to what you’ve done previously for the `auth/.__init__.py`
    file. It creates a Blueprint instance called `content_bp` and configures it to
    have distinct `static` and `templates` folders. It also imports a module called
    `content` containing the handler for managing user content. Now that you’ve got
    a Blueprint namespace for MyBlog content posts, let’s use it to present the content.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在概念上与您之前为`auth/.__init__.py`文件所做的是相同的。它创建了一个名为`content_bp`的蓝图实例，并配置它具有独立的`static`和`templates`文件夹。它还导入了一个名为`content`的模块，其中包含管理用户内容的处理程序。现在您已经为MyBlog的内容帖子获得了蓝图命名空间，让我们用它来展示内容。
- en: 11.4 Displaying and creating posts
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 显示和创建帖子
- en: The MyBlog application needs a Python handler to intercept, as well as a function
    to process calls to the content URL to display the content. It also needs templates
    to render the posts as HTML pages in the browser.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog应用程序需要一个Python处理程序来拦截，以及一个处理内容URL调用以在浏览器中显示内容的函数。它还需要模板来将帖子渲染为HTML页面。
- en: 11.4.1 Display handler
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1 显示处理程序
- en: 'The content handler needs to access other parts of the MyBlog application,
    which it does by importing the required modules and instances in the `examples/CH_11/examples/01/app/content/content.py`
    module. The first handler in the content module is for the URL `"/blog_posts"`,
    and it deals with two functions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 内容处理程序需要访问 MyBlog 应用程序的其他部分，它通过在 `examples/CH_11/examples/01/app/content/content.py`
    模块中导入所需的模块和实例来实现。内容模块中的第一个处理程序用于 URL `"/blog_posts"`，并处理两个函数：
- en: First, if the URL is invoked with a query string where `action` is `None`, it
    displays all the content posts in the MyBlog application.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，如果 URL 通过带有 `action` 为 `None` 的查询字符串被调用，它将显示 MyBlog 应用程序中的所有内容帖子。
- en: If the URL is invoked with a query string of `action=create`, it presents a
    logged-in user with a web page form where post content is created. That content
    can be saved to the database when the form is submitted.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 URL 通过带有 `action=create` 的查询字符串被调用，它向登录用户展示一个网页表单，用于创建帖子内容。当表单提交时，该内容可以保存到数据库中。
- en: The `blog_posts()` handler is a simple dispatch function to two other functions,
    depending on how the URL is invoked. Both actions could be handled in a single
    function, but that would have been more complex and harder to follow. The complexity
    is reduced by splitting the behavior into two functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`blog_posts()` 处理程序是一个简单的分派函数，根据 URL 的调用方式将调用两个其他函数。这两个操作可以在一个函数中处理，但那样会更复杂且难以理解。通过将行为拆分为两个函数来减少复杂性。'
- en: 'The first dispatch function is `blog_posts_display()`, responsible for rendering
    all the MyBlog blog posts to a browser page. The `blog_posts_display()` function
    takes the following steps to display the list of blog posts:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个分派函数是 `blog_posts_display()`，负责将 MyBlog 博客的所有帖子渲染到浏览器页面。`blog_posts_display()`
    函数通过以下步骤显示帖子列表：
- en: Gets the search string from the request.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从请求中获取搜索字符串。
- en: Begins a database session context manager.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始数据库会话上下文管理器。
- en: Gets the current page from the request.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从请求中获取当前页面。
- en: Creates a query to the database for content posts sorted in updated timestamp
    descending order.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个查询到数据库的内容帖子，按更新时间戳降序排序。
- en: Conditionally adds a filter to the query to control whether the user can see
    active posts or all posts. This allows users with editor or administrator permissions
    to see both active and inactive posts.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有条件地向查询添加过滤器以控制用户是否可以看到活动帖子或所有帖子。这允许具有编辑器或管理员权限的用户看到活动和非活动帖子。
- en: Conditionally adds a filter to the query to return posts only containing the
    search term.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有条件地向查询添加过滤器以仅返回包含搜索词的帖子。
- en: Gets the relevant posts based on the query.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据查询获取相关帖子。
- en: Renders the lists of posts to the browser display.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将帖子列表渲染到浏览器显示。
- en: 11.4.2 Display template
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.2 显示模板
- en: The content handler is responsible for gathering the intended data passed to
    the template. The template `examples/CH_11/examples/01/app/content/templates/posts.xhtml`
    can then be rendered and sent to the browser.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 内容处理程序负责收集传递给模板的预期数据。然后，`examples/CH_11/examples/01/app/content/templates/posts.xhtml`
    模板可以被渲染并发送到浏览器。
- en: Like the templates in the `auth` Blueprint, the content templates inherit from
    the system-wide `base.xhtml` template file and build the content block from there.
    The template iterates over the list of posts, if any, passed by the content handler.
    The template code formats a one-hundred-character snippet of the content and renders
    it as a Bootstrap card. If you run the MyBlog application in `examples/CH_11/examples/01`,
    and you have sample content in the database, the system will render a content
    post page.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `auth` 蓝图中的模板一样，内容模板继承自系统范围内的 `base.xhtml` 模板文件，并从那里构建内容块。模板遍历内容处理程序传递的帖子列表（如果有）。模板代码格式化内容的一百字符摘录，并将其渲染为
    Bootstrap 卡片。如果你在 `examples/CH_11/examples/01` 中运行 MyBlog 应用程序，并且数据库中有示例内容，系统将渲染内容帖子页面。
- en: Notice the blog posts are displayed in order of the most recent first. This
    is because the query sorts the results in descending order using the updated timestamp.
    Because “The Second Post” was created after “This is the first post,” it appears
    first in the rendered display.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意博客帖子是按最新顺序显示的。这是因为查询使用更新时间戳降序排序结果。因为“第二篇帖子”是在“这是第一篇帖子”之后创建的，所以在渲染的显示中它出现在第一位。
- en: Because there were only two posts in the database I used when the screenshot
    (shown in figure 11.2) was captured, there is no need to paginate the display,
    and only the single page link “1” is shown. The `render_pagination()` macro in
    the handler creates these page links. The number of blog posts to display per
    page is controlled by the configuration variable `blog_posts_per_page` in the
    `settings.toml` file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在截图（如图11.2所示）捕获时，我使用的数据库中只有两个帖子，因此不需要分页显示，只显示单个页面链接“1”。处理程序中的`render_pagination()`宏创建了这些页面链接。每页要显示的博客帖子数量由`settings.toml`文件中的配置变量`blog_posts_per_page`控制。
- en: '![](../../OEBPS/Images/CH11_F02_Farrell.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH11_F02_Farrell.png)'
- en: Figure 11.2 The browser page showing the rendered content for the first and
    second posts
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 显示第一个和第二个帖子渲染内容的浏览器页面
- en: 11.5 Creating posts
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 创建帖子
- en: Creating a MyBlog content post requires a URL handler, a form, and a template
    for the user to enter content and review it. Once users are satisfied with what
    they’ve created, they can save it to the database.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建MyBlog内容帖子需要一个URL处理程序、一个表单以及一个用户输入内容并预览的模板。一旦用户对其创建的内容满意，他们就可以将其保存到数据库中。
- en: 11.5.1 Creation handler
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.1 创建处理程序
- en: 'The second function in the `blog_posts()` dispatch handler is the `blog_posts
    _create()` function, which renders a form-based page with which a registered user
    can create and save blog post content. The `blog_posts_create()` handler function
    follows these steps to access the content from the form and save it to the database:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`blog_posts()`分发处理程序中的第二个函数是`blog_posts_create()`函数，它渲染一个基于表单的页面，注册用户可以通过该页面创建和保存博客帖子内容。`blog_posts_create()`处理程序函数按照以下步骤从表单中获取内容并将其保存到数据库：
- en: Creates an instance of the `PostForm` form handling class.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`PostForm`表单处理类的实例。
- en: Checks if the form Cancel button was clicked and redirects to the home page
    if it was.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否点击了表单取消按钮，如果是，则重定向到主页。
- en: Validates the form if the Submit button was clicked and renders the empty form
    if it was not.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果点击了提交按钮，则验证表单；如果没有点击，则渲染空表单。
- en: If the form was submitted and it passes validation, a database session context
    manager opens.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表单已提交并且通过验证，则打开数据库会话上下文管理器。
- en: Creates an instance of the `Post` SQLAlchemy model class, passing in the form
    content.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Post` SQLAlchemy模型类的实例，传入表单内容。
- en: Adds the `Post` instance to the database session.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Post`实例添加到数据库会话中。
- en: Commits the session to the database.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会话提交到数据库。
- en: Notifies the user that the post was created.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通知用户帖子已创建。
- en: Redirects the user to the newly created post.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户重定向到新创建的帖子。
- en: 11.5.2 Creation form
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.2 创建表单
- en: Because the post is created using a form, the handler needs to have access to
    a class definition to manage that form. The `PostForm` class exists in the `examples/CH_11/examples/01/app/content/forms.py`
    file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于帖子是通过表单创建的，处理程序需要访问一个类定义来管理该表单。`PostForm`类位于`examples/CH_11/examples/01/app/content/forms.py`文件中。
- en: 'The `PostForm` class inherits from `FlaskForm,` just like the forms used in
    the `auth` Blueprint. The form to create post content has four elements:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostForm`类继承自`FlaskForm`，就像在`auth`蓝图中使用的形式一样。创建帖子内容表单有四个元素：'
- en: '`title`—A `StringField` to contain the title text'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`—一个`StringField`，用于包含标题文本'
- en: '`content`—A `PageDownField` to contain the text, which can use markdown syntax
    for display when the content is rendered'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content`—一个`PageDownField`，用于包含文本，当内容被渲染时可以使用Markdown语法进行显示'
- en: '`post_create`—The `SubmitField` that submits the form to the handler'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post_create`—提交表单到处理程序的`SubmitField`'
- en: '`cancel`—Another `SubmitField` item that is intercepted by the handler to cancel
    any actions and return the user to the home screen'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cancel`—另一个被处理程序拦截的`SubmitField`项，用于取消任何操作并将用户返回到主页'
- en: The `render_kw` parameter is added to all of the fields in the form. The `render_kw`
    parameter is a dictionary that adds extra HTML attributes to the elements when
    they are rendered to the browser display.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将`render_kw`参数添加到表单中的所有字段。`render_kw`参数是一个字典，当元素被渲染到浏览器显示时，它为元素添加额外的HTML属性。
- en: The `tabindex` key in the `render_kw` dictionary controls the order that the
    cursor will move from element to element when the TAB or ALT-TAB keys are pressed
    on the keyboard. The `autofocus` key in the `render_kw` dictionary controls which
    element has cursor focus when the form is rendered. The `tabindex` and `autofocus`
    keys add useability features to the form to help the user reduce the number of
    clicks necessary to navigate and use the form.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`render_kw`字典中的`tabindex`键控制当在键盘上按下TAB或ALT-TAB键时，光标从元素到元素移动的顺序。`render_kw`字典中的`autofocus`键控制表单渲染时哪个元素具有光标焦点。`tabindex`和`autofocus`键为表单添加了可用性功能，以帮助用户减少导航和使用表单所需的点击次数。'
- en: 11.5.3 Creation template
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.3 创建模板
- en: The post-create template is connected to the `PostForm` class through the post-create
    handler. The handler uses the template file `examples/CH_11/examples/01/app/content/templates/post_create.xhtml`
    to render the form and send it to the browser. The interactive markdown behavior
    of the form is handled by creating a form field of type `PageDownField` and then
    rendering it on the page.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建帖子模板通过帖子创建处理程序与`PostForm`类连接。处理程序使用模板文件`examples/CH_11/examples/01/app/content/templates/post_create.xhtml`来渲染表单并将其发送到浏览器。表单的交互式Markdown行为通过创建一个类型为`PageDownField`的表单字段并在页面上渲染它来处理。
- en: If you run the application from the `examples/CH_11/examples/01/` directory,
    log in, and navigate to create a post, you’ll be presented with the post content
    creation form. The screenshot in figure 11.3 shows this display. The form has
    two text input fields, Title and Content. The bottom part of the screen interactively
    represents how the text in the Content field will be rendered by the browser.
    I’ve entered some text containing markdown for headers to show how the markdown
    is displayed by the `Flask-PageDown` module.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从`examples/CH_11/examples/01/`目录运行应用程序，登录并导航到创建帖子，你将看到一个帖子内容创建表单。图11.3中的截图显示了此显示。表单有两个文本输入字段，标题和内容。屏幕的下半部分交互式地表示浏览器将如何渲染内容字段中的文本。我输入了一些包含Markdown标题的文本，以显示Markdown是如何由`Flask-PageDown`模块显示的。
- en: '![](../../OEBPS/Images/CH11_F03_Farrell.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F03_Farrell.png)'
- en: Figure 11.3 The blog post content-creation form uses markdown to style the content.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 博客帖子内容创建表单使用Markdown来格式化内容。
- en: As the user types in the Content input field, the system will interactively
    update the lower part of the display to render that content. This is very useful
    when creating markdown content, and similar behavior is seen on sites like Stackoverflow
    and GitHub. Now that users can create MyBlog content, let’s give them a way to
    edit that content to update their posts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在内容输入字段中键入时，系统将交互式地更新显示的下半部分以渲染该内容。这在创建Markdown内容时非常有用，类似的行为在Stackoverflow和GitHub等网站上也可以看到。现在用户可以创建MyBlog内容，让我们给他们一个编辑这些内容以更新帖子的方式。
- en: 11.6 Displaying and editing a post
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 显示和编辑帖子
- en: You’ve developed infrastructure to display multiple posts and create a new post.
    Now you need to build systems to display and edit a single post.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经开发了显示多个帖子并创建新帖子的基础设施。现在你需要构建显示和编辑单个帖子的系统。
- en: 11.6.1 Display handler
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.1 显示处理程序
- en: In the previous section, you handled displaying multiple, abbreviated posts
    to the browser. You’ve also provided the ability to create new posts. Now we need
    to add support to display a single post. If you look back at the template to render
    the list of MyBlog posts, you’ll see each post is wrapped in an HTML hyperlink
    anchor tag `<a...>` that generates a `"/blog_posts/{post_uid}"` URL. This link
    navigates the user to the single post using the unique `post_uid` value.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你处理了向浏览器显示多个简短帖子。你还提供了创建新帖子的能力。现在我们需要添加显示单个帖子的支持。如果你回顾一下渲染MyBlog帖子列表的模板，你会看到每个帖子都被一个HTML超链接锚点标签`<a...>`包裹，该标签生成一个`"/blog_posts/{post_uid}"`
    URL。此链接使用唯一的`post_uid`值将用户导航到单个帖子。
- en: Like the initial handler for multiple posts, a single post is handled with a
    dispatch routine in anticipation of handling an HTTP `GET` request with or without
    a query string. The `blog_post()` handler is another such dispatch function, delegating
    to two other functions—one to display a single post and another to edit a single
    post.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与处理多个帖子的初始处理程序一样，单个帖子通过一个调度例程来处理，以处理带有或没有查询字符串的HTTP `GET`请求。`blog_post()`处理程序是另一个这样的调度函数，将任务委托给另外两个函数——一个用于显示单个帖子，另一个用于编辑单个帖子。
- en: 'The first function is the `blog_post_display(post_uid)`, which renders a single
    MyBlog post based on the `post_uid` parameter passed in the link. The function
    takes the following steps to get the post content from the database and display
    it in the browser:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数是 `blog_post_display(post_uid)`，它根据链接中传递的 `post_uid` 参数渲染单个 MyBlog 帖子。该函数采取以下步骤从数据库获取帖子内容并在浏览器中显示：
- en: Begins a database session context manager.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始数据库会话上下文管理器。
- en: Creates the initial database query to get the post with the `post_uid` value.
    The query also performs a `JOIN` operation with the `user` table to get the user
    information related to the post.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建初始数据库查询以获取具有 `post_uid` 值的帖子。该查询还与 `user` 表执行 `JOIN` 操作，以获取与帖子相关的用户信息。
- en: Modifies the query based on the user permissions to see all posts or only active
    ones.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据用户权限修改查询，以查看所有帖子或仅查看活跃帖子。
- en: Executes the database query.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行数据库查询。
- en: If no post was returned from the query, aborts with a `NOT FOUND` error.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果查询没有返回任何帖子，则使用 `NOT FOUND` 错误终止。
- en: Renders the post with the related single post template.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关单个帖子模板渲染帖子。
- en: 11.6.2 Display template
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.2 显示模板
- en: The `blog_post()` content handler gets the content post from the database using
    the `post_uid` value passed as a path parameter in the URL that invoked the dispatch
    function. Next, the `post` information is passed to the display template `examples/CH_11/examples/01/app/content/templates/post.xhtml`.
    The template is responsible for rendering the data sent to it as an HTML page
    to display in the user’s browser.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`blog_post()` 内容处理程序使用通过 URL 传递的 `post_uid` 值作为路径参数从数据库获取内容帖子。接下来，将 `post`
    信息传递给显示模板 `examples/CH_11/examples/01/app/content/templates/post.xhtml`。该模板负责将其接收到的数据渲染为
    HTML 页面，以便在用户的浏览器中显示。'
- en: The template conditionally renders the Active badge in the upper right corner
    of the page to indicate the active/inactive state of the post. This is displayed
    for MyBlog administrators and editors as well as the author of the post. In addition,
    the template conditionally renders the Update button, anticipating navigation
    to the edit system. Figure 11.4 presents a screenshot of the rendered display.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 模板条件性地在页面的右上角渲染活动徽章，以指示帖子的活动/非活动状态。这对于 MyBlog 管理员、编辑以及帖子的作者都适用。此外，模板条件性地渲染更新按钮，预期导航到编辑系统。图
    11.4 展示了渲染显示的截图。
- en: '![](../../OEBPS/Images/CH11_F04_Farrell.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F04_Farrell.png)'
- en: Figure 11.4 A single-content post display as rendered for the post author
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 单个内容帖子显示，为帖子作者渲染
- en: 'The Created and Updated fields displayed a timestamp when the post’s author
    created and last updated it. Both timestamps are presented in the logged-in user’s
    local time zone. If you recall, all models of the tables in the MyBlog database
    have `created` and `updated` fields, and those fields are automatically populated
    with a UTC timestamp. So how is the system presenting local time zone timestamps
    when all it has access to are UTC timestamps? Take a look at the `post.xhtml`
    template, and you’ll see this code snippet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的创建和更新字段显示了帖子作者创建和最后更新帖子的时间戳。这两个时间戳都显示在登录用户的本地时区。如果您还记得，MyBlog 数据库中所有表的模型都有
    `created` 和 `updated` 字段，并且这些字段自动填充 UTC 时间戳。那么系统是如何呈现本地时区时间戳的呢？如果您查看 `post.xhtml`
    模板，您将看到以下代码片段：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These few lines of code render the `created` and `updated` timestamps as HTML
    unordered list items. Notice that timestamp data is piped into `format_datetime`
    and then piped into `safe`. Previously, the `safe` filter has been used in MyBlog
    templates, but `format_datetime` is a new filter function that’s added to the
    `app/__init__.py` module:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这几行代码将 `created` 和 `updated` 时间戳渲染为 HTML 无序列表项。请注意，时间戳数据被导入 `format_datetime`，然后导入
    `safe`。之前，在 MyBlog 模板中已使用 `safe` 过滤器，但 `format_datetime` 是添加到 `app/__init__.py`
    模块的新过滤函数：
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The decorator adds the `format_datetime()` function as a filter to the template
    engine, making it available in the HTML template snippet shown previously. Because
    it’s part of a filter pipeline, it accepts the value of whatever is before it
    in the template pipeline as a parameter—in this case, a UTC timestamp. It then
    uses `timezone_info` from the user’s session to create a timestamp in the local
    time zone. That local timestamp is then formatted into a string and returned.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器将`format_datetime()`函数作为过滤器添加到模板引擎中，使其在之前显示的HTML模板片段中可用。因为它是一个过滤器管道的一部分，它接受模板管道中它之前的任何值的参数——在这个例子中，是一个协调世界时（UTC）时间戳。然后它使用用户会话中的`timezone_info`来创建本地时区的时间戳。然后，这个本地时间戳被格式化为字符串并返回。
- en: 'The `timezone_info` data comes from the user’s session information. How does
    it get there? The `examples/CH_11/examples/01/app/auth/auth.py` module’s `login()`
    function has been modified to add time zone information to the user’s session.
    When a user logs in, the following line of code adds the time zone information
    to their session:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`timezone_info`数据来自用户的会话信息。它是如何到达那里的？`examples/CH_11/examples/01/app/auth/auth.py`模块的`login()`函数已被修改，向用户的会话中添加时区信息。当用户登录时，以下代码行将时区信息添加到他们的会话中：'
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This line of code creates a dictionary of time zone information from a string
    stored in a form field called `timezone_info`. The `timezone_info` is a hidden
    field in the form populated by a small JavaScript function in the `login.js` file
    included in the login template:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码从一个名为`timezone_info`的表单字段中创建一个时区信息字典，该字段存储在表单中，由登录模板中包含的`login.js`文件中的一个小JavaScript函数填充：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The self-evaluating function runs when the browser has rendered the template.
    It finds the `timezone_info` hidden field element in the HTML page and populates
    it with the `JSON.stringify` results of calling the function `Intl.DateTimeFormat()
    .resolvedOptions()`. In the Chrome browser on my computer, this generates the
    JavaScript object:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器渲染模板时，自我评估函数运行。它找到HTML页面中的`timezone_info`隐藏字段元素，并用调用函数`Intl.DateTimeFormat().resolvedOptions()`的`JSON.stringify`结果填充它。在我的计算机上的Chrome浏览器中，这生成以下JavaScript对象：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The previous object is useful information when presenting time and date information
    in a locale context. It’s necessary to do this work in JavaScript because the
    functionality runs on the user’s computer, which could be anywhere in the world.
    This makes the data returned relevant to the user, not the server where the MyBlog
    application could be running. The `format_datetime` filter function uses the `timeZone`
    field to determine how to create a local time zone value of the `created` and
    `updated` timestamps.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在呈现本地上下文中的时间和日期信息时，前面的对象是有用的信息。由于功能在用户的计算机上运行，这可能在世界上的任何地方，因此有必要在JavaScript中执行这项工作。这使得返回的数据与用户相关，而不是MyBlog应用程序可能运行的服务器。`format_datetime`过滤器函数使用`timeZone`字段来确定如何创建`created`和`updated`时间戳的本地时区值。
- en: Tip When you’re working on a web-based application, it’s worth thinking about
    time zones when presenting data to your users. If you deploy your application
    to the internet, your users could be anywhere in the world. Presenting the UTC
    would be easy, but not very helpful to your user base.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：当你在基于Web的应用程序上工作时，在向用户展示数据时考虑时区是值得的。如果你将应用程序部署到互联网上，你的用户可能在世界上的任何地方。展示协调世界时（UTC）很容易，但对你的用户基础来说并不很有帮助。
- en: 11.6.3 Update handler
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.3 更新处理程序
- en: 'If a user decides to make changes to their blog content and clicks the Update
    button, they are directed to the dispatch function with the query string "`action=update`".
    The dispatch function handles the request and calls the `blog_post_update()` function.
    The function follows these steps to populate and present the page:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户决定修改他们的博客内容并点击更新按钮，他们将被导向带有查询字符串"`action=update`"的调度函数。调度函数处理请求并调用`blog_post_update()`函数。该函数按照以下步骤填充并展示页面：
- en: '`blog_post_update` is decorated with `@login_required`, requiring a user to
    be logged in to update a post.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`blog_post_update`用`@login_required`装饰，要求用户登录才能更新帖子。'
- en: Begins a database context manager.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始数据库上下文管理器。
- en: Creates a query to get the post based on the passed `post_uid`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于传递的`post_uid`获取帖子的查询。
- en: Modifies the query based on the user’s role to get only active posts, or all
    posts.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据用户的角色修改查询，以获取仅活跃帖子或所有帖子。
- en: Executes the query and gets the results.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行查询并获取结果。
- en: Was no post found? Then the function aborts the request with `NOT FOUND`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有找到帖子，则函数使用`NOT FOUND`终止请求。
- en: Gets the template form information and populates the fields with the post values.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取模板表单信息，并用提交的值填充字段。
- en: Was the form Cancel button clicked? Then the function redirects the user to
    the home page.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否点击了取消按钮？如果是，则函数将用户重定向到主页。
- en: Was the form submitted, and is it valid? Then it updates the post returned by
    the query with form data, saves the updated post to the database, and redirects
    the user to the post display page to show the updates.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表单是否已提交，并且是否有效？如果是，则使用表单数据更新查询返回的帖子，将更新后的帖子保存到数据库，并将用户重定向到帖子显示页面以显示更新。
- en: Renders the `post_update` template using the form and the post returned by the
    query.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用表单和查询返回的帖子渲染 `post_update` 模板。
- en: 11.6.4 Update form
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.4 更新表单
- en: The data to update the post comes from the `PostUpdateForm` in the `content/forms.py`
    module. The form contains the field information used in the `post_ update.xhtml`
    template to build and render the HTML page to the browser.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 更新帖子的数据来自 `content/forms.py` 模块中的 `PostUpdateForm`。该表单包含在 `post_update.xhtml`
    模板中使用的字段信息，用于构建和渲染HTML页面到浏览器。
- en: The form provides the `title`, `content`, `post_update,` and `cancel` fields
    visible when the form is rendered. It also provides a hidden field called `active_state,`
    which holds the user’s selected active state. The active state is controlled by
    the template conditionally rendering one of two other fields—`activate` and `deactivate`.
    The current user must be the author of the content or a MyBlog administrator for
    the `activate` and `deactivate` fields to be displayed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 该表单提供了在表单渲染时可见的 `title`、`content`、`post_update` 和 `cancel` 字段。它还提供了一个名为 `active_state`
    的隐藏字段，其中包含用户选择的激活状态。激活状态由模板条件性地渲染两个其他字段——`activate` 和 `deactivate`——来控制。当前用户必须是内容的作者或
    MyBlog 管理员，`activate` 和 `deactivate` 字段才能显示。
- en: Depending on the current active state of the post, one or the other of these
    fields are presented to the user as buttons. The form is submitted if the user
    clicks the button, and the active state value is toggled. The `activate` and `deactivate`
    buttons represent mutually exclusive actions to take, and only one is shown on
    the page at a time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 根据帖子的当前活动状态，其中一个或另一个字段以按钮的形式呈现给用户。如果用户点击按钮，则提交表单，并切换活动状态值。`activate` 和 `deactivate`
    按钮代表互斥的操作，一次只显示页面上的一个。
- en: 11.6.5 Update template
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.5 更新模板
- en: 'The `post_update.xhtml` template is responsible for rendering the page to the
    browser where the logged-in user can modify the post’s content. The template uses
    the form information and data passed to it to render the update-post display in
    the browser. Depending on the current user’s role, they can toggle the active
    state of the post with the conditionally presented activate and deactivate buttons.
    The snippet of the template controlling this behavior is shown here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`post_update.xhtml` 模板负责将页面渲染到浏览器，登录用户可以在此修改帖子的内容。该模板使用传递给它的表单信息和数据来在浏览器中渲染更新帖子显示。根据当前用户的角色，他们可以使用条件呈现的激活和停用按钮切换帖子的活动状态。控制此行为的模板片段如下所示：'
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The outer `if` statement calls the function `can_set_blog_post_active_state()`,
    which returns `True` or `False` if the currently logged-in user can change the
    active state of the post. The user must be an administrator or the post’s author
    to do so.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 外部 `if` 语句调用 `can_set_blog_post_active_state()` 函数，该函数根据当前登录用户是否可以更改帖子的活动状态返回
    `True` 或 `False`。用户必须是管理员或帖子的作者才能这样做。
- en: The inner `if/else` conditional determines which field to render—`deactivate`
    or `activate`—depending on the current active state of the post.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 内部 `if/else` 条件语句确定要渲染哪个字段——`deactivate` 或 `activate`——取决于帖子的当前活动状态。
- en: 'The function `can_set_blog_post_active_state()` exists in the `content.py`
    handler module as part of two functions made available in the context of template
    processing:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`can_set_blog_post_active_state()` 函数存在于 `content.py` 处理模块中，作为在模板处理上下文中提供的两个函数的一部分：'
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① Decorator to add template context functionality to the content Blueprint
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ① 装饰器用于向内容蓝图添加模板上下文功能
- en: ② Returns True if the currently logged-in user is an ADMINISTRATOR or EDITOR,
    otherwise returns False
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果当前登录用户是管理员或编辑，则返回 True，否则返回 False
- en: ③ Returns True if the currently logged-in user is an ADMINISTRATOR or the author
    of the post content
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果当前登录用户是管理员或帖子的作者，则返回 True
- en: ④ Returns the two functions to add to the template context
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 返回要添加到模板上下文中的两个函数
- en: 11.7 Content to comment hierarchy
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7 内容评论层次结构
- en: The MyBlog application can have many content posts. Each post can have many
    comments associated with it. Each of those first-level comments can also have
    many comments associated with it. The MyBlog application will limit comment nesting
    to two levels to keep things reasonable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog应用可以有多个内容帖子。每个帖子可以与多个评论相关联。这些一级评论中的每一个也可以与多个评论相关联。MyBlog应用将限制评论嵌套到两级以保持合理。
- en: The hierarchy in figure 11.5 shows two content posts, posts 0 and 1\. Content
    post 0 has two level 1 comments associated with it, with the first comment having
    two level 2 comments and the second comment having one level 2 comment. Content
    post 1 has three level 1 comments, with only one having a level 2 comment.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5中的层次结构显示了两个内容帖子，帖子0和1。内容帖子0有两个与它相关联的1级评论，第一个评论有两个2级评论，第二个评论有一个2级评论。内容帖子1有三个1级评论，只有一个有2级评论。
- en: '![](../../OEBPS/Images/CH11_F05_Farrell.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F05_Farrell.png)'
- en: Figure 11.5 The content and comment relationship structure forms a hierarchy.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 内容和评论的关系结构形成一个层次结构。
- en: Post content can contain markdown syntax, used at display rendering time, but
    is otherwise stored in the database as text. Comments on content won’t support
    markdown when displayed but are also stored as text. Aside from the title field
    associated with content, comments look very much like content when storing them
    in the database.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 帖子内容可以包含Markdown语法，在显示渲染时使用，但通常以文本形式存储在数据库中。内容上的评论在显示时不会支持Markdown，但也以文本形式存储。除了与内容相关的标题字段外，评论在数据库中存储时看起来非常像内容。
- en: This suggests a relationship between content and comments that we can take advantage
    of in the application. Content is stored in the `post` table, and it wouldn’t
    be unreasonable to store level 1 and 2 comments in separate tables based on the
    listed hierarchy. By creating separate tables, the `post` table could have a one-to-many
    relationship to level 1 comments, and level 1 comments could have a one-to-many
    relationship to level 2 comments.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明了内容和评论之间的一种关系，我们可以在应用中利用这种关系。内容存储在`post`表中，根据列出的层次结构，将1级和2级评论存储在单独的表中并不无理。通过创建单独的表，`post`表可以与1级评论形成一对一的关系，而1级评论可以与2级评论形成一对一的关系。
- en: A three-table database structure would work and provide the desired functionality.
    However, I think it has some drawbacks. First, content and comment posts are almost
    identical in structure. They both have content related to the user who posted
    them, and they have created and updated timestamps.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 三表数据库结构可以工作并提供所需的功能。然而，我认为它有一些缺点。首先，内容和评论帖子在结构上几乎相同。它们都与发布它们的用户相关的内容，并且有创建和更新时间戳。
- en: The primary difference between them is that comments don’t have a title. The
    SQLite database engine doesn’t allocate space in the database for text fields
    unless needed, so not using the title field doesn’t cost anything in terms of
    disk space.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间的主要区别是评论没有标题。SQLite数据库引擎不会为文本字段分配数据库空间，除非需要，因此不使用标题字段不会在磁盘空间上产生任何成本。
- en: The second drawback is the arbitrary two-level nesting limit of comments. For
    MyBlog, the two-level limit helps keep examples in this chapter within reason.
    In a publicly available application, the requirements could easily change to three,
    four, or more levels of comments. Extending support for more levels by using a
    table for each level means adding new tables, where each new table essentially
    replicates its parent table.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个缺点是评论的任意两级嵌套限制。对于MyBlog来说，两级限制有助于使本章的示例保持合理。在一个公开可用的应用中，要求可能会轻易地改变为三级、四级或更多级的评论。通过使用每个级别一个表来扩展对更多级别的支持意味着添加新表，其中每个新表本质上复制其父表。
- en: We can overcome these drawbacks by being clever. For example, rather than having
    content—level 1 and level 2 comments—in separate, nearly identical tables, why
    not extend the existing `Post` table to support both content and comment posts?
    This is possible by adding a `parent_uid` field to the table, as illustrated in
    figure 11.6\. In this way, a row can be the parent of another row while simultaneously
    being the child of some other parent row.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过巧妙的方法克服这些缺点。例如，与其将内容—1级和2级评论—存储在几乎相同的单独表中，为什么不扩展现有的`Post`表以支持内容和评论帖子呢？这可以通过向表中添加一个`parent_uid`字段来实现，如图11.6所示。这样，一行可以同时是另一行的父行和某些其他父行的子行。
- en: '![](../../OEBPS/Images/CH11_F06_Farrell.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F06_Farrell.png)'
- en: Figure 11.6 The self-referential `Post` table creates a hierarchal content/comment
    structure.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 自引用的 `Post` 表创建了一个层次化的内容/评论结构。
- en: We’ve created a self-referential hierarchy by adding the `parent_uid` to the
    `Post` table and making it a foreign key to the `post_uid` of the same table.
    Any row with a `parent_uid` equal to NULL is the root of a hierarchy and a content
    post. Any row with a non-NULL `parent_uid` references another row in the table
    and is a child comment. The `parent_uid` that a child row references can be a
    content post or a comment post.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将 `parent_uid` 添加到 `Post` 表并将其作为同一表的 `post_uid` 的外键，创建了一个自引用的层次结构。任何 `parent_uid`
    等于 NULL 的行是层次结构的根，也是一个内容帖子。任何非 NULL 的 `parent_uid` 引用表中的另一行，是一个子评论。子行引用的 `parent_uid`
    可以是内容帖子或评论帖子。
- en: Tip Self-referential tables are very useful when you’re trying to store hierarchical
    data. This is true if the nodes in the hierarchy are identical in structure, or
    close enough to identical.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：自引用表在尝试存储层次数据时非常有用。如果层次结构中的节点在结构上相同，或者足够接近相同，则这一点是正确的。
- en: Each row in the table can have a one-to-many relationship to a list of child
    rows within the same table. The top-level rows with no parent are content posts;
    others are comments. This structure has no inherent limit on the depth of comment
    nesting the table can support. With this self-referential structure, the two-level
    nesting constraint is a function of the application, not the database.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的每一行都可以与同一表内的子行列表建立一对一关系。没有父行的顶级行是内容帖子；其他的是评论。这种结构对表可以支持的评论嵌套深度没有固有的限制。使用这种自引用结构，两级的嵌套约束是应用程序的功能，而不是数据库的功能。
- en: 11.7.1 Modifying the post class
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.1 修改帖子类
- en: 'To implement the ERD diagram of the `Post` table, the `Post` class in the `models.py`
    module must be updated. You’ll see the changes in `examples/CH_11/examples/02/app/models.py`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `Post` 表的 ERD 图，必须在 `models.py` 模块中的 `Post` 类中进行更新。您将在 `examples/CH_11/examples/02/app/models.py`
    中看到更改：
- en: '[PRE10]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① Adds the parent_uid foreign key to post_uid of the post table
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将 `parent_uid` 外键添加到帖子表的 `post_uid`
- en: ② Adds the sort_key, which is an auto-incrementing value that’s not a primary
    key
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ② 添加 `sort_key`，它是一个非主键的自增值
- en: ③ Adds the child relationship, creates the list of children associated with
    this post, and adds "parent" to each child, referencing the child’s parent
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 添加子关系，创建与该帖子关联的子列表，并为每个子添加 "parent"，引用其父
- en: The `parent_uid` value creates the one-to-many relationship between rows of
    the `post` table. The `children` attribute doesn’t exist in the database but is
    created by SQLAlchemy when a `Post` object is returned by a query, adding a list
    of children associated with the post. It also adds a `parent` attribute to child
    rows referencing their parent row.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`parent_uid` 值在 `post` 表的行之间创建了一对多关系。`children` 属性在数据库中不存在，但由 SQLAlchemy 在查询返回
    `Post` 对象时创建，添加与帖子关联的子列表。它还向子行添加了一个 `parent` 属性，引用其父行。'
- en: 'The `sort_key` attribute is used to keep the hierarchy in properly nested order
    when displaying a content post and its related comments. The default value of
    `sort_key` is a custom Python function called when a new row is created:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort_key` 属性用于在显示内容帖子及其相关评论时保持适当的嵌套顺序。`sort_key` 的默认值是一个在创建新行时调用的自定义 Python
    函数：'
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `get_next_sort_key()` function gets the current max `sort_key` value from
    the `post` table, adds 1 to it, and returns that value. Having the function called
    as the default value of `sort_key` creates an automatically incrementing unique
    `sort_key` value for every row created in the `post` table. This behavior emulates
    the database’s autoincrement behavior for a primary key field. Unfortunately,
    SQLite doesn’t allow this behavior for nonprimary key fields, which `sort_key`
    is not. The value is used when querying the table to render a post and its hierarchy
    of comments, shown in another section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_next_sort_key()` 函数从 `post` 表中获取当前的 `sort_key` 最大值，将其加 1，并返回该值。将函数作为 `sort_key`
    的默认值创建了一个自动递增的唯一 `sort_key` 值，用于在 `post` 表中创建的每一行。这种行为模拟了数据库对主键字段的自增行为。不幸的是，SQLite
    不允许非主键字段有这种行为，而 `sort_key` 就不是。该值在查询表时使用，以渲染帖子及其评论层次结构，这在另一个部分中展示。'
- en: 11.7.2 Display handler
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.2 显示处理程序
- en: Comment posts are variations of content posts in the MyBlog application. Because
    of this, displaying, creating, and updating them are handled by modifying the
    existing handlers in `content.py`. Additional forms are added to get the user
    input to create comments. These changes are in the `examples/CH_11/examples/02/app`
    directory.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 评论帖子是 MyBlog 应用程序中内容帖子的变体。由于这个原因，显示、创建和更新它们是通过修改 `content.py` 中的现有处理程序来处理的。还添加了额外的表单以获取用户输入以创建评论。这些更改位于
    `examples/CH_11/examples/02/app` 目录中。
- en: The most significant change to the `content.py` module occurs in the `blog_
    post_display()` function. Displaying a MyBlog content post requires rendering
    any comments associated with the post in a meaningful hierarchical order. Structuring
    the `post` table in a clever manner and making it self-referential means you have
    to be clever with the query to get the post content and its comments.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`content.py` 模块最显著的变化发生在 `blog_post_display()` 函数中。显示 MyBlog 内容帖子需要以有意义的层次顺序渲染与帖子关联的任何评论。以巧妙的方式构建
    `post` 表并使其自引用意味着你必须对查询进行巧妙处理，以获取帖子内容和其评论。'
- en: Figure 11.5 indicates a treelike structure where one root node—a content post—branches
    out to multiple comment post nodes. This kind of structure can be traversed using
    recursion.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 显示了一个类似树的结构，其中一个根节点——内容帖子——分支到多个评论帖子节点。这种结构可以使用递归遍历。
- en: Because the content and comment posts are identical in definition, each one
    can have zero or many children; the same functionality can be applied to each.
    The list of associated children is iterated over at each node, and each child
    is descended into to use the functionality again.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内容和评论帖子在定义上是相同的，每个都可以有零个或多个子节点；相同的函数可以应用于每个。在节点上迭代关联的子节点列表，并进入每个子节点以再次使用该功能。
- en: The same functionality is applied again until a node with no children is reached,
    at which point the functionality ascends back to the child’s parent, and the next
    child is processed. This process continues until the entire tree attached to the
    content root node has been traversed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的功能会再次应用，直到达到没有子节点的节点，此时功能会上升至该子节点的父节点，并处理下一个子节点。这个过程会一直持续，直到整个附加到内容根节点的整个树都被遍历。
- en: To create this kind of functionality with SQLAlchemy, and ultimately in SQL,
    we’ll use common table expressions (CTE) with recursion. A CTE is a temporary,
    named result of an SQL query used within the context of a larger, enclosing query.
    A recursive CTE can traverse tree structures like the self-referential `Post`
    table.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 SQLAlchemy 创建此类功能，并在 SQL 中实现，我们将使用带有递归的公用表表达式（CTE）。CTE 是一个 SQL 查询的临时、命名的结果，用于更大、封装的查询的上下文中。一个递归
    CTE 可以遍历像自引用的 `Post` 表这样的树结构。
- en: 'The `blog_post_display(post_uid)` handler function has been simplified to:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`blog_post_display(post_uid)` 处理函数已被简化为：'
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This handler function is passed the `post_uid` value as a parameter from the
    URL that invoked the handler and takes the following steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理函数从调用处理器的 URL 中接收 `post_uid` 值作为参数，并执行以下步骤：
- en: Gets the form associated with the display for user comment input.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取与显示关联的表单，用于用户评论输入。
- en: Begins a database session context manager.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始数据库会话上下文管理器。
- en: Gets the hierarchy of the posts related to the `post_uid` value.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取与 `post_uid` 值相关的帖子层次结构。
- en: Did we get any return `posts`? If not, it aborts the request.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否得到了任何返回的 `posts`？如果没有，它将终止请求。
- en: Renders the `post.xhtml` template, passing it the form, and posts data.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染 `post.xhtml` 模板，传递表单和帖子数据。
- en: 'Getting the hierarchy of the posts results from calling the function `_build_posts_
    hierarchy(db_session,` `post_uid)`. This function moves the relative complexity
    of the recursive query out of the display function for clarity. The leading `_`
    character is just a convention to indicate the function is considered nonpublic.
    The `_build_posts_hierarchy()`function does the heavy lifting to get the hierarchy
    of the posts from the database starting from the root node (`parent_uid` equals
    NULL) and traverses the tree recursively to get all comments:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用函数 `_build_posts_hierarchy(db_session, post_uid)` 获取帖子的层次结构。此函数将递归查询的相对复杂性从显示函数中移出，以提高清晰度。前导下划线
    `_` 字符仅是一个约定，表示该函数被认为是非公开的。`_build_posts_hierarchy()` 函数负责从数据库中获取帖子的层次结构，从根节点（`parent_uid`
    等于 NULL）开始，并递归遍历树以获取所有评论：
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① Creates filters used to get the post matching the passed post_uid and ensure
    it’s a root (content) node
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建用于获取匹配传递的 `post_uid` 的帖子并确保它是一个根（内容）节点的过滤器
- en: ② Adds a filter so only posts the user is allowed to view are returned by the
    query
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ② 添加一个过滤器，以便查询只返回用户允许查看的帖子
- en: ③ Begins creating the recursive CTE
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 开始创建递归 CTE
- en: ④ Creates an alias for the Post class
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 为 Post 类创建一个别名
- en: ⑤ Completes the CTE
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 完成CTE
- en: ⑥ Queries the CTE for the hierarchical posts
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 查询 CTE 以获取层次化帖子
- en: This is the most complicated query in the MyBlog application and deserves an
    explanation. The `hierarchy` variable is set to the root node of the post based
    on the `post_uid` value. It’s also declared as a recursive CTE. Remember, recursive
    behavior descends a tree with similar operations on similar objects. That recursive
    behavior is provided by the `hierarchy` query instance having a `union_all()`
    operation applied to it. This descends the tree by connecting `parent_uid` with
    `post_uid` values.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 MyBlog 应用程序中最复杂的查询，值得解释。`hierarchy` 变量根据 `post_uid` 值设置为帖子的根节点。它也被声明为一个递归
    CTE。记住，递归行为通过在类似对象上执行类似操作来遍历树。这种递归行为是通过将 `union_all()` 操作应用于 `hierarchy` 查询实例来提供的。它通过连接
    `parent_uid` 和 `post_uid` 值来遍历树。
- en: Notice what’s going on with the `sort_key` value. The `sort_key` value is an
    auto-incrementing integer in the database, but the query casts it to a string
    labeled `sorting_key`. Comparing two posts by their `sort_key` values, the post
    with the higher `sort_key` value was inserted into the database after the post
    with the lower value. This is because the `sort_key` value auto-increments, so
    a new post inserted into the database gets a greater `sort_key` value than any
    other previous post.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `sort_key` 值的情况。`sort_key` 值是数据库中的一个自增整数，但查询将其转换为标记为 `sorting_key` 的字符串。通过比较两个帖子的
    `sort_key` 值，具有更高 `sort_key` 值的帖子是在数据库中插入具有较低值的帖子之后插入的。这是因为 `sort_key` 值是自增的，所以新插入数据库的帖子会得到比任何其他先前帖子更大的
    `sort_key` 值。
- en: The `sorting_key` value is a cumulative string of `sort_key` values, parent
    to child to child, separated by a space character. The `sorting_key` value provides
    the full path in descending chronological order to each post returned by the query.
    Because it is a string rather than a number, it sorts appropriately to display
    the post contents and its comments in order. The function returns the results
    of querying the recursive CTE and uses the `sorting_key` to apply an `order_by()`
    clause.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorting_key` 值是一个由 `sort_key` 值累积而成的字符串，从父级到子级再到子级，由空格字符分隔。`sorting_key` 值提供了查询返回的每个帖子的完整路径，按降序时间顺序排列。因为它是一个字符串而不是一个数字，所以它能够适当地排序以按顺序显示帖子内容和其评论。该函数返回查询递归
    CTE 的结果，并使用 `sorting_key` 应用一个 `order_by()` 子句。'
- en: 11.7.3 Display template
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.3 显示模板
- en: 'The `post.xhtml` template is modified to display the post content and its comments.
    It has two phases: the first renders the content much as before; the second adds
    the hierarchy of related comments indented to indicate the hierarchy.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`post.xhtml` 模板被修改以显示帖子内容和其评论。它有两个阶段：第一阶段与之前几乎相同地渲染内容；第二阶段添加了相关评论的层次结构，并缩进以表示层次。'
- en: Because a content post can have many comments, the template iterates over the
    comment posts to render them to the HTML page. The rendering operation is almost
    identical for each comment, so the functionality is in a macro that is called
    during each iteration of the comment loop. The indent level of each comment is
    determined by splitting the `sorting_key` value of the post on space characters
    and using the length of the returned array to calculate the indent level.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内容帖子可以有多个评论，模板会遍历评论帖子以将它们渲染到 HTML 页面。对于每个评论，渲染操作几乎相同，因此功能在一个在评论循环的每次迭代期间调用的宏函数中。每个评论的缩进级别是通过在空格字符上拆分帖子的
    `sorting_key` 值并使用返回数组的长度来计算缩进级别确定的。
- en: The template also provides interface elements to create new comments and edit
    existing ones. This is done by using the Bootstrap modal functionality to open
    a dialog window over the current display to create and edit comments. A macro
    function provides the necessary modal HTML.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 模板还提供了创建新评论和编辑现有评论的界面元素。这是通过使用 Bootstrap 模态功能在当前显示上打开一个对话框窗口来创建和编辑评论来完成的。一个宏函数提供了必要的模态
    HTML。
- en: Both the comment and modal macros are in a new file. Keeping with the Blueprint
    namespacing, the template imports a content-specific macro file, `content_macros
    .jinja`. This file is located in the `content/templates` folder. Running the MyBlog
    application in `examples/CH_11/examples/02` and navigating to a post that contains
    content and related comments renders a page that displays both. Figure 11.7 is
    a screenshot of the rendered display.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 评论和模态宏都位于一个新文件中。遵循Blueprint命名空间，模板导入了一个特定于内容的多文件，`content_macros .jinja`。此文件位于`content/templates`文件夹中。在`examples/CH_11/examples/02`中运行MyBlog应用程序并导航到一个包含内容和相关评论的帖子，将渲染一个显示两者的页面。图11.7是渲染显示的截图。
- en: '![](../../OEBPS/Images/CH11_F07_Farrell.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F07_Farrell.png)'
- en: Figure 11.7 The content display will also show any related comments and subcomments.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 内容显示还将显示任何相关的评论和子评论。
- en: 11.8 Creating comments
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.8 创建评论
- en: The previous display shows user interface elements to create comments on the
    content and comment on an existing comment. Both behaviors depend on creating
    a post that references a parent post.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的显示展示了用于在内容上创建评论和在现有评论上评论的用户界面元素。这两种行为都依赖于创建一个引用父帖的帖子。
- en: 11.8.1 Creation template
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.8.1 创建模板
- en: We’re changing the order of the presentation to talk about the comment creation
    template first because it exists in the `post.xhtml` template already. Rather
    than navigate away from the currently displayed post to create a comment, MyBlog
    uses Bootstrap’s ability to create modal windows.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在改变演示的顺序，首先讨论评论创建模板，因为它已经存在于`post.xhtml`模板中。而不是离开当前显示的帖子去创建评论，MyBlog使用Bootstrap创建模态窗口的能力。
- en: Modal windows are subordinate to the main window but disable interaction and
    display as a child window over the main window. This is useful in UI design to
    help keep the user’s frame of reference connected to the task at hand.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 模态窗口从属于主窗口，但禁用交互并以子窗口的形式显示在主窗口之上。这在UI设计中很有用，可以帮助保持用户的参考框架与当前任务相关联。
- en: Bootstrap creates the HTML elements of a modal window in the HTML of the window
    the modal will appear over. The containing HTML `DOM` element of the modal window
    is set to invisible when the parent window is rendered and appears because of
    an action by the user.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap在模态窗口将要出现的窗口的HTML中创建模态窗口的HTML元素。当父窗口渲染时，模态窗口的包含HTML `DOM`元素被设置为不可见，它因为用户的操作而出现。
- en: 'At the end of the `post.xhtml` template, a call to a content macro is made:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`post.xhtml`模板的末尾，调用了一个内容宏：
- en: '[PRE14]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The file `examples/CH_11/examples/02/app/content/template/content-macros.jinja`
    contains the macro code. The macro inserts the HTML elements necessary to build
    the modal window into the rendered post display.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`examples/CH_11/examples/02/app/content/template/content-macros.jinja`包含宏代码。该宏将构建模态窗口所需的HTML元素插入到渲染的帖子显示中。
- en: Each of the comment buttons in the display activates the modal window, making
    it visible (figure 11.8 ). The modal window presents a form with an HTML text
    area to enter the comment. It also has a hidden field populated with the `post_uid`
    value of the parent post to which this comment relates. The hidden field was populated
    by the Comment button when it was clicked. The Create button submits the form
    to be processed, and the Cancel button closes the modal window. Because the modal
    exists in the `post.xhtml` template, the parent form elements were available when
    the template was rendered.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 显示中的每个评论按钮都会激活模态窗口，使其可见（图11.8）。模态窗口展示一个表单，包含一个HTML文本区域用于输入评论。它还包含一个隐藏字段，其中填充了与该评论相关的父帖的`post_uid`值。隐藏字段是在点击评论按钮时被填充的。创建按钮提交表单以进行处理，取消按钮关闭模态窗口。因为模态窗口存在于`post.xhtml`模板中，所以当模板渲染时，父表单元素都是可用的。
- en: '![](../../OEBPS/Images/CH11_F08_Farrell.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F08_Farrell.png)'
- en: Figure 11.8 Creating a comment happens in a modal window over the current content
    display.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 创建评论发生在当前内容显示上的模态窗口中。
- en: 11.8.2 Creation form
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.8.2 创建表单
- en: The form to handle creating a comment exists in the `app/content/forms.py` module.
    This simple form creates the hidden field for the `parent_post_uid` of the parent
    post, the text area field for the comment, and the create submit button.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 处理创建评论的表单存在于`app/content/forms.py`模块中。这个简单的表单创建了父帖的`parent_post_uid`隐藏字段，评论的文本区域字段，以及创建提交按钮。
- en: 11.8.3 Creation handler
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.8.3 创建处理程序
- en: 'When a user has entered comment text and clicked the Create button, the form
    is submitted to the handler as an HTTP `POST` request to the URL "`/blog_post_
    create_comment`":'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入了评论文本并点击创建按钮后，表单以HTTP `POST`请求的形式提交给处理器，请求的URL是"`/blog_post_create_comment`"：
- en: '[PRE15]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The handler is responsible for validating the submitted form and creating the
    new comment post in the database. The created post has a `parent_uid` value that
    comes from making this a child of that post.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器负责验证提交的表单并在数据库中创建新的评论帖子。创建的帖子有一个`parent_uid`值，这是通过将其作为该帖子的子级来生成的。
- en: After the comment post is committed to the database, the `while` loop exists
    to iterate up the hierarchy and get the root post. The root post is used to redirect
    the user to the root post of the hierarchy where the newly created comment will
    be rendered and displayed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在将评论帖子提交到数据库后，`while`循环用于迭代层次结构并获取根帖子。根帖子用于将用户重定向到层次结构中根帖子，新创建的评论将在那里渲染和显示。
- en: 11.9 Notifying users
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.9 通知用户
- en: Another feature we’d like to add to the MyBlog application is notifying users
    when someone they’re following creates a new content post. A user who comments
    on a post is automatically added as a follower of the post.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望添加到MyBlog应用程序的一个新功能是，当某人他们关注的用户创建新的内容帖子时通知用户。在帖子上发表评论的用户会自动成为该帖子的关注者。
- en: 'Implementing followers creates a many-to-many relationship between users and
    posts. A user can follow many posts, and many users can follow a single post.
    As was shown in chapter 10, a many-to-many relationship uses an association table
    to connect two other tables. The `examples/CH_11/examples/03/app/models.py` module
    is modified to add the association table:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 实现关注者创建用户和帖子之间的多对多关系。一个用户可以关注多个帖子，多个用户可以关注单个帖子。正如第10章所示，多对多关系使用关联表来连接两个其他表。`examples/CH_11/examples/03/app/models.py`模块被修改以添加关联表：
- en: '[PRE16]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Instead of a class to model the `user_post` table, it’s created as an instance
    of the `Table` class of SQLAlchemy. The `user_post` table has just two fields—foreign
    keys to the primary keys of each of the associated tables. The user model class
    is also modified to add the many-to-many relationship connection between it and
    the `Post` model:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是创建一个用于模型化`user_post`表的类，它被创建为SQLAlchemy的`Table`类的实例。`user_post`表只有两个字段——指向相关表主键的外键。用户模型类也被修改，以添加它和`Post`模型之间的多对多关系连接：
- en: '[PRE17]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `user.posts_followed` attribute doesn’t exist in the database but is maintained
    by SQLAlchemy. An instance of the `User` class returned from a query will have
    the `posts_followed` attribute as a list of `Post` instances.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`user.posts_followed`属性不在数据库中，而是由SQLAlchemy维护。从查询返回的`User`类实例将有一个`posts_followed`属性，该属性是一个`Post`实例列表。'
- en: The `secondary` parameter connects a `User` instance with a `Post` instance
    through the `user_post` association table. The `backref` parameter creates a `users_
    following` attribute in the `Post` class. This also isn’t in the database but
    is maintained by SQLAlchemy. For a `Post` instance, the attribute `users_following`
    is a list of `User` instances following the `Post`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`secondary`参数通过`user_post`关联表将一个`User`实例与一个`Post`实例连接起来。`backref`参数在`Post`类中创建了一个`users_following`属性。这也不在数据库中，而是由SQLAlchemy维护。对于`Post`实例，`users_following`属性是一个跟随该`Post`的`User`实例列表。'
- en: 'To populate the `user_post` association table and create the many-to-many relationship,
    the `blog_post_create_comment()` handler function is modified with the addition
    of the following lines of code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要填充`user_post`关联表并创建多对多关系，`blog_post_create_comment()`处理器函数通过添加以下代码行进行了修改：
- en: '[PRE18]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `while` loop to traverse upward in the post hierarchy was created in the
    previous example to get the `root_post` value. The two new functions—`follow_root_
    post()` and `notify_root_post_followers()`—use the `root_post` value:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中创建了一个向上遍历帖子层次结构的`while`循环，以获取`root_post`值。两个新函数`follow_root_post()`和`notify_root_post_followers()`使用`root_post`值：
- en: '[PRE19]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `follow_root_post()` function gets an instance of the `current user`. When
    the `user` is found, the `root_post` is added to the `posts_followed` list if
    the `user` isn’t already following that post:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`follow_root_post()`函数获取当前用户的实例。当找到`user`时，如果该`user`尚未关注该帖子，则将`root_post`添加到`posts_followed`列表中：'
- en: '[PRE20]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `notify_root_post_followers()` function first sets the `post_url` variable
    to the URL of the newly created content post. It then iterates over the list of
    the users who follow the post’s author. Inside the loop, it uses the emailer module
    created for authentication to send a short email containing the `post_url` to
    the `user_following` user.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`notify_root_post_followers()`函数首先将`post_url`变量设置为新建内容帖子的URL。然后它遍历关注帖子作者的用户的列表。在循环内部，它使用为认证创建的emailer模块发送包含`post_url`的简短电子邮件给`user_following`用户。'
- en: 11.10 Handling site errors
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.10 处理站点错误
- en: So far, the MyBlog application has tried to handle errors and exceptions gracefully
    and redirect the user to another place in the application. Where exceptions have
    been raised and caught in try/except blocks, the exception handling has consisted
    of either logging the error or raising another, more specific one.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，MyBlog应用程序已经尝试优雅地处理错误和异常，并将用户重定向到应用程序的另一个部分。在try/except块中抛出和捕获异常的情况下，异常处理包括记录错误或抛出另一个更具体的异常。
- en: Flask handles exceptions that bubble up by rendering very generic HTML to display
    the exception message. This is great because the exception was handled and reported
    and didn’t crash the MyBlog application, but it’s not a good user experience.
    A better solution is for the exception to be reported within the context of the
    MyBlog application, with the navigation bar present and a quick way to get back
    to another part of the experience.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Flask通过渲染非常通用的HTML来显示异常信息来处理冒泡的异常。这很好，因为异常得到了处理和报告，没有使MyBlog应用程序崩溃，但这并不是一个好的用户体验。更好的解决方案是在MyBlog应用程序的上下文中报告异常，同时保留导航栏并提供快速返回应用程序其他部分的方法。
- en: 'Flask provides mechanisms to register error-handling functions using the `register_error_handler`
    method that is part of the app instance. Looking at `examples/CH_11/examples/04/app/__init__.py`
    in the `create_app()` function, you’ll see these lines of code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Flask提供了使用应用实例的`register_error_handler`方法注册错误处理函数的机制。查看`examples/CH_11/examples/04/app/__init__.py`中的`create_app()`函数，你会看到这些代码行：
- en: '[PRE21]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These lines of code use the Flask app instance that the `create_app()` function
    generated to call the `register_error_handler()` method. The first parameter to
    the call is the HTTP error code for which an error handler function is registered,
    and the second is the name of the handler function.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码行使用`create_app()`函数生成的Flask应用实例来调用`register_error_handler()`方法。调用时的第一个参数是已注册错误处理函数的HTTP错误代码，第二个参数是处理函数的名称。
- en: 'The method is called twice, once for a `404` (Page Not Found) error and again
    for a `500` (Internal Server Error) error. Any number of other standard HTTP errors
    can be handled in this way. Both calls register the same `error_page()` function
    as the handler. The `error_page()` function is at the bottom of the `__init__.py`
    module:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法被调用两次，一次是为了`404`（页面未找到）错误，另一次是为了`500`（内部服务器错误）错误。可以通过这种方式处理任意数量的其他标准HTTP错误。两次调用都注册了相同的`error_page()`函数作为处理程序。`error_page()`函数位于`__init__.py`模块的底部：
- en: '[PRE22]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This function is passed the exception that caused the error as a parameter.
    Inside the function, a new template, "`error.xhtml`", is rendered and passed the
    exception value. The exception code value is used as the HTTP return value for
    the page. The `examples/CH_11/examples/04/app/templates/error.xhtml` template
    file does a few simple things:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将导致错误的异常作为参数传递。在函数内部，渲染了一个新的模板"`error.xhtml`"，并将异常值传递给它。异常代码值用作页面的HTTP返回值。`examples/CH_11/examples/04/app/templates/error.xhtml`模板文件执行了一些简单操作：
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In terms of user experience, the most important thing is the template inheriting
    from "`base.xhtml`". This gives the page the style of the rest of the MyBlog application
    and its navigation bar. In addition, this gives users who find themselves on an
    error page a way to get back to another page in the application. The rest of the
    template styles the output of the exception code, name, and description as a Bootstrap
    card.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户体验方面，最重要的是模板继承自"`base.xhtml`"。这赋予了页面与MyBlog应用程序其余部分及其导航栏相同的样式。此外，这为发现自己处于错误页面的用户提供了一种返回应用程序其他页面的方法。模板的其余部分将异常代码、名称和描述的输出样式化为Bootstrap卡片。
- en: Cross-site scripting
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本
- en: Another area of concern that the code in `examples/CH_11/examples/04` attempts
    to handle are cross-site scripting (XSS) injection attacks. This kind of attack
    occurs when JavaScript is injected into a site and later runs on another user’s
    browser.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在 `examples/CH_11/examples/04` 中尝试处理的另一个关注领域是跨站脚本（XSS）注入攻击。这种攻击发生在 JavaScript
    被注入到网站中，并在稍后运行在其他用户的浏览器上时。
- en: 'Because creating content and comments lets the user enter plain text, that
    text could contain embedded JavaScript code in this form:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建内容和评论允许用户输入纯文本，因此该文本可能包含以下形式的嵌入 JavaScript 代码：
- en: '[PRE24]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The text is then saved in the database. If another user views the post containing
    this JavaScript, their browser has no way of knowing the script could be dangerous
    and runs it.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 文本随后被保存在数据库中。如果另一个用户查看包含此 JavaScript 的帖子，他们的浏览器无法知道该脚本可能存在危险并执行它。
- en: 'To prevent this behavior, a new module called `Bleach` is used to sanitize
    the user input text. The `Bleach` module is part of the `requirements.txt` file
    for this chapter and is imported at the top of the `content/forms.py` module.
    The user-entered text is filtered by the `content/forms.py` module before being
    saved:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种行为，使用了一个名为 `Bleach` 的新模块来清洗用户输入的文本。`Bleach` 模块是本章 `requirements.txt` 文件的一部分，并在
    `content/forms.py` 模块的顶部导入。在保存之前，用户输入的文本会通过 `content/forms.py` 模块进行过滤：
- en: '[PRE25]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This function uses the `bleach.clean` method to sanitize the `input_string`
    parameter if it is not `None`, otherwise it just returns `input_string`. The `remove_
    html_and_script_tags()` function is added to all of the form classes that contain
    `StringField` or `PageDownField` elements. As an example, the `PostForm` `content`
    field has been updated to this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数如果 `input_string` 参数不是 `None`，则使用 `bleach.clean` 方法清洗 `input_string` 参数，否则它只返回
    `input_string`。`remove_html_and_script_tags()` 函数被添加到包含 `StringField` 或 `PageDownField`
    元素的表单类中。例如，`PostForm` 的 `content` 字段已更新为如下所示：
- en: '[PRE26]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `filters` parameter is passed a tuple, the first element being the `remove_
    html_and_script_tags` function. When the form is submitted to the server, the
    filter function will be executed before the form provides the data during calls
    like this in `blog_post_create()`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`filters` 参数传递了一个元组，第一个元素是 `remove_html_and_script_tags` 函数。当表单提交到服务器时，在表单提供数据之前，过滤器函数将在
    `blog_post_create()` 中的此类调用之前执行：'
- en: '[PRE27]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this way, any embedded HTML code/scripts are disabled before the content
    is saved to the database.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，在内容保存到数据库之前，任何嵌入的 HTML 代码/脚本都被禁用。
- en: 11.11 Closing thoughts
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.11 结束语
- en: This was a lot of ground to cover, and even if it uses some patterns you’ve
    seen before in other parts of the application, it represents a significant milestone
    in developing your skill set. By developing the MyBlog application, you’re now
    able to zoom out to see the big picture necessary to build a larger application.
    You’re also able to zoom in to see the detailed view needed to implement the parts
    of a big application.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段很长的内容，即使它使用了您在其他应用程序部分中看到的一些模式，但它代表了在您的技能集中取得的一个重大里程碑。通过开发 MyBlog 应用程序，您现在能够从宏观上看到构建更大应用程序所需的整体图景。您也能够从微观上看到实现大型应用程序各个部分的详细视图。
- en: The MyBlog application is now complete, as it has met the book’s stated goals.
    As a teaching tool, I hope it has served you well. The application offers many
    opportunities for addition, modification, and improvement. I also think it’s a
    good reference if you tackle developing another web application. To adapt an old
    cliché, “That’s left as an exercise for the developer.”
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog 应用程序现在已经完成，因为它已经达到了本书所设定的目标。作为一个教学工具，我希望它已经很好地为您服务。该应用程序提供了许多添加、修改和改进的机会。我也认为，如果您着手开发另一个
    Web 应用程序，它是一个很好的参考。为了适应一个老生常谈的说法，“这留作开发者的练习。”
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Python classes using SQLAlchemy generate the MyBlog API to create posts and
    the user’s relation to those posts. Doing so models the database tables, making
    them available to your Python application.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQLAlchemy 的 Python 类生成 MyBlog API 以创建帖子以及用户与这些帖子之间的关系。这样做可以模拟数据库表，使它们可用于您的
    Python 应用程序。
- en: By capitalizing on the `Flask-PageDown` module, we’ve added useful functionality
    to the MyBlog application without having to code that functionality ourselves.
    This is a key feature of an evolved developer, being able to recognize the talents
    of others and incorporate it into our own work.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过利用 `Flask-PageDown` 模块，我们向 MyBlog 应用程序添加了有用的功能，而无需自己编写这些功能。这是进阶开发者的一项关键特性，即能够识别他人的才能并将其融入我们的工作中。
- en: Self-referential hierarchal data maintained in a single database table is a
    powerful concept and feature of which to take advantage. By using common table
    expressions (CTEs) and recursion, it’s possible to achieve this with SQLAlchemy
    and Python.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单个数据库表中维护的自引用分层数据是一个强大的概念，并且是一个值得利用的特性。通过使用公共表表达式（CTEs）和递归，使用 SQLAlchemy 和
    Python 实现这一点是可能的。
- en: Bootstrap has useful capabilities to create modal dialog boxes. These are useful
    to produce a form to gather data and keep them in the context of their current
    workflow. Using a modal to create comments on user content posts takes advantage
    of this feature.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bootstrap 具有创建模态对话框的有用功能。这些功能用于生成表单以收集数据，并保持它们在其当前工作流程的上下文中。使用模态对话框来对用户内容帖子进行评论，就是利用了这一特性。
