- en: 1  What is Express?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1  什么是 Express？
- en: Before we talk about Express, we need to talk about Node.js.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们谈论 Express 之前，我们需要先谈谈 Node.js。
- en: For most of its life, the JavaScript programming language has lived inside of
    web browsers. It started as a simple scripting language for modifying small details
    of webpages, but grew into a complex language, with loads of applications and
    libraries. Many browser vendors like Mozilla and Google began to pump lots of
    resources into fast JavaScript runtimes, and Google Chrome and Mozilla Firefox
    got much faster JavaScript engines as a result.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在其生命的大部分时间里，JavaScript 编程语言都生活在 Web 浏览器中。它最初是一种简单的脚本语言，用于修改网页的细节，但后来发展成为一种复杂的语言，拥有大量的应用程序和库。许多浏览器厂商，如
    Mozilla 和 Google，开始投入大量资源到快速的 JavaScript 运行时中，因此 Google Chrome 和 Mozilla Firefox
    的 JavaScript 引擎变得更快。
- en: In 2009, Node.js came around. Node took V8, Google Chrome's powerful JavaScript
    engine, out of the browser and made it able to run on servers. In the browser,
    developers had no choice but to choose JavaScript. In addition to Ruby, Python,
    C#, Java, or other languages, developers could now choose JavaScript when developing
    server-side applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 2009 年，Node.js 出现了。Node 将 Google Chrome 的强大 JavaScript 引擎 V8 从浏览器中提取出来，使其能够在服务器上运行。在浏览器中，开发者别无选择，只能选择
    JavaScript。除了 Ruby、Python、C#、Java 或其他语言外，开发者现在在开发服务器端应用程序时也可以选择 JavaScript。
- en: JavaScript might not be the perfect language for everyone, but Node.js had some
    real benefits. For one, the V8 JavaScript engine is fast, and Node encourages
    an asynchronous coding style, making for faster code while avoiding multi-threaded
    nightmares. JavaScript also had a bevy of useful libraries because of its popularity.
    But the biggest benefit of Node.js is the ability to share code between browser
    and server. Developers don't have to do any kind of context switch when switching
    between client and server. Now they can use the same code and the same coding
    paradigms between two different JavaScript runtimes; the browser and the server.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 可能不是适合每个人的完美语言，但 Node.js 有一些真正的优势。首先，V8 JavaScript 引擎速度快，Node 鼓励异步编程风格，这使得代码运行更快，同时避免了多线程的噩梦。由于
    JavaScript 的流行，它也拥有大量的有用库。但 Node.js 最大的好处是能够在浏览器和服务器之间共享代码。开发者不需要在客户端和服务器之间进行任何类型的上下文切换。现在，他们可以在两个不同的
    JavaScript 运行时（浏览器和服务器）之间使用相同的代码和相同的编程范式。
- en: Node.js caught on—people thought it was pretty cool.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 开始流行起来——人们认为它非常酷。
- en: Like browser-based JavaScript, Node.js provides a bevy of low-level features
    you'd need to build an application. But like browser-based JavaScript, its low-level
    offerins can be a bit verbose and difficult.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于浏览器的 JavaScript 一样，Node.js 提供了一系列低级功能，您需要这些功能来构建应用程序。但与基于浏览器的 JavaScript
    一样，其低级功能可能有点冗长且难以理解。
- en: Enter Express.js. Express is a framework that acts as light layer on top of
    the Node.js web server, making it more pleasant to develop Node.js web applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 Express.js。Express 是一个框架，它作为 Node.js Web 服务器的轻量级层，使得开发 Node.js Web 应用程序更加愉快。
- en: Express.js is philosophically similar to jQuery. People want to add dynamic
    content to their webpages, but the “vanilla” browser APIs can be verbose, confusing,
    and limited in features. Developers often have to write a lot of boilerplate code.
    jQuery exists to cut down on this boilerplate code by simplifying the APIs of
    the browser and adding helpful new features. That's basically it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从哲学上讲，Express.js 与 jQuery 类似。人们想向他们的网页添加动态内容，但“纯”浏览器 API 可能会很冗长、令人困惑，并且功能有限。开发者经常不得不编写大量的样板代码。jQuery
    的存在就是为了减少这种样板代码，通过简化浏览器的 API 并添加有用的新功能。基本上就是这样。
- en: Express is exactly the same. People want to make web applications with Node.js,
    but the “vanilla” Node.js APIs can be verbose, confusing, and limited in features.
    Developers often have to write a lot of boilerplate code. Express exists to cut
    down on this boilerplate code by simplifying the APIs of Node.js and adding helpful
    new features. That's basically it!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Express 完全一样。人们想用 Node.js 开发 Web 应用程序，但“纯”Node.js API 可能会很冗长、令人困惑，并且功能有限。开发者经常不得不编写大量的样板代码。Express
    的存在就是为了减少这种样板代码，通过简化 Node.js 的 API 并添加有用的新功能。基本上就是这样！
- en: Like jQuery, Express aims to be extensible. It's hands-off about most parts
    of your applications' decisions and is easily extended with third-party libraries.
    Throughout this book and your Express career, you'll have to make decisions about
    your applications' architectures and you'll extend Express with a bevy of powerful
    third-party modules.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 就像jQuery一样，Express旨在可扩展。它对您应用程序的大部分决策采取放手的态度，并且可以很容易地通过第三方库进行扩展。在这本书和您的Express生涯中，您将不得不就您应用程序的架构做出决定，并且您将通过一系列强大的第三方模块扩展Express。
- en: You probably didn't pick up this book for the “in short” definition, though.
    The rest of this chapter (and book, really) will discuss Express in much more
    depth.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不会为了“简而言之”的定义而选择这本书。本章的其余部分（以及整本书）将更深入地讨论Express。
- en: NOTE This book assumes that you are proficient in JavaScript, but not Node.js.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本书假设您熟悉JavaScript，但不熟悉Node.js。
- en: 1.1     What is this Node.js business?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1      Node.js是什么？
- en: Node.js is no child's play.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js不是儿戏。
- en: When I first started using Node.js, I was confused. What is it?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始使用Node.js时，我很困惑。这是什么？
- en: Node.js (often shortened to "Node") is just a JavaScript platform—a way to run
    JavaScript. Most of the time, JavaScript is run in web browsers. But there's nothing
    about the JavaScript language that requires it to be run in a browser. It's a
    programming language just like Ruby or Python or C++ or PHP or Java. Sure, there
    are JavaScript runtimes bundled with all popular web browsers, but that doesn't
    mean that it has to be run there. If you were running a Python file called myfile.py,
    you would run `python myfile.py`. But you could write your own Python interpreter,
    call it SnakeWoman, and run `snakewoman myfile.py`. They did the same with Node;
    instead of typing `javascript myfile.js`, you type `node myfile.js`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js（通常简称为“Node”）只是一个JavaScript平台——一种运行JavaScript的方式。大多数情况下，JavaScript是在网页浏览器中运行的。但JavaScript语言本身并没有要求它必须在浏览器中运行。它是一种编程语言，就像Ruby、Python、C++、PHP或Java一样。当然，所有流行的网页浏览器都捆绑了JavaScript运行时，但这并不意味着它必须在那里运行。如果您正在运行一个名为myfile.py的Python文件，您会运行`python
    myfile.py`。但您可以编写自己的Python解释器，命名为SnakeWoman，然后运行`snakewoman myfile.py`。他们用Node做了同样的事情；您不需要输入`javascript
    myfile.js`，而是输入`node myfile.js`。
- en: Running JavaScript outside of the browser lets us do a lot—anything a "regular"
    programming language could do, really—but it's mostly used for web development.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器之外运行JavaScript让我们可以做很多事情——实际上任何“常规”编程语言都能做的事情——但它主要用于Web开发。
- en: Okay, so we can run JavaScript on the server—why would we do this?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以我们可以将JavaScript运行在服务器上——我们为什么要这样做呢？
- en: A lot of developers will tell you that Node.js is fast, and that's true. Node
    isn't the fastest thing on the market by any means, but it's fast for two reasons.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者会告诉您Node.js运行速度快，这是真的。Node.js并不是市场上最快的东西，但它有两个原因使其运行速度快。
- en: 'The first is pretty simple: the JavaScript engine is fast. It''s based on the
    engine used in Google Chrome, which has a famously quick JavaScript engine. It
    can execute JavaScript like there''s no tomorrow, processing thousands of instructions
    a second.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个原因很简单：JavaScript引擎速度快。它基于Google Chrome中使用的引擎，该引擎以其快速的JavaScript引擎而闻名。它可以像没有明天一样执行JavaScript，每秒处理数千条指令。
- en: The second reason for its speed is in its ability to handle concurrency, and
    it's a bit less straightforward. Its performance comes from its asynchronous workings.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因是它处理并发的能力，这稍微复杂一些。它的性能来自于其异步操作。
- en: The best real-world analogy I can come up with is baking. Let's say I'm making
    some muffins. I have to prepare some batter. While I'm preparing the batter, I
    can't really do other things. I can't sit down and read a book, I can't cook something
    else, et cetera. But once I put the muffins in the oven, I don't just stand there
    looking at the oven until it's done—I go do something else. Maybe I start preparing
    more batter. Maybe I read a book. In any case, I don't have to wait for the muffins
    to be finished cooking for me to be able to do something.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我能想到的最佳现实类比是烘焙。假设我在做一些松饼。我必须准备一些面糊。在我准备面糊的时候，我实际上不能做其他事情。我不能坐下来看书，不能做其他烹饪，等等。但一旦我把松饼放进烤箱，我并不会站在那里盯着烤箱直到它做好——我会去做其他事情。也许我开始准备更多的面糊。也许我读一本书。无论如何，我不必等待松饼做好才能做其他事情。
- en: In Node.js, a browser might request something from your server. You begin responding
    to this request and another request comes in. Let's say both requests have to
    talk to an external database. You can ask the external database about the first
    request, and while that external database is thinking, you can begin to respond
    to the second request. You're not doing two things at once, but when someone else
    is working on something, you're not held up waiting.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，浏览器可能会向你的服务器请求某些内容。你开始响应这个请求，然后另一个请求到来。假设这两个请求都需要与外部数据库通信。你可以询问外部数据库关于第一个请求的信息，而在外部数据库思考的时候，你可以开始响应第二个请求。你并不是同时做两件事，但当别人在工作时，你不会被等待所阻碍。
- en: Other runtimes don't have this luxury built-in by default. Ruby on Rails, for
    example, can really only process one request at a time. To process more than one
    at a time, you effectively have to buy more servers. (There are, of course, many
    asterisks to this claim.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 其他运行时没有默认内置这种奢侈。例如，Ruby on Rails实际上一次只能处理一个请求。要同时处理多个请求，你实际上不得不购买更多的服务器。（当然，这个说法有很多限制。）
- en: 'Figure 1.1 demonstrates what this might look like:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1展示了这可能会是什么样子：
- en: '![](../Images/01_01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_01.png)'
- en: Figure 1.1 Comparing asynchronous code (like Node) to synchronous code. Note
    that asynchronous code can complete much faster, even though you're never executing
    your code in parallel.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 比较异步代码（如Node）与同步代码。请注意，尽管你永远不会并行执行代码，但异步代码可以完成得更快。
- en: 'I don''t mean to tell you that Node.js is the fastest in the world because
    of its asynchronous capabilities. Node.js can really squeeze a lot of performance
    out of one CPU core, but it doesn''t excel with multiple cores. Other programming
    languages truly allow you to actively do two things at once. To reuse the baking
    example: other programming languages let you buy more ovens so that you can bake
    more muffins simultaneously. Node is beginning to support this functionality but
    it is not as "first-class" in Node as it is in other programming languages.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是说Node.js因为其异步能力而成为世界上最快的。Node.js确实可以从一个CPU核心中挤出很多性能，但它并不擅长多核心。其他编程语言确实允许你同时积极做两件事。用烘焙的例子来说：其他编程语言让你可以购买更多的烤箱，这样你就可以同时烤更多的松饼。Node开始支持这种功能，但它在Node中的“一等”程度不如在其他编程语言中。
- en: Personally, I don't believe that performance is the biggest reason to choose
    Node. While it's faster than other scripting languages like Ruby or Python, I
    think the biggest reason is the fact that it's all one programming language.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我不认为性能是选择Node的最大原因。虽然它比Ruby或Python等其他脚本语言要快，但我认为最大的原因是它是一种编程语言。
- en: Often, when you're writing a web application, you'll be using JavaScript. But
    before Node, you'd have to code everything in two different programming languages.
    You'd have to learn two completely different technologies, paradigms, and libraries.
    With Node, a backend developer can jump into front-end code and vice-versa. Personally,
    I think this is the most powerful feature of the runtime.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你编写Web应用程序时，你会使用JavaScript。但在Node之前，你必须用两种不同的编程语言编写所有内容。你必须学习两种完全不同的技术、范式和库。有了Node，后端开发者可以跳入前端代码，反之亦然。我个人认为这是运行时最强大的功能。
- en: 'Other people seem to agree with me: people have created the "MEAN stack", which
    is an all-JavaScript web application stack consisting of MongoDB (a database controlled
    by JavaScript), Express, Angular.js (a front-end JavaScript framework), and Node.js.
    The "JavaScript everywhere" mentality is a huge benefit of Node.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎其他人也同意我的观点：人们创建了“MEAN堆栈”，这是一个全JavaScript的Web应用程序堆栈，包括MongoDB（由JavaScript控制的数据库）、Express、Angular.js（一个前端JavaScript框架）和Node.js。“JavaScript无处不在”的心态是Node的一个巨大优势。
- en: Large companies are even getting behind Node; the list includes Walmart, the
    BBC, LinkedIn, and PayPal. It's no child's play.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大型公司甚至开始支持Node；其中包括沃尔玛、BBC、领英和PayPal。这不是儿戏。
- en: 1.2     What is Express?
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2     什么是Express？
- en: Express is a relatively small framework that sits on top of Node.js's web server
    functionality to simplify its APIs and add helpful new features. It makes it easier
    to organize your application’s functionality with middleware and routing; it adds
    helpful utilities to Node.js’s HTTP objects; it facilitates the rendering of dynamic
    HTML views; it defines an easily-implemented extensibility standard. This book
    explores those features in a lot more depth, so all of that lingo will be demystified
    soon.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Express是一个相对较小的框架，它位于Node.js的Web服务器功能之上，以简化其API并添加有用的新功能。它通过中间件和路由使组织应用程序的功能变得更容易；它向Node.js的HTTP对象添加了有用的实用工具；它促进了动态HTML视图的渲染；它定义了一个易于实现的扩展性标准。本书将更深入地探讨这些功能，所以所有这些术语很快就会变得不再神秘。
- en: 1.2.1  The functionality in Node.js
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 Node.js中的功能
- en: When you're creating a web application (or to be more precise, a web server)
    in Node.js, you write a single JavaScript function for your entire application.
    This function listens to a web browser’s requests, or the requests from a mobile
    application consuming your API, or any other client talking to your server. When
    a request comes in, this function will look at the request and determine how to
    respond. For example, if you visit the homepage in a web browser, this function
    could determine that you want the homepage and it will send back some HTML. If
    you send a message to an API endpoint, this function could determine what you
    want and respond with JSON (for example).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在Node.js中创建一个网络应用程序（或更准确地说，一个Web服务器）时，您为您的整个应用程序编写一个单一的JavaScript函数。这个函数监听网络浏览器的请求，或消费您的API的移动应用程序的请求，或任何其他与您的服务器通信的客户端。当请求到来时，这个函数将查看请求并确定如何响应。例如，如果您在Web浏览器中访问主页，这个函数可以确定您想要主页，并将发送一些HTML。如果您向API端点发送消息，这个函数可以确定您想要什么，并以JSON（例如）响应。
- en: 'Imagine we''re writing a web application that tells users the time and time
    zone on the server. It will work like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在编写一个网络应用程序，告诉用户服务器上的时间和时区。它将这样工作：
- en: ·  If the client requests the homepage, our application will return an HTML
    page showing the time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户请求主页，我们的应用程序将返回一个显示时间的HTML页面。
- en: ·  If the client requests anything else, our application will return an HTTP
    404 “Not Found” error and some accompanying text.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户请求其他任何内容，我们的应用程序将返回一个HTTP 404“未找到”错误和一些伴随的文本。
- en: If you were building your application on top of Node.js without Express, a client
    hitting your server might look like Figure 1.2.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在没有Express的情况下在Node.js上构建应用程序，客户端击中您的服务器可能看起来像图1.2。
- en: '![](../Images/01_02.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01_02.png)'
- en: Figure 1.2 The flow of a request through a Node.js web application. Circles
    are written by you as the developer; squares are out of your domain.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 通过Node.js网络应用程序的请求流程。圆形是由您作为开发者编写的；方形超出了您的领域。
- en: The JavaScript function that processes browser requests in your application
    is called a request handler. There’s nothing too special about this; it is just
    a JavaScript function that takes the request, figures out what to do, and responds;
    that's it! Node's HTTP server handles the connection between the client and your
    JavaScript function so that you don't have to handle tricky network protocols.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中处理浏览器请求的JavaScript函数被称为请求处理函数。这没有什么特别的；它只是一个接受请求、确定要做什么并响应的JavaScript函数；就是这样！Node的HTTP服务器处理客户端和您的JavaScript函数之间的连接，这样您就不必处理复杂的网络协议。
- en: 'In code, it''s a function that takes two arguments: an object that represents
    the request and an object that represents the response. In our time/timezone application,
    the request handler function might check for the URL that the client is requesting.
    If they’re requesting the homepage, the request handler function should respond
    with the current time in an HTML page. Otherwise, it should respond with a 404\.
    Every Node.js application is just like this: it''s a single request handler function
    responding to requests. Conceptually, it''s pretty simple!'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，这是一个接受两个参数的函数：一个表示请求的对象和一个表示响应的对象。在我们的时间/时区应用程序中，请求处理函数可能会检查客户端请求的URL。如果他们请求主页，请求处理函数应该以HTML页面的当前时间响应。否则，它应该响应404。每个Node.js应用程序都是这样的：它是一个单一的请求处理函数，响应请求。从概念上讲，这很简单！
- en: The problem is that the Node APIs can get complex. Want to send a single JPEG
    file? That’ll be 45 lines of code. Want to create reusable HTML templates? Figure
    out how to do it yourself. Node.js's HTTP server is powerful, but it's missing
    a lot of features that you might want if you were building a real application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于 Node API 可能会变得复杂。想要发送单个 JPEG 文件？那将是 45 行代码。想要创建可重用的 HTML 模板？自己找出如何实现。Node.js
    的 HTTP 服务器功能强大，但它缺少了你构建真实应用程序时可能需要的许多功能。
- en: Express was born to make it easier to write web applications with Node.js.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Express 的诞生是为了让使用 Node.js 编写网络应用程序变得更加容易。
- en: 1.2.2  What Express adds to Node
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 Express 为 Node 增加的功能
- en: In broad strokes, Express adds two big features to the Node.js HTTP server.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大体上，Express 为 Node.js HTTP 服务器添加了两个主要功能。
- en: 1.  Express adds a number of helpful conveniences to Node.js's HTTP server,
    abstracting away a lot of its complexity. For example, where sending a single
    JPEG file is fairly complex in raw Node.js (especially if you have performance
    in mind), Express reduces it to just one line.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 1. Express 为 Node.js 的 HTTP 服务器添加了许多有用的便利功能，抽象掉了许多复杂性。例如，在原始的 Node.js 中发送单个
    JPEG 文件相当复杂（特别是如果你考虑性能的话），Express 将其简化为仅仅一行。
- en: 2.  Express lets you refactor one monolithic request handler function into many
    smaller request handlers that only handle specific bits and pieces. This is more
    maintainable and more modular.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 2. Express 允许你将一个庞大的请求处理函数重构为许多更小的请求处理函数，这些函数只处理特定的部分。这更加易于维护和模块化。
- en: In contrast to Figure 1.2, Figure 1.3 shows how a request would flow through
    an Express application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与图 1.2 相比，图 1.3 展示了请求如何通过 Express 应用程序流动。
- en: '![](../Images/01_03.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_03.png)'
- en: Figure 1.3 The flow of a request through an Express. Once again, circles are
    code you write and squares are out of your domain.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 Express 中的请求流程。再次强调，圆圈是你编写的代码，正方形则超出了你的领域。
- en: 'This figure might look a little more complicated, but it''s much simpler for
    you as the developer. There are essentially two things going on here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图可能看起来稍微复杂一些，但对于你作为开发者来说，它要简单得多。这里实际上只有两件事在进行：
- en: 1.  Rather than one large request handler function, Express has you writing
    many smaller functions (many of which can be third-party and not written by you).
    Some functions are executed for every request (like a function that logs all requests,
    for example) and other functions are only executed sometimes (like a function
    that only handles the homepage or the 404 page, for example). Express has many
    utilities for partitioning these smaller request handler functions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 与一个大的请求处理函数相比，Express 让你编写许多小的函数（其中许多可以是第三方且不是由你编写的）。一些函数对每个请求都会执行（例如，记录所有请求的函数）而其他函数只在某些情况下执行（例如，只处理主页或
    404 页面的函数）。Express 有许多用于划分这些较小请求处理函数的实用工具。
- en: '2.  Request handler functions take two arguments: one is the request and the
    other is the response. Node’s HTTP server provides you with some functionality;
    for example, Node’s HTTP server lets you extract the browser’s user-agent in one
    of its variables. Express augments this by adding extra features like easy access
    to the incoming request’s IP address and improved parsing of URLs. The response
    object also gets beefed up; Express adds things like the `sendFile`method, a one-line
    command that translates to about 45 lines of complicated file code. This makes
    it easier to write these request handler functions.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 请求处理函数接受两个参数：一个是请求，另一个是响应。Node 的 HTTP 服务器为你提供了一些功能；例如，Node 的 HTTP 服务器允许你从一个变量中提取浏览器的用户代理。Express
    通过添加额外的功能来增强这一点，例如，轻松访问传入请求的 IP 地址和改进的 URL 解析。响应对象也得到了加强；Express 添加了诸如 `sendFile`
    方法之类的功能，这是一个一行命令，相当于大约 45 行复杂的文件代码。这使得编写这些请求处理函数变得更加容易。
- en: Instead of managing one monolithic request handler function with verbose Node.js
    APIs, you write multiple small request handler functions that are made more pleasant
    by Express and its easier APIs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用冗长的 Node.js API 管理一个庞大的请求处理函数相比，你将编写多个小的请求处理函数，这些函数通过 Express 和其更简单的 API
    变得更加愉快。
- en: 1.3     Express's minimal philosophy
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 Express 的最小化哲学
- en: Express is a framework, which means you'll have to build your app "the Express
    way". But "the Express way" isn't too opinionated; it doesn't give you a very
    rigid structure. That means you can build many different kinds of applications,
    from video chat applications to blogs to APIs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Express 是一个框架，这意味着你将不得不以“Express 方式”构建你的应用程序。但“Express 方式”并不太具有偏见；它不会给你一个非常僵化的结构。这意味着你可以构建许多不同类型的应用程序，从视频聊天应用程序到博客到
    API。
- en: It's very rare to build an Express app of any size that only uses Express. Express
    by itself probably doesn't do everything you need, and you'll probably find yourself
    with a large number of other libraries that you integrate into your Express applications.
    (We'll look at many of these libraries throughout the book.) You can have exactly what
    you need without any extra cruft, and it enables you to confidently understand
    every part of your application. In this way, it lends itself well to the "do one
    thing well" philosophy from the Unix world.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个仅使用 Express 的任何大小的 Express 应用程序是非常罕见的。仅凭 Express 本身可能无法完成你需要的所有事情，你可能会发现自己需要将大量其他库集成到你的
    Express 应用程序中。（我们将在本书中查看许多这些库。）你可以得到你需要的 exactly 东西，没有任何额外的冗余，这使你能够自信地理解应用程序的每个部分。以这种方式，它非常适合来自
    Unix 世界的“做好一件事”的哲学。
- en: But this minimalism is a double-edged sword. On one hand, it's flexible and
    your apps are free of unused cruft. On the other hand, it does very little for
    you in comparison to other frameworks. This means that you make mistakes, you
    have to make far more decisions about your application's architecture, and you
    have to spend more time hunting for the right third-party modules. You get less
    out of the box.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种简约主义是一把双刃剑。一方面，它很灵活，你的应用程序没有不必要的冗余。另一方面，与其他框架相比，它为你做的很少。这意味着你会犯错误，你必须对你的应用程序架构做出更多的决定，你必须花更多的时间寻找正确的第三方模块。你得到的现成功能更少。
- en: While some might like a flexible framework, others might want more rigidity.
    For example, PayPal likes Express, but built a framework on top of it that more
    strictly enforces conventions for their many developers. Express doesn't care
    how you structure your apps, so two developers might make completely different
    decisions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当有些人可能喜欢灵活的框架时，其他人可能想要更多的刚性。例如，PayPal 喜欢Express，但在其之上构建了一个框架，该框架对众多开发者强制执行更严格的约定。Express
    不关心你如何结构化你的应用程序，所以两个开发者可能会做出完全不同的决定。
- en: Because you're given the reins to steer your app in any direction, you might
    make an unwise decision that'll bite you later down the line. Sometimes, I look
    back on my still-learning-Express applications and thought, "Why did I do things
    this way?"
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你可以自由地引导你的应用程序走向任何方向，你可能会做出不明智的决定，这会在以后给你带来麻烦。有时，我回顾我仍在学习的 Express 应用程序，并想，“我为什么要这样做？”
- en: In order to write less code yourself, you wind up hunting for the right third-party
    packages to use. Sometimes, it's easy; there's one module that everyone loves
    and you love it too and it's a match made in heaven. Other times, it's harder
    to choose, because there are a lot of okay-ish ones or a small number. A bigger
    framework can save you that time and headache, and you'll simply use what you're
    given.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自己编写更少的代码，你最终会寻找正确的第三方包来使用。有时，这很简单；有一个每个人都喜欢的模块，你也喜欢它，这是一场天作之合。其他时候，选择更困难，因为有很多还可以的或者数量很少。一个更大的框架可以为你节省时间和头疼，你只需使用你得到的东西。
- en: There's no right answer to this, and this book isn't going to try to debate
    the ultimate winner of the fight between big and small frameworks. But the fact
    of the matter is that Express is a minimalist framework, for better or for worse!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，没有正确答案，这本书也不会试图辩论大框架和小框架之间的最终胜利者。但事实是，Express 是一个简约框架，不管好坏！
- en: 1.4     The core parts of Express
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 Express 的核心部分
- en: Alright, so Express is minimal, and it sugarcoats Node.js to make it easier
    to use. How does it do that?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以 Express 是简约的，并且它为 Node.js 加上了糖衣，使其更容易使用。它是如何做到这一点的呢？
- en: When you get right down to it, Express has just four major features. There's
    a lot of conceptual stuff in the next few sections, but it's not just hand-waving;
    we'll get to the nitty-gritty details in the following chapters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你真正深入思考时，Express 只有四个主要功能。接下来的几节有很多概念性的内容，但并不是空谈；我们将在接下来的章节中深入细节。
- en: 1.4.1  Middleware
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.1 中间件
- en: As we saw above, raw Node.js gives us one request handler function to work with.
    The request comes into our function and the response goes out of our function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们上面所看到的，原始的 Node.js 给我们提供了一个请求处理函数来工作。请求进入我们的函数，响应从我们的函数输出。
- en: 'Middleware is poorly-named, but it''s a term that''s not Express-specific and
    has been around for a while. The idea is pretty simple: rather than one monolithic
    request handler function, we call several request handler functions that each
    deal with a small chunk of the work. These smaller request handler functions are
    called middleware functions, or sometimes just “middleware”.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的命名并不准确，但它是一个非Express特定的术语，已经存在一段时间了。这个想法很简单：而不是一个单一的、大型的请求处理函数，我们调用几个请求处理函数，每个函数处理一小部分工作。这些较小的请求处理函数被称为中间件函数，有时也简称为“中间件”。
- en: Middleware can handle a variety of tasks, from logging requests to sending static
    files to setting HTTP headers. For example, the first middleware function we might
    use in an application is a logger—log every request that comes into our server.
    When the logger is all done logging, it will continue onto the next middleware
    in the chain. This next middleware function might authenticate users. If they’re
    visiting a forbidden URL, respond with a “not authorized” page. If they’re allowed
    to visit it, continue to the next function in the chain. The next function might
    send the homepage and be done. An illustration of two possible options is shown
    in Figure 1.4.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件可以处理各种任务，从记录请求到发送静态文件到设置HTTP头。例如，我们可能在应用程序中使用的第一个中间件函数是一个日志记录器——记录进入服务器的每个请求。当日志记录器完成记录后，它将继续传递到链中的下一个中间件。下一个中间件函数可能用于验证用户身份。如果他们访问的是禁止的URL，则响应一个“未授权”页面。如果允许访问，则继续传递到链中的下一个函数。下一个函数可能发送主页并完成。两种可能的选项在图1.4中有展示。
- en: '![](../Images/01_04.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01_04.png)'
- en: Figure 1.4 Two requests flowing through middleware functions. See that middleware
    sometimes continues on, but sometimes responds to requests.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4展示了两个请求通过中间件函数的过程。可以看到，中间件有时会继续传递，但有时会响应请求。
- en: In Figure 1.4, the logging middleware is first in the chain and is always called,
    so something will always noted in the log file. Next, the logging middleware continues
    to the next one in the chain, the authorization middleware. This middleware decides,
    by some decree, whether the user is authorized to keep going. If they are, it
    continues on to the next middleware in the chain. Otherwise, send a “you’re not
    authorized!” message to the user and halt the chain. (This message could be an
    HTML page or a JSON response or anything else, depending on the application.)
    Finally, the last middleware, if it’s called, will send some secret information
    and not continue to any further middleware in the chain. (Once again, this last
    middleware can send any kind of response, from HTML to JSON to an image file.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在图1.4中，日志中间件位于链的最前端，并且总是会被调用，因此日志文件中总会记录一些内容。接下来，日志中间件继续传递到链中的下一个中间件，即授权中间件。这个中间件会根据某种规定决定用户是否有权继续操作。如果有，它将继续传递到链中的下一个中间件。否则，向用户发送“您未授权！”的消息并停止链的传递。（这个消息可能是一个HTML页面、一个JSON响应或其他任何内容，具体取决于应用程序。）最后，如果调用最后一个中间件，它将发送一些秘密信息，并且不会继续传递到链中的任何其他中间件。（同样，这个最后的中间件可以发送任何类型的响应，从HTML到JSON到图像文件。）
- en: One of the biggest features of middleware is that it's relatively standardized,
    which means that lots of people have developed middleware for Express (including
    folks on the Express team). That means that if you can dream up the middleware,
    someone has probably made it. There's middleware to compile static assets like
    LESS and SCSS; there’s middleware for security and user authentication; there’s
    middleware to parse cookies and sessions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件最大的特点之一是它相对标准化，这意味着很多人为Express开发了中间件（包括Express团队的人）。这意味着如果你能想到中间件，可能有人已经制作了它。有用于编译静态资源如LESS和SCSS的中间件；有用于安全和用户认证的中间件；有用于解析cookies和会话的中间件。
- en: 1.4.2  Routing
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.2 路由
- en: Routing is better named than middleware. Like middleware, it breaks the one
    monolithic request handler function into smaller pieces. Unlike middleware, however,
    these request handlers are executed conditionally, depending on what URL and HTTP
    method a client sends.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 路由比中间件命名得更好。像中间件一样，它将一个单一的大请求处理函数分解成更小的部分。然而，与中间件不同的是，这些请求处理函数的执行是条件性的，取决于客户端发送的URL和HTTP方法。
- en: For example, we might build a webpage with a homepage and a guestbook. When
    the user sends an HTTP GET to the homepage URL, Express should send the homepage.
    But when they visit the guestbook URL, it should send them the HTML for the guestbook,
    not for the homepage! And if they post a comment in the guestbook (with an HTTP
    POST to a particular URL), this should update the guestbook. Routing allows you
    to partition your application's behavior by route.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能会构建一个包含主页和留言簿的网页。当用户向主页URL发送HTTP GET请求时，Express应该发送主页。但当用户访问留言簿URL时，它应该发送留言簿的HTML，而不是主页的HTML！如果他们在留言簿中发表评论（通过向特定URL发送HTTP
    POST请求），这将更新留言簿。路由允许您通过路由对应用程序的行为进行分区。
- en: The behavior of these routes is, like middleware, defined in request handler
    functions. When the user visits the homepage, it will call a request handler function,
    written by you. When the user visits the guestbook URL, it will call another request
    handler function, also written by you.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路由的行为，就像中间件一样，是在请求处理函数中定义的。当用户访问主页时，它将调用您编写的请求处理函数。当用户访问留言簿URL时，它将调用另一个您编写的请求处理函数。
- en: Express applications have middleware and routes; they complement one another.
    For example, you might want to log all of the requests, but you'll also want to
    serve the homepage when the user asks for it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Express应用程序具有中间件和路由；它们相互补充。例如，您可能希望记录所有请求，但您也想要在用户请求时提供主页。
- en: 1.4.3  Sub-applications
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.3 子应用程序
- en: 'Express applications can often be pretty small, even fitting in just one file.
    As your applications get larger, though, you''ll start to want to break things
    up into multiple folders and files. Express is unopinionated about how you scale
    your app, but it provides one important feature that''s super helpful: sub-applications.
    In Express lingo, these mini-applications are called routers.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Express应用程序通常可以非常小，甚至可以只在一个文件中。然而，随着您的应用程序变大，您将开始想要将它们分解成多个文件夹和文件。Express对您如何扩展应用程序没有意见，但它提供了一项非常重要的功能，非常有帮助：子应用程序。在Express术语中，这些小程序被称为路由器。
- en: Express allows you to define routers that can be used in larger applications.
    Writing these sub-applications is almost exactly like writing “normal-sized” ones,
    but it allows you to further compartmentalize your app into smaller pieces. For
    example, you might have an administration panel in your app, and that can function
    pretty differently from the rest of your app. You could put the admin panel code
    side-by-side with the rest of your middleware and routes, but you can also create
    a sub-application for your admin panel. Figure 1.5 shows how an Express application
    might be broken up with routers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Express允许您定义可以在大型应用程序中使用的路由器。编写这些子应用程序几乎与编写“正常大小”的应用程序完全一样，但它允许您进一步将应用程序分解成更小的部分。例如，您可能有一个管理面板在您的应用程序中，它可以与您的应用程序的其他部分非常不同地工作。您可以将管理面板代码与中间件和路由并排放置，但您也可以为管理面板创建一个子应用程序。图1.5显示了如何使用路由器分解Express应用程序。
- en: '![](../Images/01_05.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01_05.png)'
- en: Figure 1.5 An example diagram showing how a large application could be broken
    up into routers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5展示了如何将大型应用程序分解为路由器的示例图。
- en: This feature doesn't really shine until your applications get large, but when
    they do, it's hugely helpful.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性直到您的应用程序变得很大时才真正发光，但一旦它们变得很大，它就非常有帮助。
- en: 1.4.4  Conveniences
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.4 便利性
- en: Express applications are made up of middleware and routes. Both of them have
    you writing request handler functions, so you'll be doing that a lot!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Express应用程序由中间件和路由组成。它们都需要您编写请求处理函数，所以您将经常这样做！
- en: To make these request handler functions easier to write, Express has added a
    bunch of niceties. In raw Node.js, if you want to write a request handler function
    that sends a JPEG file from a folder, that's a fair bit of code. In Express, that's
    just one call to the `sendFile` method. Express has a bunch of functionality for
    rendering HTML more easily, where Node.js keeps mum. It also comes with a bunch
    of functions that make it easier to parse requests as they come in, like grabbing
    the client’s IP address.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些请求处理函数更容易编写，Express增加了一些便利功能。在原始Node.js中，如果您想编写一个请求处理函数，从文件夹发送JPEG文件，那需要相当多的代码。在Express中，这只是一个调用`sendFile`方法的调用。Express提供了一系列功能，使渲染HTML更加容易，而Node.js则保持沉默。它还附带了一些函数，使解析传入的请求变得更容易，例如获取客户端的IP地址。
- en: Unlike the features above, these conveniences don't conceptually change how
    you organize your app, but they can be super helpful.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述功能不同，这些便利性在概念上并没有改变您组织应用程序的方式，但它们可以非常有帮助。
- en: 1.5     The ecosystem surrounding Express
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5     Express 的生态系统
- en: Express, like any tool, doesn’t exist in a vacuum.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Express，像任何工具一样，并不是孤立存在的。
- en: It lives in the Node.js ecosystem, so you have a bevy of third-party modules
    that can help you, such as interfaces with databases. Because Express is extensible,
    lots of developers have made third-party modules that work well with Express (rather
    than general Node.js), such as specialized middleware or ways to render dynamic
    HTML.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它生活在 Node.js 生态系统之中，因此你有一系列第三方模块可以帮助你，例如与数据库的接口。因为 Express 是可扩展的，许多开发者已经创建了与
    Express（而不是通用的 Node.js）兼容的第三方模块，例如专门的中间件或渲染动态 HTML 的方法。
- en: 1.5.1  Express versus other web application frameworks
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.1  Express 与其他网络应用框架的比较
- en: Express is hardly the first web application framework, nor will it be the last.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Express 不仅仅是第一个网络应用框架，也不会是最后一个。
- en: Express isn’t the only framework in the Node.js world. Perhaps its biggest “competitor”
    is called Hapi.js. Like Express, it’s an unopinionated, relatively small framework
    that has routing and middleware-like functionality. It’s different from Express
    in that it doesn’t aim to smooth out Node.js’s built-in HTTP server module, but
    to build a rather different architecture. It’s a pretty mature framework developed
    by the folks at Walmart, and is used by Mozilla, OpenTable, and even the npm registry!
    While I doubt there’s much animosity between Express developers and Hapi developers,
    Hapi is the biggest “competitor” to Express.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Express 并不是 Node.js 世界中唯一的框架。也许它最大的“竞争对手”叫做 Hapi.js。像 Express 一样，它是一个没有意见、相对较小的框架，具有路由和类似中间件的功能。它与
    Express 的不同之处在于，它不旨在平滑 Node.js 内置的 HTTP 服务器模块，而是构建一个相当不同的架构。这是一个相当成熟的框架，由沃尔玛的团队开发，并被
    Mozilla、OpenTable 以及 npm 注册使用！虽然我怀疑 Express 开发者和 Hapi 开发者之间没有多少敌意，但 Hapi 是 Express
    最大的“竞争对手”。
- en: There are larger frameworks in the Node.js world as well, perhaps the most popular
    of which is the full-stack Meteor. While Express is unopinionated about how you
    build your applications, Meteor has a strict structure. While Express only deals
    with the HTTP server layer, Meteor is full-stack, running code on both client
    and server. This are simply design choices—one is not inherently better than the
    other.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 世界中也有更大的框架，其中最受欢迎的可能是全栈的 Meteor。虽然 Express 对你如何构建应用程序没有意见，但 Meteor
    有一个严格的结构。虽然 Express 只处理 HTTP 服务器层，但 Meteor 是全栈的，在客户端和服务器上运行代码。这仅仅是设计选择——一个并不天生比另一个更好。
- en: Like Express piles features atop Node.js, some folks have decided to pile features
    atop Express. Some folks at PayPal created Kraken; while Kraken is technically
    just Express middleware, it sets up a lot of your application, from security defaults
    to bundled middleware. Sails.js is another up-and-coming framework built atop
    Express that adds databases, WebSocket integration, API generators, an asset pipeline,
    and more. Both of these frameworks are more opinionated than Express by design.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Express 在 Node.js 之上堆叠特性一样，有些人决定在 Express 之上堆叠特性。PayPal 的一些人创建了 Kraken；虽然
    Kraken 技术上只是 Express 中间件，但它为你的应用程序设置了大量的内容，从安全默认设置到捆绑的中间件。Sails.js 是另一个建立在 Express
    之上的新兴框架，它添加了数据库、WebSocket 集成、API 生成器、资产管道等。这两个框架在设计上比 Express 更有意见。
- en: Express has several features, just one of which is middleware. Connect is a
    web application framework for Node.js that’s just the middleware layer. Connect
    doesn’t have routing or conveniences; it’s just middleware. Express used to use
    Connect for its middleware layer, and while it now does middleware without Connect,
    Express middleware is completely compatible with Connect middleware. That means
    that any middleware that works in Connect also works in Express, which adds a
    huge number of helpful third-party modules to your arsenal.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Express 有几个特性，其中之一就是中间件。Connect 是一个 Node.js 网络应用框架，它仅仅是中间件层。Connect 没有路由或便利性；它只是中间件。Express
    以前使用 Connect 作为其中间件层，而现在它不再使用 Connect 进行中间件，但 Express 中间件与 Connect 中间件完全兼容。这意味着任何在
    Connect 中工作的中间件也在 Express 中工作，这为你的工具箱添加了大量的有用第三方模块。
- en: This is JavaScript, so there are countless other Node.js web application frameworks
    out there, and I’m sure I’ve offended someone by not mentioning theirs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 JavaScript，所以有无数其他的 Node.js 网络应用框架，我相信我没有提到某个人的，可能会冒犯了他们。
- en: Outside of the Node.js world, there are comparable frameworks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 世界之外，也有类似的框架。
- en: Express was very much inspired by Sinatra, a minimal web application framework
    from the Ruby world. Sinatra, like Express, has routing and middleware-like functionality.
    Sinatra has inspired many clones and reinterpretations many other programming
    languages, so if you’ve ever used Sinatra or a Sinatra-like framework, Express
    will be familiar. Express is also like Bottle and Flask from the Python world.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Express 在很大程度上受到了 Ruby 世界中一个最小化 Web 应用程序框架 Sinatra 的启发。Sinatra 和 Express 一样，具有路由和类似中间件的功能。Sinatra
    启发了许多其他编程语言的克隆和重新解释，所以如果你曾经使用过 Sinatra 或类似 Sinatra 的框架，Express 将会熟悉。Express 也类似于
    Python 世界的 Bottle 和 Flask。
- en: Express isn’t as much like Python’s Django or Ruby on Rails or ASP.NET or Java’s
    Play; those are larger, more opinionated frameworks with lots of features. Express
    is also unlike PHP; while it is code running on the server, it’s not as tightly
    coupled with HTML as “vanilla” PHP is.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Express 不像 Python 的 Django 或 Ruby on Rails 或 ASP.NET 或 Java 的 Play；这些都是更大、更有观点的框架，具有许多功能。Express
    也不同于 PHP；虽然它是在服务器上运行的代码，但它与“纯”PHP 相比，与 HTML 的耦合并不紧密。
- en: This book should tell you that Express is better than all of these other frameworks,
    but it can’t—Express is simply one of the many ways to build a server-side web
    application. It has some real strengths that other frameworks don’t have, like
    Node.js’s performance and the ubiquitous JavaScript, but it does less for you
    than a larger framework might do, and some people don’t think JavaScript is the
    finest language out there. We could argue about which is best forever and never
    come to an answer, but it’s important to see where Express fits into the picture.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本书应该告诉你 Express 比所有这些其他框架都要好，但它不能——Express 只是构建服务器端 Web 应用程序的一种方式。它有一些其他框架没有的真正优势，比如
    Node.js 的性能和无处不在的 JavaScript，但它为你做的比大型框架可能做的要少，而且有些人不认为 JavaScript 是最好的语言。我们可以永远争论哪个最好，但永远找不到答案，但重要的是要看到
    Express 在这个画面中的位置。
- en: 1.5.2  What Express is used for
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.2 Express 的用途
- en: In theory, Express could be used to build any web application. It can process
    incoming requests and respond to them, so it can do things that you can do in
    most of the other frameworks mentioned above. Why would you choose Express over
    something else?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，Express 可以用来构建任何 Web 应用程序。它可以处理传入的请求并对它们做出响应，因此它可以做上述大多数其他框架中可以做的事情。你为什么选择
    Express 而不是其他东西呢？
- en: One of the benefits of writing code in Node.js is the ability to share JavaScript
    code between the browser and the server. This is helpful from a code perspective
    because you can literally run the same code on client and server. It's also very
    helpful from a mental perspective; you don't have to get your mind in "server
    mode" and then switch your mind into "client mode"—it's all the same thing at
    some level. That means that a frontend developer can write backend code without
    having to learn a whole new language and its paradigms, and vice-versa. There
    is some learning to do—this book wouldn't exist otherwise!—but a lot of it is
    familiar to front-end web developers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中编写代码的一个好处是能够在浏览器和服务器之间共享 JavaScript 代码。从代码的角度来看，这很有帮助，因为你可以实际上在客户端和服务器上运行相同的代码。从心理角度来看，这也非常有帮助；你不必让你的思维进入“服务器模式”，然后再切换到“客户端模式”——在某种程度上，它们都是同一件事。这意味着前端开发者可以编写后端代码，而无需学习全新的语言及其范式，反之亦然。有一些学习要做——否则这本书就不会存在了！——但其中很多对前端
    Web 开发者来说都很熟悉。
- en: 'Express helps you do this, and people have come up with a fancy name for one
    arrangement of an all-JavaScript stack: the MEAN stack. Like the "LAMP" stack
    stands for Linux, Apache, MySQL, and PHP, "MEAN" stands for MongoDB (a JavaScript-friendly
    database), Express, Angular (a frontend JavaScript framework), and Node.js. People
    like the MEAN stack because it''s full-stack JavaScript and you get all of the
    aforementioned benefits.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Express 帮助你做到这一点，人们为一种全 JavaScript 栈的排列想出了一个花哨的名字：MEAN 栈。就像“LAMP”栈代表 Linux、Apache、MySQL
    和 PHP 一样，“MEAN”代表 MongoDB（一个 JavaScript 友好的数据库）、Express、Angular（一个前端 JavaScript
    框架）和 Node.js。人们喜欢 MEAN 栈，因为它是一个全栈 JavaScript，你可以获得上述所有好处。
- en: Express is often used to power single-page applications, or SPAs. SPAs are very
    JavaScript-heavy on the frontend, and they usually require a server component.
    The server is usually required to simply serve the HTML, CSS, and JavaScript,
    but there’s often a REST API, too. Express can do both of these things quite well;
    it’s great at serving HTML and other files, and it’s great at building APIs. Because
    the learning curve is relatively low for frontend developers, they can whip up
    a simple SPA server without too much new learning.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Express 经常被用来驱动单页应用程序，或称为 SPAs。SPAs 在前端非常依赖 JavaScript，并且通常需要一个服务器组件。服务器通常只需要简单地提供
    HTML、CSS 和 JavaScript，但通常还会有一个 REST API。Express 可以很好地完成这两件事；它在提供 HTML 和其他文件方面做得很好，在构建
    API 方面也做得很好。由于前端开发者的学习曲线相对较低，他们可以轻松地构建一个简单的 SPA 服务器，而不需要太多新的学习。
- en: When you write applications with Express, you can't get away from using Node.js,
    so you're going to have the "E" and the "N" parts of the MEAN stack, but the other
    two parts (MongoDB and Angular) are up to you because Express is unopinionated.
    Want to replace Angular with Backbone.js on the frontend? Now it's the MEBN stack.
    Want to use SQL instead of MongoDB? Now it's the SEAN stack. While MEAN is a common
    bit of lingo thrown around and a popular configuration, you can choose whichever
    you want. In this book, we'll cover the MongoDB database, so we'll get the "MEN"
    stack.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Express 编写应用程序时，你无法避开使用 Node.js，所以你将拥有 MEAN 栈中的“E”和“N”部分，但其他两个部分（MongoDB
    和 Angular）由你决定，因为 Express 是无意见的。想在前端用 Backbone.js 替换 Angular？现在就是 MEBN 栈。想用 SQL
    而不是 MongoDB？现在就是 SEAN 栈。虽然 MEAN 是一个常见的术语，并且是一个流行的配置，但你可以选择你想要的任何配置。在这本书中，我们将介绍
    MongoDB 数据库，所以我们将得到“MEN”栈。
- en: Express also fits in side-by-side with a lot of real-time features. While other
    programming environments can support real-time features like WebSockets and WebRTC,
    Node.js seems to get more of that than other languages and frameworks. That means
    that you can  Because Node gets it, Express gets it too.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Express 还可以与许多实时功能并排使用。虽然其他编程环境可以支持实时功能，如 WebSockets 和 WebRTC，但 Node.js 似乎比其他语言和框架更多地支持这些功能。这意味着你可以因为
    Node 支持，Express 也支持。
- en: 1.5.3  Third-party modules for Node and Express
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.3 Node 和 Express 的第三方模块
- en: The first few chapters of this book talk about “core” Express—that is, things
    that are baked into the framework. In very broad strokes, this is routes and middleware.
    But more than half of the book covers how to integrate Express with third-party
    modules.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的前几章讨论了“核心”Express——也就是说，这些是内置于框架中的内容。非常粗略地说，这是路由和中间件。但超过一半的书本内容涵盖了如何将 Express
    与第三方模块集成。
- en: There are loads of third-party modules for Express. Some are made specifically
    for Express and are compatible with its routing and middleware features. Others
    aren’t made for Express specifically and work well in Node.js, so they also work
    well with Express.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Express 有大量的第三方模块。其中一些是专门为 Express 制作的，并且与它的路由和中间件功能兼容。其他一些不是专门为 Express
    制作的，但在 Node.js 中表现良好，因此它们也与 Express 兼容。
- en: In this book, we’ll pick a number of third-party integrations and show some
    examples. But because Express is unopinonated, none of the contents of this book
    are the only options. If I cover Third-Party Tool X in this book, but you prefer
    alternative Third-Party Tool Y, you can swap them out.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将选择一些第三方集成并展示一些示例。但由于 Express 是无意见的，这本书中的内容并不是唯一的选择。如果我在这本书中介绍了第三方工具
    X，但你更喜欢替代的第三方工具 Y，你可以将它们替换掉。
- en: 'Express has some small features for rendering HTML. If you’ve ever used “vanilla”
    PHP or a templating language like ERB, Jinja2, HAML, or Razor, you’ve dealt with
    rendering HTML on the server. Express doesn’t come with any templating languages
    built in, but it plays nicely with almost every Node-based templating engine,
    as we’ll see. Some popular templating languages come with Express support, while
    others need a simple helper library. In this book, we’ll look at two options:
    EJS (which looks a lot like HTML) and Jade (which tries to fix HTML with a radical
    new syntax).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Express 有一些用于渲染 HTML 的小功能。如果你曾经使用过“纯”PHP 或像 ERB、Jinja2、HAML 或 Razor 这样的模板语言，你已经在服务器上处理过
    HTML 的渲染。Express 并没有内置任何模板语言，但它几乎与每个基于 Node 的模板引擎都很好地配合，正如我们将看到的。一些流行的模板语言自带 Express
    支持，而其他一些则需要一个简单的辅助库。在这本书中，我们将探讨两种选择：EJS（看起来很像 HTML）和 Jade（试图用一种激进的新语法修复 HTML）。
- en: Express doesn’t have any notion of a database. You can persist your application’s
    data however you choose; in files, in a relational SQL database, or in another
    kind of data storage mechanism. In this book, we’ll cover the popular MongoDB
    database for data storage. As we talked about above, you should never feel “boxed
    in” with Express—if you want to use another data store, Express will let you.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Express 没有任何关于数据库的概念。你可以根据你的选择持久化应用程序的数据；在文件中，在关系型 SQL 数据库中，或者在其他类型的数据存储机制中。在这本书中，我们将介绍流行的
    MongoDB 数据库用于数据存储。正如我们上面所讨论的，你不应该觉得 Express 会让你感到“受限”——如果你想使用另一个数据存储，Express 会让你做到这一点。
- en: Users often want their applications to be secure. There are a number of helpful
    libraries and modules (some for “raw” Node and some for Express) that can tighten
    the belt of your Express applications. We’ll explore all of this in the chapter
    about security (which is one of my favorite chapters, personally). We’ll also
    talk about testing our Express code to make sure that the code powering our apps
    is robust.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通常希望他们的应用程序是安全的。有许多有用的库和模块（一些是针对“原始”Node 的，一些是针对 Express 的）可以加强你的 Express
    应用程序的安全性。我们将在关于安全性的章节中探讨所有这些内容（这是我个人最喜欢的章节之一）。我们还将讨论测试我们的 Express 代码，以确保为我们的应用程序提供动力的代码是健壮的。
- en: 'An important thing to note: there’s no such thing as an “Express module”—only
    a Node module. A Node module can be compatible with Express and work well with
    its API, but they’re all just JavaScript served from the npm registry and you
    install them in just the same way. Just like in other environments, some modules
    integrate with other modules, where others can sit alongside. At the end of the
    day, Express is just a Node module just like any other.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要注意：没有所谓的“Express 模块”——只有 Node 模块。一个 Node 模块可以与 Express 兼容并且很好地与它的 API 一起工作，但它们都是来自
    npm 注册表的 JavaScript，你以同样的方式安装它们。就像在其他环境中一样，一些模块与其他模块集成，而其他模块可以独立存在。最终，Express
    只是一个像其他任何东西一样的 Node 模块。
- en: Getting help when you need it
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要帮助时
- en: 'I really hope this book is helpful and chock-full of knowledge, but there''s
    only so much wisdom one author can jam into a book. At some point, you''re going
    to need to spread your wings and find answers. Let me do my best to guide you:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我真心希望这本书能有所帮助，并且充满知识，但一个作者能塞进书里的智慧是有限的。在某个时候，你需要展开翅膀去寻找答案。让我尽我所能来引导你：
- en: For API documentation and simple guides, the official [http://expressjs.com/](http://expressjs.com/)  is
    the place to go. You can also find example applications all throughout the Express
    repository, at [https://github.com/strongloop/express/tree/master/examples](https://github.com/strongloop/express/tree/master/examples) .
    I found these examples helpful when trying to find the "right" way to do things.
    There are loads of examples in there; check them out!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 API 文档和简单的指南，官方的 [http://expressjs.com/](http://expressjs.com/) 是你该去的地方。你还可以在
    Express 仓库的整个目录中找到示例应用程序，在 [https://github.com/strongloop/express/tree/master/examples](https://github.com/strongloop/express/tree/master/examples)
    。我在尝试找到“正确”做事的方式时发现这些示例很有帮助。那里有很多示例；去看看吧！
- en: For Node modules, you'll be using Node's built-in npm tool and installing things
    from the registry at [https://www.npmjs.org/](https://www.npmjs.org/) . If you
    need help finding good modules, I'd give Substack's "finding modules" a read at
    http://substack.net/finding_modules. It's a great summary of how to find quality
    Node packages.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Node 模块，你将使用 Node 内置的 npm 工具，并从 [https://www.npmjs.org/](https://www.npmjs.org/)
    上的注册表中安装东西。如果你需要帮助找到好的模块，我建议你阅读 Substack 的“寻找模块”指南，网址为 http://substack.net/finding_modules。这是一份关于如何找到高质量
    Node 包的精彩总结。
- en: Express used to be built on another package called Connect, and is still largely
    compatible with Connect-made modules. If you can't find a module for Express,
    you might have luck searching for Connect. This also applies if you're searching
    for answers to questions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Express 以前是基于另一个名为 Connect 的包构建的，并且仍然与 Connect 制作的模块高度兼容。如果你找不到 Express 的模块，你可能通过搜索
    Connect 会更有运气。这也适用于你在寻找答案时。
- en: And as always, use your favorite search engine.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就像往常一样，使用你喜欢的搜索引擎。
- en: 1.6     The obligatory hello world
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 必不可少的“Hello World”
- en: Every introduction to a new code thing needs a “hello world”, right?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每次介绍新的代码事物都需要一个“Hello World”，对吧？
- en: 'Let''s take a look at one of the simplest Express applications we can build:
    the Hello World. We''ll delve into this in much greater detail throughout the
    book, so don''t worry if not all of this makes sense right now.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以构建的最简单的 Express 应用程序之一：“Hello World”。我们将在整本书中更详细地探讨这一点，所以如果你现在觉得有些内容不太明白，请不要担心。
- en: 'Here''s Hello World, in Express:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Express 中的“Hello World”：
- en: Listing 1.1 “Hello World” in Express
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.1 Express中的“Hello World”
- en: '`var express = require("express");  #A`   `var app = express();  #B`   `app.get("/",
    function(request, response) {  #C` `  response.send("Hello world!");           
    #C` `});                                         #C`   `app.listen(3000, function()
    {                       #D` `  console.log("Express app started on port 3000.");
    #D``});                                                 #D`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");  #A`   `var app = express();  #B`   `app.get("/",
    function(request, response) {  #C` `  response.send("Hello world!");           
    #C` `});                                         #C`   `app.listen(3000, function()
    {                       #D` `  console.log("Express app started on port 3000.");
    #D``});                                                 #D`'
- en: '#A Require Express and put it in a variable.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 引入Express并将其放入一个变量中。'
- en: '#B Call express() to make a new Express application, and put it inside of a
    variable called “app”.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 调用express()创建一个新的Express应用程序，并将其放入名为“app”的变量中。'
- en: '#C When someone sends a request to the root of your site (at “/”), they will
    be sent “Hello world!”.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 当有人向您的网站根目录（在“/”）发送请求时，他们将收到“Hello world!”。'
- en: '#D Start the Express server on port 3000 and log that the server has started.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 在端口3000上启动Express服务器并记录服务器已启动。'
- en: 'Once again: if not all of this makes sense to you, don''t worry! But you might
    be able to see that we''re creating an Express application, defining a route that
    responds with “Hello world!”, and starting our app on port 3000\. There are a
    few steps you''ll need to do to run this—all of that will become clear in the
    next couple of chapters.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调：如果这一切对您来说还不清楚，请不要担心！但您可能已经看到我们正在创建一个Express应用程序，定义了一个响应“Hello world!”的路由，并在端口3000上启动了我们的应用程序。要运行此应用程序，您需要执行几个步骤——所有这些都会在接下来的几章中变得清晰。
- en: We'll learn all of Express's secrets soon.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会了解Express的所有秘密。
- en: 1.7     Summary
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7     总结
- en: 'In this chapter, you learned that:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解到：
- en: ·  Node.js is a powerful tool for writing web applications, but it can be cumbersome
    to do so. Express was made to smooth out that process.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ·  Node.js是编写Web应用程序的强大工具，但这样做可能会很繁琐。Express就是为了简化这个过程而创建的。
- en: ·  Express is a minimal, unopinionated framework that's flexible.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ·  Express是一个最小化、无偏见且灵活的框架。
- en: '·  Express has a few key features:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ·  Express有几个关键特性：
- en: ·  Middleware, a way to break your app into smaller bits of behavior. Generally,
    middleware is called one by one, in a sequence.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ·  中间件，一种将应用程序分解成更小行为片段的方法。通常，中间件按顺序逐个调用。
- en: ·  Routing similarly breaks your app up into smaller functions that are executed
    when the user visits a particular resource; for example, showing the homepage
    when the user requests the homepage URL.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ·  路由将您的应用程序分解成更小的函数，这些函数在用户访问特定资源时执行；例如，当用户请求主页URL时显示主页。
- en: ·  Routers can further break up large applications into smaller, composable
    sub-applications.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ·  路由器可以将大型应用程序进一步分解成更小的、可组合的子应用程序。
- en: ·  Most of your Express code involves writing request handler functions, and
    Express adds a number of conveniences when writing these.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ·  您的大部分Express代码都涉及编写请求处理函数，Express在编写这些函数时提供了一些便利。
