- en: 14 Working with vectors and matrices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14 处理向量和矩阵
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Working with numbers in matrices and performing calculations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在矩阵中处理数字并执行计算
- en: Slicing and dicing arrays
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的切片和切块
- en: Concatenating arrays along different dimensions to form larger arrays
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿不同维度连接数组以形成更大的数组
- en: In chapter 4, you explored basic operations, such as push!, on one-dimensional
    arrays, called vectors. In this chapter, you will focus more on working with multidimensional
    arrays, such as matrices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，你探索了一维数组（称为向量）的基本操作，如push!。在本章中，你将更多地关注处理多维数组，如矩阵。
- en: What can you use a matrix and vector for? They can be combined to solve a great
    number of problems. For example, it is popular to use vectors in a geometric interpretation;
    in this case they represent points in space. You can use matrices to move and
    rotate these points.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用矩阵和向量做什么？它们可以组合起来解决大量问题。例如，在几何解释中使用向量很常见；在这种情况下，它们代表空间中的点。你可以使用矩阵来移动和旋转这些点。
- en: Matrices can even be used to solve mathematical equations, and they are very
    popular in machine learning. A matrix can be used to represent an image. Every
    element in a matrix can represent the color of a single pixel. Each of these topics
    deserves its own chapter or book, so in this chapter I will only cover the essentials
    of working with vectors and matrices.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵甚至可以用来解决数学方程，并且在机器学习中非常受欢迎。矩阵可以用来表示图像。矩阵中的每个元素都可以代表单个像素的颜色。这些主题每个都值得有自己的章节或书籍，所以在本章中，我将只涵盖与向量和矩阵一起工作的基本知识。
- en: 14.1 Vectors and matrices in mathematics
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 数学中的向量和矩阵
- en: A matrix or a vector is not just a dumb container of numbers. For instance,
    in mathematics, sets, tuples, and vectors may all look like a list of numbers
    and, hence, seem similar. But what you can *do* with them is different.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵或向量不仅仅是一个数字的愚蠢容器。例如，在数学中，集合、元组和向量可能都看起来像数字列表，因此看起来很相似。但你可以*做*的事情是不同的。
- en: The study of vectors and matrices is part of the field of mathematics called
    *linear algebra*. In linear algebra, single values such as 1, 4, and 8 are called
    *scalars*. While multiple values in a row or column are *vectors*, tables are
    *matrices*, and if the data is arranged in a 3D array, it may be referred to as
    a *cube*. Vectors can further be divided into column vectors and row vectors (figure
    14.1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 向量和矩阵的研究是数学领域线性代数的一部分。在线性代数中，单个值如1、4和8被称为*标量*。而一行或一列中的多个值是*向量*，表格是*矩阵*，如果数据按3D数组排列，它可能被称为*立方体*。向量可以进一步分为列向量和行向量（图14.1）。
- en: '![14-01](../Images/14-01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![14-01](../Images/14-01.png)'
- en: Figure 14.1 Arrays of different dimensions
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 不同维度的数组
- en: 14.2 Constructing a matrix from rows and columns
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 从行和列构造矩阵
- en: 'A matrix can be constructed either by specifying multiple rows stacked on top
    of each other or by columns lined up, one after the other. When constructing a
    matrix from row vectors, you separate each row with a semicolon ;; notice how
    you don’t separate individual elements with a comma. If you have forgotten about
    this, then review the discussion of row vectors and column vectors in chapter
    4:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵可以通过指定堆叠在一起的多个行或依次排列的列来构造。当从行向量构造矩阵时，你用分号;;分隔每一行；注意你不用逗号分隔单个元素。如果你已经忘记了这一点，那么请回顾第4章中关于行向量和列向量的讨论：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To create a matrix from multiple columns, you can define each column separately
    and then combine them into a matrix:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要从多个列创建一个矩阵，你可以分别定义每一列，然后将它们组合成一个矩阵：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is identical to writing the column vectors inline like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这与内联编写列向量相同：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how Julia provides a summary of what kind of Array you are getting as
    a result, with the line 4×3 Matrix{Int64}. This tells you that Julia made an array
    with 4 rows and 3 columns, where each element is of type Int64.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Julia如何提供结果的Array类型摘要，行4×3 Matrix{Int64}。这告诉你Julia创建了一个有4行3列的数组，其中每个元素都是Int64类型。
- en: 'You can query an arbitrary array about these properties: eltype provides the
    type of each element in the array, ndims provides the number of dimensions, and
    size provides the number of components (elements) along each dimension. Normally,
    we think of the dimensions as length, height, and depth, but in this case I will
    normally speak of rows and columns:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查询任意数组关于这些属性的信息：eltype提供数组中每个元素的类型，ndims提供维度数，size提供每个维度上的组件（元素）数。通常，我们认为维度是长度、高度和深度，但在这个情况下，我通常会说行和列：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Type of each element in the array
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 数组中每个元素的类型
- en: ❷ The number of rows and columns
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 行和列的数量
- en: ❸ The number of dimensions
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 维度的数量
- en: Figure 14.2 helps clarify what these different properties mean by showing vectors
    and matrices of different shapes. They have different numbers of rows and columns
    as well as different orientations and dimensions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2通过显示不同形状的向量和矩阵来帮助阐明这些不同属性的含义。它们具有不同数量的行和列，以及不同的方向和维度。
- en: '![14-02](../Images/14-02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![14-02](../Images/14-02.png)'
- en: Figure 14.2 Properties of arrays of different shape
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 不同形状数组的属性
- en: 14.3 The size, length, and norm of an array
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 数组的尺寸、长度和范数
- en: 'If you come from other programming languages it can be easy to confuse these
    array concepts:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自其他编程语言，可能会很容易混淆这些数组概念：
- en: size—The dimensions of an array
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: size—数组的维度
- en: length—Total number of elements in array
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: length—数组中元素的总数
- en: norm—Magnitude of a vector
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: norm—向量的模
- en: 'A table with 4 rows and 3 columns has been created, making a total of 12 elements:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建一个4行3列的表格，总共包含12个元素：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The norm function is trickier to grasp. To explain it, I will use a small vector,
    with the elements 3 and 4:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 范数函数比较难以理解。为了解释它，我将使用一个包含元素3和4的小向量：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Looking at a right-angled triangle will help you visualize what norm is doing.
    You can think of the elements of the vector as the sides *a* and *b* in the triangle
    (figure 14.3). norm provides the length of the longest side, the *hypotenuse*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 观察一个直角三角形将帮助你可视化范数的操作。你可以将向量的元素视为三角形中的边 *a* 和 *b*（图14.3）。范数提供了最长边的长度，即 *斜边*。
- en: '![14-03](../Images/14-03.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![14-03](../Images/14-03.png)'
- en: Figure 14.3 A right-angled triangle with sides of length a, b, and h
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 一个边长为a, b, 和h的直角三角形
- en: 'The *Pythagorean theorem* reveals the relationship between all the sides in
    a right-angled triangle. You can think of norm as applying the Pythagorean theorem
    to figure out the length of the *hypotenuse*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*勾股定理*揭示了直角三角形中所有边之间的关系。你可以将范数视为应用勾股定理来确定 *斜边* 的长度：'
- en: 5² = 3² + 4²
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 5² = 3² + 4²
- en: 14.4 Slicing and dicing an array
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4 切片和切块数组
- en: Julia has great support for selecting slices of arrays of different dimensions.
    This flexibility comes from the fact that the setindex! and getindex functions
    are invoked when you use square brackets [] to access elements or assign to them.
    I’ll now explore how this slicing works (table 14.1).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Julia对选择不同维度数组的切片提供了很好的支持。这种灵活性来源于当你使用方括号 [] 访问元素或向其赋值时，会调用setindex!和getindex函数。我现在将探讨这种切片是如何工作的（表14.1）。
- en: Table 14.1 Relation between element access and Julia function calls
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.1 元素访问与Julia函数调用的关系
- en: '| Syntax sugar | Translates to | Description |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 语法糖 | 转换为 | 描述 |'
- en: '| xs[i] | getindex(xs, i) | Get element at index i |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| xs[i] | getindex(xs, i) | 在索引i处获取元素 |'
- en: '| xs[i,j] | getindex(xs, i, j) | Get element at row i and column j |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| xs[i,j] | getindex(xs, i, j) | 在第i行和第j列获取元素 |'
- en: '| xs[i] = 42 | setindex!(xs, 42, i) | Set element at index i |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| xs[i] = 42 | setindex!(xs, 42, i) | 在索引i处设置元素 |'
- en: '| xs[i,j] = 42 | setindex!(xs, 42, i, j) | Set element at row i and column
    j |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| xs[i,j] = 42 | setindex!(xs, 42, i, j) | 在第i行和第j列设置元素 |'
- en: I’ll begin simply by first looking at accessing individual elements on a one-dimensional
    array. Figure 14.1 illustrates how one or more elements can be selected in one-dimensional
    arrays. While the figure shows selections within row vectors, the same principles
    apply to column vectors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先简单地查看一维数组上的单个元素访问。图14.1说明了如何在单维数组中选择一个或多个元素。虽然该图显示了行向量的选择，但相同的原理也适用于列向量。
- en: You can use begin and end within square brackets to refer to the first or last
    element in a vector along a row or column. In Julia, the first element in an array
    is at index 1 by default. However, it is possible to create arrays with any start
    index in Julia, which makes the begin keyword very useful (figure 14.4).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在方括号内使用 begin 和 end 来引用向量中的一行或一列的第一个或最后一个元素。在 Julia 中，数组的第一个元素默认索引为 1。然而，在
    Julia 中可以创建具有任何起始索引的数组，这使得 begin 关键字非常有用（见图 14.4）。
- en: '![14-04](../Images/14-04.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![14-04](../Images/14-04.png)'
- en: Figure 14.4 Slicing a one-dimensional array **A** in different ways
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 以不同方式切片一维数组 **A**
- en: Notice how there are many ways of accessing the same elements. For example,
    if you had an array A, then A[3] and A[begin+2] would represent the exact same
    element.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到有多种方式可以访问相同的元素。例如，如果你有一个数组 A，那么 A[3] 和 A[begin+2] 就会表示相同的元素。
- en: 'For an array with four elements, as in the first two examples, A[4] and A[end]
    refer to the same element. Likewise A[3] and A[end-1] grab the same array element.
    You can experiment with these concepts in the Julia REPL:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含四个元素的数组，如前两个示例，A[4] 和 A[end] 指的是相同的元素。同样，A[3] 和 A[end-1] 获取的是同一个数组元素。你可以在
    Julia REPL 中尝试这些概念：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you don’t care about the specific index, and just want all the elements,
    you can write A[:]. How is that different from just writing A? All slice operations
    return copies of data. This example will help clarify:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在乎特定的索引，只想获取所有元素，你可以写 A[:]。这与只写 A 有什么不同？所有切片操作都返回数据的副本。这个例子将有助于澄清：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Do you see how the second element of B got changed but not the second element
    of A? Had you written B = A instead of B = A[:], the second element would have
    been changed in A as well, since A and B would have referred to exactly the same
    array object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到 B 的第二个元素被更改了，但 A 的第二个元素没有变化吗？如果你写的是 B = A 而不是 B = A[:]，A 的第二个元素也会被更改，因为
    A 和 B 会指向完全相同的数组对象。
- en: 'But what if you want to select a slice of an array without making a copy? Especially
    when working with very large amounts of data, it can kill performance to frequently
    copy thousands of elements in some tight inner loop. In these cases, you can create
    what is called a *view* in a subsection of the array. The slices are not copies
    of elements of an array but are those elements themselves. You can turn a slice
    into a view by using the @view macro:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想在不需要复制的情况下选择数组的切片呢？尤其是在处理大量数据时，频繁地在某些紧密的内循环中复制数千个元素可能会严重影响性能。在这些情况下，你可以在数组的子部分中创建一个所谓的“视图”。这些切片不是数组元素的副本，而是那些元素本身。你可以通过使用
    @view 宏将切片转换为视图：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The last result shows that changing the second element of B caused the fourth
    element of A to be changed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的结果显示，更改 B 的第二个元素导致 A 的第四个元素也被更改。
- en: Many of these examples should be relatable, since you have worked with one-dimensional
    arrays in many previous chapters. It gets more interesting when you are dealing
    with slices for multidimensional arrays, such as matrices.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些示例应该与你之前章节中处理的一维数组相关。当你处理多维数组的切片，如矩阵时，情况会更有趣。
- en: 'Let’s create a 2D matrix A to experiment on, using Julia’s reshape function.
    reshape takes an AbstractArray as input. Let me explain the next code example:
    The range 1:12 is used as input. All ranges are subtypes of AbstractArray, hence
    Julia sees the range as a one-dimensional array with 12 elements. The reshape
    function rearrange these 12 elements to a matrix with 3 rows and 4 columns, referred
    to as a 3×4 matrix.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个二维矩阵 A 来进行实验，使用 Julia 的 reshape 函数。reshape 函数接受一个 AbstractArray 作为输入。让我解释下一个代码示例：范围
    1:12 被用作输入。所有范围都是 AbstractArray 的子类型，因此 Julia 将范围视为一个包含 12 个元素的二维数组。reshape 函数将这些
    12 个元素重新排列成一个 3 行 4 列的矩阵，称为 3×4 矩阵。
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I will demonstrate how to slice a matrix in different ways, but first I will
    give some advice on how to think about slicing, so you can make sense of the demonstrations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我将演示如何以不同的方式切片矩阵，但首先我会给出一些关于如何思考切片的建议，这样你就可以理解演示了。
- en: Important The shape of a matrix is how many rows and columns it has. Hence,
    the function for changing the number of rows and columns is called reshape in
    Julia. Keep in mind that the length of the matrix cannot be changed by reshape.
    You can reshape an array A of six elements to a 3 × 2 or 2 × 3 matrix, but you
    *cannot* reshape it to a 3 × 3 matrix, as that contains nine elements (see figure
    14.5).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：矩阵的形状是指它有多少行和列。因此，在 Julia 中，改变行和列数量的函数被称为 reshape。请注意，矩阵的长度不能通过 reshape
    来改变。你可以将包含六个元素的数组 A 调整为 3 × 2 或 2 × 3 的矩阵，但你*不能*将其调整为 3 × 3 的矩阵，因为那样会包含九个元素（见图
    14.5）。
- en: '![14-05](../Images/14-05.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![14-05](../Images/14-05.png)'
- en: Figure 14.5 An array can be reshaped to matrices with the same number of elements.
    The cross indicates that you cannot reshape an array of six elements to one with
    nine elements.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 一个数组可以被重塑为具有相同元素数量的矩阵。交叉表示你不能将包含六个元素的数组重塑为包含九个元素的数组。
- en: 'I like to think about array slicing in terms of the set intersection operation
    ∩. Thus, A[2, 3] can be read as the following: *Give me the intersection of all
    the elements of row 2 and column 3.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢用集合交集操作 ∩ 来思考数组切片。因此，A[2, 3] 可以读作以下内容：*给我所有第 2 行和第 3 列元素的交集*。
- en: Figure 14.6 provides a visualization of this idea. The shaded squares represent
    the row and columns you have selected, and the squares in darker shade represent
    the intersection between these row and column selections.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 提供了这个想法的可视化。阴影方块代表你选择的行和列，而深色阴影的方块代表这些行和列选择之间的交集。
- en: '![14-06](../Images/14-06.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![14-06](../Images/14-06.png)'
- en: Figure 14.6 Slicing two-dimensional arrays.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 二维数组的切片。
- en: 'This conceptualization makes it easier to understand the selection A[2:3, 2:4].
    You can read this as the following: *Give me the intersection of all the elements
    in rows 2 to 3 and columns 2 to 4.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种概念化使得理解选择 A[2:3, 2:4] 更容易。你可以这样读它：*给我所有第 2 行到第 3 行和第 2 列到第 4 列元素的交集*。
- en: 'Following this logic, it becomes apparent how to select an entire row or column
    in a matrix. You can experiment with this in the REPL:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个逻辑，很明显如何在矩阵中选择整个行或列。你可以在 REPL 中进行实验：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It is also worth noting that even multidimensional arrays can be treated as
    one-dimensional ones:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，即使是多维数组也可以被视为一维的：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 14.5 Combining matrices and vectors
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.5 矩阵和向量的组合
- en: Data does not always come in the shape and form you’d like for performing matrix
    operations. You may have *n* vectors, but really have wanted a matrix with *n*
    columns instead.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 数据并不总是以你想要进行矩阵操作的方式和形式出现。你可能拥有 *n* 个向量，但实际上你希望有一个具有 *n* 列的矩阵。
- en: Fortunately, Julia has a number of functions for concatenating matrices. This
    first example shows how to concatenate two row vectors, either horizontally using
    hcat or vertically using vcat (figure 14.7).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Julia 有许多用于连接矩阵的函数。这个第一个例子展示了如何使用 hcat 或 vcat（图 14.7）水平或垂直地连接两个行向量。
- en: '![14-07](../Images/14-07.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![14-07](../Images/14-07.png)'
- en: Figure 14.7 Horizontal and vertical concatenation of row vectors
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 行向量的水平垂直连接。
- en: The cat function allows you to specify along which dimension you are concatenating.
    This is useful if you are dealing with higher-dimension arrays. You can perform
    similar operations with column vectors (figure 14.8).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 猫函数允许你指定沿着哪个维度进行连接。当你处理高维数组时，这很有用。你可以使用列向量执行类似操作（图 14.8）。
- en: '![14-08](../Images/14-08.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![14-08](../Images/14-08.png)'
- en: Figure 14.8 Horizontal and vertical concatenation of column vectors
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8 列向量的水平垂直连接。
- en: The same principles apply to combining matrices; you can concatenate along any
    dimension. Horizontal and vertical concatenation have their own functions, hcat
    and vcat, because they are done so frequently (figure 14.9).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则适用于矩阵的组合；你可以沿着任何维度进行连接。水平连接和垂直连接有自己的函数，hcat 和 vcat，因为它们被频繁使用（图 14.9）。
- en: '![14-09](../Images/14-09.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![14-09](../Images/14-09.png)'
- en: Figure 14.9 Horizontal and vertical concatenation of matrices
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9 矩阵的水平垂直连接。
- en: 'These concatenation functions can take any number of argument; you are not
    limited to two:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些连接函数可以接受任意数量的参数；你不仅限于两个：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 14.6 Creating matrices
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.6 创建矩阵
- en: 'When working with matrices, you often need special kinds of matrices. Creating
    matrices with only zeros or ones is so common there are special functions to do
    this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理矩阵时，你经常需要特殊类型的矩阵。创建只包含零或一的矩阵如此常见，以至于有专门的函数来做这件事：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice how you can optionally specify what type you want each element to be
    as the first argument. If you don’t specify type, then it will default to Float64.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以选择性地指定每个元素想要的数据类型作为第一个参数。如果你没有指定类型，那么它将默认为Float64。
- en: 'Creating a whole array of random numbers is also often practical. For instance
    in deep learning, large matrices with random values are frequently used. You will
    often use random values to create test data:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一整个随机数数组也是常见的做法。例如，在深度学习中，经常使用具有随机值的大矩阵。你经常会使用随机值来创建测试数据：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Sometimes you just want to fill a whole matrix with a specific value:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你只想用一个特定的值填充整个矩阵：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Vectors and matrices are huge topics, and if we had more time I would have covered
    the geometric interpretation of vectors and matrices. What are some possible uses?
    You could have represented the orientation of your rocket with a matrix and its
    position as a vector. You could have used matrices to rotate or move the rocket
    around in the coordinate system. For in-depth discussion on working with matrices,
    *Julia for Data Analysis* (Manning, 2022) by Bogumił Kamin´ski is an excellent
    resource.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 向量和矩阵是巨大的主题，如果我们有更多时间，我会介绍向量和矩阵的几何解释。有哪些可能的用途？你可以用一个矩阵表示火箭的方向，用向量表示其位置。你可以使用矩阵在坐标系中旋转或移动火箭。对于矩阵处理的深入讨论，Bogumił
    Kamin´ski的《Julia for Data Analysis》（Manning，2022）是一本极好的资源。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Arrays can be used to define column vectors, row vectors, and matrices.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组可以用来定义列向量、行向量和矩阵。
- en: Matrices are two-dimensional arrays that can be constructed in many ways. It
    is most common to define it as a set of rows, but it is also possible to define
    matrices as a set of columns.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵是可以通过多种方式构建的二维度数组。最常见的是将其定义为一系列行，但也可以将矩阵定义为一系列列。
- en: Arrays have properties such as ndims, size, and length. These describe the number
    of dimensions, number of elements along each dimension, and total number of elements
    in the array.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组具有ndims、size和length等属性。这些描述了数组的维度数、每个维度上的元素数量以及数组中的总元素数。
- en: Arrays can be sliced by specifying ranges, which also generalize to matrices.
    You can give ranges for rows and columns to cut out a submatrix.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过指定范围来切片数组，这也适用于矩阵。你可以为行和列指定范围，以切割出子矩阵。
- en: Slices are copies of data. If you don’t want slices to be copies, but directly
    reference data in the original array, then you can create a slice view with the
    @view macro.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片是数据的副本。如果你不希望切片是副本，而是直接引用原始数组中的数据，那么你可以使用@view宏创建一个切片视图。
- en: Matrices and vectors can be combined horizontally and vertically using hcat
    and vcat. For arrays of higher dimensions, you can use cat and specify the dimension
    to concatenate along as an argument.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用hcat和vcat在水平和垂直方向上组合矩阵和向量。对于更高维度的数组，你可以使用cat并指定要连接的维度作为参数。
- en: Matrices can quickly be created with functions such as rand, fill, ones, and
    zeros.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用rand、fill、ones和zeros等函数快速创建矩阵。
