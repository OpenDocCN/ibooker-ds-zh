- en: 9 Consuming GraphQL APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 消费GraphQL API
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Running a GraphQL mock server to test our API design
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行GraphQL模拟服务器以测试我们的API设计
- en: Using the GraphiQL client to explore and consume a GraphQL API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GraphiQL客户端探索和消费GraphQL API
- en: Running queries and mutations against a GraphQL API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对GraphQL API执行查询和突变
- en: Consuming a GraphQL API programmatically using cURL and Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用cURL和Python以编程方式消费GraphQL API
- en: This chapter teaches you how to consume GraphQL APIs. As we learned in chapter
    8, GraphQL offers a query language for web APIs, and in this chapter you’ll learn
    how to use this language to run queries on the server. In particular, you’ll learn
    how to make queries against a GraphQL API. You’ll learn to explore a GraphQL API
    to discover its available types, queries, and mutations. Understanding how GraphQL
    APIs work from the client side is an important step toward mastering GraphQL.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教您如何消费GraphQL API。正如我们在第8章中学到的，GraphQL为Web API提供了一种查询语言，在本章中，您将学习如何使用这种语言在服务器上运行查询。特别是，您将学习如何对GraphQL
    API进行查询。您将学习探索GraphQL API以发现其可用的类型、查询和突变。从客户端理解GraphQL API的工作原理是掌握GraphQL的重要一步。
- en: Learning to interact with GraphQL APIs will help you learn to consume the APIs
    exposed by other vendors, it’ll let you run tests against your own APIs, and it’ll
    help you design better APIs. You’ll learn to use the GraphiQL client to explore
    and visualize a GraphQL API. As you’ll see, GraphiQL offers an interactive query
    panel that makes it easier to run queries on the server.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 学习与GraphQL API交互将帮助您学习消费其他供应商公开的API，它将允许您对自己的API进行测试，并帮助您设计更好的API。您将学习使用GraphiQL客户端探索和可视化GraphQL
    API。正如您将看到的，GraphiQL提供了一个交互式查询面板，这使得在服务器上运行查询变得更容易。
- en: To illustrate the concepts and ideas behind GraphQL’s query language, we’ll
    run practical examples using the products API we designed in chapter 8\. Since
    we haven’t implemented the API specification for the products API, we’ll learn
    to run a mock server—an important part of the API development process, as it makes
    testing and validating an API design so much easier. Finally, you’ll also learn
    to run queries against a GraphQL API programmatically using tools such as cURL
    and Python.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明GraphQL查询语言背后的概念和思想，我们将使用第8章中设计的产品API运行实际示例。由于我们尚未实现产品API的API规范，我们将学习运行模拟服务器——这是API开发过程中的重要部分，因为它使测试和验证API设计变得容易得多。最后，您还将学习如何使用cURL和Python等工具以编程方式对GraphQL
    API进行查询。
- en: 9.1 Running a GraphQL mock server
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 运行GraphQL模拟服务器
- en: In this section, we explain how we can run a GraphQL mock server to explore
    and test our API. A mock server is a fake server that emulates the behavior of
    the real server, offering the same endpoints and capabilities, but using fake
    data. For example, a mock server for the products API is a server that mimics
    the implementation of the products API and offers the same interface that we developed
    in chapter 8.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们解释了如何运行GraphQL模拟服务器以探索和测试我们的API。模拟服务器是一个模仿真实服务器行为的假服务器，提供相同的端点和功能，但使用假数据。例如，产品API的模拟服务器是一个模仿产品API实现并提供与我们第8章中开发的相同接口的服务器。
- en: definition *Mock servers* are fake servers that mimic the behavior of a real
    server. They are commonly used for developing API clients while the backend is
    being implemented. You can launch a mock server using the specification for an
    API. Mock servers return fake data and typically don’t persist data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*模拟服务器*是模仿真实服务器行为的假服务器。它们通常在实现后端时用于开发API客户端。您可以使用API规范启动模拟服务器。模拟服务器返回假数据，通常不会持久化数据。
- en: Mock servers are instrumental in the development of web APIs since they allow
    our API consumers to start working on the client-side code while we work on the
    backend implementation. In this section, we’ll run a mock server on the products
    API. The only thing we need to run a mock server is the API specification, which
    we developed in chapter 8\. You’ll find the API specification under ch08/schema.graphql
    in the GitHub repository for this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟服务器在开发Web API中起着至关重要的作用，因为它们允许我们的API消费者在我们进行后端实现的同时开始编写客户端代码。在本节中，我们将运行产品API的模拟服务器。我们运行模拟服务器所需的一切就是API规范，这是我们第8章中开发的。您可以在本书的GitHub仓库中的ch08/schema.graphql下找到API规范。
- en: 'You can choose from among many different libraries to run a GraphQL mock server.
    In this chapter, we’ll use GraphQL Faker ([https://github.com/APIs-guru/graphql-faker](https://github.com/APIs-guru/graphql-faker)),
    which is one of the most popular GraphQL mocking tools. To install GraphQL Faker,
    run the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从许多不同的库中选择来运行一个 GraphQL 模拟服务器。在本章中，我们将使用 GraphQL Faker ([https://github.com/APIs-guru/graphql-faker](https://github.com/APIs-guru/graphql-faker))，这是最受欢迎的
    GraphQL 模拟工具之一。要安装 GraphQL Faker，请运行以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will create a package-lock.json file under your current directory, as
    well as a node_ modules folder. package-lock.json contains information about the
    dependencies installed together with graphql-faker, while node_modules is the
    directory where those dependencies are installed. To run the mock server, execute
    the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的当前目录下创建一个 package-lock.json 文件，以及一个 node_modules 文件夹。package-lock.json
    包含了与 graphql-faker 一起安装的依赖项信息，而 node_modules 是这些依赖项安装的目录。要运行模拟服务器，请执行以下命令：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'GraphQL Faker normally runs on port 9002, and it exposes three endpoints:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL Faker 通常在端口 9002 上运行，并暴露了三个端点：
- en: '`/editor`—An interactive editor where you can develop your GraphQL API.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/editor`—一个交互式编辑器，您可以在其中开发您的 GraphQL API。'
- en: '`/graphql`—A GraphiQL interface to your GraphQL API. This is the interface
    we’ll use to explore the API and run our queries.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/graphql`—这是您的 GraphQL API 的 GraphiQL 接口。这是我们用来探索 API 和运行查询的接口。'
- en: '`/voyager`—An interactive display of your API, which helps you understand the
    relationships and dependencies between your types (see figure 9.1).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/voyager`—这是您 API 的交互式展示，有助于您理解类型之间的关系和依赖（见图 9.1）。'
- en: '![](../Images/09-01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-01.png)'
- en: Figure 9.1 Voyager UI for the products API. This UI shows the relationships
    between object types captured by the queries available in the API. By following
    the connecting arrows, you can see which objects we can reach from each query.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 产品 API 的 Voyager UI。此 UI 显示了 API 中可用查询捕获的对象类型之间的关系。通过跟随连接箭头，您可以看到我们可以从每个查询到达哪些对象。
- en: 'To start exploring and testing the products API, visit the following address
    in your browser: http://localhost:9002/graphql (if you’re running GraphQL Faker
    in a different port, your URL will look different). This endpoint loads a GraphiQL
    interface for our products API. Figure 9.2 illustrates what this interface looks
    like and highlights the most important elements in it.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始探索和测试产品 API，请在您的浏览器中访问以下地址：http://localhost:9002/graphql（如果您在另一个端口上运行 GraphQL
    Faker，则您的 URL 将不同）。此端点加载了我们的产品 API 的 GraphiQL 接口。图 9.2 展示了此接口的外观，并突出了其中的最重要的元素。
- en: '![](../Images/09-02.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-02.png)'
- en: Figure 9.2 API documentation explorer and query panel interface in GraphiQL
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 GraphiQL 中的 API 文档浏览器和查询面板界面
- en: 'To discover the queries and mutations exposed by the API, click the Docs button
    on the top-right corner of the UI. Upon clicking the Docs button, a side navigation
    bar will pop up offering two choices: queries or mutations (see figure 9.3 for
    an illustration). If you select queries, you’ll see the list of queries exposed
    by the server with their return types. You can click the return types to explore
    their properties, as you can see in figure 9.3\. In the next section, we’ll start
    testing the GraphQL API!'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要发现 API 暴露的查询和突变，请点击 UI 右上角处的 Docs 按钮。点击 Docs 按钮后，将弹出一个侧边导航栏，提供两个选项：查询或突变（见图
    9.3）。如果您选择查询，您将看到服务器暴露的查询列表及其返回类型。您可以点击返回类型来探索它们的属性，如图 9.3 所示。在下一节中，我们将开始测试 GraphQL
    API！
- en: '![](../Images/09-03.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-03.png)'
- en: Figure 9.3 By clicking through the Documentation Explorer in GraphiQL, you can
    inspect all the queries and mutations available in the API, as well as the types
    they return and their properties.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 通过在 GraphiQL 中的文档浏览器中点击，您可以检查 API 中所有可用的查询和突变，以及它们返回的类型及其属性。
- en: 9.2 Introducing GraphQL queries
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 介绍 GraphQL 查询
- en: In this section, we learn to consume a GraphQL API by running queries using
    GraphiQL. We’ll start with simple queries that don’t require any parameters, and
    then we’ll move on to queries with parameters.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习通过使用 GraphiQL 运行查询来消费 GraphQL API。我们将从不需要任何参数的简单查询开始，然后我们将继续到带有参数的查询。
- en: 9.2.1 Running simple queries
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 运行简单查询
- en: 'In this section, we introduce simple queries that don’t take any parameters.
    The products API offers two queries of this type: `allProducts()`, which returns
    a list of all products CoffeeMesh offers, and `allIngredients()`, which returns
    a list of all the ingredients.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了一些不需要参数的简单查询。产品 API 提供了两种此类查询：`allProducts()`，它返回 CoffeeMesh 提供的所有产品的列表，以及
    `allIngredients()`，它返回所有成分的列表。
- en: We’ll use GraphiQL to run queries against the API. To run the query, go to the
    query editor pane in the GraphiQL UI, which is illustrated in figure 9.2\. Listing
    9.1 shows how we run the `allIngredients()` query. As you can see, to run a query
    we must use the name of the query operation followed by curly braces. Within the
    curly braces, we declare the selection of properties we want to get from the server.
    The block within curly braces is called a *selection set*. GraphQL queries must
    always include a selection set. If you don’t include it, you’ll get an error response
    from the server. Here, we select only the name of each ingredient. The text representing
    the query is called a *query document*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 GraphiQL 来运行针对 API 的查询。要运行查询，请转到 GraphiQL UI 中的查询编辑器面板，如图 9.2 所示。列表 9.1
    展示了如何运行 `allIngredients()` 查询。正如你所看到的，要运行查询，我们必须使用查询操作的名称后跟大括号。在大括号内，我们声明从服务器获取的属性选择。大括号内的块称为
    *选择集*。GraphQL 查询必须始终包含选择集。如果你不包括它，你将收到来自服务器的错误响应。在这里，我们只选择了每个成分的名称。表示查询的文本称为 *查询文档*。
- en: Listing 9.1 Query document running the `allIngredients()` query
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 运行 `allIngredients()` 查询的查询文档
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① We wrap queries within curly braces.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们将查询放在大括号内。
- en: ② We run the allIngredients() query.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们运行 `allIngredients()` 查询。
- en: ③ We query the name property.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们查询名称属性。
- en: A response to a successful query from a GraphQL API contains a JSON document
    with a “data” field, which wraps the query result. An unsuccessful query results
    in a JSON document that contains an “error” key. Since we’re running a mock server,
    the API returns random values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 GraphQL API 的成功查询的响应包含一个包含“data”字段的 JSON 文档，它包装了查询结果。不成功的查询会导致包含“error”键的
    JSON 文档。由于我们正在运行模拟服务器，API 返回随机值。
- en: Listing 9.2 Example of successful response for the `allIngredients()` query
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 `allIngredients()` 查询的成功响应示例
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① A successful response includes a "data" key.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ① 成功的响应包括一个 "data" 键。
- en: ② The result of the query is indexed under a key named after the query itself.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ② 查询的结果在以查询本身命名的键下索引。
- en: Now that we know the basics of GraphQL queries, let’s spice up our queries by
    adding parameters!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 GraphQL 查询的基础知识，让我们通过添加参数来丰富我们的查询吧！
- en: 9.2.2 Running queries with parameters
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 使用参数运行查询
- en: This section explains how we use parameters in GraphQL queries. `allIngredients()`
    is a simple query that doesn’t take any parameters. Now let’s see how we can run
    a query that requires a parameter. One example of such a query is the `ingredient()`
    query, which requires an `id` parameter. The following code shows how we can call
    the `ingredient()` query with a random ID. As you can see, we include the query
    parameters as key-value pairs separated by a colon within parentheses.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了我们在 GraphQL 查询中使用参数的方式。`allIngredients()` 是一个不需要任何参数的简单查询。现在让我们看看如何运行需要参数的查询。此类查询的一个例子是
    `ingredient()` 查询，它需要一个 `id` 参数。以下代码展示了我们如何使用随机 ID 调用 `ingredient()` 查询。正如你所看到的，我们将查询参数作为冒号分隔的键值对包含在括号内。
- en: Listing 9.3 Running a query with a required parameter
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 使用必需参数运行查询
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① We call ingredient() with the ID parameter set to "asdf ".
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们调用 `ingredient()`，将 ID 参数设置为 "asdf "。
- en: Now that we know how to run queries with parameters, let’s look at the kinds
    of problems we can run into when running queries and how to deal with them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何运行带参数的查询，让我们看看在运行查询时可能会遇到的问题类型以及如何处理它们。
- en: 9.2.3 Understanding query errors
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 理解查询错误
- en: This section explains some of the most common errors you’ll find when running
    GraphQL queries, and it teaches you how to read and interpret them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了在运行 GraphQL 查询时可能会遇到的一些常见错误，并教你如何阅读和解释它们。
- en: 'If you omit the required parameter when running the `ingredient()` query, you’ll
    get an error from the API. Error responses include an error key pointing to a
    list of all the errors found by the server. Each error is an object with the following
    keys:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `ingredient()` 查询时省略了所需的参数，你将收到来自 API 的错误。错误响应包括一个错误键，指向服务器找到的所有错误的列表。每个错误都是一个具有以下键的对象：
- en: '`message`—Includes a human-readable description of the error'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`——包含错误的人类可读描述'
- en: '`locations`—Specifies where in the query the error was found, including the
    line and column'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locations`—指定错误在查询中的位置，包括行和列'
- en: 'Listing 9.4 shows what happens when you run the query with empty parentheses.
    As you can see, we get a syntax error with a somewhat cryptic message: `Expected`
    `Name,` `found` `)`. This is a common error that occurs whenever you make a syntax
    error in GraphQL. In this case, it means that GraphQL was expecting a parameter
    after the opening parenthesis, but instead it found a closing parenthesis.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4显示了当你运行空括号的查询时会发生什么。正如你所见，我们得到了一个带有某种隐晦信息的语法错误：`Expected` `Name,` `found`
    `)`。这是一个在GraphQL中发生语法错误时的常见错误。在这种情况下，这意味着GraphQL期望在开括号之后有一个参数，但相反，它找到了一个闭括号。
- en: Listing 9.4 Missing query parameter errors
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 缺少查询参数错误
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① We run the ingredient() query without the required parameter id.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们运行ingredient()查询时没有包含必需的参数id。
- en: ② An unsuccessful response includes an "errors" key.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ② 不成功的响应包括一个"errors"键。
- en: ③ We get a generic syntax error.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们得到一个通用的语法错误。
- en: ④ The precise location of the error in our query
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 错误的确切位置在我们的查询中
- en: ⑤ The error was found in the second line of our query document.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 错误出现在我们的查询文档的第二行。
- en: ⑥ The error was found at the 14th character in the second line.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 错误出现在第二行的第14个字符。
- en: On the other hand, if you run the `ingredient()` query without any parentheses
    at all, as shown in listing 9.5, you’ll get an error specifying that you missed
    the required parameter `id`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你像列表9.5中所示的那样运行没有任何括号的`ingredient()`查询，你将得到一个错误，指出你遗漏了必需的参数`id`。
- en: Use of parentheses in GraphQL queries and mutations In GraphQL, the parameters
    of a query are defined within parentheses. If you run a query with required parameters,
    such as `ingredient`, you must include the parameters within parentheses (see
    listing 9.3). Failing to do so will throw an error (see listings 9.4 and 9.5).
    If you run a query without parameters, you must omit the parentheses. For example,
    when we run the `allIngredients()` query, we omit parentheses (see listing 9.1),
    since `allIngredients()` doesn’t require any parentheses.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在GraphQL查询和突变中使用括号 在GraphQL中，查询的参数定义在括号内。如果你运行一个包含必需参数的查询，例如`ingredient`，你必须将参数包含在括号内（参见列表9.3）。如果不这样做，将会抛出错误（参见列表9.4和9.5）。如果你运行一个不带参数的查询，你必须省略括号。例如，当我们运行`allIngredients()`查询时，我们省略括号（参见列表9.1），因为`allIngredients()`不需要任何括号。
- en: Listing 9.5 Missing query parameter errors
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 缺少查询参数错误
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① We run the ingredient() query without the parentheses.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们运行ingredient()查询时没有括号。
- en: ② The error message says that the id parameter is missing in the query.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ② 错误信息表明查询中缺少id参数。
- en: ③ The error was found in the second line of our query document.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 错误出现在我们的查询文档的第二行。
- en: ④ The error was found at the third character of the second line.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 错误出现在第二行的第三个字符。
- en: Now that we know how to read and interpret error messages when we make mistakes
    in our queries, let’s explore queries that return multiple types.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何在查询出错时阅读和解释错误信息，让我们来探索返回多个类型的查询。
- en: 9.3 Using fragments in queries
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 在查询中使用片段
- en: This section explains how we run queries that return multiple types. The queries
    that we’ve seen so far in this chapter are simple since they only return one type,
    which is `Ingredient`. However, our product-related queries, such as `allProducts()`
    and `product()`, return the `Product` union type, which is the combination of
    the `Cake` and `Beverage` types. How do we run our queries in this case?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了我们如何运行返回多个类型的查询。到目前为止，本章中我们看到的查询很简单，因为它们只返回一个类型，即`Ingredient`。然而，我们的与产品相关的查询，如`allProducts()`和`product()`，返回的是`Product`联合类型，它是`Cake`和`Beverage`类型的组合。在这种情况下，我们如何运行我们的查询？
- en: When a GraphQL query returns multiple types, we must create selection sets for
    each type. For example, if you run the `allProducts()` query with a single selector,
    you get the error message saying that the server doesn’t know how to resolve the
    properties in the selection set.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个GraphQL查询返回多个类型时，我们必须为每个类型创建选择集。例如，如果你使用单个选择集运行`allProducts()`查询，你将得到一个错误信息，表明服务器不知道如何解析选择集中的属性。
- en: Listing 9.6 Calling `allProducts()` with a single selector set
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6 使用单个选择集调用`allProducts()`
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① We run the allProducts() query without parameters.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们运行allProducts()查询时没有参数。
- en: ② We include the name property in the selection set.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们在选择集中包含名称属性。
- en: ③ We get an error response.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们得到一个错误响应。
- en: ④ The server doesn’t know how to resolve the properties in the selection set.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 服务器不知道如何解析选择集中的属性。
- en: ⑤ The error was found in the third line of the query document.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 错误出现在查询文档的第三行。
- en: ⑥ The error was found at the fifth position of the third line.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 错误出现在第三行的第五个位置。
- en: 'The error message in listing 9.6 asks you whether you meant to use an inline
    fragment on either `ProductInterface`, `Beverage`, or `Cake`. What is an inline
    fragment? An *inline fragment* is an anonymous selection set on a specific type.
    The syntax for inline fragments includes three dots (the spread operator in JavaScript)
    followed by the `on` keyword and the type on which the selection set applies,
    as well as a selection of properties between curly braces:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6中的错误信息询问你是否想在`ProductInterface`、`Beverage`或`Cake`上使用内联片段。什么是内联片段？内联片段是在特定类型上的匿名选择集。内联片段的语法包括三个点（JavaScript中的扩展运算符）后跟`on`关键字和选择集应用到的类型，以及花括号之间的属性选择：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Listing 9.7 fixes the `allProducts()` query by adding inline fragments that
    select properties on the `ProductInterface`, `Cake`, and `Beverage` types. `allProducts()`’s
    return type is `Product`, which is the union of `Cake` and `Beverage`, so we can
    select properties from both types. From the specification, we also know that `Cake`
    and `Beverage` implement the `ProductInterface` interface type, so we can conveniently
    select properties common to both `Cake` and `Beverage` directly on the interface.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7通过添加选择`ProductInterface`、`Cake`和`Beverage`类型属性的内联片段来修复`allProducts()`查询。`allProducts()`的返回类型是`Product`，它是`Cake`和`Beverage`的联合，因此我们可以从这两种类型中选择属性。从规范中，我们还知道`Cake`和`Beverage`实现了`ProductInterface`接口类型，因此我们可以方便地在接口上直接选择`Cake`和`Beverage`共有的属性。
- en: Listing 9.7 Adding inline fragments for each return type
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7 添加每个返回类型的内联片段
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① Inline fragment with a selection set on the ProductInterface type
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在ProductInterface类型上有选择集的内联片段
- en: ② Inline fragment with a selection set on the Cake type
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在Cake类型上有选择集的内联片段
- en: ③ Inline fragment with a selection set on the Beverage type
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在Beverage类型上有选择集的内联片段
- en: Listing 9.7 uses inline fragments, but the real benefit of fragments is we can
    define them as standalone variables. This makes fragments reusable, and it also
    makes our queries more readable. Listing 9.8 shows how we can refactor listing
    9.7 to use standalone fragments. The queries are so much cleaner! In real-life
    situations, you’re likely to work with large selection sets, so organizing your
    fragments into standalone, reusable pieces of code will make your queries easier
    to read.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7使用内联片段，但片段的实际好处是我们可以将它们定义为独立的变量。这使得片段可重用，同时也使我们的查询更易于阅读。列表9.8展示了我们如何重构列表9.7以使用独立片段。查询变得如此干净！在实际情况下，你很可能会处理大量的选择集，因此将你的片段组织成独立的、可重用的代码片段将使你的查询更容易阅读。
- en: Listing 9.8 Using standalone fragments
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.8 使用独立片段
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we know how to deal with queries that return multiple object types,
    let’s take our querying skills to the next level. In the next section, we’ll learn
    to run queries with a specific type of parameter called an input parameter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何处理返回多个对象类型的查询，让我们将我们的查询技能提升到下一个层次。在下一节中，我们将学习如何使用一种称为输入参数的特定类型参数运行查询。
- en: 9.4 Running queries with input parameters
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 使用输入参数运行查询
- en: This section explains how we run queries with input type parameters. In section
    8.8, we learned that input types are similar to object types, but they’re meant
    for use as parameters for a GraphQL query or mutation. One example of an input
    type in the products API is `ProductsFilter`, which allows us to filter products
    by factors such as availability, minimum or maximum price, and others. `ProductsFilter`
    is the parameter of the `products()` query. How do we call the `products()` query?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何使用输入类型参数运行查询。在第8.8节中，我们了解到输入类型类似于对象类型，但它们是为了用作GraphQL查询或变异的参数。在产品API中，`ProductsFilter`是一个输入类型的例子，它允许我们通过可用性、最低或最高价格等因素过滤产品。`ProductsFilter`是`products()`查询的参数。我们如何调用`products()`查询？
- en: When a query takes parameters in the form of an input type, the query’s input
    type parameter must be passed in the form of an input object. This may sound complicated,
    but it’s actually very simple. We call the `products()` query using `ProductsFilter`’s
    `maxPrice` parameter. To use any of the parameters in the input type, we simply
    wrap them with curly braces.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个查询以输入类型的形式接受参数时，查询的输入类型参数必须以输入对象的形式传递。这可能听起来很复杂，但实际上非常简单。我们使用 `ProductsFilter`
    的 `maxPrice` 参数调用 `products()` 查询。要使用输入类型中的任何参数，我们只需用大括号将它们括起来。
- en: Listing 9.9 Calling a query with a required parameter
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.9 使用必需参数调用查询
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① We specify ProductFilter’s maxPrice parameter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ① 指定 ProductFilter 的 maxPrice 参数。
- en: ② Inline fragment on the ProductInterface type
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在 ProductInterface 类型上的内联片段
- en: Now that we know how to call queries with input parameters, let’s take a deeper
    look at the relationships between the objects defined in the API specification
    and see how we can build queries that allow us to traverse our data graph.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何使用输入参数调用查询，让我们更深入地了解 API 规范中定义的对象之间的关系，并看看我们如何构建允许我们遍历我们的数据图的查询。
- en: 9.5 Navigating the API graph
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 导航 API 图
- en: This section explains how we select properties from multiple types by leveraging
    their connections. In section 8.5, we learned to create connections between object
    types by using edge properties and through types. These connections allow API
    clients to traverse the graph of relationships between the resources managed by
    the API. For example, in the products API, the `Cake` and `Beverage` types are
    connected with the `Ingredient` type by means of a through type called `IngredientRecipe`.
    By leveraging this connection, we can run queries that fetch information about
    the ingredients related to each product. In this section, we’ll learn to build
    such queries.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何通过利用它们的连接从多个类型中选择属性。在 8.5 节中，我们学习了如何通过使用边属性和通过类型创建对象类型之间的连接。这些连接允许 API
    客户端遍历 API 管理的资源之间的关系图。例如，在产品 API 中，`Cake` 和 `Beverage` 类型通过一个称为 `IngredientRecipe`
    的通过类型与 `Ingredient` 类型连接。通过利用这个连接，我们可以运行查询，获取与每个产品相关的成分信息。在本节中，我们将学习如何构建这样的查询。
- en: In our queries, whenever we add a selector for a property that points to another
    object type, we must include a nested selection set for said object type. For
    example, if we add a selector for the `ingredient` property on the `ProductInterface`
    type, we have to include a selection set with any of the properties in `IngredientRecipe`
    nested within the `ingredients` property. We include a nested selection set for
    the `ingredients` property of `ProductInterface` in the `allProducts()` query.
    The query selects the name of each product as well as the name of each ingredient
    in the product’s recipe.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的查询中，每当我们添加一个指向另一个对象类型的属性的选择器时，我们必须包括一个嵌套的选择集。例如，如果我们添加了 `ProductInterface`
    类型上的 `ingredient` 属性的选择器，我们必须包括一个包含在 `ingredients` 属性中的 `IngredientRecipe` 的任何属性的选择集。我们在
    `allProducts()` 查询中包含了 `ProductInterface` 的 `ingredients` 属性的嵌套选择集。该查询选择了每个产品的名称以及产品配方中每个成分的名称。
- en: Listing 9.10 Querying nested object types
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 查询嵌套对象类型
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Inline fragment on the ProductInterface type
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在 ProductInterface 类型上的内联片段
- en: ② Selector for ProductInterface’s ingredients property
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ② ProductInterface 的 ingredients 属性选择器
- en: ③ Selector for IngredientRecipe’s ingredient property
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ③ IngredientRecipe 的 ingredient 属性选择器
- en: Listing 9.10 leverages the connection between the `ProductInterface` and `Ingredient`
    types to fetch information from both types in a single query, but we can take
    this further. The `Ingredient` type contains a `supplier` property, which points
    to the `Supplier` type. Say we want to get a list of products, including their
    names and ingredients, together with the supplier’s name of each ingredient. (I
    encourage you to head over to the Voyager UI generated by `graphql-faker` to visualize
    the relationships captured by this query; figure 9.1 is an illustration of the
    Voyager UI.)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 利用 `ProductInterface` 和 `Ingredient` 类型之间的连接，在单个查询中从这两个类型中获取信息，但我们还可以更进一步。`Ingredient`
    类型包含一个 `supplier` 属性，它指向 `Supplier` 类型。假设我们想要获取一个产品列表，包括它们的名称和成分，以及每个成分的供应商名称。（我鼓励您访问由
    `graphql-faker` 生成的 Voyager UI，以可视化此查询捕获的关系；图 9.1 是 Voyager UI 的示意图。）
- en: Listing 9.11 Traversing the products API graph through connections between types
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.11 通过类型之间的连接遍历产品 API 图
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① Inline fragment on the ProudctInterface type
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在 ProudctInterface 类型上的内联片段
- en: ② Selector for ProductInterface’s ingredients property
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ② ProductInterface的ingredients属性的选择器
- en: ③ Selector for IngredientRecipe’s ingredient property
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ③ IngredientRecipe的ingredient属性选择器
- en: ④ Selector for Ingredient’s supplier property
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ④ Ingredient的supplier属性选择器
- en: Listing 9.11 is traversing our graph of types. Starting from the `ProductInterface`
    type, we are able to fetch details about other objects, such as `Ingredient` and
    `Supplier`, by leveraging their connections.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.11正在遍历我们的类型图。从`ProductInterface`类型开始，我们可以通过利用它们的连接来获取其他对象的信息，例如`Ingredient`和`Supplier`。
- en: Here lies one the most powerful features of GraphQL, and one of its main advantages
    in comparison with other types of APIs, such as REST. Using REST, we’d need to
    make multiple requests to obtain all the information we were able to fetch in
    one request in listing 9.11\. GraphQL gives you the power to obtain all the information
    you need, and just the information you need, in a single request.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是GraphQL最强大的功能之一，也是与其他类型的API（如REST）相比的主要优势之一。使用REST，我们需要进行多个请求才能获取在列表9.11中通过一个请求就能获取的所有信息。GraphQL赋予你获取所需所有信息，以及仅获取所需信息的权力，在一个请求中完成。
- en: Now that we know how to traverse the graph of types in a GraphQL API, let’s
    take our querying skills to the next level by learning how to run multiple queries
    within a single request!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何在GraphQL API中遍历类型图，让我们通过学习如何在单个请求中运行多个查询来将我们的查询技能提升到下一个层次！
- en: 9.6 Running multiple queries and query aliasing
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 运行多个查询和查询别名
- en: This section explains how to run multiple queries per request and how to create
    aliases for the responses returned by the server. Aliasing our queries means changing
    the key under which the dataset returned by the server is indexed. As we’ll see,
    aliases can improve the readability of the results returned by the server, especially
    when we make multiple queries per request.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何在每个请求中运行多个查询以及如何为服务器返回的响应创建别名。别名我们的查询意味着更改服务器返回的数据集索引下的键。正如我们将看到的，别名可以提高服务器返回结果的可读性，尤其是在我们每个请求进行多个查询时。
- en: 9.6.1 Running multiple queries in the same request
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.1 在同一请求中运行多个查询
- en: In previous sections, we ran only one query per request. However, GraphQL also
    allows us to send several queries in one request. This is yet another powerful
    feature of GraphQL that can help us save unnecessary network round-trips to the
    server, improving the overall performance of our applications and therefore user
    experience.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们每次请求只运行一个查询。然而，GraphQL也允许我们在一个请求中发送多个查询。这是GraphQL的另一个强大功能，可以帮助我们节省不必要的网络往返到服务器，从而提高我们应用程序的整体性能和用户体验。
- en: Let’s say we wanted to obtain a list of all the products and ingredients available
    in the CoffeeMesh platform, as shown in figure 9.4\. To do that, we can run `allIngredients()`
    with the `allProducts()` queries. Listing 9.12 shows how we include both operations
    within the same query document. By including multiple queries within the same
    query document, we make sure all of them are sent to the server in the same request,
    and therefore we save round-trips to the server. The code also includes a named
    fragment that selects properties on the `ProductInterface` type. Named fragments
    are useful to keep our queries clean and focused.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要获取CoffeeMesh平台中所有产品和成分的列表，如图9.4所示。为此，我们可以运行`allIngredients()`和`allProducts()`查询。列表9.12显示了如何在同一个查询文档中包含这两个操作。通过在同一个查询文档中包含多个查询，我们确保它们都通过同一个请求发送到服务器，从而节省了往返服务器的次数。代码还包括一个命名片段，该片段选择`ProductInterface`类型的属性。命名片段有助于保持我们的查询简洁和专注。
- en: Listing 9.12 Multiple queries per request
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.12 每个请求中的多个查询
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① We run the allProducts() query without parameters.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们运行不带参数的allProducts()查询。
- en: ② We select properties using a named fragment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用命名片段选择属性。
- en: ③ We run the allIngredients() query.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 运行allIngredients()查询。
- en: ④ Named fragment with selection set on the ProductInterface type
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在ProductInterface类型上具有选择集的命名片段
- en: '![](../Images/09-04.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-04.png)'
- en: Figure 9.4 In GraphQL, we can run multiple queries within the same request,
    and the response will contain one dataset for each query.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 在GraphQL中，我们可以在同一个请求中运行多个查询，并且响应将包含每个查询的一个数据集。
- en: 9.6.2 Aliasing our queries
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.2 别名我们的查询
- en: All the queries we’ve run in previous sections are anonymous queries. When we
    make an anonymous query, the data returned by the server appears under a key named
    after the name of the query we’re calling.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几节中运行的所有查询都是匿名查询。当我们进行匿名查询时，服务器返回的数据会出现在我们调用的查询名称命名的键下。
- en: Listing 9.13 Result of an anonymous query
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.13 匿名查询的结果
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① We run the allIngredients() query.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们运行allIngredients()查询。
- en: ② Successful response from the query
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ② 查询成功响应
- en: ③ Query result
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 查询结果
- en: 'Running anonymous queries can sometimes be confusing. `allIngredients()` returns
    a list of ingredients, so it is helpful to index the list of ingredients under
    an `ingredients` key, instead of `allIngredients()`. Changing the name of this
    key is called *query aliasing*. We can make our queries more readable by using
    aliasing. The benefits of aliasing become clearer when we include multiple queries
    in the same request. For example, the query for all products and ingredients shown
    in listing 9.12 becomes more readable if we use aliases. The following code shows
    how we use aliases to rename the results of each query: the result of `allProducts()`
    appears under the `product` alias, and the result of the `allIngredients()` query
    appears under the `ingredients` alias.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行匿名查询有时可能会令人困惑。`allIngredients()`返回一个成分列表，因此将成分列表索引在`ingredients`键下，而不是`allIngredients()`下是有帮助的。更改此键的名称称为*查询别名*。我们可以通过使用别名使我们的查询更易读。当我们在同一个请求中包含多个查询时，别名的优势变得更加明显。例如，如果我们在9.12列表中使用别名，那么所有产品和成分的查询将变得更加易读。以下代码显示了如何使用别名重命名每个查询的结果：`allProducts()`的结果出现在`product`别名下，而`allIngredients()`查询的结果出现在`ingredients`别名下。
- en: Listing 9.14 Using query aliasing for more readable queries
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.14 使用查询别名以使查询更易读
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Alias for the allProducts() query
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ① allProducts()查询的别名
- en: ② We select properties using a named fragment.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用命名片段选择属性。
- en: ③ Alias for the allIngredients() query
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ③ allIngredients()查询的别名
- en: ④ Named fragment with selection set on the ProductInterface
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在ProductInterface上设置选择集的命名片段
- en: 'In some cases, using query aliases is necessary to make our requests work.
    For example, in listing 9.15, we run the `products()` query twice to select two
    datasets: one for available products and another for unavailable products. Both
    datasets are produced by the same query: `products`. As you can see, without query
    aliasing, this request results in conflict error, because both datasets return
    under the same key: `products`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，使用查询别名是必要的，以便使我们的请求生效。例如，在9.15列表中，我们运行了`products()`查询两次以选择两个数据集：一个用于可用产品，另一个用于不可用产品。这两个数据集都是由同一个查询生成的：`products`。正如你所看到的，如果没有查询别名，这个请求会导致冲突错误，因为两个数据集都在同一个键下返回：`products`。
- en: Listing 9.15 Error due to calling the same query multiple times without aliases
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.15 由于没有别名而多次调用相同的查询导致的错误
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① We run the products() query filtering for available products.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ① 运行用于过滤可用产品的products()查询
- en: ② We select properties using the commonProperties fragment.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用commonProperties片段选择属性。
- en: ③ We run the products() query filtering for unavailable products.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们运行用于过滤不可用产品的products()查询。
- en: ④ Named fragment with selection set on the ProductInterface type.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在ProductInterface类型上设置选择集的命名片段。
- en: ⑤ The query returns an unsuccessful response, so the payload includes an error
    key.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 查询返回失败响应，因此有效载荷包括一个错误键。
- en: ⑥ The error message says that the query document contains a conflict.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 错误信息表明查询文档包含冲突。
- en: ⑦ The server found errors in lines 2 and 5 from the query document.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 服务器在查询文档的第2行和第5行发现了错误。
- en: 'To resolve the conflict created by the queries in listing 9.15, we must use
    aliases. Listing 9.16 fixes the query by adding an alias to each operation: `availableProducts`
    for the query that filters for available products and `unavailableProducts` for
    the query that filters for unavailable products.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决9.15列表中查询所造成的冲突，我们必须使用别名。9.16列表通过为每个操作添加一个别名来修复查询：`availableProducts`用于过滤可用产品的查询，`unavailableProducts`用于过滤不可用产品的查询。
- en: Listing 9.16 Calling the same query multiple times with aliases
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.16 使用别名多次调用相同的查询
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Alias for the available products() query
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ① 可用产品()查询的别名
- en: ② unavailableProducts alias for the unavailable products() query
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ② 不可用产品()查询的unavailableProducts别名
- en: ③ Successful response from the server
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 服务器成功响应
- en: ④ Result of the available products() query
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 可用产品()查询的结果
- en: ⑤ Result of the unavailable products() query
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 不可用产品()查询的结果
- en: This concludes our overview of GraphQL queries. You’ve learned to run queries
    with parameters, with input types, with inline and named fragments, and with aliases,
    and you’ve learned to include multiple queries within the same request. We’ve
    come a long way! But no overview of the GraphQL query language would be complete
    without learning how to run mutations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 GraphQL 查询的概述。你已经学会了如何使用参数、输入类型、内联和命名的片段以及别名来运行查询，你还学会了如何在同一请求中包含多个查询。我们已经走了很长的路！但是，没有学习如何运行变异，任何
    GraphQL 查询语言的概述都不会完整。
- en: 9.7 Running GraphQL mutations
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7 运行 GraphQL 变异
- en: 'This section explains how we run GraphQL mutations. Mutations are GraphQL functions
    that allow us to create resources or change the state of the server. Running a
    mutation is similar to running a query. The only difference between the two is
    in their intent: queries are meant to read data from the server, while mutations
    are meant to create or change data in the server.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何运行 GraphQL 变异。变异是允许我们创建资源或更改服务器状态的 GraphQL 函数。运行变异与运行查询类似。这两者之间的唯一区别在于它们的意图：查询的目的是从服务器读取数据，而变异的目的是在服务器中创建或更改数据。
- en: Let’s illustrate how we run a mutation with an example. Listing 9.17 shows how
    we run the `deleteProduct()` mutation. When we use mutations, we must start our
    query document by qualifying our operation as a mutation. The `deleteProduct()`
    mutation has one required argument, a product ID, and its return value is a simple
    Boolean, so in this case, we don’t have to include a selection set.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来说明我们如何运行一个变异。列表 9.17 展示了如何运行 `deleteProduct()` 变异。当我们使用变异时，我们必须通过指定我们的操作为变异来开始我们的查询文档。`deleteProduct()`
    变异有一个必需的参数，即产品 ID，它的返回值是一个简单的布尔值，所以在这种情况下，我们不需要包含选择集。
- en: Listing 9.17 Calling a mutation
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.17 调用一个变异
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① We qualify the operation we’re going to run as a mutation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们将我们要运行的运算符指定为变异。
- en: ② We call the deleteProduct() mutation, passing in the required id parameter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们调用 `deleteProduct()` 变异，传递必需的 id 参数。
- en: 'Let’s now look at a more complex mutation, like `addProduct()`, which is used
    to add new products to the CoffeeMesh catalogue. `addProduct()` has three required
    parameters:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个更复杂的变异，比如 `addProduct()`，它用于向 CoffeeMesh 目录中添加新产品。`addProduct()` 有三个必需的参数：
- en: '`name`—The product name.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`—产品名称。'
- en: '`type`—The product type. The values for this parameter are constrained by the
    `ProductType` enumeration, which offers two choices: cake and beverage.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`—产品类型。此参数的值受 `ProductType` 枚举的限制，它提供了两个选择：蛋糕和饮料。'
- en: '`inpu`t—Additional product properties, such as its price, size, list of ingredients,
    and others. The full list of properties is given by the `AddProductInput` type.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input`—额外的产品属性，例如其价格、尺寸、成分列表等。属性的全列表由 `AddProductInput` 类型给出。'
- en: '`addProduct()` returns a value of type `Product`, which means, in this case,
    we must include a selection set. Remember that `Product` is the union of the `Cake`
    and `Beverage` types, so our selection set must use fragments to indicate which
    type’s properties we want to include in our return payload. In the following example,
    we select the `name` property on the `ProductInterface` type.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`addProduct()` 返回一个 `Product` 类型的值，这意味着在这种情况下，我们必须包含一个选择集。记住，`Product` 是 `Cake`
    和 `Beverage` 类型的联合，所以我们的选择集必须使用片段来指示我们想在返回的有效载荷中包含哪个类型的属性。在下面的示例中，我们选择了 `ProductInterface`
    类型的 `name` 属性。'
- en: Listing 9.18 Calling a mutation with input parameters and complex return type
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.18 使用输入参数和复杂返回类型调用变异
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① We qualify the operation we’re going to run as a mutation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们将我们要运行的运算符指定为变异。
- en: ② We call the addProduct() mutation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们调用 `addProduct()` 变异。
- en: ③ We select properties using a named fragment.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们使用命名的片段选择属性。
- en: Now that we know how to run mutations, it’s time to learn how we write more
    structured and readable query documents by parameterizing the arguments.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何运行变异，是时候学习我们如何通过参数化参数来编写更结构化和可读的查询文档了。
- en: 9.8 Running parameterized queries and mutations
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8 运行参数化查询和变异
- en: This section introduces parameterized queries and explains how we can use them
    to build more structured and readable query documents. In previous sections, when
    using queries and mutations that require parameters, we defined the values for
    each parameter in the same line we called the function. In queries with lots of
    arguments, this approach can lead to query documents, which are cluttered and
    difficult to read and maintain. GraphQL offers a solution for this, which is to
    use parameterized queries.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了参数化查询，并解释了我们可以如何使用它们来构建更结构化和可读的查询文档。在之前的章节中，当使用需要参数的查询和突变时，我们在调用函数的同一行定义了每个参数的值。在有很多参数的查询中，这种方法可能导致查询文档杂乱无章，难以阅读和维护。GraphQL为此提供了一个解决方案，即使用参数化查询。
- en: 'Parameterized queries allow us to decouple our query/mutation calls from the
    data. Figure 9.5 illustrates how we parameterize the call to the `addProduct()`
    mutation using GraphiQL (the code for the query is also shown in listing 9.19
    so that you can inspect it and copy it more easily). There’re two things we need
    to do when we parameterize a query or mutation: create a function wrapper around
    the query/mutation, and assign values for the query/mutation parameters in a query
    variables object. Figure 9.6 illustrates how all these pieces fit together to
    bind the parameterized values to the `addProduct()` mutation call.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化查询使我们能够将查询/突变调用与数据解耦。图9.5说明了我们如何使用GraphiQL参数化对`addProduct()`突变的调用（查询的代码也显示在列表9.19中，以便您可以检查并更容易地复制它）。当我们参数化一个查询或突变时，我们需要做两件事：在查询变量对象中为查询/突变参数分配值，并在查询/突变周围创建一个函数包装器。图9.6说明了所有这些部分如何组合在一起，将参数化值绑定到`addProduct()`突变调用。
- en: '![](../Images/09-05.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09-05.png)'
- en: Figure 9.5 GraphiQL offers a Query Variables panel where we can include the
    input values for our parameterized queries.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 GraphiQL提供了一个查询变量面板，我们可以在这里包含参数化查询的输入值。
- en: Listing 9.19 Using parameterized syntax
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.19 使用参数化语法
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① We create a wrapper named CreateProduct().
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们创建一个名为`CreateProduct()`的包装器。
- en: ② We call the addProduct() mutation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们调用`addProduct()`突变。
- en: ③ We select properties using a named fragment.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们使用命名片段选择属性。
- en: ④ We assign a value to the name parameter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们为名称参数分配一个值。
- en: ⑤ We assign a value to the type parameter.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们为类型参数分配一个值。
- en: ⑥ We assign a value to the input parameter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们为输入参数分配一个值。
- en: Let’s look at each of these steps in detail.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些步骤。
- en: '*Creating a query/mutation wrapper*. To parameterize our queries, we create
    a function wrapper around the query or mutation. In figure 9.5, we call the wrapper
    `CreateProduct()`. The syntax for the wrapper looks very similar to the syntax
    we use to define a query. Parameterized arguments must be included in the wrapper’s
    function signature. In figure 9.5, we parameterize the `name`, `type`, and `input`
    parameters of the `addProduct()` mutation. The parameterized argument is marked
    with a dollar sign (`$`). In the wrapper’s signature (i.e., in `CreateProduct()`),
    we specify the expected type of the parameterized arguments.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*创建查询/突变包装器*。为了参数化我们的查询，我们在查询或突变周围创建一个函数包装器。如图9.5所示，我们称这个包装器为`CreateProduct()`。包装器的语法看起来与我们用来定义查询的语法非常相似。参数化参数必须包含在包装器函数的签名中。在图9.5中，我们参数化了`addProduct()`突变中的`name`、`type`和`input`参数。参数化参数用美元符号（`$`）标记。在包装器的签名中（即`CreateProduct()`中），我们指定参数化参数的预期类型。'
- en: '*Parameterizing through a query variables object*. Separately, we define our
    query variables as a JSON document. As you can see in figure 9.5, in GraphiQL
    we define query variables within the Query Variables panel. For further clarification
    on how parameterized queries work, look at figure 9.6.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*通过查询变量对象进行参数化*。分别地，我们将查询变量定义为一个JSON文档。如图9.5所示，在GraphiQL中，我们在查询变量面板中定义查询变量。为了进一步了解参数化查询的工作原理，请参阅图9.6。'
- en: In figure 9.5, we used parameterized syntax to wrap only one mutation, but nothing
    prevents us from wrapping more mutations within the same query document. When
    we wrap multiple queries or mutations, all the parameterized arguments must be
    defined within the wrapper’s function signature. The following code shows how
    we extend the query from listing 9.19 to include a call to the `deleteProduct()`
    mutation. Here, we call the wrapper `CreateAndDeleteProduct()` to better represent
    the actions in this request.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 9.5 中，我们使用参数化语法仅包装了一个突变，但没有任何阻止我们在同一个查询文档中包装更多突变。当我们包装多个查询或突变时，所有参数化参数必须在包装器函数签名内定义。以下代码显示了如何将列表
    9.19 中的查询扩展到包括对 `deleteProduct()` 突变的调用。在这里，我们调用包装器 `CreateAndDeleteProduct()`
    以更好地表示此请求中的操作。
- en: '![](../Images/09-06.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09-06.png)'
- en: Figure 9.6 To parameterize queries and mutations, we create a function wrapper
    around the query or mutation. In the wrapper’s signature we include the parameterized
    arguments. Parameterized variables carry a leading dollar (`$`) sign.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 为了参数化查询和突变，我们在查询或突变周围创建了一个函数包装器。在包装器的签名中，我们包括参数化参数。参数化变量带有前导美元符号 (`$`)。
- en: Listing 9.20 Using parameterized syntax
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.20 使用参数化语法
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① We created a wrapper named CreateAndDeleteProduct().
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们创建了一个名为 CreateAndDeleteProduct() 的包装器。
- en: ② We call the addProduct() mutation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们调用 addProduct() 突变。
- en: ③ We select properties using a named fragment.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们使用命名片段选择属性。
- en: ④ We call the deleteProduct() mutation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们调用 deleteProduct() 突变。
- en: ⑤ We assign values to addProduct()’s parameters.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们为 addProduct() 的参数分配值。
- en: ⑥ We set the value for deleteProduct()’s id parameter.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们为 deleteProduct() 函数的 id 参数设置了值。
- en: This completes our journey through learning how to consume GraphQL APIs. You
    can now inspect any GraphQL API, explore its types, and play around with its queries
    and mutations. Before we close this chapter, I’d like to show you how a GraphQL
    API request works under the hood.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们学习如何消费 GraphQL API 的旅程。你现在可以检查任何 GraphQL API，探索其类型，并对其查询和突变进行实验。在我们关闭这一章之前，我想向你展示一个
    GraphQL API 请求是如何在底层工作的。
- en: 9.9 Demystifying GraphQL queries
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.9 揭秘 GraphQL 查询
- en: This section explains how GraphQL queries work under the hood in the context
    of HTTP requests. In previous sections, we used the GraphiQL client to explore
    our GraphQL API and to interact with it. GraphiQL translates our query documents
    into HTTP requests that the GraphQL server understands. GraphQL clients such as
    GraphiQL are interfaces that make it easier to interact with a GraphQL API. But
    nothing prevents you from sending an HTTP request directly to the API, say, from
    your terminal, using something like cURL. Contrary to a popular misconception,
    you don’t really need any special tools to work with GraphQL APIs.[¹](#pgfId-1098532)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了在 HTTP 请求的上下文中，GraphQL 查询是如何在底层工作的。在前面的章节中，我们使用了 GraphiQL 客户端来探索我们的 GraphQL
    API 并与之交互。GraphiQL 将我们的查询文档转换为 GraphQL 服务器能够理解的 HTTP 请求。GraphiQL 等客户端如 GraphiQL
    是使与 GraphQL API 交互更简单的接口。但没有任何阻止你直接向 API 发送 HTTP 请求，例如，从你的终端使用类似 cURL 的工具。与一个普遍的误解相反，你实际上并不需要任何特殊的工具来与
    GraphQL API 一起工作。[¹](#pgfId-1098532)
- en: To send a request to a GraphQL API, you can use either of the GET or POST methods.
    If you use GET, you send your query document using URL query parameters, and if
    you use POST, you include the query in the request payload. GraphQL Faker’s mock
    server only accepts GET requests, so I’ll illustrate how you send a query using
    GET.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 GraphQL API 发送请求，你可以使用 GET 或 POST 方法之一。如果你使用 GET，你将使用 URL 查询参数发送你的查询文档；如果你使用
    POST，你将在请求有效载荷中包含查询。GraphQL Faker 的模拟服务器只接受 GET 请求，所以我将说明如何使用 GET 发送查询。
- en: 'Let’s run the `allIngredients()` query, selecting only the `name` property
    of each ingredient. Since this is a GET request, our query document must be included
    in the URL as a query parameter. However, the query document contains special
    characters, such as curly braces, which are considered unsafe and therefore cannot
    be included in a URL. To deal with special characters in URLs, we URL encode them.
    *URL encoding* is the process of translating special characters, such as braces,
    punctuation marks, and others, into a suitable format for URLs. URL-encoded characters
    start with a percent sign, so this type of encoding is also known as *percent
    encoding*.[²](#pgfId-1098539) cURL takes care of URL encoding our data when we
    use the `--data-urlencode` option. By using `--data-urlencode`, cURL translates
    our command into a GET request with the following URL: http://localhost:9002/graphql?query=%7BallIngredients%7Bname%7D%7D.
    The following snippet shows the cURL command you need to run to make this call:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 `allIngredients()` 查询，仅选择每个成分的 `name` 属性。由于这是一个 GET 请求，我们的查询文档必须作为查询参数包含在
    URL 中。然而，查询文档包含特殊字符，如大括号，这些字符被认为是不可安全的，因此不能包含在 URL 中。为了处理 URL 中的特殊字符，我们需要对它们进行
    URL 编码。*URL 编码* 是将特殊字符（如大括号、标点符号等）转换为适合 URL 的格式的过程。URL 编码的字符以百分号开头，因此这种编码也被称为
    *百分编码*。[²](#pgfId-1098539) 当我们使用 `--data-urlencode` 选项时，cURL 会负责对数据进行 URL 编码。通过使用
    `--data-urlencode`，cURL 将我们的命令转换为以下 URL 的 GET 请求：http://localhost:9002/graphql?query=%7BallIngredients%7Bname%7D%7D。以下代码片段显示了你需要运行的
    cURL 命令来执行此调用：
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that you understand how GraphQL API requests work under the hood, let’s
    see how we can leverage this knowledge to write code in Python that consumes a
    GraphQL API.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 GraphQL API 请求的工作原理，让我们看看如何利用这些知识来编写 Python 代码，以消耗 GraphQL API。
- en: 9.10 Calling a GraphQL API with Python code
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.10 使用 Python 代码调用 GraphQL API
- en: This section illustrates how we can interact with a GraphQL API using Python.
    GraphQL clients like GraphiQL are useful to explore and get familiar with a GraphQL
    API, but in practice, you’ll spend most of your time writing applications that
    consume those APIs programmatically. In this section, we learn to consume the
    products API using a GraphQL client written in Python.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本节说明了我们如何使用 Python 与 GraphQL API 进行交互。GraphQL 客户端如 GraphiQL 有助于探索和熟悉 GraphQL
    API，但在实际应用中，你将花费大部分时间编写消耗这些 API 的应用程序。在本节中，我们将学习如何使用用 Python 编写的 GraphQL 客户端来消耗产品
    API。
- en: To work with GraphQL APIs, the Python ecosystem offers libraries such as `gql`
    ([https://github.com/graphql-python/gql](https://github.com/graphql-python/gql))
    and `sgqlc` ([https://github.com/profusion/sgqlc](https://github.com/profusion/sgqlc)).
    These libraries are useful when we want to use advanced features of GraphQL, such
    as subscriptions. You’ll rarely need those features in the context of microservices,
    so for the purposes of this section, we’ll take a simpler approach and use the
    popular `requests` library ([https://github.com/psf/requests](https://github.com/psf/requests)).
    Remember that GraphQL queries are simply GET or POST requests with a query document.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 GraphQL API 一起工作，Python 生态系统提供了如 `gql` ([https://github.com/graphql-python/gql](https://github.com/graphql-python/gql))
    和 `sgqlc` ([https://github.com/profusion/sgqlc](https://github.com/profusion/sgqlc))
    这样的库。当我们需要使用 GraphQL 的高级功能，如订阅时，这些库非常有用。在微服务环境中，你很少需要这些功能，因此在本节中，我们将采用更简单的方法，并使用流行的
    `requests` 库 ([https://github.com/psf/requests](https://github.com/psf/requests))。请记住，GraphQL
    查询仅仅是带有查询文档的 GET 或 POST 请求。
- en: Listing 9.21 shows how we call the `allIngredients()` query, adding a selector
    for `Ingredient`’s `name` property. The listing is also available under ch09/client.py
    in this book’s GitHub repository. Since our GraphQL mock server only accepts GET
    requests, we send the query document in the form of URL-encoded data. With requests,
    we accomplish this by passing the query document through the `get` method’s `params`
    argument. As you can see, the query document looks the same as what we wrote in
    the GraphiQL query panel, and the result from the API also looks the same. This
    is great news, because it means that, when working out your queries, you can start
    working with GraphiQL, leveraging its great support for syntax highlighting and
    query validation, and when you’re ready, you can move your queries directly to
    your Python code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.21展示了如何调用`allIngredients()`查询，并为`Ingredient`的`name`属性添加选择器。该列表也可在本书的GitHub仓库ch09/client.py中找到。由于我们的GraphQL模拟服务器只接受GET请求，我们以URL编码数据的形式发送查询文档。使用requests库，我们通过传递查询文档到`get`方法的`params`参数来实现这一点。如您所见，查询文档看起来与我们在GraphiQL查询面板中写的相同，API的响应结果也相同。这是一个好消息，因为它意味着，当您编写查询时，您可以从GraphiQL开始工作，利用其对语法高亮和查询验证的优秀支持，当您准备好时，可以将查询直接移动到Python代码中。
- en: Listing 9.21 Calling a GraphQL query using Python
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.21 使用Python调用GraphQL查询
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① We import the requests library.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们导入requests库。
- en: ② The base URL of our GraphQL server
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们GraphQL服务器的基URL
- en: ③ The query document
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 查询文档
- en: ④ We send a GET request to the server with the query document as a URL query
    parameter.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们将查询文档作为URL查询参数发送GET请求到服务器。
- en: ⑤ We parse and print the JSON payload returned by the server.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们解析并打印服务器返回的JSON有效负载。
- en: This concludes our journey through GraphQL. You went from learning about the
    basic scalar types supported by GraphQL in chapter 8 to making complex queries
    using tools as varied as GraphiQL, cURL, and Python in this chapter. Along the
    way, we built the specification for the products API, and we interacted with it
    using a GraphQL mock server. That’s no small feat. If you’ve read this far, you’ve
    learned a great deal of things about APIs, and you should be proud of it!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们通过GraphQL的旅程结束。您从第8章学习GraphQL支持的基本标量类型，到本章使用GraphiQL、cURL和Python等多样化的工具进行复杂查询。在这个过程中，我们构建了产品API的规范，并使用GraphQL模拟服务器与之交互。这是一项了不起的成就。如果您已经读到这儿，您已经学到了很多关于API的知识，您应该为此感到自豪！
- en: GraphQL is one of the most popular protocols in the world of web APIs, and its
    adoption grows every year. GraphQL is a great choice for building microservices
    APIs and for integration with frontend applications. In the next chapter, we’ll
    undertake the actual implementation of the products API and its service. Stay
    tuned!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL是网络API世界中最受欢迎的协议之一，其采用率每年都在增长。GraphQL是构建微服务API和与前端应用集成的绝佳选择。在下一章中，我们将着手实现产品API及其服务。敬请期待！
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: When we call a query or mutation that returns an object type, our query must
    include a selection set. A selection set is a list of the properties we want to
    fetch from the object returned by the query.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们调用返回对象类型的查询或突变时，我们的查询必须包含选择集。选择集是我们想要从查询返回的对象中获取的属性列表。
- en: When a query or mutation returns a list of multiple types, our selection set
    must include fragments. Fragments are selections of properties on a specific type,
    and they’re prefixed by the spread operator (three dots).
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当查询或突变返回多个类型的列表时，我们的选择集必须包含片段。片段是特定类型上的属性选择，并且由扩展运算符（三个点）作为前缀。
- en: When calling a query or mutation that includes arguments, we can parameterize
    those arguments by building a wrapper around the query or queries. This allows
    us to write more readable and maintainable query documents.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用包含参数的查询或突变时，我们可以通过围绕查询或查询构建包装器来参数化这些参数。这使我们能够编写更易于阅读和维护的查询文档。
- en: When designing a GraphQL API, it’s a good idea to put it to work with a mock
    server, which allows us to build API clients while the server is implemented.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计GraphQL API时，使用模拟服务器进行测试是个好主意，这允许我们在服务器实现的同时构建API客户端。
- en: You can run a GraphQL mock server using `graphql-faker`, which also creates
    a GraphiQL interface to the API. This is useful to test that our design conforms
    to our expectations.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`graphql-faker`运行GraphQL模拟服务器，它还会为API创建一个GraphiQL界面。这有助于测试我们的设计是否符合预期。
- en: Behind the scenes, a GraphQL query is a simple HTTP request that uses either
    of the GET or POST methods. When using GET, we must ensure our query document
    is URL encoded, and when using POST, we include it in the request payload.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在幕后，一个 GraphQL 查询是一个简单的 HTTP 请求，它使用 GET 或 POST 方法中的任意一种。当使用 GET 时，我们必须确保我们的查询文档是
    URL 编码的，而当使用 POST 时，我们将其包含在请求负载中。
- en: '* * *'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ Unless you want to use subscriptions (connections with the GraphQL server
    that allow you to receive notifications when something happens in the server,
    e.g., when the state of a resource changes). Subscriptions require a two-way connection
    with the server, so you need something more sophisticated than cURL. To learn
    more about GraphQL subscriptions, see Eve Porcello and Alex Banks, *Learning GraphQL,
    Declarative Data Fetching for Modern Web Apps* (O’Reilly, 2018), pp. 50–53 and
    150–160.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 除非你想使用订阅（与 GraphQL 服务器的连接，允许你在服务器发生某些事件时接收通知，例如，当资源的状态发生变化时）。订阅需要与服务器建立双向连接，因此你需要比
    cURL 更复杂的东西。要了解更多关于 GraphQL 订阅的信息，请参阅 Eve Porcello 和 Alex Banks 的著作 *Learning
    GraphQL, Declarative Data Fetching for Modern Web Apps*（O’Reilly，2018），第 50–53
    页和第 150–160 页。
- en: '² Tim Berners-Lee, R. Fielding, and L. Masinter, “Uniform Resource Identifer
    (URI): Generic Syntax,” RFC 3986, section 2.1, [https://datatracker.ietf.org/doc/html/rfc3986#section-2.1](https://datatracker.ietf.org/doc/html/rfc3986#section-2.1).'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ² Tim Berners-Lee, R. Fielding, 和 L. Masinter, “统一资源标识符 (URI)：通用语法，” RFC 3986，第
    2.1 节，[https://datatracker.ietf.org/doc/html/rfc3986#section-2.1](https://datatracker.ietf.org/doc/html/rfc3986#section-2.1).
