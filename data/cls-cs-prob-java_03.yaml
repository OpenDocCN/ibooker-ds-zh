- en: 2 Search problems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 搜索问题
- en: “Search” is such a broad term that this entire book could be called Classic
    Search Problems in Java. This chapter is about core search algorithms that every
    programmer should know. It does not claim to be comprehensive, despite the declaratory
    title.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “搜索”是一个如此广泛的概念，以至于整本书都可以被称为 Java 经典搜索问题。本章是关于每个程序员都应该知道的核心理解算法。尽管标题声称是全面的，但它并不全面。
- en: 2.1 DNA search
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 DNA 搜索
- en: Genes are commonly represented in computer software as a sequence of the characters
    A, C, G, and T. Each letter represents a nucleotide, and the combination of three
    nucleotides is called a codon. This is illustrated in figure 2.1\. A codon codes
    for a specific amino acid that together with other amino acids can form a protein.
    A classic task in bioinformatics software is to find a particular codon within
    a gene.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 基因在计算机软件中通常表示为字符 A、C、G 和 T 的序列。每个字母代表一个核苷酸，三个核苷酸的组合称为密码子。这如图 2.1 所示。密码子编码特定的氨基酸，这些氨基酸与其他氨基酸一起可以形成蛋白质。生物信息学软件中的经典任务是在基因中找到特定的密码子。
- en: 2.1.1 Storing DNA
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 存储 DNA
- en: We can represent a nucleotide as a simple enum with four cases.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将核苷酸表示为一个简单的枚举，有四个情况。
- en: Listing 2.1 Gene.java
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 Gene.java
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![2-1](../Images/2-1.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![2-1](../Images/2-1.png)'
- en: Figure 2.1 A nucleotide is represented by one of the letters A, C, G, and T.
    A codon is composed of three nucleotides, and a gene is composed of multiple codons.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 核苷酸由字母 A、C、G 和 T 中的一个表示。密码子由三个核苷酸组成，基因由多个密码子组成。
- en: Codons can be defined as a combination of three Nucleotides. The constructor
    for the Codon class converts a String of three letters into a Codon. To implement
    search methods, we will need to be able to compare one Codon to another. Java
    has an interface for that, Comparable.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 密码子可以定义为三个核苷酸的组合。密码子类的构造函数将三个字母的字符串转换为密码子。为了实现搜索方法，我们需要能够比较一个密码子与另一个密码子。Java
    有一个接口用于此，Comparable。
- en: Implementing the Comparable interface requires the construction of one method,
    compareTo(). compareTo() should return a negative number if the item in question
    is smaller than the item being compared, a zero if the two items are equal, and
    a positive number if the item is larger than the item being compared. In practice
    you can often avoid having to implement this by hand and instead use the built-in
    Java standard library interface Comparator, as we do in the following example.
    In this example, the Codon will first be compared to another Codon by its first
    Nucleotide, then by its second if the firsts are equivalent, and finally by its
    third if the seconds are equivalent. They are chained using thenComparing().
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 Comparable 接口需要构建一个方法，compareTo()。compareTo() 应该在问题项小于比较项时返回一个负数，在两个项相等时返回零，在问题项大于比较项时返回一个正数。在实践中，你通常可以避免手动实现它，而是使用内置的
    Java 标准库接口 Comparator，就像我们在以下示例中所做的那样。在这个例子中，密码子将首先根据其第一个核苷酸与另一个密码子进行比较，然后如果第一个核苷酸相同，则根据第二个核苷酸进行比较，最后如果第二个核苷酸相同，则根据第三个核苷酸进行比较。它们使用
    thenComparing() 链接。
- en: Listing 2.2 Gene.java continued
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 Gene.java 续
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note Codon is a static class. Nested classes that are marked static can be instantiated
    without regard to their enclosing class (you do not need an instance of the enclosing
    class to create an instance of a static nested class), but they cannot refer to
    any of the instance variables of their enclosing class. This makes sense for classes
    that are defined as nested classes primarily for organizational purposes instead
    of logistical purposes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：密码子是一个静态类。标记为静态的嵌套类可以在不考虑其封装类的情况下实例化（你不需要封装类的实例来创建静态嵌套类的实例），但它们不能引用其封装类的任何实例变量。这对于主要为了组织目的而不是物流目的而定义的嵌套类是有意义的。
- en: Typically, genes on the internet will be in a file format that contains a giant
    string representing all of the nucleotides in the gene’s sequence. The next listing
    shows an example of what a gene string may look like.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，互联网上的基因将以包含基因序列中所有核苷酸的巨大字符串的文件格式表示。下一个列表显示了基因字符串可能的样子。
- en: Listing 2.3 Gene string example
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 基因字符串示例
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only state in a Gene will be an ArrayList of Codons. We will also have a
    constructor that can take a gene string and convert it into a Gene (converting
    a String into an ArrayList of Codons).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在基因中，唯一的状态将是一个密码子（Codons）的 ArrayList。我们还将有一个构造函数，它可以接受一个基因字符串并将其转换为基因（将字符串转换为密码子的
    ArrayList）。
- en: Listing 2.4 Gene.java continued
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 Gene.java 续
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This constructor continually goes through the provided String and converts its
    next three characters into Codons that it adds to the end of a new Gene. It piggybacks
    on the constructor of Codon, which knows how to convert a three-letter String
    into a Codon.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数不断地遍历提供的String，并将其下一个三个字符转换为密码子，然后将它们添加到新基因的末尾。它依赖于密码子的构造函数，该构造函数知道如何将三个字母的String转换为密码子。
- en: 2.1.2 Linear search
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 线性搜索
- en: One basic operation we may want to perform on a gene is to search it for a particular
    codon. A scientist may want to do this to see if it codes for a particular amino
    acid. The goal is to simply find out whether the codon exists within the gene
    or not.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想在基因上执行的一种基本操作是搜索特定的密码子。科学家可能想这样做以查看它是否编码了特定的氨基酸。目标是简单地找出密码子是否存在于基因中。
- en: A linear search goes through every element in a search space, in the order of
    the original data structure, until what is sought is found or the end of the data
    structure is reached. In effect, a linear search is the most simple, natural,
    and obvious way to search for something. In the worst case, a linear search will
    require going through every element in a data structure, so it is of O(n) complexity,
    where n is the number of elements in the structure. This is illustrated in figure
    2.2.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索会遍历搜索空间中的每个元素，按照原始数据结构的顺序，直到找到所寻求的项目或达到数据结构的末尾。实际上，线性搜索是搜索某物最简单、最自然、最明显的方式。在最坏的情况下，线性搜索需要遍历数据结构中的每个元素，因此它的复杂度为O(n)，其中n是结构中的元素数量。这如图2.2所示。
- en: '![2-2](../Images/2-2.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![2-2](../Images/2-2.png)'
- en: Figure 2.2 In the worst case of a linear search, you’ll sequentially look through
    every element of the array.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 在线性搜索的最坏情况下，您将按顺序查看数组中的每个元素。
- en: It is trivial to define a function that performs a linear search. It simply
    must go through every element in a data structure and check for its equivalence
    to the item being sought. You can use the following code in main() to test it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个执行线性搜索的函数是微不足道的。它只需遍历数据结构中的每个元素，并检查其是否与所寻求的项目等效。您可以在main()中使用以下代码进行测试。
- en: Listing 2.5 Gene.java continued
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 Gene.java继续
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note This function is for illustrative purposes only. All of the classes in
    the Java standard library that implement the Collection interface (like ArrayList
    and LinkedList) have a contains() method that will likely be better optimized
    than anything we write.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：此函数仅用于说明目的。Java标准库中实现Collection接口的所有类（如ArrayList和LinkedList）都有一个contains()方法，其优化可能比我们编写的任何内容都要好。
- en: 2.1.3 Binary search
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 二分查找
- en: There is a faster way to search than looking at every element, but it requires
    us to know something about the order of the data structure ahead of time. If we
    know that the structure is sorted, and we can instantly access any item within
    it by its index, we can perform a binary search.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与查看每个元素相比，有一种更快的方法来搜索，但这要求我们提前知道数据结构的顺序。如果我们知道结构是排序的，并且我们可以通过索引立即访问其中的任何项目，我们就可以执行二分查找。
- en: A binary search works by looking at the middle element in a sorted range of
    elements, comparing it to the element sought, reducing the range by half based
    on that comparison, and starting the process over again. Let’s look at a concrete
    example.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找通过查看排序元素范围内的中间元素，将其与所寻求的元素进行比较，根据该比较结果将范围减半，然后再次开始这个过程。让我们看看一个具体的例子。
- en: 'Suppose we have a list of alphabetically sorted words like ["cat", "dog", "kangaroo",
    "llama", "rabbit", "rat", "zebra"] and we are searching for the word “rat”:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个按字母顺序排序的单词列表，如["cat", "dog", "kangaroo", "llama", "rabbit", "rat", "zebra"]，并且我们正在搜索单词“rat”：
- en: We could determine that the middle element in this seven-word list is “llama.”
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以确定这个七个单词列表的中间元素是“llama”。
- en: We could determine that “rat” comes after “llama” alphabetically, so it must
    be in the (approximately) half of the list that comes after “llama.” (If we had
    found “rat” in this step, we could have returned its location; if we had found
    that our word came before the middle word we were checking, we could be assured
    that it was in the half of the list before “llama.”)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以确定“rat”在字母表中排在“llama”之后，所以它必须在“llama”之后的（大约）列表的一半中。（如果我们在这个步骤中找到了“rat”，我们可以返回它的位置；如果我们发现我们的单词在我们检查的中间单词之前，我们可以确信它在“llama”之前的列表的一半中。）
- en: We could rerun steps 1 and 2 for the half of the list that we know “rat” is
    still possibly in. In effect, this half becomes our new base list. These steps
    continually run until “rat” is found or the range we are looking in no longer
    contains any elements to search, meaning that “rat” does not exist within the
    word list.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以为已知“rat”可能仍在其中的列表的一半重新运行步骤 1 和 2。实际上，这个一半变成了我们的新基本列表。这些步骤会一直运行，直到找到“rat”或者我们正在查找的范围不再包含任何要搜索的元素，这意味着“rat”不在单词列表中。
- en: Figure 2.3 illustrates a binary search. Notice that it does not involve searching
    every element, unlike a linear search.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 阐述了二分查找。请注意，它不涉及搜索每个元素，这与线性搜索不同。
- en: '![2-3](../Images/2-3.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![2-3](../Images/2-3.png)'
- en: Figure 2.3 In the worst case of a binary search, you’ll look through just lg(n)
    elements of the list.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 在二分查找的最坏情况下，你只需查看列表中的 lg(n) 个元素。
- en: A binary search continually reduces the search space by half, so it has a worst-case
    runtime of O(lg n). There is a sort-of catch, though. Unlike a linear search,
    a binary search requires a sorted data structure to search through, and sorting
    takes time. In fact, sorting takes O(n lg n) time for the best sorting algorithms.
    If we are only going to run our search once, and our original data structure is
    unsorted, it probably makes sense to just do a linear search. But if the search
    is going to be performed many times, the time cost of doing the sort is worth
    it, to reap the benefit of the greatly reduced time cost of each individual search.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找通过每次将搜索空间减半来不断减少搜索空间，因此其最坏情况运行时间为 O(lg n)。然而，有一个问题。与线性搜索不同，二分搜索需要一个已排序的数据结构来搜索，而排序需要时间。实际上，对于最佳排序算法，排序需要
    O(n lg n) 的时间。如果我们只运行一次搜索，并且我们的原始数据结构未排序，那么进行线性搜索可能是有意义的。但是，如果搜索将多次执行，那么排序的时间成本是值得的，以获得每次单独搜索大大减少的时间成本的好处。
- en: Writing a binary search function for a gene and a codon is not unlike writing
    one for any other type of data, because the Codon type can be compared to others
    of its type, and the Gene type just contains an ArrayList of Codons. Note that
    in the following example we start by sorting the codons--this eliminates all of
    the advantages of doing a binary search, because doing the sort will take more
    time than the search, as described in the previous paragraph. However, for illustrative
    purposes, the sort is necessary, since we cannot know when running this example
    that the codons ArrayList is sorted.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为基因和密码子编写二分查找函数并不像为其他类型的数据编写那样，因为密码子类型可以与其同类型的其他密码子进行比较，而基因类型只包含一个密码子 ArrayList。请注意，在下面的例子中，我们首先对密码子进行排序——这消除了进行二分查找的所有优势，因为如前一段所述，排序所需的时间将比搜索所需的时间更长。然而，为了说明目的，排序是必要的，因为我们不知道在运行此示例时密码子
    ArrayList 是否已排序。
- en: Listing 2.6 Gene.java continued
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 Gene.java 继续如下
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let’s walk through this function line by line.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析这个函数。
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We start by looking at a range that encompasses the entire list (gene).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看一个包含整个列表（基因）的范围。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We keep searching as long as there is still a range to search within. When low
    is greater than high, it means that there are no longer any slots to look at within
    the list.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们还在搜索范围内，我们就继续搜索。当 low 大于 high 时，这意味着列表中不再有任何槽位可供查看。
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We calculate the middle by using integer division and the simple mean formula
    you learned in grade school.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过整数除法和你在小学学到的简单平均公式来计算中间值。
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the element we are looking for is after the middle element of the range we
    are looking at, we modify the range that we will look at during the next iteration
    of the loop by moving low to be one past the current middle element. This is where
    we halve the range for the next iteration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在寻找的元素在我们正在查看的范围的中间元素之后，我们通过将 low 移到当前中间元素之后的一个位置来修改我们在下一次循环迭代中将查看的范围。这就是我们在下一次迭代中减半范围的地方。
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Similarly, we halve in the other direction when the element we are looking for
    is less than the middle element.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我们寻找的元素小于中间元素时，我们在另一个方向上减半。
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the element in question is not less than or greater than the middle element,
    that means we found it! And, of course, if the loop ran out of iterations, we
    return false (not reproduced here), indicating that it was never found.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所讨论的元素既不小于也不大于中间元素，这意味着我们找到了它！当然，如果循环迭代结束，我们返回 false（此处未展示），表示它从未被找到。
- en: We can now try running our binary search method with the same gene and codon.
    We can modify main() to test it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以尝试使用相同的基因和密码子运行我们的二分查找方法。我们可以修改 main() 来测试它。
- en: Listing 2.7 Gene.java continued
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 Gene.java 续
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: TIP Once again, like with linear search, you would never need to implement binary
    search yourself because there’s an implementation in the Java standard library.
    Collections.binarySearch() can search any sorted Collection (like a sorted ArrayList).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：再次提醒，就像线性搜索一样，您永远不需要自己实现二分搜索，因为 Java 标准库中有一个实现。Collections.binarySearch()
    可以搜索任何排序的集合（如排序后的 ArrayList）。
- en: 2.1.4 A generic example
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 一个通用示例
- en: The methods linearContains() and binaryContains() can be generalized to work
    with almost any Java List. The following generalized versions are nearly identical
    to the versions you saw before, with only some names and types changed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: linearContains() 和 binaryContains() 方法可以推广到几乎任何 Java List。以下推广版本几乎与您之前看到的版本相同，只是名称和类型有所改变。
- en: Note There are many imported types in the following code listing. We will be
    reusing the file GenericSearch.java for many further generic search algorithms
    in this chapter, and this gets the imports out of the way.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：以下代码列表中有许多导入的类型。我们将在这个章节的许多其他通用搜索算法中重用 GenericSearch.java 文件，这样可以避免导入。
- en: Note The extends keyword in T extends Comparable<T> means that T must be a type
    that implements the Comparable interface.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：T extends Comparable<T> 中的 extends 关键字意味着 T 必须是一个实现了 Comparable 接口类型的类型。
- en: Listing 2.8 GenericSearch.java
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.8 GenericSearch.java
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now you can try doing searches on other types of data. These methods will work
    on any List of Comparables. That is the power of writing code generically.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以尝试对其他类型的数据进行搜索。这些方法将适用于任何 Comparables 的 List。这就是编写通用代码的力量。
- en: 2.2 Maze solving
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 迷宫求解
- en: Finding a path through a maze is analogous to many common search problems in
    computer science. Why not literally find a path through a maze, then, to illustrate
    the breadth-first search, depth-first search, and A* algorithms?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在迷宫中找到一条路径与计算机科学中许多常见的搜索问题类似。那么，为什么不直接找到一条迷宫路径来展示广度优先搜索、深度优先搜索和 A* 算法呢？
- en: Our maze will be a two-dimensional grid of Cells. A Cell is an enum that knows
    how to turn itself into a String. For example, " " will represent an empty space,
    and "X" will represent a blocked space. There are also other cases for illustrative
    purposes when printing a maze.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的迷宫将是一个由单元格组成的二维网格。单元格是一个枚举，它知道如何将自己转换为字符串。例如，" " 将表示一个空格，而 "X" 将表示一个被阻塞的空间。在打印迷宫时，还有一些其他的情况用于说明。
- en: Listing 2.9 Maze.java
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.9 Maze.java
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once again, we are getting a few imports out of the way. Note that the last
    import (from GenericSearch) is of a class we have not yet defined. It is included
    here for convenience, but you may want to comment it out until you need it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我们正在处理一些导入。请注意，最后一个导入（来自 GenericSearch）是一个我们尚未定义的类。它在这里是为了方便，但您可能希望在需要之前将其注释掉。
- en: We will need a way to refer to an individual location in the maze. This will
    be a simple class, MazeLocation, with properties representing the row and column
    of the location in question. However, the class will also need a way for instances
    of it to compare themselves for equality to other instances of the same type.
    In Java, this is necessary to properly use several classes in the collections
    framework, like HashSet and HashMap. They use the methods equals() and hashCode()
    to avoid inserting duplicates, since they only allow unique instances.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来引用迷宫中的单个位置。这将是一个简单的类，MazeLocation，具有表示所讨论位置行和列的属性。然而，该类还需要一种方法，以便其实例可以与其他相同类型的实例进行比较以确定相等性。在
    Java 中，这是在集合框架中正确使用多个类（如 HashSet 和 HashMap）所必需的。它们使用 equals() 和 hashCode() 方法来避免插入重复项，因为它们只允许唯一的实例。
- en: Luckily, IDEs can do the hard work for us. The two methods following the constructor
    in the next listing were autogenerated by Eclipse. They will ensure two instances
    of MazeLocation with the same row and column are seen as equivalent to one another.
    In Eclipse, you can right-click and select Source > Generate hashCode() and equals()
    to have these methods created for you. You need to specify in a dialog which instance
    variables go into evaluating equality.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，IDE 可以为我们做这项艰苦的工作。在下一条列表中构造函数之后的两个方法是由 Eclipse 自动生成的。它们将确保具有相同行和列的两个 MazeLocation
    实例被视为彼此等价。在 Eclipse 中，您可以通过右键单击并选择 Source > Generate hashCode() 和 equals() 来创建这些方法。您需要在对话框中指定哪些实例变量用于评估相等性。
- en: Listing 2.10 Maze.java continued
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10 Maze.java 续
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 2.2.1 Generating a random maze
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 生成随机迷宫
- en: Our Maze class will internally keep track of a grid (a two-dimensional array)
    representing its state. It will also have instance variables for the number of
    rows, number of columns, start location, and goal location. Its grid will be randomly
    filled with blocked cells.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的迷宫类将内部跟踪一个表示其状态的网格（一个二维数组）。它还将有行数、列数、起始位置和目标位置的实例变量。它的网格将以随机方式填充障碍单元格。
- en: The maze that is generated should be fairly sparse so that there is almost always
    a path from a given starting location to a given goal location. (This is for testing
    our algorithms, after all.) We’ll let the caller of a new maze decide on the exact
    sparseness, but we will provide a default value of 20% blocked. When a random
    number beats the threshold of the sparseness parameter in question, we will simply
    replace an empty space with a wall. If we do this for every possible place in
    the maze, statistically, the sparseness of the maze as a whole will approximate
    the sparseness parameter supplied.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的迷宫应该相对稀疏，以便几乎总是可以从给定的起始位置到达给定的目标位置。（这毕竟是为了测试我们的算法。）我们将让新迷宫的调用者决定确切的稀疏度，但我们将提供一个默认值为20%的阻塞值。当随机数超过稀疏度参数的阈值时，我们将简单地用一个墙壁替换空格。如果我们对迷宫中的每个可能位置都这样做，从统计上讲，迷宫的整体稀疏度将接近提供的稀疏度参数。
- en: Listing 2.11 Maze.java continued
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.11 Maze.java 继续内容
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we have a maze, we also want a way to print it succinctly to the console.
    We want its characters to be close together so it looks like a real maze.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了迷宫，我们也希望有一种方法可以简洁地将其打印到控制台。我们希望它的字符紧密排列，看起来像真正的迷宫。
- en: Listing 2.12 Maze.java continued
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.12 Maze.java 继续内容
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Go ahead and test these maze functions in main() if you like.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果愿意，可以继续在main()中测试这些迷宫函数。
- en: Listing 2.13 Maze.java continued
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.13 Maze.java 继续内容
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 2.2.2 Miscellaneous maze minutiae
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 其他迷宫细节
- en: It will be handy later to have a function that checks whether we have reached
    our goal during the search. In other words, we want to check whether a particular
    MazeLocation that the search has reached is the goal. We can add a method to Maze.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在稍后，有一个函数来检查我们在搜索过程中是否达到了目标会很有用。换句话说，我们想要检查搜索到达的特定迷宫位置是否是目标。我们可以在迷宫中添加一个方法。
- en: Listing 2.14 Maze.java continued
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.14 Maze.java 继续内容
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How can we move within our mazes? Let’s say that we can move horizontally and
    vertically one space at a time from a given space in the maze. Using these criteria,
    a successors() function can find the possible next locations from a given MazeLocation.
    However, the successors() function will differ for every Maze because every Maze
    has a different size and set of walls. Therefore, we will define it as a method
    on Maze.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在迷宫中移动？假设我们可以从迷宫中的给定空间一次水平或垂直移动一个空间。使用这些标准，successors()函数可以找到从给定迷宫位置的可能下一个位置。然而，successors()函数对于每个迷宫都是不同的，因为每个迷宫的大小和墙壁集合都不同。因此，我们将它定义为迷宫上的一个方法。
- en: Listing 2.15 Maze.java continued
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.15 Maze.java 继续内容
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: successors() simply checks above, below, to the right, and to the left of a
    MazeLocation in a Maze to see if it can find empty spaces that can be gone to
    from that location. It also avoids checking locations beyond the edges of the
    Maze. It puts every possible MazeLocation that it finds into a list that it ultimately
    returns to the caller. We will use the prior two methods in our search algorithms.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: successors()简单地检查迷宫中迷宫位置的上方、下方、右侧和左侧，看是否可以找到可以从该位置到达的空格。它还避免了检查迷宫边缘之外的位置。它将找到的每个可能的迷宫位置放入一个列表中，最终返回给调用者。我们将在搜索算法中使用前两种方法。
- en: 2.2.3 Depth-first search
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 深度优先搜索
- en: 'A depth-first search (DFS) is what its name suggests: a search that goes as
    deeply as it can before backtracking to its last decision point if it reaches
    a dead end. We’ll implement a generic depth-first search that can solve our maze
    problem. It will also be reusable for other problems. Figure 2.4 illustrates an
    in-progress depth-first search of a maze.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索（DFS）正如其名所示：在回溯到上一个决策点之前，它会尽可能深入地搜索，如果遇到死胡同。我们将实现一个通用的深度优先搜索，它可以解决我们的迷宫问题。它也可以用于其他问题。图2.4展示了迷宫的深度优先搜索过程。
- en: Stacks
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 栈
- en: The depth-first search algorithm relies on a data structure known as a stack.
    (We first saw stacks in chapter 1.) A stack is a data structure that operates
    under the Last-In-First-Out (LIFO) principle. Imagine a stack of papers. The last
    paper placed on top of the stack is the first paper pulled off the stack. It is
    common for a stack to be implemented on top of a more primitive data structure
    like a linked list by adding items on one end and removing them from the same
    end. We could easily implement a stack ourselves, but the Java standard library
    includes the convenient Stack class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索算法依赖于一种称为栈的数据结构。（我们第一次在第一章中看到栈。）栈是一种遵循后进先出（LIFO）原则的数据结构。想象一下一叠纸张。最后放在栈顶的纸张是第一个从栈中取出的纸张。通常，栈是通过在链表等更原始的数据结构的一端添加项目并在同一端移除它们来实现的。我们可以轻松地自己实现一个栈，但Java标准库包括了方便的Stack类。
- en: 'Stacks generally have at least two operations:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 栈通常至少有两个操作：
- en: push()--Places an item on top of the stack
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: push()--将一个项目放置在栈顶
- en: pop()--Removes the item from the top of the stack and returns it
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pop()--从栈顶移除项目并返回它
- en: '![2-4](../Images/2-4.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![2-4](../Images/2-4.png)'
- en: Figure 2.4 In depth-first search, the search proceeds along a continuously deeper
    path until it hits a barrier and must backtrack to the last decision point.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 在深度优先搜索中，搜索沿着一条不断深入的路径进行，直到遇到障碍并必须回溯到最后一个决策点。
- en: In other words, a stack is a meta-structure that enforces an ordering of removal
    on a list. The last item put into a stack must be the next item removed from a
    stack.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，栈是一种强制对列表上的移除顺序进行排序的元结构。放入栈中的最后一个项目必须是下一个从栈中移除的项目。
- en: The DFS algorithm
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: DFS算法
- en: We will need one more little tidbit before we can get to implementing DFS. We
    need a Node class that we will use to keep track of how we got from one state
    to another state (or from one place to another place) as we search. You can think
    of a Node as a wrapper around a state. In the case of our maze-solving problem,
    those states are of type MazeLocation. We’ll call the Node that a state came from
    its parent. We will also define our Node class as having cost and heuristic properties,
    so we can reuse it later in the A* algorithm. Don’t worry about them for now.
    A Node is Comparable by comparing the combination of its cost and heuristic.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够实现DFS之前，我们还需要一个小技巧。我们需要一个Node类，我们将使用它来跟踪我们在搜索过程中从一个状态到另一个状态（或从一个位置到另一个位置）的路径。你可以将Node视为围绕状态的包装器。在我们的迷宫解决问题的关键中，这些状态是MazeLocation类型。我们将从该状态来的Node称为其父节点。我们还将定义我们的Node类具有成本和启发式属性，这样我们可以在A*算法中稍后重用它。现在不必担心它们。Node可以通过比较其成本和启发式值的组合来进行比较。
- en: Listing 2.16 GenericSearch.java continued
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.16 GenericSearch.java继续
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: TIP compareTo() here works by calling compareTo() on another type. This is a
    common pattern.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在这里，compareTo()通过在另一个类型上调用compareTo()来实现。这是一个常见的模式。
- en: NoTe If a Node does not have a parent, we will use null as a sentinel to indicate
    such.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果一个节点没有父节点，我们将使用null作为哨兵来表示这种情况。
- en: 'An in-progress depth-first search needs to keep track of two data structures:
    the stack of states (or “places”) that we are considering searching, which we
    will call the frontier, and the set of states that we have already searched, which
    we will call explored. As long as there are more states to visit in the frontier,
    DFS will keep checking whether they are the goal (if a state is the goal, DFS
    will stop and return it) and adding their successors to the frontier. It will
    also mark each state that has already been searched as explored, so that the search
    does not get caught in a circle, reaching states that have prior visited states
    as successors. If the frontier is empty, it means there is nowhere left to search.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 进行中的深度优先搜索需要跟踪两种数据结构：我们正在考虑搜索的状态（或“位置”）的栈，我们将其称为前沿，以及我们已经搜索过的状态的集合，我们将其称为已探索。只要前沿中还有更多要访问的状态，DFS将继续检查它们是否是目标（如果状态是目标，DFS将停止并返回它），并将它们的后续状态添加到前沿。它还将标记每个已经搜索过的状态为已探索，这样搜索就不会陷入循环，达到有先前访问状态作为后续状态的状态。如果前沿为空，这意味着没有其他地方可以搜索。
- en: Listing 2.17 GenericSearch.java continued
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.17 GenericSearch.java继续
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note the goalTest and successors function references. These allow different
    functions to be plugged into dfs() for different applications. This makes dfs()
    usable by more scenarios than just mazes. This is another example of solving a
    problem generically. A goalTest, being a Predicate<T>, is any function that takes
    a T (in our case, a MazeLocation) and returns a boolean. successors is any function
    that takes a T and returns a List of T.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意目标测试和后继函数引用。这些允许将不同的函数插入 dfs() 以适应不同的应用。这使得 dfs() 可以用于比迷宫更多的场景。这是解决问题通用性的另一个例子。目标测试是一个
    Predicate<T>，它是一个接受 T（在我们的情况下，是一个 MazeLocation）并返回布尔值的函数。后继是一个接受 T 并返回 T 的列表的函数。
- en: If dfs() is successful, it returns the Node encapsulating the goal state. The
    path from the start to the goal can be reconstructed by working backward from
    this Node and its priors using the parent property.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 dfs() 成功，它将返回封装目标状态的节点。可以通过从这个节点及其父节点使用父属性反向工作来重建从起点到目标的路径。
- en: Listing 2.18 GenericSearch.java continued
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.18 GenericSearch.java 继续部分
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For display purposes, it will be useful to mark up the maze with the successful
    path, the start state, and the goal state. It will also be useful to be able to
    remove a path so that we can try different search algorithms on the same maze.
    The following two methods should be added to the Maze class in Maze.java.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示目的，用成功路径、起始状态和目标状态标记迷宫将是有用的。同时，能够移除路径以便我们可以尝试不同的搜索算法在同一个迷宫上也是很有用的。以下两个方法应该添加到
    Maze.java 中的 Maze 类中。
- en: Listing 2.19 Maze.java continued
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.19 Maze.java 继续部分
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It has been a long journey, but we are finally ready to solve the maze.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是一次漫长的旅程，但我们终于准备好解决迷宫了。
- en: Listing 2.20 Maze.java continued
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.20 Maze.java 继续部分
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A successful solution will look something like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个成功的解决方案看起来可能像这样：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The asterisks represent the path that our depth-first search function found
    from the start to the goal. S is the start location and G is the goal location.
    Remember, because each maze is randomly generated, not every maze has a solution.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 星号代表从起点到目标我们深度优先搜索函数找到的路径。S 是起点位置，G 是目标位置。记住，因为每个迷宫都是随机生成的，并不是每个迷宫都有解。
- en: 2.2.4 Breadth-first search
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.4 广度优先搜索
- en: You may notice that the solution paths to the mazes found by depth-first traversal
    seem unnatural. They are usually not the shortest paths. Breadth-first search
    (BFS) always finds the shortest path by systematically looking one layer of nodes
    farther away from the start state in each iteration of the search. There are particular
    problems in which a depth-first search is likely to find a solution more quickly
    than a breadth-first search, and vice versa. Therefore, choosing between the two
    is sometimes a trade-off between the possibility of finding a solution quickly
    and the certainty of finding the shortest path to the goal (if one exists). Figure
    2.5 illustrates an in-progress breadth-first search of a maze.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，深度优先遍历找到的迷宫的解决方案路径看起来不太自然。它们通常不是最短路径。广度优先搜索（BFS）通过在搜索的每次迭代中系统地查找离起始状态更远的一层节点，总是找到最短路径。在某些特定的问题中，深度优先搜索可能比广度优先搜索更快地找到解决方案，反之亦然。因此，在这两者之间进行选择有时是在快速找到解决方案的可能性和找到到目标的最短路径的确定性（如果存在的话）之间的一种权衡。图
    2.5 展示了一个迷宫的广度优先搜索过程。
- en: '![2-5](../Images/2-5.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![2-5](../Images/2-5.png)'
- en: Figure 2.5 In a breadth-first search, the closest elements to the starting location
    are searched first.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 在广度优先搜索中，首先搜索离起始位置最近的元素。
- en: To understand why a depth-first search sometimes returns a result faster than
    a breadth-first search, imagine looking for a marking on a particular layer of
    an onion. A searcher using a depth-first strategy may plunge a knife into the
    center of the onion and haphazardly examine the chunks cut out. If the marked
    layer happens to be near the chunk cut out, there is a chance that the searcher
    will find it more quickly than another searcher using a breadth-first strategy,
    who painstakingly peels the onion one layer at a time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么深度优先搜索有时比广度优先搜索更快地返回结果，想象一下在一个洋葱的特定层上寻找标记。使用深度优先策略的搜索者可能会将刀子插入洋葱的中心，并随意检查切出的块。如果标记层恰好靠近切出的块，那么搜索者可能会比使用广度优先策略的搜索者更快地找到它，后者痛苦地一层层剥洋葱。
- en: To get a better picture of why breadth-first search always finds the shortest
    solution path where one exists, consider trying to find the path with the fewest
    number of stops between Boston and New York by train. If you keep going in the
    same direction and backtracking when you hit a dead end (as in depth-first search),
    you may first find a route all the way to Seattle before it connects back to New
    York. However, in a breadth-first search, you will first check all of the stations
    one stop away from Boston. Then you will check all of the stations two stops away
    from Boston. Then you will check all of the stations three stops away from Boston.
    This will keep going until you find New York. Therefore, when you do find New
    York, you will know you have found the route with the fewest stops, because you
    already checked all of the stations that are fewer stops away from Boston, and
    none of them was New York.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解为什么广度优先搜索总是能在存在的情况下找到最短解路径，可以考虑尝试通过火车在波士顿和纽约之间找到停站次数最少的路径。如果你一直朝同一个方向前进，并在遇到死胡同时回溯（就像深度优先搜索那样），你可能会首先找到一个直达西雅图的路线，然后再连接回纽约。然而，在广度优先搜索中，你首先会检查所有距离波士顿一站的车站。然后你会检查所有距离波士顿两站的车站。然后你会检查所有距离波士顿三站的车站。这个过程会一直持续到找到纽约。因此，当你找到纽约时，你会知道你已经找到了停站次数最少的路线，因为你已经检查了所有比波士顿更少的站点的车站，而纽约不在其中。
- en: Queues
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 队列
- en: To implement BFS, a data structure known as a queue is required. Whereas a stack
    is LIFO, a queue is FIFO (First-In-First-Out). A queue is like a line to use a
    restroom. The first person who got in line goes to the restroom first. At a minimum,
    a queue has the same push() and pop() methods as a stack. At an implementation
    level, the only thing that changes between a stack and a queue is that the queue
    removes items from the list at the opposite end from where it inserts them. This
    ensures that the oldest elements (the elements “waiting” the longest) are always
    removed first.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现广度优先搜索，需要一个称为队列的数据结构。与栈是后进先出（LIFO）不同，队列是先进先出（FIFO）。队列就像一个上厕所的队伍。第一个排队的人先上厕所。至少，队列具有与栈相同的
    push() 和 pop() 方法。在实现层面，栈和队列之间唯一不同的是，队列从与插入相反的一端从列表中移除项目。这确保了最老的元素（等待时间最长的元素）总是首先被移除。
- en: NOTE Confusingly, the Java standard library does not have a Queue class, although
    it does have a Stack class. Instead it has a Queue interface that several Java
    standard library classes implement (including LinkedList). Even more confusingly,
    in the Java standard library’s Queue interface, push() is called offer() and pop()
    is called poll().
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：令人困惑的是，Java 标准库没有 Queue 类，尽管它有一个 Stack 类。相反，它有一个 Queue 接口，该接口由几个 Java 标准库类实现（包括
    LinkedList）。更令人困惑的是，在 Java 标准库的 Queue 接口中，push() 被称为 offer()，而 pop() 被称为 poll()。
- en: The BFS algorithm
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索算法
- en: Amazingly, the algorithm for a breadth-first search is identical to the algorithm
    for a depth-first search, with the frontier changed from a stack to a queue. Changing
    the frontier from a stack to a queue changes the order in which states are searched
    and ensures that the states closest to the start state are searched first.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，广度优先搜索的算法与深度优先搜索的算法相同，只是前沿从栈改为队列。将前沿从栈改为队列改变了搜索状态顺序，并确保首先搜索距离起始状态最近的州。
- en: In the following implementation, we also have to change some calls from push()
    and pop() to offer() and poll(), respectively, because of the different naming
    schemes between the Java standard library’s Stack class and Queue interface (see
    the previous note). But do take a moment to look back at dfs() (in listing 2.17)
    and admire how similar dfs() and bfs() are to one another, with just the frontier
    data structure changing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下实现中，我们也必须将一些从 push() 和 pop() 到 offer() 和 poll() 的调用进行更改，因为 Java 标准库的 Stack
    类和 Queue 接口之间的命名方案不同（参见前面的说明）。但请花一点时间回顾一下 dfs()（在列表 2.17 中）并欣赏 dfs() 和 bfs() 之间的相似性，只是前沿数据结构发生了变化。
- en: Listing 2.21 GenericSearch.java continued
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.21 GenericSearch.java 继续内容
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you try running bfs(), you will see that it always finds the shortest solution
    to the maze in question. The main() method in Maze.java can now be modified to
    try two different ways of solving the same maze, so results can be compared.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试运行 bfs()，你会看到它总是找到迷宫问题的最短解。现在 Maze.java 中的 main() 方法可以修改为尝试解决同一迷宫的两种不同方法，以便进行比较。
- en: Listing 2.22 Maze.java continued
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.22 Maze.java 继续内容
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It is amazing that you can keep an algorithm the same and just change the data
    structure that it accesses and get radically different results. The following
    is the result of calling bfs() on the same maze that we earlier called dfs() on.
    Notice how the path marked by the asterisks is more direct from start to goal
    than in the prior example.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 真是令人惊讶，你可以在保持算法不变的情况下，仅仅改变它访问的数据结构，就能得到截然不同的结果。以下是在我们之前用dfs()调用的相同迷宫上调用bfs()的结果。注意，用星号标记的路径比先前的例子中从起点到目标更直接。
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 2.2.5 A* search
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.5 A*搜索
- en: It can be very time-consuming to peel back an onion, layer by layer, as a breadth-first
    search does. Like a BFS, an A* search aims to find the shortest path from start
    state to goal state. But unlike the preceding BFS implementation, an A* search
    uses a combination of a cost function and a heuristic function to focus its search
    on pathways most likely to get to the goal quickly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 逐层剥洋葱，就像广度优先搜索那样，可能会非常耗时。与BFS一样，A*搜索旨在找到从起始状态到目标状态的最短路径。但与先前的BFS实现不同，A*搜索使用成本函数和启发式函数的组合来集中搜索最有可能快速到达目标路径。
- en: The cost function, g(n), examines the cost to get to a particular state. In
    the case of our maze, this would be how many previous cells we had to go through
    to get to the cell in question. The heuristic function, h(n), gives an estimate
    of the cost to get from the state in question to the goal state. It can be proved
    that if h(n) is an admissible heuristic, the final path found will be optimal.
    An admissible heuristic is one that never overestimates the cost to reach the
    goal. On a two-dimensional plane, one example is a straight-line distance heuristic,
    because a straight line is always the shortest path.[1](#pgfId-1153170)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 成本函数g(n)检查到达特定状态的成本。在我们的迷宫案例中，这将是到达所讨论单元格之前我们需要通过多少个单元格。启发式函数h(n)给出了从所讨论状态到目标状态的成本估计。可以证明，如果h(n)是可接受的启发式方法，那么找到的最终路径将是最优的。可接受的启发式方法是那种永远不会高估到达目标成本的方法。在二维平面上，一个例子是直线距离启发式方法，因为直线总是最短路径。[1](#pgfId-1153170)
- en: The total cost for any state being considered is f(n), which is simply the combination
    of g(n) and h(n). In fact, f(n) = g(n) + h(n). When choosing the next state to
    explore from the frontier, an A* search picks the one with the lowest f(n). This
    is how it distinguishes itself from BFS and DFS.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑任何状态的总成本是f(n)，这仅仅是g(n)和h(n)的组合。实际上，f(n) = g(n) + h(n)。在从边界中选择下一个要探索的状态时，A*搜索会选择具有最低f(n)的那个。这就是它与BFS和DFS的区别。
- en: Priority queues
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列
- en: To pick the state on the frontier with the lowest f(n), an A* search uses a
    priority queue as the data structure for its frontier. A priority queue keeps
    its elements in an internal order, such that the first element popped out is always
    the highest-priority element. (In our case, the highest-priority item is the one
    with the lowest f(n).) Usually this means the internal use of a binary heap, which
    results in O(lg n) pushes and O(lg n) pops.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择具有最低f(n)的前沿状态，A*搜索使用优先队列作为其前沿的数据结构。优先队列保持其元素在一个内部顺序中，使得第一个弹出的元素总是最高优先级的元素。（在我们的情况下，最高优先级的项是具有最低f(n)的项。）通常这意味着内部使用二叉堆，这导致O(lg
    n)的推入和O(lg n)的弹出操作。
- en: Java’s standard library contains the PriorityQueue class, which has the same
    offer() and poll() methods as the Queue interface. Anything put into a PriorityQueue
    must be Comparable. To determine the priority of a particular element versus another
    of its kind, PriorityQueue compares them by using the compareTo() method. This
    is why we needed to implement it earlier. One Node is compared to another by looking
    at its respective f(n), which is simply the sum of the properties cost and heuristic.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Java的标准库包含PriorityQueue类，它具有与Queue接口相同的offer()和poll()方法。任何放入PriorityQueue中的内容都必须是Comparable的。为了确定特定元素与其同类元素之间的优先级，PriorityQueue通过使用compareTo()方法来比较它们。这就是为什么我们之前需要实现它的原因。一个节点通过查看其各自的f(n)来与另一个节点进行比较，f(n)仅仅是成本和启发式属性的总和。
- en: Heuristics
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 启发式方法
- en: A heuristic is an intuition about the way to solve a problem.[2](#pgfId-1153205)
    In the case of maze solving, a heuristic aims to choose the best maze location
    to search next in the quest to get to the goal. In other words, it is an educated
    guess about which nodes on the frontier are closest to the goal. As was mentioned
    previously, if a heuristic used with an A* search produces an accurate relative
    result and is admissible (never overestimates the distance), then A* will deliver
    the shortest path. Heuristics that calculate smaller values end up leading to
    a search through more states, whereas heuristics closer to the exact real distance
    (but not over it, which would make them inadmissible) lead to a search through
    fewer states. Therefore, ideal heuristics come as close to the real distance as
    possible without ever going over it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 启发式是一种关于解决问题方式的本能。[2](#pgfId-1153205) 在解决迷宫问题时，启发式旨在选择下一个要搜索的最佳迷宫位置，以到达目标。换句话说，它是对前沿节点中哪些节点最接近目标的理性猜测。正如之前提到的，如果与
    A* 搜索一起使用的启发式能够产生准确的相对结果并且是可接受的（永远不会高估距离），那么 A* 将提供最短路径。计算较小值的启发式最终会导致搜索更多状态，而接近实际真实距离（但不能超过它，这会使它们不可接受）的启发式会导致搜索较少的状态。因此，理想的启发式应该尽可能接近真实距离，但永远不要超过它。
- en: Euclidean distance
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得距离
- en: As we learn in geometry, the shortest path between two points is a straight
    line. It makes sense, then, that a straight-line heuristic will always be admissible
    for the maze-solving problem. The Euclidean distance, derived from the Pythagorean
    theorem, states that distance = √((difference in x)2 + (difference in y)2). For
    our mazes, the difference in x is equivalent to the difference in columns between
    two maze locations, and the difference in y is equivalent to the difference in
    rows. Note that we are implementing this back in Maze.java.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在几何学中学到的，两点之间的最短路径是一条直线。因此，对于迷宫解决问题，直线启发式始终是可接受的。欧几里得距离，根据勾股定理得出，表示距离 =
    √((x 差异)² + (y 差异)²)。对于我们的迷宫，x 差异相当于两个迷宫位置之间的列差异，y 差异相当于行差异。请注意，我们实际上是在 Maze.java
    中实现这个功能的。
- en: Listing 2.23 Maze.java continued
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.23 Maze.java 继续显示
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: euclideanDistance() is a function that takes a maze location and returns its
    straight-line distance to the goal. This function “knows” the goal, because it
    is actually a method on Maze, and Maze has goal as an instance variable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: euclideanDistance() 是一个函数，它接受一个迷宫位置并返回其到目标的直线距离。这个函数“知道”目标，因为它实际上是 Maze 的一个方法，而
    Maze 有一个作为实例变量的目标。
- en: Figure 2.6 illustrates Euclidean distance within the context of a grid, like
    the streets of Manhattan.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 在网格的背景下说明了欧几里得距离，就像曼哈顿的街道一样。
- en: '![2-6](../Images/2-6.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![2-6](../Images/2-6.png)'
- en: Figure 2.6 Euclidean distance is the length of a straight line from the starting
    point to the goal.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 欧几里得距离是从起点到目标的直线长度。
- en: Manhattan distance
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 曼哈顿距离
- en: Euclidean distance is great, but for our particular problem (a maze in which
    you can move only in one of four directions) we can do even better. The Manhattan
    distance is derived from navigating the streets of Manhattan, the most famous
    of New York City’s boroughs, which is laid out in a grid pattern. To get from
    anywhere to anywhere in Manhattan, one needs to walk a certain number of horizontal
    blocks and a certain number of vertical blocks. (There are almost no diagonal
    streets in Manhattan.) The Manhattan distance is derived by simply finding the
    difference in rows between two maze locations and summing it with the difference
    in columns. Figure 2.7 illustrates Manhattan distance.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得距离很好，但针对我们特定的问题（一个只能沿四个方向移动的迷宫），我们可以做得更好。曼哈顿距离是从曼哈顿街道得出的，这是纽约市最著名的行政区之一，其布局呈网格状。要从任何地方走到曼哈顿的任何地方，需要走一定数量的水平街区和一个垂直街区。（曼哈顿几乎没有对角线街道。）曼哈顿距离是通过简单地找到两个迷宫位置之间的行差异并将其与列差异相加得到的。图
    2.7 阐述了曼哈顿距离。
- en: Listing 2.24 Maze.java continued
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.24 Maze.java 继续显示
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Because this heuristic more accurately follows the actuality of navigating our
    mazes (moving vertically and horizontally instead of in diagonal straight lines),
    it comes closer to the actual distance between any maze location and the goal
    than Euclidean distance does. Therefore, when an A* search is coupled with Manhattan
    distance, it will result in searching through fewer states than when an A* search
    is coupled with Euclidean distance for our mazes. Solution paths will still be
    optimal, because Manhattan distance is admissible (never overestimates distance)
    for mazes in which only four directions of movement are allowed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个启发式更准确地遵循我们在迷宫中导航的实际性（垂直和水平移动而不是对角线直线），它比欧几里得距离更接近任何迷宫位置和目标之间的实际距离。因此，当A*搜索与曼哈顿距离结合时，它将比A*搜索与欧几里得距离结合时的搜索状态更少。解决方案路径仍然是最优的，因为曼哈顿距离对于只允许四个方向移动的迷宫是可接受的（不会高估距离）。
- en: '![2-7](../Images/2-7.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![2-7](../Images/2-7.png)'
- en: Figure 2.7 In Manhattan distance, there are no diagonals. The path must be along
    parallel or perpendicular lines.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 在曼哈顿距离中，没有对角线。路径必须沿着平行或垂直的线。
- en: The A* algorithm
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: A*算法
- en: To go from BFS to A* search, we need to make several small modifications. The
    first is changing the frontier from a queue to a priority queue. This way, the
    frontier will pop nodes with the lowest f(n). The second is changing the explored
    set to a HashMap. A HashMap will allow us to keep track of the lowest cost (g(n))
    of each node we may visit. With the heuristic function now in play, it is possible
    some nodes may be visited twice if the heuristic is inconsistent. If the node
    found through the new direction has a lower cost to get to than the prior time
    we visited it, we will prefer the new route.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要从BFS转换为A*搜索，我们需要进行几个小的修改。第一个是将边界从队列更改为优先队列。这样，边界将弹出具有最低f(n)值的节点。第二个是将已探索集更改为HashMap。HashMap将允许我们跟踪我们可能访问的每个节点的最低成本（g(n)）。由于现在启发性函数正在发挥作用，如果启发式函数不一致，某些节点可能会被访问两次。如果通过新方向找到的节点到达的成本比我们上次访问它时更低，我们将选择新的路线。
- en: For the sake of simplicity, the method astar() does not take a cost-calculation
    function as a parameter. Instead, we just consider every hop in our maze to be
    a cost of 1\. Each new Node gets assigned a cost based on this simple formula,
    as well as a heuristic score using a new function passed as a parameter to the
    search function, called heuristic. Other than these changes, astar() is remarkably
    similar to bfs(). Examine them side by side for comparison.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，astar()方法不将成本计算函数作为参数。相反，我们只是将迷宫中的每一步视为成本1。每个新的节点都会根据这个简单的公式分配一个成本，以及使用传递给搜索函数的新函数计算出的启发式分数，该函数称为启发式。除了这些变化之外，astar()与bfs()非常相似。为了比较，请将它们并排查看。
- en: Listing 2.25 GenericSearch.java continued
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.25 GenericSearch.java继续
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Congratulations. If you have followed along this far, you have learned not only
    how to solve a maze, but also some generic search functions that you can use in
    many different search applications. DFS and BFS are suitable for many smaller
    data sets and state spaces where performance is not critical. In some situations,
    DFS will outperform BFS, but BFS has the advantage of always delivering an optimal
    path. Interestingly, BFS and DFS have identical implementations, only differentiated
    by the use of a queue instead of a stack for the frontier. The slightly more complicated
    A* search, coupled with a good, consistent, admissible heuristic, not only delivers
    optimal paths, but also far outperforms BFS. And because all three of these functions
    were implemented generically, using them on nearly any search space is just an
    import away.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜。如果你一直跟到这里，你已经不仅学会了如何解决迷宫，还学到了一些通用的搜索函数，你可以在许多不同的搜索应用中使用。DFS和BFS适用于许多较小的数据集和状态空间，其中性能不是关键。在某些情况下，DFS可能会优于BFS，但BFS的优势是始终提供最优路径。有趣的是，BFS和DFS具有相同的实现，只是通过使用队列而不是栈来区分边界。稍微复杂一点的A*搜索，结合一个好的、一致的、可接受的启发式函数，不仅提供最优路径，而且远优于BFS。而且因为这三个函数都是通用实现的，所以使用它们在几乎任何搜索空间中只需一个导入即可。
- en: Go ahead and try out astar() with the same maze in Maze.java’s testing section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在Maze.java的测试部分尝试使用相同的迷宫运行astar()。
- en: Listing 2.26 Maze.java continued
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.26 Maze.java继续
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The output will interestingly be a little different from bfs(), even though
    both bfs() and astar() are finding optimal paths (equivalent in length). If it
    uses a Manhattan distance heuristic, astar() immediately drives through a diagonal
    toward the goal. It will ultimately search fewer states than bfs(), resulting
    in better performance. Add a state count to each if you want to prove this to
    yourself.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将会有趣地与bfs()略有不同，尽管bfs()和astar()都在寻找最优路径（长度等效）。如果它使用曼哈顿距离启发式，astar()会立即通过对角线向目标方向行驶。它最终将搜索比bfs()更少的州，从而获得更好的性能。如果您想证明这一点，可以在每个函数中添加一个状态计数。
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 2.3 Missionaries and cannibals
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 传教士和食人族
- en: Three missionaries and three cannibals are on the west bank of a river. They
    have a canoe that can hold two people, and they all must cross to the east bank
    of the river. There may never be more cannibals than missionaries on either side
    of the river, or the cannibals will eat the missionaries. Further, the canoe must
    have at least one person on board to cross the river. What sequence of crossings
    will successfully take the entire party across the river? Figure 2.8 illustrates
    the problem.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 三个传教士和三个食人族人在河的西岸。他们有一只可以载两个人的独木舟，他们所有人都必须过河到东岸。在任何一边，食人族人数都不能超过传教士人数，否则食人族会吃掉传教士。此外，独木舟过河时必须至少有一个人在船上。什么过河顺序能成功地将所有人带到河对岸？图2.8展示了这个问题。
- en: '![2-8](../Images/2-8.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![2-8](../Images/2-8.png)'
- en: Figure 2.8 The missionaries and cannibals must use their single canoe to take
    everyone across the river from west to east. If the cannibals ever outnumber the
    missionaries, they will eat them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 传教士和食人族必须使用他们的独木舟将所有人从西岸运送到东岸。如果食人族人数超过传教士，他们就会吃掉他们。
- en: 2.3.1 Representing the problem
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 问题表示
- en: We will represent the problem by having a structure that keeps track of the
    west bank. How many missionaries and cannibals are on the west bank? Is the boat
    on the west bank? Once we have this knowledge, we can figure out what is on the
    east bank, because anything not on the west bank is on the east bank.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个结构来表示这个问题，这个结构会跟踪西岸的情况。西岸有多少传教士和食人族人？独木舟在西岸吗？一旦我们有了这些知识，我们就可以推断出东岸有什么，因为不在西岸的任何东西都在东岸。
- en: First, we will create a little convenience variable for keeping track of the
    maximum number of missionaries or cannibals. Then we will define the main class.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个便利变量来跟踪传教士或食人族的最大数量。然后我们将定义主类。
- en: Listing 2.27 Missionaries.java
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.27 Missionaries.java
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The class MCState initializes itself based on the number of missionaries and
    cannibals on the west bank as well as the location of the boat. It also knows
    how to pretty-print itself, which will be valuable later when displaying the solution
    to the problem.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: MCState类根据西岸的传教士和食人族人数以及独木舟的位置初始化自己。它还知道如何以美观的方式打印自己，这在稍后显示问题的解决方案时将非常有价值。
- en: Working within the confines of our existing search functions means that we must
    define a function for testing whether a state is the goal state and a function
    for finding the successors from any state. The goal test function, as in the maze-solving
    problem, is quite simple. The goal is simply reaching a legal state that has all
    of the missionaries and cannibals on the east bank. We add it as a method to MCState.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们现有的搜索函数限制下工作意味着我们必须定义一个函数来测试一个状态是否是目标状态，以及一个函数来从任何状态找到后续状态。目标测试函数，就像在迷宫求解问题中一样，非常简单。目标就是简单地到达一个合法状态，其中所有传教士和食人族都在东岸。我们将它作为一个方法添加到MCState中。
- en: Listing 2.28 Missionaries.java continued
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.28 Missionaries.java继续
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To create a successors function, it is necessary to go through all of the possible
    moves that can be made from one bank to another and then check if each of those
    moves will result in a legal state. Recall that a legal state is one in which
    cannibals do not outnumber missionaries on either bank. To determine this, we
    can define a convenience method on MCState that checks if a state is legal.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个后续状态函数，必须遍历从一边到另一边可以做出的所有可能的移动，然后检查这些移动中的每一个是否会导致一个合法状态。回想一下，合法状态是指任何一边的食人族人数都不超过传教士人数的状态。为了确定这一点，我们可以在MCState上定义一个便利方法来检查状态是否合法。
- en: Listing 2.29 Missionaries.java continued
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.29 Missionaries.java继续
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The actual successors function is a bit verbose, for the sake of clarity. It
    tries adding every possible combination of one or two people moving across the
    river from the bank where the canoe currently resides. Once it has added all possible
    moves, it filters for the ones that are actually legal via removeIf() on a temporary
    List of potential states and a negated Predicate that checks isLegal(). Predicate.not()
    was added in Java 11\. Once again, this is a method on MCState.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的后继函数有点冗长，但为了清晰起见。它尝试添加从独木舟所在的河岸出发的每个人或两个人的所有可能的组合移动。一旦添加了所有可能的移动，它将通过 `removeIf()`
    在一个临时的潜在状态列表和一个检查 `isLegal()` 的否定谓词来过滤出实际合法的移动。`Predicate.not()` 是在 Java 11 中添加的。再次强调，这是一个
    `MCState` 上的方法。
- en: Listing 2.30 Missionaries.java continued
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.30 `Missionaries.java` 继续列出
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 2.3.2 Solving
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 解决方案
- en: We now have all of the ingredients in place to solve the problem. Recall that
    when we solve a problem using the search functions bfs(), dfs(), and astar(),
    we get back a Node that ultimately we convert using nodeToPath() into a list of
    states that leads to a solution. What we still need is a way to convert that list
    into a comprehensible printed sequence of steps to solve the missionaries and
    cannibals problem.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经具备了解决问题的所有要素。回想一下，当我们使用 `bfs()`、`dfs()` 和 `astar()` 搜索函数解决问题时，我们得到一个节点，我们最终使用
    `nodeToPath()` 将其转换为导致解决方案的状态列表。我们仍然需要一种方法将列表转换为可理解的打印步骤序列，以解决传教士和野人问题。
- en: The function displaySolution() converts a solution path into printed output--a
    human-readable solution to the problem. It works by iterating through all of the
    states in the solution path while keeping track of the last state as well. It
    looks at the difference between the last state and the state it is currently iterating
    on to find out how many missionaries and cannibals moved across the river and
    in which direction.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `displaySolution()` 将解决方案路径转换为打印输出——即人类可读的解决方案。它通过遍历解决方案路径中的所有状态，同时跟踪最后一个状态来实现。它查看最后一个状态和当前遍历的状态之间的差异，以找出有多少传教士和野人横渡了河流以及方向。
- en: Listing 2.31 Missionaries.java continued
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.31 `Missionaries.java` 继续列出
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The displaySolution() method takes advantage of the fact that MCState knows
    how to pretty-print a nice summary of itself via toString().
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`displaySolution()` 方法利用了 `MCState` 知道如何通过 `toString()` 方法打印出自身的一个漂亮的总结的事实。'
- en: The last thing we need to do is actually solve the missionaries and cannibals
    problem. To do so we can conveniently reuse a search function that we have already
    implemented, because we implemented them generically. This solution uses bfs().
    To work properly with the search functions, recall that the explored data structure
    needs states to be easily compared for equality. So here again we let Eclipse
    autogenerate hashCode() and equals() before solving the problem in main().
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的事情就是实际解决传教士和野人问题。为此，我们可以方便地重用我们已经实现的一个搜索函数，因为我们以通用方式实现了它们。这个解决方案使用了
    `bfs()`。为了与搜索函数正确地工作，回想一下，探索的数据结构需要状态能够轻松地进行相等性比较。因此，在 `main()` 中解决问题之前，我们再次让
    Eclipse 自动生成 `hashCode()` 和 `equals()`。
- en: Listing 2.32 Missionaries.java continued
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.32 `Missionaries.java` 继续列出
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It is great to see how flexible our generic search functions can be. They can
    easily be adapted for solving a diverse set of problems. You should see output
    that looks similar to the following (abridged):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 看到我们的通用搜索函数是多么灵活真是太好了。它们可以轻松地适应解决各种问题。你应该看到类似以下内容的输出（摘要）：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 2.4 Real-world applications
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 现实世界应用
- en: Search plays some role in all useful software. In some cases, it is the central
    element (Google Search, Spotlight, Lucene); in others, it is the basis for using
    the structures that underlie data storage. Knowing the correct search algorithm
    to apply to a data structure is essential for performance. For example, it would
    be very costly to use linear search, instead of binary search, on a sorted data
    structure.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索在所有有用的软件中都扮演着一定的角色。在某些情况下，它是核心元素（如 Google 搜索、Spotlight、Lucene）；在其他情况下，它是使用底层数据存储结构的基础。知道将哪种搜索算法应用于数据结构对于性能至关重要。例如，在排序数据结构上使用线性搜索而不是二分搜索将非常昂贵。
- en: A* is one of the most widely deployed pathfinding algorithms. It is only beaten
    by algorithms that do precalculation in the search space. For a blind search,
    A* is yet to be reliably beaten in all scenarios, and this has made it an essential
    component of everything from route planning to figuring out the shortest way to
    parse a programming language. Most directions-providing map software (think Google
    Maps) uses Dijkstra’s algorithm (which A* is a variant of) to navigate. (There
    is more about Dijkstra’s algorithm in chapter 4.) Whenever an AI character in
    a game is finding the shortest path from one end of the world to the other without
    human intervention, it is probably using A*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: A*是最广泛部署的路径查找算法之一。它只被那些在搜索空间中进行预计算的算法所击败。对于盲搜索，A*在所有场景中尚未被可靠地击败，这使得它成为从路线规划到解析编程语言最短路径的必要组成部分。大多数提供方向性地图软件（例如Google
    Maps）使用Dijkstra算法（A*是其变体）进行导航。（关于Dijkstra算法的更多信息请见第4章。）当游戏中的AI角色在没有人类干预的情况下从世界的这一端找到另一端的最短路径时，它很可能正在使用A*。
- en: Breadth-first search and depth-first search are often the basis for more complex
    search algorithms like uniform-cost search and backtracking search (which you
    will see in the next chapter). Breadth-first search is often a sufficient technique
    for finding the shortest path in a fairly small graph. But due to its similarity
    to A*, it is easy to swap out for A* if a good heuristic exists for a larger graph.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索和深度优先搜索通常是更复杂搜索算法（如一致代价搜索和回溯搜索，你将在下一章中看到）的基础。广度优先搜索通常在相当小的图中找到最短路径是足够的技术。但由于它与A*的相似性，如果存在一个好的启发式方法，则很容易将其替换为A*。
- en: 2.5 Exercises
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 练习
- en: Show the performance advantage of binary search over linear search by creating
    a list of one million numbers and timing how long it takes the generic linearContains()
    and binaryContains() defined in this chapter to find various numbers in the list.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个包含一百万个数字的列表，并计时本章中定义的通用线性查找函数linearContains()和二分查找函数binaryContains()查找列表中各种数字所需的时间，来展示二分查找相对于线性查找的性能优势。
- en: Add a counter to dfs(), bfs(), and astar() to see how many states each searches
    through for the same maze. Find the counts for 100 different mazes to get statistically
    significant results.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在dfs()、bfs()和astar()函数中添加一个计数器，以查看每个函数在相同迷宫中搜索了多少个状态。找到100个不同迷宫的计数，以获得具有统计意义的成果。
- en: Find a solution to the missionaries and cannibals problem for a different number
    of starting missionaries and cannibals.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到不同起始传教士和食人族数量的传教士和食人族问题的解决方案。
- en: '* * *'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '1. For more information on heuristics, see Stuart Russell and Peter Norvig,
    Artificial Intelligence: A Modern Approach, 3rd edition (Pearson, 2010), p. 94.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 关于启发式方法的更多信息，请参阅Stuart Russell和Peter Norvig的《人工智能：现代方法》第3版（Pearson，2010），第94页。
- en: 2. For more about heuristics for A* pathfinding, check out the “Heuristics”
    chapter in Amit Patel’s Amit’s Thoughts on Pathfinding, http://mng.bz/z7O4.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 关于A*路径查找的启发式方法，请参阅Amit Patel的《Amit关于路径查找的思考》中的“启发式”章节，http://mng.bz/z7O4。
