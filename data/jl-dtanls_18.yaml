- en: Appendix B Solutions to exercises
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B 练习题解答
- en: '**Exercise 3.1**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习3.1**'
- en: Create an x variable that is a range of values from 1 to 10^6. Now, using the
    collect function, create a y vector holding the same values as the x range. Using
    the @btime macro, check the time of sorting x and y by using the sort function.
    Finally, using the @edit macro, check the implementation of the sort function
    that would be invoked when you sort the x range.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个x变量，它是从1到10^6的值范围。现在，使用collect函数，创建一个包含与x范围相同值的y向量。使用@btime宏，通过使用sort函数检查排序x和y的时间。最后，使用@edit宏，检查当你排序x范围时将被调用的sort函数的实现。
- en: '**Solution**'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Observe that sorting the x range is much faster than sorting the y vector.
    If you have a properly configured Julia environment (see appendix A for instructions),
    calling @edit sort(x) should take you to the editor and show you the following
    method definition:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到对x范围的排序比排序y向量要快得多。如果你有一个正确配置的Julia环境（参见附录A获取说明），调用@edit sort(x)应该带你到编辑器并显示以下方法定义：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Exercise 4.1**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习4.1**'
- en: Rewrite the expression [cor(aq[:, i], aq[:, i+1]) for i in 1:2:7] by using views
    (either the view function or the @view macro). Compare the performance of both
    approaches by using the @benchmark macro from the BenchmarkTools.jl package.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用视图（无论是视图函数还是@view宏）重写表达式[cor(aq[:, i], aq[:, i+1]) for i in 1:2:7]。通过使用BenchmarkTools.jl包中的@benchmark宏来比较两种方法的性能。
- en: '**Solution**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We now run the first benchmark:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在运行第一个基准测试：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It produces the following output:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 它会产生以下输出：
- en: '![APPB_UN01_Kaminski2](../Images/APPB_UN01_Kaminski2.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![APPB_UN01_Kaminski2](../Images/APPB_UN01_Kaminski2.png)'
- en: 'Now run the second benchmark:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行第二个基准测试：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This time the execution is faster, as you can see in the following output:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这次执行更快，如以下输出所示：
- en: '![APPB_UN02_Kaminski2](../Images/APPB_UN02_Kaminski2.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![APPB_UN02_Kaminski2](../Images/APPB_UN02_Kaminski2.png)'
- en: The results of the benchmarks show that using views almost halved the execution
    time of the code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试的结果显示，使用视图几乎将代码的执行时间减半。
- en: 'If you wanted to use the @view macro, the code would be as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用@view宏，代码将是这样的：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the example code, note that we used the $ prefix in front of the aq variable
    to correctly pass it to the @benchmark macro (see chapter 2 for an explanation
    of this rule).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码中，注意我们在aq变量前使用了$前缀，以正确传递给@benchmark宏（参见第2章解释此规则）。
- en: '**Exercise 4.2**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习4.2**'
- en: Rewrite the code solving the Sicherman puzzle, wrapping the logic of the processing
    in functions. Create one function, dice_distribution, that produces a dictionary
    with a distribution of the sum of possible combinations of values on two dice
    passed as its arguments. Next, write another function, test_dice, in which you
    create the all_dice variable and the two_standard variable, and you finally run
    the main loop comparing the distribution of all dice from the all_dice vector
    against the two_standard distribution.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写解决Sicherman谜题的代码，将处理逻辑封装在函数中。创建一个函数，dice_distribution，它接受两个作为其参数的骰子值，并生成一个包含可能组合值的总和分布的字典。接下来，编写另一个函数，test_dice，在其中创建all_dice变量和two_standard变量，然后运行主循环，比较all_dice向量中所有骰子的分布与two_standard分布。
- en: '**Solution**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now you can test the solution by running the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过运行以下命令来测试解决方案：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Exercise 4.3**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习4.3**'
- en: Reproduce figure 4.6 using the data named tuple defined in listing 4.2.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在列表4.2中定义的命名元组的数据重现图4.6。
- en: '**Solution**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code reproduces figure 4.6.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码重现了图4.6。
- en: '**Exercise 5.1**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习5.1**'
- en: The parse function can be used to convert a string into a number. For instance,
    if you want to parse a string as an integer, write parse(Int, "10") to get the
    integer 10. Assume you are given a vector of strings ["1", "2", "3"]. Your task
    is to create a vector of integers by parsing the strings contained in the given
    vector.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 解析函数可以用来将字符串转换为数字。例如，如果你想将一个字符串解析为整数，写parse(Int, "10")以获取整数10。假设你被给了一个包含字符串["1",
    "2", "3"]的向量。你的任务是创建一个包含给定向量中字符串的整数的向量。
- en: '**Solution**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Exercise 5.2**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习5.2**'
- en: Repeat the analysis presented in section 5.3, but instead of adding and subtracting
    1 when creating data for clusters 1 and 2, add and subtract 0.4, respectively.
    This will reduce the separation between the two clusters in five-dimensional space.
    Check if this will reduce their separation in the two-dimensional space generated
    by t-SNE.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重复第5.3节中展示的分析，但在为1号和2号集群创建数据时，分别加上和减去0.4。这将减少五维空间中两个集群之间的距离。检查这是否会减少由t-SNE生成的二维空间中的距离。
- en: '**Solution**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**'
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Figure B.1 shows the result. We can see that the clusters are overlapping more
    than in figure 5.3.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图B.1显示了结果。我们可以看到，与图5.3相比，集群的重叠更多。
- en: '![APPB_F01_Kaminski2](../Images/APPB_F01_Kaminski2.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![APPB_F01_Kaminski2](../Images/APPB_F01_Kaminski2.png)'
- en: Figure B.1 In this result of the t-SNE embedding, the clusters, represented
    as points of different fill colors, are overlapping.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图B.1 在这个t-SNE嵌入的结果中，表示为不同填充颜色的点的集群是重叠的。
- en: '**Exercise 6.1**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习6.1**'
- en: Create a plot of the number of movies by year, using the years variable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用years变量创建按年份划分的电影数量图表。
- en: '**Solution**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**'
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Your result should look like the plot in figure B.2, on which we see a sharp
    increase of movies per year, except for the last year, for which data was likely
    not collected for the whole period.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您的结果应该看起来像图B.2中的图表，其中我们看到每年电影数量的急剧增加，除了最后一年，因为很可能在整个期间没有收集到数据。
- en: '![APPB_F02_Kaminski2](../Images/APPB_F02_Kaminski2.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![APPB_F02_Kaminski2](../Images/APPB_F02_Kaminski2.png)'
- en: Figure B.2 In this plot of the number of movies per year, observed values increase
    sharply over the years.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图B.2 在这个每年电影数量的图表中，观察值在多年内急剧增加。
- en: '**Exercise 6.2**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习6.2**'
- en: Using the s1 vector from listing 6.7, create the s3 vector consisting of symbols
    representing the same strings as those contained in the s1 vector. Next, benchmark
    how fast you can sort the s3 vector. Finally, benchmark how fast you can de-duplicate
    the s1, s2, and s3 vectors by using the unique function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表6.7中的s1向量，创建包含与s1向量中相同字符串的符号的s3向量。然后，基准测试您能够多快地对s3向量进行排序。最后，基准测试您能够多快地使用unique函数对s1、s2和s3向量进行去重。
- en: '**Solution**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**'
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Sorting Vector{Symbol} bound to s3 is a bit faster than sorting Vector{String}
    bound to s1, but is slower than sorting Vector{String3} bound to s2.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将s3绑定到Vector{Symbol}的排序比将s1绑定到Vector{String}的排序快一点，但比将s2绑定到Vector{String3}的排序慢。
- en: 'Now we test de-duplication:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们测试去重：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: De-duplicating Vector{String} is slowest, while for Vector{Symbol} and Vector{String3},
    the performance is similar. Working with Symbol values is fast because comparing
    symbols for equality is efficient, as explained in section 6.1.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: De-duplicating Vector{String}是最慢的，而对于Vector{Symbol}和Vector{String3}，性能相似。处理Symbol值很快，因为比较符号的相等性是高效的，如第6.1节所述。
- en: '**Exercise 7.1**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习7.1**'
- en: Given a vector v = ["1", "2", missing, "4"], parse it so that strings are converted
    to numbers and the missing value remains a missing value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 给定向量v = ["1", "2", missing, "4"]，将其解析为将字符串转换为数字，并将缺失值保留为缺失值。
- en: '**Solution**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**'
- en: 'I will show three ways to achieve the desired result. The first uses a comprehension,
    the second uses the map function, and the last employs the passmissing function
    and broadcasting:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示三种实现预期结果的方法。第一种使用列表推导，第二种使用map函数，最后使用passmissing函数和广播：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Exercise 7.2**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习7.2**'
- en: Create a vector containing the first day of each month in the year 2021.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含2021年每月第一天的向量。
- en: '**Solution**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**'
- en: 'I will show you two approaches for achieving the desired result. In the second
    one, we use a range, so I use the collect function to show you that the result
    is indeed as expected:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向您展示两种实现预期结果的方法。在第二种方法中，我们使用一个范围，因此我使用collect函数向您展示结果确实如预期：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that in the second case, Julia properly calculates the interval of one
    month, although different months have a different number of days. This is indeed
    the desired behavior.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第二种情况下，Julia正确地计算了一个月的时间间隔，尽管不同的月份天数不同。这确实是期望的行为。
- en: '**Exercise 7.3**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习7.3**'
- en: The NBP Web API allows you to get a sequence of rates for a period of dates.
    For example, the query "https://api.nbp.pl/api/exchangerates/rates/a/usd/2020-06-01/2020-06-30/?format=json"
    returns a sequence of rates from June 2020 for dates when the rate is present.
    In other words, dates for which there is no rate are skipped. Your task is to
    parse the result of this query and confirm that the obtained result is consistent
    with the data we collected in the dates and rates vectors.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: NBP Web API允许您获取一段时间内的汇率序列。例如，查询"https://api.nbp.pl/api/exchangerates/rates/a/usd/2020-06-01/2020-06-30/?format=json"返回了2020年6月有汇率的日期的汇率序列。换句话说，跳过了没有汇率的日期。您的任务是解析此查询的结果，并确认获得的结果与我们收集的dates和rates向量中的数据一致。
- en: '**Solution**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the solution, the json2 object in the :rates field contains a sequence of
    rates. Therefore, we extract them to the rates2 and dates2 vectors by using comprehensions.
    Next, we want to compare the rates2 and dates2 vectors to the rates and dates
    vectors for entries where the rates vector does not contain a missing value. To
    do this, we create the has_rate Boolean mask vector by broadcasting the !== comparison
    of the missing value against the rates vector.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，:rates字段中的json2对象包含一系列汇率。因此，我们通过使用列表推导式将它们提取到rates2和dates2向量中。接下来，我们想要比较rates2和dates2向量与rates和dates向量在那些rates向量不包含缺失值的条目中进行。为此，我们创建了一个has_rate布尔掩码向量，通过将缺失值与rates向量进行
    !== 比较进行广播。
- en: '**Exercise 8.1**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习8.1**'
- en: Using the BenchmarkTools.jl package, measure the performance of getting a column
    from a data frame by using the puzzles."Rating" syntax.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用BenchmarkTools.jl包，通过使用puzzles."Rating"语法来获取数据框中的列的性能进行测量。
- en: '**Solution**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As expected, the performance is a bit worse than for puzzles.Rating.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，性能略低于puzzles.Rating。
- en: '**Exercise 9.1**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习9.1**'
- en: Calculate summary statistics of the NbPlays column under two conditions. In
    the first, select only puzzles that have popularity equal to 100, and in the second,
    select puzzles that have popularity equal to -100\. To calculate the summary statistics
    of a vector, use the summarystats function from the StatsBase.jl package.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种条件下计算NbPlays列的摘要统计。在第一种情况下，仅选择流行度等于100的谜题，在第二种情况下，选择流行度等于-100的谜题。要计算向量的摘要统计，请使用StatsBase.jl包中的summarystats函数。
- en: '**Solution**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can see that the puzzles that have popularity equal to -100 are indeed played
    infrequently. However, for puzzles that have 100 popularity, this relationship
    is not that strong. As you may recall from the output produced by the code in
    listing 8.2, the mean of the number of plays for the entire data set was around
    891, and the median was 246\. So the 100-popularity puzzles were played a bit
    less on average, but the relationship is not that strong. Some of these puzzles
    seem to just be very good ones.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，那些流行度等于-100的谜题确实被玩得很少。然而，对于那些流行度为100的谜题，这种关系并不那么强烈。如您从列表8.2中的代码产生的输出中回忆起来，整个数据集的播放次数平均值约为891，中位数约为246。因此，100流行度的谜题平均播放次数略少，但关系并不那么强烈。其中一些谜题似乎只是非常好。
- en: '**Exercise 9.2**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习9.2**'
- en: Make sure that the values stored in the rating_mapping dictionary add up to
    represent all row indices of our good data frame. To do this, check whether the
    sum of lengths of these vectors is equal to the number of rows in the good data
    frame.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 确保存储在rating_mapping字典中的值加起来代表我们良好数据框的所有行索引。为此，检查这些向量的长度之和是否等于良好数据框中的行数。
- en: '**Solution**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The use of the sum function with a transformation function passed as its first
    argument is explained in chapter 4.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有其第一个参数为转换函数的sum函数的解释在第4章中。
- en: '**Exercise 9.3**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习9.3**'
- en: Check the consequences of changing the value of the span keyword argument in
    the loess function. By default, this argument has the value 0.75\. Set it to 0.25,
    and add another prediction line to the plot presented in figure 9.4\. Make the
    line yellow with its width equal to 5.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 检查在loess函数中更改span关键字参数值的影响。默认情况下，此参数的值为0.75。将其设置为0.25，并在图9.4所示的图中添加另一条预测线。使线条为黄色，宽度为5。
- en: '**Solution**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Figure B.3 shows the result. Note that by applying less smoothing, the curve
    has a slightly better fit to the data. In comparison to the predictions from figure
    9.4, it has lower bias on the edge, a rating equal to around 1500 (the original
    prediction is slightly biased upward), and in the extremum, a rating equal to
    around 1750 (the original prediction is slightly biased downward).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图B.3显示了结果。请注意，通过应用较少的平滑处理，曲线与数据的拟合略好。与图9.4的预测相比，它在边缘具有较低的偏差，评分为约1500（原始预测略有向上偏差），在极值处评分为约1750（原始预测略有向下偏差）。
- en: '![APPB_F03_Kaminski2](../Images/APPB_F03_Kaminski2.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![APPB_F03_Kaminski2](../Images/APPB_F03_Kaminski2.png)'
- en: Figure B.3 This plot of the relationship between the number of web and machine
    learning neighbors and the fraction of machine learning developers is created
    without jittering.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图B.3 此显示网络和机器学习邻居数量与机器学习开发者比例之间关系的图表是在没有抖动的情况下创建的。
- en: '**Exercise 10.1**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习10.1**'
- en: Compare the performance of creating a data frame holding a single random vector
    of one million elements with and without copying a source vector. You can generate
    this vector by using the rand(10^6) command.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 比较创建包含单个随机向量（一百万个元素）的数据框时，是否复制源向量对性能的影响。你可以通过使用rand(10^6)命令生成此向量。
- en: '**Solution**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using copycols=false leads to less memory allocation and faster code execution.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用copycols=false可以减少内存分配并加快代码执行速度。
- en: '**Exercise 10.2**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习10.2**'
- en: Check the result of vcat on the two data frames, df1=DataFrame(a=1, b=2) and
    df2=DataFrame(b=2, a=1). Next, verify the result of the operation if we also pass
    the cols=:orderequal keyword argument.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 检查两个数据框vcat的结果，df1=DataFrame(a=1, b=2)和df2=DataFrame(b=2, a=1)。接下来，验证如果我们也传递cols=:orderequal关键字参数时的操作结果。
- en: '**Solution**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Exercise 10.3**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习10.3**'
- en: Change the code from listing 10.7 so that we perform only two-steps-ahead verification
    if the random walk visits the same point again. Verify that under such a definition,
    the probability that we do not have duplicate visits to the same point is around
    7.5%.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表10.7中的代码修改为，如果随机游走再次访问相同点，则只执行两步验证。验证在这种情况下，我们没有重复访问相同点的概率大约为7.5%。
- en: '**Solution**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The difference in this code as compared to listing 10.7 is that this time, the
    condition we check is all(walk[i, :] != walk[i+2, :] for i in 1:9). As explained
    in section 10.2, we check whether we visit different points in instances 1 and
    3, 2 and 4, . . . , 9 and 11.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表10.7相比，此代码的差异在于这次，我们检查的条件是all(walk[i, :] != walk[i+2, :] for i in 1:9)。如第10.2节所述，我们检查在实例1和3、2和4、...、9和11中是否访问了不同的点。
- en: The result is around 7.5%, as expected.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 结果大约为7.5%，正如预期的那样。
- en: '**Exercise 11.1**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习11.1**'
- en: Measure the time required to create a data frame with one row and 10,000 columns
    consisting of only 1s. Use the matrix created by ones(1, 10_000) as a source and
    automatic column names. Next, measure the time required to create a NamedTuple
    of vectors from this data frame.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 测量创建一个包含10,000列且只有1s的单行数据框所需的时间。使用由ones(1, 10_000)创建的矩阵作为源，并自动生成列名。接下来，测量从该数据框创建向量NamedTuple所需的时间。
- en: '**Solution**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Creating very wide data frame objects is fast, even on the first run. On the
    other hand, creating wide NamedTuple objects incurs a very high compilation cost.
    The second run of Tables.columntable(wide) is fast because Julia caches compilation
    results of the required functions for the used column names and types.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建非常宽的数据框对象非常快，即使在第一次运行时也是如此。另一方面，创建宽NamedTuple对象会带来非常高的编译成本。Tables.columntable(wide)的第二次运行很快，因为Julia缓存了用于所需列名和类型的函数的编译结果。
- en: '**Exercise 11.2**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习11.2**'
- en: 'Using the gdf_city grouped data frame, compute the mean temperature in each
    city by using the mean function from the Statistics module. Store the result as
    a dictionary in which keys are city names and values are corresponding mean temperatures.
    Compare your result with the output of the following call: combine(gdf_ city,
    :rainfall => mean). (We will discuss the exact syntax of such expressions in chapters
    12 and 13.)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用gdf_city分组数据框，通过使用Statistics模块中的mean函数计算每个城市的平均温度。将结果存储为一个字典，其中键是城市名称，值是对应的平均温度。将你的结果与以下调用的输出进行比较：combine(gdf_city,
    :rainfall => mean)。（我们将在第12章和第13章中讨论此类表达式的确切语法。）
- en: '**Solution**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Exercise 12.1**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习12.1**'
- en: 'Using the complete_graph(37700) call, create a complete graph on 37,700 nodes
    (the number of nodes we have in the gh graph). But beware: if you have less than
    32 GB RAM on your machine, use a smaller graph size, as this exercise is memory
    intensive. Next, using the Base.summarysize function, check how much memory this
    graph takes. Finally, using the @time function, check how long the deg_class function
    would take to finish on this graph, using the classes_df.ml_target vector as the
    vector of developer types.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 complete_graph(37700) 调用，在 37,700 个节点上创建一个完整图（我们在 gh 图中拥有的节点数）。但请注意：如果你的机器上少于
    32 GB RAM，请使用更小的图大小，因为这个练习是内存密集型的。接下来，使用 Base.summarysize 函数检查这个图占用多少内存。最后，使用
    @time 函数检查 deg_class 函数在这个图上完成所需的时间，使用 classes_df.ml_target 向量作为开发者类型的向量。
- en: '**Solution**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Consistent with our discussion in chapter 12, we see that a complete graph on
    37,700 nodes has 710,626,150 edges. Creating the graph requires around 11 GB of
    RAM. Executing the deg_class function on this graph took around 7 seconds.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在第 12 章中的讨论一致，我们看到，在 37,700 个节点上的完整图有 710,626,150 条边。创建该图需要大约 11 GB 的 RAM。在图上执行
    deg_class 函数大约需要 7 秒钟。
- en: '**Exercise 12.2.**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 12.2**。'
- en: Check to see how the plot in figure 12.6 would look if you removed jittering
    from it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 检查如果从图中移除抖动，图 12.6 的绘制效果会如何。
- en: '**Solution**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code produces the plot in figure B.4.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码生成了图 B.4 的绘制。
- en: '![APPB_F04_Kaminski2](../Images/APPB_F04_Kaminski2.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![APPB_F04_Kaminski2](../Images/APPB_F04_Kaminski2.png)'
- en: Figure B.4 Plot of relationship between number of web and machine learning neighbors
    and fraction of machine learning developers. The plot is created without jittering.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.4：网络和机器学习邻居数量与机器学习开发者比例之间的关系图。该图在无抖动的情况下创建。
- en: If you compare figures B.4 and 12.6, you will see that, indeed, the points plotted
    in Figure B.4 overlap a lot, which makes it possible that some dark points would
    be unnoticed because they would be covered by many light points.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较图 B.4 和 12.6，你会看到，确实，图 B.4 中绘制的点有很多重叠，这可能导致一些暗点被忽视，因为它们会被许多亮点覆盖。
- en: '**Exercise 12.3**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 12.3**'
- en: Fit a probit model instead of a logit model to predict the ml_target variable.
    Use the ProbitLink() argument to the glm function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 probit 模型而不是 logit 模型来预测 ml_target 变量。使用 glm 函数的 ProbitLink() 参数。
- en: '**Solution**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Exercise 12.4**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 12.4**'
- en: Create an empty data frame. Add a column a to it, storing values 1, 2, and 3
    without copying. Next, create another column in the data frame, called b, that
    is the same vector as column a (without copying). Check that columns a and b store
    the same vector. Storing two identical columns in a data frame is unsafe, so in
    column b, store its copy. Now check that columns a and b store the same data but
    are different objects. Update in place the first two elements of column a by 10.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空数据框。向其中添加一个名为 a 的列，存储值 1、2 和 3，而不进行复制。接下来，在数据框中创建另一个名为 b 的列，该列与列 a 相同的向量（不进行复制）。检查列
    a 和 b 存储的向量是否相同。在数据框中存储两个相同的列是不安全的，因此，在列 b 中存储其副本。现在检查列 a 和 b 存储相同的数据但对象不同。就地更新列
    a 的前两个元素为 10。
- en: '**Solution**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Of these operations, the trickiest one is df.b = df[:, "b"]. We assign to an
    existing column b its copied value df[:, "b"]. Alternatively, we could have written
    df.b = copy(df.b).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些操作中，最棘手的是 df.b = df[:, "b"]。我们将复制的值 df[:, "b"] 赋值给现有的列 b。或者，我们也可以写成 df.b
    = copy(df.b)。
- en: '**Exercise 13.1**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 13.1**'
- en: Rewrite the code from listing 13.6, using the @rselect macro from DataFramesMeta.jl.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DataFramesMeta.jl 的 @rselect 宏重写列表 13.6 中的代码。
- en: '**Solution**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that with @rselect, we can specify simple transformations more easily,
    but the last four transformations, which we generated programmatically in listing
    13.6, have to be explicitly written instead.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用 @rselect，我们可以更容易地指定简单的转换，但最后四个转换，我们在列表 13.6 中程序化生成的，必须明确写出。
- en: '**Exercise 13.2**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 13.2**'
- en: Write a select operation creating the owensboro2 data frame that immediately
    has the dayname column (without having to perform a join).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个选择操作创建 owensboro2 数据框，该数据框立即包含 dayname 列（无需执行连接）。
- en: '**Solution**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It is enough to apply the dayname function to the :date column to get the desired
    result. Note, though, that in this case, the obtained column is not categorical,
    so we would need to turn it into a categorical one later by using the categorical
    function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将 dayname 函数应用于 :date 列即可获得所需的结果。不过，请注意，在这种情况下，获得的列不是分类的，因此我们稍后需要使用分类函数将其转换为分类列。
- en: '**Exercise 13.3**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 13.3**'
- en: To practice the operations you learned in this section, prepare the following
    analyses. First, calculate the probability of arrest per dayname column. Second,
    compute the probability of arrest again, but this time, compute it per the dayname
    and type columns, and present the results in wide form, where dayname levels are
    rows and type values form columns.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习本节学到的操作，准备以下分析。首先，计算每天被捕的概率。其次，再次计算被捕的概率，但这次按 dayname 和 type 列计算，并以宽表形式呈现结果，其中
    dayname 级别是行，type 值形成列。
- en: '**Solution**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Observe that, in general, the highest probability of arrest is on weekends:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到，通常情况下，被捕的最高概率出现在周末：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If type is pedestrian, the probability of arrest is much higher.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型是行人，被捕的概率会高得多。
- en: '**Exercise 13.4**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 13.4**'
- en: Create train and test data frames by using (a) data frame indexing syntax and
    (b) the groupby function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过（a）数据帧索引语法和（b）groupby 函数创建训练和测试数据帧。
- en: '**Solution**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the solution using the groupby function, it is important that we use sort=true.
    This ensures that groups are sorted by grouping column, so the false key is in
    the first group, and the true key is in the last group. Also, in this case, the
    train3 and test3 data frames have the SubDataFrame type, so they are views into
    the original owensboro2 data frame.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 groupby 函数的解决方案中，我们使用 sort=true 非常重要。这确保了组按分组列排序，因此 false 键在第一个组中，true 键在最后一个组中。此外，在这种情况下，train3
    和 test3 数据帧具有 SubDataFrame 类型，因此它们是原始 owensboro2 数据帧的视图。
- en: '**Exercise 14.1**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 14.1**'
- en: Using the @time macro, compare the time to compute the mean of values in the
    range -10^6:10^6 transformed by the <(0) and x -> x < 0 functions. Also, check
    the timing when you predefine the lt0(x) = x < 0 function. Run each operation
    three times.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 @time 宏，比较使用 <(0) 和 x -> x < 0 函数计算 -10^6:10^6 范围内值平均值的耗时。还要检查预先定义 lt0(x)
    = x < 0 函数时的计时。运行每个操作三次。
- en: '**Solution**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see in the results of the @time macro, the code using <(0) is faster
    because it does not have to be compiled each time, as opposed to the code using
    x -> x < 0.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 @time 宏的结果中所见，使用 <(0) 的代码更快，因为它不需要每次都编译，而使用 x -> x < 0 的代码则需要。
- en: This difference would not be important in scripts, in which everything is typically
    compiled only once. But it is most relevant when you work interactively with Julia,
    as in such cases, you are often manually repeating the same operation in global
    scope several times.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异在脚本中可能并不重要，因为在脚本中通常只编译一次。但当你以交互式方式与 Julia 一起工作时，它最为相关，在这种情况下，你通常会在全局范围内手动重复相同的操作多次。
- en: Another way to solve this issue is to define a named function:.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的另一种方法是定义一个命名函数：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: However, in interactive sessions, users often prefer to define anonymous functions
    inline rather than predefining them as named functions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在交互式会话中，用户通常更喜欢在行内定义匿名函数，而不是预先定义它们为命名函数。
- en: '**Exercise 14.2**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 14.2**'
- en: Create a web service that accepts a JSON payload with a single element n that
    is an integer. It should return in JSON format a vector of n random numbers generated
    using the rand function. If the passed request is incorrect, a 400 Bad Request
    response should be produced. Run this web server on your local computer and test
    whether it works as expected.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个接受包含单个元素 n 的 JSON 有效负载的 Web 服务，n 是一个整数。它应该以 JSON 格式返回使用 rand 函数生成的 n 个随机数的向量。如果传递的请求不正确，应生成
    400 Bad Request 响应。在您的本地计算机上运行此 Web 服务器并测试它是否按预期工作。
- en: '**Solution**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'In the solution, we now have the server and the client parts. First, start
    a Julia session that will be a server, and run the following code in it:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，我们现在有了服务器和客户端部分。首先，启动一个将作为服务器的 Julia 会话，并在其中运行以下代码：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, start another Julia session, and test the web service we have created:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动另一个 Julia 会话，并测试我们创建的 Web 服务：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the first call, we pass a correct request, and we obtain a three-element
    array of random numbers (your numbers might be different). In the second example,
    the request is malformed, as instead of n, we pass x. In this case, the server
    returns the 400 Bad Request response.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次调用中，我们传递一个正确的请求，并获得一个包含三个随机数的数组（您的数字可能不同）。在第二个示例中，请求格式不正确，因为我们没有传递 n，而是传递了
    x。在这种情况下，服务器返回 400 Bad Request 响应。
