- en: Chapter 3\. Unit-testing microservices
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章\. 單元測試微服務
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵蓋*'
- en: Applying unit testing techniques in a microservices-based architecture
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服務架構中應用單元測試技術
- en: Deciding which tools fit best for writing unit tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 確定哪些工具最適合编写單元測試
- en: Understanding solitary versus sociable unit tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解獨立與社交單元測試
- en: Writing readable, robust unit tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可讀、健壯的單元測試
- en: So far, you’ve become acquainted with the basic architecture, anatomy, and typical
    patterns used when developing microservices. You’ve also been introduced to the
    Gamer application, which is the reference application used throughout the book
    and for which we’ll now write some tests. In this chapter, you’ll learn how to
    write unit tests for a microservices-based architecture.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经熟悉了开发微服务时使用的基礎架構、解剖結構以及典型模式。你也已經被介紹了Gamer應用程序，這是整本書中使用的參考應用程序，我們將為其编写一些測試。在本章中，你將學習如何為基於微服務的架構编写單元測試。
- en: 3.1\. Unit testing techniques
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. 單元測試技術
- en: As you now know, *unit testing* is a testing technique where the code of the
    application under test should be the smallest possible snippet to produce the
    required behavior. Another main characteristic of unit tests is that they should
    execute as quickly as possible, so developers get rapid feedback after any addition
    to or refactoring of the code base.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，*單元測試*是一種測試技術，測試應用程序的代碼應該是最小的可能片段，以產生所需的行為。單元測試的另一個主要特點是它應該盡可能快地執行，以便在對代碼庫進行任何添加或重构後，開發者都能獲得快速的反饋。
- en: It’s important to remember that unit tests aren’t only a testing technique—unit
    testing is also a powerful design tool when you use a *test-driven-development*
    (TDD) approach, something we highly recommend.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要記住，單元測試不僅是一種測試技術——當你使用*測試驅動開發*（TDD）方法時，單元測試也是一個強大的設計工具，我們非常推薦這種方法。
- en: '|  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Writing a unit test should be an easy task. TDD helps with designing classes
    that are testable; if you find yourself getting into trouble while writing a unit
    test, then the problem is probably not in the unit test but in the code under
    test. In such cases, this is usually a sign that your code design should be changed
    somehow.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编写單元測試應該是一個簡單的任務。TDD幫助設計可測試的類別；如果你在编写單元測試時遇到困難，那麼問題可能不在單元測試，而在被測試的代碼中。在這種情況下，這通常是一個標誌，表明你的代碼設計應該以某種方式進行更改。
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The scope of what a unit test should cover has been discussed extensively over
    the history of unit testing, and the answer is likely to differ depending on the
    language paradigm. For example, in the case of a procedural language, it’s common
    to see a unit test cover a single function or procedure. For object-oriented languages,
    unit tests often cover a class. But the scope exposed here is only indicative.
    Depending on the project, team, code under test, and architecture, you may decide
    to expand or reduce the scope of a unit test, involving more or fewer business
    classes in a single test. As always, this is something that will need to be studied,
    discussed, and agreed on by the entire team.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 單元測試應該涵蓋的範圍在單元測試的歷史中已經被廣泛討論，答案可能會根據語言范式而有所不同。例如，在過程式語言的情況下，單元測試通常涵蓋一個單個函數或過程。對於面向對象的語言，單元測試通常涵蓋一個類別。但這裡暴露的範圍僅僅是指示性的。根據項目、團隊、測試的代碼和架構，你可能會決定擴大或縮小單元測試的範圍，在一個測試中涉及更多的或更少的業務類別。始終，這是需要整個團隊研究、討論並達成共識的事情。
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Because Java is an object-oriented language, we make an equivalence between
    the *unit* under test (the generic term) and the *class* under test, which is
    the concrete unit under test for object-oriented languages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因為Java是一種面向對象的語言，我們在測試的單元（一個通用術語）和測試的*類別*之間建立了一個等價關係，這是面向對象語言的具體測試單元。
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Naturally, a unit test will look different based on whether the code under test
    is isolated from its dependencies—testing only the unit under test without taking
    any of its collaborators into account—or involves the collaborators of the unit
    as part of the test scope. Jay Fields, author of *Working Effectively with Unit
    Tests* (Leanpub, 2015), provides names for both approaches to writing unit tests.
    A test that collaborates with its dependencies is a *sociable unit test*, and
    an isolated style is appropriately named a *solitary unit test*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，单元测试将根据要测试的代码是否与其依赖隔离而有所不同——只测试单元测试本身，不考虑任何协作者——或者将单元测试的协作者作为测试范围的一部分。Jay
    Fields，*《与单元测试有效工作》*（Leanpub，2015）的作者，为这两种编写单元测试的方法提供了名称。与依赖协作的测试被称为*社交单元测试*，而独立风格则恰当地命名为*独立单元测试*。
- en: 3.1.1\. Sociable unit tests
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1\. 社交单元测试
- en: Sociable unit tests focus on testing the behavior of the class under test along
    with its dependencies and collaborators by taking into consideration changes in
    state. Obviously, when using this approach, you’re treating the unit under test
    as a facade interface where some input is provided. Afterward, the unit under
    test uses its collaborators to calculate the output, and, finally, the output
    is validated by an assertion.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 社交单元测试通过考虑状态变化来关注测试类的行为及其依赖和协作者。显然，当使用这种方法时，你将单元测试视为一个外观接口，其中提供了一些输入。之后，单元测试使用其协作者来计算输出，最后，通过断言验证输出。
- en: Using these kind of tests, you build a *black-box* environment because everything
    is tested through the class under test. This approach is a great way to test classes
    belonging to the *business-domain component*, where such classes often expose
    calculations and state transitions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这类测试，你构建了一个*黑盒*环境，因为所有测试都是通过要测试的类进行的。这种方法是测试属于*业务域组件*的类的一个很好的方式，在这些类中，通常暴露计算和状态转换。
- en: Because business-domain objects are representations of real-world concepts,
    they contain the data of the model and the behavior that changes the state of
    the model. Domain objects are state-based, and there’s no real value in testing
    them in an isolated way. For this reason, sociable unit tests are best suited
    for testing business-domain logic.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因为业务域对象是现实世界概念的表示，它们包含模型的数据和改变模型状态的行为。域对象是基于状态的，以独立方式测试它们没有实际价值。因此，社交单元测试最适合测试业务域逻辑。
- en: '[Figure 3.1](kindle_split_012_split_001.xhtml#ch03fig01) illustrates the makeup
    of a sociable unit test. You can see that the test class and the class under test
    are contained within the scope of the test. As in solitary testing, the dependencies
    (and collaborators) of the class under test are outside that scope. The major
    difference between sociable testing and solitary testing, in which test doubles
    are used, is that the dependencies (and collaborators) are real classes.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.1](kindle_split_012_split_001.xhtml#ch03fig01)说明了社交单元测试的构成。你可以看到测试类和要测试的类都包含在测试范围内。与独立测试一样，要测试的类的依赖（和协作者）在范围之外。社交测试与使用测试替身进行的独立测试的主要区别在于，依赖（和协作者）是真实类。'
- en: Figure 3.1\. Sociable unit test
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1\. 社交单元测试
- en: '![](Images/03fig01_alt.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1](Images/03fig01_alt.jpg)'
- en: 3.1.2\. Test doubles
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2\. 测试替身
- en: As you saw in [section 3.1](kindle_split_012_split_001.xhtml#ch03lev1sec1),
    there are two approaches regarding the scope of what a unit test should cover.
    The first approach is solitary unit testing, where the class under test is isolated
    from all its dependencies and collaborators, and the second approach is sociable
    unit testing, where the class under test involves its collaborators.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[3.1节](kindle_split_012_split_001.xhtml#ch03lev1sec1)中看到的，关于单元测试应该覆盖的范围有两种方法。第一种方法是独立单元测试，其中要测试的类与其所有依赖和协作者隔离，第二种方法是社交单元测试，其中要测试的类涉及其协作者。
- en: 'Maybe you’ve already started to think about the following question: “If my
    class under test has a collaborator, and I want to write a unit test using a solitary
    unit testing approach, how do I isolate the class under test?”'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你已经开始思考以下问题：“如果我要测试的类有一个协作者，而我想要使用独立的单元测试方法来编写单元测试，我该如何隔离要测试的类？”
- en: If you don’t do anything, then the test will probably complete, at best, on
    a `NullPointerException`, because there won’t be any collaborator instance available
    for the test. So, the answer to the question is to use test doubles.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你什么都不做，那么测试可能最多会在`NullPointerException`上完成，因为没有可用的协作者实例进行测试。因此，对这个问题的答案是使用测试替身。
- en: '*Test double* is the generic term used when you replace a production object,
    usually a collaborator of the class under test, with a simplified class double
    for testing purposes. Generally speaking, there are five kinds of test doubles,
    as identified by Gerard Meszaros in *xUnit Test Patterns: Refactoring Test Code*
    (Addison-Wesley, 2007):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试替身*是在用简化类双用来替换生产对象（通常是正在测试的类的协作者）进行测试时使用的通用术语。一般来说，根据Gerard Meszaros在《xUnit
    Test Patterns: Refactoring Test Code》（Addison-Wesley，2007）中确定的，有五种测试替身类型：'
- en: '*Dummies*—A dummy object is passed but never used. It’s just used to fill required
    method parameters.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*哑元*—哑元对象被传递但从未使用。它只是用来填充所需的方法参数。'
- en: '*Fakes*—A fake object is an implementation of a collaborator, but it takes
    some shortcuts to make it more performant. Usually, a fake object isn’t suitable
    for production. A well-known example is the *in-memory database*.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*伪造*—伪造对象是协作者的实现，但它采取了一些捷径以提高性能。通常，伪造对象不适合生产。一个众所周知的例子是*内存数据库*。'
- en: '*Stubs*—A stub provides predefined answers to calls made during the test.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存根*—存根在测试期间为调用提供预定义的答案。'
- en: '*Mocks*—A mock is an object with preprogrammed expectations. An expectation
    can be a discrete value or an exception. Unlike stubs, mocks do runtime behavior
    verification. No state is stored.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模拟*—模拟是一个具有预编程期望的对象。期望可以是离散值或异常。与存根不同，模拟执行运行时行为验证。不存储任何状态。'
- en: '*Spies*—A spy object is a stub that records information during the calls to
    it. For example, an email gateway stub might be able to return all the messages
    that it “sent.”'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*间谍*—间谍对象是在对其调用期间记录信息的存根。例如，一个电子邮件网关存根可能能够返回它“发送”的所有消息。'
- en: Usually, test doubles are predictable (this is especially true for mocks). This
    means using test doubles makes your unit tests more robust, because collaborators
    will behave in exactly the same way during each execution. The execution speed
    when using test doubles is also a big advantage. They’re not real implementations,
    so they perform well. This makes your test suites performant and also provides
    quick feedback to developers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，测试替身是可预测的（这对于模拟来说尤其如此）。这意味着使用测试替身可以使你的单元测试更加健壮，因为协作者在每次执行中都会以完全相同的方式表现。使用测试替身时的执行速度也是一个很大的优势。它们不是真实实现，所以性能良好。这使得你的测试套件性能良好，同时也为开发者提供了快速的反馈。
- en: '|  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Mocks vs. stubs (and spies)**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟与存根（以及间谍）**'
- en: In our experience, most cases can be tested using *mocks* or *spies*; the only
    differences are what you assert in the test and the level of confidence that this
    assertion gives you.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，大多数情况可以使用*模拟*或*间谍*进行测试；唯一的区别是你在测试中提出的断言以及这个断言给你带来的信心水平。
- en: 'Let’s use a concrete example. Suppose you want to test a class, and one of
    its collaborators is used for sending an email. Here’s how you *spy* the collaborator:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个具体的例子来说明。假设你想测试一个类，其中一个协作者用于发送电子邮件。这是你如何*间谍*协作者的方法：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now you can write a test using the previous class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用之前的类来编写测试：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that this test verifies the state of the spy: in this case, that the
    expected message has been sent.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个测试验证了间谍的状态：在这种情况下，预期的消息已被发送。
- en: 'In a similar way, *mocking* the collaborator uses a test that looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，*模拟*协作者使用一个看起来像这样的测试：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that the biggest difference is that this test only verifies an interaction,
    so it performs behavior verification. Another big difference is that the test
    relies on collaborator method calls. Meanwhile, the spies-and-stubs case requires
    extra methods to help with verification of state changes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最大的区别是，这个测试只验证了交互，因此它执行行为验证。另一个很大的区别是，测试依赖于协作方法调用。同时，间谍和存根的情况需要额外的方法来帮助验证状态变化。
- en: As mentioned earlier, choosing between stubs/spies and mocks depends on what
    kind of test your unit needs. If you need state verifications or custom test implementations
    of a collaborator, then spies are the best choice. On the other hand, if you only
    need behavior verifications without any custom implementation, then mocks are
    generally the best choice.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，选择存根/间谍和模拟取决于你的单元需要哪种类型的测试。如果你需要状态验证或协作者的自定义测试实现，那么间谍是最好的选择。另一方面，如果你只需要行为验证而没有任何自定义实现，那么模拟通常是最好的选择。
- en: Based on our experience and in cases of doubt, the best way to start is by using
    mocks. It’s faster to get started, you only need to record the expectations, and
    usually it covers the use cases to test.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验和在存在疑问的情况下，最好的开始方式是使用模拟。这可以更快地开始，你只需要记录期望，通常它涵盖了要测试的使用案例。
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.1.3\. Solitary unit tests
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.3\. 独立单元测试
- en: Solitary unit tests focus on testing the unit or work in an isolated and controlled
    way. The unit’s collaborators are replaced by test doubles or mocks.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 独立单元测试专注于以隔离和受控的方式测试单元或工作。单元的协作者被测试替身或模拟所取代。
- en: This approach is a great way to avoid test failures that are unrelated to the
    class under test, but are related to one of its dependencies. This is usually
    far outside the scope of the test.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是一个很好的方法来避免与被测试类无关的测试失败，但与它的某个依赖项有关。这通常远远超出了测试的范围。
- en: 'Moreover, solitary unit tests are useful in cases where the class under test
    has a dependency that requires a physical connection to a network, a database,
    an email service, or even another microservice. Using real dependencies in these
    cases is a bad thing for two reasons:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，独立单元测试在以下情况下也很有用，即被测试的类有一个需要与网络、数据库、电子邮件服务或甚至另一个微服务建立物理连接的依赖项。在这些情况下使用真实依赖项是两方面的坏处：
- en: Access to I/O is a comparatively slow operation, and unit tests should be fast.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对I/O的访问是一个相对较慢的操作，单元测试应该是快速的。
- en: Remote services are prone to failure at any time (due to server outages, network
    outages, firewall rules, and so on), and this means a test might fail for reasons
    other than incorrect code.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程服务随时可能失败（由于服务器故障、网络故障、防火墙规则等），这意味着测试可能因为除了代码错误以外的其他原因而失败。
- en: 'Hence, you should aspire to use solitary unit tests for the following scenarios:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你应该努力在以下场景中使用独立单元测试：
- en: '*When collaborators of the unit under test are slow*—This can be due to I/O
    access, but it could also be due to long-running calculations.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*当被测试单元的协作者运行缓慢*——这可能是由于I/O访问，但也可能是由于长时间运行的计算。'
- en: '*When collaborators of the unit under test contain logic that may change often*—In
    this case, the test may fail not because of the class under test, but because
    one of the collaborators fails.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*当被测试单元的协作者包含可能经常变化的逻辑*——在这种情况下，测试可能失败并不是因为被测试的类，而是因为其中一个协作者失败了。'
- en: '*When you want to test corner cases that would be difficult to test using real
    instances*—For example, a disk-is-full test case.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*当你想要测试那些使用真实实例难以测试的边缘情况*——例如，磁盘满的测试用例。'
- en: '[Figure 3.2](kindle_split_012_split_001.xhtml#ch03fig02) illustrates what a
    solitary unit test looks like. You can see that the test class and the unit under
    test are within the scope of the test. The dependencies (and collaborators) of
    the class being tested are outside of that scope, and they’re not the real classes—they’re
    replaced with test doubles.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.2](kindle_split_012_split_001.xhtml#ch03fig02)展示了独立单元测试的样子。你可以看到测试类和被测试单元在测试范围内。被测试类的依赖项（和协作者）在范围之外，并且它们不是真正的类——它们被测试替身所取代。'
- en: Figure 3.2\. Solitary unit test
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2\. 独立单元测试
- en: '![](Images/03fig02_alt.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig02_alt.jpg)'
- en: 3.1.4\. Unit testing in microservices
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.4\. 微服务中的单元测试
- en: We’ve introduced what unit testing is, what different approaches you might take—such
    as solitary or sociable—and test doubles and how they can help you write better
    unit tests. In this section, you’ll see how to apply unit test concepts to the
    microservice architecture. Before we look at a concrete example, let’s review
    the anatomy of a microservice.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了单元测试是什么，你可能采取的不同方法——例如独立或社交——以及测试替身以及它们如何帮助你编写更好的单元测试。在本节中，你将看到如何将单元测试概念应用于微服务架构。在我们查看具体示例之前，让我们回顾一下微服务的结构。
- en: Resource and service component layers
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 资源和服务组件层
- en: Resources and services commonly contain coordination code between gateways,
    domain objects, and repositories, as well as message conversion between modules.
    We strongly recommend using solitary unit tests for resources and services. The
    reason is that collaborators of resources and services are usually slow. This
    will affect the robustness of the test (for example, the network might be down,
    leading to a false negative). In the case of gateways, they usually communicate
    with a service deployed on another server, so this again means touching the network.
    Use of repositories is a similar story, because disk I/O is virtually analogous
    with network traffic. For this reason, using test doubles and, to be more concrete,
    *mock* objects in collaborators is the best choice when working with resources
    and services.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 资源和服务通常包含网关、领域对象和存储库之间的协调代码，以及模块之间的消息转换。我们强烈建议为资源和服务使用独立的单元测试。原因是资源和服务的协作者通常反应较慢。这会影响测试的鲁棒性（例如，网络可能中断，导致假阴性）。在网关的情况下，它们通常与部署在另一台服务器上的服务进行通信，这意味着又要触及网络。使用存储库的情况也类似，因为磁盘I/O几乎与网络流量相似。因此，在处理资源和服务时，使用测试替身，更具体地说，使用模拟对象，是最佳选择。
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Sometimes, resources and services act as facades, passing messages between collaborators.
    In such cases, unit testing may not pay off—other testing levels, such as component
    testing, may be more worthwhile.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，资源和服务充当着门面，在协作者之间传递消息。在这种情况下，单元测试可能不会带来回报——其他测试级别，如组件测试，可能更有价值。
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Gateway component
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 网关组件
- en: Gateway component layers contain the logic to connect to an external service,
    typically using an HTTP/S client. In this case, a solitary unit test using mocks
    or stubs is the best way to proceed to avoid touching the network from within
    the unit test.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 网关组件层包含连接到外部服务的逻辑，通常使用HTTP/S客户端。在这种情况下，使用模拟或存根进行独立的单元测试是避免在单元测试中触及网络的最佳方式。
- en: 'The items to test in this layer are as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一层要测试的项目如下：
- en: Mapping logic between the underlying protocol and business objects
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在底层协议和业务对象之间的映射逻辑
- en: Forcing error conditions that might be difficult to simulate using real services
    (negative testing)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制错误条件，这些条件可能难以使用真实服务进行模拟（负面测试）
- en: Domain component
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 领域组件
- en: We talked about how to test the domain layer in [section 3.1.1](kindle_split_012_split_001.xhtml#ch03lev2sec1).
    *Domain logic* exposes calculations and state transitions. Because domain objects
    are state-based, there’s no value in testing them in an isolated way. For this
    reason, sociable unit testing is the best strategy for testing domain logic.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3.1.1节](kindle_split_012_split_001.xhtml#ch03lev2sec1)中讨论了如何测试领域层。*领域逻辑*暴露了计算和状态转换。由于领域对象基于状态，以独立方式测试它们没有价值。因此，社交单元测试是测试领域逻辑的最佳策略。
- en: Repository components
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 存储库组件
- en: A repository usually acts as a “gateway” to a persistence layer by connecting
    to a database, executing queries, and adapting the output to domain objects. A
    repository could also be a properties file, or Elasticsearch, for example. The
    list is endless.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库通常通过连接到数据库、执行查询并将输出调整为领域对象来充当持久层的“网关”。存储库也可以是属性文件，或Elasticsearch等。列表无穷无尽。
- en: A persistence layer is usually implemented using an ORM such as JPA, so in most
    cases, this layer just deals with the core class of the system. (In the case of
    JPA, this is `EntityManager`.) If you decide that writing unit tests for persistence
    objects isn’t going to pay off, then at least write integration tests for them.
    But if some logic is encompassed in mapping the response, then a solitary unit
    test and mocking the core class, such as `EntityManager`, should be sufficient
    to provide mapped objects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 持久层通常使用ORM（如JPA）实现，因此在大多数情况下，这一层仅处理系统的核心类。（在JPA的情况下，这是`EntityManager`。）如果你决定为持久化对象编写单元测试不会带来回报，那么至少为它们编写集成测试。但如果某些逻辑包含在映射响应中，那么对核心类（如`EntityManager`）进行独立的单元测试和模拟应该足够提供映射对象。
- en: Solitary or sociable?
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 独立还是社交？
- en: '[Table 3.1](kindle_split_012_split_001.xhtml#ch03table01) summarizes when to
    use the solitary approach and when to use the sociable one.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3.1](kindle_split_012_split_001.xhtml#ch03table01)总结了何时使用独立方法以及何时使用社交方法。'
- en: Table 3.1\. Solitary vs. sociable unit testing
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.1. 独立与社交单元测试的比较
- en: '| Component | Solitary | Sociable |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 独立 | 社交 |'
- en: '| --- | --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Resources | X |   |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 资源 | X |   |'
- en: '| Services | X |   |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 服务 | X |   |'
- en: '| Gateways | X |   |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 网关 | X |   |'
- en: '| Domain |   | X |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 领域 |   | X |'
- en: '| Repositories | X |   |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 仓库 | X |   |'
- en: 3.2\. Tools
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 工具
- en: We’ve presented how to best match unit testing styles to each of the components
    of the microservices architecture. Now, let’s look at the tools used for writing
    unit tests. Many such tools are available, but in our opinion the following are
    currently the most widely adopted and accepted by the Java community.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何将单元测试风格与微服务架构的各个组件最佳匹配。现在，让我们看看用于编写单元测试的工具。有许多这样的工具可用，但据我们观察，以下是目前最广泛采用并被Java社区接受的。
- en: 3.2.1\. JUnit
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. JUnit
- en: '*JUnit* is a unit testing framework for Java. Currently, it’s extended by other
    tools for writing different levels of tests such as integration and component
    tests.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*JUnit* 是一个Java单元测试框架。目前，它被其他工具扩展，用于编写不同级别的测试，如集成和组件测试。'
- en: A JUnit test is a Java object with special annotations to mark a method as a
    test. Older versions provided objects to extend, but the annotation approach is
    more flexible.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit测试是一个带有特殊注解的Java对象，用于标记方法为测试。旧版本提供了可以扩展的对象，但注解方法更灵活。
- en: 'The following snippet shows how a typical JUnit test is structured:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了典型的JUnit测试的结构：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* The method is executed before the tests defined in the class.**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 该方法在类中定义的测试之前执行。**'
- en: '***2* The method is executed before each test in the class.**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 该方法在类中的每个测试之前执行。**'
- en: '***3* Flags the method as a test method**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将方法标记为测试方法**'
- en: '***4* JUnit provides methods for asserting results.**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* JUnit 提供了断言结果的方法。**'
- en: '***5* The method is executed after each test in the class.**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 该方法在类中的每个测试之后执行。**'
- en: '***6* The method is executed after execution of all tests in the class.**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 该方法在类中所有测试执行之后执行。**'
- en: 3.2.2\. AssertJ
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. AssertJ
- en: Several important features are critical for good unit tests. A unit test should
    be *fast* and *isolated*; we’ve talked about this before. But an equally important
    aspect is that they should be *readable*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 几个重要的特性对于编写好的单元测试至关重要。单元测试应该是*快速*和*隔离*的；我们之前已经讨论过这一点。但同样重要的是，它们应该是*可读*的。
- en: Any reader of the test should be able to identify with a quick glance what the
    test is about and also what the expected result should be. The snippet in the
    previous section used clauses like `assertEquals` and `assertTrue`—these are clear
    statements.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 任何阅读测试的人都应该能够快速识别测试的内容以及预期的结果。前一个节中的代码片段使用了`assertEquals`和`assertTrue`这样的语句——这些都是清晰的表述。
- en: 'Using these clauses is valid, but they pose challenges regarding readability.
    Let’s explore some of these issues:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些语句是有效的，但它们在可读性方面提出了挑战。让我们探讨一些这些问题：
- en: You don’t immediately know which parameter is the expected value and which is
    the result value. Assuming `assertEquals(val1, val2)`, is the first parameter
    the expected value or the calculated one? It’s the expected value. This is important
    because, in the case of failure, the error message is built using these parameters.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不会立即知道哪个参数是预期值，哪个是结果值。假设`assertEquals(val1, val2)`，第一个参数是预期值还是计算值？它是预期值。这很重要，因为在失败的情况下，错误信息是使用这些参数构建的。
- en: Asserting simple conditions might be hard to read and write. `assertTrue (17
    < age)` seems unnatural to read.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言简单的条件可能难以阅读和编写。`assertTrue (17 < age)`看起来不太自然。
- en: Usually, methods return more-complex objects or lists of objects. Note that
    `assertTrue(games.contains(zelda))` has two problems. First, the assertion isn’t
    very readable; and second, what will happen if the `zelda` object doesn’t implement
    `equals`, or implements it in some detrimental way for the assertion logic? The
    *assertion* may become an *assumption*.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，方法返回更复杂的对象或对象列表。请注意，`assertTrue(games.contains(zelda))`有两个问题。首先，断言的可读性不高；其次，如果`zelda`对象没有实现`equals`，或者以对断言逻辑有害的方式实现它，会发生什么？*断言*可能变成了*假设*。
- en: To avoid all these problems, AssertJ ([http://joel-costigliola.github.io/assertj](http://joel-costigliola.github.io/assertj))
    was developed so developers can use fluent assertions in tests. One of the areas
    where AssertJ shines is in providing a rich set of assertions that facilitate
    writing assumptions for complex elements, as well as improving readability.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免所有这些问题，开发了AssertJ ([http://joel-costigliola.github.io/assertj](http://joel-costigliola.github.io/assertj))，以便开发者在测试中使用流畅的断言。AssertJ在提供丰富的断言集合方面表现出色，这些断言有助于编写复杂元素的假设，同时提高可读性。
- en: The static import you need to use is `import static org.assertj.core.api.Assertions.*`.
    You can still use `assertEquals` and `assertTrue` if you prefer, but let’s compare
    using AssertJ with previous examples.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用的静态导入是 `import static org.assertj.core.api.Assertions.*`。如果你愿意，你仍然可以使用
    `assertEquals` 和 `assertTrue`，但让我们比较一下使用 AssertJ 和之前的例子。
- en: Instead of writing `assertEquals(val1, val2)`, you can write `assertThat(val1).isEqualTo(val2)`
    using AssertJ. Notice that now the assertion is explicit for the reader, and there’s
    no ambiguity about what the expected value and the real one should be.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不用写 `assertEquals(val1, val2)`，而是使用 AssertJ 写成 `assertThat(val1).isEqualTo(val2)`。注意，现在断言对读者来说是明确的，而且关于预期值和实际值应该是什么没有歧义。
- en: You can use `assertTrue (17 < age)`, but rewriting it with AssertJ looks like
    `assertThat(age).isGreaterThan(17)`. And you thought we were using a bad example!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `assertTrue (17 < age)`，但用 AssertJ 重新编写它看起来像 `assertThat(age).isGreaterThan(17)`。你以为我们用了糟糕的例子！
- en: Finally, AssertJ can help in the case of complex validations. Instead of using
    `assertTrue(games.contains(zelda))`, which depends on the `equals` method, you
    can rewrite it with AssertJ to be something like `assertThat(games).extracting
    ("name").contains("Zelda")`. This has none of the ambiguity of the `equals` method,
    and at the same time, it improves readability.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，AssertJ 可以帮助进行复杂的验证。你不用使用 `assertTrue(games.contains(zelda))`，这依赖于 `equals`
    方法，而是可以用 AssertJ 重新编写成类似 `assertThat(games).extracting ("name").contains("Zelda")`
    的形式。这没有 `equals` 方法的任何歧义，同时，它也提高了可读性。
- en: '|  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may wonder what the difference is between AssertJ and Hamcrest (part of
    JUnit). Both projects were created for the same purpose: improving the readability
    of tests. But the most important difference between them is that whereas AssertJ
    uses fluent assertions, making writing assertions from the IDE an easy task, in
    Hamcrest you write assertions like the layers of an onion, one inside another,
    which is less natural to read and write in an IDE.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道 AssertJ 和 Hamcrest（JUnit 的一部分）之间的区别是什么。这两个项目都是为了同一个目的而创建的：提高测试的可读性。但它们之间最重要的区别是，虽然
    AssertJ 使用流畅的断言，使得在 IDE 中编写断言变得容易，而在 Hamcrest 中，你编写的断言就像洋葱的层一样，一层套一层，这在 IDE 中阅读和编写起来不太自然。
- en: '|  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You might agree that using AssertJ in your tests is a great way to not only
    improve readability but also avoid having to write cumbersome code in tests. We’ll
    use all of them, leaving the choice up to you as to which one you prefer in your
    own code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会同意，在测试中使用 AssertJ 不仅是一种提高可读性的好方法，而且还可以避免在测试中编写繁琐的代码。我们将使用所有这些，并将选择权留给你自己，决定在你的代码中更喜欢哪一个。
- en: 3.2.3\. Mockito
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.3\. Mockito
- en: 'In [section 3.1.2](kindle_split_012_split_001.xhtml#ch03lev2sec2), you saw
    different strategies for replacing a production object with a test object. There
    are five types of test doubles: dummies, fakes, stubs, spies, and mocks.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3.1.2 节](kindle_split_012_split_001.xhtml#ch03lev2sec2) 中，你看到了用测试对象替换生产对象的几种不同策略。有五种类型的测试双胞胎：哑元、伪造、存根、间谍和模拟。
- en: In unit tests, spies and mocks are by far the most used. Spies are usually implemented
    as an interface with custom code. For mocks, you need a framework that lets you
    record the canned answers for the calls.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，间谍和模拟是最常用的。间谍通常实现为一个带有自定义代码的接口。对于模拟，你需要一个框架，让你可以记录调用时的预设答案。
- en: In Java, there are several mocking frameworks, such as *JMockit*, *EasyMock*,
    and *Mockito*. In this book, the mocking framework we’ll focus on is Mockito ([http://site.mockito.org](http://site.mockito.org))—using
    more than one would be too confusing. According to an analysis performed on 30,000+
    Java projects, Mockito is the fourth-most-used library in Java projects, so we
    can consider it a de facto framework for mocking in Java. It’s a fast-moving project
    that will outpace this book, so please be sure to follow the project online. But
    feel free to analyze and choose your preferred mocking framework.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，有几个模拟框架，例如 *JMockit*、*EasyMock* 和 *Mockito*。在这本书中，我们将关注的模拟框架是 Mockito
    ([http://site.mockito.org](http://site.mockito.org))——使用多个可能会让人困惑。根据对 30,000 多个
    Java 项目的分析，Mockito 是 Java 项目中第四常用的库，因此我们可以将其视为 Java 中事实上的模拟框架。这是一个快速发展的项目，将超过本书的内容，所以请确保在线关注该项目。但请随意分析和选择你偏好的模拟框架。
- en: Mockito is a mocking framework written in Java that allows the creation of test
    doubles (mock objects) with a clean, simple API. Moreover, one of the features
    that differentiates Mockito from other mocking frameworks is that you can verify
    the behavior of the unit under test without defining expectations in advance,
    making tests simpler and reducing the coupling between test code and the unit
    under test.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 是一个用 Java 编写的模拟框架，它允许使用干净、简单的 API 创建测试双倍（模拟对象）。此外，Mockito 与其他模拟框架区分开来的一个特性是，你可以在不事先定义期望的情况下验证单元测试的行为，这使得测试更加简单，并减少了测试代码与单元测试之间的耦合。
- en: 'The following snippet shows the typical structure of a Mockito test:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段展示了 Mockito 测试的典型结构：
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Creates a proxy around the interface (or class) that you want to mock**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个代理来模拟你想要模拟的接口（或类）**'
- en: '***2* The methods of the mocked object are called like any other method.**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 模拟对象的调用方式与任何其他方法相同。**'
- en: '***3* Verifies that an expected interaction has been produced during test execution**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 验证在测试执行期间是否产生了预期的交互**'
- en: '***4* Produces an answer when this method is called with the given parameter**'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 当此方法使用给定参数调用时产生答案**'
- en: '***5* Returns “first” as the canned response**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回“first”作为 canned response**'
- en: The snippet shows only a basic usage of Mockito; more features are explained
    in the book as required.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该片段仅展示了 Mockito 的基本用法；更多功能将在书中根据需要解释。
- en: Now that you’ve been introduced to unit testing tools, let’s see what you need
    to do to start using them.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了单元测试工具，让我们看看你需要做什么才能开始使用它们。
- en: 3.2.4\. Build-script modifications
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.4\. 构建脚本修改
- en: 'In order to use a testing framework like JUnit, AssertJ, or Mockito, you need
    to define it as a test dependency in your build script. In the case of Maven,
    this information goes inside the `dependencies` block in pom.xml:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 JUnit、AssertJ 或 Mockito 这样的测试框架，你需要在构建脚本中将它定义为测试依赖项。在 Maven 的情况下，这个信息位于
    pom.xml 中的 `dependencies` 块内：
- en: '[PRE5]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Defines a dependency in the test scope**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在测试范围内定义一个依赖项**'
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Mockito used to erroneously provide a version of the Hamcrest library that clashed
    with the one that comes with JUnit. Although this has been fixed in Mockito 2,
    be aware that older projects might need upgrading.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 之前错误地提供了一个与 JUnit 一起提供的 Hamcrest 库版本，这导致了冲突。尽管在 Mockito 2 中已经修复了这个问题，但请注意，较旧的项目可能需要升级。
- en: '|  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: After registering dependencies in the build script, you can start writing unit
    tests.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建脚本中注册依赖项后，你可以开始编写单元测试。
- en: 3.3\. Writing unit tests for the Gamer app
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 为 Gamer 应用编写单元测试
- en: After discussing what unit tests are, which tools can be used, some strategies
    you can follow for each of the microservice layers, and registering the tools
    in the project, it’s time to begin writing unit tests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了单元测试是什么，可以使用哪些工具，以及你可以遵循的每个微服务层的策略，并在项目中注册这些工具之后，现在是时候开始编写单元测试了。
- en: Usually, unit tests are created under the de facto test directory named src/test/java.
    We suggest that you stick to this pattern.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，单元测试是在名为 src/test/java 的既定测试目录下创建的。我们建议你坚持这个模式。
- en: 3.3.1\. YouTubeVideoLinkCreator test
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1\. YouTubeVideoLinkCreator 测试
- en: Let’s look at how to write a unit test for the `YouTubeVideoLinkCreator` class
    (code/video/src/main/java/book/video/controller/YouTubeVideoLinkCreator.java).
    This is a simple `controller` class that has no dependency on any other class,
    so it doesn’t require any test doubles. This class is responsible for the creation
    of the embedded URL of a YouTube video ID.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编写 `YouTubeVideoLinkCreator` 类的单元测试（code/video/src/main/java/book/video/controller/YouTubeVideoLinkCreator.java）。这是一个简单的
    `controller` 类，它不依赖于任何其他类，因此不需要任何测试双倍。这个类负责创建 YouTube 视频 ID 的嵌入 URL。
- en: Listing 3.1\. `YouTubeVideoLinkCreator` class
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. `YouTubeVideoLinkCreator` 类
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For this class, only one test method is required for testing that the creation
    of the URL is correct (code/video/src/test/java/book/video/controller/YouTubeVideoLink
    CreatorTest.java).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个类，只需要一个测试方法来测试 URL 的创建是否正确（code/video/src/test/java/book/video/controller/YouTubeVideoLink
    CreatorTest.java）。
- en: Listing 3.2\. Unit test for `YouTubeVideoLinkCreator`
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. `YouTubeVideoLinkCreator` 的单元测试
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* The test method must be annotated with @Test.**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 测试方法必须使用 @Test 注解。**'
- en: '***2* Descriptive test method name: call it what it is.**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 描述性测试方法名称：直接称呼即可。**'
- en: '***3* Class under test**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 测试中的类**'
- en: '***4* Calls createEmbeddedUrl**'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 调用 createEmbeddedUrl**'
- en: '***5* Asserts that the YouTube link is valid**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 断言 YouTube 链接是有效的**'
- en: You can see that the test method is annotated with `@Test`, and it’s structured
    using the well-known Given-When-Then structure, which essentially separates a
    test case into three sections. The *given*s are the preconditions of the test,
    the *when* is the stimulus of the test, and the *then* describes the expectations
    of the test.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到测试方法被注解为`@Test`，并且它使用众所周知的Given-When-Then结构进行结构化，这本质上将测试用例分为三个部分。*Given*是测试的前提条件，*When*是测试的刺激，*Then*描述了测试的期望。
- en: '|  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Notice that currently the catch code (the `IllegalArgumentException`) isn’t
    tested. The feedback it provides isn’t worth the effort of testing it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当前尚未测试捕获代码（`IllegalArgumentException`）。它提供的反馈不值得测试的努力。
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 3.3.2\. YouTubeLink test
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2\. YouTubeLink测试
- en: Let’s write a unit test for the `YouTubeLink` class (code/video/src/main/java/book/video/entity/YoutubeLink.java).
    This class is a domain object that has a collaborator (`YouTubeVideoLinkCreator`)
    that implements logic with this domain object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`YouTubeLink`类编写一个单元测试（code/video/src/main/java/book/video/entity/YoutubeLink.java）。这个类是一个域对象，它有一个协作者（`YouTubeVideoLinkCreator`），该协作者使用此域对象实现逻辑。
- en: Listing 3.3\. `YouTubeLink` class
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.3\. `YouTubeLink`类
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Behavior logic is implemented as a Java 8 functional interface.**'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 行为逻辑实现为Java 8功能接口。**'
- en: 'Notice that there are two options for writing this test:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，编写此测试有两种选择：
- en: A solitary-testing approach, which means mocking the `YouTubeVideoLinkCreator`
    class
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种独立测试方法，即模拟`YouTubeVideoLinkCreator`类
- en: A sociable-testing approach, which means using the real `YouTubeVideoLinkCreator`
    class
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种社交测试方法，即使用真实的`YouTubeVideoLinkCreator`类
- en: This case is typical in that it’s not worth mocking the dependency, and using
    the real one is better.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个案例很典型，因为它不值得嘲笑依赖，使用真实的依赖项更好。
- en: Listing 3.4\. Unit test for `YouTubeLink`
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.4\. `YouTubeLink`的单元测试
- en: '[PRE9]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Creates a real dependency**'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建真实依赖**'
- en: '***2* Injects the logic**'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入逻辑**'
- en: 'This unit test has the same look as the previous one. But because it’s a sociable
    test, two instances are created: one for the class under test, and another as
    a dependency of it.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单元测试看起来和上一个一样。但由于它是一个社交测试，创建了两个实例：一个用于测试类，另一个作为它的依赖。
- en: '|  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the YouTube link case, the test looks simple, and you might be wondering
    whether it makes sense to write it: after all, `YouTubeVideoLinkCreator` was already
    tested in its own test. What’s being tested here isn’t the ability to create the
    YouTube embed link for a video, but that `YouTubeLinkTest`’s domain object is
    able to generate a correct YouTube embed link with its own data.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在YouTube链接案例中，测试看起来很简单，你可能想知道是否值得编写它：毕竟，`YouTubeVideoLinkCreator`已经在自己的测试中进行了测试。这里测试的不是为视频创建YouTube嵌入链接的能力，而是`YouTubeLinkTest`的域对象能够使用自己的数据生成正确的YouTube嵌入链接。
- en: '|  |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 3.3.3\. Games test
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.3\. 游戏测试
- en: So far, we’ve written unit tests without having to mock any dependencies. Let’s
    write a unit test for a *repository* element. In this case, we’ll use the `Games`
    class (code/game/src/main/java/book/games/boundary/Games.java).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写了不需要模拟任何依赖的单元测试。让我们为*仓库*元素编写一个单元测试。在这种情况下，我们将使用`Games`类（code/game/src/main/java/book/games/boundary/Games.java）。
- en: Listing 3.5\. `Games` class
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.5\. `Games`类
- en: '[PRE10]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* EJBs make classes transactional-aware by default.**'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* EJB默认使类具有事务感知性。**'
- en: '***2* EntityManager is injected for database operations.**'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入EntityManager以进行数据库操作。**'
- en: '***3* Creates a new game**'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一个新的游戏**'
- en: One of the most important things in unit tests is maintaining a good pace of
    execution. Because this repository is implemented using JPA, you need to mock
    this part.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试中最重要的事情之一是保持良好的执行速度。因为这个仓库是用JPA实现的，所以你需要模拟这部分。
- en: Listing 3.6\. Unit test for `Games`
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.6\. `Games`的单元测试
- en: '[PRE11]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* The Mockito runner initializes @Mock fields.**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Mockito运行器初始化@Mock字段。**'
- en: '***2* Marks the field as a mock**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将字段标记为模拟**'
- en: '***3* Records the answer when the mock is called**'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当调用模拟时记录答案**'
- en: '***4* Sets a mocked dependency**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 设置模拟依赖**'
- en: '***5* Normal call to the class under test**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 对测试类中的类的正常调用**'
- en: '***6* Verifies that the merge method is called with the expected game**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 验证merge方法是否以预期的游戏调用**'
- en: This test is slightly different from the previous ones. The first thing to notice
    is that it uses a custom JUnit runner. This runner is provided by the Mockito
    framework and is responsible for initializing all fields annotated with `@Mock`,
    among other things. You can use Mockito without the JUnit runner by using the
    `Mockito.mock()` method, as was shown in the introduction to the Mockito section;
    but in our opinion, unit tests look clearer when using the runner.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与之前的测试略有不同。首先要注意的是，它使用了一个自定义的JUnit运行器。这个运行器由Mockito框架提供，负责初始化所有带有`@Mock`注解的字段，以及其他一些功能。你可以使用Mockito而不使用JUnit运行器，就像在Mockito部分的介绍中所示；但据我们意见，使用运行器时单元测试看起来更清晰。
- en: The second difference is that now, in the test method, some canned answers are
    recorded for the `EntityManager` class. And finally, in addition to asserting
    the expected value, the test verifies that the mocked method is called, too. This
    is important so you can be sure that the class under test calls the expected dependency
    methods and not another method unrelated to the test.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是，现在在测试方法中，为`EntityManager`类记录了一些预设答案。最后，除了断言预期值外，测试还验证了被模拟的方法也被调用。这很重要，这样你可以确信正在测试的类调用了预期的依赖方法，而不是与测试无关的其他方法。
- en: Something similar can be done for the other methods.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他方法也可以做类似的事情。
- en: Listing 3.7\. Additional test methods in GamesTest.java
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.7\. GamesTest.java中的附加测试方法
- en: '[PRE12]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* The ID must be the same as the one recorded in the when function.**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* ID必须与when函数中记录的相同。**'
- en: '***2* Verifies that find is called, but also returns the required Optional**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 验证find被调用，但也返回所需的Optional**'
- en: '***3* Asserts that Optional has no value**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 断言Optional没有值**'
- en: '|  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Sometimes it doesn’t pay to write a unit test for repositories, because from
    the point of view of unit tests, they only act as a bridge. In this case, it’s
    worth it to not write a unit test and just write integration tests for the repository
    layer.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候编写单元测试对仓库来说并不划算，因为从单元测试的角度来看，它们只充当一个桥梁。在这种情况下，不编写单元测试，只为仓库层编写集成测试是值得的。
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.3.4\. GamesService test
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.4\. GamesService测试
- en: You’ve seen how to use JUnit, AssertJ, and Mockito in simple scenarios. Now,
    let’s write a unit test for the `searchGameById(gameId)` method, which is a bit
    more complicated (code/game/src/main/java/book/games/control/GamesService.java).
    This method is responsible for controlling whether information from a game is
    present in the database system or whether it needs to be retrieved from the official
    IGDB site.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何在简单场景中使用JUnit、AssertJ和Mockito。现在，让我们为`searchGameById(gameId)`方法编写一个单元测试，这个方法稍微复杂一些（code/game/src/main/java/book/games/control/GamesService.java）。这个方法负责控制游戏信息是否存在于数据库系统中，或者是否需要从官方IGDB网站上检索。
- en: Listing 3.8\. `searchGameById(gameId)` method
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.8\. `searchGameById(gameId)`方法
- en: '[PRE13]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Sets this class eligible for a CDI container as Dependent scope**'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将此类设置为CDI容器中依赖范围的合格类**'
- en: '***2* Other elements can be injected in a service.**'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 其他元素也可以注入到服务中。**'
- en: '***3* Finds the game in the database**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在数据库中查找游戏**'
- en: '***4* If the game isn’t found, gets it from the IGDB site.**'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果找不到游戏，则从IGDB网站上获取它。**'
- en: If you take a careful look at the logic of `GamesService`, you see that the
    methods `convertToJson` and `fromJson` of the `Game` entity are called. Again,
    you might wonder if it makes more sense to call these real methods, or to mock
    the entities as well.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看`GamesService`的逻辑，你会看到`Game`实体的`convertToJson`和`fromJson`方法被调用。再次，你可能想知道调用这些真实方法，还是模拟实体更有意义。
- en: In our experience, if it’s not complicated to manage their behavior, the best
    way to proceed is by using *real* entities (that is, the sociable-testing approach)
    instead of mocking them. It’s important to note that this test doesn’t substitute
    testing the entity object, because it’s focused on testing the `GameService` class
    and not `Game`. As you’ve seen in the previous section, the `Game` class must
    have its own test class where you test it deeply.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的经验中，如果管理它们的行为并不复杂，那么最好的做法是使用*真实*实体（即社交测试方法）而不是模拟它们。需要注意的是，这个测试并不代替对实体对象的测试，因为它专注于测试`GameService`类而不是`Game`。正如你在上一节中看到的，`Game`类必须有自己的测试类，在那里你可以深入测试它。
- en: Let’s look at a test that validates that if you have game data in an internal
    database, it’s retrieved from there and not by hitting the IGDB site (code/game/src/test/java/book/games/control/GamesServiceTest.java).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个测试，验证如果您在内部数据库中有游戏数据，它将从那里检索，而不是通过访问IGDB网站（code/game/src/test/java/book/games/control/GamesServiceTest.java）。
- en: Listing 3.9\. Unit-testing the games cache
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.9\. 游戏缓存单元测试
- en: '[PRE14]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* The game returned should be the one recorded in the mock object.**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回的游戏应该是记录在模拟对象中的那个。**'
- en: '***2* Verifies that no interaction with the IGDB site is produced**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 验证没有与IGDB网站的交互**'
- en: This test is very similar to the previous test, but there’s one simple but powerful
    change. Notice that this test verifies not only that something *has* occurred—in
    this case, that the game was retrieved by calling the search method from the database—but
    also that something *has not* occurred, in this case that the IGDB gateway methods
    weren’t called.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与之前的测试非常相似，但有一个简单而强大的变化。请注意，这个测试不仅验证了某些事情*已经发生*——在这个例子中，通过从数据库中调用搜索方法检索游戏——而且还验证了某些事情*没有发生*，在这个例子中是IGDB网关方法没有被调用。
- en: 'In a similar way, you can test the other case: when game data isn’t in the
    internal database and needs to be retrieved from IGDB.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，您可以测试其他情况：当游戏数据不在内部数据库中，需要从IGDB检索时。
- en: Listing 3.10\. Unit-testing game retrieval
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.10\. 游戏检索单元测试
- en: '[PRE15]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Asserts that the release-date tuple is correct**'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 断言发布日期元组是正确的**'
- en: '***2* Verifies that the game is stored in the internal database**'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 验证游戏是否存储在内部数据库中**'
- en: '***3* Verifies that the game is retrieved from IGDB**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 验证游戏是否从IGDB检索**'
- en: But there are cases where things can become more complex. In the next test,
    we’ll introduce the `ArgumentCaptor` feature and exception testing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 但在某些情况下，事情可能会变得更加复杂。在下一个测试中，我们将引入`ArgumentCaptor`功能和异常测试。
- en: 3.3.5\. GamesResource test
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.5\. GamesResource 测试
- en: As you’ve seen in previous sections, Mockito is helpful for mocking dependencies
    of the units under test. But testing can be more complicated in situations such
    as exception scenarios and special verification cases.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在之前的章节中看到的，Mockito对于模拟测试单元的依赖项非常有帮助。但在异常场景和特殊验证情况等情况下，测试可能会更加复杂。
- en: Let’s write a unit test for `GamesResource` (code/game/src/main/java/book/games/boundary/GamesResource.java).
    Remember that this class is the definition of REST endpoints related to game operations.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`GamesResource`编写一个单元测试（code/game/src/main/java/book/games/boundary/GamesResource.java）。记住，这个类是关于游戏操作的REST端点的定义。
- en: Listing 3.11\. `GamesResource` class
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.11\. `GamesResource` 类
- en: '[PRE16]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Resource is marked as a Singleton EJB, so the endpoint becomes transactional**'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 资源被标记为单例EJB，因此端点变为事务性**'
- en: '***2* Injects an executor service provided by the container**'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入容器提供的执行器服务**'
- en: '***3* @Asynchronous designates a method as asynchronous. Only valid if it’s
    an EJB.**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* @Asynchronous 将方法指定为异步。只有当它是EJB时才有效。**'
- en: '***4* @Suspended instructs the JAX-RS runtime that this method is asynchronous
    and injects AsyncResponse.**'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* @Suspended 指示JAX-RS运行时该方法异步，并注入AsyncResponse。**'
- en: '***5* Executes logic in another thread**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在另一个线程中执行逻辑**'
- en: '***6* Once the result is ready, the connection is resumed.**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 一旦结果准备就绪，连接将恢复。**'
- en: '***7* In case of an error, communication should also be resumed.**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 在出现错误的情况下，通信也应恢复。**'
- en: Notice that this class under test has some elements that are slightly different
    from other classes. The first item of note is that the method returns `void`.
    This doesn’t mean that the method doesn’t return *anything*, but that it returns
    the response using an async method, `response.resume()`. The second difference
    is that there’s special treatment in case an exception is thrown.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个待测试的类有一些与其他类略有不同的元素。第一个值得注意的事项是，该方法返回`void`。这并不意味着该方法不返回*任何东西*，而是它使用异步方法`response.resume()`返回响应。第二个不同之处在于，如果抛出异常，会有特殊处理。
- en: To resolve the first problem, you could use the `verify` method as seen in previous
    tests, but the `verify` method just checks the equality of arguments in a natural
    style by calling the `equals` method. This is the recommended way to match arguments
    when you have control of the object under verification, because you decide whether
    there are changes to the `equals` method. But when the object isn’t under your
    control, like `javax.ws.rs.core.Response`, then using the default `equals` method
    may not work, and it’s worth using `ArgumentCaptor`, which allows you to assert
    on certain arguments after verification instead of using the `equals` implementation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决第一个问题，你可以使用之前测试中看到的 `verify` 方法，但 `verify` 方法只是通过调用 `equals` 方法以自然风格检查参数的相等性。这是当你控制被验证的对象时匹配参数的推荐方式，因为你可以决定
    `equals` 方法是否有变化。但是，当对象不在你的控制之下，比如 `javax.ws.rs.core.Response`，那么使用默认的 `equals`
    方法可能不起作用，使用 `ArgumentCaptor` 是值得的，它允许你在验证后对某些参数进行断言，而不是使用 `equals` 实现来断言。
- en: Listing 3.12\. Unit test that uses an `ArgumentCaptor`
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.12\. 使用 `ArgumentCaptor` 的单元测试
- en: '[PRE17]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Creates a mock to provide as an argument to the JAX-RS endpoint**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个模拟对象作为 JAX-RS 端点的参数**'
- en: '***2* Creates an ArgumentCaptor using @Captor**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 @Captor 创建 ArgumentCaptor**'
- en: '***3* Creates a single thread pool**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一个单线程池**'
- en: '***4* Terminates ExecutorService**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 终止 ExecutorService**'
- en: '***5* Waits until the method is executed at the separated thread**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 等待方法在分离的线程中执行**'
- en: '***6* Verifies that resume is called, and captures the object that was used
    during the call**'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 验证是否调用了 `resume`，并捕获调用期间使用的对象**'
- en: '***7* Gets the captured object, and asserts with the expected values**'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 获取捕获的对象，并使用预期值进行断言**'
- en: 'This test is more complex than the ones you’ve written for other classes. The
    first thing to notice is that it uses `ArgumentCaptor`. It’s useful in this case
    because you’re only interested in the family of the response. You don’t know how
    the `equals` method is implemented and how it might change in the future, so capturing
    and manipulating the object in the test is the safest way to proceed. A captor
    is initialized by using the `@Captor` annotation instead of `@Mock`. The captor
    requires you to set the type of data that’s going to be captured: in this case,
    `javax.ws.rs.core.Response`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试比为你写的其他类的测试更复杂。首先要注意的是，它使用了 `ArgumentCaptor`。在这种情况下很有用，因为你只对响应的家族感兴趣。你不知道
    `equals` 方法是如何实现的，以及它将来可能会如何改变，因此在测试中捕获和操作对象是最安全的方式。捕获器是通过使用 `@Captor` 注解而不是 `@Mock`
    来初始化的。捕获器要求你设置将要捕获的数据类型：在这种情况下，是 `javax.ws.rs.core.Response`。
- en: Second, this case uses a sociable test by using the “real” `java.util.concurrent.ExecutorService`.
    Mocking an executor service would imply not executing any logic in the test and
    would make the test useless.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这个案例使用了一个社交测试，通过使用“真实”的 `java.util.concurrent.ExecutorService`。模拟一个执行器服务意味着在测试中不执行任何逻辑，这将使测试变得无用。
- en: You could argue that logic in the `submit` method could be added into its own
    class. In that case, you could write a unit test isolated from `ExecutorService`.
    That approach would be valid as well, but the truth is that with the introduction
    of functional interfaces in Java 8, the approach followed in the example is valid
    and well accepted.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以争论说，`submit` 方法中的逻辑可以添加到它自己的类中。在这种情况下，你可以编写一个与 `ExecutorService` 分离的单元测试。这种方法也是有效的，但事实是，随着
    Java 8 中函数式接口的引入，示例中采用的方法是有效且被广泛接受的。
- en: 'The last thing to note is the `ArgumentCaptor` lifecycle, which can be summarized
    as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的是 `ArgumentCaptor` 的生命周期，可以总结如下：
- en: '**1**.  The captor is initialized, in this test by using the `@Captor` annotation.'
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  捕获器被初始化，在这个测试中是通过使用 `@Captor` 注解来实现的。'
- en: '**2**.  The captor captures argument values used in the mocked method. In this
    test, the important value is the response passed to the `resume` method of `AsyncResponse`.
    To do this, you need to verify that the method is called, and if it’s called,
    capture its arguments. In the test, this is done by calling `verify(asyncResponse).resume(argumentCaptorResponse.capture())`.'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  捕获在模拟方法中使用的参数值。在这个测试中，重要的值是传递给 `AsyncResponse` 的 `resume` 方法的响应。为此，你需要验证该方法是否被调用，如果被调用，则捕获其参数。在测试中，这是通过调用
    `verify(asyncResponse).resume(argumentCaptorResponse.capture())` 来实现的。'
- en: '**3**.  Get the value captured by the captor. In this test, a `Response` object
    is captured. To get it, you call the `getValue` method.'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  获取捕获器的值。在这个测试中，捕获了一个 `Response` 对象。要获取它，你需要调用 `getValue` 方法。'
- en: In a similar way, you can test the exception scenario.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，您可以测试异常场景。
- en: '|  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**JSON Processing API dependency**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON 处理 API 依赖**'
- en: 'The `GamesResource` class uses the JSON Processing API, which is provided by
    the application server. Because unit tests aren’t run in an application server,
    you need to provide an implementation of the JSON Processing Specification. For
    this example, because you’re using WildFly Swarm, you’ll add the one used in WildFly:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`GamesResource` 类使用了由应用服务器提供的 JSON 处理 API。由于单元测试不在应用服务器上运行，您需要提供一个 JSON 处理规范的实现。对于这个例子，因为您正在使用
    WildFly Swarm，您将添加 WildFly 中使用的那个：'
- en: '[PRE18]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|  |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 3.13\. Unit-testing an exception scenario
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.13\. 测试异常场景的单元测试
- en: '[PRE19]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Throws an IOException when the searchGames(“zelda”) method is called**'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当调用 searchGames("zelda") 方法时抛出 IOException**'
- en: '***2* Verifies that resume is called with an IOException instance**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 验证 resume 是否被 IOException 实例调用**'
- en: This is the last unit test we’ll show you. The next section suggests some tests
    you can write to be sure you understand what you’ve learned.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将向您展示的最后一个单元测试。下一节建议您编写一些测试以确保您理解了所学的知识。
- en: Exercises
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: After reading this chapter, you may be ready to write tests for `book.video.boundary.YouTubeGateway`
    and `book.games.entity.Game` classes. In the first test, we suggest using a solitary-testing
    approach, and using Mockito for dependencies. For the second test, try using a
    sociable-testing approach.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，您可能已经准备好为 `book.video.boundary.YouTubeGateway` 和 `book.games.entity.Game`
    类编写测试。在第一个测试中，我们建议使用独立测试方法，并使用 Mockito 进行依赖项测试。对于第二个测试，尝试使用社交测试方法。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve started to look at how to apply unit test principles to a microservices
    architecture and use best strategies to write unit tests.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们开始探讨如何将单元测试原则应用于微服务架构，并使用最佳策略编写单元测试。
- en: It’s important to always try to develop unit tests that are as fast, robust,
    and readable as possible.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是尝试开发尽可能快、健壮和可读的单元测试是很重要的。
- en: You should know when it’s best to use test doubles, following the basic principles
    covered in the examples.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该知道在哪些情况下最好使用测试替身，遵循示例中介绍的基本原则。
- en: The JUnit, AssertJ, and Mockito technologies can be used together to create
    powerful unit tests.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit、AssertJ 和 Mockito 技术可以一起使用来创建强大的单元测试。
