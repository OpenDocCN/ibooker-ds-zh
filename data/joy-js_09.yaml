- en: 6 ECMAScript Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 ECMAScript 模块
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Evaluating programmatic module patterns
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估程序性模块模式
- en: Reviewing Immediately Invoked Function Expressions (IIFEs)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查立即执行的函数表达式（IIFEs）
- en: Introducing the ECMAScript Module syntax and the new .mjs extension
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 ECMAScript 模块语法和新的 .mjs 扩展
- en: Comparing dynamic and static module systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较动态和静态模块系统
- en: Using tree-shaking and dead-code elimination
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用树摇动和死代码消除
- en: '*Scope is like oxygen to a programmer. It’s everywhere. You often don’t even
    think about it. But when it gets polluted . . . you choke.*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*作用域对程序员来说就像氧气一样。它无处不在。你通常甚至都不会去想它。但是当它被污染时……你会窒息的。*'
- en: —David Herman (Effective JavaScript)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: —大卫·赫尔曼（有效 JavaScript）
- en: The world of JavaScript development is changing frantically, and the part of
    the language that has undergone the most change is its module system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 开发的世界正在疯狂变化，其中变化最大的部分是它的模块系统。
- en: In modern application development, we take the notion of modular programming
    for granted. The practice of breaking our applications into different files and
    then recombining them is already second nature to us. We don’t do these things
    to avoid getting blisters on our fingers from endless scrolling; we do them so
    that we can reason about and evolve different parts of our applications separately
    without fear of breaking others.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代应用程序开发中，我们理所当然地接受了模块编程的概念。将我们的应用程序分解为不同的文件然后重新组合的做法已经成为了我们的第二天性。我们不是为了避免手指因不断滚动而长水泡；我们这样做是为了可以分别推理和演进我们应用程序的不同部分，而不用担心会破坏其他部分。
- en: You may have heard the term cognitive load used to refer to the amount of information
    a person can hold at any point in time. Too much information—such as the state
    of all variables, the behavior of all components involved, and all the potential
    side effects—leads to cognitive overload. Computers can easily track millions
    of operations or changes of states per second, but humans can’t. A scientific
    fact is that humans can store around seven artifacts at the same time in short-term
    memory. (Think of a small cache.) This is why we need to subdivide our code into
    subprograms, modules, or functions so that we can examine each element in isolation
    and reduce the amount of information we take in at the same time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过认知负荷这个术语，用来指代一个人在任何时刻可以持有的信息量。过多的信息——例如所有变量的状态、所有组件的行为以及所有潜在副作用——会导致认知过载。计算机可以轻松地每秒跟踪数百万个操作或状态变化，但人类不能。一个科学事实是，人类可以在短期记忆中同时存储大约七个物品。（想想一个小缓存。）这就是为什么我们需要将我们的代码细分为子程序、模块或函数，这样我们就可以单独检查每个元素，并减少我们同时接受的信息量。
- en: As I said back in chapter 1, the days of modern JavaScript development are upon
    us. Every major programming language must have good support for modules, but until
    recently, JavaScript did not. In chapters 4 and 5, you learned about breaking
    complex code into functions and reassembling them with composition. That process
    was function/object-level modularization. This chapter covers modularization at
    the file level, using native JavaScript keywords.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在第 1 章所说的，现代 JavaScript 开发的时代已经到来。每种主要的编程语言都必须有良好的模块支持，但直到最近，JavaScript 并没有。在第
    4 章和第 5 章中，你学习了将复杂代码分解为函数，并通过组合重新组装的过程。这个过程是函数/对象级别的模块化。本章介绍了文件级别的模块化，使用原生 JavaScript
    关键字。
- en: 'We start with a brief overview of today’s landscape of module solutions and
    then move to a discussion of JavaScript’s new official standard: ECMAScript Modules
    (ESM), also known as ECMA262 Modules, which began as ECMAScript 2015 Modules.
    Unlike early module systems, ESM enhances the JavaScript syntax to use static
    dependency definitions, which has four significant benefits:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先简要概述了今天的模块解决方案的格局，然后转向讨论 JavaScript 的新官方标准：ECMAScript 模块（ESM），也称为 ECMA262
    模块，它始于 ECMAScript 2015 模块。与早期的模块系统不同，ESM 通过使用静态依赖定义增强了 JavaScript 语法，这有四个显著的好处：
- en: Improves the experience of sharing code across your applications
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高了你在应用程序之间共享代码的体验
- en: Makes tools such as static code analysis, dead-code elimination, and tree-shaking
    much more efficient
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使工具如静态代码分析、死代码消除和树摇动变得更加高效
- en: Unifies the module system for server as well as client, which solves the huge
    problem of requiring different module systems depending on the platform
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一了服务器和客户端的模块系统，解决了根据平台需要不同模块系统的大问题
- en: Optimizes the way in which compilers analyze code
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化了编译器分析代码的方式
- en: Note It’s important to mention that this book does not cover how to package
    JavaScript code or how to deliver it with package managers such as NPM and Yarn.
    Also, because there are many JavaScript compilers, I don’t cover any specific
    compiler optimizations related to ESM.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：重要的是要提到，这本书不涵盖如何打包 JavaScript 代码或如何使用 NPM 和 Yarn 等包管理器交付它。此外，由于存在许多 JavaScript
    编译器，我不涵盖任何与 ESM 相关的具体编译器优化。
- en: We’ll start by reviewing today’s JavaScript modules landscape so that you understand
    what problem ESM addresses and why we’re fortunate to have it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先回顾今天的 JavaScript 模块化景观，以便您了解 ESM 解决了什么问题以及为什么我们有幸拥有它。
- en: 6.1 Past state of affairs
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 过去的状况
- en: Modular programming has been a mainstream concept in other language communities
    for many years, but not for JavaScript. Even today, it’s challenging to manage
    dependencies and build code that can run uniformly across many environments. Keep
    in mind that JavaScript is in the unique position of supporting both server and
    client (browser) environments, which are very different in nature.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化编程在其他语言社区中已经是一个主流概念多年，但在 JavaScript 中并不是。即使今天，管理依赖关系并构建可以在许多环境中统一运行的代码仍然具有挑战性。记住，JavaScript
    处于一个独特的位置，支持服务器和客户端（浏览器）环境，这两种环境在本质上非常不同。
- en: If you’re developing client-side applications, it’s likely that you’ve already
    had to deal with some sophisticated build tool that could take all your independent
    scripts and merge them into a single bundle. At the end of the day, the application
    runs as one endless file to create the illusion of modularity. To understand the
    motivation behind ESM and why it’s so important, it helps to spend a little time
    understanding the current state of affairs of JavaScript and modules and how we
    got here.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在开发客户端应用程序，您可能已经不得不处理一些复杂的构建工具，这些工具可以将您所有的独立脚本合并成一个单一的包。最终，应用程序作为一个无休止的文件运行，以创造模块化的错觉。为了理解
    ESM 的动机以及为什么它如此重要，花点时间了解 JavaScript 和模块的当前状况以及我们是如何到达这里的，这会有所帮助。
- en: If you’ve been writing JavaScript code for some years, you probably remember
    that JavaScript faced a lot of pushback and criticism due to its lack of a proper
    module system. Without a doubt, this limitation caused the greatest amount of
    pain to web developers. Without modules, any decent-size codebase quickly entered
    a global clash of named variables and functions. This clash was magnified when
    multiple developers worked on the same application. You’d be surprised how many
    arrays named `arr`, functions named `fn`, and strings named `str` exist globally
    across hundreds of thousands of lines of code, all potentially colliding in unpredictable
    order. Something needed to be done urgently.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经编写 JavaScript 代码多年，您可能还记得 JavaScript 由于缺乏适当的模块系统而面临了大量的反对和批评。毫无疑问，这种限制给网络开发者带来了最大的痛苦。没有模块，任何相当规模的代码库很快就会陷入全局的命名变量和函数冲突。当多个开发者共同开发同一个应用程序时，这种冲突会加剧。您可能会惊讶地发现，在成千上万行代码中存在许多名为
    `arr` 的数组、名为 `fn` 的函数和名为 `str` 的字符串，它们在全球范围内都可能以不可预测的顺序发生冲突。需要紧急采取措施。
- en: Opinions on modules for JavaScript are heated and diverse. In the past, any
    attempt at normalizing it added yet another element of variability to the madness.
    Over time, out of necessity, different schools of thought for a module specification
    emerged. The most notable ones were Asynchronous Module Definition (AMD) and CommonJS
    (CJS). Both concepts were stepping stones to the (long overdue) development of
    the formal standard ECMAScript Modules (ESM) ([https://github.com/nodejs/ modules](https://github.com/nodejs/modules)).
    Figure 6.1 shows a brief approximate timeline of the evolution of the module system
    in JavaScript.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 JavaScript 模块的意见是热烈的且多样化的。在过去，任何试图规范它的尝试都给这种混乱增加了另一个变量。随着时间的推移，出于必要性，出现了关于模块规范的不同的思想流派。最显著的是异步模块定义
    (AMD) 和通用 JS (CJS)。这两个概念都是通向（长期期待）正式标准 ECMAScript 模块 (ESM) ([https://github.com/nodejs/modules](https://github.com/nodejs/modules))
    的垫脚石。图 6.1 展示了 JavaScript 模块系统演变的简要近似时间线。
- en: '![](../Images/6-1.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 6-1](../Images/6-1.png)'
- en: Figure 6.1 Overview of the evolution of JavaScript’s module system, from simple
    inline scripts in the early browser days to official ESM. All dates are approximate.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 JavaScript 模块系统的演变概述，从早期浏览器中的简单内联脚本到官方的 ESM。所有日期均为近似值。
- en: AMD and CJS had different design goals. The latter is synchronous and used in
    the server where there’s fast file I/O; the former is asynchronous and used in
    the browser, where access to files is slower and travels through the internet.
    Although the browser side was contested, AMD made the most progress by dramatically
    simplifying dependency management of large-scale, client-side JavaScript applications,
    especially when used in conjunction with the RequireJS ([https://requirejs.org](https://requirejs.org/))
    script loader library. AMD was one reason why the Single Page Apps (SPA) architecture
    was possible. An SPA contains not only layout, but also a good chunk of the business
    logic loaded into the browser. Combined with Web 2.0 technologies such as AJAX,
    entire apps were being put in browsers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: AMD和CJS有不同的设计目标。后者是同步的，用于文件I/O快速的服务器；前者是异步的，用于文件访问较慢的浏览器。尽管浏览器端存在争议，但AMD通过极大地简化大型、客户端JavaScript应用的依赖管理，尤其是在与RequireJS
    ([https://requirejs.org](https://requirejs.org/))脚本加载器库结合使用时，取得了最大的进展。AMD是单页应用（SPA）架构成为可能的原因之一。SPA不仅包含布局，还包含大量业务逻辑加载到浏览器中。结合Web
    2.0技术如AJAX，整个应用都被放入了浏览器中。
- en: Still, nothing had become standard. This lack of consensus drove the creation
    of yet another proposal that tried to unify and standardize module systems. The
    Universal Module Definition (UMD) came to the rescue, along with a module loader
    API called SystemJS ([https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs)),
    which works on client and server. Although reading through a UMD-built module
    is complex and convoluted (because it involves lots of conditional logic to support
    any module style and environment), this standard was a blessing because it allowed
    plugin and library authors to target a single format that could run on both client
    and server.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，仍然没有形成标准。这种缺乏共识推动了另一个提案的诞生，该提案试图统一和标准化模块系统。通用模块定义（UMD）应运而生，同时还有一个名为SystemJS的模块加载器API（[https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs)），它可以在客户端和服务器上运行。尽管阅读UMD构建的模块复杂且繁琐（因为它涉及大量的条件逻辑来支持任何模块风格和环境），但这一标准是一个福音，因为它允许插件和库作者针对一个可以在客户端和服务器上运行的单一格式。
- en: After many years of deliberation, ESM was the be-all and end-all of module systems
    for JavaScript. ESM is a platform-agnostic, standardized module system for JavaScript
    that works on both servers and browsers, eventually replacing CJS and all other
    module formats. Currently, ESM is the official standard; all platform vendors
    are starting to adopt it and all library authors are beginning to use it. Adoption
    will be a slow process and one that requires all of us to help.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 经过多年的深思熟虑，ESM成为了JavaScript模块系统的终极选择。ESM是一个平台无关的、标准化的JavaScript模块系统，它既适用于服务器也适用于浏览器，最终取代了CJS以及其他所有模块格式。目前，ESM是官方标准；所有平台供应商都开始采用它，所有库作者也开始使用它。这一过程将是一个缓慢的过程，需要我们大家共同努力。
- en: Before any of these formal proposals existed, JavaScript developers were hard
    at work creating amazing websites. So how were we modularizing applications back
    then, and what was considered a module? To get around making everything global
    scripts, developers invented clever patterns and naming schemes, and even used
    objects and the scope inside functions as pseudo-namespaces to avoid name collisions
    in the global context. We’ll explore these patterns in section 6.2.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些正式提案出现之前，JavaScript开发者们正努力创建令人惊叹的网站。那么我们当时是如何模块化应用的，什么被认为是模块呢？为了避免将所有内容都做成全局脚本，开发者们发明了巧妙的模式和命名方案，甚至使用对象和函数内部的作用域作为伪命名空间来避免全局上下文中的名称冲突。我们将在第6.2节中探讨这些模式。
- en: 6.2 Module patterns
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 模块模式
- en: We have multiple ways to approach modularity in JavaScript even without module
    specifications. Before JavaScript had any module system, all the code lived in
    the global space, which proved to be exceptionally hard to maintain. Code was
    separated into different script files. Developers had to get creative to organize
    their code and provide some means of abstraction over global data to create scopes
    that avoid name clashes with other running scripts—and to try to make it back
    home for dinner every day. JavaScript’s fundamental scoping mechanism has always
    been and will always be function scope, so it made complete sense to rely on functions
    to create isolated scopes of code where you could encapsulate data and behavior.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有模块规范，我们也有多种方法在JavaScript中实现模块化。在JavaScript有任何模块系统之前，所有代码都生活在全局空间中，这证明非常难以维护。代码被分成了不同的脚本文件。开发者必须发挥创意来组织他们的代码，并提供一些抽象全局数据的方法，以创建避免与其他运行脚本发生名称冲突的作用域——并且每天都要设法回家吃晚饭。JavaScript的基本作用域机制一直是，并将始终是函数作用域，因此依赖函数来创建隔离的代码作用域，在那里你可以封装数据和行为，是完全合理的。
- en: 'In this section, we’ll review some of the ad hoc modular programming patterns
    that arose out of sheer necessity before modules became a core part of the language:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾一些在模块成为语言核心部分之前，由于纯粹的需要而出现的临时模块化编程模式：
- en: Object namespaces
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象命名空间
- en: Immediately Invoked Function Expressions (IIFEs)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即调用的函数表达式（IIFEs）
- en: IIFE mixins
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IIFE混合
- en: Factory functions
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂函数
- en: These patterns are worth reviewing because they still work today and are great
    for small applications and scripts, especially if you’re targeting any of the
    older browsers, such as Internet Explorer 11.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式值得回顾，因为它们至今仍然有效，非常适合小型应用程序和脚本，尤其是如果你针对的是任何旧浏览器，如Internet Explorer 11。
- en: 6.2.1 Object namespaces
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 对象命名空间
- en: Object namespaces grew in the browser out of the need to scale out simple scripts
    into full-fledged applications before tools such as AMD existed. Because browsers
    don’t do any dependency management of their own, the order in which you included
    your files (via `<script` `/>` tags) was important.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对象命名空间是在工具如AMD存在之前，为了将简单的脚本扩展成完整的应用程序而出现的。因为浏览器本身不进行任何依赖管理，所以你包含文件（通过`<script`
    `/>`标签）的顺序很重要。
- en: Developers got into the habit of first loading any third-party libraries (jQuery,
    Prototype, and others) that they needed and then loading the application-specific
    code that depended on those libraries. The main issue was that with the exception
    of iframes and web workers, scripts ran within the same global browser realm.
    (I’ll discuss realms briefly in chapter 7.) Without property encapsulation, a
    global variable, a class, or a function in one file would collide with that of
    the same name loaded from a different file. These issues were hard to debug, especially
    because browsers gave no signs or warnings of any kind when collisions happened.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者养成了这样的习惯：首先加载他们需要的任何第三方库（如jQuery、Prototype等），然后加载依赖于这些库的应用特定代码。主要问题是，除了iframe和web
    workers之外，脚本都在同一个全局浏览器域中运行。（我将在第7章中简要讨论域。）没有属性封装，一个文件中的全局变量、类或函数会与从不同文件加载的相同名称的变量冲突。这些问题很难调试，尤其是在发生冲突时，浏览器没有给出任何提示或警告。
- en: NOTE Now you can load asynchronously by using the `async` HTML 5 attribute of
    the `script` tag, which makes this problem even worse.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：现在你可以通过使用`script`标签的`async` HTML 5属性来异步加载，这使得这个问题变得更糟。
- en: One way to get around this problem was to create artificial namespaces under
    the global object, using object literals to group your code and identify variables
    uniquely. In fact, the now-discontinued Yahoo! User Interface (YUI) library for
    building web applications used this pattern extensively. A class called `Transaction`,
    for example, could be defined in many projects and libraries because it applied
    to myriad domains. To avoid errors when declaring this name multiple times, you
    needed to define `Transaction` canonically. For Node.js, this definition could
    look something like the next listing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是在全局对象下创建人工命名空间，使用对象字面量来分组你的代码并唯一标识变量。实际上，现在已停用的Yahoo!用户界面（YUI）库广泛使用了这种模式。例如，一个名为`Transaction`的类可以在许多项目和库中定义，因为它适用于无数领域。为了避免在多次声明此名称时出错，你需要规范地定义`Transaction`。对于Node.js，这个定义可能看起来像下面的列表。
- en: Listing 6.1 Defining `Transaction` object with a global object namespace
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 使用全局对象命名空间定义`Transaction`对象
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ In the browser, you use window instead of global.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在浏览器中，你使用 window 而不是 global。
- en: NOTE Remember that `global` is the implicit global object inside a Node.js file
    or module, analogous to the `window` object in browsers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：记住，在 Node.js 文件或模块内部，`global` 是隐含的全局对象，类似于浏览器中的 `window` 对象。
- en: You saw the `Transaction` constructor function in chapter 2, and I’ll repeat
    it in the next listing, now defined under some arbitrary object namespace, which
    I call `BlockchainApp`. The properties of this object could more or less match
    the static directory structure of your application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第二章中看到了 `Transaction` 构造函数，我将在下一个列表中重复它，现在它定义在某个任意的对象命名空间下，我称之为 `BlockchainApp`。这个对象的所有属性可以或多或少地匹配你应用程序的静态目录结构。
- en: Listing 6.2 Using an object namespace
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 使用对象命名空间
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Defines the BlockchainApp object if it doesn’t exist by querying global
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果不存在，通过查询 global 定义 BlockchainApp 对象
- en: ❷ Defines a new (nested) object namespace called domain inside BlockchainApp
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在 BlockchainApp 中定义了一个新的（嵌套）对象命名空间，称为 domain
- en: ❸ The pattern of using a function that is immediately invoked is called an IIFE
    (discussed in section 6.2.2).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用立即调用的函数模式称为 IIFE（在第 6.2.2 节中讨论）。
- en: ❹ Private variables and/or privileged functions encapsulated inside the function’s
    scope
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 函数作用域内封装的私有变量和/或特权函数
- en: ❺ Public variables and/or functions exposed to the caller
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 公开变量和/或函数暴露给调用者
- en: Alternatively, you can use an inline class expression (see the next listing).
    Classes are essentially functions, so this syntax should not surprise you.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用内联类表达式（见下一个列表）。类本质上就是函数，所以这种语法不应该让你感到惊讶。
- en: Listing 6.3 Defining a class expression in an object namespace
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 在对象命名空间中定义类表达式
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Defines a new Transaction class within the BlockchainApp.domain namespace,
    using a class expression
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用类表达式在 BlockchainApp.domain 命名空间内定义一个新的 Transaction 类
- en: 'With this alternative, you can instantiate a new transaction by always specifying
    the canonical path to the class expression, which is meant to lessen the possibility
    of any collisions from, say, some third-party banking library you decided to use:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个替代方案，你可以通过始终指定类表达式的规范路径来实例化一个新的交易，这旨在减少任何冲突的可能性，比如你决定使用的第三方银行库：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'NOTE Another common technique was to use your company’s reverse URL notation.
    If you worked at MyCompany, the notation would look something like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：另一种常见的技术是使用你公司的反向 URL 表示法。如果你在 MyCompany 工作，表示法可能看起来像这样：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Classes offer great support for private data, but before classes, the most popular
    pattern for encapsulating state was the IIFE.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 类提供了对私有数据的极大支持，但在类出现之前，封装状态最流行的模式是 IIFE。
- en: 6.2.2 Immediately Invoked Function Expressions (IIFEs)
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 立即调用的函数表达式 (IIFEs)
- en: Immediately Invoked Function Expressions (IIFEs), which you may already know
    as the Module pattern, take advantage of JavaScript’s function scope to house
    variables and functions and provide encapsulation from the outside world. As you’re
    probably aware, the function is “immediately invoked” because the unnamed function
    (in parentheses) is evaluated at the end, giving you the opportunity to expose
    what you want and hide what you don’t, as with classes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 立即调用的函数表达式 (IIFEs)，你可能已经知道它是模块模式，利用 JavaScript 的函数作用域来容纳变量和函数，并提供对外部世界的封装。正如你可能已经知道的，函数是“立即调用的”，因为未命名的函数（括号内）在最后被评估，这给了你机会暴露你想要的，隐藏你不想要的，就像类一样。
- en: Listing 6.4 demonstrates how you can create a `Transaction` IIFE as an object
    namespace without leaking any private data. In this code snippet, all variable
    declarations (regardless of scope modifier `var`, `const`, or `let`) and functions
    (such as `calculateHash`) exist and are visible only from within this surrounding
    function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 展示了如何创建一个不泄露任何私有数据的 `Transaction` IIFE 作为对象命名空间。在这个代码片段中，所有变量声明（无论作用域修饰符是
    `var`、`const` 还是 `let`）和函数（如 `calculateHash`）都存在，并且只在这个周围函数内部可见。
- en: Listing 6.4 Using an IIFE
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 使用 IIFE
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Private properties defined in the module’s scope
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在模块作用域中定义的私有属性
- en: ❷ Creates the nested domain namespace
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建嵌套的 domain 命名空间
- en: ❸ Public Transaction class
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 公开的 Transaction 类
- en: ❹ Has access to the calculateHash private method defined later
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 可以访问稍后定义的 `calculateHash` 私有方法
- en: ❺ Private method. Function definitions automatically get hoisted to the top
    of the surrounding function scope.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 私有方法。函数定义自动提升到周围函数作用域的顶部。
- en: ❻ Checks whether Blockchain exists globally and if necessary creates global.BlockchainApp
    as an empty object namespace to use
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 检查全局是否存在Blockchain，如果需要，则创建空的 `global.BlockchainApp` 对象命名空间以使用
- en: 'This function executes immediately upon declaration, so `Transaction` is created
    on the spot. You can instantiate it as before:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在声明时立即执行，因此 `Transaction` 是即时创建的。你可以像以前一样实例化它：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: IIFEs were among the most popular patterns before ECMAScript 2015 classes and
    still continue to be used today. In fact, many developers and JavaScript purists
    prefer them to classes. It’s worth pointing out that placing variables and objects
    in a local scope makes the property resolution mechanism (discussed in chapter
    2) faster, because JavaScript always checks the local scope before the global.
    Finally, when used in conjunction with object namespaces, IIFEs allow you to organize
    your modules in different namespaces, which you’ll need to do in a medium-sized
    application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript 2015类出现之前，IIFEs是最受欢迎的模式之一，并且至今仍在使用。事实上，许多开发者和JavaScript纯主义者更喜欢它们而不是类。值得注意的是，将变量和对象放在局部作用域中可以使属性解析机制（在第2章中讨论）更快，因为JavaScript总是先检查局部作用域，然后才是全局作用域。最后，当与对象命名空间结合使用时，IIFEs允许你在不同的命名空间中组织你的模块，这在中等规模的应用程序中是必须的。
- en: Functions are versatile, to the point where you can augment their context to
    securely define mixins in your domain. Because we explored mixins in chapter 3,
    section 6.2.3 explores how these legacy solutions integrate with them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是多才多艺的，以至于你可以增强它们的上下文，以安全地在你的领域中定义混合。因为我们已经在第3章的第6.2.3节中探讨了混合，第6.2.4节将探讨这些遗留解决方案如何与它们集成。
- en: 6.2.3 IIFE mixins
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 IIFE混合
- en: Remember the mixin objects we discussed and defined in chapters 3 and 4? We
    can also use IIFEs to implement `HasHash`. To do so, we can take advantage of
    JavaScript’s context-aware function operators `Function#call` or `Function#apply`
    to dynamically set the object context to be extended (referred to via `this`)
    at the call site. The enhancement process is enclosed in the function, adequately
    walled off from the rest of the code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在第3章和第4章讨论和定义的混合对象吗？我们也可以使用立即执行函数表达式（IIFEs）来实现 `HasHash`。为此，我们可以利用JavaScript的上下文感知函数操作符
    `Function#call` 或 `Function#apply` 来动态设置对象上下文，以便在调用位置扩展（通过 `this` 引用）。增强过程被封装在函数中，与其他代码部分充分隔离。
- en: Listing 6.4 shows a rehash (no pun intended) of the `HasHash` mixin you learned
    about in chapter 4\. Similar to the previous techniques, we use a function to
    create a private boundary around the code we want to modularize. In listing 6.5,
    the use of an arrow function notation is a lot more intentional. `calculateHash`
    is an arrow function so that `this` refers to the augmented object, which is the
    context object or environment passed to `HasHash.call`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.4展示了与第4章中学习的 `HasHash` 混合的重新哈希（无意中用了双关语）。与先前的技术类似，我们使用一个函数来创建一个私有边界，围绕我们想要模块化的代码。在列表6.5中，使用箭头函数符号是非常有意的。"calculateHash"
    是一个箭头函数，这样 `this` 就指向增强的对象，即传递给 `HasHash.call` 的上下文对象或环境。
- en: NOTE As you know, arrow functions don’t provide their own `this` binding; they
    borrow `this` from their surrounding lexical context.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：正如你所知，箭头函数不提供自己的 `this` 绑定；它们从其周围的词法上下文中借用 `this`。
- en: '`HasHash` accepts a set of keys that identify the properties to use during
    the hashing process. The last part of the next listing shows how to augment the
    `Transaction` and `Block` classes created under the global `BlockchainApp` namespace.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`HasHash` 接受一组键，这些键用于在哈希过程中识别要使用的属性。下一列表的最后一部分展示了如何增强在全局 `BlockchainApp` 命名空间下创建的
    `Transaction` 和 `Block` 类。'
- en: Listing 6.5 The `HasHash` mixin using an IIFE
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5 使用IIFE的 `HasHash` 混合
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ this maps to the object’s prototype and adds the calculateHash method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这映射到对象的原型并添加了 calculateHash 方法。
- en: ❷ The hash of each type of object includes a different set of keys.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每种类型的对象的哈希值包含一组不同的键。
- en: 6.2.4 Factory functions
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.4 工厂函数
- en: 'A factory function is any function that always returns a new object. You saw
    an example of this pattern in the implementation of `Money` in chapter 4\. Creating
    objects via factories has two important benefits:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂函数是任何总是返回新对象的函数。你在第4章中 `Money` 的实现中看到了这个模式的例子。通过工厂创建对象有两个重要的好处：
- en: You can skip using the `new` keyword during instantiation.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实例化时，你可以跳过使用 `new` 关键字。
- en: You don’t have to rely on `this` to access instance data. Instead, you can use
    the closure formed around the object to achieve data privacy.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不必依赖 `this` 来访问实例数据。相反，你可以使用围绕对象形成的闭包来实现数据隐私。
- en: As another example, let’s introduce a new object to our blockchain application.
    `BitcoinService` handles the interaction of multiple pieces of the blockchain
    domain with tasks such as transferring funds and mining transactions. Services
    are typically stateless objects that bring together business logic orchestrating
    the job of multiple entities of your domain. Because service objects don’t transport
    any data, being stateless, we don’t need to worry about making them immutable.
    Listing 6.6 shows the shape of the `BitcoinService` with a factory function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，让我们向我们的区块链应用程序中引入一个新的对象。`BitcoinService` 处理区块链领域的多个部分之间的交互，例如转账和挖掘交易。服务通常是无状态的对象，将业务逻辑组织起来，协调您领域多个实体的工作。由于服务对象不携带任何数据，是无状态的，所以我们不需要担心使它们不可变。列表
    6.6 展示了使用工厂函数的 `BitcoinService` 的形状。
- en: Listing 6.6 `BitcoinService` object constructed via a factory function
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 通过工厂函数构建的 `BitcoinService` 对象
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Both ledger and network become part of the returning object’s closure and
    are used by all functions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 账本和网络都成为返回对象的闭包的一部分，并被所有函数使用。
- en: ❷ Mines a new block into the chain. The body of this function is shown in chapter
    8.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将新块挖掘到链中。该函数的正文在第 8 章中展示。
- en: ❸ Mines transactions into a new block
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将交易挖掘到新块中
- en: ❹ Transfers funds between two users (digital wallets)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在两个用户（数字钱包）之间转账
- en: ❺ Serializes a ledger into a string buffer of JSON objects separated by the
    provided delimiter
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将账本序列化为由提供的分隔符分隔的 JSON 对象字符串缓冲区
- en: 'You can obtain a new service object and use it like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以获取一个新的服务对象并像这样使用它：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the factory function approach, private data (such as `network`) exists
    only within the function’s scope, as with an IIFE. Accessing private data is always
    possible from within the new object API because it closes over that data at time
    of definition. In addition, not having to rely on `this` allows us to pass service
    methods around as higher-order functions without having to worry about any `this`
    bindings. Consider the `transferFunds` API, which has the following signature:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂函数方法，私有数据（如 `network`）仅存在于函数的作用域内，就像 IIFE 一样。由于在定义时封闭了该数据，因此始终可以从新对象 API
    内部访问私有数据。此外，不需要依赖 `this` 允许我们将服务方法作为高阶函数传递，而无需担心任何 `this` 绑定。考虑以下 `transferFunds`
    API，它具有以下签名：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Suppose that you want to run a batch of transfers, all with the same default
    transfer fee:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想运行一批转账，所有转账都具有相同的默认转账费用：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can extract the method directly from the object as a function, using destructuring
    assignment, and use that method as the batch operation, as shown next.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接从对象中提取方法作为函数，使用解构赋值，并将该方法用作批处理操作，如下所示。
- en: Listing 6.7 Using an extracted form of `transferFunds` as a callback function
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 使用 `transferFunds` 的提取形式作为回调函数
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Passing the service method as a higher-order function. All closed-over data
    is still available and accessible via the method’s closure.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将服务方法作为高阶函数传递。所有封闭的数据仍然可以通过方法的作用域访问和获取。
- en: If `BitcoinService` had been defined as part of a class design, you would have
    been forced to set the context object explicitly, which is not straightforward,
    using `Function#bind`
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `BitcoinService` 被定义为类设计的一部分，您将被迫显式设置上下文对象，这并不直接，使用 `Function#bind`。
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'or the new binding operator (chapter 5):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 或者新的绑定运算符（第 5 章）：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Overall, the four techniques—object namespaces, IIFEs, IIFE mixins, and factory
    functions—have a graceful, simple elegance because they use a subset of JavaScript’s
    minimal canonical language. Although these patterns are still predominant in industry,
    the downside is that we are responsible for making sure that all the modules are
    defined properly and have the proper level of encapsulation and exposure. A good
    module system should handle these tasks for us.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这四种技术——对象命名空间、IIFEs、IIFE 混合和工厂函数——因其使用 JavaScript 最小规范语言的子集而具有优雅、简单的美感。尽管这些模式在行业中仍然很普遍，但缺点是我们需要确保所有模块都正确定义，并且具有适当的封装和暴露级别。一个好的模块系统应该为我们处理这些任务。
- en: In section 6.3, we go from programmatic patterns to language-level module systems.
    At a high level, these systems can be classified as static or dynamic. It’s important
    to understand the difference because ESM is different from all others due to its
    static syntax.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 6.3 节中，我们从程序性模式转向语言级别的模块系统。从高层次来看，这些系统可以分为静态或动态。了解这些差异很重要，因为 ESM 由于其静态语法而与其他所有系统不同。
- en: 6.3 Static vs. dynamic module systems
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 静态与动态模块系统
- en: A dynamic module system is one in which the management of dependencies and the
    specification of what a module exposes and consumes is done programmatically.
    This task involves writing the code yourself or using a third-party module loader.
    The techniques discussed in section 6.2 fall into this category, so the specification
    and definition of a module (what it exposes and what it hides) are created in
    memory when the code runs. You can do certain tricks with dynamic modules, such
    as enabling conditional access to include modules or parts of a module. Examples
    include the CommonJS APIs, the AMD-compatible RequireJS library, the SystemJS
    library, and Angular’s dependency injection mechanism.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 动态模块系统是一种在程序中管理依赖关系和指定模块暴露和消耗的内容的系统。这项任务涉及自己编写代码或使用第三方模块加载器。第6.2节中讨论的技术属于这一类别，因此模块的规范和定义（它暴露什么以及它隐藏什么）是在代码运行时在内存中创建的。你可以对动态模块做一些技巧，例如启用条件访问以包含模块或模块的部分。例如，包括CommonJS
    API、AMD兼容的RequireJS库、SystemJS库和Angular的依赖注入机制。
- en: Dynamic modules are quite different from a static format such as the new ESM.
    A static module system, on the other hand, defines the module’s contracts by using
    native language syntax—specifically, the keywords `import` and `export`. This
    difference is important to understand. For starters, JavaScript has never had
    static module definitions, which makes them uncharted territory for most developers.
    Also, static definitions have certain advantages; they allow the JavaScript runtime
    to prefetch or preload modules and allow you to build tools to optimize the package
    size of your application by removing code that will never execute.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 动态模块与新的ESM等静态格式有很大不同。另一方面，静态模块系统通过使用原生语言语法（特别是`import`和`export`关键字）来定义模块的合约。这种差异非常重要，需要理解。首先，JavaScript从未有过静态模块定义，这使得它们对于大多数开发者来说是一片未知领域。此外，静态定义具有某些优势；它们允许JavaScript运行时预取或预加载模块，并允许你通过删除永远不会执行的代码来构建工具以优化应用程序的包大小。
- en: Table 6.1 shows loading the `Transaction` class via the methods discussed in
    section 6.2\. The most obvious difference is that dynamic module systems use the
    usual JavaScript functions, whereas static systems use `import` and `export`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1展示了通过第6.2节中讨论的方法加载`Transaction`类。最明显的区别是动态模块系统使用常规的JavaScript函数，而静态系统使用`import`和`export`。
- en: Table 6.1 Loading the `Transaction` class with different module systems *(continued)*
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 使用不同模块系统加载`Transaction`类 *(继续)*
- en: '| System | Type | Example |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 系统 | 类型 | 示例 |'
- en: '| CommonJS | Dynamic | `const Transaction =``require(''./domain/Transaction.js'');`
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| CommonJS | 动态 | `const Transaction = require(''./domain/Transaction.js'');`
    |'
- en: '| RequireJS | Dynamic |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| RequireJS | 动态 |'
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| ESM | Static | `import Transaction from ''./domain/Transaction.js'';` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| ESM | 静态 | `import Transaction from ''./domain/Transaction.js'';` |'
- en: 'How each loading call works is not important right now; what’s important is
    that you see the difference in the syntax used. With ESM, instead of function
    calls that traverse the file system to load new code modules, you use an `import`
    statement that abstracts this process. The caveat is that in static systems, `import`
    statements must appear at the top of the file. This requirement also exists in
    most other languages and should not be viewed as a limitation, for good reason:
    making these statements static and clearly defined at the top helps compilers
    and tools map the structure of the application ahead of time. Also, you can run
    tools that perform better static-code analysis, dead-code elimination, and even
    tree-shaking, which I’ll cover briefly in section 6.5.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个加载调用的工作原理现在并不重要；重要的是你看到了所使用的语法的差异。在ESM中，你使用一个`import`语句来抽象这个过程，而不是通过函数调用遍历文件系统来加载新的代码模块。需要注意的是，在静态系统中，`import`语句必须出现在文件顶部。这一要求也存在于大多数其他语言中，不应被视为限制，原因如下：将这些语句静态化并在顶部清晰地定义有助于编译器和工具提前映射应用程序的结构。此外，你可以运行执行更好的静态代码分析、死代码消除甚至摇树优化（tree-shaking）的工具，这些内容我将在第6.5节中简要介绍。
- en: 'Another noticeable difference in a static module system is the type of bindings
    used. In CJS, modules are plain object references. Importing an object via the
    `require` function is no different from obtaining an object from any other function
    call. The shape of the object is given by the properties assigned to `module.exports`
    inside the module file. Here’s how you would import `Validation` (created in chapter
    5) by using CJS:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态模块系统中，另一个明显的差异是使用的绑定类型。在 CJS 中，模块是普通对象引用。通过 `require` 函数导入对象与从任何其他函数调用中获取对象没有区别。对象的形状由模块文件中
    `module.exports` 分配的属性决定。以下是如何使用 CJS 导入第 5 章中创建的 `Validation` 的示例：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A more common example is importing from Node.js’s filesystem `fs` built-in
    module:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更常见的例子是从 Node.js 的 filesystem `fs` 内置模块导入：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Conversely, ESM modules take advantage of a more native and declarative syntax.
    Access to the API still looks somewhat like regular objects, but only for consistency
    with the language’s mental model and to piggyback on the success of CJS’s compact
    approach. Here’s the preceding example with ESM:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，ESM 模块利用了更原生和声明性的语法。对 API 的访问看起来仍然有些像常规对象，但这只是为了与语言的思维模型保持一致，并利用 CJS 紧凑方法的成功。以下是用
    ESM 重写的先前的示例：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On the exterior, these approaches look and feel the same, but there’s a subtle
    difference: ESM uses immutable, live code bindings, not a regular, mutable copy
    of an object. The next listing shows a simple fee calculator CJS module to illustrate
    this difference.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从外观上看，这些方法看起来和感觉相同，但有一个细微的差别：ESM 使用不可变的实时代码绑定，而不是对象的常规可变副本。下一列表展示了用于说明这种差异的简单费用计算器
    CJS 模块。
- en: Listing 6.8 calculator.js module defined with CJS
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.8 使用 CJS 定义的 calculator.js 模块
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Function is private to the module
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数是模块私有的
- en: Pay close attention to the result of each statement in the following listing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请密切注意以下列表中每个语句的结果。
- en: Listing 6.9 Using calculator.js as a CJS module
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.9 将 calculator.js 作为 CJS 模块使用
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Resets the value of that variable of the locally defined variable
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 重置本地定义的变量的值
- en: ❷ Uses the original module’s value of 0.6
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用原始模块的 0.6 值
- en: ❸ Sets the value inside the module to 0.7
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将模块内的值设置为 0.7
- en: ❹ New feePercent is being used
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 正在使用新的 feePercent
- en: ❺ Original value preserved
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 保留原始值
- en: As you can see, reassigning `feePercent` to 0.7 changes your local exported
    copy of that reference, but not the reference inside the module, which is probably
    what you’d expect. With ESM, instead of a simple variable reference, the exported
    properties in ESM are connected (bound) to the properties inside the module. In
    the same vein, changing an exported binding within the module itself alters the
    binding used outside somewhere else; it’s bound both ways. There are many good
    uses for live bindings, but they can certainly lead to confusion. My recommendation
    is to try to avoid reassigning to exported references at all costs. Take a look
    at the code sample in the next listing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，将 `feePercent` 赋值为 0.7 改变了你本地导出的引用副本，但不会改变模块内部的引用，这可能是你预期的结果。在 ESM 中，导出的属性与模块内部的属性是连接（绑定）的。同样地，在模块内部更改导出的绑定也会改变外部某处的绑定；它是双向绑定的。实时绑定有很多好的用途，但它们确实可能导致混淆。我的建议是尽可能避免重新分配导出引用。请查看下一列表中的代码示例。
- en: Listing 6.10 Using calculator.js as an ESM module
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.10 将 calculator.js 作为 ESM 模块使用
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Throws an error stating that feePercent is read-only. Value is immutable from
    the client.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 抛出错误，指出 feePercent 是只读的。从客户端看，值是不可变的。
- en: ❷ Sets the value inside the module to 0.7 via an API
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过 API 将模块内的值设置为 0.7
- en: ❸ New feePercent is being used
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 正在使用新的 feePercent
- en: ❹ feePercent reflects the new live value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ feePercent 反映了新的实时值。
- en: As you can see, CJS and ESM have slightly different behavior. By design, most
    of the differences happen behind the scenes to make ESM adoption simpler. From
    a practical standpoint, ESM works similarly to CJS in that nearly every file is
    considered to be a module and every module has its own local scope, where you
    can safely store code and data (similar to the function scope created under an
    IIFE). If you’ve used CJS, ESM shouldn’t be a huge paradigm shift.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，CJS 和 ESM 有略微不同的行为。按照设计，大多数差异都是在幕后发生的，以简化 ESM 的采用。从实际的角度来看，ESM 的工作方式与
    CJS 类似，即几乎每个文件都被视为一个模块，每个模块都有自己的局部作用域，你可以在其中安全地存储代码和数据（类似于在 IIFE 下创建的函数作用域）。如果你已经使用过
    CJS，那么 ESM 不应该是一个巨大的范式转变。
- en: The future of JavaScript lies with ESM, which will eventually supersede any
    other module format and interoperate with existing ones. When this will happen
    is uncertain because Node.js (for example) needs to support CJS for some time
    to provide backward compatibility and allow the transition to go smoothly.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的未来在于 ESM，它最终将取代任何其他模块格式，并与现有的模块格式进行交互。何时会发生这一点尚不确定，因为 Node.js（例如）需要支持
    CJS 一段时间以提供向后兼容性，并使过渡顺利进行。
- en: Now, without further ado and the past behind us, let’s jump into ESM.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再拖延，也不必回顾过去，让我们直接进入 ESM。
- en: 6.4 ESM basics
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 ESM 基础
- en: In this section, you’ll learn about the fundamentals of ESM and how it’s used
    in code. Specifically, you’ll learn how to write module path identifiers, as well
    as the syntax needed to expose and consume modules by using variations of the
    `import` and `export` keywords.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解 ESM 的基础知识以及它在代码中的应用。具体来说，你将学习如何编写模块路径标识符，以及使用 `import` 和 `export`
    关键字的变体来暴露和消费模块所需的语法。
- en: ESM was designed in TC39 as a declarative module system with the goal of unifying
    dependency management for client and server. You can use ESM experimentally, starting
    with Node.js 12, by activating an experimental flag (`—experimental-modules`)
    and in Node.js 14 without a flag. Node.js treats a file with the extension .js
    or .mjs (section 6.4.4) as a module.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ESM 是在 TC39 中设计的，作为一个声明式模块系统，旨在统一客户端和服务器端的依赖关系管理。从 Node.js 12 开始，你可以通过激活一个实验性标志（`—experimental-modules`）来实验性地使用
    ESM，在 Node.js 14 中则无需标志。Node.js 将扩展名为 .js 或 .mjs（第 6.4.4 节）的文件视为模块。
- en: 'ESM standardizes on a single module format that draws experience from both
    CJS and AMD formats. This standardization is similar to what the Universal Module
    Definition ([https://github.com/umdjs/umd](https://github.com/umdjs/umd)) project
    set out to do many years ago, with some success. The problem is that none of these
    aforementioned module formats was ever fully standardized. In ESM, you get the
    best of both worlds: synchronous live binding statements as well as dynamic, asynchronous
    APIs. ESM also retains the terse syntax that CJS uses, which has withstood the
    test of time.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ESM 标准化了一个单一的模块格式，它吸取了 CJS 和 AMD 格式的经验。这种标准化类似于多年前 Universal Module Definition
    ([https://github.com/umdjs/umd](https://github.com/umdjs/umd)) 项目所设定的目标，并取得了一些成功。问题是上述所有提到的模块格式从未完全标准化。在
    ESM 中，你得到了两者的最佳之处：同步的实时绑定语句以及动态的异步 API。ESM 还保留了 CJS 所使用的简洁语法，这种语法经受住了时间的考验。
- en: Before we dive into this topic, one important thing to keep in mind is that
    ESM modules automatically enter in strict mode without you having to write it
    explicitly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨这个主题之前，有一点非常重要的事情需要记住，那就是 ESM 模块会自动进入严格模式，无需你显式地编写。
- en: A JavaScript module is nothing more than a file or directory that’s specified
    remotely (browser) or from the local file system (server) with some special semantics.
    ESM makes these specifiers compatible with both of these environments. Unfortunately,
    this constraint means that we will have a less-flexible module system on the server
    because we lose the extensionless specifiers that we’ve become accustomed to on
    the server side. On a positive note, ESM works toward a truly universal format,
    which helps in the long run with technologies such as Server-Side Rendering and
    building isomorphic applications.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 模块不过是一个文件或目录，它通过一些特殊的语义被指定为远程（浏览器）或本地文件系统（服务器）。ESM 使这些指定符与这两个环境兼容。不幸的是，这个限制意味着我们在服务器上会有一个不太灵活的模块系统，因为我们失去了在服务器端已经习惯的无扩展名指定符。从积极的一面来看，ESM
    致力于实现一个真正的通用格式，这有助于长期的技术，如服务器端渲染和构建同构应用程序。
- en: First, let’s go over the syntax for importing and exporting modules, starting
    with path specifiers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下导入和导出模块的语法，从路径指定符开始。
- en: 6.4.1 Path specifiers
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 路径指定符
- en: One important design goal of ESM is to remain compatible with the browser to
    truly guarantee one module format for all environments. Unlike in CJS, all module
    specifiers in ESM must be valid URIs, which means (sadly for Node.js) that there
    are no extensionless specifiers or directory modules. With the exception of bare
    specifiers (such as `'ramda'`), if a JavaScript module file has an extension,
    that extension must be explicitly added to the import specifier for it to resolve
    properly. (We were allowed to omit it before.) The following listing is more in
    line with how regular browser `<script>` includes work.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ESM（模块化系统）的一个重要设计目标是与浏览器保持兼容，以确保所有环境中都真正保证有一个模块格式。与CJS不同，ESM中的所有模块指定符都必须是有效的URI，这意味着（对于Node.js来说很遗憾）没有无扩展名的指定符或目录模块。除了裸指定符（例如`'ramda'`）之外，如果JavaScript模块文件有扩展名，那么必须显式地将该扩展名添加到导入指定符中，以便正确解析。（我们之前可以省略它。）以下列表更符合常规浏览器`<script>`包含的方式。
- en: Listing 6.11 Path specifiers using ESM
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.11 使用ESM的路径指定符
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Valid only in browser environments; not supported in Node.js
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅在浏览器环境中有效；在Node.js中不受支持
- en: NOTE It’s worth mentioning that in browsers, unlike Node.js, the file extension
    does not tell the browser how to parse a module as JavaScript code. It’s done
    with the proper MIME type (`text/javascript`) and shows whether the file was included
    with `<script` `type='module'>`, as in
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：值得指出的是，在浏览器中，与Node.js不同，文件扩展名不会告诉浏览器如何解析模块作为JavaScript代码。这是通过适当的MIME类型（`text/javascript`）来完成的，并且显示文件是否通过`<script
    type='module'>`包含，如下所示
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you’re using a relative path, you must start with `./` or `../`. The following
    code generates a module-not-found error (compatible with CJS). Neither of these
    snippets would pass as a valid URI:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用相对路径，你必须以`./`或`../`开头。以下代码生成一个模块未找到错误（与CJS兼容）。以下两个片段都不会作为有效的URI通过：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Another drawback is that you won’t be able to perform directory imports in Node.js
    as with CJS. In CJS, having an index.js or a proper package.json file in a folder
    lets you perform an import of the folder implicitly without appending the index.js
    part of the specifier. Because CJS was made for the server, it had smarts built
    in to detect and autocomplete the index.js bit, much as web servers serve index.html
    from a folder by default. Sadly, because the same rules need to apply to both
    client and server, this behavior did not carry over to ESM.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，你无法像在CJS中那样在Node.js中执行目录导入。在CJS中，一个文件夹中有一个`index.js`或适当的`package.json`文件，让你可以隐式地导入文件夹，而不需要附加指定符的`index.js`部分。由于CJS是为服务器制作的，它内置了智能来检测和自动完成`index.js`部分，就像默认情况下Web服务器从文件夹中提供`index.html`一样。遗憾的是，由于相同的规则需要适用于客户端和服务器，这种行为没有延续到ESM。
- en: 'In sections 6.4.2 and 6.4.3, we jump into the two main features of ESM: exporting
    and importing.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6.4.2节和第6.4.3节中，我们将探讨ESM的两个主要功能：导出和导入。
- en: 6.4.2 Exporting
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 导出
- en: The `export` statement is used to expose a module’s interface or API and is
    analogous to `module.exports` in CJS. A module is defined as a single file and
    may contain one or many classes and functions. By default, everything within a
    file is private. (Thinking of a module file as an empty IIFE may help.) You need
    to declare what to expose via the `export` keyword. For brevity, I won’t cover
    all the possible `export` combinations. For a full list of possible combinations,
    visit [http://mng.bz/YqeK](http://mng.bz/YqeK). The combinations described in
    the following sections are used in the sample application.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`export`语句用于暴露模块的接口或API，在CJS中相当于`module.exports`。一个模块被定义为单个文件，可能包含一个或多个类和函数。默认情况下，文件中的所有内容都是私有的。（将模块文件视为一个空的IIFE可能会有所帮助。）你需要通过`export`关键字声明要暴露的内容。为了简洁，我不会涵盖所有可能的`export`组合。有关所有可能组合的完整列表，请访问[http://mng.bz/YqeK](http://mng.bz/YqeK)。以下各节中描述的组合用于示例应用程序。'
- en: Single-valued (default)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 单值（默认）
- en: So far in the book, when showing parts of the domain classes, I’ve deliberately
    left out how they map to the filesystem—in other words, the `import` statement
    that was used to obtain the class. The general convention in exporting is for
    classes to become modules of their own. You have options. You can export a single
    class in a single step
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中展示领域类的一部分时，我故意省略了它们如何映射到文件系统——换句话说，就是使用`import`语句来获取类的语句。在导出方面，通常的做法是将类变成它们自己的模块。你有选择。你可以一步导出一个单个类
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'or in two steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 或者分两步：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Single-valued export is usually the preferred way of exporting code for others
    to consume. Before Node.js had native support for classes, a class was transpiled
    into its own IIFE function. Think about how data that lives outside the `export`
    declaration inside the module file is completely hidden from the callers. The
    semantics are similar to that of an IIFE, which is nice and consistent. You can
    imagine one big IIFE function in which the body is your entire module code, giving
    you the opportunity to declare variables, functions, or other classes accessible
    only to the module code itself. We used this technique in `HasHash` to declare
    top-level constants, for example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 单值导出通常是导出代码供他人消费的首选方式。在 Node.js 具有原生类支持之前，一个类会被转换成它自己的立即执行函数表达式（IIFE）函数。想想看，模块文件内部
    `export` 声明之外的数据对调用者来说是完全隐藏的。其语义与 IIFE 类似，既好又一致。你可以想象一个大的 IIFE 函数，其主体是整个模块代码，这给了你声明变量、函数或其他仅对模块代码本身可访问的类的机会。例如，我们在
    `HasHash` 中使用了这种技术来声明顶层常量：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using the `default` keyword allows you to export one piece of data. You could
    also export multiple values from a single module.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `default` 关键字允许你导出单个数据片段。你也可以从一个模块中导出多个值。
- en: Multivalue
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 多值
- en: 'A multivalue `export` is an elegant way to create utility modules. This is
    used for the validation functions in `Block` and `Transaction`. Because you’ve
    already seen these functions, I’ll show you the `export` syntax and omit the body
    of each method:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 多值 `export` 是创建实用模块的优雅方式。这在 `Block` 和 `Transaction` 中的验证函数中使用。因为你已经看到了这些函数，我将向你展示
    `export` 语法，并省略每个方法的主体：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'API modules based on multivalue exports of standalone functions have another
    great benefit: they push you into writing with purity in mind. Because you never
    know the context under which a function will execute, you can’t assume or rely
    on any shared or closed-over state. Moreover, instead of using a factory function,
    another way to create the `BitcoinService` object is to expose individual, pure
    functions that declare all the data they need up front as function arguments.
    Instead of inheriting `ledger` and `network` from the function’s closure, you
    need to make them actual arguments:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 standalone 函数多值导出的 API 模块有另一个巨大的好处：它们促使你以纯度为中心进行编写。因为你永远不知道函数将在什么上下文中执行，你不能假设或依赖任何共享或闭包状态。此外，除了使用工厂函数之外，创建
    `BitcoinService` 对象的另一种方式是暴露单个纯函数，这些函数在函数参数中提前声明它们所需的所有数据。你不需要从函数的闭包中继承 `ledger`
    和 `network`，你需要将它们作为实际参数：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Proxying
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 代理
- en: 'A module can export and bypass the bindings of another module, acting as a
    proxy. You can accomplish this task by using the `export` `...` `from` statement.
    In our case, we can use this statement to group all the individual domain modules
    (including `Block` and `Transaction`) in a single module file, called domain.js:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块可以导出并绕过另一个模块的绑定，充当代理。你可以通过使用 `export` `...` `from` 语句来完成这个任务。在我们的例子中，我们可以使用这个语句将所有单个域模块（包括
    `Block` 和 `Transaction`）组合在一个名为 domain.js 的单个模块文件中：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Unlike with `import`, you can `export` at any line of your module. No rules
    force the placement.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `import` 不同，你可以在模块的任何一行 `export`。没有规则强制放置位置。
- en: On the flip side, exported code is consumed by clients or other modules through
    the `import` statement.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，导出的代码是通过 `import` 语句由客户端或其他模块消费的。
- en: 6.4.3 Importing
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.3 导入
- en: To consume an API, you must import the desired functionality, which you can
    do as a whole or in pieces. You have many ways to import from a module and can
    find a complete reference guide at [http://mn.bz/Gx4R](http://mn.bz/Gx4R). The
    following sections describe some of the most common techniques.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消费一个 API，你必须导入所需的功能，你可以作为一个整体或部分进行导入。你有许多从模块中导入的方法，可以在 [http://mn.bz/Gx4R](http://mn.bz/Gx4R)
    找到完整的参考指南。以下部分描述了一些最常见的技术。
- en: Single-value import
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 单值导入
- en: To import a single object from a default `export`, you can use
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要从默认 `export` 中导入单个对象，你可以使用
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is the simplest case, but you can also request components of a module.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 simplest 的情况，但你也可以请求模块的组件。
- en: multivalue import
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 多值导入
- en: You can break out pieces of a single module. The next listing shows how to do
    a multivalue import.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以拆分单个模块的片段。下面的列表展示了如何进行多值导入。
- en: Listing 6.12 Multivalue import of validation.js
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.12 validation.js 的多值导入
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ The curly braces indicate that we’re reaching into the module.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 大括号表示我们正在进入模块。
- en: 'Notice that although the code snippet in listing 6.12 suggests that destructuring
    is occurring, as used with CJS, it’s not. Following are the main differences:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管列表 6.12 中的代码片段表明正在发生解构，但与 CJS 一起使用时并非如此。以下是一些主要区别：
- en: Imports are always connected with their exports (live bindings), whereas destructuring
    creates a local copy of the object. Because CJS imports a copy of the object,
    a destructure is a copy of a copy.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入始终与其导出（活绑定）相关联，而解构则创建对象的本地副本。因为 CJS 导入对象的副本，所以解构是副本的副本。
- en: 'You can’t perform a nested destructure within an `import` statement. The following
    code won’t work:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在 `import` 语句内部进行嵌套解构。以下代码将无法工作：
- en: '[PRE33]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The syntax for property renaming (aliasing) is different, as shown in the next
    listing.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性重命名（别名）的语法不同，如下一列表所示。
- en: Listing 6.13 Property renaming in CJS and ESM
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.13 CJS 和 ESM 中的属性重命名
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '❶ CJS: Renames foo to newFoo'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ CJS：将 foo 重命名为 newFoo
- en: '❷ ESM: Does not rename but creates an alias called newFoo pointing to the bound
    foo property'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ ESM：不重命名，但创建一个指向已绑定 foo 属性的别名 newFoo
- en: 'You can also compose a multivalued exported API into a single object namespace
    by using a wildcard (alias) import:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用通配符（别名）导入将多值导出 API 组合成单个对象命名空间：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using a package manager (NPM)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包管理器（NPM）
- en: 'As with native modules, importing third-party modules with ESM is done via
    a bare path, with no path separators or extensions. As expected, the package name
    needs to match the directory name inside node_modules. Then the entry point or
    module to load is determined by the main property in its accompanying package.json.
    Here’s an example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与原生模块一样，使用 ESM 导入第三方模块是通过裸路径进行的，没有路径分隔符或扩展名。正如预期的那样，包名需要与 node_modules 内的目录名匹配。然后，通过其伴随的
    package.json 中的 main 属性确定入口点或要加载的模块。以下是一个示例：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Dynamic importing
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 动态导入
- en: If you’ve been coding in Node.js for a while, you’re probably used to loading
    modules conditionally with CJS. Unlike ESM, which requires dependencies to be
    declared at the beginning of the file, CJS allows you to `require` modules from
    anywhere. One use case where this happens a lot in the wild is the notion of using
    a module containing global settings or feature flags to roll out new code to your
    customers slowly. The following listing shows an example.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在 Node.js 中编码了一段时间，你可能已经习惯了使用 CJS 条件性地加载模块。与需要在文件开头声明依赖项的 ESM 不同，CJS 允许你从任何地方
    `require` 模块。在实际应用中，这种情况经常发生的一个用例是使用包含全局设置或功能标志的模块，以缓慢地向客户推出新代码。以下列表显示了一个示例。
- en: Listing 6.14 Loading modules dynamically with CJS
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.14 使用 CJS 动态加载模块
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Depending on the status of the global `USE_NEW_ALGORITHM` setting, the application
    may decide to use the traditional `compute_balance` module or begin using a new
    one. This technique looks handy, but the first time a library or file is required,
    the JavaScript runtime needs to interrupt its process to access the filesystem.
    Because modules are singleton, this situation would happen only the first time
    a library is loaded. Afterward, the modules are cached locally (a behavior that
    both ESM and CJS support). Similarly, the second `require` statement blocks the
    main thread to access the filesystem before caching the module.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 根据全局 `USE_NEW_ALGORITHM` 设置的状态，应用程序可能会决定使用传统的 `compute_balance` 模块或开始使用一个新的模块。这种技术看起来很方便，但第一次需要库或文件时，JavaScript
    运行时需要中断其进程以访问文件系统。因为模块是单例的，所以这种情况只会发生在第一次加载库时。之后，模块会在本地缓存（ESM 和 CJS 都支持这种行为）。同样，第二个
    `require` 语句在缓存模块之前会阻塞主线程访问文件系统。
- en: 'In the spirit of nonblocking code, filesystem access should be done asynchronously.
    The ESM specification corrects for this problem and offers a callable version
    of `import` that is asynchronous, based on promises, and aligned with loading
    code inside the browser. The `import` function fetches, instantiates, and evaluates
    all the requested module’s dependencies and returns a namespace object whose `default`
    property references the requested module’s (`export`) `default` API, as well as
    properties that match the module’s other exports. We’ll get back to asynchronous
    features of JavaScript in chapter 8, but I’ll show you how `import` works now
    as it pertains to the module system. Refactoring the code in listing 6.14 looks
    like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循非阻塞代码的精神，文件系统访问应该异步进行。ESM 规范纠正了这个问题，并提供了基于承诺的异步 `import` 版本，它与浏览器内部加载代码的方式保持一致。`import`
    函数获取、实例化和评估所有请求的模块的依赖项，并返回一个命名空间对象，其 `default` 属性引用请求模块的 (`export`) `default`
    API，以及与模块的其他导出匹配的属性。我们将在第 8 章回到 JavaScript 的异步特性，但现在我将向你展示 `import` 的工作原理，以及它与模块系统相关的内容。对列表
    6.14 中的代码进行重构看起来是这样的：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By the way, this code snippet uses a feature known as top-level-await, which
    is supported only in ESM. You’ll learn more about this feature in chapter 8\.
    The basic premise is that you can use `await` directly to trigger an asynchronous
    action (loading a script in this case) without having to write an `async` function
    explicitly.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这个代码片段使用了一个称为顶层等待（top-level-await）的功能，该功能仅在 ESM 中受支持。你将在第 8 章中了解更多关于这个功能的内容。基本前提是你可以直接使用
    `await` 来触发异步操作（在这种情况下是加载脚本），而无需显式编写 `async` 函数。
- en: 'Another important part of the ESM specification is the introduction of a new
    extension: .mjs.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ESM 规范的另一个重要部分是引入了一个新的扩展名：.mjs。
- en: 6.4.4 A new extension in town
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.4 新的扩展名
- en: 'To instruct Node.js to load modules by using ESM, you have two options:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要指导 Node.js 使用 ESM 加载模块，你有两种选择：
- en: You can set the `type` field of package.json to `"module"`. This option works
    by dynamically looking up the package.json nearest to your given .js file, starting
    with the current directory, followed by its parent, and so on. If JavaScript is
    unable to determine the type, CJS is used.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将 package.json 的 `type` 字段设置为 `"module"`。此选项通过动态查找离你提供的 .js 文件最近的 package.json
    文件来实现，从当前目录开始，然后是其父目录，依此类推。如果 JavaScript 无法确定类型，则使用 CJS。
- en: Use the new file extension (.mjs) to identify JavaScript module files. This
    extension will be helpful during the transitional period of moving to ESM. By
    the same token, .cjs files will force the use of CommonJS.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的文件扩展名 (.mjs) 来识别 JavaScript 模块文件。这个扩展名在过渡到 ESM 的过程中将非常有用。同样，.cjs 文件将强制使用
    CommonJS。
- en: Package and library authors are encouraged to provide a type field in their
    package.json files to make their code clearer and better documented. Also, modern
    browsers support `<script` `type='module'>` to match this new behavior.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励包和库的作者在他们的 package.json 文件中提供类型字段，以使他们的代码更清晰、文档更完善。此外，现代浏览器支持 `<script type='module'>`
    以匹配这一新行为。
- en: Although many people have deemed the .mjs extension to be unattractive, it has
    precedent. React uses .jsx to declare HTML components, for example, and we’ve
    all used .json as a convention to store plain-text JSON data. Browsers don’t pay
    much attention to the file extension; they care mostly about the MIME type (`text/javascript`
    for executable scripts or `application/json` for data imports). I view .mjs as
    being a transitional route before JavaScript applications catch up to ESM; then
    .js will prevail.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多人认为 .mjs 扩展名不够吸引人，但它有先例。例如，React 使用 .jsx 来声明 HTML 组件，我们也都使用 .json 作为存储纯文本
    JSON 数据的约定。浏览器不太关注文件扩展名；它们主要关注 MIME 类型（可执行脚本的 `text/javascript` 或数据导入的 `application/json`）。我认为
    .mjs 是在 JavaScript 应用程序赶上 ESM 之前的过渡路线；然后 .js 将占主导地位。
- en: 'Nevertheless, here are some of the concrete benefits of using .mjs:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，以下是使用 .mjs 的具体好处：
- en: There are no problems with backward compatibility. Because the extension is
    new, enforcing certain properties from the start (such as mandatory strict mode
    on all modules) is simple.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向后兼容性没有问题。因为扩展是新的，所以从一开始就强制实施某些属性（例如，在所有模块上强制使用严格模式）是简单的。
- en: The extension helps with deprecating non-browser-friendly module environment
    variables such as `__dirname`, `__filename`, `module`, and `exports`. Also, you
    will not be able to use `require` on files with an .mjs extension, or vice versa.
    (Use `import` on .cjs files.)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该扩展有助于弃用非浏览器友好的模块环境变量，例如`__dirname`、`__filename`、`module`和`exports`。此外，你将无法在具有.mjs扩展名的文件上使用`require`，反之亦然。（在.cjs文件上使用`import`。）
- en: The new extension communicates purpose, which is a clear departure from the
    existing module formats (AMD, CJS, and UMD).
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的扩展功能传达了目的性，这与现有的模块格式（AMD、CJS和UMD）有明显的区别。
- en: No additional instructions or parsing (so no performance penalty) are needed
    for the compiler to treat and prepare/optimize a JavaScript file for modules.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器不需要额外的指令或解析（因此没有性能损失）来处理和准备/优化JavaScript文件以供模块使用。
- en: There is special processing of module files. You can now use module-scoped metaproperties
    such as `import.meta`, for example. Currently, this object contains only the URL
    or full path of the module, but more functionality can be added later. The `url`
    property will supersede the global `__dirname` and `__filename` globals. The example
    in the next listing uses `import.meta`.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对模块文件有特殊的处理。现在你可以使用模块作用域的元属性，例如`import.meta`。目前，该对象只包含模块的URL或完整路径，但以后可以添加更多功能。`url`属性将取代全局的`__dirname`和`__filename`全局变量。下一列表中的示例使用了`import.meta`。
- en: Listing 6.15 Printing the contents of `import.meta`
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表6.15 打印`import.meta`的内容
- en: '[PRE39]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Inside Transaction.js
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❶ 在Transaction.js内部
- en: Tooling experience is improved. IDEs can be more intuitive when it comes to
    things like refactoring, syntax highlighting, code completion, and visualization.
    Static code analyzers and linters can give you better heuristics and guidance.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具体验得到改善。在诸如重构、语法高亮、代码补全和可视化等方面，IDE可以更加直观。静态代码分析器和代码检查器可以提供更好的启发式方法和指导。
- en: Supporting this new extension and phasing out the existing module systems won’t
    happen overnight. Millions of packages and lots of tools need to start this process.
    When ESM begins to trickle in with new packages and old packages get updated,
    we’ll be able to reap the benefits of ESM. These benefits extend to much more
    than code. Section 6.5 describes how tools can take advantage of the static nature
    of this module format.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 支持这个新的扩展并逐步淘汰现有的模块系统不会一夜之间发生。数百万个包和大量工具需要开始这个过程。当ESM随着新包和新包的更新开始缓慢流入时，我们将能够享受到ESM的好处。这些好处远远超出了代码本身。第6.5节描述了工具如何利用这种模块格式的静态特性。
- en: 6.5 Benefits of ESM for tooling
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 ESM对工具的好处
- en: ESM’s static, declarative structure has many benefits. The one obvious benefit
    is good IDE support for static code checking. Other important benefits include
    dead-code elimination and tree-shaking, faster property lookups, and type-friendliness,
    all discussed in the following sections.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ESM的静态、声明性结构有许多好处。一个明显的优点是良好的IDE对静态代码检查的支持。其他重要的好处包括死代码消除和树摇、更快的属性查找和类型友好性，这些内容将在以下章节中讨论。
- en: 6.5.1 Dead-code elimination and tree-shaking
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 死代码消除和树摇
- en: In simple terms, dead code is code that could never run through any paths of
    your code. Tools can identify dead code by closely examining the static structure
    of the code and tracing through the possible execution paths. The most obvious
    form is code that’s commented out. Naturally, it’s pointless to send that code
    across the network to the browser or to a remote Node.js server, so transpilers
    and build tools typically strip it out. You may also find dead code in the unreachable
    lines that appear after a function’s `return` statement. This situation sometimes
    happens in code that relies on automatic semicolon insertion ([http://mng.bz/QmDj](http://mng.bz/QmDj)).
    Other, less obvious cases include unused local variables and function calls whose
    results are never used elsewhere.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，死代码是指在任何代码路径中都无法运行的代码。工具可以通过仔细检查代码的静态结构并追踪可能的执行路径来识别死代码。最明显的形式是已被注释掉的代码。自然地，将这段代码发送到浏览器或远程Node.js服务器是没有意义的，因此转换器和构建工具通常会将其移除。你还可以在函数的`return`语句之后出现的不可达行中找到死代码。这种情况有时出现在依赖于自动分号插入（[http://mng.bz/QmDj](http://mng.bz/QmDj)）的代码中。其他不那么明显的情况包括未使用的局部变量和结果从未在其他地方使用的函数调用。
- en: On the server, the module system is a reflection of the filesystem. On the browser,
    the situation is not quite the same, but ESM aims to close this gap. For large
    SPAs, you need a bundling/build strategy. Instead of requesting thousands of small
    files (each file a module) over the wire, it makes sense to bundle them at build
    time (and while you’re at it, compress them) into a single payload.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，模块系统是文件系统的反映。在浏览器上，情况并不完全相同，但ESM旨在缩小这一差距。对于大型SPA，你需要一个捆绑/构建策略。而不是通过网络请求成千上万的文件（每个文件都是一个模块），在构建时（同时，你也可以压缩它们）将它们捆绑成一个单一的负载是有意义的。
- en: I don’t cover build tools such as Browserify, Webpack, and Rollup in this book,
    but I highly recommend that you research them all and pick the best tool for your
    project. Build tools are essential parts of coding with JavaScript. The central
    job of these tools is to map the entire dependency tree to one or two entry points
    (index.js, main.js, app.js, and so on). Build tools are smart at detecting whole
    modules or parts of a module that are never used and then ignoring them. Hence,
    unused modules down the dependency tree are virtually considered to be dead and
    dropped by shaking the tree. Aside from reducing cognitive load, modularizing
    your code as much as possible instead of packing everything into a single file
    is good practice.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这本书中没有涵盖像Browserify、Webpack和Rollup这样的构建工具，但我强烈建议你研究它们所有，并为你的项目选择最好的工具。构建工具是使用JavaScript编码的必要部分。这些工具的中心任务是映射整个依赖树到一个或两个入口点（index.js、main.js、app.js等）。构建工具擅长检测整个模块或模块的一部分从未被使用，然后忽略它们。因此，依赖树中未使用的模块实际上被认为是死去的，并通过摇树优化被丢弃。除了减少认知负担外，尽可能地将代码模块化而不是将所有内容打包到一个文件中也是良好的实践。
- en: 'ESM’s static structure imposes restrictions that simplify tree-shaking:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ESM的静态结构施加了一些限制，这些限制简化了摇树优化：
- en: You can import modules only at the top level, never inside a conditional.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只能在顶层导入模块，永远不要在条件语句内部导入。
- en: You can’t use variables or functions in `import` statements.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在`import`语句中使用变量或函数。
- en: A build tool can rely on the matching sets of `export` and `import` statements
    to map out all unused modules and remove them as shown in figure 6.2.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 构建工具可以依赖于匹配的`export`和`import`语句集来映射所有未使用的模块，并如图6.2所示将它们移除。
- en: '![](../Images/6-2.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-2.png)'
- en: Figure 6.2 Bundler tools can use the static structure of your application to
    achieve tree-shaking by identifying any unused modules of code and removing them
    from the packaged application file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 捆绑工具可以使用应用程序的静态结构通过识别任何未使用的代码模块并将它们从打包的应用程序文件中移除来实现摇树优化。
- en: Without these guarantees, eliminating unused parts would be complex. Going back
    to CJS, for example, you can `require` modules dynamically and sprinkle these
    calls anywhere in the code, making it harder to figure out what to remove and
    what to keep.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这些保证，消除未使用部分将变得复杂。以CJS为例，你可以动态地`require`模块并将这些调用散布在代码的任何地方，这使得确定要删除什么和保留什么变得更加困难。
- en: 'Furthermore, with ESM, when you’re looking at the bundled code generated, depending
    on the tool, you might see a comment like this when removing the `foo` module:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用ESM时，当你查看生成的捆绑代码时，根据工具的不同，你可能会在移除`foo`模块时看到这样的注释：
- en: '[PRE40]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A good tip is to design your modules as loosely coupled and internally cohesive
    as possible to facilitate analyzing your code. Some build tools even have additional
    support to identify when a function is pure and its result is not used and then
    can safely remove that call, which is a nice benefit of coding with a functional
    style. Recall from chapter 4 that pure functions have no side effects or use of
    shared state, so a pure function whose result is not used does not contribute
    anything to your application. Detecting whether a function is pure and free of
    side effects is not an easy problem to solve, so you can help the tooling by writing
    a bit of metadata in front of pure calls:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的建议是尽可能地将你的模块设计成松耦合和内部紧密耦合的，以方便分析你的代码。一些构建工具甚至提供了额外的支持，以识别一个函数是否是纯函数以及其结果是否被使用，然后可以安全地移除该调用，这是使用函数式风格编码的一个很好的好处。回想一下第4章，纯函数没有副作用或使用共享状态，所以一个结果未被使用的纯函数对你的应用程序没有任何贡献。检测一个函数是否是纯函数且无副作用不是一个容易解决的问题，所以你可以通过在纯函数调用前编写一些元数据来帮助工具：
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can run certain plugins that support this notation as part of your build
    process. One example is the library Terser ([https://github.com/terser-js/terser](https://github.com/terser-js/terser)),
    which looks for these `PURE` pragmas and determines whether to classify them as
    dead code based on whether the result of the function is used.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在构建过程中运行支持此符号的某些插件。一个例子是库Terser ([https://github.com/terser-js/terser](https://github.com/terser-js/terser))，它寻找这些`PURE`预处理器，并确定是否根据函数的结果是否被使用来将它们分类为死代码。
- en: 'The call to `checkTampering` made in `Block` is a pure function, for example.
    It’s part of the validation logic as we discussed in chapter 5\. Here it is again,
    annotated with the pure metacomments:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Block`中调用的`checkTampering`是一个纯函数，例如。它是我们第5章讨论的验证逻辑的一部分。这里再次呈现，并带有纯元注释：
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If we move `checkTampering` out of the composition, Terser can easily find it
    and mark it for elimination—this is possible because of the guarantees that a
    pure function gives you.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`checkTampering`从组合中移除，Terser可以轻松找到它并将其标记为消除——这是由于纯函数为你提供的保证。
- en: ESM also has faster property lookups from imported code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ESM还有从导入代码中更快地查找属性的优势。
- en: 6.5.2 Faster property lookups
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 更快的属性查找
- en: 'Another advantage of using a static structure involves calling properties on
    the imported module. In CJS, the `require` API returns a regular JavaScript object
    in which every function call goes through the standard JavaScript property resolution
    process (described in chapter 2):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态结构的好处之一涉及在导入的模块上调用属性。在CJS中，`require` API返回一个常规JavaScript对象，其中每个函数调用都通过标准的JavaScript属性解析过程（在第2章中描述）：
- en: '[PRE43]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Although this technique keeps the mental model consistent, it’s slower than
    ESM. ESM’s static structure allows the JavaScript runtime to look ahead and statically
    resolve a named property lookup. This process happens internally, and the code
    looks much the same:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种技术保持了心理模型的一致性，但它比ESM慢。ESM的静态结构允许JavaScript运行时向前看并静态解析命名属性查找。这个过程在内部发生，代码看起来几乎相同：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In addition, knowing the static structure of a module allows IDEs to provide
    useful hints that can check whether a named property exists or is misspelled.
    This benefit has always been present in statically typed languages.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，了解模块的静态结构允许IDE提供有用的提示，以检查是否存在或拼写错误的命名属性。这种好处在静态类型语言中一直存在。
- en: 6.5.3 Type-friendliness
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.3 类型友好性
- en: JavaScript could be ready for a possible optional type system down the (long)
    road. ESM is paving the way, because static type checking can be done only when
    type definitions are known statically ahead of time. We already have reference
    implementations in TypeScript or even an extension library such as Flow. Some
    proposals include types for `number`, `string`, and `symbol`, different-size `int`
    and `floats`, and new concepts such as `enum` and `any`. Although typing information
    is light years away, there’s some consensus about what it could look like. For
    more information, see appendix B.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript可能在（漫长的）未来准备好引入可能的可选类型系统。ESM正在铺路，因为只有在类型定义在静态上提前已知的情况下，才能进行静态类型检查。我们已经在TypeScript或甚至像Flow这样的扩展库中有了参考实现。一些提议包括`number`、`string`和`symbol`的类型，不同大小的`int`和`floats`，以及新的概念如`enum`和`any`。尽管类型信息还相距甚远，但关于其可能的样子已经有一些共识。更多信息，请参阅附录B。
- en: So far, I’ve covered enough of the ESM syntax to get you started. But because
    ESM is a big addition to the language, I skipped many syntactical and technical
    details that you should become familiar with before making the leap. The ESM specification
    also supports a programmatic loader API that you can use to configure how modules
    are resolved and loaded, for example. For more information, visit [https://nodejs.org/
    api/esm.html](https://nodejs.org/api/esm.html).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经涵盖了足够的ESM语法，让你开始。但由于ESM是语言的一个重大补充，我跳过了许多你应该在跃迁之前熟悉的语法和技术细节。ESM规范还支持程序性加载器API，你可以用它来配置模块的解析和加载方式，例如。更多信息，请访问[https://nodejs.org/api/esm.html](https://nodejs.org/api/esm.html)。
- en: In JavaScript, imported modules behave like objects, and you can pass them around
    like variables. You can refer to this notion as “module as data.” This congruence
    is important because in chapter 7, we enter the realm of metaprogramming.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，导入的模块表现得像对象，你可以像变量一样传递它们。你可以将这个概念称为“模块作为数据”。这种一致性很重要，因为我们在第7章进入了元编程的领域。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can use patterns such as object and function namespaces, as well as IIFEs,
    to enable modularity in JavaScript without the need for any module system.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用对象和函数命名空间等模式，以及立即执行函数表达式（IIFEs），在JavaScript中实现模块化，而无需任何模块系统。
- en: A dynamic module system uses third-party or native libraries to manage dependencies
    at runtime. A static module system takes advantage of new language syntax and
    can be used to optimize dependency management at compile time.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态模块系统使用第三方或原生库在运行时管理依赖项。静态模块系统利用新的语言语法，可以在编译时优化依赖项管理。
- en: ESM is a static module system worked on by the TC39 task group with the aim
    of unifying the module needs of both client and server JavaScript environments,
    as well as replacing all existing module formats.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ESM是由TC39任务组开发的一个静态模块系统，旨在统一客户端和服务器JavaScript环境的模块需求，并取代所有现有的模块格式。
- en: ESM offers many benefits, such as dead-code elimination, tree-shaking, faster
    property lookup, variable checking, and compatibility with a (possible) future
    type system.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ESM提供了许多好处，例如死代码消除、摇树优化、更快的属性查找、变量检查，以及与（可能的）未来类型系统的兼容性。
- en: A distinctive part of ESM is the introduction of a new file extension, .mjs,
    so that compilers can enhance JavaScript files behaving as modules.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ESM的一个显著特点是引入了新的文件扩展名 .mjs，以便编译器可以增强表现为模块的JavaScript文件。
