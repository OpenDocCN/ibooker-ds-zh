- en: Chapter 3\. Reading and writing vector data
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章. 读取和写入矢量数据
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding vector data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解矢量数据
- en: Introducing OGR
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍OGR
- en: Reading vector data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取矢量数据
- en: Creating new vector datasets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的矢量数据集
- en: Updating existing datasets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新现有数据集
- en: They seem to be rare these days, but you’ve probably seen a paper roadmap designed
    to be folded up and kept in your car. Unlike the more recent web maps that we’re
    used to using, these maps don’t use aerial imagery. Instead, features on the maps
    are all drawn as geometric objects—namely, points, lines, and polygons. These
    types of data, where the geographic features are all distinct objects, are called
    *vector datasets*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些似乎现在很少见，但你可能见过一种设计用来折叠并保存在车里的纸质路线图。与我们现在习惯使用的较新的网络地图不同，这些地图不使用航空影像。相反，地图上的特征都是绘制为几何对象——即点、线和多边形。这些类型的地理特征都是独立对象的数据，被称为*矢量数据集*。
- en: Unless you only plan to look at maps that someone else has made, you’ll need
    to know how to read and write these types of data. If you want to work with existing
    data in any way, whether you’re summarizing, editing, deriving new data, or performing
    sophisticated spatial analyses, you need to read it in from a file first. You
    also need to write any new or modified data back out to a disk. For example, if
    you had a nationwide city dataset but needed to analyze only data from cities
    with 100,000 people or more, you could extract those cities out of your original
    dataset and run your analysis on them while ignoring the smaller towns. Optionally,
    you could also save the smaller dataset to a new file for later use.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你只打算查看别人制作过的地图，否则你需要知道如何读取和写入这些类型的数据。如果你想以任何方式处理现有数据，无论是总结、编辑、推导新数据还是执行复杂的空间分析，你首先需要从文件中读取它。你还需要将任何新或修改后的数据写回到磁盘上。例如，如果你有一个全国性的城市数据集，但只需要分析人口在10万或以上的城市数据，你可以从原始数据集中提取这些城市，并在它们上进行分析，同时忽略较小的城镇。可选地，你也可以将较小的数据集保存到新文件中供以后使用。
- en: In this chapter you’ll learn basic ideas behind vector data and how to use the
    OGR library to read, write, and edit these types of datasets.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解矢量数据背后的基本概念以及如何使用OGR库读取、写入和编辑这些类型的数据集。
- en: 3.1\. Introduction to vector data
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1. 矢量数据简介
- en: At its most basic, *vector data* are data in which geographic features are represented
    as discrete geometries—specifically, points, lines, and polygons. Geographic features
    that have distinct boundaries, such as cities, work well as vector data, but continuous
    data, such as elevation, don’t. It would be difficult to draw a single polygon
    around all areas with the same elevation, at least if you were in a mountainous
    area. You could, however, use polygons to differentiate between different elevation
    ranges. For example, polygons showing subalpine zones for a region would be a
    good proxy for an elevation range, but you’d lose much of the detailed elevation
    data within those polygons. Many types of data are excellent candidates for a
    vector representation, though, such as features in the roadmap mentioned earlier.
    Roads are represented as lines, counties and states are polygons, and depending
    on the scale of the map, cities are drawn as either points or polygons. In fact,
    all of the features on the map are probably represented as points, lines, or polygons.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的意义上，*矢量数据*是指将地理特征表示为离散几何形状的数据——具体来说，是点、线和多边形。具有明确边界的地理特征，如城市，非常适合作为矢量数据，但连续数据，如海拔，则不适合。在山区，要绘制一个包含所有相同海拔区域的单一多边形可能会很困难。然而，你可以使用多边形来区分不同的海拔范围。例如，显示一个区域亚高山区的多边形可以很好地代表一个海拔范围，但你会在这些多边形内失去大部分详细的海拔数据。尽管如此，许多类型的数据非常适合矢量表示，例如前面提到的路线图中的特征。道路表示为线，县和州表示为多边形，而根据地图的比例尺，城市可能被绘制为点或多边形。实际上，地图上的所有特征可能都表示为点、线或多边形。
- en: The type of geometry used to draw a feature can be dependent on scale, however.
    [Figure 3.1](#ch03fig01) shows an example of this. On the map of New York State,
    cities are shown as points, major roads as lines, and counties as polygons. A
    map of a smaller area, such as New York City, will symbolize features differently.
    In this case, roads are still lines, but the city and its boroughs are polygons
    instead of points. Now points would be used to represent features such as libraries
    or police stations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，绘制特征所使用的几何类型可能取决于比例尺。[图3.1](#ch03fig01)展示了这样一个例子。在纽约州的地图上，城市被表示为点，主要道路为线，县为多边形。较小区域的地图，如纽约市，将用不同的符号表示特征。在这种情况下，道路仍然是线，但城市及其行政区为多边形而不是点。现在点将用来表示图书馆或警察局等特征。
- en: Figure 3.1\. An example of how scale changes the geometries used to draw certain
    features. New York City is a point on the state map, but is made of several polygons
    on the city map.
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1. 比例尺如何改变绘制某些特征所使用的几何形状的例子。纽约市在州地图上是一个点，但在城市地图上由几个多边形组成。
- en: '![](03fig01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1](03fig01.jpg)'
- en: You can imagine many other examples of geographic data that lend themselves
    to being represented this way. Anything that can be described with a single set
    of coordinates, such as latitude and longitude, can be represented as a point.
    This includes cities, restaurants, mountain peaks, weather stations, and geocache
    locations. In addition to their x and y coordinates (such as latitude and longitude),
    points can have a third z coordinate that represents elevation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象许多其他适合以这种方式表示的地理数据示例。任何可以用单一坐标集描述的事物，如纬度和经度，都可以表示为一个点。这包括城市、餐馆、山峰、气象站和地理藏宝地点。除了它们的x和y坐标（如纬度和经度）之外，点还可以有一个表示高度的第三个z坐标。
- en: Geographic areas with closed boundaries can be represented as polygons. Examples
    are states, lakes, congressional districts, zip codes, and land ownership, along
    with many of the same features that can be symbolized as points such as cities
    and parks. Other features that could be represented as polygons, but probably
    not as points, include countries, continents, and oceans.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 具有封闭边界的地理区域可以用多边形表示。例如，州、湖泊、国会选区、邮政编码、土地所有权，以及许多可以像点一样表示的特征，如城市和公园。其他可能表示为多边形但可能不是点的特征包括国家、大陆和海洋。
- en: Linear features, such roads, rivers, power lines, and bus routes, all lend themselves
    to being characterized as lines. Once again, however, scale can make a difference.
    For example, a map of New Orleans could show the Mississippi River as a polygon
    rather than a line because it’s so wide. This would also allow the map to show
    the irregular banks of the river, rather than just a smooth line, as shown in
    [figure 3.2](#ch03fig02).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 线性特征，如道路、河流、电力线和公交路线，都可以被描述为线。然而，比例尺仍然可以产生影响。例如，新奥尔良的地图可能会将密西西比河表示为多边形而不是线，因为它非常宽。这也会使地图能够显示河流不规则的河岸，而不仅仅是像图3.2中所示的那样一条平滑的线。[图3.2](#ch03fig02)。
- en: Figure 3.2\. The difference between using polygon ![](num_01.jpg) and line ![](num_02.jpg)
    geometries to represent the Mississippi River. The polygon shows the details along
    the banks, while the line doesn’t.
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2. 使用多边形![多边形](num_01.jpg)和线![线](num_02.jpg)几何形状来表示密西西比河的区别。多边形显示了河岸的细节，而线则没有。
- en: '![](03fig02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2](03fig02.jpg)'
- en: Vector data is more than geometries, however. Each one of these features also
    has associated attributes. These attributes can relate directly to the geometry
    itself, such as the area or perimeter of a polygon, or length of a line, but other
    attributes may be present as well. [Figure 3.3](#ch03fig03) shows a simple example
    of a states dataset that stores the state name, abbreviation, population, and
    other data along with each feature. As you can see from the figure, these attributes
    can be of various types. They can be numeric, such as the city population or road
    speed limit, strings like city or road names, or dates such as the date the land
    parcel was purchased or last appraised. Certain types of vector data also support
    BLOBs (binary large objects), which can be used to store binary data such as photographs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 向量数据不仅仅是几何形状。每一个这样的特征也都有相关的属性。这些属性可以直接关联到几何形状本身，例如多边形的面积或周长，或线的长度，但可能也存在其他属性。[图3.3](#ch03fig03)
    展示了一个简单的示例，一个存储州名、缩写、人口和其他数据的州数据集，每个特征都与之相关。如图所示，这些属性可以是各种类型。它们可以是数值，如城市人口或道路速度限制，也可以是字符串，如城市或道路名称，或者是日期，如土地地块购买或最后评估的日期。某些类型的向量数据还支持BLOBs（二进制大对象），可以用来存储二进制数据，如照片。
- en: Figure 3.3\. An attribute table for a dataset containing state boundaries within
    the United States. Each state polygon has an associated row in the data table
    with several attributes, including state name and population in 2010.
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3\. 包含美国州边界的数据集的属性表。每个州多边形在数据表中都有一个与之关联的行，包括州名和2010年的人口等几个属性。
- en: '![](03fig03_alt.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3](03fig03_alt.jpg)'
- en: It should be clear by now that this type of data is well suited for making maps,
    but some reasons might not be so obvious. One example is how well it scales when
    drawing. If you’re familiar with web graphics, you probably know that vector graphics
    such as SVG (scalable vector graphics) work much better than raster graphics such
    as PNG when displayed at different scales. Even if you know nothing about SVG,
    you’ve surely seen an image on a website that’s pixelated and ugly. That’s a raster
    graphic displayed at a higher resolution than it was designed for. This doesn’t
    happen with vector graphics, and the exact same principle applies to vector GIS
    data. It always looks smooth, no matter the scale.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，应该很清楚这种类型的数据非常适合制作地图，但某些原因可能并不那么明显。一个例子是它在绘图时的缩放能力。如果你熟悉网络图形，你可能知道，当以不同比例显示时，矢量图形（如SVG可缩放矢量图形）比位图图形（如PNG）表现得更好。即使你对SVG一无所知，你也一定在网站上看到过像素化且难看的图片。那是在比设计时更高的分辨率下显示的位图图形。矢量图形不会发生这种情况，矢量GIS数据也是如此。无论比例如何，它总是看起来很平滑。
- en: That doesn’t mean that scale is irrelevant, though. As you saw earlier, scale
    affects the type of geometry used to represent a geographic feature, but it also
    affects the resolution you should use for a feature. A simple way to think of
    resolution is to equate it to detail. The higher the resolution, the more detail
    can be shown. For example, a map of the United States wouldn’t show all of the
    individual San Juan Islands off the coast of Washington State, and in fact, the
    dataset wouldn’t even need to include them. A map of only Washington State, however,
    would definitely need a higher-resolution dataset that includes the islands, as
    seen in [figure 3.4](#ch03fig04). Keep in mind that resolution isn’t important
    only for display, but also for analysis. For example, the two maps of Washington
    would provide extremely different measurements for coastline length.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这并不意味着比例尺度无关紧要。如你之前所见，比例尺度影响用于表示地理特征的几何形状类型，但它也影响特征的分辨率。简单来说，分辨率可以等同于细节。分辨率越高，可以显示的细节就越多。例如，美国地图不会显示华盛顿州海岸外的所有圣胡安群岛，实际上，数据集甚至不需要包括它们。然而，仅华盛顿州的地图肯定需要一个更高分辨率的包含岛屿的数据集，如图3.4所示。记住，分辨率不仅对显示很重要，对分析也很重要。例如，华盛顿州的两个地图会提供海岸线长度的极其不同的测量结果。
- en: Figure 3.4\. An example showing the difference that resolution makes. The dataset
    shown with the thick outline has a lower resolution than the one shown with shading.
    Notice the difference in the amount of detail available in the two datasets.
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4\. 展示分辨率差异的示例。具有粗轮廓线的数据集分辨率低于具有阴影的数据集。注意两个数据集中可用的细节量差异。
- en: '![](03fig04.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4](03fig04.jpg)'
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The coastline paradox**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**海岸线悖论**'
- en: Have you ever thought about how to measure the coastline of a landmass? As first
    pointed out by the English mathematician Lewis Fry Richardson, this isn’t as easy
    as you might think, because the final measurement depends totally on scale. For
    example, think about a wild section of coastline with multiple headlands, with
    a road running along beside it. Imagine that you drive along that road and use
    your car’s odometer to measure the distance, and then you get out of the car and
    walk back the way you came. But when on foot, you walk out along the edges of
    the headlands and follow other curves in the coast that the road doesn’t. It should
    be easy to imagine that you’d walk farther than you drove because you took more
    detours. The same principle applies when measuring the entire coastline, because
    you can measure more variation if you measure in smaller increments. In fact,
    measuring the coast of Great Britain in 50-km increments instead of 100-km increments
    increases the final measurement by about 600 km. You can see another example of
    this, using part of Washington State, in [figure 3.3](#ch03fig03). If you were
    to measure all of the twists and turns in the higher-resolution dataset, you’d
    get a longer coastline measurement than if you measured the lower-resolution coastline
    shown by the dark line, which doesn’t even include many of the islands.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想过如何测量陆地的海岸线？正如英国数学家刘易斯·弗赖·理查森最初指出的，这比你想象的要困难，因为最终测量完全取决于比例尺。例如，想象一段有多个海角的海岸线，旁边有一条道路。想象你沿着这条路开车，用你车的里程表来测量距离，然后你下车沿着你来的路走回去。但是当你步行时，你沿着海角边缘走，并跟随道路没有的沿海曲线。你应该可以想象你会走得更远，因为你走了更多的弯路。当测量整个海岸线时，这个原理同样适用，因为如果你以更小的增量进行测量，你可以测量更多的变化。事实上，用50公里增量而不是100公里增量来测量大不列颠的海岸线，最终测量会增加大约600公里。你可以在[图3.3](#ch03fig03)中看到另一个例子。如果你要测量高分辨率数据集中所有的曲折和转弯，你会得到比测量由深色线表示的低分辨率海岸线更长的海岸线测量值，而这条深色线甚至不包括许多岛屿。
- en: '|  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As mentioned previously, vector data isn’t only for making maps. In fact, I
    couldn’t make a pretty map if my life depended on it, but I do know a little bit
    more about data analysis. One common type of vector data analysis is to measure
    relationships between geographic features, typically by overlaying them on one
    another to determine their spatial relationship. For example, you could determine
    if two features overlap spatially and what that area of overlap is. [Figure 3.5](#ch03fig05)
    shows the New Orleans city boundaries overlaid on a wetlands dataset. You could
    use this information to determine where wetlands exist within the city of New
    Orleans and how much of the city’s area is or isn’t wetland.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，矢量数据不仅用于制作地图。实际上，即使我的生命取决于它，我也无法制作出漂亮的地图，但我确实对数据分析了解得更多一些。一种常见的矢量数据分析类型是测量地理要素之间的关系，通常通过将它们叠加在一起来确定它们的空间关系。例如，你可以确定两个要素在空间上是否重叠以及重叠区域的大小。[图3.5](#ch03fig05)显示了新奥尔良市边界叠加在湿地数据集上。你可以使用这些信息来确定新奥尔良市内湿地的位置以及城市面积中有多少是湿地，多少不是。
- en: Figure 3.5\. An example of a vector overlay operation. The dark outline is the
    City of New Orleans boundary, and the darker land areas are wetlands. These two
    datasets could be used to determine the percentage of land area within the New
    Orleans boundary that is wetlands.
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.5. 向量叠加操作的示例。深色轮廓是新奥尔良市的边界，而更深的土地区域是湿地。这两个数据集可以用来确定新奥尔良市边界内湿地土地面积的比例。
- en: '![](03fig05_alt.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig05_alt.jpg)'
- en: Another aspect of spatial relationships is the distance between two features.
    You could find the distance between two weather stations, or all of the sandwich
    shops within one mile of your office. I helped out with a study a few years ago
    in which the researchers needed both distances and spatial relationships. They
    needed to know how far GPS-collared deer traveled between readings, but also the
    direction of travel and how they interacted with man-made features such as roads.
    One question in particular was if they crossed the roads, and if so, how often.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 空间关系的另一个方面是两个要素之间的距离。你可以找到两个气象站之间的距离，或者你办公室一英里范围内的所有三明治店。几年前，我帮助进行了一项研究，研究人员需要距离和空间关系。他们需要知道GPS项圈鹿在两次读数之间的移动距离，但还需要知道它们的移动方向以及它们如何与道路等人工特征相互作用。特别是有一个问题，即它们是否穿越道路，如果是的话，频率如何。
- en: Speaking of roads, vector datasets also do a good job of representing networks,
    such as road networks. A properly configured road network can be used to find
    routes and drive times between two locations, similar to the results you see on
    various web-mapping sites. Businesses can also use information like this to provide
    services. For example, a pizza joint might use network analysis to determine which
    parts of town they can reach within a 15-minute drive to set their delivery area.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 说到道路，矢量数据集在表示网络，如道路网络方面也做得很好。一个配置正确的道路网络可以用来查找两个地点之间的路线和驾驶时间，类似于你在各种网络地图网站上看到的结果。企业也可以使用此类信息来提供服务。例如，一家比萨店可能会使用网络分析来确定在15分钟内可以到达的城市哪些部分，以设定他们的配送区域。
- en: As with other types of data, you have multiple ways to store vector data. Similar
    to the way you can store a photograph as a JPEG, PNG, TIFF, bitmap, or one of
    many other file types, many different file formats can be used for storing vector
    data. I’ll talk more about the possibilities in the next chapter, but for now
    I’ll briefly mention a few common formats, several of which we’ll use in this
    chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型的数据一样，你有多种方式来存储矢量数据。类似于你可以将照片存储为JPEG、PNG、TIFF、位图或许多其他文件类型，许多不同的文件格式可以用于存储矢量数据。我将在下一章中更多地讨论可能性，但现在我将简要提及一些常见的格式，其中我们将使用本章中的几个。
- en: Shapefiles are a popular format for storing vector data. A shapefile isn’t made
    of a single file, however. In fact, this format requires a minimum of three binary
    files, each of which serves a different purpose. Geometry information is stored
    in .shp and .shx files, and attribute values are stored in a .dbf file. Additionally,
    other data, such as indexes or spatial reference information, can be stored in
    even more files. Generally you don’t need to know anything about these files,
    but you do need to make sure that they’re all kept together in the same folder.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Shapefiles是一种流行的矢量数据存储格式。然而，一个shapefile并不是由单个文件组成的。实际上，这种格式至少需要三个二进制文件，每个文件都服务于不同的目的。几何信息存储在.shp和.shx文件中，属性值存储在.dbf文件中。此外，其他数据，如索引或空间参考信息，可以存储在更多的文件中。通常你不需要了解这些文件，但你确实需要确保它们都保存在同一个文件夹中。
- en: Another widely used format, especially for web-mapping applications, is GeoJSON.
    These are plain text files that you can open up and look at in any text editor.
    Unlike a shapefile, a GeoJSON dataset consists of one file that stores all required
    information.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种广泛使用的格式，尤其是对于网络地图应用，是GeoJSON。这些是纯文本文件，你可以在任何文本编辑器中打开并查看。与shapefile不同，GeoJSON数据集由一个文件组成，该文件存储了所有必要的信息。
- en: Vector data can also be stored in relational databases, which allows for multiuser
    access as well as various types of indexing. Two of the most common options for
    this are spatial extensions built for widely used database systems. The PostGIS
    extension runs on top of PostgreSQL, and SpatiaLite works with SQLite databases.
    Another popular database format is the Esri file geodatabase, which is completely
    different in that it isn’t part of an existing database system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量数据也可以存储在关系数据库中，这允许多用户访问以及各种类型的索引。其中最常见的两种选项是为广泛使用的数据库系统构建的空间扩展。PostGIS扩展在PostgreSQL之上运行，SpatiaLite与SQLite数据库协同工作。另一种流行的数据库格式是Esri文件地理数据库，它与现有数据库系统完全不同。
- en: 3.2\. Introduction to OGR
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. OGR简介
- en: The OGR Simple Features Library is part of the Geospatial Data Abstraction Library
    (GDAL), an extremely popular open source library for reading and writing spatial
    data. The OGR portion of GDAL is the part that provides the ability to read and
    write many different vector data formats. OGR also allows you to create and manipulate
    geometries; edit attribute values; filter vector data based on attribute values
    or spatial location; and it also offers data analysis capabilities. In short,
    if you want to use GDAL to work with vector data, OGR is what you need to learn
    about, and you will, in the next four chapters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: OGR简单特征库是地理空间数据抽象库（GDAL）的一部分，GDAL是一个用于读取和写入空间数据的极其流行的开源库。GDAL的OGR部分是提供读取和写入许多不同矢量数据格式能力的部分。OGR还允许你创建和操作几何形状；编辑属性值；根据属性值或空间位置过滤矢量数据；它还提供数据分析功能。简而言之，如果你想使用GDAL处理矢量数据，你需要了解OGR，你将在接下来的四章中了解到这一点。
- en: The GDAL library was originally written in C and C++, but it has bindings for
    several other languages, including Python, so there’s an interface to the GDAL/OGR
    library from Python, not that the code was rewritten in Python. Therefore, to
    use GDAL with Python, you need to install both the GDAL library and the Python
    bindings for it. If you haven’t yet done this, please see [appendix A](kindle_split_022.html#app01)
    for detailed installation instructions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL 库最初是用 C 和 C++ 编写的，但它为几种其他语言提供了绑定，包括 Python，因此有一个从 Python 到 GDAL/OGR 库的接口，并不是代码是用
    Python 重写的。因此，要使用 Python 中的 GDAL，你需要安装 GDAL 库及其 Python 绑定。如果你还没有这样做，请参阅[附录 A](kindle_split_022.html#app01)以获取详细的安装说明。
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: What does the OGR acronym stand for, anyway? It used to stand for OpenGIS Simple
    Features Reference Implementation, but because OGR isn’t fully compliant with
    the OpenGIS Simple Features specification, the name was changed and now the OGR
    part of it doesn’t stand for anything and is only historical in nature.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，OGR 这个缩写究竟代表什么意思呢？它曾经代表 OpenGIS 简单特征参考实现，但由于 OGR 并不完全符合 OpenGIS 简单特征规范，因此名称被更改，现在
    OGR 部分不再代表任何含义，只是具有历史性质。
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Several functions used in this chapter are from the ospybook Python module available
    for download at [www.manning.com/books/geoprocessing-with-python](http://www.manning.com/books/geoprocessing-with-python).
    You’ll want to install this module, too. The sample datasets are available from
    the same site.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的几个函数来自可在 [www.manning.com/books/geoprocessing-with-python](http://www.manning.com/books/geoprocessing-with-python)
    下载的 ospybook Python 模块。你也需要安装这个模块。示例数据集可以从同一网站获取。
- en: Before you start working with OGR, it’s useful to look at how various objects
    in the OGR universe are related to each other, as shown in [figure 3.6](#ch03fig06).
    If you don’t understand this hierarchy, then the steps required to read and write
    data won’t make much sense. When you use OGR to open a data source, such as a
    shapefile, GeoJSON file, SpatiaLite, or PostGIS database, you’ll have a `DataSource`
    object. This data source can have one or more child `Layer` objects, one for each
    dataset contained in the data source. Many vector data formats, such as the shapefile
    examples used in this chapter, can only contain one dataset. But others, such
    as SpatiaLite, can contain multiple datasets, and you’ll see examples of this
    in the next chapter. Regardless of how many datasets are in a data source, each
    one is considered a layer by OGR. Even several of my students, who use GIS regularly
    for their classes and research, get confused by this if they mostly use shapefiles,
    because it’s counterintuitive to them that something called a layer sits between
    the data source and the actual data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 OGR 之前，查看 OGR 宇宙中各种对象之间的关系是有用的，如图 3.6[所示](#ch03fig06)。如果你不理解这个层次结构，那么读取和写入数据所需的步骤就不会很有意义。当你使用
    OGR 打开数据源，例如 shapefile、GeoJSON 文件、SpatiaLite 或 PostGIS 数据库时，你会得到一个 `DataSource`
    对象。这个数据源可以有一个或多个子 `Layer` 对象，每个对象对应数据源中包含的一个数据集。许多矢量数据格式，如本章中使用的 shapefile 示例，只能包含一个数据集。但其他格式，如
    SpatiaLite，可以包含多个数据集，你将在下一章中看到这方面的示例。无论数据源中有多少个数据集，每个数据集都被 OGR 视为一个图层。甚至一些经常在课程和研究中使用
    GIS 的我的学生，如果他们主要使用 shapefile，也会对此感到困惑，因为他们觉得被称为图层的对象位于数据源和实际数据之间，这不符合直观。
- en: Figure 3.6\. The OGR class structure. Each data source can have multiple layers,
    each layer can have multiple features, and each feature contains a geometry and
    one or more attributes.
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.6. OGR 类结构。每个数据源可以包含多个图层，每个图层可以包含多个要素，每个要素包含一个几何形状和一个或多个属性。
- en: '![](03fig06.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3.6](03fig06.jpg)'
- en: And speaking of the actual data, each layer contains a collection of `Feature`
    objects that holds the geometries and their attributes. If you load vector data
    into a GIS, such as QGIS, and then look at the attribute table, you’ll see something
    similar to [figure 3.7](#ch03fig07). Each row in the table corresponds to a feature,
    such as the feature representing Afghanistan. Each column corresponds to an attribute
    field, and in this case two of the attributes are `SOVEREIGNT` and `TYPE`. Although
    you can open data tables that don’t have any spatial information or geometries
    associated with the features, we’ll work with datasets that do have geometries.
    As you can see in [figure 3.7](#ch03fig07), the geometries don’t show up in the
    attribute table in QGIS, although other GIS software packages, such as ArcGIS,
    do show a shape column in the attribute table.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 说到实际数据，每个图层包含一个 `Feature` 对象的集合，这些对象持有几何形状及其属性。如果你将矢量数据加载到 GIS 中，如 QGIS，然后查看属性表，你会看到类似于
    [图 3.7](#ch03fig07) 的内容。表中的每一行对应一个要素，例如代表阿富汗的要素。每一列对应一个属性字段，在这种情况下，两个属性是 `SOVEREIGNT`
    和 `TYPE`。尽管你可以打开没有与要素关联的任何空间信息或几何形状的数据表，但我们将使用具有几何形状的数据集。正如你在 [图 3.7](#ch03fig07)
    中可以看到的，几何形状在 QGIS 的属性表中不会显示，尽管其他 GIS 软件包，如 ArcGIS，在属性表中确实显示了形状列。
- en: Figure 3.7\. An example of an attribute table shown in QGIS. Each row corresponds
    to a feature, and each column is an attribute field.
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.7\. 在 QGIS 中显示的属性表的示例。表中的每一行对应一个要素，每一列是一个属性字段。
- en: '![](03fig07_alt.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig07_alt.jpg)'
- en: The first step to accessing any vector data is to open the data source. For
    this, you need to have an appropriate driver that tells OGR how to work with your
    data format. The GDAL/OGR website lists more than 70 vector formats that OGR is
    capable of reading, although it can’t write to all of them. Each one of these
    has its own driver. It’s likely that your version of OGR doesn’t support all of
    those listed, but you can always compile it yourself if you need something that’s
    missing (note that this is easier said than done in many cases). See [www.gdal.org/ogr_formats.html](http://www.gdal.org/ogr_formats.html)
    for the list of all available formats and specific details pertaining to each
    one.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 访问任何矢量数据的第一步是打开数据源。为此，你需要一个合适的驱动程序，告诉 OGR 如何处理你的数据格式。GDAL/OGR 网站列出了 OGR 能够读取的超过
    70 种矢量格式，尽管它不能写入所有这些格式。这些格式中的每一个都有自己的驱动程序。很可能你的 OGR 版本不支持所有列出的格式，但如果你需要某些缺失的功能，你总是可以自己编译它（请注意，在许多情况下，这比说起来容易做起来难）。有关所有可用格式及其具体细节的列表，请参阅
    [www.gdal.org/ogr_formats.html](http://www.gdal.org/ogr_formats.html)。
- en: '|  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: A driver is a translator for a specific data format, such as Geo-JSON or shapefile.
    It tells OGR how to read and write that particular format. If no driver for a
    format is compiled into OGR, then OGR can’t work with it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序是特定数据格式的翻译器，例如 Geo-JSON 或 shapefile。它告诉 OGR 如何读取和写入该特定格式。如果没有为格式编译驱动程序到
    OGR 中，那么 OGR 就无法处理它。
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If you aren’t sure if your installation of GDAL/OGR supports a particular data
    format, you can use the ogrinfo command-line utility to find out which drivers
    are available. The location of this utility on your computer depends on your operating
    system and how you installed GDAL, so you might need to refer back to [appendix
    A](kindle_split_022.html#app01). If you aren’t used to using a command line, you
    may be tempted to double-click the ogrinfo executable file, but that won’t get
    you anywhere useful. Instead, you need to run `ogrinfo` from a terminal window
    or Windows command prompt. At any rate, once you find the executable, you’ll want
    to run it with the `--formats` option. [Figure 3.8](#ch03fig08) shows an example
    of running it on my Windows 7 machine, although I’ve cut off most of the output.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定你的 GDAL/OGR 安装是否支持特定的数据格式，你可以使用 ogrinfo 命令行实用程序来找出哪些驱动程序可用。此实用程序在计算机上的位置取决于你的操作系统以及你如何安装
    GDAL，因此你可能需要参考 [附录 A](kindle_split_022.html#app01)。如果你不习惯使用命令行，你可能想双击 ogrinfo
    可执行文件，但这不会带给你任何有用的结果。相反，你需要从终端窗口或 Windows 命令提示符运行 `ogrinfo`。无论如何，一旦找到可执行文件，你将希望使用
    `--formats` 选项运行它。[图 3.8](#ch03fig08) 展示了在我的 Windows 7 机器上运行它的示例，尽管我已经切掉了大部分输出。
- en: Figure 3.8\. An example of running the ogrinfo utility from a GDAL command prompt
    on a Windows computer
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.8\. 在 Windows 计算机上从 GDAL 命令提示符运行 ogrinfo 实用程序的示例
- en: '![](03fig08.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig08.jpg)'
- en: As you can see, ogrinfo not only tells you which drivers are included with your
    version of OGR, but also whether it can write to each one as well as read from
    it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`ogrinfo`不仅会告诉您OGR版本中包含哪些驱动程序，还会告诉您它是否可以写入每个驱动程序以及从中读取。
- en: '|  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Information about vector formats supported by OGR can be found at [www.gdal.org/ogr_formats.html](http://www.gdal.org/ogr_formats.html).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在[www.gdal.org/ogr_formats.html](http://www.gdal.org/ogr_formats.html)可以找到OGR支持的矢量格式信息。
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can also determine which drivers are available using Python. In fact, let’s
    try it. Start by opening up your favorite Python interactive environment. I’ll
    use IDLE ([figure 3.9](#ch03fig09)) because it’s the one that’s packaged with
    Python, but you can use whichever one you’re comfortable with. The first thing
    you need to do is import the `ogr` module so that you can use it. This module
    lives inside the `osgeo` package, which was installed when you installed the Python
    bindings for GDAL. All of the modules in this package are named with lowercase
    letters, which is how you need to refer to them in Python. Once you’ve imported
    `ogr`, then you can use `ogr.GetDriverByName` to find a specific driver:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用Python确定哪些驱动程序可用。实际上，让我们试试。首先打开您喜欢的Python交互环境。我将使用IDLE（[图3.9](#ch03fig09)），因为它与Python一起打包，但您可以使用您感到舒适的任何一种。您需要做的第一件事是导入`ogr`模块，以便可以使用它。此模块位于`osgeo`包中，当您安装GDAL的Python绑定时已安装。此包中的所有模块都使用小写字母命名，这就是您在Python中引用它们的方式。一旦您导入了`ogr`，然后您可以使用`ogr.GetDriverByName`来查找特定的驱动程序：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Figure 3.9\. Sample Python interactive session showing how to get drivers
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.9\. 示例Python交互会话，展示如何获取驱动程序
- en: '![](03fig09.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig09.jpg)'
- en: Use the name from the Code column on the OGR Vector Formats webpage. If you
    get a valid driver and print it out, you’ll see information about where the object
    is stored in memory. The important thing is that there was something for it to
    print out because it means you successfully found a driver. If you pass an invalid
    name, or the name of a missing driver, the function will return `None`. See [figure
    3.9](#ch03fig09) for examples.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OGR矢量格式网页上的代码列中的名称。如果您得到一个有效的驱动程序并打印出来，您将看到有关对象在内存中存储位置的信息。重要的是，它确实有东西可以打印出来，因为这表明您成功找到了驱动程序。如果您传递一个无效的名称，或者丢失的驱动程序的名称，该函数将返回`None`。请参见[图3.9](#ch03fig09)中的示例。
- en: A function called `print_drivers` in the ospybook module will also print out
    a list of available drivers. This is shown in [figure 3.9](#ch03fig09).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ospybook模块中有一个名为`print_drivers`的函数，它也会打印出可用的驱动程序列表。这如图3.9所示。
- en: 3.3\. Reading vector data
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 阅读矢量数据
- en: Now that you know what formats are available to work with, it’s time to read
    data. You’ll start with a cities shapefile, the ne_50m_populated_places.shp dataset
    in the global subfolder of your osgeopy-data folder. Feel free to open it up in
    QGIS and look. Not only will you see the cities shown in [figure 3.10](#ch03fig10),
    but you’ll also see that the attribute table contains a collection of fields,
    most of which aren’t visible in the screenshot.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道了可以与之一起工作的格式，是时候读取数据了。您将从城市shapefile开始，即您osgeopy-data文件夹的全局子文件夹中的ne_50m_populated_places.shp数据集。您可以自由地在QGIS中打开它并查看。您不仅会看到[图3.10](#ch03fig10)中显示的城市，还会看到属性表包含一系列字段，其中大多数在截图中都不可见。
- en: Figure 3.10\. The geometries and attributes from ne_50m_populated_places.shp
    as seen in QGIS
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.10\. 在QGIS中看到的ne_50m_populated_places.shp中的几何形状和属性
- en: '![](03fig10.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig10.jpg)'
- en: '[Listing 3.1](#ch03ex01) shows a little script that prints out the names, populations,
    and coordinates for the first 10 features in this dataset. Don’t worry if it doesn’t
    make much sense at first glance because we’ll go over it in excruciating detail
    in a moment. The file is included with the source code for this chapter, so if
    you want to try it out, you can open it in IDLE, change the filename in the third
    line of code to match your setup, and then choose Run Module under the Run menu.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表3.1](#ch03ex01)显示了一个小脚本，它打印出该数据集中前10个要素的名称、人口和坐标。如果您一开始看不懂，不要担心，因为我们将稍后以极其详细的方式讲解它。该文件包含在本章的源代码中，因此如果您想尝试它，您可以在IDLE中打开它，将代码第三行的文件名更改为与您的设置匹配，然后选择运行菜单下的“运行模块”。'
- en: Listing 3.1\. Printing data from the first ten features in a shapefile
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.1\. 打印shapefile中前十个要素的数据
- en: '![](045fig01_alt.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](045fig01_alt.jpg)'
- en: The basic outline is simple. The first thing you do is open the shapefile and
    make sure that the result of that operation isn’t equal to `None`, because that
    would mean the data source couldn’t be opened. I tend to call this variable `ds`,
    short for data source. After making sure the file is opened, you retrieve the
    first layer from the data source. Then you iterate through the first 10 features
    in the layer and for each one, get the geometry object, its coordinates, and the
    `NAME` and `POP_MAX` attribute values. Then you print the information about the
    feature before moving on to the next one. When done, you delete the `ds` variable
    to force the file to close.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 基本框架很简单。你做的第一件事是打开shapefile并确保该操作的结果不等于`None`，因为这将意味着数据源无法打开。我倾向于将这个变量称为`ds`，即数据源的简称。在确认文件已打开后，你从数据源中检索第一个图层。然后你遍历图层中的前10个特征，并为每个特征获取几何对象、其坐标以及`NAME`和`POP_MAX`属性值。然后你在继续到下一个之前打印有关该特征的信息。完成后，你删除`ds`变量以强制文件关闭。
- en: 'If you successfully ran the code, you should have 10 lines of output that look
    something like this, although you won’t have the parentheses if using Python 3:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功运行了代码，你应该有10行输出，看起来像这样，尽管如果你使用Python 3，你将不会看到括号：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s look at this in a little more detail. You open a data source by passing
    the filename and an optional update flag to the `Open` function. This is a standalone
    function in the OGR module, so you prefix the function name with the module name
    so that Python can find it. If the second parameter isn’t provided it defaults
    to 0, which will open the file in read-only mode. You could have passed `1` or
    `True` to open it in update, or edit, mode instead.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个。你通过传递文件名和一个可选的更新标志到`Open`函数来打开一个数据源。这是一个OGR模块中的独立函数，因此你需要在函数名前加上模块名，这样Python才能找到它。如果第二个参数没有提供，它将默认为0，这将以只读模式打开文件。你可以传递`1`或`True`来以更新或编辑模式打开它。
- en: 'If the file can’t be opened, then the `Open` function returns `None`, so the
    next thing you do is check for this and print out an error message and quit if
    needed. I like to check for this so I can solve the problem immediately and in
    the manner of my choosing (quitting, in this case) instead of waiting for the
    script to crash when it tries to use the nonexistent data source. Change the filename
    in [listing 3.1](#ch03ex01) to a bogus one and run the script if you want to see
    this behavior in action:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件无法打开，那么`Open`函数将返回`None`，所以接下来你要检查这一点，并在需要时打印出错误消息并退出。我喜欢检查这一点，这样我就可以立即以我选择的方式（在这种情况下是退出）解决问题，而不是等待脚本在尝试使用不存在的数据源时崩溃。如果你想看到这种行为在实际操作中的表现，可以将[列表
    3.1](#ch03ex01)中的文件名更改为一个无效的名称并运行脚本：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remember that data sources are made of one or more layers that hold the data,
    so after opening the data source you need to get the layer from it. Data sources
    have a function called `GetLayer` that takes either a layer index or a layer name
    and returns the corresponding `Layer` object inside that particular data source.
    Layer indexes start at 0, so the first layer has index 0, the second has index
    1, and so on. If you don’t provide any parameters to `GetLayer,` then it returns
    the first layer in the data source. The shapefile only has one layer, so the index
    isn’t technically needed in this case.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，数据源由一个或多个包含数据的图层组成，因此打开数据源后，你需要从其中获取图层。数据源有一个名为`GetLayer`的函数，它接受一个图层索引或图层名称，并返回该特定数据源中的相应`Layer`对象。图层索引从0开始，因此第一个图层的索引是0，第二个是1，依此类推。如果你没有为`GetLayer`提供任何参数，那么它将返回数据源中的第一个图层。Shapefile只有一个图层，所以在这种情况下，索引在技术上不是必需的。
- en: 'Now you want to get the data out of your layer. Recall that each layer is made
    of one or more features, with each feature representing a geographic object. The
    geometries and attribute values are attached to these features, so you need to
    look at them to get your data. The second half of the code in [listing 3.1](#ch03ex01)
    loops through the first 10 features in the layer and prints information about
    each one. Here’s the interesting part of it again:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你想要从你的图层中获取数据。回想一下，每个图层由一个或多个特征组成，每个特征代表一个地理对象。几何形状和属性值都附加到这些特征上，因此你需要查看它们来获取你的数据。在[列表
    3.1](#ch03ex01)中的代码的第二部分会遍历图层中的前10个特征，并打印每个特征的信息。以下是它的有趣部分再次呈现：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The layer is a collection of features that you can iterate over with a `for`
    loop. Each time through the loop, the `feat` variable will be the next feature
    in the layer, and the loop will iterate over all features in the layer before
    stopping. You don’t want to print out all 1,249 features, though, so you force
    it to stop after the first 10.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 层是一个可以遍历的特征集合，您可以使用`for`循环遍历它。每次循环迭代时，`feat`变量将是层中的下一个特征，循环将在遍历层中的所有特征后停止。但是，您不想打印出所有1,249个特征，所以您强制它在第一个10个特征后停止。
- en: The first thing you do inside the loop is get the geometry from the feature
    and stick it in a variable called `pt`. Once you have the geometry, you grab its
    x and y coordinates and store them in variables to use later.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部的第一件事是获取特征的几何形状并将其存储在一个名为`pt`的变量中。一旦您有了几何形状，您就获取其x和y坐标并将它们存储在变量中以供以后使用。
- en: Next you retrieve the values from the `NAME` and `POP_MAX` fields and store
    those in variables as well. The `GetField` function takes either an attribute
    name or index and returns the value of that field. Once you have the attributes,
    you print out all of the information you gathered about the current feature.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您从`NAME`和`POP_MAX`字段中检索值，并将这些值也存储在变量中。`GetField`函数接受一个属性名称或索引，并返回该字段的值。一旦您有了属性，您就会打印出关于当前特征收集的所有信息。
- en: One thing you should be aware of is that the `GetField` function returns data
    that’s the same data type as that in the underlying dataset. In this example,
    the value in the `name` variable is a string, but the value stored in `pop` is
    a number. If you want the data in another format, check out [appendix B](kindle_split_023.html#app02)
    to see a list of functions that return values as a specific type. For example,
    if you wanted `pop` to be a string so that you could concatenate it to another
    string, you could use `GetFieldAsString`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意的一件事是，`GetField`函数返回的数据类型与底层数据集中的数据类型相同。在这个例子中，`name`变量中的值是字符串，但存储在`pop`中的值是数字。如果您想以其他格式存储数据，请查看[附录B](kindle_split_023.html#app02)，以查看返回特定类型值的函数列表。例如，如果您想将`pop`转换为字符串以便将其连接到另一个字符串，您可以使用`GetFieldAsString`。
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that not all data formats support all field types, and not all data can
    successfully be converted between types, so you should test things thoroughly
    before relying on these automatic conversions. Not only are these functions useful
    for converting data between types, but you can also use them to make data types
    more evident in your code. For example, if you use `GetFieldAsInteger`, then it’s
    obvious to anyone reading your code that the value is an integer.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，并非所有数据格式都支持所有字段类型，并且并非所有数据都可以成功地在类型之间转换，因此在依赖这些自动转换之前，您应该彻底测试这些事情。这些函数不仅对于在类型之间转换数据很有用，而且您还可以使用它们使代码中的数据类型更加明显。例如，如果您使用`GetFieldAsInteger`，那么任何阅读您代码的人都会清楚地知道该值是整数。
- en: 3.3.1\. Accessing specific features
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1. 访问特定特征
- en: Sometimes you don’t need every feature, so you have no reason to iterate through
    all of them as you’ve done so far. One powerful method of limiting features to
    a subset is to select them by attribute value or spatial extent, and you’ll do
    that in [chapter 5](kindle_split_013.html#ch05). Another way is to look at features
    with specific offsets, also called *feature IDs* (FIDs). The offset is the position
    that the feature is at in the dataset, starting with zero. It depends entirely
    on the position of the feature in the file and has nothing to do with the sort
    order in memory. For example, if you open the ne_50m_populated_places shapefile
    in QGIS and look at the attribute table, it would show Bombo as the first record
    in the table, as in [figure 3.11](#ch03fig11)A. See the numbers in the left-most
    column? Those are the offset values. Now try sorting the table by name by clicking
    on the NAME column header, as shown in [figure 3.11](#ch03fig11)B. Now the first
    record shown in the table is the one for Abakan, but it has an offset of 346\.
    As you can see, that left-most column isn’t a row number like you see in spreadsheets,
    where the row numbers are always in the right order no matter how you sort the
    data. These numbers represent the order in the file instead.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你不需要所有功能，因此你没有必要像之前那样迭代所有功能。限制功能到子集的一种强大方法是按属性值或空间范围选择它们，你将在[第5章](kindle_split_013.html#ch05)中这样做。另一种方法是查看具有特定偏移量的功能，也称为*功能ID*（FIDs）。偏移量是功能在数据集中的位置，从零开始。它完全取决于功能在文件中的位置，与内存中的排序顺序无关。例如，如果你在QGIS中打开ne_50m_populated_places形状文件并查看属性表，它将显示Bombo作为表中的第一条记录，如[图3.11](#ch03fig11)A所示。看到最左侧列的数字了吗？那些是偏移值。现在尝试通过点击NAME列标题按名称对表进行排序，如[图3.11](#ch03fig11)B所示。现在表中显示的第一条记录是Abakan的记录，但它的偏移量为346。正如你所见，最左侧列不是像你在电子表格中看到的行号，行号无论你如何排序数据总是按正确顺序排列。这些数字代表文件中的顺序。
- en: Figure 3.11\. The attribute table for the ne_50m_populated_places shapefile.
    Table A shows the native sort order, with the FIDs in order. Table B has been
    sorted by city name, and the FIDs are no longer ordered sequentially.
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.11。ne_50m_populated_places形状文件的属性表。表A显示了原始排序顺序，FIDs按顺序排列。表B已按城市名称排序，FIDs不再按顺序排列。
- en: '![](03fig11.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11](03fig11.jpg)'
- en: If you know the offset of the feature you want, you can ask for that feature
    by FID. To get the feature for Vatican City, you use `GetFeature(7)`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你想要的功能的偏移量，你可以通过FID请求该功能。要获取梵蒂冈城的功能，你使用`GetFeature(7)`。
- en: 'You can also get the total number of features with `GetFeatureCount`, so you
    could grab the last feature in the layer like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`GetFeatureCount`获取功能总数，因此你可以这样获取图层中的最后一个功能：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You have to subtract one from the total number of features because the first
    index is zero. If you had tried to get the feature at index `num_features,` you’d
    have gotten an error message saying that the feature ID was out of the available
    range. This snippet also shows an alternate way of retrieving an attribute value
    from a feature, instead of using `GetField`, but it only works if you know the
    names beforehand so that you can hardcode them into your script.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须从功能总数中减去一个，因为第一个索引是零。如果你尝试获取索引`num_features`处的功能，你会收到一个错误消息，说功能ID超出了可用范围。这个片段还展示了从功能中检索属性值的一种替代方法，而不是使用`GetField`，但这只在你事先知道名称的情况下有效，这样你就可以将它们硬编码到你的脚本中。
- en: The current feature
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 当前功能
- en: Another important point is that the functions that return features keep track
    of which feature was last accessed; this is the *current feature*. When you first
    get the layer object, it has no current feature. But if you start iterating through
    features, the first time through the loop, the current feature is the one with
    an FID of zero. The second time through the loop, the current feature is the one
    with offset 1, and so on. If you use `GetFeature` to get the one with an FID of
    5, that’s now the current feature, and if you then call `GetNextFeature` or start
    a loop, the next feature returned will be the one with offset 6\. Yes, you read
    that right. If you iterate through the features in the layer, it doesn’t start
    at the first one if you’ve already set the current feature.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的一点是，返回特征的函数会跟踪最后访问的是哪个特征；这是当前的特征。当您第一次获取图层对象时，它没有当前特征。但是如果您开始遍历特征，第一次通过循环时，当前特征是FID为零的那个。第二次通过循环时，当前特征是偏移量为1的那个，以此类推。如果您使用
    `GetFeature` 获取FID为5的那个，那么现在它就是当前特征，如果您随后调用 `GetNextFeature` 或开始一个循环，返回的下一个特征将是偏移量为6的那个。是的，您没有看错。如果您遍历图层中的特征，如果您已经设置了当前特征，它不会从第一个开始。
- en: Based on what you’ve learned so far, what do you think would happen if you iterated
    through all of the features and printed out their names and populations, but then
    later tried to iterate through a second time to print out their names and coordinates?
    If you guessed that no coordinates would print out, you were right. The first
    loop stops when it runs out of features, so the current feature is pointing past
    the last one and isn’t reset to the beginning (see [figure 3.12](#ch03fig12)).
    No next feature is there when the second loop starts, so nothing happens. How
    do you get the current feature to point to the beginning again? You wouldn’t want
    to use a FID of zero, because if you tried to iterate through them all, the first
    feature would be skipped. To solve this problem, use the `layer.ResetReading()`
    function, which sets the current feature pointer to a location before the first
    feature, similar to when you first opened the layer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您迄今为止所学的内容，您认为如果您遍历所有特征并打印出它们的名称和人口，然后在稍后再次遍历以打印出它们的名称和坐标会发生什么？如果您猜测不会打印出坐标，您是对的。第一个循环在运行完所有特征后停止，因此当前特征指针指向最后一个特征之后，并且不会重置到开始位置（见[图3.12](#ch03fig12)）。当第二个循环开始时，没有下一个特征，所以什么也不会发生。您如何让当前特征指针再次指向开始位置？您不想使用零的FID，因为如果您尝试遍历所有特征，第一个特征将被跳过。为了解决这个问题，请使用
    `layer.ResetReading()` 函数，该函数将当前特征指针设置在第一个特征之前的位置，类似于您第一次打开图层时。
- en: Figure 3.12\. The location of the current feature pointer at various times
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.12. 当前特征指针在各个时间点的位置
- en: '![](03fig12.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig12.jpg)'
- en: 3.3.2\. Viewing your data
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2. 查看您的数据
- en: Before we continue, you might find it useful to know about functions in the
    ospybook module that will help you visualize your data without opening it in another
    software program. These don’t allow the level of interaction with the data that
    a GIS does, so opening it in QGIS is still a much better option for exploring
    the data in any depth.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，您可能想知道关于 ospybook 模块中的函数的信息，这些函数可以帮助您在不打开其他软件程序的情况下可视化您的数据。这些函数不允许与数据的交互达到GIS的水平，因此仍然在QGIS中打开是探索数据的更好选择。
- en: Viewing attributes
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查看属性
- en: 'You can print out attribute values to your screen using the `print_attributes`
    function, which looks like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `print_attributes` 函数将属性值打印到屏幕上，其外观如下：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`lyr_or_fn` is either a layer object or the path to a data source. If it’s
    a data source, the first layer will be used.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lyr_or_fn` 是一个图层对象或数据源的路径。如果是数据源，则将使用第一个图层。'
- en: '`n` is an optional number of records to print. The default is to print them
    all.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n` 是可选的记录数量，用于打印。默认情况下，打印所有记录。'
- en: '`fields` is an optional list of attribute fields to include in the printout.
    The default is to include them all.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields` 是一个可选的属性字段列表，用于包含在打印输出中。默认情况下，包含所有字段。'
- en: '`geom` is an optional Boolean flag indicating whether the geometry type is
    printed. The default is `True`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom` 是一个可选的布尔标志，指示是否打印几何类型。默认值为 `True`。'
- en: '`reset` is an optional Boolean flag indicating whether the layer should be
    reset to the first record before printing. The default is `True`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset` 是一个可选的布尔标志，指示在打印之前是否应该将图层重置到第一条记录。默认值为 `True`。'
- en: 'For example, to print out the name and population for the first three cities
    in the populated places shapefile, you could do something like this from a Python
    interactive window:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要打印出人口密集地区形状文件中前三个城市的名称和人口，你可以在 Python 交互窗口中这样做：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Normally, you must provide arguments to functions in the order they’re listed,
    but if you want to provide an optional argument without specifying values for
    earlier optional parameters, you can use keywords to specify which parameter you
    mean. For example, If you wanted to set `geom` to `False` without specifying a
    list of fields, you could do it like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你必须按照它们列出的顺序为函数提供参数，但如果你想提供一个可选参数而不指定早期可选参数的值，你可以使用关键字来指定你指的是哪个参数。例如，如果你想将
    `geom` 设置为 `False` 而不指定字段列表，你可以这样做：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function works well for viewing small numbers of attributes, but you’ll
    probably regret using it to print all attributes of a large file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数对于查看少量属性效果良好，但如果你用它来打印大文件的全部属性，你可能会后悔。
- en: Plotting spatial data
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 绘制空间数据
- en: 'The ospybook module also contains convenience classes to help you visualize
    your data spatially, although you’ll learn how to do it yourself in the last chapter.
    To use these, you must have the matplotlib Python module installed. To plot your
    data, you need to create a new instance of the `VectorPlotter` class and pass
    a Boolean parameter to the constructor indicating if you want to use interactive
    mode. If interactive, the data will be drawn immediately when you plot it. If
    not interactive, you’ll need to call `draw` after plotting the data, and everything
    will be drawn at once. Either way, once you’ve created this object, you can use
    it to plot your data with the `plot` method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ospybook 模块还包含方便的类，可以帮助你从空间上可视化你的数据，尽管你将在最后一章中学习如何自己做到这一点。要使用这些类，你必须安装 matplotlib
    Python 模块。要绘制你的数据，你需要创建 `VectorPlotter` 类的新实例，并将一个布尔参数传递给构造函数，以指示你是否想使用交互模式。如果是交互模式，数据将在绘图时立即绘制。如果不是交互模式，你需要在绘制数据后调用
    `draw`，所有内容将一次性绘制。无论哪种方式，一旦创建了此对象，你就可以使用它通过 `plot` 方法绘制你的数据：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`geom_or_lyr` is a geometry, layer, or path to a data source. If a data source,
    the first layer will be drawn.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom_or_lyr` 是一个几何形状、图层或数据源的路径。如果是一个数据源，则将绘制第一层。'
- en: '`symbol` is an optional `pyplot` symbol to draw the geometries with.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbol` 是一个可选的 `pyplot` 符号，用于绘制几何图形。'
- en: '`name` is an optional name to assign to the data so it can be accessed later.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 是一个可选的名称，用于分配给数据，以便以后可以访问它。'
- en: '`kwargs` are optional `pyplot` drawing parameters that are specified by keyword
    (you’ll see the abbreviation `kwargs` used often for an indeterminate number of
    keyword arguments).'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kwargs` 是通过关键字指定的可选 `pyplot` 绘图参数（你将经常看到 `kwargs` 缩写用于不定数量的关键字参数）。'
- en: 'The `plot` function can optionally use parameters from the `pyplot` interface
    in matplotlib. You’ll see a few used in this book, but to see more you can read
    the `pyplot` documentation at [http://matplotlib.org/1.5.0/api/pyplot_summary.html](http://matplotlib.org/1.5.0/api/pyplot_summary.html).
    Let’s start with an example that plots the populated places shapefile on top of
    country outlines:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot` 函数可以可选地使用 matplotlib 的 `pyplot` 接口中的参数。你将在本书中看到一些使用示例，但要了解更多，你可以阅读 [http://matplotlib.org/1.5.0/api/pyplot_summary.html](http://matplotlib.org/1.5.0/api/pyplot_summary.html)
    上的 `pyplot` 文档。让我们从一个示例开始，该示例在国家轮廓上绘制人口密集地区的形状文件：'
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first thing you do is use the built-in os module to change your working
    directory, which allows you to use filenames later instead of typing the entire
    path. Then you pass `True` to `VectorPlotter` to create an interactive plotter.
    The `fill pyplot` parameter causes the countries shapefile to be drawn as hollow
    polygons, and the `'bo'` symbol for populated places means blue circles. This
    results in a plot that looks like [figure 3.13](#ch03fig13).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先要做的是使用内置的 os 模块更改你的工作目录，这允许你以后使用文件名而不是输入整个路径。然后你将 `True` 传递给 `VectorPlotter`
    以创建一个交互式绘图器。`fill pyplot` 参数导致国家形状文件被绘制为空心多边形，而 `'bo'` 符号表示人口密集地区为蓝色圆圈。这导致了一个看起来像
    [图 3.13](#ch03fig13) 的图表。
- en: Figure 3.13\. The output from plotting the global populated places shapefile
    on top of the country outlines
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.13\. 在国家轮廓上绘制全球人口密集地区形状文件的输出
- en: '![](03fig13.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig13.jpg)'
- en: You don’t need to do anything special if you want to use this in a script, but
    you should know that when the plotter isn’t created with interactive mode, it
    will stop script execution until you close the window that pops up. I’ve also
    discovered that depending on the environment I’m running the script from, sometimes
    it closes itself automatically if I created it with interactive mode, so I never
    get the chance to view it. Because of this, if I’m using a `VectorPlotter` in
    a script instead of a Python interactive window, I usually create it using non-interactive
    mode and call `draw` at the end of the script. The source code for this chapter
    has examples of this.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在脚本中使用这些信息，你不需要做任何特殊的事情，但你应该知道，当绘图器不是在交互模式下创建时，它将停止脚本执行，直到你关闭弹出的窗口。我还发现，根据我运行脚本的运行环境，有时如果我用交互模式创建它，它有时会自动关闭，所以我从未有机会查看它。因此，如果我在脚本中使用`VectorPlotter`而不是Python交互窗口，我通常使用非交互模式创建它，并在脚本末尾调用`draw`。本章的源代码有这个示例的例子。
- en: 3.4\. Getting metadata about the data
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4. 获取数据元数据
- en: Sometimes you also need to know general information about a dataset, such as
    the number of features, spatial extent, geometry type, spatial reference system,
    or the names and types of attribute fields. For example, say you want to display
    your data on top of a Google map. You need to make sure that your data use the
    same spatial reference system as Google, and you need to know the spatial extent
    so that you can have your map zoom to the correct part of the world. Because different
    geometry types have different drawing options, you also need to know geometry
    types to define the symbology for your features.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你也需要了解数据集的一般信息，例如特征数量、空间范围、几何类型、空间参考系统，或者属性字段的名称和类型。例如，假设你想在谷歌地图上显示你的数据。你需要确保你的数据使用与谷歌相同的空间参考系统，并且你需要知道空间范围，这样你才能将地图缩放到世界的正确部分。因为不同的几何类型有不同的绘图选项，所以你还需要知道几何类型来定义你特征的症状。
- en: You’ve already seen how to get some of these, such as the number of features
    in a layer with `GetFeatureCount`. Remember that this applies to the layer and
    not the data source, because each layer in a data source can have a different
    number of features, geometry type, spatial extent, or attributes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何获取一些这些信息，例如使用`GetFeatureCount`获取图层中的特征数量。请记住，这适用于图层而不是数据源，因为数据源中的每个图层可以有不同的特征数量、几何类型、空间范围或属性。
- en: 'The spatial extent of a layer is the rectangle constructed from the minimum
    and maximum bounding coordinates in all directions. [Figure 3.14](#ch03fig14)
    shows the Washington large_cities file and its extent. You can get these bounding
    coordinates from a layer object with the `GetExtent` function, which returns a
    tuple of numbers as `(min_x, max_x, min_y, max_y)`. Here’s an example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图层的空间范围是由所有方向上的最小和最大边界坐标构成的矩形。[图3.14](#ch03fig14)显示了华盛顿大型城市文件及其范围。你可以通过图层对象使用`GetExtent`函数来获取这些边界坐标，该函数返回一个包含数字的元组，格式为`(min_x,
    max_x, min_y, max_y)`。以下是一个示例：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Figure 3.14\. Here you can see the spatial extent of the large_cities dataset.
    The minimum and maximum longitude (x) values are approximately -122.7 and -117.4,
    respectively. The minimum and maximum latitude (y) values are approximately 45.6
    and 48.8.
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.14。在这里，你可以看到大型城市数据集的空间范围。最小和最大经度（x）值分别约为-122.7和-117.4。最小和最大纬度（y）值分别约为45.6和48.8。
- en: '![](03fig14_alt.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig14_alt.jpg)'
- en: Compare these numbers to those in [figure 3.14](#ch03fig14) to better understand
    what’s returned in the extent tuple.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些数字与[图3.14](#ch03fig14)中的数字进行比较，以更好地理解返回的范围元组。
- en: 'You can also get the geometry type from the layer object, but there’s a catch.
    The `GetGeomType` function returns an integer instead of a human-readable string.
    But how is that useful? The OGR module has a number of constants, shown in [table
    3.1](#ch03table01), which are basically unchangeable variables with descriptive
    names and numeric values. You can compare the value you get with `GetGeomType`
    to one of these constants in order to check if it’s that geometry type. For example,
    the constant for point geometries is `wkbPoint` and the one for polygons is `wkbPolygon`,
    so continuing with the previous example, you could find out if large_cities.shp
    is a point or polygon shapefile like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从图层对象中获取几何类型，但有一个限制。`GetGeomType`函数返回一个整数而不是可读的字符串。但这有什么用呢？OGR模块有许多常量，如[表3.1](#ch03table01)所示，这些常量基本上是不可更改的变量，具有描述性的名称和数值。你可以将`GetGeomType`返回的值与这些常量之一进行比较，以检查它是否是那种几何类型。例如，点几何形状的常量是`wkbPoint`，多边形的常量是`wkbPolygon`，所以继续前面的例子，你可以这样找出large_cities.shp是点还是多边形形状文件：
- en: '![](052fig01_alt.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![052fig01_alt.jpg]'
- en: Table 3.1\. Common geometry type constants. You can find more in [appendix B](kindle_split_023.html#app02).
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.1. 常见几何类型常量。你可以在[附录B](kindle_split_023.html#app02)中找到更多信息。
- en: '| Geometry type | OGR constant |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 几何类型 | OGR常量 |'
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Point | wkbPoint |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| Point | wkbPoint |'
- en: '| Mulitpoint | wkbMultiPoint |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| Mulitpoint | wkbMultiPoint |'
- en: '| Line | wkbLineString |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| Line | wkbLineString |'
- en: '| Multiline | wkbMultiLineString |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| Multiline | wkbMultiLineString |'
- en: '| Polygon | wkbPolygon |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| Polygon | wkbPolygon |'
- en: '| Multipolygon | wkbMultiPolygon |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| Multipolygon | wkbMultiPolygon |'
- en: '| Unknown geometry type | wkbUnknown |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| Unknown geometry type | wkbUnknown |'
- en: '| No geometry | wkbNone |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| No geometry | wkbNone |'
- en: If the layer has geometries of varying types, such as a mixture of points and
    polygons, `GetGeomType` will return `wkbUnknown`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图层包含不同类型的几何形状，例如点和多边形的混合，`GetGeomType`将返回`wkbUnknown`。
- en: '|  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The wkb prefix on the OGR geometry constants stands for well-known binary (WKB),
    which is a standard binary representation used to exchange geometries between
    different software packages. Because it’s binary, it isn’t human-readable, but
    a well-known text (WKT) format does exist that is readable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: OGR几何常量中的wkb前缀代表已知二进制（WKB），这是一种用于在不同软件包之间交换几何形状的标准二进制表示。因为它是以二进制形式存在的，所以它不是可读的，但存在一种已知文本（WKT）格式，它是可读的。
- en: '|  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Sometimes you’d rather have a human-readable string, however, and you can get
    this from one of the feature geometries. The following example grabs the first
    feature in the layer, gets the geometry object from that feature, and then prints
    the name of the geometry:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能更希望有一个可读的字符串，而你可以从特征几何中获取这个字符串。以下示例从图层中获取第一个特征，从该特征中获取几何对象，然后打印出几何名称：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Another useful piece of data you can get from the layer object is the spatial
    reference system, which describes the coordinate system that the dataset uses.
    Your GPS unit probably shows unprojected, or geographic, coordinates by default.
    These are the latitude and longitude coordinates that we’re all familiar with.
    These geographic coordinates can be converted to many other types of coordinate
    systems, however, and if you don’t know which of these systems a dataset uses,
    then you have no way of knowing where on the earth the coordinates refer to. Obviously,
    this is a crucial bit of metadata, and I’ll talk more about it in [chapter 8](kindle_split_016.html#ch08).
    For now, you only need to know that you can get this information. If you print
    it out, you’ll get a string that describes the reference system in WKT format,
    like that shown in [listing 3.2](#ch03ex02).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从图层对象中获取另一条有用的数据，即空间参考系统，它描述了数据集使用的坐标系。你的GPS设备默认可能显示未投影的或地理坐标。这是我们所有人都熟悉的纬度和经度坐标。然而，这些地理坐标可以转换为许多其他类型的坐标系，如果你不知道数据集使用的是哪种系统，那么你就无法知道这些坐标在地球上的位置。显然，这是一项至关重要的元数据，我将在[第8章](kindle_split_016.html#ch08)中更多地讨论它。现在，你只需要知道你可以获取这些信息。如果你打印出来，你会得到一个字符串，它以WKT格式描述了参考系统，就像[列表3.2](#ch03ex02)中所示的那样。
- en: Listing 3.2\. Example of well-known text representation of a spatial reference
    system
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.2. 空间参考系统已知文本表示的示例
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Depending on your GIS experience, this output may or may not mean much to you.
    Don’t worry if it makes no sense now, because you’ll learn all about it later.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的GIS经验，这个输出可能对你来说意义不大。如果你现在觉得没有意义，不要担心，因为稍后你会了解到所有关于它的信息。
- en: 'Last, you can also get information about the attribute fields attached to the
    layer. The easiest way to do this is to use the schema property on the layer object
    to get a list of `FieldDefn` objects. Each of these contains information such
    as the attribute column name and data type. Here’s an example of printing out
    the name and data type of each field:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你还可以获取有关附加到图层的属性字段的信息。最简单的方法是使用图层对象的模式属性来获取`FieldDefn`对象列表。这些对象中的每一个都包含诸如属性列名称和数据类型等信息。以下是一个打印出每个字段名称和数据类型的示例：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Part of this output was left out in the interest of space, but you can run the
    code yourself to see the rest of the fields in the layer. You’ll learn more about
    working with `FieldDefn` objects in [section 3.5.2](#ch03lev2sec4).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，这里省略了一部分输出，但你可以运行代码自己查看图层中其余的字段。你将在[3.5.2节](#ch03lev2sec4)中了解更多关于与`FieldDefn`对象一起工作的内容。
- en: 3.5\. Writing vector data
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5. 写入矢量数据
- en: Reading data is definitely useful, but you’ll probably need to edit existing
    or create new datasets. [Listing 3.3](#ch03ex03) shows how to create a new shapefile
    that contains only the features corresponding to capital cities in the global
    populated places shapefile. The output will look like the cities in [figure 3.15](#ch03fig15).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据肯定是有用的，但你可能还需要编辑现有或创建新的数据集。[列表3.3](#ch03ex03)展示了如何创建一个新的shapefile，该shapefile只包含全球已填充地点shapefile中对应首都城市的要素。输出将类似于[图3.15](#ch03fig15)中的城市。
- en: Figure 3.15\. Capital cities with country outlines for reference
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.15. 带有国家轮廓的首都城市，供参考
- en: '![](03fig15.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig15.jpg)'
- en: Listing 3.3\. Exporting capital cities to a new shapefile
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.3. 将首都城市导出到新的shapefile
- en: '![](055fig01_alt.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](055fig01_alt.jpg)'
- en: In this example you open up a folder instead of a shapefile as the data source.
    A nice feature of the shapefile driver is that it will treat a folder as a data
    source if a majority of the files in the folder are shapefiles, and each shapefile
    is treated as a layer. Notice that you pass `1` as the second parameter to `Open`,
    which will allow you to create a new layer (shapefile) in the folder. You pass
    the shapefile name, without the extension, to `GetLayer` to get the populated
    places shapefile as a layer. Even though you open it differently here than in
    [listing 3.1](#ch03ex01), you can use it in exactly the same way.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你打开一个文件夹作为数据源，而不是shapefile。shapefile驱动程序的一个优点是，如果文件夹中的大多数文件是shapefile，它将把文件夹视为数据源，并且每个shapefile被视为一个图层。请注意，你将`1`作为`Open`函数的第二个参数传递，这将允许你在文件夹中创建一个新的图层（shapefile）。你将不带扩展名的shapefile名称传递给`GetLayer`以获取作为图层的已填充地点shapefile。即使你在这里以不同的方式打开它，与[列表3.1](#ch03ex01)相比，你仍然可以以完全相同的方式使用它。
- en: Because OGR won’t overwrite existing layers, you check to see if the output
    layer already exists, and delete it if it did. Obviously you wouldn’t want to
    do this if you didn’t want the layer overwritten, but in this case you can overwrite
    data as you test different things.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因为OGR不会覆盖现有的图层，所以你需要检查输出图层是否已经存在，如果存在，则删除它。显然，如果你不希望图层被覆盖，你不会想这样做，但在这个例子中，你可以在测试不同的事情时覆盖数据。
- en: 'Then you create a new layer to store your output data in. The only required
    parameter for `CreateLayer` is a name for the layer, which should be unique within
    the data source. You do have, however, several optional parameters that you should
    set when possible:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你创建一个新的图层来存储你的输出数据。`CreateLayer`函数的唯一必需参数是图层的名称，该名称应在数据源内是唯一的。然而，你确实有多个可选参数，在可能的情况下你应该设置这些参数：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`name` is the name of the layer to create.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`是要创建的图层的名称。'
- en: '`srs` is the spatial reference system that the layer will use. The default
    is `None`, meaning that no spatial reference system will be assigned.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srs`是图层将使用的空间参考系统。默认值为`None`，表示不会分配任何空间参考系统。'
- en: '`geom_type` is a geometry type constant from [table 3.1](#ch03table01) that
    specifies the type of geometry the layer will hold. The default is `wkbUnknown`.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom_type`是从[表3.1](#ch03table01)中获取的几何类型常量，它指定了图层将持有的几何类型。默认值为`wkbUnknown`。'
- en: '`options` is an optional list of layer-creation options, which only applies
    to certain vector format types.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`是一个可选的图层创建选项列表，仅适用于某些矢量格式类型。'
- en: The first of these optional parameters is the spatial reference, which defaults
    to `None` if not provided. Remember that without spatial reference information,
    it’s extremely difficult to figure out where the features are on the planet. Sometimes
    the spatial reference is implicit in the data; for example, KML only supports
    unprojected coordinates using the WGS 84 datum, but you should set this if possible.
    In this case, you copy the spatial reference information from the original shapefile
    to the new one. We’ll discuss spatial reference systems and how to use them in
    more detail in [chapter 8](kindle_split_016.html#ch08).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可选参数中的第一个是空间参考，如果没有提供，则默认为`None`。请记住，如果没有空间参考信息，很难确定特征在地球上的位置。有时空间参考隐含在数据中；例如，KML仅支持使用WGS
    84大地基准的未投影坐标，但如果有可能，您应该设置它。在这种情况下，您将空间参考信息从原始shapefile复制到新文件中。我们将在[第8章](kindle_split_016.html#ch08)中更详细地讨论空间参考系统及其使用方法。
- en: The second optional parameter is one of the OGR geometry type constants from
    either [table 3.1](#ch03table01) or [appendix B](kindle_split_023.html#app02).
    This specifies the type of geometries that the layer will contain. If not provided,
    it defaults to `ogr.wkbUnknown`, although in many cases this will be updated to
    the correct value after you add features to the layer and it can be determined
    from them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个可选参数是来自[表3.1](#ch03table01)或[附录B](kindle_split_023.html#app02)的OGR几何类型常量之一。这指定了图层将包含的几何类型。如果没有提供，它默认为`ogr.wkbUnknown`，尽管在许多情况下，在您向图层添加特征后，它将被更新为正确的值，并且可以从它们中确定。
- en: The last optional parameter is a list of layer-creation option strings in the
    form of *option=value*. These are documented for each driver on the OGR formats
    webpage. Not all vector data formats have layer-creation options, and even if
    a format does have options, you’re under no obligation to use them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个可选参数是一系列以*option=value*形式的图层创建选项字符串。这些在OGR格式网页上的每个驱动程序中都有文档说明。并非所有矢量数据格式都有图层创建选项，即使格式有选项，您也没有义务使用它们。
- en: 'You use the following code to create a new point shapefile called capital_cities.shp
    that uses the same spatial reference system as the populated places shapefile.
    You do one more thing, though. The `schema` property on the input layer returns
    a list of attribute field definitions for that layer, and you pass that list to
    `CreateFields` to create the exact same set of attribute fields in the new layer:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码创建一个名为capital_cities.shp的新点shapefile，它使用与人口密集地区shapefile相同的空间参考系统。不过，您还需要做一件事。输入图层的`schema`属性返回该图层属性字段定义的列表，您将此列表传递给`CreateFields`以在新的图层中创建完全相同的属性字段集：
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, to add a feature to a layer, you need to create a dummy feature that you
    add the geometry and attributes to, and then you insert that into the layer. The
    next step is to create this blank feature. Creating a feature requires a feature
    definition that contains information about the geometry type and all of the attribute
    fields, and this is used to create an empty feature with the same fields and geometry
    type. You need to get the feature definition from the layer you plan to add features
    to, but you must do it after you’ve added, deleted, or updated any fields. If
    you get the feature definition first, and then change the fields in any way, the
    definition will be out of date. This means that a feature you try to insert based
    on this outdated definition will not match reality, as seen in [figure 3.16](#ch03fig16).
    This will cause Python to die a horrible death, and you definitely don’t want
    that.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要向图层添加一个特征，您需要创建一个虚拟特征，将几何和属性添加到其中，然后将其插入到图层中。下一步是创建这个空白特征。创建特征需要一个包含有关几何类型和所有属性字段信息的特征定义，并使用它来创建具有相同字段和几何类型的空特征。您需要从您计划添加特征的图层中获取特征定义，但您必须在添加、删除或更新任何字段之后进行。如果您首先获取特征定义，然后以任何方式更改字段，定义将过时。这意味着基于这个过时的定义尝试插入的特征将不会与实际情况匹配，如图3.16所示。这将导致Python以可怕的方式死亡，您肯定不希望那样。
- en: Figure 3.16\. Always get feature definitions after making changes to fields,
    or the definition will not match reality.
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.16。在更改字段后，始终获取特征定义，否则定义将不会与实际情况匹配。
- en: '![](03fig16_alt.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图3.16](03fig16_alt.jpg)'
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that you have a feature to put information into, it’s time to start looping
    through the input dataset. For each feature, you check to see if its `FEATURECLA`
    attribute was equal to `''Admin-0 capital''`, which means it’s a capital city.
    If it is, then you copy the geometry from it into the dummy feature. Then you
    loop through all of the fields in the attribute table and copy the values from
    the input feature into the output feature. This works because you create the fields
    in the new shapefile based on the fields in the original, so they’re in the same
    order in both shapefiles. If they were in different orders, you’d have to use
    their names to access them, but you can use indexes here because you know that
    they match:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个可以存放信息的特征，是时候开始遍历输入数据集了。对于每个特征，你检查其`FEATURECLA`属性是否等于`'Admin-0 capital'`，这意味着它是一个首都。如果是的话，你就将几何信息从它复制到虚拟特征中。然后你遍历属性表中的所有字段，并将输入特征的值复制到输出特征中。这是因为你在新的shapefile中创建的字段是基于原始文件中的字段创建的，所以它们在两个shapefile中的顺序是相同的。如果它们的顺序不同，你将不得不使用它们的名称来访问它们，但在这里你可以使用索引，因为你知道它们是一致的：
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once you copy all of the attribute fields over, you insert the feature into
    the layer using `CreateFeature`. This function saves a copy of the feature, including
    all of the information you add to it, to the layer. The feature object can then
    be reused, and whatever you do to it won’t affect the data that have already been
    added to the layer. This way you don’t have the overhead of creating multiple
    features, because you can create a single one and keep editing its data each time
    you want to add a new feature to the layer.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你复制了所有的属性字段，你使用`CreateFeature`将特征插入到图层中。这个函数将特征及其所有添加的信息的副本保存到图层中。特征对象可以被重复使用，你对它所做的任何操作都不会影响已经添加到图层中的数据。这样你就不需要创建多个特征，因为你可以创建一个，并在每次你想向图层添加新特征时编辑其数据。
- en: 'You delete the `ds` variable at the end of the script, which forces the files
    to close and all of your edits to be written to disk. Deleting the layer variable
    doesn’t do the trick; you must close the data source. If you wanted to keep the
    data source open, you could call `SyncToDisk` on either the layer or data source
    object instead, like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你在脚本末尾删除了`ds`变量，这强制文件关闭，并将所有编辑写入磁盘。删除图层变量不起作用；你必须关闭数据源。如果你想保持数据源打开，你可以对图层或数据源对象调用`SyncToDisk`，如下所示：
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: You must close your files or call `SyncToDisk` to flush your edits to disk.
    If you don’t do this, and your interactive environment still has your data source
    open, you’ll be disappointed to find an empty dataset.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须关闭你的文件或调用`SyncToDisk`以将你的编辑刷新到磁盘。如果你不这样做，并且你的交互式环境仍然打开了你的数据源，你将失望地发现一个空的数据集。
- en: '|  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'It’s always a good idea to carefully inspect your output to make sure you get
    the results you want. The best way would be to open it in QGIS, or you could get
    a good idea by plotting it from Python ([figure 3.17](#ch03fig17)):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查你的输出以确保你得到你想要的结果总是一个好主意。最好的方式是在QGIS中打开它，或者你也可以通过Python将其绘制出来来获得一个很好的概念（[图3.17](#ch03fig17)）：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Figure 3.17\. The result of plotting the new capital cities shapefile on top
    of country outlines
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.17。将新的首都shapefile叠加在国家轮廓上的结果
- en: '![](03fig17.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig17.jpg)'
- en: Let’s return to the topic of adding attribute values for a moment. You might
    be wondering if multiple functions exist for setting attribute field values as
    with retrieving values. The answer is generally no. Most data will be converted
    to the correct type for you, but you may not like the results if a conversion
    isn’t possible. For example, pretend for a minute that you made a mistake and
    inserted the population into the `Name` field, and the name into the `Population`
    field. Do you think that the population could be converted to a string and successfully
    inserted into the `Name` field? How about converting the country name to a number
    so it could go in the `Population` field? Well, converting a number to a string
    works fine, but converting a string to a number is problematic. The string `"3578"`
    can be translated into the number 3578, but what about the string `"Russia"`?
    If you try it in a Python interactive window by typing `int('Russia'),` you’ll
    get an error, but OGR will insert a zero into the `Population` field instead of
    crashing. Sometimes this behavior is to your advantage because you don’t need
    to convert data before inserting it in a feature, but it can also be a problem
    if you mistakenly try to insert the wrong type of data into a field.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时回到为属性添加值的话题。你可能想知道，在检索值时存在多个函数，设置属性字段值时是否也存在多个函数。答案是通常没有。大多数数据都会自动转换为正确的类型，但如果你无法进行转换，结果可能并不理想。例如，假设你犯了一个错误，将人口数据插入到`Name`字段中，而将名称插入到`Population`字段中。你认为人口数据能否转换为字符串并成功插入到`Name`字段中？又或者将国家名称转换为数字以便放入`Population`字段中？好吧，将数字转换为字符串是可行的，但将字符串转换为数字则存在问题。字符串`"3578"`可以转换为数字3578，但`"Russia"`字符串怎么办？如果你在Python交互式窗口中输入`int('Russia')`，你会得到一个错误，但OGR会将在`Population`字段中插入零而不是崩溃。有时这种行为对你有利，因为你不需要在将数据插入要素之前转换数据，但如果错误地尝试将错误类型的数据插入字段，这也可能成为一个问题。
- en: 3.5.1\. Creating new data sources
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.1\. 创建新的数据源
- en: You used an existing data source in [listing 3.3](#ch03ex03), but sometimes
    you’ll need to create new ones. Fortunately, it’s not difficult. Perhaps the most
    important part is that you use the correct driver. It’s the driver that does the
    work here, and each driver only knows how to work with one vector format, so using
    the correct one is essential. For example, the GeoJSON driver won’t create a shapefile,
    even if you ask it to create a file with an .shp extension. As shown in [figure
    3.18](#ch03fig18), the output will have an .shp extension, but it will still be
    a GeoJSON file at heart.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[列表3.3](#ch03ex03)中使用了现有的数据源，但有时你需要创建新的数据源。幸运的是，这并不困难。也许最重要的部分是使用正确的驱动程序。在这里，驱动程序负责工作，每个驱动程序只知道如何处理一种矢量格式，因此使用正确的驱动程序是至关重要的。例如，GeoJSON驱动程序不会创建shapefile，即使你要求它创建一个具有.shp扩展名的文件。如图3.18所示，输出将具有.shp扩展名，但本质上仍然是一个GeoJSON文件。
- en: Figure 3.18\. Using the GeoJSON driver to create a file with an .shp extension
    will still create a GeoJSON file, not a shapefile.
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.18\. 使用GeoJSON驱动程序创建具有.shp扩展名的文件仍然会创建一个GeoJSON文件，而不是shapefile。
- en: '![](03fig18_alt.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig18_alt.jpg)'
- en: 'You have a couple of ways to get the required driver. The first is to get the
    driver from a dataset that you’ve already opened, which will allow you to create
    a new data source using the same vector data format as the existing data source.
    In this example, the `driver` variable will hold the ESRI shapefile driver:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你有几种方法可以获取所需的驱动程序。第一种是从你已打开的数据集中获取驱动程序，这将允许你使用与现有数据源相同的矢量数据格式创建新的数据源。在这个例子中，`driver`变量将包含ESRI
    shapefile驱动程序：
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The second way to get a driver object is to use the OGR function `GetDriverByName`
    and pass it the short name of the driver. Remember that these names are available
    on the OGR website, by using the `ogrinfo` utility that comes with GDAL/OGR, or
    the `print_drivers` function available in the code accompanying this book. This
    example will get the GeoJSON driver:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 获取驱动程序对象的第二种方式是使用OGR函数`GetDriverByName`，并传递驱动程序的简称。请记住，这些名称可以在OGR网站上找到，通过使用GDAL/OGR附带的`ogrinfo`实用程序，或者通过使用本书代码中可用的`print_drivers`函数。此示例将获取GeoJSON驱动程序：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once you have a driver object, you can use it to create an empty data source
    by providing the data source name. This new data source is automatically open
    for writing, and you can add layers to it the way you did in [listing 3.3](#ch03ex03).
    If the data source can’t be created, then `CreateDataSource` returns `None`, so
    you need to check for this condition:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了驱动程序对象，你可以通过提供数据源名称来使用它创建一个空的数据源。这个新的数据源自动打开用于写入，你可以像在[列表3.3](#ch03ex03)中做的那样向其中添加图层。如果无法创建数据源，则`CreateDataSource`返回`None`，因此你需要检查这个条件：
- en: '[PRE23]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A few data formats have creation options that you can use when creating a data
    source, although these aren’t required. Like layer-creation options, these parameters
    are documented on the OGR website. Don’t confuse the two, because data source
    and layer-creation options are two different things. Both types are passed as
    a list of strings, however. Let’s see how you’d use a data source–creation option
    to create a full-fledged SpatiaLite data source instead of SQLite. This will fail
    if your version of OGR wasn’t built with SpatiaLite support, though:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据格式在创建数据源时提供了你可以使用的创建选项，尽管这些选项不是必需的。就像图层创建选项一样，这些参数在OGR网站上都有文档说明。不要混淆这两者，因为数据源和图层创建选项是两回事。然而，这两种类型都作为字符串列表传递。让我们看看如何使用数据源创建选项来创建一个完整的SpatiaLite数据源而不是SQLite。如果你的OGR版本没有使用SpatiaLite支持构建，这将失败：
- en: '[PRE24]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Another thing to be aware of when creating new data sources is that you can’t
    overwrite an existing data source. If a chance exists that your code might legitimately
    try to overwrite a dataset, then you’ll need to delete the old one before attempting
    to create the new one. One way to deal with this would be to use the Python `os.path.exists`
    function to see if a file already exists before you attempt to create a data source;
    or you could wait and deal with it if your original attempt fails, either after
    checking for `None` or by using a try/except block. Either way, you should use
    the driver to delete the existing source instead of using a Python built-in function.
    Why? Because the driver will make sure that all required files are deleted. For
    example, if you’re deleting a shapefile, the shapefile driver will delete the
    .shp, .dbf, .shx, and any other optional files that may be present. If you were
    using the Python built-in module to delete the shapefile, you’d have to make sure
    your code checked for all of these files. Here’s an example of one way to deal
    with an existing data source:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新数据源时需要注意的另一件事是，你不能覆盖现有的数据源。如果你的代码可能会合法地尝试覆盖数据集，那么在尝试创建新数据源之前，你需要删除旧的。处理这个问题的一种方法是在尝试创建数据源之前使用Python的`os.path.exists`函数来检查文件是否已经存在；或者你可以等待，如果原始尝试失败（无论是检查`None`还是使用try/except块），再处理它。无论如何，你应该使用驱动程序来删除现有的源，而不是使用Python内置函数。为什么？因为驱动程序将确保删除所有必需的文件。例如，如果你正在删除shapefile，shapefile驱动程序将删除.shp、.dbf、.shx以及可能存在的任何其他可选文件。如果你使用Python内置模块删除shapefile，你必须确保你的代码检查了所有这些文件。以下是一个处理现有数据源的方法示例：
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you try to create a shapefile as a data source rather than a layer (where
    the data source is the containing folder), and the shapefile already exists, you’ll
    get an odd error message saying that the shapefile isn’t a directory.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试创建一个作为数据源而不是图层（数据源是包含文件夹）的shapefile，并且shapefile已经存在，你会得到一个奇怪的错误消息，说shapefile不是一个目录。
- en: '|  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using OGR exceptions**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用OGR异常**'
- en: By default, OGR doesn’t raise an error if it has a problem, such as failing
    to create a new data source. This is why you check for `None`, but Python programmers
    generally expect an error to be raised instead. You can enable this behavior if
    you’d like, by calling `ogr.UseExceptions()` at the beginning of your code. Although
    most of the time this works as anticipated, I’ve discovered that it doesn’t always
    raise an error when I expect. For example, no error is raised if OGR fails to
    open a data source. However, in instances where it does raise an error, you don’t
    need to check for `None` before continuing. Using exceptions also gives you flexibility
    with handling errors.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，OGR在遇到问题，例如无法创建新的数据源时，不会引发错误。这就是为什么你需要检查`None`，但Python程序员通常期望会引发错误。如果你希望启用这种行为，可以在代码开头调用`ogr.UseExceptions()`。尽管大多数时候这会按预期工作，但我发现它并不总是在我期望的时候引发错误。例如，如果OGR无法打开数据源，则不会引发错误。然而，在它确实引发错误的情况下，你不需要在继续之前检查`None`。使用异常也为你处理错误提供了灵活性。
- en: 'For example, here’s a contrived situation where I’m pretending to process data,
    then I want to save some temporary data to a GeoJSON file, and then I want to
    keep processing something else. If I can’t create the temporary file, I want to
    skip that step and go on to the next bit of data processing rather than crashing.
    Here’s the sample code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个假设的情况，我假装在处理数据，然后我想将一些临时数据保存到GeoJSON文件中，然后我想继续处理其他数据。如果我不能创建临时文件，我想跳过该步骤并继续处理下一部分数据，而不是崩溃。以下是一个示例代码：
- en: '![](061fig01_alt.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](061fig01_alt.jpg)'
- en: 'Suppose that the africa.geojson file already exists. This code doesn’t check
    for that, so you know it will fail when you call `CreateDataSource`. If you weren’t
    using OGR exceptions, this script would fail at that point and never get to the
    last `print` statement. But because you’re using exceptions, you’ll get an error
    message saying that the file couldn’t be created, and then it will continue on
    to the last `print` statement, and the output will look like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 假设africa.geojson文件已经存在。此代码不会检查这一点，所以你知道在调用`CreateDataSource`时它将失败。如果你没有使用OGR异常，此脚本将在该点失败，并且永远不会到达最后的`print`语句。但是，因为你使用了异常，你会得到一个错误消息，说明文件无法创建，然后它会继续到最后一个`print`语句，输出将如下所示：
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Try it out yourself and comment out the first line, and watch how the behavior
    changes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己操作并注释掉第一行，然后观察行为如何变化。
- en: '|  |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.5.2\. Creating new fields
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.2\. 创建新字段
- en: You saw in [listing 3.3](#ch03ex03) how to copy attribute field definitions
    from one layer to another, but you can also define your own custom fields. Several
    different field types are available, but not all are supported by all data formats.
    This is another situation when the online documentation for the various formats
    will come in handy, so hopefully you’ve bookmarked that page.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[列表3.3](#ch03ex03)中看到了如何从一个图层复制属性字段定义到另一个图层，但你也可以定义自己的自定义字段。有几种不同的字段类型可用，但并非所有数据格式都支持。在这种情况下，各种格式的在线文档将非常有用，所以希望你已经将该页面添加到书签。
- en: To add a field to a layer, you need a `FieldDefn` object that contains the important
    information about the field, such as name, data type, width, and precision. The
    `schema` property you used in [listing 3.3](#ch03ex03) returns a list of these,
    one for each field in the layer. You can create your own, however, by providing
    the name and data type for the new field to the `FieldDefn` constructor. The data
    type is one of the constants from [table 3.2](#ch03table02).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字段添加到图层中，你需要一个包含字段重要信息的`FieldDefn`对象，例如名称、数据类型、宽度和精度。你在[列表3.3](#ch03ex03)中使用的`schema`属性返回一个列表，其中包含图层中每个字段的这些信息。然而，你也可以通过向`FieldDefn`构造函数提供新字段的名称和数据类型来自定义它。数据类型是[表3.2](#ch03table02)中的常量之一。
- en: Table 3.2\. Field type constants. There are more shown in [appendix B](kindle_split_023.html#app02),
    but I have been unable to make them work in Python.
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.2\. 字段类型常量。更多内容请参阅[附录B](kindle_split_023.html#app02)，但我一直无法在Python中使用它们。
- en: '| Field data type | OGR constant |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 字段数据类型 | OGR常量 |'
- en: '| --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Integer | OFTInteger |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | OFTInteger |'
- en: '| List of integers | OFTIntegerList |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 整数列表 | OFTIntegerList |'
- en: '| Floating point number | OFTReal |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数 | OFTReal |'
- en: '| List of floating point numbers | OFTRealList |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数列表 | OFTRealList |'
- en: '| String | OFTString |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | OFTString |'
- en: '| List of strings | OFTStringList |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 字符串列表 | OFTStringList |'
- en: '| Date | OFTDate |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | OFTDate |'
- en: '| Time of day | OFTTime |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 一天中的时间 | OFTTime |'
- en: '| Date and time | OFTDateTime |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 日期和时间 | OFTDateTime |'
- en: 'After you create a basic field definition, but before you use it to add a field
    to the layer, you can add other constraints such as floating-point precision or
    field width, although I’ve noticed that these don’t always have an effect, depending
    on the driver being used. For example, I haven’t been able to set a precision
    in a GeoJSON file, and I’ve also discovered that you must set a field width if
    you want to set field precision in a shapefile. This example would create two
    fields to hold x and y coordinates with a precision of `3`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建基本字段定义之后，但在使用它将字段添加到图层之前，你可以添加其他约束，例如浮点数精度或字段宽度，尽管我注意到这些约束并不总是有效，这取决于所使用的驱动程序。例如，我无法在GeoJSON文件中设置精度，我还发现如果你想在shapefile中设置字段精度，你必须设置字段宽度。以下示例将创建两个字段来存储x和y坐标，精度为`3`：
- en: '![](062fig01_alt.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](062fig01_alt.jpg)'
- en: You might have noticed that you don’t create two different field definition
    objects here. Once you’ve used the field definition to create a field in the layer,
    you can change the definition’s attributes and reuse it to create another field,
    which makes this easier because you want two fields that were identical except
    in name.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，您在这里没有创建两个不同的字段定义对象。一旦您使用字段定义在图层中创建了一个字段，您就可以更改定义的属性并重新使用它来创建另一个字段，这使得这更容易，因为您想要两个除了名称之外完全相同的字段。
- en: Also, sometimes the field width will be ignored if it’s too small for the data
    provided. For example, if you create a string field with a width of `6`, but then
    try to insert a value that’s 11 characters long, in certain cases the width of
    the field would increase to hold the entire string. This isn’t always possible,
    however, and it’s best to be specific about what you want rather than hope something
    like this will conveniently happen.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果字段宽度对于提供的数据来说太小，有时会被忽略。例如，如果您创建了一个宽度为 `6` 的字符串字段，但随后尝试插入一个 11 个字符长的值，在某些情况下，字段的宽度会增加以容纳整个字符串。然而，这并不总是可能的，最好具体说明您想要的内容，而不是希望这种事情方便地发生。
- en: 3.6\. Updating existing data
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6\. 更新现有数据
- en: Sometimes you need to update existing data rather than create an entirely new
    dataset. Whether this is possible, and which edits are supported, depends on the
    format of the data. For example, you can’t edit GeoJSON files, but many different
    edits are allowed on shapefiles. We’ll discuss getting information about what’s
    supported in the next chapter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要更新现有数据而不是创建全新的数据集。这是否可能以及哪些编辑被支持取决于数据的格式。例如，您不能编辑 GeoJSON 文件，但在 shapefiles
    上允许许多不同的编辑。我们将在下一章讨论如何获取有关支持的信息。
- en: 3.6.1\. Changing the layer definition
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.1\. 更改图层定义
- en: 'Depending on the type of data you’re working with, you can edit the layer definition
    by adding new fields, deleting existing ones, or changing field properties such
    as name. As with adding new fields, you need a field definition to change a field.
    Once you have a field definition that you’re happy with, you use the `AlterFieldDefn`
    function to replace the existing field with the new one:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您正在处理的数据类型，您可以通过添加新字段、删除现有字段或更改字段属性（如名称）来编辑图层定义。与添加新字段一样，您需要字段定义来更改字段。一旦您对字段定义满意，您就可以使用
    `AlterFieldDefn` 函数用新字段替换现有字段：
- en: '[PRE27]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`iField` is the index of the field you want to change. A field name won’t work
    in this case.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iField` 是您想要更改的字段的索引。在这种情况下，字段名不起作用。'
- en: '`field_def` is the new field definition object.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`field_def` 是新的字段定义对象。'
- en: '`nFlags` is an integer that is the sum of one or more of the constants shown
    in [table 3.3](#ch03table03).'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nFlags` 是一个整数，它是 [表 3.3](#ch03table03) 中显示的一个或多个常量的总和。'
- en: Table 3.3\. Flags used to specify which properties of a field definition can
    be changed. To use more than one, simply add them together
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 3.3\. 用于指定字段定义哪些属性可以更改的标志。要使用多个标志，只需将它们相加
- en: '| Field properties that need to change | OGR constant |'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 需要更改的字段属性 | OGR 常量 |'
- en: '| --- | --- |'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Field name only | ALTER_NAME_FLAG |'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 仅字段名称 | ALTER_NAME_FLAG |'
- en: '| Field type only | ALTER_TYPE_FLAG |'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 仅字段类型 | ALTER_TYPE_FLAG |'
- en: '| Field width and/or precision only | ALTER_WIDTH_PRECISION_FLAG |'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 仅字段宽度和/或精度 | ALTER_WIDTH_PRECISION_FLAG |'
- en: '| All of the above | ALTER_ALL_FLAG |'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 以上所有 | ALTER_ALL_FLAG |'
- en: 'To change a field’s properties, you need to create a field definition containing
    the new properties, find the index of the existing field, and decide which constants
    from [table 3.3](#ch03table03) to use to ensure your changes take effect. To change
    the name of a field from `''Name''` to `''City_Name''`, you might do something
    like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改字段的属性，您需要创建一个包含新属性的字段定义，找到现有字段的索引，并决定使用 [表 3.3](#ch03table03) 中的哪些常量以确保您的更改生效。要将字段名从
    `'Name'` 更改为 `'City_Name'`，您可能做如下操作：
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you needed to change multiple properties, such as both the name and the
    precision of a floating-point attribute field, you’d pass the sum of `ALTER_NAME_FLAG`
    and `ALTER_WIDTH_PRECISION_FLAG`, like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更改多个属性，例如浮点属性字段的名称和精度，您将传递 `ALTER_NAME_FLAG` 和 `ALTER_WIDTH_PRECISION_FLAG`
    的总和，如下所示：
- en: '[PRE29]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that you use the original field width when creating the new field definition.
    I found out the hard way that if you don’t set the width large enough to hold
    the original data, then the results will be incorrect. To get around the problem,
    use the original width. For the precision change to take effect, all records must
    be rewritten. Making the precision larger than it was won’t give you more precision,
    however, because data can’t be created from thin air. The precision can be decreased,
    however.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在创建新的字段定义时，你使用的是原始字段宽度。我通过艰难的方式发现，如果你没有设置足够大的宽度来容纳原始数据，那么结果将会是不正确的。为了解决这个问题，使用原始宽度。为了使精度变化生效，所有记录都必须重写。然而，将精度设置得比原来更大并不会给你带来更多的精度，因为数据不能凭空创造。然而，精度可以降低。
- en: Instead of summing up flag values, you could cheat and just use `ALTER_ALL_FLAG`.
    Only do this if your new field definition is exactly what you want the field to
    look like after editing, however. The other flags limit what can change, but this
    one doesn’t. For example, if your field definition has a different data type than
    the original field but you pass `ALTER_NAME_FLAG`, then the data type will not
    change, but it will if you pass `ALTER_ALL_FLAG`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不计算标志值，而使用 `ALTER_ALL_FLAG`。只有当你的新字段定义正好是你想要编辑后字段看起来像的样子时才这样做。其他标志限制了可以更改的内容，但这个标志没有限制。例如，如果你的字段定义与原始字段的数据类型不同，但你传递了
    `ALTER_NAME_FLAG`，那么数据类型将不会改变，但如果你传递了 `ALTER_ALL_FLAG`，则会改变。
- en: 3.6.2\. Adding, updating, and deleting features
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.2\. 添加、更新和删除特征
- en: 'Adding new features to existing layers is exactly the same as adding them to
    brand-new layers. Create an empty feature based on the layer definition, populate
    it, and insert it into the layer. Updating features is much the same, except you
    work with features that already exist in the layer instead of blank ones. Find
    the feature you want to edit, make the desired changes, and then update the information
    in the layer by passing the updated feature to `SetFeature` instead of `CreateFeature`.
    For example, you could do something like this to add a unique ID value to each
    feature in a layer:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 向现有层添加新特征与向全新的层添加它们完全一样。根据层定义创建一个空的特征，填充它，并将其插入到层中。更新特征与添加特征类似，只是你处理的是层中已经存在的特征而不是空白特征。找到你想要编辑的特征，进行所需的更改，然后通过将更新后的特征传递给
    `SetFeature` 而不是 `CreateFeature` 来更新层中的信息。例如，你可以这样做来向层中的每个特征添加一个唯一的 ID 值：
- en: '[PRE30]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First you add an ID field, and then you iterate through the features and set
    the ID equal to the value of the `n` variable. Because you increment `n` each
    time through the loop, each feature has a unique ID value. Last, you update the
    feature in the layer by passing it to `SetFeature`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你添加一个 ID 字段，然后遍历特征并将 ID 设置为 `n` 变量的值。因为你在循环中每次都会增加 `n`，所以每个特征都有一个唯一的 ID 值。最后，通过传递给
    `SetFeature` 来更新层中的特征。
- en: 'Deleting features is even easier. All you need to know is the FID of the feature
    you want to get rid of. If you don’t know that number off the top of your head,
    or through another means, you can get it from the feature itself, like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 删除特征甚至更简单。你只需要知道你想要删除的特征的 FID。如果你不知道这个数字，或者通过其他方式不知道，你可以从特征本身获取它，就像这样：
- en: '[PRE31]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For each feature in the layer, you check to see if its `'City_Name'` attribute
    is equal to `'Seattle'`, and if it is, you retrieve the FID from the feature itself
    and then pass that number to `DeleteFeature`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于层中的每个特征，你需要检查它的 `'City_Name'` 属性是否等于 `'Seattle'`，如果是，你从特征本身检索 FID，然后将该数字传递给
    `DeleteFeature`。
- en: Certain formats don’t completely kill the feature at this point, however. You
    may not see it, but sometimes the feature has only been marked for deletion instead
    of totally thrown out, so it’s still lurking in the shadows. Because of this,
    you won’t see any other features get assigned that FID, and it also means that
    if you’ve deleted many features, there may be a lot of needlessly used space in
    your file. See [figure 3.19](#ch03fig19) for a simple example. Deleting these
    features will reclaim this space. If you have much experience with relational
    databases, you should be familiar with this idea. It’s similar to running Compact
    and Repair on a Microsoft Access database or using `VACUUM` on a PostgreSQL database.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，某些格式在此点并不会完全删除要素。你可能看不到它，但有时要素只是被标记为删除，而不是完全被丢弃，因此它仍然潜伏在阴影中。因此，你不会看到其他要素被分配该FID，这也意味着如果你删除了许多要素，文件中可能会有很多不必要的空间。请参见[图3.19](#ch03fig19)以获取一个简单的示例。删除这些要素将回收空间。如果你在关系数据库方面有很多经验，你应该熟悉这个概念。它与在Microsoft
    Access数据库上运行“压缩和修复”或在使用PostgreSQL数据库上使用`VACUUM`类似。
- en: Figure 3.19\. The effect of vacuuming or repacking a database. Notice that the
    FID values change.
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.19\. 真空吸尘或重新打包数据库的影响。请注意，FID值发生了变化。
- en: '![](03fig19_alt.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig19_alt.jpg)'
- en: 'How to go about reclaiming this space, or determining if it needs to be done,
    is dependent on the vector data format being used. Here are examples for doing
    it for shapefiles and SQLite:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如何回收空间或确定是否需要这样做，取决于所使用的矢量数据格式。以下是针对形状文件和SQLite进行此操作的示例：
- en: '![](065fig01_alt.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](065fig01_alt.jpg)'
- en: In both cases, you need to open the data source and then execute a SQL statement
    on it that compacts the database. For shapefiles you need to know the name of
    the layer, so if the layer is called `"cities"`, then the SQL would be `"REPACK
    cities"`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你都需要打开数据源，然后在其上执行一个SQL语句来压缩数据库。对于形状文件，你需要知道层的名称，所以如果层名为“cities”，则SQL语句为“REPACK
    cities”。
- en: 'Another issue with shapefiles is that they don’t update their metadata for
    spatial extent when existing features are modified or deleted. If you edit existing
    geometries or delete features, you can ensure that the spatial extent gets updated
    by calling this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 形状文件（shapefiles）的另一个问题是，当现有要素被修改或删除时，它们不会更新其空间范围（spatial extent）的元数据（metadata）。如果你编辑现有的几何形状或删除要素，可以通过调用以下命令来确保空间范围得到更新：
- en: '[PRE32]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This isn’t necessary if you insert features, however, because those extent changes
    are tracked. It’s also not necessary if there’s no chance that your edits change
    the layer’s extent.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你插入要素，这并不是必要的，因为这些范围变化是有记录的。如果没有可能你的编辑改变层的范围，那么这也不是必要的。
- en: 3.7\. Summary
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7\. 摘要
- en: Vector data formats are most appropriate for features that can be characterized
    as a point, line, or polygon.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量数据格式最适合可以表征为点、线或多边形的要素。
- en: Each geographic feature in a vector dataset can have attribute data, such as
    name or population, attached to it.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量数据集中的每个地理要素都可以附加属性数据，例如名称或人口。
- en: The type of geometry used to model a given feature may change depending on scale.
    A city could be represented as a point on a map of an entire country, but as a
    polygon on a map of a smaller area, such as a county.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于建模特定要素的几何类型可能会根据比例尺而变化。一个城市在某个国家的地图上可能被表示为一个点，但在较小区域（如县）的地图上则可能是一个多边形。
- en: Vector datasets excel for measuring relationships between geographic features
    such as distances or overlaps.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量数据集在测量地理要素之间的关系方面表现出色，例如距离或重叠。
- en: You can use OGR to read and write many different types of vector data, but which
    ones depend on which drivers have been compiled into your version of GDAL/OGR.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用OGR读取和写入许多不同类型的向量数据，但具体哪些取决于哪些驱动程序被编译到你的GDAL/OGR版本中。
- en: Data sources can contain one or more layers (depending on data format), and
    in turn, layers can contain one or more features. Each feature has a geometry
    and a variable number of attribute fields.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据源可以包含一个或多个层（取决于数据格式），而层可以包含一个或多个要素。每个要素都有一个几何形状和可变数量的属性字段。
- en: Newly created data sources are automatically opened for writing. If you want
    to edit existing data, remember to open the data source for writing.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新创建的数据源会自动打开以供写入。如果你想编辑现有数据，请记住打开数据源以供写入。
- en: Remember to make changes to the layer, such as adding or deleting fields, before
    getting the layer definition and creating a feature for adding or updating data.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在获取层定义并创建要素以添加或更新数据之前，请记住对层进行更改，例如添加或删除字段。
