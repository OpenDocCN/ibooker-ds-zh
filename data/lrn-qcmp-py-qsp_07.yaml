- en: '6 Teleportation and entanglement: Moving quantum data around'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 量子数据传输与纠缠：量子数据的移动
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Moving data around a quantum computer using classical and quantum control
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用经典和量子控制移动量子计算机中的数据
- en: Visualizing single-qubit operations with the Bloch sphere
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布洛赫球可视化单量子比特操作
- en: Predicting the output of two-qubit operations, and Pauli operations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测双量子比特操作和泡利操作的结果
- en: In the last chapter, we added support for multiple qubits to our quantum device
    simulator with the help of the QuTiP package. That allowed us to play the CHSH
    game and show that our understanding of quantum mechanics is consistent with what
    we observe in the real world.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们借助QuTiP包为我们的量子设备模拟器添加了对多个量子比特的支持。这使得我们能够玩CHSH游戏，并表明我们对量子力学的理解与我们在现实世界中的观察一致。
- en: In this chapter, we’ll get to see how we can move data between different people
    or registers in a quantum device. We will take a look at how things like the *no-cloning*
    theorem affect how we manage our data on a quantum device. We will also get to
    check out a uniquely quantum protocol our quantum device can perform, called *teleportation*,
    which moves data (as opposed to copies).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何在量子设备的不同人或寄存器之间移动数据。我们将探讨诸如*不可克隆定理*之类的理论如何影响我们在量子设备上管理数据的方式。我们还将检查量子设备可以执行的一种独特量子协议，称为*量子传输*，它移动数据（而不是复制）。
- en: 6.1 Moving quantum data
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 移动量子数据
- en: Just as with classical computing, sometimes in a quantum computer, we have some
    data *here* that we would very much appreciate being somewhere over *there*. Classically,
    this is an easy problem to solve by copying data; but as we saw in chapters 3
    and 4, the no-cloning theorem means in general, we *can’t* copy data stored in
    qubits.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在经典计算中一样，有时在量子计算机中，我们有一些数据*在这里*，我们非常希望它在*那里*。在经典计算中，通过复制数据可以轻松解决这个问题；但正如我们在第3章和第4章中看到的，不可克隆定理意味着在一般情况下，我们不能复制存储在量子比特中的数据。
- en: Moving data classically
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 经典地移动数据
- en: In some parts of classical computing, we run into the same problem of not being
    able to copy information, but for different reasons. Copying data in a multithreaded
    application can introduce subtle race conditions, while performance considerations
    can prompt us to reduce the amount of data that we copy.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典计算的一些部分，我们会遇到无法复制信息的问题，但原因不同。在多线程应用程序中复制数据可能会引入微妙的竞态条件，而性能考虑可能会促使我们减少复制的数据量。
- en: The solution embraced by many classical languages (e.g., C++11 and Rust) focuses
    on *moving* data. Thinking in terms of moving data is helpful in quantum computing,
    although we’ll implement moves in a very different way.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 许多经典语言（例如C++11和Rust）采用的解决方案侧重于*移动*数据。从移动数据的角度思考对量子计算很有帮助，尽管我们将以非常不同的方式实现移动。
- en: So what can we do if we want to move data in a quantum device? Fortunately,
    there are a number of different ways to move quantum data instead of copying it.
    In this chapter, we’ll see a few of these approaches and add the last couple of
    features to our simulator to implement them. Let’s get to sharing quantum information!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们想在量子设备中移动数据，我们能做什么呢？幸运的是，有几种不同的方法可以移动量子数据而不是复制它。在本章中，我们将看到这些方法中的几种，并将最后几个特性添加到我们的模拟器中以实现它们。让我们开始分享量子信息吧！
- en: 'Suppose Eve has some qubits that encode data she’d like to share with us:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设爱娃有一些量子比特，这些量子比特编码了她想要与我们分享的数据：
- en: '*Hey player! I have some quantum information I want to share with you. Can
    I send it over to you*?'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*嘿玩家！我有一些量子信息想要与你分享。我能把它发给你吗*？'
- en: Here, Eve is referring to the `swap` instruction—it’s a bit different than the
    instructions we’ve seen so far in that it operates on *two* qubits at once. By
    contrast, every operation we’ve seen so far operates on only one qubit at a time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，爱娃指的是`swap`指令——它与之前我们看到的指令有一点不同，因为它一次操作两个量子比特。相比之下，我们之前看到的每个操作一次只操作一个量子比特。
- en: 'Looking at what `swap` does, the name is pretty descriptive: it literally swaps
    the state of two qubits in the same register. For example, say we have two qubits
    in the |01〉 state. If we use the `swap` instruction on both qubits, our register
    will now be in the |10〉 state. Let’s look at an example of using the `swap` matrix
    built into QuTiP.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 观察`swap`操作的作用，其名称相当描述性：它实际上交换了同一寄存器中两个量子比特的状态。例如，假设我们有两个处于|01〉状态的量子比特。如果我们在这两个量子比特上使用`swap`指令，我们的寄存器现在将处于|10〉状态。让我们看看使用QuTiP内置的`swap`矩阵的一个例子。
- en: Listing 6.1 Using QuTiP’s `swap` on |+0〉 to get the |0+〉 state
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 使用QuTiP的`swap`操作在|+0〉上得到|0+〉状态
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '❶ Uses qt.basis, hadamard_transform, and qt.tensor to define a variable for
    our old friend from chapter 5: the state vector |+0〉'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 `qt.basis`、`hadamard_transform` 和 `qt.tensor` 定义一个变量，用于第 5 章中的老朋友：状态向量
    |+0〉
- en: ❷ As we saw in chapter 4, this state has equal amplitudes on the |00〉 and |10〉
    computational basis states.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 正如我们在第 4 章中看到的，这个状态在 |00〉 和 |10〉 计算基态上有相等的振幅。
- en: ❸ Gets a copy of the unitary matrix for the swap instruction by calling qt.swap
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过调用 `qt.swap` 获取交换指令的单位矩阵副本
- en: ❹ The same way that we’ve simulated single-qubit operations, we can multiply
    our state by the unitary matrix for swap to find the state of our two-qubit register
    after applying a swap instruction.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 与我们模拟单量子比特操作的方式相同，我们可以通过乘以交换操作的单位矩阵来找到在应用交换指令后我们的双量子比特寄存器的状态。
- en: ❺ When we do so, we end up in a superposition between |00〉 and |01〉 instead
    of between |00〉 and |10〉.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当我们这样做时，我们最终处于 |00〉 和 |01〉 之间的叠加态，而不是 |00〉 和 |10〉 之间的叠加态。
- en: ❻ Quickly checks that the result of using the swap instruction on a register
    of two qubits that start in the |+0〉 state is |0+〉
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 快速检查对从 |+0〉 状态开始的两个量子比特寄存器使用交换指令的结果是 |0+〉
- en: Looking at listing 6.1, we can see that the `swap` instruction did pretty much
    what its name suggests. In particular, `swap` took two qubits that started in
    the state |+0〉 to the |0+〉 state. More generally, we can read what the `swap`
    instruction does by looking at the unitary matrix we used to simulate it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 查看列表 6.1，我们可以看到 `swap` 指令基本上做了它名字所暗示的事情。特别是，`swap` 将处于 |+0〉 状态的两个量子比特转换到了 |0+〉
    状态。更普遍地说，我们可以通过查看我们用来模拟它的单位矩阵来了解 `swap` 指令做了什么。
- en: Listing 6.2 Unitary matrix for the `swap` instruction
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 `swap` 指令的单位矩阵
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ The unitary matrix we use to simulate the swap instruction is a 4 × 4 matrix
    because it acts on two-qubit states.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们用来模拟交换指令的单位矩阵是一个 4 × 4 矩阵，因为它作用于双量子比特状态。
- en: ❷ Each column of this unitary matrix tells us what happens to one of the computational
    basis states; here, the swap instruction does nothing to qubits that start in
    the |00〉 state.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个单位矩阵的每一列都告诉我们计算基态中的一个状态会发生什么；在这里，交换指令对处于 |00〉 状态的量子比特不做任何操作。
- en: ❸ On the other hand, the |01〉 and |10〉 states are swapped by the swap instruction.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 另一方面，交换指令交换了 |01〉 和 |10〉 状态。
- en: ❹ The swap instruction also leaves |11〉 alone.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 交换指令也不会改变 |11〉 状态。
- en: Each column of this unitary matrix tells us what happens to one of the computational
    basis states. For instance, the first column tells us that the |00〉 state is mapped
    to the vector `[[1], [0], [0], [0]]`, which we recognize as |00〉.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单位矩阵的每一列都告诉我们计算基态中的一个状态会发生什么。例如，第一列告诉我们 |00〉 状态被映射到向量 `[[1], [0], [0], [0]]`，这是我们认识的
    |00〉。
- en: Note The unitary matrix for the `swap` instruction *cannot* be written as the
    tensor product of any two single-qubit unitary matrices. That is, we can’t understand
    what `swap` does by considering one qubit at a time—we need to work out what it
    does to the state of the pair of qubits that the `swap` instruction acts on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`swap` 指令的单位矩阵**不能**写成任何两个单量子比特单位矩阵的张量积。也就是说，我们不能通过一次考虑一个量子比特来理解 `swap` 做了什么——我们需要弄清楚它对
    `swap` 指令作用的两个量子比特对的态做了什么。
- en: Figure 6.1 shows that we can see what `swap` does in general, regardless of
    what state our two qubits start in.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 显示，我们可以看到 `swap` 指令在一般情况下会做什么，无论我们的两个量子比特最初处于什么状态。
- en: '![](../Images/6-1.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/6-1.png)'
- en: Figure 6.1 The two-qubit operation `swap` exchanges the states of two qubits
    in a register. We can see this in the generic example shown here because the terms
    describing the |01〉 and |10〉 states are swapped. The other two are not because
    we can’t tell the difference when the two qubits are in the same state.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 双量子比特操作 `swap` 交换寄存器中两个量子比特的状态。我们可以在这里显示的通用示例中看到这一点，因为描述 |01〉 和 |10〉 状态的项被交换了。其他两个没有被交换，因为我们无法区分两个量子比特处于相同状态时的情况。
- en: Remember that in chapter 2, we saw that a unitary matrix is a lot like a truth
    table. That is, unitary matrices like what we get back from `qt.swap` are useful
    in that they help us simulate what the `swap` instruction does. Just as a classical
    adder isn’t its truth table, though, it’s helpful to remember that these unitary
    matrices aren’t quantum programs but tools that we use to simulate how quantum
    programs work.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在第 2 章中，我们看到了单位矩阵非常类似于真值表。也就是说，像我们从 `qt.swap` 得到的单位矩阵这样的单位矩阵是有用的，因为它们帮助我们模拟
    `swap` 指令做了什么。然而，就像经典加法器不是它的真值表一样，记住这些单位矩阵不是量子程序，而是我们用来模拟量子程序如何工作的工具是有帮助的。
- en: 'Exercise 6.1: Swapping the second and third qubits in a register'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.1：交换寄存器中的第二个和第三个量子比特
- en: Say you have a register with three qubits in the state |01+〉. Using QuTiP, write
    out this state, and then swap the second and third qubits so your register is
    in the |0+1〉 state.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个包含三个量子比特且处于|01+〉状态的寄存器。使用QuTiP，写出这个状态，然后交换第二个和第三个量子比特，使您的寄存器处于|0+1〉状态。
- en: '*Hint*: Since nothing will happen to the first qubit, be sure take the tensor
    product of an identity matrix and `qt.swap` to build up the correct operation
    for your register.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示*：由于第一个量子比特不会发生任何变化，请确保使用单位矩阵和`qt.swap`的张量积来构建寄存器中正确的操作。'
- en: Exercise solutions
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 练习题解答
- en: 'All solutions for exercises in this book can be found in the companion code
    repo: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).
    Just go to the folder for the chapter you are in and open the Jupyter notebook
    with the name that mentions exercise solutions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有练习题解答都可以在配套代码仓库中找到：[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)。只需进入您所在章节的文件夹，然后打开名为练习题解答的Jupyter笔记本。
- en: At this point, Eve is positively *dying* waiting to send her qubits. Let’s add
    what we need to our simulator to not keep her waiting any longer!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Eve已经迫不及待地想要发送她的量子比特了。让我们添加我们需要的到我们的模拟器中，以便不再让她等待！
- en: 6.1.1 Swapping out the simulator
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 替换模拟器
- en: 'The simulator we worked on in chapter 4 needs just a couple of tweaks to be
    able to use two-qubit operations like `swap`. The changes we need to make are
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第4章中开发的模拟器只需要进行一些调整，就可以使用像`swap`这样的双量子比特操作。我们需要做的更改如下：
- en: Modify `_apply` to work with two-qubit operations.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`_apply`以支持双量子比特操作。
- en: Add `swap` and other two-qubit instructions.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`swap`和其他双量子比特指令。
- en: Add the rest of the single-qubit rotation instructions.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加剩余的单量子比特旋转指令。
- en: As we saw in chapter 4, if a matrix acts on a single-qubit register, we can
    use QuTiP to apply that to a register with an arbitrary number of qubits by using
    the `gate_expand _1toN` function. This takes the tensor product of identity operators
    on each qubit except the qubits we’re working with.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第4章中看到的，如果一个矩阵作用于单量子比特寄存器，我们可以使用QuTiP通过使用`gate_expand_1toN`函数将其应用于任意数量的量子比特寄存器。这个函数将除了我们正在处理的量子比特之外的所有量子比特的单位算符的张量积。
- en: In the same way, we can call QuTiP’s `gate_expand_2toN` function to turn two-qubit
    unitary matrices into matrices that we can use to simulate how two-qubit operations
    like `swap` transform the state of a whole register. Let’s add that to our simulator
    now (listing 6.3).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以调用QuTiP的`gate_expand_2toN`函数，将双量子比特单位矩阵转换为我们可以用来模拟像`swap`这样的双量子比特操作如何转换整个寄存器状态的矩阵。现在让我们将其添加到我们的模拟器中（列表6.3）。
- en: 'Tip We’ve made a couple of small changes to the code in this chapter to help
    make the printed output look a little nicer. These changes, along with all the
    samples for this and other chapters, are on the GitHub repo for this book: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：我们对本章中的代码进行了一些小的修改，以帮助使打印的输出看起来更美观。这些更改以及本书和其他章节的所有示例，都可以在GitHub仓库中找到：[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)。
- en: 'Listing 6.3 simulator.py: applying two-qubit unitary matrices'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 simulator.py：应用双量子比特单位矩阵
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '❶ To simulate two-qubit operations, we need two indices for qubits in the register:
    one for each qubit that our instruction acts on.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 要模拟双量子比特操作，我们需要寄存器中量子比特的两个索引：一个用于我们的指令作用的每个量子比特。
- en: ❷ The call to gate_expand_2toN looks very similar to our call to gate_expand_1toN,
    except that we pass a 4 × 4 matrix instead of a 2 × 2 matrix.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `gate_expand_2toN`的调用看起来与我们的`gate_expand_1toN`调用非常相似，只是我们传递的是一个4×4矩阵而不是2×2矩阵。
- en: We saw that QuTiP provides the function `swap` to give us a copy of the unitary
    matrix that simulates the `swap` instruction. This can be used to pretty quickly
    add the `swap` instruction to our simulator using the changes we made to `Simulator._apply`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到QuTiP提供了`swap`函数来为我们提供一个模拟`swap`指令的单位矩阵的副本。这可以使用我们对`Simulator._apply`所做的更改快速地将`swap`指令添加到我们的模拟器中。
- en: 'Listing 6.4 simulator.py: adding a `swap` instruction'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.4 simulator.py：添加`swap`指令
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ To get the 4 × 4 unitary matrix, we need to pass to “apply”; we just use the
    qt.swap function we’ve seen a few times so far in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 要获取4×4单位矩阵，我们需要传递给“apply”，我们只需使用本章前面几次看到的`qt.swap`函数。
- en: ❷ We need to make sure we pass the indices for both qubits we want to swap between
    so that gate_expand_2toN correctly applies the unitary matrix for our new swap
    instruction to the state of an entire register.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们需要确保传递我们想要交换的两个量子比特的索引，以便gate_expand_2toN能够正确地将我们新`swap`指令的单位矩阵应用于整个寄存器的状态。
- en: While we’re working with the simulator, let’s add one more instruction to print
    out its state more easily without having to access its internals.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在模拟器上工作时，让我们添加一个额外的指令来更轻松地打印其状态，而无需访问其内部。
- en: 'Listing 6.5 simulator.py: adding a `dump` instruction'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5 simulator.py：添加`dump`指令
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This way, we can ask the simulator to help us debug quantum programs, but in
    a way that can be safely stripped out for devices that don’t support it (e.g.,
    actual quantum hardware).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以要求模拟器帮助我们调试量子程序，但以一种可以在不支持它的设备（例如，实际量子硬件）上安全移除的方式。
- en: Tip Remember that a qubit is not a state. A state is just a convenient way of
    representing how the quantum system will behave.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：记住，量子比特不是一个状态。状态只是表示量子系统如何行为的便捷方式。
- en: With both these changes in place, we’re all set to use the `swap` instruction.
    Let’s use it to repeat the experiment where we swapped two qubits starting in
    the |0+〉 state to transform them into the |+0〉 state.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施这两个更改后，我们就准备好使用`swap`指令了。让我们用它来重复实验，在这个实验中，我们从|0+〉状态开始交换两个量子比特，将它们转换到|+0〉状态。
- en: 'Tip As always, for the full sample files, see the GitHub repo for this book:
    [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：一如既往，对于完整的示例文件，请参阅本书的GitHub仓库：[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)。
- en: Listing 6.6 Testing the `swap` instruction on the |0+〉 state
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.6 在|0+〉状态下测试`swap`指令
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Since we’ll be working a lot with multiple-qubit registers in this chapter,
    we’ve added a new convenience method that lets us allocate several qubits at once.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由于在本章中我们将大量使用多量子比特寄存器，我们添加了一个新的便利方法，允许我们一次性分配多个量子比特。
- en: ❷ The first dump comes from our first call to sim.dump and confirms that eve.h()
    prepared the qubits in the |0+〉 state.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第一个`dump`来自我们对sim.dump的第一个调用，并确认eve.h()已将量子比特准备在|0+〉状态。
- en: '❸ After calling you.swap(eve), our qubit ends up in the |+〉 state, with Eve’s
    qubit ending the way ours started: in the |0〉 state.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在调用you.swap(eve)之后，我们的量子比特最终处于|+〉状态，而Eve的量子比特则以我们的量子比特开始的方式结束：处于|0〉状态。
- en: 'Great: we now have a way to share quantum data with Eve! Well, at least *as
    long as we’re sharing a single quantum device* so that we can apply the `swap`
    instruction to both our qubits at the same time.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了：我们现在有了一种与Eve共享量子数据的方法！嗯，至少在我们共享单个量子设备的情况下是这样，这样我们才能同时应用`swap`指令到我们的量子比特上。
- en: 'What happens if we want to share quantum information *between* devices? Fortunately,
    quantum computing gives us a way to send qubits by only communicating classical
    data, as long as we both start with some entanglement between our qubits. Like
    much in quantum computing, this technique is given a whimsical name: *quantum
    teleportation*. Don’t let the name fool you, however. When we get right down to
    it, teleportation uses what we learned in chapter 4 to let us share quantum data
    in a useful way. Figure 6.2 shows a list of the steps in a teleportation program.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在设备之间共享量子信息会发生什么？幸运的是，量子计算为我们提供了一种通过仅通信经典数据来发送量子比特的方法，只要我们双方在量子比特之间开始时有一些纠缠。像量子计算中的许多事物一样，这种技术有一个异想天开的名字：*量子隐形传态*。然而，不要被这个名字欺骗。当我们深入探讨时，隐形传态使用我们在第4章中学到的知识，以有用的方式共享量子数据。图6.2显示了量子隐形传态程序中的步骤列表。
- en: '![](../Images/6-2.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/6-2.png)'
- en: Figure 6.2 The steps in the teleportation program. We prepare and entangle a
    register of qubits, and then Eve can prepare and teleport her state to us. Note
    that she will not have the state after teleportation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 量子隐形传态程序中的步骤。我们准备并纠缠一个量子比特寄存器，然后Eve可以准备并传态她的状态给我们。请注意，她将不会在传态后拥有该状态。
- en: What’s really neat about teleportation is that, while we and Eve still need
    to do some two-qubit operations between our respective qubits, Eve can decide
    what data she wants to send us *after* we’ve done those operations. This means
    we could prepare the entangled qubits before we needed to exchange quantum data
    and just use them as needed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 量子隐形传态真正酷的地方在于，虽然我们和Eve仍然需要在各自的量子比特之间进行一些双量子比特操作，但Eve可以在我们完成这些操作后决定她想要发送给我们的数据。这意味着我们可以在需要交换量子数据之前准备纠缠量子比特，然后按需使用它们。
- en: Using the simulator that we’ve developed throughout the past several chapters,
    we might write up teleportation with a quantum program like that shown in the
    following listing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在过去几章中开发的模拟器，我们可能会编写一个量子程序，如下所示：
- en: Listing 6.7 A teleportation program in Python
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 Python 中的量子传输程序
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are a few new instructions in this program, though. In the rest of this
    chapter, we’ll see the other pieces required to get up and running with quantum
    teleportation using our simulator.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个程序中有一些新的指令。在本章的其余部分，我们将看到运行量子传输所需的其余组件。
- en: 6.1.2 What other two-qubit gates are there?
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 还有哪些其他双量子比特门？
- en: 'As you may guess, `swap` is not the only two-qubit operation. Indeed, as shown
    in listing 6.7, to get teleportation working, we need to add another two-qubit
    instruction called `cnot` to the simulator. The `cnot` instruction does something
    similar to `swap`, except it switches the |10〉 and |11〉 computational basis states
    instead of the |01〉 and |10〉 states. Another way to think of this is that `cnot`
    flips the second qubit *controlled* on the state of the first qubit being |1〉.
    This is where the name `cnot` comes from: it’s shorthand for “controlled NOT.”'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，`swap` 并不是唯一的双量子比特操作。实际上，正如列表 6.7 所示，为了使量子传输工作，我们需要在模拟器中添加另一个名为 `cnot`
    的双量子比特指令。`cnot` 指令执行的功能与 `swap` 类似，但它交换的是 |10〉 和 |11〉 计算基态，而不是 |01〉 和 |10〉 状态。另一种思考方式是，`cnot`
    会根据第一个量子比特处于 |1〉 状态来 *控制* 第二个量子比特。这个名字 `cnot` 的由来就是：它是“受控非”的缩写。
- en: Tip We often call the first qubit passed to a `cnot` instruction the *control
    qubit* and the second qubit the *target qubit*. As we will see in chapter 7, though,
    there is a bit of subtlety to these names.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：我们通常将传递给 `cnot` 指令的第一个量子比特称为 *控制量子比特*，第二个量子比特称为 *目标量子比特*。然而，正如我们将在第 7 章中看到的，这些名称有一些微妙之处。
- en: 'Let’s jump right in and see how the `cnot` instruction works by applying it
    to that lovely example, the |+0〉 state:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接看看 `cnot` 指令是如何工作的，通过将其应用于那个可爱的例子，即 |+0〉 状态：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Initializes two qubits so that they start in the |+0〉 = (|00〉 + |10〉) / √2
    state
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始化两个量子比特，使它们从 |+0〉 = (|00〉 + |10〉) / √2 状态开始
- en: ❷ QuTiP provides the unitary matrix for the cnot instruction as the qt.cnot
    function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ QuTiP 提供了 `cnot` 指令的单位矩阵作为 `qt.cnot` 函数。
- en: ❸ The cnot instruction leaves our qubits in the state (|00〉 + |11〉) / √2.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `cnot` 指令将我们的量子比特留在 (|00〉 + |11〉) / √2 状态。
- en: ❹ The matrix for cnot maps the |10〉 computational basis state to |11〉 and vice
    versa, just as we expected from the description.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ `cnot` 的矩阵将 |10〉 计算基态映射到 |11〉，反之亦然，正如我们所期望的那样。
- en: Note The `cnot` instruction is *not* the same as `if` statements in classical
    programming languages, in that a `cnot` instruction preserves superposition. If
    we wanted to use an `if` statement, we’d have to measure the control qubit, causing
    it to collapse any superposition on the control qubit. We’ll actually use both
    `cnot` instructions and `if` statements conditioned on measurement results when
    we write out our teleportation program at the end of this chapter—both can be
    useful! In chapters 8 and 9, we’ll see more about how controlled operations differ
    from `if` statements.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`cnot` 指令与经典编程语言中的 `if` 语句不同，因为 `cnot` 指令保留了叠加态。如果我们想使用 `if` 语句，我们必须测量控制量子比特，这将导致控制量子比特上的任何叠加态坍缩。实际上，在本书末尾编写我们的量子传输程序时，我们将使用
    `cnot` 指令和基于测量结果的 `if` 语句——两者都很有用！在第 8 章和第 9 章中，我们将看到控制操作与 `if` 语句的不同之处。
- en: Figure 6.3 shows how the `cnot` instruction acts on two-qubit states in general.
    For now, though, we recognize the output state that we got in the previous code
    snippet by applying `cnot` on two qubits in the |0〉 state as the `entangled` we
    needed to play the CHSH game in chapter 4, (|00〉+|11〉)/ √2.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 展示了 `cnot` 指令在一般情况下对双量子比特状态的作用。然而，现在我们认识到，通过在 |0〉 状态的两个量子比特上应用 `cnot`
    而得到的输出状态，是我们第 4 章中玩 CHSH 游戏所需的 `entangled` 状态，即 (|00〉+|11〉)/ √2。
- en: '![](../Images/6-3.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-3.png)'
- en: Figure 6.3 The two-qubit operation `cnot` applies a `not` operation conditioned
    on the state of a control qubit.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 双量子比特操作 `cnot` 在控制量子比特的状态下执行 `not` 操作。
- en: This means we have everything we need to write a quantum program that entangles
    two qubits that start in the |00〉 state. All we need to do is add the `cnot` instruction
    to our simulator, the same way we added `swap` earlier.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们拥有了编写量子程序所需的一切，该程序可以将处于 |00〉 状态的两个量子比特纠缠在一起。我们所需做的只是将 `cnot` 指令添加到我们的模拟器中，就像我们之前添加
    `swap` 一样。
- en: 'Listing 6.8 simulator.py: adding the `cnot` instruction'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8 simulator.py：添加`cnot`指令
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can write a program to prepare two qubits in an entangled pair:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个程序来准备一对纠缠的量子比特：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At this point, it’s helpful to pause a moment (sorry, Eve!) and reflect on what
    we just did. In chapter 4, when we simulated playing the CHSH game with Eve, we
    had to “cheat” by assuming that we and Eve could have access to two qubits that
    magically start in the entangled state (|00〉 + |11〉) / √2. Now, though, we see
    exactly how we and Eve can prepare that entanglement by running another quantum
    program before playing CHSH. The `h` instruction prepares the superposition that
    we need, while the new `cnot` instruction allows us to prepare entanglement with
    Eve. This entanglement “shares” that superposition across our two qubits. (Sharing
    is caring, after all.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，暂停片刻（抱歉，伊芙！）并反思我们刚刚所做的是很有帮助的。在第4章中，当我们模拟与伊芙玩CHSH游戏时，我们必须“作弊”，假设我们和伊芙可以访问两个在纠缠态（|00〉
    + |11〉）/ √2下神奇地开始的量子比特。但现在，我们看到我们和伊芙如何通过在玩CHSH之前运行另一个量子程序来准备这种纠缠。`h`指令准备我们需要的叠加态，而新的`cnot`指令使我们能够与伊芙准备纠缠。这种纠缠“共享”了我们的两个量子比特之间的叠加态。（毕竟，分享就是关爱。）
- en: Just like preparing entanglement between us and Eve was how we got ready for
    the CHSH game in chapter 4, it is the first step we need for Eve to teleport her
    quantum data to us. This makes `cnot` a very important instruction going forward.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在第4章中为CHSH游戏做准备与伊芙之间的纠缠一样，这是伊芙将她的量子数据传输到我们的第一步。这使得`cnot`指令在未来的操作中变得非常重要。
- en: Getting back to Eve, though, the next step for her to teleport her data to us
    is using one of four different single-qubit operations to *decode* the quantum
    data she sends us (recall figure 6.2). Let’s look at those next.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，回到伊芙，她将数据传输到我们的下一步是使用四种不同的单个量子比特操作来*解码*她发送给我们的量子数据（回想一下图6.2）。让我们看看下一个。
- en: 6.2 All the single (qubit) rotations
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2所有单个（量子比特）旋转
- en: The last thing we need to program quantum teleportation is to apply a correction
    based on some classical data that Eve sends us. To do so, we need a couple of
    new single-qubit instructions. For that, it’s helpful to revisit the pictures
    we’ve been using to depict quantum instructions as rotations, because we may have
    been cheating a little. We have depicted our qubits so far as any position on
    a circle, but in reality, we are missing a dimension for our model of a qubit.
    The state of a *single* qubit is represented by any point on the surface of a
    sphere, generally referred to as the *Bloch sphere*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编程量子传输的最后一件事是根据伊芙发送给我们的某些经典数据进行校正。为此，我们需要一些新的单个量子比特指令。为此，回顾我们用来描绘量子指令为旋转的图片是有帮助的，因为我们可能有点“作弊”。到目前为止，我们一直将量子比特描绘为圆上的任何位置，但在现实中，我们的量子比特模型缺少一个维度。单个量子比特的状态由球面上的任何点表示，通常称为*布洛赫球*。
- en: Single qubits only!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 单个量子比特仅限！
- en: This (and the previous) way of visualizing the state of a qubit *only* works
    if that qubit is not entangled with any other qubits. Another way of saying this
    is that we cannot easily visualize a multi-qubit state. Even trying to visualize
    the state of a two-qubit register with entanglement would involve drawing pictures
    in seven dimensions. While 7D might be nice for advertising a ride at Niagara
    Falls, it is much harder to draw useful pictures that way.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种（以及之前的）可视化量子比特状态的方法仅在量子比特未与其他量子比特纠缠时才有效。另一种说法是，我们无法轻易地可视化多量子比特状态。甚至尝试可视化具有纠缠的两个量子比特寄存器的状态将涉及在七维空间中绘制图片。虽然7D可能适合尼亚加拉大瀑布的游乐广告，但用这种方式绘制有用的图片要困难得多。
- en: The circle we are familiar with was really just a slice through the sphere,
    and all the rotations we were doing resulted in states still on that circle. Figure
    6.4 shows how the previous qubit model compares to the Bloch sphere.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所熟悉的圆实际上是球的一个切片，而我们所做的所有旋转都导致状态仍然在那个圆上。图6.4显示了前一个量子比特模型与布洛赫球的比较。
- en: '![](../Images/6-4.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/6-4.png)'
- en: Figure 6.4 Comparison of our previous model for a qubit (a point on a circle)
    and the Bloch sphere. The Bloch sphere is a more general model for the state of
    a single qubit. We need another dimension to capture that state of a qubit represented
    by a vector of *complex* numbers, but it only works for single qubits.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4比较了我们的前一个量子比特模型（圆上的一个点）和布洛赫球。布洛赫球是单个量子比特状态的更一般模型。我们需要另一个维度来捕捉由复数向量表示的量子比特状态，但它仅适用于单个量子比特。
- en: Tip You might have inferred from the fact that we showed the *Z*-axis and the
    *X*-axis that the *Y*-axis was hiding somewhere! As it turns out, when we move
    from a circle to a sphere, the axis that goes out of the page is often called
    the “*Y*-axis.”
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你可能已经从我们展示了*Z*-轴和*X*-轴的事实中推断出*Y*-轴可能隐藏在某个地方！实际上，当我们从圆移动到球体时，从页面中伸出的轴通常被称为“*Y*-轴。”
- en: When we first introduced the vector representation of a qubit state in chapter
    2, you may recall that the amplitudes in each vector were *complex numbers*. In
    the rest of this chapter, we’ll see that in general, when we use rotation instructions
    to transform the state of a single qubit, we get complex numbers. Complex numbers
    are an incredibly useful tool for keeping track of rotations and thus play a large
    role in quantum computing. Primarily they help us understand the angles and phases
    between different quantum states. Don’t worry if you’re a little rusty with complex
    numbers, as you’ll get plenty of chances to practice with them throughout the
    rest of the book.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第2章首次介绍量子比特状态的矢量表示时，你可能还记得每个向量中的振幅是*复数*。在本章的其余部分，我们将看到，当我们使用旋转指令来转换单个量子比特的状态时，我们通常会得到复数。复数是跟踪旋转的极其有用的工具，因此在量子计算中起着重要作用。主要来说，它们帮助我们理解不同量子状态之间的角度和相位。如果你对复数有些生疏，不要担心，因为在本书的其余部分，你将有很多机会练习它们。
- en: '6.2.1 Relating rotations to coordinates: The Pauli operations'
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 将旋转与坐标相关联：泡利算符
- en: 'In figure 6.5, let’s take a moment to quickly review a couple of the single-qubit
    operations we have seen so far: `x` and `ry`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在图6.5中，让我们花一点时间快速回顾一下我们迄今为止看到的几个单量子比特操作：`x`和`ry`。
- en: '![](../Images/6-5.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-5.png)'
- en: Figure 6.5 Illustrations of what `x` and `ry` do to a qubit. We have seen both
    operations in previous chapters. The `ry` instruction rotates the state of our
    qubit by an angle theta, and `x` takes qubits in the |0〉 state to the |1〉 and
    vice versa.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 `x`和`ry`对量子比特的影响示意图。我们已经在之前的章节中看到了这两个操作。`ry`指令通过角度theta旋转我们的量子比特状态，而`x`将|0〉状态的量子比特转换到|1〉状态，反之亦然。
- en: Now that we know the state of our qubit can be rotated on the surface of a sphere,
    what other rotations can help us rotate the state out of the plane? We can add
    a rotation about the line between the |+〉 and |−〉 states. This line is conventionally
    called the *X*-axis to distinguish it from the *Z*-axis that connects the |0〉
    and |1〉 states. The `rx` function in QuTiP gives us a `Qobj` encapsulating the
    rotation matrix for a *X*-axis rotation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的量子比特状态可以在球面上旋转，那么还有哪些旋转可以帮助我们将状态旋转出平面呢？我们可以在|+〉和|−〉状态之间的线上添加一个旋转。这条线通常被称为*X*-轴，以区别于连接|0〉和|1〉状态的*Z*-轴。QuTiP中的`rx`函数为我们提供了一个封装了*X*-轴旋转矩阵的`Qobj`。
- en: Listing 6.9 Using the QuTiP built-in function `qt.sigmaz`
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.9 使用QuTiP内置函数`qt.sigmaz`
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ QuTiP Qobj instances have a tidyup method to help make matrices more readable,
    as floating-point arithmetic on classical computers can result in small errors.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ QuTiP Qobj实例有一个tidyup方法，可以帮助使矩阵更易于阅读，因为经典计算机上的浮点运算可能会导致小的误差。
- en: ❷ Up to a coefficient of –*i* (written in Python as –1j), rotating by 180° about
    the *X*-axis results in the `x` (NOT) instruction that we first saw in chapter
    2.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在系数–*i*（在Python中表示为–1j）的范围内，围绕*X*-轴旋转180°会导致我们在第2章首次看到的`x`（NOT）指令。
- en: 'Tip In Python, the complex number *i* is represented by `1.0j`: 1 times *j*,
    which is sometimes what the imaginary number *i* is called in other fields.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在Python中，复数*i*表示为`1.0j`：1乘以*j*，这在其他领域有时被称为虚数*i*。
- en: 'This snippet illustrates something very important: the `x` operation is precisely
    what we get by rotating around the *X*-axis by an angle of 180° (*π*).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段说明了非常重要的一点：`x`操作正是我们通过围绕*X*-轴旋转180°（*π*）所得到的结果。
- en: Definition As noted in the callouts for listing 6.1, we can check that `qt.rx(np.pi)`
    is actually off by a factor of *–i* from `qt.sigmax()`. That factor is an example
    of a *global phase*. As we will see shortly, global phases *cannot* affect the
    results of the measurement. Thus, `qt.rx(np.pi)` and `qt.sigmax()` are different
    unitary matrices that represent the same operation. We’ll get more practice with
    global and local phases in chapters 7 and 8.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：正如列表6.1的说明中提到的，我们可以检查`qt.rx(np.pi)`实际上比`qt.sigmax()`少了一个*–i*因子。这个因子是一个*全局相位*的例子。正如我们很快就会看到的，全局相位*不能*影响测量的结果。因此，`qt.rx(np.pi)`和`qt.sigmax()`是不同的幺正矩阵，它们表示相同的操作。在第7章和第8章中，我们将更多地练习全局和局部相位。
- en: By analogy, we call rotating by 180° about the *Z*-axis a `z` operation. In
    chapter 3, QuTiP provided the `qt.sigmax` function that simulates the `x` instruction.
    Similarly, `qt.sigmaz` provides the unitary matrices we need to simulate the `z`
    instructions. The next listing shows an example of using `qt.sigmaz`. Note that
    we’ve included the coefficient (that is, the global phase) of *–i* by multiplying
    by *i* right away; this works since *–i* × *i* = –(–1) = 1.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类比，我们将绕 *Z*-轴旋转 180°称为 `z` 操作。在第 3 章中，QuTiP 提供了 `qt.sigmax` 函数来模拟 `x` 指令。同样，`qt.sigmaz`
    提供了我们需要来模拟 `z` 指令的单位矩阵。下面的列表展示了使用 `qt.sigmaz` 的一个示例。请注意，我们立即通过乘以 *i* 来包括系数（即全局相位）；这之所以有效，是因为
    *–i* × *i* = –(–1) = 1。
- en: Listing 6.10 Using the QuTiP functions `qt.rz` and `qt.sigmaz`
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.10 使用 QuTiP 函数 `qt.rz` 和 `qt.sigmaz`
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Cancelling out the global phase this way makes it easier to read the output.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 以这种方式消除全局相位使得读取输出更加容易。
- en: ❷ As promised, up to the coefficient of –*i*, the `z` instruction applies a
    180° rotation about the *Z*-axis.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如承诺的那样，直到系数为 –*i*，`z` 指令在 *Z*-轴上应用了 180° 旋转。
- en: In the same way that the `X` operation flips between |0〉 and |1〉 while leaving
    |+〉 and |−〉 alone, the `z` operation flips between |+〉 and |−〉 while leaving |0〉
    and |1〉 alone.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `X` 操作在 |0〉 和 |1〉 之间翻转，同时保持 |+〉 和 |−〉 不变的方式相同，`z` 操作在 |+〉 和 |−〉 之间翻转，同时保持
    |0〉 和 |1〉 不变。
- en: Table 6.1 shows a truth table like the ones we made for the Hadamard operation
    in chapter 2\. By looking at the truth table, we can confirm that, if we do a
    `z` operation twice on any input state, we will be back where we started. In other
    words, `z` squares to the identity operation 𝟙 in the same way that *X*² = 𝟙.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 显示了一个类似于我们在第 2 章中为哈达玛操作（Hadamard operation）制作的真值表。通过查看真值表，我们可以确认，如果我们对任何输入状态执行两次
    `z` 操作，我们将回到起点。换句话说，`z` 的平方等于恒等操作 𝟙，就像 *X*² = 𝟙 一样。
- en: Table 6.1 Representing the `z` instruction as a table
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 将 `z` 指令表示为表格
- en: '| Input state | Output state |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 输入状态 | 输出状态 |'
- en: '| &#124;0〉 | &#124;0〉 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| &#124;0〉 | &#124;0〉 |'
- en: '| &#124;1〉 | –&#124;1〉 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| &#124;1〉 | –&#124;1〉 |'
- en: '| &#124;+〉 | &#124;−〉 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| &#124;+〉 | &#124;−〉 |'
- en: '| &#124;−〉 | &#124;+〉 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| &#124;−〉 | &#124;+〉 |'
- en: Note We listed four rows in table 6.1, but we need only two rows to completely
    specify how *Z* acts for any input. The other two rows serve to emphasize that
    we can choose between defining *Z* by its action on |0〉 and |1〉 or by its action
    on |+〉 and |−〉.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 我们在表 6.1 中列出了四行，但我们只需要两行就可以完全指定 *Z* 对任何输入的作用。其他两行是为了强调我们可以选择通过 *Z* 在 |0〉
    和 |1〉 上的作用来定义 *Z*，或者通过 *Z* 在 |+〉 和 |−〉 上的作用来定义 *Z*。
- en: 'Exercise 6.2: Practice using rz and z'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.2：练习使用 rz 和 z
- en: Suppose you prepare a qubit in the |−〉 state and apply a `z` rotation. If you
    measure along the *X*-axis, what do you get? What do you measure if you apply
    two `z` rotations? If you implement those same two rotations with `rz`, what angles
    should you use?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你准备了一个处于 |−〉 状态的量子比特，并应用了一个 `z` 旋转。如果你沿着 *X*-轴进行测量，你会得到什么？如果你应用两个 `z` 旋转，你会测量到什么？如果你用
    `rz` 实现相同的两个旋转，你应该使用什么角度？
- en: 'We can define one more rotation the same way: the rotation about an axis coming
    “out of the page.” This axis connects the states (|0〉 + *i*|1〉) / √2 = *R[x]*
    (*π*/2)|0〉 and (|0〉 − i |1〉) / √2 = *R[x]* (*π*/2)|1〉 and is conventionally called
    the *Y*-axis. A 180° rotation about the *Y*-axis both flips bit labels (|0〉 ![](../Images/emoji-harrow.png)
    |1〉) and phases (|+〉 ![](../Images/emoji-harrow.png) |−〉) but leaves alone the
    two states along the *Y*-axis.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用相同的方式定义一个额外的旋转：绕着从页面“出来”的轴旋转。这个轴连接着状态 (|0〉 + *i*|1〉) / √2 = *R[x]* (*π*/2)|0〉
    和 (|0〉 − i |1〉) / √2 = *R[x]* (*π*/2)|1〉，并且传统上被称为 *Y*-轴。绕 *Y*-轴旋转 180°会翻转比特标签（|0〉
    ![](../Images/emoji-harrow.png) |1〉）和相位（|+〉 ![](../Images/emoji-harrow.png) |−〉），但会保留沿
    *Y*-轴的两个状态。
- en: 'Exercise 6.3: Truth table for `sigmay`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.3：`sigmay` 的真值表
- en: Use the `qt.sigmay()` function to make a table similar to table 6.1, but for
    the `y` instruction.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `qt.sigmay()` 函数制作一个类似于表 6.1 的表格，但用于 `y` 指令。
- en: Definition Together, the three matrices *X*, *Y*, and *Z* representing the `x`,
    `y`, and `z` operations are called the *Pauli matrices* in honor of physicist
    Wolfgang Pauli. The identity matrix 𝟙 is sometimes included as well, representing
    the “do nothing” or identity operation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 一起，代表 `x`、`y` 和 `z` 操作的三个矩阵 *X*、*Y* 和 *Z* 被称为保罗矩阵（Pauli matrices），以纪念物理学家沃尔夫冈·泡利（Wolfgang
    Pauli）。单位矩阵 𝟙 有时也被包括在内，代表“不做任何事情”或恒等操作。
- en: Playing rock-paper-scissors with the Pauli matrices
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与保罗矩阵玩剪刀石头布
- en: The Pauli matrices have a number of useful properties that we’ll use throughout
    the rest of the book. Many of these properties make it easy to work out different
    equations involving the Pauli operators. For example, if we multiply *X* by *Y*,
    we get *iZ*, but if we multiply *YX*, we get *–**iZ*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 泊松矩阵具有许多有用的性质，我们将在本书的其余部分使用这些性质。许多这些性质使得使用泡利算符的不同方程变得容易。例如，如果我们乘以*X*和*Y*，我们得到*iZ*，但如果我们乘以*YX*，我们得到*–*iZ*。
- en: 'QuTiP can help explore what happens when we multiply Pauli matrices together:
    for example, multiplying *X* and *Y* together in both possible orderings:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: QuTiP可以帮助探索当我们相乘泡利矩阵时会发生什么：例如，以两种可能的顺序将*X*和*Y*相乘：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similarly, *YZ* = *iX* and *ZX* = *iY*, but *ZY* = *–**iX* and *XZ* = *–**iY*.
    One way to remember this is to think of *X*, *Y*, and *Z* as playing a little
    game of rock-paper-scissors: *X* “beats” *Y*, *Y* “beats” *Z*, and *Z* “beats”
    *X* in turn.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，*YZ* = *iX*和*ZX* = *iY*，但*ZY* = *–*iX*和*XZ* = *–*iY*。一种记住这个的方法是将*X*、*Y*和*Z*想象成在玩一个小游戏：*X*“打败”*Y*，*Y*“打败”*Z*，然后*Z*“打败”*X*。
- en: We can think of these matrices as establishing a kind of coordinate system for
    qubit states, called the *Bloch sphere*. As shown in figure 6.6, the *X*- and
    *Z*-axes form the circle we’ve seen in the book thus far, while the *Y*-axis comes
    out of the page.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些矩阵视为为量子比特态建立一种坐标系统，称为*布洛赫球面*。如图6.6所示，*X*轴和*Z*轴形成了我们在书中迄今为止看到的圆，而*Y*轴则从页面上伸出。
- en: '![](../Images/6-6.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-6.png)'
- en: Figure 6.6 The Bloch sphere, in all its spherical glory. Here, each of the axes
    is labeled with the corresponding Pauli operator representing rotations around
    that axis.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 布洛赫球面，展示其球面之美。在这里，每个轴都标有表示围绕该轴旋转的泡利算符。
- en: Describing states with Pauli measurements
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泡利测量描述态
- en: Any single-qubit state can be entirely specified up to a global phase by the
    measurement probabilities for *X*, *Y*, and *Z* measurements. That is, if we tell
    you the probability of getting a “1” outcome for each of the three Pauli measurements
    that we could perform, you can use that information to write a state vector that
    is identical to ours, up to the global phase. This makes the analogy to points
    in three dimensions useful for thinking about single-qubit states.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 任何单个量子比特态都可以通过*X*、*Y*和*Z*测量的测量概率完全指定，直到全局相位。也就是说，如果我们告诉你我们能够执行的三种泡利测量中每种得到“1”结果的概率，你可以使用这些信息来编写一个与我们完全相同（除了全局相位）的状态向量。这使得将三维空间中的点与单个量子比特态的类比对于思考单个量子比特态是有用的。
- en: The *i*s have it
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*i*有优势'
- en: 'The states at the ends of the *Y*-axis are usually labeled |*i* 〉 and |−*i*
    〉 but are not often used on their own. We will just stick to the labeled states
    we were using before: |0〉, |1〉, |+〉, and |−〉.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Y轴末端的态通常标记为|*i* 〉和|−*i* 〉，但它们通常不单独使用。我们将继续使用之前标记的状态：|0〉、|1〉、|+〉和|−〉。
- en: With this picture in mind, it’s easier to see why some rotations don’t affect
    the results of measurements. For instance, as illustrated in figure 6.7, the Bloch
    sphere picture helps us understand what happens if we rotate |0〉 about the *Z*-axis.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图景下，更容易理解为什么某些旋转不会影响测量的结果。例如，如图6.7所示，布洛赫球面图帮助我们理解如果我们围绕*Z*轴旋转|0〉会发生什么。
- en: '![](../Images/6-7.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-7.png)'
- en: Figure 6.7 The Bloch sphere illustrating how an `rz` rotation leaves the |0〉
    state unchanged
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 布洛赫球面展示了`rz`旋转如何使|0〉态保持不变
- en: In the same way that the North Pole stays in the same spot no matter how much
    we spin a globe, if we rotate a state about an axis parallel to that state, there
    is no observable effect on our qubit. We can also see this effect come out of
    the math.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就像北极无论我们如何旋转地球都保持在同一位置一样，如果我们围绕与态平行的轴旋转态，那么我们的量子比特上不会有可观察到的效果。我们也可以从数学中看到这种效果。
- en: Listing 6.11 How the |0〉 state is unaffected by `rz` rotations
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.11 |0〉态不受`rz`旋转的影响
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Defines a variable to represent the state |0〉
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个变量来表示态|0〉
- en: ❷ Introduces a new state |*Ψ*〉 that’s a 60° (*π* / 3 in radians) rotation of
    |0〉 about the Z-axis
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 引入一个新的态|*Ψ*〉，它是围绕Z轴旋转60°（以弧度计为*π* / 3）的|0〉态。
- en: ❸ The resulting state is |*Ψ*〉 = [cos(60° / 2) − i sin(60° / 2)] |0〉 = [√3 /
    2 − i / 2] |0〉.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 结果态是|*Ψ*〉 = [cos(60° / 2) − i sin(60° / 2)] |0〉 = [√3 / 2 − i / 2] |0〉。
- en: ❹ Recall that in QuTiP, we write out the “dagger” operator ⁺ by calling the
    .dag method of Qobj instances, in this case giving us the row vector for 〈0|.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 记住，在QuTiP中，我们通过调用Qobj实例的.dag方法来写出“共轭”算符⁺，在这种情况下，它给出了〈0〉的行向量。
- en: ❺ Taking the inner product 〈0|*Ψ*〉, we can compute Born’s rule Pr(0|*Ψ*) = |〈0|*Ψ*〉|².
    Note that we need to index by [0, 0], since QuTiP represents the inner product
    of |0〉 with |*Ψ*〉 as a 1 × 1 matrix.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 通过取内积 〈0|*Ψ*〉，我们可以计算 Born 规则 Pr(0|*Ψ*) = |〈0|*Ψ*〉|²。请注意，我们需要用 [0, 0] 来索引，因为
    QuTiP 将 |0〉 与 |*Ψ*〉 的内积表示为一个 1 × 1 矩阵。
- en: ❻ As before, the probability of observing a “0” when measuring along the Z-axis
    hasn’t changed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如前所述，沿 Z 轴测量的“0”观察概率没有改变。
- en: Tip When writing down states, |*Ψ*〉 is often used as an arbitrary name, similar
    to how x is often used to represent an arbitrary variable in algebra.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：在写下状态时，|*Ψ*〉 常常被用作一个任意名称，类似于在代数中 x 常常被用来表示一个任意变量。
- en: 'Exercise 6.4: Verifying that applying rz doesn’t change |0〉'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.4：验证应用 rz 不改变 |0〉
- en: We’ve only checked that one measurement probability is still the same, but maybe
    the probabilities have changed for *x* or *y* measurements. To fully check that
    the global phase doesn’t change anything, prepare the same state and rotation
    as in listing 6.11 and check that the probabilities of measuring the state along
    the *X**-* or *Y*-axis aren’t changed by applying an `rz` instruction.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只检查了一个测量概率仍然相同，但也许 *x* 或 *y* 测量的概率已经改变。为了完全检查全局相位不会改变任何东西，准备与列表 6.11 中相同的状态和旋转，并检查应用
    `rz` 指令后沿 *X**-* 或 *Y*-轴测量状态的概率是否改变。
- en: In general, we can always multiply a state by a complex number whose absolute
    value is 1 without changing the probabilities of any measurement. Any complex
    number *z* = *a* + *bi* can be written as *z* = *re*^(*i*θ) for real numbers *r*
    and *θ*, where *r* is the absolute value of *z* and where θ is an angle. When
    *r* = 1, we have a number of the form *e*^(*i*θ), which we call a *phase*. We
    then say that multiplying the state by a phase applies a *global phase* to that
    state.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以总是乘以一个绝对值为 1 的复数，而不会改变任何测量的概率。任何复数 *z* = *a* + *bi* 都可以写成 *z* = *re*^(*i*θ)
    的形式，其中 *r* 和 *θ* 是实数，*r* 是 *z* 的绝对值，θ 是一个角度。当 *r* = 1 时，我们有一个形式为 *e*^(*i*θ) 的数，我们称之为
    *相位*。然后我们说，乘以一个相位对该状态应用了一个 *全局相位*。
- en: Note No global phase can ever be detected by any measurement.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：任何全局相位都无法通过任何测量检测到。
- en: The states |*Ψ*〉 and *e*^(*i*θ) |*Ψ*〉 are in every conceivable way two different
    ways of describing the exact same state. There is no measurement we can do *even
    in principle* to learn about global phases. On the other hand, we’ve seen that
    we can tell apart states like |+〉 = (|0〉 + |1〉) / √2 and |−〉 = (|0〉 − |1〉) / √2
    that differ only in the *local* phase of the |1〉 computational basis state.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 状态 |*Ψ*〉 和 *e*^(*i*θ) |*Ψ*〉 以任何可以想象的方式都是描述完全相同状态的两种不同方法。我们甚至无法进行任何测量（即使是原则上）来了解全局相位。另一方面，我们已经看到我们可以区分像
    |+〉 = (|0〉 + |1〉) / √2 和 |−〉 = (|0〉 − |1〉) / √2 这样的状态，它们仅在 |1〉 计算基态的 *局部* 相位上有所不同。
- en: Taking a step back, let’s summarize what we’ve learned about the `x`, `y`, and
    `z` instructions so far and about the Pauli matrices we use to simulate those
    instructions. We’ve seen that the `x` instruction flips between |0〉 and |1〉, while
    the `z` instruction flips between the |+〉 and |−〉 states. Put differently, the
    `x` instruction flips bits, while the `z` instruction flips phases.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，让我们总结一下到目前为止我们关于 `x`、`y` 和 `z` 指令以及我们用来模拟这些指令的泡利矩阵所了解到的内容。我们已经看到，`x` 指令在
    |0〉 和 |1〉 之间翻转，而 `z` 指令在 |+〉 和 |−〉 状态之间翻转。换句话说，`x` 指令翻转比特，而 `z` 指令翻转相位。
- en: Looking at the Bloch sphere, we can see that rotating about the *Y*-axis should
    do both of these. We can also see this via *Y* = *–iXZ*, as it is straightforward
    to check with QuTiP. We summarize what each Pauli instruction does in table 6.2.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 观察布洛赫球，我们可以看到绕 *Y*-轴旋转应该做这两件事。我们也可以通过 *Y* = *–iXZ* 来看到这一点，因为使用 QuTiP 检查这一点很简单。我们在表
    6.2 中总结了每个泡利指令的作用。
- en: Table 6.2 Pauli matrices as bit and phase flips
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2 泡利矩阵作为比特和相位翻转
- en: '| Instruction | Pauli matrix | Flips bits (&#124;0?〉 ![](../Images/emoji-harrow.png)
    &#124;1〉) | Flips phases (&#124;+〉 ![](../Images/emoji-harrow.png) &#124;−〉)?
    |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 泡利矩阵 | 翻转比特 (&#124;0?〉 ![](../Images/emoji-harrow.png) &#124;1〉) | 翻转相位
    (&#124;+〉 ![](../Images/emoji-harrow.png) &#124;−〉)? |'
- en: '| (no instruction) | 𝟙  | No | No |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| (无指令) | 𝟙  | 否 | 否 |'
- en: '| `x` | *X* | Yes | No |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `x` | *X* | 是 | 否 |'
- en: '| `y` | *Y* | Yes | Yes |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `y` | *Y* | 是 | 是 |'
- en: '| `z` | *Z* | No | Yes |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `z` | *Z* | 否 | 是 |'
- en: 'Exercise 6.5: Hmm, that rings a Bell'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.5：嗯，这让我想起了什么
- en: 'The (|00〉 + |11〉) / √2 state that we’ve seen a few times now isn’t the only
    example of an entangled state. In fact, if we pick a two-qubit state at random,
    it is almost certainly going to be entangled. Just as the computational basis
    {|00〉, |01〉, |10〉, |11〉} is a particularly useful set of unentangled states, there’s
    a set of four particular entangled states known as the *Bell basis* after physicist
    John Stewart Bell:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次看到的（|00〉 + |11〉）/ √2 状态并不是纠缠态的唯一例子。实际上，如果我们随机选择一个两量子比特状态，它几乎肯定是一个纠缠态。就像计算基{|00〉、|01〉、|10〉、|11〉}是一个特别有用的非纠缠态集合一样，还有一个由物理学家约翰·斯图尔特·贝尔命名的四个特定纠缠态集合，称为*贝尔基*：
- en: '| Name | Expansion in computational basis |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 计算基展开 |'
- en: '| &#124;β[00]〉 | (&#124;00〉 + &#124;11〉) / √2 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| &#124;β[00]〉 | (&#124;00〉 + &#124;11〉) / √2 |'
- en: '| &#124;β[01]〉 | (&#124;00〉 – &#124;11〉) / √2 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| &#124;β[01]〉 | (&#124;00〉 – &#124;11〉) / √2 |'
- en: '| &#124;β[10]〉 | (&#124;01〉 + &#124;10〉) / √2 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| &#124;β[10]〉 | (&#124;01〉 + &#124;10〉) / √2 |'
- en: '| &#124;β[11]〉 | (&#124;01〉 – &#124;10〉) / √2 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| &#124;β[11]〉 | (&#124;01〉 – &#124;10〉) / √2 |'
- en: Using what you’ve learned about the `cnot` instruction and the Pauli instructions
    (`x`, `y`, and `z`), write programs to prepare each of the four Bell states in
    the table.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你关于`cnot`指令和Pauli指令（`x`、`y`和`z`）的知识，编写程序来准备表中的每个四个贝尔态。
- en: '*Hint*: Table 6.2 should be very helpful in this exercise.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示*：表6.2在这个练习中应该非常有帮助。'
- en: We finish our discussion of single-qubit operations by adding instructions to
    our `Qubit` interface and simulator for the `x`, `y`, and `z` operations. To do
    this, we can implement the rotation instructions `rx`, `ry`, and `rz` using the
    corresponding QuTiP functions `qt.rx`, `qt.ry`, and `qt.rz` to get copies of the
    unitary matrices we need to simulate each instruction. Here is how we can do this
    in our simulator.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向我们的`Qubit`接口和模拟器添加`x`、`y`和`z`操作的指令来完成对单量子比特操作的讨论。为此，我们可以使用相应的QuTiP函数`qt.rx`、`qt.ry`和`qt.rz`来实现旋转指令`rx`、`ry`和`rz`，以获取模拟每个指令所需的单位矩阵的副本。以下是我们在模拟器中如何实现这一点的示例。
- en: 'Listing 6.12 simulator.py: adding all of the Pauli rotations'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.12 simulator.py：添加所有Pauli旋转
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: QuTiP uses the notation σ[x] instead of *X* for the Pauli matrices. Using this
    notation, the function `sigmax()` returns a new `Qobj` representing the Pauli
    matrix *X*. This way, we can implement the `x`, `y`, and `z` instructions corresponding
    to each Pauli matrix.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: QuTiP使用σ[x]而不是*X*来表示Pauli矩阵。使用这种表示法，函数`sigmax()`返回一个表示Pauli矩阵*X*的新`Qobj`。这样，我们可以实现对应于每个Pauli矩阵的`x`、`y`和`z`指令。
- en: No one can be told what the Matrix is; you have to see it for yourself
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人能告诉你什么是矩阵；你必须亲自去体验
- en: We’ve talked a lot about matrices in part 1 of this book. A *lot*. It’s tempting
    to say that quantum programming is all about matrices and that qubits are really
    just vectors. In reality, though, matrices are how we *simulate* what a quantum
    device does. We’ll see more in part 2, but quantum programs don’t manipulate matrices
    and vectors at all—they manipulate classical data such as what instructions to
    send to a quantum device and what to do with the data we get back from devices.
    For instance, if we run an instruction on a device, there’s no simple way to see
    what matrix we should use to simulate that instruction—rather, we have to reconstruct
    that matrix from many repeated measurements using a technique called *process
    tomography*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的第一部分已经讨论了很多关于矩阵的内容。很多。人们可能会说量子编程就是关于矩阵的，而量子比特实际上只是向量。然而，实际上，矩阵是我们模拟量子设备所做事情的方式。在第二部分中，我们将看到更多，但量子程序并不操作矩阵和向量——它们操作经典数据，例如要发送到量子设备的指令以及如何处理从设备返回的数据。例如，如果我们在一个设备上运行一个指令，没有简单的方法可以看到我们应该使用哪个矩阵来模拟该指令——相反，我们必须使用称为*过程全息术*的技术从多次重复测量中重建该矩阵。
- en: When we write a matrix, whether in code or on a piece of paper, we’re implicitly
    simulating a quantum system. If that really bakes your noodle, don’t worry; this
    will make a lot more sense as you go through the rest of the book.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写矩阵时，无论是在代码中还是在纸上，我们都在隐式地模拟一个量子系统。如果这让你感到困惑，不要担心；随着你阅读本书的其余部分，这将会更加清晰。
- en: 6.3 Teleportation
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 量子态传输
- en: OK, now we have everything we need to write out what teleportation looks like
    as a quantum program. As a quick review, figure 6.8 is what we want this program
    to do.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们拥有了编写量子程序来描述量子态传输所需的一切。作为一个快速回顾，图6.8展示了我们希望这个程序执行的操作。
- en: '![](../Images/6-8.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-8.png)'
- en: Figure 6.8 Recall the steps of the teleportation program.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 回顾量子态传输程序的步骤。
- en: We will assume you can prepare some entangled qubits while they are in the same
    device and that we and Eve have a means of classical communication that we can
    use to signal the right correction to use. We can now use the features we added
    to our simulator in this chapter to implement the teleportation program.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设你们可以在它们位于同一设备上时准备一些纠缠量子比特，并且我们和爱娃有一种我们可以用来发出正确校正信号的经典通信方式。现在我们可以使用我们在本章中添加到我们的模拟器中的功能来实现量子传输程序。
- en: 'Listing 6.13 teleport.py: quantum teleportation in just a few lines'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.13 teleport.py：几行代码实现量子传输
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '❶ The teleport function takes two qubits as input: the qubit we want to move
    (msg) and where we want it to be moved (“there”). We also need one temporary qubit,
    which we call “here”. We presume by convention that both “here” and “there” start
    in the |0〉 state.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 传输函数接受两个量子比特作为输入：我们想要移动的量子比特（msg）以及我们想要它移动到的位置（“那里”）。我们还需要一个临时量子比特，我们称之为“这里”。我们按照惯例假设“这里”和“那里”都从|0〉状态开始。
- en: ❷ We need to start with some entanglement between “here” and “there”. We can
    use our old friend, the `h` instruction, together with our new friend, the `cnot`
    instruction.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们需要从“这里”和“那里”之间开始一些纠缠。我们可以使用我们的老朋友，`h`指令，以及我们的新朋友，`cnot`指令。
- en: ❸ The only instruction in this program that needs to act on both “here” and
    “there”. After running this, we can send Eve our qubit, and both of us can run
    the rest of the program with only classical communication.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这个程序中唯一需要同时作用于“这里”和“那里”的指令。运行这个指令后，我们可以将我们的量子比特发送给爱娃，然后我们两个人都可以只用经典通信来运行程序的其余部分。
- en: ❹ At this point in the program, “here” and “there” are in the (|00〉 + |11〉)
    / √2 state that we first saw in chapter 4.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在程序的这个阶段，“这里”和“那里”处于（|00〉 + |11〉）/ √2 状态，这是我们第一次在第4章中看到的。
- en: ❺ Runs the program we used to prepare the (|00〉 + |11〉) / √2 state backward,
    but on the msg and “here” qubits that live entirely on our device. We can think
    of running a preparation backward as a kind of measurement, such that these steps
    set us up to measure the quantum message we’re trying to send Eve in an entangled
    basis.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 运行我们用来准备（|00〉 + |11〉）/ √2状态的程序的反向，但是在我们设备上完全存在的msg和“这里”量子比特上。我们可以把运行准备的反向看作是一种测量，这样这些步骤就为我们设置好了，以便在一个纠缠基下测量我们试图发送给爱娃的量子消息。
- en: ❻ When we actually do that measurement, we get classical data to send Eve. Once
    she has that data, she can use the `x` and `z` instructions to decode the quantum
    message.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 当我们实际进行这个测量时，我们会得到可以发送给爱娃的经典数据。一旦她有了这些数据，她就可以使用`x`和`z`指令来解码量子消息。
- en: ❼ Now that we’re done with our qubits, it’s good to put them back into |0〉 so
    they’re ready to be used again. This doesn’t affect the state of “there”, though,
    as we’ve only reset our qubits, not the one we gave to Eve!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 现在我们已经处理完我们的量子比特，把它们放回|0〉状态是个好主意，这样它们就可以再次使用了。然而，这不会影响“那里”的状态，因为我们只是重置了我们的量子比特，而不是我们给爱娃的那个！
- en: '*c* what we did there?'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*c* 我们在那里做了什么？'
- en: 'Suppose we didn’t need to send Eve a classical measurement result as a part
    of teleportation. In that case, we could use teleportation to send both classical
    and quantum data faster than the speed of light. Just as we couldn’t communicate
    with Eve when we played the CHSH game in chapter 5, the speed of light means we
    need to communicate with Eve classically to use entanglement to send quantum data.
    In both cases, entanglement can help us communicate, but it doesn’t let us communicate
    all on its own: we always need some other kind of communication as well.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不需要将经典测量结果作为量子传输的一部分发送给爱娃。在这种情况下，我们可以使用量子传输以超过光速的速度发送经典和量子数据。正如我们在第5章中玩CHSH游戏时不能与爱娃通信一样，光速意味着我们需要以经典方式与爱娃通信，以使用纠缠来发送量子数据。在这两种情况下，纠缠可以帮助我们通信，但它并不让我们单独通信：我们始终需要其他类型的通信。
- en: To see that this actually works, we can prepare something on our qubit and send
    it to Eve, and then she can undo our preparation on her qubit. Thus far, the messages
    we and Eve have been sending have been classical, but here the message is *quantum*.
    We can and will measure the quantum message to get a classical bit, but we can
    also use the quantum message we get from Eve like any other quantum data. For
    example, we can apply whatever rotations and other instructions we like.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这实际上是如何工作的，我们可以在我们的量子比特上准备一些东西，并将其发送给爱娃，然后她可以在她的量子比特上撤销我们的准备。到目前为止，我们和爱娃发送的消息都是经典的，但在这里，消息是*量子*的。我们可以并且会测量量子消息以获得一个经典比特，但我们也可以像使用其他任何量子数据一样使用我们从爱娃那里得到的量子消息。例如，我们可以应用我们喜欢的任何旋转和其他指令。
- en: What is this good for?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么好处？
- en: Sending quantum data may not seem that much more useful than sending classical
    data; after all, sending classical data has gotten us a lot of neat things thus
    far. In contrast, applications for sending quantum data tend to be a bit more
    niche at the moment.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 发送量子数据可能看起来并不比发送经典数据更有用；毕竟，发送经典数据已经让我们得到了很多有趣的东西。相比之下，发送量子数据的应用目前似乎更具有针对性。
- en: That said, moving quantum data is a really useful example to help us understand
    how quantum computers work. The ideas developed in this chapter aren’t often *directly*
    useful but will help us build great stuff going forward.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，移动量子数据是一个非常有用的例子，可以帮助我们理解量子计算机是如何工作的。本章中开发的思想并不总是*直接*有用，但将有助于我们未来构建伟大事物。
- en: Let’s say we prepare a *quantum* message by using the operation `msg.ry(0.123)`.
    The following listing shows how we can teleport this message to Eve.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们通过使用操作`msg.ry(0.123)`来准备一个*量子*消息。以下列表显示了我们可以如何将此消息传送给Eve。
- en: 'Listing 6.14 teleport.py: using teleportation to move quantum data'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.14 teleport.py：使用量子隐形传态移动量子数据
- en: '[PRE16]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ As before, allocates a register of qubits and gives each qubit a name
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如前所述，分配一个量子比特寄存器，并为每个量子比特命名
- en: ❷ Prepares a message to send to Eve. Here, we’ve shown using a particular angle
    as the message, but it can be anything.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 准备一个要发送给Eve的消息。在这里，我们使用特定的角度作为消息，但它可以是任何东西。
- en: ❸ Calls the teleportation program we wrote earlier to move the message we prepared
    onto Eve’s qubit
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用我们之前编写的量子隐形传态程序，将我们准备的消息移动到Eve的量子比特上
- en: ❹ Checks the output of the dump instruction to see that the register we allocated
    is back in the |000〉 state
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查`dump`指令的输出，以确认我们分配的寄存器已回到|000〉状态
- en: 'If Eve then undoes our rotation by rotating by the opposite angle, we can check
    that the register we allocated is back in the |000〉 state. This shows that our
    teleportation worked! When you run this program, you’ll get output similar to
    the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Eve随后通过旋转相反的角度撤销我们的旋转，我们可以检查我们分配的寄存器是否回到了|000〉状态。这表明我们的量子隐形传态是有效的！当你运行这个程序时，你会得到类似于以下输出的结果：
- en: '[PRE17]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note Your output may differ by a global phase, depending on what measurement
    outcomes you got.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 你的输出可能因全局相位不同而有所不同，具体取决于你得到了哪些测量结果。
- en: To verify that the teleportation worked, if Eve undoes the instruction that
    we did on her qubit (`there.ry(0.123)`), she should get back the |0〉 state that
    we started with. With teleportation, we and Eve can send quantum information using
    entanglement and classical communication, as you can prove to yourself in exercise
    6.6.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证量子隐形传态是否成功，如果Eve撤销我们在她的量子比特上执行的指令（`there.ry(0.123)`），她应该得到我们开始时的|0〉状态。通过量子隐形传态，我们可以使用纠缠和经典通信来发送量子信息，正如你在练习6.6中可以证明的那样。
- en: 'Exercise 6.6: What if it didn’t do anything?'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.6：如果它不起作用怎么办？
- en: Try changing your operation or Eve’s operation to convince yourself that you
    only get a |000〉 state at the end if you undo the same operation that Eve applied
    to her qubit.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改你的操作或Eve的操作，以确信只有当你撤销Eve对其量子比特应用的操作时，你才能在最后得到|000〉状态。
- en: Now we can brag to all our friends (making whatever sci-fi references we want)
    that we can do teleportation. Hopefully you see why this is *not* the same as
    getting beamed down to a planet from orbit and that when you teleport a message,
    it does not communicate faster than the speed of light.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以向所有朋友吹嘘（做出我们想要的任何科幻参考）我们能够进行量子隐形传态。希望你能理解这*不是*从轨道上被传送到一个星球上，当你进行量子隐形传态时，信息并没有以超过光速的速度传递。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The no-cloning theorem prevents us from copying arbitrary data stored by quantum
    registers, but we can still move data using the `swap` operation and algorithms
    like teleportation.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量子不可克隆定理阻止我们复制量子寄存器存储的任意数据，但我们可以通过`swap`操作和像量子隐形传态这样的算法来移动数据。
- en: When a qubit isn’t entangled with any other qubits, we can visualize its state
    as a point on a sphere, known as the *Bloch sphere*.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个量子比特没有与任何其他量子比特纠缠时，我们可以将其状态可视化为球面上的一个点，称为*布洛赫球*。
- en: In general, we can rotate the state of a single qubit around the *x*-, *y*-,
    or *Z*-axis. The operations that apply rotations of 180° about each of these axes
    are called the *Pauli operations* and describe flipping either or both bits and
    phases.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，我们可以围绕*x*、*y*或*Z*轴旋转单个量子比特的状态。围绕这些轴旋转180°的操作称为*泡利操作*，描述了翻转一个或两个比特及其相位。
- en: In quantum teleportation, entanglement is used together with Pauli rotations
    to transfer quantum data from one qubit to another qubit without copying it.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在量子传输中，纠缠与泡利旋转一起使用，将量子数据从一比特传输到另一比特，而不复制它。
- en: 'Part 1: Conclusion'
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分：结论
- en: We have made it to the end of part 1 of the book, but sadly our qubits are in
    another castle ![](../Images/emoji-lol.png). Getting through this part was no
    mean feat, as we were building a simulator for a quantum device while learning
    a whole host of new quantum concepts. You are probably a bit shaky on some questions
    or topics, and that’s OK.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了本书第一部分的结尾，但遗憾的是，我们的量子比特在另一个城堡！![emoji-lol](../Images/emoji-lol.png)。通过这一部分并不容易，因为我们一边学习大量新的量子概念，一边构建量子设备的模拟器。你可能对某些问题或主题感到有些不稳定，这是正常的。
- en: Tip Appendix B contains some quick references (glossary and definitions) that
    may be helpful as you move forward in this book and your subsequent quantum development
    endeavors.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 提示附录B包含一些快速参考（术语表和定义），在你继续阅读本书并从事后续的量子发展工作时可能会很有帮助。
- en: 'We will be using and practicing these skills to develop more complicated quantum
    programs for cool applications like chemistry and cryptography. Before we move
    on to that, though, give yourself a pat on the back: you’ve done a lot so far!
    Let’s summarize some of what you’ve accomplished:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用并练习这些技能来开发更复杂的量子程序，用于酷炫的应用，如化学和密码学。在我们继续前进之前，先给自己鼓掌：你已经做得很多了！让我们总结一下你取得的成就：
- en: Refreshed your linear algebra and complex number skills
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 温习了线性代数和复数技能
- en: Learned what a qubit is as well as what you can do with one
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习了量子比特是什么以及你可以用它做什么
- en: Built a multiple-qubit simulator in Python
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python构建了一个多比特模拟器
- en: Wrote quantum programs for tasks like quantum key distribution (QKD), playing
    nonlocal games, and even quantum teleportation
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写了量子程序，用于量子密钥分发（QKD）、玩非局域游戏，甚至量子传输
- en: Learned braket notation for the states of quantum systems
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习了量子系统状态的braket符号
- en: Your Python simulator will continue to be a useful tool for trying to understand
    what is happening when we get to larger applications. In part 2, we will switch
    to primarily using Q# as our tool of choice to write quantum programs. We will
    talk in the next chapter about why we will write more advanced quantum programs
    in Q# rather than Python, but the main reasons are speed and extensibility. Plus,
    you can use Q# from Python or with a Q# kernel for Jupyter, so you can work with
    whatever development environment you like best.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Python模拟器将继续是尝试理解我们在更大应用中发生的事情的有用工具。在第二部分，我们将主要使用Q#作为编写量子程序的首选工具。我们将在下一章讨论为什么我们将更多地使用Q#而不是Python来编写更高级的量子程序，但主要原因还是速度和可扩展性。此外，你可以从Python或使用Q#内核与Jupyter一起使用Q#，这样你就可以使用你最喜爱的开发环境进行工作。
- en: See you in part 2!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分再见！
