- en: 5 Beyond callbacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 超越回调
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Callbacks and their limitations, as shown with a gateway/edge service example
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调及其局限性，如网关/边缘服务示例所示
- en: Futures and promises--a simple model to chain asynchronous operations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来和承诺--一个简单的模型，用于链式异步操作
- en: Reactive extensions--a more powerful model that is especially well suited to
    composing streams of asynchronous events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式扩展--一个更强大的模型，特别适合组合异步事件流
- en: Kotlin coroutines--language-level support for asynchronous code execution flows
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin协程--对异步代码执行流程的语言级支持
- en: You will need to write all sorts of business logic while developing a reactive
    application, and not all logic is easy to express in an asynchronous form. While
    callbacks are a simple form of asynchronous event notification, they can easily
    render asynchronous code complicated.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发反应式应用程序时，您需要编写各种业务逻辑，并且并非所有逻辑都容易用异步形式表达。虽然回调是异步事件通知的简单形式，但它们很容易使异步代码变得复杂。
- en: Let’s look at a real example of why callbacks are not always the best asynchronous
    programming model. Then we’ll explore the multiple options supported in Vert.x.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看为什么回调不总是最好的异步编程模型的实际例子。然后我们将探讨Vert.x支持的多种选项。
- en: '5.1 Composing asynchronous operations: The edge service example'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 组合异步操作：边缘服务示例
- en: We’ll take the example of an *edge service* to illustrate composing asynchronous
    operations with different asynchronous programming models.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个 *边缘服务* 为例，说明如何使用不同的异步编程模型组合异步操作。
- en: An edge service is also frequently called an *API gateway*. It is a service
    that serves as a facade for other services, so that a requester just has to deal
    with one service interface rather than having to talk to each service. An edge
    service may also perform other tasks, such as data transformation and interacting
    with other services, so it does not just conveniently aggregate data from multiple
    services.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘服务也经常被称为 *API网关*。它是一个充当其他服务门面的服务，因此请求者只需处理一个服务接口，而不是与每个服务交谈。边缘服务还可以执行其他任务，例如数据转换和与其他服务的交互，因此它不仅方便地聚合来自多个服务的数据。
- en: 5.1.1 Scenario
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 场景
- en: Let’s go back to the heat sensor verticles we used in chapter 3\. Suppose that
    we have several heat sensors, and we want to expose an API to fetch and aggregate
    all of the sensors’ heat data. This is a very simple yet effective example of
    an edge service, as it abstracts the need for a requester to know about and contact
    all the sensors. To make things even more interesting, we’ll also have a *snapshot*
    service that captures and logs the sensor values before they are returned to the
    requester. The whole scenario is illustrated in figure 5.1.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下第3章中使用的热传感器垂直结构。假设我们有几个热传感器，我们想要公开一个API来获取和聚合所有传感器的热数据。这是一个非常简单但有效的边缘服务示例，因为它抽象了请求者需要了解和联系所有传感器的需求。为了使事情更有趣，我们还将有一个
    *快照* 服务，在将传感器值返回给请求者之前捕获并记录这些值。整个场景如图5.1所示。
- en: '![](../Images/CH05_F01_Ponge.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F01_Ponge.png)'
- en: Figure 5.1 Edge service scenario
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 边缘服务场景
- en: The requester issues a request to the edge service, which in turn fetches temperature
    data from the sensor services. Each sensor exposes an HTTP/JSON API, and the edge
    service aggregates all responses in a larger JSON document. This document is then
    sent to the snapshot service, before it’s sent back to the requester. The interactions
    are summarized in figure 5.2.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请求者向边缘服务发出请求，边缘服务随后从传感器服务中获取温度数据。每个传感器都公开了HTTP/JSON API，边缘服务将所有响应聚合在一个更大的JSON文档中。然后，该文档被发送到快照服务，然后再发送回请求者。这些交互总结在图5.2中。
- en: '![](../Images/CH05_F02_Ponge.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F02_Ponge.png)'
- en: Figure 5.2 Interactions between the edge, sensor, and snapshot services
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 边缘、传感器和快照服务之间的交互
- en: 'This example allows us to reason about parallel and sequential operations:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使我们能够对并行和顺序操作进行推理：
- en: 'Parallel asynchronous operations: fetching heat sensor data'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行异步操作：获取热传感器数据
- en: 'Sequential asynchronous operations: aggregating heat sensor data, sending it
    to the snapshot service, and then returning it to the requester'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序异步操作：聚合热传感器数据，将其发送到快照服务，然后将其返回给请求者
- en: 5.1.2 Heat sensor verticles
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 热传感器垂直结构
- en: We could deploy our heat sensors as multiple independent processes, each exposing
    an HTTP API. To simplify our example, we will deploy them within the same process,
    albeit with HTTP servers listening on different TCP ports.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的热传感器作为多个独立进程部署，每个进程都公开一个 HTTP API。为了简化我们的示例，我们将它们部署在同一个进程中，尽管 HTTP 服务器监听不同的
    TCP 端口。
- en: The following `HeatSensor` class is a simple adaptation of the one we used earlier.
    Listing 5.1 shows the preamble of the class, directly ported from the code in
    chapter 3.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `HeatSensor` 类是对我们之前使用的类的简单修改。列表 5.1 显示了类的序言，直接从第 3 章的代码移植过来。
- en: Listing 5.1 Heat sensor verticle
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 热传感器垂直
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Each sensor has a generated unique identifier.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每个传感器都有一个生成的唯一标识符。
- en: The code keeps the same logic of updating the temperature by a random amount,
    with a random delay of between one and six seconds.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码保持了通过随机量更新温度的逻辑，随机延迟在一到六秒之间。
- en: The following listing shows the code added to expose an HTTP API.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了添加以公开 HTTP API 的代码。
- en: Listing 5.2 Heat sensor verticle HTTP API code
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 热传感器垂直 HTTP API 代码
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ The server TCP port is configurable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 服务器 TCP 端口是可配置的。
- en: This is a very straightforward use of the Vert.x HTTP server, with the HTTP
    port being passed by configuration. The response is encoded in JSON.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常直接使用 Vert.x HTTP 服务器的例子，HTTP 端口通过配置传递。响应以 JSON 编码。
- en: 5.1.3 Snapshot service verticle
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 快照服务垂直
- en: The snapshot service exposes an HTTP server as well, as you can see in the following
    listing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 快照服务也公开了一个 HTTP 服务器，如下列所示。
- en: Listing 5.3 Snapshot service verticle
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.3 快照服务垂直
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ This waits for the whole body to be received rather than assembling intermediate
    buffers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这等待整个体被接收，而不是组装中间缓冲区。
- en: The HTTP request handler expects an HTTP `POST` request, extracts the body using
    a body handler, and logs the received data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求处理器期望一个 HTTP `POST` 请求，使用一个体处理器提取体，并记录接收到的数据。
- en: With these two verticles defined, the fun can now begin, and we can look into
    making our edge service.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这两个垂直之后，现在可以开始有趣的部分了，我们可以看看如何制作我们的边缘服务。
- en: 5.2 Callbacks
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 回调
- en: We are first going to implement the edge service using callbacks, as we have
    been doing since the beginning of this book.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将使用回调函数来实现边缘服务，就像我们从这本书开始做的那样。
- en: The dependencies we need for our project are *Vert.x Core*, *Vert.x Web Client*
    (to simplify making HTTP requests), and *Logback*. The following listing shows
    the dependencies for a Gradle build. The artifacts are exactly the same when using
    Maven or any other compatible build tool.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目需要的依赖项是 *Vert.x Core*，*Vert.x Web Client*（简化 HTTP 请求的创建），以及 *Logback*。以下列表显示了
    Gradle 构建的依赖项。当使用 Maven 或任何其他兼容的构建工具时，工件完全相同。
- en: Listing 5.4 Edge service dependencies (callbacks version)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4 边缘服务依赖项（回调版本）
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Replace ${vertxVersion} with the current Vert.x version of your choice.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 ${vertxVersion} 替换为您选择的当前 Vert.x 版本。
- en: Note All classes other than `chapter5.future.CollectorService` compile on Vert.x
    3.9\. This class requires the newer Vert.x 4 future-based APIs, as mentioned in
    section 5.3.2 on Vert.x futures and promises.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：除了 `chapter5.future.CollectorService` 类以外的所有类都在 Vert.x 3.9 上编译。此类需要较新的基于
    Vert.x 4 的未来 API，如第 5.3.2 节中提到的 Vert.x 未来和承诺。
- en: 5.2.1 Implementation
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 实现
- en: We’ll start with the preamble of the `CollectorService` verticle class implementation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `CollectorService` 垂直类实现的序言开始。
- en: Listing 5.5 Callbacks implementation preamble
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.5 回调实现序言
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ A Vert.x web client needs a vertx context.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Vert.x 网络客户端需要一个 vertx 上下文。
- en: 'The `start` method first creates a `WebClient` instance and then starts an
    HTTP server on port 8080\. The web client class comes from the `vertx-web-client`
    module and greatly simplifies making HTTP requests compared to the HTTP client
    in the Vert.x core APIs. It especially simplifies HTTP body handling and conversions:
    you can convert a body to plain text, to JSON, or to general-purpose Vert.x buffers.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`start` 方法首先创建一个 `WebClient` 实例，然后在端口 8080 上启动一个 HTTP 服务器。Web 客户端类来自 `vertx-web-client`
    模块，与 Vert.x 核心API中的 HTTP 客户端相比，大大简化了 HTTP 请求的创建。它特别简化了 HTTP 体处理和转换：你可以将体转换为纯文本、JSON
    或通用 Vert.x 缓冲区。'
- en: The HTTP request handler is the `handleRequest` method shown in the following
    listing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求处理器是以下列表中显示的 `handleRequest` 方法。
- en: Listing 5.6 Request-handling with callbacks
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 使用回调处理请求
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ We need a list to collect the JSON responses.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们需要一个列表来收集 JSON 响应。
- en: ❷ We also need a counter for tracking responses, since the number of responses
    may be less than the number of requests when there are errors.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们还需要一个计数器来跟踪响应，因为当有错误时，响应的数量可能少于请求的数量。
- en: ❸ This issues an HTTP GET request on resource / on localhost and port 3000 +
    i.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这会在资源 / 上对 localhost 和端口 3000 + i 发出 HTTP GET 请求。
- en: ❹ This predicate triggers an error when the HTTP status code is not in the 2xx
    range.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当 HTTP 状态码不在 2xx 范围内时，此谓词会触发错误。
- en: ❺ This treats the body as a JSON object and performs automatic conversion.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 这将体视为 JSON 对象并执行自动转换。
- en: ❻ When all requests (or errors) have been received, we can move to the next
    operation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 当所有请求（或错误）都已接收后，我们可以进行下一步操作。
- en: This method shows how easy it is to use the web client API to perform HTTP requests.
    The main difficulty lies in coordinating the parallel HTTP requests. We need a
    loop to issue the requests, and since they are asynchronous, we also need to keep
    track of the number of received responses and the response values. This is done
    by having a list of responses, and using a counter for responses. Note that we
    use an `AtomicInteger` here not because of concurrency, but rather because we
    need an object to increment an integer from the callbacks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法展示了使用网络客户端 API 执行 HTTP 请求是多么容易。主要困难在于协调并行 HTTP 请求。我们需要一个循环来发出请求，由于它们是异步的，我们还需要跟踪接收到的响应数量和响应值。这是通过有一个响应列表和使用响应计数器来完成的。请注意，我们在这里使用
    `AtomicInteger` 不是因为并发，而是因为我们需要一个对象来从回调中增加一个整数。
- en: Once all responses have been received, we can move to the next operation, which
    is sending the data to the snapshot service.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有响应都已接收，我们可以进行下一步操作，即将数据发送到快照服务。
- en: Listing 5.7 Sending data to the snapshot service
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 向快照服务发送数据
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ In case of error, we end the HTTP request here with a 500 status code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果发生错误，我们在此处使用 500 状态码结束 HTTP 请求。
- en: This method implementation simply uses the web client to issue an HTTP `POST`
    request.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法实现简单地使用网络客户端发出 HTTP `POST` 请求。
- en: Upon success, the code moves to the `sendResponse` method to end the HTTP request,
    shown next.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 成功后，代码将移动到 `sendResponse` 方法以结束 HTTP 请求，如下所示。
- en: Listing 5.8 Sending the response
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 发送响应
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Gives a compact JSON text representation
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提供紧凑的 JSON 文本表示
- en: 5.2.2 Running
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 运行
- en: To run the edge service, we first need to deploy verticles, as in the following
    listing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行边缘服务，我们首先需要部署 verticles，如下所示。
- en: Listing 5.9 Main method
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 主方法
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Each instance can use a different port number.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每个实例可以使用不同的端口号。
- en: We can issue HTTP requests to test the service with HTTPie, as shown next.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 HTTPie 来发出 HTTP 请求以测试服务，如下所示。
- en: Listing 5.10 Calling the edge service
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.10 调用边缘服务
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Using HTTPie, :8080 is a shortcut for http://localhost:8080.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 HTTPie，:8080 是 http://localhost:8080 的快捷方式。
- en: On the server side, we can check that the snapshot service outputs some logs,
    as in the following listing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们可以检查快照服务是否输出了一些日志，如下所示。
- en: Listing 5.11 Logs of the edge service
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.11 边缘服务的日志
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Each entry has the aggregated JSON data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每个条目都有聚合的 JSON 数据。
- en: 5.2.3 The “callback hell” is not the problem
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 “回调地狱”不是问题
- en: Many people will scream “Callback hell!” when discussing callbacks. Callback
    hell is when nested callbacks are being used to chain asynchronous operations,
    resulting in code that is harder to understand, due to the deep nesting. Error
    handling is especially more difficult with nested callbacks.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论回调时，许多人会尖叫“回调地狱！”。回调地狱是指使用嵌套回调来链式异步操作，导致代码难以理解，因为嵌套太深。使用嵌套回调进行错误处理尤其困难。
- en: While this is true, callback hell can easily be mitigated using one method for
    each asynchronous operation callback, as we did with the `handleRequest`, `sendToSnapshot`,
    and `sendResponse` methods. Each method does exactly one thing, and we avoid nesting
    the callbacks.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是真的，但可以通过为每个异步操作回调使用一个方法来轻松缓解回调地狱，就像我们在 `handleRequest`、`sendToSnapshot`
    和 `sendResponse` 方法中所做的那样。每个方法只做一件事，我们避免了回调的嵌套。
- en: The following listing shows equivalent code to the preceding, but compacted
    as a single piece with nested callbacks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了与前面等效的代码，但紧凑地作为一个带有嵌套回调的单个部分。
- en: Listing 5.12 Variant with nested callbacks
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12 嵌套回调的变体
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Send a sensor request in parallel with the others.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 与其他并行发送传感器请求。
- en: ❷ All HTTP responses have been received.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 所有 HTTP 响应已接收。
- en: ❸ Post to the snapshot service.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 向快照服务发送帖子。
- en: ❹ Respond to the requester.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 回应请求者。
- en: Nested callbacks certainly do not render the code more readable, but I argue
    that the real issue lies in the fact that the functional code is entangled with
    asynchronous coordination code. You need to decipher from the loop, callbacks,
    and branching that three HTTP requests are being made in parallel and that their
    results are being assembled, sent to a third-party service, and then given back
    as a response.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套回调当然不会使代码更易读，但我认为真正的问题在于函数式代码与异步协调代码交织在一起。你需要从循环、回调和分支中解析出三个HTTP请求是并行进行的，并且它们的处理结果被组装、发送到第三方服务，然后作为响应返回。
- en: Callbacks aren’t perfect, but a bit of discipline keeps the code readable, especially
    when all you have is sequential composition of asynchronous operations, like `sendToSnapshot`
    passing the work to `sendResponse`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 回调并不完美，但一点点的纪律可以使代码更易读，尤其是当你只有异步操作的顺序组合时，比如`sendToSnapshot`将工作传递给`sendResponse`。
- en: Let’s now look at other asynchronous programming models that can be more interesting
    than callbacks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看其他可能比回调更有趣的异步编程模型。
- en: 5.3 Futures and promises
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 Futures和promises
- en: You have already been exposed to Vert.x *futures* and *promises* due to the
    signature of the verticle `start` methods. You may also have been exposed to them
    in other languages, like JavaScript. We’ll explore this model further and see
    how they are interesting primitives for composing asynchronous operations with
    Vert.x.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经因为verticle `start`方法的签名而接触到了Vert.x的*futures*和*promises*。你也许在其他语言中，如JavaScript，也接触到了它们。我们将进一步探讨这个模型，并看看它们是如何成为Vert.x中组合异步操作的有趣原语。
- en: Vert.x implements a model of futures and promises that is in line with the original
    research results from Barbara Liskov and Liuba Shrira.[1](#pgfId-1015385) They
    introduced promises as a language abstraction for composing asynchronous remote
    procedure calls.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x实现了一个与Barbara Liskov和Liuba Shrira原始研究成果一致的futures和promises模型。[1](#pgfId-1015385)
    他们引入了promises作为异步远程过程调用的一种语言抽象。
- en: A promise holds the value of some computation for which there is no value right
    now. A promise is eventually completed with a result value or an error. In the
    context of asynchronous I/O, a promise is a natural fit for holding the result
    of an asynchronous operation. In turn, a future allows you to read a value that
    will eventually be available from a promise.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Promise持有某个计算的结果值，但目前还没有值。Promise最终会完成，带有结果值或错误。在异步I/O的上下文中，Promise是异步操作结果的理想选择。反过来，future允许你读取最终可以从Promise中获取的值。
- en: 'To summarize: a promise is used to write an eventual value, and a future is
    used to read it when it is available. Let’s now see how it works in Vert.x.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 总结：Promise用于写入最终值，future用于在它可用时读取它。现在让我们看看它在Vert.x中是如何工作的。
- en: 5.3.1 Futures and promises in Vert.x
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 Vert.x中的futures和promises
- en: A promise is created by a piece of code that is about to perform an asynchronous
    operation. As an example, imagine that you want to report that an asynchronous
    operation has completed, not now but in five seconds. In Vert.x you would use
    a timer for that, and a promise would be used to hold the result, as shown in
    the following listing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Promise是由即将执行异步操作的代码创建的。例如，假设你想报告一个异步操作已完成，不是现在，而是在五秒后。在Vert.x中，你会使用计时器来做这件事，并使用promise来持有结果，如以下列表所示。
- en: Listing 5.13 Creating a promise
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.13 从promise创建promise
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Create a promise.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建promise。
- en: ❷ Asynchronous operation
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 异步操作
- en: ❸ Complete the promise with a value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用值完成promise。
- en: ❹ Fail the promise with an exception.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用异常使promise失败。
- en: ❺ See listing 5.14.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❺参见列表5.14。
- en: Here the asynchronous operation is a timer of five seconds, after which the
    promise is completed. Depending on whether the current time is odd or even, the
    promise completes with a value or fails with an exception. This is great, but
    how do we actually *get* the value from the promise?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里异步操作是一个五秒的计时器，之后promise完成。根据当前时间是否为奇数或偶数，promise会完成带有值或失败带有异常。这很好，但我们实际上如何从promise中获取值呢？
- en: The code that wants to react when the result is available needs a future object.
    A Vert.x future is created from a promise, then passed to the code that wants
    to read the value, as shown in the next listing, which is the rest of listing
    5.13.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当结果可用时想要做出反应的代码需要一个future对象。Vert.x future是从promise创建的，然后传递给想要读取值的代码，如下一列表所示，这是列表5.13的其余部分。
- en: Listing 5.14 Creating a future from a promise
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.14 从promise创建future
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Derive a future from a promise, and then return it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从一个承诺中派生出一个未来，然后返回它。
- en: ❷ Callback for when the promise is completed
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当承诺完成时的回调
- en: ❸ Callback for when the future is failed
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当未来失败时的回调
- en: The `Future` interface defines two methods, `onSuccess` and `onFailure`, for
    handling values and errors. When we run the corresponding code, we see that either
    “Ok!” or “Bad luck...” is printed after five seconds.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future` 接口定义了两个方法，`onSuccess` 和 `onFailure`，用于处理值和错误。当我们运行相应的代码时，我们会在五秒后看到打印出“Ok！”或“Bad
    luck...”。'
- en: We can perform more advanced asynchronous operations with futures, as shown
    in the following listing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用未来执行更高级的异步操作，如下面的列表所示。
- en: Listing 5.15 Advanced future composition operations
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.15 高级未来组合操作
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Recover from an error with another value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用另一个值从错误中恢复。
- en: ❷ Map a value to another value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将一个值映射到另一个值。
- en: ❸ Compose with another asynchronous operation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 与另一个异步操作组合。
- en: The `recover` operation is called when the promise is failed, and it is used
    to replace the error with another value. You can see `recover` as the equivalent
    of a `catch` block in Java, where you can handle an error. Here we simply provide
    a recovery value using a succeeded future, but you can also report a *failed*
    future in more advanced cases when there is nothing you can do to recover.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当承诺失败时调用 `recover` 操作，它用于用另一个值替换错误。你可以将 `recover` 视为 Java 中的 `catch` 块的等价物，其中你可以处理错误。在这里，我们简单地使用一个成功的未来提供一个恢复值，但在更高级的情况下，当没有可以恢复的操作时，你也可以报告一个
    *失败的* 未来。
- en: The `map` operation transforms a value using a function, whereas `flatMap` composes
    with another asynchronous operation. You can think of `flatMap` as “and then.”
    Here the operation takes the string value and prepends it with “>>>” after three
    seconds. We also see the typical promise/future pattern where we first create
    a promise, then perform an asynchronous operation that eventually completes the
    promise, and finally return a future so the value can be consumed by another piece
    of code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 操作使用一个函数转换一个值，而 `flatMap` 与另一个异步操作组合。你可以将 `flatMap` 视为“然后”。在这里，操作在三个秒后将字符串值前加上“>>>”。我们还可以看到典型的承诺/未来模式，我们首先创建一个承诺，然后执行一个最终完成承诺的异步操作，最后返回一个未来，以便值可以被其他代码消费。'
- en: 5.3.2 Future-based APIs in Vert.x 4
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 Vert.x 4 中的基于未来的 API
- en: Vert.x 4 brings Vert.x futures to the core APIs alongside callbacks. While callbacks
    remain the canonical model, most APIs are available with variants that return
    a `Future`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 4 将 Vert.x 的未来对象引入到核心 API 中，与回调一起使用。虽然回调仍然是标准模型，但大多数 API 都提供了返回 `Future`
    的变体。
- en: This means that given a method, `void doThis(Handler<AsyncResult<T>>)`, there
    is a variant of the form `Future<T> doThis()`. A good example is shown in the
    following listing where we start an HTTP server.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着给定一个方法，`void doThis(Handler<AsyncResult<T>>)`，存在一个形式为 `Future<T> doThis()`
    的变体。以下列表中展示了良好的示例，其中我们启动了一个 HTTP 服务器。
- en: Listing 5.16 Starting an HTTP server with future methods
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.16 使用未来方法启动 HTTP 服务器
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Returns a Future<HttpServer>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回一个 Future<HttpServer>
- en: ❷ Called when the server could not be started
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当服务器无法启动时调用
- en: ❸ Called on success
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 成功时调用
- en: The `listen` method that we saw in earlier examples took a callback, and here
    it returns a `Future<HttpServer>`. We can then chain calls to `onFailure` and
    `onSuccess` to define what to do when the server starts, or when an error occurs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在早期示例中看到的 `listen` 方法接受了一个回调，而在这里它返回一个 `Future<HttpServer>`。然后我们可以链式调用 `onFailure`
    和 `onSuccess` 来定义服务器启动或发生错误时应该做什么。
- en: Note You can use the new promise/future interfaces starting from Vert.x 3.8,
    but the future-based APIs are only available in Vert.x 4\.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以从 Vert.x 3.8 开始使用新的承诺/未来接口，但基于未来的 API 只在 Vert.x 4 中可用。
- en: 5.3.3 Interoperability with CompletionStage APIs
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 与 CompletionStage API 的互操作性
- en: Vert.x futures are also interoperable with the `CompletionStage` interface of
    the `java.util.concurrent` package in the JDK. The `CompletionStage` interface
    represents a step in an asynchronous operation, so you can think of it as being
    a future, especially as there is a class called `CompletableFuture` that implements
    `CompletionStage`. For instance, the HTTP client API in Java 11 offers `sendAsync`
    methods that return `CompletableFuture` to make asynchronous HTTP requests.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 的未来对象也与 JDK 中 `java.util.concurrent` 包的 `CompletionStage` 接口互操作。`CompletionStage`
    接口代表异步操作中的一个步骤，因此你可以将其视为一个未来，特别是有一个名为 `CompletableFuture` 的类实现了 `CompletionStage`。例如，Java
    11 中的 HTTP 客户端 API 提供了返回 `CompletableFuture` 的 `sendAsync` 方法，以便进行异步 HTTP 请求。
- en: The interoperability between Vert.x futures and `CompletionStage` is useful
    when you need to interact with libraries that use `CompletionStage` in their APIs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要与使用 `CompletionStage` 在其 API 中的库交互时，Vert.x futures 和 `CompletionStage` 之间的互操作性很有用。
- en: Note The Vert.x `Future` interface is not a subtype of `CompletionStage`. The
    Vert.x team thought about it while preparing the roadmap for Vert.x 4, but we
    ultimately opted for our own interface definition, since `CompletionStage` is
    more agnostic regarding the threading model. Indeed, the “async”-suffixed methods
    provide variants where you can pass an executor like `CompletionStage<Void> thenRunAsync(Runnable,Executor)`,
    while the variants without an executor parameter dispatch by default to a `ForkJoinPool`
    instance. These methods allow stepping out of Vert.x event loops or worker thread
    pools too easily, so we chose to offer interoperability and not use `CompletionStage`
    directly in the Vert.x APIs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Vert.x `Future` 接口不是 `CompletionStage` 的子类型。在准备 Vert.x 4 的路线图时，Vert.x 团队考虑过这一点，但最终我们选择了自己的接口定义，因为
    `CompletionStage` 对线程模型更为中立。确实，“async”后缀的方法提供了可以传递执行器（如 `CompletionStage<Void>
    thenRunAsync(Runnable,Executor)`）的变体，而无需执行器参数的变体默认调度到 `ForkJoinPool` 实例。这些方法允许轻易地从
    Vert.x 事件循环或工作线程池中退出，因此我们选择提供互操作性，而不是在 Vert.x API 中直接使用 `CompletionStage`。
- en: The following listing shows how we can move from a Vert.x `Future` to a `CompletionStage`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何从 Vert.x `Future` 转换到 `CompletionStage`。
- en: Listing 5.17 From a Vert.x `Future` to a `CompletionStage`
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.17 从 Vert.x `Future` 到 `CompletionStage`
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Converts a Future to a CompletionStage
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 Future 转换为 CompletionStage
- en: ❷ thenApply is similar to map in Vert.x Future.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `thenApply` 与 Vert.x Future 中的 `map` 类似。
- en: ❸ Takes a value or an error
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 接收一个值或一个错误
- en: Here we convert the string result to uppercase, prefix it with a string, and
    eventually call `whenComplete`. Note that this is a `BiConsumer`, and you need
    to test which of the values or exception parameters is `null` to know whether
    the promise completed successfully. It is also important to note that unless you
    call an asynchronous `CompletionStage` method, the calls are performed on a Vert.x
    thread.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将字符串结果转换为大写，在其前面添加一个字符串，并最终调用 `whenComplete`。请注意，这是一个 `BiConsumer`，你需要测试哪个值或异常参数是
    `null`，以确定承诺是否成功完成。同样重要的是要注意，除非你调用异步的 `CompletionStage` 方法，否则调用将在 Vert.x 线程上执行。
- en: Last but not least, you can convert a `CompletionStage` to a Vert.x `Future`,
    as follows.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，你可以将 `CompletionStage` 转换为 Vert.x `Future`，如下所示。
- en: Listing 5.18 From a `CompletionStage` to a Vert.x `Future`
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.18 从 `CompletionStage` 到 Vert.x `Future`
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Create a CompletableFuture from an asynchronous operation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从异步操作创建一个 CompletableFuture。
- en: ❷ Convert to a Vert.x future, and dispatch on a Vert.x context.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 转换为 Vert.x future，并在 Vert.x 上下文中调度。
- en: '`CompletableFuture` implements `CompletionStage`, and `supplyAsync` dispatches
    a call to the default `ForkJoinPool`. A thread from that pool will be used, sleeping
    for five seconds before returning a string, which will be the `CompletableFuture`
    result. The `fromCompletionStage` method converts to a Vert.x `Future`. The method
    has two variants: one with a Vert.x context to call `Future` methods like `onSuccess`
    on the context, and one where the calls will happen on whatever thread completed
    the provided `CompletionStage` instance.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture` 实现 `CompletionStage`，`supplyAsync` 将调用调度到默认的 `ForkJoinPool`。该池中的一个线程将被使用，在返回一个字符串之前将睡眠五秒钟，这个字符串将是
    `CompletableFuture` 的结果。`fromCompletionStage` 方法将转换为 Vert.x `Future`。该方法有两个变体：一个带有
    Vert.x 上下文以调用 `Future` 方法，如 `onSuccess` 在上下文中，另一个调用将在完成提供的 `CompletionStage` 实例的任何线程上发生。'
- en: 5.3.4 Collector service with Vert.x futures
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.4 使用 Vert.x futures 的收集器服务
- en: Going back to the edge service example, we can make use of the Vert.x APIs that
    use `Future`. We’ll use the earlier verticle `start` method from listing 5.16.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 回到边缘服务示例，我们可以利用使用 `Future` 的 Vert.x API。我们将使用列表 5.16 中的早期 verticle `start` 方法。
- en: First of all, we can define the `fetchTemperature` method in the following listing
    to get the temperature from a service.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以在以下列表中定义 `fetchTemperature` 方法以从服务获取温度。
- en: Listing 5.19 Fetching temperature with future-based APIs
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.19 使用基于未来的 API 获取温度
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ A Future<HttpResponse>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Future<HttpResponse>
- en: ❷ Extract and return just the body.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 提取并返回仅包含正文的内容。
- en: This method returns a future of a `JsonObject`, and to achieve that we use the
    future-returning variant of the `WebClientsend` method, and then map the result
    to extract just the JSON data.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个 `JsonObject` 的 future，为了实现这一点，我们使用了返回 future 的 `WebClient.send` 方法的变体，然后将结果映射以提取仅包含
    JSON 数据。
- en: Temperatures are collected in the `handleRequest` method shown next.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 温度数据在下面的 `handleRequest` 方法中收集。
- en: Listing 5.20 Collecting temperatures with future-based APIs
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.20 使用基于未来的 API 收集温度
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Compose several futures.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 组合多个未来。
- en: ❷ Fetch temperatures.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取温度。
- en: ❸ Chain with another asynchronous operation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 与另一个异步操作链式调用。
- en: ❹ Handle success.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 处理成功情况。
- en: ❺ Handle failure.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 处理失败情况。
- en: You can use `CompositeFuture` to make one future out of several. The `all` static
    method results in a future that is completed when all futures are completed, and
    that fails when any future has failed. There are also `any` and `join` methods
    that have different semantics.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `CompositeFuture` 将多个未来合并成一个。`all` 静态方法会生成一个当所有未来都完成时完成，任何未来失败时失败的未来。还有
    `any` 和 `join` 方法，它们有不同的语义。
- en: Once all temperatures have been successfully received, the call to `flatMap`
    sends data to the snapshot service, which is an asynchronous operation. The code
    for the `sendToSnapshot` method is shown in the following listing.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有温度都成功接收，`flatMap` 的调用会将数据发送到快照服务，这是一个异步操作。`sendToSnapshot` 方法的代码如下所示。
- en: Listing 5.21 Sending data to the snapshot service with future-based APIs
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.21 使用基于未来的 API 向快照服务发送数据
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Future-based variant
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 基于未来的变体
- en: 'This code is similar to that of `fetchTemperature` because we use a method
    of `WebClient` that returns a `Future`. The code of the main method that deploys
    verticles is the same as in the callbacks variant, except that we deploy a different
    `CollectorService` verticle:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与 `fetchTemperature` 的代码类似，因为我们使用了一个返回 `Future` 的 `WebClient` 方法。部署 verticles
    的主方法代码与回调变体相同，只是我们部署了一个不同的 `CollectorService` verticle：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let’s now move on to reactive extension, another asynchronous programming model.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续探讨反应式扩展，另一种异步编程模型。
- en: 5.4 Reactive extensions
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 反应式扩展
- en: Reactive extensions are an elaborated form of the *observable* design pattern.[2](#pgfId-1018609)
    They were first popularized by Erik Meijer in the *Microsoft .NET* ecosystem.
    Modern applications are increasingly composed of asynchronous event streams, not
    just on the server, but also in web, desktop, and mobile clients.[3](#pgfId-1018641)
    Indeed, we can think of graphical user interface events as a stream of events
    that an application has to respond to.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式扩展是 *可观察* 设计模式的扩展形式。[2](#pgfId-1018609) 它们最初由 Erik Meijer 在 *Microsoft .NET*
    生态系统中推广。现代应用程序越来越多地由异步事件流组成，不仅限于服务器，还包括 Web、桌面和移动客户端。[3](#pgfId-1018641) 事实上，我们可以将图形用户界面事件视为应用程序必须响应的事件流。
- en: 'Reactive extensions are defined by three things:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式扩展由三件事定义：
- en: Observing event or data streams (e.g., an incoming HTTP request can be observed)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察事件或数据流（例如，观察传入的 HTTP 请求）
- en: Composing operators to transform streams (e.g., merge multiple HTTP request
    streams as one)
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过组合操作符转换流（例如，将多个 HTTP 请求流合并为一个）
- en: Subscribing to streams and reacting to events and errors
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅流并对事件和错误做出反应
- en: The *ReactiveX* initiative offers a common API and implementations in many languages,
    both for backend and frontend projects ([http://reactivex.io/](http://reactivex.io/)).
    The RxJS project offers reactive extensions for JavaScript applications in the
    browser, whereas a project like RxJava offers a general-purpose reactive extensions
    implementation for the Java ecosystem.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*ReactiveX* 创新为许多语言提供了通用的 API 和实现，包括后端和前端项目 ([http://reactivex.io/](http://reactivex.io/))。RxJS
    项目为浏览器中的 JavaScript 应用程序提供反应式扩展，而像 RxJava 这样的项目为 Java 生态系统提供了一个通用的反应式扩展实现。'
- en: Vert.x offers bindings for RxJava versions 1 and 2\. Using version 2 is recommended
    because it supports back-pressure, while version 1 does not.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 为 RxJava 1 和 2 版本提供绑定。建议使用版本 2，因为它支持背压，而版本 1 不支持。
- en: 5.4.1 RxJava in a nutshell
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 RxJava 简述
- en: Let’s explore the basics of what RxJava is and see what it does and how it nicely
    it integrates with Vert.x
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 RxJava 的基础知识，看看它做什么以及它如何与 Vert.x 优雅地集成。
- en: tip Timo Tuominen’s *RxJava for Android Developers* (Manning, 2019) is a solid
    resource for learning RxJava.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: tip Timo Tuominen 的 *RxJava for Android Developers* (Manning, 2019) 是学习 RxJava
    的一个可靠资源。
- en: Observable types
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察类型
- en: First of all, RxJava 2 offers five different types of observable sources, listed
    in table 5.1.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，RxJava 2 提供了五种不同类型的可观察源，列在表 5.1 中。
- en: Table 5.1 Observable types in RxJava
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 RxJava 中的可观察类型
- en: '| Type | Description | Example |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 | 示例 |'
- en: '| `Observable<T>` | A stream of events of type `T`. Does not support back-pressure.
    | Timer events, observable source where we cannot apply back-pressure like GUI
    events |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `Observable<T>` | 类型为 `T` 的事件流。不支持背压。 | 计时事件，无法应用背压的观察源，如 GUI 事件 |'
- en: '| `Flowable<T>` | A stream of events of type `T` where back-pressure can be
    applied | Network data, filesystem inputs |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `Flowable<T>` | 可以应用背压的类型为 `T` 的事件流 | 网络数据，文件系统输入 |'
- en: '| `Single<T>` | A source that emits exactly one event of type `T` | Fetching
    an entry from a data store by key |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `Single<T>` | 发出类型为 `T` 的确切一个事件的源 | 通过键从数据存储中获取条目 |'
- en: '| `Maybe<T>` | A source that may emit one event of type `T`, or none | Fetching
    an entry from a data store by key, but the key may not exist |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `Maybe<T>` | 可能发出类型为 `T` 的一个事件，或没有 | 通过键从数据存储中获取条目，但键可能不存在 |'
- en: '| `Completable` | A source that notifies of some action having completed, but
    no value is being given | Deleting files |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `Completable` | 通知某些操作已完成，但没有给出任何值 | 删除文件 |'
- en: You may sometimes read about *hot* and *cold* sources. A hot source is a source
    where events are being emitted whether there are subscribers or not. A cold source
    is a source where events only start being emitted after the first subscription.
    A periodic timer is a hot source, whereas a file to read is a cold source. With
    a cold source, you can get all events, but with a hot source, you will only get
    those emitted after you have subscribed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时会读到 *热* 和 *冷* 源。热源是一个无论是否有订阅者都会发出事件的源。冷源是一个只有在第一次订阅后才开始发出事件的源。周期性计时器是一个热源，而要读取的文件是一个冷源。对于冷源，你可以获取所有事件，但对于热源，你将只能获取订阅后发出的那些事件。
- en: Basic examples
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 基本示例
- en: We’ll start with the simple example in listing 5.22, illustrated in figure 5.3.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从列表 5.22 中的简单示例开始，如图 5.3 所示。
- en: '![](../Images/CH05_F03_Ponge.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F03_Ponge.png)'
- en: Figure 5.3 RxJava pipeline of listing 5.22
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 列表 5.22 的 RxJava 管道
- en: Listing 5.22 A first RxJava example
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.22 一个 RxJava 的第一个示例
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ This is an observable of a predefined sequence.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是一个预定义序列的观察者。
- en: ❷ We map to a string.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们将它们映射为字符串。
- en: ❸ We transform the string.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们转换字符串。
- en: ❹ For each item, we print to the standard output.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对于每个项目，我们将其打印到标准输出。
- en: 'Running the code in listing 5.22 yields the following console output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表 5.22 中的代码会产生以下控制台输出：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This example creates an observable of three integers. The `just` factory method
    creates an `Observable<Integer>` source. We then use two `map` operators to transform
    the stream. The first one converts from an `Observable<Integer>` to an `Observable<String>`.
    The second one prepends the `@` character to each item. Finally, `subscribe` performs
    a subscription where `System.out.println` is called for each item.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例创建了一个包含三个整数的观察者。`just` 工厂方法创建了一个 `Observable<Integer>` 源。然后我们使用两个 `map`
    操作符来转换流。第一个将 `Observable<Integer>` 转换为 `Observable<String>`。第二个在每一项前添加 `@` 字符。最后，`subscribe`
    执行订阅，对每个项目调用 `System.out.println`。
- en: Sources may emit errors, in which case the subscriber can be notified. Consider
    the observable in the following listing.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 源可能会发出错误，在这种情况下，订阅者可以被通知。考虑以下列表中的观察者。
- en: Listing 5.23 Error handling with RxJava
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.23 使用 RxJava 进行错误处理
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ The observable emits one error.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 观察者发出一个错误。
- en: ❷ This is never called.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个方法永远不会被调用。
- en: ❸ The stacktrace will be printed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将打印堆栈跟踪。
- en: The observable of string values will emit one error. The `map` operator will
    never be called, since it operates only on values, not errors. We can see that
    `subscribe` now has two parameters; the second one is the callback to process
    errors. In this example, we just print the stack trace, but in networked applications,
    for example, we would do error recovery.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串值的观察者将发出一个错误。`map` 操作符永远不会被调用，因为它只操作值，不操作错误。我们可以看到 `subscribe` 现在有两个参数；第二个是处理错误的回调。在这个例子中，我们只是打印堆栈跟踪，但在网络应用程序中，例如，我们会进行错误恢复。
- en: Note Using the `just` factory method is great in examples and tests, but in
    real-world scenarios you’ll want to adapt a more complex source to produce events
    to an RxJava observable type. To do that, there is a general-purpose `Publisher`
    interface that you can implement to emit items to subscribers using the `fromPublisher`
    method (instead of `just`). There are also adapter methods for JDK futures, for
    iterable objects, and for generating items from a JDK callable object.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用`just`工厂方法在示例和测试中非常好，但在现实场景中，你可能需要将更复杂的源适配以产生RxJava可观察类型的事件。为此，有一个通用的`Publisher`接口，你可以实现它来使用`fromPublisher`方法（而不是`just`）向订阅者发出项目。还有适配器方法用于JDK未来、可迭代对象以及从JDK可调用对象生成项目。
- en: Life cycle
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期
- en: The previous example didn’t show the full life cycle of an observable. Once
    a subscription has been made, zero or many items are emitted. Then the stream
    terminates with either an error or a notification that it has completed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子没有显示可观察对象的完整生命周期。一旦订阅发生，就会发出零个或多个项目。然后流以错误或完成通知结束。
- en: Let’s look at a more elaborated example.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更详细的例子。
- en: Listing 5.24 Dealing with all life-cycle events in RxJava
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.24 在RxJava中处理所有生命周期事件
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Actions can be inserted, such as when a subscription happens.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 可以插入操作，例如当发生订阅时。
- en: ❷ This delays emitting events by five seconds.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这延迟了事件发射五秒钟。
- en: ❸ Another action, here called for each item flowing in the stream
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 另一个动作，在这里称为流中每个流动的项目
- en: ❹ This groups events 2 by 2.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 这组将事件2个一组。
- en: ❺ Called when the stream has completed
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当流完成时调用
- en: Running the preceding code gives the following output.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会得到以下输出。
- en: Listing 5.25 Output of running listing 5.24
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.25 运行列表5.24的输出
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ This is the sole output for five seconds. Then the next lines appear.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是五秒钟的唯一输出。然后出现下一行。
- en: 'This example shows us the form of `subscribe` where all events can be handled:
    an event, an error, and the completion of the stream. The example also shows further
    operators:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了`subscribe`的形式，其中可以处理所有事件：一个事件、一个错误和流的完成。该示例还展示了进一步的运算符：
- en: '`doOnSubscribe` and `doOnNext` are actions (with potential side effects) that
    can be triggered as items pass along the stream.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnSubscribe`和`doOnNext`是动作（可能有副作用），可以在项目通过流时触发。'
- en: '`delay` allows delaying when events start to be emitted further down the stream.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`允许在流中进一步发射事件时延迟。'
- en: '`buffer` groups events (into lists), so here we get events in pairs.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer`将事件（到列表中）分组，因此我们在这里以成对的事件接收。'
- en: There is, of course, more to RxJava than we’ve discussed in this section, but
    we’ve covered enough to dive into the Vert.x and RxJava integration.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，RxJava的内容远不止我们在这个部分讨论的，但我们已经涵盖了足够的内容，可以深入到Vert.x和RxJava的集成。
- en: 5.4.2 RxJava and Vert.x
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 RxJava和Vert.x
- en: The RxJava integration in Vert.x is available from the `vertx-rx-java2` module.
    In Gradle (and similarly in Maven), the dependency can be added as
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x中的RxJava集成可在`vertx-rx-java2`模块中找到。在Gradle（以及类似地，在Maven中），可以将依赖项添加为
- en: '[PRE27]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: All APIs from the projects in the official Vert.x stack have RxJava support.
    The RxJava APIs are automatically generated from those of the core APIs. There
    are several idiomatic conversion rules to RxJava APIs, but as a simple example,
    when you have
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 官方Vert.x堆栈中的所有项目API都支持RxJava。RxJava API是从核心API自动生成的。有几个习惯用法转换规则到RxJava API，但作为一个简单的例子，当你有
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: the translation to RxJava is
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译到RxJava是
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The RxJava APIs are in subpackages of `io.vertx.reactivex`. For instance, the
    RxJava version of `AbstractVerticle` is `io.vertx.reactivex.core.AbstractVerticle`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava API位于`io.vertx.reactivex`的子包中。例如，`AbstractVerticle`的RxJava版本是`io.vertx.reactivex.core.AbstractVerticle`。
- en: Let’s look at an example verticle using the RxJava APIs.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用RxJava API的一个示例verticle。
- en: Listing 5.26 RxJava and Vert.x APIs
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.26 RxJava和Vert.x API
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ rxStart notifies of deployment success using a Completable rather than a Future.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ rxStart使用Completable而不是Future通知部署成功。
- en: ❷ The scheduler enforces the Vert.x threading model.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调度器强制执行Vert.x线程模型。
- en: ❸ This is an RxJava variant of listen(port, callback).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这是一个RxJava的listen(port, callback)变体。
- en: ❹ This returns a Completable from a Single.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 这从Single返回一个Completable。
- en: This example opens a classic HTTP server that replies `Ok` to any request. The
    interesting part is that the RxJava variant of `AbstractVerticle` has an `rxStart`
    (and `rxStop`) method that notifies of deployment success. In our case, the verticle
    has been successfully deployed when the HTTP server has started, so we return
    a `Completable` object. You can check that methods prefixed with `rx` correspond
    to generated methods for supporting RxJava. If you inspect the RxJava APIs, you
    will note that the original methods (including callbacks) are still present.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子打开了一个经典的 HTTP 服务器，对任何请求都回复 `Ok`。有趣的部分是 RxJava 的 `AbstractVerticle` 变体有一个
    `rxStart`（和 `rxStop`）方法，用于通知部署成功。在我们的情况下，当 HTTP 服务器启动时，verticle 已成功部署，因此我们返回一个
    `Completable` 对象。你可以检查以 `rx` 前缀开头的方法是否对应于支持 RxJava 的生成方法。如果你检查 RxJava API，你会注意到原始方法（包括回调）仍然存在。
- en: The other interesting part of this example is the observable that emits events
    every second. It behaves essentially as a Vert.x timer would. There are several
    operator methods in the RxJava APIs that accept a *scheduler* object, because
    they need to defer asynchronous tasks. By default, they call back from an internal
    worker-thread pool that they manage, which breaks the Vert.x threading model assumptions.
    We can always pass a Vert.x scheduler to ensure that events are still being called
    back on the original context event loop.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中另一个有趣的部分是每秒发出事件的观察者。它本质上与 Vert.x 定时器类似。RxJava API 中有几个操作符方法接受一个 *scheduler*
    对象，因为它们需要延迟异步任务。默认情况下，它们从它们管理的内部工作线程池中回调，这打破了 Vert.x 线程模型假设。我们可以始终传递一个 Vert.x
    调度器以确保事件仍然在原始上下文事件循环中被回调。
- en: 5.4.3 Collector service in RxJava
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.3 RxJava 中的收集器服务
- en: We can now go back to our edge service example and rewrite the `CollectorService`
    verticle class with RxJava.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以回到我们的边缘服务示例，并用 RxJava 重新编写 `CollectorService` verticle 类。
- en: To begin, we’ll update the imports to use the `io.vertx.reactivex.*` packages.
    Since the verticle starts an HTTP server, we can take advantage of `rxStart` as
    follows.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将更新导入以使用 `io.vertx.reactivex.*` 包。由于 verticle 启动了一个 HTTP 服务器，我们可以利用 `rxStart`
    如下。
- en: Listing 5.27 RxJava collector service preamble
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.27 RxJava 收集器服务前缀
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ A Single<HttpServer>
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个 Single<HttpServer>
- en: ❷ A Completable
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个 Completable
- en: The next step is to write a method for fetching temperatures in parallel, and
    then to assemble the responses as a JSON object. Just like the callbacks version,
    we can have a method to fetch a single temperature. The code is shown in the following
    listing.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编写一个并行获取温度的方法，然后将响应组装成一个 JSON 对象。就像回调版本一样，我们可以有一个获取单个温度的方法。代码如下所示。
- en: Listing 5.28 Fetching temperature with RxJava
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.28 使用 RxJava 获取温度
- en: '[PRE32]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ This returns a Single.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这返回一个 Single。
- en: Again, the difference from the callbacks versions is that we use `rxSend` (which
    returns a `Single`) instead of `send` (which uses a callback).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，与回调版本的区别在于我们使用 `rxSend`（它返回一个 `Single`）而不是 `send`（它使用回调）。
- en: The next listing shows a method that composes parallel asynchronous HTTP requests
    and assembles a JSON object based on the responses.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了一个方法，该方法组合并行异步 HTTP 请求并根据响应组装一个 JSON 对象。
- en: Listing 5.29 Collecting temperatures requests with RxJava
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.29 使用 RxJava 收集温度请求
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ The zip operator composes three responses.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ zip 操作符组合了三个响应。
- en: ❷ The value is the zip operator response, boxed in a Single.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 值是 zip 操作符的响应，封装在一个 Single 中。
- en: By using `fetchTemperature` to fetch individual responses, we obtain `Single`
    objects that observe individual HTTP responses. To compose the results, we use
    the `zip` operator, which takes severable sources and composes the result as another
    `Single` object. When all HTTP responses are available, the `zip` operator passes
    the values to a function that must produce a value (of any type). The returned
    value is then the `Single` object that the `zip` operator emits. Here we build
    a JSON array using the HTTP response bodies that the Vert.x web client has converted
    to JSON for us, and we then wrap the array in a JSON object.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `fetchTemperature` 来获取单个响应，我们获得观察单个 HTTP 响应的 `Single` 对象。为了组合结果，我们使用 `zip`
    操作符，它接受可分割的源并将结果组合为另一个 `Single` 对象。当所有 HTTP 响应都可用时，`zip` 操作符将值传递给一个必须产生值的函数（任何类型）。返回的值然后是
    `zip` 操作符发出的 `Single` 对象。在这里，我们使用 Vert.x 网络客户端为我们转换成 JSON 的 HTTP 响应体构建一个 JSON
    数组，然后我们将数组包装在一个 JSON 对象中。
- en: Note that `zip` has many overloaded definitions with varying numbers of parameters
    to cope with two sources, three sources, and so on. When the code needs to handle
    an undefined number of sources, there is a variant taking a list of sources, and
    the function passed to `zip` accepts a list of values.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`zip` 函数有多个重载定义，参数数量不同，以应对两个来源、三个来源等情况。当代码需要处理未定义数量的来源时，有一个变体接受来源列表，并且传递给
    `zip` 函数的函数接受值列表。
- en: This leads us to the definition of the HTTP request handling method that collects
    the temperatures, posts to the snapshot service, and then responds to the requester.
    The code is in the following listing.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了处理 HTTP 请求的方法的定义，该方法收集温度，发布到快照服务，然后响应请求者。代码如下所示。
- en: Listing 5.30 RxJava collector service HTTP handler
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.30 RxJava 收集器服务 HTTP 处理器
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ We send data to the snapshot service.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们将数据发送到快照服务。
- en: ❷ We have a single point of error management.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们有一个错误管理的单一点。
- en: 'This method also performs the subscription: upon success JSON data is returned
    to the requester, and on failure an HTTP 500 error is returned. It is important
    to note that the subscription triggers the HTTP requests to the sensor services,
    then to the snapshot service, and so on. Until a subscription is made, RxJava
    observable pipelines are just “recipes” for processing events.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法还执行订阅：成功返回 JSON 数据给请求者，失败则返回 HTTP 500 错误。重要的是要注意，订阅触发对传感器服务的 HTTP 请求，然后是对快照服务的请求，等等。在订阅之前，RxJava
    可观察管道只是处理事件的“食谱”。
- en: The last missing part is the method that sends data to the snapshot service.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后缺少的部分是将数据发送到快照服务的方法。
- en: Listing 5.31 Sending data to the snapshot service with RxJava
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.31 使用 RxJava 向快照服务发送数据
- en: '[PRE35]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Once we have the JSON data, we issue an HTTP request.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一旦我们有了 JSON 数据，我们就发出一个 HTTP 请求。
- en: ❷ This sends a JSON object, then reports on the HTTP request response.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这发送一个 JSON 对象，然后报告 HTTP 请求响应。
- en: ❸ This allows us to give back the JSON object rather than the HTTP request response.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这使我们能够返回 JSON 对象而不是 HTTP 请求响应。
- en: This method introduces the `flatMap` operator, which is well known to functional
    programming enthusiasts. Don’t worry if `flatMap` sounds cryptic to you; in the
    case of composing sequential asynchronous operations, you can just read “flatmap”
    as “and then.”
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法引入了 `flatMap` 操作符，这对于函数式编程爱好者来说很熟悉。如果你觉得 `flatMap` 听起来很神秘，不要担心；在组合顺序异步操作的情况下，你只需将“flatMap”读作“然后”即可。
- en: Since `data` emits a JSON object, the `flatMap` operator allows us to issue
    an HTTP request with the web client once that JSON object has been emitted. We
    need another (nested) `flatMap` after the HTTP request to the snapshot service
    has succeeded. Indeed, `rxSendJsonObject` gives a single observable that emits
    an HTTP response. However, we need the JSON object because it has to be returned
    to the requester after sending to the snapshot service has succeeded, so the second
    `flatMap` allows us to do that and re-inject it into the pipeline. This is a very
    common pattern with RxJava.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `data` 发射一个 JSON 对象，`flatMap` 操作符允许我们在 JSON 对象发射后使用网络客户端发出一个 HTTP 请求。在向快照服务发出
    HTTP 请求并成功后，我们需要另一个（嵌套的）`flatMap`。确实，`rxSendJsonObject` 给出一个只发射 HTTP 响应的单个可观察对象。然而，我们需要
    JSON 对象，因为它必须在将数据发送到快照服务成功后返回给请求者，所以第二个 `flatMap` 允许我们这样做，并将其重新注入到管道中。这是 RxJava
    中非常常见的模式。
- en: 'Running the RxJava version of the edge service is no different from running
    the callback version. All we need to do is change the deployment of the `CollectorService`
    to the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 运行边缘服务的 RxJava 版本与运行回调版本没有区别。我们所需做的只是将 `CollectorService` 的部署更改如下：
- en: '[PRE36]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Interacting with the service yields the same results as with the callback version.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 与回调版本相比，与服务交互产生相同的结果。
- en: The difference between `map` and `flatMap`
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 和 `flatMap` 的区别'
- en: '`flatMap` comes from the “flatten” and “map” operators. To better understand
    how it works, let’s illustrate `flatMap` with JavaScript arrays (you can test
    it using `node` or directly from a web browser console).'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap` 来自“flatten”和“map”操作符。为了更好地理解其工作原理，让我们用 JavaScript 数组来阐述 `flatMap`（你可以使用
    `node` 或直接从网页浏览器控制台测试它）。'
- en: 'With `let a = [1,` `2,` `3]`, `a` is an array with values `1`, `2`, and `3`.
    Now suppose that for each value, we want to have the value multiplied by `10`
    and `100`. With `map`, we could write `let` `b` `=` `a.map(x` `=>` `[x` `*` `10,`
    `x` `*` `100])`, which gives us an array of arrays: `[` `[ 10,` `100` `],` `[`
    `20,` `200` `],` `[` `30,` `300` `]` `]`.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `let a = [1,` `2,` `3]`, `a` 是一个包含值 `1`, `2`, 和 `3` 的数组。现在假设对于每个值，我们想要将其乘以
    `10` 和 `100`。使用 `map`，我们可以写出 `let b = a.map(x => [x * 10, x * 100])`，这将给我们一个数组的数组：`[[
    10, 100 ], [ 20, 200 ], [ 30, 300 ]]`。
- en: This is not very convenient if we just want the values rather than nested arrays,
    so we can “flatten” `b`, `b.flat()`, which gives us `[` `10,` `100,` `20,` `200,`
    `30,` `300` `]`. You can get the same result directly with `a.flatMap(x => [x
    * 10, x * 100])`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想得到值而不是嵌套数组，这并不太方便，因此我们可以“扁平化” `b`，`b.flat()`，这将给我们 `[10, 100, 20, 200,
    30, 300]`。您可以直接使用 `a.flatMap(x => [x * 10, x * 100])` 得到相同的结果。
- en: This translates directly to other operations, like HTTP client requests or database
    calls, as `flatMap` avoids nested observables of observables.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接转换为其他操作，如 HTTP 客户端请求或数据库调用，因为 `flatMap` 避免了嵌套的可观察对象的可观察对象。
- en: 5.5 Kotlin coroutines
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 Kotlin 协程
- en: The last asynchronous programming model to explore is that of *coroutines* in
    the Kotlin programming language. (For more information about Kotlin, see Dmitry
    Jemerov and Svetlana Isakova’s *Kotlin in Action* [Manning, 2017]).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要探索的异步编程模型是 Kotlin 编程语言中的 *协程*。（有关 Kotlin 的更多信息，请参阅 Dmitry Jemerov 和 Svetlana
    Isakova 的 *Kotlin in Action* [Manning, 2017]）。
- en: Coroutines are interesting to explore, as in many cases they allow us to write
    asynchronous code that *looks like* regular non-asynchronous code. Also, Kotlin
    has a solid implementation of coroutines that is very easy for Java developers
    to understand, and since we said that Vert.x was polyglot, this book had to show
    Vert.x without Java at some point!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 协程很有趣，因为它们在很多情况下允许我们编写看起来像常规非异步代码的异步代码。此外，Kotlin 有一个很好的协程实现，这对于 Java 开发者来说很容易理解，而且既然我们说
    Vert.x 是多语言的，这本书在某些时候不得不展示没有 Java 的 Vert.x！
- en: 5.5.1 What is a coroutine?
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 协程是什么？
- en: 'The term *coroutines* first appeared in a paper from Melvin Conway in 1963
    about the design of a COBOL compiler.[4](#pgfId-1022506) Many languages have support
    for coroutines, or some form of coroutines: Python (generators), C# (`async`/`await`
    operators), Go (*goroutines*), and more. Implementations for Java using bytecode
    instrumentation exist, and a future version of Java will have support for coroutines
    thanks to Project Loom ([https://openjdk.java.net/projects/loom/](https://openjdk.java.net/projects/loom/)).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *协程* 首次出现在 Melvin Conway 在 1963 年关于 COBOL 编译器设计的论文中。[4](#pgfId-1022506) 许多语言都支持协程或某种形式的协程：Python（生成器）、C#（`async`/`await`
    操作符）、Go（*goroutines*）以及更多。存在使用字节码插装实现的 Java，并且 Java 的未来版本将支持协程，归功于 Project Loom
    ([https://openjdk.java.net/projects/loom/](https://openjdk.java.net/projects/loom/))。
- en: A coroutine can have its execution suspended and resumed at a later point in
    time. It can be seen as a function with multiple entry and exit points and whose
    execution stack can be resumed. Coroutines fit well with an asynchronous model,
    as they can be suspended when the result of an asynchronous operation is needed
    and resumed when it is available.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 协程可以在未来的某个时间点挂起和恢复其执行。它可以被视为一个具有多个入口和出口点的函数，其执行堆栈可以被恢复。协程非常适合异步模型，因为它们可以在需要异步操作的结果时挂起，并在结果可用时恢复。
- en: To make things more concrete, let’s look at using coroutines in Kotlin. First,
    consider the following code.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更具体，让我们看看在 Kotlin 中使用协程。首先，考虑以下代码。
- en: Listing 5.32 Coroutines hello world
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.32 协程 hello world
- en: '[PRE37]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ This function can be suspended.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此函数可以被挂起。
- en: ❷ This function is suspending and will not block the caller thread.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此函数是挂起的，并且不会阻塞调用线程。
- en: ❸ This allows waiting for coroutines code to complete.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这允许等待协程代码完成。
- en: The call to `delay` does not block the caller thread because that method can
    be suspended. The method is called again when the time has elapsed, and it resumes
    executing at the next line, which returns a string. In a callback world, the `delay`
    function would have taken a callback parameter, which would have had to pass the
    returned string to the caller, probably using another callback.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`delay` 函数的调用不会阻塞调用线程，因为该方法可以被挂起。当时间过去后，该方法会再次被调用，并在下一行继续执行，返回一个字符串。在回调世界中，`delay`
    函数将需要一个回调参数，该参数将不得不将返回的字符串传递给调用者，可能使用另一个回调。'
- en: Here is a more elaborated example.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更详细的例子。
- en: Listing 5.33 Coroutines example
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.33 协程示例
- en: '[PRE38]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Starts a job
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 启动一个任务
- en: ❷ Starts a job that returns a value
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 启动一个返回值的任务
- en: ❸ Waits for the job to complete
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 等待任务完成
- en: ❹ Gets the value when the job completes
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在任务完成时获取值
- en: In this example, `job1` is created using `launch`, which executes some code
    in parallel. It waits for 500 ms. The same applies to `job2`, except that `async`
    is for code blocks that return a value. It computes the Fibonacci value of 42,
    which takes some time. The `join` and `await` methods on the jobs allow us to
    wait for these jobs to complete. Last but not least, the `main` function is wrapped
    in a `runBlocking` call. This is because suspended methods are being called, so
    the execution must wait for all coroutines to complete.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`job1` 使用 `launch` 创建，它并行执行一些代码。它等待 500 毫秒。对 `job2` 也适用，除了 `async` 是用于返回值的代码块。它计算
    42 的斐波那契值，这需要一些时间。作业上的 `join` 和 `await` 方法允许我们等待这些作业完成。最后但同样重要的是，`main` 函数被 `runBlocking`
    调用包裹。这是因为正在调用挂起方法，所以执行必须等待所有协程完成。
- en: We only scratched the surface of Kotlin and coroutines, but this should be enough
    to look at the Vert.x integration. To dive deeper into Kotlin, you may also want
    to read Pierre-Yves Saumont, *The Joy of Kotlin* (Manning, 2019).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是对 Kotlin 和协程进行了初步了解，但这应该足以查看 Vert.x 集成。要深入了解 Kotlin，您还可以阅读 Pierre-Yves Saumont
    的《Kotlin 的乐趣》（Manning，2019）。
- en: 5.5.2 Vert.x and Kotlin coroutines
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2 Vert.x 和 Kotlin 协程
- en: Vert.x offers first-class support for Kotlin coroutines. To use them in a Gradle
    project, you’ll need the dependencies and configuration shown in the following
    listing.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 为 Kotlin 协程提供了一级支持。要在 Gradle 项目中使用它们，您需要以下列表中显示的依赖项和配置。
- en: Listing 5.34 Vert.x Kotlin coroutine dependencies and configuration excerpt
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.34 Vert.x Kotlin 协程依赖项和配置摘录
- en: '[PRE39]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Replace kotlinVersion with the current Kotlin version (they are released often).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 kotlinVersion 替换为当前的 Kotlin 版本（它们发布得很频繁）。
- en: ❷ Replace vertxVersion with the current Vert.x version.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 vertxVersion 替换为当前的 Vert.x 版本。
- en: ❸ This brings JDK 8 Kotlin APIs.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这引入了 JDK 8 Kotlin API。
- en: ❹ By default, Kotlin compiles to JDK 6 bytecode for Android compatibility purposes.
    The JDK 8 bytecode is better.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 默认情况下，Kotlin 编译为 JDK 6 字节码以实现 Android 兼容性。JDK 8 字节码更好。
- en: Again, the coroutine bindings are generated from the callback APIs. The convention
    is that for any method having a callback, a Kotlin suspending method is generated
    with the suffix `Await`. Given
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，协程绑定是从回调 API 生成的。惯例是，对于任何具有回调的方法，都会生成一个带有后缀 `Await` 的 Kotlin 挂起方法。给定
- en: '[PRE40]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'the following method will exist in the Kotlin coroutines binding:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法将存在于 Kotlin 协程绑定中：
- en: '[PRE41]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There is a verticle base class called `io.vertx.kotlin.coroutines.CoroutineVerticle`
    where the `start` and `stop` methods are suspending, so you can use coroutines
    directly from them. By using `CoroutineVerticle`, you also get to execute coroutines
    on the verticle event-loop thread rather than on threads of a worker pool, like
    the default Kotlin coroutines do.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `io.vertx.kotlin.coroutines.CoroutineVerticle` 的 verticle 基类，其中 `start`
    和 `stop` 方法是挂起的，因此您可以直接从它们使用协程。通过使用 `CoroutineVerticle`，您还可以在 verticle 事件循环线程上而不是在工作池的线程上执行协程。默认的
    Kotlin 协程是在工作池的线程上执行的。
- en: tip If you write Vert.x code in Kotlin, you can also directly use RxJava from
    Kotlin. There is also a helper RxKotlin library that makes some RxJava APIs even
    more idiomatic from Kotlin.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果您用 Kotlin 编写 Vert.x 代码，您也可以直接从 Kotlin 使用 RxJava。还有一个辅助 RxKotlin 库，它使一些
    RxJava API 在 Kotlin 中更加符合语言习惯。
- en: 5.5.3 Edge service with coroutines
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.3 使用协程的边缘服务
- en: Let’s look at an implementation of the edge service using Kotlin coroutines.
    The preamble is given in the following listing.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 Kotlin 协程实现的边缘服务的一个示例。前言如下所示。
- en: Listing 5.35 Coroutine collector service preamble
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.35 协程收集服务前言
- en: '[PRE42]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ lateinit indicates that the field will not be initialized in a constructor.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `lateinit` 表示该字段将在构造函数中不会被初始化。
- en: ❷ This awaits for the HTTP server to be started; otherwise it throws an exception
    with the error.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这等待 HTTP 服务器启动；否则它将抛出一个包含错误的异常。
- en: Compared to the other implementations, there is not much difference except that
    the `start` method is suspending, and the HTTP server is started using `listenAwait`.
    Since that method call is suspending, the execution resumes when the HTTP server
    is running, and the method returns the HTTP server instance, which we simply ignore
    here.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他实现相比，没有太大的区别，除了`start`方法是挂起的，HTTP服务器使用`listenAwait`启动。由于该方法调用是挂起的，执行将在HTTP服务器运行时恢复，该方法返回HTTP服务器实例，我们在这里简单地忽略它。
- en: The next listing shows the code for the `fetchTemperature` and `sendToSnapshot`
    methods adapted to coroutines.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了`fetchTemperature`和`sendToSnapshot`方法针对协程的代码。
- en: Listing 5.36 HTTP requests and coroutines
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.36 HTTP请求和协程
- en: '[PRE43]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ “as” is a keyword in Kotlin, so it has to be escaped when used as a method
    name.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ “as”是Kotlin中的一个关键字，所以当用作方法名时必须转义。
- en: Both methods now look like more classical imperative code. `fetchTemperature`
    returns a value (a JSON object), albeit asynchronously because the execution in
    the method is suspended when calling `sendAwait`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法现在看起来更像传统的命令式代码。`fetchTemperature`返回一个值（一个JSON对象），尽管它是异步的，因为在调用`sendAwait`时方法中的执行被挂起。
- en: The illusion of “asynchronous operations that do not look like asynchronous
    operations” is even more apparent in the following listing, which contains the
    core logic of the edge service.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，异步操作看起来并不像异步操作，这种错觉更加明显，它包含了边缘服务的核心逻辑。
- en: Listing 5.37 Coroutines collector HTTP handler
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.37 协程收集器HTTP处理器
- en: '[PRE44]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Fetching each temperature is asynchronous.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取每个温度是异步的。
- en: ❷ Waiting for all values
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 等待所有值
- en: ❸ Vert.x has a small Kotlin DSL to ease JSON object creation.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Vert.x有一个小的Kotlin DSL来简化JSON对象的创建。
- en: ❹ Error management with a classic try/catch structure
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用经典try/catch结构进行错误管理
- en: This code expresses very naturally that temperatures are fetched asynchronously,
    their values are collected in a JSON object, the snapshot service is called, and
    the result is eventually sent to the requester. Still, there are many suspension
    points with asynchronous operations. Also, the error management is a familiar
    `try/catch` structure.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常自然地表达了温度是异步获取的，它们的值被收集在一个JSON对象中，调用快照服务，最终结果被发送给请求者。尽管如此，异步操作中仍有许多暂停点。此外，错误管理是一个熟悉的`try/catch`结构。
- en: You may have noticed the `launch` function call that wraps the whole method
    code. This is because while the `start` method is suspending, the HTTP request
    handler is not a suspending function type, and it will be called outside of a
    Kotlin coroutine context. Calling `launch` ensures a coroutine context is created,
    so suspending methods can be called. Also, the coroutine is automatically attached
    to a context that ensures events run on the verticle event-loop thread (thanks
    to the internals of `CoroutineVerticle`).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了包裹整个方法代码的`launch`函数调用。这是因为虽然`start`方法是挂起的，但HTTP请求处理器不是挂起函数类型，它将在Kotlin协程上下文之外被调用。调用`launch`确保创建了一个协程上下文，因此可以调用挂起方法。此外，协程自动附加到一个上下文中，确保事件在verticle事件循环线程上运行（归功于`CoroutineVerticle`的内部机制）。
- en: Note Coroutines are not magic, and their implementation requires special compiler
    and runtime library support. A suspending function is split into many functions
    by the Kotlin compiler. The split points are the suspending function calls where
    the rest of the function ends up in another function (called a “continuation”).
    There is then a finite state machine that determines what split function to call
    when the suspended function resumes. The design proposal for Kotlin coroutines
    is on GitHub at [http://mng.bz/Qxvj](http://mng.bz/Qxvj).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 注意协程并非魔法，它们的实现需要特殊的编译器和运行时库支持。Kotlin编译器将挂起函数分割成许多函数。分割点是挂起函数调用，其余的函数最终结束在另一个函数（称为“延续”）中。然后有一个有限状态机，它确定挂起函数恢复时调用哪个分割函数。Kotlin协程的设计提案在GitHub上[http://mng.bz/Qxvj](http://mng.bz/Qxvj)。
- en: 5.6 Which model should I use?
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 我应该使用哪种模型？
- en: We just covered three different asynchronous programming models that are generally
    better than callbacks. There is no definite answer to which model you should be
    using to write Vert.x applications. Opting for one model or the other depends
    essentially on what you are trying to achieve.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍了三种不同的异步编程模型，这些模型通常比回调更好。对于编写Vert.x应用程序应该使用哪种模型，并没有明确的答案。选择哪种模型基本上取决于你试图实现什么。
- en: 'This is the great thing about Vert.x: you can write a verticle with RxJava
    because it makes the code straightforward for the functional requirements of that
    verticle, and you can use Kotlin coroutines for another verticle. You can mix
    and match models within the same application.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Vert.x的伟大之处：你可以用RxJava编写一个verticle，因为它使该verticle的函数式需求代码更简单，你可以为另一个verticle使用Kotlin协程。你可以在同一应用程序中混合和匹配模型。
- en: 'Futures and promises are a simple and effective model for composing asynchronous
    operations. They are built into the Vert.x core APIs starting from version 4,
    and they offer the essential tools for dealing with asynchronous results: transforming
    values (`map`), recovering from errors (`recover`/`otherwise`), chaining (`flatMap`),
    and composition (`CompositeFuture`). They also provide interoperability with `CompletionStage`
    from the JDK.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 未来和承诺是组合异步操作的一种简单而有效的模型。它们从版本4开始内置到Vert.x核心API中，并提供处理异步结果的必要工具：转换值（`map`）、从错误中恢复（`recover`/`otherwise`）、链式（`flatMap`）和组合（`CompositeFuture`）。它们还提供了与JDK中的`CompletionStage`的互操作性。
- en: RxJava allows you to reason about *streams* of events in a *functional* and
    *declarative* fashion. It is especially very powerful in terms of error management
    and recovery. There are operators for retrying failed operations, handling timeouts,
    and switching the processing to another value or pipeline in case of errors. There
    is, however, an inherent risk of “monad hell” when building a long chain of (sometimes
    nested) operators, and the code becomes harder to read. Splitting processing into
    multiple methods is a good strategy. Operators like `zip`, `flatMap`, and `concatMap`
    are not necessarily meaningful if you are not very familiar with functional programming
    idioms. Also, not all processing is easy to express as pipelines, especially when
    conditional branching is involved.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava允许你以函数式和声明式的方式对事件流进行推理。它在错误管理和恢复方面特别强大。有操作符用于重试失败的操作、处理超时以及在出错的情况下将处理切换到另一个值或管道。然而，在构建长链（有时是嵌套的）操作符时，存在“单子地狱”的固有风险，这使得代码更难以阅读。将处理拆分为多个方法是好策略。如果你不熟悉函数式编程惯例，像`zip`、`flatMap`和`concatMap`这样的操作符可能并不一定有意义。此外，并非所有处理都容易表示为管道，尤其是在涉及条件分支的情况下。
- en: Kotlin coroutines have the advantage of producing code that doesn’t look like
    asynchronous code. Simple error management cases can be expressed with familiar
    `try/catch` blocks. Although it wasn’t mentioned here, Kotlin coroutines support
    channels and selectors in the style of the Go programming language, which allows
    message-passing between coroutines. That being said, more sophisticated error
    management, such as retries, needs to be expressed manually. Last but not least,
    it remains important to be aware of how coroutines and asynchronous programming
    work.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin协程的优势在于生成的代码看起来不像异步代码。简单的错误管理案例可以用熟悉的`try/catch`块来表示。尽管这里没有提到，但Kotlin协程支持类似于Go编程语言的通道和选择器，这允许协程之间的消息传递。然而，更复杂的错误管理，如重试，需要手动表示。最后但同样重要的是，了解协程和异步编程的工作方式仍然很重要。
- en: Again, there is no definite answer, as all models have their pros and cons,
    but with your own experience and preferences you will likely recognize which model
    you should use for a given situation. In the remainder of this book, we will use
    different models depending on the examples that we write, but this does not mean
    that you cannot rewrite them with a model that you prefer.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，没有明确的答案，因为所有模型都有其优缺点，但凭借你自己的经验和偏好，你可能会认识到在特定情况下应该使用哪种模型。在本书的剩余部分，我们将根据所编写的示例使用不同的模型，但这并不意味着你不能用你偏好的模型重写它们。
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Callbacks have expressiveness limitations when it comes to composing asynchronous
    operations, and they can render code harder to comprehend without proper care.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当涉及到组合异步操作时，回调存在表达力的限制，并且如果不加以适当注意，它们可能会使代码更难以理解。
- en: 'Parallel and sequential asynchronous operations can be composed with other
    asynchronous programming models: futures and promises, reactive extensions, and
    coroutines.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行和顺序异步操作可以使用其他异步编程模型进行组合：未来和承诺、响应式扩展和协程。
- en: Reactive extensions have a rich set of composable operators, and they are especially
    well suited for event streams.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式扩展有一套丰富的可组合操作符，并且它们特别适合于事件流。
- en: Futures and promises are great for simple chaining of asynchronous operations.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来和承诺非常适合简单链式异步操作。
- en: Kotlin coroutines provide language-level support for asynchronous operations,
    which is another interesting option.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 协程提供了对异步操作的语言级别支持，这是另一个有趣的选择。
- en: There is no universally good asynchronous programming model as they all have
    their preferred use cases. The good thing about Vert.x is that you can mix and
    match these models according to your problem domains.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有普遍适用的异步编程模型，因为它们各自都有它们偏好的用例。Vert.x 的好处是你可以根据你的问题域混合和匹配这些模型。
- en: '* * *'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '1.B. Liskov and L. Shrira, “Promises: linguistic support for efficient asynchronous
    procedure calls in distributed systems,” in R.L. Wexelblat, ed., Proceedings of
    the ACM SIGPLAN 1988 conference on Programming language design and implementation
    (PLDI’88), p. 260-267 (ACM, 1988).'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 1.B. Liskov 和 L. Shrira, “承诺：在分布式系统中对高效异步过程调用的语言支持,” 在 R.L. Wexelblat 编，ACM
    SIGPLAN 1988 年程序设计语言设计和实现会议（PLDI’88）论文集，第 260-267 页 (ACM, 1988).
- en: '2.Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, Design Patterns:
    Elements of Reusable Object-Oriented Software (Addison-Wesley Professional, 1995).'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 2.Erich Gamma, Richard Helm, Ralph Johnson, 和 John Vlissides, 设计模式：可重用面向对象软件的元素
    (Addison-Wesley Professional, 1995).
- en: 3.Erik Meijer, “Your Mouse is a Database,” Queue 10, 3 (March 2012), [http://mng.bz/v96M](http://mng.bz/v96M).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 3.Erik Meijer, “你的鼠标是一个数据库,” Queue 10, 3 (三月 2012), [http://mng.bz/v96M](http://mng.bz/v96M).
- en: 4.Melvin E. Conway, “Design of a separable transition-diagram compiler,” Communications
    of the ACM 6, 7 (July 1963), 396-408, [http://mng.bz/4B4V](http://mng.bz/4B4V).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 4.Melvin E. Conway, “可分离转换图编译器的设计,” Communications of the ACM 6, 7 (七月 1963),
    396-408, [http://mng.bz/4B4V](http://mng.bz/4B4V).
