- en: 7 Running multi-container apps with Docker Compose
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 使用 Docker Compose 运行多容器应用程序
- en: Most applications don’t run in one single component. Even large old apps are
    typically built as frontend and backend components, which are separate logical
    layers running in physically distributed components. Docker is ideally suited
    to running distributed applications--from n-tier monoliths to modern microservices.
    Each component runs in its own lightweight container, and Docker plugs them together
    using standard network protocols. You define and manage multi-container apps like
    this using Docker Compose.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序不是在一个单一组件中运行的。即使是大型老式应用程序，通常也是作为前端和后端组件构建的，这些组件是物理上分布在不同组件中的独立逻辑层。Docker
    极其适合运行分布式应用程序--从多层单体到现代微服务。每个组件都在自己的轻量级容器中运行，Docker 使用标准网络协议将它们连接起来。你可以使用 Docker
    Compose 以这种方式定义和管理多容器应用程序。
- en: Compose is a file format for describing distributed Docker apps, and it’s a
    tool for managing them. In this chapter we’ll revisit some apps from earlier in
    the book and see how Docker Compose makes it easier to use them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Compose 是一种描述分布式 Docker 应用程序的文件格式，也是管理它们的工具。在本章中，我们将回顾书中早些时候的一些应用程序，并看看 Docker
    Compose 如何使它们的使用更加容易。
- en: 7.1 The anatomy of a Docker Compose file
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 Docker Compose 文件的解剖结构
- en: You’ve worked with lots of Dockerfiles, and you know that the Dockerfile is
    a script for packaging an application. But for distributed apps, the Dockerfile
    is really just for packaging one part of the application. For an app with a frontend
    website, a backend API, and a database, you could have three Dockerfiles--one
    for each component. How would you run that app in containers?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经与许多 Dockerfile 一起工作过，你知道 Dockerfile 是一个打包应用程序的脚本。但对于分布式应用程序，Dockerfile 实际上只是用于打包应用程序的一部分。对于一个具有前端网站、后端
    API 和数据库的应用程序，你可能需要三个 Dockerfile--每个组件一个。你将如何在这个容器中运行该应用程序？
- en: You could use the Docker CLI to start each container in turn, specifying all
    the options for the app to run correctly. That’s a manual process that is likely
    to become a point of failure, because if you get any of the options wrong, the
    applications might not work correctly, or the containers might not be able to
    communicate. Instead you can describe the application’s structure with a Docker
    Compose file.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Docker CLI 逐个启动每个容器，指定应用程序运行所需的全部选项。这是一个手动过程，可能会成为故障点，因为如果你有任何选项错误，应用程序可能无法正确运行，或者容器可能无法相互通信。相反，你可以使用
    Docker Compose 文件描述应用程序的结构。
- en: The Docker Compose file describes the desired state of your app--what it should
    look like when everything’s running. It’s a simple file format where you place
    all the options you would put in your `docker` `container` `run` commands into
    the Compose file. Then you use the Docker Compose tool to run the app. It works
    out what Docker resources it needs, which could be containers, networks, or volumes--and
    it sends requests to the Docker API to create them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 文件描述了应用程序的期望状态--当一切运行时它应该看起来是什么样子。这是一个简单的文件格式，其中你将所有会放在 `docker`
    `container` `run` 命令中的选项放入 Compose 文件中。然后你使用 Docker Compose 工具运行应用程序。它会计算出 Docker
    需要的资源，这些资源可能是容器、网络或卷--然后向 Docker API 发送请求以创建它们。
- en: Listing 7.1 shows a full Docker Compose file--you’ll find this in the `exercises`
    folder for this chapter in the book’s source code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 展示了一个完整的 Docker Compose 文件--你可以在书籍源代码的“`exercises`”文件夹中找到这个文件。
- en: Listing 7.1 A Docker Compose file to run the to-do app from chapter 6
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 运行第 6 章待办事项应用程序的 Docker Compose 文件
- en: '` version: ''3.7''` ` services:`     `   todo-web:` `       image: diamol/ch06-todo-list`
    `       ports:` `           - "8020:80"` `       networks:` `           - app-net` 
    ` networks:` `   app-net:` `       external:` `             name: nat`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '` version: ''3.7''` ` services:` `   todo-web:` `       image: diamol/ch06-todo-list`
    `       ports:` `           - "8020:80"` `       networks:` `           - app-net`
    ` networks:` `   app-net:` `       external:` `             name: nat`'
- en: This file describes a simple application with one Docker container plugging
    into one Docker network. Docker Compose uses YAML, which is a human-readable text
    format that’s widely used because it translates easily to JSON (which is the standard
    language for APIs). Spaces are important in YAML--indentation is used to identify
    objects and the child properties of objects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件描述了一个简单的应用程序，其中一个 Docker 容器连接到一个 Docker 网络。Docker Compose 使用 YAML，这是一种人类可读的文本格式，因其易于转换为
    JSON（这是 API 的标准语言）而广泛使用。在 YAML 中，空格很重要--缩进用于标识对象及其对象的子属性。
- en: 'In this example there are three top-level statements:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有三个顶级语句：
- en: '`version` is the version of the Docker Compose format used in this file. The
    feature set has evolved over many releases, so the version here identifies which
    releases this definition works with.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`是此文件中使用的Docker Compose格式的版本。功能集在许多版本中已经演变，因此这里的版本标识了哪些版本与此定义兼容。'
- en: '`services` lists all the components that make up the application. Docker Compose
    uses the idea of services instead of actual containers, because a service could
    be run at scale with several containers from the same image.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`services`列出了构成应用程序的所有组件。Docker Compose使用服务而非实际容器的概念，因为一个服务可以以多个容器从同一镜像的规模运行。'
- en: '`networks` lists all the Docker networks that the service containers can plug
    into.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`networks`列出了服务容器可以连接的所有Docker网络。'
- en: You could run this app with Compose, and it would start a single container to
    get to the desired state. Figure 7.1 shows the architecture diagram of the app’s
    resources.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Compose运行此应用程序，并且它将启动单个容器以到达所需状态。图7.1显示了应用程序资源的架构图。
- en: There are a couple of things to look at more closely before we actually run
    this app. The service called `todo-web` will run a single container from the `diamol/ch06-todo-list`
    image. It will publish port `8020` on the host to port `80` on the container,
    and it will connect the container to a Docker network referred to as `app-net`
    inside the Compose file. The end result will be the same as running `docker` `container`
    `run` `-p` `8020:80` `--name` `todo-web` `--network` `nat` `diamol/ch06-todo-list`
    .
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际运行此应用程序之前，有几件事情需要更仔细地查看。名为`todo-web`的服务将从一个名为`diamol/ch06-todo-list`的镜像运行单个容器。它将在主机上发布端口`8020`到容器的端口`80`，并且它将连接容器到在Compose文件中称为`app-net`的Docker网络。最终结果将与运行`docker`
    `container` `run` `-p` `8020:80` `--name` `todo-web` `--network` `nat` `diamol/ch06-todo-list`相同。
- en: '![](../Images/7-1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-1.jpg)'
- en: Figure 7.1 The architecture of a simple Compose file with one service and one
    network
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 简单Compose文件的一个服务和网络架构
- en: 'Under the service name are the properties, which are a fairly close map to
    the options in the `docker` `container` `run` command: `image` is the image to
    run, `ports` are the ports to publish, and `networks` are the networks to connect
    to. The service name becomes the container name and the DNS name of the container,
    which other containers can use to connect on the Docker network. The network name
    in the service is `app-net` , but under the networks section that network is specified
    as mapping to an external network called `nat` . The `external` option means Compose
    expects the `nat` network to already exist, and it won’t try to create it.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务名称下方是属性，这些属性与`docker` `container` `run`命令中的选项相当接近：`image`是要运行的镜像，`ports`是要发布的端口，而`networks`是要连接的网络。服务名称成为容器名称和容器的DNS名称，其他容器可以使用它来在Docker网络上进行连接。服务中的网络名称是`app-net`，但在网络部分，该网络被指定为映射到名为`nat`的外部网络。`external`选项意味着Compose期望`nat`网络已经存在，并且它不会尝试创建它。
- en: You manage apps with Docker Compose using the `docker-compose` command line,
    which is separate from the Docker CLI. The `docker-compose` command uses different
    terminology, so you start an app with the `up` command, which tells Docker Compose
    to inspect the Compose file and create anything that’s needed to bring the app
    up to the desired state.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker-compose`命令行来管理应用程序，该命令行与Docker CLI分开。`docker-compose`命令使用不同的术语，因此您使用`up`命令启动应用程序，该命令告诉Docker
    Compose检查Compose文件并创建任何需要的内容以将应用程序带到所需状态。
- en: 'Try it now Open a terminal and create the Docker network. Then browse to the
    folder with the Compose file from listing 7.1, and then run the app using the
    `docker-compose` command line:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 打开终端并创建Docker网络。然后浏览到包含7.1列表中Compose文件的文件夹，然后使用`docker-compose`命令行运行应用程序：
- en: '` docker network create nat`  ` cd ./ch07/exercises/todo-list`  ` docker-compose
    up`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker network create nat`  ` cd ./ch07/exercises/todo-list`  ` docker-compose
    up`'
- en: You don’t always need to create a Docker network for Compose apps, and you may
    already have that `nat` network from running the exercises in chapter 4, in which
    case you’ll get an error that you can ignore. If you use Linux containers, Compose
    can manage networks for you, but if you use Windows containers, you’ll need to
    use the default network called `nat` that Docker creates when you install it on
    Windows. I’m using the `nat` network, so the same Compose file will work for you
    whether you’re running Linux or Windows containers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不总是需要为Compose应用程序创建Docker网络，你可能已经从第4章的练习中运行了`nat`网络，在这种情况下，你会得到一个可以忽略的错误。如果你使用Linux容器，Compose可以为你管理网络，但如果你使用Windows容器，你需要使用Docker在Windows上安装时创建的默认网络`nat`。我正在使用`nat`网络，所以无论你运行Linux容器还是Windows容器，相同的Compose文件都会为你工作。
- en: The Compose command line expects to find a file called `docker-compose.yml`
    in the current directory, so in this case it loads the to-do list application
    definition. You won’t have any containers matching the desired state for the `todo-web`
    service, so Compose will start one container. When Compose runs containers, it
    collects all the application logs and shows them grouped by containers, which
    is very useful for development and testing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Compose命令行期望在当前目录中找到一个名为`docker-compose.yml`的文件，因此在这种情况下，它加载了待办事项列表应用程序定义。对于`todo-web`服务，你不会有任何匹配所需状态的容器，所以Compose将启动一个容器。当Compose运行容器时，它会收集所有应用程序日志并将它们按容器分组显示，这对于开发和测试非常有用。
- en: My output from running the previous command is in figure 7.2--when you run it
    yourself you’ll also see the images being pulled from Docker Hub, but I’d already
    pulled them before running the command.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上一个命令的输出结果在图7.2中——当你自己运行时，你也会看到从Docker Hub拉取的镜像，但我在运行命令之前已经拉取了它们。
- en: '![](../Images/7-2.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-2.jpg)'
- en: Figure 7.2 Starting an app using Docker Compose, which creates Docker resources
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 使用Docker Compose启动应用程序，它创建了Docker资源
- en: 'Now you can browse to http: */ /* localhost:8020 and see the to-do list application.
    It works in exactly the same way as in chapter 6, but Docker Compose gives you
    a much more robust way to start the app. The Docker Compose file will live in
    source control alongside the code for the app and the Dockerfiles, and it becomes
    the single place to describe all the runtime properties of the app. You don’t
    need to document the image name or the published port in a README file, because
    it’s all in the Compose file.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，你可以浏览到http: */ /* localhost:8020来查看待办事项列表应用程序。它的工作方式与第6章完全相同，但Docker Compose为你提供了启动应用程序的更稳健的方式。Docker
    Compose文件将位于源代码控制中，与应用程序代码和Dockerfile一起，并成为描述应用程序所有运行时属性的单一位置。你不需要在README文件中记录镜像名称或发布的端口，因为所有这些都在Compose文件中。'
- en: The Docker Compose format records all the properties you need to configure your
    app, and it can also record other top-level Docker resources like volumes and
    secrets. This app just has a single service, and even in this case it’s good to
    have a Compose file that you can use to run the app and to document its setup.
    But Compose really makes sense when you’re running multi-container apps.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose格式记录了你配置应用程序所需的所有属性，它还可以记录其他顶级Docker资源，如卷和机密。这个应用程序只有一个服务，即使在这种情况下，也最好有一个可以用来运行应用程序和记录其设置的Compose文件。但当你运行多容器应用程序时，Compose才真正有意义。
- en: 7.2 Running a multi-container application with Compose
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 使用Compose运行多容器应用程序
- en: Back in chapter 4 we built a distributed app that shows an image from NASA’s
    astronomy picture of the day API. There was a Java frontend website, a REST API
    written in Go, and a log collector written in Node.js. We ran the app by starting
    each container in turn, and we had to plug the containers into the same network
    and use the correct container names so the components could find each other. That’s
    exactly the sort of brittle approach that Docker Compose fixes for us.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，我们构建了一个分布式应用程序，该程序展示了来自NASA每日天文图片API的图片。该应用程序包含一个Java前端网站，一个用Go编写的REST
    API，以及一个用Node.js编写的日志收集器。我们通过依次启动每个容器来运行应用程序，并且必须将容器连接到相同的网络并使用正确的容器名称，以便组件能够相互找到。这正是Docker
    Compose为我们解决的问题之一。
- en: In listing 7.2 you can see the `services` section for a Compose file that describes
    the image gallery application. I’ve removed the network configuration to focus
    on the service properties, but the services plug into the `nat` network just like
    in the to-do app example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表7.2中，你可以看到描述图像库应用程序的Compose文件的`services`部分。我已经移除了网络配置，以便专注于服务属性，但服务就像待办事项应用程序示例中一样连接到`nat`网络。
- en: Listing 7.2 The Compose services for the multi-container image gallery app
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 多容器图像画廊应用程序的 Compose 服务
- en: '` accesslog:` `   image: diamol/ch04-access-log` ` iotd:` `   image: diamol/ch04-image-of-the-day`
    `   ports:` `       - "80"`  ` image-gallery:` `   image: diamol/ch04-image-gallery`
    `   ports:` `       - "8010:80"`  `   depends_on:` `       - accesslog` `         -
    iotd`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '` accesslog:` `   image: diamol/ch04-access-log` ` iotd:` `   image: diamol/ch04-image-of-the-day`
    `   ports:` `       - "80"`  ` image-gallery:` `   image: diamol/ch04-image-gallery`
    `   ports:` `       - "8010:80"` `   depends_on:` `       - accesslog` `         -
    iotd`'
- en: 'This is a good example of how to configure different types of services. The
    `accesslog` service doesn’t publish any ports or use any other properties you
    would capture from the `docker` `container` `run` command, so the only value recorded
    is the image name. The `iotd` service is the REST API--the Compose file records
    the image name and also publishes port `80` on the container to a random port
    on the host. The `image-gallery` service has the image name and a specific published
    port: `8010` on the host maps to port `80` in the container. It also has a `depends_on`
    section saying this service has a dependency on the other two services, so Compose
    should make sure those are running before it starts this one.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个配置不同类型服务的良好示例。`accesslog` 服务不发布任何端口或使用任何其他从 `docker` `container` `run` 命令捕获的属性，因此唯一记录的值是镜像名称。`iotd`
    服务是 REST API--Compose 文件记录了镜像名称，并在容器上发布了端口 `80` 到主机的随机端口。`image-gallery` 服务具有镜像名称和特定的发布端口：主机上的
    `8010` 端口映射到容器中的端口 `80`。它还有一个 `depends_on` 部分，说明此服务依赖于其他两个服务，因此 Compose 应该确保在启动此服务之前那些服务正在运行。
- en: '![](../Images/7-3.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-3.jpg)'
- en: Figure 7.3 A more complex Compose file that specifies three services connected
    to the same network
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 一个更复杂的 Compose 文件，指定了连接到同一网络的三种服务
- en: Figure 7.3 shows the architecture of this app. I’ve generated the diagrams in
    this chapter from a tool that reads the Compose file and generates a PNG image
    of the architecture. That’s a great way to keep your documentation up to date--you
    can generate the diagram from the Compose file every time there’s a change. The
    diagram tool runs in a Docker container of course--you can find it on GitHub at
    *[https:// github.com/pmsipilot/docker-compose-viz](https://github.com/pmsipilot/docker-compose-viz)*
    .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 展示了此应用程序的架构。我使用一个读取 Compose 文件并生成架构 PNG 图像的工具生成了本章中的图表。这是一个保持文档更新的好方法--每次有更改时，您都可以从
    Compose 文件生成图表。该图表工具当然运行在 Docker 容器中--您可以在 GitHub 上找到它，网址为 *[https://github.com/pmsipilot/docker-compose-viz](https://github.com/pmsipilot/docker-compose-viz)*
    。
- en: We’ll use Docker Compose to run the app, but this time we’ll run in detached
    mode. Compose will still collect the logs for us, but the containers will be running
    in the background so we’ll have our terminal session back, and we can use some
    more features of Compose.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Docker Compose 来运行应用程序，但这次我们将以分离模式运行。Compose 仍然会为我们收集日志，但容器将在后台运行，这样我们就可以恢复终端会话，并使用
    Compose 的更多功能。
- en: 'Try it now Open a terminal session to the root of your DIAMOL source code,
    and then navigate to the image gallery folder and run the app:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 打开终端会话到您的 DIAMOL 源代码根目录，然后导航到图像画廊文件夹并运行应用程序：
- en: '` cd ./ch07/exercises/image-of-the-day` ` docker-compose up --detach`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ./ch07/exercises/image-of-the-day` ` docker-compose up --detach`'
- en: Your output will be like mine in figure 7.4\. You can see that the `accesslog`
    and `iotd` services are started before the `image-gallery` service, because of
    the dependencies recorded in the Compose file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出将像我图 7.4 中的那样。您可以看到，由于 Compose 文件中记录的依赖关系，`accesslog` 和 `iotd` 服务在 `image-gallery`
    服务之前启动。
- en: '![](../Images/7-4.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-4.jpg)'
- en: Figure 7.4 Starting a multi-container app with dependencies specified using
    Docker Compose
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 使用 Docker Compose 指定依赖关系启动多容器应用程序
- en: 'When the app is running, you can browse to http: */ /* localhost:8010\. It
    works just like it did in chapter 4, but now you have a clear definition in the
    Docker Compose file of how the containers need to be configured for them to work
    together. You can also manage the application as a whole using the Compose file.
    The API service is effectively stateless, so you can scale it up to run on multiple
    containers. When the web container requests data from the API, Docker will share
    those requests across the running API containers.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '当应用程序运行时，你可以浏览到 http: */ /* localhost:8010\. 它与第4章中的操作一样，但现在你在Docker Compose文件中有明确的定义，说明容器需要如何配置才能一起工作。你还可以使用Compose文件来管理整个应用程序。API服务实际上是无状态的，因此你可以将其扩展到在多个容器上运行。当Web容器从API请求数据时，Docker会将这些请求共享到正在运行的API容器中。'
- en: 'Try it now In the same terminal session, use Docker Compose to increase the
    scale of the *iotd* service, and then refresh the web page a few times and check
    the logs of the *iotd* containers:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 在相同的终端会话中，使用Docker Compose增加*iotd*服务的扩展规模，然后刷新网页几次并检查*iotd*容器的日志：
- en: '` docker-compose up -d --scale iotd=3`  ` # browse to http://localhost:8010
    and refresh`  ` docker-compose logs --tail=1 iotd`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker-compose up -d --scale iotd=3`  ` # 浏览到 http://localhost:8010 并刷新` 
    ` docker-compose logs --tail=1 iotd`'
- en: You’ll see in the output that Compose creates two new containers to run the
    image API service, so it now has a scale of three. When you refresh the web page
    showing the photograph, the web app requests data from the API, and that request
    could be handled by any of the API containers. The API writes a log entry when
    it handles requests, which you can see in the container logs. Docker Compose can
    show you all log entries for all containers, or you can use it to filter the output--the
    `--tail=1` parameter just fetches the last log entry from each of the `iotd` service
    containers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在输出中看到Compose创建了两个新的容器来运行图像API服务，因此现在它的扩展规模为三。当你刷新显示照片的网页时，Web应用程序会从API请求数据，这个请求可以由任何API容器处理。API在处理请求时写入日志条目，你可以在容器日志中看到。Docker
    Compose可以显示所有容器的所有日志条目，或者你可以使用它来过滤输出--`--tail=1`参数仅从每个`iotd`服务容器中获取最后一个日志条目。
- en: My output is in figure 7.5--you can see that containers 1 and 3 have been used
    by the web app, but container 2 hasn’t handled any requests so far.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出在图7.5中--你可以看到容器1和3已被Web应用程序使用，但容器2迄今为止还没有处理任何请求。
- en: '![](../Images/7-5.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-5.jpg)'
- en: Figure 7.5 Scaling up an application component and checking its logs with Docker
    Compose
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 使用Docker Compose扩展应用程序组件并检查其日志
- en: Docker Compose is now managing five containers for me. I can control the whole
    app using Compose; I can stop all the containers to save compute resources, and
    start them all again when I need the app running. But these are normal Docker
    containers that I can also work with using the Docker CLI. Compose is a separate
    command-line tool for managing containers, but it uses the Docker API in the same
    way that the Docker CLI does. You can use Compose to manage your app, but still
    use the standard Docker CLI to work with containers that Compose created.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose现在正在为我管理五个容器。我可以使用Compose控制整个应用程序；我可以停止所有容器以节省计算资源，当我需要应用程序运行时再次启动它们。但这些都是我可以使用Docker
    CLI进行操作的普通Docker容器。Compose是一个用于管理容器的独立命令行工具，但它以与Docker CLI相同的方式使用Docker API。你可以使用Compose来管理你的应用程序，但仍然可以使用标准的Docker
    CLI来与Compose创建的容器进行交互。
- en: 'Try it now In the same terminal session, stop and start the app with Docker
    Compose commands, and then list all running containers with the Docker CLI:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 在相同的终端会话中，使用Docker Compose命令停止和启动应用程序，然后使用Docker CLI列出所有正在运行的容器：
- en: '` docker-compose stop`  ` docker-compose start`  ` docker container ls`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker-compose stop`  ` docker-compose start`  ` docker container ls`'
- en: Your output will be like mine in figure 7.6\. You’ll see that Compose lists
    individual containers when it stops the app, but it only lists the services when
    it starts the app again, and the services are started in the correct dependency
    order. In the container list you’ll see that Compose has restarted the existing
    containers, rather than creating new ones. All my containers show they were created
    over 30 minutes ago, but they’ve only been up for a few seconds.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将像我图7.6中的那样。你会看到当停止应用程序时，Compose会列出单个容器，但当它再次启动应用程序时，它只列出服务，并且服务以正确的依赖顺序启动。在容器列表中，你会看到Compose重新启动了现有的容器，而不是创建新的容器。所有我的容器都显示它们是在30分钟前创建的，但它们只运行了几秒钟。
- en: '![](../Images/7-6.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-6.jpg)'
- en: Figure 7.6 Stopping and starting multi-container apps with Docker Compose
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 使用 Docker Compose 停止和启动多容器应用程序
- en: There are many more features to Compose--run `docker-compose` without any options
    to see the full list of commands--but there’s one really important consideration
    you need to take in before you go much further. Docker Compose is a client-side
    tool. It’s a command line that sends instructions to the Docker API based on the
    contents of the Compose file. Docker itself just runs containers; it isn’t aware
    that many containers represent a single application. Only Compose knows that,
    and Compose only knows the structure of your application by looking at the Docker
    Compose YAML file, so you need to have that file available to manage your app.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Compose 有许多其他功能——运行 `docker-compose` 而不带任何选项以查看完整的命令列表——但在你进一步操作之前，有一个非常重要的考虑因素。Docker
    Compose 是一个客户端工具。它是一个命令行，根据 Compose 文件的内容向 Docker API 发送指令。Docker 本身只是运行容器；它没有意识到许多容器代表一个单一的应用程序。只有
    Compose 知道这一点，而 Compose 只是通过查看 Docker Compose YAML 文件来了解你的应用程序结构，因此你需要有这个文件来管理你的应用程序。
- en: It’s possible to get your application out of sync with the Compose file, such
    as when the Compose file changes or you update the running app. That can cause
    unexpected behavior when you return to manage the app with Compose. We’ve already
    done this ourselves--we scaled up the `iotd` service to three containers, but
    that configuration isn’t captured in the Compose file. When you bring the application
    down and then recreate it, Compose will return it to the original scale.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能使你的应用程序与 Compose 文件不同步，例如当 Compose 文件更改或你更新正在运行的应用程序时。当你返回使用 Compose 管理应用程序时，这可能会导致意外的行为。我们已经自己做过这件事了——我们将
    `iotd` 服务扩展到三个容器，但这个配置没有在 Compose 文件中捕获。当你关闭应用程序然后重新创建它时，Compose 会将其恢复到原始的缩放级别。
- en: 'Try it now In the same terminal session--because Compose needs to use the same
    YAML file--use Docker Compose to bring the application down and back up again.
    Then check the scale by listing running containers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下，在同一个终端会话中——因为 Compose 需要使用相同的 YAML 文件——使用 Docker Compose 将应用程序关闭并重新启动。然后通过列出运行中的容器来检查缩放情况：
- en: '`docker-compose down`  `docker-compose up -d`  `docker container ls`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose down`  `docker-compose up -d`  `docker container ls`'
- en: The `down` command removes the application, so Compose stops and removes containers--it
    would also remove networks and volumes if they were recorded in the Compose file
    and not flagged as `external` . Then `up` starts the application, and because
    there are no running containers, Compose creates all the services--but it uses
    the app definition in the Compose file, which doesn’t record scale, so the API
    service starts with one container instead of the three we previously had running.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`down` 命令删除应用程序，因此 Compose 会停止并删除容器——如果它们在 Compose 文件中记录并且未标记为 `external`，它也会删除网络和卷。然后
    `up` 命令启动应用程序，因为没有正在运行的容器，Compose 会创建所有服务——但它使用 Compose 文件中的应用程序定义，该定义没有记录缩放，因此
    API 服务使用一个容器启动，而不是我们之前运行的三个容器。'
- en: You can see that in my output in figure 7.7\. The goal here was to restart the
    app, but we’ve accidentally scaled the API service down as well.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图 7.7 的输出中看到。这里的目的是重新启动应用程序，但我们意外地将 API 服务缩放到了更低的级别。
- en: Docker Compose is simple to use and powerful, but you need to be mindful that
    it’s a client-side tool, so it’s dependent on good management of the app definition
    YAML files. When you deploy an app with Compose, it creates Docker resources,
    but the Docker Engine doesn’t know those resources are related--they’re only an
    application as long as you have the Compose file to manage them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 使用简单且功能强大，但你需要注意它是一个客户端工具，因此它依赖于对应用程序定义 YAML 文件的良好管理。当你使用 Compose
    部署应用程序时，它会创建 Docker 资源，但 Docker 引擎并不知道这些资源是相关的——只有当你有 Compose 文件来管理它们时，它们才是一个应用程序。
- en: 7.3 How Docker plugs containers together
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 Docker 如何连接容器
- en: All the components in a distributed application run in Docker containers with
    Compose, but how do they communicate with each other? You know that a container
    is a virtualized environment with its own network space. Each container has a
    virtual IP address assigned by Docker, and containers plugged into the same Docker
    network can reach each other using their IP addresses. But containers get replaced
    during the application life cycle, and new containers will have new IP addresses,
    so Docker also supports service discovery with DNS.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式应用程序中的所有组件都运行在 Compose 的 Docker 容器中，但它们如何相互通信呢？您知道容器是一个具有自己网络空间的虚拟化环境。每个容器都由
    Docker 分配一个虚拟 IP 地址，连接到同一 Docker 网络的容器可以使用它们的 IP 地址相互通信。但是容器在应用程序生命周期中会被替换，新的容器将拥有新的
    IP 地址，因此 Docker 也支持使用 DNS 进行服务发现。
- en: DNS is the Domain Name System, which links names to IP addresses. It works on
    the public internet and on private networks. When you point your browser to blog.sixeyed.com,
    you’re using a domain name, which gets resolved to an IP address for one of the
    Docker servers I have hosting my blog. Your machine actually fetches content using
    the IP address, but you, as the user, work with the domain name, which is much
    friendlier.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 是域名系统，它将名称链接到 IP 地址。它在公共互联网和私有网络上工作。当您将浏览器指向 blog.sixeyed.com 时，您正在使用域名，该域名解析为托管我的博客的
    Docker 服务器之一的 IP 地址。您的机器实际上使用 IP 地址获取内容，但作为用户，您与域名一起工作，这要友好得多。
- en: Docker has its own DNS service built in. Apps running in containers make domain
    lookups when they try to access other components. The DNS service in Docker performs
    that lookup--if the domain name is actually a container name, Docker returns the
    container’s IP address, and the consumer can work directly across the Docker network.
    If the domain name isn’t a container, Docker passes the request on to the server
    where Docker is running, so it will make a standard DNS lookup to find an IP address
    on your organization’s network or the public internet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 内置了自己的 DNS 服务。运行在容器中的应用程序在尝试访问其他组件时进行域名查找。Docker 中的 DNS 服务执行该查找——如果域名实际上是一个容器名称，Docker
    返回容器的 IP 地址，消费者可以直接在 Docker 网络中工作。如果域名不是容器，Docker 将请求转发到 Docker 运行的服务器，因此它将进行标准的
    DNS 查找以在您的组织网络或公共互联网上找到 IP 地址。
- en: You can see that in action with the `image-gallery` app. The response from Docker’s
    DNS service will contain a single IP address for services running in a single
    container, or multiple IP addresses if the service is running at scale across
    multiple containers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 `image-gallery` 应用程序看到这一过程。Docker 的 DNS 服务响应将包含单个 IP 地址，用于在单个容器中运行的服务，或者如果服务在多个容器中跨规模运行，则包含多个
    IP 地址。
- en: '![](../Images/7-7.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7-7](../Images/7-7.jpg)'
- en: Figure 7.7 Removing and recreating an app resets it to the state in the Docker
    Compose file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 移除和重新创建应用程序将其重置为 Docker Compose 文件中的状态。
- en: 'Try it now In the same terminal session, use Docker Compose to bring the application
    up with the API running at a scale of three. Then connect to a session in the
    web container--choose the Linux or Windows command to run--and perform a DNS lookup:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下。在相同的终端会话中，使用 Docker Compose 以 API 运行三倍的规模启动应用程序。然后连接到 Web 容器中的会话——选择要运行的
    Linux 或 Windows 命令——并执行 DNS 查找：
- en: '` docker-compose up -d --scale iotd=3`  ` # for Linux containers:` ` docker
    container exec -it image-of-the-day_image-gallery_1 sh`  ` # for Windows containers:`
    ` docker container exec -it image-of-the-day_image-gallery_1 cmd`  ` nslookup
    accesslog`  ` exit`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker-compose up -d --scale iotd=3`  ` # 对于 Linux 容器：` ` docker container
    exec -it image-of-the-day_image-gallery_1 sh`  ` # 对于 Windows 容器：` ` docker container
    exec -it image-of-the-day_image-gallery_1 cmd`  ` nslookup accesslog`  ` exit`'
- en: '`nslookup` is a small utility that is part of the base image for the web application--it
    performs a DNS lookup for the name you provide, and it prints out the IP address.
    My output is in figure 7.8--you can see there’s an error message from `nslookup`
    , which you can ignore (that’s to do with the DNS server itself), and then the
    IP address for the container. My `accesslog` container has the IP address `172.24.0.2`
    .'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`nslookup` 是网络应用程序基本镜像的一部分的小工具——它为您提供的名称执行 DNS 查找，并打印出 IP 地址。我的输出在图 7.8 中——您可以看到
    `nslookup` 的错误消息，您可以忽略（这与 DNS 服务器本身有关），然后是容器的 IP 地址。我的 `accesslog` 容器的 IP 地址是
    `172.24.0.2` 。'
- en: '![](../Images/7-8.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7-8](../Images/7-8.jpg)'
- en: Figure 7.8 Scaling a service with Docker Compose and performing DNS lookups
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 使用 Docker Compose 缩放服务并执行 DNS 查找
- en: Containers plugged into the same Docker network will get IP addresses in the
    same network range, and they connect over that network. Using DNS means that when
    your containers get replaced and the IP address changes, your app still works
    because the DNS service in Docker will always return the current container’s IP
    address from the domain lookup.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到同一Docker网络的容器将获得相同网络范围内的IP地址，并且它们通过该网络连接。使用DNS意味着当您的容器被替换且IP地址发生变化时，您的应用程序仍然可以工作，因为Docker中的DNS服务将始终从域名查找中返回当前容器的IP地址。
- en: You can verify that by manually removing the `accesslog` container using the
    Docker CLI, and then bringing the application back up again using Docker Compose.
    Compose will see there’s no `accesslog` container running, so it will start a
    new one. That container may have a new IP address from the Docker network--depending
    on other containers being created--so when you run a domain lookup, you may see
    a different response.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用Docker CLI手动删除`accesslog`容器来验证这一点，然后使用Docker Compose再次启动应用程序。Compose会看到没有正在运行的`accesslog`容器，因此它会启动一个新的容器。该容器可能从Docker网络获得新的IP地址——这取决于正在创建的其他容器——因此当您进行域名查找时，您可能会看到不同的响应。
- en: 'Try it now Still in the same terminal session, use the Docker CLI to remove
    the `accesslog` container, and then use Docker Compose to bring the app back to
    the desired state. Then connect to the web container again, using `sh` in Linux
    or `cmd` in Windows, and run some more DNS lookups:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 仍然在同一个终端会话中，使用Docker CLI删除`accesslog`容器，然后使用Docker Compose将应用程序恢复到所需状态。然后再次连接到Web容器，使用Linux中的`sh`或Windows中的`cmd`，并运行更多的DNS查找：
- en: '` docker container rm -f image-of-the-day_accesslog_1` ` docker-compose up
    -d --scale iotd=3`  ` # for Linux containers:` ` docker container exec -it image-of-the-day_image-gallery_1
    sh`  ` # for Windows containers:` ` docker container exec -it image-of-the-day_image-gallery_1
    cmd`  ` nslookup accesslog`  ` nslookup iotd`  ` exit`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker container rm -f image-of-the-day_accesslog_1` ` docker-compose up
    -d --scale iotd=3`  ` # 对于Linux容器：` ` docker container exec -it image-of-the-day_image-gallery_1
    sh`  ` # 对于Windows容器：` ` docker container exec -it image-of-the-day_image-gallery_1
    cmd`  ` nslookup accesslog`  ` nslookup iotd`  ` exit`'
- en: You can see my output in figure 7.9\. In my case there were no other processes
    creating or removing containers, so the same IP address `172.24.0.2` got used
    for the new `accesslog` container. In the DNS lookup for the `iotd` API, you can
    see that three IP addresses are returned, one for each of the three containers
    in the service.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在图7.9中看到我的输出。在我的情况下，没有其他进程创建或删除容器，因此相同的IP地址`172.24.0.2`被用于新的`accesslog`容器。在`iotd`
    API的DNS查找中，您可以看到返回了三个IP地址，每个服务中的三个容器对应一个。
- en: DNS servers can return multiple IP address for a domain name. Docker Compose
    uses this mechanism for simple load-balancing, returning all the container IP
    addresses for a service. It’s up to the application that makes the DNS lookup
    how it processes multiple responses; some apps take a simplistic approach of using
    the first address in the list. To try to provide load-balancing across all the
    containers, the Docker DNS returns the list in a different order each time. You’ll
    see that if you repeat the `nslookup` call for the `iotd` service--it’s a basic
    way of trying to spread traffic around all the containers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: DNS服务器可以为域名返回多个IP地址。Docker Compose使用此机制进行简单的负载均衡，为服务返回所有容器的IP地址。处理多个响应的方式取决于执行DNS查找的应用程序；一些应用程序采用简单的方法，使用列表中的第一个地址。为了尝试在所有容器之间提供负载均衡，Docker
    DNS每次都会以不同的顺序返回列表。您会看到，如果您重复对`iotd`服务进行`nslookup`调用——这是一个尝试在所有容器之间分配流量的基本方法。
- en: Docker Compose records all the startup options for your containers, and it takes
    care of communication between containers at runtime. You can also use it to set
    up the configuration for your environments.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose记录了您容器的所有启动选项，并在运行时处理容器之间的通信。您还可以使用它来设置环境的配置。
- en: '![](../Images/7-9.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9](../Images/7-9.jpg)'
- en: Figure 7.9 Services scale with multiple containers--every container’s IP address
    is returned in a lookup.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 服务与多个容器一起扩展——查找中返回了每个容器的IP地址。
- en: 7.4 Application configuration in Docker Compose
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 Docker Compose中的应用程序配置
- en: The to-do app from chapter 6 can be used in different ways. You can run it as
    a single container, in which case it stores data in a SQLite database--which is
    just a file inside the container. You saw in chapter 6 how to use volumes to manage
    that database file. SQLite is fine for small projects, but larger apps will use
    a separate database, and the to-do app can be configured to use a remote Postgres
    SQL database instead of local SQLite.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章中的待办事项应用可以以不同的方式使用。您可以将其作为一个单独的容器运行，在这种情况下，它将在 SQLite 数据库中存储数据——这只是一个容器内的文件。您在第
    6 章中看到了如何使用卷来管理该数据库文件。SQLite 适用于小型项目，但大型应用程序将使用单独的数据库，并且待办事项应用可以配置为使用远程 Postgres
    SQL 数据库而不是本地 SQLite。
- en: Postgres is a powerful and popular open source relational database. It works
    nicely in Docker, so you can run a distributed application where the app is running
    in one container and the database is in another container. The Docker image for
    the to-do app has been built in line with the guidance in this book, so it packages
    a default set of configuration for the dev environment, but config settings can
    be applied so they work with other environments. We can apply those config settings
    using Docker Compose.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Postgres 是一个强大且流行的开源关系型数据库。它在 Docker 中运行良好，因此您可以在一个容器中运行应用程序，在另一个容器中运行数据库的分布式应用程序。此待办事项应用的
    Docker 镜像是根据本书中的指南构建的，因此它包含开发环境的默认配置集，但配置设置可以应用，以便与其他环境兼容。我们可以使用 Docker Compose
    应用这些配置设置。
- en: Take a look at the services for the Compose file in listing 7.3--these specify
    a Postgres database service and the to-do application service.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 查看列表 7.3 中的 Compose 文件的服务——这些指定了 Postgres 数据库服务和待办事项应用程序服务。
- en: Listing 7.3 The Compose services for the to-do app with a Postgres database
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 带有 Postgres 数据库的待办事项应用的 Compose 服务
- en: '` services:`      `   todo-db:` `       image: diamol/postgres:11.5` `       ports:`
    `           - "5433:5432"` `       networks:` `           - app-net`  `   todo-web:`
    `       image: diamol/ch06-todo-list` `       ports:` `           - "8020:80"`
    `       environment:` `           - Database:Provider=Postgres` `       depends_on:`
    `           - todo-db` `       networks:` `           - app-net` `       secrets:`
    `           - source: postgres-connection` `                 target: /app/config/secrets.json`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '` services:`    `   todo-db:` `       image: diamol/postgres:11.5` `       ports:`
    `           - "5433:5432"` `       networks:` `           - app-net`  `   todo-web:`
    `       image: diamol/ch06-todo-list` `       ports:` `           - "8020:80"`
    `       environment:` `           - Database:Provider=Postgres` `       depends_on:`
    `           - todo-db` `       networks:` `           - app-net` `       secrets:`
    `           - source: postgres-connection` `                 target: /app/config/secrets.json`'
- en: 'The specification for the database is straightforward--it uses the `diamol/postgres:11.5`
    image, publishes the standard Postgres port `5342` in the container to port `5433`
    on the host, and uses the service name `todo-db` , which will be the DNS name
    for the service. The web application has some new sections to set up configuration:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的规范很简单——它使用 `diamol/postgres:11.5` 镜像，将容器中的标准 Postgres 端口 `5342` 发布到主机上的端口
    `5433`，并使用服务名称 `todo-db`，这将是服务的 DNS 名称。Web 应用程序有一些新的配置部分：
- en: '`environment` sets up environment variables that are created inside the container.
    When this app runs, there will be an environment variable called `Database:Provider`
    set inside the container, with the value `Postgres` .'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment` 设置在容器内创建的环境变量。当此应用运行时，容器内将设置一个名为 `Database:Provider` 的环境变量，其值为
    `Postgres`。'
- en: '`secrets` can be read from the runtime environment and populated as files inside
    the container. This app will have a file at `/app/config/secrets.json` with the
    contents of the secret called `postgres-connection` .'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secrets` 可以从运行时环境读取，并在容器内作为文件填充。此应用将在 `/app/config/secrets.json` 文件中包含名为 `postgres-connection`
    的秘密内容。'
- en: Secrets are usually provided by the container platform in a clustered environment--that
    could be Docker Swarm or Kubernetes. They are stored in the cluster database and
    can be encrypted, so they’re useful for sensitive configuration data like database
    connection strings, certificates, or API keys. On a single machine running Docker,
    there is no cluster database for secrets, so with Docker Compose you can load
    secrets from files. There’s a `secrets` section at the end of this Compose file,
    shown in listing 7.4.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群环境中，秘密通常由容器平台提供——这可能是 Docker Swarm 或 Kubernetes。它们存储在集群数据库中，可以进行加密，因此对于敏感配置数据（如数据库连接字符串、证书或
    API 密钥）非常有用。在运行 Docker 的单台机器上，没有集群数据库用于秘密，因此使用 Docker Compose 可以从文件中加载秘密。此 Compose
    文件的末尾有一个 `secrets` 部分，如列表 7.4 所示。
- en: Listing 7.4 Loading secrets from local files in Docker Compose
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4 在Docker Compose中从本地文件加载秘密
- en: '` secrets:` `   postgres-connection:` `         file: ./config/secrets.json`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '` secrets:` `   postgres-connection:` `         file: ./config/secrets.json`'
- en: This tells Docker Compose to load the secret called `postgres-connection` from
    the file on the host called `secrets.json` . This scenario is like the bind mounts
    we covered in chapter 6--in reality the file on the host gets surfaced into the
    container. But defining it as a secret gives you the option of migrating to a
    real, encrypted secret in a clustered environment.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Docker Compose从名为`secrets.json`的主机文件中加载名为`postgres-connection`的秘密。这种场景类似于我们在第6章中提到的绑定挂载——实际上，主机上的文件被暴露到容器中。但将其定义为秘密，您可以选择在集群环境中迁移到真正的加密秘密。
- en: Plugging app configuration into the Compose file lets you use the same Docker
    images in different ways and be explicit about the settings for each environment.
    You can have separate Compose files for your development and test environments,
    publishing different ports and triggering different features of the app. This
    Compose file sets up environment variables and secrets to run the to-do app in
    Postgres mode and provide it with the details to connect to the Postgres database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序配置插入到Compose文件中，让您以不同的方式使用相同的Docker镜像，并对每个环境的设置进行明确说明。您可以为开发和测试环境分别创建不同的Compose文件，发布不同的端口并触发应用程序的不同功能。此Compose文件设置环境变量和秘密，以便在Postgres模式下运行待办事项应用程序，并提供连接到Postgres数据库的详细信息。
- en: When you run the app, you’ll see it behaves in the same way, but now the data
    is stored in a Postgres database container that you can manage separately from
    the app.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，您会看到它的行为方式相同，但现在数据存储在可以单独管理（与应用程序分开）的Postgres数据库容器中。
- en: 'Try it now Open a terminal session at the root of the code for the book, and
    switch to the directory for this exercise. In that directory you’ll see the Docker
    Compose file and also the JSON file that contains the secret to load into the
    application container. Start the app using `docker-compose` `up` in the usual
    way:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 打开代码根目录的终端会话，并切换到本练习的目录。在那个目录中，您将看到Docker Compose文件以及包含要加载到应用程序容器中的秘密的JSON文件。使用`docker-compose`
    `up`命令以常规方式启动应用程序：
- en: '` cd ./ch07/exercises/todo-list-postgres`  ` # for Linux containers:` ` docker-compose
    up -d`  ` # OR for Windows containers (which use different file paths):`  ` docker-compose
    -f docker-compose-windows.yml up -d`  ` docker-compose ps`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ./ch07/exercises/todo-list-postgres`  ` # for Linux containers:` ` docker-compose
    up -d`  ` # OR for Windows containers (which use different file paths):`  ` docker-compose
    -f docker-compose-windows.yml up -d`  ` docker-compose ps`'
- en: Figure 7.10 shows my output. There’s nothing new in there except the `docker-compose`
    `ps` command, which lists all running containers that are part of this Compose
    application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10显示了我的输出。那里没有新的内容，除了`docker-compose` `ps`命令，它列出了所有作为此Compose应用程序一部分运行的容器。
- en: '![](../Images/7-10.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-10.jpg)'
- en: Figure 7.10 Running a new application with Docker Compose and listing its containers
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 使用Docker Compose运行新应用程序并列出其容器
- en: 'You can browse to this version of the to-do app at http: */ /* localhost:8030\.
    The functionality is the same, but now the data is being saved in the Postgres
    database container. You can check that with a database client--I use Sqlectron,
    which is a fast, open source, cross-platform UI for connecting to Postgres, MySQL,
    and SQL Server databases. The address of the server is `localhost:5433` , which
    is the port published by the container; the database is called `todo` , the username
    is `postgres` , and there is no password. You can see in figure 7.11 that I’ve
    added some data to the web app, and I can query it in Postgres.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以通过http: */ /* localhost:8030访问此版本的待办事项应用程序。功能相同，但现在数据正在Postgres数据库容器中保存。您可以使用数据库客户端进行检查——我使用Sqlectron，这是一个快速的开源、跨平台UI，用于连接到Postgres、MySQL和SQL
    Server数据库。服务器的地址是`localhost:5433`，这是容器公开的端口；数据库名为`todo`，用户名为`postgres`，没有密码。您可以在图7.11中看到，我已经向Web应用程序添加了一些数据，并且我可以在Postgres中查询它。'
- en: Separating the application package from the runtime configuration is a key benefit
    of Docker. Your application image will be produced by your build pipeline, and
    that same image will progress through the test environments until it is ready
    for production. Each environment will apply its own config settings, using environment
    variables or bind mounts or secrets--that are easy to capture in Docker Compose
    files. In every environment, you’re working with the same Docker images, so you
    can be confident you’re releasing the exact same binaries and dependencies into
    production that have passed the tests in all other environments.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序包与运行时配置分离是Docker的一个关键优势。你的应用程序镜像将由你的构建管道生成，并且相同的镜像将经过测试环境直到它准备好投入生产。每个环境都会应用自己的配置设置，使用环境变量或绑定挂载或机密信息--这些都可以轻松地捕获在Docker
    Compose文件中。在每一个环境中，你都在使用相同的Docker镜像，因此你可以确信你正在将所有其他环境中测试通过的精确二进制文件和依赖项发布到生产环境中。
- en: '![](../Images/7-11.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-11.jpg)'
- en: Figure 7.11 Running the to-do app in containers with a Postgres database and
    querying the data
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 在容器中运行待办事项应用程序，使用Postgres数据库并查询数据
- en: 7.5 Understanding the problem Docker Compose solves
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 理解Docker Compose解决的问题
- en: Docker Compose is a very neat way of describing the setup for complex distributed
    apps in a small, clear file format. The Compose YAML file is effectively a deployment
    guide for your application, but it’s miles ahead of a guide written as a Word
    document. In the old days those Word docs described every step of the application
    release, and they ran to dozens of pages filled with inaccurate descriptions and
    out-of-date information. The Compose file is simple and it’s actionable--you use
    it to run your app, so there’s no risk of it going out of date.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose是一种非常整洁的方式来描述复杂分布式应用程序的设置，使用的是小型、清晰的文件格式。Compose YAML文件实际上是你应用程序的部署指南，但它比用Word文档编写的指南要先进得多。在以前，那些Word文档描述了应用程序发布的每一步，它们有数十页，充满了不准确描述和过时信息。Compose文件简单且可操作--你用它来运行你的应用程序，因此不存在过时的风险。
- en: Compose is a useful part of your toolkit when you start making more use of Docker
    containers. But it’s important to understand exactly what Docker Compose is for,
    and what its limitations are. Compose lets you define your application and apply
    the definition to a single machine running Docker. It compares the live Docker
    resources on that machine with the resources described in the Compose file, and
    it will send requests to the Docker API to replace resources that have been updated
    and create new resources where they are needed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始更多地使用Docker容器时，Compose是你工具箱中的一个有用部分。但了解Docker Compose的确切用途及其局限性非常重要。Compose允许你定义你的应用程序并将定义应用到运行Docker的单台机器上。它会将该机器上实时Docker资源与Compose文件中描述的资源进行比较，并将向Docker
    API发送请求以替换已更新的资源，并在需要的地方创建新资源。
- en: You get the desired state of your application when you run `docker-compose`
    `up` , but that’s where Docker Compose ends. It is not a full container platform
    like Docker Swarm or Kubernetes--it does not continually run to make sure your
    application keeps its desired state. If containers fail or if you remove them
    manually, Docker Compose will not restart or replace them until you explicitly
    run `docker-compose` `up` again. Figure 7.12 gives you a good idea of where Compose
    fits into the application life cycle.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 `docker-compose` `up` 命令时，你将获得应用程序期望的状态，但Docker Compose的任务就到这里结束了。它不是一个像Docker
    Swarm或Kubernetes那样的完整容器平台--它不会持续运行以确保你的应用程序保持期望的状态。如果容器失败或你手动删除它们，Docker Compose将不会重新启动或替换它们，直到你再次明确运行
    `docker-compose` `up` 命令。图7.12展示了Compose在应用程序生命周期中的位置。
- en: '![](../Images/7-12.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-12.jpg)'
- en: Figure 7.12 Where you use Docker Compose in the application life cycle from
    development to production
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 在应用程序生命周期中从开发到生产使用Docker Compose的位置
- en: That’s not to say Docker Compose isn’t suitable for production. If you’re just
    starting with Docker and you’re migrating workloads from individual VMs to containers,
    it might be fine as a starting point. You won’t get high availability, load balancing,
    or failover on that Docker machine, but you didn’t get that on your individual
    app VMs either. You will get a consistent set of artifacts for all your applications--everything
    has Dockerfiles and Docker Compose files--and you’ll get consistent tools to deploy
    and manage your apps. That might be enough to get you started before you look
    into running a container cluster.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说 Docker Compose 不适合生产环境。如果您刚开始使用 Docker，并且正在将工作负载从单个虚拟机迁移到容器，它可能是一个不错的起点。在那个
    Docker 机器上，您不会获得高可用性、负载均衡或故障转移，但您在单个应用程序虚拟机上也没有这些。您将为所有应用程序获得一致的工具集--所有内容都有 Dockerfile
    和 Docker Compose 文件--并且您将获得一致的工具来部署和管理您的应用程序。这可能足以在您考虑运行容器集群之前开始。
- en: 7.6 Lab
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 实验室
- en: 'There are some useful features in Docker Compose that add reliability to running
    your app. In this lab I’d like you to create a Compose definition to run the to-do
    web app more reliably in a test environment:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 中有一些有用的功能，可以为运行您的应用程序提供可靠性。在这个实验中，我希望您创建一个 Compose 定义，以便在测试环境中更可靠地运行待办事项
    Web 应用程序：
- en: The application containers will restart if the machine reboots, or if the Docker
    engine restarts.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器重新启动或 Docker 引擎重新启动，应用程序容器将重新启动。
- en: The database container will use a bind mount to store files, so you can bring
    the app down and up again but retain your data.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库容器将使用绑定挂载来存储文件，因此您可以停用并重新启动应用程序，同时保留您的数据。
- en: The web application should listen on standard port 80 for test.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 应用程序应监听标准端口 80 进行测试。
- en: 'Just one hint for this one:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点，只有一个提示：
- en: You can find the Docker Compose file specification in Docker’s reference documentation
    at *[https://docs.docker.com/compose/compose-file](https://docs.docker.com/compose/compose-file)*
    . That defines all the settings you can capture in Compose.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在 Docker 的参考文档中找到 Docker Compose 文件规范：*[https://docs.docker.com/compose/compose-file](https://docs.docker.com/compose/compose-file)*。它定义了您可以在
    Compose 中捕获的所有设置。
- en: 'My sample solution is on the book’s GitHub repository as always. Hopefully
    this one isn’t too complex, so you won’t need it: *[https://github.com/sixeyed/diamol/blob/
    master/ch07/lab/README.md](https://github.com/sixeyed/diamol/blob/master/ch07/lab/README.md)*
    .'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我的示例解决方案始终在书的 GitHub 仓库中。希望这个示例不会太复杂，这样您就不需要它了：*[https://github.com/sixeyed/diamol/blob/master/ch07/lab/README.md](https://github.com/sixeyed/diamol/blob/master/ch07/lab/README.md)*。
