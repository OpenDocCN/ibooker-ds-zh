- en: 9 Simulating moving objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 模拟移动物体
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Implementing Newton’s laws of motion in code to simulate realistic motion
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中实现牛顿运动定律以模拟真实运动
- en: Calculating velocity and acceleration vectors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算速度和加速度向量
- en: Using Euler’s method to approximate the position of a moving object
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用欧拉方法近似移动物体的位置
- en: Finding the exact trajectory of a moving object with calculus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用微积分找到移动物体的精确轨迹
- en: Our asteroid game from chapter 7 was functional but not that challenging. In
    order to make it more interesting, we need the asteroids to actually move! And,
    to give the player a chance to avoid the moving asteroids, we need to make it
    possible to move and steer the spaceship as well.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第7章中的小行星游戏虽然功能齐全，但挑战性并不强。为了使其更有趣，我们需要让小行星真正地移动！而且，为了让玩家有机会躲避移动的小行星，我们需要让太空船也能移动和转向。
- en: 'To implement motion in the asteroid game, we’ll use many of the same calculus
    concepts from chapter 8\. The numerical quantities we’ll consider are the *x*
    and the *y* positions of the asteroids and of the spaceship. If we want the asteroids
    to move, these values are different at different points in time, so we can consider
    them to be functions of time: *x*(*t*) and *y*(*t*). The derivative of a position
    function with respect to time is called *velocity*, and the derivative of velocity
    with respect to time is called *acceleration*. Because we have two position functions,
    we have two velocity functions and two acceleration functions. This allows us
    to think of velocities and accelerations as vectors, as well.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 asteroid 游戏中实现运动，我们将使用第8章中提到的许多相同的微积分概念。我们将考虑的数值量是小行星和太空船的 *x* 和 *y* 位置。如果我们想让小行星移动，这些值在时间上的不同点会有所不同，因此我们可以将它们视为时间的函数：*x*(*t*)
    和 *y*(*t*)。位置函数对时间的导数称为 *速度*，而速度对时间的导数称为 *加速度*。因为我们有两个位置函数，所以我们有两个速度函数和两个加速度函数。这使我们能够将速度和加速度视为向量。
- en: Our first goal is to get the asteroids moving. For that, we’ll provide random,
    constant velocity functions for the asteroids. Then we’ll integrate these velocity
    functions in “real time” to get the position of each asteroid in each frame using
    an algorithm called *Euler’s method*. Euler’s method is mathematically similar
    to the integration we did in chapter 8, but it has the advantage that we can carry
    it out as the game runs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要目标是让小行星移动。为此，我们将为小行星提供随机的、恒定的速度函数。然后我们将这些速度函数在“实时”中积分，使用称为 *Euler’s method*
    的算法来获取每一帧中每个小行星的位置。欧拉方法在数学上与第8章中我们做的积分相似，但它有一个优点，那就是我们可以在游戏运行时进行。
- en: After that, we can allow the user to control the spaceship. When the user presses
    the up arrow on their keyboard, the spaceship should accelerate in the direction
    it’s pointing. That means the derivative of the derivative of each of *x*(*t*)
    and *y*(*t*) becomes non-zero; the velocity begins to change, and the position
    starts to change as well. Again, we’ll use Euler’s method to integrate the acceleration
    function and the velocity function in real time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以允许用户控制太空船。当用户按下键盘上的上箭头时，太空船应该朝其指向的方向加速。这意味着 *x*(*t*) 和 *y*(*t*) 的二阶导数变为非零；速度开始变化，位置也开始变化。同样，我们将使用欧拉方法实时积分加速度函数和速度函数。
- en: Euler’s method is merely an approximation of the integral, and in this application,
    it’s analogous to the Riemann sums from chapter 8\. It is possible to calculate
    the exact positions of the asteroids and of the spaceship over time, and I conclude
    the chapter with a brief comparison of the Euler’s method results and the exact
    solutions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉方法仅仅是积分的一个近似，在这个应用中，它类似于第8章中的黎曼和。我们可以计算小行星和太空船随时间变化的精确位置，并在本章末尾简要比较欧拉方法的结果和精确解。
- en: 9.1 Simulating a constant velocity motion
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 模拟恒定速度运动
- en: In everyday usage, the word *velocity* is a synonym for the word *speed*. In
    math and physics, velocity has a special meaning; it includes the concepts of
    both speed and direction of motion. Therefore, velocity will be the concept that
    we focus on, and we’ll think of it as a vector.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常用语中，单词 *velocity* 是单词 *speed* 的同义词。在数学和物理学中，速度有特殊的意义；它包括速度和运动方向的概念。因此，速度将是我们要关注的概念，我们将将其视为一个向量。
- en: What we want to do is to give each of the asteroid objects a random velocity
    vector, meaning a pair of numbers (*v[x]*, *v[y]*), and interpret these to be
    the constant values of the derivatives of position with respect to time. That
    is, we assume *x*'(*t*) = *v[x]* and *y*'(*t*) = *v[y]*. With that information
    encoded, we can update the game engine so that the asteroids actually move with
    those velocities as the game progresses.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的是给每个小行星对象提供一个随机的速度向量，即一对数字 (*v[x]*, *v[y]*)，并将这些解释为位置对时间导数的常数值。也就是说，我们假设
    *x*(*t*) = *v[x]* 和 *y*(*t*) = *v[y]*。有了这些信息编码，我们可以更新游戏引擎，使小行星在游戏进行过程中以这些速度移动。
- en: 'Because our game is two-dimensional, we work with pairs of positions and pairs
    of velocities. I switch back and forth from talking about *x*(*t*) and *y*(*t*)
    as a pair of position functions and *x*''(*t*) and *y*''(*t*) as a pair of velocity
    functions, and writing them as *vector-valued* functions: *s*(*t*) = (*x*(*t*),
    *y*(*t*)) and *v*(*t*) = (*x*''(*t*), *y*''(*t*)). This notation just means that
    *s*(*t*) and *v*(*t*) are both functions that take a time value and return a vector,
    representing position and velocity, respectively, at that time.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的游戏是二维的，我们处理位置和速度的对。我交替使用 *x*(*t*) 和 *y*(*t*) 作为一对位置函数以及 *x*'(*t*) 和 *y*'(*t*)
    作为一对速度函数，并将它们写成 *向量值* 函数：*s*(*t*) = (*x*(*t*), *y*(*t*)) 和 *v*(*t*) = (*x*'(*t*),
    *y*'(*t*))。这种表示法只是意味着 *s*(*t*) 和 *v*(*t*) 都是函数，它们接受一个时间值并返回一个向量，分别表示在那个时间点的位置和速度。
- en: The asteroids already have position vectors, indicated by their *x* and *y*
    properties, but we need to give them velocity vectors as well, indicating how
    fast they are moving in the *x* and *y* directions. That’s our first step to get
    them moving frame-by-frame.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 小行星已经具有位置向量，由它们的 *x* 和 *y* 属性表示，但我们需要给它们也提供速度向量，以指示它们在 *x* 和 *y* 方向上的移动速度。这是我们让它们逐帧移动的第一步。
- en: 9.1.1 Adding velocities to the asteroids
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 向小行星添加速度
- en: 'To give each asteroid a velocity vector, we can add the two components of the
    vectors `v x` and `v y` as properties on the `PolygonModel` object (in the chapter
    9 version of `asteroids.py` in the source code):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给每个小行星提供一个速度向量，我们可以在 `PolygonModel` 对象（在源代码中 `asteroids.py` 的第 9 章版本）上添加向量的两个分量作为属性：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ The first four properties are kept from the original implementation of this
    class in chapter 7.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 前四个属性保留自第 7 章中此类的原始实现。
- en: ❷ These vx and vy properties store the current values of *v[x]* = *x*'(*t*)
    and *v[y]* = *y*'(*t*). By default, they are set to 0, meaning the object is not
    moving.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这些 vx 和 vy 属性存储了当前值 *v[x]* = *x*(*t*) 和 *v[y]* = *y*(*t*)。默认情况下，它们被设置为 0，这意味着对象没有移动。
- en: 'Next, to make our asteroids move erratically, we can give them random values
    for the two components of their velocities. This means adding two lines at the
    bottom of the `Asteroid` constructor:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了使我们的小行星移动得更加不规则，我们可以给它们速度的两个分量赋予随机值。这意味着在 `Asteroid` 构造函数的底部添加两行：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Up to this line, the code is unchanged from chapter 7; it initializes the
    asteroid’s shape as a polygon with randomly positioned vertices.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 到这一行，代码与第 7 章没有变化；它初始化小行星的形状为一个具有随机位置顶点的多边形。
- en: ❷ In the last two lines, the *x* and y velocities are set to random values between
    −1 and 1.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在最后两行，*x* 和 *y* 速度被设置为介于 -1 和 1 之间的随机值。
- en: Remember, a negative derivative means that a function is decreasing, while a
    positive value means that a function is increasing. The fact that the *x* and
    *y* velocities could be positive or negative means that the *x* and *y* positions
    could each either be increasing or decreasing. That means our asteroids could
    be moving to the right or left and upward or downward.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，负导数意味着函数正在减少，而正值则意味着函数正在增加。*x* 和 *y* 速度可以是正也可以是负的事实意味着 *x* 和 *y* 位置各自可以是增加或减少。这意味着我们的小行星可以向右或向左以及向上或向下移动。
- en: 9.1.2 Updating the game engine to move the asteroids
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 更新游戏引擎以移动小行星
- en: The next thing we need to do is use the velocity to update the position. Regardless
    of whether we’re talking about the spaceship, the asteroids, or some other `PolygonModel`
    objects, the velocity components *v[x]* and *v[y]* tell us how to update the position
    components *x* and *y*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是使用速度来更新位置。无论我们是在谈论宇宙飞船、小行星还是其他 `PolygonModel` 对象，速度分量 *v[x]* 和 *v[y]*
    告诉我们如何更新位置分量 *x* 和 *y*。
- en: If some time Δ*t* elapses between frames, we update *x* by *v[x]* · Δ*t* and
    *y* by *v[y]* · Δ*t*. (The symbol Δ is the capital Greek letter delta, often used
    to indicate a change in a variable). This is the same approximation we use to
    find a small change in volume from a small change in flow rate in chapter 8\.
    In this case, it is better than an approximation because the velocities are constant,
    the velocity times the elapsed time gives the change in position.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在帧之间经过一段时间 Δ*t*，我们通过 *v[x]* · Δ*t* 更新 *x*，通过 *v[y]* · Δ*t* 更新 *y*。 (符号 Δ 是大写希腊字母
    delta，常用来表示变量的变化)。这是我们在第 8 章中用来从流量的小变化中找到体积小变化的相同近似。在这种情况下，由于速度是恒定的，速度乘以经过的时间给出位置的变化，所以这个近似比其他近似更好。
- en: 'We can add a `move` method to the `PolygonModel` class that updates an object’s
    position based on this formula. The only thing that the object won’t be intrinsically
    aware of is the elapsed time, so we pass that in (in milliseconds):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `PolygonModel` 类中添加一个 `move` 方法，根据这个公式更新对象的位置。唯一对象本身不会内在意识到的是经过的时间，所以我们将其传递进来（以毫秒为单位）：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The change in *x* position is called dx, and the change in y position is called
    dy. Both are calculated by multiplying the asteroid’s velocity by the elapsed
    time in seconds.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ *x* 位置的变化称为 dx，y 位置的变化称为 dy。两者都是通过将陨石的速度乘以经过的秒数来计算的。
- en: ❷ Completes the movement for the frame, updating the positions by adding the
    respective changes dx and dy
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 完成框架的运动，通过添加相应的变化 dx 和 dy 更新位置
- en: This is a first, simple application of the Euler’s method algorithm. The algorithm
    consists of keeping track of the value of one or more functions (in our case,
    the positions *x*(*t*) and *y*(*t*) as well as their derivatives *x*'(*t*) = *v[x]*
    and *y*'(*t*) = *v[y]*) and updating the functions according to their derivatives
    in each step. This works perfectly if the derivatives are constant, but it is
    still a fairly good approximation if the derivatives are themselves changing.
    When we turn our attention to the spaceship, we’ll deal with changing velocity
    values and update our implementation of Euler’s method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 Euler 方法算法的一个简单应用。算法包括跟踪一个或多个函数的值（在我们的情况下，是位置 *x*(*t*) 和 *y*(*t*) 以及它们的导数
    *x*'(*t*) = *v[x]* 和 *y*'(*t*) = *v[y]*)，并在每一步根据它们的导数更新函数。如果导数是恒定的，这会非常完美，但如果导数本身在变化，它仍然是一个相当好的近似。当我们转向宇宙飞船时，我们将处理变化的速率值并更新我们的
    Euler 方法实现。
- en: 9.1.3 Keeping the asteroids on the screen
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 保持陨石在屏幕上
- en: We can add one more small feature to improve the gameplay experience. An asteroid
    with a random velocity is bound to drift off the screen at some point. To keep
    the asteroids within the screen area, we can add some logic to keep both coordinates
    between the minimum and maximum values of −10 and 10\. When, for instance, the
    *x* property increases from 10.0 to 10.1, we subtract 20 so it becomes an acceptable
    value of -9.9\. This has the effect of “teleporting” the asteroid from the right
    side of the screen to the left. This game mechanic has nothing to do with physics,
    but makes the game more interesting by keeping the asteroids in play (figure 9.1).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个额外的功能来提高游戏体验。一个具有随机速度的陨石注定会在某个时刻从屏幕上漂移出去。为了保持陨石在屏幕区域内，我们可以添加一些逻辑来确保两个坐标都在
    -10 和 10 的最小和最大值之间。例如，当 *x* 属性从 10.0 增加到 10.1 时，我们减去 20，使其成为可接受值 -9.9。这会产生将陨石从屏幕的右侧“传送”到左侧的效果。这种游戏机制与物理学无关，但通过保持陨石在游戏中，使游戏更有趣（图
    9.1）。
- en: '![](../Images/CH09_F01_Orland.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F01_Orland.png)'
- en: Figure 9.1 Keeping all objects’ coordinates between −10 and 10 by “teleporting”
    the objects across the screen when they are about to leave it
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 通过在对象即将离开屏幕时将其“传送”到屏幕的另一侧，保持所有对象的坐标在 -10 和 10 之间
- en: 'Here’s the teleportation code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是传送代码：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ If *x* < −10, the asteroid drifts off the left side of the screen, so we add
    20 units to the *x* position to teleport it to the right side of the screen.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果 *x* < −10，陨石会从屏幕的左侧漂移出去，所以我们向 *x* 位置添加 20 个单位，将其传送到屏幕的右侧。
- en: ❷ If y < −10, the asteroid drifts off the bottom of the screen, so we add 20
    units to the y position to teleport it to the top of the screen.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果 y < −10，陨石会从屏幕的底部漂移出去，所以我们向 y 位置添加 20 个单位，将其传送到屏幕的顶部。
- en: 'Finally, we need to call the `move` method for every asteroid in play. To do
    that, we need the following lines within our game loop before the drawing begins:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为每个在游戏中运行的陨石调用 `move` 方法。为了做到这一点，我们需要在绘图开始之前在我们的游戏循环中添加以下几行：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Figures out how many milliseconds have elapsed since the last frame
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算自上一帧以来经过的毫秒数
- en: ❷ Signals all of the asteroids to update their position based on their velocity
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向所有陨石发送信号以根据它们的速度更新它们的位置
- en: It’s unremarkable when printed on this page, but when you run the code yourself,
    you’ll see the asteroids move randomly about the screen, each in a random direction.
    But if you focus on an asteroid, you’ll see that its motion isn’t random; it changes
    position by the same distance in the same direction in each passing second (figure
    9.2).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印在这页上时，这并不引人注目，但当你自己运行代码时，你会看到陨石在屏幕上随机移动，每个陨石都朝一个随机方向移动。但如果你专注于一个陨石，你会看到它的运动并不是随机的；它在每一秒内以相同的距离和方向改变位置（图9.2）。
- en: '![](../Images/CH09_F02_Orland.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F02_Orland.png)'
- en: Figure 9.2 With the preceding code included, each asteroid moves with a random,
    constant velocity.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 包含前面的代码后，每个陨石都以随机恒定的速度移动。
- en: With asteroids that move, the ship is now in danger−it needs to move to avoid
    them. But even moving at a constant velocity won’t save the ship as it will likely
    run into an asteroid at some point. The player needs to change the velocity of
    the ship, meaning both its speed and its direction. Next, we look at how to simulate
    change in velocity, which is known as *acceleration*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有移动的陨石，飞船现在处于危险之中−它需要移动以避开它们。但即使以恒定速度移动，飞船也可能会在某一点撞上陨石。玩家需要改变飞船的速度，这意味着它的速度和方向。接下来，我们将探讨如何模拟速度的变化，这被称为*加速度*。
- en: 9.1.4 Exercises
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.4 练习
- en: '| **Exercise 9.1**: An asteroid has the velocity vector ***v*** = (*v[x]*,
    *v[y]*) = (−3, 1). Which direction is it moving on the screen?'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习9.1**：一颗陨石的速度向量为 ***v*** = (*v[x]*, *v[y]*) = (−3, 1)。它在屏幕上移动的方向是什么？'
- en: Up and to the right
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上并向右
- en: Up and to the left
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上并向左
- en: Down and to the left
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下并向左
- en: Down and to the right
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下并向右
- en: '**Solution**: Because *x*''(*t*) = *v[x]* = −3 at this moment in time, the
    asteroid is moving in the negative *x* direction, or to the left. Because *y*''(*t*)
    = *v[y]* = 1, the asteroid is moving in the positive *y* direction at this moment,
    which is upward. Therefore, answer *b* is correct. |'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**：因为在这个时刻，*x*''(*t*) = *v[x]* = −3，所以陨石正在向负 *x* 方向移动，即向左。因为 *y*''(*t*)
    = *v[y]* = 1，所以陨石在这个时刻正在向正 *y* 方向移动，即向上。因此，答案是 *b*。 |'
- en: 9.2 Simulating acceleration
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 模拟加速度
- en: Let’s imagine our spaceship is equipped with a thruster that burns rocket fuel,
    and the expanding gasses push the spaceship in the direction it’s pointed (figure
    9.3).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们的宇宙飞船装备了一个燃烧火箭燃料的推进器，膨胀的气体将宇宙飞船推向它指向的方向（图9.3）。
- en: '![](../Images/CH09_F03_Orland.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F03_Orland.png)'
- en: Figure 9.3 Schematic of how a rocket propels itself
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 火箭推进自身的示意图
- en: We’ll assume that when the rocket is firing its thruster, it accelerates at
    a constant rate in the direction it’s pointed. Because acceleration is defined
    as the derivative of velocity, constant acceleration values mean that the velocities
    change at a constant rate in both directions with respect to time. When acceleration
    is nonzero, the velocities *v[x]* and *v[y]* are not constant; they are the functions
    *v[x]*(*t*) and *v[y]*(*t*) that change over time. Our assumption that acceleration
    is constant means that there are two numbers, *a[x]* and *a[y]*, so that *v'[x]*(*t*)
    = *a[x]* and *v'[y]*(*t*) = *a[y]*. As a vector, we denote acceleration by *a*
    = (*a[x]*, *a[y]*).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设当火箭点燃其推进器时，它以恒定的速率在其指向的方向上加速。因为加速度被定义为速度的导数，恒定的加速度值意味着速度在时间上以恒定的速率在两个方向上变化。当加速度不为零时，速度
    *v[x]* 和 *v[y]* 不是常数；它们是随时间变化的函数 *v[x]*(*t*) 和 *v[y]*(*t*)。我们假设加速度是恒定的，意味着有两个数字，*a[x]*
    和 *a[y]*，所以 *v'[x]*(*t*) = *a[x]* 和 *v'[y]*(*t*) = *a[y]*。作为一个向量，我们用 *a* = (*a[x]*,
    *a[y]*) 表示加速度。
- en: Our goal is to give the Python spaceship a pair of properties representing (*a[x]*
    and *a[y]*) and to have it accelerate and move across the screen according to
    those values. When the user is not pressing any buttons, the spaceship should
    have zero acceleration in both directions, and when the user presses the up arrow
    key, the acceleration values should instantly be updated so that (*a[x]*, *a[y]*)
    is a non-zero vector pointing in the direction the spaceship is headed. While
    the user holds down the up arrow key, the spaceship’s velocity and position should
    both change realistically, causing it to move frame-by-frame.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是为 Python 飞船提供一对属性，代表 (*a[x]* 和 *a[y]*)，并使其根据这些值加速并在屏幕上移动。当用户没有按下任何按钮时，飞船在两个方向上应该都没有加速度，而当用户按下上箭头键时，加速度值应立即更新，使得
    (*a[x]*, *a[y]*) 是一个非零向量，指向飞船前进的方向。当用户按下上箭头键时，飞船的速度和位置都应该以逼真的方式改变，使其逐帧移动。
- en: 9.2.1 Accelerating the spaceship
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 加速飞船
- en: 'Regardless of the direction the spaceship is pointing, we want it to appear
    to accelerate at the same rate. That means that while the thruster is firing,
    the magnitude of the vector (*a[x]*, *a[y]*) should have a fixed value. By trial
    and error, I discovered that an acceleration magnitude of 3 makes the ship sufficiently
    maneuverable. Let’s include this constant in our game code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 无论飞船指向哪个方向，我们都希望它看起来以相同的速率加速。这意味着当推进器正在发射时，向量 (*a[x]*, *a[y]*) 的大小应该有一个固定的值。通过试错，我发现加速度大小为3可以使飞船足够灵活。让我们将这个常数包含到我们的游戏代码中：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Thinking of the distance units in our game as meters, this represents a value
    of 3 meters per second per second (m/s/s). If the spaceship starts at a standstill
    and the player holds down the up arrow key, the spaceship increases its speed
    by 3 m/s every second in the direction it’s pointing. PyGame works in milliseconds,
    so the relevant speed change will be 0.003 m/s every millisecond, or 0.003 meters
    per second per millisecond.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们游戏中的距离单位视为米，这代表每秒每秒3米（m/s/s）的值。如果飞船从静止开始，并且玩家按下上箭头键，飞船将以每秒3 m/s的速度在其指向的方向上增加速度。PyGame
    以毫秒为单位工作，因此相关的速度变化将是每毫秒0.003 m/s，或者每毫秒每秒0.003米。
- en: Let’s figure out how to calculate the acceleration vector *a* = (*a[x]*, *a[y]*)
    while the up arrow key is pressed. If the ship is pointing at a rotation angle
    θ, then we need to use trigonometry to find the vertical and horizontal components
    of the acceleration from the magnitude |*a*| = 3\. By the definition of sine and
    cosine, the horizontal and vertical components are |*a*| · cos(θ) and |*a*| ·
    sin(θ), respectively (figure 9.4). In other words, the acceleration vector is
    the pair of components ( |*a*| · cos(θ), |*a*| · sin(θ)). Incidentally, you could
    also use the `from_polar` function we wrote in chapter 2 to get these components
    from the magnitude and direction of acceleration.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何在按下上箭头键时计算加速度向量 *a* = (*a[x]*, *a[y]*)。如果飞船指向一个旋转角度 θ，那么我们需要使用三角学来找到加速度的垂直和水平分量，其大小为
    |*a*| = 3。根据正弦和余弦的定义，水平和垂直分量分别是 |*a*| · cos(θ) 和 |*a*| · sin(θ)（见图9.4）。换句话说，加速度向量是分量对
    ( |*a*| · cos(θ), |*a*| · sin(θ))。顺便提一下，你也可以使用我们在第2章中编写的 `from_polar` 函数，从加速度的大小和方向得到这些分量。
- en: '![](../Images/CH09_F04_Orland.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F04_Orland.png)'
- en: Figure 9.4 Using trigonometry to find the components of acceleration from its
    magnitude and direction
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 使用三角学从加速度的大小和方向找到加速度分量
- en: 'During each iteration of the game loop, we can update the velocity of the ship
    before it moves. Over an elapsed time Δ*t*, the update to *v[x]* will be *a[x]*
    · Δ*t* and the update to *v[y]* will be *a[y]* · Δ*t*. In code, we need to add
    the appropriate changes in velocity to the ship’s `vx` and `vy` properties:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏循环的每次迭代中，我们可以在飞船移动之前更新其速度。在经过的时间 Δ*t* 内，*v[x]* 的更新将是 *a[x]* · Δ*t*，而 *v[y]*
    的更新将是 *a[y]* · Δ*t*。在代码中，我们需要将适当的速度变化添加到飞船的 `vx` 和 `vy` 属性中：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Detects whether the up arrow key is pressed
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检测上箭头键是否被按下
- en: ❷ Calculates the values of *a*[x] and *a*[y] based on the fixed magnitude of
    acceleration and the angle the ship is pointing
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 根据加速度的固定大小和飞船指向的角度计算 *a*[x] 和 *a*[y] 的值
- en: ❸ Updates the *x* and y velocities by *a*[x] · Δ*t* and ay · Δ*t*, respectively
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 分别通过 *a*[x] · Δ*t* 和 *a*[y] · Δ*t* 更新 *x* 和 *y* 速度
- en: ❹ Moves the spaceship, using the updated velocities to update positions
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用更新的速度来更新飞船的位置，从而移动飞船
- en: That’s it! With this added code, the spaceship should accelerate when you press
    the up arrow. The code to rotate the spaceship with the left and right arrow keys
    is similar and included in the source code, but I won’t go into it here. With
    the left, right, and up arrow functionality implemented, you can point the ship
    in whatever direction to accelerate when you want to avoid asteroids.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！添加了这段代码后，当按下上箭头键时，宇宙飞船应该会加速。使用左右箭头键旋转宇宙飞船的代码类似，包含在源代码中，但这里不会详细介绍。实现了左右和上箭头的功能后，你可以将飞船指向任何方向，以便在需要避开小行星时加速。
- en: 'This is a slightly more advanced application of Euler’s method where we have
    *second* *derivatives* : *x*''''(*t) = v* ''*x*(*t*) = *ax* and *y*''''(*t* *)
    = v* ''*y*(*t*) = *ay*. At each step, we first update the velocities, then we
    use the updated velocities in the `move` method to determine the updated positions.
    We’re done with our game programming for this chapter, but in the next sections,
    we take a closer look at Euler’s method and evaluate how well it approximates
    motion.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对欧拉方法的一个稍微高级的应用，其中我们有了 *二阶* 导数：*x*''(*t*) = v* '*x*(*t*) = *ax* 和 *y*''(*t*)
    = v* '*y*(*t*) = *ay*。在每一步中，我们首先更新速度，然后使用更新的速度在 `move` 方法中确定更新的位置。我们完成了本章的游戏编程，但在接下来的几节中，我们将更深入地研究欧拉方法并评估它对运动的逼近程度。
- en: 9.3 Digging deeper into Euler’s method
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 深入研究欧拉方法
- en: The core idea of Euler’s method is to start with an initial value of a quantity
    (like position) and an equation describing its derivatives (like velocity and
    acceleration). The derivatives then tell us how to update the quantity. Let’s
    review how we did this by walking through an example, one step at a time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉方法的核心思想是从一个量的初始值（如位置）和一个描述其导数的方程（如速度和加速度）开始。导数然后告诉我们如何更新这个量。让我们通过逐步分析一个例子来回顾我们是如何做到这一点的。
- en: Say an object starts at time *t* = 0 at position (0, 0) with an initial velocity
    (1, 0) and a constant acceleration (0, 0.2). (For notational clarity, I’ll leave
    out units in this section, but you can continue to think in seconds, meters, meters
    per second, and so on.) This initial velocity points in the positive *x* direction,
    and the acceleration points in the positive *y* direction. This means if we look
    at the plane, the object starts by moving directly to the right, but it veers
    upward over time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个物体在时间 *t* = 0 时从位置 (0, 0) 开始，以初始速度 (1, 0) 和恒定加速度 (0, 0.2) 运动。（为了表述清晰，我在本节中省略了单位，但你可以继续以秒、米、米/秒等单位思考。）这个初始速度指向正
    *x* 方向，加速度指向正 *y* 方向。这意味着如果我们观察平面，物体开始时直接向右移动，但随时间向上偏移。
- en: Our task is to find the values of the position vector every two seconds from
    *t* = 0 to *t* = 10 using Euler’s method. First, we’ll do it by hand and then
    we’ll do the identical computation in Python. Equipped with the resulting positions,
    we’ll draw them in the *x*,*y* plane to show the path the spaceship follows.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是使用欧拉方法找到从 *t* = 0 到 *t* = 10 每两秒的位置矢量值。首先，我们将手动完成它，然后我们将在 Python 中进行相同的计算。有了这些结果位置，我们将在
    *x*，*y* 平面上绘制它们，以显示宇宙飞船遵循的路径。
- en: 9.3.1 Carrying out Euler’s method by hand
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 手动执行欧拉方法
- en: 'We will continue to think of position, velocity, and acceleration as functions
    of time: at any given time, the object will have some vector value for each of
    these quantities. I’ll call these vector-valued functions: *s*(*t*) *, v* (*t*)
    and *a*(*t*) where *s*(*t*) = (*x*(*t*), *y*(*t*)), *v*(*t*) = (*x*''(*t*), *y*''(*t*)),
    and *a*(*t*) = (*x*''''(*t*), *y*''''(*t*)). Here are the initial values given
    in a table at time *t* = 0:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续将位置、速度和加速度视为时间的函数：在任何给定的时间，物体将具有这些量的某些矢量值。我将称这些矢量值函数为：*s*(*t*) *, v* (*t*)
    和 *a*(*t*)，其中 *s*(*t*) = (*x*(*t*), *y*(*t*)), *v*(*t*) = (*x*'(*t*), *y*'(*t*)),
    和 *a*(*t*) = (*x*''(*t*), *y*''(*t*)). 这里是时间 *t* = 0 时给出的初始值表：
- en: '![](../Images/CH09_F04_Orland_EQ01.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F04_Orland_EQ01.png)'
- en: 'In our asteroid game, PyGame dictated how many milliseconds elapsed between
    each calculation of position. In this example, to make it quick, let’s reconstruct
    the position from time *t* = 0 to *t* = 10 in 2-second increments. The table we
    need to complete is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的彗星游戏中，PyGame 决定了每次计算位置之间的毫秒数。在这个例子中，为了快速起见，让我们以2秒的增量从时间 *t* = 0 到 *t* =
    10重建位置。我们需要完成的表格如下：
- en: '![](../Images/CH09_F04_Orland_EQ02.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F04_Orland_EQ02.png)'
- en: 'I already filled out the acceleration column for us because we’ve stipulated
    that the acceleration is constant. What happens in the 2-second period between
    *t* = 0 and *t* = 2? The velocities change according to the acceleration as calculated
    in the following pair of equations. In these equations, we again use the Greek
    letter Δ (delta) to mean the change in a variable on the interval we’re considering.
    For instance, Δ*t* is the change in time, so Δ*t* = 2 seconds for each of the
    5 intervals. The velocity components at time 2 are therefore:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为我们填写了加速度列，因为我们已经规定加速度是恒定的。在 *t* = 0 和 *t* = 2 之间的 2 秒期间会发生什么？速度会根据以下一对方程中计算出的加速度发生变化。在这些方程中，我们再次使用希腊字母
    Δ（delta）来表示我们考虑的区间内变量的变化。例如，Δ*t* 是时间的变化，所以 Δ*t* = 2 秒，对于这 5 个区间中的每一个。因此，在 2 秒时的速度分量是：
- en: '![](../Images/CH09_F04_Orland_EQ03.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F04_Orland_EQ03.png)'
- en: 'The new vector value of the velocity at time *t* = 2 is *v*(2) = (*v[x]* (2),
    *v[y]* (2)) = (1, 0.4). The position changes as well, according to the velocity
    *v*(0):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间 *t* = 2 时，速度的新向量值是 *v*(2) = (*v[x]* (2), *v[y]* (2)) = (1, 0.4)。位置也根据速度
    *v*(0) 发生变化：
- en: '![](../Images/CH09_F04_Orland_EQ04.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F04_Orland_EQ04.png)'
- en: 'Its updated value is *s* = (*x, y*) = (2, 0). That gives us the second row
    of the table:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它的更新值是 *s* = (*x, y*) = (2, 0)。这为我们提供了表格的第二行：
- en: '![](../Images/CH09_F04_Orland_EQ05.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F04_Orland_EQ05.png)'
- en: 'Between *t* = 2 and *t* = 4, the acceleration stays the same so the velocity
    increases by the same amount, *a* · Δ*t* = (0, 0.2) · 2 = (0, 0.4), to a new value,
    *v*(4) = (1, 0.8). The position increases according to the velocity *v*(2):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *t* = 2 和 *t* = 4 之间，加速度保持不变，因此速度增加的量相同，*a* · Δ*t* = (0, 0.2) · 2 = (0, 0.4)，到一个新的值，*v*(4)
    = (1, 0.8)。位置根据速度 *v*(2) 增加：
- en: '![](../Images/CH09_F04_Orland_EQ06.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F04_Orland_EQ06.png)'
- en: 'This increases the position to *s*(4) = (4, 0.8). We now have three rows of
    the table completed, and we’ve calculated two of the five positions we wanted:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将位置提升到 *s*(4) = (4, 0.8)。现在我们已经完成了表格的三行，并且计算了我们想要的五个位置中的两个：
- en: '![](../Images/CH09_F04_Orland_EQ07.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F04_Orland_EQ07.png)'
- en: 'We could keep going like this, but it will be more pleasant if we let Python
    do the work for us−that’s our next step. But first, let’s pause for a moment.
    I’ve taken us through quite a bit of arithmetic in the past few paragraphs. Did
    any of my assumptions seem suspect to you? I’ll give you a hint: it’s not quite
    legal to use the equation Δ*s* = *v* · Δ*t* as I did here, so the positions in
    the table are only approximately correct. If you don’t see where I snuck in approximations
    yet, don’t worry. It will be clear soon, once we’ve plotted the position vectors
    on a graph.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续这样做，但如果让 Python 为我们完成这项工作会更好——这是我们下一步要做的事情。但首先，让我们暂停一下。在过去的几段中，我已经带你们经历了很多算术。我的任何假设看起来可疑吗？我会给你一个提示：我这样使用方程
    Δ*s* = *v* · Δ*t* 并不完全合法，所以表格中的位置只是近似正确的。如果你还没有看到我如何偷偷使用近似值，不要担心。一旦我们在图上绘制了位置向量，一切就会变得清晰。
- en: 9.3.2 Implementing the algorithm in Python
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 在 Python 中实现算法
- en: 'Describing this procedure in Python isn’t too much work. We first need to set
    the initial values of time, position, velocity, and acceleration:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中描述这个程序并不需要太多工作。我们首先需要设置时间、位置、速度和加速度的初始值：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The other values we need to specify are the moments in time we’re interested
    in: 0, 2, 4, 6, 8, and 10 seconds. Rather than list all of these, we can use the
    fact that *t* = 0 to begin with and specify a constant Δ*t* = 2 for each time
    step with 5 time steps in total:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要指定的其他值是我们感兴趣的时间点：0、2、4、6、8 和 10 秒。我们不必列出所有这些，我们可以使用 *t* = 0 作为起点，并指定每个时间步长为
    2 秒的恒定 Δ*t*，总共有 5 个时间步长：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we need to update time, position, and velocity once for every time
    step. As we go, we can store the positions in an array for later use:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在每个时间步长更新一次时间、位置和速度。在这个过程中，我们可以将位置存储在数组中以供以后使用：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Updates the position by adding the change in position Δs = v·Δt to the current
    position *s*. (I used the scale and add functions from chapter 2.)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过将位置变化 Δs = v·Δt 加到当前位置 *s* 上来更新位置。 (我使用了第 2 章中的缩放和加法函数。)
- en: ❷ Updates the velocity by adding the change in velocity Δv = a·Δt to the current
    velocity v
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过将速度变化 Δv = a·Δt 加到当前速度 v 上来更新速度
- en: 'If we run this code, the positions list is populated with six values of the
    vector *s*, corresponding to the times *t* = 0, 2, 4, 6, 8, 10\. Now that we have
    the values in code, we can plot them and picture the object’s motion. If we plot
    them in 2D using the drawing module from chapters 2 and 3, we can see the object
    initially moving to the right and then veering upward as expected (figure 9.5).
    Here’s the Python code, and the plot it generates:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，位置列表将填充六个向量`s`的值，对应于时间`t` = 0, 2, 4, 6, 8, 10。现在我们有了代码中的值，我们可以绘制它们并想象物体的运动。如果我们使用第2章和第3章中的绘图模块在2D中绘制它们，我们可以看到物体最初向右移动，然后像预期的那样向上倾斜（图9.5）。以下是Python代码及其生成的图表：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](../Images/CH09_F05_Orland.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F05_Orland.png)'
- en: Figure 9.5 Points on the object’s trajectory according to our calculation with
    Euler’s method
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 根据我们的欧拉方法计算得到的物体轨迹上的点。
- en: In our approximation, it’s as if the object moved in five straight lines at
    a different velocity on each of the five time intervals (figure 9.6).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的近似中，物体似乎在每个五段时间间隔内以不同的速度沿着五条直线移动（图9.6）。
- en: '![](../Images/CH09_F06_Orland.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F06_Orland.png)'
- en: Figure 9.6 The five displacement vectors connecting the points on the trajectory
    by straight lines.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 通过直线连接轨迹上各点的五个位移向量。
- en: The object is supposed to be accelerating the whole time, so you might expect
    it to move in a smooth curve instead of in straight lines. Now that we have Euler’s
    method implemented in Python, we can quickly rerun it with different parameters
    to assess the quality of the approximation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 物体应该一直在加速，所以你可能期望它移动在一个平滑的曲线上而不是直线。现在我们已经在Python中实现了欧拉方法，我们可以快速用不同的参数重新运行它，以评估近似的质量。
- en: 9.4 Running Euler’s method with smaller time steps
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 使用更小的时间步长运行欧拉方法
- en: We can rerun the calculation again using twice as many time steps by setting
    `dt = 1` and `steps = 10`. This still simulates 10 seconds of motion, but instead,
    models it with 10 straight line paths (figure 9.7).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`dt`设置为`1`和`steps`设置为`10`来重新运行计算，使用两倍的时间步数。这仍然模拟了10秒的运动，但用10条直线路径来建模（图9.7）。
- en: '![](../Images/CH09_F07_Orland.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F07_Orland.png)'
- en: Figure 9.7 Euler’s method produces different results with the same initial values
    and different numbers of steps.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 使用相同的初始值和不同步数，欧拉方法产生了不同的结果。
- en: Trying again with 100 steps and `dt` `=` `0.1`, we see yet another trajectory
    in the same 10 seconds (figure 9.8).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试使用100步和`dt` `=` `0.1`，我们在同样的10秒内看到了另一条轨迹（图9.8）。
- en: '![](../Images/CH09_F08_Orland.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F08_Orland.png)'
- en: Figure 9.8 With 100 steps instead of 5 or 10, we get yet another trajectory.
    Dots are omitted for this trajectory because there are so many of them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 使用100步而不是5或10步，我们得到了另一条轨迹。由于点太多，这条轨迹中的点被省略了。
- en: Why do we get different results even though the same equations went into all
    three calculations? It seems like the more time steps we use, the bigger the *y*-coordinates
    get. We can see the problem if we look closely at the first two seconds.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么尽管三个计算都使用了相同的方程，我们得到的结果却不同？看起来我们使用的步数越多，`y`坐标就越大。如果我们仔细观察前两秒，就能看到这个问题。
- en: In the 5-step approximation, there’s no acceleration; the object is still traveling
    along the x-axis. In the 10-step approximation, the object has had one chance
    to update its velocity, so it has risen above the x-axis. Finally, the 100-step
    approximation has 19 velocity updates between *t* = 0 and *t* = 1, so its velocity
    increase is the largest (figure 9.9).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在5步近似中，没有加速度；物体仍在x轴上移动。在10步近似中，物体已经更新了一次速度，因此它已经上升到x轴以上。最后，100步近似在`t` = 0和`t`
    = 1之间有19次速度更新，因此它的速度增加最大（图9.9）。
- en: '![](../Images/CH09_F09_Orland.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F09_Orland.png)'
- en: Figure 9.9 Looking closely at the first two segments, the 100-step approximation
    is the largest because its velocity updates most frequently.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 仔细观察前两个段落，100步近似值最大，因为它的速度更新最频繁。
- en: This is what I swept under the rug earlier. The equation Δ*s* = *v* · Δ*t* is
    only correct when velocity is constant. Euler’s method is a good approximation
    when you use a lot of time steps because on smaller time intervals, velocity doesn’t
    change that much. To confirm this, you can try some large time steps with small
    values for *dt*. For example, with 100 steps of 0.1 seconds each, the final position
    is
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我之前忽略的事情。方程 Δ*s* = *v* · Δ*t* 仅在速度恒定时才正确。当使用大量时间步长时，欧拉方法是一个很好的近似，因为在较短的时间间隔内，速度变化不大。为了证实这一点，你可以尝试一些大时间步长和小的
    *dt* 值。例如，使用 100 步，每步 0.1 秒，最终位置是
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: and with 100,000 steps of 0.0001 seconds each, the final position is
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以及使用 100,000 步，每步 0.0001 秒，最终位置是
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The exact value of the final position is (10.0, 10.0), and as we add more and
    more steps to our approximation with Euler’s method, our results appear to *converge*
    to this value. You’ll have to trust me for now that (10.0, 10.0) is the exact
    value. We’ll cover how to do exact integrals in the next chapter to prove it.
    Stay tuned!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最终位置的精确值是 (10.0, 10.0)，随着我们使用欧拉方法添加越来越多的步骤，我们的结果似乎 *收敛* 到这个值。现在你必须相信我，(10.0,
    10.0) 是精确值。我们将在下一章中介绍如何进行精确积分来证明这一点。请耐心等待！
- en: Exercises
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '| **Exercise 9.2-Mini Project**: Create a function that carries out Euler’s
    method automatically for a constantly accelerating object. You need to provide
    the function with an acceleration vector, initial velocity vector, initial position
    vector, and perhaps other parameters.**Solution**: I also included the total time
    and number of steps as parameters to make it easy to test various answers in the
    solution.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 9.2-迷你项目**：创建一个函数，该函数可以自动对匀加速物体执行欧拉方法。你需要向该函数提供加速度向量、初始速度向量、初始位置向量，以及可能的其他参数。**解决方案**：我还包括了总时间和步数作为参数，以便于测试解决方案中的各种答案。'
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ The duration of each time step dt is the total time elapsed divided by the
    number of time steps.❷ For each step, updates the position and velocity and adds
    the latest position as the next position in the trajectory (list of positions)
    |
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每个时间步长 dt 的持续时间是总时间除以时间步长的数量。❷ 对于每一步，更新位置和速度，并将最新的位置作为轨迹（位置列表）中的下一个位置。
- en: '| **Exercise 9.3-Mini Project**: In the calculation of section 9.4, we under
    approximated the *y*-coordinate of position because we updated the *y* component
    of the velocity at the end of each time interval. Update the velocity at the beginning
    of each time interval and show that you over approximate the *y* position over
    time.**Solution**: We can tweak our implementation of the `eulers_method` function
    from mini-project 9.2 with the only modification being switching the update order
    of `s` and `v` :'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 9.3-迷你项目**：在 9.4 节的计算中，我们低估了位置坐标的 *y* 值，因为我们是在每个时间间隔结束时更新速度的 *y* 分量。在每个时间间隔开始时更新速度，并展示你如何随着时间的推移高估
    *y* 位置。**解决方案**：我们可以通过将 `eulers_method` 函数的 `s` 和 `v` 更新顺序进行切换来调整迷你项目 9.2 中的实现：'
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the same inputs, this indeed gives a higher approximation of the *y*-coordinate
    than the original implementation. If you look closely at the trajectory in the
    following figure, you can see it is already moving in the *y* direction in the
    first time step.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的输入，这确实给出了比原始实现更高的 *y* 坐标近似值。如果你仔细观察以下图中的轨迹，你可以看到它已经在第一个时间步中向 *y* 方向移动。
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](../Images/CH09_UN01_Orland.png)The original Euler’s method trajectory and
    the new one. The exact trajectory is shown in black for comparison. |'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![原始欧拉方法轨迹和新轨迹](../Images/CH09_UN01_Orland.png) 原始的欧拉方法轨迹和新的轨迹。为了比较，精确轨迹用黑色显示。'
- en: '| **Exercise 9.4−Mini Project**: Any projectile like a thrown baseball, a bullet,
    or an airborne snowboarder experiences the same acceleration vector: 9.81 m/s/s
    toward the earth. If we think of the x-axis of the plane as flat ground with the
    positive y-axis pointing upward, that amounts to an acceleration vector of (0,
    9.81). If a baseball is thrown from shoulder height at *x* = 0, we could say its
    initial position is (0, 1.5). Assume it’s thrown at an initial speed of 30 m/s
    at an angle of 20° up from the positive *x* direction and simulate its trajectory
    with Euler’s method. Approximately how far does the baseball go in the *x* direction
    before hitting the ground?**Solution**: The initial velocity is (30 · cos(20°),
    30 · sin(20°)). We can use the `eulers_method` function from mini-project 9.2
    to simulate the baseball’s motion over a few seconds:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习9.4-迷你项目**：任何像投掷的棒球、子弹或空中滑雪板运动员这样的抛射体都会经历相同的加速度向量：9.81 m/s/s指向地球。如果我们把平面的x轴看作是平坦的地面，正y轴向上，那么加速度向量就是(0,
    9.81)。如果一个棒球从肩高处以*x* = 0的位置投出，我们可以说它的初始位置是(0, 1.5)。假设它以30 m/s的初始速度，从正*x*方向向上20°的角度投出，并使用欧拉方法模拟其轨迹。棒球在击中地面之前在大约x轴的67米处能飞多远？**解答**：初始速度是(30
    · cos(20°), 30 · sin(20°))。我们可以使用迷你项目9.2中的`eulers_method`函数来模拟棒球在几秒钟内的运动：'
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Plotting the resulting trajectory, this figure shows that the baseball makes
    an arc in the air before returning to the earth at about the 67-meter mark on
    the x-axis. The trajectory continues underground because we didn’t tell it to
    stop.![](../Images/CH09_UN02_Orland.png) |
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制得到的轨迹，这个图显示了棒球在空中形成一个弧线，在大约x轴的67米处返回地球。轨迹继续地下延伸，因为我们没有告诉它停止。![投掷棒球](../Images/CH09_UN02_Orland.png)
    |
- en: '| **Exercise 9.5−Mini Project**: Rerun the Euler’s method simulation from the
    previous mini-project with the same initial speed of 30 but using an initial position
    of (0, 0) and trying various angles for the initial velocity. What angle makes
    the baseball go the farthest before hitting the ground?**Solution**: To simulate
    different angles, you can package this code as a function. Using a new starting
    position of (0, 0), you can see various trajectories in the following figure.
    It turns out that the baseball makes it the farthest at an angle of 45°. (Notice
    that I’ve filtered out the points on the trajectory with negative *y* components
    to consider only the motion before the baseball hits the ground.)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习9.5-迷你项目**：重新运行之前迷你项目中使用的欧拉方法模拟，初始速度相同为30，但使用初始位置(0, 0)并尝试不同的初始速度角度。哪个角度使棒球在击中地面之前飞得最远？**解答**：为了模拟不同的角度，你可以将这段代码打包成一个函数。使用新的起始位置(0,
    0)，你可以在下面的图中看到各种轨迹。结果发现，棒球在45°的角度下飞得最远。（注意，我已经过滤掉了轨迹上具有负*y*分量的点，只考虑棒球击中地面之前的运动。）'
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](../Images/CH09_UN03_Orland.png)Throwing a baseball at 30 m/s at various
    angles |'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![投掷棒球](../Images/CH09_UN03_Orland.png)以30 m/s的速度从不同角度投掷棒球 |'
- en: '| **Exercise 9.6−Mini Project**: An object moving in 3D space has an initial
    velocity of (1, 2, 0) and has a constant acceleration vector of (0, −1, 1). If
    it starts at the origin, where is it after 10 seconds? Plot its trajectory in
    3D using the drawing functions from chapter 3.**Solution**: It turns out our `eulers_method`
    implementation can already handle 3D vectors! The figure following the code snippet
    shows the trajectory in 3D.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习9.6-迷你项目**：一个在3D空间中移动的物体具有初始速度(1, 2, 0)和恒定的加速度向量(0, −1, 1)。如果它从原点开始，10秒后它在哪里？使用第3章的绘图函数绘制其在3D空间中的轨迹。**解答**：我们的`eulers_method`实现已经可以处理3D向量了！代码片段之后的图显示了3D空间中的轨迹。'
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](../Images/CH09_UN04_Orland.png)Running with 1,000 steps for improved accuracy,
    we can find the last position:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![跑步](../Images/CH09_UN04_Orland.png)使用1,000步以提高精度，我们可以找到最后的位置：'
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It’s close to (10, −30, 50), which turns out to be the exact position. |
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它接近于(10, −30, 50)，这最终是确切的位置。|
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Velocity is the derivative of position with respect to time. It is a vector
    consisting of the derivatives of each of the position functions. In 2D, with position
    functions *x*(*t*) and *y*(*t*), we can write the position *vector* as a function
    *s*(*t*) = (*x*(*t*), *y*(*t*)) and the velocity vector as a function *v*(*t*)
    = (*x*'(*t*), *y*'(*t*)).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度是位置对时间的导数。它是一个向量，由每个位置函数的导数组成。在2D中，使用位置函数*x*(*t*)和*y*(*t*)，我们可以将位置向量写成一个函数*s*(*t*)
    = (*x*(*t*), *y*(*t*))，速度向量写成一个函数*v*(*t*) = (*x*'(*t*), *y*'(*t*)).
- en: In a video game, you can animate an object moving at a constant velocity by
    updating its position in each frame. Measuring the time between frames and multiplying
    it by the object’s velocity gives you the change in position for the frame.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一款视频游戏中，你可以通过在每一帧更新对象的位置来使对象以恒定速度移动。测量帧之间的时间并乘以对象的速度，可以得到该帧的位置变化。
- en: Acceleration is the derivative of velocity with respect to time. It is a vector
    whose components are the derivatives of the components of velocity, for instance,
    *a*(*t*) = (*v*'*x*(*t*), *v*'*y*(*t*)).
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速度是速度对时间的导数。它是一个向量，其分量是速度分量的导数，例如，*a*(t) = (*v*'*x*(t), *v*'*y*(t))。
- en: To simulate an accelerating object in a video game, you need to not only update
    the position with each frame but also update the velocity.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在视频游戏中模拟加速对象，你需要不仅更新每一帧的位置，还要更新速度。
- en: If you know the rate at which a quantity changes with respect to time, you can
    compute the value of a quantity itself over time by calculating the quantity’s
    change over many small time intervals. This is called *Euler’s method*.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你知道一个量相对于时间的改变率，你可以通过计算该量在许多小时间间隔内的变化来计算该量随时间的变化值。这被称为*欧拉法*。
