- en: '4 Nonlocal games: Working with multiple qubits'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 非局域游戏：与多个量子比特一起工作
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using nonlocal games to check that quantum mechanics is consistent with how
    the universe works
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非局域游戏来验证量子力学与宇宙运作方式的一致性
- en: Simulating state preparation, operations, and measurement results for multiple
    qubits
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟多个量子比特的状态准备、操作和测量结果
- en: Recognizing the characteristics of entangled states
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别纠缠态的特征
- en: In the last chapter, we used qubits to communicate with Eve securely, exploring
    how we can use quantum devices in cryptography. Working with one qubit at a time
    is fun, but working with more will be—well, more fun! In this chapter, we’ll learn
    how to model states of multiple qubits and what it means for them to be *entangled*.
    We will again be playing games with Eve, but this time we will need a referee!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用量子比特与Eve安全通信，探讨了如何利用量子设备进行密码学。一次只处理一个量子比特很有趣，但处理多个量子比特将会——嗯，更有趣！在本章中，我们将学习如何模拟多个量子比特的状态以及它们“纠缠”的含义。我们还将再次与Eve玩游戏，但这次我们需要一个裁判！
- en: 4.1 Nonlocal games
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 非局域游戏
- en: 'At this point, we have seen how single-qubit devices can be programmed to accomplish
    useful tasks such as random number generation and quantum key distribution. The
    most exciting computational tasks, however, require using multiple qubits together.
    In this chapter, we’ll learn about nonlocal games: a way to validate our quantum
    mechanical descriptions of the universe with friends using multi-qubit systems.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到如何编程单量子比特设备来完成有用的任务，例如随机数生成和量子密钥分发。然而，最激动人心的计算任务需要使用多个量子比特一起完成。在本章中，我们将了解非局域游戏：一种使用多量子比特系统与朋友验证我们对宇宙量子力学描述的方法。
- en: 4.1.1 What are nonlocal games?
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 什么是非局域游戏？
- en: 'We have all played games of one type or another, whether sports, board games,
    video games, or role-playing games. Games are one of the best ways to explore
    new worlds and test our limits of strength, endurance, and understanding. Turns
    out Eve loves to play games, and the latest encrypted message from her was the
    following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都玩过各种各样的游戏，无论是体育、棋类、电子游戏还是角色扮演游戏。游戏是探索新世界和测试我们力量、耐力和理解极限的最好方式之一。事实证明，Eve喜欢玩游戏，她最新的加密信息如下：
- en: “*Hi player! I am keen to play a game called CHSH. It is a nonlocal game where
    we play with a referee. I’ll send the instructions in the next message. STOP*”
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: “*嗨玩家！我非常想玩一个叫做CHSH的游戏。这是一个非局域游戏，其中我们与裁判一起玩。我将在下一条消息中发送指令。停止*”
- en: What makes the game proposed by Eve *nonlocal* is the fact that the players
    are (sadly) not in the same place while playing the game. The players participate
    in the game by sending and receiving messages with a central referee but don’t
    have a chance to talk to each other while playing. What is really cool is that
    by playing the game, we can show that classical physics just doesn’t cut it to
    describe the results we get in these games with particular strategies. The particular
    winning strategy we will look at here involves the players sharing a pair of qubits
    before the game starts. We will dive into just what entangling two qubits means
    as we go through this chapter, but let’s start with describing the full rules
    of our nonlocal game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Eve提出的游戏之所以是非局域的，是因为玩家在玩游戏时（遗憾的是）不在同一个地方。玩家通过向中心裁判发送和接收消息来参与游戏，但在玩游戏时没有机会互相交谈。真正酷的是，通过玩游戏，我们可以证明经典物理学根本无法描述我们在这些游戏中使用特定策略得到的结果。我们将在这里查看的特定获胜策略涉及玩家在游戏开始前共享一对量子比特。随着我们进入本章，我们将深入了解纠缠两个量子比特的含义，但让我们先描述我们的非局域游戏的完整规则。
- en: Note A referee adjudicating a nonlocal game can ensure that the players don’t
    communicate by separating them by a large enough distance that no light from one
    player could reach the other before the game ends.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：裁判在非局域游戏中进行裁决可以确保玩家之间没有通过足够大的距离进行通信，这样任何一个玩家的光线在游戏结束前都无法到达另一个玩家。
- en: '4.1.2 Testing quantum physics: The CHSH game'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 测试量子物理：CHSH游戏
- en: The nonlocal game Eve has suggested playing is called *the CHSH game*, shown
    in figure 4.1.^([1](#pgfId-1020764))
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Eve建议玩的游戏被称为*CHSH游戏*，如图4.1所示.^([1](#pgfId-1020764))
- en: The CHSH game comprises two players and a referee. We can play as many rounds
    of the game as we like, and each round has three steps. As Eve mentioned in her
    first message, once a round starts, the players cannot communicate and must make
    their own (possibly preplanned) decisions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: CHSH 游戏由两个玩家和一个裁判组成。我们可以玩任意多轮游戏，每一轮有三个步骤。正如伊芙在她的第一条信息中提到的，一旦一轮开始，玩家们就不能进行交流，必须自己（可能是预先计划的）做出决定。
- en: '![](../Images/4-1.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-1.png)'
- en: Figure 4.1 The CHSH game, a nonlocal game with two players and a referee. The
    referee gives each player a question in the form of a bit value, and then each
    player has to figure out how to respond to the referee. The players win if the
    Boolean AND of their responses is the same as the classical XOR of the referee’s
    questions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 CHSH 游戏，一个有两个玩家和一个裁判的非局域性游戏。裁判以比特值的形式向每个玩家提出问题，然后每个玩家必须弄清楚如何回应裁判。如果玩家们的响应的布尔
    AND 与裁判问题的经典 XOR 相同，则玩家们获胜。
- en: 'The steps for one round of the CHSH game are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CHSH 游戏一轮的步骤如下：
- en: 'The referee starts the round by giving us and Eve each one classical bit. The
    referee chooses these bits *independently* and uniformly at random, so we could
    get a 0 or a 1, each with 50% probability, and the same for Eve. This means there
    are four possible ways the referee can start the game (our bit, Eve’s bit): (0,0),
    (0,1), (1,0), or (1,1).'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 裁判通过给我们和伊芙各自一个经典比特来开始一轮。裁判独立且均匀随机地选择这些比特，所以我们可能会得到 0 或 1，每种情况各有 50% 的概率，伊芙也是如此。这意味着裁判可以以四种可能的方式开始游戏（我们的比特，伊芙的比特）：(0,0)，(0,1)，(1,0)，或
    (1,1)。
- en: We and Eve must each *independently* decide on a single classical bit to give
    back to the referee as a response.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们和伊芙必须各自 *独立地* 决定一个经典比特作为回应给裁判。
- en: The referee then calculates the parity (XOR) of our and Eve’s classical bit
    responses.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 裁判随后计算我们和伊芙的经典比特响应的奇偶性（XOR）。
- en: As listed in table 4.1, in three out of the four cases, we and Eve must respond
    with *even* parity (our answers must be equal) to win, while in the fourth case,
    our answers must be different. These are definitely *unusual* rules, but not too
    bad compared to some multiday board games.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如表 4.1 所列，在四种情况中的三种情况下，我们和伊芙必须以 *偶数* 奇偶性（我们的答案必须相等）来响应以获胜，而在第四种情况下，我们的答案必须不同。这些规则确实
    *不同寻常*，但与一些多日棋盘游戏相比，还算不错。
- en: Table 4.1 Win conditions for the CHSH game
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 CHSH 游戏的获胜条件
- en: '| Our input | Eve’s input | Response parity to win |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 我们的输入 | 伊芙的输入 | 获胜的响应奇偶性 |'
- en: '| 0 | 0 | Even |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 偶数 |'
- en: '| 0 | 1 | Even |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 偶数 |'
- en: '| 1 | 0 | Even |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 偶数 |'
- en: '| 1 | 1 | Odd |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 奇数 |'
- en: We can expand on table 4.1 to get all of the possible outcomes of the game;
    see table 4.2.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展表 4.1 来获取游戏的所有可能结果；见表 4.2。
- en: Table 4.2 All possible states of the CHSH game with win conditions. Input bits
    come from the referee, and both players respond to the referee.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 具有获胜条件的 CHSH 游戏的所有可能状态。输入比特来自裁判，两位玩家都对裁判做出回应。
- en: '| Our input | Eve’s input | Our response | Eve’s response | Parity | Win? |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 我们的输入 | 伊芙的输入 | 我们的响应 | 伊芙的响应 | 奇偶性 | 获胜？ |'
- en: '| 0 | 0 | 0 | 0 | Even | Yes |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 偶数 | 是 |'
- en: '| 0 | 0 | 0 | 1 | Odd | No |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 1 | 奇数 | 否 |'
- en: '| 0 | 0 | 1 | 0 | Odd | No |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0 | 奇数 | 否 |'
- en: '| 0 | 0 | 1 | 1 | Even | Yes |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 1 | 偶数 | 是 |'
- en: '| 0 | 1 | 0 | 0 | Even | Yes |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 0 | 偶数 | 是 |'
- en: '| 0 | 1 | 0 | 1 | Odd | No |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 | 奇数 | 否 |'
- en: '| 0 | 1 | 1 | 0 | Odd | No |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 | 奇数 | 否 |'
- en: '| 0 | 1 | 1 | 1 | Even | Yes |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 1 | 偶数 | 是 |'
- en: '| 1 | 0 | 0 | 0 | Even | Yes |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 0 | 偶数 | 是 |'
- en: '| 1 | 0 | 0 | 1 | Odd | No |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 | 奇数 | 否 |'
- en: '| 1 | 0 | 1 | 0 | Odd | No |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | 奇数 | 否 |'
- en: '| 1 | 0 | 1 | 1 | Even | Yes |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 1 | 偶数 | 是 |'
- en: '| 1 | 1 | 0 | 0 | Even | No |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 | 偶数 | 否 |'
- en: '| 1 | 1 | 0 | 1 | Odd | Yes |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 1 | 奇数 | 是 |'
- en: '| 1 | 1 | 1 | 0 | Odd | Yes |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 0 | 奇数 | 是 |'
- en: '| 1 | 1 | 1 | 1 | Even | No |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 偶数 | 否 |'
- en: Let’s look at some Python code to simulate this game. Since our and Eve’s responses
    to the referee are allowed to depend on the message the referee gives us, we can
    represent each player’s actions as a “function” that the referee calls.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些 Python 代码来模拟这个游戏。由于我们和伊芙对裁判的响应可以依赖于裁判给出的信息，我们可以将每个玩家的行动表示为裁判调用的“函数”。
- en: 'Exercise 4.1: Umpire state of mind'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.1：裁判心态
- en: Since the referee is purely classical, we’ll model them as using classical random
    number generators. This leaves open the possibility, though, that we and Eve could
    cheat by guessing the referee’s questions. A possible improvement might be to
    use the QRNGs from chapter 2\. Modify the code sample in listing 4.1 so that the
    referee can ask questions of us and Eve by measuring a qubit that starts off in
    the |+〉 state.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于裁判完全是经典的，我们将它们建模为使用经典随机数生成器。然而，这留下了我们和 Eve 通过猜测裁判的问题来作弊的可能性。一个可能的改进可能是使用第
    2 章中的 QRNG。修改列表 4.1 中的代码示例，以便裁判可以通过测量一个从 |+〉 状态开始的量子比特来向我们和 Eve 提问。
- en: Exercise solutions
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 练习解答
- en: 'All solutions for exercises in this book can be found in the companion code
    repo: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).
    Just go to the folder for the chapter you are in and open the Jupyter notebook
    with the name that mentions exercise solutions.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所有练习的解答都可以在配套代码仓库中找到：[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)。只需转到您所在的章节文件夹，并打开提及练习解答的
    Jupyter notebook。
- en: As we can see in listing 4.1, we are declaring a new type `Strategy` to define
    the tuple of functions representing our and Eve’s one-bit functions that represent
    our individual strategies. We can think of these functions as representing what
    we and Eve each do with the bits given to us by the referee.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 4.1 所示，我们正在声明一个新的类型 `Strategy` 来定义表示我们和 Eve 的单个位函数的函数元组。我们可以将这些函数视为代表我们和
    Eve 各自如何处理裁判给我们的位。
- en: 'Listing 4.1 chsh.py: Python implementation for the CHSH game'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 chsh.py：CHSH 游戏的 Python 实现
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Using Python’s typing module lets us document that a value of type Strategy
    is a tuple of two functions, each of which takes an int and returns an int.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 Python 的 typing 模块，我们可以记录一个类型为 Strategy 的值是一个包含两个函数的元组，每个函数都接受一个 int 并返回一个
    int。
- en: ❷ The classical random number generator the referee will use
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 裁判将使用的经典随机数生成器
- en: ❸ The “strategy” function will assign one-bit functions representing what “you”
    and “eve” will do based on our input.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ “策略”函数将根据我们的输入分配代表“你”和“eve”将做什么的单个位函数。
- en: ❹ The referee picks two random bits, one for each player.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 裁判选择两个随机位，一个给每个玩家。
- en: ❺ Gives each player their random bit and then computes the parity of their responses
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 给每个玩家他们的随机位，然后计算他们响应的奇偶性
- en: ❻ Check table 4.1 to see if the players won.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 检查表 4.1 以查看玩家是否获胜。
- en: ❼ We can use Python’s built-in sum function to count the number of times referee
    returns True for a particular strategy—in other words, how many times we have
    won the game.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 我们可以使用 Python 的内置 sum 函数来计算裁判对特定策略返回 True 的次数——换句话说，我们赢得游戏的次数。
- en: ❽ Divides by the number of games we played and then estimates the probability
    that our and Eve’s strategy wins the CHSH game
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 将游戏次数除以，然后估计我们的和 Eve 的策略赢得 CHSH 游戏的概率。
- en: Note that in listing 4.1, we don’t have a definition yet for the input `strategy`
    to the referee. Now that we have implemented the rules of the game in Python,
    let’s talk *strategy* and get to implementing a classical strategy for playing
    the CHSH game.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在列表 4.1 中，我们还没有为裁判的输入 `strategy` 提供定义。现在我们已经用 Python 实现了游戏的规则，让我们谈谈 *策略*
    并开始实现 CHSH 游戏的经典策略。
- en: Tip It’s helpful to choose variable naming conventions that make it obvious
    what role each variable plays in our code. We chose to use the prefix `n_` in
    the variable `n_games` to indicate that the variable refers to a number or size,
    and we use the prefix `idx_` to refer to the index for each individual game. Much
    like driving, it’s good if our code is predictable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：选择变量命名约定，使代码中每个变量的作用显而易见是有帮助的。我们选择在变量 `n_games` 中使用前缀 `n_` 来表示该变量表示一个数字或大小，并使用前缀
    `idx_` 来指代每个单独游戏的索引。就像开车一样，如果我们的代码可预测，那就很好。
- en: 4.1.3 Classical strategy
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 经典策略
- en: The simplest strategy for both us and Eve to pursue is to ignore our inputs
    entirely. Looking at table 4.3, if both of us agree before the game that we will
    never change our outputs (i.e., always return 0), we will win 75% of the time
    (this does assume the referee chooses the random bits for each player uniformly).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们和 Eve 来说，最简单的策略是完全忽略我们的输入。查看表 4.3，如果我们俩在游戏开始前就同意我们永远不会改变我们的输出（即，总是返回 0），我们将有
    75% 的胜率（这假设裁判为每个玩家均匀地选择随机位）。
- en: Table 4.3 Best classical strategy for the CHSH game, where we both always respond
    with 0 with win conditions
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3 CHSH游戏的最佳经典策略，我们双方在满足条件时总是响应0
- en: '| Our input | Eve’s input | Our response | Eve’s response | Parity | Win? |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 我们的输入 | 爱娃的输入 | 我们的响应 | 爱娃的响应 | 奇偶性 | 胜？ |'
- en: '| 0 | 0 | 0 | 0 | Even | Yes |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 偶数 | 是 |'
- en: '| 0 | 1 | 0 | 0 | Even | Yes |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 0 | 偶数 | 是 |'
- en: '| 1 | 0 | 0 | 0 | Even | Yes |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 0 | 偶数 | 是 |'
- en: '| 1 | 1 | 0 | 0 | Even | No |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 | 偶数 | 否 |'
- en: If we were to write this strategy as a Python function, we would have the following
    code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个策略写成Python函数，代码如下。
- en: 'Listing 4.2 chsh.py: an easy, constant strategy for the CHSH game'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 chsh.py：CHSH游戏的简单、恒定策略
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we can test how often we expect to win a round the CHSH game using `constant
    _strategy`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试我们预期在CHSH游戏中赢得一局的频率，使用`constant_strategy`：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Note that you may get slightly more or less than 75% when you try this. This
    is because the win probability is estimated using a finite number of rounds (in
    stats, this is called a binomial distribution). For this example, we’d expect
    error bars of about 1.5%.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注意，当你尝试这个时，你可能得到略多或略少的75%。这是因为胜率是通过有限轮次（在统计学中称为二项分布）估计的。对于这个例子，我们预计误差条约为1.5%。
- en: OK, so that’s an easy strategy, but is there anything cleverer we can do? Given
    that we and Eve only have classical resources, sadly, this is *provably* the best
    we can do. Short of cheating ![](../Images/emoji-devil.png) (e.g., communicating
    with Eve or guessing the referee’s inputs), we cannot win this game more than
    75% of the time on average.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是一个简单的策略，但我们能做得更聪明吗？鉴于我们和爱娃只有经典资源，遗憾的是，这*已经被证明*是我们能做的最好的。除非作弊（例如，与爱娃通信或猜测裁判的输入），否则我们平均无法在75%的时间内赢得这场比赛。
- en: 'This all leads to the obvious question: what if we and Eve could use qubits?
    What would be our best strategy then, and how often would we win? What does it
    say about our understanding of the universe if we have proof that we cannot win
    CHSH more than about 75% of the time, and then we find a way that we *can* beat
    that win rate? As you might guess, we can do better than a 75% win rate playing
    CHSH if the players share quantum resources, i.e., have qubits. Later in the chapter,
    we will get into quantum-based strategies for CHSH, but spoiler: we will need
    to simulate more than one qubit.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都引出了一个明显的问题：如果我们和爱娃能够使用量子比特，那会怎么样？那时我们最佳的战略是什么，我们会有多高的胜率？如果我们有证据表明我们无法在超过75%的时间内赢得CHSH游戏，然后我们找到了一种*可以*提高胜率的方法，这又说明了我们对宇宙的理解是什么？正如你可能猜到的，如果我们玩CHSH游戏时玩家共享量子资源，即拥有量子比特，我们就能比75%的胜率做得更好。在章节的后面，我们将探讨CHSH的量子策略，但剧透一下：我们需要模拟多个量子比特。
- en: 4.2 Working with multiple qubit states
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 与多个量子比特状态一起工作
- en: So far, in this book, we’ve only worked with one qubit at a time. To play a
    nonlocal game, for example, each player will need their own qubit. This raises
    the question, how do things change when the system we are considering has more
    than one qubit? The main difference is that we cannot describe each qubit individually
    and have to think in terms of a state that describes the whole system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们一次只处理一个量子比特。例如，要玩一个非局域游戏，每个玩家将需要他们自己的量子比特。这引发了一个问题，当我们考虑的系统有多个量子比特时，事情会有什么变化？主要区别是我们不能单独描述每个量子比特，而必须从描述整个系统的状态的角度来思考。
- en: Note When describing a group or register of qubits, we generally *cannot* just
    describe each qubit individually. The most useful quantum behaviors can only be
    seen when we describe the state of a group or register of qubits.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在描述一组或寄存器时，我们通常*不能*单独描述每个量子比特。最有用的量子行为只有在描述一组或寄存器的状态时才能看到。
- en: The next section will help relate this system-level view with a similar classical
    programming concept of a register.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将帮助将这个系统级视图与类似经典编程概念的寄存器联系起来。
- en: 4.2.1 Registers
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 寄存器
- en: 'Suppose that we have a *register* of classical bits: that is, a collection
    of many classical bits. We can index through each bit in that register and look
    at its value independently, even though it is still a part of that register. The
    contents of the register can represent a more complex value, like bits that together
    represent a Unicode character (as we saw in chapter 3), but this higher-level
    interpretation is not necessary.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个经典比特的*寄存器*：也就是说，许多经典比特的集合。我们可以独立地索引寄存器中的每个比特并查看其值，尽管它仍然是寄存器的一部分。寄存器的内容可以表示更复杂的值，比如一起表示一个Unicode字符的比特（正如我们在第3章中看到的），但这种高级解释不是必要的。
- en: When we store information in a classical register, the number of different states
    of that register grows very rapidly as we add more bits. For example, if we have
    three bits, there are eight different states that our register can be in; see
    listing 4.3 for an example. We say for the classical register state `101` that
    the zeroth bit is a 1, the first is 0, and the second is 1\. When these values
    are concatenated together, they give us the string `101`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在经典寄存器中存储信息时，随着我们添加更多的比特，该寄存器的不同状态数量会迅速增长。例如，如果我们有三个比特，我们的寄存器可以处于八种不同的状态；参见列表
    4.3 中的示例。我们说对于经典寄存器状态 `101`，零比特是 1，第一个比特是 0，第二个比特是 1。当这些值连接在一起时，它们给出了字符串 `101`。
- en: Listing 4.3 Listing all states of a classical three-bit register
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 列出经典三比特寄存器的所有状态
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we have four bits, we can store one of 16 different states; if we have *N*
    bits, we can store one of 2*N*. We say that the number of different possible states
    of a classical register *grows exponentially* with the number of bits. The bit
    strings output by listing 4.3 show the actual data in the register for each state
    of the register. They also serve as convenient labels for one of eight possible
    messages that we can encode with three classical bits.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有四个比特，我们可以存储 16 种不同的状态；如果我们有 *N* 个比特，我们可以存储 2*N* 种状态。我们说经典寄存器的不同可能状态的数量
    *以指数方式增长*，与比特的数量成正比。列表 4.3 输出的比特字符串显示了寄存器每个状态的实际数据。它们还作为方便的标签，用于我们可以用三个经典比特编码的八种可能消息之一。
- en: What does all this have to do with qubits? We saw in chapters 2 and 3 that any
    state of the classical bit also describes a qubit state. The same holds for registers
    of qubits as well. For instance, the three-bit state “010” describes the three-qubit
    state |010〉.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些与量子比特有什么关系？我们在第 2 章和第 3 章中看到，任何经典比特的状态也描述了一个量子比特状态。对于量子比特寄存器也是如此。例如，三比特状态
    “010” 描述了三量子比特状态 |010〉。
- en: Tip In chapter 2, we saw that qubit states described by classical bits in this
    way are called *computational basis states*; here, we use the same term for states
    of multiple qubits that are described by strings of classical bits.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 在第 2 章中，我们了解到用这种方式用经典比特描述的量子比特状态被称为 *计算基态*；在这里，我们用相同的术语来描述由经典比特字符串描述的多个量子比特的状态。
- en: 'Just as with single qubits, however, the state of a register of multiple qubits
    can also be made up by adding different qubit states together. In the exact same
    way that we can write |+〉 as (|0〉 + |1〉) / √2 to get another valid qubit state,
    our three-qubit register can be in a wide variety of different states:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与单个量子比特一样，多个量子比特寄存器的状态也可以通过将不同的量子比特状态相加来构成。正如我们可以将 |+〉 写作 (|0〉 + |1〉) / √2
    来得到另一个有效的量子比特状态一样，我们的三量子比特寄存器可以处于多种不同的状态：
- en: (|010〉 + |111〉) / √2
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (|010〉 + |111〉) / √2
- en: (|001〉 + |010〉 + |100〉) / √3
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (|001〉 + |010〉 + |100〉) / √3
- en: 'Tip We’ll see more as we go along, but just as we needed the square root of
    2 to make the measurement probabilities work out for |+〉 = (|0〉 + |1〉) / √2, we
    need to divide by √2 and √3 in our examples to make sure all the probabilities
    for each measurement are realistic: i.e., add up to one.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 随着我们的深入，我们将看到更多内容，但正如我们需要 2 的平方根来使 |+〉 = (|0〉 + |1〉) / √2 的测量概率成立一样，我们需要在我们的例子中除以
    √2 和 √3 来确保每个测量的所有概率都是现实的：即总和为 1。
- en: This example of the linearity of quantum registers is called the *superposition
    principle*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个量子寄存器线性的例子被称为 *叠加原理*。
- en: Definition The *superposition principle* tells us that we can add together two
    different states of a quantum register to get another valid state. The |+〉 state
    we saw before is a good example of this, except each register has only one qubit.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *叠加原理* 告诉我们，我们可以将量子寄存器的两种不同状态相加，得到另一个有效状态。我们之前看到的 |+〉 状态是这种情况的一个好例子，但每个寄存器只有一个量子比特。
- en: To write the state of a quantum register in a computer, we’ll again use vectors,
    just as we did in chapter 2\. The main difference is how many numbers we list
    in each vector. Let’s see what it looks like to write the state of a two-qubit
    register on a computer. For example, the vector for the two-qubit state (|00〉
    + |11〉) / √2 can also be written as the state (1 × |00〉 + 0 × |01〉 + 0 × |10〉
    + 1 × |11〉) / √2. If we make a list of what we had to multiply each computational
    basis state by to get the state we wanted, we have precisely the information we
    need to write in our vector. In listing 4.4, we’ve written down (|00〉 + |11〉)
    / √2 as a vector.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要在计算机上写出量子寄存器的状态，我们再次使用向量，就像我们在第2章中做的那样。主要区别是我们每个向量中列出的数字数量。让我们看看在计算机上写出两量子比特寄存器状态的样子。例如，两量子比特状态(|00〉
    + |11〉) / √2也可以写成状态(1 × |00〉 + 0 × |01〉 + 0 × |10〉 + 1 × |11〉) / √2。如果我们列出为了得到我们想要的状态而必须乘以每个计算基态的值，我们就有精确的信息可以写入我们的向量。在列表4.4中，我们将(|00〉
    + |11〉) / √2写成向量形式。
- en: Listing 4.4 Using Python to write an example of a two-qubit state
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4：使用Python编写一个两量子比特状态的示例
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ We start the same way, using the np.array function to make a new vector.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们以相同的方式开始，使用np.array函数创建一个新的向量。
- en: ❷ Each entry in this vector describes a different computational basis state.
    This entry tells us that we have to multiply |00〉 by 1.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个向量中的每个条目描述了一个不同的计算基态。这个条目告诉我们，我们需要将|00〉乘以1。
- en: ❸ Similarly, this entry tells us how much of the |01〉 state we need to add to
    get the state we want.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 同样，这个条目告诉我们需要添加多少|01〉状态才能得到我们想要的状态。
- en: ❹ Finally, we divide by √2 to make sure all the measurement probabilities work
    out, just as we did with the |+〉 state in chapters 2 and 3.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 最后，我们除以√2，以确保所有测量概率都正确，就像我们在第2章和第3章中处理|+〉状态时做的那样。
- en: The numbers in the vector from listing 4.4 are coefficients that we multiply
    by each of the computational basis states, which we then add together to make
    a new state. These coefficients are also called the *amplitudes* for each of the
    basis states in the sum.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4中的向量中的数字是我们要乘以每个计算基态的系数，然后我们将它们相加以得到一个新的状态。这些系数也被称为每个基态的*振幅*。
- en: Thinking with directions
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 思考方向
- en: Another way to think about this example is in terms of directions on a map,
    similar to how vectors are discussed in appendix C. Each different computational
    basis state tells us about a *direction* that a qubit state can be pointed in.
    We can think of a two-qubit state as a direction in four dimensions instead of
    the two-dimensional maps we see in appendix C. Since this book is two-dimensional
    rather than four-dimensional, we unfortunately can’t draw a picture here, but
    sometimes thinking of vectors as directions can be more helpful than thinking
    of vectors as lists of numbers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考这个示例的方法是考虑地图上的方向，类似于附录C中讨论向量时的方式。每个不同的计算基态告诉我们一个量子比特状态可以指向的*方向*。我们可以将两量子比特状态视为四维空间中的一个方向，而不是我们在附录C中看到的二维地图。由于这本书是二维的而不是四维的，我们很遗憾不能在这里画图，但有时将向量视为方向比将向量视为数字列表更有帮助。
- en: 4.2.2 Why is it hard to simulate quantum computers?
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 为什么模拟量子计算机很难？
- en: We have seen that as the number of bits grows, the number of different states
    a register can be in grows exponentially. While this won’t be a problem for us
    in playing a nonlocal game with only two qubits, we’ll want to use more than just
    two qubits as we proceed through this book.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，随着比特数的增加，寄存器可以处于的不同状态数量呈指数增长。虽然在我们仅用两个量子比特玩非局域游戏时这不会成为问题，但随着我们继续阅读本书，我们将需要使用超过两个量子比特。
- en: When we do, we’ll also have exponentially many different computational basis
    states for our quantum register, meaning that we will need exponentially many
    different amplitudes in our vectors as we grow the size of our quantum register.
    To write the state of a 10-qubit register, we’ll need to use a vector that is
    a list of 2^(10) = 1024 different amplitudes. For a 20-qubit register, we’ll need
    about 1 million amplitudes in our vectors. By the time we get to 60 qubits, we’ll
    need about 1.15 × 10^(18) numbers in our vectors. That’s about one amplitude for
    each grain of sand on the planet.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们也将会有指数级多的不同计算基态用于我们的量子寄存器，这意味着随着我们量子寄存器大小的增加，我们向量中需要指数级多的不同振幅。为了写出10量子比特寄存器的状态，我们需要使用一个包含2^10
    = 1024个不同振幅的向量。对于一个20量子比特寄存器，我们向量中需要大约100万个振幅。当我们达到60个量子比特时，我们向量中需要大约1.15 × 10^18个数字。这大约是地球上每粒沙子的一个振幅。
- en: In table 4.4, we summarize what this exponential growth means as we try to simulate
    quantum computers using classical computers like phones, laptops, clusters, and
    cloud environments. This table shows that even though it’s very challenging to
    reason about quantum computers using classical computers, we can pretty easily
    reason about small examples. With a laptop or desktop, we can simulate up to about
    30 qubits without too much hassle. As we’ll see throughout the rest of the book,
    this is more than enough to understand how quantum programs work and how quantum
    computers can be used to solve interesting problems.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在表 4.4 中，我们总结了当我们尝试使用经典计算机（如手机、笔记本电脑、集群和云环境）模拟量子计算机时，这种指数级增长意味着什么。这张表显示，尽管使用经典计算机推理量子计算机非常具有挑战性，但我们可以相当容易地推理小型示例。使用笔记本电脑或台式机，我们可以模拟大约
    30 个量子比特，而不会遇到太多麻烦。正如本书的其余部分将展示的那样，这已经足够理解量子程序的工作原理以及量子计算机如何用于解决有趣的问题。
- en: Table 4.4 How much memory is required to store a quantum state?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.4 存储量子状态需要多少内存？
- en: '| # of qubits | # of amplitudes | Memory | Size comparison |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 量子比特数量 | 振幅数量 | 内存 | 大小比较 |'
- en: '| 1 | 2 | 128 bits |  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 128 bits |  |'
- en: '| 2 | 4 | 256 bits |  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 4 | 256 比特 |  |'
- en: '| 3 | 8 | 512 bits |  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 8 | 512 比特 |  |'
- en: '| 4 | 16 | 1 kilobit |  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 16 | 1 千比特 |  |'
- en: '| 8 | 256 | 4 KB | Tap-enabled credit card |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 256 | 4 KB | 滑动式信用卡 |'
- en: '| 10 | 1024 | 16 KB |  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1024 | 16 KB |  |'
- en: '| 20 | 1,048,576 | 16 MB |  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 1,048,576 | 16 MB |  |'
- en: '| 26 | 67,108,864 | 1 GB | Raspberry Pi RAM |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 26 | 67,108,864 | 1 GB | 树莓派 RAM |'
- en: '| 28 | 268,435,456 | 4 GB | iPhone XS Max RAM |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 28 | 268,435,456 | 4 GB | iPhone XS Max RAM |'
- en: '| 30 | 1,073,741,824 | 16 GB | Laptop or desktop RAM |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 30 | 1,073,741,824 | 16 GB | 笔记本或台式机 RAM |'
- en: '| 40 | 1,099,511,627,776 | 16 TB |  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 40 | 1,099,511,627,776 | 16 TB |  |'
- en: '| 50 | 1,125,899,906,842,624 | 16 petabytes |  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 1,125,899,906,842,624 | 16 PB |  |'
- en: '| 60 | 1,152,921,504,606,846,976 | 16 exabytes |  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 60 | 1,152,921,504,606,846,976 | 16 EB |  |'
- en: '| 80 | 1,208,925,819,614,629,174,706,176 | 16 yottabytes | Approximate size
    of the internet |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 80 | 1,208,925,819,614,629,174,706,176 | 16 亿字节 | 大约的互联网大小 |'
- en: '| 410 | 2.6 × 10^(123) | 4.2 × 10^(124) bytes | Computer the size of the universe
    |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 410 | 2.6 × 10^(123) | 4.2 × 10^(124) bytes | 宇宙大小的计算机 |'
- en: 'Deep dive: Are quantum computers exponentially more powerful?'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：量子计算机的指数级强大吗？
- en: You may have heard that the number of different numbers we have to keep track
    of to simulate a quantum computer using a classical computer is why quantum computers
    are more powerful, or that a quantum computer can store that much information.
    This isn’t exactly true. A mathematical theorem known as *Holevo’s theorem* tells
    us that a quantum computer made up of 410 qubits can store at most 410 classical
    bits of information, even if it would take a classical computer about the size
    of the entire universe to write the state of that quantum computer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过，为了使用经典计算机模拟量子计算机，我们需要追踪的不同数字的数量，这就是量子计算机更强大的原因，或者量子计算机可以存储如此多的信息。这并不完全正确。一个被称为
    *霍勒沃定理* 的数学定理告诉我们，由 410 个量子比特组成的量子计算机最多可以存储 410 个经典比特的信息，即使需要整个宇宙大小的经典计算机来写入该量子计算机的状态。
- en: Put differently, *just because it’s hard to simulate a quantum computer doesn’t
    mean it does something useful*. Throughout the rest of the book, we’ll see that
    it takes a bit of art to figure out how to use a quantum computer to solve useful
    problems.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*仅仅因为模拟量子计算机很难并不意味着它有什么有用的功能*。在本书的其余部分，我们将看到，要使用经典计算机（如手机、笔记本电脑、集群和云环境）模拟量子计算机需要一点艺术性，才能弄清楚如何使用量子计算机解决有用的问题。
- en: 4.2.3 Tensor products for state preparation
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 状态准备的张量积
- en: Describing quantum registers as vectors describing computational basis states
    is all well and good, but even if we know the state we want to get to, we need
    to know how to prepare it. For example, if one player in a nonlocal game has a
    qubit in the |0〉 state and the other has a qubit in the |1〉 state, we can combine
    those two single-qubit states in a straightforward way to describe the state of
    the game as |01〉. What does it mean to “combine” the states of two (or more) qubits?
    We can do this by adding one more concept to our mathematics toolbox, called the
    *tensor product*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将量子寄存器描述为描述计算基态的向量是很好，但即使我们知道我们想要达到的状态，我们也需要知道如何准备它。例如，在一个非局域游戏中，如果一个玩家有一个处于
    |0〉 状态的量子比特，而另一个玩家有一个处于 |1〉 状态的量子比特，我们可以直接将这两个单量子比特状态结合起来，以描述游戏的状态为 |01〉。将两个（或更多）量子比特的状态“结合”是什么意思？我们可以通过向我们的数学工具箱中添加一个名为
    *张量积* 的概念来实现这一点。
- en: In the same way that we used the `product` function in listing 4.3 to combine
    labels for a three-classical-bit register, we can use the concept of a tensor
    product, written as ⊗, to combine the quantum states for each qubit to make a
    state that describes multiple qubits. The output of `product` was a list of all
    possible states of those three classical bits. The output of a tensor product
    is, similarly, a state that lists all computational basis states for a quantum
    register. We can use NumPy to compute tensor products; NumPy provides an implementation
    of the tensor product as the function `np.kron`, as shown in listing 4.5.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们使用列表 4.3 中的 `product` 函数来组合三个经典比特寄存器的标签一样，我们可以使用张量积的概念（表示为 ⊗），将每个量子比特的量子状态结合起来，形成一个描述多个量子比特的状态。`product`
    的输出是那些三个经典比特的所有可能状态的一个列表。同样，张量积的输出是一个列出量子寄存器所有计算基态的状态。我们可以使用 NumPy 来计算张量积；NumPy
    通过 `np.kron` 函数提供了张量积的实现，如图 4.5 所示。
- en: Why kron?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是 kron？
- en: The name `np.kron` may seem odd for a function that implements tensor products,
    but the name is short for a related mathematical concept called the *Kronecker
    product*. NumPy’s use of `kron` as short for *Kronecker* follows the convention
    used in MATLAB, R, Julia, and other scientific computing platforms.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.kron` 这个名字对于一个实现张量积的函数来说可能看起来有些奇怪，但这个名字是与其相关的数学概念——克罗内克积（Kronecker product）的简称。NumPy
    使用 `kron` 作为克罗内克积的简称，遵循了 MATLAB、R、Julia 和其他科学计算平台使用的约定。'
- en: Listing 4.5 A two-qubit state, using NumPy and tensor products
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 使用 NumPy 和张量积表示一个双量子比特状态
- en: '[PRE5]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Defines vectors for the single-qubit states |0〉 and |1〉, just as in chapters
    2 and 3
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义了单量子比特状态 |0〉 和 |1〉 的向量，就像在第 2 章和第 3 章中一样。
- en: ❷ We can build the vector for |0〉 ⊗ |1〉 by calling NumPy’s implementation of
    the tensor product. For historical reasons, the tensor product is represented
    in NumPy by the kron function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们可以通过调用 NumPy 的张量积实现来构建 |0〉 ⊗ |1〉 的向量。由于历史原因，NumPy 中的张量积是通过 `kron` 函数表示的。
- en: ❸ The vector returned by np.kron has a 1 for the entry corresponding to the
    |01〉 computational basis state and 0s everywhere else, so we recognize this vector
    as being the state |01〉.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `np.kron` 返回的向量在对应于 |01〉计算基态的条目处为 1，其他地方为 0，因此我们识别这个向量是状态 |01〉。
- en: This example shows us that |0〉 ⊗ |1〉 = |01〉. That is, if we have the state of
    each qubit individually, we can combine them by using the tensor product to describe
    the state of the whole register.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们展示了 |0〉 ⊗ |1〉 = |01〉。也就是说，如果我们单独拥有每个量子比特的状态，我们可以通过使用张量积来描述整个寄存器的状态，从而将它们结合起来。
- en: We can combine as many qubits as we want this way. Say we had four qubits, all
    in the |0〉 state. The register of all four qubits could be described as |0〉 ⊗
    |0〉 ⊗ |0〉 ⊗ |0〉.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这种方式组合任意数量的量子比特。比如说，我们有了四个量子比特，它们都处于 |0〉 状态。所有四个量子比特的寄存器可以描述为 |0〉 ⊗ |0〉
    ⊗ |0〉 ⊗ |0〉。
- en: Listing 4.6 Making |0000〉 as the tensor product of 4 copies of |0〉
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 将 |0000〉 作为 4 个 |0〉 的张量积
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The reduce function provided with the Python standard library lets us apply
    a two-argument function like kron between each element in a list. Here, we use
    reduce instead of np.kron(ket0, np.kron(ket0, np.kron(ket0, ket0))).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Python 标准库提供的 reduce 函数允许我们在列表中的每个元素之间应用一个双参数函数，如 kron。在这里，我们使用 reduce 而不是
    np.kron(ket0, np.kron(ket0, np.kron(ket0, ket0)))。
- en: ❷ We get back a four-qubit state vector representing |0〉 ⊗ |0〉 ⊗ |0〉 ⊗ |0〉 =
    |0000〉.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们得到了一个表示 |0〉 ⊗ |0〉 ⊗ |0〉 ⊗ |0〉 = |0000〉 的四量子比特状态向量。
- en: Note The two-qubit state (|00〉 + |11〉) / √2 that we saw earlier *cannot* be
    written as the tensor product of two single-qubit states. Multiple-qubit states
    that can’t be written out as tensor products are called *entangled*. We’ll see
    a lot more about entanglement throughout the rest of this chapter and in the rest
    of the book.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们之前看到的二量子比特状态 (|00〉 + |11〉) / √2 不能写成两个单量子比特状态的张量积。不能表示为张量积的多量子比特状态称为 *纠缠*。在本章的其余部分和本书的其余部分，我们将看到更多关于纠缠的内容。
- en: 4.2.4 Tensor products for qubit operations on registers
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 寄存器上的量子比特操作的张量积
- en: Now that we know how to use the tensor product to combine quantum states, what
    is `np.kron` actually doing? In essence, the tensor product is a table of every
    different way of combining its two arguments, as shown in figure 4.2.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用张量积来组合量子状态，`np.kron` 实际上在做什么呢？本质上，张量积是一个表格，列出了将其两个参数以不同方式组合的所有可能方式，如图
    4.2 所示。
- en: '![](../Images/4-2.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-2.png)'
- en: Figure 4.2 The tensor product of two matrices shown step by step. We start by
    multiplying each term in *a* by a full copy of *b*. The resulting matrix dimensions
    of the tensor product are the product of the dimensions of the input matrices.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 逐步展示两个矩阵的张量积。我们首先将 *a* 中的每个项与 *b* 的完整副本相乘。张量积的矩阵维度是输入矩阵维度的乘积。
- en: The same tensor product shown in figure 4.2 of two matrices in Python is also
    shown in the following listing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 中显示的两个矩阵的张量积在 Python 中的表示也显示在下面的列表中。
- en: Listing 4.7 Finding the tensor product of *A* and *B* with NumPy
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 使用 NumPy 求解 *A* 和 *B* 的张量积
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Matrices A and B are arbitrary 2 × 2 matrices used as examples here.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 矩阵 A 和 B 是这里用作示例的任意 2 × 2 矩阵。
- en: ❷ As we saw earlier, np.kron is NumPy’s implementation of the tensor product.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如我们之前所见，np.kron 是 NumPy 对张量积的实现。
- en: ❸ Note that the order of the arguments to the tensor product matters. Although
    both np.kron(A, B) and np.kron(B, A) contain the same information, the entries
    in each are ordered quite differently!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 注意张量积参数的顺序很重要。虽然 np.kron(A, B) 和 np.kron(B, A) 包含相同的信息，但每个中的条目顺序相当不同！
- en: Using the tensor product between two matrices, we can find how different quantum
    operations transform the state of a quantum register. We can also understand how
    a quantum operation transforms the state of multiple qubits by taking the tensor
    product of two matrices instead, letting us understand how our and Eve’s moves
    in a nonlocal game affect our shared state.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过两个矩阵之间的张量积，我们可以找到不同的量子操作如何转换量子寄存器的状态。我们也可以通过取两个矩阵的张量积来理解量子操作如何转换多个量子比特的状态，这样我们可以理解我们在非局域游戏中的移动如何影响我们的共享状态。
- en: For example, we know that we can write |1〉 as *X*|0〉 (that is, the result of
    applying the `x` instruction to an initialized qubit). This also gives us another
    way to write out multiple-qubit states like the |01〉 state we saw earlier. In
    this case, we can get |01〉 by applying an `x` instruction *only* to the second
    qubit of a two-qubit register. Using the tensor product, we can find a unitary
    matrix to represent this.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们知道可以将 |1〉 写作 *X*|0〉（即对初始化的量子比特应用 `x` 指令的结果）。这也为我们提供了另一种方式来写出像我们之前看到的 |01〉
    状态这样的多量子比特状态。在这种情况下，我们只需对两个量子比特寄存器的第二个量子比特应用一个 `x` 指令即可得到 |01〉。使用张量积，我们可以找到一个单位矩阵来表示这一点。
- en: Listing 4.8 Calculating the tensor product of two matrices
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.8 计算两个矩阵的张量积
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Defines a matrix that represents doing nothing to the first qubit, known as
    the identity matrix 𝟙. Since 𝟙 is hard to write in Python, we use I instead
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义了一个表示对第一个量子比特不做任何操作的矩阵，称为单位矩阵 𝟙。由于 𝟙 在 Python 中难以书写，我们使用 I 来代替
- en: ❷ Defines the unitary matrix *X* that lets us simulate the `x` instruction
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义了允许我们模拟 `x` 指令的单位矩阵 *X*
- en: ❸ Combines the two using the tensor product `I` ⊗ *X*
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用张量积 `I` ⊗ *X* 将它们结合起来
- en: ❹ The matrix 𝟙 ⊗ *X* consists of two copies of *X* representing what happens
    to the second qubit for each possible state of the first qubit.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 矩阵 𝟙 ⊗ *X* 包含两个 *X* 的副本，表示对于第一个量子比特的每个可能状态，第二个量子比特会发生什么。
- en: ❺ Let’s see what happens when we use 𝟙 ⊗ X to simulate how the x instruction
    transforms the second qubit in a two-qubit register. We’ll start with that register
    in the |00〉 = |0〉 ⊗ |0〉 state.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 让我们看看当我们使用 𝟙 ⊗ X 来模拟 x 指令如何将两个量子比特寄存器中的第二个量子比特的状态进行转换时会发生什么。我们将从这个处于 |00〉
    = |0〉 ⊗ |0〉 状态的寄存器开始。
- en: ❻ We recognize the state we get back as the |01〉 state from earlier in this
    section. As expected, that is the state we get by flipping the second qubit from
    |0〉 to |1〉.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 我们认出我们得到的状态是本节前面提到的 |01〉 状态。正如预期的那样，这是通过将第二个量子比特从 |0〉 翻转到 |1〉 得到的状态。
- en: 'Exercise 4.2: Hadamard operation on a two-qubit register'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.2：对两个量子比特寄存器进行哈达玛操作
- en: How would you prepare a |+0〉 state? First, what vector would you use to represent
    the two-qubit state |+0〉 = |+〉 ⊗ |0〉? You have an initial two-qubit register in
    the |00〉 state. What operation should you apply to get the state you want?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何准备一个 |+0〉 状态？首先，你将使用什么向量来表示两个量子比特状态 |+0〉 = |+〉 ⊗ |0〉？你有一个初始处于 |00〉 状态的两个量子比特寄存器。你应该应用什么操作来得到你想要的状态？
- en: '*Hint*: Try (*H* ⊗ 𝟙) if you’re stuck!'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示*：如果你卡住了，试试 (*H* ⊗ 𝟙)！'
- en: 'Deep dive: Finally proving the no-cloning theorem'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：最终证明无克隆定理
- en: Learning that operations on multiple qubits are also represented by unitary
    matrices lets us finally prove the no-cloning theorem that we’ve seen a few times
    so far. The key insight is that cloning a state isn’t linear and thus cannot be
    written as a matrix.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 学习到多个量子位的操作也由单位矩阵表示，让我们最终证明了我们之前几次看到的不可克隆定理。关键洞察是，克隆一个状态不是线性的，因此不能写成矩阵的形式。
- en: As with many proofs in mathematics, the proof of the no-cloning theorem works
    by *contradiction*. That is, we assume the opposite of the theorem and then show
    that we get something false due to that assumption.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与数学中的许多证明一样，不可克隆定理的证明是通过**矛盾**来进行的。也就是说，我们假设定理的相反，然后表明由于这个假设，我们得到了一些错误的东西。
- en: Without further ado, then, we start by assuming that we have some wondrous `clone`
    instruction that can perfectly copy the state of its qubit. For instance, if we
    have a qubit `q1` whose state starts in |1〉 and a qubit `q2` whose state starts
    in |0〉, then after calling `q1.clone(q2)`, we would have the register |11〉.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们不再犹豫，首先假设我们有一些神奇的`clone`指令，可以完美地复制其量子位的状态。例如，如果我们有一个量子位`q1`，其状态从|1〉开始，以及一个量子位`q2`，其状态从|0〉开始，那么在调用`q1.clone(q2)`之后，我们会得到寄存器|11〉。
- en: 'Similarly, if `q1` starts in |+〉, then `q1.clone(q2)` should give us a register
    in the state |++〉 = |+〉 ⊗ |+〉. The problem comes in reconciling what `q1.clone(q2)`
    should do in these two cases. We know that any quantum operation other than measurement
    must be linear, so let’s give the matrix that lets us simulate `clone` a name:
    *C* seems pretty reasonable.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果`q1`从|+〉开始，那么`q1.clone(q2)`应该给我们一个处于|++〉 = |+〉 ⊗ |+〉状态的寄存器。问题在于调和`q1.clone(q2)`在这两种情况下应该做什么。我们知道，除了测量之外，任何量子操作都必须是线性的，所以让我们给让我们模拟`clone`的矩阵起个名字：*C*看起来相当合理。
- en: Using *C*, we can break down the case that we want to clone |+〉 into the case
    in which we want to clone |0〉 plus the case in which we want to clone |1〉. We
    know that *C*|+0〉 = |++〉, but we also know that *C*|+0〉 = *C*(|00〉 + |10〉) / √2
    = (*C*|00〉 + *C*|10〉) / √2. Since `clone` needs to clone |0〉 and |1〉 as well as
    |+〉, we know that *C*|00〉 = |00〉 and *C*|10〉 = |11〉. That gives us that (*C*|00〉
    + *C*|10〉) / √2 = (|00〉 + |11〉) / √2, but we concluded earlier that *C*|+0〉 =
    |++〉 = (|00〉 + |01〉 + |10〉 + |11〉) / 2.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*C*，我们可以将我们要克隆|+〉的情况分解为我们要克隆|0〉的情况加上我们要克隆|1〉的情况。我们知道*C*|+0〉 = |++〉，但我们还知道*C*|+0〉
    = *C*(|00〉 + |10〉) / √2 = (*C*|00〉 + *C*|10〉) / √2。由于`clone`需要克隆|0〉、|1〉以及|+〉，我们知道*C*|00〉
    = |00〉和*C*|10〉 = |11〉。这给了我们(*C*|00〉 + *C*|10〉) / √2 = (|00〉 + |11〉) / √2，但我们之前得出结论，*C*|+0〉
    = |++〉 = (|00〉 + |01〉 + |10〉 + |11〉) / 2。
- en: We thus have a contradiction and can conclude that we went wrong at the very
    first step, where we assumed that `clone` could exist! Thus, we have shown the
    no-cloning theorem.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们遇到了矛盾，可以得出结论，我们在第一步就犯了错误，那时我们假设`clone`可以存在！因此，我们证明了不可克隆定理。
- en: One important thing to note from this argument is that we can always copy information
    from one qubit to another *if we know the right basis*. The problem came in when
    we didn’t know if we should copy information about |0〉 vs. |1〉 or |+〉 vs. |−〉,
    as we could copy either |0〉 or |+〉, but not both. This isn’t a problem classically,
    as we only ever have the computational basis to work with.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个论点中需要注意的一个重要问题是，如果我们知道正确的基，我们总能从一个量子位复制信息到另一个量子位。问题在于当我们不知道我们应该复制关于|0〉与|1〉还是|+〉与|−〉的信息时，因为我们可以复制|0〉或|+〉，但不能两者同时复制。在经典情况下这不是问题，因为我们只有计算基可以工作。
- en: Up to this point, we’ve used NumPy to write our qubit simulator, `SingleQubitSimulator()`.
    This is very helpful, as without NumPy, we’d need to write our own matrix analysis
    functions and methods. However, it is often convenient to rely on Python packages
    with special support for quantum concepts, building on the excellent numerical
    support provided by NumPy and SciPy (an extension to the NumPy numerical capabilities).
    In the next chapter, we will look at a Python package designed for quantum computing
    called QuTiP (Quantum Toolbox in Python), which will help us finish the upgrades
    to our simulator to simulate our CHSH game.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用NumPy来编写我们的量子位模拟器`SingleQubitSimulator()`。这非常有帮助，因为没有NumPy，我们就需要编写自己的矩阵分析函数和方法。然而，通常方便依赖于具有量子概念特殊支持的Python包，这些包建立在NumPy和SciPy（NumPy数值能力的扩展）提供的优秀数值支持之上。在下一章中，我们将探讨一个专为量子计算设计的Python包，称为QuTiP（Python中的量子工具箱），它将帮助我们完成模拟器的升级，以模拟我们的CHSH游戏。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Nonlocal games such as the CHSH game are experiments that can be used to check
    that quantum mechanics is consistent with how our universe actually works.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于CHSH游戏这样的非局域游戏是实验，可以用来验证量子力学与我们宇宙实际运作方式的一致性。
- en: It takes exponentially many classical bits to write the state of a quantum register,
    making it very hard to simulate more than about 30 qubits using traditional computers.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要用经典比特来表示量子寄存器的状态需要指数级数量的比特，这使得使用传统计算机模拟超过大约30个量子比特变得非常困难。
- en: We can combine single-qubit states together using the tensor product, allowing
    us to describe multi-qubit states.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用张量积将单量子比特状态组合在一起，从而能够描述多量子比特状态。
- en: Multi-qubit states that can’t be written by combining single-qubit states represent
    qubits that are *entangled* with each other.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法通过组合单量子比特状态来表示的多量子比特状态代表着相互**纠缠**的量子比特。
- en: '* * *'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^(1.)The name CHSH comes from the initials of the researchers who originally
    created the game: Clauser, Horne, Shimony, and Holt. You can find the original
    if you are interested: [https://journals.aps.org/prl/abstract/ 10.1103/PhysRevLett.23.880](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.23.880).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ^(1.)CHSH这个名字来源于最初创建这个游戏的四位研究者的首字母：Clauser, Horne, Shimony, 和 Holt。如果您感兴趣，可以找到原始文献：[https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.23.880](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.23.880)。
