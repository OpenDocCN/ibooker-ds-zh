- en: 5 Java concurrency fundamentals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 Java并发基础
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Concurrency theory
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发理论
- en: Block-structured concurrency
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块结构并发
- en: Synchronization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步
- en: The Java Memory Model (JMM)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java内存模型（JMM）
- en: Concurrency support in bytecode
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节码中的并发支持
- en: 'Java has two, mostly separate concurrency APIs: the older API, which is usually
    called *block-structured concurrency* or *synchronization-based concurrency* or
    even “classic concurrency,” and the newer API, which is normally referred to by
    its Java package name, `java.util.concurrent`.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Java有两个，主要独立的并发API：较老的API，通常被称为*块结构并发*或*基于同步的并发*，甚至“经典并发”，以及较新的API，通常通过其Java包名`java.util.concurrent`来引用。
- en: In this book, we’re going to talk about both approaches. In this chapter, we’ll
    begin our journey by looking at the first of these two approaches. After that,
    in the next chapter, we’ll introduce `java.util.concurrent`. Much later, we’ll
    return to the subject of concurrency in chapter 16, “Advanced Concurrent Programming,”
    which discusses advanced techniques, concurrency in non-Java JVM languages, and
    the interplay between concurrency and functional programming.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将讨论这两种方法。在本章中，我们将通过探讨这两种方法中的第一种方法开始我们的旅程。之后，在下一章中，我们将介绍 `java.util.concurrent`。稍后，我们将在第16章“高级并发编程”中回到并发主题，该章节讨论了高级技术、非Java
    JVM语言中的并发以及并发与函数式编程之间的相互作用。
- en: Let’s get started and meet the classic approach to concurrency. This was the
    only API available until Java 5\. As you might guess from the alternative name,
    “synchronization-based concurrency,” this is the language-level API that is built
    into the platform and depends upon the `synchronized` and `volatile` keywords.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，了解经典的并发方法。这是Java 5之前可用的唯一API。正如你可能从其备选名称“基于同步的并发”中猜到的，这是一个内置到平台中的语言级API，依赖于
    `synchronized` 和 `volatile` 关键字。
- en: It is a low-level API and can be somewhat difficult to work with, but it is
    very much worth understanding. It provides a solid foundation for the chapters
    later in the book that explain other types and aspects of concurrency.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个低级API，可能有些难以处理，但它非常值得理解。它为书中后续章节中解释其他并发类型和方面提供了坚实的基础。
- en: In fact, correctly reasoning about the other forms of concurrency is very difficult
    without at least a working knowledge of the low-level API and concepts that we
    will introduce in this chapter. As we encounter the relevant topics, we will also
    introduce enough theory to illuminate the other views of concurrency that we’ll
    discuss later in the book, including when we meet concurrency in non-Java languages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果没有至少对我们在本章中将要介绍的底层API和概念有实际了解，正确推理其他形式的并发是非常困难的。当我们遇到相关主题时，我们还将引入足够的理论来阐明我们在书中稍后讨论的其他并发观点，包括当我们遇到非Java语言中的并发时。
- en: To make sense of Java’s approach to concurrent programming, we’re going to start
    off by talking about a small amount of theory. After that, we’ll discuss the impact
    that “design forces” have in the design and implementation of systems. We’ll talk
    about the two most important of these forces, *safety* and *liveness*, and mention
    some of the others.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解Java的并发编程方法，我们将从讨论一些理论开始。之后，我们将讨论“设计力量”在设计实现系统中的影响。我们将讨论其中两个最重要的力量，*安全性*和*活性*，并提及一些其他的力量。
- en: An important section (and the longest one in the chapter) is the detail of block-structured
    concurrency and an exploration of the low-level threading API. We’ll conclude
    this chapter by discussing the Java Memory Model (JMM), and then using the bytecode
    techniques that we learned in chapter 4 to understand the real source of some
    common complexities in concurrent Java programming.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的部分（也是本章中最长的一个部分）是关于块结构并发和底层线程API的细节。我们将通过讨论Java内存模型（JMM）来结束本章，然后使用我们在第4章中学到的字节码技术来理解并发Java编程中一些常见复杂性的真正来源。
- en: 5.1 Concurrency theory primer
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 并发理论入门
- en: Let’s get started on our journey into concurrency with a cautionary tale before
    we meet some basic theory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们遇到一些基本理论之前，让我们用一个警示故事开始我们的并发之旅。
- en: 5.1.1 But I already know about Thread
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 但我已经知道关于线程的知识
- en: 'It’s one of the most common (and potentially deadly) mistakes a developer can
    make: to assume that an acquaintance with `Thread`, `Runnable`, and the language-level
    basic primitives of Java’s concurrency mechanism are enough to be a competent
    developer of concurrent code. In fact, the subject of concurrency is a large one,
    and good multithreaded development is difficult and continues to cause problems
    for even the best developers with years of experience under their belts.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是开发者可能犯的最常见（并且可能致命）的错误之一：认为对 `Thread`、`Runnable` 和 Java 并发机制的语言级基本原语有所了解就足以成为一个合格的并发代码开发者。实际上，并发是一个很大的主题，良好的多线程开发困难重重，即使是经验丰富的开发者也会遇到问题。
- en: It is also true that the area of concurrency is undergoing a massive amount
    of active research at present—this has been going on for at least the last 5–10
    years and shows no signs of abating. These innovations are likely to have an impact
    on Java and the other languages you’ll use over the course of your career.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，并发领域目前正在进行大量的活跃研究——这至少已经持续了5-10年，并且没有减缓的迹象。这些创新可能会对 Java 以及您在职业生涯中使用的其他语言产生影响。
- en: 'In the first edition of this book, we made the following claim: “If we were
    to pick one fundamental area of computing that’s likely to change radically in
    terms of industry practice over the next five years, it would be concurrency.”
    Not only has history borne out this claim, but we feel comfortable rolling this
    prediction forward—the next five years will see a continued emphasis on the different
    approaches to concurrency that are now part of the programming landscape.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一版中，我们提出了以下观点：“如果我们选择一个可能在五年内彻底改变行业实践的计算机计算基本领域，那么这个领域将是并发。”历史已经证实了这一观点，我们感到很舒服地将这个预测向前推进——接下来的五年将继续强调编程景观中现在已经是并发不同方法的重点。
- en: So, rather than try to be a definitive guide to every aspect of concurrent programming,
    the aim of this chapter is to make you aware of the underlying platform mechanisms
    that explain why Java’s concurrency works the way it does. We’ll also cover enough
    general concurrency theory to give you the vocabulary to understand the issues
    involved and to teach you about both the necessity and the difficulty involved
    in getting concurrency right. First, we’ll discuss what every well-grounded Java
    developer should know about hardware and one of the most important theoretical
    limitations of concurrency.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，而不是试图成为并发编程每个方面的权威指南，本章的目标是让您了解解释 Java 并发工作方式的底层平台机制。我们还将涵盖足够的通用并发理论，以便您能够理解涉及的问题，并教授您在正确实现并发时所需的知识和难度。首先，我们将讨论每个扎实的
    Java 开发者都应该了解的关于硬件和并发最重要的理论限制。
- en: 5.1.2 Hardware
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 硬件
- en: 'Let’s start with some basic facts about concurrency and multithreading:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从并发和多线程的一些基本事实开始：
- en: Concurrent programming is fundamentally about performance.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发编程在本质上关乎性能。
- en: There are basically no good reasons for implementing a concurrent algorithm
    if the system you are running on has sufficient performance that a serial algorithm
    will work.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您运行的系统性能足够，以至于串行算法也能工作，那么实现并发算法基本上没有很好的理由。
- en: Modern computer systems have multiple processing cores—even mobile phones have
    two or four cores today.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代计算机系统具有多个处理核心——即使是现在的手机也有两个或四个核心。
- en: All Java programs are multithreaded, even those that have only a single application
    thread.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 Java 程序都是多线程的，即使那些只有单个应用程序线程的程序也是如此。
- en: This last point is true because the JVM is itself a multithreaded binary that
    can use multiple cores (e.g., for JIT compilation or garbage collection). In addition,
    the standard library also includes APIs that use *runtime-managed concurrency*
    to implement multithreaded algorithms for some execution tasks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一个观点是正确的，因为 JVM 本身就是一个多线程的二进制文件，可以使用多个核心（例如，用于 JIT 编译或垃圾回收）。此外，标准库还包括使用 *运行时管理的并发*
    来实现某些执行任务的并发算法的 API。
- en: Note It is entirely possible that a Java application will run *faster* just
    by upgrading the JVM it runs on, due to performance improvements in the runtime.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Java 应用程序仅通过升级其运行的 JVM，就有可能因为运行时的性能改进而运行得更快。
- en: A fuller discussion of hardware takes place in chapter 7, but these basic facts
    are so fundamental and so relevant to concurrent programming that we want to introduce
    them immediately.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关于硬件的更详细讨论将在第7章进行，但这些基本事实是如此基础且与并发编程如此相关，我们希望立即介绍它们。
- en: Now let’s meet *Amdahl’s law*, named after an early IBM computer scientist,
    Gene Amdahl, sometimes called the “father of the mainframe.”
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来认识一下*Amdahl定律*，它是以早期IBM计算机科学家、Gene Amdahl的名字命名的，有时被称为“大型机之父”。
- en: 5.1.3 Amdahl’s law
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 Amdahl定律
- en: This is a simple, rough-and-ready model for reasoning about the efficiency of
    sharing work over multiple execution units. In the model, the execution units
    are abstract, so you can think of them as threads, but they could also be processes,
    or any other entity that is capable of carrying out work.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的、现成的模型，用于推理在多个执行单元之间共享工作的效率。在这个模型中，执行单元是抽象的，所以你可以把它们看作是线程，但它们也可能是进程，或者任何其他能够执行工作的实体。
- en: Note None of the setup for or consequences of Amdahl’s law depend on the details
    of how the work is done or the precise nature of the execution units or how the
    computing systems are implemented.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Amdahl定律的设置或后果的细节并不取决于工作是如何完成的，或者执行单元的确切性质，或者计算系统是如何实现的。
- en: The basic premise is that we have a single task that can be subdivided into
    smaller units for processing. This allows us to use multiple execution units to
    speed up the time taken to complete the work.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基本前提是我们有一个可以拆分成更小处理单元的单个任务。这使我们能够使用多个执行单元来加快完成工作的时间。
- en: So, if we have `N` processors (or threads to do the work), then we might naively
    expect the elapsed time to be `T1 / N` (if `T1` is the time the job would take
    on a single processor). In this model, we can finish the job as quickly as we
    like by just adding execution units and thereby increasing `N`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们有`N`个处理器（或线程来完成工作），那么我们可能会天真地期望经过的时间是`T1 / N`（如果`T1`是单个处理器完成工作所需的时间）。在这个模型中，我们可以通过添加执行单元并增加`N`来尽快完成工作。
- en: However, splitting up the work is not free! A (hopefully small) overhead is
    involved in the subdividing and recombination of the task. Let’s assume that this
    *communication overhead* (sometime called the *serial part* of the calculation)
    is an overhead that amounts to a few percent, and we can represent it by a number
    `s` (0 < `s` < 1). So, a typical value for `s` might be `0.05` (or 5%, whichever
    way you’d prefer to express it). This means that the task will always take at
    least `s * T1` to complete—no matter how many processing units we throw at it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将工作拆分并非没有代价！在任务的细分和重组过程中，会涉及到一个（希望是小的）额外开销。让我们假设这个*通信开销*（有时称为计算的*串行部分*）是一个相当于几个百分比的额外开销，我们可以用数字`s`（0
    < `s` < 1）来表示它。因此，`s`的典型值可能是`0.05`（或5%，您喜欢哪种表达方式都可以）。这意味着任务将始终至少需要`s * T1`的时间来完成——无论我们投入多少处理单元。
- en: This assumes that `s` does not depend upon `N`, of course, but in practice,
    the dividing up of work that `s` represents may get more complex and require *more*
    time as `N` increases. It is extremely difficult to conceive of a system architecture
    in which `s` *decreases* as `N` increases. So the simple assumption of “`s` is
    constant” is usually understood to be a *best-case* scenario.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设`s`不依赖于`N`，当然，但在实践中，`s`所代表的任务拆分可能会变得更加复杂，并且随着`N`的增加需要更多的时间。很难想象一个系统架构，其中`s`随着`N`的增加而减少。因此，“`s`是常数”的简单假设通常被理解为一种*最佳情况*情景。
- en: 'So, the easiest way to think about Amdhal’s law is: if `s` is between 0 and
    1, then the maximum speedup that can be achieved is `1 / s`. This result is somewhat
    depressing—it means that if the communication overhead is just 2%, the maximum
    speedup that can ever be achieved (even with thousands of processors working at
    full speed) is 50X.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，思考Amdahl定律的最简单方法是：如果`s`在0和1之间，那么可以达到的最大加速比是`1 / s`。这个结果有些令人沮丧——这意味着如果通信开销仅为2%，那么可以实现的最高加速比（即使有成千上万的处理器以全速工作）也只有50倍。
- en: 'Amdahl’s law has a slightly more complex formulation, which is represented
    like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Amdahl定律有一个稍微复杂一些的公式，表示如下：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This can be seen visually in figure 5.1\. Note that the *x*-axis is a logarithmic
    scale—the convergence to `1 / s` would be very hard to see in a linear scale representation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这在图5.1中可以直观地看到。注意，*x*轴是对数刻度——在线性刻度表示中，收敛到`1 / s`将非常难以看到。
- en: '![](../Images/CH05_F01_Evans2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F01_Evans2.png)'
- en: Figure 5.1 Amdahl’s law
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 Amdahl定律
- en: Having set the scene with hardware and a first, very simple concurrency model,
    let’s dive into the specifics of how Java handles threading.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件和第一个非常简单的并发模型的基础上设定了场景后，让我们深入了解Java如何处理线程的具体细节。
- en: 5.1.4 Explaining Java’s threading model
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.4 解释Java的线程模型
- en: 'Java’s threading model is based on the following two fundamental concepts:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Java的线程模型基于以下两个基本概念：
- en: Shared, visible-by-default mutable state
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下可见的共享可变状态
- en: Preemptive thread scheduling by the operating system
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统执行的抢占式线程调度
- en: 'Let’s consider the following most important aspects of these ideas:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这些想法最重要的几个方面：
- en: Objects can be easily shared between all threads within a process.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象可以很容易地在进程内的所有线程之间共享。
- en: Objects can be changed (“mutated”) by any threads that have a reference to them.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象可以被任何持有其引用的线程所改变（“变异”）。
- en: The thread scheduler (the operating system) can swap threads on and off cores
    at any time, more or less.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程调度器（操作系统）可以在任何时候在核心之间切换线程，或多或少。
- en: Methods must be able to be swapped out while they’re running (otherwise, a method
    with an infinite loop would steal the CPU forever).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法必须在运行时能够被替换出来（否则，一个无限循环的方法将永远占用CPU）。
- en: This, however, runs the risk of an unpredictable thread swap, leaving a method
    “half-done” and an object in an inconsistent state.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，这存在不可预测的线程交换风险，导致方法“半完成”和对象处于不一致的状态。
- en: Objects can be *locked* to protect vulnerable data.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象可以被*锁定*以保护易受攻击的数据。
- en: The last point is absolutely crucial—without it there is a huge risk of changes
    being made in one thread not being seen correctly in other threads. In Java, the
    ability to lock objects is provided by the `synchronized` keyword in the core
    language.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点至关重要——没有它，一个线程中做出的更改在其他线程中可能无法正确看到。在Java中，通过核心语言中的`synchronized`关键字提供了锁定对象的能力。
- en: Note Technically, Java provides *monitors* on each of its objects, which combine
    a lock (aka mutual exclusion) with the ability to wait for a certain condition
    to become true.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：从技术上讲，Java为每个对象提供了*监视器*，它将锁（也称为互斥）与等待某个条件变为真的能力结合起来。
- en: Java’s thread-and-lock-based concurrency is very low level and often hard to
    work with. To cope with this, a set of concurrency libraries, known as `java.util.concurrent`
    after the Java package where the new classes live, was introduced in Java 5\.
    This provided a set of tools for writing concurrent code that many programmers
    find easier to use than the classic block-structured concurrency primitives. We
    will discuss `java .util.concurrent` in the next chapter and will focus on the
    language-level API for now.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Java基于线程和锁的并发性非常低级，通常很难处理。为了应对这种情况，引入了一套名为`java.util.concurrent`的并发库，这个名字来源于新类所在的新Java包。这提供了一套编写并发代码的工具，许多程序员发现这些工具比经典的块结构并发原语更容易使用。我们将在下一章讨论`java.util.concurrent`，现在我们将专注于语言级别的API。
- en: 5.1.5 Lessons learned
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.5 得到的教训
- en: Java was the first mainstream programming language to have built-in support
    for multithreaded programming. This represented a huge step forward at the time,
    but now, 15 years later, we’ve learned a lot more about how to write concurrent
    code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Java是第一个主流支持多线程编程的语言。这在当时是一个巨大的进步，但现在，15年后，我们关于如何编写并发代码的了解更多了。
- en: It turns out that some of Java’s initial design decisions are quite difficult
    for most programmers to work with. This is unfortunate, because the increasing
    trend in hardware is toward processors with many cores, and the only good way
    to take advantage of those cores is with concurrent code. We’ll discuss some of
    the difficulties of concurrent code in this chapter. The subject of modern processors
    naturally requiring concurrent programming is covered in some detail in chapter
    7 where we discuss performance.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，Java的一些初始设计决策对于大多数程序员来说相当难以处理。这是不幸的，因为硬件的趋势正在向多核处理器发展，而利用这些核心的唯一好方法就是使用并发代码。在本章中，我们将讨论并发代码的一些困难。现代处理器自然需要并发编程的主题在第7章中进行了详细讨论，其中我们讨论了性能。
- en: As developers become more experienced with writing concurrent code, they find
    themselves running up against recurring concerns that are important to their systems.
    We call these concerns *design forces*. They’re high-level concepts that exist
    (and often conflict) in the design of practical concurrent OO systems. We’re going
    to spend a little bit of time looking at some of the most important of these forces
    in the next couple of sections.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发者对编写并发代码经验的增加，他们发现自己遇到了一些反复出现且对其系统重要的关注点。我们把这些关注点称为*设计力*。它们是存在于（并且通常相互冲突）实际并发面向对象系统设计中的高级概念。在接下来的几节中，我们将花一些时间来探讨一些最重要的这些力。
- en: 5.2 Design concepts
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 设计概念
- en: 'The most important design forces, listed next, were catalogued by Doug Lea
    as he was doing his landmark work producing `java.util.concurrent`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下列最重要的设计力是由Doug Lea在他进行标志性的工作生产`java.util.concurrent`时编目：
- en: Safety (also known as *concurrent type safety*)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性（也称为*并发类型安全*）
- en: Liveness
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活跃性
- en: Performance
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: Reusability
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可复用性
- en: Let’s look at each of these forces now.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来看看这些力。
- en: 5.2.1 Safety and concurrent type safety
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 安全性和并发类型安全
- en: Safety is about ensuring that object instances remain self-consistent, regardless
    of any other operations that may be happening at the same time. If a system of
    objects has this property, it’s said to be *safe* or *concurrently typesafe*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是确保对象实例在同时发生的任何其他操作中保持自洽性的问题。如果一个对象系统具有这种属性，那么它就被说成是*安全*或*并发类型安全*。
- en: As you might guess from the name, one way to think about concurrency is in terms
    of an extension to the regular concepts of object modeling and type safety. In
    nonconcurrent code, you want to ensure that regardless of what public methods
    you call on an object, it’s in a well-defined and consistent state at the end
    of the method. The usual way to do this is to keep all of an object’s state private
    and expose a public API of methods that alter the object’s state only in a way
    that makes senses for the design domain.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜测的，思考并发的一种方式是将它视为对常规对象建模和类型安全概念的扩展。在非并发代码中，你希望确保无论在对象上调用哪些公共方法，方法结束时对象都处于一个定义良好且一致的状态。通常的做法是将对象的所有状态保持为私有，并公开一个仅以对设计域有意义的方修改对象状态的公共API。
- en: 'Concurrent type safety is the same basic concept as type safety for an object,
    but applied to the much more complex world in which other threads are potentially
    operating on the same objects on different CPU cores at the same time. For example,
    consider this simple class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 并发类型安全与对象类型安全的基本概念相同，但应用于一个更为复杂的场景，即其他线程可能同时在不同的CPU核心上操作相同的对象。例如，考虑以下简单的类：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When used by single-threaded client code, this is fine. However, preemptive
    thread scheduling can cause problems. For example, a context switch between execution
    threads can occur at this point in the code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当由单线程客户端代码使用时，这是没有问题的。然而，抢占式线程调度可能会引起问题。例如，在代码的此点可能会发生执行线程之间的上下文切换：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The object is left in an inconsistent and incorrect state.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对象被留在不一致和不正确的状态。
- en: If the object is then viewed from another thread, one part of the state (`values`)
    will have been updated but the other (`current`) will not. Exploring, and solving,
    this problem is the primary theme of this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从另一个线程查看该对象，状态的一部分（`values`）已经被更新，而另一部分（`current`）则没有。探索和解决这个问题是本章的主要主题。
- en: In general, one strategy for safety is to never return from a nonprivate method
    in an inconsistent state, and to never call any nonprivate method (and certainly
    not a method on any other object) while in an inconsistent state. If this practice
    is combined with a way of protecting the object (such as a synchronization lock
    or critical section) while it’s inconsistent, the system can be guaranteed to
    be safe.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一种确保安全性的策略是永远不要在非私有方法中返回不一致的状态，并且永远不要在不一致的状态下调用任何非私有方法（当然，更不要调用任何其他对象的方法）。如果这种做法与一种在对象不一致时保护对象的方式（如同步锁或临界区）相结合，则可以保证系统是安全的。
- en: 5.2.2 Liveness
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 活跃性
- en: A live system is one in which every attempted activity eventually either progresses
    or fails. A system that is not live is basically stuck—it will neither progress
    toward success or fail.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个活跃的系统是指每个尝试的活动最终要么进展，要么失败。一个不活跃的系统基本上是停滞的——它既不会向成功进展，也不会失败。
- en: The keyword in the definition is *eventually*—there is a distinction between
    a transient failure to progress (which isn’t that bad in isolation, even if it’s
    not ideal) and a permanent failure. Transient failures could be caused by a number
    of underlying problems, such as
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 定义中的关键字是*最终*——暂时性故障（即使它不是理想的，孤立地看也不是那么糟糕）和永久性故障之间有一个区别。暂时性故障可能由许多潜在问题引起，例如
- en: Locking or waiting to acquire a lock
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定或等待获取锁
- en: Waiting for input (such as network I/O)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待输入（例如，网络I/O）
- en: Temporary failure of a resource
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源的暂时性故障
- en: Not enough CPU time available to run the thread
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的CPU时间不足以运行线程
- en: 'Permanent failures could be due to a number of causes. Some of the most common
    follow:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 永久性故障可能由多种原因引起。以下是一些最常见的原因：
- en: Deadlock
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死锁
- en: Unrecoverable resource problem (such as if the network filesystem [NFS] goes
    away)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可恢复的资源问题（例如，如果网络文件系统 [NFS] 不可用）
- en: Missed signal
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢失信号
- en: We’ll discuss locking and several of these other problems later in the chapter,
    although you may already be familiar with some or all of them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论锁定和这些问题中的几个，尽管你可能已经熟悉其中的一些或全部。
- en: 5.2.3 Performance
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 性能
- en: The performance of a system can be quantified in a number of different ways.
    In chapter 7, we’ll talk about performance analysis and techniques for tuning,
    and we’ll introduce a number of other metrics you should know about. For now,
    think of performance as being a measure of how much work a system can do with
    a given amount of resources.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的性能可以通过多种方式量化。在第7章中，我们将讨论性能分析和调优技术，并介绍一些你应该了解的其他指标。现在，将性能视为系统在给定资源下能完成多少工作的度量。
- en: 5.2.4 Reusability
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 可重用性
- en: Reusability forms a fourth design force, because it isn’t really covered by
    any of the other considerations. A concurrent system that has been designed for
    easy reuse is sometimes very desirable, although this isn’t always easy to implement.
    One approach is to use a reusable toolbox (like `java.util.concurrent`) and build
    nonreusable application code on top of it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可重用性形成第四个设计力，因为它并没有被其他任何考虑所涵盖。一个为易于重用而设计的并发系统有时是非常理想的，尽管这并不总是容易实现。一种方法是在可重用工具箱（如`java.util.concurrent`）上构建不可重用的应用程序代码。
- en: 5.2.5 How and why do the forces conflict?
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.5 如何以及为什么力会冲突？
- en: 'The design forces are often in opposition to each other, and this tension can
    be viewed as a central reason that designing good concurrent systems is difficult,
    as explained by the following points:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设计力往往是相互对立的，这种紧张关系可以被视为设计良好的并发系统困难的一个核心原因，如下所述：
- en: Safety stands in opposition to liveness—safety is about ensuring that bad things
    don’t happen, whereas liveness requires progress to be made.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性与活跃性相对立——安全性是确保坏事不会发生，而活跃性要求取得进展。
- en: Reusable systems tend to expose their internals, which can cause problems with
    safety.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用系统倾向于暴露其内部结构，这可能会引起安全问题。
- en: A naïvely written safe system will typically not be very performant, because
    it usually resorts to heavy use of locking to provide safety guarantees.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个天真编写的安全系统通常不会非常高效，因为它通常依赖于大量使用锁定来提供安全保证。
- en: 'The balance that you should ultimately try to achieve is for the code to be
    flexible enough to be useful for a wide range of problems, closed enough to be
    safe, and still reasonably live and performant. This is quite a tall order, but,
    fortunately, some practical techniques can help with this. Here are some of the
    most common in rough order of usefulness:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终应该努力达到的平衡是代码足够灵活，可以用于广泛的问题，足够封闭以确保安全，同时仍然合理活跃和高效。这是一项相当艰巨的任务，但幸运的是，一些实用的技术可以帮助实现这一点。以下是一些最常见的，按有用性大致排序：
- en: Restrict the external communication of each subsystem as much as possible. Data
    hiding is a powerful tool for aiding with safety.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽可能限制每个子系统的外部通信。数据隐藏是帮助确保安全的有力工具。
- en: Make the internal structure of each subsystem as deterministic as possible.
    For example, design in static knowledge of the threads and objects in each subsystem,
    even if the subsystems will interact in a concurrent, nondeterministic way.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽可能使每个子系统的内部结构尽可能确定。例如，设计时考虑每个子系统中的线程和对象，即使子系统将以并发和非确定性的方式进行交互。
- en: Apply policy approaches that client apps must adhere to. This technique is powerful
    but relies on user apps cooperating, and it can be hard to debug if a badly behaved
    app disobeys the rules.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用客户端应用程序必须遵守的策略方法。这种技术很强大，但依赖于用户应用程序的合作，如果表现不佳的应用程序不遵守规则，调试可能会很困难。
- en: Document the required behavior. This is the weakest of the alternatives, but
    it’s sometimes necessary if the code is to be deployed in a very general context.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录所需的行为。这是所有替代方案中最弱的，但有时如果代码要在非常通用的环境中部署，这是必要的。
- en: The developer should be aware of each of these possible safety mechanisms and
    should use the strongest possible technique, while being aware that in some circumstances,
    only the weaker mechanisms are possible.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者应该了解这些可能的安全机制中的每一个，并应使用最强可能的技巧，同时意识到在某些情况下，可能只能使用较弱的机制。
- en: 5.2.6 Sources of overhead
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.6 开销来源
- en: 'Many aspects of a concurrent system can contribute to the inherent overhead:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 并发系统的许多方面都可能对固有的开销做出贡献：
- en: Monitors (i.e., locks and condition variables)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视器（即，锁和条件变量）
- en: Number of context switches
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文切换次数
- en: Number of threads
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程数量
- en: Scheduling
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度
- en: Locality of memory
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存局部性
- en: Algorithm design
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法设计
- en: This should form the basis of a checklist in your mind. When developing concurrent
    code, you should ensure that you have thought about everything on this list.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该成为你心中的清单基础。在开发并发代码时，你应该确保你已经考虑了清单上的每一项。
- en: In particular, the last of these—algorithm design—is an area in which developers
    can really distinguish themselves, because learning about algorithm design will
    make you a better programmer in any language.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，这些中的最后一个是算法设计，这是开发者可以真正脱颖而出的一块领域，因为了解算法设计将使你在任何语言中都能成为更好的程序员。
- en: Two standard texts (highly recommended by the authors) are *Introduction to
    Algorithms* by Cormen et al. (MIT, 2009)—don’t be deceived by the title; this
    is a serious work—and *The Algorithm Design Manual* (3rd ed.), by Skiena (Springer-Verlag,
    2020). For both single-threaded and concurrent algorithms, these books are excellent
    choices for further reading.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 两本标准文本（作者强烈推荐）是Cormen等人所著的《算法导论》（MIT，2009年）——不要被标题所欺骗；这是一部严肃的作品——以及Skiena所著的《算法设计手册》（第3版，Springer-Verlag，2020年）。对于单线程和并发算法，这些书都是进一步阅读的绝佳选择。
- en: 'We’ll mention many of these sources of overhead in this chapter and the subsequent
    ones (especially chapter 7, about performance), but now let’s turn to our next
    subject: a review of Java’s “classic” concurrency and a close look at why programming
    with it can be difficult.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章和随后的章节（特别是关于性能的第7章）中提到许多这些开销的来源，但现在让我们转向下一个主题：对Java的“经典”并发进行回顾，并深入了解为什么使用它编程可能会很困难。
- en: 5.3 Block-structured concurrency (pre-Java 5)
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 块结构并发（Java 5之前）
- en: Much of our coverage of Java concurrency is about discussing alternatives to
    the language-level, aka block-synchronization-based, aka *intrinsic* approach
    to concurrency. But to get the most out of the discussion of the alternatives,
    it’s important to have a firm grasp of what’s good and bad about the classic view
    of concurrency.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于Java并发的许多内容都是关于讨论语言级别、即基于块同步的、即*内在*的并发方法之外的替代方案。但为了最大限度地发挥对替代方案的讨论，了解经典并发观点的优缺点非常重要。
- en: To that end, for the rest of this chapter, we’ll discuss the original, quite
    low-level way of tackling multithreaded programming using Java’s concurrency keywords—`synchronized`,
    `volatile`, and so on. This discussion will take place in the context of the design
    forces and with an eye to what will come later on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章的剩余部分，我们将讨论使用Java的并发关键字（如`synchronized`、`volatile`等）处理多线程编程的原始、相当低级的方法。这次讨论将在设计力量和关注未来将发生什么的背景下进行。
- en: Following on from that, we’ll briefly consider the life cycle of a thread and
    then discuss common techniques (and pitfalls) of concurrent code, such as fully
    synchronized objects, deadlocks, the volatile keyword, and immutability. Let’s
    get started with an overview of synchronization.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们将简要考虑线程的生命周期，然后讨论并发代码的常见技术（以及陷阱），例如完全同步的对象、死锁、`volatile`关键字和不可变性。让我们从同步的概述开始。
- en: 5.3.1 Synchronization and locks
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 同步和锁
- en: 'As you probably already know, the `synchronized` keyword can be applied either
    to a block or to a method. It indicates that before entering the block or method,
    a thread must acquire the appropriate lock. For example, let’s think about a method
    to withdraw money from a bank account, as shown next:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，`synchronized`关键字可以应用于代码块或方法。它表示在进入代码块或方法之前，线程必须获取适当的锁。例如，让我们考虑一个从银行账户提取资金的示例方法，如下所示：
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Only one thread can try to withdraw from this account at once.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 同时只能有一个线程尝试从这个账户中提取资金。
- en: The method must acquire the lock belonging to the object instance (or the lock
    belonging to the `Class` object for `static synchronized` methods). For a block,
    the programmer should indicate which object’s lock is to be acquired.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 方法必须获取对象实例所属的锁（或`static synchronized`方法所属的`Class`对象的锁）。对于代码块，程序员应指明要获取哪个对象的锁。
- en: Only one thread can be progressing through any of an object’s synchronized blocks
    or methods at once; if other threads try to enter, they’re suspended by the JVM.
    This is true regardless of whether the other thread is trying to enter the same
    or a different synchronized block on the same object. In concurrency theory, this
    type of construct is sometimes referred to as a *critical section*, but this term
    is more commonly used in C++ than in Java.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 同时只能有一个线程可以进入对象的所有同步块或方法之一；如果其他线程尝试进入，它们将被JVM挂起。无论其他线程是尝试进入同一对象上的相同或不同的同步块，还是尝试进入不同对象上的同步块，这都是正确的。在并发理论中，这种结构有时被称为*临界区*，但这个术语在C++中比在Java中更常用。
- en: Note Have you ever wondered why the Java keyword used for a critical section
    is `synchronized`? Why not “critical” or “locked”? What is it that’s being *synchronized*
    ? We’ll return to this in section 5.3.5, but if you don’t know or have never thought
    about it, you may want to take a couple of minutes to ponder it before continuing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你是否曾经想过为什么Java用于临界区的关键字是`synchronized`？为什么不叫“critical”或“locked”？正在被什么同步？我们将在5.3.5节中回到这个问题，但如果你不知道或者从未想过这个问题，你可能想在继续之前花几分钟思考一下。
- en: 'Let’s look at some basic facts about synchronization and locks in Java. Hopefully
    you already have most (or all) of these at your fingertips:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看关于Java中同步和锁的一些基本事实。希望你已经掌握了这些（或大部分）：
- en: Only objects—not primitives—can be locked.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有对象——而不是原始数据类型——可以被锁定。
- en: Locking an array of objects doesn’t lock the individual objects.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定对象数组不会锁定单个对象。
- en: A synchronized method can be thought of as equivalent to a `synchronized (this)
    { ... }` block that covers the entire method (but note that they’re represented
    differently in bytecode).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将同步方法视为等同于一个覆盖整个方法的 `synchronized (this) { ... }` 块（但请注意，它们在字节码中的表示方式不同）。
- en: A `static synchronized` method locks the `Class` object, because there’s no
    instance object to lock.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static synchronized`方法锁定`Class`对象，因为没有实例对象可以锁定。'
- en: If you need to lock a `Class` object, consider carefully whether you need to
    do so explicitly or by using `getClass()`, because the behavior of the two approaches
    will be different in a subclass.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要锁定`Class`对象，仔细考虑你是否需要显式地这样做，或者使用`getClass()`，因为这两种方法在子类中的行为将不同。
- en: Synchronization in an inner class is independent of the outer class (to see
    why this is so, remember how inner classes are implemented).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部类的同步与外部类无关（要了解为什么是这样，请记住内部类是如何实现的）。
- en: '`synchronized` doesn’t form part of the method signature, so it can’t appear
    on a method declaration in an interface.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synchronized`不是方法签名的一部分，因此它不能出现在接口的方法声明中。'
- en: Unsynchronized methods don’t look at or care about the state of any locks, and
    they can progress while synchronized methods are running.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未同步的方法不会查看或关心任何锁的状态，并且它们可以在同步方法运行时继续执行。
- en: Java’s locks are reentrant—a thread holding a lock that encounters a synchronization
    point for the same lock (such as a `synchronized` method calling another `synchronized`
    method on the same object) will be allowed to continue.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java的锁是可重入的——持有锁的线程遇到同一锁的同步点（例如，一个`synchronized`方法在同一个对象上调用另一个`synchronized`方法）将被允许继续执行。
- en: Note Non-reentrant locking schemes do exist in other languages (and can be synthesized
    in Java—see the detail of the Javadoc for `ReentrantLock` in `java.util.concurrent.locks`
    if you want the gory details), but they’re generally painful to deal with, and
    they’re best avoided unless you really know what you’re doing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：非可重入锁定方案在其他语言中确实存在（也可以在Java中实现——如果你想知道详细情况，请参阅`java.util.concurrent.locks`中`ReentrantLock`的Javadoc），但它们通常很难处理，最好避免使用，除非你真的知道自己在做什么。
- en: That’s enough review of Java’s synchronization. Now let’s move on to discuss
    the states that a thread moves through during its life cycle.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java的同步性，我们已经足够回顾了。现在让我们继续讨论线程在其生命周期中移动到的状态。
- en: 5.3.2 The state model for a thread
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 线程的状态模型
- en: In figure 5.2, you can see the state model for a Java thread. This governs how
    a Java thread progresses through its life cycle.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在图5.2中，你可以看到Java线程的状态模型。这决定了Java线程在其生命周期中的进展方式。
- en: '![](../Images/CH05_F02_Evans2.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 Java线程的状态模型](../Images/CH05_F02_Evans2.png)'
- en: Figure 5.2 The state model of a Java thread
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 Java线程的状态模型
- en: Java has an enum called `Thread.State`, which corresponds to the states in the
    above state mode and is a layer over the operating system’s view of the thread
    state.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Java有一个名为`Thread.State`的枚举，它对应于上述状态模型，并且是在操作系统对线程状态的视图之上的一层。
- en: Note Every operating system has its own version of threads, and they may differ
    in the precise details. In most cases, modern operating systems have reasonably
    similar thread and scheduling implementations, but this was not always the case
    (e.g., Solaris or Windows XP).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：每个操作系统都有自己的线程版本，它们可能在细节上有所不同。在大多数情况下，现代操作系统具有相当相似的线程和调度实现，但这种情况并非总是如此（例如，Solaris或Windows
    XP）。
- en: A Java thread object is initially created in the `NEW` state. At this time,
    an OS thread does not yet exist (and may never exist). To create the execution
    thread, `Thread.start()` must be called. This signals the OS to actually create
    a thread.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Java线程对象最初处于`NEW`状态。此时，操作系统线程尚不存在（可能永远不存在）。要创建执行线程，必须调用`Thread.start()`。这会向操作系统发出创建线程的信号。
- en: The scheduler will place the new thread into the run queue and, at some later
    point, will find a core for it to run upon (some amount of waiting time may be
    involved if the machine is heavily loaded). From there, the thread can proceed
    by consuming its time allocation and be placed back into the run queue to await
    further processor time slices. This is the action of the forcible thread scheduling
    that we mentioned in section 5.1.1.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器将新线程放入运行队列，并在稍后的某个时刻找到一个运行它的核心（如果机器负载很重，可能涉及一些等待时间）。从那里，线程可以通过消耗其时间分配继续执行，并被放回运行队列以等待进一步的处理器时间片。这是我们第5.1.1节中提到的强制线程调度的动作。
- en: 'Throughout this scheduling process, of being placed on a core, running, and
    being placed back in the run queue, the Java `Thread` object remains in the `RUNNABLE`
    state. As well as this scheduling action, the thread itself can indicate that
    it isn’t able to make use of the core at this time. This can be achieved in two
    different ways:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个调度过程中，即被放置在核心上、运行，然后被放回运行队列中，Java `Thread`对象始终处于`RUNNABLE`状态。除了这个调度动作外，线程本身还可以表明它现在无法使用核心。这可以通过两种不同的方式实现：
- en: The program code indicates by calling `Thread.sleep()` that the thread should
    wait for a fixed time before continuing.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序代码通过调用`Thread.sleep()`来指示线程应在继续之前等待固定的时间。
- en: The thread recognizes that it must wait until some external condition has been
    met and calls `Object.wait()`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程意识到它必须等待直到某个外部条件得到满足，并调用`Object.wait()`。
- en: In both cases, the thread is immediately removed from the core by the OS. However,
    the behavior after that point is different in each case.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，线程都会立即被操作系统从核心中移除。然而，从那时起的行为在每个情况下都是不同的。
- en: In the first case, the thread is asking to sleep for a definite amount of time.
    The Java thread transitions into the `TIMED_WAITING` state, and the operating
    system sets a timer. When it expires, the sleeping thread is woken up and is ready
    to run again and is placed back in the run queue.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，线程请求睡眠一定的时间。Java线程进入`TIMED_WAITING`状态，操作系统设置一个计时器。当计时器到期时，睡眠的线程被唤醒，并准备好再次运行，并被放回运行队列。
- en: The second case is slightly different. It uses the condition aspect of Java’s
    per-object monitors. The thread will transition into `WAITING` and will wait indefinitely.
    It will not normally wake up until the operating system signals that the condition
    may have been met—usually by some other thread calling `Object.notify()` on the
    current object.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况略有不同。它使用了Java对象监视器的条件方面。线程将进入`WAITING`状态并无限期等待。它通常不会在操作系统发出条件可能已满足的信号之前醒来——通常是通过其他线程在当前对象上调用`Object.notify()`来实现的。
- en: 'As well as these two possibilities that are under the threads control, a thread
    can transition into the `BLOCKED` state because it’s waiting on I/O or to acquire
    a lock held by another thread. Finally, if the OS thread corresponding to a Java
    `Thread` has ceased execution, then that thread object will have transitioned
    into the `TERMINATED` state. Let’s move on to talk about one well-known way to
    solve the synchronization problem: the idea of fully synchronized objects.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个在线程控制下的可能性之外，线程还可以进入`BLOCKED`状态，因为它正在等待I/O或获取另一个线程持有的锁。最后，如果对应于Java `Thread`的操作系统线程已停止执行，那么该线程对象将进入`TERMINATED`状态。让我们继续讨论解决同步问题的一个著名方法：完全同步对象的概念。
- en: 5.3.3 Fully synchronized objects
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 完全同步对象
- en: Earlier in this chapter, we introduced the concept of concurrent type safety
    and mentioned one strategy for achieving this. Let’s look at a more complete description
    of this strategy, which is usually called *fully synchronized objects*. If all
    of the following rules are obeyed, the class is known to be thread-safe and will
    also be live.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们介绍了并发类型安全的概念，并提到了实现这一目标的一种策略。让我们看看这种策略的更完整描述，这通常被称为*完全同步对象*。如果遵守以下所有规则，该类被认为是线程安全的，也将是活跃的。
- en: 'A fully synchronized class is a class that meets all of the following conditions:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 完全同步的类是满足以下所有条件的类：
- en: All fields are always initialized to a consistent state in every constructor.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有字段在每一个构造函数中都被初始化为一致的状态。
- en: There are no public fields.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有公共字段。
- en: Object instances are guaranteed to be consistent after returning from any nonprivate
    method (assuming the state was consistent when the method was called).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象实例在从任何非私有方法返回后都保证是一致的（假设在调用方法时状态是一致的）。
- en: All methods provably terminate in bounded time.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有方法都能在有限的时间内终止。
- en: All methods are synchronized.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有方法都是同步的。
- en: No method calls another instance’s methods while in an inconsistent state.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不一致的状态下，任何方法都不会调用另一个实例的方法。
- en: No method calls any nonprivate method on the current instance while in an inconsistent
    state.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不一致的状态下，任何方法都不会在当前实例上调用任何非私有方法。
- en: Listing 5.1 shows an example of such a class from the backend of a banking system.
    The class `FSOAccount` models an account. The FSO prefix is there to clearly indicate
    that this implementation uses fully synchronized objects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1展示了来自银行系统后端的一个此类示例。`FSOAccount`类模拟了一个账户。FSO前缀存在是为了清楚地表明这个实现使用了完全同步的对象。
- en: This situation provides deposits, withdrawals, and balance queries—a classic
    conflict between read and write operations—so synchronization is used to prevent
    inconsistency.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况提供了存款、取款和余额查询——这是读操作和写操作之间的一种经典冲突——因此使用同步来防止不一致性。
- en: Listing 5.1 A fully synchronized class
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 一个完全同步的类
- en: '[PRE4]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ No public fields
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 没有公共字段
- en: ❷ All fields are initialized in the constructor.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 所有字段都在构造函数中初始化。
- en: ❸ All methods are synchronized.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 所有方法都是同步的。
- en: This seems fantastic at first glance—the class is both safe and live. The problem
    comes with performance. Just because something is safe and live doesn’t mean it’s
    necessarily going to be very quick. You have to use `synchronized` to coordinate
    all the accesses (both get and put) to the balance, and that locking is ultimately
    going to slow you down. This is a central problem of this way of handling concurrency.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常棒——这个类既安全又活跃。问题是性能。仅仅因为某件事是安全和活跃的，并不意味着它一定会非常快。你必须使用`synchronized`来协调对余额的所有访问（无论是获取还是放置），而这种锁定最终会减慢你的速度。这是处理并发方式的一个核心问题。
- en: In addition to the performance problems, the code in listing 5.1 is quite fragile.
    You can see that you never touch `balance` outside of a synchronized method, but
    this is possible only to check by eye due to the small amount of code in play.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了性能问题之外，列表5.1中的代码相当脆弱。你可以看到你从未在同步方法之外触摸`balance`，但这只可能是通过检查代码的少量来实现的。
- en: In real, larger systems, this sort of manual verification would not be possible
    due to the amount of code. It’s too easy for bugs to creep into larger codebases
    that use this approach, which is another reason that the Java community began
    to look for more robust approaches.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中的大型系统中，由于代码量很大，这种手动验证是不可能的。对于使用这种方法的较大代码库，很容易出现错误，这也是 Java 社区开始寻找更稳健方法的原因之一。
- en: 5.3.4 Deadlocks
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.4 死锁
- en: Another classic problem of concurrency (and not just Java’s take on it) is the
    *deadlock*. Consider listing 5.2, which is a slightly extended form of the previous
    example. In this version, as well as modeling the account balance, we also have
    a `transferTo()` method that can move money from one account to another.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 并发（不仅仅是 Java 的观点）的另一个经典问题是 *死锁*。考虑列表 5.2，它是先前示例的略微扩展形式。在这个版本中，除了模拟账户余额外，我们还有一个
    `transferTo()` 方法，可以将资金从一个账户转移到另一个账户。
- en: Note This is a naïve attempt to build a multithreaded transaction system. It’s
    designed to demonstrate deadlocking—you shouldn’t use this as the basis for real
    code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这是一个构建多线程事务系统的天真尝试。它旨在演示死锁——你不应该将其作为真实代码的基础。
- en: In the next listing, let’s add a method to transfer funds between two `FSOAccount`
    objects, like this.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，让我们添加一个方法来在两个 `FSOAccount` 对象之间转移资金，如下所示。
- en: Listing 5.2 A deadlocking example
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 死锁示例
- en: '[PRE5]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let’s actually introduce some concurrency in a main class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在主类中实际引入一些并发性：
- en: '[PRE6]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At first glance, this code looks sensible. You have two transactions being performed
    by separate threads. This doesn’t seem too outlandish a design— just threads sending
    money between the two accounts—and all the methods are `synchronized`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，这段代码看起来是合理的。你有两个由不同线程执行的事务。这种设计看起来并不离谱——只是线程在两个账户之间转账——并且所有的方法都是 `synchronized`。
- en: Note that we’ve introduced a small sleep into the `transferTo()` method. This
    is to allow the thread scheduler to run both threads and lead to the possibility
    of deadlock.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `transferTo()` 方法中引入了一个小的睡眠。这是为了让线程调度器运行两个线程，并导致死锁的可能性。
- en: Note The sleep is for demonstration purposes, not because it is something you’d
    actually do when writing code for a bank transfer. It’s there to simulate code
    that would actually be there in practice—a delay caused by a call to a database
    or an authorization check.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这里的睡眠是为了演示目的，并不是因为你在编写银行转账代码时实际上会这样做。它在那里是为了模拟实际中可能存在的代码——由数据库调用或授权检查引起的延迟。
- en: If you run the code, you’ll normally see an example of a deadlock—both threads
    will run for a bit and eventually get stuck. The reason is that each thread requires
    the other to release the lock it holds before the transfer method can progress.
    This can be seen in figure 5.3.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行代码，你通常会看到一个死锁的例子——两个线程会运行一段时间，最终陷入停滞。原因是每个线程都需要其他线程在转移方法可以继续之前释放它持有的锁。这可以在图
    5.3 中看到。
- en: '![](../Images/CH05_F03_Evans2.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F03_Evans2.png)'
- en: Figure 5.3 Deadlocked threads
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 死锁线程
- en: Another way of looking at this can be seen in figure 5.4, where we show the
    Thread Dump view from the JDK Mission Control tool (we will have more to say about
    this tool in chapter 7 and will show you how to find this useful view then).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这个问题的方式可以在图 5.4 中看到，其中我们展示了 JDK Mission Control 工具的线程转储视图（我们将在第 7 章中详细介绍这个工具，并展示如何找到这个有用的视图）。
- en: '![](../Images/CH05_F04_Evans2.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F04_Evans2.png)'
- en: Figure 5.4 Deadlocked threads
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 死锁线程
- en: The two threads have been created as Thread-0 and Thread-1, and we can see that
    Thread-0 has locked one reference and is `BLOCKED`, waiting to lock the other.
    The corresponding thread dump for Thread-1 would show the opposite configuration
    of the locks, hence the deadlock.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 两个线程被创建为 Thread-0 和 Thread-1，我们可以看到 Thread-0 锁定了一个引用，并且处于 `BLOCKED` 状态，等待锁定另一个。Thread-1
    的对应线程转储将显示锁的相反配置，因此发生死锁。
- en: Note In terms of the fully synchronized object approach, this deadlock occurs
    because of the violation of the “bounded time” principle. When the code calls
    `other.deposit()`, we cannot guarantee how long the code will run for, because
    the Java Memory Model gives us no guarantees on when a blocked monitor will be
    released.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在完全同步对象方法方面，这个死锁是由于违反了“有限时间”原则而发生的。当代码调用 `other.deposit()` 时，我们无法保证代码将运行多长时间，因为
    Java 内存模型没有给我们关于阻塞监视器何时释放的保证。
- en: To deal with deadlocks, one technique is to always acquire locks in the same
    order in every thread. In the preceding example, the first thread to start acquires
    them in the order `A`, `B`, whereas the second thread acquires them in the order
    `B`, `A`. If both threads had insisted on acquiring them in the order `A`, `B`,
    the deadlock would have been avoided, because the second thread would have been
    blocked from running at all until the first had completed and released its locks.
    Later in the chapter, we will show a simple way to arrange for all locks to be
    obtained in the same order and a way to verify that this is indeed satisfied.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理死锁，一种技术是在每个线程中始终以相同的顺序获取锁。在前面的例子中，第一个启动的线程以`A`、`B`的顺序获取它们，而第二个线程以`B`、`A`的顺序获取它们。如果两个线程都坚持按`A`、`B`的顺序获取锁，那么死锁就可以避免，因为第二个线程将无法运行，直到第一个线程完成并释放其锁。在本章的后面部分，我们将展示一种简单的方法来安排所有锁以相同的顺序获取，以及一种验证这确实得到满足的方法。
- en: 'Next, we’ll return to a puzzle we posed earlier: why the Java keyword for a
    critical section is named `synchronized`. This will then lead us into a discussion
    of the `volatile` keyword.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回到我们之前提出的一个谜题：为什么Java中临界区的关键字被命名为`synchronized`。这将引导我们讨论`volatile`关键字。
- en: 5.3.5 Why synchronized?
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.5 为什么是`synchronized`？
- en: A simple conceptual model of concurrent programming is timesharing of a CPU—
    that is, threads swapping on and off a single core. This classic view is shown
    in figure 5.5.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程的简单概念模型是CPU的时分共享——也就是说，线程在单个核心上开关。这种经典观点在图5.5中显示。
- en: '![](../Images/CH05_F05_Evans2.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F05_Evans2.png)'
- en: Figure 5.5 The single (left) and multicore (right) of thinking about concurrency
    and threads
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 单核（左）和多核（右）并发和线程的思考
- en: However, this has not been an accurate picture of modern hardware for many years
    now. Twenty years ago, a working programmer could go for years on end without
    encountering a system that had more than one or at most two processing cores.
    That is no longer the case.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在许多年已经不再是对现代硬件的准确描述。二十年前，一个工作的程序员可以连续几年不遇到一个拥有超过一个或最多两个处理核心的系统。情况已经不再是这样了。
- en: Today, anything as big as or larger than a mobile phone has multiple cores,
    so the mental model should be different, too, encompassing multiple threads all
    running on different cores at the same physical moment (and potentially operating
    on shared data). You can see this in figure 5.5\. For efficiency, each thread
    that is running simultaneously may have its own cached copy of data being operated
    on.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何大小等于或大于移动电话的设备都有多个核心，因此心智模型也应该不同，涵盖在同一物理时刻运行在不同核心上的多个线程（并且可能操作共享数据）。您可以在图5.5中看到这一点。为了效率，同时运行的每个线程可能都有自己的数据缓存副本。
- en: Note We will still present theoretical models of execution where our hypothetical
    computer has only one core. This is purely so that you can see that the nondeterministic
    concurrency problems we are discussing are inherent and not caused by particular
    aspects of hardware design.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们仍然会展示执行的理论模型，其中我们的假设计算机只有一个核心。这样做纯粹是为了让您看到我们讨论的非确定性并发问题固有的，而不是由硬件设计的特定方面引起的。
- en: With this picture in mind, let’s turn to the question of the choice of keyword
    used to denote a locked section or a method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图景中，让我们转向关于用于表示锁定部分或方法的关键字的选择问题。
- en: 'We asked earlier, what is it that’s being synchronized in the code in listing
    5.1? The answer is: *the memory representation in different threads of the object
    being locked.* That is, after the synchronized method (or block) has completed,
    any and all changes that were made to the object being locked are flushed back
    to main memory before the lock is released, as illustrated in figure 5.6.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前问过，在列表5.1中的代码中，是什么被`synchronized`同步了？答案是：*被锁定对象在不同线程中的内存表示*。也就是说，在`synchronized`方法（或块）完成后，对被锁定对象所做的任何更改都会在释放锁之前刷新回主内存，如图5.6所示。
- en: '![](../Images/CH05_F06_Evans2.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F06_Evans2.png)'
- en: Figure 5.6 A change to an object propagates between threads via the main memory.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 对象的更改通过主内存传播到线程之间。
- en: In addition, when a synchronized block is entered, after the lock has been acquired,
    any changes to the locked object are read in *from* main memory, so the thread
    with the lock is synchronized to the main memory’s view of the object before the
    code in the locked section begins to execute.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当一个同步块被进入，并且在获取锁之后，任何对锁定对象的更改都是从主内存中读取的，因此拥有锁的线程在锁定部分的代码开始执行之前与主内存中对象的观点同步。
- en: 5.3.6 The volatile keyword
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.6 `volatile` 关键字
- en: 'Java has had the `volatile` keyword since the dawn of time (Java 1.0), and
    it’s used as a simple way to deal with concurrent handling of object fields, including
    primitives. The following rules govern a volatile field:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Java 自从诞生之初（Java 1.0）就拥有了 `volatile` 关键字，它被用作处理对象字段并发处理的一种简单方式，包括原始数据类型。以下规则支配一个
    `volatile` 字段：
- en: The value seen by a thread is always reread from the main memory before use.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程看到的值总是在使用之前从主内存中重新读取。
- en: Any value written by a thread is always flushed through to the main memory before
    the bytecode instruction completes.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程写入的任何值总是在字节码指令完成之前通过主内存刷新。
- en: This is sometimes described as being “like a tiny little synchronized block”
    around the single operation, but this is misleading because `volatile` does not
    involve any locking. The action of `synchronized` is to use a mutual exclusion
    lock on an object to ensure that only one thread can execute a synchronized method
    on that object. Synchronized methods can contain many read and write operations
    on the object, and they will be executed as an indivisible unit (from the point
    of view of other threads) because the results of the method executing on the object
    are not seen until the method exits and the object is flushed back to main memory.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时被描述为在单个操作周围有一个“小小的同步块”，但这种说法是误导性的，因为 `volatile` 不涉及任何锁定。`synchronized` 的作用是使用一个互斥锁在对象上，以确保只有一个线程可以执行该对象上的同步方法。同步方法可以在对象上包含许多读取和写入操作，并且它们将作为一个不可分割的单元（从其他线程的角度看）执行，因为直到方法退出并将对象刷新回主内存，其他线程看不到对象上方法执行的结果。
- en: The key point about `volatile` is that it allows for only *one* operation on
    the memory location, which will be immediately flushed to memory. This means either
    a single read, *or* a single write, but not more than that. We saw these two sorts
    of operations in figure 5.6.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `volatile` 的关键点是它只允许对内存位置进行 *一个* 操作，该操作将立即刷新到内存中。这意味着要么是单个读取，*或者* 是单个写入，但不会超过这个范围。我们在图
    5.6 中看到了这两种类型的操作。
- en: A volatile variable should be used to model a variable only where writes to
    the variable don’t depend on the current state (the read state) of the variable.
    This is a consequence of `volatile` guaranteeing only a single operation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 应该只在写入变量不依赖于变量的当前状态（读取状态）的情况下使用 `volatile` 变量来模拟变量。这是 `volatile` 保证只执行单个操作的结果。
- en: For example, the `++` and `--` operators are not safe to use on a `volatile`,
    because they are equivalent to `v = v + 1` or `v = v – 1`. The increment example
    is a classic example of a *state-dependent update*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`++` 和 `--` 运算符在 `volatile` 上使用是不安全的，因为它们等价于 `v = v + 1` 或 `v = v – 1`。增量示例是一个经典的
    *状态相关更新* 例子。
- en: For cases where the current state matters, you must always introduce a lock
    to be completely safe. So, `volatile` allows the programmer to write simplified
    code in some cases, but at the cost of the extra flushes on every access. Notice
    also that because the volatile mechanism doesn’t introduce any locks, you can’t
    deadlock using volatiles—only with synchronization. Later in the chapter, we will
    meet some other applications for `volatile` and discuss the mechanism in more
    detail.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于当前状态重要的情况，你必须始终引入一个锁来确保完全安全。因此，`volatile` 允许程序员在某些情况下编写简化的代码，但代价是每次访问都要进行额外的刷新。注意，由于
    `volatile` 机制不引入任何锁，你不能使用 `volatile` 导致死锁——只能使用同步。在本章的后面部分，我们将遇到 `volatile` 的其他一些应用，并更详细地讨论该机制。
- en: 5.3.7 Thread states and methods
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.7 线程状态和方法
- en: 'A `java.lang.Thread` object is just that: a Java object that lives in the heap
    and contains metadata about an operating system thread that either exists, used
    to exist, or will potentially exist in the future.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `java.lang.Thread` 对象就是这样：一个存在于堆中的 Java 对象，它包含有关操作系统线程的元数据，该线程可能存在、曾经存在，或者将来可能存在。
- en: 'Java defines the following states for a thread object, which correspond to
    OS thread states on mainstream operating systems. They are closely related to
    the state model we saw in figure 5.2:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Java为线程对象定义了以下状态，这些状态对应于主流操作系统上的操作系统线程状态。它们与我们图5.2中看到的状态模型密切相关：
- en: '`NEW`—the `Thread` object has been created, but the actual OS thread has not.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEW`—`Thread`对象已被创建，但实际的操作系统线程尚未创建。'
- en: '`RUNNABLE`—The thread is available to run. The OS is responsible for scheduling
    it.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNNABLE`—线程可运行。操作系统负责调度它。'
- en: '`BLOCKED`—The thread is not running; it needs to acquire a lock or is in a
    system call.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLOCKED`—线程未运行；它需要获取一个锁或处于系统调用中。'
- en: '`WAITING`—The thread is not running; it has called `Object.wait()` or `Thread
    .join()`.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WAITING`—线程未运行；它已经调用了`Object.wait()`或`Thread.join()`。'
- en: '`TIMED_WAITING`—The thread is not running; it has called `Thread.sleep()`.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMED_WAITING`—线程未运行；它已经调用了`Thread.sleep()`。'
- en: '`TERMINATED`—The thread is not running; it has completed execution.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TERMINATED`—线程未运行；它已经完成了执行。'
- en: All threads start in the `NEW` state and finish in the `TERMINATED` state, whether
    the thread’s `run()` method exits normally or throws an exception.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所有线程都从`NEW`状态开始，无论线程的`run()`方法是否正常退出或抛出异常，最终都会结束于`TERMINATED`状态。
- en: Note The Java thread state model does not distinguish between whether a `RUNNABLE`
    thread is actually physically executing at that precise moment or is waiting (in
    the *run queue*).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Java线程状态模型不区分一个`RUNNABLE`线程是否在那一刻实际物理执行或在等待（在*运行队列*中）。
- en: The actual creation of the thread is done by the `start()` method, which calls
    into native code to actually perform the relevant system calls (e.g., `clone()`
    on Linux) to create the thread and begin code execution in the thread’s `run()`
    method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的实际创建是通过`start()`方法完成的，该方法调用本地代码来执行相关的系统调用（例如Linux上的`clone()`）以创建线程，并在线程的`run()`方法中开始代码执行。
- en: The standard Thread API in Java breaks down into three groups of methods. Rather
    than include a lot of boilerplate Javadoc descriptions of each method, we will
    just list them and leave the reader to consult the API docs for more detail.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Java的Thread API可以分为三组方法。我们不会包含每个方法的很多样板Javadoc描述，而是只列出它们，并让读者查阅API文档以获取更多详细信息。
- en: 'The first is a group of methods for reading metadata about the thread:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是读取线程元数据的一组方法：
- en: '`getId()`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getId()`'
- en: '`getName()`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getName()`'
- en: '`getState()`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getState()`'
- en: '`getPriority()`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPriority()`'
- en: '`isAlive()`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isAlive()`'
- en: '`isDaemon()`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDaemon()`'
- en: '`isInterrupted()`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isInterrupted()`'
- en: 'Some of this metadata (such as the thread ID obtained from `getId()`) will
    be fixed for the lifetime of the thread. Some of it, such as the thread state
    and interrupted state, will naturally change as the thread runs, and some of it
    (e.g., the name and daemon status) can be set by the programmer. This leads us
    to the second group of methods:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些元数据（例如从`getId()`获取的线程ID）将在线程的生命周期内保持固定。其中一些（例如线程状态和中断状态）会随着线程的运行而自然变化，而其中一些（例如名称和守护状态）可以被程序员设置。这引出了第二组方法：
- en: '`setDaemon()`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setDaemon()`'
- en: '`setName()`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setName()`'
- en: '`setPriority()`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setPriority()`'
- en: '`setUncaughtExceptionHandler()`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setUncaughtExceptionHandler()`'
- en: It is often better for the programmer to configure any appropriate properties
    for threads before starting them.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序员来说，在启动线程之前配置任何适当的线程属性通常更好。
- en: 'Finally, the following set of thread control methods are used to start new
    threads and interact with other running threads:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下线程控制方法用于启动新线程并与其他正在运行的线程交互：
- en: '`start()`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start()`'
- en: '`interrupt()`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interrupt()`'
- en: '`join()`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join()`'
- en: Note that `Thread.sleep()` does not appear in this list, because it’s a static
    method that targets only the current thread.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Thread.sleep()`没有出现在这个列表中，因为它是一个静态方法，仅针对当前线程。
- en: Note Some of the thread methods with timeouts (e.g., `Thread.join()` with a
    timeout parameter) may actually result in the thread being placed into `TIMED_WAITING`
    instead of `WAITING`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一些具有超时的线程方法（例如，带有超时参数的`Thread.join()`）实际上可能导致线程被放置在`TIMED_WAITING`状态而不是`WAITING`状态。
- en: 'Let’s take a look at an example of how to use the thread methods in a typical
    life cycle of a simple multithreaded application:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，了解如何在简单多线程应用程序的典型生命周期中使用线程方法：
- en: '[PRE7]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ The thread’s metadata object is created.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建线程的元数据对象。
- en: ❷ The operating system creates an actual thread.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 操作系统创建了一个实际的线程。
- en: ❸ The main thread pauses and waits for the worker to exit before continuing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 主线程暂停并等待工作线程退出后再继续。
- en: 'This is pretty simple stuff: the main thread creates the worker, starts it,
    then waits for at least 100 ms (to give the scheduler a chance to run) before
    reaching the `join()` call, which causes it to pause until the worker thread exits.
    In the meantime, the worker thread completes the sleep, wakes up again, and prints
    out the message.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单：主线程创建工作线程，启动它，然后在达到 `join()` 调用之前至少等待 100 毫秒（给调度器一个运行的机会），`join()` 调用会导致它暂停，直到工作线程退出。与此同时，工作线程完成睡眠，再次醒来，并打印出消息。
- en: Note The elapsed time for the sleep will most likely not be exactly 1000 ms.
    The operating system scheduler is nondeterministic, and so the best guarantee
    that is offered is that the operating system will attempt to ensure that the thread
    sleeps for the requested amount of time, unless woken. However, multithreaded
    programming is often about dealing with unexpected circumstances, as we will see
    in the next section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：睡眠的经过时间很可能不会正好是 1000 毫秒。操作系统的调度器是非确定性的，因此操作系统提供的最佳保证是操作系统将尝试确保线程睡眠所需的时间，除非被唤醒。然而，多线程编程通常涉及处理意外情况，正如我们将在下一节中看到的那样。
- en: Interrupting threads
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 中断线程
- en: 'When working with threads, it’s relatively common to want to safely interrupt
    the work a thread is doing, and methods are provided for that on the `Thread`
    object. However, they may not behave as we’d first expect. Let’s run the following
    code that creates a thread, hard at work, and then tries to interrupt it:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当与线程一起工作时，相对常见的是想要安全地中断线程正在执行的工作，`Thread` 对象上提供了用于此目的的方法。然而，它们可能不会像我们最初预期的那样表现。让我们运行以下代码，该代码创建了一个正在努力工作的线程，然后尝试中断它：
- en: '[PRE8]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Creates and starts a new thread that will run forever
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建并启动一个将永远运行的新的线程
- en: ❷ Asks the thread to interrupt itself (i.e., stop executing)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 请求线程中断自己（即停止执行）
- en: ❸ Waits in our main thread for the other to complete
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在主线程中等待另一个线程完成
- en: 'If you run this code, you may be surprised to find that our `join()` will block
    forever. What’s happening here is that thread interruption is opt-in—the methods
    being called in a thread have to explicitly check the interrupt state and respond
    to it, and our naive `while` loop never makes such a check. We can fix this in
    our loop by doing the expected check, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你可能会惊讶地发现我们的 `join()` 将永久阻塞。这里发生的情况是线程中断是可选的——线程中调用的方法必须显式检查中断状态并对其做出响应，而我们的简单
    `while` 循环从未进行过这样的检查。我们可以在循环中通过执行预期的检查来修复这个问题，如下所示：
- en: '[PRE9]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Checks our current thread’s interrupt state instead of looping on true
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查当前线程的中断状态，而不是在 `true` 上循环
- en: Now our loop will exit when requested, and our `join()` no longer blocks forever.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当请求时，我们的循环将退出，并且我们的 `join()` 方法不再永久阻塞。
- en: It is common for methods in the JDK that are blocking—whether on IO, waiting
    on a lock, or other scenarios—to check the thread interrupt state. The convention
    is that these methods will throw `InterruptedException`, a checked exception.
    This explains why, for instance, `Thread.sleep()` requires you to add the `InterruptedException`
    to the method signature or handle it.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 中，方法通常是阻塞的——无论是 IO、等待锁还是其他场景，都普遍存在检查线程中断状态的情况。惯例是这些方法将抛出 `InterruptedException`，这是一个检查型异常。这解释了为什么例如
    `Thread.sleep()` 需要你将 `InterruptedException` 添加到方法签名中或处理它。
- en: 'Let’s modify our example from the previous section to see how `Thread.sleep()`
    behaves when interrupted:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改上一节中的示例，看看 `Thread.sleep()` 在被中断时的行为：
- en: '[PRE10]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Our Runnable must handle the checked InterruptedException. When we interrupt,
    it prints the stack, and then execution continues from here.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的 `Runnable` 必须处理检查型 `InterruptedException`。当我们中断时，它打印堆栈，然后从这里继续执行。
- en: ❷ Creates the worker thread
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建工作线程
- en: ❸ The main thread interrupts the worker and wakes it up.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 主线程中断工作线程并唤醒它。
- en: 'When we run this code, we see some output like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们会看到一些类似以下的输出：
- en: '[PRE11]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you look closely, you will see that the message `"Thread Worker interrupted"`
    does not appear. This reveals a pertinent fact about handling interrupts in our
    code: checks for the thread’s interruption state actually reset the state. The
    code that throws the standard `InterruptedException` cleared that interrupt, because
    it’s considered “handled” when the exception is thrown.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会看到消息 `"Thread Worker interrupted"` 并没有出现。这揭示了关于我们在代码中处理中断的一个相关事实：检查线程的中断状态实际上会重置该状态。抛出标准
    `InterruptedException` 的代码清除了中断，因为当异常被抛出时，它被认为是“已处理”。
- en: 'Note We have the following two methods for checking the interrupt state: a
    static `Thread.interrupted()`, which implicitly looks at the current thread, and
    an instance level `isInterrupted()` on a thread object. The static version clears
    the state after checking and is what’s expected for use before throwing an `InterruptedException`.
    The instance method, on the other hand, doesn’t alter the state.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们有以下两种方法来检查中断状态：一个静态的 `Thread.interrupted()`，它隐式地查看当前线程，以及一个线程对象的实例级别 `isInterrupted()`。静态版本在检查后清除状态，这是在抛出
    `InterruptedException` 之前期望使用的。另一方面，实例方法不会改变状态。
- en: 'If we want to retain the information that our thread was interrupted, we have
    to handle that directly ourselves. For our simple example where we need the state
    only later in the thread’s code, something like this would work:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要保留我们的线程被中断的信息，我们必须直接处理它。对于我们的简单示例，我们只需要在线程代码的稍后部分使用状态，以下内容将有效：
- en: '[PRE12]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Sets up the state to record a possible interruption
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置状态以记录可能的中断
- en: ❷ Records the interruption
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 记录中断
- en: In more complex situations, you may wish to ensure an `InterruptedException`
    is rethrown for callers, throw a custom exception of some sort, perform your own
    custom logic, or even restore the interrupt state onto the thread in question.
    All of these are possible, depending on your specific needs.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的情况下，你可能希望确保为调用者重新抛出 `InterruptedException`，抛出某种自定义异常，执行自己的自定义逻辑，或者甚至将中断状态恢复到相关的线程上。所有这些都是可能的，具体取决于你的具体需求。
- en: Working with exceptions and threads
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 与异常和线程一起工作
- en: 'Another issue for multithreaded programming is how to handle exceptions that
    may be thrown from within a thread. For example, suppose that we are executing
    a `Runnable` of unknown provenance. If it throws an exception and dies, then other
    code may not be aware of it. Fortunately, the Thread API provides the ability
    to add uncaught exception handlers to a thread before starting it, like this example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个多线程编程的问题是处理可能从线程内部抛出的异常。例如，假设我们正在执行一个来源未知的 `Runnable`。如果它抛出异常并死亡，那么其他代码可能不会意识到这一点。幸运的是，Thread
    API 提供了在启动线程之前向线程添加未捕获异常处理器的功能，如下例所示：
- en: '[PRE13]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The handler is an instance of `UncaughtExceptionHandler`, which is a functional
    interface, defined like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器是 `UncaughtExceptionHandler` 的一个实例，它是一个函数式接口，定义如下：
- en: '[PRE14]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method provides a simple callback to allow thread control code to take
    action based on the observed exception—for example, a thread pool may restart
    a thread that has exited in this way to maintain pool size.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法提供了一个简单的回调，允许线程控制代码根据观察到的异常采取行动——例如，线程池可能会重新启动以这种方式退出的线程，以保持池的大小。
- en: Note Any exception thrown by `uncaughtException()` will be ignored by the JVM.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由 `uncaughtException()` 抛出的任何异常都将被 JVM 忽略。
- en: Before we move on, we need to discuss some other control methods of `Thread`
    that are deprecated and that should not be used by application programmers.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要讨论一些 `Thread` 的已废弃控制方法，这些方法不应该由应用程序员使用。
- en: Deprecated thread methods
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 已废弃的线程方法
- en: Java was the first mainstream language to support multithreaded programming
    out of the box. However, this “first mover” advantage had its dark side—many of
    the inherent issues that exist with concurrent programming were first encountered
    by programmers working in Java.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是第一个支持多线程编程的主流语言。然而，这种“先行者”优势也有其阴暗面——许多并发编程中固有的问题首先是由在 Java 中工作的程序员遇到的。
- en: One aspect of this is the unfortunate fact that some of the methods in the original
    Thread API are simply unsafe and unfit to use, in particular, `Thread.stop()`.
    This method is essentially impossible to use safely—it kills another thread without
    any warning and with no way for the killed thread to ensure that any locked objects
    are made safe.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这其中有一个不幸的事实，即原始 Thread API 中的某些方法实际上是不安全的，不适合使用，特别是 `Thread.stop()`。此方法基本上无法安全使用——它在不警告的情况下杀死另一个线程，并且没有让被杀死的线程确保任何锁定对象都变得安全的方法。
- en: The deprecation of `stop()` followed close on the heels of its active use in
    early Java because stopping another thread required injecting an exception into
    the other thread’s execution. However, it’s impossible to know precisely *where*
    that other thread is in execution. Maybe the thread is killed in the middle of
    a `finally` block the developer assumed would run fully, and the program is left
    in a corrupted state.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop()`的弃用紧随其在早期Java中的积极使用之后，因为停止另一个线程需要在另一个线程的执行中注入一个异常。然而，无法确切知道那个其他线程在执行中的确切位置。也许线程在开发者假设会完全运行的`finally`块中间被杀死，程序处于损坏状态。'
- en: The mechanism is that an unchecked `ThreadDeath` exception is triggered on the
    killed thread. It is not feasible for code to guard against such an exception
    with try blocks (any more than it is possible to reliably protect against an `OutOfMemoryError`),
    and so the exception immediately starts unwinding the stack of the killed thread,
    and all monitors are unlocked. This immediately makes potentially damaged objects
    visible to other threads, and so `stop()` is just not safe for use.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 机制是在被杀死的线程上触发未检查的`ThreadDeath`异常。代码无法通过try块来保护自己免受此类异常的影响（就像不可能可靠地保护自己免受`OutOfMemoryError`一样），因此异常会立即开始回滚被杀死线程的堆栈，并解锁所有监视器。这立即使可能受损的对象对其他线程可见，因此`stop()`的使用并不安全。
- en: In addition to the reasonably well-known issues with `stop()`, several other
    methods also have serious issues. For example, `suspend()` does not cause any
    monitors to be released, so any thread that attempts to access any synchronized
    code that is locked by the suspended thread will block permanently, unless the
    suspended thread is reactivated. This represents a major liveness hazard, and
    so `suspend()` and `resume()` should never be used. The `destroy()` method was
    never implemented, but it would have suffered from the same issues if it had been.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 除了众所周知的`stop()`问题之外，还有其他几个方法也存在严重问题。例如，`suspend()`不会释放任何监视器，因此任何尝试访问被挂起线程锁定的同步代码的线程将永久阻塞，除非挂起线程被重新激活。这代表了一个重大的活跃性风险，因此`suspend()`和`resume()`永远不应该使用。`destroy()`方法从未实现过，但如果实现了，也会遇到相同的问题。
- en: Note These dangerous thread methods have been deprecated since Java 1.2—over
    20 years ago—and have recently been marked for removal (which will be a breaking
    change, to give you some idea of how seriously this is viewed).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这些危险的线程方法自Java 1.2以来就被弃用了——超过20年前，并且最近已被标记为即将删除（这将是一个破坏性变更，让你了解这个问题被如何看待得多么严重）。
- en: The real solution to the problem of reliably controlling threads from other
    threads is best illustrated by the *Volatile Shutdown* pattern that we will meet
    later in the chapter. Now let’s move on to one of the most useful techniques when
    handling data that must be shared safely when programming in a concurrent style.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 从其他线程可靠地控制线程的真实解决方案最好通过我们在本章后面将要遇到的*Volatile Shutdown*模式来展示。现在让我们继续讨论在以并发方式编程时处理必须安全共享的数据时最有用的技术之一。
- en: 5.3.8 Immutability
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.8 不可变性
- en: One technique that can be of great value is the use of immutable objects. These
    are objects that either have no state or that have only final fields (which must,
    therefore, be populated in the constructors of the objects). These are always
    safe and live, because their state can’t be mutated, so they can never be in an
    inconsistent state.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一种非常有价值的技术是使用不可变对象。这些对象要么没有任何状态，要么只有最终字段（因此，必须在对象的构造函数中填充这些字段）。这些对象总是安全且活跃的，因为它们的状态不能被修改，所以它们永远不会处于不一致的状态。
- en: 'One problem is that any values that are required to initialize a particular
    object must be passed into the constructor. This can lead to unwieldy constructor
    calls, with many parameters. As a result, many coders use a *factory method* instead.
    This can be as simple as using a static method on the class, instead of a constructor,
    to produce new objects. The constructors are usually made protected or private,
    so that the static factory methods are the only way of instantiating. For example,
    consider a simple deposit class that we might see in a banking system, as shown
    here:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是，任何需要用于初始化特定对象的值都必须传递给构造函数。这可能导致构造函数调用笨拙，参数众多。因此，许多编码者使用*工厂方法*。这可以简单到在类上使用静态方法而不是构造函数来生成新对象。构造函数通常被设置为受保护的或私有的，这样静态工厂方法就成为了实例化的唯一方式。例如，考虑一个简单的存款类，我们可能在银行系统中看到，如下所示：
- en: '[PRE15]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This has the fields of the class, a private constructor, and two factory methods,
    one of which is a convenience method for creating deposits for today. Next up
    are the accessor methods for the fields:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这具有类的字段，一个私有构造函数，以及两个工厂方法，其中一个是为创建今天的存款提供的便利方法。接下来是字段的访问器方法：
- en: '[PRE16]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that in our example, these are presented in *record style*, where the name
    of the accessor method matches the name of the field. This is in contrast to *bean
    style*, when getter methods are prefixed with `get` and setter methods (for any
    nonfinal fields) are prefixed with `set`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们的示例中，这些是以记录风格呈现的，其中访问器方法的名称与字段的名称相匹配。这与bean风格形成对比，在bean风格中，getter方法以`get`为前缀，setter方法（对于任何非final字段）以`set`为前缀。
- en: 'Immutable objects obviously can’t be changed, so what happens when we want
    to make changes to one of them? For example, it’s very common that if a deposit
    or other transaction can’t take place on a specific day, that transaction is “rolled”
    to the following day. We can achieve this by having an instance method on the
    type that returns an object that is almost the same, but has some modified fields,
    as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 不变对象显然不能被更改，那么当我们想要更改其中一个时会发生什么？例如，如果存款或其他交易在特定一天无法进行，那么这笔交易通常会“滚动”到下一天。我们可以通过在类型上有一个实例方法来实现这一点，该方法返回一个几乎相同但某些字段已修改的对象，如下所示：
- en: '[PRE17]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: One problem that immutable objects potentially have is that they may need many
    parameters to be passed in to the factory method. This isn’t always very convenient,
    especially when you may need to accumulate state from several sources before creating
    a new immutable object.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 不变对象可能存在的一个问题是，它们可能需要许多参数传递给工厂方法。这并不总是非常方便，尤其是在你需要在创建新的不变对象之前从多个来源累积状态时。
- en: 'To solve this, we can use the Builder pattern. This is a combination of two
    constructs: a static inner class that implements a generic builder interface,
    and a private constructor for the immutable class itself.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用构建器模式。这是两种结构的组合：一个实现泛型构建器接口的静态内部类，以及不变类本身的私有构造函数。
- en: The static inner class is the builder for the immutable class, and it provides
    the only way that a developer can get hold of new instances of the immutable type.
    One very common implementation is for the `Builder` class to have exactly the
    same fields as the immutable class but to allow mutation of the fields. This listing
    shows how you might use this to model a more complex view of a deposit.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 静态内部类是不变类的构建器，它为开发者提供了获取不变类型新实例的唯一方式。一个非常常见的实现是，`Builder`类与不变类具有完全相同的字段，但允许字段的可变。以下列表显示了如何使用这种方法来模拟存款的更复杂视图。
- en: Listing 5.3 Immutable objects and builders
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 不变对象和构建器
- en: '[PRE18]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The builder is a generic top-level interface, which is usually defined like
    this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器是一个泛型顶层接口，通常定义如下：
- en: '[PRE19]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We should note a couple of things about the builder. First of all, it is a so-called
    SAM type (for “single abstract method”), and it could, technically speaking, be
    used as the target type for a lambda expression. However, the purpose of the builder
    is to produce immutable instances—it is about gathering up state, not representing
    a function or callback. This means that although the builder *could* be used as
    a functional interface, in practice, it will never be useful to do so.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意关于构建器的一些事情。首先，它是一个所谓的SAM类型（代表“单个抽象方法”），从技术上讲，它可以作为lambda表达式的目标类型。然而，构建器的目的是生成不可变实例——它关于聚集状态，而不是表示一个函数或回调。这意味着尽管构建器*可以*用作功能接口，但在实践中，这样做永远不会有用。
- en: For this reason, we do *not* decorate the interface with the `@FunctionalInterface`
    annotation—another good example of “just because you can do something, doesn’t
    mean that you should.”
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不会用`@FunctionalInterface`注解来装饰接口——这是“仅仅因为你可以做某事，并不意味着你应该这样做”的另一个好例子。
- en: Secondly, we should also notice that the builder is not thread-safe. The design
    implicitly assumes that the user knows not to share builders between threads.
    Instead, correct usage of the Builder API is for one thread to use a builder to
    aggregate all needed state and then produce an immutable object that *can* be
    trivially shared with other threads.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们还应该注意到构建器不是线程安全的。设计隐式假设用户知道不要在线程之间共享构建器。相反，正确的Builder API使用方式是一个线程使用构建器聚合所有需要的状态，然后生成一个可以与其他线程简单共享的不变对象。
- en: Note If you find yourself wanting to share a builder between threads, take a
    moment to stop and reconsider your design and whether your domain needs refactoring.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你发现自己想在多个线程之间共享一个构建器，请花点时间停下来重新考虑你的设计和你的领域是否需要重构。
- en: Immutability is a very common pattern (not just in Java, but also in other languages,
    especially functional languages) and is one that has wide applicability.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性是一个非常常见的模式（不仅限于Java，也适用于其他语言，尤其是函数式语言），并且具有广泛的应用性。
- en: 'One last point about immutable objects: the `final` keyword applies only to
    the object directly pointed to. As you can see in figure 5.7, the reference to
    the main object can’t be assigned to point at object 3, but within the object,
    the reference to object 1 can be updated to point at object 2\. Another way of
    saying this is that a `final` reference can point at an object that has nonfinal
    fields. This is sometimes known as *shallow immutability*.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 关于不可变对象的一个最后要点：`final`关键字仅适用于直接指向的对象。正如你在图5.7中可以看到的，主对象的引用不能被分配以指向对象3，但在对象内部，对对象1的引用可以被更新以指向对象2。另一种说法是，`final`引用可以指向具有非final字段的对象。这有时被称为*浅不可变性*。
- en: '![](../Images/CH05_F07_Evans2.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F07_Evans2.png)'
- en: Figure 5.7 Immutability of value versus reference
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 值与引用的不可变性
- en: 'Another way of seeing this is that it is perfectly possible to write the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这个问题的方式是，完全有可能写出以下内容：
- en: '[PRE20]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this statement, the reference `numbers` and the integer objects contained
    in the list are immutable. However, the list object itself is still mutable because
    integer objects can still be added, removed, and replaced with the list.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个声明中，引用`numbers`和列表中包含的整数对象是不可变的。然而，列表对象本身仍然是可变的，因为整数对象仍然可以被添加、删除和替换到列表中。
- en: Immutability is a very powerful technique, and you should use it whenever feasible.
    However, sometimes it’s just not possible to develop efficiently with only immutable
    objects, because every change to an object’s state requires a new object to be
    spun up. So we’re sometimes left with the necessity of dealing with mutable objects.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性是一个非常强大的技术，你应该在可行的情况下使用它。然而，有时仅仅使用不可变对象是无法高效开发的，因为对象状态的任何更改都需要启动一个新的对象。因此，我们有时不得不处理可变对象。
- en: In the next section, we’ll discuss the often-misunderstood details of the Java
    Memory Model (JMM). Many Java programmers are aware of the JMM and have been coding
    to their own understanding of it without ever being formally introduced to it.
    If that sounds like you, this new understanding will build upon your informal
    awareness and place it onto firm foundations. The JMM is quite an advanced topic,
    so you can skip it if you’re in a hurry to get on to the next chapter.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论经常被误解的Java内存模型（JMM）的细节。许多Java程序员对JMM有所了解，并且一直在根据自己的理解编写代码，而没有正式地介绍过它。如果你是这样的程序员，这种新的理解将建立在你的非正式认识之上，并将其建立在坚实的基础之上。JMM是一个非常高级的话题，所以如果你急于进入下一章，可以跳过它。
- en: 5.4 The Java Memory Model (JMM)
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 Java内存模型（JMM）
- en: The JMM is described in section 17.4 of the Java Language Specification (JLS).
    This is a formal part of the spec, and it describes the JMM in terms of synchronization
    actions and some quite mathematical concepts, for example, a *partial order* for
    operations.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Java语言规范（JLS）的第17.4节描述了JMM。这是规范的一个正式部分，它使用同步操作和一些相当数学的概念来描述JMM，例如操作的*偏序*。
- en: This is great from the point of view of language theorists and implementers
    of the Java spec (compiler and JVM makers), but it’s worse for application developers
    who need to understand the details of how their multithreaded code will execute.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 从语言理论家和Java规范（编译器和JVM制造者）的角度来看，这是非常好的，但对于需要理解其多线程代码执行细节的应用程序开发者来说，这是更糟的。
- en: 'Rather than repeat the formal details, we’ll list the most important rules
    here in terms of a couple of basic concepts: the *Synchronizes-With* and *Happens-Before*
    relationships between blocks of code:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会重复正式的细节，而是将最重要的规则列在这里，以几个基本概念的形式：代码块之间的*同步于*和*发生之前*关系：
- en: '*Happens-Before*—This relationship indicates that one block of code fully completes
    before the other can start.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发生之前*—这种关系表示一个代码块在另一个代码块开始之前完全完成。'
- en: '*Synchronizes-With*—An action will synchronize its view of an object with main
    memory before continuing.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步于*—在继续之前，一个操作将同步其对对象的视图与主内存。'
- en: If you’ve studied formal approaches to OO programming, you may have heard the
    expressions *Has-A* and *Is-A* used to describe the building blocks of object
    orientation. Some developers find it useful to think of Happens-Before and Synchronizes-With
    as being similar, basic conceptual building blocks, but for understanding Java
    concurrency rather than OO. However, we should emphasize that no direct technical
    connection exists between the two sets of concepts. In figure 5.8 you can see
    an example of a volatile write that Synchronizes-With a later read access (for
    the `println()`).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经研究过面向对象编程的正式方法，你可能听说过用来描述面向对象构建块的 *Has-A* 和 *Is-A* 这些表达。一些开发者发现将 Happens-Before
    和 Synchronizes-With 视为类似的基本概念构建块是有用的，但这是为了理解 Java 并发而不是面向对象。然而，我们应该强调这两组概念之间没有直接的技术联系。在图
    5.8 中，你可以看到一个与后续读取访问（对于 `println()`）同步的易变写入示例。
- en: 'The JMM has these main rules:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: JMM 有以下主要规则：
- en: An unlock operation on a monitor Synchronizes-With later locks operations.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在监视器上的解锁操作将同步与后续的锁定操作。
- en: A write to a volatile variable Synchronizes-With later reads from the variable.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向一个易变变量写入将同步与该变量的后续读取操作。
- en: If an action A Synchronizes-With action B, then A Happens-Before B.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作 A 与操作 B 同步，那么 A 发生在 B 之前。
- en: If A comes before B in program order, within a thread, then A Happens-Before
    B.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在程序顺序中 A 在 B 之前发生，那么在同一个线程中，A 发生在 B 之前。
- en: '![](../Images/CH05_F08_Evans2.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![示例图片](../Images/CH05_F08_Evans2.png)'
- en: Figure 5.8 A Synchronizes-With example
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8 同步示例](../Images/CH05_F08_Evans2.png)'
- en: The general statement of the first two rules is that “releases happen before
    acquires.” In other words, the locks that a thread holds when writing are released
    before the locks can be acquired by other operations (including reads). For example,
    the rules guarantee that if one thread writes a value to a volatile variable,
    then any thread that later reads that variable will see the value that was written
    (assuming no other writes have taken place).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条和第二条规则的一般表述是“释放发生在获取之前。”换句话说，线程在写入时持有的锁在可以由其他操作（包括读取）获取之前被释放。例如，规则保证如果一个线程向一个易变变量写入值，那么任何稍后读取该变量的线程都将看到写入的值（假设没有其他写入发生）。
- en: 'Additional rules, which are really about sensible behavior, follow:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 随后是关于合理行为的附加规则：
- en: The completion of a constructor Happens-Before the finalizer for that object
    starts to run (an object has to be fully constructed before it can be finalized).
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数的完成发生在该对象的终结器开始运行之前（一个对象必须完全构建后才能进行终结）。
- en: An action that starts a thread Synchronizes-With the first action of the new
    thread.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动线程的操作与新线程的第一个操作同步。
- en: '`Thread.join()` Synchronizes-With the last (and all other) actions in the thread
    being joined.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.join()` 将同步与被加入线程的最后一个（以及所有其他）操作。'
- en: If X Happens-Before Y and Y Happens-Before Z, then X Happens-Before Z (transitivity).
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 X 发生在 Y 之前，并且 Y 发生在 Z 之前，那么 X 发生在 Z 之前（传递性）。
- en: These simple rules define the whole of the platform’s view of how memory and
    synchronization works. Figure 5.9 illustrates the transitivity rule.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的规则定义了整个平台对内存和同步工作方式的看法。图 5.9 阐述了传递性规则。
- en: '![](../Images/CH05_F09_Evans2.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 Happens-Before 的传递性](../Images/CH05_F09_Evans2.png)'
- en: Figure 5.9 Transitivity of Happens-Before
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.9 Happens-Before 的传递性](../Images/CH05_F09_Evans2.png)'
- en: Note In practice, these rules are the minimum guarantees made by the JMM. Real
    JVMs may behave much better in practice than these guarantees suggest. This can
    be quite a pitfall for the developer because it’s easy for the false sense of
    safety given by the behavior of a particular JVM to turn out to be just a quirk
    hiding an underlying concurrency bug.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在实际应用中，这些规则是 JMM 做出的最小保证。实际的 JVM 可能在实际中表现得比这些保证更好。这对开发者来说可能是一个陷阱，因为特定 JVM
    的行为所提供的虚假安全感可能会暴露出隐藏的并发错误。
- en: From these minimum guarantees, it’s easy to see why immutability is an important
    concept in concurrent Java programming. If objects can’t be changed, there are
    no issues related to ensuring that changes are visible to all threads.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些最小保证中，很容易看出不可变性是并发 Java 编程中的一个重要概念。如果对象不能被更改，那么就不会有与确保更改对所有线程可见相关的问题。
- en: 5.5 Understanding concurrency through bytecode
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 通过字节码理解并发
- en: 'Let’s discuss concurrency through the lens of a classic example: a bank account.
    Let’s assume that a customer’s account looks like this and that withdrawals and
    deposits are possible by calling methods. We have provided both synchronized and
    unsynchronized implementations of the key methods:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个经典示例来讨论并发：一个银行账户。假设客户的账户看起来像这样，并且可以通过调用方法进行提款和存款。我们已经提供了关键方法的同步和未同步实现：
- en: '[PRE21]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This set of methods will allow us to explore many common concurrency problems
    in Java.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这组方法将使我们能够探索Java中许多常见的并发问题。
- en: Note There is a reason we are using the block form of synchronization at this
    stage, rather than the `synchronized` method modifier—we will explain why a bit
    later in the chapter.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们之所以在这个阶段使用同步的块形式，而不是`synchronized`方法修饰符，是因为我们将在本章稍后解释原因。
- en: 'We might also suppose that, if required, the class has two argument helper
    methods that look like this:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以假设，如果需要，该类有两个类似这样的辅助方法：
- en: '[PRE22]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let’s start by meeting one of the fundamental problems that multithreaded systems
    display that requires us to introduce some sort of protection mechanism.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先遇到多线程系统显示的一个基本问题，这需要我们引入某种保护机制。
- en: 5.5.1 Lost Update
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 更新丢失
- en: 'To demonstrate this common problem (or antipattern), known as *Lost Update*,
    let’s look at the bytecode for the `rawDeposit()` method:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个常见问题（或反模式），称为*更新丢失*，让我们看看`rawDeposit()`方法的字节码：
- en: '[PRE23]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Reads the balance from the object
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从对象中读取余额
- en: ❷ Adds the deposit amount
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加存款金额
- en: ❸ Writes the new balance to the object
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将新余额写入对象
- en: Let’s introduce two threads of execution, called `A` and `B`. We can then imagine
    two deposits being attempted on the same account at once. By prefixing the instruction
    with the thread label, we can see individual bytecode instructions executing on
    different threads, but they are both affecting the same object.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们引入两个执行线程，称为`A`和`B`。然后我们可以想象同时尝试在同一个账户上存款。通过在指令前加上线程标签，我们可以看到不同线程上执行的单个字节码指令，但它们都影响同一个对象。
- en: Note Remember that some bytecode instructions have parameters that follow them
    in the stream, which causes occasional “skips” in the instruction numbering.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：请记住，一些字节码指令后面跟着参数，这会导致指令编号偶尔出现“跳过”。
- en: 'Lost Update is the issue that it is possible, due to the nondeterministic scheduling
    of application threads, to end up with a bytecode sequence of reads and writes
    like this:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 更新丢失是由于应用程序线程的非确定性调度，可能出现这种读取和写入的字节码序列的问题：
- en: '[PRE24]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Thread A reads a value from the balance.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 线程A从余额中读取一个值。
- en: ❷ Thread B reads the same value from the balance as A did.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 线程B读取与A相同的余额值。
- en: ❸ Thread B writes a new value back to the balance.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 线程B将新值写回余额。
- en: ❹ Thread A overwrites the balance—B’s update is lost.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 线程A覆盖了余额——B的更新丢失了。
- en: 'The updated balance is calculated by each thread by using the evaluation stack.
    The `dadd` opcode is the point where the updated balance is placed on the stack,
    but recall that every method invocation has its own, private evaluation stack.
    So, at point `B7` in the previous flow are *two* copies of the updated balance:
    one in A’s evaluation stack and one in B’s. The two `putfield` operations at `B8`
    and `A8` then execute, but `A8` overwrites the value placed at `B8`. This leads
    to the situation where both deposits appear to succeed, but only one of them actually
    shows up.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的余额是由每个线程使用评估栈计算的。`dadd` 操作码是将更新后的余额放置在栈上的点，但请记住，每个方法调用都有自己的、私有的评估栈。因此，在前一个流程中的`B7`点有`两个`更新后的余额副本：一个在A的评估栈中，一个在B的。然后执行`B8`和`A8`处的两个`putfield`操作，但`A8`覆盖了在`B8`处放置的值。这导致两个存款似乎都成功了，但实际上只有一个出现。
- en: 'The account balance will register a deposit, but the code will still cause
    money to vanish from the account, because the balance field is read twice (with
    `getfield`), then written and overwritten (by the two `putfield` operations).
    For example, in some code like this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 账户余额将记录存款，但代码仍然会导致账户中的钱消失，因为余额字段被读取两次（使用`getfield`），然后被写入和覆盖（通过两个`putfield`操作）。例如，在某些代码如下：
- en: '[PRE25]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: it is possible for the final balance to be either 50 or 70—but with both threads
    “successfully” depositing money. The code has paid in 120 but has lost some of
    it—a classic example of incorrect multithreaded code.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 最终余额可能是50或70——但两个线程都“成功”存了钱。代码存入了120，但丢失了一些——这是不正确多线程代码的一个经典例子。
- en: Be careful with the simple form of the code shown here. The full range of nondeterministic
    possibilities may not show up in such a simple example. Do not be fooled by this—when
    this code is combined into a large program, the incorrectness will assuredly appear.
    Assuming that your code is OK because it’s “too simple” or trying to cheat the
    concurrency model will inevitably end badly.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里展示的代码的简单形式。在这样一个简单的例子中，可能不会显示出非确定性的全部可能性。不要被这个例子所迷惑——当这段代码组合进一个大型程序中，错误肯定会显现出来。认为代码因为“太简单”就一定没问题，或者试图欺骗并发模型，最终结果必然是糟糕的。
- en: Note There is an example (`AtmLoop`) that shows this effect in the source code
    repository, but it relies upon using a class we haven’t met yet (`AtomicInteger`)
    so we won’t show it in full here. So, if you need to be convinced, please go and
    examine how the example behaves.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：源代码库中有一个示例（`AtmLoop`）展示了这种效果，但它依赖于我们尚未遇到的一个类（`AtomicInteger`），所以我们在这里不会完全展示。因此，如果您需要确信，请去检查示例的行为。
- en: In general, access patterns like
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，访问模式
- en: '[PRE26]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: or
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE27]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: will cause problems for our account objects.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 将会对我们的账户对象造成问题。
- en: Recall that the operating system effectively causes nondeterministic scheduling
    of threads, so this type of interleaving is always possible, and Java objects
    live in the heap, so the threads are operating on shared, mutable data.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，操作系统实际上会导致线程的非确定性调度，因此这种交错总是可能的，Java对象存在于堆中，因此线程正在操作共享的、可变的数据。
- en: 'What we really need is to introduce a mechanism to somehow prevent this and
    ensure that the ordering is always of the following form:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要的是引入一种机制，以某种方式防止这种情况，并确保排序始终是以下形式：
- en: '[PRE28]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This mechanism is synchronization, and it is our next subject.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 此机制是同步，这是我们下一个主题。
- en: 5.5.2 Synchronization in bytecode
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2 字节码中的同步
- en: 'In chapter 4, we introduced JVM bytecodes and briefly met `monitorenter` and
    `monitorexit`. A synchronized block is turned into these opcodes (we’ll talk about
    synchronized methods a bit later). Let’s see them in action by looking at an example
    we saw earlier (we’re reproducing the Java code so it’s close at hand):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，我们介绍了JVM字节码，并简要地遇到了`monitorenter`和`monitorexit`。同步块被转换成这些操作码（我们稍后会讨论同步方法）。让我们通过查看我们之前看到的示例来观察它们的作用（我们正在重现Java代码，因此它就在手边）：
- en: '[PRE29]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is turned into 40 bytes of JVM bytecode:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这被转换成40字节JVM字节码：
- en: '[PRE30]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ The start of the synchronized block
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 同步块的开始
- en: ❷ The if statement that checks the balance
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查余额的if语句
- en: ❸ Writes the new value to the balance field
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将新值写入余额字段
- en: ❹ The end of the synchronized block
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 同步块的结束
- en: ❺ Returns from the method
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 方法返回值
- en: The eagle-eyed reader might spot a couple of oddities in the bytecode. First
    of all, let’s look at the code paths. If the balance check succeeds, then bytecodes
    0–28 are executed with no jumps. If it fails, bytecodes 0–11 execute, then a jump
    to 29–31 and a jump to 39–40.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 留意细节的读者可能会在字节码中注意到几个奇怪之处。首先，让我们看看代码路径。如果余额检查成功，则字节码0-28被执行，没有跳转。如果失败，字节码0-11被执行，然后跳转到29-31和39-40。
- en: At first glance, no set of circumstances will lead to bytecodes 34–38 being
    executed. This seeming discrepancy is actually explained by exception handling—some
    of the bytecode instructions (including `monitorenter`) can throw exceptions,
    so there needs to be an exception handling code path.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，没有任何一组情况会导致字节码34-38被执行。这种看似矛盾的情况实际上是由异常处理解释的——一些字节码指令（包括`monitorenter`）可以抛出异常，因此需要有一个异常处理代码路径。
- en: The second puzzler is the return type of the method. In the Java code, it is
    declared as `boolean`, but we can see that the return instructions are `ireturn`,
    which is the integer variant of the return opcode. In fact, no variant forms of
    instructions for bytes, shorts, chars, or booleans exist. These types are replaced
    by ints during the compilation process. This is a form of *type erasure*, which
    is one of the misunderstood aspects of Java’s type system (especially as it is
    usually applied to the case of generics and type parameters).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个难题是方法的返回类型。在Java代码中，它被声明为`boolean`，但我们可以看到返回指令是`ireturn`，这是返回操作码的整数变体。实际上，对于字节、短整型、字符或布尔类型，不存在指令的变体形式。这些类型在编译过程中被替换为整型。这是一种*类型擦除*，这是Java类型系统（尤其是通常应用于泛型和类型参数的情况）被误解的一个方面。
- en: 'Overall, the previous bytecode sequence is more complex than the nonsynchronized
    case but should be possible to follow: we load the object to be locked onto the
    evaluation stack and then execute a `monitorenter` to acquire the lock. Let’s
    assume the lock attempt succeeds.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，之前的字节码序列比非同步情况更复杂，但应该可以理解：我们将要锁定的对象加载到评估堆栈上，然后执行`monitorenter`以获取锁。让我们假设锁尝试成功。
- en: 'Now, if any other thread attempts to execute a `monitorenter` on the same object,
    the thread will block, and the second `monitorenter` instruction will not complete
    until the thread holding the lock executes a `monitorexit` and releases the lock.
    This is how we deal with Lost Update—the `monitor` instructions are enforcing
    the following ordering:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果任何其他线程尝试在同一个对象上执行`monitorenter`，该线程将被阻塞，并且第二个`monitorenter`指令将不会完成，直到持有锁的线程执行`monitorexit`并释放锁。这就是我们处理“丢失更新”的方式——`monitor`指令强制执行以下顺序：
- en: '[PRE31]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This provides the Happens-Before relationship between synchronized blocks:
    the end of one synchronized block Happens-Before the start of any other synchronized
    block on the same object, and this is guaranteed by the JMM.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了同步块之间的发生之前关系：一个同步块的结束发生在任何其他同步块的开始之前，这是由JMM保证的。
- en: We should also note that the Java source compiler ensures that every code path
    through a method that contains a `monitorenter` will result in a `monitorexit`
    being executed before the method terminates. Not only this, but at class loading
    time, the classfile verifier will reject any class that tries to circumvent this
    rule.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注意，Java源代码编译器确保每个包含`monitorenter`的方法中的代码路径都会在方法终止前执行一个`monitorexit`。不仅如此，在类加载时，类文件验证器会拒绝任何试图规避此规则的类。
- en: 'We can now see the basis for the claim that “synchronization is a cooperative
    mechanism in Java.” Let’s look at what happens when thread A calls `safeWithdraw()`
    and thread B calls `rawDeposit()`:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到“同步是Java中的合作机制”这一说法的基础。让我们看看当线程A调用`safeWithdraw()`而线程B调用`rawDeposit()`时会发生什么：
- en: '[PRE32]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We’ve reproduced the Java code once again for easy comparison:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次重现了Java代码，以便于比较：
- en: '[PRE33]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The depositing code is very simple: just one field read, an arithmetic operation,
    and a write back to the same field, as shown here:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 存款代码非常简单：只读取一个字段，进行算术运算，然后将结果写回同一个字段，如下所示：
- en: '[PRE34]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The bytecode looks more complicated but actually isn’t:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码看起来更复杂，但实际上并不复杂：
- en: '[PRE35]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note The code for `rawDeposit()` does not contain any `monitor` instructions—and
    without a `monitorenter`, the lock will never be checked.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`rawDeposit()`的代码中不包含任何`monitor`指令——没有`monitorenter`，锁将永远不会被检查。
- en: 'An ordering like this, between two threads `A` and `B`, is entirely possible,
    as shown next:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个线程`A`和`B`之间，这种排序是完全可能的，如下所示：
- en: '[PRE36]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Writes to the balance (via unsynchronized method)
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过非同步方法对余额的写入
- en: ❷ Second write to the balance (via synchronized)
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过同步对余额进行第二次写入
- en: 'This is just our old friend Lost Update, but now it occurs when one of the
    methods uses synchronization and one doesn’t. The amount deposited has been lost—good
    news for the bank, but not so good for the customer. The inescapable conclusion
    is this: to get the protections provided by synchronization, *all* methods must
    use it correctly.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们熟悉的老朋友“丢失更新”，但现在它发生在一种方法使用同步而另一种方法没有使用同步的情况下。存款金额已经丢失——这对银行是个好消息，但对客户来说却不是那么好。不可避免的结论是：为了获得同步提供的安全保护，*所有*方法都必须正确使用它。
- en: 5.5.3 Synchronized methods
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.3 同步方法
- en: 'Until now, we have been talking about the case of synchronized blocks, but
    what about the case of synchronized *methods*? We might guess that the compiler
    will insert synthetic `monitor` bytecodes, but that’s actually not the case, as
    we can see if we change our safe methods to look like this:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在谈论同步块的情况，但同步*方法*的情况又如何呢？我们可能会猜测编译器会插入合成的`monitor`字节码，但实际上并非如此，正如我们通过将安全方法修改如下所示可以看到：
- en: '[PRE37]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Instead of showing up in the bytecode sequence, the `synchronized` modifier
    for the method actually shows up in the method’s flags, as `ACC_SYNCHRONIZED`.
    We can see this by recompiling the method and noticing that the `monitor` instructions
    have disappeared, as shown here:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，方法上的`synchronized`修饰符并没有出现在字节码序列中，而是出现在方法的标志中，作为`ACC_SYNCHRONIZED`。我们可以通过重新编译方法并注意到`monitor`指令已经消失来看到这一点，如下所示：
- en: '[PRE38]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When executing an `invoke` instruction, one of the first things the bytecode
    interpreter checks is to see whether the method is `synchronized`. If it is, then
    the interpreter proceeds down a different code path—first by trying to acquire
    the appropriate lock. If the method does not have the `ACC_SYNCHRONIZED`, then
    no such check is done.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`invoke`指令时，字节码解释器首先检查的一件事是查看该方法是否是`synchronized`。如果是，则解释器沿着不同的代码路径进行——首先尝试获取适当的锁。如果没有`ACC_SYNCHRONIZED`，则不会进行此类检查。
- en: This means that, just as we might expect, an unsynchronized method can execute
    at the same time as a synchronized one because only one of them performs a check
    for the lock.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，正如我们可能预期的，一个非同步方法可以与一个同步方法同时执行，因为只有一个方法执行了锁的检查。
- en: 5.5.4 Unsynchronized reads
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.4 非同步读取
- en: A very common beginner’s error with Java concurrency is to assume that “only
    methods that write data need to be synchronized; reads are safe.” This is emphatically
    not true, as we will demonstrate.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发中一个非常常见的初学者错误是假设“只有写入数据的方法需要同步；读取是安全的。”这绝对不是真的，我们将证明这一点。
- en: This false sense of security for reads sometimes occurs because the code example
    being reasoned about is a bit too simple. What happens when we introduce a small
    ATM fee to our example—say, 1% of the amount being withdrawn?
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对读取操作的错误安全感有时发生，因为正在推理的代码示例过于简单。当我们向示例中引入一小笔ATM费用时——比如说，取款金额的1%——会发生什么？
- en: '[PRE39]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The bytecode for this method is now a bit more complex:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的字节码现在稍微复杂一些：
- en: '[PRE40]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Compares balance to amount
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 比较余额与金额
- en: ❷ The account balance is updated.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更新账户余额。
- en: ❸ The fee is applied and the balance updated again.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 应用费用并再次更新余额。
- en: Note that there are now two `putfield` instructions, because `safeWithdraw()`
    takes a `boolean` parameter that determines whether a fee should be charged. The
    fact that two separate updates occur is what raises the potential for a concurrency
    bug.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在有两个`putfield`指令，因为`safeWithdraw()`方法接受一个`boolean`参数，用于确定是否应收费。两次单独更新的事实引发了并发错误的潜在可能性。
- en: 'The code for reading the raw balance is very simple:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 读取原始余额的代码非常简单：
- en: '[PRE41]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, this can be interleaved with the withdraw-with-fee code like this:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可以与带有费用的取款代码交织在一起，如下所示：
- en: '[PRE42]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ The balance written with the amount (but not the fee) deducted
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 减去金额（但不是费用）后写入的余额
- en: ❷ The balance read while the full withdraw is still being processed
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在完整取款处理过程中读取的余额
- en: With an unsynchronized read, there is the possibility of a *nonrepeatable read*—a
    value that does not actually correspond to a real state of the system. If you’re
    familiar with SQL databases, this may remind you of performing a read partway
    through a database transaction.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在非同步读取中，存在发生*不可重复读取*的可能性——一个实际上并不对应于系统真实状态的价值。如果你熟悉SQL数据库，这可能会让你想起在数据库事务进行中执行读取操作。
- en: Note You might be tempted to think, “I know the bytecodes,” and optimize your
    code based on that. You should resist this temptation for several reasons. For
    example, what happens when you have handed over your code and it is maintained
    by other developers who do not understand the context or consequences of seemingly
    harmless code changes?
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可能会想，“我知道字节码”，并基于此优化你的代码。你应该抵制这种诱惑，有几个原因。例如，当你将代码交给其他开发者维护，而这些开发者不了解看似无害的代码更改的上下文或后果时，会发生什么？
- en: 'The conclusion: there is no get-out clause for “just reads.” If even one code
    path fails to use synchronization correctly, the resulting code is not thread-safe
    and so is incorrect in a multithreaded environment. Let’s move on and take a look
    at how deadlock shows up in bytecode.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 结论：对于“仅读取”没有逃避的途径。如果即使一个代码路径未能正确使用同步，生成的代码也不是线程安全的，因此在多线程环境中是不正确的。让我们继续前进，看看死锁如何在字节码中体现出来。
- en: 5.5.5 Deadlock revisited
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.5 再次探讨死锁
- en: 'Suppose the bank wants to add the ability to transfer money between accounts
    into our code. An initial version of this code might look like this:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 假设银行想要将账户间转账的功能添加到我们的代码中。这个代码的初始版本可能看起来像这样：
- en: '[PRE43]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This produces quite a long bytecode listing, so we have shortened it by omitting
    the by-now-familiar sequence for checking that the balance can support the withdrawal
    and some synthetic exception-handling blocks.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生相当长的字节码列表，所以我们通过省略检查余额是否支持取款以及一些合成异常处理块来缩短它。
- en: Note There are now two account objects, and each of them has a lock. To be safe,
    we need to coordinate access to both locks—the lock belonging to `this` and that
    belonging to `other`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：现在有两个账户对象，每个对象都有一个锁。为了安全起见，我们需要协调对两个锁的访问——属于`this`的锁和属于`other`的锁。
- en: 'We will need to deal with *two* pairs of `monitor` instructions, with each
    pair dealing with the lock of a different object:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理*两对*`monitor`指令，每一对处理不同对象的锁：
- en: '[PRE44]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Acquires a lock on this object
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取这个对象的锁
- en: ❷ Acquires a lock on the other object
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取另一个对象的锁
- en: ❸ Releases the lock on the other object
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 释放另一个对象的锁
- en: ❹ Releases the lock on this object
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 释放这个对象的锁
- en: 'Imagine two threads that are trying to transfer money between the same two
    accounts—let’s call the threads `A` and `B`. Let’s further suppose that the threads
    are executing transactions that are labeled by the sending account, so thread
    `A` is trying to send money from object `A` to object `B` and vice versa:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 想象有两个线程正在尝试在相同的两个账户之间转账——让我们称这两个线程为`A`和`B`。进一步假设，这两个线程正在执行由发送账户标记的事务，因此线程`A`正在尝试从对象`A`向对象`B`转账，反之亦然：
- en: '[PRE45]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ The lock acquired on account object A (by thread A)
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 线程A获取的账户对象A的锁（由线程A获取）
- en: ❷ The lock acquired on account object B (by thread B)
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 线程B获取的账户对象B的锁
- en: ❸ Thread B tries to acquire a lock on object A. It fails and blocks.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 线程B尝试获取对象A的锁。它失败了，然后阻塞。
- en: ❹ Thread A tries to acquire a lock on object B. It fails and blocks.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 线程A尝试获取对象B的锁。它失败了，然后阻塞。
- en: After executing this sequence, neither thread can make progress. Worse yet,
    only thread A can release the lock on object `A`, and only thread B can release
    the lock on object `B`, so these two threads are permanently blocked by the synchronization
    mechanism, and these method calls will never complete. By viewing the deadlock
    antipattern at a bytecode level, we can see clearly what actually causes it.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个序列后，两个线程都无法继续前进。更糟糕的是，只有线程A可以释放对象`A`的锁，只有线程B可以释放对象`B`的锁，所以这两个线程被同步机制永久阻塞，这些方法调用将永远不会完成。通过在字节码级别查看死锁反模式，我们可以清楚地看到它实际上是由什么引起的。
- en: 5.5.6 Deadlock resolved, revisited
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.6 死锁解决，重新审视
- en: 'To solve this problem, as we discussed earlier, we need to ensure that the
    locks are always acquired in the same order by every thread. One way to do this
    is by creating an ordering on the threads—say, by introducing a unique account
    number and implementing the rule: “acquire the lock corresponding to the lowest
    account ID first.”'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，正如我们之前讨论的，我们需要确保每个线程总是以相同的顺序获取锁。一种方法是为线程创建一个排序——比如说，通过引入一个唯一的账户号并实施规则：“首先获取对应最低账户ID的锁。”
- en: Note For objects that don’t have numeric IDs, we will need to do something different,
    but the general principle of using an unambiguous *total order* still applies.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于没有数字ID的对象，我们需要做些不同的事情，但使用不明确的*总顺序*的一般原则仍然适用。
- en: 'This method produces a bit more complexity, and to do it completely correctly,
    we need a guarantee that the account IDs are not reused. We can do this by introducing
    a `static int` field, which holds the next account ID to be allocated, and updating
    it only in a `synchronized` method, like this:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法会产生一点更多的复杂性，为了完全正确地执行它，我们需要保证账户ID不会被重复使用。我们可以通过引入一个`static int`字段来实现，这个字段持有下一个要分配的账户ID，并且只在一个`synchronized`方法中更新它，如下所示：
- en: '[PRE46]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We don’t need to synchronize the `getAccountId()` method because the field
    is `final` and can’t change, as illustrated here:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要同步`getAccountId()`方法，因为字段是`final`的，不能改变，如下所示：
- en: '[PRE47]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The resulting Java code is, of course, a little asymmetrical.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的Java代码当然有点不对称。
- en: Note By avoiding holding any locks for any longer than necessary makes it clear
    which parts of the code actually require locks.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：通过避免持有任何锁超过必要的时间，可以清楚地知道代码的哪些部分实际上需要锁。
- en: 'The previous code produces a very long bytecode listing, but let’s break it
    down by parts. First off, we check the ordering of the account IDs:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码产生了一个非常长的字节码列表，但让我们按部分来分解它。首先，我们检查账户ID的排序：
- en: '[PRE48]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If `A < B` (which it is), then we move on to instruction 24; otherwise, we
    jump ahead to 91, as follows:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`A < B`（确实如此），则继续执行到指令24；否则，跳转到91，如下所示：
- en: '[PRE49]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ The start of synchronized (this) {
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `synchronized(this)`的开始
- en: ❷ If insufficient funds exist, bails out to offset 77 (further on)
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果资金不足，则跳转到偏移量77（稍后）
- en: 'Let’s follow the branch where the sending account has sufficient funds to continue,
    so control falls through to bytecode 38, which is the start of the `balance =
    balance - amount;` statement in the Java code:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟随发送账户有足够资金继续的分支，因此控制流通过字节码 38，这是 Java 代码中 `balance = balance - amount;`
    语句的开始：
- en: '[PRE50]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ The start of synchronized (other) {
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ synchronized (other) {} 的开始
- en: ❷ The end of synchronized (other) {
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ synchronized (other) {} 的结束
- en: ❸ The end of synchronized (this) {
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ synchronized (this) {} 的结束
- en: 'For completeness, let’s show the code path used in the case of insufficient
    balance in the sending account. We basically just unlock the monitor on `this`
    and return this:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，让我们展示在发送账户余额不足的情况下的代码路径。我们基本上只是解锁 `this` 上的监视器并返回这个：
- en: '[PRE51]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ The end of synchronized (this) {
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ synchronized (this) {} 的结束
- en: 'Note that some of the instructions (such as `invoke` and `monitor` instructions)
    may throw exceptions, so we are, as usual, ignoring the bytecode handlers for
    those exceptions. The rest of the method looks like this:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些指令（如 `invoke` 和 `monitor` 指令）可能会抛出异常，所以我们，像往常一样，忽略这些异常的字节码处理器。方法的其余部分如下所示：
- en: '[PRE52]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Let’s look at what happens with two threads, remembering that the account ID
    of `A < B`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个线程会发生什么，记住账户 ID `A < B`。
- en: 'We now have one additional complication: the local variables (used in instructions
    such as `aload_0`) are different between the two threads. To draw out this distinction,
    we’ll slightly mangle the bytecode by labeling the local variable with the thread
    as well, so we’ll write `aload_A0` and `aload_A1` for clarity:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个额外的复杂性：两个线程中的局部变量（在 `aload_0` 等指令中使用）是不同的。为了突出这种区别，我们将稍微修改字节码，通过将线程标签添加到局部变量上，以便我们用
    `aload_A0` 和 `aload_A1` 来表示，以增加清晰度：
- en: '[PRE53]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ❶ The lock acquired on object A by thread A
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 线程 A 获取对象 A 的锁
- en: '❷ The lock attempted on object A by thread B: blocks'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 线程 B 尝试获取对象 A 的锁：阻塞
- en: ❸ The lock acquired on object B by thread A
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 线程 A 获取对象 B 的锁
- en: ❹ The lock released on object B by thread A
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 线程 A 释放对象 B 的锁
- en: '❺ The lock released on object A by thread A: thread B can resume'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 线程 A 释放对象 A 的锁：线程 B 可以继续执行
- en: This is, without doubt, a complex listing. The key insight is that `A0 == B1`,
    so locking these two objects will always induce a blocking call in the second
    thread. The invariant `A < B` ensures that thread B is sent down the alternate
    branch.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，这是一个复杂的列表。关键洞察是 `A0 == B1`，因此锁定这两个对象将始终在第二个线程中引起阻塞调用。不变量 `A < B` 确保线程 B
    被发送到替代分支。
- en: 5.5.7 Volatile access
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.7 可见性访问
- en: What does `volatile` look like in bytecode? Let’s take a look at an important
    pattern— *Volatile Shutdown*—to help answer this.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在字节码中 `volatile` 看起来是什么样子？让我们通过查看一个重要的模式——*Volatile Shutdown*——来帮助回答这个问题。
- en: 'The Volatile Shutdown pattern helps solve the problem of interthread communication
    that we touched upon earlier when we met the dangerous and deprecated `stop()`
    method. Consider a simple class that is responsible for doing some work. In the
    simplest case, we will assume that work comes in discrete units, with a well-defined
    “complete” status for each unit, as shown next:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: Volatile Shutdown 模式有助于解决我们在遇到危险的已弃用 `stop()` 方法时提到的线程间通信问题。考虑一个负责执行一些工作的简单类。在最简单的情况下，我们将假设工作以离散的单位到来，每个单位都有一个定义良好的“完成”状态，如下所示：
- en: '[PRE54]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The intent of the pattern is hopefully clear. All the time the `shutdown` flag
    is `false`, work units will continue to be processed. If it ever flips to `true`,
    then the `TaskManager` will, after it has completed its current work unit, exit
    the `while` loop and the thread will exit cleanly, in a “graceful shutdown.”
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的意图希望是清晰的。只要 `shutdown` 标志为 `false`，工作单元将继续被处理。如果它变为 `true`，那么 `TaskManager`
    在完成当前工作单元后，将退出 `while` 循环，线程将干净地退出，即“优雅关闭”。
- en: 'The more subtle point is derived from the Java Memory Model: any write to a
    volatile variable Happens-Before all subsequent reads of that variable. As soon
    as another thread calls `shutdown()` on the `TaskManager` object, the flag is
    changed to `true` and the effect of that change is guaranteed to be visible on
    the next read of the flag—before the next work unit is accepted.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 更微妙的一点来自于 Java 内存模型：对任何 volatile 变量的写入都会在所有后续对该变量的读取之前发生。一旦另一个线程在 `TaskManager`
    对象上调用 `shutdown()`，标志将变为 `true`，并且该变化的效果将保证在下一个读取标志时可见——在下一个工作单元被接受之前。
- en: 'The Volatile Shutdown pattern produces bytecode like this:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: Volatile Shutdown 模式生成的字节码如下所示：
- en: '[PRE55]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you look carefully, you can see that the volatile nature of `shutdown` does
    not appear anywhere except in the field definition. There are no additional clues
    on the opcodes—and it is accessed using the standard `getfield` and `putfield`
    opcodes.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会发现`shutdown`的volatile特性仅在字段定义中出现。在操作码中没有额外的线索——它使用标准的`getfield`和`putfield`操作码进行访问。
- en: Note `volatile` is a hardware access mode and produces a CPU instruction that
    says to ignore the cache hardware and instead read or write directly from main
    memory.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`volatile`是一种硬件访问模式，它产生一个CPU指令，指示忽略缓存硬件，而是直接从主内存中读取或写入。
- en: The only difference is in how `putfield` and `getfield` behave—the implementation
    of the bytecode interpreter will have separate code paths for volatile and standard
    fields.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别在于`putfield`和`getfield`的行为——字节码解释器的实现将为volatile字段和标准字段提供不同的代码路径。
- en: In fact, *any* piece of physical memory can be accessed in a volatile manner,
    and—as we will see later on—this is not the only access mode possible. The volatile
    case is merely a common case of access semantics that James Gosling and the original
    designers of Java chose to encode in the core of the language, by making it a
    keyword that can apply to fields.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，*任何*物理内存都可以以volatile的方式访问，并且——正如我们稍后将看到的——这并不是唯一的访问模式。volatile只是访问语义的常见情况，James
    Gosling和Java的原始设计者选择将其编码在语言的核心中，通过将其作为一个可以应用于字段的关键字。
- en: Concurrency is one of the most important features of the Java platform, and
    a good developer will increasingly need a solid understanding of it. We’ve reviewed
    the underpinnings of Java’s concurrency and the design forces that occur in multithreaded
    systems. We’ve discussed the Java Memory Model and low-level details of how the
    platform implements concurrency.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是Java平台最重要的特性之一，一个优秀的开发者将越来越需要对其有一个坚实的理解。我们已经回顾了Java并发的底层原理以及多线程系统中出现的设计力量。我们讨论了Java内存模型以及平台实现并发的底层细节。
- en: This chapter isn’t intended to be a complete statement of everything you’ll
    ever need to know about concurrency—it’s enough to get you started and give you
    an appreciation of what you’ll need to learn more about, and stop you from being
    dangerous when writing concurrent code. But you’ll need to know more than we can
    cover here if you’re going to be a truly first-rate developer of multithreaded
    code. A number of excellent books about nothing but Java concurrency are out there.
    One of the best is *Java Concurrency in Practice* by Brian Goetz and others (Addison-Wesley
    Professional, 2006).
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的并不是要完整地陈述你将需要了解的所有关于并发的知识——它足以让你开始学习，并让你了解你需要进一步学习的内容，以及在你编写并发代码时避免危险。但如果你想要成为一名真正一流的并发代码开发者，你需要了解的将远超我们在这里所能涵盖的内容。关于Java并发的优秀书籍有很多。其中之一是Brian
    Goetz和其他人合著的《Java并发实践》（Addison-Wesley Professional，2006年）。
- en: Summary
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Java’s threads are a low-level abstraction.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java的线程是一个低级抽象。
- en: Multithreading is present even in the Java bytecode.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程甚至存在于Java字节码中。
- en: The Java Memory Model is very flexible but makes minimal guarantees.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java内存模型非常灵活，但只提供最少的保证。
- en: Synchronization is a cooperative mechanism—all threads must participate to achieve
    safety.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步是一种协作机制——所有线程都必须参与以实现安全性。
- en: Never use `Thread.stop()` or `Thread.suspend()`.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要使用`Thread.stop()`或`Thread.suspend()`。
