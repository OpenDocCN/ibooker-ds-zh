- en: 3 Julia’s support for scaling projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 Julia对项目扩展的支持
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using Julia’s type system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Julia的类型系统
- en: Defining multiple methods for a function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为函数定义多个方法
- en: Working with modules and packages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与模块和包一起工作
- en: Using macros
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用宏
- en: In this chapter, you will learn elements of the Julia language that are important
    when creating larger projects. We start with exploring Julia’s type system. Understanding
    how type hierarchy works is essential to learning how to define multiple methods
    for a single function, a topic we started discussing in section 2.4\. Similarly,
    when you use an existing function, you must know how to find out which types of
    arguments it accepts. Getting an exception because you tried to pass an argument
    of incorrect type when calling a function is one of the most common errors when
    working in Julia. To avoid such problems, you must have a good understanding of
    how Julia’s type system is designed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习在创建大型项目时重要的Julia语言元素。我们从探索Julia的类型系统开始。了解类型层次结构的工作方式对于学习如何为单个函数定义多个方法至关重要，这是我们始于第2.4节讨论的话题。同样，当你使用现有的函数时，你必须知道如何找出它接受的参数类型。在调用函数时尝试传递错误类型的参数并引发异常是Julia中工作最常见错误之一。为了避免这些问题，你必须对Julia的类型系统设计有一个很好的理解。
- en: When you define methods for a function, you can restrict the types of arguments
    they accept. This feature makes your Julia programs faster, allows you to catch
    bugs more easily, and makes it easier to understand how the code works.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为函数定义方法时，你可以限制它们接受的参数类型。这个特性使得你的Julia程序运行更快，更容易捕获错误，并使代码的工作方式更容易理解。
- en: If your projects grow larger, you will need to use third-party functionalities
    provided as packages or organize your source code into modules. In this chapter,
    you will learn how to do that with Julia.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目变得更大，你需要使用第三方功能，这些功能以包的形式提供，或者将你的源代码组织成模块。在本章中，你将学习如何使用Julia来实现这一点。
- en: Finally, in some cases, it is convenient to automatically generate Julia code.
    This is achieved in Julia with macros. The topic of writing your own macros is
    advanced, so in this chapter, you will learn how to use macros that are available
    in Julia.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在某些情况下，自动生成Julia代码是非常方便的。在Julia中，这是通过宏来实现的。编写自己的宏是一个高级话题，所以在本章中，你将学习如何使用Julia中可用的宏。
- en: To show you the practical usefulness of the material I introduce in this chapter,
    we will improve the winsorized_mean function initially implemented in chapter
    2 in terms of its performance, code safety, and readability.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我在本章中介绍的材料在实际中的实用性，我们将改进第2章中最初实现的winsorized_mean函数，从性能、代码安全和可读性等方面进行优化。
- en: 3.1 Understanding Julia’s type system
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 理解Julia的类型系统
- en: As discussed in chapter 2, the winsorized_mean function implemented in section
    2.4 will not work with all possible values of arguments that you could pass to
    it. How can we make sure that it will correctly handle various types of passed
    arguments? To understand this, we first need to discuss the Julia type system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如第2章所述，第2.4节中实现的winsorized_mean函数不会与你可以传递给它的所有可能的参数值一起工作。我们如何确保它能够正确处理各种类型的传入参数？为了理解这一点，我们首先需要讨论Julia的类型系统。
- en: 3.1.1 A single function in Julia may have multiple methods
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 Julia中一个函数可能有多个方法
- en: 'When learning about Julia, you might have heard that it uses *multiple dispatch*
    (mentioned in section 2.4). You can define multiple methods for the same function
    with different implementations, depending on the types of the passed arguments.
    You can use the methods function to get the list of methods defined for a given
    function. Here is an example list of methods for the cd function that sets the
    Julia working directory:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你学习Julia语言时，你可能听说过它使用*多重分派*（在第2.4节中提到）。你可以为同一个函数定义多个方法，这些方法的实现根据传入参数的类型不同而不同。你可以使用methods函数来获取为给定函数定义的方法列表。以下是一个为设置Julia工作目录的cd函数定义的方法列表示例：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see that some of the arguments of the functions have type annotations;
    in this case, they are ::Function and ::AbstractString, which restrict the types
    of values allowed by the given methods and change their behavior, depending on
    types of passed values.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，一些函数的参数有类型注解；在这种情况下，它们是::Function和::AbstractString，这限制了给定方法允许的值的类型，并根据传入值的类型改变其行为。
- en: 'Let’s focus here on the Function type. Intuitively, all functions should have
    this type, and this is typically the case:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里关注函数类型。直观上，所有函数都应该具有这种类型，通常情况下也是如此：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, if we check the type of the sum function, we see that it is not Function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们检查 sum 函数的类型，我们会看到它不是 Function：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To understand what is going on here, we need to know that in Julia, types are
    organized in a hierarchy. This allows the bundling together of several types when
    defining methods for functions. For instance, in the preceding example, the cd
    function can take any function as an argument.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这里发生的事情，我们需要知道在 Julia 中，类型是按照层次结构组织的。这允许在定义函数的方法时将多个类型捆绑在一起。例如，在上一个例子中，cd
    函数可以接受任何函数作为参数。
- en: 3.1.2 Types in Julia are arranged in a hierarchy
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 Julia 中的类型是按照层次结构排列的
- en: 'In Julia, all types are arranged in a tree, and each type has a parent. This
    parent, called a *supertype*, can be checked using the supertype function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，所有类型都排列在一个树中，每个类型都有一个父类型。这个父类型，称为 *超类型*，可以使用 supertype 函数来检查：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, indeed, we see that the type of the sum function is a *subtype* of the
    Function type. The following rules govern how the type tree works (here I show
    the main mental model and omit discussion of some corner cases):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们确实看到 sum 函数的类型是 Function 类型的 *子类型*。以下规则控制着类型树的工作方式（在这里我展示了主要的心智模型，并省略了一些边缘情况的讨论）：
- en: The root type of the tree is called Any. All other types are subtypes of the
    Any type. If you define a function without specifying its argument(s) type, as
    we did in section 2.4, Julia assumes by default that the Any type is allowed;
    that is, you can pass a value of any type to such a function.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树的根类型称为 Any。所有其他类型都是 Any 类型的子类型。如果你定义一个函数而没有指定其参数类型，就像我们在 2.4 节中所做的那样，Julia
    默认假设允许 Any 类型；也就是说，你可以向这样的函数传递任何类型的值。
- en: Only the types that are leaves can have instances (that is, have objects that
    are of that specific type). The types that can be instantiated are called *concrete*.
    In other words, if you have a value, you can be sure that its type is concrete
    and that it is a leaf type. For this reason, there is no function whose type is
    Function. Every function has its own unique concrete type that is a subtype of
    the Function type.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有叶类型才能有实例（也就是说，有特定类型的对象）。可以实例化的类型被称为 *具体的*。换句话说，如果你有一个值，你可以确信它的类型是具体的，并且它是一个叶类型。因此，没有类型是
    Function 的函数。每个函数都有其独特的具体类型，它是 Function 类型的子类型。
- en: The types that are not leaves of the type tree (for example, Any or Function)
    cannot be instantiated. They serve only as intermediate types allowing for logical
    grouping of other types and are called *abstract*. You can find the list of subtypes
    of an abstract type by calling the subtypes function.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型树中不是叶子的类型（例如，Any 或 Function）不能被实例化。它们仅作为中间类型，允许对其他类型进行逻辑分组，并被称为 *抽象的*。你可以通过调用
    subtypes 函数来找到抽象类型的子类型列表。
- en: Concrete vs. abstract types
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 具体类型与抽象类型
- en: Only concrete types can be instantiated and cannot have concrete subtypes. You
    can check whether a given type is concrete by using the isconcretetype function.
    Abstract types cannot have instances but can have subtypes. You can check whether
    a given type is abstract by using the isabstracttype function. Therefore, it is
    not possible for a type to be both abstract and concrete.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 只有具体类型可以被实例化，不能有具体的子类型。你可以使用 isconcretetype 函数来检查给定的类型是否是具体的。抽象类型不能有实例，但可以有子类型。你可以使用
    isabstracttype 函数来检查给定的类型是否是抽象的。因此，一个类型既抽象又具体是不可能的。
- en: However, some types are neither abstract nor concrete. You will encounter these
    types in chapter 4 when you learn more about parametric types. An example of such
    a type is Vector. (Note that this type has its parameter left out, and this is
    why it is not concrete; in section 2.1, you saw an example of a value having Vector{Int},
    which is a concrete type as it has a fully specified parameter, Int in that case.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些类型既不是抽象的也不是具体的。当你学习更多关于参数化类型的内容时，你将在第 4 章遇到这些类型。这种类型的一个例子是 Vector。（注意，这个类型省略了其参数，这就是为什么它不是具体的；在
    2.1 节中，你看到了一个具有 Vector{Int} 的值的例子，这是一个具体的类型，因为它有一个完全指定的参数，在这种情况下是 Int。）
- en: 3.1.3 Finding all supertypes of a type
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 查找类型的所有超类型
- en: 'Let’s see the supertype and subtypes functions in action. First, we start with
    the Int64 type that you already know and check which supertypes it has. For this,
    we define the following recursive function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 supertype 和 subtypes 函数的实际应用。首先，我们从你已知的 Int64 类型开始，检查它有哪些超类型。为此，我们定义以下递归函数：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The print_supertypes function accepts a type as its argument.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ print_supertypes 函数接受一个类型作为其参数。
- en: As you can see, the type hierarchy is quite deep. This allows your functions
    to have fine-grained control of the types of arguments they accept.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，类型层次结构相当深。这允许您的函数对它们接受的参数类型有精细的控制。
- en: In our function, we traverse the type tree recursively. In this example, we
    start with the Int64 type. We first print it. Next, we check whether it is equal
    to the Any type. Int64 is not equal to Any; therefore, since we used the || operator,
    we execute the print_supertypes(supertype(T)) expression. It calls the print_supertypes
    function again with a supertype of Int64, which is Signed. The process is repeated
    recursively until print_supertypes is passed the Any type as an argument, the
    root
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的函数中，我们递归地遍历类型树。在这个例子中，我们从Int64类型开始。我们首先打印它。接下来，我们检查它是否等于Any类型。Int64不等于Any；因此，由于我们使用了||运算符，我们执行了print_supertypes(supertype(T))表达式。它再次调用print_supertypes函数，这次以Int64的超类型作为参数，即Signed。这个过程递归重复，直到print_supertypes函数以Any类型作为参数，即类型树的根。
- en: of the type tree. At that point, we do not perform a recursive call of the print_supertypes
    function, and the process terminates. Figure 3.1 illustrates the result; the arrow
    indicates the subtype relationship.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们不执行print_supertypes函数的递归调用，过程终止。图3.1说明了结果；箭头指示子类型关系。
- en: '![CH03_F01_Kaminski2](../Images/CH03_F01_Kaminski2.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F01_Kaminski2](../Images/CH03_F01_Kaminski2.png)'
- en: Figure 3.1 The print_supertypes function accepts a type as its argument.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 print_supertypes函数接受一个类型作为其参数。
- en: Also, you might have noticed the return nothing line in our code. It serves
    the purpose discussed in section 2.4—namely, the recommendation that all functions
    should explicitly specify the value they want to return. In this case, because
    we do not want any specific value to be returned, we return the nothing value
    to signal that there’s nothing to return from the function. If a function returns
    nothing, the Julia REPL does not print any return value to the terminal. Therefore,
    in this example, the only things that get printed are the types outputted by the
    println(T) operation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可能已经注意到了我们代码中的return nothing行。它服务于2.4节中讨论的目的——即所有函数应明确指定它们想要返回的值。在这种情况下，因为我们不希望返回任何特定值，所以我们返回nothing值以表示函数中没有返回值。如果一个函数返回nothing，Julia的REPL不会在终端打印任何返回值。因此，在这个例子中，唯一打印的是println(T)操作输出的类型。
- en: 3.1.4 Finding all subtypes of a type
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.4 查找类型的所有子类型
- en: 'Now we will do the reverse operation and try to print all subtypes of the Integer
    abstract type. Here is the code that performs this operation. In this example,
    we use recursion again. This time, the recursion stops when a type does not have
    any subtypes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将进行相反的操作，尝试打印Integer抽象类型的所有子类型。以下是执行此操作的代码。在这个例子中，我们再次使用递归。这次，当类型没有子类型时，递归停止：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You have learned that the Integer type has three subtypes: Bool, Signed, and
    Unsigned. The Bool type does not have a subtype, while Signed and Unsigned are
    abstract and have a wide range of subtypes with differing memory footprints in
    bits (indicated by the number in the type name; see section 2.1 for a discussion
    about bitwise representation of different numeric types). Figure 3.2 presents
    this type hierarchy.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解到整数类型有三个子类型：Bool、Signed和Unsigned。Bool类型没有子类型，而Signed和Unsigned是抽象的，并且具有广泛的子类型，这些子类型在位（由类型名称中的数字表示；参见2.1节关于不同数值类型的位表示的讨论）中具有不同的内存占用。图3.2展示了这个类型层次结构。
- en: '![CH03_F02_Kaminski2](../Images/CH03_F02_Kaminski2.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F02_Kaminski2](../Images/CH03_F02_Kaminski2.png)'
- en: Figure 3.2 Hierarchy of subtypes of the Integer type
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 Integer类型的子类型层次结构
- en: You might ask what the " " ^ indent_ level expression does in the preceding
    code. It simply repeats the " " string indent_level times. Chapter 6 covers more
    details about working with strings in Julia.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问，前述代码中的" " ^ indent_level表达式是什么意思。它只是重复" "字符串indent_level次。第6章将详细介绍在Julia中处理字符串的更多细节。
- en: 3.1.5 Union of types
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.5 类型联合
- en: Referring to collections of types by using abstract types is useful. However,
    sometimes you might want to specify a list of types that do not have the respective
    node (abstract type) in the type tree. For instance, what if you want to allow
    only signed or unsigned integers in your code but not Bool values? You could use
    the Union keyword. In our scenario, if you write Union{Signed, Unsigned}, you
    tell Julia that you allow any of the types specified inside the curly brackets
    after the Union keyword.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抽象类型引用类型集合是有用的。然而，有时你可能想要指定一个没有相应节点（抽象类型）的类型树中的类型列表。例如，如果你想在代码中只允许有符号或无符号整数，但不允许
    Bool 值，你可以使用 Union 关键字。在我们的场景中，如果你写 Union{Signed, Unsigned}，你告诉 Julia 允许 Union
    关键字后面的花括号内指定的任何类型。
- en: In data science workflows, the Union keyword is often used when we specify a
    union between a certain type and the Missing type. For instance, if you write
    Union{String, Missing}, you indicate that a value must be a String but can optionally
    be missing. Chapter 7 covers handling missing values in more detail.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据科学工作流程中，当我们指定某种类型与 Missing 类型之间的联合时，通常会使用 Union 关键字。例如，如果你写 Union{String,
    Missing}，你表示一个值必须是一个 String，但也可以是可选的缺失值。第 7 章更详细地介绍了处理缺失值。
- en: 3.1.6 Deciding what type restrictions to put in method signature
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.6 决定在方法签名中放置哪些类型限制
- en: 'Let’s now go back to our winsorized_mean function from section 2.4\. It takes
    two arguments: an integer k and a vector x. What are appropriate type restrictions
    for these arguments? For k, this is easy. From what you have learned, it is natural
    to require that k is an Integer. What about x? Let’s check the type and the supertype
    of the vector [1.0, 2.0, 3.0] and range 1:3 by using the print_supertypes function
    we defined previously:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到 2.4 节中的 winsorized_mean 函数。它接受两个参数：一个整数 k 和一个向量 x。这些参数的适当类型限制是什么？对于 k，这很简单。根据你所学的，自然要求
    k 是一个 Integer。那么 x 呢？让我们使用我们之前定义的 print_supertypes 函数检查向量 [1.0, 2.0, 3.0] 和范围
    1:3 的类型和其超类型：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We see that the type hierarchy is a bit deep, but the types seem to meet at
    AbstractVector level; the only problem is that in the first case, we have a Float64
    parameter of the type, and in the second case, Int64. An intuitive and correct
    solution is to just drop the parameter and require x to be AbstractVector. This
    is what we will do in section 3.2\. Let’s see what AbstractVector is:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到类型层次结构有点深，但类型似乎在 AbstractVector 层级上相遇；唯一的问题是，在第一种情况下，我们有一个 Float64 类型的参数，而在第二种情况下，是
    Int64。一个直观且正确的方法是只删除参数，并要求 x 是 AbstractVector。这就是我们在 3.2 节将要做的。让我们看看 AbstractVector
    是什么：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The where T addition in the alias explanation means that T can be any type.
    An alternative way to learn the correct common type of [1.0, 2.0, 3.0] and 1:3
    would be to use the typejoin function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在别名解释中添加 where T 意味着 T 可以是任何类型。学习 [1.0, 2.0, 3.0] 和 1:3 的正确公共类型的一个替代方法是使用类型join
    函数：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The typejoin function finds the narrowest type that is a supertype of types
    passed as its arguments. You will not need this function often, but it is useful
    to confirm our intuition in this case.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类型join 函数找到其参数类型中最窄的父类型。你可能不会经常用到这个函数，但它在确认我们的直觉方面很有用。
- en: The topic of working with types is much more complex than what we have covered
    here. We will come back to it in chapter 5, which covers parametric types and
    the where keyword. However, I still skip many concepts related to types in this
    book. When doing data science, you will usually not need to define your own types,
    so I have left out the process of creating your own types, defining constructors,
    and defining type promotion and conversion rules. A definitive guide to these
    topics is the “Types” section of the Julia Manual ([https://docs.julialang.org/en/v1/manual/types/](https://docs.julialang.org/en/v1/manual/types/)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与类型一起工作的主题比我们在这里所涵盖的复杂得多。我们将在第 5 章中回到这个话题，该章涵盖了参数类型和 where 关键字。然而，我在这本书中仍然省略了许多与类型相关的概念。在进行数据科学时，你通常不需要定义自己的类型，所以我省略了创建自己的类型、定义构造函数以及定义类型提升和转换规则的过程。关于这些主题的权威指南是
    Julia 手册中的“类型”部分（[https://docs.julialang.org/en/v1/manual/types/](https://docs.julialang.org/en/v1/manual/types/))。
- en: 3.2 Using multiple dispatch in Julia
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 在 Julia 中使用多重分派
- en: Now that you know how to define functions and how type hierarchy works, you
    are ready to learn to define functions that have different methods. You can then
    apply this knowledge to our winsorized_mean function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何定义函数以及类型层次结构是如何工作的，你就可以学习如何定义具有不同方法的函数了。然后你可以将这种知识应用到我们的 winsorized_mean
    函数中。
- en: 3.2.1 Rules for defining methods of a function
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 定义函数方法规则
- en: Fortunately, defining methods is relatively easy if you understand the principles
    of how Julia’s type system works. You just add the type restriction to the arguments
    of the function after ::. As discussed in section 3.1, if the type specification
    part is omitted, Julia assumes that a value of Any type is allowed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，如果你理解了 Julia 类型系统的工作原理，定义方法相对简单。你只需在函数参数后添加类型限制 ::。如第 3.1 节所述，如果省略类型指定部分，Julia
    假设允许 Any 类型的值。
- en: 'Assume we want to create the function fun by taking a single positional argument
    with the following behavior:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要通过接受单个位置参数并具有以下行为来创建函数 fun：
- en: If fun is passed a number, it should print a number was passed, unless it is
    a value having Float64 type, in which case we want a Float64 value printed.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果向 fun 传递一个数字，它应该打印“传递了一个数字”，除非它是一个具有 Float64 类型的值，在这种情况下，我们希望打印一个 Float64
    值。
- en: In all other cases, we want to print unsupported type.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有其他情况下，我们希望打印“不支持类型”。
- en: 'Here is an example of implementing this behavior by defining three methods
    for a function fun:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个通过为函数 fun 定义三个方法来实现这种行为的例子：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, 1 is a Number (as it is Int) but is not Float64, for instance,
    so the most specific matching method is fun(x::Number).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，1 是一个 Number（因为它是一个 Int），但它不是 Float64，例如，所以最具体的匹配方法是 fun(x::Number)。
- en: 3.2.2 Method ambiguity problem
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 方法歧义问题
- en: When defining multiple methods for a function, you must avoid method ambiguities.
    They happen when the Julia compiler is not able to decide which method for a given
    set of arguments should be selected.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当为函数定义多个方法时，你必须避免方法歧义。当 Julia 编译器无法决定给定参数集应该选择哪个方法时，就会发生歧义。
- en: 'It is easier to understand the problem with an example. Assume you want to
    define a bar function taking two positional arguments. The bar function should
    inform you if any of these arguments are numbers. Here is a first attempt to implement
    this function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个例子更容易理解这个问题。假设你想要定义一个接受两个位置参数的 bar 函数。bar 函数应该告诉你这些参数中是否有任何是数字。这是实现这个函数的第一个尝试：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, everything works nicely until we want to call bar by passing
    a number as both its first and second argument. In this case, Julia complains
    that it does not know which method should be called, as two of them potentially
    could be selected. Fortunately, we get a hint as to how to resolve the situation.
    We need to define an additional method that fixes the ambiguity:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，直到我们想要通过传递两个参数（第一个和第二个）都是数字来调用 bar 时，一切工作得都很顺利。在这种情况下，Julia 会抱怨它不知道应该调用哪个方法，因为可能有两个方法可以被选中。幸运的是，我们得到了如何解决这种情况的提示。我们需要定义一个额外的、解决歧义的方法：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Why is multiple dispatch useful?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 多重分派有什么用？
- en: Understanding how methods work in Julia is essential. As you could see in the
    preceding examples, this knowledge allows users to differentiate behavior of functions,
    based on the type of any positional argument of the function. Combined with the
    flexible type hierarchy system discussed in section 3.1, multiple dispatch allows
    Julia programmers to write highly flexible and reusable code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Julia 中方法的工作原理是至关重要的。正如你在前面的例子中所看到的，这种知识使用户能够根据函数任何位置参数的类型来区分函数的行为。结合第 3.1
    节中讨论的灵活的类型层次系统，多重分派允许 Julia 程序员编写高度灵活和可重用的代码。
- en: Observe that by specifying types at a suitable level of abstraction, the user
    does not have to think of every possible concrete type that could be passed to
    the function while still retaining control of the kind of values that are accepted.
    For instance, if you define your own Number subtype—as is done, for example, by
    the Decimals.jl package ([https://github.com/JuliaMath/Decimals.jl](https://github.com/JuliaMath/Decimals.jl))
    that features types supporting decimal floating-point calculations of arbitrary
    precision—you do not have to rewrite your code. Everything will just work with
    the new type, even if the original code was not developed specifically to target
    this use case.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过在适当的抽象级别指定类型，用户不需要考虑所有可能的具体类型，这些类型可以传递给函数，同时仍然保留对接受值的类型的控制。例如，如果你定义了自己的
    Number 子类型——例如，通过 Decimals.jl 包（[https://github.com/JuliaMath/Decimals.jl](https://github.com/JuliaMath/Decimals.jl)），该包具有支持任意精度十进制浮点计算的类型——你不需要重写你的代码。新类型将正常工作，即使原始代码并不是专门针对这个用例开发的。
- en: 3.2.3 Improved implementation of winsorized mean
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 改进的 winsorized mean 实现
- en: 'We are ready to improve our winsorized_mean function definition. Here is how
    you could implement it more carefully than we did in section 2.4:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好改进winsorized_mean函数的定义。以下是如何比我们在2.4节中做得更仔细地实现它的方法：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'First note that we have restricted the allowed types for x and k; therefore,
    if you try to invoke the function, its arguments must match the required types:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先请注意，我们已经限制了x和k的允许类型；因此，如果你尝试调用该函数，其参数必须匹配所需的类型：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Additionally, we can see several changes in the code that make it more robust.
    First, we check if passed arguments are consistent; that is, if k is negative
    or too large, it is invalid, in which case we throw an error by calling the throw
    function with ArgumentError as its argument. See what happens if we pass the wrong
    k:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以看到一些使代码更健壮的代码更改。首先，我们检查传递的参数是否一致；也就是说，如果k是负数或太大，则无效，在这种情况下，我们通过调用带有ArgumentError作为其参数的throw函数来抛出错误。看看如果我们传递错误的k会发生什么：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, make a copy of the data stored in the x vector before sorting it. To achieve
    this, we use the collect function, which takes any iterable collection and returns
    an object storing the same values that has a Vector type. We pass this vector
    to the sort! function to sort it in place.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在排序之前，先复制存储在x向量中的数据。为了实现这一点，我们使用collect函数，它接受任何可迭代集合，并返回一个存储相同值的对象，具有Vector类型。我们将这个向量传递给sort!函数以就地排序。
- en: You might ask why using the collect function to allocate a new Vector is needed.
    The reason is that, for example, ranges like 1:10 are read-only; therefore, later,
    we would not be able to update y with y[i] = y[k + 1] and y[end - the + 1] = y[end
    -- k]. Additionally, in general, Julia can support non-1-based indexing in arrays
    (see [https://github.com/JuliaArrays/OffsetArrays.jl](https://github.com/JuliaArrays/OffsetArrays.jl)).
    However, Vector uses 1-based indexing. In summary, using the collect function
    turns any collection or general AbstractVector into a standard Vector type defined
    in Julia that is mutable and uses 1-based indexing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么需要使用collect函数来分配一个新的Vector。原因是，例如，像1:10这样的范围是只读的；因此，之后我们就无法通过y[i] =
    y[k + 1]和y[end - the + 1] = y[end -- k]来更新y。此外，通常Julia可以支持数组中的非1基索引（见[https://github.com/JuliaArrays/OffsetArrays.jl](https://github.com/JuliaArrays/OffsetArrays.jl)）。然而，Vector使用1基索引。总之，使用collect函数将任何集合或通用AbstractVector转换为Julia中定义的标准Vector类型，该类型是可变的，并使用1基索引。
- en: Finally, note that instead of performing the for loop manually, we have just
    used the sum function, which is both simpler and more robust.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，我们不是手动执行for循环，而是使用了sum函数，这使得代码既简单又健壮。
- en: Does adding argument type annotations in methods improve their execution speed?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中添加参数类型注解是否会提高它们的执行速度？
- en: You have seen in section 3.2 that adding type annotations to function arguments
    makes the Julia code easier to read and safer. A natural question that users often
    ask is whether this improves code execution speed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你在3.2节中已经看到，给函数参数添加类型注解可以使Julia代码更容易阅读和更安全。用户经常问的一个自然问题是，这是否会提高代码执行速度。
- en: If you have a single method for a function, adding type annotations does not
    improve code execution speed. The reason is that when a function is called, the
    Julia compiler knows the types of arguments that you have passed to it and generates
    the native machine code using this information. In other words, type restriction
    information does not affect code generation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为函数只有一个方法，添加类型注解不会提高代码执行速度。原因是当函数被调用时，Julia编译器知道你传递给它的参数类型，并使用这些信息生成本机机器代码。换句话说，类型限制信息不会影响代码生成。
- en: However, the situation is different if you have multiple methods defined for
    a function. This is because type restrictions influence method dispatch. Then,
    each method can have a different implementation using an algorithm optimized for
    a value of a given type. Using multiple dispatch allows the Julia compiler to
    pick the implementation that is best for your data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你为函数定义了多个方法，情况就不同了。这是因为类型限制会影响方法调度。然后，每个方法都可以有不同的实现，使用针对给定类型的值优化的算法。使用多重调度允许Julia编译器选择最适合你的数据的实现。
- en: Let’s look at an example. Consider the sort function introduced in chapter 2\.
    By calling methods(sort), you can learn that it has five methods defined in Base
    Julia (and possibly more if you loaded Julia packages). There is a general method
    for sorting vectors with the signature sort(v::AbstractVector; kwthe.) and a specialized
    method for sorting ranges like 1:3 that has the signature sort(r::Abstract- UnitRange).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。考虑第2章中引入的sort函数。通过调用methods(sort)，你可以了解到它在Base Julia中定义了五个方法（如果你加载了Julia包，可能还有更多）。有一个用于排序向量的通用方法，其签名是sort(v::AbstractVector;
    kwthe.)，还有一个用于排序范围如1:3的专用方法，其签名是sort(r::Abstract- UnitRange)。
- en: What is the benefit of having this specialized method? The second method is
    defined as sort(r::AbstractUnitRange) = r. Since we know that objects of type
    AbstractUnitRange are already sorted (they are ranges of values with an increment
    equal to 1), we can just return the passed value. In this case, taking advantage
    of type restriction in the method signature can significantly improve the sort
    operation performance. In section 3.4, you will learn how to check that this is
    indeed the case by using benchmarking.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有这种专用方法的好处是什么？第二个方法定义为sort(r::AbstractUnitRange) = r.。因为我们知道类型为AbstractUnitRange的对象已经是排序好的（它们是值范围，增量等于1），所以我们只需返回传递的值。在这种情况下，利用方法签名中的类型限制可以显著提高排序操作的性能。在3.4节中，你将学习如何通过使用基准测试来检查这一点。
- en: 3.3 Working with packages and modules
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 与包和模块一起工作
- en: Larger programs in Julia require structure that helps organize their code. Therefore,
    it is likely that someone already implemented a function like our winsorized_mean
    because it is a commonly used statistical method. In Julia, such functions are
    shared using packages. So, if someone did create a function like ours, then instead
    of writing our own function, we could use the one defined in a package. That’s
    why you need to know how to use packages in Julia.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中的大型程序需要结构来帮助组织它们的代码。因此，很可能有人已经实现了一个像我们的winsorized_mean这样的函数，因为它是一种常用的统计方法。在Julia中，这样的函数是通过包共享的。所以，如果有人创建了一个像我们这样的函数，那么我们就不必编写自己的函数，而可以使用包中定义的那个。这就是为什么你需要知道如何在Julia中使用包。
- en: 3.3.1 What is a module in Julia?
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 Julia中的模块是什么？
- en: A starting point in this discussion is understanding the concept of a *module*
    and how it is related to *packages* and *files*. Let’s start by working with multiple
    files, as this is the easiest to understand.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个讨论的起点是理解模块的概念以及它与*包*和*文件*的关系。让我们从处理多个文件开始，因为这最容易理解。
- en: 'Assume your code is split into three files—file1.jl, file2.jl, and file3.jl—and
    you want to create a main file—call it, for example, main.jl—that uses these three
    files. You can achieve this by using the include function. Assume that the source
    code of your main.jl file is the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的代码被拆分成了三个文件——file1.jl、file2.jl和file3.jl——并且你想要创建一个主文件——比如，可以叫main.jl——它使用这三个文件。你可以通过使用include函数来实现这一点。假设你的main.jl文件中的源代码如下：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, if you execute it, simplifying a bit, it would work as if you had copied
    and pasted the contents of file1.jl into it, then copied and pasted the contents
    of file2.jl into it, and finally copied and pasted file3.jl. As you can see, the
    logic of the include function is easy. It just allows you to split the code into
    multiple files to make them smaller.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果你执行它，简化一下，它的工作方式就像你将file1.jl的内容复制并粘贴进去，然后复制并粘贴file2.jl的内容进去，最后复制并粘贴file3.jl。正如你所看到的，include函数的逻辑很简单。它只是允许你将代码拆分成多个文件，以使它们更小。
- en: In Julia, the pattern I have just shown you is common. You create one main file
    that does have a minimal amount of logic and mostly serves as a place to include
    other files where the actual code is stored.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，我刚刚展示的模式很常见。你创建一个主文件，它确实包含最小量的逻辑，并且主要作为一个包含实际代码存储的其他文件的位置。
- en: So, what are modules? *Modules* are a way to define separate variable namespaces.
    Back in section 2.4, I told you there that there is one global scope in your program.
    Now you will learn that there can be many, as each module defines its own separate
    global scope. The default global scope when you work with Julia is also a module
    that is called Main (therefore, in many of the listings in this chapter, you have
    seen that functions are defined in Main).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，模块是什么？*模块*是一种定义独立的变量命名空间的方式。在2.4节中，我告诉你程序中有一个全局作用域。现在你将了解到可以有多个，因为每个模块定义了自己的独立的全局作用域。当你使用Julia时，默认的全局作用域也是一个名为Main的模块（因此，在本章的许多列表中，你已经看到函数是在Main中定义的）。
- en: 'You can define the module ExampleModule that defines a single function called
    example by using the module keyword argument like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用模块关键字参数像这样定义一个名为 ExampleModule 的模块，该模块定义了一个名为 example 的单个函数：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You might have noticed two stylistic things in this example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了这个例子中的两个风格问题：
- en: Code inside the module is not indented as a convention (unlike all other blocks
    in Julia). Modules can get very large (spanning even thousands of lines), so using
    four-space indentation for the entire content of the module would not be practical.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块内的代码按照惯例不缩进（与 Julia 中所有其他块不同）。模块可以非常大（甚至跨越数千行），因此为模块的全部内容使用四个空格缩进并不实用。
- en: There is a convention to put a comment with the module name after the end keyword
    argument. Again, modules typically contain hundreds or even thousands of lines
    of code. Therefore, it is often hard to visually identify that the end keyword
    is finishing the definition of the module. For this reason, it is useful to explicitly
    indicate the end by using a comment.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个惯例是在结束关键字参数后添加一个带有模块名称的注释。再次强调，模块通常包含数百甚至数千行代码。因此，很难从视觉上识别结束关键字是否完成了模块的定义。因此，使用注释明确指出结束是有用的。
- en: 'When doing data science projects with Julia, you most often will not need to
    define your own modules, so let me highlight some key practical concepts:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Julia 进行数据科学项目时，你通常不需要定义自己的模块，所以让我强调一些关键的实际概念：
- en: Unlike Python, modules have no relationship with how the code is organized into
    files. You can have many modules in a single file, or a single module can be defined
    in multiple files (combined using the include function). Modules are used only
    to give a logical structure to your code by defining separate variable namespaces
    and module-specific global scopes.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Python 不同，模块与代码如何组织成文件没有关系。你可以在单个文件中拥有许多模块，或者一个模块可以在多个文件中定义（使用 include 函数组合）。模块仅用于通过定义单独的变量命名空间和模块特定的全局作用域，为你的代码提供逻辑结构。
- en: A module designer can decide which variables and functions are exposed to the
    module users by using the export keyword.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块设计者可以使用 export 关键字决定哪些变量和函数对模块用户是可用的。
- en: If someone creates a module that is intended to be shared with other Julia users,
    it can be registered with the Julia general registry ([https://github.com/JuliaRegistries/General](https://github.com/JuliaRegistries/General)).
    These modules must have a special structure, and after being registered, they
    become available as *packages*. You can find instructions for managing packages
    in appendix A.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人创建了一个打算与其他 Julia 用户共享的模块，它可以通过 Julia 通用注册表（[https://github.com/JuliaRegistries/General](https://github.com/JuliaRegistries/General)）进行注册。这些模块必须具有特殊结构，注册后，它们作为
    *包* 可用。你可以在附录 A 中找到管理包的说明。
- en: Simplifying a bit, you can think of modules and packages as follows. Modules
    give you the capability to organize code into coherent units. When a developer
    decides to share the functionality provided by a module with other Julia users,
    this module can be annotated with proper metadata (like its version) and registered
    as a package. You can find detailed information about package creation, development,
    and management in the Pkg.jl package documentation at [https://pkgdocs.julialang.org/v1/](https://pkgdocs.julialang.org/v1/).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，你可以这样理解模块和包。模块赋予你将代码组织成连贯单元的能力。当开发者决定将模块提供的功能与其他 Julia 用户共享时，这个模块可以通过适当的元数据（如版本）进行标注，并注册为包。你可以在
    Pkg.jl 包文档中找到有关包创建、开发和管理的详细信息，文档地址为 [https://pkgdocs.julialang.org/v1/](https://pkgdocs.julialang.org/v1/)。
- en: Julia’s standard library
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的标准库
- en: Normally, when you want to use a package, you need to install it (installation
    is explained in appendix A). However, Julia gets shipped with a set of standard
    library modules. These behave like regular Julia packages, but you don’t need
    to install them explicitly. An example of such a module that we use in this chapter
    is Statistics. You can find documentation of all standard library modules in the
    “Standard Library” section of the Julia Manual ([https://docs.julialang.org/en/v1/](https://docs.julialang.org/en/v1/)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你想要使用一个包时，你需要安装它（安装将在附录 A 中解释）。然而，Julia 随附了一套标准库模块。它们的行为类似于常规的 Julia 包，但你不需要明确安装它们。我们在这个章节中使用的此类模块的例子是
    Statistics。你可以在 Julia 手册的“标准库”部分找到所有标准库模块的文档（[https://docs.julialang.org/en/v1/](https://docs.julialang.org/en/v1/)）。
- en: 3.3.2 How can packages be used in Julia?
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 在 Julia 中如何使用包？
- en: 'Knowing how to use modules that are bundled into packages is important for
    a data scientist. You have two basic ways to make the functionality of an installed
    package usable in your code: using the import or using keyword arguments. When
    you use import, only the module name is brought into the scope of your code. To
    access variables and functions defined by the module, you need to prefix their
    names with the module name, followed by a dot. Here is an example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用捆绑到包中的模块对于数据科学家来说很重要。你有两种基本方法可以使已安装包的功能在你的代码中使用：使用 import 或 using 关键字参数。当你使用
    import 时，只有模块名称被引入到你的代码作用域中。要访问模块定义的变量和函数，你需要用模块名称作为前缀，后面跟着一个点。以下是一个例子：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Statistics module is shipped with the Julia standard library. It defines
    basic statistical functions like mean, std, var, and quantile. As you can see,
    when we used import, we had to prefix the function name with Statistics to make
    things work.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Statistics 模块是 Julia 标准库的一部分。它定义了基本统计函数，如 mean、std、var 和 quantile。正如你所见，当我们使用
    import 时，我们必须在函数名称前加上 Statistics 以使一切正常工作。
- en: 'Instead, with the using keyword, we bring all exported functionalities of the
    module into the scope so they can be used directly. Therefore, following the preceding
    example, we have this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用 using 关键字，我们将模块的所有导出功能引入到作用域中，以便可以直接使用。因此，根据前面的例子，我们有以下内容：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code works because the mean function is exported by the Statistics module.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以正常工作，因为 mean 函数是由 Statistics 模块导出的。
- en: Now you might wonder if you should be using the import or the using statements
    in your code. This is a question often asked by Python users who learn that it
    is safe to import only the functions or variables that they plan to use in code.
    This is not the case in Julia.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道在代码中你应该使用 import 还是 using 语句。这是 Python 用户经常问的问题，他们了解到只导入计划在代码中使用的函数或变量是安全的。在
    Julia 中情况并非如此。
- en: 'In most Julia code, you can safely employ the using statement, and this is
    what people normally do. You already know the reason: the Julia language can automatically
    detect if a name you are trying to use conflicts with an identical name already
    introduced with, for example, the using keyword. In such cases, you will be informed
    that there is a problem.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Julia 代码中，你可以安全地使用 using 语句，这也是人们通常的做法。你已经知道原因：Julia 语言可以自动检测你试图使用的名称是否与已通过例如
    using 关键字引入的相同名称冲突。在这种情况下，你会被告知存在问题。
- en: 'Let me go through the most common situations where you might see name conflict
    problems. In the first example, you define a variable name that is later introduced
    from the module with the using statement. Start a fresh Julia session for this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我通过一些最常见的情况来解释你可能会遇到名称冲突问题。在第一个例子中，你定义了一个变量名，后来通过 using 语句从模块中引入。为此，请启动一个新的
    Julia 会话：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, since you already defined the mean variable, loading the Statistics
    module, which exports the mean function, produces a warning but does not overshadow
    your definition. You would have to call the mean function from this module by
    using the form with the prefix—that is, Statistics.mean.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，因为你已经定义了 mean 变量，加载导出 mean 函数的 Statistics 模块会产生警告，但不会覆盖你的定义。你必须使用带有前缀的形式从这个模块中调用
    mean 函数——即 Statistics.mean。
- en: 'In the second scenario, you try to make an assignment to a variable that has
    a name that conflicts with a function from a loaded module that was already used
    (start a fresh Julia session again):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，你试图将一个与已加载模块中的函数名称冲突的变量名赋值（再次启动一个新的 Julia 会话）：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This time, you get an error; from the point where you have used the mean function
    from the Statistics module, you are not allowed to assign a value to it in your
    code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你得到了一个错误；从你使用 Statistics 模块中的 mean 函数的那一刻起，你就不允许在代码中为其赋值。
- en: 'In the last scenario, you first load a module and then define a conflicting
    variable name before using the same name defined in the module (start a fresh
    Julia session):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下，你首先加载一个模块，然后在使用模块中定义的相同名称之前定义一个冲突的变量名（再次启动一个新的 Julia 会话）：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now you are allowed to freely define the mean variable without a warning. Later,
    if you want to use the mean function from the Statistics module, you again would
    need to write Statistics.mean. For convenience, you’re allowed to define the variable
    in your global scope in this case without an error or a warning. If you are never
    planning to use a certain name from a loaded module, it is not brought into scope.
    This is useful when you already have some working code and need to start using
    an additional module that exports the name that you already use in your code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您被允许自由定义均值变量而不会收到警告。稍后，如果您想使用来自 Statistics 模块的 mean 函数，您又需要再次编写 Statistics.mean。为了方便起见，在这种情况下，您可以在全局作用域中定义变量而不会出现错误或警告。如果您永远不会计划使用从已加载的模块中加载的某个名称，则该名称不会被引入作用域。这在您已经有了一些正在运行的代码并需要开始使用一个导出您已在代码中使用名称的额外模块时非常有用。
- en: In such a scenario, this behavior ensures that you do not have to change your
    original code; it will keep working as it did before. The mental model that you
    can build to understand this behavior is that Julia is lazy; it introduces a variable
    into scope and resolves its name the first time it is used.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这种行为确保您不需要更改您的原始代码；它将像以前一样继续工作。您可以建立的心理模型是 Julia 是懒惰的；它在第一次使用时将变量引入作用域并解析其名称。
- en: 3.3.3 Using StatsBase.jl to compute the winsorized mean
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 使用 StatsBase.jl 计算winsorized均值
- en: 'We are now ready to go back to our winsorized_mean example. Assuming you have
    the StatsBase.jl package installed, you can find that it provides the winsor function.
    After loading Statistics and StatsBase, you can check its help (start a fresh
    Julia session):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备回到我们的 winsorized_mean 示例。假设您已安装了 StatsBase.jl 包，您会发现它提供了 winsor 函数。在加载
    Statistics 和 StatsBase 之后，您可以检查其帮助信息（启动一个新的 Julia 会话）：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s check to see if it indeed produces the same result as winsorized_mean
    for our data:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查它是否确实产生了与我们的数据中的 winsorized_mean 相同的结果：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Why do you need to restart your Julia session?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么您需要重启您的 Julia 会话？
- en: In several examples in this section, I have prompted you to start a fresh Julia
    session. This is because it is currently impossible to fully reset the workspace
    after you have defined variables or functions in it. For instance, as you saw
    in our examples, after we used the mean function from the Statistics module, we
    were not allowed to create a variable that would have the mean name.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中的几个示例中，我已提示您启动一个新的 Julia 会话。这是因为目前无法在定义了变量或函数后完全重置工作空间。例如，正如您在示例中看到的，在我们使用了来自
    Statistics 模块的 mean 函数之后，我们不允许创建一个具有 mean 名称的变量。
- en: Since users often need this functionality when working interactively, the Julia
    development team plans to add the capability to clear the workspace without restarting
    Julia sessions in the future.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户在交互式工作时经常需要此功能，Julia 开发团队计划在未来添加清除工作空间而不重启 Julia 会话的功能。
- en: As usual, if you would like to learn more details about modules, refer to the
    Julia Manual ([https://docs.julialang.org/en/v1/manual/modules/](https://docs.julialang.org/en/v1/manual/modules/)).
    Detailed information about how to create packages and how the Julia package manager
    works is provided in the Pkg.jl package documentation ([https://pkgdocs.julialang.org/v1/](https://pkgdocs.julialang.org/v1/)).
    Appendix A explains how to install packages in Julia and get help regarding their
    functionality.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，如果您想了解更多关于模块的详细信息，请参阅 Julia 手册 ([https://docs.julialang.org/en/v1/manual/modules/](https://docs.julialang.org/en/v1/manual/modules/))。有关如何创建包以及
    Julia 包管理器如何工作的详细信息，请参阅 Pkg.jl 包文档 ([https://pkgdocs.julialang.org/v1/](https://pkgdocs.julialang.org/v1/))。附录
    A 解释了如何在 Julia 中安装包以及如何获取它们功能方面的帮助。
- en: 'Wrapping up the discussion about modules and packages, it is important to discuss
    the Julia community’s conventions for managing their functionality. The design
    of Julia, in terms of provided functionalities and functions, follows a similar
    principle to Python''s “batteries included” approach:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论模块和包的总结中，讨论 Julia 社区管理其功能的标准非常重要。就提供的功能和方法而言，Julia 的设计遵循与 Python 的“电池包含”方法相似的原则：
- en: By default, you are given access to a very limited set of functions, defined
    in the Base module that is always loaded when you start Julia.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，您只能访问在 Base 模块中定义的一组非常有限的函数，该模块在启动 Julia 时始终被加载。
- en: Julia comes with many preinstalled packages that form a Julia standard library
    that you can load if needed. These modules provide functionality such as string
    handling, working with dates and time, multithreading and distributed computing,
    I/O, sorting, basic statistics, random number generation, linear algebra, serialization
    of Julia objects, and testing.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 随带了许多预安装的包，这些包构成了 Julia 标准库，你可以在需要时加载。这些模块提供了诸如字符串处理、处理日期和时间、多线程和分布式计算、I/O、排序、基本统计、随机数生成、线性代数、Julia
    对象序列化和测试等功能。
- en: If you require functionality that is unavailable in the standard library, the
    easiest thing to do is to look for it in packages. JuliaHub ([https://juliahub.com/ui/Packages](https://juliahub.com/ui/Packages))
    provides a flexible web interface allowing you to browse available packages.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要标准库中不可用的功能，最简单的方法是查找它所在的包。JuliaHub ([https://juliahub.com/ui/Packages](https://juliahub.com/ui/Packages))
    提供了一个灵活的网页界面，允许你浏览可用的包。
- en: The meaning of the Base Julia term
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Base Julia 术语的含义
- en: Often, in this book, as well as in other resources on Julia, you’ll see the
    term *Base Julia*. This refers to the Base module that Julia defines. This module
    provides a set of definitions that are always loaded by Julia when you run it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在这本书以及其他关于 Julia 的资源中，你会看到术语 *Base Julia*。这指的是 Julia 定义的 Base 模块。此模块提供了一组定义，当你在运行
    Julia 时，这些定义总是被加载。
- en: Doing statistics with Julia
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Julia 进行统计分析
- en: Julia comes with the Statistics module as part of its standard library. This
    module contains basic statistics functionalities that allow you to compute the
    mean, variance, standard deviation, Pearson correlation, covariance, median, and
    quantiles of your data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 随带 Statistics 模块作为其标准库的一部分。此模块包含基本统计功能，允许你计算数据的均值、方差、标准差、皮尔逊相关、协方差、中位数和分位数。
- en: More advanced statistical functionalities are provided by the packages from
    the JuliaStats collection ([https://juliastats.org/](https://juliastats.org/)).
    The StatsBase.jl package discussed in this chapter is part of JuliaStats. This
    package defines functions that allow you to compute weighted statistics of your
    data, and provides functionalities such as rankings and rank correlations, along
    with various data-sampling algorithms.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: JuliaStats 收集中的更多高级统计功能提供了。本章讨论的 StatsBase.jl 包是 JuliaStats 的一部分。此包定义了允许你计算数据加权统计函数，并提供诸如排名和秩相关以及各种数据抽样算法的功能。
- en: Other popular packages from JuliaStats are Distributions.jl (providing support
    for various probability distributions), HypothesisTests.jl (defining many commonly
    used statistical tests), MultivariateStats.jl (for multivariate statistical analysis
    like principal component analysis), Distances.jl (for efficient computing of distances
    between vectors), KernelDensity.jl (for kernel density estimation), Clustering.jl
    (providing algorithms for data clustering), and GLM.jl (allowing you to estimate
    generalized linear models).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: JuliaStats 的其他流行包包括 Distributions.jl（提供各种概率分布的支持）、HypothesisTests.jl（定义了许多常用的统计测试）、MultivariateStats.jl（用于多元统计分析，如主成分分析）、Distances.jl（用于高效计算向量之间的距离）、KernelDensity.jl（用于核密度估计）、Clustering.jl（提供数据聚类算法）和
    GLM.jl（允许你估计广义线性模型）。
- en: 3.4 Using macros
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 使用宏
- en: The last important feature of Julia that you are going to encounter in this
    book is the macro. As a data scientist, you likely will not need to define your
    own macros, but expect to use them quite often, especially in part 2, when we
    will discuss the domain-specific language (DSL) defined in the DataFramesMeta.jl
    package that allows working conveniently with data frames.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书中遇到 Julia 的最后一个重要特性是宏。作为一名数据科学家，你可能不需要定义自己的宏，但预期你会经常使用它们，尤其是在第 2 部分，我们将讨论
    DataFramesMeta.jl 包中定义的特定领域语言（DSL），它允许方便地处理数据框。
- en: For our current purposes, we will need to use the @time macro to compare the
    performance of our winzorized_mean function against the implementation provided
    by the StatsBase.jl package.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的目的下，我们需要使用 @time 宏来比较我们的 winzorized_mean 函数与 StatsBase.jl 包提供的实现之间的性能。
- en: So, what does a macro do? *Macros* are used to generate your program’s code.
    You can think of macros as functions that take a parsed representation of Julia
    code and return its transformation (technically, macros operate at a level of
    *abstract syntax trees* [[http://mng.bz/5mKZ](http://mng.bz/5mKZ)]).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，宏到底做了什么？*宏*用于生成你的程序代码。你可以把宏看作是接受 Julia 代码的解析表示并返回其转换（技术上，宏在 *抽象语法树* 的层面上操作
    [[http://mng.bz/5mKZ](http://mng.bz/5mKZ)]）的函数。
- en: It is important to understand that macros are executed after Julia code is parsed,
    but before it is compiled. If you know the Lisp programming language, you will
    notice similarities in the way Julia and Lisp support macros. Note that in Julia,
    macros are different from C macros that perform textual manipulation of the source
    code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，宏是在 Julia 代码解析之后、编译之前执行的。如果你了解 Lisp 编程语言，你会注意到 Julia 和 Lisp 在支持宏的方式上有相似之处。请注意，在
    Julia 中，宏与执行源代码文本操作的 C 宏不同。
- en: 'You can easily recognize macro calls in the code, as a macro is always prefixed
    with the @ character. Here is an example of a macro call:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地在代码中识别宏调用，因为宏总是以 @ 字符为前缀。以下是一个宏调用的例子：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, we use the @time macro and pass the 1 + 2 expression to it.
    This macro executes the passed expression and prints the time it took to execute.
    As you can see, unlike functions, you can call macros without using parentheses.
    However, you could also enclose the expression passed to the macro in parentheses:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 @time 宏并将 1 + 2 表达式传递给它。这个宏执行传递的表达式并打印出执行所需的时间。如你所见，与函数不同，你可以不使用括号来调用宏。然而，你也可以将传递给宏的表达式用括号括起来：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is an example of calling a macro taking two arguments:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个调用接受两个参数的宏的例子：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that if you do not use parentheses, the expressions passed to the macro
    should be separated with a space (a comma must not be used in this case).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你不使用括号，传递给宏的表达式应该用空格分隔（在这种情况下不能使用逗号）。
- en: 'You now know how macros are called, but what do they do? As I have said, they
    rewrite your code to generate new, transformed code. You can easily see this rewritten
    code by using the @macroexpand macro. Let’s start with a simple example of the
    @assert macro:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道了宏是如何被调用的，但它们到底做了什么？正如我所说的，它们重写你的代码以生成新的、转换后的代码。你可以通过使用 @macroexpand 宏轻松地看到这段重写的代码。让我们从一个简单的
    @assert 宏的例子开始：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, in this case, the generated code is relatively simple. The @assert
    macro has created the if block, which does nothing if the assertion is true and
    throws an error if the assertion is false.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这种情况下，生成的代码相对简单。@assert 宏创建了一个 if 块，如果断言为真则什么都不做，如果断言为假则抛出错误。
- en: 'Of course, normally macros can generate much more complex code. For example,
    the @time macro performs multiple operations to ensure proper measurement of the
    execution time of the passed expression:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，通常宏可以生成更复杂的代码。例如，@time 宏执行多个操作以确保正确测量传递表达式的执行时间：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, a seemingly simple operation of measuring execution time is,
    in fact, quite complex.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，看似简单的测量执行时间的操作实际上相当复杂。
- en: Now you might ask why @time is a macro and not just a function. If you were
    to define the time function instead and write time(1 + 2), the 1 + 2 expression
    would be evaluated before it was passed to the function, so it would be impossible
    to measure the time it took to execute it. To measure the execution time of an
    expression, we must augment it with proper code before the expression is run.
    This is possible only during parsing of the Julia code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会问为什么 @time 是一个宏而不是一个函数。如果你定义的是 time 函数而不是宏，并编写 time(1 + 2)，那么 1 + 2 表达式会在传递给函数之前被评估，因此无法测量其执行时间。为了测量一个表达式的执行时间，我们必须在表达式运行之前增加适当的代码。这只有在解析
    Julia 代码时才可能实现。
- en: It is worth remembering the @macroexpand macro, as you will find it useful when
    learning the DataFramesMeta.jl package in part 2.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是 @macroexpand 宏，因为你在学习 DataFramesMeta.jl 包的第二部分时会发现它很有用。
- en: As usual in this chapter, let’s use the winsorized_mean example to test macros.
    We’ll compare the performance of our solution with the performance of the implementation
    from StatsBase.jl. For benchmarking, we will use the @benchmark macro from the
    BenchmarkTools.jl package. It differs from the @time macro in that it runs the
    expression many times and then calculates the statistics of the observed run times
    (before running this code, define the winsorized_mean function by using the code
    from section 3.2). In the example code, I added a semicolon (;) after the rand(10^6)
    expression to suppress printing of its value to the terminal.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章惯例，让我们使用winsorized_mean示例来测试宏。我们将比较我们的解决方案与StatsBase.jl实现的性能。对于基准测试，我们将使用BenchmarkTools.jl包中的@benchmark宏。它与@time宏的不同之处在于它多次运行表达式，然后计算观察到的运行时间的统计数据（在运行此代码之前，请使用第3.2节中的代码定义winsorized_mean函数）。在示例代码中，我在rand(10^6)表达式后添加了一个分号（;），以抑制将其值打印到终端。
- en: 'We start with the benchmark of our winsorized_mean function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基准测试我们的winsorized_mean函数开始：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Uses ; at the end of the expression passed in the REPL to suppress printing
    its value to the terminal
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在REPL传入的表达式末尾使用分号（;）来抑制将其值打印到终端
- en: ❷ Since x is a global variable, uses $x to ensure proper benchmarking of the
    tested code
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 由于x是一个全局变量，使用$x来确保测试代码的正确基准测试
- en: You should get a timing similar to the one presented in figure 3.3 (exact timings
    might differ slightly on your machine).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到与图3.3中所示类似的计时结果（在您的机器上，精确的计时可能略有不同）。
- en: '![CH03_F03_Kaminski2](../Images/CH03_F03_Kaminski2.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F03_Kaminski2](../Images/CH03_F03_Kaminski2.png)'
- en: Figure 3.3 Benchmark of execution time of the winsorized_mean function
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 winsorized_mean函数的执行时间基准测试
- en: 'Now we benchmark computation of the winsorized mean by using the functions
    provided by the packages from the Julia statistics ecosystem:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用Julia统计生态系统中的包提供的函数来基准测试winsorized mean的计算：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code produces the timing presented in figure 3.4\. Using library functions
    is noticeably faster.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 代码产生了图3.4中所示的计时结果。使用库函数要快得多。
- en: '![CH03_F04_Kaminski2](../Images/CH03_F04_Kaminski2.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F04_Kaminski2](../Images/CH03_F04_Kaminski2.png)'
- en: Figure 3.4 Benchmark of execution time when using the winsor function
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 使用winsor函数的执行时间基准测试
- en: In the example, we first generate one million random floats from the range [0,
    1] by using the rand function. The results of the benchmarks show that the library
    function is around four times faster than our code. The reason for this is relatively
    easy to guess. In our function, we sort the whole vector, while most of the time
    it is not needed, as k is typically relatively small in comparison to the size
    of the vector. The library solution uses the partialsort! function to improve
    its efficiency.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们首先使用rand函数从范围[0, 1]生成一百万个随机浮点数。基准测试的结果表明，库函数的速度大约是我们代码的四倍。这个原因相对容易猜测。在我们的函数中，我们排序整个向量，而通常情况下，由于k与向量大小相比通常相对较小，所以不需要这样做。库解决方案使用partialsort!函数来提高其效率。
- en: An important aspect of using the @benchmark macro is that we use $x instead
    of just x. This is needed to get a correct assessment of execution time of the
    expressions we check. As a rule, remember to prefix with $ all global variables
    you use in the expressions you want to benchmark (this applies only to benchmarking
    and is not a general rule when using macros). For details about this requirement,
    refer to the documentation of the BenchmarkTools.jl package ([https://github.com/JuliaCI/BenchmarkTools.jl](https://github.com/JuliaCI/BenchmarkTools.jl)).
    The short explanation is as follows. Recall that since x is a global variable,
    code using it is not type stable. When the @benchmark macro sees the $x, it is
    instructed to turn the x variable into one that is local (and thus type stable)
    before running the benchmarks.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用@benchmark宏的一个重要方面是，我们使用$x而不是仅仅使用x。这是为了正确评估我们检查的表达式的执行时间。作为规则，请记住，在您想要基准测试的表达式中使用$前缀来标记所有全局变量（这仅适用于基准测试，并不是使用宏时的通用规则）。有关此要求的详细信息，请参阅BenchmarkTools.jl包的文档([https://github.com/JuliaCI/BenchmarkTools.jl](https://github.com/JuliaCI/BenchmarkTools.jl))。简短的解释如下。回想一下，由于x是一个全局变量，使用它的代码不是类型稳定的。当@benchmark宏看到$x时，它被指示在运行基准测试之前将x变量转换为局部变量（因此是类型稳定的）。
- en: 'The BenchmarkTools.jl package also provides the @btime macro that accepts the
    same arguments as @benchmark. The difference is that it produces less-verbose
    output, similar to @time, and the printed time is the minimum elapsed time measured
    during benchmarking. Here is an example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkTools.jl 包也提供了一个接受与 @benchmark 相同参数的 @btime 宏。区别在于它产生的输出更简洁，类似于 @time，并且打印的时间是基准测试期间测量的最小时间。以下是一个示例：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that the reported time is similar to the minimum time produced by @benchmark
    mean(winsor($x; count=10^5)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，报告的时间与 @benchmark mean(winsor($x; count=10^5)) 生成的最小时间相似。
- en: 'As a final example of applying macros, try writing the following in your Julia
    REPL:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用宏的最后一个例子，尝试在你的 Julia REPL 中写下以下内容：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '@edit is one of my favorite macros. In your source code editor, it takes you
    directly to the source code of the function you are using (you can specify which
    editor should be used by setting the JULIA_EDITOR environment variable; see [http://mng.bz/yaJy](http://mng.bz/yaJy)).
    A huge benefit of using Julia is that this function is most likely written in
    Julia, so you can easily inspect its implementation. I recommend you check how
    the winsor function is implemented to find out the tricks its creators used to
    make it fast.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`@edit` 是我最喜欢的宏之一。在你的源代码编辑器中，它会直接带你到你所使用函数的源代码（你可以通过设置 `JULIA_EDITOR` 环境变量来指定应该使用哪个编辑器；参见
    [http://mng.bz/yaJy](http://mng.bz/yaJy)）。使用 Julia 的一个巨大好处是，这个函数很可能是用 Julia 编写的，因此你可以轻松地检查其实现。我建议你检查
    winsor 函数的实现，以了解其创造者使用了哪些技巧来使其运行得更快。'
- en: Exercise 3.1 Create an x variable that is a range of values from 1 to 10^6.
    Now, using the collect function, create a y vector holding the same values as
    the x range. Using the @btime macro, check the time of sorting x and y by using
    the sort function. Finally, using the @edit macro, check the implementation of
    the sort function that would be invoked when you sort the x range.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.1 创建一个名为 x 的变量，其值为从 1 到 10^6 的范围。现在，使用 `collect` 函数创建一个 y 向量，其包含与 x 范围相同的值。使用
    `@btime` 宏，通过使用 `sort` 函数来检查对 x 和 y 进行排序的时间。最后，使用 `@edit` 宏，检查在排序 x 范围时将被调用的 `sort`
    函数的实现。
- en: That is all you need to know about macros to use them. You will hardly ever
    need to write your own macros, as most of the time, writing functions is enough
    to get what you want. However, sometimes you want certain actions to be performed
    on your code before the code is executed. In these cases, macros are the way to
    achieve the desired result.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要了解关于宏的所有内容，以便使用它们。你几乎不需要编写自己的宏，因为大多数时候，编写函数就足以得到你想要的结果。然而，有时你希望在代码执行之前执行某些操作。在这些情况下，宏是实现预期结果的方法。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Types of variables have a hierarchical relationship and form a tree. The root
    of the tree is the Any type that matches any value. Types that have subtypes are
    called *abstract* and cannot have instances. Types that can have instances cannot
    have subtypes and are called *concrete*.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的类型之间存在层次关系，并形成一个树状结构。树的根是 `Any` 类型，它可以匹配任何值。具有子类型的类型被称为 *抽象* 类型，不能有实例。可以有实例的类型不能有子类型，被称为
    *具体* 类型。
- en: A single function can have multiple methods. Each method has a unique set of
    argument types that it allows.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数可以有多个方法。每个方法都有一个独特的参数类型集，它允许使用这些参数。
- en: In Julia, modules are used to create separate namespaces (global scopes). The
    most common use of modules is for creation of packages. Packages can be registered
    with the Julia general registry and made available for all developers.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Julia 中，模块用于创建独立的命名空间（全局作用域）。模块最常见的使用是创建包。包可以注册到 Julia 通用注册表中，并供所有开发者使用。
- en: Macros in Julia allow you to transform code into other code before it gets executed.
    They are sometimes useful when functions do not allow you to achieve the desired
    result.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 中的宏允许你在代码执行之前将其转换为其他代码。当函数不允许你达到预期结果时，它们有时很有用。
- en: When you install Julia, it comes with “batteries included.” Many modules are
    shipped as part of the standard library and provide essential functionalities
    that are commonly needed in practice. You can explore the additional packages
    in the Julia ecosystem in JuliaHub.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你安装 Julia 时，它“内置”了许多模块。这些模块作为标准库的一部分提供，并提供了在实践中最常需要的功能。你可以在 JuliaHub 中探索 Julia
    生态系统中的额外包。
