- en: Chapter 1\. Introducing Go
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 1 章. Go 语言介绍
- en: '*In this chapter*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章内容*'
- en: Solving modern computing challenges with Go
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Go 解决现代计算挑战
- en: Using the Go tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Go 工具
- en: Computers have evolved, but programming languages haven’t kept up the same pace
    of evolution. The cell phones we carry might have more CPU cores than the first
    computer we used. High-powered servers now have 64, 128, or even more cores, but
    we’re still programming using the techniques we were using for a single core.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机已经发展，但编程语言并没有跟上同样的进化速度。我们携带的手机可能比我们最初使用的第一台计算机拥有更多的 CPU 核心。现在，高性能服务器拥有 64、128
    或更多的核心，但我们仍然使用着为单核设计的编程技术。
- en: 'The art of programming has evolved too. Most programs aren’t written by a single
    developer any more: they’re written by teams of people sitting in different time
    zones and working at different times of the day. Large projects are broken up
    into smaller pieces and assigned to programmers who then deliver their work back
    to the team in the form of a library or package that can be used across an entire
    suite of applications.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 编程艺术也在不断发展。大多数程序不再是单个开发者编写的：它们是由不同时区、不同时间工作的人们组成的团队编写的。大型项目被分解成更小的部分，分配给程序员，然后他们以库或包的形式将他们的工作交付给团队，这些库或包可以在整个应用程序套件中使用。
- en: Today’s programmers and companies believe more than ever in the power of open
    source software. Go is a programming language that makes sharing code easy. Go
    ships with tools that make it simple to use packages written by others, and Go
    makes it easy to share our own packages too.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，程序员和公司比以往任何时候都更相信开源软件的力量。Go 是一种使代码共享变得容易的编程语言。Go 附带了一些工具，使使用他人编写的包变得简单，同时
    Go 也使共享我们自己的包变得容易。
- en: In this chapter you’ll see how Go is different from other programming languages.
    Go rethinks the traditional object-oriented development you might be used to,
    while still providing an efficient means for code reuse. Go makes it easier for
    you to effectively use all of the cores on your expensive server, and it takes
    away the penalty of compiling a very large project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你将看到 Go 语言与其他编程语言的不同之处。Go 重新思考了你可能习惯的传统面向对象开发，同时仍然提供了一种高效的代码重用方法。Go 使你能够更有效地使用昂贵的服务器上的所有核心，并消除了编译一个非常大的项目的惩罚。
- en: 'As you read this chapter, you’ll get a feeling for the many decisions that
    shaped the creation of Go, from its concurrency model to its lightning-fast compiler.
    We mentioned it in the preface, but it bears repeating: this book has been written
    for an intermediate-level developer who has some experience with other programming
    languages and wants to learn Go. Our goal in writing this book is to provide you
    an intensive, comprehensive, and idiomatic view of the language. We focus on both
    the specification and implementation of the language, including the wide-ranging
    topics of language syntax, Go’s type system, concurrency, channels, testing, and
    more. We believe this book is perfect for anyone who wants a jump-start in learning
    Go or who wants a more thorough understanding of the language and its internals.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章时，你会感受到塑造 Go 语言创建的众多决策，从其并发模型到其闪电般的编译器。我们在前言中提到过，但值得再次强调：本书是为有一定其他编程语言经验的初级开发者编写的，他们希望学习
    Go 语言。我们编写本书的目标是为你提供一个密集、全面和地道的语言视角。我们关注语言的规范和实现，包括语言语法、Go 的类型系统、并发、通道、测试等多个广泛的主题。我们相信这本书非常适合那些想要快速入门学习
    Go 语言或希望更深入理解语言及其内部机制的人。
- en: The source code for the examples in the book is available at [https://github.com/goinaction/code](https://github.com/goinaction/code).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 书中示例的源代码可在 [https://github.com/goinaction/code](https://github.com/goinaction/code)
    获取。
- en: We hope you’ll appreciate the tools that ship with Go to make your life as a
    developer easier. In the end, you’ll appreciate why so many developers are choosing
    Go when they start up that new project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你会欣赏 Go 语言附带的各种工具，使你的开发者生活更加轻松。最终，你会理解为什么许多开发者在启动新项目时选择 Go 语言。
- en: 1.1\. Solving modern programming challenges with Go
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1. 使用 Go 解决现代编程挑战
- en: The Go team went to great lengths to solve the problems facing software developers
    today. Developers have to make an uncomfortable choice between rapid development
    and performance when choosing a language for their projects. Languages like C
    and C++ offer fast execution, whereas languages like Ruby and Python offer rapid
    development. Go bridges these competing worlds and offers a high-performance language
    with features that make development fast.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go团队付出了巨大的努力来解决当今软件开发者面临的问题。当开发者选择项目语言时，必须在快速开发和性能之间做出不舒服的选择。像C和C++这样的语言提供快速执行，而像Ruby和Python这样的语言则提供快速开发。Go连接了这些竞争的世界，并提供了具有使开发快速的功能的高性能语言。
- en: As we explore Go, you’ll find well-planned features and concise syntax. As a
    language, Go is defined not only by what it includes, but by what it doesn’t include.
    Go has a concise syntax with few keywords to memorize. Go has a compiler that’s
    so fast, sometimes you’ll forget it’s running. As a Go developer, you’ll spend
    significantly less time waiting for your project to build. Because of Go’s built-in
    concurrency features, your software will scale to use the resources available
    without forcing you to use special threading libraries. Go uses a simple and effective
    type system that takes much of the overhead out of object-oriented development
    and lets you focus on code reuse. Go also has a garbage collector, so you don’t
    have to manage your own memory. Let’s look quickly at these key features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们探索Go，你会发现精心设计的特性和简洁的语法。作为一个语言，Go不仅由它包含的内容定义，还由它不包含的内容定义。Go具有简洁的语法，关键字数量少，易于记忆。Go有一个非常快的编译器，有时你会忘记它在运行。作为一个Go开发者，你将花费显著更少的时间等待项目构建。由于Go内置的并发特性，你的软件将能够扩展以使用可用的资源，而无需强迫你使用特殊的线程库。Go使用简单而有效的类型系统，从面向对象开发中移除了大部分开销，让你能够专注于代码重用。Go还有一个垃圾回收器，因此你不需要管理自己的内存。让我们快速看一下这些关键特性。
- en: 1.1.1\. Development speed
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1. 开发速度
- en: Compiling a large application in C or C++ takes more time than getting a cup
    of coffee. [Figure 1.1](#ch01fig01) shows an XKCD classic excuse for messing around
    in the office.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在C或C++中编译一个大型应用程序所需的时间比喝一杯咖啡还要长。[图1.1](#ch01fig01)展示了XKCD经典的一个在办公室闲逛的借口。
- en: Figure 1.1\. Working hard? (via XKCD)
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1. 工作努力吗？（via XKCD）
- en: '![](01fig01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig01.jpg)'
- en: Go offers lightning-quick compiles by using a smart compiler and simplified
    dependency resolution algorithms. When you build a Go program, the compiler only
    needs to look at the libraries that you directly include, rather than traversing
    the dependencies of all the libraries that are included in the entire dependency
    chain like Java, C, and C++. Consequently, many Go applications compile in under
    a second. The entire Go source tree compiles in under 20 seconds on modern hardware.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Go通过使用智能编译器和简化的依赖解析算法，实现了闪电般的快速编译。当你构建一个Go程序时，编译器只需要查看你直接包含的库，而不是像Java、C和C++那样遍历整个依赖链中包含的所有库的依赖。因此，许多Go应用程序的编译时间不到一秒。在现代化硬件上，整个Go源代码树编译时间不到20秒。
- en: Writing applications in dynamic languages makes you productive quickly because
    there are no intermediate steps between writing code and executing it. The trade-off
    is that dynamic languages don’t offer the type safety that static languages do
    and often need a comprehensive test suite to avoid discovering incorrect type
    bugs at runtime.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态语言编写应用程序可以让你快速变得高效，因为编写代码和执行代码之间没有中间步骤。代价是动态语言不提供静态语言那样的类型安全，并且通常需要一个全面的测试套件来避免在运行时发现不正确的类型错误。
- en: Imagine writing a large application in a dynamic language like JavaScript and
    coming across a function that expects to receive a field called `ID`. Is that
    an integer, a string, or a UUID? The way to find out is to look at the source.
    You could try to execute the function with a number or a string and see what happens.
    In Go, you wouldn’t spend time wondering, because the compiler will catch type
    differences for you.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在像JavaScript这样的动态语言中编写一个大型应用程序，并遇到一个期望接收名为`ID`的字段的函数。这是一个整数、一个字符串还是一个UUID？找出答案的方法是查看源代码。你可以尝试用数字或字符串执行该函数，看看会发生什么。在Go中，你不会浪费时间猜测，因为编译器会为你捕获类型差异。
- en: 1.1.2\. Concurrency
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2. 并发
- en: One of the hardest things to do as a programmer is to write an application that
    effectively uses the available resources of the hardware running it. Modern computers
    have many cores, but most programming languages don’t have effective tools for
    utilizing those additional resources easily. They often require a lot of thread
    synchronization code, which is prone to errors.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，最难的事情之一是编写一个能够有效利用运行其硬件可用资源的应用程序。现代计算机拥有许多核心，但大多数编程语言都没有有效利用这些额外资源的工具。它们通常需要大量的线程同步代码，这些代码容易出错。
- en: Go’s concurrency support is one of its strongest features. Goroutines are like
    threads, but use far less memory and require less code to use. Channels are data
    structures that let you send typed messages between goroutines with synchronization
    built in. This facilitates a programming model where you send data between goroutines,
    rather than letting the goroutines fight to use the same data. Let’s look at these
    features in more detail now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的并发支持是其最强大的功能之一。Goroutines 类似于线程，但使用更少的内存，并且使用起来需要更少的代码。Channels 是一种数据结构，它允许您在
    goroutine 之间发送类型化的消息，并内置了同步机制。这促进了一种编程模型，在该模型中，您在 goroutine 之间发送数据，而不是让 goroutine
    争夺使用相同的数据。现在让我们更详细地看看这些功能。
- en: Goroutines
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Goroutines
- en: Goroutines are functions that run concurrently with other goroutines, including
    the entry point of your program. In other languages, you’d use threads to accomplish
    the same thing, but in Go many goroutines execute on a single thread. For example,
    if you write a web server and you want to handle different web requests simultaneously,
    you’d have to write a lot of extra code to use threads in C or Java. In Go, the
    net/http library has concurrency built in using goroutines. Each inbound request
    automatically runs on its own goroutine. Goroutines use less memory than threads
    and the Go runtime will automatically schedule the execution of goroutines against
    a set of configured logical processors. Each logical processor is bound to a single
    OS thread (see [figure 1.2](#ch01fig02)). This makes your application much more
    efficient with significantly less development effort.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutines 是与包括程序入口点在内的其他 goroutine 并发运行的函数。在其他语言中，您会使用线程来完成相同的事情，但在 Go 中，许多
    goroutine 在单个线程上执行。例如，如果您编写一个 Web 服务器并且想要同时处理不同的 Web 请求，您将不得不编写大量的额外代码来在 C 或 Java
    中使用线程。在 Go 中，net/http 库内置了使用 goroutine 的并发功能。每个传入请求都会自动在其自己的 goroutine 上运行。Goroutines
    比线程使用更少的内存，Go 运行时将自动将 goroutine 的执行调度到一组配置的逻辑处理器。每个逻辑处理器绑定到单个 OS 线程（参见[图 1.2](#ch01fig02)）。这使得您的应用程序更加高效，并且开发工作量显著减少。
- en: Figure 1.2\. Many goroutines execute on a single OS thread
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.2\. 许多 goroutine 在单个 OS 线程上执行
- en: '![](01fig02_alt.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig02_alt.jpg)'
- en: 'If you want to execute some code concurrently while you move on to accomplish
    other things, a goroutine is perfect for the job. Here’s a quick example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在执行其他任务的同时并发执行一些代码，goroutine 是完美的选择。以下是一个快速示例：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That keyword `go` is all you need to schedule the `log` function to run as a
    goroutine and for that goroutine be run concurrently with other goroutines. This
    means you can continue executing the rest of your application while the logging
    happens concurrently, which often results in greater perceived performance for
    your end users. As stated before, goroutines have minimal overhead, so it isn’t
    uncommon to spawn tens of thousands of them. We’ll explore goroutines and concurrency
    more in-depth in [chapter 6](kindle_split_014.html#ch06).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `go` 是您调度 `log` 函数作为 goroutine 运行以及使该 goroutine 与其他 goroutine 并发运行所需的所有内容。这意味着您可以在日志并发执行的同时继续执行应用程序的其他部分，这通常会导致最终用户感知的性能显著提升。正如之前所述，goroutine
    的开销最小，因此产生成千上万的 goroutine 并不罕见。我们将在第 6 章[深入探讨 goroutine 和并发](kindle_split_014.html#ch06)。
- en: Channels
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Channels
- en: Channels are data structures that enable safe data communication between goroutines.
    Channels help you to avoid problems typically seen in programming languages that
    allow shared memory access.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Channels 是一种数据结构，它允许 goroutine 之间安全地交换数据。Channels 帮助您避免在允许共享内存访问的编程语言中通常遇到的问题。
- en: The hardest part of concurrency is ensuring that your data isn’t unexpectedly
    modified by concurrently running processes, threads, or goroutines. When multiple
    threads change the same data without locks or synchronization, heartache always
    follows. In other languages, when you have global variables and shared memory,
    you’re required to use complicated locking disciplines to prevent unsynchronized
    changes to the same variables.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程中最困难的部分是确保你的数据不会被同时运行的过程、线程或goroutines意外修改。当多个线程在没有锁或同步的情况下修改相同的数据时，总是会有痛苦随之而来。在其他语言中，当你有全局变量和共享内存时，你必须使用复杂的锁定纪律来防止对同一变量的不同步更改。
- en: Channels help to solve this problem by providing a pattern that makes data safe
    from concurrent modification. Channels help to enforce the pattern that only one
    goroutine should modify the data at any time. You can see an example of this flow
    in [figure 1.3](#ch01fig03), where channels are used to send data between several
    running goroutines. Imagine an application where many different processes need
    to know about or modify data sequentially. Using goroutines and channels, you
    can model this process safely.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Channels通过提供一种使数据免受并发修改的模式来帮助解决这个问题。Channels帮助强制执行这样的模式：在任何时候只有一个goroutine应该修改数据。你可以在[图1.3](#ch01fig03)中看到一个这样的流程示例，其中使用了channels在几个运行中的goroutines之间发送数据。想象一个应用程序，其中许多不同的进程需要按顺序了解或修改数据。使用goroutines和channels，你可以安全地模拟这个过程。
- en: Figure 1.3\. Using channels to safely pass data between goroutines
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3. 使用channels在goroutines之间安全地传递数据
- en: '![](01fig03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3](01fig03.jpg)'
- en: In [figure 1.3](#ch01fig03) you see three goroutines and two unbuffered channels.
    The first goroutine passes a data value through the channel to a second goroutine
    that’s already waiting. The exchange of the data between both goroutines is synchronized,
    and once the hand-off occurs, both goroutines know the exchange took place. After
    the second goroutine performs its tasks with the data, it then sends the data
    to a third goroutine that’s waiting. That exchange is also synchronized, and both
    goroutines can have guarantees the exchange has been made. This safe exchange
    of data between goroutines requires no other locks or synchronization mechanisms.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图1.3](#ch01fig03)中，你可以看到三个goroutines和两个无缓冲的channels。第一个goroutine通过channel将一个数据值传递给一个已经等待的第二个goroutine。这两个goroutines之间的数据交换是同步的，一旦交接发生，两个goroutines都知道交换已经发生。第二个goroutine使用数据执行其任务后，然后将数据发送给一个等待的第三个goroutine。这个交换也是同步的，两个goroutines都可以保证交换已经完成。这种goroutines之间的安全数据交换不需要其他锁或同步机制。
- en: It’s important to note that channels don’t provide data access protection between
    goroutines. If copies of data are exchanged through a channel, then each goroutine
    has its own copy and can make any changes to that data safely. When pointers to
    the data are being exchanged, each goroutine still needs to be synchronized if
    reads and writes will be performed by the different goroutines.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，channels不会在goroutines之间提供数据访问保护。如果通过channel交换数据的副本，那么每个goroutine都有自己的副本，并且可以安全地对该数据进行任何更改。当交换数据的指针时，如果不同的goroutines将执行读写操作，那么每个goroutine仍然需要同步。
- en: 1.1.3\. Go’s type system
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3. Go的类型系统
- en: Go provides a flexible hierarchy-free type system that enables code reuse with
    minimal refactoring overhead. It’s still object-oriented development, but without
    the traditional headaches. If you’ve ever spent a week planning your abstract
    classes and interfaces in a complex Java or C++ program, you’ll appreciate the
    simplicity of Go’s type system. Go developers simply embed types to reuse functionality
    in a design pattern called *composition*. Other languages use composition, but
    it’s often deeply tied to inheritance, which can make it complicated and difficult
    to use. In Go, types are *composed* of smaller types, which is in contrast to
    traditional inheritance-based models.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一个灵活的无层次类型系统，它通过最小化重构开销来促进代码重用。它仍然是面向对象开发，但没有传统头痛的问题。如果你曾经在一个复杂的Java或C++程序中花费一周时间来规划你的抽象类和接口，你会欣赏Go的类型系统的简单性。Go开发者简单地嵌入类型，以在称为*组合*的设计模式中重用功能。其他语言也使用组合，但它通常与继承紧密相连，这可能会使其变得复杂且难以使用。在Go中，类型是由更小的类型*组合*而成的，这与传统的基于继承的模型形成对比。
- en: In addition Go has a unique interface implementation that allows you to model
    behavior, rather than model types. You don’t need to declare that you’re implementing
    an interface in Go; the compiler does the work of determining whether values of
    your types satisfy the interfaces you’re using. Many interfaces in Go’s standard
    library are very small, exposing only a few functions. In practice this takes
    some time to get used to, especially if you’ve been writing in object-oriented
    languages like Java.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Go 还有一个独特的接口实现，允许你建模行为，而不是建模类型。你不需要在 Go 中声明你正在实现接口；编译器会做这项工作，确定你的类型的值是否满足你使用的接口。Go
    标准库中的许多接口都非常小，仅暴露了几个函数。在实践中，这需要一些时间来适应，尤其是如果你一直在使用像 Java 这样的面向对象语言编写代码。
- en: Types are simple
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类型很简单
- en: Go has built-in types like `int` and `string` as well as user-defined types.
    A typical user-defined type in Go will have typed fields to store data. If you’ve
    seen structs in C, Go’s user-defined types will look familiar and operate similarly.
    But types may also declare methods that operate on that data. Rather than building
    a long inheritance structure—Client extends User extends Entity—Go developers
    build small types—Customer and Admin—and embed them into larger ones. [Figure
    1.4](#ch01fig04) demonstrates the difference between inheritance and composition.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Go 有内置类型如 `int` 和 `string`，以及用户定义的类型。Go 中的典型用户定义类型将具有类型字段以存储数据。如果你见过 C 中的结构体，Go
    的用户定义类型看起来会非常熟悉，并且操作方式相似。但类型也可以声明操作该数据的方法。而不是构建一个长的继承结构——Client 扩展 User 扩展 Entity——Go
    开发者构建小的类型——Customer 和 Admin——并将它们嵌入到更大的类型中。[图 1.4](#ch01fig04) 展示了继承与组合之间的区别。
- en: Figure 1.4\. Inheritance versus composition
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.4\. 继承与组合
- en: '![](01fig04_alt.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig04_alt.jpg)'
- en: Go interfaces model small behaviors
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Go 接口建模小行为
- en: Interfaces allow you to express the behavior of a type. If a value of a type
    implements an interface, it means the value has a specific set of behaviors. You
    don’t even need to declare that you’re implementing an interface; you just need
    to write the implementation. Other languages call this *duck typing*—if it quacks
    like a duck, then it can *be* a duck—and Go does it well. In Go, if your type
    implements the methods of an interface, a value of your type can be stored in
    a value of that interface type. No special declarations are required.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接口允许你表达类型的行怍。如果一个类型的值实现了接口，这意味着该值具有一组特定的行为。你甚至不需要声明你正在实现接口；你只需要编写实现即可。其他语言称这为
    *鸭子类型*——如果它像鸭子叫，那么它就可以 *是* 一只鸭子——Go 也做得很好。在 Go 中，如果你的类型实现了接口的方法，你的类型的值可以存储在接口类型的值中。不需要特殊的声明。
- en: 'In a strictly object-oriented language like Java, interfaces are all-encompassing.
    You’re often required to think through a large inheritance chain before you’re
    able to even start writing code. Here’s an example of a Java interface:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个严格面向对象的编程语言如 Java 中，接口是无所不包的。在开始编写代码之前，你通常需要仔细思考一个大的继承链。以下是一个 Java 接口的示例：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implementing this interface in Java requires you to create a class that fulfills
    all of the promises made in the `User` interface and explicitly declare that you
    implement the interface. In contrast, a Go interface typically represents just
    a single action. One of the most common interfaces you’ll use in Go is `io.Reader`.
    The `io.Reader` interface provides a simple way to declare that your type has
    data to be read in a way that other functions in the standard library understand.
    Here’s the definition:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中实现此接口需要你创建一个类，该类满足 `User` 接口中的所有承诺，并明确声明你实现了该接口。相比之下，Go 接口通常只代表一个单一的操作。你将在
    Go 中使用最频繁的接口之一是 `io.Reader`。`io.Reader` 接口提供了一种简单的方式来声明你的类型具有以标准库中的其他函数理解的方式可读的数据。以下是定义：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To write a type that implements the `io.Reader` interface, you only need to
    implement a `Read` method that accepts a slice of bytes and returns an integer
    and possible error.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个实现 `io.Reader` 接口的类型，你只需要实现一个接受字节数组并返回整数和可能的错误的 `Read` 方法。
- en: This is a radical departure from the interface systems used in other object-oriented
    programming languages. Go’s interfaces are smaller and more aligned with single
    actions. In practice, this allows significant advantages in code reuse and composability.
    You can implement an `io.Reader` on nearly any type that has data available, and
    then pass it to any Go function that knows how to read from `io.Reader`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他面向对象编程语言中使用的接口系统有根本的不同。Go 的接口更小，更符合单一操作。在实践中，这允许在代码重用和可组合性方面有显著的优势。您几乎可以在任何具有可用数据的数据类型上实现
    `io.Reader`，然后将其传递给任何知道如何从 `io.Reader` 读取的 Go 函数。
- en: The entire networking library in Go is built using the `io.Reader` interface,
    because it allows it to separate the network implementation required for each
    different network operation from the functionality of your application. It makes
    interfaces fun, elegant, and flexible. That same `io.Reader` enables simple operations
    with files, buffers, sockets, and any other data source. Using a single interface
    allows you to operate on data efficiently, regardless of the source.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的整个网络库都是使用 `io.Reader` 接口构建的，因为它允许它将每个不同网络操作所需的网络实现与您应用程序的功能分离。这使得接口变得有趣、优雅且灵活。相同的
    `io.Reader` 还允许与文件、缓冲区、套接字和其他任何数据源进行简单操作。使用单个接口允许您高效地操作数据，无论数据源是什么。
- en: 1.1.4\. Memory management
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.4\. 内存管理
- en: Improper memory management causes applications to crash and leak memory, and
    even crash the operating system. Go has a modern garbage collector that does the
    hard work for you. In other systems languages, like C or C++, you need to allocate
    a piece of memory before you can use it, and then free it when you’re done. If
    you fail to do either of these correctly, you’ll have program crashes or memory
    leaks. It isn’t always easy to track a piece of memory when it’s no longer needed;
    threads and heavy concurrency make it even harder. When you write code with garbage
    collection in mind, Go’s garbage collection adds little overhead to program execution
    time, but reduces development effort significantly. Go takes the tedium out of
    programming and leaves the bean counting to the accountants.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不当的内存管理会导致应用程序崩溃和内存泄漏，甚至可能使操作系统崩溃。Go 拥有一个现代的垃圾回收器，它会为您完成繁重的工作。在其他系统语言，如 C 或
    C++ 中，您在使用内存之前需要分配一块内存，并在完成时释放它。如果您未能正确执行这两者中的任何一个，程序可能会崩溃或发生内存泄漏。当内存不再需要时，跟踪内存并不总是容易；线程和重并发使它变得更加困难。当您考虑垃圾回收编写代码时，Go
    的垃圾回收器对程序执行时间几乎没有开销，但显著减少了开发工作量。Go 去掉了编程中的繁琐，让会计师们去数豆子。
- en: 1.2\. Hello, Go
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2\. Hello, Go
- en: 'It’s much easier to get the feel of a programming language by seeing it in
    action. Let’s look at the traditional *Hello World!* application written in Go:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过看到编程语言的实际应用，更容易获得其感觉。让我们看看用 Go 编写的传统 *Hello World!* 应用程序：
- en: '![](007fig01_alt.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](007fig01_alt.jpg)'
- en: This sample program prints a familiar phrase on your screen when you run it.
    But how should you run it? Without installing Go on your computer, you can use
    almost all that Go provides right from your web browser.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此示例程序时，它会在屏幕上打印出一个熟悉的短语。但您应该如何运行它呢？在不安装 Go 到您的计算机上，您可以直接从您的网页浏览器使用 Go 提供的大部分功能。
- en: 1.2.1\. Introducing the Go Playground
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1\. 介绍 Go Playground
- en: The Go Playground allows you to edit and run Go code from your web browser.
    Fire up a web browser and navigate to [http://play.golang.org](http://play.golang.org).
    The code in the browser window is editable right on the screen (see [figure 1.5](#ch01fig05)).
    Click Run and see what happens!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Go Playground 允许您通过网页浏览器编辑和运行 Go 代码。打开一个网页浏览器，并导航到 [http://play.golang.org](http://play.golang.org)。浏览器窗口中的代码可以直接在屏幕上编辑（见
    [图 1.5](#ch01fig05)）。点击运行，看看会发生什么！
- en: Figure 1.5\. The Go Playground
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.5\. Go Playground
- en: '![](01fig05_alt.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig05_alt.jpg)'
- en: You can even change the code to make the greeting text output in a different
    language. Go ahead and change the greeting inside the `fmt.Println()` function
    and hit Run again.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以更改代码，使问候文本输出为不同的语言。请继续更改 `fmt.Println()` 函数内的问候语，然后再次点击运行。
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Sharing Go code
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 共享 Go 代码
- en: 'Go developers use the Playground to share code ideas, test theories, and debug
    their code, as you soon will too. Every time you create a new application on the
    Playground, you can click Share to get a sharable URL that anyone else can open.
    Try this one: [http://play.golang.org/p/EWIXicJdmz](http://play.golang.org/p/EWIXicJdmz).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Go 开发者使用演示场来分享代码想法、测试理论以及调试他们的代码，你很快也会这样做。每次你在演示场创建一个新的应用程序时，你都可以点击“分享”来获取一个可分享的
    URL，任何人都可以打开。试试这个：[http://play.golang.org/p/EWIXicJdmz](http://play.golang.org/p/EWIXicJdmz)。
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The Go Playground is the perfect way to demonstrate an idea to a coworker or
    friend who’s trying to learn something, or to solicit help. On the Go IRC channels,
    Slack group, mailing lists, and countless emails sent among Go developers, you’ll
    see Go Playground programs being created, modified, and shared.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Go 演示场是向试图学习新东西的同事或朋友展示想法的完美方式，或者寻求帮助。在 Go 的 IRC 频道、Slack 群组、邮件列表以及 Go 开发者之间发送的无数电子邮件中，你会看到正在创建、修改和共享的
    Go 演示场程序。
- en: 1.3\. Summary
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3. 摘要
- en: Go is modern, fast, and comes with a powerful standard library.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 语言现代、快速，并附带强大的标准库。
- en: Go has concurrency built-in.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 语言内置了并发功能。
- en: Go uses interfaces as the building blocks of code reuse.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 语言使用接口作为代码重用的构建块。
