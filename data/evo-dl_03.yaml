- en: 2 Introducing evolutionary computation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 介绍进化计算
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Exploring the Game of Life with Google Colaboratory
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Google Colaboratory 探索生命游戏
- en: Creating a simple cellular life simulation in Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中创建简单的细胞生命模拟
- en: Optimizing cell attributes by simulating life
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模拟生命来优化单元格属性
- en: Applying the theory of evolution to a simulation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将进化论理论应用于模拟
- en: Applying genetics and genetic algorithms to simulation optimization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将遗传学和遗传算法应用于模拟优化
- en: In the last chapter, we introduced the concept of applying evolutionary computation
    on top of or as an optimization of DL. As a general all-encompassing term, we
    refer to this process as *evolutionary deep learning* (EDL). Before we start exploring
    the applications of EDL, we first need to understand what evolutionary computation
    or algorithms are.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了在深度学习之上或作为其优化的基础上应用进化计算的概念。作为一个通用的总称，我们将这个过程称为 *进化深度学习*（EDL）。在我们开始探索
    EDL 的应用之前，我们首先需要了解进化计算或算法是什么。
- en: '*Evolutionary computation* is, likewise, a blanket term for a whole host of
    methods that borrow from life simulation in many forms, with evolution being just
    one of them. In this chapter, we present a gradual introduction to life simulation,
    what it is, what it does, and how it can optimize problems.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，“进化计算”是一个总称，涵盖了从多种形式的生命模拟中借鉴的众多方法，其中进化只是其中之一。在本章中，我们将逐步介绍生命模拟，包括它是什么，它能做什么，以及它如何优化问题。
- en: 'Life simulation is just one form of simulation we can use to explore and optimize
    problems. There are plenty of other forms of simulation that allow us to better
    model processes, from fires to financial markets and more. However, they do all
    have one thing in common: they find their origins in the computer version of Conway’s
    Game of Life.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 生命模拟是我们可以使用来探索和优化问题的模拟形式之一。还有许多其他形式的模拟，允许我们更好地模拟过程，从火灾到金融市场等等。然而，它们都有一个共同点：它们的起源都来自康威生命游戏的计算机版本。
- en: 2.1 Conway’s Game of Life on Google Colaboratory
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 在 Google Colaboratory 上实现康威的生命游戏
- en: The Game of Life is a simple cellular automation developed in 1970 by John Horton
    Conway; this “game” is attributed as the birth of the computer simulation. While
    the rules of the simulation are simple, the patterns and manifestations it can
    produce are an incredible testament to its eloquence.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 生命游戏是由约翰·霍顿·康威在 1970 年开发的一种简单的细胞自动化，这个“游戏”被认为是计算机模拟的诞生。尽管模拟的规则很简单，但它能产生的模式和表现是对其优雅性的惊人证明。
- en: This next exercise also helps us introduce Google Colaboratory, or Colab, as
    it is widely known. Colab is an excellent platform for performing all forms of
    ML, from evolutionary computation to DL. It is based on Jupyter Notebook, so it
    should be familiar to most Python developers with a notebook background. Furthermore,
    it is free and provides both CPU and GPU resources we use heavily later.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个练习也有助于我们介绍 Google Colaboratory，或简称 Colab。Colab 是一个执行所有形式机器学习（从进化计算到深度学习）的优秀平台。它基于
    Jupyter Notebook，因此对于大多数有笔记本背景的 Python 开发者来说应该很熟悉。此外，它是免费的，并提供我们后来会大量使用的 CPU 和
    GPU 资源。
- en: Begin the exercise by loading up the EDL_2_1_Conways_Game_of_Life.ipynb exercise
    in your browser. Please refer to the appendix for details on how to load the code
    from the GitHub repository to Colab.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 开始练习，请在浏览器中加载 EDL_2_1_Conways_Game_of_Life.ipynb 练习。有关如何从 GitHub 仓库将代码加载到 Colab
    中的详细信息，请参阅附录。
- en: After you open the notebook in Colab, you will see several text and code cells.
    Don’t worry about any of the code in this exercise—just the steps on how to use
    Colab to execute the notebook and explore the results.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Colab 中打开笔记本后，您将看到几个文本和代码单元格。请不要担心这个练习中的任何代码——只需关注如何使用 Colab 执行笔记本和探索结果的操作步骤。
- en: Next, select the first code cell in the notebook and click the Run Cell button
    in the top left or type Ctrl-Enter or Cmd-Enter to run the cell. This runs the
    code and sets up the `show_video` function to be used later. We employ this function
    to demonstrate a real-time visual output of the simulation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择笔记本中的第一个代码单元格，然后在左上角点击运行单元格按钮，或者按 Ctrl-Enter 或 Cmd-Enter 来运行单元格。这将运行代码并设置稍后要使用的
    `show_video` 函数。我们使用此函数来展示模拟的实时可视化输出。
- en: 'Google Colaboratory: Colab and real-time output'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Google Colaboratory：Colab 和实时输出
- en: Colab is an excellent platform and an incredible educational tool for quickly
    showcasing code to students. While it can be used to explore code quickly for
    various tasks, one downfall of Colab is that it doesn’t provide a real-time graphic
    rendering output. To work around this, we use several tricks and techniques in
    this book to visualize real-time simulation graphic output.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Colab 是一个出色的平台，也是一个令人难以置信的教育工具，可以快速向学生展示代码。虽然它可以用来快速探索各种任务的代码，但 Colab 的一个缺点是它不提供实时图形渲染输出。为了解决这个问题，我们在本书中使用了几个技巧和技术来可视化实时模拟图形输出。
- en: Move down to the next cell, which implements the simple rules of life. Again,
    we don’t explore the code here, but figure 2.1 pictorially explains the rules
    for Conway’s Game of Life. Run the cell by pressing the Run button or using the
    keyboard shortcut.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到下一个单元格，该单元格实现了生命的简单规则。同样，我们在这里不探索代码，但图 2.1 以图解的形式解释了康威生命游戏的规则。通过按运行按钮或使用键盘快捷键来运行单元格。
- en: The rules for Conway’s Game of Life
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 康威生命游戏的规则
- en: 'The elegance of the Game of Life comes down to the simplicity of the rules
    used to mimic cellular simulation. Four simple rules were used to mimic or simulate
    the life of cells:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 生命游戏的优雅之处在于其规则的简单性，这些规则用于模拟细胞模拟。使用了四个简单的规则来模拟或模拟细胞的生存：
- en: Any live cell with fewer than two live neighbors dies, as if by underpopulation.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何拥有少于两个活细胞的活细胞都会死亡，就像因为人口不足一样。
- en: Any live cell with two or three live neighbors lives on to the next generation.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何拥有两个或三个活细胞的活细胞将存活到下一代。
- en: Any live cell with more than three live neighbors dies, as if by overpopulation.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何拥有超过三个活细胞的活细胞都会死亡，就像因为过度拥挤一样。
- en: Any dead cell with exactly three live neighbors becomes a live cell, as if by
    reproduction.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何拥有恰好三个活细胞的死细胞会变成活细胞，就像通过繁殖一样。
- en: '![](../Images/CH02_F01_Lanham.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F01_Lanham.png)'
- en: Figure 2.1 The Game of Life rules
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 生命游戏规则
- en: Run the next cell, and observe the output, as shown in figure 2.2\. For this
    simple life simulation, the starting cellular pattern is simple. There are a wide
    variety of other starting positions that can result in some fantastic animations
    and constructions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 运行下一个单元格，并观察输出，如图 2.2 所示。对于这个简单的生命模拟，起始的细胞模式很简单。还有许多其他起始位置可以产生一些令人惊叹的动画和结构。
- en: '![](../Images/CH02_F02_Lanham.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F02_Lanham.png)'
- en: Figure 2.2 Starting cellular positions highlighted
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 起始细胞位置被突出显示
- en: Since we aren’t interested in exploring the rest of the code, we can simply
    run the entire notebook using Runtime > Run All from the menu or typing Ctrl-F9,
    Cmd-F9\. The second last cell that performs the simulation takes a couple of minutes
    to run, but as it does so, a progress bar is displayed. When the simulation is
    complete, the first function we set up, `show_video`, is used to show a short
    video clip in the output.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们并不感兴趣去探索代码的其他部分，我们可以简单地通过菜单中的“运行”>“运行所有”或通过按 Ctrl-F9，Cmd-F9 来运行整个笔记本。倒数第二个执行模拟的单元格需要几分钟才能运行，但在此过程中，会显示一个进度条。当模拟完成后，我们最初设置的第一个函数
    `show_video` 会在输出中显示一个简短的视频剪辑。
- en: '![](../Images/CH02_F03_Lanham.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F03_Lanham.png)'
- en: Figure 2.3 Watching the simulation video
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 观看模拟视频
- en: Play the video after the process is complete, and watch how the cellular simulation
    runs. An excerpt from the video is shown in figure 2.3, which highlights how expansive
    the cellular network can grow to be.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程完成后播放视频，并观察细胞模拟的运行情况。视频的摘录如图 2.3 所示，突出了细胞网络可以扩展到多么广阔。
- en: The simplicity and elegance of the Game of Life showcased the power of computer
    simulation and birthed many disciplines. It showcased how simple rules could be
    used to mimic life but also generate new and unforeseen solutions, given some
    very basic rules and inputs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 生命游戏的简单性和优雅展示了计算机模拟的力量，并催生了许多学科。它展示了如何使用简单的规则来模拟生命，但也可以根据一些非常基本的规则和输入生成新的和未预见的解决方案。
- en: 'While the path life simulation has taken since looks significantly different
    now, we often try to adhere to the simple principle Conway extolled in this first
    simulation: derive a simple set of rules that simulate a greater process with
    the goal of uncovering some unforeseen pattern or solution. This goal helps orient
    us while learning about methods of EC in this and future chapters.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自从路径生命模拟以来看起来显著不同，但我们通常试图坚持康威在这第一次模拟中赞美的简单原则：推导出一套简单的规则，以模拟更复杂的过程，目的是揭示一些未预见的模式或解决方案。这个目标有助于我们在本章和未来的章节中了解进化计算的方法。
- en: 2.2 Simulating life with Python
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 使用 Python 模拟生命
- en: Before we get into deriving more complex forms of life simulation using evolution
    or other methods, it is helpful to look at a simple contrived implementation.
    We continue looking at simulating cellular life, but this time, we only consider
    the attributes of a cell, ignoring the physical conditions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨使用进化或其他方法推导更复杂的生命模拟形式之前，查看一个简单的、人为的实现是有帮助的。我们继续探讨模拟细胞生命，但这次，我们只考虑细胞的属性，忽略物理条件。
- en: Geospatial life and agent simulation
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 地理空间生命和代理模拟
- en: Simulations that use space or spatial representations, like the Game of Life,
    are still used to do all manner of modeling and predications, from traffic to
    a viral spread like COVID-19\. These forms of simulation can be fun to explore
    and run but won’t be our focus in EDL. Instead, our spatial focus is more mathematically
    driven, meaning we look more at analyzing vector or graph distances than physical
    space.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空间或空间表示的模拟，如生命游戏，仍然用于进行各种建模和预测，从交通到像 COVID-19 这样的病毒传播。这些类型的模拟可以很有趣去探索和运行，但不会是我们在
    EDL 中的重点。相反，我们的空间关注点更侧重于数学驱动，这意味着我们更多地关注分析向量或图距离，而不是物理空间。
- en: In the next exercise, we jump into Python code on Colab that demonstrates a
    simple cellular life simulation. Keep in mind this is a contrived example that
    is only meant to demonstrate some basic concepts and, in some ways, what not to
    do. As we move through the chapter, the sample evolves into a full evolutionary
    method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将跳转到 Colab 上的 Python 代码，演示一个简单的细胞生命模拟。请记住，这是一个人为的例子，仅用于展示一些基本概念，以及在某种程度上说明不应该做什么。随着我们进入本章，示例将演变成一个完整的进化方法。
- en: Open notebook EDL_2_2_Simulating_Life.ipynb in your browser. Refer to the appendix
    if you need assistance.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开笔记本 EDL_2_2_Simulating_Life.ipynb。如需帮助，请参阅附录。
- en: As a rule, the first couple of cells in a notebook install or set up any additional
    dependencies and perform the general imports. Run the cell to perform the imports,
    as shown in the following listing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，笔记本中的前几个单元格会安装或设置任何额外的依赖项，并执行一般导入。运行单元格以执行导入，如下所示。
- en: 'Listing 2.1 EDL_2_2_Simulating_Life.ipynb: Using `import`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 EDL_2_2_Simulating_Life.ipynb：使用 `import`
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Used for creating random numbers
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于生成随机数
- en: ❷ Used for tracking time and waiting
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于跟踪时间和等待
- en: ❸ Used for displaying plots
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 用于显示图表
- en: ❹ Used for clearing the notebook cell output
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 用于清除笔记本单元格输出
- en: Move down to the next notebook cell. This block of code sets up a function to
    create a new cell as well as generate a list or set of cells based on the number
    of offspring desired. Run this cell, and you will see an example of the cells
    generated as a list of dictionaries, as shown in the following listing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到下一个笔记本单元格。此代码块设置了一个创建新细胞以及根据所需后代数量生成单元格列表或集合的函数。运行此单元格，您将看到单元格的示例列表，如下所示。
- en: 'Listing 2.2 EDL_2_2_Simulating_Life.ipynb: Using `create_cell` and `birth`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 EDL_2_2_Simulating_Life.ipynb：使用 `create_cell` 和 `birth`
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Creates a cell with a random health from 1–100
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个具有 1-100 之间随机健康值的单元格
- en: ❷ Creates a list of cells of size offspring
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个大小为后代的细胞列表
- en: ❸ Uses birth function to build a list of cells
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用出生函数构建单元格列表
- en: The following listing defines the reproduction and death code/rules. Unlike
    the Game of Life, this example uses a predefined parameter, called `RPRD_RATE`,
    to define the likelihood of new cells being created. Likewise, the code also checks
    for cell death based on a random evaluation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表定义了繁殖和死亡代码/规则。与生命游戏不同，此示例使用一个预定义的参数，称为 `RPRD_RATE`，来定义新细胞被创建的可能性。同样，代码还根据随机评估检查细胞死亡。
- en: 'Listing 2.3 EDL_2_2_Simulating_Life.ipynb: Reproduction and death'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 EDL_2_2_Simulating_Life.ipynb：繁殖和死亡
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Defines the rate of reproduction and death
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义繁殖和死亡的速率
- en: ❷ For every cell in, cells reproduce new cell based on the rate
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于每个细胞，根据速率繁殖新细胞
- en: ❸ For every cell in, cells let a cell live based on change of death
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对于每个细胞，根据死亡变化让细胞存活
- en: ❹ Runs a generation of cells through reproduction and death
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 运行一代细胞的繁殖和死亡
- en: Run the last code cell to create the reproduction and death functions; this
    sets up the base life simulation functions. At this stage, there won’t be any
    output, since we are just setting up the functions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行最后一个代码单元格以创建繁殖和死亡函数；这设置了基本的生命模拟函数。在这个阶段，由于我们只是在设置函数，所以不会有任何输出。
- en: Next, jump to the last cell. This cell performs the simulation, and our only
    goal now is to increase the cell `population`, as shown in the following listing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，跳转到最后一个单元格。这个单元格执行模拟，我们现在的唯一目标是增加单元格`人口`，如下所示。
- en: 'Listing 2.4 EDL_2_2_Simulating_Life.ipynb: Reproduction and death'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 EDL_2_2_Simulating_Life.ipynb：繁殖和死亡
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Creates a new list of cells
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的细胞列表
- en: ❷ Loops through the number of generations
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历代数数量
- en: ❸ Runs a generation (reproduction/death) over the cells
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在细胞上运行一代（繁殖/死亡）
- en: ❹ Clears the output, and plots the updated history of population
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 清除输出，并绘制人口更新的历史图表
- en: ❺ Sleeps for a second, so the plot is visible
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 睡眠一秒钟，以便可以看到图表
- en: Run this cell, and watch the simulation run. If the reproduction and death rates
    are set correctly, the `population` should show an increase. You can modify the
    parameters that drive the simulation using the Colab form sliders, as shown in
    figure 2.4\. You can go back and alter the parameters and then run the last notebook
    cell again to see updated simulation results.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个单元格，并观察模拟的运行。如果繁殖和死亡速率设置正确，`人口`应该会增加。你可以使用Colab表单滑块修改驱动模拟的参数，如图2.4所示。你可以返回并更改参数，然后再次运行最后一个笔记本单元格以查看更新的模拟结果。
- en: '![](../Images/CH02_F04_Lanham.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F04_Lanham.png)'
- en: Figure 2.4 Running the simulation and changing parameters in Colab
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 在Colab中运行模拟和更改参数
- en: The goal of this exercise is simply to set up a simple cellular simulation and
    try to get the `population` to grow. We define rates to control both the reproduction
    and death of the cells. There is very little elegance in this simulation, but
    it is easy to understand and use. Use the learning exercises in the next section
    to understand this basic life simulation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标仅仅是设置一个简单的细胞模拟，并尝试让`人口`增长。我们定义了速率来控制细胞的繁殖和死亡。这个模拟没有太多的优雅性，但它易于理解和使用。使用下一节的学习练习来理解这个基本的生命模拟。
- en: 2.2.1 Learning exercises
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 学习练习
- en: 'At the end of each section, there is a set of exercises to help you review
    the various sections’ code and concepts. Taking the time to work through these
    exercises significantly aids your understanding of future concepts:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分的结尾都有一个练习集，帮助你回顾各个部分的代码和概念。花时间完成这些练习将极大地帮助你理解未来的概念：
- en: Modify the number of `generations` and `initial_offspring` parameters to see
    what effect that has on the results.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`代数`和`初始后代`参数以查看这对结果的影响。
- en: Modify the birth and death rates to see what effect this has on the final `population`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改出生率和死亡率以查看这对最终`人口`的影响。
- en: See if you can find a reproduction and death rate that produces a decline in
    `population` growth.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看你是否能找到一个繁殖和死亡率，它会导致`人口`增长下降。
- en: Now that we understand how we can easily simulate life, we move on to understanding
    why we would want to in specific applications.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何轻松地模拟生命，我们继续了解为什么在特定应用中我们想要这样做。
- en: 2.3 Life simulation as optimization
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 生命模拟作为优化
- en: In this scenario, we use our previous simple example and elevate it to perform
    optimization of an attribute defined on the cells. There are many reasons we may
    develop simulations for all forms of discovery of behavior, optimization, or enlightenment.
    For most applications of evolutionary algorithms, our end goal is to optimize
    a process, parameters, or a structure.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用我们之前的简单例子，并将其提升到对单元格上定义的属性进行优化的水平。我们可能开发模拟以进行各种形式的行为发现、优化或启迪的原因有很多。对于大多数进化算法的应用，我们的最终目标是优化一个过程、参数或结构。
- en: In this notebook, we extend the attributes in each cell from `health` to include
    a new parameter called `strength`. Our goal is to optimize the cell strength of
    our entire `population`. The `strength` parameter is representative of any trait
    in an organism that makes it successful in its environment. That means in our
    simple example, our goal is to maximize `strength` across the entire `population`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个笔记本中，我们将每个单元格的属性从`健康`扩展到包括一个名为`力量`的新参数。我们的目标是优化整个`人口`的细胞力量。`力量`参数代表任何使生物在其环境中成功的特征。这意味着在我们的简单例子中，我们的目标是最大化整个`人口`的`力量`。
- en: Open the notebook example EDL_2_3_Simulating_Life.ipynb in your browser. Check
    the appendix if you require assistance.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开笔记本示例EDL_2_3_Simulating_Life.ipynb。如果需要帮助，请查看附录。
- en: We use a useful real-time plotting library called LiveLossPlot for several examples
    in this book. This library is intended for plotting training losses for ML and
    DL problems, so the default graphs present terminology we would use in a DL problem.
    Nonetheless, it works perfectly well for our needs. The following listing demonstrates
    installing the package and importing the `PlotLosses` class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个书中使用了一个有用的实时绘图库，称为LiveLossPlot，来展示几个示例。这个库旨在用于绘制机器学习和深度学习问题的训练损失，因此默认图表中包含我们在深度学习问题中会使用的术语。尽管如此，它非常适合我们的需求。以下列表展示了安装该包并导入`PlotLosses`类。
- en: 'Listing 2.5 EDL_2_3_Simulating_Life.ipynb: Installing `PlotLosses`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 EDL_2_3_Simulating_Life.ipynb：安装`PlotLosses`
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Installs the livelossplot package into Colab
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在Colab中安装livelossplot包
- en: ❷ Loads the PlotLosses class for later use
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 加载PlotLosses类以供后续使用
- en: The bulk of the code in this example is shared from the previous, and as such,
    we just look at the differences here. Starting with the first cell, we can see
    a few changes in the functions that define the life simulation shown in the following
    listing. The biggest change is that we now use the new `strength` parameter to
    derive the cell’s `health`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的大部分代码与上一个例子共享，因此我们只需关注这里的差异。从第一个代码单元开始，我们可以看到以下列表中定义生命模拟的函数中的一些变化。最大的变化是我们现在使用新的`strength`参数来推导细胞的`health`。
- en: 'Listing 2.6 EDL_2_3_Simulating_Life.ipynb: Life functions updated'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6 EDL_2_3_Simulating_Life.ipynb：生命函数更新
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Adds the strength parameter to the cell
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将强度参数添加到细胞中
- en: ❷ The new evaluate function calculates cell health.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 新的评估函数计算细胞健康。
- en: ❸ Cell health becomes a function of strength.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 细胞健康成为强度的函数。
- en: Likewise, the reproduction and death functions have been modified to not pick
    random cells to reproduce or die. Instead, the new functions determine whether
    a cell reproduces or dies based on the health attribute. Notice the addition of
    two new parameters—`RPRD_BOUNDS` and `DEATH_BOUNDS`—in the following listing.
    These new parameters control at what health level a cell can reproduce or when
    it should die.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，繁殖和死亡函数也被修改，不再随机选择细胞进行繁殖或死亡。相反，新的函数根据健康属性确定细胞是否繁殖或死亡。注意以下列表中新增加了两个参数——`RPRD_BOUNDS`和`DEATH_BOUNDS`。这些新参数控制细胞在什么健康水平下可以繁殖或何时应该死亡。
- en: 'Listing 2.7 EDL_2_3_Simulating_Life.ipynb: The new reproduction and death functions'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7 EDL_2_3_Simulating_Life.ipynb：新的繁殖和死亡函数
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Reproduction now compares health against RPRD_BOUNDS.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 繁殖现在将健康与RPRD_BOUNDS进行比较。
- en: ❷ Death compares cell health above DEATH_BOUNDS.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 死亡比较细胞健康是否超过DEATH_BOUNDS。
- en: ❸ Cell health becomes a function of strength.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 细胞健康成为强度的函数。
- en: ❹ Adds a new evaluation function to update cell health based on strength
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 添加一个新的评估函数，根据强度更新细胞健康
- en: For this simulation, we have adapted explicit rules for determining when a cell
    dies or reproduces based on cell health. Remember the goal of our simulation is
    to optimize the cell’s `population strength` attribute.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个模拟，我们根据细胞健康制定了细胞死亡或繁殖的显式规则。记住，我们模拟的目标是优化细胞的`population strength`属性。
- en: Jump down to the last code cell; we have made some additional changes to generating
    output, but otherwise, the simulation code remains mostly the same. The new code
    in the following listing uses the `PlotLosses` class to output a real-time plot
    of the simulation as it runs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转到最后一个代码单元；我们对生成输出做了一些额外的更改，但除此之外，模拟代码基本上保持不变。以下列表中的新代码使用`PlotLosses`类来输出模拟运行时的实时图表。
- en: 'Listing 2.8 EDL_2_3_Simulating_Life.ipynb: Plotting the results'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8 EDL_2_3_Simulating_Life.ipynb：绘制结果
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Sets up plotting groups to generate output plots
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置绘图组以生成输出图表
- en: ❷ The history dictionary is updated with tracked variables.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更新历史字典以跟踪变量。
- en: ❸ Sends the output to the plots
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将输出发送到图表
- en: Go ahead and run the whole notebook using Run > Run All from the menu or Ctrl-F9,
    CMD-F9\. Figure 2.5 shows the output of running the simulation for 25 `generations`.
    Notice in the Attributes plot on the left how the average strength and health
    are both trending upward.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过菜单中的“运行”>“运行所有”或使用Ctrl-F9，CMD-F9来运行整个笔记本。图2.5显示了运行25代模拟的输出。注意左边的属性图，平均强度和健康都呈上升趋势。
- en: '![](../Images/CH02_F05_Lanham.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F05_Lanham.png)'
- en: Figure 2.5 The output of the simulation run
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 模拟运行输出
- en: 'By modifying our life simulation code, we were able to demonstrate the rough
    optimization of a single attribute: `strength`. While we can see a gradual increase
    in the `population`’s `strength` and `health` attributes, the results are not
    overwhelming. In fact, if our life sim was to replicate the real world, then it
    is likely we would have never evolved to be who we are.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改我们的生命模拟代码，我们能够展示单个属性`strength`的大致优化。虽然我们可以看到`population`的`strength`和`health`属性逐渐增加，但结果并不令人印象深刻。事实上，如果我们的生命模拟要复制现实世界，那么我们很可能永远不会进化成现在的我们。
- en: The missing key to our life simulation is the ability of the cells to pass on
    their successful traits to offspring. Charles Darwin first observed that life
    passed on successful traits to its offspring in a process he termed *evolution*.
    As it turns out, this theory of evolution is a cornerstone to not only life on
    Earth but evolutionary computation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生命模拟中缺失的关键是细胞将它们的成功性状传递给后代的能力。查尔斯·达尔文首先观察到，生命通过他称之为*进化*的过程将成功性状传递给后代。事实证明，这个进化理论不仅是地球上的生命，也是进化计算的基石。
- en: 2.3.1 Learning exercises
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 学习练习
- en: 'Use these quick exercises to help improve your understanding of the concepts:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些快速练习来帮助提高你对概念的理解：
- en: Modify the death and birth rate parameters to see what effect this has on results.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改死亡率和出生率参数，看看这对结果有什么影响。
- en: Modify the `evaluate` function from listing 2.6 to alter the returned health
    parameter and then rerun the simulation and see what effect this has.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改列表2.6中的`evaluate`函数，以改变返回的健康参数，然后重新运行模拟并看看有什么影响。
- en: Alter the starting values of `health` and `strength` in the `create_cell` function
    from listing 2.6.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改列表2.6中的`create_cell`函数中`health`和`strength`的起始值。
- en: Simulation, as a form of optimization, is a diverse field, but our focus in
    the next section and the rest of the book is simulating evolution for optimization.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟作为一种优化形式，是一个多样化的领域，但我们在下一节以及本书的其余部分将专注于模拟进化以进行优化。
- en: 2.4 Adding evolution to the life simulation
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 将进化添加到生命模拟中
- en: Taking our life sim to the next level requires us to simulate evolution. While
    this may sound difficult, it is relatively simple to implement and elegant. In
    our next exercise, we borrow from many of the observations of Darwin and others
    to build our upgraded life sim.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的生命模拟提升到下一个层次需要我们模拟进化。虽然这可能听起来很困难，但实现起来相对简单且优雅。在接下来的练习中，我们借鉴了达尔文和其他人的许多观察结果来构建我们的升级版生命模拟。
- en: 2.4.1 Simulating evolution
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 模拟进化
- en: Again, in this exercise we borrow much of the previous exercise code, modifying
    it to simulate evolution or the ability of the cells to pass on selective traits.
    This time, however, instead of using a single trait like strength, we are assigning
    three new traits, labeled `a`, `b`, and `c`. On top of that, we replace the `health`
    trait with a more generalized term called `fitness`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在这个练习中，我们借鉴了前一个练习的大部分代码，修改它来模拟进化或细胞传递选择性性状的能力。然而，这一次，我们不是使用像力量这样的单一性状，而是分配了三个新的性状，分别标记为`a`、`b`和`c`。此外，我们将`health`性状替换为一个更通用的术语，称为`fitness`。
- en: Open notebook example EDL_2_4_Simulating_Evolution.ipynb in your browser. Consult
    the appendix if you need help doing this.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开笔记本示例EDL_2_4_Simulating_Evolution.ipynb。如果你需要帮助做这件事，请查阅附录。
- en: This code has several upgrades we inspect in detail, starting with the updated
    `create_cell` function. It is important to notice here that the function now takes
    two input cells or two cells to produce a single offspring. If there are no parents
    at the start of the sim, for instance, then random values are set for the traits.
    If there are parents, then the average of each trait becomes the child’s new value,
    as shown in the following listing. Keep in mind that this averaging mechanism
    is just one possibility for creating the new child’s trait values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有几个升级，我们将详细检查，首先是更新的`create_cell`函数。在这里，重要的是要注意，该函数现在接受两个输入细胞或两个细胞来产生一个后代。例如，如果在模拟开始时没有亲本，那么性状将被设置为随机值。如果有亲本，那么每个性状的平均值将成为孩子的新的值，如下面的列表所示。请记住，这种平均机制只是创建新孩子性状值的一种可能性。
- en: 'Listing 2.9 EDL_2_4_Simulating_Evolution.ipynb: Updating `create_cell`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9 EDL_2_4_Simulating_Evolution.ipynb：更新`create_cell`
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ It now takes two parent cells to procreate.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 现在需要两个亲本细胞来繁殖。
- en: ❷ fitness always starts at 0.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 适应性始终从0开始。
- en: ❸ If there are no parents, traits are initialized to random values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果没有亲本，性状将初始化为随机值。
- en: ❹ The new trait value is the average of both parents.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 新的性状值是两个亲本的平均值。
- en: Next, we look at the updated `reproduce` function. A few things have changed
    here. First, we sort the parent cells by `fitness` and then take the top half
    in a process known as `selection`. Second, we loop over the remaining parents
    twice (two children per parent) and randomly select two to mate. These two parents
    are then passed to `create_cell` to bear a new child with shared traits from both
    parents. Lastly, the cells are passed through a new `mutate` function before being
    returned. The form of reproduction `selection` we are using in the following listing
    is just one example; as we shall see, there are many variations to this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们查看更新的 `reproduce` 函数。这里有一些变化。首先，我们按 `fitness` 对父母细胞进行排序，然后通过一个称为 `selection`
    的过程选择上半部分。其次，我们对剩余的父母进行两次循环（每个父母两个子代）并随机选择两个进行交配。然后，这两个父母被传递给 `create_cell` 以产生具有来自两个父母共享特征的新的子代。最后，细胞通过一个新的
    `mutate` 函数，然后返回。下面列表中使用的繁殖 `selection` 形式只是一个例子；我们将看到，这里有许多变体。
- en: 'Listing 2.10 EDL_2_4_Simulating_Evolution.ipynb: Updating `reproduce`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10 EDL_2_4_Simulating_Evolution.ipynb：更新 `reproduce`
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Sorts the parents by fitness and then takes the top half
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 按 `fitness` 排序父母并选择上半部分
- en: ❷ Loops through the remaining parents twice
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对剩余的父母进行两次循环
- en: ❸ Randomly samples two parents to procreate
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 随机选择两个父母进行繁殖
- en: ❹ Passes the parents to create_cell to bear a child cell
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将父母传递给 create_cell 以产生子代细胞
- en: ❺ Mutates the children before passing back the list
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在返回列表前对子代进行突变
- en: The last step in `reproduce` is calling the `mutate` function, shown in the
    following listing, which has a random chance of modifying the children. We add
    this function or rule to simulate that random chance in life where organisms (cells)
    may `mutate` beyond their parents’ traits. Mutation is a key factor in evolution
    and is responsible for all higher forms of life on Earth.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `reproduce` 中的最后一步是调用 `mutate` 函数，如下面的列表所示，它有一个随机机会修改子代。我们添加这个函数或规则来模拟生活中生物（细胞）可能超出其父母特征的
    `mutate` 随机性。突变是进化中的一个关键因素，并负责地球上所有高级生命形式。
- en: 'Listing 2.11 EDL_2_4_Simulating_Evolution.ipynb: The `mutate` function'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.11 EDL_2_4_Simulating_Evolution.ipynb：`mutate` 函数
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Checks the random chance the cell mutates
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查细胞突变的随机机会
- en: ❷ Adds a random number from -+ MUTATE_RNG
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加来自 -+ MUTATE_RNG 的随机数
- en: Next, we want to look at the updated `evaluate` function. This time we `evaluate`
    the value of traits `a`, `b`, and `c` using a simple equation that outputs the
    `fitness` of the cell. We can see this function places twice the value on trait
    `a`, places a negative value on trait `b`, and leaves trait `c` as is, as shown
    in the following listing. The goal of our evolutionary life sim is now to optimize
    these traits to maintain high `fitness`. Higher `fitness` contributes to a higher
    likelihood of reproducing, encouraging the passing of those successful traits
    further.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要查看更新的 `evaluate` 函数。这次我们使用一个简单的方程来 `evaluate` 特征 `a`、`b` 和 `c` 的值，该方程输出细胞的
    `fitness`。我们可以看到这个函数将两倍的价值放在特征 `a` 上，对特征 `b` 附加一个负值，而特征 `c` 保持不变，如下面的列表所示。我们进化生命模拟的目标现在是通过优化这些特征来保持高
    `fitness`。更高的 `fitness` 有助于提高繁殖的可能性，从而鼓励那些成功的特征得到进一步的传承。
- en: 'Listing 2.12 EDL_2_4_Simulating_Evolution.ipynb: The `mutate` function'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.12 EDL_2_4_Simulating_Evolution.ipynb：`mutate` 函数
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ The updated evaluate function
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 更新的 `evaluate` 函数
- en: Notice that we removed the `death` function and instead focus on the `reproduce`
    function. We can do this because we now make the simple assumption that after
    reproducing, all the parents are not able to further reproduce; therefore, this
    is not a consideration. Thus, we no longer care about an increasing `population`
    but rather the breeding `population`. This assumption simplifies our process and
    the performance of the simulation and is one we continue to use in most cases.
    Obviously, you could also simulate breeding across multiple `generations`, but
    we consider that an advanced topic for now.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们移除了 `death` 函数，而是专注于 `reproduce` 函数。我们可以这样做，因为我们现在简单地假设繁殖后，所有父母都无法进一步繁殖；因此，这不是一个考虑因素。因此，我们不再关心
    `population` 的增加，而是关注繁殖 `population`。这个假设简化了我们的过程和模拟的性能，并且是我们继续在大多数情况下使用的一个假设。显然，你也可以模拟跨多代的繁殖，但我们现在认为这是一个高级主题。
- en: Lastly, we look at the `run_generation` function to see how it has been simplified.
    Inside the function, the first call is to `evaluate`, which updates the `fitness`
    of the cell. Next, the `reproduce` function is called to produce the next breeding
    `generation`. After this, we again call the `evaluate` function on the new `generation`
    to update the `fitness` values, as shown in the following listing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看看`run_generation`函数，看看它是如何简化的。在函数内部，第一次调用是`evaluate`，它更新细胞的`fitness`。接下来，调用`reproduce`函数来产生下一个繁殖`generation`。之后，我们再次在新的`generation`上调用`evaluate`函数来更新`fitness`值，如下所示。
- en: 'Listing 2.13 EDL_2_4_Simulating_Evolution.ipynb: The `run_generation` function'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.13 EDL_2_4_Simulating_Evolution.ipynb：`run_generation`函数
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Evaluates the fitness of the current and new generations
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 评估当前和新生代的`fitness`
- en: ❷ Reproduces a new breeding generation
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 产生一个新的繁殖`generation`
- en: Figure 2.6 shows the output of running all the code (Run > Run All from the
    menu or Ctrl-F9, CMD-F9). Notice the sharp difference between figure 2.5 and 2.6,
    where there is an obvious improvement in `fitness`, but the `population` remains
    at 10\. Also notice how the traits `a`, `b`, and `c` are all showing well-defined
    optimizations. In the case of trait `a`, we see a definite increase, and with
    trait `b`, we see a decrease. This is a direct result of the `evaluate` function
    and the way we defined those traits in the `fitness` equation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6显示了运行所有代码的输出（从菜单中选择“运行”>“运行所有”或按Ctrl-F9，CMD-F9）。注意图2.5和2.6之间的明显差异，其中`fitness`有明显的改进，但`population`保持在10。同时注意特性`a`、`b`和`c`都显示出良好的定义优化。在特性`a`的情况下，我们看到一个明显的增加，而在特性`b`的情况下，我们看到一个减少。这是`evaluate`函数和我们定义这些特性在`fitness`方程中的方式的结果。
- en: '![](../Images/CH02_F06_Lanham.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F06_Lanham.png)'
- en: Figure 2.6 The results of running the evolution life sim
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 运行进化生命模拟的结果
- en: We can see that by adding the concept of evolution to the life sim, we are able
    to see a strong correlation between `fitness` and trait optimization. Not only
    is this modified simulation more elegant, but it is also more robust and scalable.
    It’s so elegant, in fact, that the simple concept of evolution is now the backbone
    of a whole class of algorithms, many of which we explore in later chapters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，通过将进化的概念添加到生命模拟中，我们能够看到`fitness`和特性优化之间的强烈相关性。这不仅使修改后的模拟更加优雅，而且更加健壮和可扩展。事实上，如此优雅，简单的进化概念现在成为了一类算法的骨干，其中许多我们在后面的章节中进行了探讨。
- en: 2.4.2 Learning exercises
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 学习练习
- en: 'Use these exercises to improve your understanding:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些练习来提高你的理解：
- en: Modify the `fitness` calculation in the `evaluate` function shown in listing
    2.12\. Rerun the evolution to confirm the new equation optimizes different values.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改2.12列表中所示的`evaluate`函数中的`fitness`计算。重新运行进化过程以确认新方程优化了不同的值。
- en: Add a new attribute, `d`, to the cell. This requires you to modify listings
    2.9, 2.11, and 2.12.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向细胞添加一个新的属性`d`。这需要你修改2.9、2.11和2.12列表。
- en: Alter the `mutation` rate, `MUTATE_RATE`, to a new value between `0` and `1`.
    Try this a few times and then after each change, rerun the notebook. Observe what
    effect `mutation` has on the evolution of the cells.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`mutation`率`MUTATE_RATE`更改为`0`和`1`之间的新值。尝试几次，然后在每次更改后重新运行笔记本。观察`mutation`对细胞进化的影响。
- en: 2.4.3 Some background on Darwin and evolution
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 关于达尔文和进化的背景知识
- en: Charles Darwin formed his initial concepts and theory of natural selection from
    his voyages around the continent of South America. From Darwin’s work, our thirst
    for understanding evolution drove our exploration into how life on Earth shares
    and passes on selective traits using genetics.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 查尔斯·达尔文从他在南美洲大陆的航行中形成了他的初步概念和自然选择理论。从达尔文的工作中，我们对理解进化的渴望驱使我们探索地球上的生命如何通过遗传学共享和传递选择性特性。
- en: 'Taking two decades to write, in 1859, Darwin published his most famous work,
    *On the Origin of Species* (published by John Murray), a seminal work that uprooted
    the natural sciences. His work challenged the idea of an intelligent creator and
    formed the basis of much of our natural and biological sciences to this day. The
    following quote from that book describes the theory of natural selection in Darwin’s
    words: “One general law, leading to the advancement of all organic beings, namely,
    multiply, vary, let the strongest live and the weakest die.”'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 经过二十年的写作，达尔文在1859年发表了其最著名的工作，《物种起源》（由约翰·默里出版），这是一部开创性的作品，颠覆了自然科学。他的工作挑战了智能创造者的观点，并成为我们今天自然和生物科学的基础。书中以下引用描述了达尔文对自然选择的看法：“不是最强的物种能够生存下来，也不是最聪明的物种，而是那些最能适应变化的物种。”
- en: From this law, Darwin constructed his theory of evolution and the need for life
    to survive by passing on more successful traits to offspring. While he didn’t
    understand the process of cellular mitosis and genetics, he did observe the selective
    passing of traits in multiple species. It wasn’t until 1865 that a German monk
    named Gregor Mendel would outline his theories of gene inheritance by observing
    seven traits in pea plants.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个定律出发，达尔文构建了他的进化理论，以及生命为了生存而将更成功的特征传递给后代的必要性。尽管他并不理解细胞有丝分裂和遗传学的过程，但他观察到了多个物种中特征的选择性传递。直到1865年，一位名叫格雷戈尔·孟德尔的德国僧侣才会通过观察豌豆植物的七个特征来概述他的基因遗传理论。
- en: Mendel used the terms *factors* or *traits* to describe what we now understand
    as genes. It took nearly another three decades before his work was recognized
    and the field of genetics was born. Since then, our understanding of genetics
    has grown to include such fields as gene therapy and hacking to solving complex
    problems and evolving code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 孟德尔使用*因子*或*特征*来描述我们现在所理解的基因。他的工作几乎又过了三十年才得到认可，遗传学领域才诞生。从那时起，我们对遗传学的理解已经扩展到包括基因治疗和破解复杂问题以及进化代码等领域。
- en: 2.4.4 Natural selection and survival of the fittest
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.4 自然选择和适者生存
- en: The term *survival of the fittest* is often thrown around to define evolution
    and, subsequently, evolutionary computation. While the term is often incorrectly
    attributed to Darwin, it was first used by an earlier naturalist Herbert Spencer,
    who is attributed with coining the phrase 7 years earlier. Spencer, a misguided
    social evolutionist, would continue to be a critic of Darwin and his interpretation
    of evolution.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: “适者生存”这个术语经常被用来定义进化以及随后的进化计算。虽然这个术语通常被错误地归功于达尔文，但它最初是由一位早期的自然学家赫伯特·斯宾塞使用的，他比达尔文早7年提出了这个短语。斯宾塞，一个误入歧途的社会进化论者，会继续成为达尔文及其对进化的解释的批评者。
- en: Definition *Social Darwinism*—The idea, often attributed to Herbert Spencer,
    that social success breeds success and those who socially fail are born to fail.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *社会达尔文主义*——通常归功于赫伯特·斯宾塞的观点，即社会成功孕育成功，而那些在社会上失败的人天生注定要失败。
- en: 'What Spencer and others missed from Darwin’s greater theory of evolution was
    that survival was only a consequence of change. Darwin explains this concept well:
    “It is not the strongest of the species that survives, nor the most intelligent,
    but the ones most responsive to change.”'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 斯宾塞和其他人从达尔文的更大进化理论中遗漏的是，生存只是变化的一个后果。达尔文很好地解释了这个概念：“不是最强的物种能够生存下来，也不是最聪明的物种，而是那些最能适应变化的物种。”
- en: As we move through the chapters in this book, there is no better idea to keep
    in mind than that Darwin quote. Evolution is not about developing the strongest
    or fittest but the one that can best adapt to change. What this means, in practical
    terms, is that while we focus on developing algorithms that produce the most `fitness`,
    our real goal is developing evolutionary change.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们阅读这本书的章节时，没有什么比记住达尔文的这句话更好的想法了。进化不是关于发展最强壮或最适应的物种，而是关于能够最好地适应变化的物种。在实践意义上，这意味着虽然我们专注于开发产生最多`适应性`的算法，但我们的真正目标是发展进化变化。
- en: Evolutionary change, in computation, is applied to our algorithms by making
    sure not just the fittest or best survive. This means we employ methods to make
    sure a `population` of `individuals` is not just the best but, rather, the most
    diverse. Encouraging diversity in `populations` often allows us to solve problems
    more quickly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算中，进化变化通过确保不仅仅是最强壮或最好的个体能够存活下来，被应用于我们的算法中。这意味着我们采用方法确保一个`种群`中的`个体`不仅仅是最好的，而是最多样化的。鼓励`种群`中的多样性通常能让我们更快地解决问题。
- en: Biology applied to evolutionary computation
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 生物学应用于进化计算
- en: Evolutionary computation borrows from biology and the theory of evolution. And
    like DL (neural networks) comparisons to the brain, not all terminology is transferable.
    In several cases, attempts are made to use terminology that resembles or matches
    the biological equivalent. In many cases, the biological terms have been significantly
    simplified for easier understanding. This was done not to incite biologists, geneticists,
    or evolutionists but to make the terminology more accessible.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 进化计算借鉴了生物学和进化理论。并且像DL（神经网络）与大脑的比较一样，并非所有术语都可以转移。在几个案例中，尝试使用与生物等效物相似或匹配的术语。在许多情况下，生物学术语已经被显著简化，以便更容易理解。这样做不是为了激怒生物学家、遗传学家或进化论者，而是为了让术语更容易接近。
- en: 2.5 Genetic algorithms in Python
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 Python中的遗传算法
- en: GAs are the simulation of life in code, borrowing from the concepts of evolution,
    natural selection, and the passing of successful traits through genetics. These
    algorithms simulate the biological cell-level meiosis that occurs in higher-level
    organic reproduction. While you don’t have to be a geneticist to use GAs, it may
    be helpful to understand biological relationships.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法（GAs）是代码中生命的模拟，借鉴了进化、自然选择和通过遗传传递成功特性的概念。这些算法模拟了在高级有机繁殖中发生的生物细胞级别的减数分裂。虽然你不需要成为遗传学家就能使用遗传算法，但了解生物关系可能会有所帮助。
- en: In the next section, we review some important base concepts of genetics and
    the process of meiosis. This is intended to demonstrate the relationship and mimicry
    of genetics in code. Certainly, if you already have a strong grounding in genetic
    theory and meiosis, feel free to quickly scan the section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们回顾了一些遗传学的重要基本概念和减数分裂的过程。这是为了展示代码中遗传的关系和模仿。当然，如果你已经在遗传理论和减数分裂方面有很强的基础，你可以快速浏览这一节。
- en: 2.5.1 Understanding genetics and meiosis
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 理解遗传学和减数分裂
- en: GAs simulate the evolution of life at the genetic level. However, this simulation
    is more specific to higher forms of life—like us. We also make several simplifications
    in the genetic process (meiosis). As such, the concepts we cover in this section
    are intended to be at the same high level.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法模拟了遗传层面的生命进化。然而，这种模拟更具体地针对高级生命形式——就像我们。我们在遗传过程（减数分裂）中也做了几个简化。因此，本节中涉及的概念旨在达到相同的高级水平。
- en: Anytime we talk about genetics, we need to start with *deoxyribonucleic acid*,
    commonly known as DNA. DNA strands are often referred to as the blueprint of life.
    Everything about us, down to our cells, is defined within our DNA.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们谈论遗传学时，我们都需要从*脱氧核糖核酸*（通常称为DNA）开始。DNA链通常被称为生命的蓝图。关于我们的一切，包括我们的细胞，都在我们的DNA中定义。
- en: DNA itself is composed of four base pairs that are arranged into patterns. Figure
    2.7 shows how DNA is formed and wrapped into double-helix structures that are
    then folded into chromosomes. These chromosomes are housed in the nucleus of every
    cell, as shown in the figure.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: DNA本身由四种碱基对组成，这些碱基对排列成一定的模式。图2.7展示了DNA的形成和缠绕成双螺旋结构，然后折叠成染色体。这些染色体位于每个细胞的细胞核中，如图所示。
- en: '![](../Images/CH02_F07_Lanham.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F07_Lanham.png)'
- en: Figure 2.7 DNA, genes, chromosomes, a nucleus, and a cell
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 DNA、基因、染色体、细胞核和细胞
- en: Genes, those things Mendel first defined, can be identified at the DNA level.
    A *gene* is a sequence of DNA that defines some characteristic or attribute of
    an organism. From 1990 to 2003, the Human Genome Project studied and classified
    all the genes within our chromosomes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 基因，那些孟德尔最初定义的事物，可以在DNA层面上被识别。*基因*是一段DNA序列，它定义了生物体的某些特征或属性。从1990年到2003年，人类基因组计划研究了并分类了我们染色体内的所有基因。
- en: '*Chromosomes*, as shown in figure 2.7, are containers for these sequences of
    genes. A single chromosome could contain hundreds or thousands of genes. Each
    gene itself could be comprised of hundreds to thousands of DNA base pairs. This
    all sounds quite complicated, but fortunately, in GA, we only worry about genes
    and chromosomes.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如图2.7所示，*染色体*是这些基因序列的容器。单个染色体可能包含数百或数千个基因。每个基因本身可能由数百到数千个DNA碱基对组成。这一切听起来相当复杂，但幸运的是，在遗传算法（GA）中，我们只关心基因和染色体。
- en: The simulation of genetic evolution itself is done by mimicking the process
    of meiosis. *Meiosis* is the sexual reproduction of cells from a sperm and egg,
    not to be confused with *mitosis*, which is the process of basic cellular division.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传进化的模拟本身是通过模拟减数分裂的过程来完成的。*减数分裂*是精子和卵子细胞的性繁殖过程，不要与*有丝分裂*混淆，后者是基本细胞分裂的过程。
- en: Meiosis is the process by which half an organism’s genetic material is combined
    with half of another organism’s genetic material. In humans, this is the story
    of the sperm in an egg, in which the male combines half its DNA (the sperm cell)
    with half of the female’s DNA (the egg).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 减数分裂是半个生物体的遗传物质与另一个生物体的一半遗传物质结合的过程。在人类中，这是精子与卵子的故事，其中男性将其一半的DNA（精子细胞）与女性的一半DNA（卵子）结合。
- en: Figure 2.8 shows an excerpt from the meiosis process, in which chromosomes from
    mating organisms are combined. In this process, the homologous chromosome pairs
    (i.e., alike chromosomes) are first aligned. Then, a crossover, or sharing of
    genetic material, happens. The resulting recombined chromosomes are used to define
    the new organism.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8展示了减数分裂过程的一个片段，其中交配生物的染色体被结合。在这个过程中，同源染色体对（即相似的染色体）首先对齐。然后，发生交叉，即遗传物质的共享。由此产生的重组染色体被用来定义新的生物体。
- en: '![](../Images/CH02_F08_Lanham.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F08_Lanham.png)'
- en: Figure 2.8 An excerpt of the meiosis process, showing chromosome crossover
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 细胞减数分裂过程的一个片段，展示了染色体的交叉
- en: In GAs, we simulate genes, chromosomes, and this mating or crossover process
    at the cellular level. We also need to simulate a couple other factors, as we
    discover in the next section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在遗传算法（GAs）中，我们在细胞层面上模拟基因、染色体以及这种交配或交叉过程。我们还需要模拟其他一些因素，这些因素将在下一节中介绍。
- en: 2.5.2 Coding genetic algorithms
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 编码遗传算法
- en: At the heart of GA is the `gene` that describes the various traits, good or
    bad, an `individual` possesses. In GA, we think of an `individual` as composed
    of one or more sequences of `genes` contained within a `chromosome`. We can also
    simulate multiple `chromosomes`, but typically, we stick with one.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法（GA）的核心是描述个体所具有的各种特征（无论是好是坏）的`基因`。在GA中，我们认为一个`个体`由一个或多个包含在`染色体`内的`基因`序列组成。我们也可以模拟多个`染色体`，但通常我们只使用一个。
- en: Figure 2.9 shows a `population` of `individuals`, each with a sequence of `genes`
    in a `chromosome`. Each `gene` is described by a number or Boolean value, representing
    a 0 or 1 in this case. A `gene` may contain any information, including text characters,
    colors, or whatever else you want to use to describe the traits of an `individual`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9显示了一个`个体`的`种群`，每个`个体`在`染色体`中都有一个`基因`序列。每个`基因`由一个数字或布尔值描述，代表此例中的0或1。一个`基因`可以包含任何信息，包括文本字符、颜色或您想要用来描述个体特征的任何其他信息。
- en: '![](../Images/CH02_F09_Lanham.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F09_Lanham.png)'
- en: Figure 2.9 `Population`, `genes`, and `chromosomes` in GA
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 遗传算法中的`种群`、`基因`和`染色体`
- en: Genes and chromosomes
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 基因和染色体
- en: A `gene` may map to a single array value or could be defined by multiple values.
    Likewise, you may want to define a single `chromosome` or multiple. In most cases,
    we define only a single `chromosome` in this book.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`基因`可以映射到一个单一的数组值，或者可以由多个值定义。同样，您可能想要定义一个单一的`染色体`或多个。在大多数情况下，本书中我们只定义一个`染色体`。
- en: 2.5.3 Constructing the population
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 构建种群
- en: GA can be quite abstract and difficult to envision, so to assist with our understanding,
    in this section, we work through some example code in Python that will likely
    make these concepts more tangible. You can follow along by opening the notebook
    EDL_2_5_GeneticAlgorithms.ipynb in Google Colab in your browser. Refer to the
    appendix if you need assistance loading this notebook. When the notebook is loaded,
    use the menu to select Runtime > Run All to run all cells.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法（GA）可能相当抽象且难以想象，因此为了帮助理解，在本节中，我们将通过一些Python示例代码来阐述这些概念，这可能会使这些概念更加具体。您可以通过在浏览器中打开Google
    Colab中的笔记本EDL_2_5_GeneticAlgorithms.ipynb来跟随操作。如果需要帮助加载此笔记本，请参考附录。当笔记本加载完成后，使用菜单选择运行
    > 运行所有来运行所有单元格。
- en: We can start by looking at the first code cell in the notebook, which sets up
    a `population` of `individuals` using a NumPy array. Everyone in the `population`
    is composed of a single *n*-dimensional vector with the size of `genes`. The entire
    `population` is constructed into a NumPy tensor using the `randint` function,
    with `0,2` as the inputs and the size of the tensor as `(population,genes)`. This
    results in an output tensor, where each row represents a vector with the size
    of `genes`, as shown in the following listing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从笔记本中的第一个代码单元格开始，它使用NumPy数组设置了一个`个体`的`种群`。`种群`中的每个人都是由一个大小为`基因`的单一*n*-维向量组成的。整个`种群`通过`randint`函数构建成一个NumPy张量，输入为`0,2`，张量的大小为`(种群,基因)`。这产生了一个输出张量，其中每一行代表一个大小为`基因`的向量，如下所示。
- en: 'Listing 2.14 EDL_2_5_Genetic_Algorithms.ipynb: Creating the `population`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '列表2.14 EDL_2_5_Genetic_Algorithms.ipynb: 创建`种群`'
- en: '[PRE13]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ The number of individuals in the entire population
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 整个种群中个体的数量
- en: ❷ The number of genes in an individual
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个个体中的基因数量
- en: ❸ The number of generations to evaluate
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 评估的代数数量
- en: ❹ Creates an initial random population with gene values 0 or 1
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 创建一个初始随机种群，基因值为0或1
- en: ❺ The output of print, showing each individual gene sequence in array
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 打印输出的输出，显示数组中每个个体的基因序列
- en: 2.5.4 Evaluating fitness
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.4 评估适应性
- en: Within a `population` of `individuals`, we want to determine which is the fittest
    or most likely to survive or solve a problem. In this simple example, our goal
    is to evolve `individuals`, so all their `gene` values are `1`. This is known
    as the max one problem in GA and is a common first problem introduced to newcomers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个`个体`种群中，我们想要确定哪个是最适应的或最有可能生存或解决问题的。在这个简单的例子中，我们的目标是进化`个体`，因此所有`基因`的值都是`1`。这被称为遗传算法中的最大一问题，是向新入门者介绍的一个常见问题。
- en: To determine the `fitness` of an `individual`, we typically derive a `fitness`
    function or way to calculate how close an `individual` is to reaching a target
    goal. Often, that goal is the maximization or minimization of a target value.
    In this example, our goal is to maximize the sum of all the `genes` in an `individual`.
    Since each `gene` is just a `0` or `1`, a maximized sum represents an `individual`
    with all `genes` set to `1`, as shown in listing 2.15.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定一个`个体`的`适应性`，我们通常推导出一个`适应性`函数或计算方法，以确定一个`个体`距离达到目标目标有多近。通常，这个目标是最小化或最大化一个目标值。在这个例子中，我们的目标是最大化一个`个体`中所有`基因`的总和。由于每个`基因`只是一个`0`或`1`，最大化的总和代表一个所有`基因`都设置为`1`的`个体`，如列表2.15所示。
- en: With NumPy, the code to do this with our `population` already defined in a tensor
    is quite simple and can be done with a single line of code. Scrolling down to
    the next cell in the notebook, you can see the call to `np.max` taking as input
    the `population` `pop` tensor and the `axis=1`. The following code listing demonstrates
    how to calculate `fitness`, simply by using `np.sum`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NumPy，如果我们已经在张量中定义了种群，那么执行这一操作的代码非常简单，只需一行代码即可。滚动到笔记本中的下一个单元格，你可以看到调用`np.max`函数，它以`种群``pop`张量作为输入，并设置`axis=1`。下面的代码列表展示了如何通过使用`np.sum`来计算`适应性`。
- en: 'Listing 2.15 EDL_2_5_Genetic_Algorithms.ipynb: Calculating `fitness`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '列表2.15 EDL_2_5_Genetic_Algorithms.ipynb: 计算`适应性`'
- en: '[PRE14]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ The sum of all individuals (axis 1)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 所有个体的总和（轴1）
- en: Figure 2.10 shows the histogram output of the `population`’s initial randomized
    `individual` `fitness`. As we might expect, the output resembles a normal distribution
    of the values, centered at approximately 50\. For this example, since everyone
    has a single `chromosome` with `100` `genes`, each with a value of `0` or `1`,
    the maximum ideal `fitness` score is `100`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10显示了种群初始随机`个体`适应性的直方图输出。正如我们可能预期的那样，输出类似于值的大致50左右的正态分布。在这个例子中，由于每个人都有一个包含`100`个`基因`的单个`染色体`，每个`基因`的值为`0`或`1`，因此最大理想的`适应性`分数是`100`。
- en: '![](../Images/CH02_F10_Lanham.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F10_Lanham.png)'
- en: Figure 2.10 A histogram of the initial `population` fitness
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 初始`种群`适应性的直方图
- en: 2.5.5 Selecting for reproduction (crossover)
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.5 选择繁殖（交叉）
- en: After evaluating the `fitness` of the `population`, we can determine which parents
    to use for mating to produce offspring. Just like in real life, we simulate the
    mating selection and reproduction of individuals. In nature, we typically see
    the strong, or more fit, individuals survive and reproduce to produce offspring
    that share some of their genetic code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估了种群的`适应性`之后，我们可以确定哪些父母用于交配以产生后代。就像在现实生活中一样，我们模拟了个体的交配选择和繁殖。在自然界中，我们通常看到强壮的或适应性更强的个体生存并繁殖，产生具有部分遗传代码的后代。
- en: In GAs, we simulate this by first determining which `individuals` in our `population`
    are fit enough to produce offspring. There are several strategies we can use to
    make this `selection`, but for this simple example, we take the two fittest `individuals`
    to use as parents for the entire next `generation` of offspring. This form of
    `selection` is known as *elite selection*, and the code to perform it is shown
    in the following listing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在遗传算法中，我们通过首先确定种群中哪些`个体`足够适应以产生后代来模拟这个过程。我们可以使用几种策略来进行这种`选择`，但在这个简单的例子中，我们选择两个最适应的`个体`作为下一代的父母。这种`选择`形式被称为*精英选择*，执行它的代码如下所示。
- en: 'Listing 2.16 EDL_2_5_Genetic_Algorithms.ipynb: Selecting the fittest'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.16 EDL_2_5_Genetic_Algorithms.ipynb：选择最适应的
- en: '[PRE15]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Sorts by fitness and then returns the top two individuals
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 按照适应性排序，然后返回前两个个体
- en: The `elite_selection` function takes as input the `population` `fitness` we
    calculated previously and returns indexes for the top two parents. It does this
    by sorting the `fitness` values using the `argsort` function and then indexing
    to the top two parents to return the indexes. These returned indexes can then
    be used to extract the `individuals` from the `population` using `pop[parents[idx]]`,
    with `idx` being `0` or `1`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`elite_selection` 函数接受我们之前计算的 `population` `fitness` 作为输入，并返回前两个父代的索引。它是通过使用
    `argsort` 函数对 `fitness` 值进行排序，然后索引到前两个父代以返回索引。这些返回的索引可以用来通过 `pop[parents[idx]]`
    从 `population` 中提取 `individuals`，其中 `idx` 为 `0` 或 `1`。'
- en: For this simple example, *elite selection*, or selecting the best `individuals`
    to reproduce, works well, but in more complex problems, we often use more diverse
    `selection` methods. Diversity in parents and mating `selection` allows `individuals`
    to propagate traits that may not be beneficial in the interim but may develop
    to longer-term solutions. This is akin to solving for a global maximum and getting
    stuck at a local minimum.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的例子，*精英选择*，即选择最佳的 `individuals` 进行繁殖，效果很好，但在更复杂的问题中，我们通常使用更多样化的 `selection`
    方法。父母和配对 `selection` 中的多样性允许 `individuals` 传播那些在短期内可能不利的特征，但可能发展为长期解决方案。这类似于求解全局最大值并陷入局部最小值。
- en: '2.5.6 Applying crossover: Reproduction'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.6 应用交叉：繁殖
- en: After the parents are selected, we can move on to applying `crossover` or, essentially,
    the reproduction process of creating offspring. As in the cellular division process
    in biology, we simulate the combining of `chromosomes` through a `crossover` operation,
    where each parent shares a slice of its `gene` sequence and combines it with the
    other parents.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择父母后，我们可以继续应用 `crossover` 或本质上创建子代的繁殖过程。在生物学中的细胞分裂过程中，我们通过 `crossover` 操作模拟
    `chromosomes` 的结合，其中每个父代分享其 `gene` 序列的一部分并与另一个父代结合。
- en: Figure 2.11 shows the `crossover` operation being applied using two parents.
    In `crossover`, a point is selected either randomly or using some strategy along
    the `gene` sequence. It is at this point the `gene` sequences of the parents are
    split and then recombined. In this simple example, we don’t care about what percentage
    of the `gene` sequence is shared with each offspring.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11显示了使用两个父代应用 `crossover` 操作。在 `crossover` 中，随机选择或使用某种策略沿着 `gene` 序列选择一个点。在这个点上，父代的
    `gene` 序列被分割并重新组合。在这个简单的例子中，我们不在乎每个子代与 `gene` 序列共享的百分比是多少。
- en: '![](../Images/CH02_F11_Lanham.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F11_Lanham.png)'
- en: Figure 2.11 A `crossover` operation applied to parents to produce offspring
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 对父母应用 `crossover` 操作以产生子代
- en: For more complex problems requiring thousands or millions of `generations`,
    we may prefer more balanced `crossover` strategies, rather than this random `selection`
    method. We further cover the strategies we can use to define this operation later
    in the chapter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要成千上万或数百万 `generations` 的更复杂问题，我们可能更喜欢更平衡的 `crossover` 策略，而不是这种随机的 `selection`
    方法。我们将在本章后面进一步介绍我们可以使用的策略来定义此操作。
- en: In code, the `crossover` operation first makes a copy of itself to create the
    raw children. Then we randomly determine if there is a `crossover` operation using
    the variable `crossover_rate`. If there is a `crossover` operation, then a random
    point along the `gene` sequence is generated as the `crossover` point. This point
    is used to split the `gene` sequence and then the children are generated by combining
    the `gene` sequences of both parents, as shown in the following listing.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，`crossover` 操作首先复制自身以创建原始子代。然后我们使用变量 `crossover_rate` 随机确定是否存在 `crossover`
    操作。如果存在 `crossover` 操作，则生成一个沿 `gene` 序列的随机点作为 `crossover` 点。这个点用于分割 `gene` 序列，然后通过以下列表将两个父代的
    `gene` 序列组合起来生成子代。
- en: 'Listing 2.17 EDL_2_5_Genetic_Algorithms.ipynb: `Crossover` and reproduction'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.17 EDL_2_5_Genetic_Algorithms.ipynb：`Crossover` 和繁殖
- en: '[PRE16]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Children start out being copies of the parents.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 子代最初是父母的副本。
- en: ❷ We randomly allow for the crossover operation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 随机允许交叉操作。
- en: ❸ Selects the crossover point randomly
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 随机选择交叉点
- en: ❹ Crossover and create the children.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 交叉并创建子代。
- en: ❺ Calls the function using parent 1 and 2
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用父代1和2调用函数
- en: There are several variations and ways in which `crossover` may be applied to
    the `gene` sequence. For this example, selecting a random `crossover` point and
    then simply combining the sequences at the split point works. However, in some
    cases, particular `gene` sequences may or may not make sense; in those cases,
    we may need other methods to preserve `gene` sequences.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在基因序列中，`交叉`可以以多种变体和方式应用。对于这个例子，选择一个随机的`交叉`点，然后简单地结合分裂点的序列即可。然而，在某些情况下，特定的`基因`序列可能或可能没有意义；在这些情况下，我们可能需要其他方法来保留`基因`序列。
- en: 2.5.7 Applying mutation and variation
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.7 应用变异和变体
- en: In nature, we occasionally see offspring develop traits that neither parent
    possesses. In these cases, offspring develop mutations, causing traits not seen
    in their parents. Over time, these mutations can compound to create entirely new
    features or individual species. Mutation is a key operation through which we believe
    life evolved from the single-celled organism to humans.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在自然界中，我们偶尔会看到后代发展出父母双方都不具备的特征。在这些情况下，后代发生变异，导致出现父母双方未见过的特征。随着时间的推移，这些变异可以累积，创造出全新的特征或个体物种。变异是我们认为生命从单细胞生物进化到人类的关键操作。
- en: In nature, GAs, and other similar evolutionary processes, mutation is generally
    unique and rare. With GA, we can control the amount and type of mutation we apply
    after the `crossover` operation. You can think of mutation, then, as the potential
    weird artifacts that may happen in the clumsy reproduction process.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在自然界中，遗传算法（GAs）和其他类似的进化过程中，变异通常是独特且罕见的。使用遗传算法，我们可以在`交叉`操作之后控制变异的数量和类型。因此，你可以将变异视为在笨拙的繁殖过程中可能出现的潜在奇怪产物。
- en: Applying the `mutation` operation to our offspring in listing 2.18 is as simple
    as flipping a single bit or `gene` in the sequence. In the `mutation` function,
    each `gene` in the `individual` is tested for the possibility of `mutation`. For
    testing the function, we use a `mutation_rate` of `.5`, or 50%, though in general,
    `mutation` rates are much lower—less than 5%.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 2.18 的后代中应用`变异`操作就像翻转序列中的单个比特或`基因`一样简单。在`变异`函数中，对`个体`中的每个`基因`都进行了变异可能性的测试。为了测试函数，我们使用`.5`的`变异率`，即
    50%，尽管通常变异率要低得多——低于 5%。
- en: 'Listing 2.18 EDL_2_5_Genetic_Algorithms.ipynb: `Mutation`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2.18 EDL_2_5_Genetic_Algorithms.ipynb: `变异`'
- en: '[PRE17]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ We test for possible mutation on all genes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们对所有基因进行可能的变异测试。
- en: ❷ If mutating, flip the gene 0 -> 1, 1 -> 0.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果进行变异，将基因 0 -> 1，1 -> 0。
- en: Again, as with the genetic operations of `selection` and `crossover`, `mutation`
    can also take a variety of forms. In some cases, you may prefer to keep the possibility
    of `mutation` low, while in others, a `population` may benefit from more random
    influences. `Mutation` is like the learning rate in DL, where a lower learning
    rate leads to more stable training that may get stuck, while higher rates yield
    good initial results but may never stabilize to a solution.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，与`选择`和`交叉`的遗传操作一样，`变异`也可以采取多种形式。在某些情况下，你可能更喜欢保持`变异`的可能性低，而在其他情况下，一个`种群`可能从更多的随机影响中受益。`变异`类似于深度学习中的学习率，较低的学习率会导致更稳定的训练，但可能会陷入停滞，而较高的学习率会产生良好的初始结果，但可能永远不会稳定到解决方案。
- en: 2.5.8 Putting it all together
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.8 整合所有内容
- en: Finally, when we put all the genetic operations together, we get the flowchart
    depicted in figure 2.12, which shows the entire GA process. In this figure, we
    start with initialization, which, in our case, is completely random. Then, the
    first operation is to calculate the `fitness` of all the `individuals`. From `fitness`,
    we can determine which `individuals` will reproduce offspring by using the `crossover`
    operation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们把所有的遗传操作整合在一起时，我们得到图 2.12 所示的流程图，它展示了整个遗传算法过程。在这个图中，我们从初始化开始，在我们的例子中，这是完全随机的。然后，第一个操作是计算所有`个体`的`适应度`。从`适应度`中，我们可以确定哪些`个体`将通过`交叉`操作繁殖后代。
- en: '![](../Images/CH02_F12_Lanham.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F12_Lanham.png)'
- en: Figure 2.12 The GA process
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 遗传算法过程
- en: After the `crossover` operation is applied, `mutation` is applied, followed
    by the evaluation of `fitness`. Next, we check if the stopping criteria is met.
    In general, we define the stopping criteria by the number of `generations` the
    GA runs for, where each `generation` is counted as a full flow through the GA
    process. We may also use other stopping criteria, like achieving a maximum or
    minimum `fitness`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用交叉操作后，应用变异，然后评估`适应度`。接下来，我们检查是否满足停止条件。通常，我们通过GA运行的`代`数来定义停止条件，其中每一代都被计为一个完整的GA流程。我们也可以使用其他停止条件，如达到最大或最小`适应度`。
- en: We can put all the GA process code into a single function, as shown in the `simple_GA`
    function. In this function, we can see each genetic operation applied to the `population`,
    which results in a new `generation` of children. As shown in the following listing,
    this `population` of children is returned, to be `evaluated` further and passed
    as a new `generation` to `simple_GA`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有遗传算法（GA）的过程代码放入一个单独的函数中，如`simple_GA`函数所示。在这个函数中，我们可以看到对`种群`应用的每个遗传操作，这导致了新一代的子代。如下面的代码列表所示，这个子代`种群`被返回，以供进一步评估，并作为新一代传递给`simple_GA`。
- en: 'Listing 2.19 EDL_2_5_Genetic_Algorithms.ipynb: The full GA process'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.19 EDL_2_5_Genetic_Algorithms.ipynb：完整的GA过程
- en: '[PRE18]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Calculates the fitness of the entire population
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算整个`种群`的适应度
- en: ❷ Performs selection to select the parents
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 执行选择以选择父母
- en: ❸ Creates an empty children population with all 0s
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个所有元素为0的空子代`种群`
- en: ❹ Loops through the entire population to create new children
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 遍历整个`种群`以创建新的子代
- en: ❺ Applies crossover
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 应用交叉
- en: ❻ Applies mutation
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 应用变异
- en: ❼ Each call represents one generation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 每次调用代表一代。
- en: This single function, `simple_ga`, represents one complete process of all genetic
    operations on a `population` or `generation` of `individuals`. We can `evaluate`
    consecutive `generations` using the code in the last code block of the notebook.
    If the notebook has completed training, run the last cell again, which allows
    you to see how the `population` evolves. The following code listing demonstrates
    the loop that simulates each `generation` of evolution.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单独的函数`simple_ga`代表对`种群`或`个体`的`代`的所有遗传操作的一个完整过程。我们可以使用笔记本中最后一个代码块中的代码来评估连续的`代`。如果笔记本已经完成训练，再次运行最后一个单元格，这允许你看到`种群`是如何进化的。下面的代码列表演示了模拟每个`代`进化的循环。
- en: 'Listing 2.20 EDL_2_5_Genetic_Algorithms.ipynb: Running the simulation'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.20 EDL_2_5_Genetic_Algorithms.ipynb：运行模拟
- en: '[PRE19]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Creates an initial random population
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个初始随机`种群`
- en: ❷ Loops through generations and processes the GA
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历代数并处理GA
- en: Figure 2.13 shows the result of evolving the `population` through 100 `generations`.
    The figure shows a `fitness` of `98` was reached, with a minimum `fitness` of
    `88`, an average of `93.21`, and a standard deviation of `2`. These are generally
    good results, and unlike in DL, in which the focus is a maximum or minimum loss
    or accuracy, in GA, we want to determine how well the entire `population` is progressing.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13显示了通过100代进化`种群`的结果。图中显示达到了`98`的`适应度`，最小`适应度`为`88`，平均为`93.21`，标准差为`2`。这些结果通常都是好的，并且与深度学习（DL）不同，在深度学习中，我们关注的是最大或最小损失或准确度，而在遗传算法（GA）中，我们希望确定整个`种群`的进步情况。
- en: '![](../Images/CH02_F13_Lanham.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F13_Lanham.png)'
- en: Figure 2.13 Results from evolving the `population` on the one max problem
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13在单最大问题上的`种群`进化结果
- en: While the `fitness` of a single `individual` could solve a difficult problem,
    making sure to maintain a fit `population` overall allows for continued evolution.
    Unlike in DL, where training progress can slow over time, in GA there are often
    late breakthroughs in evolution that cause radical changes and advances to solutions.
    As a result, we generally want to consider the entire `population`’s `fitness`
    when using evolving algorithms.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单个`个体`的`适应度`可以解决一个困难的问题，但确保整体保持一个健康的`种群`可以允许持续进化。与深度学习（DL）不同，在深度学习中，训练进度可能会随时间放缓，在遗传算法（GA）中，进化过程中往往会有晚期的突破，导致解决方案的激进变化和进步。因此，当我们使用进化算法时，通常希望考虑整个`种群`的`适应度`。
- en: Survival of the adaptable
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 适应性生存
- en: Remember, our goal in training evolutionary algorithms is always to make sure
    the `population` is adaptive to change. This means we generally want to see a
    `population` of `individuals` score a normal distribution of `fitness`. We can
    control this adaptation to change with the type and form of `selection` and `mutation`
    operators.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们训练进化算法的目标始终是确保`种群`能够适应变化。这意味着我们通常希望看到`个体`的`种群`得分一个正常的`适应度`分布。我们可以通过选择和突变操作符的类型和形式来控制这种适应变化。
- en: 2.5.9 Understanding genetic algorithm hyperparameters
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.9 理解遗传算法超参数
- en: 'As you may have already noticed, GA provides us with several hyperparameters
    and genetic operator options for optimizing the evolution of a solution. We explore
    the various operator options in this chapter, as these options are necessary for
    understanding what hyperparameters we can use to enhance evolution. The following
    is a list of the genetic hyperparameters we have explored thus far and how they
    work and can be used:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，GA为我们提供了几个超参数和遗传操作符选项，以优化解决方案的进化。我们在本章中探讨了各种操作符选项，因为这些选项对于理解我们可以使用哪些超参数来增强进化至关重要。以下是我们迄今为止探索的遗传超参数列表以及它们的工作方式和用途：
- en: '*Population*—This represents the number of `individuals` simulated through
    each `generation` of evolution. The `population` value is closely related to the
    size of the `chromosome` or length of the `gene` sequence. Thus, `individuals`
    with more complex `gene` sequences require larger training `populations` to be
    effective.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*种群*—这代表通过每一代进化模拟的`个体`数量。`种群`值与`染色体`的大小或基因序列长度密切相关。因此，具有更复杂`基因`序列的`个体`需要更大的训练`种群`才能有效。'
- en: '*Gene/chromosome length*—The number and length of `chromosomes` or the type
    of `genes` are often set by the problem. In the previous example exercise, we
    chose an arbitrary value for the number `genes` to demonstrate different `gene`
    sequence lengths.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基因/染色体长度*—`染色体`的数量和长度或`基因`的类型通常由问题设定。在先前的示例练习中，我们选择了一个任意的`基因`数量值来展示不同的`基因`序列长度。'
- en: '*Generations*—Like epochs in DL, the number of `generations` represents the
    number of iterations of evolution. The word *training* is reserved for `individual`
    betterment, and in GA, we evolve an entire species or `population` of `individuals`.
    Like `population`, the number of `generations` is often dictated by the `chromosome`
    length and complexity. This may be balanced against the `population` size, where
    you could have a large `population` and small number of `generations`.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代数*—类似于深度学习中的epoch，`代数`的数量代表进化的迭代次数。`训练`一词保留用于`个体`的改善，在GA中，我们进化整个物种或`个体`的`种群`。与`种群`一样，`代数`的数量通常由`染色体`长度和复杂性决定。这可能与`种群`大小相平衡，你可能有大型`种群`和少量`代数`。'
- en: '*Crossover rate*—This may determine the possibility of `crossover`, or it may
    dictate the point or amount of `crossover`. In the last example, we used this
    rate to determine how frequently parents would share `genes`. However, in most
    cases, `crossover` is assumed, and the rate may then determine the `crossover`
    point.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交叉率*—这可能决定了交叉的可能性，或者它可能规定了交叉的点或量。在最后的示例中，我们使用这个比率来确定父母共享`基因`的频率。然而，在大多数情况下，交叉是假设的，比率然后可能决定交叉点。'
- en: '*Mutation rate*—This accounts for the possibility of something going wrong
    in the `crossover` mix. A high rate of `mutation` often causes lots of variation
    in the `population`, which may be beneficial for more complex problems. Except,
    high `mutation` may also prevent `individuals` from achieving optimum performance.
    Conversely, lower rates of `mutation` produce less `population` variety and more
    specialization.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*突变率*—这解释了在`交叉`混合过程中可能出现错误的可能性。高突变率通常会导致`种群`中产生大量变异，这可能对更复杂的问题有益。然而，高突变率也可能阻止`个体`达到最佳性能。相反，较低的突变率会产生较少的`种群`多样性和更多的专业化。'
- en: At this point, a good way to understand how these hyperparameters work in practice
    is to go back to the last example and alter them and then rerun the notebook.
    Go ahead and try this, as it really is the best way to learn and understand how
    these basic values can alter the evolution of a `population`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，了解这些超参数在实际中如何工作的一个好方法是回到最后的示例并更改它们，然后重新运行笔记本。请尝试这样做，因为这确实是学习和理解这些基本值如何改变`种群`进化的最佳方式。
- en: GAs lay the foundation for several EC methods we explore in the following chapters.
    Fundamentally, the concepts of evolution and survival of the fittest are the key
    components in any EC method. We use these general laws Darwin penned over 170
    years ago throughout our journey toward finding better ways to optimize DL systems.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法（GAs）为我们探索的以下章节中的几种进化计算（EC）方法奠定了基础。从根本上说，进化和适者生存的概念是任何EC方法的关键组成部分。我们在寻找优化深度学习（DL）系统更好方法的过程中，使用了达尔文170多年前提出的这些普遍规律。
- en: 2.5.10 Learning exercises
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.10 学习练习
- en: 'We have covered a lot of foundational material in this section. Be sure to
    undertake at least one of the following exercises:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经涵盖了大量的基础材料。请确保至少完成以下练习之一：
- en: Modify the `fitness` calculation in listing 2.15\. See what effect this has
    on evolution.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改列表2.15中的`适应度`计算。看看这会对进化产生什么影响。
- en: Modify the `crossover` and `mutation` rates in listing 2.19\. Rerun the evolution,
    and see what effect changing each has on how quickly a solution is evolved.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改列表2.19中的`交叉`和`变异`率。重新运行进化过程，看看改变每个参数对进化速度的影响。
- en: Can you think of other ways parents may select mates? Write them down, and revisit
    this list later.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能想到其他父母选择配偶的方式吗？把它们写下来，稍后再回顾这个列表。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Conway’s Game of Life demonstrates one of the first basic forms of rule-based
    life simulation. Life simulation can assist us in optimizing computational and
    simulated real-world problems.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 康威生命游戏（Conway’s Game of Life）展示了基于规则的生命模拟的第一种基本形式。生命模拟可以帮助我们优化计算和模拟的实际情况问题。
- en: Life simulation can be used to observe simple behaviors using functions to define
    reproduction and death.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用函数定义繁殖和死亡来观察简单的行为。
- en: Evolution incorporated through basic life simulation can demonstrate the passing
    of successful traits to offspring. Traits passed through evolution can be used
    to optimize a particular problem.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过基本生命模拟实现的进化可以展示成功性状传递给后代。通过进化传递的性状可以用来优化特定问题。
- en: The evolutionary success of an optimization problem is measured using a `fitness`
    function. `Fitness` functions quantify the ability of a simulated `individual`
    to successfully solve a given problem.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化问题的进化成功是通过一个`适应度`函数来衡量的。`适应度`函数量化了模拟的`个体`成功解决给定问题的能力。
- en: 'Python with NumPy can be used to demonstrate the basic concepts or operations
    of simulated genetic evolution. In genetic evolution (GAs), we use operators to
    mimic the base operations of biological meiosis or higher-organism reproduction.
    The base operations used in a genetic simulation are `selection`, `crossover`,
    `mutation`, and `evaluation`/`fitness`:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NumPy的Python可以用来演示模拟遗传进化的基本概念或操作。在遗传进化（GAs）中，我们使用算子来模拟生物减数分裂或高等生物繁殖的基本操作。遗传模拟中使用的基操作是`选择`、`交叉`、`变异`和`评估`/`适应度`：
- en: '*Selection*—The stage or operation in which `individuals` are chosen to reproduce.
    There are a variety of `selection` methods used in GAs.'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择*—这是选择`个体`进行繁殖的阶段或操作。在遗传算法（GAs）中使用了多种`选择`方法。'
- en: '*Crossover*—The stage or operation in which two selected `individuals` mate
    and share a portion of genetic material.'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交叉*—这是两个选定的`个体`交配并共享部分遗传材料的阶段或操作。'
- en: '*Mutation*—To simulate real-world biological processes, we apply some amount
    of randomization to the produced offspring from the previous `crossover` operation.'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*变异*—为了模拟现实世界的生物过程，我们在前一个`交叉`操作产生的后代中应用一定程度的随机化。'
- en: '*Evaluation*—Newly produced `individuals` are `evaluated` through a function
    to produce a `fitness` score. This score determines how successful an `individual`
    will be at completing some problem or task.'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*评估*—通过一个函数对新生成的`个体`进行`评估`，以产生一个`适应度`分数。这个分数决定了`个体`完成某些问题或任务的成功程度。'
- en: 'The base operators’ inputs and configurations of genetic evolution can be tuned
    and modified. Typical configuration parameters we would modify include the following:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遗传进化的基本算子的输入和配置可以调整和修改。我们通常会修改以下典型配置参数：
- en: '*Population size*—The number of `individuals` simulated in a `generation`.'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*种群大小*—在一代中模拟的`个体`数量。'
- en: '*Number of generations*—How many iterations to simulate.'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代数数量*—模拟的迭代次数。'
- en: '*Crossover rate*—The frequency with which `individuals` share genetic material
    during the `crossover` operation.'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交叉率*—在`交叉`操作期间`个体`共享遗传材料的频率。'
- en: '*Mutation rate*—The frequency a new `individual` will be subjected to randomized
    alteration of its genetic material.'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*突变率*—新个体将遭受其遗传材料随机改变的频率。'
