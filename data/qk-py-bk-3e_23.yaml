- en: Chapter 20\. Basic file wrangling
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第20章。基本文件处理
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Moving and renaming files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动和重命名文件
- en: Compressing and encrypting files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩和加密文件
- en: Selectively deleting files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择性删除文件
- en: This chapter deals with the basic operations you can use when you have an ever-increasing
    collection of files to manage. Those files might be log files, or they might be
    from a regular data feed, but whatever their source, you can’t simply discard
    them immediately. How do you save them, manage them, and ultimately dispose of
    them according to a plan, but without manual intervention?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了当你拥有不断增长的数据文件集合时可以使用的基本操作。这些文件可能是日志文件，也可能是常规数据源，但无论它们的来源如何，你都不能简单地立即丢弃它们。你如何保存它们、管理它们，并最终根据计划处置它们，但又不需要人工干预？
- en: '20.1\. The problem: The never-ending flow of data files'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1. 问题：数据文件永无止境的流动
- en: Many systems generate a continuous series of data files. These files might be
    the log files from an e-commerce server or a regular process; they might be a
    nightly feed of product information from a server; they might be automated feeds
    of items for online advertising; historical data of stock trades; or they might
    come from a thousand other sources. They’re often flat text files, uncompressed,
    with raw data that’s either an input or a byproduct of other processes. In spite
    of their humble nature, however, the data they contain has some potential value,
    so the files can’t be discarded at the end of the day—which means that every day,
    their numbers grow. Over time, files accumulate until dealing with them manually
    becomes unworkable and until the amount of storage they consume becomes unacceptable.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统会生成一系列连续的数据文件。这些文件可能是电子商务服务器的日志文件或常规流程；它们可能是来自服务器的产品信息夜间更新；它们可能是在线广告项目的自动化数据源；股票交易的歷史数据；或者它们可能来自成千上万的其它来源。它们通常是平面文本文件，未压缩，包含的是输入数据或其它流程的副产品。然而，尽管它们性质平凡，但它们包含的数据具有一定的潜在价值，因此文件不能在一天结束时被丢弃——这意味着每天它们的数量都在增长。随着时间的推移，文件积累到手动处理变得不可行，以及它们消耗的存储空间变得无法接受。
- en: '20.2\. Scenario: The product feed from hell'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.2. 场景：来自地狱的产品数据源
- en: A typical situation I’ve encountered is a daily feed of product data. This data
    might be coming in from a supplier or going out for online marketing, but the
    basic aspects are the same.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到的一个典型情况是产品数据的每日更新。这些数据可能来自供应商或用于在线营销，但基本方面是相同的。
- en: Consider the example of a product feed coming from a supplier. The feed file
    comes in once a day, with one row for each item that the business supplies. Each
    row has fields for the supplier’s stock-keeping unit (SKU) number; a brief description
    of the item; the item’s cost, height, width, length, and width; the item’s status
    (in stock or back-ordered, say); and probably several other things, depending
    on the business.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个来自供应商的产品数据源示例。数据源文件每天更新一次，每行代表业务提供的每个项目。每行包含供应商的库存单位（SKU）编号；项目的简要描述；项目的成本、高度、宽度、长度和宽度；项目的状态（库存或已预订，等等）；以及根据业务需求可能包含的其他几项信息。
- en: In addition to this basic info file, you might well be getting others, possibly
    of related products, more detailed item attributes, or something else. In that
    case, you end up with several files with the same filenames arriving every day
    and landing in the same directory for processing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个基本信息文件外，你可能会收到其他文件，可能是相关产品的，更详细的物品属性，或者其他东西。在这种情况下，你每天都会收到几个具有相同文件名的文件，并进入相同的目录进行处理。
- en: 'Now assume that you get three related files every day: item_info.txt, item_attributes.txt,
    related_items.txt. These three files come in every day and get processed. If processing
    were the only requirement, you wouldn’t have to worry much; you could just let
    each day’s set of files replace the last and be done with it. But what if you
    can’t throw the data away? You may want to keep the raw data in case there’s a
    question about the accuracy of the process and you need to refer to past files.
    Or you may want to track the changes in the data over time. Whatever the reason,
    the need to keep the files means that you need to do some processing.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你每天都会收到三个相关的文件：item_info.txt、item_attributes.txt、related_items.txt。这三个文件每天都会到来并得到处理。如果处理是唯一的要求，你不必过于担心；你可以让每天的一组文件替换上一次的文件并完成。但如果你不能丢弃数据呢？你可能想保留原始数据，以防对处理过程的准确性有疑问，你需要参考过去的文件。或者你可能想跟踪数据随时间的变化。无论是什么原因，保留文件的需求意味着你需要进行一些处理。
- en: The simplest thing you might do is mark the files with the dates on which they
    were received and move them to an archive folder. That way, each new set of files
    can be received, processed, renamed, and moved out of the way so that the process
    can be repeated with no loss of data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能做的最简单的事情是标记文件接收的日期，并将它们移动到存档文件夹。这样，每批新文件都可以接收、处理、重命名并移开，以便可以无损失地重复该过程。
- en: 'After a few repetitions, the directory structure might look something like
    this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几次重复后，目录结构可能看起来像这样：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Main working folder, with current files for processing**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 主要工作文件夹，包含当前要处理的文件**'
- en: '***2* Subdirectory for archiving processed files**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 存档已处理文件的子目录**'
- en: Think about the steps needed to make this process happen. First, you need to
    rename the files so that the current date is added to the filename. To do that,
    you need to get the names of the files you want to rename; then you need to get
    the stem of the filenames without the extensions. When you have the stem, you
    need to add a string based on the current date, add the extension back to the
    end, and then actually change the filename and move it to the archive directory.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使此过程发生所需的步骤。首先，你需要重命名文件，以便将当前日期添加到文件名中。为此，你需要获取你想要重命名的文件名；然后你需要获取不带扩展名的文件名主干。当你有了主干，你需要添加一个基于当前日期的字符串，将扩展名重新添加到末尾，然后实际上更改文件名并将其移动到存档目录。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Consider the choices'
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：考虑选择
- en: What are your options for handling the tasks I’ve identified? What modules in
    the standard library can you think of that will do the job? If you want, you can
    even stop right now and work out the code to do it. Then compare your solution
    with the one you develop later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你处理我已识别的任务有哪些选项？你能想到哪些标准库模块来完成这项工作？如果你想，你现在就可以停下来，编写代码来完成这项工作。然后，将你的解决方案与稍后开发的解决方案进行比较。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can get the names of the files in several ways. If you’re sure that the
    names are always exactly the same and that there aren’t many files, you *could*
    hardcode them into your script. A safer way, however, is to use the `pathlib`
    module and a path object’s `glob` method, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种方式获取文件名。如果你确定文件名总是完全相同，并且文件不多，你*可以*将它们硬编码到你的脚本中。然而，更安全的方法是使用`pathlib`模块和路径对象的`glob`方法，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now you can step through the paths that match your `FILE_PATTERN` and apply
    the needed changes. Remember that you need to add the date as part of the name
    of each file, as well move the renamed files to the archive directory. When you
    use `pathlib`, the entire operation might look like this.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以遍历与你的`FILE_PATTERN`匹配的路径，并应用所需更改。请记住，你需要将日期作为每个文件名称的一部分添加，同时将重命名的文件移动到存档目录。当你使用`pathlib`时，整个操作可能看起来像这样。
- en: Listing 20.1\. File files_01.py
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表20.1\. 文件files_01.py
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Sets the pattern to match files and the archive directory**'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置匹配文件和存档目录的模式**'
- en: '***2* A directory named “archive” must exist for this code to run.**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 必须存在一个名为“archive”的目录，以便此代码运行。**'
- en: '***3* Uses the date object from the datetime library to create a date string
    based on today’s date**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用datetime库中的日期对象根据今天的日期创建日期字符串**'
- en: '***4* Creates a new path from the current path, the archive directory, and
    the new filename**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从当前路径、存档目录和新文件名创建新的路径**'
- en: '***5* Renames (and moves) the file as one step**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 一步重命名（并移动）文件**'
- en: It’s worth noting here that `Path` objects make this operation simpler, because
    no special parsing is needed to separate the filename stem and suffix. This operation
    is also simpler than you might expect because the `rename` method can in effect
    move a file by using a path that includes the new location.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`Path`对象使此操作更简单，因为不需要进行特殊解析来分离文件名的主干和后缀。此操作也比你可能预期的要简单，因为`rename`方法实际上可以通过包含新位置的路径来移动文件。
- en: This script is a very simple one and does the job effectively in very few lines
    of code. In the next sections, you consider how to handle more complex requirements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本非常简单，用很少的代码行有效地完成了工作。在下一节中，你将考虑如何处理更复杂的要求。
- en: '|  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Potential Problems'
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：潜在问题
- en: Because the preceding solution is very simple, there are likely to be many situations
    that it won’t handle well. What are some potential issues or problems that might
    arise with the example script? How might you remedy these problems?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的解决方案非常简单，因此可能存在许多它处理不好的情况。示例脚本可能会出现哪些潜在问题或问题？你如何解决这些问题？
- en: Consider the naming convention used for the files, which is based on the year,
    month and name, in that order. What advantages do you see in that convention?
    What might be the disadvantages? Can you make any arguments for putting the date
    string somewhere else in the filename, such as the beginning or the end?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑文件使用的命名约定，它是基于年份、月份和名称的顺序。你在这个约定中看到什么优点？可能有什么缺点？你能否为将日期字符串放在文件名中的其他位置（如开头或结尾）提出任何论点？
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 20.3\. More organization
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.3\. 更多组织
- en: The solution to storing files described in the previous section works, but it
    does have some disadvantages. For one thing, as the files accumulate, managing
    them might become a bit more trouble, because over the course of a year, you’d
    have 365 sets of related files in the same directory, and you could find the related
    files only by inspecting their names. If the files arrive more frequently, of
    course, or if there are more related files in a set, the hassle would be even
    greater.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中描述的存储文件的解决方案是可行的，但它确实存在一些缺点。首先，随着文件的积累，管理它们可能会变得有些麻烦，因为在一年内，你会在同一个目录下有365组相关的文件，你只能通过检查它们的名称来找到相关的文件。当然，如果文件到达得更频繁，或者一组中相关的文件更多，麻烦会更大。
- en: 'To mitigate this problem, you can change the way you archive the files. Instead
    of changing the filenames to include the dates on which they were received, you
    can create a separate subdirectory for each set of files and name that subdirectory
    after the date received. Your directory structure might look like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这个问题，你可以改变归档文件的方式。而不是将文件名改为包含它们接收的日期，你可以为每组文件创建一个单独的子目录，并以接收的日期命名该子目录。你的目录结构可能看起来像这样：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Main working folder, with current files for processing**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 主要工作文件夹，包含当前待处理的文件**'
- en: '***2* Main subdirectory for archiving processed files**'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 存档已处理文件的子目录**'
- en: '***3* Subdirectories for each set of files, named for date received**'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每组文件的子目录，以接收日期命名**'
- en: This scheme has the advantage that each set of files is grouped together. No
    matter how many sets of files you get or how many files you have in a set, it’s
    easy to find all the files of a particular set.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案的优势在于每组文件都聚集在一起。无论你得到多少组文件，或者一组中有多少文件，都很容易找到特定组的所有文件。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Implementation of multiple directories'
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：多目录实现
- en: How would you modify the code that you developed to archive each set of files
    in subdirectories named according to date received? Feel free to take the time
    to implement the code and test it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何修改你开发的代码，以便将每组文件存档到以接收日期命名的子目录中？请随意花时间实现代码并测试它。
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: It turns out that archiving the files by subdirectory isn’t much more work than
    the first solution. The only additional step is to create the subdirectory before
    renaming the file. This script is one way to perform this step.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，通过子目录归档文件并不比第一个解决方案多费多少功夫。唯一的额外步骤是在重命名文件之前创建子目录。这个脚本是执行这一步骤的一种方法。
- en: Listing 20.2\. File files_02.py
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 20.2\. 文件 files_02.py
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Note that this directory needs to be created only once, before the files
    are moved into it.**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注意，这个目录只需要在将文件移动到其中之前创建一次。**'
- en: This solution groups related files, which makes managing them as sets somewhat
    easier.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案将相关的文件分组，这使得以集合的形式管理它们变得相对容易。
- en: '|  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Alternate solutions'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：替代方案
- en: How might you create a script that does the same thing without using `pathlib`?
    What libraries and functions would you use?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何创建一个不使用 `pathlib` 的脚本来完成相同的事情？你会使用哪些库和函数？
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '20.4\. Saving storage space: Compression and grooming'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.4\. 保存存储空间：压缩和整理
- en: So far, you’ve been concerned mainly with managing the groups of files received.
    Over time, however, the data files accumulate until the amount of storage they
    need becomes a concern. When that happens, you have several choices. One option
    is to get a bigger disk. Particularly if you’re on a cloud-based platform, it
    may be easy and economical to adopt this strategy. Do keep in mind, however, that
    adding storage doesn’t really solve the problem; it merely postpones solving it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你主要关注的是管理接收到的文件组。然而，随着时间的推移，数据文件会积累，直到它们所需的存储空间成为一个问题。当这种情况发生时，你有几个选择。一个选项是获取更大的磁盘。特别是如果你在基于云的平台，采用这种策略可能既容易又经济。但请记住，增加存储空间并不能真正解决问题；它只是推迟了解决问题。
- en: 20.4.1\. Compressing files
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.4.1\. 压缩文件
- en: If the space that the files are taking up is an issue, the next approach you
    might consider is compressing them. You have numerous ways to compress a file
    or set of files, but in general, these methods are similar. In this section, you
    consider archiving each day’s data file to a single zip file. If the files are
    mainly text files and are fairly large, the savings in storage achieved by compression
    can be impressive.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件占用的空间是一个问题，你可能考虑的下一个方法是将它们压缩。你有多种压缩文件或文件集的方法，但通常这些方法相似。在本节中，你考虑将每天的数据文件存档到一个单独的zip文件中。如果文件主要是文本文件并且相当大，压缩节省的存储空间可能会非常显著。
- en: 'For this script, you use the same date string with a `.zip` extension as the
    name of each zip file. In [listing 20.2](#ch20ex02), you created a new directory
    in the archive directory and then moved the files into it, which resulted in a
    directory structure that looks like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，你使用与每个zip文件相同的日期字符串，并带有`.zip`扩展名作为文件名。在[列表20.2](#ch20ex02)中，你在存档目录中创建了一个新目录，然后将文件移动到其中，从而形成了如下所示的目录结构：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Main working folder, where current files are processed; these files are
    archived and removed after processing.**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 主要工作文件夹，其中处理当前文件；这些文件在处理后被存档并删除。**'
- en: '***2* Zip files, each one containing that day’s item_info.txt, attribute_info.text,
    and related_items.txt**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Zip文件，每个文件包含当天的item_info.txt、attribute_info.text和related_items.txt**'
- en: Obviously, to use zip files you need to change some of the steps you used previously.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，为了使用zip文件，你需要更改之前使用的一些步骤。
- en: '|  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Archiving to zip files pseudocode'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：存档到zip文件的伪代码
- en: Write the pseudocode for a solution that stores data files in zip files. What
    modules and functions or methods do you intend to use? Try coding your solution
    to make sure that it works.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个存储数据文件到zip文件中的解决方案的伪代码。你打算使用哪些模块、函数或方法？尝试编写你的解决方案以确保它能够工作。
- en: '|  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: One key addition in the new script is an import of the zipfile library and with
    it, the code to create a new zip file object in the archive directory. After that,
    you can use the zip file object to write the data files to the new zip file. Finally,
    because you’re no longer actually moving files, you need to remove the original
    files from the working directory. One solution looks like this.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 新脚本中的一个关键添加是导入zipfile库，以及创建存档目录中的新zip文件对象的代码。之后，你可以使用zip文件对象将数据文件写入新zip文件。最后，因为你不再实际移动文件，你需要从工作目录中删除原始文件。一个解决方案如下。
- en: Listing 20.3\. File files_03.py
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表20.3\. 文件files_03.py
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Imports zipfile library**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入zipfile库**'
- en: '***2* Creates the path to the zip file in the archive directory**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在存档目录中创建zip文件的路径**'
- en: '***3* Opens the new zip file object for writing; str() is needed to convert
    a Path to a string.**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打开新的zip文件对象以进行写入；需要str()将Path转换为字符串。**'
- en: '***4* Writes the current file to the zip file**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将当前文件写入zip文件**'
- en: '***5* Removes the current file from the working directory**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 从工作目录中删除当前文件**'
- en: 20.4.2\. Grooming files
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.4.2\. 文件整理
- en: Compressing data files into zipfile archives can save an impressive amount of
    space and may be all you need. If you have a lot of files, however, or files that
    don’t compress much (such as JPEG image files), you may still find yourself running
    short of storage space. You may also find that your data doesn’t change much,
    making it unnecessary to keep an archived copy of every data set in the longer
    term. That is, although it may be useful to keep every day’s data for the past
    week or month, it may not be worth the storage to keep every data set for much
    longer. For data older than a few months, it may be acceptable to keep just one
    set of files per week or even one set per month.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据文件压缩到zip存档中可以节省大量的空间，可能就是你所需要的。然而，如果你有很多文件，或者文件压缩效果不佳（例如JPEG图像文件），你可能仍然发现自己存储空间不足。你也可能发现数据变化不大，这使得在较长时间内保留每个数据集的存档副本变得不必要。也就是说，尽管保留过去一周或一个月的每天数据可能有用，但保留更长时间的数据集可能不值得存储。对于几个月前的数据，可能每周或每月保留一组文件就足够了。
- en: The process of removing files after they reach a certain age is sometimes called
    *grooming*. Suppose that after several months of receiving a set of data files
    every day and archiving them in a zip file, you’re told that you should retain
    only one file a week of the files that are more than one month old.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件达到一定年龄后删除文件的过程有时被称为*整理*。假设你每天接收一组数据文件并将其存档到zip文件中已经几个月了，你被告知你应该只保留超过一个月的文件中的一周文件。
- en: 'The simplest grooming script removes any files that you no longer need—in this
    case, all but one file a week for anything older than a month old. In designing
    this script, it’s helpful to know the answers to two questions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的整理脚本会删除你不再需要的任何文件——在这种情况下，对于一个月以上的任何东西，除了一个文件外。在设计此脚本时，了解以下两个问题的答案很有帮助：
- en: Because you need to save one file a week, would it be much easier to simply
    pick the day of the week you want to save?
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于你需要每周保存一个文件，是否简单地选择你想要保存的星期几会更容易？
- en: 'How often should you do this grooming: daily, weekly, or once a month? If you
    decide that grooming should take place daily, it might make sense to combine the
    grooming with the archiving script. If, on the other hand, you need to groom only
    once a week or once a month, the two operations should be in separate scripts.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该多久进行一次整理：每天、每周还是每月一次？如果你决定整理应该每天进行，那么将整理与存档脚本结合起来可能是有意义的。另一方面，如果你只需要每周或每月整理一次，这两个操作应该放在单独的脚本中。
- en: For this example, to keep things clear, you write a separate grooming script
    that can be run at any interval and that removes all the unneeded files. Further,
    assume that you’ve decided to keep only the files received on Tuesdays that are
    more than one month old. Here is a sample grooming script.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，为了保持清晰，你编写了一个独立的整理脚本，可以在任何间隔运行，并删除所有不需要的文件。此外，假设你已经决定只保留超过一个月的周二接收的文件。以下是一个示例整理脚本。
- en: Listing 20.4\. File files_04.py
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表20.4\. 文件 files_04.py
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Gets a datetime object for the current day**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取当前日期的 `datetime` 对象**'
- en: '***2* path.stem returns the filename without any extension.**'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* `path.stem` 返回不带任何扩展名的文件名。**'
- en: '***3* strptime parses a string into a datetime object based on the format string.**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* `strptime` 根据格式字符串将字符串解析为 `datetime` 对象。**'
- en: '***4* Subtracting one date from another yields a timedelta object.**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从一个日期减去另一个日期会产生一个 `timedelta` 对象。**'
- en: '***5* timedelta(days=30) creates a timedelta object of 30 days; the weekday()
    method returns an integer for the day of the week, with Monday = 0.**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* `timedelta(days=30)` 创建一个30天的 `timedelta` 对象；`weekday()` 方法返回一周中某天的整数，其中星期一
    = 0。**'
- en: The code shows how Python’s datetime and pathlib libraries can be combined to
    groom files by date with only a few lines of code. Because your archive files
    have names derived from the dates on which they were received, you can get those
    file paths by using the `glob` method, extract the stem, and use `strptime` to
    parse it into a `datetime` object. From there, you can use `datetime`’s `timedelta`
    objects and the `weekday()` method to find a file’s age and the day of the week,
    and then remove (unlink) the files you don’t need.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 代码展示了如何通过几行代码将 Python 的 datetime 和 pathlib 库结合起来按日期整理文件。因为你的存档文件名是从它们接收的日期派生出来的，你可以使用
    `glob` 方法获取这些文件路径，提取文件名，并使用 `strptime` 将其解析为 `datetime` 对象。从那里，你可以使用 `datetime`
    的 `timedelta` 对象和 `weekday()` 方法来找到文件的年龄和星期几，然后删除（解除链接）你不需要的文件。
- en: '|  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Consider different parameters'
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：考虑不同的参数
- en: 'Take some time to consider different grooming options. How would you modify
    the code in [listing 20.4](#ch20ex04) to keep only one file a month? How would
    you change it so that files from the previous month and older were groomed to
    save one a week? (Note: This is *not* the same as older than 30 days!)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间考虑不同的整理选项。你将如何修改[代码列表20.4](#ch20ex04)中的代码，以保留每月只保留一个文件？你将如何修改它，以便将上个月及更早的文件整理，每周保留一个？（注意：这**不是**指超过30天的情况！）
- en: '|  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The `pathlib` module can greatly simplify file operations such as finding the
    root and extension, moving and renaming, and matching wildcards.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pathlib` 模块可以极大地简化文件操作，如查找根目录和扩展名、移动和重命名、匹配通配符。'
- en: As the number and complexity of files increase, automated archiving solutions
    are vital, and Python offers several easy ways to create them.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着文件数量和复杂性的增加，自动存档解决方案变得至关重要，Python 提供了多种简单的方法来创建它们。
- en: You can dramatically save storage space by compressing and grooming data files.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过压缩和整理数据文件，你可以显著节省存储空间。
