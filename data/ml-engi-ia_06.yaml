- en: '6 Experimentation in action: Testing and evaluating a project'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 实验行动：测试和评估一个项目
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Evaluating potential approaches for an ML project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估机器学习项目的潜在方法
- en: Objectively selecting an approach for a project’s implementation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客观选择项目实施的方法
- en: The preceding chapter covered all the preparatory actions that should be taken
    to minimize the risks associated with an experimentation phase of a project. These
    range from conducting research that informs the options available for solving
    the problem to building useful functions that the team members can leverage during
    the prototyping phase. We will continue the previous scenario throughout this
    chapter, a time-series modeling project for airport passenger demand forecasting,
    while focusing on methodologies to be applied to experimental testing that will
    serve to reduce the chances of project failure.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章涵盖了为了最小化与项目实验阶段相关的风险而应采取的所有准备工作。这些工作包括进行研究以提供解决问题的选项，以及构建团队成员在原型设计阶段可以利用的有用功能。我们将继续本章的前一个场景，即机场旅客需求预测的时间序列建模项目，同时关注应用于实验测试的方法，这些方法将有助于降低项目失败的可能性。
- en: We will spend time covering testing methodologies simply because this stage
    of project development is absolutely crucial for two primary reasons. First, at
    one extreme, if not enough approaches are tested (evaluated critically and objectively),
    the chosen approach may be insufficient to solve the actual problem. At the other
    extreme, testing too many options to too great a depth can result in an experimental
    prototyping phase that risks taking too long in the eyes of the business.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将花费时间介绍测试方法，因为这个项目开发阶段对于两个主要原因至关重要。首先，在一种极端情况下，如果测试的方法（批判性和客观地评估）不足，所选的方法可能不足以解决实际问题。在另一种极端情况下，测试过多的选项并深入到过大的程度可能导致实验原型设计阶段在业务眼中耗时过长。
- en: By following a methodology that aims to rapidly test ideas, using uniform scoring
    methods to achieve comparability between approaches, and focusing on evaluation
    of the performance of the approaches rather than the absolute accuracy of the
    predictions, the chances of project abandonment can be reduced.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循旨在快速测试想法的方法论，使用统一的评分方法以实现方法之间的可比性，并专注于评估方法的表现而非预测的绝对准确性，可以降低项目放弃的可能性。
- en: Figure 6.1 compares the two extremes of prototyping within an ML project. The
    middle ground, the moderate approach, has shown the highest success rates with
    the teams that I’ve either led or worked with.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1比较了在机器学习项目中原型设计的两种极端。中间地带，即适度方法，在我所领导或合作过的团队中显示出最高的成功率。
- en: As this diagram shows, the extreme approaches on either side frequently result
    in polar opposite problems. On the left side, there exists an extremely high probability
    for project cancellation due to a lack of faith on the part of the business the
    business in the DS team’s ability to deliver a solution. Barring a case of extreme
    good luck, the solution that the team haphazardly selected and barely tested is
    likely not going to be even remotely optimal. Their implementation of their solution
    is equally likely to be poor, expensive, and fragile.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如此图表所示，两端的极端方法通常会导致截然相反的问题。在左侧，由于业务对DS团队交付解决方案能力的信心不足，项目取消的概率极高。除非极端幸运，否则团队随意选择且几乎未经测试的解决方案可能根本不是最优的。他们实施解决方案的方式同样可能糟糕、昂贵且脆弱。
- en: On the other side of the diagram, however, there exists a different problem
    entirely. The academic-influenced thoroughness on display here is admirable and
    would work well for a team conducting original research. For a DS team working
    in industry, though, the sheer volume of time required to thoroughly evaluate
    all possible solutions to a problem will delay the project far longer than most
    companies have patience for. Customized feature engineering for each approach,
    full evaluation of available models in popular frameworks, and, potentially, the
    implementation of novel algorithms are all sunk costs. While they are more scientifically
    rigorous as a series of actions to take, the time spent building each of these
    approaches in order to properly vet which is most effective means that other projects
    aren’t being worked on. As the old adage goes, time is money, and spending time
    building out fully fledged approaches to solve a problem is expensive from both
    a time and a money perspective.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在图表的另一侧，却存在一个完全不同的问题。这里展示的受学术影响的彻底性是值得赞扬的，对于进行原创研究的团队来说效果很好。但对于在工业界工作的DS团队来说，彻底评估所有可能解决方案所需的时间将远远超过大多数公司所能容忍的耐心。为每种方法定制特征工程、全面评估流行框架中可用的模型，以及可能的新算法的实施，都是沉没成本。虽然它们作为一系列采取的行动更加科学严谨，但花费时间构建每种方法以正确检验哪种方法最有效，意味着其他项目无法得到工作。正如古老的谚语所说，时间就是金钱，从时间和金钱的角度来看，构建完整的方法来解决问题是昂贵的。
- en: For the purposes of exploring an effective approach in an applications-focused
    manner, we will continue with the preceding chapter’s scenario of time-series
    modeling. In this chapter, we’ll move through the middle ground of figure 6.1
    to arrive at the candidate approach that is most likely to result in a successful
    MVP.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以应用为导向的方式探索一种有效的方法，我们将继续使用前一章中关于时间序列建模的场景。在本章中，我们将从图6.1的中间地带开始，到达最有可能导致成功MVP的候选方法。
- en: Resist the temptation to achieve perfection at this stage
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，要抵制追求完美的诱惑。
- en: As data scientists, our natural inclination in all of our work is to build solutions
    that are as optimal and mathematically correct as possible. This is an important
    drive to have, but it should be the goal for the project as a whole. During early
    testing phases, having a drive for perfection can actually be a detriment to the
    success of a project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据科学家，我们工作中的自然倾向是构建尽可能最优和数学上正确的解决方案。这是一个重要的驱动力，但应该是整个项目的目标。在早期测试阶段，追求完美实际上可能对项目的成功产生不利影响。
- en: While the project’s business sponsors share the same desire to have the best
    possible solutions, their visibility into this solution is focused only on the
    eventual approach that you decide upon. They are also focused on the time required
    to develop this solution (as well as its cost). They have no visibility into what
    you’re doing to figure out the best solution, and don’t really care how many things
    you’ve tested on the way to discovering an optimal solution.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管项目的商业赞助者都希望拥有最佳可能的解决方案，但他们对这个解决方案的可见性仅限于你最终决定的方法。他们还专注于开发这个解决方案所需的时间（以及其成本）。他们对你为了找出最佳解决方案所做的一切没有可见性，并且并不真正关心你在发现最佳解决方案的过程中测试了多少东西。
- en: It is best, at this stage of prototyping and testing approaches, to eschew your
    innate desire to fully explore all options to solve a problem and instead focus
    on efficient means of finding the most probable approach. By adjusting focus in
    this way and shifting your paradigm to thinking of the time to deliver as the
    second-most important factor in the project, you will ensure a higher chance of
    the solution being allowed to progress further along the path to production.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在原型设计和测试方法这个阶段，最好是摒弃你天生的全面探索所有解决问题选项的欲望，而是专注于高效地找到最可能的方法。通过这种方式调整焦点，并将你的范式转变为将交付时间视为项目第二重要的因素，你将确保解决方案有更高的机会沿着生产路径进一步推进。
- en: '![06-01](../Images/06-01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![06-01](../Images/06-01.png)'
- en: Figure 6.1 The sliding scale of approaches to ML solution prototyping work
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 机器学习解决方案原型设计工作的滑动尺度
- en: 6.1 Testing ideas
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 测试想法
- en: At the conclusion of chapter 5, we were left at a stage where we were ready
    to evaluate the different univariate modeling approaches for forecasting passengers
    at airports. The team is now ready to split into groups; each will focus on implementations
    of the various researched options that have been discovered, putting forth their
    best efforts not only to produce as accurate a solution as they can, but also
    to understand the nuances of tuning each model.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章结束时，我们处于一个准备评估机场乘客预测的不同单变量建模方法的状态。现在，团队准备分成小组；每个小组将专注于实施已发现的各种研究选项，不仅全力以赴以产生尽可能准确的结果，还要理解调整每个模型的细微差别。
- en: Before everyone goes off to hack through the implementations, a few more standard
    tooling functions need to be developed to ensure that everyone is evaluating the
    same metrics, producing the same reports, and generating the appropriate visualizations
    that can easily show the benefits and drawbacks of the disparate approaches. Once
    these are completed, the teams can then get into the task of evaluating and researching
    each of their assigned modeling tasks, all using the same core functionality and
    scoring. Figure 6.2 gives an overview of typical utilities, functionality, and
    standards that should be adhered to during the model prototyping phase of a project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个人都开始编写实现代码之前，还需要开发一些额外的标准化工具函数，以确保每个人都在评估相同的指标，生成相同的报告，并生成可以轻松显示不同方法优势和劣势的适当可视化。一旦完成这些，团队就可以开始评估和进行研究，每个团队都使用相同的核心功能和评分。图6.2概述了在项目模型原型阶段应遵守的典型实用工具、功能标准。
- en: '![06-02](../Images/06-02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![06-02](../Images/06-02.png)'
- en: Figure 6.2 The prototyping phase work elements and their functions
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 原型阶段的工作要素及其功能
- en: As mentioned in section 5.2, this path of actions is generally focused on supervised
    learning project work. A prototyping phase for, say, a CNN would look quite a
    bit different (with far more front-loaded work in building human-readable evaluations
    of the model performance, particularly if we’re talking about a classifier). But
    in general, these pre-work actions and approaches to prototyping different solutions
    will save weeks of frustrating rework and confusion if adhered to.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如第5.2节所述，这一行动路径通常专注于监督学习项目工作。对于CNN等原型阶段，其工作方式会有很大不同（在构建模型性能的可读性评估方面有更多前期工作，尤其是如果我们谈论的是分类器）。但总的来说，如果遵循这些前期行动和原型不同解决方案的方法，将节省几周令人沮丧的重做和困惑。
- en: 6.1.1 Setting guidelines in code
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 在代码中设置指南
- en: 'In chapter 5, we looked at and developed a set of visualization tools and basic
    data ingestion and formatting functions that each team can use. We built these
    for two primary purposes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章中，我们查看并开发了一套可视化工具和基本的数据摄入和格式化函数，每个团队都可以使用。我们建立这些工具的主要目的是：
- en: '*Standardization*—So that each team is generating identical plots, figures,
    and metrics to allow for a coherent comparison between the different approaches'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标准化*——以便每个团队生成相同的图表、图形和指标，以便在不同方法之间进行连贯的比较'
- en: '*Communication*—So that we can generate referenceable visualizations to demonstrate
    to the business how our modeling efforts are solving the problem'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*沟通*——以便我们可以生成可引用的可视化，向业务展示我们的建模工作是如何解决问题的'
- en: It is critically important to meet these two needs starting at this phase of
    project work. Without standardization, we run the risk of making poor decisions
    on which approach to go with for the MVP (and the subsequent fully developed solution).
    In addition, we risk wasting time by multiple teams that, instead of testing their
    approaches, are building implementations that are effectively identical to a visualization
    that in essence does the same thing. Without the communication aspect, we would
    be left with either confusing metric score values to report, or, in the worst
    case, raw code to show to the business. Either approach would be a recipe for
    disaster in a demonstration meeting.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目工作的这个阶段满足这两个需求至关重要。如果没有标准化，我们可能会在MVP（以及随后的完整解决方案）选择方法上做出错误的决定。此外，我们可能会浪费多个团队的时间，这些团队本应测试他们的方法，却正在构建实际上与可视化本质上做同样事情的实现。如果没有沟通方面，我们可能会留下令人困惑的指标分数值来报告，或者在最坏的情况下，向业务展示原始代码。任何一种方法都会在演示会议上导致灾难。
- en: Always be prepared with non-confusing plots
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总是准备好不令人困惑的图表
- en: One of the earliest lessons that I learned as a fledgling data scientist (back
    before we were called that) was that not every person in a company has an appetite
    for statistics. There is no better way to learn this than by spouting off the
    veracity of a solution that you’ve spent months working on by claiming some obscure
    (to them, not to us) accuracy score, confidence interval, or other mathematical
    metric to an executive who is providing funding for a project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名初出茅庐的数据科学家（在我们被称为这个名字之前），我学到的最早的教训之一是，公司里的每个人并不都对统计数据有胃口。没有比向为项目提供资金的高管吹嘘你花费数月时间研究出的解决方案的真实性更好的方法了，你可以声称一些晦涩（对他们来说，不是对我们来说）的准确度分数、置信区间或其他数学指标。
- en: As a species, we yearn for order and patterns in the world. *Negentropy* (a
    term coined by Leon Brillouin) is a natural evolutionary tendency that is effectively
    programmed into us. Because of this, visual representations of data, particularly
    when crafted to simplify a highly complex system, are always going to be more
    effective as a communications tool.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种物种，我们渴望在世界上找到秩序和模式。*负熵*（由莱昂·布里渊提出的一个术语）是一种自然的进化趋势，它被有效地编程进我们的身体中。正因为如此，数据的视觉表示，尤其是当它们被精心设计以简化高度复杂的系统时，总是作为沟通工具更加有效。
- en: I can’t recommend strongly enough that for any particular solution that a data
    scientist is working on, a great deal of thought and energy should be spent thinking
    of, and building, the most effective and easy-to-comprehend visualization that
    conveys the respective predictive power of the algorithms in use (or developed
    from scratch) to solve the targeted business problem. This isn’t to say that everyone
    in the business units is going to be ignorant of the metrics used; rather, the
    point is that a visual representation is always going to be more powerful in conveying
    information about an ML solution than any other means.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈推荐，对于任何数据科学家正在工作的特定解决方案，都应该投入大量的思考和精力来思考并构建最有效且易于理解的视觉表示，以传达所使用的算法（或从头开发）的相应预测能力，以解决目标商业问题。这并不是说业务部门的每个人都将是无知的；相反，重点是视觉表示总是比其他任何手段在传达机器学习解决方案的信息方面更强大。
- en: To quote the original conveyer of the idea, Henrik Ibsen, “A thousand words
    leave not the same deep impression as does a single deed.” In other words, conveniently
    adapted by Fred R. Barnard, “a picture is worth a thousand words.”
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 引用这个想法的原始传达者亨利克·易卜生的话，“一千个词也不如一个行动留下的深刻印象。”换句话说，正如弗雷德·R·巴纳德方便地改编的那样，“一图胜千言。”
- en: Before the teams break out and start developing their assigned solutions too
    intensely in their respective silos, we could stand to have one final analysis
    done by the larger team to help inform how well their predictions are performing
    in a visual sense. Keep in mind that, as we discussed in chapter 4, at the conclusion
    of this phase of experimentation the team will need to present its findings in
    a way that can be easily digested by a non-ML and nontechnical audience.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队开始跳出自己的领域并过于专注于开发分配的解决方案之前，我们可能需要由更大的团队进行一次最终分析，以帮助了解他们的预测在视觉上的表现如何。记住，正如我们在第4章中讨论的那样，在这个实验阶段的结束时，团队需要以一种可以轻松被非机器学习和非技术受众消化的方式展示其发现。
- en: One of the most effective ways of achieving this communication is through simple
    visualizations. Focusing on showing the results of the approach’s output with
    clear and simple annotations can not only benefit the early phases of testing
    but also can be used to report on performance of the solution later, when it is
    in production. Avoiding confusing reports and tables of metrics with no visual
    cue to explain what they mean will ensure clear and concise communication with
    the business.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种沟通的最有效方式之一是通过简单的可视化。专注于展示方法输出的结果，并使用清晰简单的注释，不仅可以有利于测试的早期阶段，还可以在解决方案投入生产后用于报告其性能。避免使用没有视觉提示来解释其含义的混淆报告和指标表，将确保与业务进行清晰简洁的沟通。
- en: Baseline comparison visualization
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 基线比较可视化
- en: To have a basic reference for more-complex models, it can be beneficial to see
    what the simplest implementation produces; then we can see if whatever we come
    up with can do better than that. This baseline, for the purposes of time-series
    modeling, can take the form of a simple moving average and an exponentially smoothed
    average. Neither of these two approaches would be applicable for the forecasting
    needs of the project, but their output results can be used to see, within the
    holdout period for validation, if our more sophisticated approaches will be an
    improvement.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个更复杂模型的基本参考，查看最简单的实现结果可能是有益的；然后我们可以看看我们提出的方案是否能做得更好。对于时间序列建模而言，这个基线可以采取简单移动平均和指数平滑平均的形式。这两种方法都不适用于项目的预测需求，但它们的输出结果可以用来在验证的保留期内查看我们的更复杂的方法是否会是一个改进。
- en: To create a visualization that the teams can use to see these relationships
    for simpler algorithms, we first have to define an exponential smoothing function,
    as shown in the next listing. Keep in mind that this is all designed both to standardize
    the work of each team and to build an effective communication tool for conveying
    the success of the project to the business.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建团队可以用来查看这些关系的可视化，我们首先必须定义一个指数平滑函数，如以下列表所示。请记住，这一切都是为了标准化每个团队的工作，并建立一个有效的沟通工具，以传达项目的成功给业务。
- en: Listing 6.1 Exponential smoothing function to generate a comparison forecast
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 用于生成比较预测的指数平滑函数
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ alpha is the smoothing parameter, providing dampening to the previous values
    in the series. (Values close to 1.0 have strong dampening effects, while conversely,
    values near 0.0 are not dampened as much.)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ alpha是平滑参数，为序列中的前一个值提供阻尼。 (值接近1.0具有强烈的阻尼效果，而相反，值接近0.0的阻尼效果较小。)
- en: ❷ Adds the starting value from the series to initiate the correct index positions
    for the traversal
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将序列的起始值添加到初始化正确的索引位置以进行遍历
- en: ❸ Iterates through the series, applying the exponential smoothing formula to
    each value and preceding value
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对序列进行迭代，将指数平滑公式应用于每个值及其前一个值
- en: A complementary function is needed for additional analytics purposes to generate
    a metric and error estimation for these simple modeling fits for the time series.
    The following listing provides a method for calculating the mean absolute error
    for the fit, as well as for calculating the uncertainty intervals (`yhat` values).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行额外的分析目的，需要提供一个补充函数来为这些简单的时间序列建模拟合生成指标和误差估计。以下列表提供了一个计算拟合平均绝对误差的方法，以及计算不确定性区间（`yhat`值）的方法。
- en: Listing 6.2 Mean absolute error and uncertainty
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2 平均绝对误差和不确定性
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Instantiates a dictionary to place the calculated values in for the purposes
    of currying
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 实例化一个字典，用于将计算值放入Currying的目的地
- en: ❷ Uses the standard sklearn mean_absolute_error function to get the MAE between
    the raw data and the smoothed series
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用标准的sklearn mean_absolute_error函数获取原始数据和平滑序列之间的MAE
- en: ❸ Calculates the standard deviation of the series differences to calculate the
    uncertainty threshold (yhat)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算序列差异的标准差以计算不确定性阈值（yhat）
- en: ❹ Calculates the standard baseline yhat value for the differenced series
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 计算差分序列的标准基线yhat值
- en: ❺ Generates a low and high yhat series centered around the smoothed series data
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在平滑序列数据周围生成一个低和高yhat序列
- en: NOTE Throughout these code listings, `import` statements are shown where needed
    above functions. This is for demonstration purposes only. All `import` statements
    should always be at the top of the code, whether writing in a notebook, a script,
    or in an IDE as modules.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这些代码列表中，`import`语句在函数上方需要的地方显示。这只是为了演示目的。所有的`import`语句都应该始终位于代码的顶部，无论是编写笔记本、脚本还是在IDE中作为模块。
- en: Now that we’ve defined the two functions in listings 6.1 and 6.2, we can call
    them in another function to generate not only a visualization, but a series of
    both the moving average and the exponentially smoothed data. The code to generate
    this reference data and an easily referenceable visualization for each airport
    and passenger type follows.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了列表6.1和6.2中的两个函数，我们可以在另一个函数中调用它们，不仅生成可视化，还可以生成移动平均和指数平滑数据的系列。以下代码用于生成每个机场和乘客类型的参考数据和易于引用的可视化。
- en: Listing 6.3 Generating smoothing plots
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 生成平滑图
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Currying dictionary for data return values
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 数据返回值的Currying字典
- en: ❷ Simple time-series moving average calculation
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 简单的时间序列移动平均计算
- en: ❸ Calls the function defined in listing 6.1
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用列表6.1中定义的函数
- en: ❹ Calls the function defined in listing 6.2 for the simple moving average series
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 调用列表6.2中定义的函数以获取简单移动平均序列
- en: ❺ Calls the function defined in listing 6.2 for the exponentially smoothed trend
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 调用列表6.2中定义的函数以获取指数平滑趋势
- en: ❻ Applies the pandas index date series to the non-indexed exponentially smoothed
    series (and the yhat series values as well)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将pandas索引日期序列应用于非索引的指数平滑序列（以及yhat序列值）
- en: ❼ Uses string interpolation with numeric formatting so the visualizations are
    more legible
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 使用字符串插值和数字格式化，使可视化更易读
- en: We call this function in the next listing. With this data and the visualization
    prebuilt, the teams can have an easy-to-use and standard guide to reference throughout
    their modeling experimentation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一列表中调用此函数。有了这些数据和预建的可视化，团队可以有一个易于使用且标准化的指南，在整个建模实验过程中进行参考。
- en: Listing 6.4 Calling the reference smoothing function for series data and visualizations
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.4 调用参考平滑函数以获取序列数据和可视化
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When it’s executed, this code will give the subteams a quick reference visualization
    (and the series data to compare with from the moving average and exponentially
    weighted moving average smoothing algorithm), shown in figure 6.3.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，此代码将为子团队提供一个快速参考可视化（以及与移动平均和指数加权移动平均平滑算法比较的序列数据），如图6.3所示。
- en: '![06-03](../Images/06-03.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![06-03](../Images/06-03.png)'
- en: Figure 6.3 Reference trends visualization based on the usage of the smoothed_time_plots()
    function, as shown in listing 6.4
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 基于列表6.4中展示的smoothed_time_plots()函数使用的参考趋势可视化
- en: 'The goal in wrapping this boilerplate visualization code into a function (as
    shown in listing 6.3 and used in listing 6.4) at this stage is twofold:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段将此样板可视化代码包装成函数（如列表6.3所示，并在列表6.4中使用）的目标有两个：
- en: '*Portability*—Each team can be given this function as a referenceable bit of
    code that can be used as a dependency to its work, ensuring that everyone is generating
    the exact same visualizations.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*便携性*—每个团队都可以将此函数作为可引用的代码片段使用，作为其工作的依赖项，确保每个人都在生成完全相同的可视化。'
- en: '*Preparing for production*—This code, as a function, can be easily ported into
    a visualization class as a method that can be used for not only this project,
    but also other forecasting projects in the future.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为生产做准备*—作为函数，此代码可以轻松地移植到可视化类中，作为方法使用，不仅适用于本项目，也适用于未来的其他预测项目。'
- en: The focus on spending a marginal amount of time at creating reusable code may
    not seem worthwhile at this point, particularly with the focus that we’ve been
    giving to timeliness of delivery for the solution prototype. But rest assured,
    as projects grow in scope and the complexity extends far beyond a simple forecasting
    problem, the relatively small effort made at this point to prepare for modularized
    code now will save a great deal of time later.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建可重用代码上花费少量时间可能在此阶段看起来不值得，尤其是考虑到我们一直关注解决方案原型的及时交付。但请放心，随着项目规模的扩大和复杂性的增加远远超出简单的预测问题，现在为模块化代码所做的相对较小的努力将节省大量的时间。
- en: Standard metrics
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 标准指标
- en: The last thing the team needs to implement before moving to the model experimentation
    is the standardized measurement of the forecasting predictions to holdout validation
    data. This effort is to eliminate any chance of debate regarding the effectiveness
    of each implementation. We’re effectively streamlining the adjudication of each
    implementation’s merits by way of standardization, which will not only save time
    in meetings, but also provide a strong scientific methodology to the comparison
    of each.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在转向模型实验之前，团队需要实施的最后一件事是对预测预测的标准化测量，以保持对保留验证数据的评估。这项工作是为了消除关于每个实现有效性的任何争议。我们通过标准化有效地简化了每个实现优点的裁决，这不仅会在会议中节省时间，而且为每个的比较提供了一个强大的科学方法。
- en: If were we to leave each team to determine its own optimal evaluation metrics,
    comparing them to one another would be nigh impossible, leading to rework of tests
    and further project delays. If we were to accumulate enough of these avoidable
    delays, we could dramatically increase the possibility of project abandonment.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们让每个团队自行确定其最优评估指标，比较它们将几乎不可能，导致测试的重做和项目进一步的延误。如果我们积累足够的这些可避免的延误，我们将大大增加项目放弃的可能性。
- en: Arguing over metrics sounds silly, right?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就指标进行争论听起来很愚蠢，对吧？
- en: Yes. Yes, it most certainly does.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。是的，它确实如此。
- en: Have I seen it done? Yes, I have.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过有人这样做吗？是的，我见过。
- en: Have I done it? Shamefully, yes, and I wish I had those hours of my life back
    to use more fruitfully.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我做过吗？羞愧地说，是的，我希望我能把那些生命中的小时重新利用起来。
- en: Have I endured it as a recipient? I most certainly have.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我作为接受者是否忍受过这种情况？我当然忍受过。
- en: Have I seen it be the cause of a project being cancelled? No, that’s ridiculous.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过它是导致项目取消的原因吗？不，那太荒谬了。
- en: What needs to be mentioned is that time is finite. When building a solution
    to solve a business problem, only so many delays can be allowed to occur before
    the business unit will either continue doing what it’s been doing up until the
    DS team was involved, or will flat-out call for a cancellation of the project
    and basically refuse to ever work with the team again.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 需要提到的是，时间是有限的。当构建一个解决方案来解决业务问题时，在业务单元继续做它之前的事情，或者会直接要求取消项目，基本上拒绝再次与团队合作之前，只能允许发生如此多的延迟。
- en: Avoidable and superfluous delays surrounding sustained arguments about which
    metric to use to evaluate a model are flat-out silly, particularly when we consider
    that it’s such a trivial investment of time to calculate all the metrics for a
    model evaluation and have their referenceable scores preserved for post hoc evaluation
    at any time in the future. Just collect all that are relevant to the problem you’re
    trying to solve (with the notable exception mentioned earlier—if the metric is
    of such computational complexity to prove noticeably expensive to acquire, make
    sure it’s worthwhile to capture before writing the code for it). Adapting the
    code to support such flexibility is in alignment with Agile principles, permitting
    a rapid pivot without requiring a large refactoring to change the functionality.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕着关于使用哪个指标来评估模型持续争论的可避免和多余的延迟是愚蠢的，尤其是当我们考虑到计算模型评估的所有指标并保留其可参考的分数以供未来任何时候的后验评估是一项如此微不足道的时间投资时。只需收集与你要解决的问题相关的所有指标（值得注意的是，前面提到的例外——如果指标的计算复杂度如此之高，以至于获取它明显很昂贵，确保在编写代码之前捕获它是值得的）。使代码适应这种灵活性符合敏捷原则，允许快速转向，而无需进行大量重构来更改功能。
- en: 'In section 5.1.3, we covered the agreed-upon metrics that the team will be
    using to score models: R-squared, MSE, RMSE, MAE, MAPE, and explained variance.
    To save a great deal of time for each subteam that will be focused on implementing
    the modeling tests, we should build a few functions that will make scoring and
    standardized reporting of the results much easier.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在5.1.3节中，我们讨论了团队将用于评估模型的协议指标：R平方、均方误差（MSE）、均方根误差（RMSE）、平均绝对误差（MAE）、平均绝对百分比误差（MAPE）和解释方差。为了为每个将专注于实施建模测试的子团队节省大量时间，我们应该构建一些函数，这将使评分和标准化报告结果变得更加容易。
- en: First, we need to actually implement MAPE, as it is not readily available as
    a scoring metric in Python libraries (at the time of this writing). This metric
    is of critical importance to assessing the overall quality of predictions across
    so many different time series, as it is a scaled and standardized value that can
    be used to compare against different forecasts without having to account for the
    magnitude of the series values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要实际实现MAPE，因为它在Python库中（在撰写本文时）并不是作为评分指标 readily available。这个指标对于评估跨许多不同时间序列的预测的整体质量至关重要，因为它是一个缩放和标准化的值，可以用来比较不同的预测，而无需考虑序列值的幅度。
- en: It shouldn’t, however, be used as the only measurement metric, as we discussed
    earlier in planning for our experimentation. Having multiple metrics recorded
    for each experiment being conducted is going to pay dividends if we need to evaluate
    previous experiments based on a different metric. The following listing shows
    a basic MAPE implementation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它不应该作为唯一的测量指标，正如我们在实验规划中之前讨论的那样。为每个正在进行的实验记录多个指标将带来好处，如果我们需要根据不同的指标评估以前的实验。以下列表显示了一个基本的MAPE实现。
- en: Listing 6.5 Simple MAPE implementation
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5 简单MAPE实现
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have that defined, we can create a simple series scoring function
    that will calculate all the agreed-upon metrics without having to litter all of
    the experimentation code bases with manual implementations of each calculation.
    This function will also allow us to embed these calculations into our visualizations
    without having to constantly redefine standard metric calculations throughout
    the code. The standard metric function that we’ll be using is shown next.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了这一点，我们可以创建一个简单的序列评分函数，它将计算所有商定的指标，而无需在所有实验代码库中手动实现每个计算。此函数还将允许我们将这些计算嵌入到我们的可视化中，而无需在代码中不断重新定义标准指标计算。我们将使用的标准指标函数将在下面展示。
- en: Listing 6.6 Standard error calculations for scoring forecast data
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.6为评分预测数据的标准误差计算
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Imports and utilizes as many standard scoring implementations as possible
    that are available. There’s no reason to reinvent the wheel.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 尽可能多地导入和利用可用的标准评分实现。没有必要重新发明轮子。
- en: ❷ Passes in the actual series and the predicted series for the forecasting validation
    time period
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 实际序列和预测序列在预测验证时间段的通过情况
- en: ❸ Instantiates a dictionary construct for storing the scores for use elsewhere
    (notice the absence of print statements)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 实例化一个字典结构来存储评分以供其他地方使用（注意打印语句的缺失）
- en: ❹ Local variable declaration (since the mse value will be stored and used for
    the rmse metric)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 局部变量声明（因为mse值将被存储并用于rmse指标）
- en: ❺ Calculation and usage of the mape calculation defined in listing 6.5
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 列表6.5中定义的mape计算的运算和使用
- en: Conspicuously absent from this function is a `print` statement. This is by design
    for two distinctly different reasons.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数明显没有`print`语句。这是出于两个截然不同的原因的设计。
- en: First, we want to use the dictionary-encapsulated score metrics for the visualization
    we’re going to build for the teams to use; therefore, we don’t want to have the
    values simply printed to stdout. Second, it’s a bad practice to have stdout reporting
    in functions and methods, as this will create more work for you later when developing
    a solution.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望使用字典封装的评分指标来构建我们将为团队使用的可视化；因此，我们不希望简单地打印到标准输出。其次，在函数和方法中报告标准输出是一种不良做法，因为这将在你开发解决方案时给你带来更多的工作。
- en: Digging through code prior to a release to production to scrub out `print` statements
    (or convert them to logging statements) is tedious, error-prone, and if missed,
    can have performance impacts on production solutions (particularly in lazily evaluated
    languages). In addition, in production, *no one will ever read* stdout, leaving
    the `print` statements as nothing more than needlessly executed code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布到生产之前挖掘代码以清除`print`语句（或将它们转换为日志语句）是乏味、易出错且如果遗漏，可能会对生产解决方案的性能产生影响（尤其是在延迟评估的语言中）。此外，在生产中，*没有人会阅读*标准输出，使得`print`语句除了是无用执行的代码之外别无其他。
- en: Print statements and why they’re terrible for ML
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 打印语句及其为何对机器学习很糟糕
- en: Honestly, `print` statements are bad for all software. The only notable exception
    is for temporary debugging of code. If you want to check the state of something
    complex during runtime, they can be a great help. Aside from that specific use
    case, they should be avoided at all costs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`print`语句对所有软件都不好。唯一的显著例外是用于代码的临时调试。如果你想检查运行时复杂事物的状态，它们可以非常有帮助。除了这个特定用例之外，应该不惜一切代价避免使用。
- en: 'The problem is that I see them everywhere: printed row counts, printed scoring
    metrics, printed lengths of arrays and lists, printed hyperparameters being tested,
    printed sources and sinks for I/O operations, and printed configurations for arguments
    supplied to methods. They’re all equally useless (and most are actively detrimental
    to your team’s infrastructure budget).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我到处都看到它们：打印的行数、打印的评分指标、打印的数组和列表长度、打印正在测试的超参数、打印I/O操作的源和目标以及打印传递给方法的参数配置。它们都是同样无用的（而且大多数对团队的基础设施预算有积极破坏作用）。
- en: 'Blog posts, hello worlds, and basic Getting Started guides for APIs use them
    liberally to showcase an immediate and gratifying result for those getting into
    a new language, topic, or API, but once you’ve become marginally familiar with
    the syntax and usage, these should always be removed from code. The reason is
    simple: you’re never going to look at those `print` statements ever again outside
    of experimentation and development. Littering them around in code will leave confusing
    and hard-to find references within stdout, indicating where the code is going
    to be running in production, which generally means that once a run is over, the
    information is lost forever.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 博客文章、Hello World示例和API的基本入门指南广泛使用它们来展示新语言、主题或API的即时和令人满意的结果，但一旦您对语法和用法有了基本的了解，这些应该总是从代码中移除。原因很简单：您永远不会再次查看那些`print`语句，除非是在实验和开发之外。在代码中随意放置它们会在stdout中留下令人困惑且难以找到的引用，指示代码将在生产中运行的位置，这通常意味着一旦运行结束，信息就会永远丢失。
- en: The better approach for information associated with an ML run is to persist
    the data to a location that can be easily queried or visually referenced. That
    way, the information that you painstakingly collect for the purpose of the `print`
    statement can be stored for later reference, plotting, or for system control for
    automated processes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与机器学习运行相关的信息，更好的做法是将数据持久化到可以轻松查询或视觉参考的位置。这样，您为`print`语句收集的辛苦收集的信息可以存储起来供以后参考、绘图或用于系统控制自动化流程。
- en: Do yourself a favor and, if you really need to print things during experimentation,
    make sure that `print` statements are present only in experimental script code.
    The better alternative is to log the results in code, or, as we will cover in
    the next chapter, a service like MLflow.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 做个好事，如果你在实验期间真的需要打印东西，确保`print`语句只存在于实验脚本代码中。更好的替代方案是在代码中记录结果，或者，如我们将在下一章中介绍的，使用MLflow这样的服务。
- en: For the final pre-modeling work, we need to build a quick visualization and
    metric-reporting function that will give each team a standard and highly reusable
    means of evaluating the prediction performance for each model. The following listing
    shows a simple example, which we will be utilizing during the model experimentation
    phase in section 6.1.2.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最终建模前的准备工作，我们需要构建一个快速的可视化和指标报告函数，这将给每个团队提供一个标准且高度可重用的评估每个模型预测性能的方法。以下列表显示了一个简单的示例，我们将在第6.1.2节中的模型实验阶段使用它。
- en: Listing 6.7 Prediction forecast plotting with error metrics
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.7：带有误差度量的预测预报绘图
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Sets the inputs to be indexed series values instead of a DataFrame input with
    field names to keep the function more generic
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将输入设置为索引系列值，而不是具有字段名的DataFrame输入，以使函数更通用
- en: ❷ Calls the function created in listing 6.6 to calculate all of the agreed-upon
    error metrics for the project
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用第6.6节中创建的函数，计算项目中所有商定的误差度量
- en: ❸ Adds the error metrics to the output dictionary for use outside of simply
    producing a visualization
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将误差度量添加到输出字典中，以便在仅生成可视化之外使用
- en: ❹ Generates the string that will be applied to a bounding box element superimposed
    on the graph
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 生成应用于图上叠加的边界框元素的字符串
- en: ❺ Plots the overlays of the actual and forecasted prediction data onto the same
    graph with different colors
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 以不同颜色将实际和预测预测数据叠加到同一图上
- en: ❻ Creates a text box that shows all error scores along with the plotted data
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 创建一个文本框，显示所有误差分数以及绘制的数据
- en: ❼ Writes the text contents into the text bounding box
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将文本内容写入文本边界框
- en: Now, after creating these basic functions to accelerate our experimentation
    work, we can finally begin the process of testing various forecasting algorithms
    for our time-series work.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在创建这些基本函数以加速我们的实验工作之后，我们终于可以开始测试各种时间序列工作的预测算法的过程了。
- en: 6.1.2 Running quick forecasting tests
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 运行快速预测测试
- en: The rapid testing phase is by far the most critical aspect of prototyping to
    get right. As mentioned in this chapter’s introduction, it is imperative to strive
    for the middle ground—between not testing enough of the various approaches to
    determine the tuning sensitivity of each algorithm, and spending inordinate amounts
    of time building a full MVP solution for each approach. Since *time is the most
    important aspect of this phase*, we need to be efficient while making an informed
    decision about which approach shows the most promise in solving the problem in
    a robust manner.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 快速测试阶段是原型设计中最关键的方面，必须正确处理。正如本章引言中提到的，努力寻求中间地带至关重要——既不是测试各种方法太少，无法确定每个算法的调整灵敏度，也不是花费过多的时间构建每个方法的完整最小可行产品（MVP）解决方案。由于*时间是这一阶段最重要的方面*，我们需要在做出明智决策的同时保持效率，关于哪种方法最有希望以稳健的方式解决问题。
- en: Freshly armed with useful and standardized utility functions, each team can
    work on its respective approaches, rapidly testing to find the most promising
    model. The team has agreed that the airports under consideration for modeling
    tests are JFK, EWR, and LGA (each team needs to test its model and tuning paradigms
    on the same datasets so a fair evaluation of each approach can occur).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有有用且标准化的效用函数，每个团队都可以在其相应的方法上工作，快速测试以找到最有希望的模式。团队已经同意，用于建模测试的机场是JFK、EWR和LGA（每个团队需要在相同的数据集上测试其模型和调整范式，以便对每种方法进行公平的评价）。
- en: Let’s take a look at what the teams will be doing with the different model approaches
    during rapid testing, what decisions will be made about the approaches, and how
    the teams can quickly pivot if they find that the approach is going nowhere. The
    exploratory phase is going to not only uncover nuances of each algorithm but also
    illuminate aspects of the project that might not have been realized during the
    preparatory phase (covered in chapter 5). It’s important to remember that this
    is to be expected and that during this rapid testing phase, the teams should be
    in frequent communication with one another when they discover these problems (see
    the following sidebar for tips on effectively managing these discoveries).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在快速测试期间，团队将如何使用不同的模型方法，将做出哪些关于方法的决策，以及如果他们发现这种方法没有进展，团队如何快速调整。探索阶段不仅将揭示每个算法的细微差别，还将阐明在准备阶段（在第5章中介绍）可能没有意识到的项目方面。重要的是要记住，这是可以预见的，在快速测试阶段，当团队发现这些问题时，他们应该相互之间保持频繁的沟通（以下侧边栏提供了有效管理这些发现的技巧）。
- en: A call for a referee during hackathons
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在黑客马拉松期间寻求裁判
- en: Some of my most exciting DS work has occurred in the rapid prototyping phase
    of a project. It’s exciting to see the creativity that’s generated and the intensity
    of groups of brilliant minds working together to build a solution to a business
    problem previously thought to be unsolvable.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我最激动人心的数据科学工作之一发生在项目的快速原型阶段。看到产生的创造力和一群聪明人共同努力解决一个被认为无法解决的问题，这是令人兴奋的。
- en: With all of the chaos of the day (or days, depending on the complexity of the
    problem) of a hackathon, it is important to have a moderator for the event. Whether
    it be the team lead, manager, lead data scientist, or the most senior individual
    technical contributor to the group, the important thing is to set one person aside
    from the work to serve as a communicator among the groups.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在黑客马拉松一天（或几天，取决于问题的复杂性）的混乱中，有一个活动调解员非常重要。无论是团队领导、经理、首席数据科学家还是小组中最资深的个人技术贡献者，重要的是要留出一个人来从工作中抽身，作为小组之间的沟通者。
- en: This person’s role is to discuss what is being worked on, provide advice, and
    transfer knowledge that has been gained among the groups. This person shouldn’t
    be actively working on any of the solutions because of the importance of the arbiter
    role. They should be spending time moving from group to group, asking brief but
    pointed questions, and helping provide advice on alternate strategies in case
    a team gets stuck.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个人的角色是讨论正在进行的任务，提供建议，并转移在团队之间获得的知识。由于仲裁角色的关键性，这个人不应该积极从事任何解决方案的工作。他们应该花时间在各个小组之间移动，提出简短而尖锐的问题，并在团队遇到困难时提供关于替代策略的建议。
- en: We’ll see throughout this exercise of rapid prototyping in this section that
    findings that come up in one team can apply to other teams. Having a neutral technical
    party available to disperse this information is key.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到快速原型设计练习中的发现可以应用于其他团队。有一个中立的第三方技术方来传播这些信息是关键。
- en: Whether the prototyping phase is gamified or not, the important point to remember
    is that the entire team is, after all, working for the same company. Everyone
    will eventually be focused on the approach that wins out through the MVP, development,
    and production phases of the solution. There’s really nothing to be gained by
    having an aggressive and highly competitive competition.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 无论原型设计阶段是否游戏化，重要的是要记住，毕竟整个团队都在为同一家公司工作。每个人最终都会关注通过MVP、开发和生产阶段胜出的解决方案的方法。进行激烈和高度竞争的比赛实际上没有什么好处。
- en: Wait a minute . . . how are we going to create a validation dataset?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下……我们怎么创建一个验证数据集？
- en: One group drew the proverbial short straw in the model-testing phase with a
    forecasting approach to research and test that isn’t particularly well understood
    by the team. Someone on the team found mention of using a VAR to model multiple
    time series together (multivariate endogenous series modeling), and thus, this
    group sets out to research what this algorithm is all about and how to use it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型测试阶段，有一个团队抽到了不吉利的短草，他们采用了一种团队不太理解的预测方法进行研究和测试。团队中的某个人提到了使用向量自回归（VAR）来共同建模多个时间序列（多元内生序列建模），因此这个团队着手研究这个算法是什么以及如何使用它。
- en: The first thing that they do is run a search for “vector autoregression,” which
    results in a massive wall of formulaic theory analysis and mathematical proofs
    centered primarily around macro-econometrics research and natural sciences utilizations
    of the model. That’s interesting, but not particularly useful if they want to
    test out the applications of this model to the data quickly. They next find the
    statsmodels API documentation for the model.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 他们首先搜索“向量自回归”，结果是一大堆围绕宏观经济计量研究和模型在自然科学应用中的公式化理论分析和数学证明。这很有趣，但如果他们想快速测试这个模型在数据上的应用，就不是很实用了。接下来，他们找到了该模型的statsmodels
    API文档。
- en: 'The team members quickly realize that they haven’t thought about standardizing
    one common function yet: the split methodology. For most supervised ML problems,
    they’ve always used pandas split methodologies through DataFrame slicing or utilizing
    the high-level random split APIs, which use a random seed to select rows for training
    and test datasets. However, for forecasting, they realize that they haven’t had
    to do datetime splitting in quite some time and need a deterministic and chronological
    split method to get accurate forecast validation holdout data. Since the dataset
    has an index set from the ingestion function’s formatting of the DataFrame, they
    could probably craft a relatively simple splitting function based on the index
    position. What they come up with is in the following listing.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 团队成员很快意识到，他们还没有考虑过标准化一个共同的功能：分割方法。对于大多数监督机器学习问题，他们一直使用pandas的分割方法，通过DataFrame切片或利用高级随机分割API，这些API使用随机种子来选择训练集和测试集的数据行。然而，对于预测，他们意识到他们已经有一段时间没有进行时间分割了，需要一种确定性和按时间顺序的分割方法来获取准确的预测验证保留数据。由于数据集有一个从DataFrame格式化函数中设置的索引，他们可能可以基于索引位置构建一个相对简单的分割函数。他们想出的方法如下所示。
- en: Listing 6.8 Time split for train and test datasets (with validation check)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8：训练集和测试集的时间分割（包含验证检查）
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ A validation assertion function designed to ensure that the splits being conducted
    through the custom function are not dropping any rows of data between train and
    test
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设计的验证断言函数旨在确保通过自定义函数进行的分割不会在训练集和测试集之间丢失任何数据行
- en: ❷ Assertions like this are a prelude to “hardened code” and unit testing. We
    cover this more in later chapters, but for this simple example, realize that we
    are building a custom splitting function to ensure that it functions as the user
    expects.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这样的断言是“加固代码”和单元测试的前奏。我们将在后面的章节中更详细地介绍这一点，但在这个简单的例子中，要意识到我们正在构建一个自定义分割函数，以确保它按用户期望的方式运行。
- en: ❸ The function for generating the train and test splits for building the model
    and validating it
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 用于生成训练集和测试集分割以构建模型并验证它的函数
- en: ❹ Might as well allow for creative inputs here, right? “June 3rd 2005” should
    resolve just like “2005-06-03.” If we’re using Python, we might as well leverage
    this sort of flexibility. I mean, who needs type safety, anyway?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '❻ 允许在这里进行创新输入，对吧？“2005年6月3日”应该像“2005-06-03”一样解析。如果我们使用 Python，我们不妨利用这种灵活性。我的意思是，谁还需要类型安全呢？ '
- en: ❺ A search function for finding the nearest date. (Remember, we have monthly
    data here; what happens if someone puts in 2008-04-17? What happens if they put
    in 2008-04-01? We need to have the behavior be the same regardless of which valid
    data is passed in.)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 一个用于查找最近日期的搜索函数。（记住，我们这里的数据是按月度提供的；如果有人输入 2008-04-17 会发生什么？如果他们输入 2008-04-01
    会发生什么？我们需要确保无论传入哪个有效数据，行为都是相同的。）
- en: ❻ Generates the training data up to the nearest found date
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 生成直到最近找到的日期的训练数据
- en: ❼ Generates the test data from the next index position after where the train
    left off
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 从训练结束后的下一个索引位置生成测试数据
- en: ❽ Validates that our train and test splits didn’t duplicate or drop rows from
    the original source DataFrame. (We didn’t have to do that in the fuzzy parsing
    portion because an invalid date from the parser will throw an exception.)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 验证我们的训练和测试分割没有从原始源 DataFrame 中重复或删除行。（在模糊解析部分我们不需要这样做，因为解析器中的无效日期会抛出异常。）
- en: This team’s members, being the wonderful stewards of teamwork and comradery
    that they know themselves to be, immediately send this function snippet to the
    other teams so that they can have an easy single-line methodology for splitting
    their data. They even put in a creative fuzzy matching parser in case people want
    to use different date formats.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个团队的成员，作为他们自己知道的优秀的团队合作和友谊的守护者，立即将这个函数片段发送给其他团队，以便他们可以有一个简单的单行方法来分割他们的数据。他们甚至加入了一个创新的模糊匹配解析器，以防人们想使用不同的日期格式。
- en: Just to be sure that they’ve written it correctly, they’re going to do some
    testing of their implementation. They want to make sure that they’re actually
    getting exceptions raised if the data doesn’t match up correctly. Let’s see what
    they test in figure 6.4.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保他们正确地编写了代码，他们将对他们的实现进行一些测试。他们想确保如果数据不匹配，实际上会抛出异常。让我们看看他们在图 6.4 中测试了什么。
- en: '![06-04](../Images/06-04.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![06-04](../Images/06-04.png)'
- en: Figure 6.4 This function validation for custom logic ensures that listing 6.8
    functions the way we expect.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 这个自定义逻辑验证函数确保列表 6.8 的功能按预期工作。
- en: Rapid testing of the VAR model approach
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: VAR 模型方法的快速测试
- en: Now that we have a way to split data into train and test, let’s check back in
    with the team that was set up with testing out a VAR model. Without getting into
    excruciating detail about what this model can do, the goal of a VAR model is for
    simultaneous modeling of multiple time series in a single pass.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了将数据分割成训练和测试的方法，让我们回顾一下之前设置用于测试 VAR 模型的团队。不深入探讨这个模型能做什么，VAR 模型的目标是单次遍历中对多个时间序列进行同时建模。
- en: note If you are interested in learning more about these advanced approaches,
    there is no better resource than *New Introduction to Multiple Time Series Analysis*
    (Springer, 2006) by Helmut Lütkepohl, the creator of this algorithm.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：如果您想了解更多关于这些高级方法的信息，没有比 Helmut Lütkepohl 的《多时间序列分析新引论》（Springer，2006）更好的资源了，他是这个算法的创造者。
- en: The team looks at the example on the API docs page and starts to implement a
    simple test, shown next.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 团队查看 API 文档页面上的示例，并开始实现一个简单的测试，如下所示。
- en: Listing 6.9 A rough first pass at a VAR model
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.9 对 VAR 模型的一个粗略的初步尝试
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ There’s our vector autoregressor that we’ve been talking about!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这就是我们一直在谈论的向量自回归模型！
- en: ❷ Uses our super-sweet split function that can read all sorts of nonsense that
    people want to type in as dates
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用我们超级棒的分割函数，可以读取人们想输入的各种日期的废话
- en: ❸ Configures the VAR model with a vector of time-series data. We can model both
    at the same time! Cool? I guess?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用时间序列数据向量配置 VAR 模型。我们可以同时建模！酷吗？我想？
- en: ❹ The VAR class has an optimizer based on minimizing the Akaike information
    criterion (AIC). This function attempts to set a limit on the ordering selection
    to optimize for goodness of fit. We learned this by reading the API documentation
    for this module. Optimizing for AIC will allow for the algorithm to test a bunch
    of autoregressive lag orders and select the one that performs the best (at least
    it’s supposed to).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ VAR类有一个基于最小化赤池信息准则（AIC）的优化器。这个函数试图对滞后阶数的选择设置一个限制，以优化拟合度。我们是通过阅读这个模块的API文档了解到这一点的。优化AIC将允许算法测试大量的自回归滞后阶数，并选择表现最好的一个（至少理论上是这样）。
- en: ❺ Let’s call fit() on the model and see what equation it comes up with.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 让我们在模型上调用fit()函数，看看它会得出什么方程。
- en: ❻ The documentation said to do this. It’s supposed to get the AIC-optimized
    lag order from the fit model.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 文档建议这样做。它应该从拟合模型中获取AIC优化的滞后阶数。
- en: ❼ Generates the predictions. This was a bit tricky to figure out because the
    documentation was super vague and apparently few people use this model. We noodled
    around and figured it out, though. Here, we’re starting the forecast on the test
    dataset for both series, extracting the pure series from them, and forecasting
    out the same number of data points as are in the test dataset.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 生成预测。这有点难以理解，因为文档非常模糊，而且显然很少有人使用这个模型。我们摸索了一下，终于搞明白了。在这里，我们正在从两个序列的测试数据集中开始预测，提取出纯序列，并预测出与测试数据集中相同数量的数据点。
- en: ❽ This hurts my head, and I wrote it. Since we get a vector of forecasts (a
    tuple of domestic passenger predictions and international passenger predictions),
    we need to extract the values from this array of tuples, put them into a list,
    convert them to a NumPy array, and then generate a pandas series with the correct
    index from the test data so we can plot this. Whew.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 这让我头疼，而且是我写的。由于我们得到了一个预测的向量（国内乘客预测和国际乘客预测的元组），我们需要从这个元组数组中提取值，将它们放入一个列表中，将它们转换为NumPy数组，然后从测试数据中生成一个具有正确索引的pandas序列，这样我们就可以绘制这个图了。呼。
- en: ❾ We don’t even use this for plotting (reasons forthcoming), but this obnoxious
    copy-pasta is to be expected from experimental code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 我们甚至不用这个来绘图（原因即将揭晓），但实验代码中出现这种令人讨厌的复制粘贴是预料之中的。
- en: ❿ Let’s finally use that prediction plot code created in listing 6.7 to see
    how well our model did!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 最后，让我们使用在列表6.7中创建的预测图代码来看看我们的模型做得怎么样！
- en: The resulting forecast plot in the preceding code, comparing the predicted to
    actual data within the holdout validation period, is shown in figure 6.5.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中生成的预测图，比较了在保留验证期间预测数据和实际数据，如图6.5所示。
- en: '![06-05](../Images/06-05.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![06-05](../Images/06-05.png)'
- en: Figure 6.5 Probably should have read the API documentation
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 可能应该阅读API文档
- en: PRO TIP If I had a penny for every time I’ve either created a hot mess like
    that shown in figure 6.5 in a prediction (or in algorithm development code), I
    wouldn’t be employed right now. I’d be relaxing somewhere with my gorgeous wife
    and a half dozen dogs, sipping on a well-chilled cocktail and listening to the
    sweet sounds of the ocean lapping at a crystalline shore. Don’t get discouraged
    when you generate garbage. We all do it. It’s how we learn.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: PRO TIP 如果我每次在预测（或在算法开发代码中）创造出像图6.5中那样的混乱局面，我都会有一便士，我现在就不会工作了。我会在某个地方和我的美丽妻子以及半打狗一起放松，啜饮着冰镇鸡尾酒，听着海浪轻拍着水晶般的海岸的美妙声音。当你生成垃圾时，不要气馁。我们都会这样做。这是我们学习的方式。
- en: OK, so that was bad. Not as bad as it could have been (it didn’t predict that
    there would be more passengers than the number of humans that had ever lived,
    for instance), but it’s pretty much a garbage prediction. Let’s pretend that the
    team’s constitutional fortitude and wisdom are high enough that they are up for
    digging through the API documentation and Wikipedia articles to figure out what
    went wrong.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那确实很糟糕。但也没有糟糕到无法想象的地步（例如，它没有预测出乘客数量会超过历史上所有人类生活的数量），但基本上是一个垃圾预测。让我们假设这个团队的宪法勇气和智慧足够高，他们愿意挖掘API文档和维基百科文章来找出哪里出了问题。
- en: The most important aspect to remember here is that *poor results are an expected
    part of the rapid testing phase*. Sometimes you get lucky and things just work,
    but the vast majority of the time, things aren’t going to work out well on the
    first try. The absolute worst thing to do, after seeing results similar to figure
    6.5, would be to classify the approach as untenable and move on to something else.
    With some tuning and adjustments to the approach, this model could be the best
    solution. If it’s abandoned after a first attempt of just using default configurations
    on a raw series of data, the team would never know that it could be a viable solution.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要记住的最重要的一点是，*糟糕的结果是快速测试阶段预期的一部分*。有时你会很幸运，事情会顺利，但大多数时候，事情在第一次尝试时不太可能顺利。在看到类似于图6.5的结果之后，最糟糕的事情就是将这种方法归类为不可行并转向其他事情。通过一些调整和改进方法，这个模型可能就是最好的解决方案。如果它在仅使用默认配置对原始数据系列进行第一次尝试后就放弃了，团队就永远不会知道它可能是一个可行的解决方案。
- en: Bearing that extreme in mind, however, the other extreme is just as damaging
    to the project’s success. If the team members were to spend days (or weeks) reworking
    the approach hundreds of times to get the absolute best result from the model,
    they would no longer be working on a prototype; rather, they would be building
    out an MVP and sinking a great deal of resources into this single approach. The
    goal at this stage is getting a quick answer in a few hours as to whether this
    one out of many approaches is worth risking the success of the project.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑到这种极端情况，另一个极端对项目的成功同样有害。如果团队成员花费数天（或数周）重新调整方法数百次，以从模型中获得最佳结果，他们就不再是在做原型；相反，他们将会构建一个MVP，并将大量资源投入到这个单一的方法中。在这个阶段的目标是在几小时内得到一个快速的答案，以确定这种方法是否值得冒险影响项目的成功。
- en: Let’s get ready to screw some things up
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备好去搞砸一些事情吧
- en: Throughout this chapter, we’ve been looking at building up experiments from
    a state of terrible results to something that is pretty OK. This is to be expected
    in ML. For any problem that is approached with the tools of ML, many possible
    avenues could solve it. Some are easier to implement than others. For those others,
    hidden levels of complexity may not instantly be apparent when reading through
    API docs, blogs, and even books. It is inevitable that, for most of us who are
    naturally fallible humans, the perfect solution is not going to be found initially.
    In fact, the first dozen or so attempts at solving a problem are probably going
    to be embarrassingly bad.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直在观察从糟糕的结果到相当不错的结果的实验构建过程。这在机器学习中是可以预料的。对于任何使用机器学习工具解决的问题，可能有许多可能的途径可以解决。有些比其他更容易实现。对于那些更难实现的，隐藏的复杂层次在阅读API文档、博客甚至书籍时可能不会立即显现。对于大多数我们这些天生有缺陷的人类来说，完美的解决方案可能不会一开始就能找到。事实上，解决一个问题的前十几次尝试可能都会令人尴尬地糟糕。
- en: My general guide to ML development is that for every successful model that I’ve
    brought to a production state, I’ve thrown away over a hundred attempts (and generally
    a similar factor of the lines of code of the final solution is thrown away in
    the process of building it).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我在机器学习开发方面的一般指导原则是，对于我带到生产状态的每一个成功的模型，我都已经扔掉了超过一百次的尝试（并且通常最终解决方案的代码行数也有类似的倍数被扔掉，在构建过程中）。
- en: It’s critical as a professional ML engineer to realize that, in the early stages
    of experimentation, you’ll have some truly (perhaps amusing) failures. Some can
    be pretty frustrating, but most give an incredible sense of satisfaction when
    you finally figure out the issue and have a less-than-horrible prediction result.
    Simply embrace the failures, learn from them, and get a solid feel for how much
    API documentation you need to read before writing even your first attempt, to
    strike the balance between hacking through a problem blindly and spending weeks
    learning the API to the same level of detail as the original authors.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名专业的机器学习工程师，意识到在实验的早期阶段，你可能会遇到一些真正（也许是有趣的）失败是很关键的。有些可能会相当令人沮丧，但当你最终找出问题并得到一个不那么糟糕的预测结果时，大多数都会给你带来难以置信的满足感。简单地接受失败，从中学习，并在写下你的第一次尝试之前，对需要阅读多少API文档有一个稳固的感觉，以在盲目解决问题和花费数周时间学习API以达到原作者同样详细程度之间取得平衡。
- en: During this next round of testing, the team discovers that the `fit()` method
    *actually takes parameters*. The example that they saw and used as a baseline
    for the first attempt didn’t have this defined, so they were unaware of these
    arguments until they read the API documentation. They discovered that they can
    set the lag periodicity to help the model understand how far back to look when
    building its autoregressive equations, which, according to the documentation,
    should help with building the autoregressive model’s linear equations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一轮测试中，团队发现`fit()`方法实际上*接受参数*。他们看到的例子和用作第一次尝试基准的例子没有定义这些参数，所以他们直到阅读API文档才知道这些参数。他们发现他们可以设置滞后周期性，以帮助模型理解在构建自回归方程时应该回溯多远，根据文档，这应该有助于构建自回归模型的线性方程。
- en: Looking back to what they remembered (and recorded, saved, and stored) from
    the time-series analysis tasks that they did before starting on modeling, they
    knew that the trend decomposition had a period of 12 months (that was the point
    at which the residuals of the trend line became noise and not some cyclic relationship
    that didn’t fit with the seasonality period). They gave it another go, shown in
    the next listing.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾他们从开始建模之前所做的时序分析任务中记住的（以及记录、保存和存储的）内容，他们知道趋势分解有一个12个月的周期（那时趋势线的残差变成了噪声，而不是与季节性周期不匹配的某种循环关系）。他们再次尝试，如下一列表所示。
- en: Listing 6.10 Let’s give VAR another shot after we read the docs
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.10 在阅读文档后，让我们再给VAR试一次。
- en: '[PRE9]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ There’s the key. Let’s try to set that correctly and see if we get something
    that’s not so embarrassingly bad.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是关键。让我们尝试正确设置它，看看我们是否能得到不那么令人尴尬的结果。
- en: ❷ To be thorough, let’s take a look at the other time series as well (international
    passengers).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为了彻底，让我们也看看其他时序数据（国际旅客）。
- en: ❸ Let’s plot the international passengers as well to see how well this model
    predicts both.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 让我们再绘制国际旅客数据，看看这个模型预测得如何。
- en: After running this slightly adjusted test, the team looks at the results, shown
    in figure 6.6\. They look better than before, certainly, but they’re still just
    a bit off. Upon a final review and a bit more research, they find that the VAR
    model is designed to handle stationary time-series data only.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这个略微调整的测试后，团队查看结果，如图6.6所示。它们确实比之前好，但仍然只是稍微有点偏差。经过最终审查和更多研究后，他们发现VAR模型仅设计用于处理平稳时序数据。
- en: '![06-06](../Images/06-06.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![06-06](../Images/06-06.png)'
- en: Figure 6.6 Just because this result of executing listing 6.10 is an order of
    magnitude better than before doesn’t mean that it’s good.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 仅因为执行列表6.10的结果比之前好了一个数量级，并不意味着它是好的。
- en: 'At this point, this team is done with its evaluations. The team members have
    learned quite a few things about this API:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这个团队已经完成了其评估。团队成员对这个API了解了很多：
- en: The acquisition of a forecast from this API is complex.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这个API获取预测很复杂。
- en: Running multiple time series through this model seems to have a complementary
    effect to the vector passed in. This could prove problematic for divergent series
    at the same airport.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个时序数据通过此模型运行似乎对传入的向量有互补作用。这可能会对同一机场的分歧序列造成问题。
- en: With a vector being required of a similar shape, will this handle airports that
    began offering international flights only after they were a domestic hub?
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要向量具有相似的形状，这将如何处理那些在成为国内枢纽后才开始提供国际航班的机场？
- en: The loss of resolution in seasonality components means that fine detail in the
    predicted trend will be lost if the forecast runs too far in the future.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 季节性成分的分辨率损失意味着，如果预测运行得太远，预测趋势中的细微细节将会丢失。
- en: The algorithm seems sensitive to the `fit()` method’s `maxlags` parameter. This
    will require extensive testing and monitoring if used in production.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该算法似乎对`fit()`方法的`maxlags`参数很敏感。如果在生产中使用，这将需要广泛的测试和监控。
- en: The VAR model is not designed to handle nonstationary data. From the earlier
    tests, we know that these time series are not stationary, based on the Dickey-Fuller
    tests from section 5.2.1 when running code listing 6.10.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VAR模型不是设计用来处理非平稳数据的。从早期的测试中，我们知道这些时序数据不是平稳的，这是基于5.2.1节中运行代码列表6.10时的Dickey-Fuller测试。
- en: Now that this team has finished testing and has a solid understanding of the
    limitations of this model family (namely, the stationarity issue), it’s time to
    look into a few other teams’ progress (don’t worry, we won’t be going through
    all nine models). Perhaps they’re having more luck.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个团队已经完成了测试，并且对这一模型家族的限制（即平稳性问题）有了坚实的理解，是时候看看其他几个团队的进展了（不用担心，我们不会逐一查看所有九个模型）。也许他们运气会更好。
- en: On second thought, let’s just give it one last shot. The team has a day to draw
    conclusions on this model, and a few more hours are still left before the internal
    deadline for each team, after all.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 重新考虑一下，我们再给它最后一次机会。团队有整天的时间来对这个模型得出结论，而且每个团队内部截止日期之前还有几个小时。
- en: Let’s figure out that stationarity issue quickly and see if we can make the
    predictions just a little bit better. To convert the time series to a stationary
    series, we need to normalize the data by applying a natural log to it. Then, to
    remove the nonstationary trend associated with the series, we can use a differencing
    function to get the rate of change as the series moves along the timescale. Listing
    6.11 is the full code for converting to a differenced scale, running the model
    fit, and uncompacting the time series to the appropriate scale.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速解决这个平稳性问题，看看我们是否能将预测做得更好一点。要将时间序列转换为平稳序列，我们需要通过应用自然对数来归一化数据。然后，为了消除与序列相关的非平稳趋势，我们可以使用差分函数来获取序列在时间尺度上移动时的变化率。列表6.11是转换为差分尺度、运行模型拟合和将时间序列压缩到适当尺度的完整代码。
- en: Listing 6.11 Stationarity-adjusted predictions with a VAR model
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.11 使用VAR模型的平稳性调整预测
- en: '[PRE10]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Takes a differencing function of the log of the series to create a stationary
    time series (remember, this is just as we did for the outlier analysis)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对序列的对数取差分函数以创建平稳时间序列（记住，这与我们对异常值分析所做的一样）
- en: ❷ We also have to do the same thing to the other vector position series data
    for international passengers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们还必须对国际乘客的其他向量位置序列数据进行同样的操作。
- en: ❸ Trains the model on the stationary representation of the data
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在数据的平稳表示上训练模型
- en: ❹ Converts the stationary data back to the actual scale of the data by using
    the inverse function of a diff(), a cumulative sum. Then converts the log scale
    of the data back to linear space by using an exponential. This series is set as
    a diff, though, so we have to multiply the values by the starting position value
    (which is the actual value at the start of the test dataset series) in order to
    have the correct scaling.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通过使用diff()的逆函数（累积和）将平稳数据转换回数据的实际尺度。然后通过使用指数将数据的对数尺度转换回线性空间。这个序列被设置为差分，因此我们必须将值乘以起始位置值（这是测试数据集序列开始处的实际值）以获得正确的缩放。
- en: ❺ Compares the test series with the expanded prediction series
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 比较测试序列与扩展预测序列
- en: What’s with all of this copying and pasting?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这么多的复制粘贴是怎么回事？
- en: In all of the examples in this section, we’ve been seeing the same lines of
    code pasted over and over above each of our iterations of model improvement. Including
    all of this in these snippets is not merely to demonstrate a fully built-out code
    block that can execute. Rather, it’s a simulation of what many experimental notebooks
    (or, if writing Python scripts, the copies of such scripts) will end up looking
    like as implementations are tested, individual ideas are iterated upon, and eventually
    a functional script of code will produce results that are measurable.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的所有示例中，我们都看到相同的代码行在每次模型改进的迭代中反复粘贴。将这些代码全部包含在这些片段中，不仅仅是为了展示一个可以执行的完整代码块，而是模拟了许多实验笔记本（或者，如果编写Python脚本，这些脚本的副本）在测试过程中最终会呈现的样子，包括对个别想法的迭代，最终一个功能性的脚本将产生可测量的结果。
- en: This is normal. This is expected in experimentation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正常的。这是实验中预期会发生的事情。
- en: A generally good guideline is to ensure that your experimentation and evaluation
    code is relatively well organized, easy to read and follow, and documented with
    enough comments that can explain anything particularly complex. Whichever solution
    is selected, keeping the code clean enough will facilitate the next phase in development.
    Clean up as you go, delete dead code, and keep a salient structure.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普遍的好做法是确保你的实验和评估代码相对组织良好，易于阅读和跟踪，并且有足够的注释来解释任何特别复杂的内容。无论选择哪种解决方案，保持代码足够整洁将有助于开发下一阶段。边做边清理，删除死代码，并保持显著的结构。
- en: What you certainly don’t want to do is have out-of-order cells, broken variable
    dependency chains, and large amounts of commented-out nonfunctional code in a
    state of pure distilled chaos littered about a notebook. Trying to piece together
    a chaotic experiment is an exercise in frustration and futility, raising the difficulty
    of an already complex process (formulating encapsulation design and architecture
    of production-grade code) to levels that, in many cases, make it easier to just
    rewrite everything from scratch rather than try to salvage what has already been
    developed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定不希望看到的是，笔记本中充满了无序的单元格、损坏的变量依赖链和大量注释掉的无效代码，处于一种纯粹的混乱状态。试图拼凑一个混乱的实验是一种令人沮丧和无用的练习，它将一个已经复杂的过程（制定生产级代码的封装设计和架构）的难度提升到许多情况下，从头开始重写一切比尝试挽救已经开发的内容更容易。
- en: Having fully functional and cell-level encapsulation isn’t necessarily a bad
    thing while in this phase of a project. Provided that the code is cleanly written
    and correctly formatted, this encapsulation can be easier than sifting through
    dozens (or hundreds!) of cells to figure out how to get an experiment to run as
    it did during the rapid prototyping phase. It also makes conversion to a class-based
    or functional programming-based implementation quite a bit easier.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目这个阶段，拥有完全功能和单元格级别的封装并不一定是坏事。只要代码编写整洁且格式正确，这种封装可能比筛选数十个（或数百个！）单元格以找出如何让实验像快速原型阶段那样运行要容易得多。它还使得转换为基于类或基于函数编程的实现变得容易得多。
- en: Figure 6.7 shows the final state that this team finds itself in, after having
    iterated on the model implementation, gone back to read the documentation fully,
    and done a bit of research about how the model works (at an “applications of ML
    level” at least). This visualization results from running the code in listing
    6.11.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7显示了该团队在迭代模型实现、完全阅读文档并研究模型如何工作（至少在“机器学习应用”层面）之后所达到的最终状态。这个可视化结果是通过运行列表6.11中的代码得到的。
- en: '![06-07](../Images/06-07.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![06-07](../Images/06-07.png)'
- en: Figure 6.7 Result of executing listing 6.11
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 执行列表6.11的结果
- en: The first part of the experimentation phase is done. The team has a model that
    shows promise and, more important, understands the application of the model and
    can tune it properly. The visualizations have been recorded for them to show the
    results, and clean example code is written in a notebook that can be referenced
    for later use.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 实验阶段的第一个部分已经完成。团队拥有一个有潜力的模型，更重要的是，他们理解了模型的应用并能够正确调整它。已经记录了可视化结果以展示结果，并在笔记本中编写了干净的示例代码，以便以后参考使用。
- en: The people working on this particular model implementation, provided that they
    have finished their prototyping before the other groups, can be spread to other
    teams to impart some of the wisdom that they have gained from their work. This
    sharing of information will also help speed the progress of all the experiments
    so that a decision can be made on what approach to implement for the actual project
    work.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他团队完成原型设计之前，从事这个特定模型实现的团队成员，可以将他们从工作中获得的智慧传授给其他团队。这种信息共享也将有助于加快所有实验的进度，以便对实际项目工作应采用哪种方法做出决定。
- en: Wow, that was unpleasant . . .
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，那真是不愉快……
- en: It’s important to note how difficult it is for a particular approach to get
    an acceptable result. Whether it requires an abnormally large amount of feature
    engineering for a model to produce something other than garbage, or has extreme
    sensitivity to hyperparameters, or even uses a confusing and poorly designed API,
    the difficulties presented during this phase need to be noted by the team.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，采用特定方法获得可接受结果有多么困难。无论是模型需要异常大量的特征工程才能产生除垃圾之外的东西，还是对超参数极端敏感，或者甚至使用一个令人困惑且设计不佳的API，这个阶段所面临的困难需要由团队记录下来。
- en: As we will review in section 6.2, the challenges faced in implementing the various
    solutions will have a strong bearing on the complexity of developing a production-capable
    solution. In addition, these challenges will directly influence the team’s ability
    to maintain the solution when it is in production.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第6.2节中将要回顾的，实施各种解决方案所面临的挑战将对开发具有生产能力的解决方案的复杂性产生重大影响。此外，这些挑战将直接影响团队在解决方案投入生产后维护该解决方案的能力。
- en: 'It’s good to think about the following topics while going through this phase
    and to take notes during the process so that they can be referenced when evaluating
    the complexity later:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段思考以下主题并记录笔记是好的，这样在以后评估复杂性时可以参考：
- en: Sensitivity to parameter changes.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对参数变化的敏感性。
- en: Quantity of hyperparameters. (This will affect the optimization of models.)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超参数的数量。（这将影响模型的优化。）
- en: Fluency of the API. (Is it standard? Can it be placed into a pipeline?)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API的流畅性。（是否是标准的？能否放入管道中？）
- en: Amount of feature-engineering work that had to be done to get an acceptable
    result.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了得到可接受的结果，必须进行的特征工程工作的数量。
- en: Adaptability to changes in training and test data volumes. (Did the predictions
    fall apart when the split boundary was changed?)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应训练和测试数据量变化的能力。（当分割边界改变时，预测是否崩溃了？）
- en: Rapid testing for ARIMA
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA的快速测试
- en: Let’s pretend for a moment that the ARIMA team members don’t get any tips from
    the VAR team when getting started, aside from the train and test split methodology
    for the series data to perform scoring of their predictions against holdout data.
    They’re beginning the model research and testing phases, using the same function
    tools that the other teams are using for data preprocessing and formatting of
    the date index, but aside from that, they’re in greenfield territory.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时假设ARIMA团队成员在开始时除了系列数据的训练和测试分割方法以对预测进行评分之外，没有从VAR团队那里得到任何提示。他们正在开始模型研究和测试阶段，使用与其他团队用于数据预处理和日期索引格式化的相同功能工具，但除此之外，他们处于绿色地带。
- en: The team realizes that one of its first big obstacles is in the required settings
    for the ARIMA model, specifically the `p` (autoregressive parameters), `d` (differences),
    and `q` (moving average) variables that need to be assigned during model instantiation.
    Reading through the documentation, the team members realize that the pre-experimentation
    work that everyone contributed to already provides a means of finding a place
    to start for these values. By using the stationarity test visualization function
    built in chapter 5’s listing 5.14, we can get the significance values for the
    autoregressive (AR) parameters.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 团队意识到他们面临的一个主要障碍是ARIMA模型所需的设置，特别是模型实例化时需要分配的`p`（自回归参数）、`d`（差分）和`q`（移动平均）变量。阅读文档后，团队成员意识到大家已经贡献的前期实验工作已经提供了一种找到这些值起始点的方法。通过使用第5章列表5.14中构建的平稳性测试可视化函数，我们可以获得自回归（AR）参数的显著性值。
- en: To get the appropriate autocorrelation and partial autocorrelation measurements,
    we’re going to have to perform the same difference function on the logarithm of
    the time series as the VAR team did in its final model for testing (the VAR team
    members were being especially nice and shared their findings) so that we can remove
    as much of the noise as we can. Figure 6.8 shows the resulting trend plots.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得适当的自相关和偏自相关测量值，我们将在时间序列的对数上执行与VAR团队在其最终测试模型中执行相同的差分函数（VAR团队成员特别友好，并分享了他们的发现），以便我们可以消除尽可能多的噪声。图6.8显示了结果趋势图。
- en: '![06-08](../Images/06-08.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![06-08](../Images/06-08.png)'
- en: Figure 6.8 Executing the stationarity tests for the lag-diff of the JFK domestic
    passenger series
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 执行JFK国内乘客序列的滞后差分平稳性测试
- en: Much like the VAR team before them, the ARIMA team members spend a few iterations
    trying different parameters to get results that aren’t tragically poor. We won’t
    cover all those iterations (this isn’t a book on time-series modeling, after all).
    Instead, let’s look at the final result that they came up with.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 与他们之前的VAR团队一样，ARIMA团队成员尝试了几个不同的参数来获得不是悲惨的结果。我们不会涵盖所有这些迭代（毕竟这不是一本关于时间序列建模的书）。相反，让我们看看他们最终得出的结果。
- en: Listing 6.12 Final state of the ARIMA experimentation
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.12 ARIMA实验的最终状态
- en: '[PRE11]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ The ordering parameters of (p,d,q). The p (period) value was derived from
    the autocorrelation and partial autocorrelation analyses as a factor of the significant
    values calculated.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ (p,d,q)的阶数参数。p（周期）值是从自相关和偏自相关分析中作为显著值的计算因子推导出来的。
- en: Of particular note is the absence of the stationarity-forcing log and diff actions
    being taken on the series. While these stationarity adjustments were tested, the
    results were significantly worse than the forecasting that was done on the raw
    data. (We won’t be looking at the code, as it is nearly identical to the approaches
    in listing 6.11.)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 特别值得注意的是，在序列上没有采取强制平稳性的对数和差分操作。虽然对这些平稳性调整进行了测试，但结果明显比在原始数据上进行的预测要差。（我们不会查看代码，因为它几乎与列表
    6.11 中的方法相同。）
- en: Figure 6.9 shows the validation plots and scores for a few of their tests; the
    log diff attempt is on the left (obviously inferior), and the unmodified series
    being used for training is on the right. While the right grouping of charts is
    by no means ideal for the project solution as is, it certainly gives the broader
    team an idea of the nuances and capabilities of an ARIMA model for forecasting
    purposes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 显示了他们一些测试的验证图和分数；对数差分的尝试位于左侧（显然较差），用于训练的未修改序列位于右侧。虽然右侧的图表组合在项目解决方案中并不理想，但它确实为更广泛的团队提供了一个关于
    ARIMA 模型在预测目的上的细微差别和能力的主意。
- en: '![06-09](../Images/06-09.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![06-09](../Images/06-09.png)'
- en: Figure 6.9 Comparison of enforcing stationarity (left) and using the raw data
    (right) for ARIMA modeling
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 强制平稳性（左侧）和使用原始数据（右侧）进行 ARIMA 模型比较
- en: These results from their testing show promise in both approaches (raw data and
    stationarity-enforced manipulations), illustrating that an opportunity exists
    for better tuning to make this algorithm’s implementation better. Armed with this
    knowledge and the results, this team can be ready to present its findings to the
    larger team in an adjudication without spending more precious time on attempting
    to improve the results at this stage.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 他们测试的结果表明，在两种方法（原始数据和强制平稳性操作）中都有希望，说明存在更好的调整机会，以使该算法的实现更加完善。凭借这些知识和结果，这个团队可以准备好向更大的团队展示其发现，而无需在此阶段花费更多宝贵的时间来尝试改进结果。
- en: Rapid testing of the Holt-Winters exponential smoothing algorithm
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 快速测试 Holt-Winters 指数平滑算法
- en: We’re going to be much briefer with this one (sorry, fans of time-series modeling).
    For this model evaluation, the team members wanted to wrap their implementation
    of the Holt-Winters exponential smoothing model in a function so that they didn’t
    have to keep copying the same code throughout their notebook cells.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对此部分进行更简短的介绍（抱歉，时间序列建模的粉丝）。对于这个模型评估，团队成员希望将他们的 Holt-Winters 指数平滑模型实现包装在一个函数中，这样他们就不必在整个笔记本单元中重复相同的代码。
- en: The reasons that this approach is the preferred way to write even experimental
    code will become more obvious in the next chapter. For now, let’s just say that
    this team has a few more senior DS members. The next listing shows what they eventually
    came up with.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这种方法是编写甚至实验代码的首选方式，将在下一章中变得更加明显。现在，我们只需说，这个团队有几位资深的 DS 成员。下一个列表显示了他们最终得出的结果。
- en: Listing 6.13 Holt-Winters exponential smoothing function and usage
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.13 Holt-Winters 指数平滑函数及其用法
- en: '[PRE12]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ In development, if this model is chosen, all of these settings (as well as
    the others available to this fit method) will be parameterized and subject to
    auto-optimization with a tool like Hyperopt.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在开发过程中，如果选择此模型，所有这些设置（以及此拟合方法可用的其他设置）都将参数化，并使用类似 Hyperopt 的工具进行自动优化。
- en: ❷ Slightly different from the other models tested, this model requires at least
    the last element of the training data to be present for the range of predictions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 与其他测试的模型略有不同，此模型要求预测范围至少包含训练数据中的最后一个元素。
- en: ❸ Removes the forecast made on the last element of the training data series
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从训练数据序列的最后一个元素中移除所做的预测
- en: ❹ Uses a longer periodicity for the autoregressive element (seasonal_periods)
    because of the nature of the time series of that group. In development, if this
    model is chosen, these values will be automatically tuned through a grid search
    or more elegant auto-optimization algorithm.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 由于该组时间序列的性质，自动回归元素（seasonal_periods）使用更长的周期。在开发过程中，如果选择此模型，这些值将通过网格搜索或更优雅的自动优化算法自动调整。
- en: In the process of developing this, this subteam discovers that the API for Holt-Winters
    exponential smoothing changed fairly dramatically between versions 0.11 and 0.12
    (0.12.0 was the most recent documentation on the API doc website, and as such,
    shows up by default). As a result, team members spend quite a bit of time trying
    to figure out why the settings that they try to apply are constantly failing with
    exceptions that are the result of renamed or modified parameters.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，这个子团队发现Holt-Winters指数平滑的API在版本0.11和0.12之间发生了相当大的变化（0.12.0是API文档网站上的最新文档，因此默认显示）。因此，团队成员花费了大量时间试图弄清楚为什么他们尝试应用的设置总是因为重命名或修改的参数而抛出异常而失败。
- en: Eventually, they realize that they need to check the version of statsmodels
    that was installed to get the correct documentation. (For further reading on versioning
    in Python, see the following sidebar.) Figure 6.10 shows the results of this group’s
    work, reflecting the most promising metrics yet from any of the groups.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，他们意识到他们需要检查安装的statsmodels版本以获取正确的文档。（有关Python版本管理的进一步阅读，请参阅以下侧边栏。）图6.10显示了该团队的工作结果，反映了迄今为止任何团队中最有希望的指标。
- en: How to quickly figure out the version of a module without a huge fuss
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如何快速找出模块的版本而无需大费周章
- en: The package manager that we’re using for these examples, Anaconda, has quite
    a few modules available. In addition to the base Python itself, hundreds of incredibly
    useful tools have been included for ML work. Each has been meticulously collated
    such that the respective dependencies are all aligned to work together.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这些示例中使用的包管理器Anaconda提供了相当多的模块。除了基本的Python本身之外，还包括了数百个对机器学习工作非常有用的工具。每个模块都经过精心整理，以确保相应的依赖项都能协同工作。
- en: Because of this, some of the modules may not be as recent as the “stable release”
    that the API documentation might have (particularly for projects that are under
    active development and do frequent releases). As a result, the docs may not reflect
    the version of the module that you are interacting with.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，一些模块可能不像API文档中提到的“稳定版本”那样新（尤其是对于正在积极开发和频繁发布的项目）。因此，文档可能不会反映你正在交互的模块版本。
- en: This isn’t just a Python problem either. Any large open source ecosystem will
    have this issue. You’ll encounter this in Java, Scala, R, TensorFlow, Keras, and
    more. In Python, however, we can relatively easily get the version information
    from within the Python REPL (or a notebook cell).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是一个Python问题。任何大型开源生态系统都会遇到这个问题。你会在Java、Scala、R、TensorFlow、Keras等语言中遇到这个问题。然而，在Python中，我们可以相对容易地从Python
    REPL（或笔记本单元格）中获取版本信息。
- en: For the purposes of our examples, let’s check the versioning information for
    statsmodels. To acquire it, you simply have to figure out the method name (usually
    a pseudo-private method) and call it. You can find what these method names might
    be called (typically, a variant of `__VERSION__`, `__version`, `_version`, or
    the like) by importing the base package, performing a `dir(<package``name>)`,
    and seeing the naming of it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的示例，让我们检查statsmodels的版本信息。要获取它，你只需找出方法名（通常是伪私有方法）并调用它。你可以通过导入基本包，执行`dir(<packagename>)`，并查看其命名来找到这些方法名可能被调用（通常是`__VERSION__`、`__version`、`_version`等变体的一个）。
- en: 'For statsmodels, the method name is `_version`. To print the version information,
    we simply type the following in a cell, and it will print to stdout:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于statsmodels，方法名是`_version`。要打印版本信息，我们只需在单元格中输入以下内容，它就会打印到标准输出：
- en: '[PRE13]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At the time of this writing, the latest stable version of statsmodels is 0.12.0,
    with some significant changes to the APIs that we’ve been using. Luckily, each
    release of an open source software package typically retains older versions of
    its documentation on its web page. Just be sure that the correct version is selected
    when you’re looking at the docs to make sure that you’re not wasting time implementing
    something incompatible with the installed version of the package that you’re running
    against.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，statsmodels的最新稳定版本是0.12.0，API发生了我们一直在使用的重大变化。幸运的是，开源软件包的每个版本通常都会在其网页上保留其旧版本的文档。只是确保你在查看文档时选择了正确的版本，以确保你不会浪费时间实现与你要运行的包的安装版本不兼容的东西。
- en: The version that we’re using in this build of Anaconda, though, is 0.11.1\.
    We need to make sure that we’re looking at that version of the API docs to see
    the options with each class that we’re importing for modeling.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在Anaconda构建中使用的版本是0.11.1。我们需要确保我们正在查看该版本的API文档，以查看我们为建模导入的每个类别的选项。
- en: '![06-10](../Images/06-10.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![06-10](../Images/06-10.png)'
- en: Figure 6.10 Results of the Holt-Winters exponential smoothing tests from listing
    6.13\. We have a clear contender!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10展示了列表6.13中的Holt-Winters指数平滑测试结果。我们有一个明确的竞争者！
- en: After completing their day-long mini hackathon, the teams collate their results
    into simple and easy-to-digest reports on the efficacy of the algorithms’ abilities
    to forecast this data. Then the teams meet for a bit of a show-and-tell.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成了一天的迷你黑客松后，团队将他们的结果整理成关于算法预测此数据能力的简单且易于消化的报告。然后，团队进行了一段时间的展示和说明。
- en: Applying the preparation steps defined throughout section 6.1, we can efficiently,
    reliably, and objectively compare different approaches. The standardization means
    that the team will have a true baseline comparison to adjudicate each approach,
    while the time-boxed nature of the evaluations ensures that no team spends too
    much time building out an MVP solution (wasting both time and computing resources)
    without knowing whether the approach that they’re building is actually the best
    one.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 应用第6.1节中定义的准备工作步骤，我们可以高效、可靠和客观地比较不同的方法。标准化意味着团队将有一个真正的基线比较来评判每个方法，而评估的时间限制性质确保没有任何团队在没有知道他们正在构建的方法是否确实是最好的方法之前，花费太多时间构建MVP解决方案（浪费时间和计算资源）。
- en: We’ve reduced the chances of picking a poor implementation to solve the business
    need and have done so quickly. Even though the business unit that is asking for
    an answer to their problem is blind to these internal processes, the company will
    have a better product by the end because of this methodical approach, as well
    as one that meets the project’s deadline.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经减少了选择一个较差的实现来解决业务需求的机会，并且做得很快。即使请求解决问题的业务部门对这些内部流程一无所知，但由于这种方法论的方法，公司最终将拥有一个更好的产品，并且能够满足项目的截止日期。
- en: 6.2 Whittling down the possibilities
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 精简可能性
- en: How does the team as a whole decide which direction to go in? Recall that in
    chapters 3 and 4, we discussed that after experimentation evaluation is complete,
    it’s time to involve the business stakeholders. We’ll need to get their input,
    subjective as it may be, to ensure that they’re going to feel comfortable with
    the approach and included in the direction choice, and that their expertise of
    deep subject area knowledge is weighed heavily in the decision.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 团队作为一个整体如何决定前进的方向？回想一下，在第3章和第4章中，我们讨论了在实验评估完成后，是时候涉及业务利益相关者了。我们需要获取他们的意见，尽管这些意见可能是主观的，但为了确保他们会感到对这种方法感到舒适，并且被包括在方向选择中，以及他们的专业知识在深度主题领域知识中在决策中占有重要地位。
- en: 'To ensure a thorough adjudication of the tested potential implementations for
    the project, the broader team needs to look at each approach that has been tested
    and make a judgment that is based on the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保对项目测试的潜在实施方法进行彻底的审查，更广泛的团队需要查看每个已测试的方法，并基于以下标准做出判断：
- en: Maximizing the predictive power of the approach
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大化方法的可预测能力
- en: Minimizing the complexity of the solution as much as is practicable to still
    solve the problem
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在尽可能解决问题的同时，最大限度地减少解决方案的复杂性
- en: Evaluating and estimating the difficulty in developing the solution for purposes
    of realistic scoping for delivery dates
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估和估算开发解决方案的难度，以便为交付日期进行现实范围的规划
- en: Estimating the total cost of ownership for (re)training and inference
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估算（再）培训和推理的总拥有成本
- en: Evaluating the extensibility of the solution
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估解决方案的可扩展性
- en: By focusing on each of these aspects during the evaluation phase, the team can
    dramatically reduce risk in the project, collectively deciding on an MVP approach
    that will reduce the vast majority of reasons ML projects fail, end up abandoned,
    or get cancelled. Figure 6.11 shows each of these criteria and how they fit into
    the overall prototyping phase of ML project work.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在评估阶段关注这些方面的每一个，团队可以显著降低项目风险，集体决定一个MVP方法，这将减少大多数机器学习项目失败、最终被废弃或取消的原因。图6.11显示了每个这些标准以及它们如何适应机器学习项目工作的整体原型阶段。
- en: '![06-11](../Images/06-11.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![06-11](../Images/06-11.png)'
- en: Figure 6.11 Elements of the evaluation phase to guide the path for building
    the MVP
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 评估阶段元素，以指导构建MVP的路径
- en: Now that you have a solid idea of *what* a team should be looking at when evaluating
    an approach, let’s look at *how* this team will arrive at a decision on which
    approach to implement.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对团队在评估方法时应关注的内容有了稳固的认识，让我们看看这个团队将如何做出决定，选择要实施的方法。
- en: 6.2.1 Evaluating prototypes properly
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 正确评估原型
- en: It’s at this point that most ML teams can let themselves be led astray, specifically
    in the sense of presenting only the accuracy that a particular solution brings.
    We’ve discussed previously in section 6.1.1 (and listing 6.7) the importance of
    creating compelling visualizations to illustrate in an easy-to-consume format
    for both the ML teams and the business unit, but that’s only part of the story
    for deciding on one ML approach versus another. The predictive power of an algorithm
    is certainly incredibly important, but it is merely one among many other important
    considerations to weigh. As an example, let’s continue with these three implementations
    (and the others that we didn’t show for brevity’s sake) and collect data about
    them so that the full picture of building out any of these solutions can be explored.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，大多数ML团队可能会让自己误入歧途，特别是在只展示特定解决方案带来的准确性的意义上。我们之前在6.1.1节（以及列表6.7）中讨论了创建引人入胜的可视化的重要性，以易于消费的格式向ML团队和业务部门展示，但这只是决定采用一种ML方法而不是另一种方法的故事的一部分。算法的预测能力当然非常重要，但它只是众多重要考虑因素中的一个。例如，让我们继续讨论这三个实现（以及为了简洁我们没有展示的其他实现），并收集它们的数据，以便可以探索构建任何这些解决方案的完整图景。
- en: The team meets, shows code to one another, reviews the different test runs with
    the various parameters that were tested, and assembles an agreed-upon comparison
    of relative difficulty. For some models (such as the VAR model, elastic net regressor,
    lasso regressor, and RNN), the ML team decides to not even include these results
    in the analysis because of the overwhelmingly poor results generated in forecasting.
    Showing abject failures to the business serves no useful purpose and simply makes
    an already intellectually taxing discussion longer and more onerous. If a full
    disclosure about the amount of work involved to arrive at candidates is in order,
    simply state, “We tried 15 other things, but they’re really not suited for this
    data” and move on.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 团队会面，互相展示代码，回顾使用不同参数进行的各种测试运行，并汇总一个关于相对难度的共识比较。对于某些模型（例如VAR模型、弹性网络回归器、lasso回归器和RNN），ML团队决定甚至不将这些结果包含在分析中，因为这些模型在预测中产生了压倒性的糟糕结果。向业务部门展示彻底的失败没有任何实际作用，只会让一个已经智力上负担沉重的讨论变得更长、更繁重。如果需要对达到候选方案所需的工作量进行完全披露，只需简单地说，“我们尝试了15种其他方法，但它们真的不适合这些数据”，然后继续前进。
- en: After deliberating over the objective merits of each approach, the internal
    DS team arrives at an evaluation matrix similar to figure 6.12\. While relatively
    generic, the evaluation elements in this matrix can be applied to most project
    implementations. In the past, I’ve used selection criteria that are far more detailed
    and customized to the type of problem the project is aiming to solve, but a generic
    one is a good place to start.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在权衡每种方法的客观优点后，内部DS团队得出一个类似于图6.12的评估矩阵。虽然相对通用，但这个矩阵中的评估元素可以应用于大多数项目实施。在过去，我使用过更加详细和针对项目旨在解决的问题类型定制的选择标准，但一个通用的标准是一个好的起点。
- en: '![06-12](../Images/06-12.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![06-12](../Images/06-12.png)'
- en: Figure 6.12 The decision matrix from the results of the experimentation prototyping
    phase
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 实验原型阶段的结果决策矩阵
- en: As you can see, it’s incredibly important to holistically evaluate an approach
    on elements other than its predictive power. After all, the chosen solution will
    need to be developed for production, monitored, modified, and maintained for (hopefully)
    a long time. Failing to take the maintainability factors into account can land
    a team with an incredibly powerful solution that is nearly impossible to keep
    running.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，全面评估一个方法除了其预测能力之外的元素至关重要。毕竟，所选的解决方案将需要开发、监控、修改和（希望）长期维护。未能考虑可维护性因素可能导致团队获得一个极其强大的解决方案，但几乎不可能保持其运行。
- en: It’s worthwhile, at the stage after prototyping is done, to think deeply about
    what it’s going to be like to build this solution, as well as what total life-cycle
    ownership will be like. Is anyone going to want to improve upon it? Will they
    be able to? Is this something that will be relatively straightforward to troubleshoot
    should the predictions start to become poor? Can we explain why the model made
    the decisions that it did? Can we afford to run it?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在原型制作完成后，深入思考构建这个解决方案将是什么样的，以及整个生命周期所有权将是什么样的，这是值得的。有人会想要改进它吗？他们能够做到吗？如果预测开始变得不准确，这将是一件相对简单的问题吗？我们能解释模型为什么会做出这样的决策吗？我们能承担运行它的成本吗？
- en: If you’re unsure of any of these aspects of the proposed group of solutions,
    it’s best to either discuss these topics among the team until consensus is arrived
    at, or, at the very least, don’t propose it as a potential solution to the business.
    The absolutely last thing that you want from the conclusion of a project is to
    realize that you’ve built an abomination that you wish would just silently fade
    away into nothingness, never to return and rear its ugly head, pervading your
    waking and sleepless nights like a haunting fever dream. Choose wisely at this
    point, because once you commit, it’s going to be expensive to pivot to another
    approach.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些建议的解决方案中的任何方面感到不确定，最好是团队内部讨论这些话题，直到达成共识，或者至少，不要将其作为潜在解决方案提交给业务。你绝对不希望项目结束时意识到你建造了一个令人厌恶的东西，你希望它能够无声无息地消失，永远不再回来，不再露出丑陋的脑袋，像一种令人不安的梦魇一样渗透你的清醒和失眠之夜。在这个时候要明智选择，因为一旦你做出承诺，转向另一种方法将会非常昂贵。
- en: 6.2.2 Making a call on the direction to go in
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 确定前进方向
- en: Now that the data about the relative strengths and weaknesses of each approach
    has been assembled and the modeling approach has been decided upon, the real fun
    begins. Since everyone came to the conclusion that Holt-Winters exponential smoothing
    seems like the safest option for building these forecasts, we can start talking
    about architecture and code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经收集了关于每种方法的相对优势和劣势的数据，并且已经决定了建模方法，真正的乐趣开始了。由于每个人都得出结论，Holt-Winters指数平滑似乎是构建这些预测的最安全选项，我们可以开始讨论架构和代码。
- en: Before any code is written, though, the team needs to have another planning
    session. This is the time for the *hard questions*. The most important thing to
    keep in mind about these is that *they should be answered before committing to
    a development direction*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，团队需要进行另一次规划会议。这是提出*困难问题*的时候。关于这些问题的最重要的注意事项是，*它们应该在承诺开发方向之前得到回答*。
- en: 'Question 1: How often does this need to run?'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 问题1：这个需求需要运行多频繁？
- en: “How often does this need to run?” is quite possibly the most important question,
    considering the type of model that everyone selected. Since this is an autoregressive
    model, if the model is not retrained at a high frequency (probably each inference
    run), the predictions will not adapt to new factual data coming in. The model
    looks at only a univariate series to make its forecasts, so having training that’s
    as up-to-date as possible can ensure that the forecasts adapt to the changing
    trend accurately.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: “这个需求需要运行多频繁？”可能是最重要的问题，考虑到每个人都选定的模型类型。由于这是一个自回归模型，如果模型不是以高频率（可能每次推理运行）重新训练，预测将不会适应新的事实数据。模型只看单一变量的序列来做出预测，所以尽可能最新的训练可以确保预测能够准确适应变化趋势。
- en: TIP Don’t ever ask the business or any frontend developer, “So, how often do
    you need the predictions?” They will usually spout off some ridiculously short
    time period. Instead, ask, “At what point will the predictions become irrelevant?”
    and work back from there. The difference between a 4-hour SLA and a 10-millisecond
    SLA is several hundred thousand dollars of infrastructure and about six months
    of work.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 永远不要问业务或任何前端开发者，“那么，你们多久需要一次预测？”他们通常会给出一些荒谬的短时间。相反，问，“预测何时会变得无关紧要？”然后从那里开始工作。4小时的服务水平协议（SLA）和10毫秒的SLA之间的差异是几十万美元的基础设施和大约六个月的工作。
- en: The business is going to need to provide a minimum and maximum service-level
    agreement (SLA) for the “freshness” of these predictions. Give rough estimates
    of how long it will take to develop a solution that supports these SLA requirements,
    as well as how expensive the solution will be to run in production.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 业务将需要为这些预测的“freshness”提供最小和最大服务级别协议（SLA）。给出开发支持这些SLA要求的解决方案所需时间的粗略估计，以及该解决方案在生产中运行的成本。
- en: 'Question 2: Where is the data for this right now?'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 问题2：目前这些数据在哪里？
- en: Since the data is provided by an external data feed, we need to be conscientious
    about how to create a stable and reliable ETL ingestion for both the training
    data and the imputation (prediction) data. The freshness of this data needs to
    meet the requirements of question 1’s answer (the SLA being requested).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据由外部数据源提供，我们需要认真考虑如何为训练数据和预测数据创建一个稳定可靠的ETL摄取。数据的 freshness 需要满足问题1答案的要求（请求的SLA）。
- en: We need to bring in the DE team members to ensure that they are prioritizing
    the acquisition of this feed long before we’re thinking of going into production
    for this project. If they are unable to commit to an acceptable date, we will
    have to write this ETL and populate the source tables with this data ourselves,
    increasing our project scope, cost, and risk.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将DE团队成员纳入其中，以确保他们在我们考虑将此项目投入生产之前，就已经优先考虑获取此数据源。如果他们无法承诺一个可接受的时间，我们就必须自己编写这个ETL，并手动将数据填充到源表中，这将增加我们的项目范围、成本和风险。
- en: 'Question 3: Where are the forecasts going to be stored?'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 问题3：预测将被存储在哪里？
- en: Are the users going to be issuing business intelligence (BI) style queries to
    the predictions, fueling analytics visualizations in an ad hoc manner? Then we
    can probably write the data to an RDBMS source that we have in-house.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 用户是否会向预测发出类似商业智能（BI）风格的查询，以临时方式推动分析可视化？然后我们可以将数据写入我们内部拥有的关系数据库管理系统（RDBMS）源。
- en: Is this going to be queried frequently by hundreds (or thousands) of users?
    Is the data going to be made available as a service for a web frontend? If so,
    we’re going to have to think about storing the predictions as sorted arrays in
    a NoSQL engine or perhaps an in-memory store such as Redis. We’ll need to build
    a REST API in front of this data if we’re going to be serving to a frontend service,
    which will increase the scope of work for this project by a few sprints.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被数百（或数千）个用户频繁查询吗？数据是否将作为服务提供给Web前端？如果是这样，我们必须考虑将预测存储为排序数组在NoSQL引擎中或可能是一个内存存储，如Redis。如果我们打算为前端服务提供服务，我们还需要在数据前面构建一个REST
    API，这将增加这个项目几个冲刺的工作范围。
- en: 'Question 4: How are we setting up our code base?'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 问题4：我们如何设置我们的代码库？
- en: Is this going to be a new project code base, or are we going to let this code
    live with other ML projects in a common repo? Are we pursuing a full object-oriented
    (OO) approach with the modular design, or will we be attempting to do functional
    programming (FP)?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个新的项目代码库，还是我们将让这段代码与其他机器学习项目共同存在于一个公共仓库中？我们是否追求使用模块化设计的完全面向对象（OO）方法，还是我们将尝试进行函数式编程（FP）？
- en: What is our deployment strategy for future improvements? Are we going to use
    a continuous integration/continuous deployment (CI/CD) system, GitFlow releases,
    or standard Git? Where are our metrics associated with each run going to live?
    Where are we going to log our parameters, auto-tuned hyperparameters, and visualizations
    for reference?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对于未来的改进部署策略是什么？我们将使用持续集成/持续部署（CI/CD）系统、GitFlow发布，还是标准的Git？每个运行的指标将存储在哪里？我们将把参数、自动调整的超参数和可视化日志记录在哪里以供参考？
- en: It’s not *absolutely critical* to have answers to all of those questions regarding
    development immediately at this point, but the team lead and architect should
    be carefully considering all of these aspects of the project development *very
    soon* and should be making a well-considered set of decisions regarding these
    elements (we’ll cover this in the next chapter at length).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个阶段，立即对有关开发的所有这些问题都有答案并不是绝对必要的，但团队领导和架构师应该仔细考虑项目开发的各个方面，并且应该尽快做出关于这些元素的深思熟虑的决策（我们将在下一章详细讨论）。 '
- en: 'Question 5: Where is this going to run for training?'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 问题5：这个模型将在哪里进行训练？
- en: We ~~probably~~ *really shouldn’t run this on our laptops*. Seriously. Don’t
    do it.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们**绝对**不应该在我们的笔记本电脑上运行这个。真的。别这么做。
- en: With the number of models involved in this project, we’ll be exploring options
    for this in the next chapter and discussing the pros and cons of each.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本项目涉及到的模型数量，我们将在下一章中探讨这方面的选项，并讨论每个选项的优缺点。
- en: 'Question 6: Where is the inference going to run?'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 6：推理将在哪里运行？
- en: We ~~really~~ *definitely shouldn’t be running this on our laptops*. Cloud service
    provider infrastructure, on-premises data centers, or ephemeral serverless containers
    running on either the cloud or on-prem are really the only option here.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们**绝对**不应该在我们的笔记本电脑上运行这个。云服务提供商的基础设施、本地数据中心，或者在云或本地运行的临时无服务器容器，这里真的是唯一的选择。
- en: 'Question 7: How are we going to get the predictions to the end users?'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 7：我们如何将预测结果传递给最终用户？
- en: As stated in the answer to question 3, getting the predictions to the end users
    is by far the most overlooked and yet most critical part of any ML project that
    strives to be actually useful. Do you need to serve the predictions on a web page?
    Now would be a good time to have a conversation with some frontend and/or full-stack
    developers.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如问题 3 的答案所述，将预测结果传递给最终用户是任何力求真正有用的机器学习项目中最被忽视但最关键的部分。您是否需要在网页上提供预测结果？现在是与一些前端和/或全栈开发者进行交谈的好时机。
- en: Does it need to be part of a BI report? The DE and BI engineering teams should
    be consulted now.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 是否需要将其作为 BI 报告的一部分？现在应该咨询 DE 和 BI 工程团队。
- en: Does it need to be stored for ad hoc SQL queries by analysts? If that’s the
    case, you’ve got this. That’s trivial.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 是否需要存储以供分析师进行即兴的 SQL 查询？如果是这样，您已经有了这个。这很简单。
- en: 'Question 8: How much of our existing code can be used for this project?'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 8：我们现有的代码中有多少可以用于此项目？
- en: If you have utility packages already developed that can make your life easier,
    review them. Do they have existing tech debt that you can fix and make better
    while working on this project? If yes, then now’s the time to fix it. If you have
    existing code and believe it has no tech debt, you should be more honest with
    yourself.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经开发了可以简化您生活的实用程序包，请检查它们。它们是否有现有的技术债务，您可以在进行此项目时修复并改进？如果是的话，那么现在是修复它的时候了。如果您有现有的代码并且认为它没有技术债务，您应该对自己更诚实一些。
- en: If you don’t have an existing utility framework built up or are just getting
    started with ML engineering practices for the first time, worry not! We’ll cover
    what this sort of tooling looks like in many of the subsequent chapters.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有建立现有的实用框架，或者您是第一次开始使用机器学习工程实践，请不要担心！我们将在接下来的许多章节中介绍这种工具的外观。
- en: 'Question 9: What is our development cadence, and how are we going to work on
    features?'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 9：我们的开发节奏是什么，我们将如何处理功能？
- en: Are you dealing with a project manager? Take some time now to explain just how
    much code you’re going to be throwing away during this development process. Let
    the project manager know that entire stories and epics are going to be dead code,
    erased from the face of the earth, never to be seen again. Explain to them the
    chaos of ML project work so that they can get through those first four stages
    of grief and learn to accept it before the project starts. You don’t need to give
    them a hug or anything, but break the news to them gently, for it will shatter
    their understanding of the nature of reality.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否在与项目经理打交道？现在花点时间解释一下在开发过程中您将要丢弃多少代码。让项目经理知道整个故事和史诗级的内容将成为死代码，永远从地球上消失，不再被看到。向他们解释机器学习项目工作的混乱，以便他们能够度过那些最初的四个悲伤阶段，并在项目开始之前学会接受它。您不需要给他们一个拥抱或任何东西，但请温柔地告诉他们这个消息，因为它将粉碎他们对现实本质的理解。
- en: ML feature work is a unique beast. It is entirely true that huge swaths of code
    will be developed, only to be completely refactored (or thrown away!) when a particular
    approach is found to be untenable. This is a stark contrast to “pure” software
    development, in which a particular functionality is rationally defined and can
    be fairly accurately scoped. Unless part of your project is the design and development
    of an entirely new algorithm (it probably shouldn’t be, for your information,
    no matter how much one of your team members is trying to convince you that it
    needs to be), there is no guarantee of a particular functionality coming out of
    your code base.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习特征工作是一种独特的生物。确实，将开发大量代码，但一旦发现某种方法不可行，这些代码将被完全重构（或丢弃！）这是与“纯”软件开发截然不同，在“纯”软件开发中，特定的功能是理性定义的，并且可以相当准确地界定范围。除非你的项目的一部分是设计和发展一个全新的算法（据我所知，这不应该发生，无论你的团队成员多么试图说服你需要这样做），否则无法保证代码库中会实现特定的功能。
- en: Therefore, the pure Agile approach is usually not an effective way of developing
    code for ML simply because of the nature of changes that might need to be made
    (swapping out a model, for instance, could incur a large, wholesale refactoring
    that could consume two entire sprints). To help with the different nature of Agile
    as applied to ML development, it’s critical to organize your stories, your scrums,
    and your commits accordingly.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，纯敏捷方法通常不是开发机器学习代码的有效方式，仅仅是因为可能需要做出的变化（例如，更换模型可能会引起大量、全面的重构，这可能会消耗两个整个冲刺）。为了帮助处理应用于机器学习开发的敏捷的不同性质，相应地组织你的故事、你的scrum和你的提交是至关重要的。
- en: 6.2.3 So . . . what’s next?
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 那么，接下来是什么？
- en: What’s next is actually building the MVP. It’s working on the demonstratable
    solution that has fine-tuned accuracy for the model, logged testing results, and
    a presentation to the business showing that the problem can be solved. What’s
    next is what puts the *engineering* in *ML engineering*.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步实际上是构建最小可行产品（MVP）。这是在开发一个可演示的解决方案，该解决方案对模型进行了精确调整，记录了测试结果，并向业务展示问题可以解决。下一步是让*工程*在*机器学习工程*中发挥作用。
- en: We’ll delve heavily into these topics in the next chapter, continuing with this
    peanut-inventory-optimization problem, watching it go from a hardcoded prototype
    with marginal tuning to the beginnings of a code base filled with functions, the
    support for automatically tuned models, and full logging for each model’s tuning
    evaluations into MLflow. We’ll also be moving from the world of single-threaded
    sequential Python into the world of concurrent modeling capabilities in the distributed
    system of Apache Spark.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章深入探讨这些主题，继续以这个花生库存优化问题为例，观察它从硬编码的原型及其边缘调整到充满函数、自动调整模型的支持以及每个模型调整评估的完整日志记录到MLflow的代码库的初期。我们还将从单线程顺序Python的世界过渡到Apache
    Spark分布式系统中的并发建模能力的世界。
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A time-boxed and holistic approach to testing APIs for potential solutions to
    a problem will help ensure that an implementation direction for a project is reached
    quickly, evaluated thoroughly, and meets the needs of the problem in the shortest
    possible time. Predictive power is not the only criteria that matters.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用时间限制和整体方法测试潜在解决问题的API，将有助于确保项目快速达到实施方向，彻底评估，并在尽可能短的时间内满足问题的需求。预测能力并不是唯一重要的标准。
- en: Reviewing all aspects of candidate methods for solving a problem encourages
    evaluating more than predictive power. From maintainability, to implementation
    complexity, to cost, many factors should be considered when selecting a solution
    to pursue to solve a problem.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查解决一个问题的候选方法的所有方面，鼓励评估不仅仅是预测能力。从可维护性、实现复杂性到成本，在选择解决方案以解决问题时，应考虑许多因素。
