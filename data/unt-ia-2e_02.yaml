- en: 1 Getting to know Unity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 了解Unity
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What makes Unity a great choice
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么Unity是一个很好的选择
- en: Operating the Unity editor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作Unity编辑器
- en: Programming in Unity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中进行编程
- en: If you’re anything like me, you’ve had developing a video game on your mind
    for a long time. But it’s a big jump from playing games to making them. Numerous
    game development tools have appeared over the years, and we’re going to discuss
    one of the most recent and most powerful of these tools.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和我一样，你很久以前就有开发视频游戏的念头。但从玩游戏到制作游戏是一个很大的跳跃。多年来出现了许多游戏开发工具，我们将讨论其中最新且最强大的工具之一。
- en: '*Unity* is a professional-quality game engine used to create video games targeting
    a variety of platforms. It’s not only a professional development tool used daily
    by thousands of seasoned game developers, but also one of the most accessible
    modern tools for novice game developers. Until recently, a newcomer to game development
    would face lots of imposing barriers right from the start, but Unity makes it
    easy to start learning these skills.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*Unity* 是一个用于创建针对各种平台的游戏的专业级游戏引擎。它不仅是一个每天被成千上万的资深游戏开发者使用的专业开发工具，也是新手游戏开发者最易于接触的现代工具之一。直到最近，游戏开发的新手从一开始就会面临许多令人望而却步的障碍，但Unity使得学习这些技能变得容易。'
- en: Because you’re reading this book, chances are you’re curious about computer
    technology and have either developed games with other tools or built other kinds
    of software, such as desktop applications or websites. Creating a video game isn’t
    fundamentally different from writing any other kind of software; it’s mostly a
    difference of degree. For example, a video game is a lot more interactive than
    most websites, and thus involves different sorts of code, but the skills and processes
    involved in creating both are similar.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你在阅读这本书，所以你很可能对计算机技术感兴趣，并且已经使用其他工具开发过游戏，或者构建过其他类型的软件，例如桌面应用程序或网站。创建一个视频游戏与编写任何其他类型的软件在本质上并没有太大的区别；它主要是一个程度上的差异。例如，视频游戏比大多数网站更具交互性，因此涉及不同类型的代码，但创建两者所涉及的技术和流程是相似的。
- en: If you’ve already cleared the first hurdle on your path to learning game development,
    having learned the fundamentals of programming software, then your next step is
    to pick up some game development tools and translate that programming knowledge
    into the realm of gaming. Unity is a great choice of game development environment
    to work with.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在学习游戏开发的道路上克服了第一个障碍，即学习了软件编程的基础知识，那么你的下一步就是选择一些游戏开发工具，并将你的编程知识转化为游戏领域。Unity是一个非常适合工作的游戏开发环境选择。
- en: A warning about terminology
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 关于术语的警告
- en: This book is about programming in Unity and is therefore primarily of interest
    to coders. Although many other resources discuss different aspects of game development
    and Unity, in this book programming takes front and center.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是关于在Unity中进行编程的，因此主要对程序员感兴趣。尽管许多其他资源讨论了游戏开发和Unity的不同方面，但在这本书中，编程是重点。
- en: 'Incidentally, note that the word *developer* may have an unfamiliar meaning
    in the context of game development: *developer* is a synonym for *programmer*
    in disciplines like web development, but in game development, *developer* often
    refers to anyone who works on a game, and *programmer* is a specific role within
    that. Other kinds of game developers are artists and designers, but this book
    focuses on programming.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，请注意，在游戏开发的背景下，“开发者”这个词可能有陌生的含义：“开发者”在像网络开发这样的学科中是“程序员”的同义词，但在游戏开发中，“开发者”通常指任何参与游戏工作的人，而“程序员”是其中的一个特定角色。其他类型的游戏开发者是艺术家和设计师，但本书专注于编程。
- en: To start, go to [www.unity.com](http://www.unity.com) to learn more about the
    software. Although Unity’s original focus was on 3D games, Unity works great for
    2D games as well, and this book covers both. Indeed, even when demonstrated on
    a 3D project, many topics (saving data, playing audio, and so on) apply to both.
    Section 1.2 will walk you through installing Unity as a newcomer, but first let’s
    discuss specific reasons to choose this tool.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，前往 [www.unity.com](http://www.unity.com) 了解更多关于该软件的信息。尽管Unity最初的重点是3D游戏，但Unity在2D游戏方面也表现出色，本书涵盖了这两者。实际上，即使是在3D项目中演示，许多主题（如保存数据、播放音频等）也适用于两者。第1.2节将指导你作为新手安装Unity，但首先让我们讨论选择这个工具的具体原因。
- en: 1.1 Why is Unity so great?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 为什么Unity如此出色？
- en: 'Let’s take a closer look at that description from the beginning of the chapter:
    Unity is a professional-quality game engine used to create video games targeting
    a variety of platforms. That’s a fairly straightforward answer to the straightforward
    question “What is Unity?” But what exactly does that answer mean, and why is Unity
    so great?'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看本章开头的描述：Unity是一个用于创建针对各种平台的游戏的专业质量游戏引擎。这是对简单直接的问题“什么是Unity？”的一个相当直接的回答。但这个答案究竟意味着什么，为什么Unity如此出色？
- en: 1.1.1 Unity’s strengths and advantages
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 Unity的优势和优点
- en: 'Game engines provide a plethora of features that are useful across many games.
    A game implemented using a particular engine will get all those features, while
    adding custom art assets and gameplay code specific to that game. Unity has physics
    simulation, normal maps, screen space ambient occlusion (SSAO), dynamic shadows
    . . . and the list goes on. Many game engines boast such features, but Unity has
    two main advantages over similar cutting-edge game development tools: an extremely
    productive visual workflow and a high degree of cross-platform support.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏引擎提供了许多适用于许多游戏的特性。使用特定引擎实现的游戏将获得所有这些特性，同时添加特定于该游戏的定制艺术资源和游戏代码。Unity拥有物理模拟、法线贴图、屏幕空间环境遮挡（SSAO）、动态阴影……等等。许多游戏引擎都吹嘘这样的特性，但Unity在类似前沿的游戏开发工具中具有两个主要优势：极其高效的工作流程和高度跨平台支持。
- en: The visual workflow is a fairly unique design, different from most other game
    development environments. Whereas other game development tools are often a complicated
    mishmash of disparate parts that must be wrangled, or perhaps a programming library
    that requires you to set up your own integrated development environment (IDE),
    build-chain, and whatnot, the development workflow in Unity is anchored by a sophisticated
    visual editor.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉工作流程是一种相当独特的设计，与大多数其他游戏开发环境不同。其他游戏开发工具通常是由多个不同部分组成的复杂混合体，必须进行整理，或者可能是一个需要你设置自己的集成开发环境（IDE）、构建链等编程库，而Unity的开发工作流程则由一个复杂的视觉编辑器支撑。
- en: The editor is used to lay out the scenes in your game and to tie together art
    assets and code into interactive objects. The beauty of this editor is that it
    enables professional-quality games to be built quickly and efficiently, giving
    developers tools to be incredibly productive, while still using an extensive list
    of the latest technologies in video gaming.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器用于布置游戏中的场景，并将艺术资源和代码结合成交互式对象。这个编辑器的优点在于它能够快速高效地构建专业质量的游戏，为开发者提供工具，使他们能够极其高效地工作，同时仍然使用视频游戏领域中最先进的技术列表。
- en: NOTE Most other game development tools that have a central visual editor are
    also saddled with limited and inflexible scripting support, but Unity doesn’t
    suffer from that disadvantage. Although everything created for Unity ultimately
    goes through the visual editor, this core interface can be used to link projects
    to custom code that runs in Unity’s game engine. Experienced programmers shouldn’t
    dismiss this development environment, mistaking it for some click-together game
    creator with limited programming capability!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：大多数其他拥有中心视觉编辑器的游戏开发工具也伴随着有限的和不灵活的脚本支持，但Unity并没有这个缺点。尽管为Unity创建的一切最终都要通过视觉编辑器进行，但这个核心界面可以用来将项目链接到在Unity游戏引擎中运行的定制代码。经验丰富的程序员不应该轻视这个开发环境，错误地认为它是一个具有有限编程能力的点击式游戏创建器！
- en: The editor is especially helpful for doing rapid iteration, honing the game
    through cycles of prototyping and testing. You can adjust objects in the editor
    and move things around even while the game is running. Plus, Unity allows you
    to customize the editor itself by writing scripts that add new features and menus
    to the interface.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器特别有助于进行快速迭代，通过原型设计和测试的循环来精炼游戏。你可以在编辑器中调整对象，甚至在游戏运行时移动它们。此外，Unity允许你通过编写脚本来自定义编辑器本身，这些脚本可以向界面添加新功能和菜单。
- en: Besides the editor’s significant productivity advantages, the other main strength
    of Unity’s tool set is a high degree of cross-platform support. Not only is Unity
    multiplatform in terms of deployment targets (you can deploy to PC, web, mobile,
    or consoles), but it’s also multiplatform in terms of development tools (you can
    develop a game on Microsoft Windows or Apple macOS). This platform-agnostic nature
    is largely because Unity started as Mac-only software and was later ported to
    Windows. The first version launched in 2005 and initially supported only Mac,
    but within months Unity had been updated to work on Windows as well.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编辑器显著的生产力优势外，Unity 工具集的另一个主要优势是高度跨平台支持。Unity 不仅在部署目标方面是多平台的（你可以部署到 PC、网页、移动设备或游戏机），而且在开发工具方面也是多平台的（你可以在
    Microsoft Windows 或 Apple macOS 上开发游戏）。这种平台无关性在很大程度上是因为 Unity 最初是仅限 Mac 的软件，后来才移植到
    Windows。第一个版本于 2005 年发布，最初只支持 Mac，但几个月内 Unity 就更新了，使其也能在 Windows 上运行。
- en: Successive versions gradually added more deployment platforms, such as a cross-platform
    web player in 2006, iPhone in 2008, Android in 2010, and even game consoles like
    Xbox and PlayStation. More recently, Unity has added deployment to WebGL, the
    new framework for graphics in web browsers, and even has support for extended
    reality (XR)—both virtual reality (VR) and augmented reality (AR)—platforms like
    Oculus and VIVE. Few game engines support as many deployment targets as Unity,
    and none make deploying to multiple platforms so simple.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 后续版本逐渐增加了更多的部署平台，例如 2006 年的跨平台网页播放器、2008 年的 iPhone、2010 年的 Android，甚至像 Xbox
    和 PlayStation 这样的游戏机。最近，Unity 还增加了对 WebGL 的部署，这是网页浏览器中图形的新框架，甚至支持扩展现实（XR）平台，如
    Oculus 和 VIVE——包括虚拟现实（VR）和增强现实（AR）。很少有游戏引擎支持像 Unity 那样多的部署目标，也没有哪个引擎能让跨平台部署如此简单。
- en: In addition to these main strengths, a third, more subtle, benefit comes from
    the modular component system used to construct game objects. In a component system,
    *components* are mix-and-match packets of functionality, and objects are built
    up as a collection of components, rather than as a strict hierarchy of classes.
    A component system is a different (and usually more flexible) approach to object-oriented
    programming (OOP) that constructs game objects through composition rather than
    inheritance. Figure 1.1 diagrams an example comparison.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些主要优势外，第三个更微妙的好处来自于构建游戏对象所使用的模块化组件系统。在组件系统中，*组件* 是功能包的组合，对象是通过组件的集合构建起来的，而不是作为严格的类层次结构。组件系统是一种不同的（通常更灵活的）面向对象编程（OOP）方法，它通过组合而不是继承来构建游戏对象。图
    1.1 展示了一个示例比较。
- en: '![CH01_F01_Hocking3](../Images/CH01_F01_Hocking3.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F01_Hocking3](../Images/CH01_F01_Hocking3.png)'
- en: Figure 1.1 Inheritance versus composition
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 继承与组合
- en: In a component system, objects exist on a flat hierarchy, and different objects
    have different collections of components. An inheritance structure, in contrast,
    has different objects on completely different branches of the tree. The component
    arrangement facilitates rapid prototyping, because you can quickly mix and match
    components rather than having to refactor the inheritance chain when objects change.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件系统中，对象存在于一个扁平的层次结构中，不同的对象有不同的组件集合。相比之下，继承结构中的不同对象位于树的完全不同的分支上。组件排列促进了快速原型设计，因为你可以快速混合和匹配组件，而无需在对象更改时重构继承链。
- en: Although you could write code to implement a custom component system if one
    didn’t exist, Unity already has a robust component system, and this system is
    even integrated with the visual editor. Instead of being able to manipulate components
    only in code, you can attach and detach components within the visual editor. Meanwhile,
    you aren’t limited to building objects only through composition; you still have
    the option of using inheritance in your code, including all the best-practice
    design patterns that have emerged based on inheritance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如果你没有自定义组件系统，可以编写代码来实现，但 Unity 已经有一个强大的组件系统，并且这个系统甚至与可视化编辑器集成。你不仅可以在代码中操作组件，还可以在可视化编辑器中附加和分离组件。同时，你不仅限于通过组合构建对象；你仍然可以选择在代码中使用继承，包括基于继承的所有最佳实践设计模式。
- en: 1.1.2 Downsides to be aware of
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 需要注意的缺点
- en: Unity has many advantages that make it a great choice for developing games,
    and I highly recommend it, but I’d be remiss if I didn’t mention its weaknesses.
    In particular, the combination of the visual editor and sophisticated coding,
    though very effective with Unity’s component system, is unusual and can create
    difficulties. In complex scenes, you can lose track of which objects in the scene
    have specific components attached. Unity does provide a search feature for finding
    attached scripts, but it could be more robust; sometimes you still encounter situations
    requiring you to manually inspect everything in the scene in order to find script
    linkages. This doesn’t happen often, but when it does happen, it can be tedious.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Unity有许多优点，使其成为开发游戏的一个很好的选择，我强烈推荐它，但如果不提及它的弱点，我会感到疏忽。特别是，视觉编辑器和复杂编码的结合，尽管与Unity的组件系统非常有效，但却是非同寻常的，可能会造成困难。在复杂的场景中，你可能会失去对场景中哪些对象附加了特定组件的跟踪。Unity确实提供了一个用于查找附加脚本的搜索功能，但它可能更健壮；有时你仍然会遇到需要手动检查场景中的所有内容以找到脚本链接的情况。这种情况并不常见，但一旦发生，可能会很繁琐。
- en: Another disadvantage that can be surprising and frustrating for experienced
    programmers is that linking in external code libraries can be difficult. Old versions
    of Unity didn’t support external code libraries at all actually, so they had to
    be manually copied into every project. Now Unity comes with the Package Manager,
    and libraries (or *packages*) are referenced from a central shared location. These
    packages work great for optional functionality provided by Unity itself (Unity
    doesn’t automatically include functionality that you don’t need in every single
    project), and future chapters will occasionally have you installing packages for
    things like advanced font handling. Creating your own packages can be tricky,
    however, making it awkward to share code among multiple projects. You may find
    it simpler to just manually copy code between projects and deal with any version
    mismatches down the road, which is not an ideal trade-off to be making.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能会让有经验的程序员感到惊讶和沮丧的缺点是，链接外部代码库可能很困难。实际上，Unity的旧版本根本不支持外部代码库，因此它们必须手动复制到每个项目中。现在Unity带有包管理器，库（或*包*）是从一个中央共享位置引用的。这些包对于Unity本身提供的可选功能（Unity不会自动包含每个项目中不需要的功能）工作得很好，未来的章节偶尔会要求你安装用于高级字体处理等功能的包。然而，创建自己的包可能很复杂，这使得在多个项目中共享代码变得尴尬。你可能发现直接在项目之间手动复制代码并处理未来的版本不匹配要简单一些，但这并不是一个理想的权衡。
- en: NOTE Difficulty working with version-control systems (such as Git or Subversion)
    used to be a significant weakness of Unity, but more recent versions work fine.
    You may find out-of-date resources telling you that Unity doesn’t work with version
    control, but newer resources describe which files and folders in a project need
    to be put in the repository and which don’t. To start out, read Unity’s documentation
    ([http://mng.bz/BbhD](http://mng.bz/BbhD)) or look at the .gitignore file maintained
    by GitHub ([http://mng.bz/g7nl](http://mng.bz/g7nl)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：过去，与版本控制系统（如Git或Subversion）一起工作一直是Unity的一个显著弱点，但较新版本的Unity运行良好。你可能会发现过时的资料告诉你Unity不支持版本控制，但新的资料会描述一个项目中哪些文件和文件夹需要放入仓库，哪些不需要。要开始，请阅读Unity的文档([http://mng.bz/BbhD](http://mng.bz/BbhD))或查看GitHub维护的.gitignore文件([http://mng.bz/g7nl](http://mng.bz/g7nl))。
- en: A third weakness has to do with the sometimes dizzying array of options. Unity
    offers multiple approaches to some functionalities, and it is not always clear
    which approach you should use. To a certain extent, that situation is inevitable
    for a tool under active development, but still results in confusion and discomfort
    for users. This evolutionary messiness can bewilder even Unity veterans, so newcomers
    to Unity will definitely face confusion at times. This book highlights such features
    and offers guidance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个弱点与有时令人眼花缭乱的选项数组有关。Unity为某些功能提供了多种方法，但并不总是清楚你应该使用哪种方法。在某种程度上，这种情况对于正在积极开发中的工具来说是不可避免的，但仍然会给用户带来困惑和不适。这种演化的混乱可能会让Unity的老手也感到困惑，因此Unity的新手肯定会时不时地遇到困惑。本书突出了这些功能并提供指导。
- en: For example, chapter 7 explains how to develop a user interface (UI) for Unity
    games. Well, Unity actually has *three* UI systems (which are compared at [http://
    mng.bz/r60X](http://mng.bz/r60X)) because of successively developed systems that
    improve on their predecessor. This book covers the second UI system (Unity UI,
    or uGUI) because it is still preferred over the incomplete third UI system (UI
    Toolkit), but I wouldn’t be surprised if UI Toolkit matures to production-ready
    within a few years. In the interim, newcomers may have difficulty deciding on
    a UI approach.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，第7章解释了如何为Unity游戏开发用户界面（UI）。嗯，Unity实际上有*三个* UI系统（这些系统在[http:// mng.bz/r60X](http://mng.bz/r60X)上进行了比较），因为随着系统的不断开发，它们在改进其前辈。本书涵盖了第二个UI系统（Unity
    UI，或uGUI），因为它仍然比不完整的第三个UI系统（UI Toolkit）更受欢迎，但几年内UI Toolkit成熟到生产就绪阶段，我也不会感到惊讶。在此期间，新来者可能难以决定UI方法。
- en: 1.1.3 Example games built with Unity
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.3 使用Unity构建的示例游戏
- en: You’ve heard about the pros and cons of Unity, but you might still need convincing
    that its development tools can give first-rate results. Visit the Unity gallery
    at [https://unity.com/case-study](https://unity.com/case-study) to see a constantly
    updated list of games and simulations developed using Unity. This section explores
    a handful of games, showcasing multiple genres and deployment platforms. All game
    titles are trademarks of their respective game companies, and screenshots are
    also copyrighted to those companies, with all rights reserved.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经听说过Unity的优缺点，但你可能仍然需要证明其开发工具可以提供一流的结果。访问Unity画廊[https://unity.com/case-study](https://unity.com/case-study)，查看使用Unity开发的不断更新的游戏和模拟列表。本节探讨了几个游戏，展示了多个类型和部署平台。所有游戏名称均为各自游戏公司的商标，截图也归这些公司所有，版权所有。
- en: Desktop (Windows, Mac, Linux) and Console (PlayStation, Xbox, Switch)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面（Windows，Mac，Linux）和控制台（PlayStation，Xbox，Switch）
- en: 'Because the Unity editor runs on the same platform, deployment to Windows or
    Mac is often the most straightforward target platform. Meanwhile, console games
    developed in Unity are often released on PC too, thanks to Unity’s easy cross-platform
    deployment. Here are a couple of examples of desktop and console games in different
    genres:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Unity编辑器运行在相同的平台上，部署到Windows或Mac通常是目标平台中最直接的选择。同时，在Unity中开发的控制台游戏也经常在PC上发布，这得益于Unity的简单跨平台部署。以下是一些不同类型的桌面和控制台游戏的例子：
- en: '*Fall Guys* (figure 1.2), a chaotic 3D action game developed by Mediatonic
    (trademarks of Mediatonic Limited)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Fall Guys*（图1.2），由Mediatonic（Mediatonic Limited的商标）开发的一款混乱的3D动作游戏'
- en: '![CH01_F02_Hocking3](../Images/CH01_F02_Hocking3.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F02_Hocking3](../Images/CH01_F02_Hocking3.png)'
- en: Figure 1.2 *Fall Guys*
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 *Fall Guys*
- en: '*Cuphead* (figure 1.3), a 2D platformer developed by Studio MDHR'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Cuphead*（图1.3），由Studio MDHR开发的一款2D平台游戏'
- en: '![CH01_F03_Hocking3](../Images/CH01_F03_Hocking3.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F03_Hocking3](../Images/CH01_F03_Hocking3.png)'
- en: Figure 1.3 *Cuphead*
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 *Cuphead*
- en: Mobile (iOS and Android)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 移动端（iOS和Android）
- en: 'Unity can also deploy games to mobile platforms like iOS (iPhones and iPads)
    and Android (phones and tablets). Here are three examples of mobile games in different
    genres:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Unity还可以将游戏部署到移动平台，如iOS（iPhone和iPad）和Android（手机和平板电脑）。以下是一些不同类型的移动游戏的例子：
- en: '*Monument Valley 2* (figure 1.4), a puzzle game developed by ustwo'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Monument Valley 2*（图1.4），由ustwo开发的一款解谜游戏'
- en: '![CH01_F04_Hocking3](../Images/CH01_F04_Hocking3.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F04_Hocking3](../Images/CH01_F04_Hocking3.png)'
- en: Figure 1.4 *Monument Valley 2*
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 *Monument Valley 2*
- en: '*Guns of Boom* (figure 1.5), a first-person shooter developed by Game Insight'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Guns of Boom*（图1.5），由Game Insight开发的一款第一人称射击游戏'
- en: '![CH01_F05_Hocking3](../Images/CH01_F05_Hocking3.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F05_Hocking3](../Images/CH01_F05_Hocking3.png)'
- en: Figure 1.5 *Guns of Boom*
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 *Guns of Boom*
- en: '*Animation Throwdown* (figure 1.6), a collectible card game developed by Kongregate'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Animation Throwdown*（图1.6），由Kongregate开发的一款收藏卡牌游戏'
- en: '![CH01_F06_Hocking3](../Images/CH01_F06_Hocking3.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F06_Hocking3](../Images/CH01_F06_Hocking3.png)'
- en: Figure 1.6 *Animation Throwdown*
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 *Animation Throwdown*
- en: Virtual Reality (Oculus, VIVE, PlayStation VR)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟现实（Oculus，VIVE，PlayStation VR）
- en: 'Unity can even deploy to XR platforms, including virtual reality headsets.
    Here are a couple of examples of VR games in different genres:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Unity甚至可以将游戏部署到XR平台，包括虚拟现实头戴设备。以下是一些不同类型的VR游戏的例子：
- en: '*Beat Saber* (figure 1.7), a rhythm game developed by Beat Games'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Beat Saber*（图1.7），由Beat Games开发的一款节奏游戏'
- en: '![CH01_F07_Hocking3](../Images/CH01_F07_Hocking3.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F07_Hocking3](../Images/CH01_F07_Hocking3.png)'
- en: Figure 1.7 *Beat Saber*
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 *Beat Saber*
- en: '*I Expect You to Die* (figure 1.8), an escape puzzle game developed by Schell
    Games'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*I Expect You to Die*（图1.8），由Schell Games开发的一款逃脱解谜游戏'
- en: '![CH01_F08_Hocking3](../Images/CH01_F08_Hocking3.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F08_Hocking3](../Images/CH01_F08_Hocking3.png)'
- en: Figure 1.8 *I Expect You to Die*
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 *我期待你死去*
- en: As you can see from these examples, Unity’s strengths can definitely translate
    into commercial-quality games. But even with Unity’s significant advantages over
    other game development tools, newcomers may misunderstand the involvement of programming
    in the development process.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如这些示例所示，Unity 的优势确实可以转化为商业品质的游戏。但即使 Unity 在其他游戏开发工具上具有显著优势，新来者也可能误解编程在开发过程中的作用。
- en: Unity is often portrayed as a list of features with no programming required,
    which is a misleading view that won’t teach people what they need to know in order
    to produce commercial titles. Though it’s true that you can click together a fairly
    elaborate prototype using preexisting components even without a programmer being
    involved (which is itself a pretty big feat), rigorous programming is required
    to move beyond an interesting prototype to a polished game ready for release.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 常常被描绘为无需编程即可使用的一系列功能，这是一个误导性的观点，它不会教人们他们需要知道的内容，以便制作商业游戏。虽然确实可以在不涉及程序员的情况下使用预存组件构建相当复杂的原型（这本身就是一个相当大的成就），但要从一个有趣的原型过渡到一个准备发布的精良游戏，则需要严格的编程。
- en: 1.2 How to use Unity
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 如何使用 Unity
- en: The previous section talked a lot about the productivity benefits of Unity’s
    visual editor, so let’s go over what the interface looks like and how it operates.
    If you haven’t already done so, download the program by going to [www.unity.com](https://unity.com/)
    and clicking Get Started. Here you will see a breakdown of the various subscription
    plans offered. Everything in this book works in the free version, so select the
    Individual tab and click the button under the free Personal edition. The paid
    versions of Unity differ mainly in commercial licensing terms, not in underlying
    functionality.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节详细讨论了 Unity 视觉编辑器的生产力优势，所以让我们来看看界面是什么样的，以及它是如何操作的。如果你还没有这样做，请访问 [www.unity.com](https://unity.com/)
    并点击“开始使用”来下载程序。在这里，你可以看到提供的各种订阅计划的概述。本书中的所有内容在免费版本中都可以使用，所以选择“个人”选项卡，然后点击免费个人版下面的按钮。Unity
    的付费版本主要区别在于商业许可条款，而不是底层功能。
- en: The website has separate downloads for new and returning users. The difference
    is simply that the download for new users will launch into a software wizard that
    directs users to intro tutorials, whereas the download for returning users goes
    straight to the main application with no introduction. So even if you are new
    to Unity, get the download for returning users and skip the intro content (it’s
    redundant with this book, after all).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 网站为新用户和回访用户提供了不同的下载。区别仅仅在于新用户的下载将启动一个软件向导，引导用户进入入门教程，而回访用户的下载将直接进入主应用程序，没有任何介绍。所以即使你是
    Unity 的新手，也请下载回访用户的版本并跳过入门内容（毕竟，它与本书的内容重复）。
- en: You’ll actually download a lightweight installation manager rather than the
    main Unity application. This manager application, called *Unity Hub*, exists to
    simplify the installation and use of multiple versions of Unity simultaneously.
    As shown in figure 1.9, installing the editor will be the first thing that happens
    when you launch Unity Hub. Install whichever is the default Recommended Release;
    this book uses Unity 2020.3.12 (the current default release as of this writing).
    If you later want to install additional versions of Unity (newer versions than
    the default are available), click Installs on the side menu in Unity Hub.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你会下载一个轻量级的安装管理器，而不是主要的 Unity 应用程序。这个管理应用程序被称为 *Unity Hub*，它的存在是为了简化同时安装和使用多个
    Unity 版本。如图 1.9 所示，当你启动 Unity Hub 时，安装编辑器将是第一件事。安装默认推荐的版本；本书使用 Unity 2020.3.12（截至本书写作时的当前默认版本）。如果你以后想安装额外的
    Unity 版本（比默认版本更新的版本），请点击 Unity Hub 侧菜单中的“安装”。
- en: '![CH01_F09_Hocking3](../Images/CH01_F09_Hocking3.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F09_Hocking3](../Images/CH01_F09_Hocking3.png)'
- en: Figure 1.9 Unity Hub on first launch versus subsequently
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 Unity Hub 首次启动与后续启动对比
- en: TIP By the time you read this, newer Unity versions will likely have been released.
    Advanced features will have changed, and possibly even the look of the interface
    could be different, but the fundamental concepts covered by this book will still
    be true. The explanations given in this book will generally still apply to whichever
    future version of Unity is current.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：到您阅读这本书的时候，可能已经发布了更新的Unity版本。高级功能可能会发生变化，甚至界面的外观也可能不同，但本书涵盖的基本概念仍然适用。本书中的解释通常仍然适用于当前的任何Unity未来版本。
- en: WARNING Projects remember which version of Unity they were created in and will
    issue a warning if you attempt to open them in a different version. Sometimes
    it doesn’t matter (for example, ignore the warning if it appears while opening
    this book’s sample downloads), but sometimes you don’t want to open a project
    in the wrong version.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：项目会记住它们是在哪个Unity版本中创建的，如果您尝试在另一个版本中打开它们，将会发出警告。有时这并不重要（例如，如果在此书样本下载打开时出现警告，请忽略它），但有时您不希望在一个错误的版本中打开项目。
- en: Continuing on from installing the editor, go to the Learn tab to download a
    first project. Select any project to look around in (you won’t be doing much with
    it anyway) but note that figure 1.10 shows Karting. Unity will download and launch
    the selected project. You may see a warning message about importing files to set
    up the new project; realize that the import can take several minutes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从安装编辑器继续，转到“学习”标签页以下载第一个项目。选择任何项目进行浏览（您无论如何也不会做太多），但请注意图1.10显示了Karting。Unity将下载并启动所选项目。您可能会看到一个关于导入文件以设置新项目的警告消息；请意识到导入可能需要几分钟。
- en: Once the new project is finally loaded, choose Load Scene to dismiss the initial
    pop-up. If it isn’t already open, navigate to Assets/Karting/Scenes/ in the file
    browser at the bottom of the editor, and double-click MainScene (scene files have
    the Unity cube icon). You should see a screen similar to figure 1.10.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新项目最终加载完成，选择“加载场景”以关闭初始弹出窗口。如果文件浏览器底部的编辑器中尚未打开，请导航到Assets/Karting/Scenes/，双击MainScene（场景文件有Unity立方体图标）。您应该看到一个类似于图1.10的屏幕。
- en: '![CH01_F10_Hocking3](../Images/CH01_F10_Hocking3.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F10_Hocking3](../Images/CH01_F10_Hocking3.png)'
- en: Figure 1.10 Parts of the interface in Unity
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 Unity界面部分
- en: 'The interface in Unity is split into sections: the Scene tab, the Game tab,
    the Toolbar, the Hierarchy tab, the Inspector, the Project tab, and the Console
    tab. Each section has a different purpose, but all are crucial to the game-building
    life cycle:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的界面分为几个部分：场景标签页、游戏标签页、工具栏、层次结构标签页、检查器、项目标签页和控制台标签页。每个部分都有不同的用途，但所有部分对于游戏制作的生命周期都是至关重要的：
- en: You can browse through all the files in the Project tab.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在项目标签页中浏览所有文件。
- en: You can position objects in the current scene by using the Scene tab.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用场景标签页来定位当前场景中的对象。
- en: The Toolbar has controls for working with the scene.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具栏包含用于处理场景的控制。
- en: You can drag and drop object relationships in the Hierarchy tab.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在层次结构标签页中拖放对象关系。
- en: The Inspector lists information about selected objects, including linked code.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查器列出了所选对象的信息，包括链接的代码。
- en: You can test playing in Game view while watching error output in the Console
    tab.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在游戏视图中测试播放，同时查看控制台标签页中的错误输出。
- en: This is the default layout in Unity; all of the views are in tabs and can be
    moved around or resized, docking in different places on the screen. Later, you
    can play around with customizing the layout, but for now, the default layout is
    the best way to understand what all the views do.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Unity中的默认布局；所有视图都在标签页中，可以移动或调整大小，停靠在屏幕的不同位置。稍后，您可以尝试自定义布局，但现在，默认布局是了解所有视图功能的最佳方式。
- en: 1.2.1 Scene view, Game view, and the Toolbar
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 场景视图、游戏视图和工具栏
- en: 'The most prominent part of the interface is the *Scene view* in the middle.
    This is where you can see what the game world looks like and move objects around.
    Mesh objects in the scene appear as, well, their mesh (defined in a moment). You
    can also see other objects in the scene, represented by icons and colored lines:
    cameras, lights, audio sources, collision regions, and so forth. Note that the
    view you’re seeing here isn’t the same as the view in the running game—you’re
    able to look around the scene at will without being constrained to the game’s
    view.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 界面最显著的部分是中间的*场景视图*。在这里，您可以查看游戏世界的外观并移动对象。场景中的网格对象以网格（稍后定义）的形式出现。您还可以看到场景中的其他对象，它们由图标和彩色线条表示：摄像机、灯光、音频源、碰撞区域等等。请注意，您在这里看到的视图与运行中的游戏视图不同——您可以随意在场景中环顾四周，而无需受限于游戏的视图。
- en: DEFINITION A *mesh object* is a visual object in space. Visuals in 3D graphics
    are constructed out of lots of connected lines and shapes—hence the word *mesh*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*网格对象*是空间中的视觉对象。3D图形中的视觉效果由许多连接的线条和形状构成——因此得名*网格*。
- en: The *Game view* isn’t a separate part of the screen but rather another tab located
    right next to Scene (look for tabs at the top left of views). A couple of places
    in the interface have multiple tabs like this; if you click a different tab, the
    view is replaced by the new active tab. When the game is running, what you see
    in this view is the game. It isn’t necessary to manually switch tabs every time
    you run the game, because the view automatically switches to Game when the game
    starts.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*游戏视图*不是屏幕的独立部分，而是一个位于场景旁边的另一个标签（在视图的左上角寻找标签）。界面上有几个地方有多个这样的标签；如果您点击不同的标签，视图将替换为新活动的标签。当游戏运行时，您在这个视图中看到的是游戏。每次运行游戏时无需手动切换标签，因为当游戏开始时，视图会自动切换到游戏视图。'
- en: TIP While the game is running, you can switch back to the Scene view, allowing
    you to inspect objects in the running scene. This capability is extremely useful
    for seeing what’s going on while the game is running and is a helpful debugging
    tool that isn’t available in most game engines.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：当游戏运行时，您可以切换回场景视图，允许您检查运行场景中的对象。这种能力在游戏运行时查看正在发生的事情时非常有用，并且是一个在大多数游戏引擎中不可用的有用调试工具。
- en: Speaking of running the game, that’s as simple as clicking the Play button just
    above the Scene view. That whole top section of the interface is referred to as
    the *Toolbar*, and Play is located right in the middle. Figure 1.11 breaks apart
    the full editor interface to show only the Toolbar at the top as well as the Scene/Game
    tabs right underneath.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 说到运行游戏，只需点击场景视图正上方的播放按钮就这么简单。界面的整个顶部部分被称为*工具栏*，播放按钮位于正中央。图1.11将完整的编辑器界面拆分，只显示顶部的工具栏以及位于其下的场景/游戏标签。
- en: '![CH01_F11_Hocking3](../Images/CH01_F11_Hocking3.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F11_Hocking3](../Images/CH01_F11_Hocking3.png)'
- en: Figure 1.11 Editor screenshot cropped to show Toolbar, Scene, and Game
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 编辑器截图裁剪以显示工具栏、场景和游戏视图
- en: At the left side of the Toolbar are buttons for scene navigation and transforming
    objects—to look around the scene and to move objects. I suggest you spend time
    practicing these, because they are two of the most important activities you’ll
    do in Unity’s visual editor. (They’re so important that they get their own section
    following this one.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏的左侧是场景导航和变换对象的按钮——用于环顾场景和移动对象。我建议您花时间练习这些，因为它们是您在Unity视觉编辑器中将要做的最重要的活动之二。（它们如此重要，以至于在接下来的部分中会有它们自己的章节。）
- en: The right-hand side of the Toolbar is where you’ll find drop-down menus for
    layouts and layers. As mentioned earlier, the layout of Unity’s interface is flexible,
    so the Layout menu allows you to switch layouts. As for the Layers menu, that’s
    advanced functionality that you can ignore for now (layers are mentioned in future
    chapters).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏的右侧是布局和图层下拉菜单的位置。如前所述，Unity界面的布局是灵活的，因此布局菜单允许您切换布局。至于图层菜单，那是目前可以忽略的高级功能（图层将在未来的章节中介绍）。
- en: 1.2.2 The mouse and keyboard
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 鼠标和键盘
- en: Scene navigation is primarily done using the mouse, along with a few modifier
    keys used to change what the mouse is doing. The three main navigation maneuvers
    are Move, Orbit, and Zoom. The specific mouse movements vary depending on the
    mouse you’re using and are described in appendix A. The three movements involve
    clicking and dragging while holding down a combination of Alt (or Option on Mac)
    and Ctrl (Command on a Mac). Spend a few minutes moving around in the scene to
    understand what Move, Orbit, and Zoom do.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 场景导航主要使用鼠标完成，同时使用一些修改键来改变鼠标的操作。三种主要的导航操作是移动、环绕和缩放。具体的鼠标移动取决于你使用的鼠标，并在附录 A 中描述。这三种移动涉及在按住
    Alt（或 Mac 上的 Option）和 Ctrl（Mac 上的 Command）组合键的同时点击和拖动。花几分钟在场景中移动，以了解移动、环绕和缩放的作用。
- en: TIP Although Unity can be used with one- or two-button mice, I highly recommend
    getting a three-button mouse (and yes, a three-button mouse works fine on a Mac).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：尽管 Unity 可以使用单键或双键鼠标，但我强烈推荐使用三键鼠标（是的，三键鼠标在 Mac 上也能正常工作）。
- en: 'Transforming objects is also done through three main maneuvers, and the three
    scene navigation moves are analogous to the three transforms: Translate, Rotate,
    and Scale (figure 1.12 demonstrates the transforms on a cube).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的变换也是通过三种主要操作完成的，三种场景导航操作与三种变换相对应：平移、旋转和缩放（图 1.12 展示了在立方体上的变换）。
- en: '![CH01_F12_Hocking3](../Images/CH01_F12_Hocking3.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F12_Hocking3](../Images/CH01_F12_Hocking3.png)'
- en: 'Figure 1.12 Applying the three transforms: Translate, Rotate, and Scale. (The
    lighter lines are the previous state of the object before it was transformed.)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 应用三个变换：平移、旋转和缩放。（较浅的线条是变换前的对象状态。）
- en: When you select an object in the scene, you can then move it around (the mathematically
    accurate technical term is *translate*), rotate it, and scale its size. Relating
    back to scene navigation maneuvers, Move corresponds to Translate for the camera,
    Orbit corresponds to Rotate, and Zoom corresponds to Scale. Besides the buttons
    on the Toolbar, you can switch these functions by pressing W, E, or R on the keyboard.
    When you activate a transform, you’ll notice that a set of color-coded arrows
    or circles appears over the object in the scene; this is the Transform gizmo,
    and you can click and drag this gizmo to apply the transformation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在场景中选择一个对象时，你可以将其移动（在数学上准确的技术术语是 *平移*），旋转它，并调整其大小。将场景导航操作联系起来，移动对应于摄像机的平移，环绕对应于旋转，缩放对应于缩放。除了工具栏上的按钮外，你可以通过按键盘上的
    W、E 或 R 来切换这些功能。当你激活变换时，你会注意到一组彩色箭头或圆圈出现在场景中的对象上；这是变换工具，你可以点击并拖动这个工具来应用变换。
- en: A fourth tool is next to the transform buttons. Called the *Rect tool*, it’s
    designed for use with 2D graphics. This one tool combines movement, rotation,
    and scaling. Similarly, the fifth button is for a tool that combines movement,
    rotation, and scaling for 3D objects. Personally, I prefer to manipulate the three
    transforms separately, but you may find the combined tools more convenient.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个工具位于变换按钮旁边。称为 *矩形工具*，它专为 2D 图形设计。这个工具结合了移动、旋转和缩放。同样，第五个按钮用于结合移动、旋转和缩放的工具，用于
    3D 对象。我个人更喜欢分别操作三个变换，但你可能会觉得组合工具更方便。
- en: Unity has a host of other keyboard shortcuts for speeding up a variety of tasks.
    Refer to appendix A to learn about them. And with that, on to the remaining sections
    of the interface!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 还有一系列键盘快捷键，用于加快各种任务的速度。请参阅附录 A 了解它们。有了这些，接下来我们将介绍界面的其他部分！
- en: 1.2.3 The Hierarchy view and the Inspector panel
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 层次视图和检查器面板
- en: Looking at either side of the screen, you’ll see the Hierarchy tab on the left
    and the Inspector tab on the right (see figure 1.13). *Hierarchy* lists the name
    of every object in the scene and nests the names together according to their hierarchy
    linkages in the scene. Basically, it’s a way of selecting objects by name instead
    of hunting them down and clicking them within the Scene view. The Hierarchy linkages
    group objects together visually, like folders, allowing you to move the entire
    group as one.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 观察屏幕的任一边，你会在左侧看到层次标签，在右侧看到检查器标签（见图 1.13）。*层次*列出了场景中每个对象的名称，并根据场景中的层次链接关系将名称嵌套在一起。基本上，这是一种通过名称选择对象而不是在场景视图中搜索并点击对象的方法。层次链接关系将对象组合在一起，就像文件夹一样，允许你将整个组作为一个整体移动。
- en: '![CH01_F13_Hocking3](../Images/CH01_F13_Hocking3.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F13_Hocking3](../Images/CH01_F13_Hocking3.png)'
- en: Figure 1.13 Editor screenshot cropped to show the Hierarchy and Inspector tabs
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 编辑器截图裁剪以显示层次结构和检查器标签页
- en: The *Inspector* shows you information about the currently selected object. Select
    an object, and the Inspector is then filled with information about that object.
    The information shown is pretty much a list of components, and you can even attach
    or remove components from objects. All game objects have at least one component,
    Transform, so you’ll always see at least information about positioning and rotation
    in the Inspector. Often, objects will have several components listed here, including
    scripts attached to them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*检查器* 显示关于当前选中对象的信息。选择一个对象，检查器就会填充有关该对象的信息。显示的信息基本上是组件列表，你甚至可以给对象附加或移除组件。所有游戏对象至少有一个组件，即变换组件，所以你总会看到至少有关位置和旋转的信息在检查器中。通常，对象在这里会列出几个组件，包括附加到它们上的脚本。'
- en: 1.2.4 The Project and Console tabs
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 项目和控制台标签页
- en: At the bottom of the screen, you’ll see Project and Console (see figure 1.14).
    As with Scene and Game, these aren’t two separate portions of the screen, but
    rather tabs that you can switch between.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕底部，你会看到项目视图和控制台（见图 1.14）。与场景和游戏一样，这些不是屏幕的两个独立部分，而是你可以切换的标签页。
- en: '*Project* shows all the assets (art, code, and so on) in the project. Specifically,
    on the left side of the view is a listing of the project’s directories; when you
    select a directory, the right side of the view shows the individual files in that
    directory. The directory listing in Project is similar to the list view in Hierarchy,
    but Hierarchy shows objects in the scene; Project shows files that may not be
    contained within any specific scene (including scene files—when you save a scene,
    it shows up in Project!).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*项目* 显示项目中的所有资源（艺术、代码等）。具体来说，在视图的左侧是项目目录的列表；当你选择一个目录时，视图的右侧会显示该目录中的单个文件。项目中的目录列表类似于层次结构中的列表视图，但层次结构显示场景中的对象；项目显示可能不在任何特定场景中包含的文件（包括场景文件——当你保存场景时，它会在项目中显示出来！）。'
- en: '![CH01_F14_Hocking3](../Images/CH01_F14_Hocking3.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F14_Hocking3](../Images/CH01_F14_Hocking3.png)'
- en: Figure 1.14 Editor screenshot cropped to show the Project and Console tabs
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14 编辑器截图裁剪以显示项目和控制台标签页
- en: TIP Project view mirrors the Assets directory on disk, but generally, you shouldn’t
    move or delete files directly by going to the Assets folder in your OS’s file
    explorer. If you do those things within the Project view, Unity will keep in sync
    with that folder.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 项目视图反映了磁盘上的资源目录，但通常，你不应该通过在操作系统的文件资源管理器中直接访问资源文件夹来移动或删除文件。如果你在项目视图中执行这些操作，Unity
    将与该文件夹保持同步。
- en: The *Console* tab is the place where messages from the code show up. Some of
    these messages will be debugging output that you placed deliberately, but Unity
    also emits error messages if it encounters problems in the script you wrote.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制台* 标签页是代码消息出现的地方。其中一些消息将是故意放置的调试输出，但 Unity 如果在脚本中遇到问题，也会发出错误消息。'
- en: 1.3 Getting up and running with Unity programming
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 使用 Unity 编程入门
- en: Now let’s look at how the process of programming works in Unity. Although art
    assets can be laid out in the visual editor, you need to write code to control
    them and make the game interactive. Complex programming in Unity is done using
    C# as the programming language.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看在 Unity 中编程的过程是如何工作的。虽然可以在视觉编辑器中布置艺术资源，但你需要编写代码来控制它们并使游戏交互。Unity 中的复杂编程使用
    C# 作为编程语言来完成。
- en: 'Launch Unity and create a new project: choose New in Unity Hub, or choose File
    > New Project if Unity is already running. Type a name for the project, leave
    the default 3D template (future chapters mention 2D), and then choose where you
    want to save the project. A Unity project is simply a directory full of various
    asset and settings files, so save the project anywhere on your computer. Click
    Create, and then Unity will briefly disappear while it sets up the project directory.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Unity 并创建一个新项目：在 Unity Hub 中选择“新建”，或者在 Unity 已运行时选择“文件”>“新建项目”。为项目输入一个名称，保留默认的
    3D 模板（后续章节将介绍 2D），然后选择你想要保存项目的地方。Unity 项目只是一个包含各种资源和设置文件的目录，所以你可以将项目保存在电脑上的任何位置。点击“创建”，然后
    Unity 将暂时消失，以设置项目目录。
- en: Alternatively, you could open the chapter 1 sample project. I strongly recommend
    you try to follow the upcoming instructions in a new project, and look at the
    finished sample only afterward to check your work, but it’s up to you. Choose
    Add in Unity Hub to add a downloaded project folder to the list and then click
    the project in the list.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以打开第1章的示例项目。我强烈建议您在一个新项目中尝试遵循即将到来的说明，然后在检查您的作品之后查看完成的示例，但这完全取决于您。在Unity
    Hub中选择“添加”以将下载的项目文件夹添加到列表中，然后单击列表中的项目。
- en: 'WARNING If you are opening the book’s sample project rather than creating a
    new project, Unity may emit the following message: Rebuilding Library because
    the asset database could not be found! This refers to the project’s Library folder;
    that folder contains files generated by Unity and used while working, but it is
    not necessary to distribute those files.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：如果您打开的是本书的示例项目而不是创建一个新项目，Unity可能会显示以下消息：“重建库，因为找不到资产数据库！”这指的是项目的库文件夹；该文件夹包含Unity生成并在工作期间使用的文件，但在分发这些文件时不是必需的。
- en: When Unity reappears, you’ll be looking at a blank project. Next, let’s discuss
    how programs get executed in Unity.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当Unity再次出现时，您将看到一个空白项目。接下来，让我们讨论程序如何在Unity中执行。
- en: '1.3.1 Running code in Unity: Script components'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 在Unity中运行代码：脚本组件
- en: All code execution in Unity starts from code files linked to an object in the
    scene. Ultimately, this code execution is all part of the component system described
    earlier; game objects are built up as a collection of components, and that collection
    can include scripts to execute.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的所有代码执行都是从与场景中的对象链接的代码文件开始的。最终，这种代码执行是之前描述的组件系统的一部分；游戏对象是由组件集合构建的，而这个集合可以包括执行脚本的脚本。
- en: 'NOTE Unity refers to the code files as *scripts*, using a definition of *script*
    that’s most commonly encountered with JavaScript running in a browser: the code
    is executed within the Unity game engine, as opposed to compiled code that runs
    as its own executable. But don’t get confused, because many people define the
    word differently; for example, *scripts* often refer to short, self-contained
    utility programs. Scripts in Unity are more akin to individual OOP classes, and
    scripts attached to objects in the scene are object instances.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Unity将代码文件称为*脚本*，使用的是在浏览器中运行JavaScript时最常见的*脚本*定义：代码在Unity游戏引擎中执行，而不是作为其自己的可执行文件运行的编译代码。但不要混淆，因为许多人将这个词定义为不同的含义；例如，*脚本*通常指的是短小、自包含的实用程序。Unity中的脚本更类似于单个OOP类，并且附加到场景中对象的脚本是对象实例。
- en: As you’ve probably surmised from this description, in Unity, scripts *are* components—not
    all scripts, mind you, only scripts that inherit from MonoBehaviour, the base
    class for script components. MonoBehaviour defines the invisible groundwork for
    attaching components to game objects, and (as shown in listing 1.1) inheriting
    from it provides a couple of automatically run methods that you can implement.
    Those methods include Start(), called once when the object becomes active (which
    is generally as soon as the scene with that object has loaded), and Update(),
    which is called every frame. Your code is run when you put it inside these predefined
    methods.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从描述中可能推测到的，在Unity中，脚本*是*组件——请注意，不是所有脚本，只有继承自MonoBehaviour的脚本，MonoBehaviour是脚本组件的基类。MonoBehaviour定义了将组件附加到游戏对象的无形基础，并且（如列表1.1所示）从它继承提供了一些自动运行的方法，您可以实现这些方法。这些方法包括Start()，当对象变为活动状态时调用一次（通常是在带有该对象的场景加载后立即调用），以及Update()，它每帧都会被调用。当您将这些代码放入这些预定义方法中时，您的代码就会被运行。
- en: DEFINITION A *frame* is a single cycle of the looping game code. Nearly all
    video games (not only in Unity, but video games in general) are built around a
    core game loop, where the code executes in a cycle while the game is running.
    Each cycle includes drawing the screen—hence the name *frame* (like the series
    of still frames of a movie).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*帧*是循环游戏代码的单个周期。几乎所有视频游戏（不仅是在Unity中，而且在一般视频游戏中）都是围绕核心游戏循环构建的，其中代码在游戏运行时循环执行。每个周期包括绘制屏幕——因此得名*帧*（就像电影的一系列静态帧）。
- en: Listing 1.1 Code template for a basic script component
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.1 基本脚本组件的代码模板
- en: '[PRE0]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Include namespaces for Unity and .NET/Mono classes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含Unity和.NET/Mono类的命名空间。
- en: ❷ The syntax for inheritance
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 继承的语法
- en: ❸ Put code here that runs once.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在此处放置只运行一次的代码。
- en: ❹ Put code here that runs every frame.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在此处放置每帧运行的代码。
- en: 'This is what the file contains when you create a new C# script: the minimal
    boilerplate code that defines a valid Unity component. Unity has a script template
    tucked away in the bowels of the application, and when you create a new script,
    Unity copies that template and renames the class to match the name of the file
    (which is HelloWorld.cs in my case). Unity also has empty shells for Start() and
    Update(), because those are the two most common places from which you’ll call
    your custom code.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个新的C#脚本时，文件包含的内容是这样的：定义一个有效Unity组件的最小样板代码。Unity在应用程序的深处藏有一个脚本模板，当你创建一个新的脚本时，Unity会复制这个模板并将类重命名为与文件名匹配（在我的例子中是HelloWorld.cs）。Unity还为Start()和Update()提供了空壳，因为这两个是最常见的调用自定义代码的地方。
- en: To create a script, select C# Script from the Create menu, which you access
    either under the Assets menu (note that Assets and GameObjects both have listings
    for Create, but they’re different menus) or by right-clicking in the Project view.
    Type in a name for the new script, such as HelloWorld. As explained later in the
    chapter (see figure 1.16), you’ll click and drag this script file onto an object
    in the scene. Double-click the script, and it’ll automatically be opened in another
    program for editing, as discussed next.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个脚本，从创建菜单中选择C#脚本，你可以通过在资产菜单下（注意资产和游戏对象都有创建的列表，但它们是不同的菜单）或通过在项目视图中右键单击来访问它。为新脚本输入一个名称，例如HelloWorld。如本章后面所述（见图1.16），你会点击并拖动这个脚本文件到场景中的对象上。双击脚本，它将自动在另一个程序中打开以进行编辑，如下一节所述。
- en: 1.3.2 Using Visual Studio, the included IDE
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.2 使用Visual Studio，内置的IDE
- en: Programming isn’t done within Unity exactly, but rather code exists as separate
    files that you point Unity to. Script files can be created within Unity, but you
    still need to use a text editor or IDE to write all the code within those initially
    empty files. Unity comes with Microsoft Visual Studio, an IDE for C# (figure 1.15
    shows what it looks like). You can visit [https://visualstudio.microsoft.com](https://visualstudio.microsoft.com/)
    to learn more about this software.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 编程并不是在Unity中完成的，而是代码作为独立的文件存在，你需要将这些文件指向Unity。脚本文件可以在Unity中创建，但你仍然需要使用文本编辑器或IDE来编写那些最初为空的文件。Unity附带Microsoft
    Visual Studio，这是一个C#的IDE（图1.15展示了其外观）。你可以访问[https://visualstudio.microsoft.com](https://visualstudio.microsoft.com/)了解更多关于这个软件的信息。
- en: '![CH01_F15_Hocking3](../Images/CH01_F15_Hocking3.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F15_Hocking3](../Images/CH01_F15_Hocking3.png)'
- en: Figure 1.15 Parts of the interface in Visual Studio
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15 Visual Studio界面的一部分
- en: NOTE If Unity opens a different IDE than Visual Studio, you may want to switch
    the External Tools preference. Go to Preferences > External Tools > External Script
    Editor to select an IDE.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果Unity打开的不是Visual Studio，你可能需要切换外部工具首选项。前往首选项 > 外部工具 > 外部脚本编辑器以选择一个IDE。
- en: NOTE Visual Studio organizes files into groupings called a *solution*. Unity
    automatically generates a solution that has all the script files, so you usually
    don’t need to worry about that.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Visual Studio将文件组织成称为“解决方案”的分组。Unity自动生成一个包含所有脚本文件的解决方案，所以你通常不需要担心这一点。
- en: Various flavors of Visual Studio are available (many programmers prefer Visual
    Studio Code), or you could use an IDE from a completely different company, like
    JetBrains Rider. Switching to a different IDE is as simple as going to External
    Tools in Unity’s preferences. I generally use Visual Studio for Mac, but you could
    use a different IDE and not have any problems following along with this book.
    Beyond this introductory chapter, I’m not going to talk about the IDE.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的Visual Studio版本有很多（许多程序员更喜欢Visual Studio Code），或者你可以使用来自不同公司的IDE，如JetBrains
    Rider。切换到不同的IDE就像在Unity的首选项中转到外部工具一样简单。我通常使用Visual Studio for Mac，但你可以使用不同的IDE，并且不会遇到任何问题来跟随这本书的内容。在本章介绍之后，我不会再谈论IDE。
- en: Always keep in mind that, although the code is written in Visual Studio, the
    code isn’t run there. The IDE is pretty much a fancy text editor, and the code
    is run when you click Play within Unity.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 总要记住，尽管代码是在Visual Studio中编写的，但代码并不是在那里运行的。IDE基本上是一个高级的文本编辑器，代码是在你点击Unity中的播放时运行的。
- en: '1.3.3 Printing to the console: Hello World!'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.3 打印到控制台：Hello World！
- en: All right, you already have an empty script in the project, but you also need
    an object in the scene to attach the script to. Recall figure 1.1 depicting how
    a component system works; a script is a component, so it needs to be set as one
    of the components on an object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你已经在项目中有一个空脚本了，但你还需要一个场景中的对象来附加脚本。回想一下图 1.1 描述的组件系统；脚本是一个组件，因此它需要被设置为对象上的组件之一。
- en: Choose GameObject > Create Empty, and a blank GameObject will appear in the
    Hierarchy list. Now drag the script from the Project view over to the Hierarchy
    view and drop it on the empty GameObject. As shown in figure 1.16, Unity will
    highlight valid places to drop the script, and dropping it on the GameObject will
    attach the script to that object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 GameObject > 创建空对象，一个空 GameObject 将出现在层次列表中。现在将脚本从项目视图拖动到层次视图，并将其放在空 GameObject
    上。如图 1.16 所示，Unity 将突出显示放置脚本的合法位置，并将脚本放在 GameObject 上会将其附加到该对象。
- en: '![CH01_F16_Hocking3](../Images/CH01_F16_Hocking3.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F16_Hocking3](../Images/CH01_F16_Hocking3.png)'
- en: Figure 1.16 How to link a script to a GameObject
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 如何将脚本链接到 GameObject
- en: 'To verify that the script is attached to the object, select the GameObject
    and look at the Inspector view. You should see two components listed: the Transform
    component, which is the basic position/rotation/scale component all objects have
    and which can’t be removed, and below that, your script.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证脚本是否已附加到对象，选择 GameObject 并查看检查器视图。你应该看到列出了两个组件：Transform 组件，这是所有对象都有的基本位置/旋转/缩放组件，且不能被移除，在其下方是你的脚本。
- en: NOTE Eventually, this action of dragging objects from one place and dropping
    them on other objects will feel routine. A lot of linkages in Unity, not only
    attaching scripts to objects, are created by dragging things on top of each other.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：最终，这种从一处拖动对象并将其放置到另一处的动作将变得习以为常。在 Unity 中，许多链接（不仅限于将脚本附加到对象）都是通过将对象拖放到彼此上方来创建的。
- en: When a script is linked to an object, you’ll see something like figure 1.17,
    with the script showing up as a component in the Inspector. Now the script will
    execute when you play the scene, although nothing is going to happen yet because
    you haven’t written any code. Let’s do that next!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本链接到对象时，你将看到如图 1.17 所示的内容，脚本在检查器中显示为一个组件。现在脚本将在你播放场景时执行，尽管目前还没有发生任何事情，因为你还没有编写任何代码。让我们接下来做这件事！
- en: '![CH01_F17_Hocking3](../Images/CH01_F17_Hocking3.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F17_Hocking3](../Images/CH01_F17_Hocking3.png)'
- en: Figure 1.17 Linked script being displayed in the Inspector
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17 在检查器中显示的链接脚本
- en: Double-click the script to open it and get back to listing 1.1\. The classic
    place to start when learning a new programming environment is having it print
    the text Hello World!, so add the line in the following listing inside the Start()
    method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 双击脚本以打开它并返回到列表 1.1。在学习新的编程环境时，最经典的做法是让它打印出“Hello World!”文本，因此请在以下列表中的 Start()
    方法内添加该行。
- en: Listing 1.2 Adding a console message
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.2 添加控制台消息
- en: '[PRE1]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Add the logging command here.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在此处添加日志命令。
- en: The Debug.Log() command prints a message to the Console view in Unity. Meanwhile,
    that line goes in the Start() method because, as was explained earlier, that method
    is called as soon as the object becomes active. Start() will be called once, as
    soon as you click Play in the editor. Once you’ve added the log command, save
    the script, click Play in Unity, and switch to the Console view. You’ll see the
    message Hello World! appear. Congratulations—you’ve written your first Unity script!
    Of course, the code will be more elaborate in later chapters, but this is an important
    first step.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Debug.Log() 命令会在 Unity 的控制台视图中打印一条消息。同时，该行代码会放入 Start() 方法中，因为，如前所述，该方法会在对象变为活动状态时立即被调用。点击编辑器中的播放后，Start()
    将被调用一次。一旦添加了日志命令，保存脚本，点击 Unity 中的播放，并切换到控制台视图。你会看到“Hello World!”消息出现。恭喜你——你已经编写了你的第一个
    Unity 脚本！当然，代码将在后面的章节中变得更加复杂，但这是一个重要的第一步。
- en: WARNING Always remember to save the file after making adjustments to a script!
    A pretty common mistake is to adjust the code and then immediately click Play
    in Unity without saving, resulting in the game still using the code from before
    you adjusted it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：始终记得在调整脚本后保存文件！一个相当常见的错误是在调整代码后立即点击 Unity 中的播放而不保存，导致游戏仍然使用你调整之前的代码。
- en: “Hello World!” steps in brief
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: “Hello World!” 简要步骤
- en: 'Let’s reiterate and summarize the steps from the last few pages:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重申并总结一下上一页的步骤：
- en: Create a new project.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目。
- en: Create a new C# script.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本。
- en: Create an empty GameObject.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空 GameObject。
- en: Drag the script onto the object.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本拖放到对象上。
- en: Add the log command to the script.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将日志命令添加到脚本中。
- en: Click Play!
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放！
- en: Now it’s time to save the scene; this creates a .unity file with the Unity icon.
    The scene file is a snapshot of everything currently loaded in the game so that
    you can reload this scene later. Saving this scene may hardly seem worthwhile
    because it’s so simple (a single empty GameObject)—but if you don’t save the scene,
    you’ll find it empty again when you come back to the project after quitting Unity.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是保存场景的时候了；这将创建一个带有Unity图标的.unity文件。场景文件是当前游戏中加载的所有内容的快照，这样你可以在以后重新加载这个场景。保存这个场景可能几乎看起来不值得，因为它如此简单（一个空的GameObject）——但如果你不保存场景，当你退出Unity后回到项目时，你会发现它又是空的。
- en: Errors in the script
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中的错误
- en: To see how Unity indicates errors, purposely put a typo in the HelloWorld script.
    For example, if you type an extra parenthesis symbol, an error message will appear
    in the Console tab with a red error icon.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Unity如何指示错误，故意在HelloWorld脚本中输入一个拼写错误。例如，如果你输入了一个多余的括号符号，错误信息将在控制台标签页中显示一个红色的错误图标。
- en: '![CH01_UN01_Hocking3](../Images/CH01_UN01_Hocking3.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_UN01_Hocking3](../Images/CH01_UN01_Hocking3.png)'
- en: A script error being displayed in the Console tab
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台标签页中显示的脚本错误
- en: 'Get used to reading these error messages, because this will be your main way
    of solving problems in your code. Notice how the message is structured: it first
    indicates which file has the error, then shows a line number within that file,
    and finally provides a description of the error that occurred.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯于阅读这些错误信息，因为这将是你解决代码中问题的主要方式。注意信息的结构：它首先指出哪个文件有错误，然后显示该文件中的行号，最后提供发生错误的描述。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Unity is a multiplatform development tool.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity是一个多平台开发工具。
- en: Unity’s visual editor has several sections that work in concert.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity的视觉编辑器有几个部分协同工作。
- en: Scripts are attached to objects as components.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本作为组件附加到对象上。
- en: Code is written inside scripts by using Visual Studio.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Visual Studio在脚本中编写代码。
