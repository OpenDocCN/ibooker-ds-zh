- en: 2 Containerizing apps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 容器化应用程序
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: How to containerize apps
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何容器化应用程序
- en: Running your container locally
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地运行您的容器
- en: Executing commands in the container context
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器上下文中执行命令
- en: Containerizing your application—that is, packaging your application and its
    dependencies into an executable container—is a required step before adopting Kubernetes.
    The good news is that containerizing your application has benefits beyond being
    able to deploy it into Kubernetes; it’s a valuable step in its own right, as you’re
    packaging the application’s dependencies and can then run it anywhere without
    needing to install those dependencies on the host machine.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序容器化——即，将应用程序及其依赖项打包到可执行容器中——在采用Kubernetes之前是一个必要的步骤。好消息是，容器化应用程序的好处不仅在于能够将其部署到Kubernetes中；它本身就是一个有价值的步骤，因为您正在打包应用程序的依赖项，然后可以在任何地方运行它，而无需在主机机器上安装这些依赖项。
- en: Regardless of how you deploy your app, containerizing it means that your developers
    can begin working on it locally using Docker, enabling them to get started on
    a new project with no setup beyond installing Docker. It provides easy context
    switching between the different applications developers are working on, as the
    environments are completely isolated (figure 2.1). These properties make it a
    valuable way to improve developer productivity even if you don’t end up deploying
    your app into production with containers (although you’ll probably want to do
    that, too).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您如何部署您的应用程序，将其容器化意味着您的开发人员可以使用Docker在本地开始工作，使他们能够在不进行除安装Docker之外任何设置的情况下开始新的项目。它提供了在不同应用程序之间轻松切换环境，因为环境是完全隔离的（见图2.1）。即使您最终没有使用容器将应用程序部署到生产环境中，这些特性也使其成为提高开发者生产力的宝贵方式（尽管您可能也希望这样做）。
- en: '![02-01](../../OEBPS/Images/02-01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![02-01](../../OEBPS/Images/02-01.png)'
- en: Figure 2.1 Comparison of multiple projects on a development machine with and
    without containerization
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 比较开发机器上容器化和非容器化多个项目
- en: Having your application packaged into containers means that all your dependencies
    and configurations are captured by a container configuration file—the Dockerfile—rather
    than a mix of bash scripts, text-based instructions, human memory, and other nonstandard
    configuration systems. It makes it possible to deploy multiple applications on
    a single host machine without worrying that they will interfere with each other
    but with greater performance and less overhead than full virtualization.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的应用程序打包到容器中意味着所有依赖项和配置都由容器配置文件——Dockerfile——捕获，而不是由bash脚本、基于文本的指令、人类记忆和其他非标准配置系统混合而成。这使得在单个主机机器上部署多个应用程序成为可能，无需担心它们会相互干扰，并且比完整虚拟化具有更高的性能和更低的开销。
- en: 2.1 Building Docker containers
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 构建Docker容器
- en: Let’s take an application and put it in a container.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿一个应用程序并将其放入容器中。
- en: 2.1.1 Developer setup
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 开发者设置
- en: Docker is distributed as a developer tool that is available for most platforms
    as Docker Desktop ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)),
    which includes some convenient utilities such as a local Kubernetes environment
    (covered in chapter 3). For Linux (including Windows Subsystem for Linux [WSL]),
    you can also install the Docker Engine standalone.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Docker作为一种开发者工具，可在大多数平台上使用Docker Desktop([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop))进行分发，其中包含一些方便的实用工具，例如本地Kubernetes环境（在第3章中介绍）。对于Linux（包括Windows
    Subsystem for Linux [WSL]），您还可以单独安装Docker Engine。
- en: Mac
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Mac
- en: On Mac, simply install Docker Desktop.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，只需安装Docker Desktop。
- en: Windows
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Windows
- en: On Windows, I highly recommend first configuring the WSL ([https://learn.microsoft.com/en-us/windows/wsl/install](https://learn.microsoft.com/en-us/windows/wsl/install)).
    WSL 2 is the one you want so that Docker can use it as well. With WSL 2 installed,
    you can also install a distribution of Linux like Ubuntu ([http://mng.bz/pP40](http://mng.bz/pP40)),
    which gives you a bash shell and is a convenient way to run the samples presented
    in this section. Once WSL is configured, install Docker Desktop.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，我强烈建议首先配置WSL([https://learn.microsoft.com/en-us/windows/wsl/install](https://learn.microsoft.com/en-us/windows/wsl/install))。您需要的是WSL
    2，这样Docker才能使用它。安装了WSL 2后，您还可以安装Linux的发行版，如Ubuntu([http://mng.bz/pP40](http://mng.bz/pP40))，它提供了一个bash
    shell，并且是运行本节中展示的示例的便捷方式。一旦配置了WSL，安装Docker Desktop。
- en: Linux
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Linux
- en: 'For Linux, there is another option in addition to Docker Desktop—the Docker
    Engine. You can find instructions for various platforms, including Ubuntu, here:
    [https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/).
    Docker Engine is also an option when you use Linux via WSL.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux，除了Docker Desktop之外，还有一个选项——Docker Engine。你可以在这里找到各种平台（包括Ubuntu）的说明：[https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/)。当你通过WSL使用Linux时，Docker
    Engine也是一个选项。
- en: 2.1.2 Running commands in Docker
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 在Docker中运行命令
- en: 'To explore how Docker works before we build our own application container,
    we can bring up a containerized Linux shell in Docker, like so:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建自己的应用程序容器之前，为了探索Docker的工作原理，我们可以在Docker中启动一个容器化的Linux shell，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This downloads the base `ubuntu` image, starts a container, and runs the bash
    command against it. The `-it` parameters make it an interactive bash terminal.
    Now we are in the container, and anything we run will happen in the container.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载基础`ubuntu`镜像，启动一个容器，并对其运行bash命令。`-it`参数使其成为一个交互式bash终端。现在我们已经在容器中，我们运行的任何东西都会在容器中发生。
- en: Since we’re going to be building an application on Ubuntu, let’s install the
    language package. I’m going to be using Python for many of the examples in this
    chapter, but the concept applies equally to any other language.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在Ubuntu上构建应用程序，让我们安装语言包。我将在本章的许多示例中使用Python，但这个概念同样适用于任何其他语言。
- en: 'Run the following two commands in the container shell:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器shell中运行以下两个命令：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we can try out Python interactively, for example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试交互式地运行Python，例如：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can capture this most basic of commands into our own Python script:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个最基本的命令捕获到我们自己的Python脚本中：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you’re done playing around in this container, exit using `exit`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在容器中玩够了，使用`exit`退出。
- en: 'The beauty of this is that we installed Python and ran our Python command on
    the container, not on our local system. The Docker `run` command actually created
    a *container*, from our *image*. The image, `ubuntu`, is a prebuilt filesystem
    from which the container process runs in. When we exit our interactive session
    with the container, it will be stopped, but you can easily start it up again using
    `docker` `ps` `-a` to get the container ID, `docker` `start` `$CONTAINER_ID` to
    boot it, and `docker` `attach` `$CONTAINER_ID` to reconnect our shell:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这的好处是我们在容器中安装了Python并运行了我们的Python命令，而不是在本地系统中。Docker的`run`命令实际上创建了一个*容器*，从我们的*镜像*中。镜像`ubuntu`是一个预先构建的文件系统，容器进程在其中运行。当我们退出与容器的交互会话时，它将被停止，但你可以很容易地再次启动它，使用`docker`
    `ps` `-a`获取容器ID，`docker` `start` `$CONTAINER_ID`来启动它，以及`docker` `attach` `$CONTAINER_ID`来重新连接我们的shell：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After running a lot of Docker containers, you’ll end up with a pretty big list
    of stopped containers (and lots of hard drive space used). To clean up these images,
    which typically you don’t need to keep, at any time, run:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行了很多Docker容器后，你最终会得到一个相当大的停止容器列表（以及大量的硬盘空间被使用）。为了清理这些通常不需要保留的镜像，在任何时候，运行：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Container image vs. container instance
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像与容器实例
- en: In Docker terminology, the container *image* is the file artifact (whether downloaded
    from a registry as in this section or built locally), and the container instance
    (or just container) is an invocation of the container. In Kubernetes, configuration
    refers only to images, while container instances are created at run time and are
    ephemeral in nature (they are deleted when the Pod is stopped). When using Docker
    locally, the instance concept is important, not least because every invocation
    creates a container instance that persists, so eventually you’ll need to clean
    them up to recover the disk space.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker术语中，容器*镜像*是文件工件（无论是从本节中提到的注册表中下载，还是本地构建），而容器实例（或简称容器）是容器的调用。在Kubernetes中，配置仅指镜像，而容器实例在运行时创建，并且是短暂的（当Pod停止时它们会被删除）。在本地使用Docker时，实例概念很重要，因为每次调用都会创建一个持久化的容器实例，所以最终你需要清理它们以恢复磁盘空间。
- en: With these steps, we now have a Linux environment, which we can use for testing
    and running random commands, all without needing to install anything (beyond Docker)
    on our local machine. Want two Linux container environments with a different config?
    No worries—just run another container!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们现在拥有了一个Linux环境，我们可以用它来测试和运行随机命令，而无需在我们的本地机器上安装任何东西（除了Docker）。想要两个配置不同的Linux容器环境？不用担心——只需运行另一个容器！
- en: If you’ve ever set up a virtual machine (VM) before, you’ll appreciate just
    how fast this is to set up! Containers are simple to create. As you’ll see in
    the next section, they are also easy to build on and expand.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前曾经设置过虚拟机（VM），您将非常欣赏设置速度有多快！容器易于创建。正如您将在下一节中看到的那样，它们也易于构建和扩展。
- en: 2.1.3 Building our own images
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 构建我们自己的镜像
- en: In the previous section, we started a Linux container, installed Python, and
    created a simple Python script, which we ran in the container. Let’s say we want
    to make this repeatable. That is, we want to capture the configuration of the
    container (installing Python) and our application (the Python script) in our own
    container image. Such an image would be useful so we don’t have to remember the
    steps we took and also so that others can build our amazing application!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们启动了一个Linux容器，安装了Python，并创建了一个简单的Python脚本，我们在容器中运行了这个脚本。假设我们想要使其可重复。也就是说，我们想要在我们的容器镜像中捕获容器的配置（安装Python）和我们的应用程序（Python脚本）。这样的镜像非常有用，这样我们就不必记住我们采取的步骤，而且其他人也可以构建我们的神奇应用程序！
- en: While this example uses only a simple Python script, you can imagine that the
    application can be as large and complex as you want to make it. It doesn’t just
    have to be Python either; these steps work for any interpreted language (see section
    2.1.7 for how to deal with compiled applications). Just substitute the Python
    configuration for whatever language you are using.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个示例只使用了简单的Python脚本，但您可以想象应用程序可以变得多大和多复杂，您想要让它变得多大。它不仅限于Python；这些步骤适用于任何解释型语言（有关如何处理编译应用程序的说明，请参阅2.1.7节）。只需将Python配置替换为您使用的任何语言即可。
- en: The process of building our container image so we can make a repeatable application
    deployment uses a configuration file known as a Dockerfile. The Dockerfile is
    a set of procedural instructions used to build your container. Think of it like
    a bash script that configures a VM image with your app and its dependencies; only
    the output is a container image.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 构建我们的容器镜像以便进行可重复的应用程序部署的过程使用一个名为Dockerfile的配置文件。Dockerfile是一组用于构建容器的程序性指令。将其想象成一个配置带有你的应用程序及其依赖项的虚拟机镜像的bash脚本；只是输出是一个容器镜像。
- en: Running the examples
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'The example Docker applications and Kubernetes configuration listed in this
    book can be found in the source repository. Clone the repository and change into
    the root directory with the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本书列出的示例Docker应用程序和Kubernetes配置可以在源代码库中找到。克隆仓库并切换到根目录，如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The examples are arranged by chapter and section. For example, the code from
    chapter 2 is in a folder named Chapter02, and the examples from section 2.1.3
    are in folder 2.1.3_Dockerfile. Each code listing includes the path to the sample
    file so you can locate it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 示例按章节和节进行排列。例如，第2章的代码在名为Chapter02的文件夹中，第2.1.3节的示例在2.1.3_Dockerfile文件夹中。每个代码列表都包括样本文件的路径，以便您可以找到它。
- en: The shell commands given start from the root sample code folder (`kubernetes-for-developers`,
    if you cloned the repo per the previous command), so just change back to that
    directory after running any example or exploring the code, and you should be ready
    to pick up where you left off and follow the next example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 给出的shell命令从根样本代码文件夹（`kubernetes-for-developers`，如果您按照之前的命令克隆了仓库）开始，所以在运行任何示例或探索代码后，只需切换回该目录，您就应该准备好继续您离开的地方并跟随下一个示例。
- en: We’ll start with the basic Python program we created in the previous section,
    as shown in the following listing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上一节中创建的基本Python程序开始，如下所示。
- en: Listing 2.1 Chapter02/2.1.3_Dockerfile/hello.py
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 Chapter02/2.1.3_Dockerfile/hello.py
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To build a container image for this script, you’ll need to create a Dockerfile,
    pick a base container image to use as the starting point, configure Python, and
    add the program. For now, we’ll start with the generic base image `ubuntu`, which
    provides a containerized Linux environment. The following listing shows a basic
    Dockerfile to capture these steps.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要为这个脚本构建一个容器镜像，你需要创建一个Dockerfile，选择一个基础容器镜像作为起点，配置Python，并添加程序。目前，我们将从通用的基础镜像`ubuntu`开始，它提供了一个容器化的Linux环境。以下列表显示了一个基本的Dockerfile来捕获这些步骤。
- en: Listing 2.2 Chapter02/2.1.3_Dockerfile/Dockerfile
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 Chapter02/2.1.3_Dockerfile/Dockerfile
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Specifies the base container image
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指定基础容器镜像
- en: ❷ Configures our environment
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 配置我们的环境
- en: ❸ Copies the app to the container
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将应用程序复制到容器中
- en: ❹ Sets the current working directory
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 设置当前工作目录
- en: 'Build this container and name (tag) it `hello`, like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 构建这个容器，并将其命名为（标记为）`hello`，如下所示：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once built, we can run the `python3` `hello.py` command on the container named
    `hello`, like so:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成，我们就可以在名为`hello`的容器上运行`python3 hello.py`命令，如下所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how the commands in our Dockerfile are essentially the same as the ones
    we used in the previous section. Rather than starting the `ubuntu` container image
    directly, we use it as our base image of the Dockerfile. Then we run the same
    two `apt-get` commands as before to install Python, copy our Python script into
    the image, and specify the default working directory to indicate where commands
    will be run. Also, notice that the command to run the code is still `python3`
    `hello.py`; it’s just now prefixed to run in our new container image.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们Dockerfile中的命令与上一节中使用的命令基本相同。我们不是直接启动`ubuntu`容器镜像，而是将其用作Dockerfile的基础镜像。然后我们运行与之前相同的两个`apt-get`命令来安装Python，将我们的Python脚本复制到镜像中，并指定默认工作目录以指示命令将运行的位置。此外，请注意，运行代码的命令仍然是`python3
    hello.py`；只是现在它被添加了前缀以在新的容器镜像中运行。
- en: We’ve now encapsulated the environment we built and our script into a neat package
    that we can use and run ourselves and share with others. The wonderful thing about
    containers is that they encapsulate the configuration steps along with the program
    itself. The best part is that when the `ubuntu` base image is updated, we can
    rebuild our image by simply running that one `build` command again.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将构建的环境和我们的脚本封装到一个整洁的包中，我们可以自己使用和运行，也可以与他人分享。容器最奇妙的地方在于它们封装了配置步骤以及程序本身。最好的部分是，当`ubuntu`基础镜像更新时，我们只需再次运行那个`build`命令就可以重新构建我们的镜像。
- en: Compare this to installing Python on your developer machine and running everything
    locally. For one, if you’d done that, you would now have Python installed. You
    probably would be happy to have Python installed, but imagine a more complex application
    that brings with it dozens of tools and libraries. Do you really want all these
    on your system? Furthermore, what if you’re developing a few different applications,
    all with their own dependencies or with the same dependency but requiring particular
    versions of that dependency, making it impossible to satisfy the dependencies
    of both applications simultaneously (a situation sometimes referred to as “dependency
    hell”)?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与在你的开发机器上安装Python并本地运行所有内容进行比较。首先，如果你那样做了，现在Python就已经安装了。你可能会很高兴Python已经安装，但想象一个更复杂的应用程序，它带来了数十个工具和库。你真的想在你的系统上安装所有这些吗？此外，如果你正在开发几个不同的应用程序，每个应用程序都有自己的依赖项，或者有相同的依赖项但需要特定版本的依赖项，使得同时满足两个应用程序的依赖项变得不可能（这种情况有时被称为“依赖地狱”）？
- en: Containers solve this by isolating applications along with their dependencies
    in their own container images. You can happily work on multiple projects, share
    Dockerfiles with your development team, and upload container images to your production
    environment without messing up your developer machine.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通过在各自的容器镜像中隔离应用程序及其依赖项来解决这个问题。你可以愉快地在多个项目中工作，与你的开发团队共享Dockerfile，并将容器镜像上传到你的生产环境，而不会弄乱你的开发机器。
- en: For a different language, like Ruby, the setup is fairly similar, as shown in
    the following two listings.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像Ruby这样的不同语言，设置相当相似，如下面的两个列表所示。
- en: Listing 2.3 Chapter02-ruby/2.1.3_Dockerfile/hello.rb
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 Chapter02-ruby/2.1.3_Dockerfile/hello.rb
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Listing 2.4 Chapter02-ruby/2.1.3_Dockerfile/Dockerfile
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 Chapter02-ruby/2.1.3_Dockerfile/Dockerfile
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To run, the only difference is the command that is passed:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，唯一的区别是传递的命令：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 2.1.4 Using base images
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 使用基础镜像
- en: The previous section uses the Linux container `ubuntu` as a base to configure
    our Linux-based app. Base images, including `ubuntu` and other distributions such
    as `centos` and the `alpine`, are a good starting point for configuring any Linux-based
    app. However, for convenience, the container community has created several more-specific
    images designed for various languages and environments.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节使用Linux容器`ubuntu`作为基础来配置我们的基于Linux的应用。基础镜像，包括`ubuntu`和其他如`centos`和`alpine`等发行版，是配置任何基于Linux应用的良好起点。然而，为了方便，容器社区已经创建了几个更具体的镜像，这些镜像针对各种语言和环境进行了设计。
- en: Instead of installing Python ourselves onto the `ubuntu` base image, we can
    just start with the `python` image and save some steps. The added bonus is that
    these base images are generally created by experts and thus are well-configured
    to run Python apps. The following listing shows the same container but starting
    with the `python` base image.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要自己将 Python 安装到`ubuntu`基础镜像中，我们可以直接从`python`镜像开始，并节省一些步骤。额外的优势是，这些基础镜像通常由专家创建，因此它们配置良好，可以运行
    Python 应用程序。以下列表显示了相同的容器，但以`python`基础镜像开始。
- en: Listing 2.5 Chapter02/2.1.4_BaseImage/Dockerfile
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 第二章/2.1.4_BaseImage/Dockerfile
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Simpler, right? Building and running it is the same as before:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单吗？构建和运行与之前相同：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What is a base image, really?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 究竟什么是基础镜像？
- en: The base image used in this example*,* `python`*,* is itself built with a Dockerfile
    and configures an environment with everything needed to run Python programs. For
    container images from Docker Hub, their Dockerfile sources are linked so you can
    see how they are composed. Base images often start with another base image, and
    so on, until one that starts with a completely empty container known as `scratch`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中使用的*基础镜像*，*python*，*实际上是通过 Dockerfile 构建的，并配置了一个包含运行 Python 程序所需所有内容的运行环境。对于来自
    Docker Hub 的容器镜像，它们的 Dockerfile 源代码是链接的，这样你可以看到它们是如何组成的。基础镜像通常以另一个基础镜像开始，以此类推，直到一个以完全空容器`scratch`开始的镜像。
- en: If you’re using Ruby instead of Python, setup is pretty similar. Just use the
    `ruby` base image, as shown in the following two listings.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Ruby 而不是 Python，设置相当类似。只需使用`ruby`基础镜像，如下面的两个列表所示。
- en: Listing 2.6 Chapter02-ruby/2.1.4_BaseImage/hello.rb
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 第二章-ruby/2.1.4_BaseImage/hello.rb
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Listing 2.7 Chapter02-ruby/2.1.4_BaseImage/Dockerfile
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 第二章-ruby/2.1.4_BaseImage/Dockerfile
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To build and run:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: More than just operation system and language-specific base images exist. If
    you’re using an environment like Apache, you can start with the `httpd` base image.
    Sometimes you’ll have a situation where there are multiple base images that could
    serve as the base. The best rule of thumb is to pick the one that saves you the
    most configuration (and you can always crib from the Dockerfile of the one you
    didn’t pick!).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅存在操作系统和语言特定的基础镜像。如果你使用的是 Apache 这样的环境，你可以从`httpd`基础镜像开始。有时你可能会遇到多个可以作为基础镜像的情况。最好的经验法则是选择可以节省最多配置的镜像（你总是可以从未选择的镜像的
    Dockerfile 中借鉴！）。
- en: Base images—or at least public examples that you can copy—exist for pretty much
    every common language, environment, and open source application. Before building
    your own from scratch, it is wise to search Docker Hub or Google for a base image
    to see if someone has an example for your environment that you can use as a starting
    point.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基础镜像——或者至少你可以复制的公共示例——几乎为每种常见的语言、环境和开源应用程序都存在。在从头开始构建自己的镜像之前，明智的做法是在 Docker
    Hub 或 Google 中搜索基础镜像，看看是否有人为你所在的环境提供了一个可以使用的示例，作为起点。
- en: 2.1.5 Adding a default command
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.5 添加默认命令
- en: Typically, the command executed in the container (`python3` `hello.py` in the
    earlier Python example) is the same each time. Rather than repeating it each time,
    you can specify that in the Dockerfile as well.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在容器中执行的命令（在之前的 Python 示例中为`python3 hello.py`）每次都是相同的。你可以在 Dockerfile 中指定它，而不是每次都重复它。
- en: Listing 2.8 Chapter02/2.1.5_DefaultCommand/Dockerfile
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.8 第二章/2.1.5_DefaultCommand/Dockerfile
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To build and run this container, execute the following from the command line:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和运行此容器，请在命令行中执行以下操作：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Unlike the other lines in the Dockerfile we’ve used so far, `CMD` is unique
    as it doesn’t actually change *how* the container is built. It merely saves the
    default command that will be executed if you call `docker` `run` without a command
    specified. This doesn’t stop you from overriding it and executing a different
    command at run time. With the command now specified in the Dockerfile, to build
    and run the Ruby version of this program, it is also simply `docker` `run` `$IMAGE_NAME`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前在 Dockerfile 中使用的其他行不同，`CMD`是独特的，因为它实际上并不改变容器构建的*方式*。它只是保存了在没有指定命令的情况下调用`docker
    run`时将执行的默认命令。这并不会阻止你覆盖它并在运行时执行不同的命令。现在命令已在 Dockerfile 中指定，要构建和运行此程序的 Ruby 版本，也只需简单地`docker
    run $IMAGE_NAME`：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 2.1.6 Adding dependencies
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.6 添加依赖项
- en: Most nontrivial applications will have their own dependencies not included in
    the base image. To load those dependencies, you can run commands during the container
    build process to configure the image as you need. This was how we added Python
    to the Linux base image in the previous example, and this method can be used to
    install all the dependencies that your application needs. If your application
    establishes a database connection to a MariaDB database, you might build your
    container as in the following listing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数非平凡的应用程序都将有自己的依赖项，这些依赖项不包括在基础镜像中。为了加载这些依赖项，你可以在容器构建过程中运行命令来配置镜像，以满足你的需求。这就是我们在前面的示例中向
    Linux 基础镜像添加 Python 的方法，这种方法可以用来安装应用程序需要的所有依赖项。如果你的应用程序连接到 MariaDB 数据库，你可能构建的容器如下所示。
- en: Listing 2.9 Chapter02/2.1.6_Dependencies/Dockerfile
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.9 第二章/2.1.6_依赖项/Dockerfile
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Use apt-get to configure your Linux container with everything your app needs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 apt-get 配置你的 Linux 容器，使其包含你的应用程序所需的一切。
- en: The `python` base image is built from Debian, a distribution of Linux widely
    used for containers, which uses the apt-get package manager, so we can use `apt-get`
    to install pretty much any other dependency we need.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`python` 基础镜像是从 Debian 构建的，Debian 是广泛用于容器的 Linux 发行版，它使用 apt-get 软件包管理器，因此我们可以使用
    `apt-get` 安装我们需要的几乎所有其他依赖项。'
- en: You don’t just have to use `apt-get` either. Say you have a service that’s creating
    PDF files, and you need to include a Unicode font. You can build an image that
    includes Google’s Noto free font, like in the following listing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不一定只能使用 `apt-get`。比如说，你有一个创建 PDF 文件的服务，你需要包含一个 Unicode 字体。你可以构建一个包含 Google
    的 Noto 免费字体的镜像，如下面的列表所示。
- en: Listing 2.10 Chapter02/2.1.6_Dependencies-2/Dockerfile
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10 第二章/2.1.6_依赖项-2/Dockerfile
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Installs bsdtar
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安装 bsdtar
- en: ❷ Creates a new directory and changes into it. Notice how multiple commands
    can be combined on one line.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个新的目录并切换到它。注意如何在同一行上组合多个命令。
- en: ❸ Downloads the font package and extracts it
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 下载字体包并提取它
- en: ❹ Installs the fonts
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 安装字体
- en: It is common for containers to have many dependencies, and you can configure
    any part of the operating system you need to in this way, such as installing fonts
    or TLS certificates.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通常有许多依赖项，你可以以这种方式配置操作系统的任何部分，例如安装字体或 TLS 证书。
- en: 2.1.7 Compiling code in Docker
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.7 在 Docker 中编译代码
- en: What about programs that need compilation, like Java, .NET, Swift, and C++?
    Obviously, a `COPY` command will not suffice in the Dockerfile, unless you already
    have compiled binaries lying around.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要编译的程序，如 Java、.NET、Swift 和 C++，怎么办？显然，在 Dockerfile 中仅使用 `COPY` 命令是不够的，除非你已经有现成的编译二进制文件。
- en: Precompiling the application locally would be one option, but why not use Docker
    to compile your application as well! Let’s re-implement our “Hello World” example
    in Java and compile it into our container, as shown in the following two listings.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地预编译应用程序是一个选项，但为什么不使用 Docker 来编译你的应用程序呢！让我们重新实现我们的“Hello World”示例，用 Java 编写并编译到我们的容器中，如下面的两个列表所示。
- en: Listing 2.11 Chapter02/2.1.7_CompiledCode/Hello.java
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.11 第二章/2.1.7_编译代码/Hello.java
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Listing 2.12 Chapter02/2.1.7_CompiledCode/Dockerfile
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.12 第二章/2.1.7_编译代码/Dockerfile
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ The compile command
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 编译命令
- en: 'This Dockerfile is similar to the previous ones: we start with the OpenJDK
    (`openjdk)` base image and copy the app. In this case, however, we’ll use the
    `RUN` command to build the app, prefaced with a `WORKDIR` directive to specify
    where this action (and subsequent actions) should be performed.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Dockerfile 与之前的类似：我们以 OpenJDK (`openjdk`) 基础镜像开始，并复制应用程序。然而，在这种情况下，我们将使用
    `RUN` 命令来构建应用程序，前面加上一个 `WORKDIR` 指令来指定这个操作（以及随后的操作）应该在哪里执行。
- en: 'To build and run this example, do the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和运行此示例，请执行以下操作：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Another example that compiles a server-side Swift application is given in the
    Chapter02-swift/2.1.7_CompiledCode folder. It can be built and run in the same
    way.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例在第二章-swift/2.1.7_编译代码文件夹中，它可以用相同的方式构建和运行。
- en: 2.1.8 Compiling code with a multistage build
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.8 使用多阶段构建编译代码
- en: Using `RUN` to compile code or perform other actions is a viable path; however,
    the drawback is that you end up configuring your container image with tools it
    needs to execute the `RUN` command. These tools end up in the final container
    image along with any source code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `RUN` 来编译代码或执行其他操作是一个可行的途径；然而，缺点是最终你会在容器镜像中配置所需的工具来执行 `RUN` 命令。这些工具最终会与任何源代码一起出现在最终的容器镜像中。
- en: For example, if you look at the image we created in the previous section and
    run `ls`,
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你查看上一节中创建的镜像并运行`ls`，
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: you’ll see that the source code remains. Also, the Java compiler (`javac`) is
    still present in the image, even though it will never be used again (we don’t
    need the compiler when running our application).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到源代码仍然存在。此外，Java编译器（`javac`）仍然存在于镜像中，即使它将不再被使用（我们在运行应用程序时不需要编译器）。
- en: This mixing of responsibilities of the container image—to both build and run—is
    less than ideal. Not only do all those extra binaries bloat the container image,
    but they also needlessly increase the attack surface area of the container (as
    any process running in the container now has a compiler to work with). You could
    clean up the container with a bunch of additional Docker commands (e.g., deleting
    the source code, uninstalling tools that are no longer needed), but it’s not always
    practical, particularly if all these extra tools came from the base image.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将容器镜像的责任混合在一起——既用于构建又用于运行——并不是最佳选择。这不仅让所有额外的二进制文件膨胀了容器镜像，还无谓地增加了容器的攻击面（因为现在容器中运行的任何进程都有一个编译器可用）。你可以使用一些额外的Docker命令（例如，删除源代码，卸载不再需要的工具）来清理容器，但这并不总是实用的，尤其是如果所有这些额外的工具都来自基础镜像。
- en: A better way to solve this problem is to use a multistage container build (figure
    2.2). With a multistage build, we first configure a temporary container with everything
    needed to *build* the program, and then we configure a final container with everything
    needed to *run* the program. This keeps the concerns separated and neatly isolated
    to their own containers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的更好方法是使用多阶段容器构建（图2.2）。使用多阶段构建，我们首先配置一个临时容器，其中包含构建程序所需的一切，然后我们配置一个最终容器，其中包含运行程序所需的一切。这保持了关注点的分离，并将它们干净利落地隔离到各自的容器中。
- en: '![02-02](../../OEBPS/Images/02-02.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![02-02](../../OEBPS/Images/02-02.png)'
- en: Figure 2.2 A multistage container build, where an intermediate container is
    used to build the binary
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 多阶段容器构建，其中使用了一个中间容器来构建二进制文件
- en: Let’s rework the example in the previous section to be built using a multistage
    Dockerfile.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新整理上一节中的示例，使其使用多阶段Dockerfile进行构建。
- en: Listing 2.13 Chapter02/2.1.8_MultiStage/Dockerfile
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.13 Chapter02/2.1.8_MultiStage/Dockerfile
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ The build container is named buildstage and has the responsibility to build
    the code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建容器被命名为buildstage，其责任是构建代码。
- en: ❷ The runtime container uses a slimmed-down base image, without the compile
    tools
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 运行时容器使用了一个精简的基础镜像，没有包含编译工具
- en: ❸ --from= is used to reference files from the build container.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用`--from=`来引用构建容器中的文件。
- en: As you can see from this example, there are what looks like two Dockerfiles
    in one (each beginning with a `FROM` command). The first is configured and built
    purely to compile the app, using the full `openjdk` base image, which includes
    the Java compiler, and the second has only what is needed to run the app and is
    built from the `jre` base image, which only includes the Java Runtime Environment.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个示例中可以看出，似乎有一个Dockerfile中包含了两个（每个都以`FROM`命令开始）。第一个配置和构建纯粹是为了编译应用程序，使用完整的`openjdk`基础镜像，其中包含Java编译器，而第二个只包含运行应用程序所需的内容，并从`jre`基础镜像构建，该镜像只包含Java运行时环境。
- en: This Dockerfile produces, as its final artifact, a production container that
    only contains the compiled Java class and dependencies needed to run it. The intermediate
    artifact of the first container that built the app is effectively discarded after
    the build completes (technically, it’s saved in your docker cache, but no part
    is included in the final artifact that you would use in production).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Dockerfile产生的最终产物是一个生产容器，它只包含编译后的Java类和运行它所需的依赖项。构建应用程序的第一个容器的中间产物在构建完成后实际上被丢弃（技术上，它被保存在你的docker缓存中，但没有任何部分包含在最终产物中，你会在生产中使用）。
- en: 'To run this example, do the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，请执行以下操作：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we run the `ls` command on this new container, we can see that there is
    only the compiled code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这个新的容器上运行`ls`命令，我们可以看到其中只有编译后的代码：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Another example that compiles a server-side Swift application with the multistage
    build process is given in the Chapter02-swift/2.1.8_MultiStage folder. It can
    be built and run in the same way.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chapter02-swift/2.1.8_MultiStage文件夹中给出了另一个示例，它使用多阶段构建过程编译服务器端Swift应用程序。它可以以相同的方式构建和运行。
- en: 2.2 Containerizing a server application
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 服务器应用程序的容器化
- en: The examples in the previous section were all simple programs that run once
    then exit. This is a use case for containers such as command-line programs and
    batch workloads or even to serve requests in a functions-as-a-service environment.
    One of the most common workloads to deploy in Kubernetes, however, is HTTP services—that
    is, an application that listens for and processes incoming requests (i.e., a web
    server).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的示例都是一些运行一次然后退出的简单程序。这是一个适用于命令行程序、批处理工作负载，甚至在函数即服务环境中处理请求的容器用例。然而，在Kubernetes中部署的最常见工作负载之一是HTTP服务——也就是说，一个监听并处理传入请求的应用程序（即一个网络服务器）。
- en: A server application is no different from any other application from Docker’s
    perspective. There are a few differences in how you start and connect to the container,
    owing to the fact that you likely want to keep the container running (so it can
    serve requests). You’ll also likely want to forward ports from your local machine
    so you can connect to it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从Docker的角度来看，服务器应用程序与其他任何应用程序没有区别。由于你很可能希望容器持续运行（以便它可以处理请求），因此在启动和连接到容器的方式上可能有一些差异。你很可能还希望从你的本地机器转发端口，以便你可以连接到它。
- en: 2.2.1 Containerizing an application server
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 容器化应用程序服务器
- en: Until now, the example program has been a basic “Hello World” Python script.
    To demonstrate how to containerize HTTP servers, we’ll need something that is
    an HTTP server! Listing 2.14 is an example of a bare-bones HTTP server in Python
    that returns the current date and time. Don’t worry too much about the code itself.
    This book is language agnostic, and the Python used here is purely an example.
    You can apply these principles to any HTTP server.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，示例程序一直是一个基本的“Hello World”Python脚本。为了演示如何容器化HTTP服务器，我们需要一个实际上是HTTP服务器的例子！列表2.14是一个Python中裸骨HTTP服务器的示例，它返回当前的日期和时间。不必太担心代码本身。这本书是语言无关的，这里使用的Python纯粹是一个例子。你可以将这些原则应用到任何HTTP服务器上。
- en: Listing 2.14 Chapter02/timeserver/server.py
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.14 Chapter02/timeserver/server.py
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Containerizing this server application is very similar to the earlier command-line
    program as follows.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化这个服务器应用程序与早期的命令行程序非常相似，如下所示。
- en: Listing 2.15 Chapter02/timeserver/Dockerfile
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.15 Chapter02/timeserver/Dockerfile
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Containerizing your own application
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化自己的应用程序
- en: 'If you’re containerizing your own application, follow these generic steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在容器化自己的应用程序，请遵循以下通用步骤：
- en: Find an ideal base image that provides as much of your configuration as possible.
    For a Ruby on Rails app, start with `ruby` and not the more generic `ubuntu`.
    For Django, use `python`, and so on.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个理想的基镜像，尽可能多地提供你的配置。对于一个Ruby on Rails应用程序，从`ruby`开始，而不是更通用的`ubuntu`。对于Django，使用`python`，依此类推。
- en: Configure any application-specific dependencies you need (via `RUN` statements,
    as we did previously).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置任何你需要的应用程序特定依赖项（通过`RUN`语句，就像我们之前做的那样）。
- en: Copy your application.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制你的应用程序。
- en: I find that Google search is really your friend for this. Unless you’re doing
    something new and exotic, someone’s probably figured out and shared an example
    Dockerfile of how to configure an application using your framework. If you’re
    using a popular framework like Django, Ruby on Rails, WordPress, Node.JS, or SpringBoot
    I can say with certainty that there are a lot of resources for you to draw on.
    Every application is different—your dependencies won’t exactly match everyone
    else’s all the time—but you can get a huge head start this way.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现谷歌搜索在这方面真的是你的朋友。除非你在做一些新颖和异国情调的事情，否则可能有人已经找到了并分享了一个示例Dockerfile，说明了如何使用你的框架配置应用程序。如果你使用像Django、Ruby
    on Rails、WordPress、Node.JS或SpringBoot这样的流行框架，我可以肯定地说，有很多资源可以借鉴。每个应用程序都是不同的——你的依赖项并不总是与别人的完全匹配——但你可以通过这种方式获得巨大的优势。
- en: 'Now that we have our HTTP server application, we can build it like usual:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了HTTP服务器应用程序，我们可以像往常一样构建它：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running it is a little different this time since we’ll need to forward ports
    from the host machine to the container, so we can actually try this application
    in the browser. Let’s forward port 8080 on our local machine to port 80 in the
    container that the application is listening on:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它这次有些不同，因为我们需要从主机机器转发端口到容器，这样我们实际上可以在浏览器中尝试这个应用程序。让我们将本地机器上的端口8080转发到应用程序监听的容器的端口80：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now you should be able to browse to http://localhost:8080 and view the application.
    Or, with `curl`, do the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够浏览到http://localhost:8080并查看应用程序。或者，使用`curl`，执行以下操作：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `-it` parameter (actually two parameters but normally used together) allows
    us to terminate by sending `SIGTERM` (often Ctrl/Command+C). This makes the typical
    developer loop of build-run-fix-repeat easy (run, Ctrl+C, fix, repeat). Alternatively,
    you can run Docker in the background with `docker` `run` `-d` `-p` `8080:80` `timeserver`.
    Without using `-it`, you’ll need to stop the process manually: `docker` `ps` to
    list the process and `docker` `stop` `$CONTAINER_ID` to stop it, or `docker` `stop`
    `$(docker` `ps` `-q)` to stop all running containers.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`-it` 参数（实际上是两个参数，但通常一起使用）允许我们通过发送 `SIGTERM`（通常是 Ctrl/Command+C）来终止。这使得典型的开发者循环（构建-运行-修复-重复）变得简单（运行，Ctrl+C，修复，重复）。或者，你可以使用
    `docker` `run` `-d` `-p` `8080:80` `timeserver` 在后台运行 Docker。如果不使用 `-it`，你需要手动停止进程：使用
    `docker` `ps` 列出进程，然后使用 `docker` `stop` `$CONTAINER_ID` 停止它，或者使用 `docker` `stop`
    `$(docker` `ps` `-q)` 停止所有正在运行的容器。'
- en: 'For a neat development loop, I like to use the following one-liner that will
    build and run the image in one go. When you need to rebuild, you can just press
    Ctrl+C (or equivalent), the Up arrow to show the last-used command, and Enter
    to do it all again. Just be sure to watch the console output for any errors during
    the build stage, as otherwise it will run the last built image:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一个整洁的开发循环，我喜欢使用以下一行命令，它将一次性构建并运行镜像。当你需要重新构建时，只需按下 Ctrl+C（或等效键），使用上箭头显示最后使用的命令，然后按
    Enter 重新执行。务必在构建阶段查看控制台输出，以检查是否有任何错误，否则它将运行最后一个构建的镜像：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That’s it! We now have a containerized application running in Docker. In section
    2.3, I cover how to use Docker Compose to configure and run a local debug setup
    (useful if your application consists of a few different containers) and, in the
    next chapter, how to deploy this web application into Kubernetes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在有一个在 Docker 中运行的应用程序容器。在第 2.3 节中，我介绍了如何使用 Docker Compose 配置和运行本地调试设置（如果你的应用程序由几个不同的容器组成，这很有用），在下一章中，我将介绍如何将这个
    Web 应用程序部署到 Kubernetes。
- en: 2.2.2 Debugging
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 调试
- en: 'If you’re having trouble getting your app to run after configuring a Dockerfile,
    it can be useful to shell into the container’s environment to poke around and
    see what’s going wrong. While the container is running using the previous instructions,
    you can shell into the running container from a new console window, like so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你配置 Dockerfile 后遇到应用程序运行困难的问题，进入容器环境进行探索以查看哪里出错可能很有用。当容器正在运行时，你可以使用之前的指令从新的控制台窗口进入正在运行的容器，如下所示：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can run any command other than `sh`, too; for example, on a Ruby on Rails
    project, you might run `bundle` `exec` `rails` `console` here to bring up the
    rails console directly without an intermediate step.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以运行除 `sh` 之外的其他任何命令；例如，在一个 Ruby on Rails 项目中，你可能会在这里运行 `bundle` `exec` `rails`
    `console` 来直接启动 rails 控制台，而不需要中间步骤。
- en: 'I won’t list out every Docker command, as the docs do a great job at that,
    but another one I find especially useful for debugging is `docker` `cp`. It allows
    you to copy files between your host and the container. Here’s an example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会列出每个 Docker 命令，因为文档在这方面做得很好，但我发现另一个特别有用的调试命令是 `docker` `cp`。它允许你在主机和容器之间复制文件。以下是一个示例：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Or to copy a file out of the container, do the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，要从容器中复制文件，请执行以下操作：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you do fix anything by running commands via `exec`, or copying files, be
    sure to capture the change in the Dockerfile. The Dockerfile is your primary specification,
    not the container instance. If you rely on manual changes to the container instance,
    it’s no better than the old “shell into a VM and change things” model that we’re
    moving away from.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过 `exec` 运行命令或复制文件来修复任何问题，请确保在 Dockerfile 中捕获更改。Dockerfile 是你的主要规范，而不是容器实例。如果你依赖于对容器实例的手动更改，那么它并不比我们正在远离的旧“进入虚拟机并更改内容”模式更好。
- en: 2.3 Using Docker Compose for local testing
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 使用 Docker Compose 进行本地测试
- en: At this point, we have built a container image and are ready to start using
    Kubernetes. If you like, skip ahead to the next chapter and deploy this newly
    built container into Kubernetes right away to a cloud or local Kubernetes environment.
    This section covers how you can use Docker Compose for local container testing
    and development before deploying to Kubernetes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一个容器镜像，并准备好开始使用 Kubernetes。如果你愿意，可以跳到下一章，立即将新构建的容器部署到云或本地 Kubernetes
    环境中。本节介绍了在部署到 Kubernetes 之前，如何使用 Docker Compose 进行本地容器测试和开发。
- en: In the previous section, we booted our server application using Docker and forwarded
    ports to our host for testing. Using this approach for testing during development
    has a couple of drawbacks. You have to set up the ports to forward each time,
    and if you’re developing an application with a few containers, it can be complex
    to get everything up and running with the right ports forwarded, and so forth.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用Docker启动了我们的服务器应用，并将端口转发到主机进行测试。在开发过程中使用这种方法进行测试有几个缺点。每次测试时，您都必须设置要转发的端口，如果您正在开发一个包含几个容器的应用，那么配置正确的端口并使一切正常运行可能会变得复杂。
- en: This is where Docker Compose comes in. Compose is a mini container orchestrator
    that can bring up and tear down multiple containers in a logical group and preserve
    the runtime settings in between runs, which is useful for local testing. To run
    the web server container from section 2.2.1 with Compose, we can configure a docker-compose.yaml
    file, such as in the following listing.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Docker Compose的用武之地。Compose是一个迷你容器编排器，可以在逻辑组中启动和销毁多个容器，并在运行之间保留运行时设置，这对于本地测试非常有用。要使用Compose运行2.2.1节中的Web服务器容器，我们可以配置一个docker-compose.yaml文件，如下所示。
- en: Listing 2.16 Chapter02/2.3_Compose/docker-compose.yaml
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.16 第02章/2.3_Compose/docker-compose.yaml
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ The path to the directory containing the docker container to be built
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含要构建的docker容器的目录路径
- en: ❷ Command that will be run on the container. It can be skipped if your Dockerfile
    specifies CMD.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在容器上运行的命令。如果Dockerfile指定了CMD，则可以省略。
- en: ❸ Ports to forward to the container from the local machine. In this case, port
    8080 on the local machine will be forwarded to the container’s port 80.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将端口从本地机器转发到容器。在这种情况下，本地机器上的8080端口将被转发到容器的80端口。
- en: 'To build and run the container, do the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和运行容器，请执行以下操作：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When developing, I tend to run both these steps as one so I can create a tight
    rebuild loop:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我倾向于将这两个步骤合并为一个，这样我就可以创建一个紧凑的重构循环：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With this simple configuration, there’s no need to remember the specific Docker
    command to boot and test the application—everything is stored neatly in the compose
    file. With this example, that mostly consists of some ports to forward, but this
    benefit will become apparent as you add more configuration and dependencies.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种简单的配置，无需记住启动和测试应用的特定Docker命令——所有内容都整齐地存储在compose文件中。在这个例子中，这主要是一些要转发的端口，但随着您添加更多配置和依赖项，这种好处将变得明显。
- en: 2.3.1 Mapping folders locally
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 本地映射文件夹
- en: Earlier, we used `docker` `cp` to copy files into and out of container instances.
    One really useful feature of Compose is that you can actually map local folders
    right into the container. In other words, instead of the container having a copy
    of your application, it will actually just link to the application folder on your
    hard drive. During development, this can be really handy, as it allows you to
    work on the files in the container right from your desktop without needing to
    copy things back and forth or rebuild the container.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用`docker` `cp`将文件复制到容器实例中。Compose的一个非常有用的功能是您实际上可以将本地文件夹直接映射到容器中。换句话说，容器不会包含您应用的副本，它实际上只是链接到您硬盘上的应用文件夹。在开发过程中，这非常有用，因为它允许您直接从桌面工作在容器中的文件，而无需来回复制文件或重建容器。
- en: Recall from the Dockerfile in listing 2.15 that our server app is copied into
    the `/app` directory within the container. What we want to do now is mount our
    local directory into the container at that same directory using volume binding,
    as follows.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下列表2.15中的Dockerfile，我们的服务器应用被复制到容器内的/app目录。我们现在想做的就是在相同的目录下使用卷绑定将我们的本地目录挂载到容器中，如下所示。
- en: Listing 2.17 Chapter02/2.3.1_VolumeMount/docker-compose.yaml
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.17 第02章/2.3.1_卷挂载/docker-compose.yaml
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Binds the local container build directory into the container’s /app directory
    (matching the Dockerfile)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将本地容器构建目录绑定到容器的/app目录（与Dockerfile匹配）
- en: ❷ Sets a new environment variable so that Python can be made to reload our source
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置一个新的环境变量，以便Python可以重新加载我们的源代码
- en: With this volume binding, the files from our local machine are used instead
    of the ones copied when we built our container. When we update those files locally,
    the changes can be immediately read in the container without a rebuild. For interpreted
    languages like Python, Ruby, and PHP, as well as markup languages like HTML and
    CSS, this means you can potentially have a setup where you just hit Save in your
    editor and reload the page in the browser for a really tight development loop.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种卷绑定，我们的本地机器上的文件将用于构建容器时复制的文件。当我们本地更新这些文件时，更改可以立即在容器中读取，无需重新构建。对于 Python、Ruby
    和 PHP 等解释型语言以及 HTML 和 CSS 等标记语言来说，这意味着您可能有一个设置，只需在编辑器中点击保存，然后在浏览器中重新加载页面，就可以有一个非常紧密的开发循环。
- en: NOTE For compiled code, this may not be of much help. You could build the binary
    locally, replacing it in the container, but if you prefer to build everything
    through Docker (or there is an architectural difference between your local environment
    and the container), then this won’t help. For compiled code, I recommend using
    other developer tools like Skaffold[¹](#pgfId-1065389) to give you a tight development
    loop.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于编译代码，这可能没有太大帮助。您可以在本地构建二进制文件，将其替换到容器中，但如果您更喜欢通过 Docker（或者您的本地环境和容器之间存在架构差异）构建一切，那么这可能没有帮助。对于编译代码，我建议使用其他开发工具，如
    Skaffold[¹](#pgfId-1065389) 以提供紧密的开发循环。
- en: There’s a trick to get this to work with the sample application, however. Our
    Python code, by default, isn’t reloaded from the disk when there are changes.
    So, while we can modify the source code, it won’t have any effect once the container
    is running. This will be true for many other build systems as well.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要让这个示例应用程序工作有一个技巧。我们的 Python 代码默认情况下，在发生更改时不会从磁盘重新加载。因此，虽然我们可以修改源代码，但一旦容器运行，它就不会有任何效果。这同样适用于许多其他构建系统。
- en: Let’s update the Python timeserver app to support reloading the code while it’s
    running and configure a local mount in Compose. The steps here will vary by language
    and framework. For Python, we can use the *reloading* library to have our `GET`
    function reloaded from disk each time there is a new request.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 Python 时间服务器应用程序以支持在运行时重新加载代码，并在 Compose 中配置本地挂载。这里的步骤将因语言和框架而异。对于 Python，我们可以使用
    *reloading* 库，以便在每次有新请求时从磁盘重新加载我们的 `GET` 函数。
- en: Listing 2.18 Chapter02/2.3.1_VolumeMount/server.py
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.18 第二章/2.3.1_VolumeMount/server.py
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ By adding the @reloading tag to our method, it will be reloaded from disk
    every time it runs so we can change our do_GET function while it’s running.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过在我们的方法中添加 @reloading 标签，每次运行时它都会从磁盘重新加载，这样我们就可以在运行时更改我们的 do_GET 函数。
- en: Since we’re using a new library, we’ll need to add that dependency in the Dockerfile
    as well.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了一个新的库，我们还需要在 Dockerfile 中添加这个依赖项。
- en: Listing 2.19 Chapter02/2.3.1_VolumeMount/Dockerfile
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.19 第二章/2.3.1_VolumeMount/Dockerfile
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With our app configured to reload files from the disk, we can now run it with
    Compose as before:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序配置为从磁盘重新加载文件后，我们现在可以像以前一样使用 Compose 运行它：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As before, browse to the app at http://localhost:8080/. This time, open up
    the 2.3.1_VolumeMount/server.py code (listing 2.18) and make a change to the response.
    For example, we can change the response to 24-hour time by replacing line 12 with:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，浏览到 http://localhost:8080/ 上的应用程序。这次，打开 2.3.1_VolumeMount/server.py 代码（列表
    2.18）并修改响应。例如，我们可以通过将第 12 行替换为以下内容来将响应更改为 24 小时时间：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Save the file in your editor and reload the page. You should see the new text
    in the response:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的编辑器中保存文件并重新加载页面。您应该会在响应中看到新的文本：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this example, we had to make some code changes to make it work, but if you’re
    using a standard development framework, that will likely not be necessary, as
    you’ll be able to configure it to perform reloads automatically.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不得不做一些代码更改才能使其工作，但如果你使用的是标准开发框架，那么这很可能不是必要的，因为你将能够配置它以自动执行重新加载。
- en: Being able to map local folders into the container to create a development loop
    that is as fast as clicking Save in your code editor, then reloading a page on
    the browser has to be one of my favorite features of Docker Compose and containers
    in general. You have all the benefits of containers, where you don’t need to mess
    around installing the developer tools locally, with the same efficiency as if
    you were running it locally without any build step.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将本地文件夹映射到容器中，创建一个与在代码编辑器中点击保存然后重新加载浏览器页面一样快的开发循环，这必须是我最喜欢的 Docker Compose
    和容器的一般特性之一。您拥有容器的一切好处，您不需要在本地安装开发工具，效率与您在本地运行时没有任何构建步骤一样。
- en: The binding works both ways, too. If you make any changes in the container within
    the bound volume, it will be reflected on your local disk. This can be useful
    when you want to run commands in the container and save their output. In fact,
    with this approach, you can completely avoid having the developer tools installed
    on your local machine at all. For example, a Rails developer will, from time to
    time, run `gem` `update` `rails` in their project directory to keep the framework
    up to date. With a volume binding, you can run that in the container and get the
    changed package list on your hard drive ready to commit to version control.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定是双向的。如果你在绑定卷内的容器中进行了任何更改，它将反映在你的本地磁盘上。当你想在容器中运行命令并保存它们的输出时，这非常有用。实际上，使用这种方法，你可以完全避免在本地机器上安装开发者工具。例如，Rails
    开发者有时会在他们的项目目录中运行 `gem update rails` 来保持框架更新。使用卷绑定，你可以在容器中运行它，并在你的硬盘上获得已更改的包列表，以便提交到版本控制。
- en: 2.3.2 Adding service dependencies
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 添加服务依赖项
- en: In the case where your app is completely standalone, congratulations, you are
    done. The rest of the time, though, you’ll likely have other services that you
    need to bring up alongside your application. These might be other separate servers
    that you build or standard components that might be run by your cloud provider,
    like a database. In both cases, you can add these dependencies in Compose to create
    a local development environment.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序完全独立的情况下，恭喜你，你已经完成了。然而，在其余的时间里，你很可能会需要其他服务来与你的应用程序一起启动。这些可能包括你构建的其他独立服务器，或者可能由你的云服务提供商运行的标准组件，比如数据库。在这两种情况下，你都可以在
    Compose 中添加这些依赖项来创建一个本地开发环境。
- en: Compose or Kubernetes for local development?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Compose 或 Kubernetes 用于本地开发？
- en: Why use or consider Compose rather than Kubernetes itself to bring up dependent
    services for development? Kubernetes certainly can be used for local development,
    and if you want to replicate your production environment, it’s the best option
    (chapter 3 includes a section on local development). What makes Compose popular
    for this task, however, is its simplicity.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择使用 Compose 而不是直接使用 Kubernetes 来为开发搭建依赖服务呢？Kubernetes 当然可以用于本地开发，如果你想要复制生产环境，它无疑是最佳选择（第
    3 章包含关于本地开发的章节）。然而，Compose 在这项任务中之所以受欢迎，主要是因为它的简单性。
- en: Compose is easy to set up for local use if you just need a handful of dependent
    services, which for many simple applications is the case. Production, where you’re
    not just running a few single instance services on one machine, is a different
    (more complex) story, which is where Kubernetes excels.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要少量依赖服务，那么 Compose 的本地设置非常简单，对于许多简单应用程序来说就是这样。在生产环境中，你不仅仅是在一台机器上运行几个单实例服务，这是一个不同（更复杂）的故事，这正是
    Kubernetes 之所以出色的地方。
- en: This duality means it’s not uncommon to see Compose for local dev and Kubernetes
    in production. It does mean that your runtime configuration is essentially duplicated,
    but this configuration has two separate purposes—development and production—so
    it likely won’t look identical even if it was all in Kubernetes. I suggest simply
    using whichever approach makes life as a developer easier.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这种双重性意味着在本地开发中使用 Compose 和在生产中使用 Kubernetes 是很常见的。这也意味着你的运行时配置实际上是重复的，但由于这个配置有两个不同的目的——开发和生产——所以即使全部都在
    Kubernetes 中，它也可能不会看起来完全相同。我建议简单地使用任何能让开发者生活更轻松的方法。
- en: Multiple services can easily be added to the Compose. These can reference standard
    images (in the case of a dependency like MySQL) or other projects on your computer.
    A common project structure is to have one root folder for all services, with each
    checked out in a subfolder and a Docker Compose file that can reference them all.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 可以轻松地将多个服务添加到 Compose 中。这些服务可以引用标准镜像（例如，对于像 MySQL 这样的依赖项）或你电脑上的其他项目。一个常见的项目结构是有一个根文件夹用于所有服务，每个服务都在子文件夹中检出，并且有一个
    Docker Compose 文件可以引用它们。
- en: 'Listing 2.20 provides an example of a Compose file with two containerized services:
    our app that’s built locally and a database instance using the public MySQL container.
    The demo app here doesn’t actually use MySQL, but, hopefully, you can see how
    easy it is to add the dependencies that your app needs. You can add all the services
    you need here, including multiple locally built containers and multiple external
    images.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.20 提供了一个包含两个容器化服务的 Compose 文件示例：我们本地构建的应用程序和一个使用公共 MySQL 容器的数据库实例。这里的演示应用程序实际上并没有使用
    MySQL，但希望你能看到添加应用程序所需依赖项有多容易。你可以在这里添加所有需要的服务，包括多个本地构建的容器和多个外部镜像。
- en: Listing 2.20 Chapter02/2.3.2_MultipleServices/docker-compose.yaml
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.20 Chapter02/2.3.2_MultipleServices/docker-compose.yaml
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ Our app that is built locally; you can have multiple locally built apps.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们本地构建的应用程序；你可以拥有多个本地构建的应用程序。
- en: ❷ A service running a public image; you can have multiple such services as well.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 运行公共图像的服务；你也可以拥有多个这样的服务。
- en: ❸ Volume definition for the development database so that it will persist between
    restarts
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为开发数据库定义卷，以便它在重启之间持续存在
- en: This is one of the key reasons to use Compose, rather than just Docker, for
    local testing—the ability to bring up a complete testing environment and tear
    it down all with a single command.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是使用Compose而不是仅使用Docker进行本地测试的关键原因之一——能够通过单个命令启动完整的测试环境并将其拆除。
- en: TIP When configuring your application for local development and for production,
    all configuration changes should be made by environment variables. Even a single
    environment variable that indicates `prod` or `dev` to select which configuration
    file to use can suffice. Configuration should not be baked into the container
    in such a way that you need to modify it between environments. This allows you
    to reuse the same container in all environments and also means that you are testing
    the production artifact.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：当配置你的应用程序用于本地开发和生产时，所有配置更改都应通过环境变量进行。甚至一个表示`prod`或`dev`以选择要使用哪个配置文件的单个环境变量也足够了。配置不应以将需要在不同环境之间修改的方式嵌入到容器中。这允许你在所有环境中重用相同的容器，这也意味着你在测试生产工件。
- en: 2.3.3 Faking external dependencies
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 模拟外部依赖
- en: If, to date, you’ve been testing against remote dependencies (like a cloud storage
    API), now might be a good time to see whether you can replace those remote dependencies
    with fakes. Fakes are lightweight implementations of the same API of the external
    dependency, which speed up development and testing by providing a local service.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果到目前为止，你一直在针对远程依赖项（如云存储API）进行测试，那么现在可能是一个好时机，看看你是否可以用模拟来替换这些远程依赖项。模拟是外部依赖项相同API的轻量级实现，通过提供本地服务来加速开发和测试。
- en: In the past, you might have been constrained to finding a fake written in the
    same language as your application (for practical reasons, like not wanting to
    support multiple different environments for one project). One of the benefits
    of containers is that just like how you probably don’t care what language a cloud
    service you consume is written in, you no longer need to care about what language
    your fake is written in either, as you don’t need to maintain the environment—it
    runs in its own container.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，你可能被迫寻找与你的应用程序编写语言相同（出于实际原因，如不想为一个项目支持多个不同的环境）的模拟。容器的一个好处是，就像你可能不关心你消费的云服务是用什么语言编写的，你也不再需要关心你的模拟是用什么语言编写的，因为你不需要维护环境——它在自己的容器中运行。
- en: This also brings the opportunity for high-quality fakes that are really just
    lighter-weight implementations of the same API you’ll use in production. Just
    as in listing 2.20 where we used real MySQL in a container (rather than a fake),
    you can use a real object storage provider to test against, even if you ultimately
    use a cloud provider service like Google Cloud Storage or Amazon S3.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这也带来了高质量模拟的机会，这些模拟实际上只是生产中使用的相同API的更轻量级实现。就像在列表2.20中我们使用容器中的真实MySQL（而不是模拟）一样，你可以使用真实对象存储提供商进行测试，即使你最终使用像Google
    Cloud Storage或Amazon S3这样的云服务提供商服务。
- en: Taking the object storage example, say your application does cloud storage using
    S3-compatible APIs (e.g., with S3 itself or one of the many object stores that
    support the API, like Google Cloud Storage). To set up a local fake for fast iteration,
    you could get a container like Adobe’s S3Mock[²](#pgfId-1065510), but with containers,
    it’s equally easy to use a fully fledged S3-compatible local storage solution
    like MinIO[³](#pgfId-1065515). MinIO is not really a fake—you can deploy it into
    production in cases where you want to manage your own block storage service—but
    you can still use it as a high-quality fake and get benefits like a convenient
    UI.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以对象存储为例，假设你的应用程序使用与S3兼容的API进行云存储（例如，使用S3本身或许多支持该API的对象存储之一，如Google Cloud Storage）。为了快速迭代而设置本地模拟，你可以获取一个像Adobe的S3Mock[²](#pgfId-1065510)这样的容器，但使用容器，使用一个完整的S3兼容的本地存储解决方案（如MinIO[³](#pgfId-1065515)）同样容易。MinIO实际上不是一个模拟——在你想管理自己的块存储服务的情况下，你可以将其部署到生产环境中——但你仍然可以使用它作为一个高质量的模拟，并获得如方便的用户界面等好处。
- en: The ubiquity of the S3 API for object storage
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对象存储的S3 API的普遍性
- en: Like SQL standardized database query languages, S3’s API is surprisingly popular
    for object storage providers. For example, Google Cloud, Azure, and (of course)
    AWS all implement the S3 API, along with most other clouds and several bare metal
    storage options as well. The benefit of this ubiquity is you can easily switch
    between providers and have several fakes to choose from to develop locally.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 就像SQL标准化的数据库查询语言一样，S3的API对于对象存储提供商来说出奇地受欢迎。例如，Google Cloud、Azure以及（当然）AWS都实现了S3
    API，以及大多数其他云和几个裸金属存储选项。这种普遍性的好处是您可以轻松地在提供商之间切换，并从多个伪造中选择以进行本地开发。
- en: Earlier, I discussed how containers make it easy to mix and match services,
    all running in their own environments. Here, we see how this ability can make
    development better as well. Rather than implementing a fake yourself or finding
    a rudimentary fake for your environment, you can either use the same service locally
    as in production (such as with MySQL) or find a production-grade replacement for
    another cloud service that you use (like with MinIO subbing in for cloud object
    storage). Let’s add MinIO as another service to our Docker Compose file.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我讨论了容器如何使混合和匹配服务变得容易，所有这些服务都在它们自己的环境中运行。在这里，我们看到这种能力如何使开发变得更好。您不必自己实现伪造或为您的环境找到原始的伪造，您可以使用与生产中相同的服务本地使用（例如MySQL）或找到您使用的另一个云服务的生产级替代品（例如MinIO作为云对象存储的替代）。让我们将MinIO作为另一个服务添加到我们的Docker
    Compose文件中。
- en: Listing 2.21 Chapter02/2.3.3_Fakes/docker-compose.yaml
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.21第二章/2.3.3_Fakes/docker-compose.yaml
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ The new storage fake
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 新的存储伪造
- en: ❷ The application configured to use the new fake
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 配置为使用新伪造的应用程序
- en: Typically with services used as fakes, as we are using MinIO here, you can specify
    the access keys it will accept and then simply specify those same secrets to the
    application using environment variables.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于用作伪造的服务，例如我们在这里使用MinIO，您可以指定它将接受的访问密钥，然后只需将这些相同的密钥作为环境变量指定给应用程序即可。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Containerization captures your app’s build, environment, and configuration into
    a standardized format that can then be run with VM-like isolation but without
    the VM overhead.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化将您的应用程序的构建、环境和配置捕获到一个标准化的格式中，然后可以像虚拟机一样进行隔离运行，但无需虚拟机的开销。
- en: Containerization is key step toward adopting Kubernetes, as this is the executable
    environment that Kubernetes supports.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化是采用Kubernetes的关键步骤，因为这是Kubernetes支持的执行环境。
- en: Not just for production, containers help developers work on multiple projects
    at once, without the environments conflicting and without needing complex setup
    instructions.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不仅用于生产，容器还有助于开发者同时处理多个项目，无需担心环境冲突，也不需要复杂的设置说明。
- en: The process of building a container image uses a configuration file known as
    a Dockerfile, which contains a set of procedural instructions used to build your
    container.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器镜像的过程使用一个名为Dockerfile的配置文件，其中包含用于构建您容器的一系列过程指令。
- en: To build a Dockerfile, start with the base image that is the most complete for
    your needs, then configure with your application and its dependencies.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要构建Dockerfile，首先从满足您需求的最完整的基镜像开始，然后配置您的应用程序及其依赖项。
- en: Multistage builds are useful for complied applications.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多阶段构建对于编译型应用程序很有用。
- en: With a multistage container build, we first configure a temporary container
    with everything needed to *build* the program, and then we configure another container
    with everything needed to *run* the program. This keeps the concerns separated
    and neatly isolated to their own containers.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多阶段容器构建中，我们首先配置一个临时容器，其中包含构建程序所需的一切，然后配置另一个容器，其中包含运行程序所需的一切。这保持了关注点的分离，并将它们干净地隔离到各自的容器中。
- en: Docker Compose is a lightweight container orchestrator that can give you a quick
    container-based development environment for multiple services.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose是一个轻量级的容器编排器，可以为多个服务提供一个基于容器的快速开发环境。
- en: Mapping folders locally with Compose enables the editing of noncompiled applications
    in real time, creating a tight development loop.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Compose映射本地文件夹可以实时编辑非编译应用程序，创建紧密的开发循环。
- en: During testing, containers allow for high-quality fakes of external dependencies
    that are really just lighter-weight implementations of the same API you’ll use
    in production, such as MySQL in a container or a real object storage provider.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试期间，容器允许使用高质量的伪造外部依赖项，这些依赖项实际上是您在生产中使用的相同API的轻量级实现，例如容器中的MySQL或真实的对象存储提供商。
- en: '* * *'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.) [https://skaffold.dev/](https://skaffold.dev/)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ^(1.) [https://skaffold.dev/](https://skaffold.dev/)
- en: ^(2.) [https://github.com/adobe/S3Mock](https://github.com/adobe/S3Mock)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: (2.) [https://github.com/adobe/S3Mock](https://github.com/adobe/S3Mock)
- en: ^(3.) [https://min.io/](https://min.io/)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: (3.) [https://min.io/](https://min.io/)
