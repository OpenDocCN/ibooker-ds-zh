- en: 5 Documenting REST APIs with OpenAPI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 使用 OpenAPI 记录 REST API
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Using JSON Schema to create validation models for JSON documents
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON Schema 创建 JSON 文档的验证模型
- en: Describing REST APIs with the OpenAPI documentation standard
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OpenAPI 文档标准描述 REST API
- en: Modeling the payloads for API requests and responses
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型 API 请求和响应的有效载荷
- en: Creating reusable schemas in OpenAPI specifications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OpenAPI 规范中创建可重用的模式
- en: 'In this chapter, you’ll learn to document APIs using OpenAPI: the most popular
    standard for describing RESTful APIs, with a rich ecosystem of tools for testing,
    validating, and visualizing APIs. Most programming languages have libraries that
    support OpenAPI specifications, and in chapter 6 you’ll learn to use OpenAPI-compatible
    libraries from the Python ecosystem.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节中，你将学习如何使用 OpenAPI：描述 RESTful API 最流行的标准，它拥有丰富的工具生态系统，用于测试、验证和可视化 API。大多数编程语言都有支持
    OpenAPI 规范的库，在第 6 章中，你将学习如何使用 Python 生态系统中的 OpenAPI 兼容库。
- en: OpenAPI uses JSON Schema to describe an API’s structure and models, so we start
    by providing an overview of how JSON Schema works. JSON Schema is a specification
    for defining the structure of a JSON document, including the types and formats
    of the values within the document.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 使用 JSON Schema 来描述 API 的结构和模型，因此我们首先提供 JSON Schema 的工作概述。JSON Schema
    是一个用于定义 JSON 文档结构的规范，包括文档中值的类型和格式。
- en: After learning about JSON Schema, we study how an OpenAPI document is structured,
    what its properties are, and how we use it to provide informative API specifications
    for our API consumers. API endpoints constitute the core of the specification,
    so we pay particular attention to them. We break down the process of defining
    the endpoints and schemas for the payloads of the API’s requests and responses,
    step by step. For the examples in this chapter, we work with the API of CoffeeMesh’s
    orders service. As we mentioned in chapter 1, CoffeeMesh is a fictional on-demand
    coffee-delivery platform, and the orders service is the component that allows
    customers to place and manage their orders. The full specification for the orders
    API is available under ch05/oas.yaml in the GitHub repository for this book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解 JSON Schema 之后，我们研究 OpenAPI 文档的结构、其属性以及我们如何使用它为 API 消费者提供有信息的 API 规范。API
    端点是规范的核心，因此我们特别关注它们。我们逐步分解定义 API 请求和响应有效载荷端点和模式的过程。在本章的示例中，我们与 CoffeeMesh 订单服务的
    API 进行合作。正如我们在第 1 章中提到的，CoffeeMesh 是一个虚构的按需咖啡配送平台，订单服务是允许客户下单和管理订单的组件。订单 API 的完整规范可在本书
    GitHub 仓库的 ch05/oas.yaml 下找到。
- en: 5.1 Using JSON Schema to model data
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 使用 JSON Schema 模型数据
- en: This section introduces the specification standard for JSON Schema and explains
    how we leverage it to produce API specifications. OpenAPI uses an extended subset
    of the JSON Schema specification for defining the structure of JSON documents
    and the types and formats of its properties. It’s useful for documenting interfaces
    that use JSON to represent data and to validate that the data being exchanged
    is correct. The JSON Schema specification is under active development, with the
    latest version being 2020-12.[¹](#pgfId-1304948)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 JSON Schema 规范标准，并解释了如何利用它来生成 API 规范。OpenAPI 使用 JSON Schema 规范的扩展子集来定义
    JSON 文档的结构及其属性的类型和格式。这对于记录使用 JSON 表示数据并验证交换的数据是否正确非常有用。JSON Schema 规范正在积极开发中，最新版本为
    2020-12。[¹](#pgfId-1304948)
- en: DEFINITION *JSON Schema* is a specification standard for defining the structure
    of a JSON document and the types and formats of its properties. OpenAPI uses JSON
    Schema to describe the properties of an API.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *JSON Schema* 是一个用于定义 JSON 文档结构和其属性类型及格式的规范标准。OpenAPI 使用 JSON Schema 来描述
    API 的属性。
- en: 'A JSON Schema specification usually defines an object with certain attributes
    or properties. A JSON Schema `object` is represented by an associative array of
    key-value pairs. A JSON Schema specification usually looks like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Schema 规范通常定义了一个具有某些属性或属性的对象。JSON Schema 的 `object` 通过键值对关联数组表示。JSON Schema
    规范通常看起来像这样：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Each property in a JSON Schema specification comes as a key whose values are
    the descriptors of the property.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ① JSON Schema 规范中的每个属性都是一个键，其值是该属性的描述符。
- en: ② The minimum descriptor necessary for a property is the type. In this case,
    we specify that the status property is a string.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ② 属性所需的最小描述符是类型。在这种情况下，我们指定状态属性是一个字符串。
- en: In this example, we define the schema of an object with one attribute named
    `status`, whose type is `string`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个具有一个名为 `status` 的属性的对象模式，其类型为 `string`。
- en: JSON Schema allows us to be very explicit with respect to the data types and
    formats that both the server and the client should expect from a payload. This
    is fundamental for the integration between the API provider and the API consumer,
    since it lets us know how to parse the payloads and how to cast them into the
    right data types in our runtime.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Schema 允许我们对服务器和客户端应从有效载荷中期望的数据类型和格式非常明确。这对于 API 提供者和 API 消费者之间的集成是基本的，因为它让我们知道如何解析有效载荷以及如何在我们的运行时将它们转换为正确的数据类型。
- en: 'JSON Schema supports the following basic data types:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Schema 支持以下基本数据类型：
- en: '`string` for character values'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于字符值，使用 `string`。
- en: '`number` for integer and decimal values'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于整数和小数值，使用 `number`。
- en: '`object` for associative arrays (i.e., dictionaries in Python)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于关联数组（即 Python 中的字典），使用 `object`。
- en: '`array` for collections of other data types (i.e., lists in Python)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于其他数据类型的集合（即 Python 中的列表），使用 `array`。
- en: '`boolean` for `true` or `false` values'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `true` 或 `false` 值，使用 `boolean`。
- en: '`null` for uninitialized data'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于未初始化的数据，使用 `null`。
- en: To define an object using JSON Schema, we declare its type as `object`, and
    we list its properties and their types. The following shows how we define an object
    named `order`, which is one of the core models of the orders API.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 JSON Schema 定义一个对象，我们声明其类型为 `object`，并列出其属性及其类型。以下是如何定义一个名为 `order` 的对象，它是订单
    API 的核心模型之一。
- en: Listing 5.1 Defining the schema of an object with JSON Schema
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 使用 JSON Schema 定义对象的模式
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① We can declare the schema as an object.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们可以将模式声明为一个对象。
- en: ② We describe the object’s properties under the properties keyword.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们在 `properties` 关键字下描述对象的属性。
- en: 'Since `order` is an object, the `order` attribute also has properties, defined
    under the `properties` attribute. Each property has its own type. A JSON document
    that complies with the specification in listing 5.1 is the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `order` 是一个对象，因此 `order` 属性也有属性，这些属性在 `properties` 属性下定义。每个属性都有自己的类型。符合列表
    5.1 中规范的一个 JSON 文档如下：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, each of the properties described in the specification is used
    in this document, and each of them has the expected type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，规范中描述的每个属性都用于本文档中，并且每个属性都有预期的类型。
- en: A property can also represent an array of items. In the following code, the
    `order` object represents an array of objects. As you can see, we use the `items`
    keyword to define the elements within the array.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 属性也可以表示一个项目数组。在下面的代码中，`order` 对象代表一个对象数组。正如你所看到的，我们使用 `items` 关键字来定义数组中的元素。
- en: Listing 5.2 Defining an array of objects with JSON Schema
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 使用 JSON Schema 定义对象数组
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① We define the elements within the array using the items keyword.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们使用 `items` 关键字定义数组中的元素。
- en: In this case, the `order` property is an array. Array types require an additional
    property in their schema, which is the `items` property that defines the type
    of each of the elements contained in the array. In this case, each of the elements
    in the array is an object that represents an item in the order.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`order` 属性是一个数组。数组类型在其模式中需要额外的属性，即 `items` 属性，它定义了数组中每个元素的类型。在这种情况下，数组中的每个元素都是一个对象，它代表订单中的一个项目。
- en: An object can have any number of nested objects. However, when too many objects
    are nested, indentation grows large and makes the specification difficult to read.
    To avoid this problem, JSON Schema allows us to define each object separately
    and to use JSON pointers to reference them. A *JSON pointer* is a special syntax
    that allows us to point to another object definition within the same specification.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象可以有任意数量的嵌套对象。然而，当嵌套的对象太多时，缩进会变得很大，使得规范难以阅读。为了避免这个问题，JSON Schema 允许我们分别定义每个对象，并使用
    JSON 指针来引用它们。*JSON 指针* 是一种特殊语法，允许我们在同一规范中指向另一个对象定义。
- en: As you can see in the following code, we can extract the definition of each
    item within the `order` array as a model called `OrderItemSchema` and use a JSON
    pointer to reference `OrderItemSchema` using the special `$ref` keyword.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如以下代码所示，我们可以将 `order` 数组中每个项目的定义作为一个名为 `OrderItemSchema` 的模型提取出来，并使用特殊的 `$ref`
    关键字通过 JSON 指针引用 `OrderItemSchema`。
- en: Listing 5.3 Using JSON pointers to reference other schemas
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.3 使用 JSON 指针引用其他模式
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① We can specify the type of the array’s items using a JSON pointer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们可以使用 JSON 指针来指定数组项的类型。
- en: 'JSON pointers use the special keyword `$ref` and JSONPath syntax to point to
    another definition within the schema. In JSONPath syntax, the root of the document
    is represented by the hashtag symbol (#), and the relationship of nested properties
    is represented by forward slashes (/). For example, if we wanted to create a pointer
    to the `size` property of the `OrderItemSchema` model, we would use the following
    syntax: `''#/OrderItemSchema/size''`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 指针使用特殊关键字 `$ref` 和 JSONPath 语法来指向模式中的另一个定义。在 JSONPath 语法中，文档的根由井号符号（#）表示，嵌套属性的相互关系由正斜杠（/）表示。例如，如果我们想创建一个指向
    `OrderItemSchema` 模型中 `size` 属性的指针，我们会使用以下语法：`'#/OrderItemSchema/size'`。
- en: 'DEFINITION A *JSON pointer* is a special syntax in JSON Schema that allows
    us to point to another definition within the same specification. We use the special
    keyword `$ref` to declare a JSON pointer. To build the path to another schema,
    we use JSONPath syntax. For example, to point to a schema called `OrderItemSchema`,
    defined at the top level of the document, we use the following syntax: `{"$ref":`
    `"#/OrderItemSchema"}`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 A *JSON 指针* 是 JSON Schema 中的一个特殊语法，它允许我们在同一规范中指向另一个定义。我们使用特殊关键字 `$ref` 来声明一个
    JSON 指针。要构建指向另一个模式的路径，我们使用 JSONPath 语法。例如，要指向在文档顶层定义的名为 `OrderItemSchema` 的模式，我们使用以下语法：`{"$ref":
    "#/OrderItemSchema"}`。'
- en: We can refactor our specification using JSON pointers by extracting common schema
    objects into reusable models, and we can reference them using JSON pointers. This
    helps us avoid duplication and keep the specification clean and succinct.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提取通用的模式对象到可重用模型，并使用 JSON 指针来重构我们的规范。我们可以通过 JSON 指针来引用它们。这有助于我们避免重复，并保持规范简洁。
- en: 'In addition to being able to specify the type of a property, JSON Schema also
    allows us to specify the format of the property. We can develop our own custom
    formats or use JSON Schema’s built-in formats. For example, for a property representing
    a date, we can use the `date` format—a built-in format supported by JSON Schema
    that represents an ISO date (e.g., 2025-05-21). Here’s an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够指定属性的类型之外，JSON Schema 还允许我们指定属性的格式。我们可以开发自己的自定义格式或使用 JSON Schema 内置的格式。例如，对于一个表示日期的属性，我们可以使用
    `date` 格式——这是 JSON Schema 支持的内置格式，它表示 ISO 日期（例如，2025-05-21）。以下是一个示例：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this section, we’ve worked with examples in JSON format. However, JSON Schema
    documents don’t need to be written in JSON. In fact, it’s more common to write
    them in YAML format, as it’s more readable and easier to understand. OpenAPI specifications
    are also commonly served in YAML format, and for the remainder of this chapter,
    we’ll use YAML to develop the specification of the orders API.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用了 JSON 格式的示例。然而，JSON Schema 文档不需要用 JSON 编写。实际上，更常见的是用 YAML 格式编写，因为它更易于阅读和理解。OpenAPI
    规范也通常以 YAML 格式提供，因此在本章的剩余部分，我们将使用 YAML 来开发订单 API 的规范。
- en: 5.2 Anatomy of an OpenAPI specification
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 OpenAPI 规范的结构
- en: In this section, we introduce the OpenAPI standard, and we learn to structure
    an API specification. OpenAPI’s latest version is 3.1; however, this version still
    has little support in the current ecosystem, so we’ll document the API using OpenAPI
    3.0\. There’s not much difference between the two versions, and nearly everything
    you learn about OpenAPI 3.0 applies to 3.1.[²](#pgfId-1305088)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 OpenAPI 标准，并学习了如何构建 API 规范。OpenAPI 的最新版本是 3.1；然而，这个版本在当前生态系统中仍然支持很少，因此我们将使用
    OpenAPI 3.0 来记录 API。这两个版本之间没有太大差异，你关于 OpenAPI 3.0 所学到的几乎所有内容都适用于 3.1。[²](#pgfId-1305088)
- en: OpenAPI is a standard specification format for documenting RESTful APIs (figure
    5.1). OpenAPI allows us to describe in detail every element of an API, including
    its endpoints, the format of its request and response payloads, its security schemes,
    and so on. OpenAPI was created in 2010 under the name of Swagger as an open source
    specification format for describing RESTful web APIs. Over time, this framework
    grew in popularity, and in 2015 the Linux Foundation and a consortium of major
    companies sponsored the creation of the OpenAPI initiative, a project aimed at
    improving the protocols and standards for building RESTful APIs. Today, OpenAPI
    is by far the most popular specification format used to document RESTful APIs,[³](#pgfId-1305093)
    and it benefits from a rich ecosystem of tools for API visualization, testing,
    and validation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 是一种用于记录 RESTful API 的标准规范格式（图 5.1）。OpenAPI 允许我们详细描述 API 的每个元素，包括其端点、请求和响应负载的格式、其安全方案等。OpenAPI
    于 2010 年以 Swagger 的名义创建，作为一个开源规范格式，用于描述 RESTful 网络API。随着时间的推移，这个框架越来越受欢迎，2015
    年，Linux 基金会和一家主要公司联盟赞助了 OpenAPI 创新项目的创建，该项目旨在改进构建 RESTful API 的协议和标准。如今，OpenAPI
    是最流行的规范格式，用于记录 RESTful API，[³](#pgfId-1305093) 并且它受益于一个丰富的工具生态系统，用于 API 可视化、测试和验证。
- en: '![](../Images/05-01.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05-01.png)'
- en: Figure 5.1 An OpenAPI specification contains five sections. For example, the
    `paths` section describes the API endpoints, while the `components` section contains
    reusable schemas referenced across the document.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 OpenAPI 规范包含五个部分。例如，`paths` 部分描述了 API 端点，而 `components` 部分包含在文档中引用的可重用模式。
- en: 'An OpenAPI specification contains everything that the consumer of the API needs
    to know to be able to interact with the API. As you can see in figure 5.1, an
    OpenAPI is structured around five sections:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 规范包含了 API 消费者需要了解的所有信息，以便能够与 API 交互。正如你在图 5.1 中所看到的，OpenAPI 围绕五个部分进行结构化：
- en: '`openapi`—Indicates the version of OpenAPI that we used to produce the specification.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openapi`—指示我们用于生成规范的 OpenAPI 版本。'
- en: '`info`—Contains general information, such as the title and version of the API.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`—包含一般信息，如 API 的标题和版本。'
- en: '`servers`—Contains a list of URLs where the API is available. You can list
    more than one URL for different environments, such as the production and staging
    environments.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`servers`—包含 API 可用的 URL 列表。你可以为不同的环境（如生产环境和预发布环境）列出多个 URL。'
- en: '`paths`—Describes the endpoints exposed by the API, including the expected
    payloads, the allowed parameters, and the format of the responses. This is the
    most important part of the specification, as it represents the API interface,
    and it’s the section that consumers will be looking for to learn how to integrate
    with the API.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paths`—描述 API 提供的端点，包括预期的负载、允许的参数和响应的格式。这是规范中最重要的一部分，因为它代表了 API 接口，并且是消费者将寻找以了解如何与
    API 集成的部分。'
- en: '`components`—Defines reusable elements that are referenced across the specification,
    such as schemas, parameters, security schemes, request bodies, and responses.[⁴](#pgfId-1305109)
    A *schema* is a definition of the expected attributes and types in your request
    and response objects. OpenAPI schemas are defined using JSON Schema syntax.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components`—定义了在规范中可重用的元素，例如模式、参数、安全方案、请求体和响应。[⁴](#pgfId-1305109) 一个 *模式*
    是对请求和响应对象中预期属性和类型的定义。OpenAPI 模式使用 JSON Schema 语法定义。'
- en: Now that we know how to structure an OpenAPI specification, let’s move on to
    documenting the endpoints of the orders API.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何构建 OpenAPI 规范的结构，让我们继续记录订单 API 的端点。
- en: 5.3 Documenting the API endpoints
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 记录 API 端点
- en: 'In this section, we declare the endpoints of the orders API. As we mentioned
    in section 5.2, the `paths` section of an OpenAPI specification describes the
    interface of your API. It lists the URL paths exposed by the API, with the HTTP
    methods they implement, the types of requests they expect, and the responses they
    return, including the status codes. Each path is an object whose attributes are
    the HTTP methods it supports. In this section, we’ll focus specifically on documenting
    the URL paths and the HTTP methods. In chapter 4, we established that the orders
    API contains the following endpoints:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们声明订单 API 的端点。正如我们在第 5.2 节中提到的，OpenAPI 规范的 `paths` 部分描述了您的 API 接口。它列出了
    API 暴露的 URL 路径，以及它们实现的 HTTP 方法、它们期望的请求类型以及它们返回的响应，包括状态码。每个路径都是一个对象，其属性是该路径支持的
    HTTP 方法。在本节中，我们将特别关注记录 URL 路径和 HTTP 方法。在第 4 章中，我们确定了订单 API 包含以下端点：
- en: POST `/orders`—Places an order. It requires a payload with the details of the
    order.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST `/orders`—下单。它需要一个包含订单详细信息的有效负载。
- en: GET `/orders`—Returns a list of orders. It accepts URL query parameters, which
    allow us to filter the results.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET `/orders`—返回订单列表。它接受 URL 查询参数，允许我们过滤结果。
- en: GET `/orders/{order_id}`—Returns the details of a specific order.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET `/orders/{order_id}`—返回特定订单的详细信息。
- en: PUT `/orders/{order_id}`—Updates the details of an order. Since this is a PUT
    endpoint, it requires a full representation of the order.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PUT `/orders/{order_id}`—更新订单的详细信息。由于这是一个 PUT 端点，它需要一个完整的订单表示。
- en: DELETE `/orders/{order_id}`—Deletes an order.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DELETE `/orders/{order_id}`—删除一个订单。
- en: POST `/orders/{order_id}/pay`—Pays for an order.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST `/orders/{order_id}/pay`—为订单付款。
- en: POST `/orders/{order_id}/cancel`—Cancels the order.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST `/orders/{order_id}/cancel`—取消订单。
- en: The following shows the high-level definitions of the orders API endpoints.
    We declare the URLs and the HTTP implemented by each URL, and we add an operation
    ID to each endpoint so that we can reference them in other sections of the document.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了订单 API 端点的高级定义。我们声明 URL 和每个 URL 实现的 HTTP，并为每个端点添加一个操作 ID，以便我们可以在文档的其他部分中引用它们。
- en: Listing 5.4 High-level definition of the orders API endpoints
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4 订单 API 端点的概述
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① We declare a URL path.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们声明一个 URL 路径。
- en: ② An HTTP method supported by the /orders URL path
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ② 由 /orders URL 路径支持的 HTTP 方法
- en: Now that we have the endpoints, we need to fill in the details. For the GET
    `/orders` endpoint, we need to describe the parameters that the endpoint accepts,
    and for the POST and PUT endpoints, we need to describe the request payloads.
    We also need to describe the responses for each endpoint. In the following sections,
    we’ll learn to build specifications for different elements of the API, starting
    with the URL query parameters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了端点，我们需要填写详细信息。对于 GET `/orders` 端点，我们需要描述端点接受的参数，对于 POST 和 PUT 端点，我们需要描述请求有效负载。我们还需要描述每个端点的响应。在以下章节中，我们将学习为
    API 的不同元素构建规范，从 URL 查询参数开始。
- en: 5.4 Documenting URL query parameters
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 记录 URL 查询参数
- en: 'As we learned in chapter 4, URL query parameters allow us to filter and sort
    the results of a GET endpoint. In this section, we learn to define URL query parameters
    using OpenAPI. The GET `/orders` endpoint allows us to filter orders using the
    following parameters:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 4 章中学到的，URL 查询参数允许我们过滤和排序 GET 端点的结果。在本节中，我们将学习如何使用 OpenAPI 定义 URL 查询参数。GET
    `/orders` 端点允许我们使用以下参数过滤订单：
- en: '`cancelled`—Whether the order was cancelled. This value will be a Boolean.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cancelled`—订单是否被取消。此值将是一个布尔值。'
- en: '`limit`—Specifies the maximum number of orders that should be returned to the
    user. The value for this parameter will be a number.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit`—指定应返回给用户的最大订单数。此参数的值将是一个数字。'
- en: 'Both `cancelled` and `limit` can be combined within the same request to filter
    the results:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`cancelled` 和 `limit` 都可以在同一请求中组合使用以过滤结果：'
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This request asks the server for a list of five orders that have been cancelled.
    Listing 5.5 shows the specification for the GET `/orders` endpoint’s query parameters.
    The definition of a parameter requires a `name`, which is the value we use to
    refer to it in the actual URL. We also specify what `type` of parameter it is.
    OpenAPI 3.1 distinguishes four types of parameters: path parameters, query parameters,
    header parameters, and cookie parameters. Header parameters are parameters that
    go in an HTTP header field, while cookie parameters go into a cookie payload.
    Path parameters are part of the URL path and are typically used to identify a
    resource. For example, in `/orders/` `{order_id},` `order_id` is a path parameter
    that identifies a specific order. Query parameters are optional parameters that
    allow us to filter and sort the results of an endpoint. We define the parameter’s
    type using the `schema` keyword (Boolean in the case of `cancelled`, and a number
    in the case of `limit`), and, when relevant, we specify the `format` of the parameter
    as well.[⁵](#pgfId-1305171)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此请求要求服务器列出五个已取消的订单。列表5.5显示了GET `/orders`端点查询参数的规范。参数的定义需要一个`name`，这是我们实际URL中用来引用它的值。我们还指定了它是哪种`type`的参数。OpenAPI
    3.1区分四种类型的参数：路径参数、查询参数、头参数和cookie参数。头参数是放入HTTP头字段中的参数，而cookie参数放入cookie有效载荷中。路径参数是URL路径的一部分，通常用于标识资源。例如，在`/orders/`
    `{order_id}`中，`order_id`是一个路径参数，用于标识一个特定的订单。查询参数是可选参数，允许我们过滤和排序端点的结果。我们使用`schema`关键字（对于`cancelled`是布尔值，对于`limit`是数字）来定义参数的类型，并在相关的情况下，我们还指定了参数的`format`。[⁵](#pgfId-1305171)
- en: Listing 5.5 Specification for the GET `/orders` endpoint’s query parameters
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5 GET `/orders`端点查询参数规范
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① We describe URL query parameters under the parameters property.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们在“参数”属性下描述URL查询参数。
- en: ② The parameter’s name
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ② 参数的名称
- en: ③ We use the in descriptor to specify that the parameter goes in the URL path.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们使用in描述符来指定参数位于URL路径中。
- en: ④ We specify whether the parameter is required.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们指定参数是否必需。
- en: ⑤ We specify the parameter’s type under schema.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们在“模式”下指定参数的类型。
- en: 'Now that we know how to describe URL query parameters, in the next section
    we’ll tackle something more complex: documenting request payloads.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何描述URL查询参数，在下一节中，我们将处理更复杂的事情：记录请求有效载荷。
- en: 5.5 Documenting request payloads
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 记录请求有效载荷
- en: 'In chapter 4, we learned that a request represents the data sent by a client
    to the server through a POST or a PUT request. In this section, we learn to document
    the request payloads of the orders API endpoints. Let’s start with the POST `/orders`
    method. In section 5.1, we established that the payload for the POST `/orders`
    endpoint looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，我们了解到一个请求代表客户端通过POST或PUT请求发送给服务器的数据。在本节中，我们将学习如何记录订单API端点的请求有效载荷。让我们从POST
    `/orders`方法开始。在第5.1节中，我们确定了POST `/orders`端点的有效载荷如下所示：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This payload contains an attribute `order`, which represents an array of items.
    Each item is defined by the following three attributes and constraints:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此有效载荷包含一个名为`order`的属性，它表示一个物品数组。每个物品由以下三个属性和约束定义：
- en: '`product`—The type of product the user is ordering.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product`—用户订购的产品类型。'
- en: '`size`—The size of the product. It can be one of the three following choices:
    `small`, `medium`, and `big`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`—产品的尺寸。它可以有以下三种选择之一：`small`、`medium`和`big`。'
- en: '`quantity`—The amount of the product. It can be any integer number equal to
    or greater than 1.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quantity`—产品的数量。它可以是一个等于或大于1的任何整数。'
- en: 'Listing 5.6 shows how we define the schema for this payload. We define request
    payloads under the `content` property of the method’s `requestBody` property.
    We can specify payloads in different formats. In this case, we allow data only
    in JSON format, which has a media type definition of `application/json`. The schema
    for our payload is an object with one property: `order`, whose type is `array`.
    The items in the array are objects with three properties: the `product` property,
    with type `string`; the `size` property, with type `string`; and the `quantity`
    property, with type `integer`. In addition, we define an enumeration for the `size`
    property, which constrains the accepted values to `small`, `medium`, and `big`.
    Finally, we also provide a default value of `1` for the `quantity` property, since
    it’s the only nonrequired field in the payload. Whenever a user sends a request
    containing an item without the `quantity` property, we assume that they want to
    order only one unit of that item.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 展示了如何定义此负载的方案。我们在方法的 `requestBody` 属性的 `content` 属性下定义请求负载。我们可以以不同的格式指定负载。在这种情况下，我们只允许
    JSON 格式的数据，其媒体类型定义为 `application/json`。我们的负载模式是一个具有一个属性的对象：`order`，其类型为 `array`。数组中的项是具有三个属性的对象：`product`
    属性，类型为 `string`；`size` 属性，类型为 `string`；和 `quantity` 属性，类型为 `integer`。此外，我们还为 `size`
    属性定义了一个枚举，将接受的值限制为 `small`、`medium` 和 `big`。最后，我们还为 `quantity` 属性提供了一个默认值 `1`，因为它是在负载中唯一的非必需字段。每当用户发送包含没有
    `quantity` 属性的项目的请求时，我们假设他们只想订购该项目的单个单位。
- en: Listing 5.6 Specification for the POST `/orders` endpoint
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 规范 POST `/orders` 端点
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① We describe request payloads under requestBody.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们在 requestBody 下描述请求负载。
- en: ② We specify whether the payload is required.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们指定负载是否必需。
- en: ③ We specify the payload’s content type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们指定负载的内容类型。
- en: ④ We define the payload’s schema.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们定义负载的方案。
- en: ⑤ We can constrain the property’s values using an enumeration.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们可以使用枚举来约束属性的值。
- en: ⑥ We specify a default value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们指定一个默认值。
- en: Embedding payload schemas within the endpoints’ definitions, as in listing 5.6,
    can make our specification more difficult to read and understand. In the next
    section, we learn to refactor payload schemas for reusability and for readability.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 5.6 所示，在端点的定义中嵌入负载模式可以使我们的规范更难以阅读和理解。在下一节中，我们将学习如何重构负载模式以提高可重用性和可读性。
- en: 5.6 Refactoring schema definitions to avoid repetition
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 重构模式定义以避免重复
- en: 'In this section, we learn strategies for refactoring schemas to keep the API
    specification clean and readable. The definition of the POST `/orders` endpoint
    in listing 5.6 is long and contains several layers of indentation. As a result,
    it’s difficult to read, and that means in the future it’ll become difficult to
    extend and to maintain. We can do better by moving the payload’s schema to a different
    section of the API specification: the `components` section. As we explained in
    section 5.2, the `components` section is used to declare schemas that are referenced
    across the specification. Every schema is an object where the key is the name
    of the schema, and the values are the properties that describe it.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习重构模式以保持 API 规范清洁和可读的策略。列表 5.6 中的 POST `/orders` 端点定义很长，包含多层缩进。因此，它难以阅读，这意味着将来它将难以扩展和维护。我们可以通过将负载模式移至
    API 规范的不同部分（即 `components` 部分）来做得更好。正如我们在 5.2 节中解释的，`components` 部分用于声明在规范中引用的方案。每个方案都是一个对象，其中键是方案名称，值是描述它的属性。
- en: Listing 5.7 Specification for the POST `/orders` endpoint using a JSON pointer
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 使用 JSON 指针规范 POST `/orders` 端点的规范
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① We use a JSON pointer to reference a schema defined somewhere else in the
    document.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们使用 JSON 指针引用文档中其他地方定义的方案。
- en: ② Schema definitions go under components.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ② 模式定义位于 components 下。
- en: ③ Every schema is an object, where the key is the name and the values are the
    properties that describe it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 每个方案都是一个对象，其中键是名称，值是描述它的属性。
- en: 'Moving the schema for the POST `/orders` request payload under the `components`
    section of the API makes the document more readable. It allows us to keep the
    `paths` section of the document clean and focused on the higher-level details
    of the endpoint. We simply need to refer to the `CreateOrderSchema` schema using
    a JSON pointer:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将 POST `/orders` 请求负载的模式移至 API 的 `components` 部分可以使文档更易于阅读。它允许我们保持文档的 `paths`
    部分清洁并专注于端点的高级细节。我们只需通过 JSON 指针引用 `CreateOrderSchema` 模式即可：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The specification is looking good, but it can get better. `CreateOrderSchema`
    is a tad long, and it contains several layers of nested definitions. If `CreateOrderSchema`
    grows in complexity, over time it’ll become difficult to read and maintain. We
    can make it more readable by refactoring the definition of the `order` item in
    the array in the following code. This strategy allows us to reuse the schema for
    the order’s item in other parts of the API.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 规范看起来不错，但可以做得更好。`CreateOrderSchema`有点长，并且包含多层嵌套定义。如果`CreateOrderSchema`变得复杂，随着时间的推移，它将变得难以阅读和维护。我们可以通过以下代码中数组中`order`项的定义重构来使其更易于阅读。这种策略允许我们在API的其他部分重用订单项的架构。
- en: Listing 5.8 Schema definitions for `OrderItemSchema` and `Order`
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.8 `OrderItemSchema`和`Order`的架构定义
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① We introduce the OrderItemSchema.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们引入了OrderItemSchema。
- en: ② We use a JSON pointer to point to OrderItemSchema.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用JSON指针指向OrderItemSchema。
- en: Our schemas are looking good! The `CreateOrderSchema` schema can be used to
    create an order or to update it, so we can reuse it in the PUT `/orders/{order_id}`
    endpoint, as you can see in listing 5.9\. As we learned in chapter 4, the `/orders/{order_id}`
    URL path represents a singleton resource, and therefore the URL contains a path
    parameter, which is the order’s ID. In OpenAPI, path parameters are represented
    between curly braces. We specify that the `order_id` parameter is a string with
    a UUID format (a long, random string often used as an ID).[⁶](#pgfId-1305342)
    We define the URL path parameter directly under the URL path to make sure it applies
    to all HTTP methods.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式看起来不错！`CreateOrderSchema`架构可用于创建订单或更新订单，因此我们可以在PUT `/orders/{order_id}`端点中重用它，如列表5.9所示。正如我们在第4章中学到的，`/orders/{order_id}`
    URL路径代表一个单例资源，因此URL包含一个路径参数，即订单的ID。在OpenAPI中，路径参数用大括号表示。我们指定`order_id`参数是一个具有UUID格式的字符串（一个长随机字符串，常用于ID）。[⁶](#pgfId-1305342)
    我们直接在URL路径下定义URL路径参数，以确保它适用于所有HTTP方法。
- en: Listing 5.9 Specification for the PUT `/orders/{order_id}` endpoint
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.9 PUT `/orders/{order_id}`端点的规范
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① We declare the order’s resource URL.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们声明订单的资源URL。
- en: ② We define the URL path parameter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们定义URL路径参数。
- en: ③ The order_id parameter is part of the URL path.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ③ order_id参数是URL路径的一部分。
- en: ④ The name of the parameter
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 参数的名称
- en: ⑤ The order_id parameter is required.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ order_id参数是必需的。
- en: ⑥ We specify the parameter’s format (UUID).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们指定参数的格式（UUID）。
- en: ⑦ We define the HTTP method PUT for the current URL path.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们为当前URL路径定义HTTP方法PUT。
- en: ⑧ We document the request body of the PUT endpoint.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 我们记录了PUT端点的请求体。
- en: Now that we understand how to define the schemas for our request payloads, let’s
    turn our attention to the responses.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何定义请求有效载荷的架构，让我们将注意力转向响应。
- en: 5.7 Documenting API responses
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7 记录API响应
- en: 'In this section, we learn to document API responses. We start by defining the
    payload for the GET `/orders/{order_id}` endpoint. The response of the GET `/orders/`
    `{order_id}` endpoint looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习如何记录API响应。我们首先定义GET `/orders/{order_id}`端点的有效载荷。GET `/orders/` `{order_id}`端点的响应如下：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This payload shows the products ordered by the user, when the order was placed,
    and the status of the order. This payload is similar to the request payload we
    defined in section 5.6 for the POST and PUT endpoints, so we can reuse our previous
    schemas.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此有效载荷显示了用户订购的产品、订单的放置时间和订单的状态。此有效载荷与我们在第5.6节中为POST和PUT端点定义的请求有效载荷类似，因此我们可以重用之前的模式。
- en: Listing 5.10 Definition of the `GetOrderSchema` schema
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.10 `GetOrderSchema`架构的定义
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① We define the GetOrderSchema schema.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们定义GetOrderSchema架构。
- en: ② We constrain the values of the status property with an enumeration.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用枚举约束状态属性的值。
- en: ③ A string with date-time format
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 具有日期时间格式的字符串
- en: ④ We reference the OrderItemSchema schema using a JSON pointer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们使用JSON指针引用OrderItemSchema模式。
- en: In listing 5.10, we use a JSON pointer to point to `GetOrderSchema`. An alternative
    way to reuse the existing schemas is to use inheritance. In OpenAPI, we can inherit
    and extend a schema using a strategy called *model composition*, which allows
    us to combine the properties of different schemas in a single object definition.
    The special keyword `allOf` is used in these cases to indicate that the object
    requires all the properties in the listed schemas.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 5.10 中，我们使用 JSON 指针指向 `GetOrderSchema`。另一种重用现有模式的方法是使用继承。在 OpenAPI 中，我们可以使用称为
    *模型组合* 的策略来继承和扩展一个模式，这允许我们在单个对象定义中结合不同模式的属性。在这些情况下，使用特殊关键字 `allOf` 来指示该对象需要列出的模式中的所有属性。
- en: DEFINITION *Model composition* is a strategy in JSON Schema that allows us to
    combine the properties of different schemas into a single object. It is useful
    when a schema contains properties that have already been defined elsewhere, and
    therefore allows us to avoid repetition.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *模型组合* 是 JSON Schema 中的一种策略，允许我们将不同模式的属性组合成一个单一的对象。当模式包含已在其他地方定义的属性时，它非常有用，因此可以避免重复。
- en: 'The following code shows an alternative definition of `GetOrderSchema` using
    the `allOf` keyword. In this case, `GetOrderSchema` is the composition of two
    other schemas: `CreateOrderSchema` and an anonymous schema with two keys—`status`
    and `created`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了使用 `allOf` 关键字对 `GetOrderSchema` 的另一种定义。在这种情况下，`GetOrderSchema` 是两个其他模式的组合：`CreateOrderSchema`
    和一个包含两个键——`status` 和 `created` 的匿名模式。
- en: Listing 5.11 Alternative implementation of `GetOrderSchema` using the `allOf`
    keyword
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.11 使用 `allOf` 关键字对 `GetOrderSchema` 的替代实现
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① We use the allOf keyword to inherit properties from other schemas.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们使用 `allOf` 关键字从其他模式继承属性。
- en: ② We use a JSON pointer to reference another schema.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用 JSON 指针引用另一个模式。
- en: ③ We define a new object to include properties that are specific to GetOrderSchema.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们定义了一个新对象，以包含特定于 `GetOrderSchema` 的属性。
- en: Model composition results in a cleaner and more succinct specification, but
    it only works if the schemas are strictly compatible. If we decide to extend `CreateOrderSchema`
    with new properties, then this schema may no longer be transferable to the `GetOrderSchema`
    model. In that sense, it’s sometimes better to look for common elements among
    different schemas and refactor their definitions into standalone schemas.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 模型组合导致更简洁的规范，但它仅在模式严格兼容时才有效。如果我们决定通过新属性扩展 `CreateOrderSchema`，那么这个模式可能就不再适用于
    `GetOrderSchema` 模型。从这个意义上说，有时最好在不同的模式中寻找共同元素，并将它们的定义重构为独立的模式。
- en: Now that we have the schema for the GET `/orders/{order_id}` endpoint’s response
    payload, we can complete the endpoint’s specification. We define the endpoint’s
    responses as objects in which the key is the response’s status code, such as 200\.
    We also describe the response’s content type and its schema, `GetOrderSchema`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 GET `/orders/{order_id}` 端点响应负载的规范，我们可以完成端点的规范。我们将端点的响应定义为对象，其键是响应的状态码，例如
    200。我们还描述了响应的内容类型及其模式，`GetOrderSchema`。
- en: Listing 5.12 Specification for the GET `/orders/{order_id}` endpoint
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12 GET `/orders/{order_id}` 端点的规范
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① We define the GET endpoint of the /orders/{order_id} URL path.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们定义了 /orders/{order_id} URL 路径的 GET 端点。
- en: ② We provide a summary description of this endpoint.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们提供了此端点的摘要描述。
- en: ③ We define this endpoint’s responses.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们定义了这个端点的响应。
- en: ④ Each response is an object where the key is the status code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 每个响应都是一个对象，其键是状态码。
- en: ⑤ A brief description of the response
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 对响应的简要描述
- en: ⑥ We describe the content types of the response.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们描述了响应的内容类型。
- en: ⑦ We use a JSON pointer to reference GetOrderSchema.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们使用 JSON 指针引用 `GetOrderSchema`。
- en: As you can see, we define response schemas within the `responses` section of
    the endpoint. In this case, we only provide the specification for the 200 (OK)
    successful response, but we can also document other status codes, such as error
    responses. The next section explains how we create generic responses we can reuse
    across our endpoints.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在端点的 `responses` 部分定义了响应模式。在这种情况下，我们只提供了 200 (OK) 成功响应的规范，但我们也可以记录其他状态码，例如错误响应。下一节解释了我们如何创建可以在端点之间重用的通用响应。
- en: 5.8 Creating generic responses
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.8 创建通用响应
- en: In this section, we learn to add error responses to our API endpoints. As we
    mentioned in chapter 4, error responses are more generic, so we can use the `components`
    section of the API specification to provide generic definitions of those responses,
    and then reuse them in our endpoints.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习如何向我们的 API 端点添加错误响应。正如我们在第 4 章中提到的，错误响应更为通用，因此我们可以使用 API 规范的 `components`
    部分提供这些响应的通用定义，然后在我们的端点中重复使用它们。
- en: We define generic responses within the `responses` header of the API’s `components`
    section. The following shows a generic definition for a 404 response named `NotFound`.
    As with any other response, we also document the content’s payload, which in this
    case is defined by the `Error` schema.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 API 的 `components` 部分的 `responses` 标题内定义通用响应。以下是一个名为 `NotFound` 的 404 响应的通用定义。与任何其他响应一样，我们也记录了内容的有效负载，在这种情况下，它由
    `Error` 架构定义。
- en: Listing 5.13 Generic `404` status code response definition
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.13 通用 `404` 状态码响应定义
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① Generic responses go under responses in the components section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ① 通用响应位于组件部分的 responses 下。
- en: ② We name the response.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们命名了响应。
- en: ③ We describe the response.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们描述了响应。
- en: ④ We define the response’s content.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们定义了响应的内容。
- en: ⑤ We reference the Error schema.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们引用了 Error 架构。
- en: ⑥ We define the schema for the Error payload.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们定义了 Error 有效负载的架构。
- en: This specification for the 404 response can be reused in the specification of
    all our endpoints under the `/orders/{order_id}` URL path, since all of those
    endpoints are specifically designed to target a specific resource.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些端点都是专门设计来针对特定资源的，因此这个 404 响应的规范可以在 `/orders/{order_id}` URL 路径下所有端点的规范中重复使用。
- en: NOTE You may be wondering, if certain responses are common to all the endpoints
    of a URL path, why can’t we define the responses directly under the URL path and
    avoid repetition? The answer is this isn’t possible as of now. The `responses`
    keyword is not allowed directly under a URL path, so we must document all the
    responses for every endpoint individually. There’s a request in the OpenAPI GitHub
    repository to allow including common responses directly under the URL path, but
    it hasn’t been implemented ([http://mng.bz/097p](http://mng.bz/097p)).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可能想知道，如果某些响应对所有 URL 路径的端点都是通用的，为什么我们不能直接在 URL 路径下定义响应以避免重复？答案是，目前这是不可能的。`responses`
    关键字不允许直接位于 URL 路径下，因此我们必须为每个端点单独记录所有响应。OpenAPI GitHub 仓库中有一个请求，允许直接在 URL 路径下包含通用响应，但尚未实现([http://mng.bz/097p](http://mng.bz/097p))。
- en: We can use the generic 404 response from listing 5.13 under the GET `/orders/`
    `{order_id}` endpoint.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 GET `/orders/` `{order_id}` 端点下使用列表 5.13 中的通用 404 响应。
- en: Listing 5.14 Using the 404 response schema under GET `/orders/{order_id}`
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.14 在 GET `/orders/{order_id}` 下使用 404 响应架构
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① We define a 404 response.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们定义了一个 404 响应。
- en: ② We reference the NotFound response using a JSON pointer.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用 JSON 指针引用 NotFound 响应。
- en: The orders API specification in the GitHub repository for this book also contains
    a generic definition for 422 responses and an expanded definition of the `Error`
    component that accounts for the different error payloads we get from FastAPI.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本书 GitHub 仓库中的订单 API 规范还包含了对 422 响应的通用定义和对 `Error` 组件的扩展定义，该定义考虑了从 FastAPI 获得的不同错误有效负载。
- en: We’re nearly done. The only remaining endpoint is GET `/orders`, which returns
    a list of orders. The endpoint’s payload reuses `GetOrderSchema` to define the
    items in the `orders` array.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。唯一剩下的端点是 GET `/orders`，它返回订单列表。端点有效负载重复使用 `GetOrderSchema` 来定义 `orders`
    数组中的项目。
- en: Listing 5.15 Specification for the GET `/orders` endpoint
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.15 GET `/orders` 端点的规范
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① We define the new GET method of the /orders URL path.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们定义了 /orders URL 路径的新 GET 方法。
- en: ② orders is an array.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ② 订单是一个数组。
- en: ③ Each item in the array is defined by GetOrderSchema.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 数组中的每个项目都由 GetOrderSchema 定义。
- en: Our API’s endpoints are now fully documented! You can use many more elements
    within the definitions of your endpoints, such as `tags` and `externalDocs`. These
    attributes are not strictly necessary, but they can help to provide more structure
    to your API or make it easier to group the endpoints. For example, you can use
    `tags` to create groups of endpoints that logically belong together or share common
    features.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 API 的端点现在已完全记录！你可以在端点的定义中使用许多其他元素，例如 `tags` 和 `externalDocs`。这些属性不是严格必要的，但可以帮助提供更多结构给你的
    API 或使其更容易分组端点。例如，你可以使用 `tags` 创建逻辑上属于一起或具有共同特征的端点组。
- en: 'Before we finish this chapter, there’s one more topic we need to address: documenting
    the authentication scheme of our API. That’s the topic of the next section!'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本章之前，还有一个话题我们需要解决：记录我们 API 的认证方案。这就是下一节的主题！
- en: 5.9 Defining the authentication scheme of the API
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.9 定义 API 的认证方案
- en: If our API is protected, the API specification must describe how users need
    to authenticate and authorize their requests. This section explains how we document
    our API’s security schemes. The security definitions of the API go within the
    `components` section of the specification, under the `securitySchemes` header.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的 API 受保护，API 规范必须描述用户如何进行身份验证和授权他们的请求。本节解释了我们如何记录我们的 API 安全方案。API 的安全定义位于规范中的
    `components` 部分的 `securitySchemes` 标题下。
- en: With OpenAPI, we can describe different security schemes, such as HTTP-based
    authentication, key-based authentication, Open Authorization 2 (OAuth2), and OpenID
    Connect.[⁷](#pgfId-1305609) In chapter 11, we’ll implement authentication and
    authorization using the OpenID Connect and OAuth2 protocols, so let’s go ahead
    and add definitions for these schemes. Listing 5.16 shows the changes we need
    to make to our API specification to document the security schemes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenAPI，我们可以描述不同的安全方案，例如基于 HTTP 的认证、基于密钥的认证、开放授权 2 (OAuth2) 和 OpenID Connect。[⁷](#pgfId-1305609)
    在第 11 章中，我们将使用 OpenID Connect 和 OAuth2 协议实现认证和授权，因此让我们继续添加这些方案的定义。列表 5.16 展示了我们需要对我们的
    API 规范进行的更改，以记录安全方案。
- en: 'We describe three security schemes: one for OpenID Connect, another one for
    OAuth2, and another for bearer authorization. We’ll use OpenID Connect to authorize
    user access through a frontend application, and for direct API integrations, we’ll
    offer OAuth’s client credentials flow. We’ll explain how each protocol and each
    authorization flow works in detail in chapter 11\. For OpenID Connect, we must
    provide a configuration URL that describes how our backend authentication works
    under the `openIdConnectUrl` property. For OAuth2, we must describe the authorization
    flows available, together with a URL that clients must use to obtain their authorization
    tokens and the available scopes. The bearer authorization tells users that they
    must include a JSON Web Token (JWT) in the Authorization header to authorize their
    requests.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了三种安全方案：一个用于 OpenID Connect，另一个用于 OAuth2，还有一个用于携带授权。我们将使用 OpenID Connect
    通过前端应用程序授权用户访问，对于直接 API 集成，我们将提供 OAuth 的客户端凭据流。在第 11 章中，我们将详细解释每个协议和每个授权流程的工作原理。对于
    OpenID Connect，我们必须提供一个配置 URL，该 URL 描述了我们的后端身份验证如何在 `openIdConnectUrl` 属性下工作。对于
    OAuth2，我们必须描述可用的授权流程，以及客户端必须使用的 URL 来获取他们的授权令牌和可用的作用域。携带授权告诉用户，他们必须在授权头中包含一个 JSON
    Web Token (JWT) 来授权他们的请求。
- en: Listing 5.16 Documenting an API’s security scheme
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.16 记录 API 的安全方案
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① The security schemes under the securitySchemes header of the API’s components
    section
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ① API 组件部分的 `securitySchemes` 标题下的安全方案
- en: ② We provide a name for the security scheme (it can be any name).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们为安全方案提供一个名称（可以是任何名称）。
- en: ③ The type of security scheme
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 安全方案的类型
- en: ④ The URL that describes the OpenID Connect configuration in our backend
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 描述我们后端 OpenID Connect 配置的 URL
- en: ⑤ The name of another security scheme
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 另一个安全方案的名称
- en: ⑥ The type of the security scheme
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 安全方案的类型
- en: ⑦ The authorization flows available under this security scheme
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 此安全方案下的可用授权流程
- en: ⑧ A description of the client credentials flow
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 客户端凭据流的描述
- en: ⑨ The URL where users can request authorization tokens
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 用户可以请求授权令牌的 URL
- en: ⑩ The available scopes when requesting an authorization token
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 请求授权令牌时的可用作用域
- en: ⑪ The bearer token has a JSON Web Token (JWT) format.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 携带令牌具有 JSON Web Token (JWT) 格式。
- en: This concludes our journey through documenting REST APIs with OpenAPI. And what
    a ride! You’ve learned how to use JSON Schema; how OpenAPI works; how to structure
    an API specification; how to break down the process of documenting your API into
    small, progressive steps; and how to produce a full API specification. The next
    time you work on an API, you’ll be well positioned to document its design using
    these standard technologies.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们通过 OpenAPI 记录 REST API 的旅程结束。这是一次多么精彩的旅程！你学习了如何使用 JSON Schema；OpenAPI
    的工作原理；如何构建 API 规范；如何将记录 API 的过程分解为小而渐进的步骤；以及如何生成完整的 API 规范。下次你处理 API 时，你将能够使用这些标准技术来记录其设计。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: JSON Schema is a specification for defining the types and formats of the properties
    of a JSON document. JSON Schema is useful for defining data validation models
    in a language-agnostic manner.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON Schema是定义JSON文档属性类型和格式的规范。JSON Schema以语言无关的方式定义数据验证模型非常有用。
- en: OpenAPI is a standard documentation format for describing REST APIs and uses
    JSON Schema to describe the properties of the API. By using OpenAPI, you’re able
    to leverage the whole ecosystem of tools and frameworks built around the standard,
    which makes it easier to build API integrations.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAPI是描述REST API的标准文档格式，并使用JSON Schema来描述API的属性。通过使用OpenAPI，您可以利用围绕标准构建的整个工具和框架生态系统，这使得构建API集成变得更加容易。
- en: A JSON pointer allows you to reference a schema using the `$ref` keyword. Using
    JSON pointers, we can create reusable schema definitions that can be used in different
    parts of an API specification, keeping the API specification clean and easy to
    understand.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON指针允许您使用`$ref`关键字引用模式。使用JSON指针，我们可以创建可重用的模式定义，这些定义可以在API规范的不同部分中使用，从而保持API规范整洁且易于理解。
- en: 'An OpenAPI specification contains the following sections:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAPI规范包含以下部分：
- en: '`openapi`—Specifies the version of OpenAPI used to document the API'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openapi`—指定用于记录API的OpenAPI版本'
- en: '`info`—Contains information about the API, such as its title and version'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`—包含有关API的信息，例如其标题和版本'
- en: '`servers`—Documents the URLs under which the API is available'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`servers`—记录API可用的URL'
- en: '`paths`—Describes the endpoints exposed by the API, including the schemas for
    the API requests and responses and any relevant URL path or query parameters'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paths`—描述API公开的端点，包括API请求和响应的模式以及任何相关的URL路径或查询参数'
- en: '`components`—Describes reusable components of the API, such as payload schemas,
    generic responses, and authentication schemes'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components`—描述API的可重用组件，例如有效载荷模式、通用响应和身份验证方案'
- en: '* * *'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '¹ A. Wright, H. Andrews, B. Hutton, “JSON Schema: A Media Type for Describing
    JSON Documents” (December 8, 2020); [https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-00](https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-00).
    You can follow the development of JSON Schema and contribute to its improvement
    by participating in its repository in GitHub: [https://github.com/json-schema-org/json-schema-spec](https://github.com/json-schema-org/json-schema-spec).
    Also see the website for the project: [https://json-schema.org/](https://json-schema.org/).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '¹ A. Wright, H. Andrews, B. Hutton, “JSON Schema: A Media Type for Describing
    JSON Documents” (December 8, 2020); [https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-00](https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-00)。您可以通过参与GitHub上的其仓库来跟踪JSON
    Schema的发展并为其改进做出贡献：[https://github.com/json-schema-org/json-schema-spec](https://github.com/json-schema-org/json-schema-spec)。还可以查看项目的网站：[https://json-schema.org/](https://json-schema.org/)。'
- en: '² For a detailed analysis of the differences between OpenAPI 3.0 and 3.1, check
    out OpenAPI’s migration from 3.0 to 3.1 guide: [https://www.openapis.org/blog/2021/02/16/migrating-from-openapi-3-0-to-3-1-0](https://www.openapis.org/blog/2021/02/16/migrating-from-openapi-3-0-to-3-1-0).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ² 要详细了解OpenAPI 3.0和3.1之间的差异，请查看OpenAPI从3.0迁移到3.1的指南：[https://www.openapis.org/blog/2021/02/16/migrating-from-openapi-3-0-to-3-1-0](https://www.openapis.org/blog/2021/02/16/migrating-from-openapi-3-0-to-3-1-0)。
- en: ³ According to the 2022 “State of the API” report by Postman ([https://www.postman.com/state-of-api/api-technologies/#api-technologies](https://www.postman.com/state-of-api/api-technologies/#api-technologies)).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 根据2022年Postman发布的“API状态”报告([https://www.postman.com/state-of-api/api-technologies/#api-technologies](https://www.postman.com/state-of-api/api-technologies/#api-technologies))。
- en: ⁴ See [https://swagger.io/docs/specification/components/](https://swagger.io/docs/specification/components/)
    for a full list of reusable elements that can be defined in the `components` section
    of the API specification.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 有关API规范中`components`部分可以定义的所有可重用元素的完整列表，请参阅[https://swagger.io/docs/specification/components/](https://swagger.io/docs/specification/components/)。
- en: ⁵ To learn more about the date types and formats available in OpenAPI 3.1 see
    [http://spec.openapis.org/oas/v3.1.0#data-types](http://spec.openapis.org/oas/v3.1.0#data-types).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ⁵ 要了解OpenAPI 3.1中可用的日期类型和格式，请参阅[http://spec.openapis.org/oas/v3.1.0#data-types](http://spec.openapis.org/oas/v3.1.0#data-types)。
- en: ⁶ P. Leach, M. Mealling, and R. Salz, “A Universally Unique Identifier (UUID)
    URN Namespace,” RFC 4112 ([https://datatracker.ietf.org/doc/html/rfc4122](https://datatracker.ietf.org/doc/html/rfc4122)).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ⁶ P. Leach, M. Mealling, and R. Salz, “A Universally Unique Identifier (UUID)
    URN Namespace,” RFC 4112 ([https://datatracker.ietf.org/doc/html/rfc4122](https://datatracker.ietf.org/doc/html/rfc4122)).
- en: ⁷ For a complete reference of all the security schemas available in OpenAPI,
    see [https://swagger.io/docs/specification/authentication/](https://swagger.io/docs/specification/authentication/).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ⁷ 关于OpenAPI中所有可用安全模式的完整参考，请参阅[https://swagger.io/docs/specification/authentication/](https://swagger.io/docs/specification/authentication/).
