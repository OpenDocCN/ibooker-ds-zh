- en: Chapter 9\. Working with laziness
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 9 章：与惰性一起工作
- en: '***This chapter covers***'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖的内容***'
- en: Understanding the importance of laziness
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解惰性的重要性
- en: Implementing laziness in Java
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 中实现惰性
- en: 'Creating a lazy list data structure: the `Stream`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建惰性列表数据结构：`Stream`
- en: Optimizing lazy lists by memoizing evaluated values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过缓存已评估的值来优化惰性列表
- en: Handling infinite streams
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理无限流
- en: Some languages are said to be *lazy*, while others are not. Does this mean that
    some languages work harder than others? Not at all. Laziness is opposed to strictness.
    It has nothing to do with how hard a language can work, although you could sometimes
    think of lazy languages as languages that don’t require the programmer to work
    as hard as they must with strict ones.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有些语言被称为 *惰性的*，而有些则不是。这难道意味着有些语言比其他语言更努力工作吗？根本不是。惰性与严格性相对立。这与语言可以工作多努力没有关系，尽管有时你可以将惰性语言视为不需要像严格语言那样努力工作的语言。
- en: Laziness, as you’ll see, has many advantages for some specific problems, such
    as composing infinite data structures and evaluating error conditions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，对于某些特定问题，如组合无限数据结构和评估错误条件，惰性有许多优点。
- en: 9.1\. Understanding strictness and laziness
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. 理解严格性和惰性
- en: When applied to method arguments, strictness means that arguments are evaluated
    as soon as they’re received by the method. Laziness means that arguments are evaluated
    only when they’re needed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于方法参数时，严格性意味着参数在方法接收到它们时立即被评估。惰性意味着只有在需要时才会评估参数。
- en: 'Of course, strictness and laziness apply not only to method arguments, but
    to everything. For example, consider the following declaration:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，严格性和惰性不仅适用于方法参数，还适用于一切。例如，考虑以下声明：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, `x` is immediately evaluated to `5` because Java is a strict language;
    it performs the addition immediately. Let’s look at another example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`x` 立即被评估为 `5`，因为 Java 是一种严格的语言；它立即执行加法。让我们看看另一个例子：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In Java, as soon as the `x` variable is declared, the `getValue` method is called
    to provide the corresponding value. On the other hand, with a lazy language, the
    `getValue` method is only called if and when the `x` variable is to be used. This
    can make a huge difference.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，一旦声明了 `x` 变量，就会调用 `getValue` 方法来提供相应的值。另一方面，在惰性语言中，只有在 `x` 变量被使用时才会调用
    `getValue` 方法。这可能会产生巨大的差异。
- en: 'For example, look at the following Java program:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看以下 Java 程序：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This program will print `Returning 5` on the console because the `getValue`
    method will be called, although the returned value will never be used. In a lazy
    language, nothing would be evaluated, so nothing would be printed on the console.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将在控制台上打印 `Returning 5`，因为会调用 `getValue` 方法，尽管返回的值永远不会被使用。在惰性语言中，不会进行任何评估，因此控制台上不会打印任何内容。
- en: 9.1.1\. Java is a strict language
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1. Java 是一种严格的语言
- en: Java, in principle, has no option concerning laziness. Java is strict. Everything
    is evaluated immediately. Method arguments are said to be passed *by value*, which
    means first they’re evaluated, and then the evaluated value is passed. On the
    other hand, in lazy languages, arguments are said to be passed *by name*, which
    means *unevaluated*. Don’t be confused by the fact that method arguments in Java
    are often references. References are addresses, and these addresses are passed
    by value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Java 在原则上没有关于惰性的选择。Java 是严格的。一切都会立即被评估。方法参数被称为是按 *值* 传递的，这意味着首先进行评估，然后传递评估后的值。另一方面，在惰性语言中，参数被称为是按
    *名* 传递的，这意味着 *未评估的*。不要被 Java 中方法参数通常是引用的事实所迷惑。引用是地址，这些地址是按值传递的。
- en: Some languages are strict (like Java); others are lazy; some are strict by default
    and are optionally lazy; and others are lazy by default and are optionally strict.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言是严格的（如 Java）；其他是惰性的；有些默认是严格的，但可以选择惰性；还有一些默认是惰性的，但可以选择严格。
- en: 'Java, however, isn’t always strict. These are some lazy constructs in Java:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Java 并非总是严格的。以下是一些 Java 中的惰性结构：
- en: Boolean operators `||` and `&&`
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔运算符 `||` 和 `&&`
- en: Ternary operator `?:`
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三元运算符 `?:`
- en: '`if ... else`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if ... else`'
- en: '`for` loop'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: '`while` loop'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: Java 8 streams
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8 流
- en: If you think about it, you’ll soon realize that not much could be done if Java
    weren’t sometimes lazy. Can you imagine an `if ... else` structure where both
    branches were systematically evaluated? Or can you imagine a loop from which it
    was impossible to escape? All languages have to be lazy sometimes. This said,
    standard Java is often not lazy enough for functional programming.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细思考，很快就会意识到如果 Java 不时地不是那么“懒惰”，那么能做的事情就很少了。你能想象一个两个分支都会被系统性地评估的 `if ...
    else` 结构吗？或者你能想象一个无法逃离的循环吗？所有语言都必须在某种程度上“懒惰”。话虽如此，标准的 Java 对于函数式编程来说通常不够“懒惰”。
- en: 9.1.2\. The problem with strictness
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2\. 严格性的问题
- en: Strictness is so fundamental in languages like Java that it’s seen by many programmers
    as the only possibility for evaluating expressions, even if, in reality, nothing
    would be possible with a totally strict language. Moreover, Java’s documentation
    doesn’t use the words *non-strict* or *lazy* when describing lazy constructs.
    For example, the Boolean operators `||` and `&&` aren’t called *lazy*, but *short-circuiting*.
    But the simple reality is that these operators are non-strict regarding their
    arguments. We can easily show how this is different from a “strict” evaluation
    of method arguments.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Java 这样的语言中，严格性是如此基本，以至于许多程序员认为它是评估表达式的唯一可能性，即使在实际中，使用完全严格的语言什么也不可能实现。此外，Java
    的文档在描述懒惰结构时没有使用“非严格”或“懒惰”这样的词。例如，布尔运算符 `||` 和 `&&` 并不被称为“懒惰”，而是称为“短路”。但简单的事实是，这些运算符在它们的参数方面是非严格的。我们可以很容易地展示这与方法参数的“严格”评估有何不同。
- en: Imagine that you wanted to simulate Boolean operators with a function. The following
    listing shows what you could do.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你想要用一个函数来模拟布尔运算符。下面的列表显示了你可以做什么。
- en: Listing 9.1\. The `and` and `or` logical methods
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. `and` 和 `or` 逻辑方法
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are, of course, simpler ways to do this using the Boolean operators,
    but your goal here is to avoid these operators. Are you done? Running this program
    will display the following result on the console:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用布尔运算符有更简单的方法来做这件事，但你的目标是要避免这些运算符。你完成了吗？运行这个程序将在控制台上显示以下结果：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So far, so good. But now try running the following program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但现在尝试运行以下程序。
- en: Listing 9.2\. The problem with strictness
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2\. 严格性的问题
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This programs prints the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序打印以下内容：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Obviously, the `or` method isn’t equivalent to the `||` operator. The difference
    is that `||` evaluates its operand lazily, which means the second operand isn’t
    evaluated if the first one is `true`, because it’s not necessary for computing
    the result. But the `or` method evaluates its arguments strictly, which means
    that the second argument is evaluated even if its value isn’t needed, so the `IllegalStateException`
    is always thrown.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`or` 方法并不等同于 `||` 操作符。区别在于 `||` 会懒惰地评估其操作数，这意味着如果第一个操作数是 `true`，则不需要评估第二个操作数，因为它对计算结果没有影响。但是，`or`
    方法严格地评估其参数，这意味着即使第二个参数的值不需要，也会评估它，因此总是抛出 `IllegalStateException`。
- en: In [chapters 6](kindle_split_013.xhtml#ch06) and [7](kindle_split_014.xhtml#ch07)
    you encountered this problem with the `getOrElse` method because its argument
    was always evaluated, even if the computation was successful.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](kindle_split_013.xhtml#ch06) 和 [第 7 章](kindle_split_014.xhtml#ch07)
    中，你遇到了 `getOrElse` 方法的问题，因为其参数总是被评估，即使计算成功也是如此。
- en: 9.2\. Implementing laziness
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2\. 实现懒惰
- en: Laziness is necessary on many occasions. Java does in fact use laziness for
    constructs like `if ... else`, loops, and `try ... catch` blocks. Without laziness,
    a `catch` block, for example, would be evaluated even in the absence of an exception.
    Implementing laziness is a must when it comes to providing behavior for errors,
    as well as when you need to manipulate infinite data structures.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多场合，懒惰是必要的。实际上，Java 确实使用了懒惰来处理诸如 `if ... else`、循环和 `try ... catch` 块等结构。如果没有懒惰，例如，即使在没有异常的情况下，`catch`
    块也会被评估。在提供错误行为以及需要操作无限数据结构时，实现懒惰是必须的。
- en: 'Implementing laziness in Java isn’t fully possible, but you can produce a good
    approximation using the `Supplier` class you used in previous chapters:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中实现懒惰并不完全可能，但你可以使用之前章节中使用的 `Supplier` 类来产生一个很好的近似：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that you created your own class, but Java 8 also offers a `Supplier` class.
    Which one you use is up to you. They are completely equivalent.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你创建了自己的类，但 Java 8 也提供了一个 `Supplier` 类。你使用哪一个取决于你。它们是完全等价的。
- en: Using the `Supplier` class, you can rewrite the `BooleanMethods` example as
    follows.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Supplier` 类，你可以将 `BooleanMethods` 示例重写如下。
- en: Listing 9.3\. Using laziness to emulate Boolean operators
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.3. 使用惰性模拟布尔运算符
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This programs prints out the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序打印出以下内容：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The problem of laziness is nearly solved, although you’ve been forced to change
    the signature of your method. This is a low price to pay for using laziness. Of
    course, it might be overkill if the parameters are very quick to evaluate, or
    if they’re already evaluated, such as when using literal values. But it may save
    a great deal of time when evaluation requires a long computation. And if that
    evaluation isn’t free of side effects, it may completely change the outcome of
    the program.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性问题几乎已经解决，尽管你被迫改变了方法的签名。这是使用惰性所付出的低代价。当然，如果参数很快就能评估，或者它们已经被评估，比如使用字面值时，这可能有点过度。但如果有长计算需要评估，它可能会节省大量时间。而且如果评估不是无副作用的，它可能会完全改变程序的结果。
- en: 9.3\. Things you can’t do without laziness
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3. 没有惰性无法完成的事情
- en: 'So far, it may seem that the absence of laziness in evaluating expressions
    in Java isn’t a big deal. After all, why should you bother rewriting Boolean methods
    when you can use Boolean operators? There are, however, other cases where laziness
    would be useful. There are even several algorithms that can’t be implemented without
    resorting to laziness. I’ve already talked about how useless a strict version
    of `if ... else` would be. Think about the following algorithm:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，可能看起来Java在评估表达式时缺乏惰性并不是什么大问题。毕竟，为什么要在可以使用布尔运算符时重写布尔方法呢？然而，还有其他情况下惰性会有用。甚至有几个算法没有惰性是无法实现的。我已经讨论了严格的`if
    ... else`版本是多么的无用。想想以下算法：
- en: Take the list of positive integers.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取正整数列表。
- en: Filter the primes.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤素数。
- en: Return the list of the first ten results.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回前十个结果列表。
- en: This is an algorithm for finding the first ten primes, but this algorithm can’t
    be implemented without laziness. If you don’t believe me, just try it. Start with
    the first line. If you’re strict, you’ll first evaluate the list of positive integers.
    You’ll never have the opportunity to go to the second line, because the list of
    integers is infinite, and you’ll exhaust available memory before reaching the
    (nonexistent) end.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个寻找前十个素数的算法，但这个算法没有惰性是无法实现的。如果你不相信我，就试试看。从第一行开始。如果你很严格，你首先会评估正整数列表。你永远不会有机会到达第二行，因为整数列表是无限的，你会在达到（不存在的）终点之前耗尽可用内存。
- en: 'Clearly, this algorithm can’t be implemented without laziness, but you know
    how to replace it with a different algorithm. The preceding algorithm was functional.
    If you want to find the result without resorting to laziness, you’ll have to replace
    it with an imperative algorithm, like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个算法没有惰性是无法实现的，但你知道如何用不同的算法来替换它。前面的算法是函数式的。如果你想不依赖惰性找到结果，你必须用命令式算法来替换它，如下所示：
- en: Take the first integer.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取第一个整数。
- en: Check whether it’s a prime.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查它是否是素数。
- en: If it is, store it in a list.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，将其存储在列表中。
- en: Check whether this resulting list has ten elements.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查这个结果列表是否有十个元素。
- en: If it has ten elements, return it as the result.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它有十个元素，则将其作为结果返回。
- en: If not, increment the integer by 1.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有，将整数加1。
- en: Go to line 2.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到第二行。
- en: Sure, it works. But what a mess! First, it’s a bad recipe. Shouldn’t you increment
    the tested integer by 2 rather than by 1, in order to not test even numbers? And
    why test multiples of 3, 5, and so on? But more importantly, it doesn’t express
    the nature of the problem. It’s only a recipe for computing the result.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它工作。但多么混乱！首先，这是一个糟糕的配方。你不应该将测试的整数增加2而不是1，以避免测试偶数吗？为什么还要测试3、5等的倍数？但更重要的是，它没有表达问题的本质。它只是计算结果的一个配方。
- en: This isn’t to say that the implementation details (such as not testing even
    numbers) aren’t important for getting good performance. But these implementation
    details should be clearly separated from the problem definition. The imperative
    description isn’t a description of the problem—it’s a description of another problem
    giving the same result.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说实现细节（例如不测试偶数）对于获得良好的性能不重要。但这些实现细节应该与问题定义明确分开。命令式描述不是对问题的描述——它是对另一个给出相同结果的问题的描述。
- en: 'In functional programming, you generally solve this kind of problem with a
    special structure: the lazy list, called `Stream`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，你通常用一种特殊结构来解决这类问题：惰性列表，称为`Stream`。
- en: 9.4\. Why not use the Java 8 Stream?
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4. 为什么不使用Java 8 Stream？
- en: 'Java 8 introduced a new structure called `Stream`. Can you use it for this
    type of computation? Well, you could, but there are several reasons not to do
    this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8引入了一种新的结构称为`Stream`。你能用它来进行这种类型的计算吗？好吧，你可以，但有几个原因不这样做：
- en: Defining your own structure is far more rewarding. In doing so, you’ll learn
    and understand many things that you wouldn’t even have thought of if you were
    using Java 8 streams.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义自己的结构要更有回报。这样做，你会学到和理解许多你甚至都没有想过的事情，如果你使用的是Java 8流的话。
- en: Java streams are a very powerful tool, but not the tool you need. Java 8 streams
    were designed with the idea of automatic parallelization in mind. To allow for
    automatic parallelization, many compromises were made. Many functional methods
    are missing because they would have made automatic parallelization more difficult.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java流是一个非常强大的工具，但不是你需要的那把工具。Java 8流的设计考虑到了自动并行化的想法。为了允许自动并行化，做出了许多妥协。许多功能方法缺失，因为它们会使自动并行化变得更加困难。
- en: Java 8 streams are stateful. Once they’ve been used for some operations, they
    will have changed their state and are no longer usable.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8流是有状态的。一旦它们被用于某些操作，它们的状态就会改变，就不再可用了。
- en: Folding Java 8 streams is a strict operation that causes the evaluation of all
    elements.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8流的折叠是一个严格的操作，它会导致所有元素的评估。
- en: For all these reasons, you’ll define your own streams in this chapter. After
    you’ve finished this chapter, you may prefer to use the Java 8 streams, but you’ll
    do so fully understanding what’s missing in the Java 8 implementation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些原因，你将在本章中定义自己的流。完成本章后，你可能更喜欢使用Java 8流，但你会完全理解Java 8实现中缺少什么。
- en: 9.5\. Creating a lazy list data structure
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5\. 创建一个懒列表数据结构
- en: Now that you know how to represent non-evaluated data as instances of `Supplier`,
    you can easily define a lazy list data structure. It will be called `Stream` and
    will be very similar to the singly linked list you developed in [chapter 5](kindle_split_012.xhtml#ch05),
    with some subtle but very important differences. The following listing shows the
    starting point of your `Stream` data type.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何将未评估的数据表示为`Supplier`的实例，你可以轻松地定义一个懒列表数据结构。它将被命名为`Stream`，并且将与你在[第5章](kindle_split_012.xhtml#ch05)中开发的单链表非常相似，但有一些微妙但非常重要的区别。以下列表显示了你的`Stream`数据类型的起点。
- en: Listing 9.4\. The `Stream` data type
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.4\. `Stream`数据类型
- en: '![](Images/ch09ex04-0.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch09ex04-0.jpg)'
- en: '![](Images/ch09ex04-1.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch09ex04-1.jpg)'
- en: 'Here’s an example of how to use this `Stream` type:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用这种`Stream`类型的一个示例：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This program prints the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序会打印以下内容：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This probably doesn’t seem very useful. To make `Stream` a valuable tool, you’ll
    need to add some methods to it. But first you must optimize it slightly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来并不很有用。为了使`Stream`成为一个有价值的工具，你需要向其中添加一些方法。但首先你必须稍微优化它。
- en: 9.5.1\. Memoizing evaluated values
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.1\. 缓存已评估的值
- en: The idea behind laziness is that you can save time by evaluating data only when
    it’s needed. This implies that you must evaluate data when it’s first accessed.
    But reevaluating it on subsequent accesses is a waste of time. Because you’re
    writing functional programs, multiple evaluation won’t harm anything, but it will
    slow the program. One solution is to memoize the evaluated value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 懒性的理念是，你可以在需要时评估数据来节省时间。这暗示了你在第一次访问时必须评估数据。但在后续访问中重新评估它是浪费时间。因为你在编写函数式程序，多次评估不会伤害任何东西，但它会减慢程序。一个解决方案是缓存已评估的值。
- en: 'To do this, you’ll have to add fields for evaluated values in the `Cons` class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你必须在`Cons`类中添加用于已评估值的字段：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then change the getters as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下方式更改获取器：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This well-known technique isn’t specific to functional programming. It’s sometimes
    called *evaluation on demand*, or *evaluation as needed*, or *lazy evaluation*.
    When the value is asked for the first time, the evaluated field is `null`, so
    the value is evaluated. On subsequent access, the value won’t be evaluated again,
    and the previously evaluated value will be returned.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种众所周知的技术并不仅限于函数式编程。有时被称为*按需评估*，或*按需评估*，或*懒评估*。当第一次请求值时，评估字段是`null`，因此会进行评估。在后续访问中，值不会再次评估，并且会返回之前评估的值。
- en: Some languages offer lazy evaluation as a standard feature, whether by default
    or optionally. With such languages, you don’t need to resort to `null` references
    and mutable fields. Unfortunately, Java isn’t one of these languages. In Java,
    the most frequent approach when a value is to be initialized later is to first
    assign it the `null` reference if it’s an object type, or a sentinel value if
    it’s a primitive. This is risky because there’s no guarantee that the value will
    indeed be initialized to a significant value when needed. A `null` reference will
    probably cause a `NullPointerException` to be thrown, which at least will be noticed
    if exception handling has been implemented correctly, but a zero value could be
    an acceptable business value, leading to a program silently using this acceptable
    but incorrect value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言提供懒加载作为标准功能，无论是默认提供还是可选提供。在这样的语言中，你不需要求助于 `null` 引用和可变字段。不幸的是，Java 不是这些语言之一。在
    Java 中，当值稍后需要初始化时，最常见的方法是首先将其分配给 `null` 引用（如果它是对象类型），或者如果它是原始类型，则分配给哨兵值。这是有风险的，因为没有保证在需要时值确实会被初始化为一个有意义的值。`null`
    引用可能会抛出 `NullPointerException`，这至少会在异常处理被正确实现时被发现，但零值可能是一个可接受的业务值，导致程序静默地使用这个可接受但错误的价值。
- en: Alternatively, you could use a `Result<A>` to represent the value. This would
    avoid the use of the `null` reference, but you’d still have to use mutable fields.
    Because all this stuff is private, it’s acceptable to use `null`. But if you prefer,
    you can use a `Result` (or an `Option`) to represent the `h` and `t` fields.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `Result<A>` 来表示值。这将避免使用 `null` 引用，但你仍然需要使用可变字段。因为所有这些内容都是私有的，所以使用 `null`
    是可以接受的。但如果你愿意，可以使用 `Result`（或 `Option`）来表示 `h` 和 `t` 字段。
- en: Note that although the `h` and `t` fields must be mutable, they don’t need synchronization.
    The worst thing that may happen is that one thread will test the field and find
    it `null`, and then a second thread might also test the field before it has been
    initialized by the first one. The end result is that the field will have been
    initialized twice with potentially different (although equal) values. By itself,
    this isn’t a big problem; writing references is atomic, so the data can’t be corrupted.
    However, this could cause two instances of the corresponding object to coexist
    in memory. This won’t be a problem if you only test objects for equality, but
    it could be if you test them for identity (which, of course, you never do).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 `h` 和 `t` 字段必须是可变的，但它们不需要同步。最糟糕的情况是，一个线程将测试该字段并发现它是 `null`，然后第二个线程可能在第一个线程初始化它之前测试该字段。最终结果是该字段被初始化了两次，可能具有不同的（尽管相等）值。单从本身来看，这不是一个大问题；写入引用是原子的，所以数据不会被破坏。然而，这可能导致内存中存在对应对象的两个实例。如果你只测试对象是否相等，这不会是问题，但如果你测试它们是否具有相同的身份（当然，你永远不会这样做），则可能会出现问题。
- en: Also note that it’s possible to completely avoid `null` references and mutable
    fields at the cost of slight modifications in other places. Try to figure out
    how to do this. If you don’t know how, keep this idea in mind. We’ll come back
    to it near the end of this chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，可以通过在其他地方进行轻微修改来完全避免 `null` 引用和可变字段。尝试找出如何做到这一点。如果你不知道如何做到，请记住这个想法。我们将在本章末尾回到它。
- en: The following listing shows the complete `Stream` class with lazy evaluation
    of the `head` and `tail`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了具有懒加载 `head` 和 `tail` 的完整 `Stream` 类。
- en: Listing 9.5\. The complete `Stream` class
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. 完整的 `Stream` 类
- en: '![](Images/ch09ex05-0.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch09ex05-0.jpg)'
- en: '![](Images/ch09ex05-1.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch09ex05-1.jpg)'
- en: Exercise 9.1
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 9.1
- en: 'Write a `headOption` method that returns the evaluated `head` of the stream.
    This method will be declared in the `Stream` parent class with the following signature:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `headOption` 方法，该方法返回流评估后的 `head`。此方法将在 `Stream` 父类中声明，其签名如下：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Solution 9.2
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 9.2
- en: 'The `Empty` implementation returns an empty `Result`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 实现返回一个空的 `Result`：'
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Cons` implementation returns a `Success` of the evaluated `head`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cons` 实现返回评估后的 `head` 的 `Success`：'
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 9.5.2\. Manipulating streams
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.2\. 操作流
- en: In the remainder of this chapter, you’ll learn how to compose streams while
    making the most of the fact that the data is unevaluated. But in order to look
    at the streams, you’ll need a method to evaluate them. Evaluating all the elements
    of a stream can be done by converting it to a `List`. Or you can process a stream
    by evaluating only the first *n* elements, or by evaluating elements as long as
    a condition is met.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，你将学习如何在数据未评估的情况下组合流，并充分利用这一点。但为了查看流，你需要一个方法来评估它们。可以通过将其转换为 `List` 来评估流的所有元素。或者，你可以通过评估前
    *n* 个元素，或者通过评估满足条件直到条件不再满足的元素来处理流。
- en: Exercise 9.2
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 9.2
- en: Create a `toList` method to convert a `Stream` into a `List`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `toList` 方法，将 `Stream` 转换为 `List`。
- en: Hint
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You can implement an explicitly recursive method in the `Stream` class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `Stream` 类中实现一个显式的递归方法。
- en: Solution 9.2
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 9.2
- en: 'A recursive version will simply `cons` the `head` of the stream to the result
    of the `toList` method applied to the `tail`. Of course, you’ll need to make this
    process tail recursive in order to use `TailCall` to get a stack-safe implementation:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 递归版本将简单地 `cons` 流的 `head` 到对 `tail` 应用 `toList` 方法的结果。当然，你需要使此过程尾递归，以便使用 `TailCall`
    来获得栈安全的实现：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the static imports of `TailCall.ret()` and `TailCall.sus()` aren’t
    shown here.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里没有显示 `TailCall.ret()` 和 `TailCall.sus()` 的静态导入。
- en: Beware that calling `toList` on an infinite stream, such as the stream created
    by `Stream.from(1)`, will create an infinite list. Unlike the stream, the list
    is eagerly evaluated, so it will result, in theory, in a never-ending program.
    (In reality, it will end with an `OutOfMemoryError`.) Be sure to create a condition
    that will truncate the list before running the program, as you’ll see in the next
    exercise.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在无限流（如 `Stream.from(1)` 创建的流）上调用 `toList` 将创建一个无限列表。与流不同，列表是急切评估的，因此理论上会导致程序永远无法结束。（在现实中，它将以
    `OutOfMemoryError` 结束。）确保在运行程序之前创建一个条件来截断列表，正如你将在下一个练习中看到的那样。
- en: Exercise 9.3
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 9.3
- en: 'Write a `take(n)` method that returns the first `n` elements of a stream, and
    a `drop(n)` method that returns the remaining stream after removing the first
    `n` elements. Note that you have to ensure that no evaluation occurs while calling
    these methods. Here are the signatures in the `Stream` parent class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `take(n)` 方法，它返回流的前 `n` 个元素，并编写一个 `drop(n)` 方法，它返回移除前 `n` 个元素后的剩余流。请注意，在调用这些方法时必须确保不发生任何评估。以下是
    `Stream` 父类中的签名：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Solution 9.3
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 9.3
- en: Both implementations in the `Empty` class return `this`. For the `take` method
    in the `Cons` class, you need to create a new `Stream<A>` by calling the `cons`
    method with the non-evaluated `head` of the stream (which means a reference to
    the `head` field and not a call to the `head()` method) and making a recursive
    call to `take(n - 1)` on the `tail` of the stream until `n == 1`. The `drop` method
    is even simpler. You just have to call `drop(n – 1)` recursively on the tail while
    `n > 0`. Note that the `take` method doesn’t need to be made stack-safe, because
    the recursive call to `take` is already lazy.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 类中的两种实现都返回 `this`。对于 `Cons` 类中的 `take` 方法，你需要通过调用 `cons` 方法并使用流的非评估
    `head`（这意味着对 `head` 字段的引用，而不是对 `head()` 方法的调用）来创建一个新的 `Stream<A>`，并对流的 `tail`
    进行递归调用 `take(n - 1)`，直到 `n == 1`。`drop` 方法甚至更简单。你只需要在 `n > 0` 时对尾部递归调用 `drop(n
    - 1)`。请注意，`take` 方法不需要确保栈安全，因为对 `take` 的递归调用已经是懒加载的。'
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `take` method allows you to work on an infinite stream by truncating it
    after a number of elements. Beware, however, that this method must be called on
    the stream before converting it to a list:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`take` 方法允许你通过截断无限流来在有限范围内工作。但是请注意，在将其转换为列表之前，必须在该流上调用此方法：'
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Calling the equivalent method on the resulting list will instead hang until
    memory is exhausted, causing an `OutOfMemoryError`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果列表上调用等效方法将导致程序挂起，直到内存耗尽，从而引发 `OutOfMemoryError`：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By contrast, the `drop` method must be made stack-safe:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，`drop` 方法必须确保栈安全：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Exercise 9.4
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 9.4
- en: 'Write a `takeWhile` method that will return a `Stream` containing all starting
    elements as long as a condition is matched. Here’s the method signature in the
    `Stream` parent class:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `takeWhile` 方法，该方法将返回一个 `Stream`，只要满足条件，就包含所有起始元素。这是 `Stream` 父类中的方法签名：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Hint
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Be aware that, unlike `take` and `drop`, this method will evaluate one element,
    because it will have to test the first element to verify whether it fulfills the
    condition expressed by the predicate. You should verify that only the first element
    of the stream is evaluated.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与`take`和`drop`不同，这个方法将评估一个元素，因为它必须测试第一个元素以验证它是否满足由谓词表达的条件。您应该验证只有流中的第一个元素被评估。
- en: Solution 9.4
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 9.4
- en: 'This method is very similar to the `take` method. The main difference is that
    the terminal condition is no longer `n <= 0` but the provided function returning
    `false`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法与`take`方法非常相似。主要区别在于终止条件不再是`n <= 0`，而是提供的返回`false`的函数：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once again, you don’t need to make the method stack-safe because the recursive
    call is unevaluated. The `Empty` implementation returns `this`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，您不需要使该方法堆栈安全，因为递归调用未评估。`Empty`实现返回`this`。
- en: Exercise 9.5
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 9.5
- en: 'Write a `dropWhile` method that returns a stream with the front elements removed
    as long as they satisfy a condition. Here’s the signature in the `Stream` parent
    class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`dropWhile`方法，该方法返回一个流，只要前导元素满足条件就移除它们。这是在`Stream`父类中的签名：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Hint
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You’ll need to write a tail recursive version of this method in order to make
    it stack-safe.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要编写这个方法的尾递归版本，以便使其堆栈安全。
- en: Solution 9.5
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 9.5
- en: 'As in previous recursive methods, the solution will include a main method calling
    a stack-safe recursive helper method and evaluating its result:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的递归方法一样，解决方案将包括一个主方法调用堆栈安全的递归辅助方法并评估其结果：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Because this method uses a helper method, it can be implemented in the `Stream`
    parent class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个方法使用辅助方法，所以它可以在`Stream`父类中实现。
- en: 9.6\. The true essence of laziness
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6. 懒惰的真正本质
- en: Laziness is often perceived as evaluating expressions only when (and if) needed.
    In fact, this is only an application of laziness.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰通常被理解为仅在需要时（如果需要）评估表达式。实际上，这仅仅是懒惰的一个应用。
- en: '|  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**What laziness really means**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**懒惰的真正含义**'
- en: The real difference between strictness and laziness is that strictness is about
    *doing things*, and laziness is about *noting things to do*. Lazy evaluation of
    data notes that data must be evaluated sometime in the future. But laziness isn’t
    limited to evaluating data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 严格性和懒惰之间的真正区别在于，严格性是关于*做事情*，而懒惰是关于*标记要做的事情*。懒惰评估数据表示数据必须在未来的某个时刻被评估。但懒惰并不局限于评估数据。
- en: Printing to the console in Java is strict, and it’s incompatible with functional
    programming because it’s an effect. But noting that you should print to the console
    sometime in the future (which could be called “lazy printing”) is different. This
    lazy effect is just producing data that could be returned as the result of the
    program. More on this subject in [chapter 13](kindle_split_020.xhtml#ch13).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中向控制台打印是严格的，因为它是一个效果，所以它与函数式编程不兼容。但是，标记您应该在未来的某个时刻打印到控制台（这可以称为“懒惰打印”）是不同的。这种懒惰效果只是产生可以作为程序结果返回的数据。关于这个主题的更多内容请参阅第
    13 章[学习如何做到这一点](kindle_split_020.xhtml#ch13)。
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Take the example of a very simple imperative program:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个非常简单的命令式程序为例：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This program applies strictness, because for each name in the list it executes
    what it has to do. A lazy version of the program might look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序应用了严格性，因为对于列表中的每个名称，它执行必须执行的操作。这个程序的懒惰版本可能看起来像这样：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Instead of printing each name, this program produces a list of instructions
    for printing the names. In other words, this program writes a program that can
    be executed later. What’s important to understand is that the two programs aren’t
    equivalent, because if you run them, they won’t produce the same results. But
    the output of the second program is equivalent to the first program itself, because
    if you run the output of the second program, you’ll get exactly the same result
    as you would by running the first program.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是打印每个名称，这个程序生成打印名称的指令列表。换句话说，这个程序编写了一个可以在以后执行的程序。重要的是要理解，这两个程序并不等价，因为如果您运行它们，它们不会产生相同的结果。但第二个程序的结果与第一个程序本身等价，因为如果您运行第二个程序的结果，您将得到与运行第一个程序完全相同的结果。
- en: Of course, to run the output of the second program, you’d need some sort of
    interpreter. You’ll learn how to do this in [chapter 13](kindle_split_020.xhtml#ch13)
    (although you probably already have a good idea about what’s involved).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要运行第二个程序的结果，你需要某种类型的解释器。您将在第 13 章[学习如何做到这一点](kindle_split_020.xhtml#ch13)（尽管您可能已经对涉及的内容有了很好的了解）。
- en: One huge advantage of this approach is that you could produce a description
    of a program producing an error, and then decide not to execute it based on some
    condition. Or you could produce an infinite expression, and then apply some means
    of reducing it to a finite one.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的巨大优势在于，你可以生成一个描述产生错误的程序的描述，然后基于某些条件决定不执行它。或者，你可以生成一个无限表达式，然后应用一些方法将其简化为有限的表达式。
- en: 'You already saw an example of the first case when you wrote a method to simulate
    the laziness of Boolean operators. For an example of the second case, imagine
    you have a list of all the positive integers. In imperative programming, this
    could be written as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个模拟布尔运算符惰性的方法时，你已经看到了第一个情况的例子。对于第二个情况的例子，想象你有一个所有正整数的列表。在命令式编程中，可以这样写：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Such a program will never terminate, although it doesn’t do anything. But if
    you want to find the first integer for which the Fibonacci value is greater than
    500, you could write this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的程序永远不会终止，尽管它没有做任何事情。但如果你想找到第一个斐波那契值大于500的整数，你可以这样写：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now your program terminates because the list of integers will stop being evaluated
    after the answer is found. This is because the `for` loop is a lazy structure.
    Although `for (int i = 0;; i++)` represents an infinite sequence of integers,
    it will only be evaluated as needed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序终止，因为找到答案后整数列表将停止评估。这是因为`for`循环是一个惰性结构。尽管`for (int i = 0;; i++)`代表一个无限整数序列，但它只会按需评估。
- en: 'In [chapter 8](kindle_split_015.xhtml#ch08), you created the following `exists`
    method in the `List` class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](kindle_split_015.xhtml#ch08)中，你在`List`类中创建了以下`exists`方法：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method traversed the list until an element was found satisfying the predicate
    `p`. The rest of the list wasn’t examined because the `||` operator is lazy and
    doesn’t evaluate its second argument if the first one evaluates to `true`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法遍历列表，直到找到一个满足谓词`p`的元素。由于`||`操作符是惰性的，如果第一个参数评估为`true`，则不会评估其第二个参数，因此不会检查列表的其余部分。
- en: Exercise 9.6
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习9.6
- en: Create an `exists` method for `Stream`. The method should cause elements to
    be evaluated only until the condition is met. If the condition is never met, all
    elements will be evaluated.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为`Stream`创建一个`exists`方法。该方法应该只在满足条件时评估元素。如果条件从未满足，则所有元素都将被评估。
- en: Solution 9.6
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案9.6
- en: 'A simple solution could be very similar to the `exists` method in `List`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方案可以与`List`中的`exists`方法非常相似：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Of course, you should make it stack-safe. In order to write a stack-safe implementation,
    you must first make it tail recursive, and then use the `TailCall` class:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你应该使其堆栈安全。为了编写堆栈安全的实现，你必须首先使其尾递归，然后使用`TailCall`类：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This version works for both subclasses, so it can be put in the `Stream` parent
    class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本适用于两个子类，因此它可以放在`Stream`父类中。
- en: 9.6.1\. Folding streams
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.6.1. 折叠流
- en: In [chapter 5](kindle_split_012.xhtml#ch05) you saw how to abstract recursion
    into fold methods, and you learned how to fold lists right or left. Folding streams
    is a bit different. Although the principle is the same, the main difference is
    that streams are unevaluated. A recursive operation could overflow the stack and
    cause a `StackOverflowException` to be thrown, but a description of a recursive
    operation will not. The consequence is that a `foldRight`, which can’t be made
    stack-safe in `List`, will in many cases not overflow the stack. It will overflow
    if it implies evaluating each operation, such as adding the elements of a `Stream<Integer>`,
    but it won’t if, instead of evaluating an operation, it constructs a description
    of an unevaluated one.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](kindle_split_012.xhtml#ch05)中，你看到了如何将递归抽象为折叠方法，并学习了如何折叠列表的左右。折叠流略有不同。尽管原理相同，但主要区别在于流是未评估的。递归操作可能会导致堆栈溢出并抛出`StackOverflowException`，但递归操作的描述不会。结果是，在`List`中无法使其堆栈安全的`foldRight`在许多情况下不会溢出堆栈。如果它意味着评估每个操作，例如添加`Stream<Integer>`的元素，则它将溢出，但如果它不是评估操作，而是构建一个未评估操作的描述，则不会溢出。
- en: On the other hand, the `List` implementation of `foldRight` based on `foldLeft`
    (which can be made stack-safe) can’t be used with streams, because it would require
    reversing the stream, which would cause the evaluation of all elements; it might
    even be impossible in the case of an infinite stream. And the stack-safe version
    of `foldLeft` can’t be used either, because it inverts the direction of the computation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，基于`foldLeft`的`List`的`foldRight`实现（可以是栈安全的）不能与流一起使用，因为它需要反转流，这将导致评估所有元素；在无限流的情况下甚至可能不可能。同样，栈安全的`foldLeft`版本也不能使用，因为它反转了计算的方向。
- en: Exercise 9.7
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 9.7
- en: Create a `foldRight` method for streams. This method will be similar to the
    `List.fold-Right` method, but you should take care of laziness.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为流创建一个`foldRight`方法。此方法将与`List.fold-Right`方法类似，但你应该注意延迟计算。
- en: Hint
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Laziness is expressed by the elements being `Supplier<T>` instead of `T`. The
    signature of the method in the `Stream` parent class will be
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟计算通过元素是`Supplier<T>`而不是`T`来表示。`Stream`父类中方法的签名将是
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Solution 9.7
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 9.7
- en: 'The implementation in the `Empty` class is obvious:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty`类中的实现是显而易见的：'
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And here’s the `Cons` implementation:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Cons`实现的示例：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that this method isn’t stack-safe, so it shouldn’t be used for such computations
    as the sum of a list of more than about a thousand integers. You’ll see, however,
    that it has many interesting use cases.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此方法不是栈安全的，因此不应用于计算超过大约一千个整数的列表之和。然而，你会发现它有许多有趣的用例。
- en: Exercise 9.8
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 9.8
- en: Implement the `takeWhile` method in terms of `foldRight`. Verify how it behaves
    on long lists.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`foldRight`实现`takeWhile`方法。验证它在长列表上的行为。
- en: Solution 9.8
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 9.8
- en: The starting value is a `Supplier` of an empty stream. This could be written
    `() -> empty()`, but you can also use the method reference version, `Stream::empty`.
    The function tests the current element (`f.apply(a)`). If the result is `true`
    (meaning that the element fulfills the condition expressed by the predicate `p`),
    a stream is returned by `cons`-ing a `Supplier` of `a` to the current stream.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 初始值是一个空的流`Supplier`。这可以写成`() -> empty()`，但你也可以使用方法引用版本，`Stream::empty`。该函数测试当前元素（`f.apply(a)`）。如果结果是`true`（意味着该元素满足由谓词`p`表达的条件），则通过将`a`的`Supplier`添加到当前流中，`cons`返回一个流。
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can verify by running the tests provided in the code accompanying this
    book ([https://github.com/fpinjava/fpinjava](https://github.com/fpinjava/fpinjava)),
    this method won’t overflow the stack, even for streams longer than one million
    elements. This is because `foldRight` doesn’t evaluate the result by itself. Evaluation
    depends on the function used to make the fold. If this function constructs a new
    stream (as it does in the case of `takeWhile`), this stream isn’t evaluated.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如您通过运行本书附带代码中的测试（[https://github.com/fpinjava/fpinjava](https://github.com/fpinjava/fpinjava)）所验证的，即使对于超过一百万个元素的流，此方法也不会导致栈溢出。这是因为`foldRight`不会自己评估结果。评估取决于用于折叠的函数。如果此函数构造了一个新的流（如`takeWhile`的情况），则此流不会被评估。
- en: Exercise 9.9
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 9.9
- en: Implement `headOption` using `foldRight`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`foldRight`实现`headOption`。
- en: Solution 9.9
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 9.9
- en: The starting element will be a non-evaluated empty stream (`Result::empty` or
    `() -> Result.empty()`). This will be the returned value if the stream is empty.
    The function used to fold the stream will simply ignore the second argument, so
    the first time it’s applied (to the `head` element), it returns `Result.success(a)`,
    and this result will never change.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 起始元素将是一个非评估的空流（`Result::empty`或`() -> Result.empty()`）。这将是在流为空时返回的值。用于折叠流的函数将简单地忽略第二个参数，因此第一次应用（到`head`元素）时，它返回`Result.success(a)`，并且此结果将永远不会改变。
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Exercise 9.10
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 9.10
- en: Implement `map` in terms of `foldRight`. Verify that this method doesn’t evaluate
    any of the stream elements.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`foldRight`实现`map`。验证此方法不会评估流中的任何元素。
- en: Solution 9.10
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 9.10
- en: Start with a `Supplier` of an empty stream. The function used to make the fold
    will `cons` a non-evaluated application of the function on the current element
    with the current result.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个空的流`Supplier`开始。用于折叠的函数将`cons`当前元素的非评估应用与当前结果。
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Exercise 9.11
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 9.11
- en: Implement `filter` in terms of `foldRight`. Verify that this method doesn’t
    evaluate more stream elements than needed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`foldRight`实现`filter`。验证此方法不会评估比所需更多的流元素。
- en: Solution 9.11
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 9.11
- en: Again, start with a non-evaluated empty stream. The function used to fold applies
    the filter to the current argument. If the result is `true`, the element is used
    to create a new stream by `cons`-ing it with the current stream result. Otherwise,
    the current stream result is left unchanged. (Calling `get` on `b` doesn’t evaluate
    any elements.)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，从一个非评估的空流开始。用于折叠的函数将过滤器应用于当前参数。如果结果是`true`，则使用该元素通过`cons`将其与当前流结果组合来创建一个新的流。否则，当前流结果保持不变。（在`b`上调用`get`不会评估任何元素。）
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that this method evaluates the stream elements until the first match is
    found. See the corresponding tests in the accompanying code for details.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种方法评估流元素直到找到第一个匹配项。有关详细信息，请参阅附带代码中的相应测试。
- en: Exercise 9.12
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习9.12
- en: Implement `append` in terms of `foldRight`. The `append` method should be non-strict
    in its argument.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`foldRight`来实现`append`。`append`方法在参数上应该是非严格的。
- en: Solution 9.12
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答9.12
- en: The starting element is the (non-evaluated) stream you want to append. The folding
    function simply creates a new stream by `cons`-ing the current element on the
    current result.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 起始元素是你想要附加的（非评估的）流。折叠函数简单地通过`cons`将当前元素附加到当前结果上创建一个新的流。
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Exercise 9.13
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习9.13
- en: Implement `flatMap` in terms of `foldRight`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`foldRight`来实现`flatMap`。
- en: Solution 9.13
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答9.13
- en: Again, you start with an unevaluated empty stream. The function is applied to
    the current element, producing a stream to which the current result is appended.
    This has the effect of flattening the result (transforming a `Stream<Stream<B>>`
    into a `Stream<B>`).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你从一个未评估的空流开始。函数应用于当前元素，生成一个流，当前结果被附加到该流上。这相当于将结果扁平化（将`Stream<Stream<B>>`转换为`Stream<B>`）。
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Tracing evaluation and function application
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 跟踪评估和函数应用
- en: 'It’s important to notice the consequence of laziness. With strict collections,
    like lists, applying successively a `map`, a `filter`, and a new `map` would imply
    iterating over the list three times:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意惰性的后果。对于像列表这样的严格集合，连续应用`map`、`filter`和新的`map`将意味着对列表进行三次迭代：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As you can see, functions `f` and `p` aren’t true functions because they log
    to the console. This isn’t very functional, but it will help you understand what’s
    happening. You could have easily implemented a functional version of this test
    by returning a tuple of the result and a list of logging strings. (You can do
    this as an extra exercise if you like.) This program prints the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，函数`f`和`p`不是真正的函数，因为它们将日志记录到控制台。这并不非常函数式，但它将帮助你理解正在发生的事情。你可以很容易地实现这个测试的函数式版本，通过返回一个包含结果和日志字符串列表的元组。（如果你喜欢，你可以作为额外练习这样做。）这个程序打印以下内容：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This shows that all elements are processed by function `f`, implying a full
    traversal of the list. Then all elements are processed by function `p`, implying
    a second full traversal of the list that results from the first `map`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明所有元素都通过函数`f`处理，意味着对列表的完整遍历。然后所有元素都通过函数`p`处理，意味着对由第一次`map`产生的列表的第二次完整遍历。
- en: 'By contrast, look at the following program, which uses a `Stream` instead of
    a `List`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，看看以下程序，它使用`Stream`而不是`List`：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This is the output:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can see that the stream traversal occurs only once. First the element `1`
    is mapped with `f`, giving `3`. Then `3` is filtered (and discarded because it’s
    not even). Then `2` is mapped with `f`, giving `6`, which is filtered and kept
    for the result.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到流遍历只发生一次。首先元素`1`通过`f`映射，得到`3`。然后`3`被过滤（由于它不是偶数而被丢弃）。然后`2`通过`f`映射，得到`6`，被过滤并保留为结果。
- en: As you can see, the laziness of streams allows you to compose the descriptions
    of the computations rather than their results. Note that the evaluation of elements
    is reduced to a minimum.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，流的惰性允许你组合计算的描述而不是结果。注意，元素的评估被减少到最小。
- en: 'The following result is obtained if you use unevaluated values to construct
    the stream and an evaluating method with logging, while removing the printing
    of the result:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用未评估的值来构建流，并使用带有日志记录的评估方法，同时删除结果的打印，则会得到以下结果：
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You can see that only the first two elements are evaluated. The rest of the
    evaluations were the result of the final printing.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到只有前两个元素被评估。其余的评估是最终打印的结果。
- en: Exercise 9.14
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习9.14
- en: Write a `find` method that takes a predicate (a function from `A` to `Boolean`)
    as a parameter and returns a `Result<A>`. This will be a `Success` if an element
    is found to match the predicate, or an `Empty` otherwise.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `find` 方法，它接受一个谓词（一个从 `A` 到 `Boolean` 的函数）作为参数，并返回一个 `Result<A>`。如果找到与谓词匹配的元素，则为
    `Success`，否则为 `Empty`。
- en: Hint
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You should have nearly nothing to write. Just combine two of the methods you’ve
    written in the previous sections.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎不需要写什么。只需结合前几节中编写的两种方法即可。
- en: Solution 9.14
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 9.14
- en: 'Just compose the `filter` method with `headOption`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将 `filter` 方法与 `headOption` 组合：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 9.7\. Handling infinite streams
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7\. 处理无限流
- en: 'Because a stream is unevaluated, it can be made infinite while still being
    composable in computations. A simple example is the `from` method that you’ve
    already seen:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因为流是未评估的，所以它可以在计算中组合的同时变得无限。一个简单的例子是您已经看到的 `from` 方法：
- en: '[PRE49]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This method returns an infinite stream of integers, starting from `i` and adding
    one to each new element. This is a very convenient way to create a finite stream
    of increasing integers:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个从 `i` 开始并以每个新元素加一为特征的整数无限流。这是一种创建有限递增整数流的非常方便的方法：
- en: '[PRE50]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This code will create a stream of 10,000 integers, from 0 to 9,999, without
    evaluating anything.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将创建一个包含 10,000 个整数的流，从 0 到 9,999，而不进行任何评估。
- en: Exercise 9.15
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 9.15
- en: Write a `repeat` method that takes an object as its parameter and returns an
    infinite stream of the same object.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `repeat` 方法，它接受一个对象作为其参数，并返回一个无限流，该流包含相同的对象。
- en: Solution 9.15
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 9.15
- en: 'This method is very similar to the `from` method:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与 `from` 方法非常相似：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Exercise 9.16
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 9.16
- en: 'Generalize the `from` and `repeat` methods by writing an `iterate` method that
    takes two parameters: a seed, which will be used for the first value, and a function
    that will compute the next one. Here’s its signature:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写一个接受两个参数的 `iterate` 方法泛化 `from` 和 `repeat` 方法：一个种子，它将被用于第一个值，以及一个计算下一个值的函数。以下是它的签名：
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Then rewrite the `from` and `repeat` methods based on `iterate`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后基于 `iterate` 重新编写 `from` 和 `repeat` 方法。
- en: Solution 9.16
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 9.16
- en: 'The `iterate` method has exactly the same structure as `from` and `repeat`,
    with the difference that the starting value and the function have been parameterized:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterate` 方法的结构与 `from` 和 `repeat` 完全相同，区别在于起始值和函数已被参数化：'
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Note that because the seed is passed as a method parameter, it’s evaluated
    before being used to create an “unevaluated” value (a `Supplier`). It is, of course,
    very easy to create a version of `iterate` that takes an unevaluated seed:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为种子作为方法参数传递，所以在用于创建一个“未评估”值（一个 `Supplier`）之前，它会被评估。当然，创建一个接受未评估种子的 `iterate`
    版本非常简单：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Exercise 9.17
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 9.17
- en: 'Write a `fibs` function that generates the infinite stream of Fibonacci numbers:
    0, 1, 1, 2, 3, 5, 8, and so on.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `fibs` 函数，生成斐波那契数的无限流：0, 1, 1, 2, 3, 5, 8，以此类推。
- en: Hint
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Consider producing an intermediate stream of tuples of integers using the `iterate`
    method.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用 `iterate` 方法生成一个包含整数元组的中间流。
- en: Solution 9.17
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 9.17
- en: 'The solution consists in creating a stream of tuples (x, y) with `x` and `y`
    being two successive Fibonacci numbers. Once this stream is produced, you just
    have to `map` it with a function from a tuple to its first element:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 解答在于创建一个包含两个连续斐波那契数 (x, y) 的元组流。一旦生成了这个流，只需使用一个从元组到其第一个元素的函数对其进行 `map` 即可：
- en: '[PRE55]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Exercise 9.18
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 9.18
- en: The `iterate` method can be further generalized. Write an `unfold` method that
    takes as its parameters a starting state of type `S` and a function from `S` to
    `Result<Tuple<A, S>>`, and returns a stream of `A`. Returning a `Result` makes
    it possible to indicate whether the stream should stop or continue.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterate` 方法可以进一步泛化。编写一个 `unfold` 方法，它接受一个类型为 `S` 的起始状态和一个从 `S` 到 `Result<Tuple<A,
    S>>` 的函数作为参数，并返回一个 `A` 类型的流。返回 `Result` 使得可以指示流是否应该停止或继续。'
- en: 'Using a state `S` means that the source of data generation doesn’t have to
    be of the same type as the generated data. To apply this new method, write new
    versions of `fibs` and `from` in terms of the `unfold` method. Here’s the `unfold`
    signature:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用状态 `S` 意味着数据生成的来源不必与生成的数据类型相同。要应用这种方法，请用 `unfold` 方法重新编写 `fibs` 和 `from` 的版本。以下是
    `unfold` 方法的签名：
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Solution 9.18
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 9.18
- en: 'To start with, apply the `f` function to the initial state `z`. This produces
    a `Result<Tuple<A, S>>`. Then map this result with a function from a `Tuple<A,
    S>`, producing a stream by `cons`-ing the left member of the tuple (the `A` value)
    with a (non-evaluated) recursive call to `unfold`, and using the right member
    of the tuple as the initial state. The result of this mapping is either `Success(stream)`
    or `Empty`. Then use `getOrElse` to return either the contained stream or a default
    empty stream:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将`f`函数应用于初始状态`z`。这会产生一个`Result<Tuple<A, S>>`。然后使用一个从`Tuple<A, S>`到函数的映射，通过`cons`操作将元组的左侧成员（`A`值）与一个（非评估的）递归调用`unfold`相结合，并使用元组的右侧成员作为初始状态，从而生成一个流。这个映射的结果是`Success(stream)`或`Empty`。然后使用`getOrElse`来返回包含的流或默认的空流：
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The new version of `from` uses the integer seed as the initial state, and a
    function from `Integer` to `Tuple<Integer, Integer>`. Here, the state is of the
    same type as the value:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`from`的新版本使用整数种子作为初始状态，以及一个从`Integer`到`Tuple<Integer, Integer>`的函数。在这里，状态与值具有相同的类型：'
- en: '[PRE58]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `fibs` method makes more complete use of the `unfold` method. The state
    is a `Tuple<Integer, Integer>`, and the function produces a `Tuple<Integer, Tuple
    <Integer, Integer>>`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`fibs`方法更完整地使用了`unfold`方法。状态是一个`Tuple<Integer, Integer>`，函数产生一个`Tuple<Integer,
    Tuple<Integer, Integer>>`：'
- en: '[PRE59]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You can see how compact and elegant these method implementations are!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这些方法实现是多么紧凑和优雅！
- en: 9.8\. Avoiding null references and mutable fields
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8\. 避免使用`null`引用和可变字段
- en: In [section 9.5.1](#ch09lev2sec3), I said it was easy to modify your `Stream`
    class to memoize the head and tail without resorting to `null` references and
    mutable fields. Did you find a solution? In fact, memoization of the tail reference
    isn’t really necessary because the tail itself is a lazy structure (a `Stream`),
    so evaluating the reference won’t take a noticeable amount of time. You’ll only
    memoize the head.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9.5.1节](#ch09lev2sec3)中，我说修改你的`Stream`类以缓存头和尾而不使用`null`引用和可变字段是很简单的。你找到解决方案了吗？实际上，对尾引用的缓存并不是真正必要的，因为尾本身是一个惰性结构（一个`Stream`），所以评估引用不会花费太多时间。你只需要缓存头。
- en: 'Avoiding `null` references is easy: you can use `Result.Empty` instead of `null`
    as long as the value is non-evaluated, and use `Result.Success` to hold the evaluated
    value. To avoid using mutable fields, you need to produce a new `Stream` when
    the value is evaluated. To do so, you’ll use two constructors: one with the non-evaluated
    head and one with the evaluated one:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用`null`引用很简单：只要值没有被评估，你可以使用`Result.Empty`代替`null`，并使用`Result.Success`来保存评估后的值。为了避免使用可变字段，当值被评估时，你需要生成一个新的`Stream`。为此，你将使用两个构造函数：一个用于非评估的头，另一个用于评估的头：
- en: '[PRE60]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Because evaluation occurs in the `head` method, you need a new implementation
    of it. But you also need to return the new `Stream` with the `head` value. You
    can make the `head` method return a `Tuple<A, Stream<A>>`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于评估发生在`head`方法中，你需要一个新的实现。但你还需要返回带有`head`值的新的`Stream`。你可以让`head`方法返回一个`Tuple<A,
    Stream<A>>`：
- en: '[PRE61]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Of course, all methods using `head()` must now use `head()._1` instead. And
    if a reference to the stream was held, it must be replaced with the new stream
    (`head()._2`). Note that so far this has never occurred inside the `Stream` class!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在所有使用`head()`的方法都必须使用`head()._1`。如果持有对流的引用，它必须被新的流（`head()._2`）替换。注意，到目前为止，这从未在`Stream`类内部发生！
- en: The `headOption` method must also be modified to return a tuple. You’ll find
    the complete `Stream` class in the listing09_06 package in the code accompanying
    this book ([https://github.com/fpinjava/fpinjava](https://github.com/fpinjava/fpinjava)).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`headOption`方法也必须修改为返回一个元组。你可以在本书附带的代码中的`listing09_06`包中找到完整的`Stream`类（[https://github.com/fpinjava/fpinjava](https://github.com/fpinjava/fpinjava)）。'
- en: Exercise 9.19
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 9.19
- en: Using `foldRight` to implement various methods is a smart technique. Unfortunately,
    it doesn’t really work for `filter`. If you test this method with a predicate
    that’s not matched by more than 1,000 or 2,000 consecutive elements, it will overflow
    the stack. Using the new `Stream` class without `null` or mutable fields, write
    a stack-safe `filter` method.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`foldRight`来实现各种方法是智能的技术。不幸的是，它对`filter`并不真正适用。如果你用一个不匹配超过1,000或2,000个连续元素的谓词测试这个方法，它将溢出栈。在不使用`null`或可变字段的新`Stream`类中，编写一个栈安全的`filter`方法。
- en: Hint
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The problem comes from long sequences of elements for which the predicate returns
    `false`. Try to think of a way to get rid of these elements.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 问题来自于那些返回`false`的长序列元素。试着想想如何去除这些元素。
- en: Solution 9.19
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 9.19
- en: The solution is to remove the long series of elements that return `false` by
    using the `dropWhile` method. To do this, you must reverse the condition (`!p.apply(x)`)
    and then test the resulting stream for emptiness. If the stream is empty, return
    it. (Any empty stream will do, because the empty stream is a singleton. It just
    needs to be of the right type.) If the stream isn’t empty, create a new stream
    by `cons`-ing the head with the filtered tail.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用`dropWhile`方法删除返回`false`的长序列元素。为此，你必须反转条件（`!p.apply(x)`），然后测试结果流是否为空。如果流为空，则返回它。（任何空流都可以，因为空流是一个单例。它只需要是正确的类型。）如果流不为空，则通过`cons`将头与过滤后的尾部组合来创建一个新的流。
- en: Note that the `head` method returns a tuple, so you must use the left (first)
    element of this tuple as the `head` element of the stream. In theory, you should
    use the right (second) element of the tuple for any further access. Not doing
    so would cause a new evaluation of the head. But because you don’t access the
    head a second time, but only the tail, you can use `stream.getTail()` instead.
    This allows you to avoid the use of a local variable to reference the result of
    `stream.head()`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`head`方法返回一个元组，因此你必须使用这个元组的左（第一个）元素作为流的`head`元素。在理论上，你应该使用元组的右（第二个）元素进行任何进一步的访问。如果不这样做，就会导致对头的再次评估。但由于你不会第二次访问头，而只是访问尾部，你可以使用`stream.getTail()`代替。这允许你避免使用局部变量来引用`stream.head()`的结果。
- en: '[PRE62]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Another possibility is to use the `headOption` method. This method returns a
    `Tuple` holding a `Result<A>` that can be mapped to produce the new stream through
    a recursive call. In the end, this produces a `Result<Stream<A>>` that will be
    empty if no elements satisfy the predicate. All that remains to be done is to
    call `getOrElse` on this `Result`, passing an empty stream as the default value.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是使用`headOption`方法。此方法返回一个包含`Result<A>`的`Tuple`，该`Result<A>`可以通过递归调用映射以产生新的流。最终，这将产生一个`Result<Stream<A>>`，如果没有元素满足谓词，它将是空的。剩下要做的就是调用`Result`上的`getOrElse`，传递一个空流作为默认值。
- en: '[PRE63]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 9.9\. Summary
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.9. 摘要
- en: Strict evaluation means evaluating values as soon as they’re referenced.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格评估意味着在引用值时立即评估值。
- en: Lazy evaluation means evaluating values only if and when they’re needed.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载意味着仅在需要时评估值。
- en: Some languages are strict, and others are lazy. Some are lazy by default and
    optionally strict; others are strict by default and optionally lazy.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些语言是严格的，而另一些是懒加载的。有些默认是懒加载的，并且可以选择严格；而有些默认是严格的，并且可以选择懒加载。
- en: Java is a strict language. It’s strict regarding method arguments.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java是一种严格的编程语言。它在方法参数方面非常严格。
- en: Although Java isn’t lazy, you can use the `Supplier` interface to implement
    laziness.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然Java不是懒加载的，但你仍然可以使用`Supplier`接口来实现懒加载。
- en: Laziness allows you to manipulate and compose infinite data structures.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载允许你操作和组合无限数据结构。
- en: A `Stream` is a non-evaluated, possibly infinite, list.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream`是一个非评估的、可能无限的列表。'
- en: You can use memoization to avoid evaluating the same values several times.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用记忆化来避免多次评估相同的值。
- en: Right folds don’t cause stream evaluation. Only some functions used for folding
    do.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右折叠不会导致流评估。只有一些用于折叠的函数会这样做。
- en: Using folds, you can compose several iterating operations without resulting
    in multiple iterations.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用折叠，你可以组合多个迭代操作，而不会导致多次迭代。
- en: You can easily define and compose infinite streams.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以轻松定义和组合无限流。
