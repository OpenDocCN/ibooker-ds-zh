- en: 2 Starting a project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 开始一个项目
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Introducing the Hibernate and Spring Data projects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Hibernate和Spring Data项目
- en: Developing a “Hello World” with Jakarta Persistence API, Hibernate, and Spring
    Data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jakarta Persistence API、Hibernate和Spring Data开发“Hello World”
- en: Examining the configuration and integration options
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查配置和集成选项
- en: In this chapter, we’ll start with the Jakarta Persistence API (JPA), Hibernate,
    and Spring Data and work through a step-by-step example. We’ll look at the persistence
    APIs and see the benefits of using either standardized JPA, native Hibernate,
    or Spring Data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从Jakarta Persistence API（JPA）、Hibernate和Spring Data开始，逐步进行示例。我们将查看持久化API，并了解使用标准化的JPA、本地的Hibernate或Spring
    Data的好处。
- en: We’ll begin with a tour through JPA, Hibernate, and Spring Data, looking at
    a straightforward “Hello World” application. JPA (Jakarta Persistence API, formerly
    Java Persistence API) is the specification defining an API that manages the persistence
    of objects and object/relational mappings—it specifies what must be done to persist
    objects. Hibernate, the most popular implementation of this specification, will
    make the persistence happen. Spring Data makes the implementation of the persistence
    layer even more efficient; it’s an umbrella project that adheres to the Spring
    framework principles and offers an even simpler approach.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从JPA、Hibernate和Spring Data的简要浏览开始，查看一个简单的“Hello World”应用程序。JPA（Jakarta Persistence
    API，以前称为Java Persistence API）是一个定义管理对象和对象/关系映射的API的规范——它指定了持久化对象必须执行的操作。Hibernate是这个规范最流行的实现，它将使持久化成为可能。Spring
    Data使持久化层的实现更加高效；它是一个遵循Spring框架原则的伞形项目，并提供了一种更简单的方法。
- en: 2.1 Introducing Hibernate
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 介绍Hibernate
- en: Object/relational mapping (ORM) is a programming technique for making the connection
    between the incompatible worlds of object-oriented systems and relational databases.
    Hibernate is an ambitious project that aims to provide a complete solution to
    the problem of managing persistent data in Java. Today, Hibernate is not only
    an ORM service but also a collection of data management tools extending well beyond
    ORM.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对象/关系映射（ORM）是一种编程技术，用于在面向对象系统的不兼容世界和关系数据库之间建立联系。Hibernate是一个雄心勃勃的项目，旨在为Java中持久化数据的问题提供一个完整的解决方案。如今，Hibernate不仅是一个ORM服务，而且是一个数据管理工具集合，其范围远远超出了ORM。
- en: 'The Hibernate project suite includes the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate项目套件包括以下内容：
- en: '*Hibernate ORM*—Hibernate ORM consists of a core, a base service for persistence
    with SQL databases, and a native proprietary API. Hibernate ORM is the foundation
    for several of the other projects in the suite, and it’s the oldest Hibernate
    project. You can use Hibernate ORM on its own, independent of any framework or
    any particular runtime environment with all JDKs. As long as a data source is
    accessible, you can configure it for Hibernate, and it works.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Hibernate ORM*—Hibernate ORM由核心、用于与SQL数据库持久化的基础服务以及本地专有API组成。Hibernate ORM是套件中其他几个项目的基石，也是Hibernate最古老的项目。您可以在没有任何框架或特定运行时环境的情况下独立使用Hibernate
    ORM，适用于所有JDK。只要数据源可访问，您就可以为Hibernate配置它，并且它将正常工作。'
- en: '*Hibernate EntityManager*—This is Hibernate’s implementation of the standard
    Jakarta Persistence API. It’s an optional module you can stack on top of Hibernate
    ORM. Hibernate’s native features are a superset of the JPA persistence features
    in every respect.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Hibernate EntityManager*—这是Hibernate对标准Jakarta Persistence API的实现。它是一个可选模块，可以堆叠在Hibernate
    ORM之上。Hibernate的本地特性在各个方面都是JPA持久化特性的超集。'
- en: '*Hibernate Validator*—Hibernate provides the reference implementation of the
    Bean Validation (JSR 303) specification. Independent of other Hibernate projects,
    it provides declarative validation for domain model (or any other) classes.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Hibernate Validator*—Hibernate提供了Bean Validation (JSR 303)规范的参考实现。与其他Hibernate项目独立，它为领域模型（或任何其他）类提供声明式验证。'
- en: '*Hibernate Envers*—Envers is dedicated to audit logging and keeping multiple
    versions of data in the SQL database. This helps add data history and audit trails
    to the application, similar to any version control systems you might already be
    familiar with, such as Subversion or Git.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Hibernate Envers*—Envers致力于审计日志记录和保留SQL数据库中的多个数据版本。这有助于向应用程序添加数据历史和审计跟踪，类似于您可能已经熟悉的任何版本控制系统，例如Subversion或Git。'
- en: '*Hibernate Search*—Hibernate Search keeps an index of the domain model data
    up to date in an Apache Lucene database. It lets you query this database with
    a powerful and naturally integrated API. Many projects use Hibernate Search in
    addition to Hibernate ORM, adding full-text search capabilities. If you have a
    free text search form in your application’s user interface, and you want happy
    users, work with Hibernate Search. Hibernate Search isn’t covered in this book,
    but you can get a good start with *Hibernate Search in Action* by Emmanuel Bernard
    (Bernard, 2008).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Hibernate Search*—Hibernate Search 在 Apache Lucene 数据库中维护领域模型数据的最新索引。它允许您使用强大且自然集成的
    API 查询此数据库。许多项目在 Hibernate ORM 之外使用 Hibernate Search，增加了全文搜索功能。如果您在应用程序的用户界面中有一个免费文本搜索表单，并且希望用户满意，请使用
    Hibernate Search。Hibernate Search 在本书中未涵盖，但您可以通过 Emmanuel Bernard 的 *Hibernate
    Search in Action*（Bernard, 2008）获得良好的起点。'
- en: '*Hibernate OGM*—This Hibernate project is an object/grid mapper. It provides
    JPA support for NoSQL solutions, reusing the Hibernate core engine but persisting
    mapped entities into key/value-, document-, or graph-oriented data stores.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Hibernate OGM*—这个 Hibernate 项目是一个对象/网格映射器。它为 NoSQL 解决方案提供 JPA 支持，重用 Hibernate
    核心引擎，但将映射的实体持久化到键/值、文档或图导向的数据存储中。'
- en: '*Hibernate Reactive*—Hibernate Reactive is a reactive API for Hibernate ORM,
    interacting with a database in a non-blocking manner. It supports non-blocking
    database drivers. Hibernate Reactive isn’t covered in this book.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Hibernate Reactive*—Hibernate Reactive 是 Hibernate ORM 的反应式 API，以非阻塞方式与数据库交互。它支持非阻塞数据库驱动程序。Hibernate
    Reactive 在本书中未涵盖。'
- en: The Hibernate source code is freely downloadable from [https://github.com/hibernate](https://github.com/hibernate).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 源代码可以从 [https://github.com/hibernate](https://github.com/hibernate)
    免费下载。
- en: 2.2 Introducing Spring Data
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 介绍 Spring Data
- en: 'Spring Data is a family of projects belonging to the Spring framework whose
    purpose is to simplify access to both relational and NoSQL databases:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 是 Spring 框架的一系列项目，其目的是简化对关系型数据库和无 SQL 数据库的访问：
- en: '*Spring Data Commons*—Spring Data Commons, part of the umbrella Spring Data
    project, provides a metadata model for persisting Java classes and technology-neutral
    repository interfaces.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Data Commons*—Spring Data Commons 是 Spring Data 项目的一部分，提供了持久化 Java
    类的元数据模型和技术中立的数据仓库接口。'
- en: '*Spring Data JPA*—Spring Data JPA deals with the implementation of JPA-based
    repositories. It provides improved support for JPA-based data access layers by
    reducing the boilerplate code and creating implementations for the repository
    interfaces.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Data JPA*—Spring Data JPA 处理基于 JPA 的仓库实现。它通过减少样板代码并为仓库接口创建实现来提供对基于
    JPA 的数据访问层的改进支持。'
- en: '*Spring Data JDBC*—Spring Data JDBC deals with the implementation of JDBC-based
    repositories. It provides improved support for JDBC-based data access layers.
    It does not offer a series of JPA capabilities, such as caching or lazy loading,
    resulting in a simpler and limited ORM.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Data JDBC*—Spring Data JDBC 处理基于 JDBC 的仓库实现。它提供了对基于 JDBC 的数据访问层的改进支持。它不提供一系列
    JPA 功能，如缓存或懒加载，从而实现了一个更简单且功能有限的 ORM。'
- en: '*Spring Data REST*—Spring Data REST deals with exporting Spring Data repositories
    as RESTful resources.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Data REST*—Spring Data REST 处理将 Spring Data 仓库作为 RESTful 资源导出。'
- en: '*Spring Data MongoDB*—Spring Data MongoDB deals with access to the MongoDB
    document database. It relies on the repository-style data access layer and the
    POJO programming model.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Data MongoDB*—Spring Data MongoDB 处理对 MongoDB 文档数据库的访问。它依赖于仓库式数据访问层和
    POJO 编程模型。'
- en: '*Spring Data Redis*—Spring Data Redis deals with access to the Redis key/value
    database. It relies on freeing the developer from managing the infrastructure
    and providing high- and low-level abstractions for access to the data store. Spring
    Data Redis isn’t covered in this book.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Data Redis*—Spring Data Redis 处理对 Redis 键/值数据库的访问。它依赖于释放开发人员管理基础设施，并提供对数据存储的高层和低层抽象。Spring
    Data Redis 在本书中未涵盖。'
- en: The Spring Data source code (together with other Spring projects) is freely
    downloadable from [https://github.com/spring-projects](https://github.com/spring-projects).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 源代码（与其他 Spring 项目一起）可以从 [https://github.com/spring-projects](https://github.com/spring-projects)
    免费下载。
- en: Let’s get started with our first JPA, Hibernate, and Spring Data project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的第一个 JPA、Hibernate 和 Spring Data 项目。
- en: 2.3 “Hello World” with JPA
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 使用 JPA 的“Hello World”
- en: 'In this section we’ll write our first JPA application, which will store a message
    in the database and then retrieve it. The machine we are running our code on has
    MySQL Release 8.0 installed. To install MySQL Release 8.0, follow the instructions
    in the official documentation: [https://dev.mysql.com/doc/refman/8.0/en/installing.xhtml](https://dev.mysql.com/doc/refman/8.0/en/installing.xhtml).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写我们的第一个 JPA 应用程序，该程序将在数据库中存储一条消息，然后检索它。我们运行代码的机器上安装了 MySQL Release
    8.0。要安装 MySQL Release 8.0，请遵循官方文档中的说明：[https://dev.mysql.com/doc/refman/8.0/en/installing.xhtml](https://dev.mysql.com/doc/refman/8.0/en/installing.xhtml)。
- en: 'In order to execute the examples in the source code, you’ll need first to run
    the Ch02.sql script, as shown in figure 2.1\. Open MySQL Workbench, go to File
    > Open SQL Script, and choose the SQL file and run it. The examples use a MySQL
    server with the default credentials: the username *root* and no password.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行源代码中的示例，您首先需要运行 Ch02.sql 脚本，如图 2.1 所示。打开 MySQL Workbench，转到文件 > 打开 SQL 脚本，选择
    SQL 文件并运行它。示例使用默认凭证的 MySQL 服务器：用户名 *root*，无密码。
- en: '![](../../OEBPS/Images/CH02_F01_Tudose2.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH02_F01_Tudose2.png)'
- en: Figure 2.1 Creating the MySQL database by running the Ch02.sql script
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 通过运行 Ch02.sql 脚本创建 MySQL 数据库
- en: In the “Hello World” application, we want to store messages in the database
    and load them from the database. Hibernate applications define persistent classes
    that are mapped to database tables. We define these classes based on our analysis
    of the business domain; hence, they’re a model of the domain. This example will
    consist of one class and its mapping. We’ll write the examples as executable tests,
    with assertions that verify the correct outcome of each operation. We’ve tested
    all the examples in this book, so we can be sure they work properly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Hello World”应用程序中，我们希望将消息存储在数据库中，并从数据库中加载它们。Hibernate 应用程序定义了映射到数据库表的持久化类。我们根据对业务领域的分析来定义这些类；因此，它们是领域模型。本例将包括一个类及其映射。我们将编写可执行的测试示例，其中包含验证每个操作正确结果的断言。我们已经测试了本书中的所有示例，因此我们可以确信它们可以正常工作。
- en: Let’s start by installing and configuring JPA, Hibernate, and the other needed
    dependencies. We’ll use Apache Maven as the project build tool for all the examples
    in this book. For basic Maven concepts and details on how to set up Maven, see
    appendix A.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先安装和配置 JPA、Hibernate 以及其他所需依赖项。我们将使用 Apache Maven 作为本书中所有示例的项目构建工具。有关基本 Maven
    概念和如何设置 Maven 的详细信息，请参阅附录 A。
- en: We’ll declare the dependencies shown in the following listing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下列表中声明依赖项。
- en: Listing 2.1 The Maven dependencies on Hibernate, JUnit Jupiter, and MySQL
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 Maven 对 Hibernate、JUnit Jupiter 和 MySQL 的依赖
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `hibernate-entitymanager` module includes transitive dependencies on other
    modules we’ll need, such as `hibernate-core` and the JPA interface stubs. We also
    need the `junit-jupiter-engine` dependency to run the tests with the help of JUnit
    5, and the `mysql-connector-java` dependency, which is the official JDBC driver
    for MySQL.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`hibernate-entitymanager` 模块包括对其他我们将需要的模块的传递依赖，例如 `hibernate-core` 和 JPA 接口存根。我们还需要
    `junit-jupiter-engine` 依赖项，以使用 JUnit 5 运行测试，以及 `mysql-connector-java` 依赖项，这是 MySQL
    的官方 JDBC 驱动程序。'
- en: Our starting point in JPA is the *persistence unit*. A persistence unit is a
    pairing of our domain model class mappings with a database connection, plus some
    other configuration settings. Every application has at least one persistence unit;
    some applications have several if they’re talking to several (logical or physical)
    databases. Hence, our first step is setting up a persistence unit in our application’s
    configuration.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JPA 中，我们的起点是 *持久化单元*。持久化单元是将我们的领域模型类映射与数据库连接以及一些其他配置设置配对。每个应用程序至少有一个持久化单元；如果它们与多个（逻辑或物理）数据库通信，则某些应用程序可能有多个。因此，我们的第一步是在应用程序配置中设置持久化单元。
- en: 2.3.1 Configuring a persistence unit
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 配置持久化单元
- en: The standard configuration file for persistence units is located on the classpath
    in META-INF/persistence.xml. Create the following configuration file for the “Hello
    World” application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化单元的标准配置文件位于类路径上的 META-INF/persistence.xml。为“Hello World”应用程序创建以下配置文件。
- en: Listing 2.2 The persistence.xml configuration file
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 persistence.xml 配置文件
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ⓐ The persistence.xml file configures at least one persistence unit; each unit
    must have a unique name.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ persistence.xml 文件配置了至少一个持久化单元；每个单元必须有一个唯一名称。
- en: Ⓑ As JPA is only a specification, we need to indicate the vendor-specific PersistenceProvider
    implementation of the API. The persistence we define will be backed by a Hibernate
    provider.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 由于 JPA 只是一个规范，我们需要指出 API 的供应商特定 PersistenceProvider 实现。我们定义的持久化将由 Hibernate
    提供商支持。
- en: Ⓒ Indicate the JDBC properties—the driver.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 指定 JDBC 属性——驱动程序。
- en: Ⓓ The URL of the database.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 数据库的 URL。
- en: Ⓔ The username.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 用户名。
- en: Ⓕ There is no password for access. The machine we are running the programs on
    has MySQL 8 installed, and the access credentials are the ones from persistence.xml.
    You should modify the credentials to correspond to the ones on your machine.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 没有访问密码。我们运行程序的机器上安装了 MySQL 8，访问凭证来自 persistence.xml。你应该修改凭证以匹配你机器上的凭证。
- en: Ⓖ The Hibernate dialect is MySQL8, as the database to interact with is MySQL
    Release 8.0.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ Hibernate 方言是 MySQL8，因为我们交互的数据库是 MySQL Release 8.0。
- en: Ⓗ While executing, show the SQL code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 在执行过程中，显示 SQL 代码。
- en: Ⓘ Hibernate will format the SQL nicely and generate comments in the SQL string
    so we know why Hibernate executed the SQL statement.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓘ Hibernate 会很好地格式化 SQL 并在 SQL 字符串中生成注释，这样我们就能知道 Hibernate 为什么执行这个 SQL 语句。
- en: Ⓙ Every time the program is executed, the database will be created from scratch.
    This is ideal for automated testing, when we want to work with a clean database
    for every test run.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓙ 每次程序执行时，数据库都将从头创建。这对于自动化测试来说很理想，当我们希望每次测试运行都使用一个干净的数据库时。
- en: Let’s see what a simple persistent class looks like, how the mapping is created,
    and some of the things we can do with instances of the persistent class in JPA.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的持久化类的样子，映射是如何创建的，以及我们可以用 JPA 中持久化类的实例做的一些事情。
- en: 2.3.2 Writing a persistent class
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 编写持久化类
- en: The objective of this example is to store messages in a database and retrieve
    them for display. The application has a simple persistent class, `Message`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的目标是将消息存储在数据库中，并检索它们以供显示。应用程序有一个简单的持久化类，`Message`。
- en: Listing 2.3 The `Message` class
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 `Message` 类
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Ⓐ Every persistent entity class must have at least the `@Entity` annotation.
    Hibernate maps this class to a table called `MESSAGE`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 每个持久化实体类至少必须有一个 `@Entity` 注解。Hibernate 将此类映射到名为 `MESSAGE` 的表。
- en: Ⓑ Every persistent entity class must have an identifier attribute annotated
    with `@Id`. Hibernate maps this attribute to a column named `id`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 每个持久化实体类都必须有一个用 `@Id` 注解的标识符属性。Hibernate 将此属性映射到名为 `id` 的列。
- en: Ⓒ Someone must generate identifier values; this annotation enables automatic
    generation of ids.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 必须有人生成标识符值；这个注解允许自动生成 ID。
- en: Ⓓ We usually implement regular attributes of a persistent class with private
    fields and public getter/setter method pairs. Hibernate maps this attribute to
    a column called `text`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 我们通常使用私有字段和公共 getter/setter 方法对来实现持久化类的常规属性。Hibernate 将此属性映射到名为 `text` 的列。
- en: The identifier attribute of a persistent class allows the application to access
    the database identity—the primary key value—of a persistent instance. If two instances
    of `Message` have the same identifier value, they represent the same row in the
    database. This example uses `Long` for the type of identifier attribute, but this
    isn’t a requirement. Hibernate allows you to use virtually anything for the identifier
    type, as you’ll see later in the book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化类的标识符属性允许应用程序访问持久化实例的数据库身份——主键值。如果两个 `Message` 实例具有相同的标识符值，它们代表数据库中的同一行。本例使用
    `Long` 作为标识符属性的类型，但这不是必需的。Hibernate 允许你使用几乎任何东西作为标识符类型，正如你将在本书后面的内容中看到的。
- en: You may have noticed that the `text` attribute of the `Message` class has JavaBeans-style
    property accessor methods. The class also has a (default) constructor with no
    parameters. The persistent classes we’ll show in the examples will usually look
    something like this. Note that we don’t need to implement any particular interface
    or extend any special superclass.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 `Message` 类的 `text` 属性具有 JavaBeans 风格的属性访问器方法。该类还有一个（默认的）无参数构造函数。我们将在示例中展示的持久化类通常看起来像这样。请注意，我们不需要实现任何特定的接口或扩展任何特殊超类。
- en: 'Instances of the `Message` class can be managed (made persistent) by Hibernate,
    but they don’t have to be. Because the `Message` object doesn’t implement any
    persistence-specific classes or interfaces, we can use it just like any other
    Java class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message` 类的实例可以由 Hibernate 管理（使其持久化），但它们不必这样做。因为 `Message` 对象没有实现任何持久化特定的类或接口，我们可以像使用任何其他
    Java 类一样使用它：'
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It may look like we’re trying to be cute here; in fact, we’re demonstrating
    an important feature that distinguishes Hibernate from some other persistence
    solutions. We can use the persistent class in any execution context—*no special
    container is needed*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来我们在这里试图卖弄聪明；实际上，我们正在展示Hibernate与其他一些持久化解决方案区分开来的一个重要特性。我们可以在任何执行上下文中使用持久化类——*不需要特殊容器*。
- en: We don’t have to use annotations to map a persistent class. Later we’ll show
    other mapping options, such as the JPA orm.xml mapping file and the native hbm.xml
    mapping files, and we’ll look at when they’re a better solution than source annotations,
    which are the most frequently used approach nowadays.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必使用注解来映射持久化类。稍后我们将展示其他映射选项，例如JPA orm.xml映射文件和本地的hbm.xml映射文件，并探讨它们何时比源注解（目前最常用的方法）更优。
- en: The `Message` class is now ready. We can store instances in our database and
    write queries to load them again into application memory.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message`类现在已准备好。我们可以在数据库中存储实例并编写查询将它们再次加载到应用程序内存中。'
- en: 2.3.3 Storing and loading messages
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 存储和加载消息
- en: What you really came here to see is JPA with Hibernate, so let’s save a new
    `Message` to the database.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你真正来这里想看的是与Hibernate一起使用的JPA，所以让我们将一个新的`Message`保存到数据库中。
- en: Listing 2.4 The `HelloWorldJPATest` class
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 `HelloWorldJPATest`类
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Ⓐ First we need an `EntityManagerFactory` to talk to the database. This API
    represents the persistence unit, and most applications have one `EntityManager-Factory`
    for one configured persistence unit. Once it starts, the application should create
    the `EntityManagerFactory`; the factory is thread-safe, and all code in the application
    that accesses the database should share it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 首先，我们需要一个`EntityManagerFactory`来与数据库通信。这个API代表持久化单元，大多数应用程序为一个配置的持久化单元有一个`EntityManagerFactory`。一旦启动，应用程序应该创建`EntityManagerFactory`；工厂是线程安全的，应用程序中所有访问数据库的代码都应该共享它。
- en: Ⓑ Begin a new session with the database by creating an `EntityManager`. This
    is the context for all persistence operations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 通过创建`EntityManager`来与数据库开始一个新的会话。这是所有持久化操作上下文。
- en: Ⓒ Get access to the standard transaction API, and begin a transaction on this
    thread of execution.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 获取标准事务API的访问权限，并在当前执行线程上开始一个事务。
- en: Ⓓ Create a new instance of the mapped domain model class `Message`, and set
    its `text` property.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 创建一个映射的领域模型类`Message`的新实例，并设置其`text`属性。
- en: Ⓔ Enlist the transient instance with the persistence context; we make it persistent.
    Hibernate now knows that we wish to store that data, but it doesn't necessarily
    call the database immediately.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 将瞬态实例注册到持久化上下文中；我们使其持久化。Hibernate现在知道我们希望存储这些数据，但它并不一定立即调用数据库。
- en: Ⓕ Commit the transaction. Hibernate automatically checks the persistence context
    and executes the necessary SQL `INSERT` statement. To help you understand how
    Hibernate works, we show the automatically generated and executed SQL statements
    in source code comments when they occur. Hibernate inserts a row in the `MESSAGE`
    table, with an automatically generated value for the `ID` primary key column,
    and the `TEXT` value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 提交事务。Hibernate会自动检查持久化上下文并执行必要的SQL `INSERT`语句。为了帮助您理解Hibernate的工作原理，我们在源代码注释中展示了自动生成和执行的SQL语句，当它们发生时。Hibernate在`MESSAGE`表中插入一行，为`ID`主键列自动生成一个值，以及`TEXT`值。
- en: Ⓖ Every interaction with the database should occur within transaction boundaries,
    even if we’re only reading data, so we start a new transaction. Any potential
    failure appearing from now on will not affect the previously committed transaction.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 每次与数据库的交互都应该在事务边界内进行，即使我们只是在读取数据，因此我们开始一个新的事务。从现在开始出现的任何潜在失败都不会影响之前提交的事务。
- en: Ⓗ Execute a query to retrieve all instances of `Message` from the database.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 执行查询以从数据库中检索所有`Message`实例。
- en: Ⓘ We can change the value of a property. Hibernate detects this automatically
    because the loaded `Message` is still attached to the persistence context it was
    loaded in.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓘ 我们可以更改属性的值。Hibernate会自动检测这一点，因为加载的`Message`仍然附加在它被加载的持久化上下文中。
- en: Ⓙ On commit, Hibernate checks the persistence context for dirty state, and it
    executes the SQL `UPDATE` automatically to synchronize in-memory objects with
    the database state.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓙ 在提交时，Hibernate会检查持久化上下文是否存在脏状态，并自动执行SQL `UPDATE`语句以同步内存中的对象与数据库状态。
- en: Ⓚ Check the size of the list of messages retrieved from the database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓚ 检查从数据库检索到的消息列表的大小。
- en: Ⓛ Check that the message we persisted is in the database. We use the JUnit 5
    `assertAll` method, which always checks all the assertions that are passed to
    it, even if some of them fail. The two assertions that we verify are conceptually
    related.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓛ 检查我们持久化的消息是否在数据库中。我们使用JUnit 5的`assertAll`方法，该方法始终检查传递给它的所有断言，即使其中一些失败。我们验证的两个断言在概念上是相关的。
- en: Ⓜ We created an `EntityManager`, so we must close it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓜ 我们创建了一个`EntityManager`，因此我们必须关闭它。
- en: Ⓝ We created an `EntityManagerFactory`, so we must close it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓝ 我们创建了一个`EntityManagerFactory`，因此我们必须关闭它。
- en: The query language you’ve seen in this example isn’t SQL, it’s the Jakarta Persistence
    Query Language (JPQL). Although there is syntactically no difference in this trivial
    example, the `Message` in the query string doesn’t refer to the database table
    name but to the persistent class name. For this reason, the `Message` class name
    in the query is case-sensitive. If we map the class to a different table, the
    query will still work.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中您看到的查询语言不是SQL，它是Jakarta Persistence Query Language（JPQL）。尽管在这个简单的例子中在语法上没有区别，但查询字符串中的`Message`并不指向数据库表名，而是指向持久化类名。因此，查询中的`Message`类名是区分大小写的。如果我们将类映射到不同的表，查询仍然会工作。
- en: Also, notice how Hibernate detects the modification to the text property of
    the message and automatically updates the database. This is the automatic dirty-checking
    feature of JPA in action. It saves us the effort of explicitly asking the persistence
    manager to update the database when we modify the state of an instance inside
    a transaction.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意Hibernate如何检测消息文本属性的修改，并自动更新数据库。这是JPA的自动脏检查功能在起作用。它节省了我们显式请求持久化管理器在事务中修改实例状态时更新数据库的努力。
- en: Figure 2.2 shows the result of checking for the existence of the record we inserted
    and updated on the database side. As you’ll recall, we created a database named
    CH02 by running the Ch02.sql script from the chapter’s source code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2显示了在数据库侧检查我们插入和更新记录存在性的结果。如您所回忆的，我们通过从章节源代码中运行Ch02.sql脚本来创建了一个名为CH02的数据库。
- en: '![](../../OEBPS/Images/CH02_F02_Tudose2.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F02_Tudose2.png)'
- en: Figure 2.2 The result of checking for the existence of the inserted and updated
    record on the database side
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 检查数据库侧插入和更新记录存在性的结果
- en: You’ve just completed your first JPA and Hibernate application. Let’s now take
    a quick look at the native Hibernate bootstrap and configuration API.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚完成了您的第一个JPA和Hibernate应用程序。现在让我们快速了解一下本地的Hibernate引导和配置API。
- en: 2.4 Native Hibernate configuration
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 本地Hibernate配置
- en: Although basic (and extensive) configuration is standardized in JPA, we can’t
    access all the configuration features of Hibernate with properties in persistence.xml.
    Note that most applications, even quite sophisticated ones, don’t need such special
    configuration options and hence don’t have to access the bootstrap API we’ll show
    in this section. If you aren’t sure, you can skip this section and come back to
    it later when you need to extend Hibernate type adapters, add custom SQL functions,
    and so on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JPA中基本（和广泛）的配置是标准化的，但我们无法通过`persistence.xml`中的属性访问Hibernate的所有配置功能。请注意，大多数应用程序，即使是相当复杂的，也不需要这样的特殊配置选项，因此不需要访问本节中我们将展示的引导API。如果您不确定，您可以跳过这一节，稍后再回来，当您需要扩展Hibernate类型适配器、添加自定义SQL函数等时。
- en: When using native Hibernate we’ll use the Hibernate dependencies and API directly,
    rather than the JPA dependencies and classes. JPA is a specification, and it can
    use different implementations (Hibernate is one example, but EclipseLink is another
    alternative) through the same API. Hibernate, as an implementation, provides its
    own dependencies and classes. While using JPA provides more flexibility, you’ll
    see throughout the book that accessing the Hibernate implementation directly allows
    you to use features that are not covered by the JPA standard (we’ll point this
    out where it’s relevant).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用本地Hibernate时，我们将直接使用Hibernate依赖项和API，而不是JPA依赖项和类。JPA是一个规范，它可以通过相同的API使用不同的实现（Hibernate是一个例子，但EclipseLink是另一个替代方案）。Hibernate作为一个实现，提供了它自己的依赖项和类。虽然使用JPA提供了更多的灵活性，但您会在整本书中看到，直接访问Hibernate实现允许您使用JPA标准未涵盖的功能（我们将在相关的地方指出这一点）。
- en: The native equivalent of the standard JPA `EntityManagerFactory` is the `org.hibernate.SessionFactory`.
    We have usually one per application, and it involves the same pairing of class
    mappings with database connection configuration.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 标准JPA `EntityManagerFactory`的原生等价物是`org.hibernate.SessionFactory`。我们通常每个应用程序有一个，它涉及与数据库连接配置相同的类映射配对。
- en: To configure the native Hibernate, we can use a hibernate.properties Java properties
    file or a hibernate.cfg.xml XML file. We’ll choose the second option, and the
    configuration will contain database and session-related options. This XML file
    is generally placed in the src/main/resource or src/test/resource folder. As we
    need the information for the Hibernate configuration in our tests, we’ll choose
    the second location.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置原生Hibernate，我们可以使用一个hibernate.properties Java属性文件或一个hibernate.cfg.xml XML文件。我们将选择第二种选项，配置将包含数据库和会话相关的选项。这个XML文件通常放置在src/main/resource或src/test/resource文件夹中。由于我们需要在测试中使用Hibernate配置信息，我们将选择第二个位置。
- en: Listing 2.5 The hibernate.cfg.xml configuration file
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 hibernate.cfg.xml配置文件
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ⓐ We use the tags to indicate that we are configuring Hibernate.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 我们使用标签来表示我们正在配置Hibernate。
- en: Ⓑ More exactly, we are configuring the `SessionFactory` object. `SessionFactory`
    is an interface, and we need one `SessionFactory` to interact with one database.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 更确切地说，我们正在配置`SessionFactory`对象。`SessionFactory`是一个接口，我们需要一个`SessionFactory`来与一个数据库交互。
- en: Ⓒ Indicate the JDBC properties—the driver.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 指定JDBC属性——驱动程序。
- en: Ⓓ The URL of the database.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 数据库的URL。
- en: Ⓔ The username.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 用户名。
- en: Ⓕ No password is required to access it. The machine we are running the programs
    on has MySQL 8 installed and the access credentials are the ones from hibernate
    .cfg.xml. You should modify the credentials to correspond to the ones on your
    machine.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 访问它不需要密码。我们运行的程序机器上安装了MySQL 8，访问凭证来自hibernate .cfg.xml。您应该修改凭证以匹配您机器上的凭证。
- en: Ⓖ Limit the number of connections waiting in the Hibernate database connection
    pool to 50.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 将Hibernate数据库连接池中等待的连接数限制为50。
- en: Ⓗ While executing, the SQL code is shown.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 在执行过程中，会显示SQL代码。
- en: Ⓘ Every time the program is executed, the database will be created from scratch.
    This is ideal for automated testing, when we want to work with a clean database
    for every test run.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓘ 每次程序执行时，数据库将从零开始创建。这对于自动化测试来说很理想，当我们希望每次测试运行都使用一个干净的数据库时。
- en: Let’s save a `Message` to the database using native Hibernate.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用原生Hibernate将一个`Message`保存到数据库中。
- en: Listing 2.6 The `HelloWorldHibernateTest` class
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6 `HelloWorldHibernateTest`类
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ⓐ To create a `SessionFactory`, we first need to create a configuration.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 要创建一个`SessionFactory`，我们首先需要创建一个配置。
- en: Ⓑ We need to call the `configure` method on it and to add `Message` to it as
    an annotated class. The execution of the `configure` method will load the content
    of the default hibernate.cfg.xml file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 我们需要调用它的`configure`方法，并将`Message`作为注解类添加到其中。`configure`方法的执行将加载默认的hibernate.cfg.xml文件的内容。
- en: Ⓒ The builder pattern helps us create the immutable service registry and configure
    it by applying settings with chained method calls. A `ServiceRegistry` hosts and
    manages services that need access to the `SessionFactory`. Services are classes
    that provide pluggable implementations of different types of functionality to
    Hibernate.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 建造者模式帮助我们创建不可变的服务注册表，并通过链式方法调用应用设置来配置它。`ServiceRegistry`托管并管理需要访问`SessionFactory`的服务。服务是提供不同类型功能可插拔实现的类。
- en: Ⓓ Build a `SessionFactory` using the configuration and the service registry
    we have previously created.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 使用配置和之前创建的服务注册表构建一个`SessionFactory`。
- en: Ⓔ The `SessionFactory` created with the `createSessionFactory` method we previously
    defined is passed as an argument to a `try` with resources, as `SessionFactory`
    implements the `AutoCloseable` interface.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 使用我们之前定义的`createSessionFactory`方法创建的`SessionFactory`作为参数传递给一个`try`资源，因为`SessionFactory`实现了`AutoCloseable`接口。
- en: Ⓕ Similarly, we begin a new session with the database by creating a `Session`,
    which also implements the `AutoCloseable` interface. This is our context for all
    persistence operations.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 类似地，我们通过创建一个`Session`来与数据库开始一个新的会话，该`Session`也实现了`AutoCloseable`接口。这是我们所有持久化操作的环境。
- en: Ⓕ Get access to the standard transaction API and begin a transaction on this
    thread of execution.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 获取标准事务API的访问权限，并在执行线程上开始一个事务。
- en: Ⓗ Create a new instance of the mapped domain model class `Message`, and set
    its `text` property.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 创建一个映射的域模型类`Message`的新实例，并设置其`text`属性。
- en: Ⓘ Enlist the transient instance with the persistence context; we make it persistent.
    Hibernate now knows that we wish to store that data, but it doesn't necessarily
    call the database immediately. The native Hibernate API is pretty similar to the
    standard JPA, and most methods have the same name.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓘ 将瞬态实例注册到持久化上下文中；我们使其持久化。Hibernate现在知道我们希望存储该数据，但它不一定立即调用数据库。原生的Hibernate API与标准JPA非常相似，并且大多数方法具有相同的名称。
- en: Ⓙ Synchronize the session with the database, and close the current session on
    commit of the transaction automatically.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓙ 同步会话与数据库，并在事务提交时自动关闭当前会话。
- en: Ⓚ Begin another transaction. Every interaction with the database should occur
    within transaction boundaries, even if we’re only reading data.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓚ 开始另一个事务。每次与数据库的交互都应在事务边界内进行，即使我们只是在读取数据。
- en: Ⓛ Create an instance of `CriteriaQuery` by calling the `CriteriaBuilder` `createQuery()`
    method. A `CriteriaBuilder` is used to construct criteria queries, compound selections,
    expressions, predicates, and orderings. A `CriteriaQuery` defines functionality
    that is specific to top-level queries. `CriteriaBuilder` and `CriteriaQuery` belong
    to the Criteria API, which allows us to build a query programmatically.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓛ 通过调用`CriteriaBuilder`的`createQuery()`方法创建`CriteriaQuery`实例。`CriteriaBuilder`用于构建查询、复合选择、表达式、谓词和排序。`CriteriaQuery`定义了顶层查询特有的功能。`CriteriaBuilder`和`CriteriaQuery`属于Criteria
    API，它允许我们以编程方式构建查询。
- en: Ⓜ Create and add a query root corresponding to the given `Message` entity.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓜ 创建并添加一个与给定`Message`实体对应的查询根。
- en: Ⓝ Call the `getResultList()` method of the query object to get the results.
    The query that is created and executed will be `SELECT * FROM MESSAGE`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓝ 调用查询对象的`getResultList()`方法以获取结果。创建并执行查询将是`SELECT * FROM MESSAGE`。
- en: Ⓞ Commit the transaction.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓞ 提交事务。
- en: Ⓟ Check the size of the list of messages retrieved from the database.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓟ 检查从数据库检索到的消息列表的大小。
- en: Ⓠ Check that the message we persisted is in the database. We use the JUnit 5
    `assertAll` method, which always checks all the assertions that are passed to
    it, even if some of them fail. The two assertions that we verify are conceptually
    related.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓠ 检查我们持久化的消息是否在数据库中。我们使用JUnit 5的`assertAll`方法，该方法始终检查传递给它的所有断言，即使其中一些失败。我们验证的两个断言在概念上是相关的。
- en: Figure 2.3 shows the result of checking for the existence of the record we inserted
    on the database side by using native Hibernate.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3显示了使用原生Hibernate在数据库侧检查我们插入的记录存在性的结果。
- en: '![](../../OEBPS/Images/CH02_F03_Tudose2.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH02_F03_Tudose2.png)'
- en: Figure 2.3 The result of checking for the existence of the inserted record on
    the database side
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 在数据库侧检查插入记录存在性的结果
- en: Most of the examples in this book won’t use the `SessionFactory` or `Session`
    API. From time to time, when a particular feature is only available in Hibernate,
    we’ll show you how to `unwrap()` the native interface.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数示例都不会使用`SessionFactory`或`Session` API。偶尔，当某个特定功能仅在Hibernate中可用时，我们会向您展示如何使用`unwrap()`方法来解包原生接口。
- en: 2.5 Switching between JPA and Hibernate
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 在JPA和Hibernate之间切换
- en: Suppose you’re working with JPA and need to access the Hibernate API. Or, vice
    versa, you’re working with native Hibernate and you need to create an `EntityManagerFactory`
    from the Hibernate configuration. To obtain a `SessionFactory` from an `EntityManagerFactory`,
    you’ll have to unwrap the first one from the second one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在使用JPA并需要访问Hibernate API。或者，相反，您正在使用原生Hibernate，您需要从Hibernate配置中创建一个`EntityManagerFactory`。要从`EntityManagerFactory`获取`SessionFactory`，您必须从第二个中解包第一个。
- en: Listing 2.7 Obtaining a `SessionFactory` from an `EntityManagerFactory`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7 从`EntityManagerFactory`获取`SessionFactory`
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Starting with JPA version 2.0, you can get access to the APIs of the underlying
    implementations. The `EntityManagerFactory` (and also the `EntityManager`) declares
    an `unwrap` method that will return objects belonging to the classes of the JPA
    implementation. When using the Hibernate implementation, you can get the corresponding
    `SessionFactory` or `Session` objects and start using them as demonstrated in
    listing 2.6\. When a particular feature is only available in Hibernate, you can
    switch to it using the `unwrap` method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从JPA版本2.0开始，您可以访问底层实现的API。`EntityManagerFactory`（以及`EntityManager`）声明了一个`unwrap`方法，该方法将返回属于JPA实现类别的对象。当使用Hibernate实现时，您可以获取相应的`SessionFactory`或`Session`对象，并开始像示例2.6中所示那样使用它们。当某个特定功能仅在Hibernate中可用时，您可以使用`unwrap`方法切换到它。
- en: 'You may be interested in the reverse operation: creating an `EntityManagerFactory`
    from an initial Hibernate configuration.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对反向操作感兴趣：从一个初始Hibernate配置中创建`EntityManagerFactory`。
- en: Listing 2.8 Obtaining an `EntityManagerFactory` from a Hibernate configuration
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8 从Hibernate配置中获取`EntityManagerFactory`
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Ⓐ Create a new Hibernate configuration.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 创建一个新的Hibernate配置。
- en: Ⓑ Call the `configure` method, which adds the content of the default hibernate
    .cfg.xml file to the configuration, and then explicitly add `Message` as an annotated
    class.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 调用`configure`方法，该方法将默认hibernate .cfg.xml文件的内容添加到配置中，然后显式添加`Message`作为注解类。
- en: Ⓒ Create a new hash map to be filled in with the existing properties.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 创建一个新的哈希表，用于填充现有的属性。
- en: Ⓓ Get all the property names from the Hibernate configuration.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 获取Hibernate配置中的所有属性名称。
- en: Ⓔ Add the property names one by one to the previously created map.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 将属性名称逐个添加到之前创建的映射中。
- en: Ⓕ Return a new `EntityManagerFactory`, providing to it the ch02.ex01 persistence
    unit name and the previously created map of properties.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 返回一个新的`EntityManagerFactory`，向其提供ch02.ex01持久化单元名称和之前创建的属性映射。
- en: 2.6 “Hello World” with Spring Data JPA
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 使用Spring Data JPA的“Hello World”
- en: Let’s now write our first Spring Data JPA application, which will store a message
    in the database and then retrieve it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写第一个Spring Data JPA应用程序，该程序将在数据库中存储一条消息，然后检索它。
- en: We’ll first add the Spring dependencies to the Apache Maven configuration.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将Spring依赖项添加到Apache Maven配置中。
- en: Listing 2.9 The Maven dependencies on Spring
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9 Spring的Maven依赖项
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Ⓐ The `spring-data-jpa` module provides repository support for JPA and includes
    transitive dependencies on other modules we’ll need, such as `spring-core` and
    `spring-context`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `spring-data-jpa`模块为JPA提供仓库支持，并包含对我们需要的其他模块的传递依赖，例如`spring-core`和`spring-context`。
- en: Ⓑ We also need the `spring-test` dependency to run the tests.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 我们还需要`spring-test`依赖项来运行测试。
- en: The standard configuration file for Spring Data JPA is a Java class that creates
    and sets up the beans needed by Spring Data. The configuration can be done using
    either an XML file or Java code, and we’ve chosen the second alternative. Create
    the following configuration file for the “Hello World” application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JPA的标准配置文件是一个Java类，它创建并设置Spring Data所需的bean。配置可以使用XML文件或Java代码完成，我们选择了第二种选择。为“Hello
    World”应用程序创建以下配置文件。
- en: Listing 2.10 The `SpringDataConfiguration` class
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.10 `SpringDataConfiguration`类
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Ⓐ The `@EnableJpaRepositories` annotation enables scanning of the package received
    as an argument for Spring Data repositories.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `@EnableJpaRepositories`注解使Spring Data仓库能够扫描作为参数接收的包。
- en: Ⓑ Create a data source bean.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 创建一个数据源bean。
- en: Ⓒ Specify the JDBC properties—the driver.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 指定JDBC属性——驱动程序。
- en: Ⓓ The URL of the database.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 数据库的URL。
- en: Ⓔ The username.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓜ 用户名。
- en: Ⓕ No password is required for access. The machine we are running the programs
    on has MySQL 8 installed, and the access credentials are the ones from this configuration.
    You should modify the credentials to correspond to the ones on your machine.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 访问不需要密码。我们运行的程序机器上安装了MySQL 8，访问凭证来自此配置。你应该修改凭证以匹配你机器上的凭证。
- en: Ⓖ Create a transaction manager bean based on an entity manager factory. Every
    interaction with the database should occur within transaction boundaries, and
    Spring Data needs a transaction manager bean.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 基于实体管理器工厂创建一个事务管理器bean。每次与数据库的交互都应在事务边界内进行，Spring Data需要一个事务管理器bean。
- en: Ⓗ Create the JPA vendor adapter bean needed by JPA to interact with Hibernate.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 创建JPA供应商适配器bean，这是JPA与Hibernate交互所需的。
- en: Ⓘ Configure this vendor adapter to access a MySQL database.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓘ 配置此供应商适配器以访问MySQL数据库。
- en: Ⓙ Show the SQL code while it is executed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓙ 在执行时显示SQL代码。
- en: Ⓚ Create a `LocalContainerEntityManagerFactoryBean`. This is a factory bean
    that produces an `EntityManagerFactory` following the JPA standard container bootstrap
    contract.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓚ 创建一个`LocalContainerEntityManagerFactoryBean`。这是一个工厂bean，它根据JPA标准容器启动合同生成`EntityManagerFactory`。
- en: Ⓛ Set the data source.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓛ 设置数据源。
- en: Ⓜ Set the database to be created from scratch every time the program is executed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓜ 设置每次程序执行时从头创建数据库。
- en: Ⓝ Set the vendor adapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓝ 设置供应商适配器。
- en: Ⓞ Set the packages to scan for entity classes. As the `Message` entity is located
    in `com.manning.javapersistence.ch02`, we set this package to be scanned.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓞ 设置扫描实体类的包。由于`Message`实体位于`com.manning.javapersistence.ch02`，我们将此包设置为扫描。
- en: Spring Data JPA provides support for JPA-based data access layers by reducing
    the boilerplate code and creating implementations for the repository interfaces.
    We only need to define our own repository interface to extend one of the Spring
    Data interfaces.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JPA 通过减少样板代码并创建仓库接口的实现来支持基于 JPA 的数据访问层。我们只需要定义自己的仓库接口，以扩展 Spring
    Data 接口之一。
- en: Listing 2.11 The `MessageRepository` interface
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.11 `MessageRepository` 接口
- en: '[PRE11]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `MessageRepository` interface extends `CrudRepository <Message,` `Long>`.
    This means that it is a repository of `Message` entities with a `Long` identifier.
    Remember, the `Message` class has an `id` field annotated as `@Id` of type `Long`.
    We can directly call methods such as `save`, `findAll`, or `findById`, which are
    inherited from `CrudRepository`, and we can use them without any other additional
    information to execute the usual operations against a database. Spring Data JPA
    will create a proxy class implementing the `MessageRepository` interface and implement
    its methods (figure 2.4).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageRepository` 接口扩展了 `CrudRepository <Message, Long>`。这意味着它是一个具有 `Long`
    标识符的 `Message` 实体仓库。记住，`Message` 类有一个被注解为 `@Id` 的 `id` 字段，其类型为 `Long`。我们可以直接调用从
    `CrudRepository` 继承的方法，如 `save`、`findAll` 或 `findById`，并且我们可以使用它们来执行对数据库的常规操作，而无需任何其他附加信息。Spring
    Data JPA 将创建一个实现 `MessageRepository` 接口的代理类，并在创建代理类时生成其方法（见图 2.4）。'
- en: '![](../../OEBPS/Images/CH02_F04_Tudose2.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH02_F04_Tudose2.png)'
- en: Figure 2.4 The Spring Data JPA `Proxy` class implements the `MessageRepository`
    interface.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 Spring Data JPA 的 `Proxy` 类实现了 `MessageRepository` 接口。
- en: Let’s save a `Message` to the database using Spring Data JPA.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Spring Data JPA 将一个 `Message` 对象保存到数据库中。
- en: Listing 2.12 The `HelloWorldSpringDataJPATest` class
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.12 `HelloWorldSpringDataJPATest` 类
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Ⓐ Extend the test using `SpringExtension`. This extension is used to integrate
    the Spring test context with the JUnit 5 Jupiter test.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用 `SpringExtension` 扩展测试。这个扩展用于将 Spring 测试上下文与 JUnit 5 Jupiter 测试集成。
- en: Ⓑ The Spring test context is configured using the beans defined in the previously
    presented `SpringDataConfiguration` class.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 使用之前展示的 `SpringDataConfiguration` 类中定义的 beans 配置 Spring 测试上下文。
- en: Ⓒ A `MessageRepository` bean is injected by Spring through autowiring. This
    is possible as the `com.manning.javapersistence.ch02.repositories` package where
    `MessageRepository` is located was used as the argument of the `@EnableJpaRepositories`
    annotation in listing 2.8\. If we call `messageRepository.getClass()`, we’ll see
    that it returns something like `com.sun.proxy.$Proxy41`—a proxy generated by Spring
    Data, as explained in figure 2.4.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 通过自动装配，Spring 注入了一个 `MessageRepository` bean。这是可能的，因为 `MessageRepository`
    所在的 `com.manning.javapersistence.ch02.repositories` 包被用作列表 2.8 中 `@EnableJpaRepositories`
    注解的参数。如果我们调用 `messageRepository.getClass()`，我们会看到它返回类似 `com.sun.proxy.$Proxy41`
    的内容——这是 Spring Data 生成的代理，如图 2.4 所解释的。
- en: Ⓓ Create a new instance of the mapped domain model class `Message`, and set
    its `text` property.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 创建一个映射的领域模型类 `Message` 的新实例，并设置其 `text` 属性。
- en: Ⓔ Persist the `message` object. The `save` method is inherited from the `CrudRepository`
    interface, and its body will be generated by Spring Data JPA when the proxy class
    is created. It will simply save a `Message` entity to the database.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 持久化 `message` 对象。`save` 方法是从 `CrudRepository` 接口继承的，并且当创建代理类时，其体将由 Spring
    Data JPA 生成。它将简单地保存一个 `Message` 实体到数据库中。
- en: Ⓕ Retrieve the messages from the repository. The `findAll` method is inherited
    from the `CrudRepository` interface, and its body will be generated by Spring
    Data JPA when the proxy class is created. It will simply return all entities belonging
    to the `Message` class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 从仓库中检索消息。`findAll` 方法是从 `CrudRepository` 接口继承的，并且当创建代理类时，其体将由 Spring Data
    JPA 生成。它将简单地返回属于 `Message` 类的所有实体。
- en: Ⓖ Check the size of the list of messages retrieved from the database and that
    the message we persisted is in the database.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 检查从数据库检索的消息列表的大小，以及我们持久化的消息是否在数据库中。
- en: Ⓗ Use the JUnit 5 `assertAll` method, which checks all the assertions that are
    passed to it, even if some of them fail. The two assertions that we verify are
    conceptually related.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 使用 JUnit 5 的 `assertAll` 方法，该方法检查传递给它的所有断言，即使其中一些失败。我们验证的两个断言在概念上是相关的。
- en: You’ll notice that the Spring Data JPA test is considerably shorter than the
    ones using JPA or native Hibernate. This is because the boilerplate code has been
    removed—there’s no more explicit object creation or explicit control of the transactions.
    The repository object is injected, and it provides the generated methods of the
    proxy class. The burden is now heavier on the configuration side, but this should
    be done only once per application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，Spring Data JPA 测试比使用 JPA 或原生 Hibernate 的测试要短得多。这是因为已经去除了样板代码——不再有显式的对象创建或显式的事务控制。仓库对象被注入，并提供代理类生成的相关方法。现在，配置方面的负担更重，但这个操作应该在每个应用程序中只进行一次。
- en: Figure 2.5 shows the result of checking that the record we inserted with Spring
    Data JPA exists in the database.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 展示了使用 Spring Data JPA 插入的记录在数据库中存在的检查结果。
- en: '![](../../OEBPS/Images/CH02_F05_Tudose2.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F05_Tudose2.png)'
- en: Figure 2.5 The result of checking that the inserted record exists in the database
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 检查插入的记录在数据库中存在的结果
- en: 2.7 Comparing the approaches of persisting entities
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7 比较实体持久化方法
- en: We have implemented a simple application that interacts with a database and
    uses, alternatively, JPA, native Hibernate, and Spring Data JPA. Our purpose was
    to analyze each approach and see how the configuration and code varies. Table
    2.1 summarizes the characteristics of these approaches.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个简单的应用程序，它与数据库交互，并交替使用 JPA、原生 Hibernate 和 Spring Data JPA。我们的目的是分析每种方法，并查看配置和代码如何变化。表
    2.1 总结了这些方法的特点。
- en: Table 2.1 Comparison of working with JPA, native Hibernate, and Spring Data
    JPA
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 JPA、原生 Hibernate 和 Spring Data JPA 的工作比较
- en: '| Framework | Characteristics |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 框架 | 特征 |'
- en: '| JPA |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| JPA |'
- en: Uses the general JPA API and requires a persistence provider.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用的 JPA API 并需要一个持久化提供者。
- en: We can switch between persistence providers from the configuration.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从配置中切换到不同的持久化提供者。
- en: Requires explicit management of the `EntityManagerFactory`, `EntityManager`,
    and transactions.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要显式管理 `EntityManagerFactory`、`EntityManager` 和事务。
- en: The configuration and the amount of code to be written is similar to the native
    Hibernate native approach.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和需要编写的代码量与原生 Hibernate 原生方法类似。
- en: We can switch to the JPA approach by constructing an `EntityManagerFactory`
    from a native Hibernate configuration.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过从原生 Hibernate 配置中构建一个 `EntityManagerFactory` 来切换到 JPA 方法。
- en: '|'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Native Hibernate |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| Native Hibernate |'
- en: Uses the native Hibernate API. You are locked into using this chosen framework.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原生 Hibernate API。你将锁定使用这个选定的框架。
- en: Builds its configuration starting with the default Hibernate configuration files
    (hibernate.cfg.xml or hibernate.properties).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从默认的 Hibernate 配置文件（hibernate.cfg.xml 或 hibernate.properties）开始构建其配置。
- en: Requires explicit management of the `SessionFactory`, `Session`, and transactions.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要显式管理 `SessionFactory`、`Session` 和事务。
- en: The configuration and the amount of code to be written are similar to the JPA
    approach.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和需要编写的代码量与 JPA 方法类似。
- en: We can switch to the native Hibernate native approach by unwrapping a `Session-Factory`
    from an `EntityManagerFactory` or a `Session` from an `EntityManager`.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过从 `EntityManagerFactory` 解包 `SessionFactory` 或从 `EntityManager` 解包 `Session`
    来切换到原生 Hibernate 原生方法。
- en: '|'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Spring Data JPA |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| Spring Data JPA |'
- en: Needs additional Spring Data dependencies in the project.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在项目中添加额外的 Spring Data 依赖项。
- en: The configuration will also take care of the creation of beans needed for the
    project, including the transaction manager.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置还将负责创建项目所需的豆类，包括事务管理器。
- en: The repository interface only needs to be declared, and Spring Data will create
    an implementation for it as a proxy class with generated methods that interact
    with the database.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库接口只需要声明，Spring Data 将为其创建一个代理类实现，并生成与数据库交互的方法。
- en: The necessary repository is injected and not explicitly created by the programmer.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必要的仓库被注入，而不是由程序员显式创建。
- en: This approach requires the least amount of code to be written, as the configuration
    takes care of most of the burden.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法需要编写的代码量最少，因为配置处理了大部分的负担。
- en: '|'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: For more information on the performance of each approach, see the article “Object-Relational
    Mapping Using JPA, Hibernate and Spring Data JPA,” by Cătălin Tudose and Carmen
    Odubășteanu (Tudose, 2021).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 关于每种方法的性能信息，请参阅 Cătălin Tudose 和 Carmen Odubășteanu 撰写的文章“使用 JPA、Hibernate 和
    Spring Data JPA 进行对象关系映射”（Tudose, 2021）。
- en: To analyze the running times, we executed a batch of insert, update, select,
    and delete operations using the three approaches, progressively increasing the
    number of records from 1,000 to 50,000\. Tests were made on Windows 10 Enterprise,
    running on a four-core Intel i7-5500U processor at 2.40 GHz with 8 GB of RAM.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析运行时间，我们使用三种方法执行了一系列的插入、更新、选择和删除操作，记录数量从1,000逐渐增加到50,000。测试在Windows 10 Enterprise操作系统上进行，该系统运行在四核Intel
    i7-5500U处理器上，主频为2.40 GHz，内存为8 GB。
- en: The insert execution times of Hibernate and JPA are very close (see table 2.2
    and figure 2.6). The execution time for Spring Data JPA increases much faster
    with the increase of the number of records.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate和JPA的插入执行时间非常接近（见表2.2和图2.6）。随着记录数量的增加，Spring Data JPA的执行时间增长速度更快。
- en: Table 2.2 Insert execution times by framework (times in ms)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2 按框架的插入执行时间（单位：毫秒）
- en: '| Number of records | Hibernate | JPA | Spring Data JPA |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 记录数 | Hibernate | JPA | Spring Data JPA |'
- en: '| 1,000 | 1,138 | 1,127 | 2,288 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 1,000 | 1,138 | 1,127 | 2,288 |'
- en: '| 5,000 | 3,187 | 3,307 | 8,410 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 5,000 | 3,187 | 3,307 | 8,410 |'
- en: '| 10,000 | 5,145 | 5,341 | 14,565 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 10,000 | 5,145 | 5,341 | 14,565 |'
- en: '| 20,000 | 8,591 | 8,488 | 26,313 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 20,000 | 8,591 | 8,488 | 26,313 |'
- en: '| 30,000 | 11,146 | 11,859 | 37,579 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 30,000 | 11,146 | 11,859 | 37,579 |'
- en: '| 40,000 | 13,011 | 13,300 | 48,913 |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 40,000 | 13,011 | 13,300 | 48,913 |'
- en: '| 50,000 | 16,512 | 16,463 | 59,629 |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 50,000 | 16,512 | 16,463 | 59,629 |'
- en: '![](../../OEBPS/Images/CH02_F06_Tudose2.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH02_F06_Tudose2.png)'
- en: Figure 2.6 Insert execution times by framework (times in ms)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 按框架的插入执行时间（单位：毫秒）
- en: The update execution times of Hibernate and JPA are also very close (see table
    2.3 and figure 2.7). Again, the execution time for Spring Data JPA increases much
    faster with the increase of the number of records.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate和JPA的更新执行时间也非常接近（见表2.3和图2.7）。同样，随着记录数量的增加，Spring Data JPA的执行时间增长速度更快。
- en: Table 2.3 Update execution times by framework (times in ms)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.3 按框架的更新执行时间（单位：毫秒）
- en: '| Number of records | Hibernate | JPA | Spring Data JPA |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 记录数 | Hibernate | JPA | Spring Data JPA |'
- en: '| 1,000 | 706 | 759 | 2,683 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 1,000 | 706 | 759 | 2,683 |'
- en: '| 5,000 | 2,081 | 2,256 | 10,211 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 5,000 | 2,081 | 2,256 | 10,211 |'
- en: '| 10,000 | 3,596 | 3,958 | 17,594 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 10,000 | 3,596 | 3,958 | 17,594 |'
- en: '| 20,000 | 6,669 | 6,776 | 33,090 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 20,000 | 6,669 | 6,776 | 33,090 |'
- en: '| 30,000 | 9,352 | 9,696 | 46,341 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 30,000 | 9,352 | 9,696 | 46,341 |'
- en: '| 40,000 | 12,720 | 13,614 | 61,599 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 40,000 | 12,720 | 13,614 | 61,599 |'
- en: '| 50,000 | 16,276 | 16,355 | 75,071 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 50,000 | 16,276 | 16,355 | 75,071 |'
- en: '![](../../OEBPS/Images/CH02_F07_Tudose2.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH02_F07_Tudose2.png)'
- en: Figure 2.7 Update execution times by framework (times in ms)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 按框架的更新执行时间（单位：毫秒）
- en: The situation is similar for the select operations, with practically no difference
    between Hibernate and JPA, and a steep curve for Spring Data as the number of
    records increases (see table 2.4 and figure 2.8).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选择操作，情况也类似，Hibernate和JPA之间几乎没有差异，而随着记录数量的增加，Spring Data的曲线陡峭（见表2.4和图2.8）。
- en: Table 2.4 Select execution times by framework (times in ms)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.4 按框架的选择执行时间（单位：毫秒）
- en: '| Number of records | Hibernate | JPA | Spring Data JPA |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 记录数 | Hibernate | JPA | Spring Data JPA |'
- en: '| 1,000 | 1,138 | 1,127 | 2,288 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 1,000 | 1,138 | 1,127 | 2,288 |'
- en: '| 5,000 | 3,187 | 3,307 | 8,410 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 5,000 | 3,187 | 3,307 | 8,410 |'
- en: '| 10,000 | 5,145 | 5,341 | 14,565 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 10,000 | 5,145 | 5,341 | 14,565 |'
- en: '| 20,000 | 8,591 | 8,488 | 26,313 |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 20,000 | 8,591 | 8,488 | 26,313 |'
- en: '| 30,000 | 11,146 | 11,859 | 37,579 |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 30,000 | 11,146 | 11,859 | 37,579 |'
- en: '| 40,000 | 13,011 | 13,300 | 48,913 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 40,000 | 13,011 | 13,300 | 48,913 |'
- en: '| 50,000 | 16,512 | 16,463 | 59,629 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 50,000 | 16,512 | 16,463 | 59,629 |'
- en: '![](../../OEBPS/Images/CH02_F08_Tudose2.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH02_F08_Tudose2.png)'
- en: Figure 2.8 Select execution times by framework (times in ms)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 按框架的选择执行时间（单位：毫秒）
- en: It’s no surprise that the delete operation behaves similarly, with Hibernate
    and JPA being close to each other, and Spring Data’s execution time increasing
    faster as the number of records increases (see table 2.5 and figure 2.9).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作的行为也类似，Hibernate和JPA非常接近，而随着记录数量的增加，Spring Data的执行时间增长速度更快（见表2.5和图2.9）。
- en: Table 2.5 Delete execution times by framework (times in ms)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.5 按框架的删除执行时间（单位：毫秒）
- en: '| Number of records | Hibernate | JPA | Spring Data JPA |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 记录数 | Hibernate | JPA | Spring Data JPA |'
- en: '| 1,000 | 584 | 551 | 2,430 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 1,000 | 584 | 551 | 2,430 |'
- en: '| 5,000 | 1,537 | 1,628 | 9,685 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 5,000 | 1,537 | 1,628 | 9,685 |'
- en: '| 10,000 | 2,992 | 2,763 | 17,930 |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 10,000 | 2,992 | 2,763 | 17,930 |'
- en: '| 20,000 | 5,344 | 5,129 | 32,906 |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 20,000 | 5,344 | 5,129 | 32,906 |'
- en: '| 30,000 | 7,478 | 7,852 | 47,400 |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 30,000 | 7,478 | 7,852 | 47,400 |'
- en: '| 40,000 | 10,061 | 10,493 | 62,422 |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 40,000 | 10,061 | 10,493 | 62,422 |'
- en: '| 50,000 | 12,857 | 12,768 | 79,799 |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 50,000 | 12,857 | 12,768 | 79,799 |'
- en: '![](../../OEBPS/Images/CH02_F09_Tudose2.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F09_Tudose2.png)'
- en: Figure 2.9 Delete execution times by framework (times in ms)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 按框架删除执行时间（时间单位：毫秒）
- en: The three approaches provide different performances. Hibernate and JPA go head
    to head—the graphics of their times almost overlap for all four operations (insert,
    update, select, and delete). Even though JPA comes with its own API on top of
    Hibernate, this additional layer introduces no overhead.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法提供不同的性能。Hibernate和JPA正面交锋——它们的时代图形在所有四个操作（插入、更新、选择和删除）上几乎重叠。尽管JPA在Hibernate之上有自己的API，但这额外的层引入了没有开销。
- en: The execution times of Spring Data JPA insertions start at about 2 times those
    of Hibernate and JPA for 1,000 records and go to about 3.5 times more for 50,000
    records. The overhead of the Spring Data JPA framework is considerable.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JPA插入的执行时间从大约是Hibernate和JPA的2倍开始，对于10,000条记录增加到大约3.5倍，对于50,000条记录。Spring
    Data JPA框架的额外开销相当可观。
- en: For Hibernate and JPA, the update and delete execution times are lower than
    the insert execution times. In contrast, the Spring Data JPA update and delete
    execution times are longer than the insert execution times.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Hibernate和JPA，更新和删除的执行时间低于插入的执行时间。相比之下，Spring Data JPA的更新和删除执行时间比插入执行时间长。
- en: For Hibernate and JPA, the select times grow very slowly with the number of
    rows. The Spring Data JPA select execution times strongly grow with the number
    of rows.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Hibernate和JPA，选择时间随着行数的增加而缓慢增长。Spring Data JPA的选择执行时间随着行数的增加而急剧增长。
- en: 'Using Spring Data JPA is mainly justified in particular situations: if the
    project already uses the Spring framework and needs to rely on its existing paradigm
    (such as inversion of control or automatically managed transactions), or if there
    is a strong need to decrease the amount of code and thus shorten the development
    time (nowadays it is cheaper to acquire more computing power than to acquire more
    developers).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Data JPA主要在特定情况下是合理的：如果项目已经使用Spring框架并且需要依赖其现有范式（例如控制反转或自动管理的事务），或者如果存在强烈的减少代码量的需求，从而缩短开发时间（如今获取更多计算能力比获取更多开发者更便宜）。
- en: This chapter has focused on alternatives for working with databases from a Java
    application—JPA, native Hibernate, and Spring Data JPA—and we looked at introductory
    examples for each of them. Chapter 3 will introduce a more complex example and
    will deal in more depth with domain models and metadata.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了从Java应用程序与数据库交互的替代方案——JPA、本地Hibernate和Spring Data JPA，并分别介绍了它们的入门示例。第3章将介绍一个更复杂的示例，并更深入地探讨领域模型和元数据。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'A Java persistence project can be implemented using three alternatives: JPA,
    native Hibernate, and Spring Data JPA.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Java持久化项目可以使用三种替代方案实现：JPA、本地Hibernate和Spring Data JPA。
- en: You can create, map, and annotate a persistent class.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以创建、映射和注解一个持久化类。
- en: Using JPA, you can implement the configuration and bootstrapping of a persistence
    unit, and you can create the `EntityManagerFactory` entry point.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JPA，你可以实现持久化单元的配置和启动，并且可以创建`EntityManagerFactory`入口点。
- en: You can call the `EntityManager` to interact with the database, storing and
    loading an instance of the persistent domain model class.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过调用`EntityManager`与数据库交互，存储和加载持久化领域模型类的实例。
- en: 'Native Hibernate provides bootstrapping and configuration options, as well
    as the equivalent basic Hibernate APIs: `SessionFactory` and `Session`.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地Hibernate提供了启动和配置选项，以及等效的基本Hibernate API：`SessionFactory`和`Session`。
- en: You can switch between the JPA approach and Hibernate approach by unwrapping
    a `SessionFactory` from an `EntityManagerFactory` or obtaining an `EntityManagerFactory`
    from a Hibernate configuration.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过从`EntityManagerFactory`解包`SessionFactory`或从Hibernate配置中获取`EntityManagerFactory`在JPA方法和Hibernate方法之间切换。
- en: You can implement the configuration of a Spring Data JPA application by creating
    the repository interface, and then use it to store and load an instance of the
    persistent domain model class.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过创建存储库接口来实现Spring Data JPA应用程序的配置，然后使用它来存储和加载持久化领域模型类的实例。
- en: Comparing and contrasting these three approaches (JPA, native Hibernate, and
    Spring Data JPA) demonstrates the advantages and shortcomings of each of them,
    in terms of portability, needed dependencies, amount of code, and execution speed.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较和对比这三种方法（JPA、本地Hibernate和Spring Data JPA）展示了它们在可移植性、所需依赖项、代码量和执行速度方面的优缺点。
