- en: 2  Python Language Basics, IPython, and Jupyter Notebooks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 Python语言基础，IPython和Jupyter笔记本
- en: 原文：[https://wesmckinney.com/book/python-basics](https://wesmckinney.com/book/python-basics)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://wesmckinney.com/book/python-basics](https://wesmckinney.com/book/python-basics)
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此《Python数据分析第三版》的开放访问网络版本现在作为[印刷版和数字版](https://amzn.to/3DyLaJc)的伴侣版本提供。如果您发现任何勘误，请[在此处报告](https://oreilly.com/catalog/0636920519829/errata)。请注意，由Quarto制作的此网站的某些方面与O’Reilly的印刷版和电子书版本的格式不同。
- en: If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *When
    I wrote the first edition of this book in 2011 and 2012, there were fewer resources
    available for learning about doing data analysis in Python. This was partially
    a chicken-and-egg problem; many libraries that we now take for granted, like pandas,
    scikit-learn, and statsmodels, were comparatively immature back then. Now in 2022,
    there is now a growing literature on data science, data analysis, and machine
    learning, supplementing the prior works on general-purpose scientific computing
    geared toward computational scientists, physicists, and professionals in other
    research fields. There are also excellent books about learning the Python programming
    language itself and becoming an effective software engineer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现本书的在线版本有用，请考虑[订购纸质版](https://amzn.to/3DyLaJc)或[无DRM的电子书](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)以支持作者。本网站的内容不得复制或复制。代码示例采用MIT许可证，可在GitHub或Gitee上找到。当我在2011年和2012年编写本书的第一版时，关于在Python中进行数据分析的学习资源较少。这在一定程度上是一个鸡生蛋的问题；许多我们现在认为理所当然的库，如pandas、scikit-learn和statsmodels，在那时相对不成熟。现在是2022年，现在有越来越多关于数据科学、数据分析和机器学习的文献，补充了关于面向计算科学家、物理学家和其他研究领域专业人士的通用科学计算的先前作品。还有关于学习Python编程语言本身并成为有效软件工程师的优秀书籍。
- en: 'As this book is intended as an introductory text in working with data in Python,
    I feel it is valuable to have a self-contained overview of some of the most important
    features of Python’s built-in data structures and libraries from the perspective
    of data manipulation. So, I will only present roughly enough information in this
    chapter and [Ch 3: Built-in Data Structures, Functions, and Files](/book/python-builtin)
    to enable you to follow along with the rest of the book.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书旨在作为在Python中处理数据的入门文本，我认为从数据操作的角度对Python的内置数据结构和库的一些最重要特性进行自包含概述是有价值的。因此，我将在本章和[第3章：内置数据结构、函数和文件](/book/python-builtin)中提供大致足够的信息，以便您能够跟随本书的其余部分。
- en: Much of this book focuses on table-based analytics and data preparation tools
    for working with datasets that are small enough to fit on your personal computer.
    To use these tools you must sometimes do some wrangling to arrange messy data
    into a more nicely tabular (or *structured*) form. Fortunately, Python is an ideal
    language for doing this. The greater your facility with the Python language and
    its built-in data types, the easier it will be for you to prepare new datasets
    for analysis.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的很大一部分关注于基于表格的分析和数据准备工具，用于处理足够小以适合个人计算机的数据集。要使用这些工具，有时您必须对混乱的数据进行一些整理，将其整理成更整洁的表格（或*结构化*）形式。幸运的是，Python是做这些事情的理想语言。您对Python语言及其内置数据类型的熟练程度越高，准备新数据集进行分析就会变得更容易。
- en: Some of the tools in this book are best explored from a live IPython or Jupyter
    session. Once you learn how to start up IPython and Jupyter, I recommend that
    you follow along with the examples so you can experiment and try different things.
    As with any keyboard-driven console-like environment, developing familiarity with
    the common commands is also part of the learning curve.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的一些工具最好在实时的IPython或Jupyter会话中进行探索。一旦您学会如何启动IPython和Jupyter，我建议您跟着示例进行实验和尝试不同的东西。与任何基于键盘的类似控制台的环境一样，熟悉常用命令也是学习曲线的一部分。
- en: '*Note* *There are introductory Python concepts that this chapter does not cover,
    like classes and object-oriented programming, which you may find useful in your
    foray into data analysis in Python.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章未涵盖一些入门级Python概念，如类和面向对象编程，这些概念在您进入Python数据分析领域时可能会有用。
- en: 'To deepen your Python language knowledge, I recommend that you supplement this
    chapter with the [official Python tutorial](http://docs.python.org) and potentially
    one of the many excellent books on general-purpose Python programming. Some recommendations
    to get you started include:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加深您对Python语言的了解，我建议您将本章与[官方Python教程](http://docs.python.org)以及可能是许多优秀的通用Python编程书籍结合起来阅读。一些建议让您开始包括：
- en: '*Python Cookbook*, Third Edition, by David Beazley and Brian K. Jones (O''Reilly)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Python Cookbook》，第三版，作者David Beazley和Brian K. Jones（O'Reilly）
- en: '*Fluent Python* by Luciano Ramalho (O''Reilly)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《流畅的Python》，作者Luciano Ramalho（O'Reilly）
- en: '*Effective Python*, Second Edition, by Brett Slatkin (Addison-Wesley)*  *##
    2.1 The Python Interpreter'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Effective Python》，第二版，作者Brett Slatkin（Addison-Wesley）## 2.1 Python解释器
- en: 'Python is an *interpreted* language. The Python interpreter runs a program
    by executing one statement at a time. The standard interactive Python interpreter
    can be invoked on the command line with the `python` command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种解释性语言。Python解释器通过逐条执行程序来运行程序。标准的交互式Python解释器可以通过命令行使用`python`命令调用：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `>>>` you see is the *prompt* after which you’ll type code expressions.
    To exit the Python interpreter, you can either type `exit()` or press Ctrl-D (works
    on Linux and macOS only).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到的`>>>`是您将输入代码表达式的*提示*。要退出Python解释器，您可以输入`exit()`或按Ctrl-D（仅适用于Linux和macOS）。
- en: 'Running Python programs is as simple as calling `python` with a *.py* file
    as its first argument. Suppose we had created *hello_world.py* with these contents:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Python程序就像调用`python`并将*.py*文件作为第一个参数一样简单。假设我们已经创建了包含以下内容的*hello_world.py*文件：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can run it by executing the following command (the *hello_world.py* file
    must be in your current working terminal directory):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行以下命令来运行它（*hello_world.py*文件必须在您当前的工作终端目录中）：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'While some Python programmers execute all of their Python code in this way,
    those doing data analysis or scientific computing make use of IPython, an enhanced
    Python interpreter, or Jupyter notebooks, web-based code notebooks originally
    created within the IPython project. I give an introduction to using IPython and
    Jupyter in this chapter and have included a deeper look at IPython functionality
    in [Appendix A: Advanced NumPy](/book/advanced-numpy). When you use the `%run`
    command, IPython executes the code in the specified file in the same process,
    enabling you to explore the results interactively when it’s done:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些Python程序员以这种方式执行他们的所有Python代码，但进行数据分析或科学计算的人使用IPython，这是一个增强的Python解释器，或者使用Jupyter笔记本，这是最初在IPython项目中创建的基于Web的代码笔记本。我在本章中介绍了如何使用IPython和Jupyter，并在[附录A：高级NumPy](/book/advanced-numpy)中深入探讨了IPython功能。当您使用`%run`命令时，IPython会在同一进程中执行指定文件中的代码，使您能够在完成时交互地探索结果：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The default IPython prompt adopts the numbered `In [2]:` style, compared with
    the standard `>>>` prompt.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的IPython提示采用带编号的`In [2]:`样式，与标准的`>>>`提示相比。
- en: 2.2 IPython Basics
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 IPython基础知识
- en: In this section, I'll get you up and running with the IPython shell and Jupyter
    notebook, and introduce you to some of the essential concepts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将带您快速了解IPython shell和Jupyter笔记本，并介绍一些基本概念。
- en: Running the IPython Shell
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行IPython Shell
- en: 'You can launch the IPython shell on the command line just like launching the
    regular Python interpreter except with the `ipython` command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像启动常规Python解释器一样在命令行上启动IPython shell，只是使用`ipython`命令：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can execute arbitrary Python statements by typing them and pressing Return
    (or Enter). When you type just a variable into IPython, it renders a string representation
    of the object:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过键入Python语句并按回车键（或Enter键）来执行任意Python语句。当您只输入一个变量时，IPython会呈现对象的字符串表示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first two lines are Python code statements; the second statement creates
    a variable named `data` that refers to a newly created list. The last line prints
    the value of `data` in the console.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行是Python代码语句；第二个语句创建了一个名为`data`的变量，指向一个新创建的列表。最后一行在控制台中打印了`data`的值。
- en: 'Many kinds of Python objects are formatted to be more readable, or *pretty-printed*,
    which is distinct from normal printing with `print`. If you printed the above
    `data` variable in the standard Python interpreter, it would be much less readable:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 许多种类的Python对象都被格式化为更易读或*漂亮打印*，这与使用`print`进行正常打印不同。如果您在标准Python解释器中打印上述`data`变量，它将不太易读：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: IPython also provides facilities to execute arbitrary blocks of code (via a
    somewhat glorified copy-and-paste approach) and whole Python scripts. You can
    also use the Jupyter notebook to work with larger blocks of code, as we will soon
    see.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: IPython还提供了执行任意代码块（通过一种略微夸张的复制粘贴方法）和整个Python脚本的功能。您还可以使用Jupyter笔记本来处理更大的代码块，我们很快就会看到。
- en: Running the Jupyter Notebook
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在终端中运行Jupyter Notebook
- en: One of the major components of the Jupyter project is the *notebook*, a type
    of interactive document for code, text (including Markdown), data visualizations,
    and other output. The Jupyter notebook interacts with *kernels*, which are implementations
    of the Jupyter interactive computing protocol specific to different programming
    languages. The Python Jupyter kernel uses the IPython system for its underlying
    behavior.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter项目的一个主要组件是*笔记本*，一种用于代码、文本（包括Markdown）、数据可视化和其他输出的交互式文档。Jupyter笔记本与*内核*交互，这些内核是针对不同编程语言的Jupyter交互式计算协议的实现。Python
    Jupyter内核使用IPython系统作为其基础行为。
- en: 'To start up Jupyter, run the command `jupyter` `notebook` in a terminal:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动Jupyter，请在终端中运行命令`jupyter` `notebook`：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On many platforms, Jupyter will automatically open in your default web browser
    (unless you start it with `--no-browser`). Otherwise, you can navigate to the
    HTTP address printed when you started the notebook, here `http://localhost:8888/?token=0a77b52fefe52ab83e3c35dff8de121e4bb443a63f2d3055`.
    See [Figure 2.1](#fig-figure_jupyter_landing) for what this looks like in Google
    Chrome.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多平台上，Jupyter会自动在默认的Web浏览器中打开（除非您使用`--no-browser`启动）。否则，您可以导航到启动笔记本时打印的HTTP地址，例如`http://localhost:8888/?token=0a77b52fefe52ab83e3c35dff8de121e4bb443a63f2d3055`。在Google
    Chrome中查看[图2.1](#fig-figure_jupyter_landing)。
- en: '*Note* *Many people use Jupyter as a local computing environment, but it can
    also be deployed on servers and accessed remotely. I won''t cover those details
    here, but I encourage you to explore this topic on the internet if it''s relevant
    to your needs.*  *![](../Images/1cd631e8481f11b53a8555983ea31c1e.png)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *许多人将Jupyter用作本地计算环境，但它也可以部署在服务器上并远程访问。我不会在这里涵盖这些细节，但如果这与您的需求相关，我鼓励您在互联网上探索这个主题。*  *![](../Images/1cd631e8481f11b53a8555983ea31c1e.png)'
- en: 'Figure 2.1: Jupyter notebook landing page'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：Jupyter笔记本首页
- en: To create a new notebook, click the New button and select the "Python 3" option.
    You should see something like [Figure 2.2](#fig-figure_jupyter_new_nb). If this
    is your first time, try clicking on the empty code "cell" and entering a line
    of Python code. Then press Shift-Enter to execute it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新笔记本，点击“New”按钮并选择“Python 3”选项。您应该看到类似于[图2.2](#fig-figure_jupyter_new_nb)的内容。如果这是您第一次尝试，请尝试点击空的代码“单元格”并输入一行Python代码。然后按Shift-Enter执行它。
- en: '![](../Images/7f99b0a8aa2805183d2316e51eba5f22.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7f99b0a8aa2805183d2316e51eba5f22.png)'
- en: 'Figure 2.2: Jupyter new notebook view'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：Jupyter新笔记本视图
- en: When you save the notebook (see "Save and Checkpoint" under the notebook File
    menu), it creates a file with the extension *.ipynb*. This is a self-contained
    file format that contains all of the content (including any evaluated code output)
    currently in the notebook. These can be loaded and edited by other Jupyter users.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当您保存笔记本（请参见笔记本文件菜单下的“保存和检查点”）时，它将创建一个扩展名为*.ipynb*的文件。这是一种自包含的文件格式，包含当前笔记本中的所有内容（包括任何已评估的代码输出）。其他Jupyter用户可以加载和编辑这些文件。
- en: To rename an open notebook, click on the notebook title at the top of the page
    and type the new title, pressing Enter when you are finished.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要重命名打开的笔记本，请单击页面顶部的笔记本标题，然后键入新标题，完成后按Enter。
- en: To load an existing notebook, put the file in the same directory where you started
    the notebook process (or in a subfolder within it), then click the name from the
    landing page. You can try it out with the notebooks from my *wesm/pydata-book*
    repository on GitHub. See [Figure 2.3](#fig-figure_jupyter_existing_nb).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载现有笔记本，请将文件放在启动笔记本进程的同一目录中（或其中的子文件夹），然后从登录页面点击名称。您可以尝试使用GitHub上我的*wesm/pydata-book*存储库中的笔记本。请参见[图2.3](#fig-figure_jupyter_existing_nb)。
- en: When you want to close a notebook, click the File menu and select "Close and
    Halt." If you simply close the browser tab, the Python process associated with
    the notebook will keep running in the background.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要关闭笔记本时，请单击文件菜单，然后选择“关闭并停止”。如果您只是关闭浏览器选项卡，则与笔记本相关联的Python进程将继续在后台运行。
- en: While the Jupyter notebook may feel like a distinct experience from the IPython
    shell, nearly all of the commands and tools in this chapter can be used in either
    environment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Jupyter笔记本可能感觉与IPython shell有所不同，但本章中的几乎所有命令和工具都可以在任何环境中使用。
- en: '![](../Images/85dffdfb28f327f6e100f02d45b76f91.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/85dffdfb28f327f6e100f02d45b76f91.png)'
- en: 'Figure 2.3: Jupyter example view for an existing notebook*  *### Tab Completion'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：现有笔记本的Jupyter示例视图* *### Tab Completion
- en: 'On the surface, the IPython shell looks like a cosmetically different version
    of the standard terminal Python interpreter (invoked with `python`). One of the
    major improvements over the standard Python shell is *tab completion*, found in
    many IDEs or other interactive computing analysis environments. While entering
    expressions in the shell, pressing the Tab key will search the namespace for any
    variables (objects, functions, etc.) matching the characters you have typed so
    far and show the results in a convenient drop-down menu:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，IPython shell看起来像标准终端Python解释器的外观不同版本（使用`python`调用）。与标准Python shell相比，IPython
    shell的一个主要改进是*制表完成*，在许多IDE或其他交互式计算分析环境中都可以找到。在shell中输入表达式时，按Tab键将搜索命名空间以查找与您迄今为止键入的字符匹配的任何变量（对象、函数等），并在方便的下拉菜单中显示结果：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, note that IPython displayed both of the two variables I defined,
    as well as the built-in function `any`. Also, you can also complete methods and
    attributes on any object after typing a period:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，请注意IPython显示了我定义的两个变量以及内置函数`any`。此外，在键入句点后，您还可以完成任何对象的方法和属性：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The same is true for modules:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 模块也是如此：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Note* *Note that IPython by default hides methods and attributes starting
    with underscores, such as magic methods and internal “private” methods and attributes,
    in order to avoid cluttering the display (and confusing novice users!). These,
    too, can be tab-completed, but you must first type an underscore to see them.
    If you prefer to always see such methods in tab completion, you can change this
    setting in the IPython configuration. See the [IPython documentation](https://ipython.readthedocs.io)
    to find out how to do this.*  *Tab completion works in many contexts outside of
    searching the interactive namespace and completing object or module attributes.
    When typing anything that looks like a file path (even in a Python string), pressing
    the Tab key will complete anything on your computer’s filesystem matching what
    you’ve typed.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *请注意，默认情况下，IPython隐藏以下划线开头的方法和属性，例如魔术方法和内部“私有”方法和属性，以避免显示混乱（并使初学者感到困惑！）。这些也可以通过制表完成，但您必须首先键入下划线才能看到它们。如果您希望始终在制表完成中看到此类方法，请更改IPython配置中的此设置。请参阅[IPython文档](https://ipython.readthedocs.io)以了解如何执行此操作。*  *制表完成在许多上下文中起作用，不仅限于搜索交互式命名空间并完成对象或模块属性。在键入任何看起来像文件路径的内容（即使在Python字符串中），按Tab键将完成与您键入的内容匹配的计算机文件系统上的任何内容。'
- en: 'Combined with the `%run` command (see [Appendix B.2.1: The %run Command](/book/ipython#ipython_basics_magic_run)),
    this functionality can save you many keystrokes.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 结合`%run`命令（请参见[附录B.2.1：`%run`命令](/book/ipython#ipython_basics_magic_run)），此功能可以为您节省许多按键。
- en: Another area where tab completion saves time is in the completion of function
    keyword arguments (including the `=` sign!). See [Figure 2.4](#fig-figure_jupyter_autocomplete_keywords).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 制表完成还可以节省函数关键字参数（包括`=`符号！）的完成时间。请参见[图2.4](#fig-figure_jupyter_autocomplete_keywords)。
- en: '![](../Images/9ddeddd0816344270288957f3493eb63.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9ddeddd0816344270288957f3493eb63.png)'
- en: 'Figure 2.4: Autocomplete function keywords in a Jupyter notebook'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：在Jupyter笔记本中自动完成函数关键字
- en: We'll have a closer look at functions in a little bit.*  *### Introspection
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将更仔细地查看函数。*  *### 内省
- en: 'Using a question mark (`?`) before or after a variable will display some general
    information about the object:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量前或后使用问号（`?`）将显示有关对象的一些常规信息：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is referred to as *object introspection*. If the object is a function
    or instance method, the docstring, if defined, will also be shown. Suppose we’d
    written the following function (which you can reproduce in IPython or Jupyter):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*对象内省*。如果对象是函数或实例方法，则如果定义了文档字符串，它也将显示出来。假设我们编写了以下函数（您可以在IPython或Jupyter中重现）：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then using `?` shows us the docstring:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`?`显示文档字符串：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`?` has a final usage, which is for searching the IPython namespace in a manner
    similar to the standard Unix or Windows command line. A number of characters combined
    with the wildcard (`*`) will show all names matching the wildcard expression.
    For example, we could get a list of all functions in the top-level NumPy namespace
    containing `load`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`?`还有一个最终的用途，就是在IPython命名空间中进行搜索，类似于标准的Unix或Windows命令行。与通配符(`*`)结合的一系列字符将显示所有与通配符表达式匹配的名称。例如，我们可以获取包含`load`的顶级NumPy命名空间中的所有函数列表：'
- en: '[PRE14]**  **## 2.3 Python Language Basics'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]**  **## 2.3 Python语言基础'
- en: In this section, I will give you an overview of essential Python programming
    concepts and language mechanics. In the next chapter, I will go into more detail
    about Python data structures, functions, and other built-in tools.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将为您概述基本的Python编程概念和语言机制。在下一章中，我将更详细地介绍Python数据结构、函数和其他内置工具。
- en: Language Semantics
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语言语义
- en: The Python language design is distinguished by its emphasis on readability,
    simplicity, and explicitness. Some people go so far as to liken it to “executable
    pseudocode.”
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言设计的一个重要特点是其对可读性、简单性和明确性的强调。有些人甚至将其比作“可执行的伪代码”。
- en: Indentation, not braces
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缩进，而不是大括号
- en: 'Python uses whitespace (tabs or spaces) to structure code instead of using
    braces as in many other languages like R, C++, Java, and Perl. Consider a `for`
    loop from a sorting algorithm:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用空格（制表符或空格）来结构化代码，而不是像R、C++、Java和Perl等许多其他语言那样使用大括号。考虑一个排序算法中的`for`循环：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A colon denotes the start of an indented code block after which all of the code
    must be indented by the same amount until the end of the block.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示缩进代码块的开始，之后所有代码都必须缩进相同的量，直到块的结束。
- en: Love it or hate it, significant whitespace is a fact of life for Python programmers.
    While it may seem foreign at first, you will hopefully grow accustomed to it in
    time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你喜欢还是讨厌，对于Python程序员来说，有意义的空白是一个事实。虽然一开始可能会感到陌生，但希望你能逐渐习惯它。
- en: '*Note* *I strongly recommend using *four spaces* as your default indentation
    and replacing tabs with four spaces. Many text editors have a setting that will
    replace tab stops with spaces automatically (do this!). IPython and Jupyter notebooks
    will automatically insert four spaces on new lines following a colon and replace
    tabs by four spaces.*  *As you can see by now, Python statements also do not need
    to be terminated by semicolons. Semicolons can be used, however, to separate multiple
    statements on a single line:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *我强烈建议使用*四个空格*作为默认缩进，并用四个空格替换制表符。许多文本编辑器都有一个设置，可以自动将制表符替换为空格（请这样做！）。IPython和Jupyter笔记本会在冒号后的新行自动插入四个空格，并用四个空格替换制表符。*  *正如你现在所看到的，Python语句也不需要以分号结尾。但是，分号可以用来在单行上分隔多个语句：'
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Putting multiple statements on one line is generally discouraged in Python as
    it can make code less readable.*  *#### Everything is an object
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在一行上放置多个语句通常在Python中是不鼓励的，因为这可能会使代码变得不太可读。*  *#### 一切都是对象
- en: An important characteristic of the Python language is the consistency of its
    *object model*. Every number, string, data structure, function, class, module,
    and so on exists in the Python interpreter in its own “box,” which is referred
    to as a *Python object*. Each object has an associated *type* (e.g., *integer*,
    *string*, or *function*) and internal data. In practice this makes the language
    very flexible, as even functions can be treated like any other object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言的一个重要特点是其*对象模型*的一致性。每个数字、字符串、数据结构、函数、类、模块等都存在于Python解释器中的自己的“盒子”中，这被称为*Python对象*。每个对象都有一个关联的*类型*（例如*整数*、*字符串*或*函数*）和内部数据。实际上，这使得语言非常灵活，因为即使函数也可以像任何其他对象一样对待。
- en: Comments
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注释
- en: 'Any text preceded by the hash mark (pound sign) `#` is ignored by the Python
    interpreter. This is often used to add comments to code. At times you may also
    want to exclude certain blocks of code without deleting them. One solution is
    to *comment out* the code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由井号（井号）`#`引导的任何文本都会被Python解释器忽略。这通常用于向代码添加注释。有时您可能还想排除某些代码块而不删除它们。一种解决方案是*注释掉*代码：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Comments can also occur after a line of executed code. While some programmers
    prefer comments to be placed in the line preceding a particular line of code,
    this can be useful at times:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注释也可以出现在执行代码的行之后。虽然一些程序员更喜欢将注释放在特定代码行之前的行中，但有时这样做也是有用的：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Function and object method calls
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数和对象方法调用
- en: 'You call functions using parentheses and passing zero or more arguments, optionally
    assigning the returned value to a variable:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用括号调用函数并传递零个或多个参数，可选地将返回的值赋给一个变量：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Almost every object in Python has attached functions, known as *methods*, that
    have access to the object’s internal contents. You can call them using the following
    syntax:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Python中几乎每个对象都有附加的函数，称为*方法*，这些函数可以访问对象的内部内容。您可以使用以下语法调用它们：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Functions can take both *positional* and *keyword* arguments:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受*位置*和*关键字*参数：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will look at this in more detail later.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会更详细地看一下这个。
- en: Variables and argument passing
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量和参数传递
- en: 'When assigning a variable (or *name*) in Python, you are creating a *reference*
    to the object shown on the righthand side of the equals sign. In practical terms,
    consider a list of integers:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中赋值变量（或*名称*）时，您正在创建对等号右侧显示的对象的*引用*。在实际操作中，考虑一个整数列表：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Suppose we assign `a` to a new variable `b`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将`a`赋给一个新变量`b`：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In some languages, the assignment if `b` will cause the data `[1, 2, 3]` to
    be copied. In Python, `a` and `b` actually now refer to the same object, the original
    list `[1, 2, 3]` (see [Figure 2.5](#fig-figure_references) for a mock-up). You
    can prove this to yourself by appending an element to `a` and then examining `b`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些语言中，对`b`的赋值将导致数据`[1, 2, 3]`被复制。在Python中，`a`和`b`实际上现在指向同一个对象，即原始列表`[1, 2,
    3]`（请参见[图2.5](#fig-figure_references)的模拟）。您可以通过向`a`附加一个元素，然后检查`b`来证明这一点：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](../Images/844beecf4a6f3e1c98bd50a928a5d379.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/844beecf4a6f3e1c98bd50a928a5d379.png)'
- en: 'Figure 2.5: Two references for the same object'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：同一对象的两个引用
- en: Understanding the semantics of references in Python, and when, how, and why
    data is copied, is especially critical when you are working with larger datasets
    in Python.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Python中引用的语义以及何时、如何以及为什么数据被复制，在处理Python中的大型数据集时尤为重要。
- en: '*Note* *Assignment is also referred to as *binding*, as we are binding a name
    to an object. Variable names that have been assigned may occasionally be referred
    to as bound variables.*  *When you pass objects as arguments to a function, new
    local variables are created referencing the original objects without any copying.
    If you bind a new object to a variable inside a function, that will not overwrite
    a variable of the same name in the "scope" outside of the function (the "parent
    scope"). It is therefore possible to alter the internals of a mutable argument.
    Suppose we had the following function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *赋值也被称为*绑定*，因为我们正在将一个名称绑定到一个对象。已经分配的变量名称有时可能被称为绑定变量。* *当您将对象作为参数传递给函数时，将创建新的本地变量引用原始对象，而不进行任何复制。如果在函数内部将一个新对象绑定到一个变量，那么它不会覆盖函数外部（“父范围”）具有相同名称的变量。因此，可以更改可变参数的内部。假设我们有以下函数：'
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then we have:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有：
- en: '[PRE26]*  *#### Dynamic references, strong types'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE26]*  *#### 动态引用，强类型'
- en: 'Variables in Python have no inherent type associated with them; a variable
    can refer to a different type of object simply by doing an assignment. There is
    no problem with the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的变量没有与之关联的固有类型；通过赋值，变量可以引用不同类型的对象。以下情况没有问题：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Variables are names for objects within a particular namespace; the type information
    is stored in the object itself. Some observers might hastily conclude that Python
    is not a “typed language.” This is not true; consider this example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是特定命名空间内对象的名称；类型信息存储在对象本身中。一些观察者可能匆忙得出结论，认为Python不是一种“类型化语言”。这是不正确的；考虑这个例子：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In some languages, the string `''5''` might get implicitly converted (or *cast*)
    to an integer, thus yielding 10\. In other languages the integer `5` might be
    cast to a string, yielding the concatenated string `''55''`. In Python, such implicit
    casts are not allowed. In this regard we say that Python is a *strongly typed*
    language, which means that every object has a specific type (or *class*), and
    implicit conversions will occur only in certain permitted circumstances, such
    as:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，字符串`'5'`可能会被隐式转换（或*转换*）为整数，从而得到10。在其他语言中，整数`5`可能会被转换为字符串，从而得到连接的字符串`'55'`。在Python中，不允许这种隐式转换。在这方面，我们说Python是一种*强类型*语言，这意味着每个对象都有一个特定的类型（或*类*），隐式转换只会在某些允许的情况下发生，例如：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, even though `b` is an integer, it is implicitly converted to a float for
    the division operation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，即使`b`是一个整数，它也会被隐式转换为浮点数进行除法运算。
- en: 'Knowing the type of an object is important, and it’s useful to be able to write
    functions that can handle many different kinds of input. You can check that an
    object is an instance of a particular type using the `isinstance` function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 了解对象的类型很重要，能够编写能够处理许多不同类型输入的函数也很有用。您可以使用`isinstance`函数检查对象是否是特定类型的实例：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`isinstance` can accept a tuple of types if you want to check that an object’s
    type is among those present in the tuple:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要检查对象的类型是否在元组中存在，`isinstance`可以接受一个类型元组：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Attributes and methods
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性和方法
- en: 'Objects in Python typically have both attributes (other Python objects stored
    “inside” the object) and methods (functions associated with an object that can
    have access to the object’s internal data). Both of them are accessed via the
    syntax <obj.attribute_name>:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的对象通常具有属性（存储在对象“内部”的其他Python对象）和方法（与对象关联的函数，可以访问对象的内部数据）。它们都可以通过语法<obj.attribute_name>访问：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Attributes and methods can also be accessed by name via the `getattr` function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 属性和方法也可以通过`getattr`函数按名称访问：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: While we will not extensively use the functions `getattr` and related functions
    `hasattr` and `setattr` in this book, they can be used very effectively to write
    generic, reusable code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在本书中不会广泛使用`getattr`函数和相关函数`hasattr`和`setattr`，但它们可以非常有效地用于编写通用的可重用代码。
- en: Duck typing
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: 'Often you may not care about the type of an object but rather only whether
    it has certain methods or behavior. This is sometimes called *duck typing*, after
    the saying "If it walks like a duck and quacks like a duck, then it''s a duck."
    For example, you can verify that an object is iterable if it implements the *iterator
    protocol*. For many objects, this means it has an `__iter__` “magic method,” though
    an alternative and better way to check is to try using the `iter` function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可能不关心对象的类型，而只关心它是否具有某些方法或行为。这有时被称为*鸭子类型*，源自谚语“如果它走起来像鸭子，叫起来像鸭子，那么它就是鸭子。”例如，如果对象实现了*迭代器协议*，则可以验证该对象是否可迭代。对于许多对象，这意味着它具有一个`__iter__`“魔术方法”，尽管检查的另一种更好的方法是尝试使用`iter`函数：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This function would return `True` for strings as well as most Python collection
    types:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串以及大多数Python集合类型，此函数将返回`True`：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Imports
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导入
- en: 'In Python, a *module* is simply a file with the *.py* extension containing
    Python code. Suppose we had the following module:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，*模块*只是一个包含Python代码的扩展名为*.py*的文件。假设我们有以下模块：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we wanted to access the variables and functions defined in *some_module.py*,
    from another file in the same directory we could do:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从同一目录中的另一个文件中访问*some_module.py*中定义的变量和函数，我们可以这样做：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Or alternately:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'By using the `as` keyword, you can give imports different variable names:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`as`关键字，您可以为导入指定不同的变量名称：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Binary operators and comparisons
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 二进制运算符和比较
- en: 'Most of the binary math operations and comparisons use familiar mathematical
    syntax used in other programming languages:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数二进制数学运算和比较使用其他编程语言中常用的数学语法：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: See [Table 2.1](#tbl-table_binary_ops) for all of the available binary operators.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[表2.1](#tbl-table_binary_ops)以获取所有可用的二进制运算符。
- en: 'Table 2.1: Binary operators'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1：二进制运算符
- en: '| Operation | Description |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 描述 |'
- en: '| --- | --- |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `a + b` | Add `a` and `b` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `a + b` | 将`a`和`b`相加 |'
- en: '| `a - b` | Subtract `b` from `a` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `a - b` | 从`a`中减去`b` |'
- en: '| `a * b` | Multiply `a` by `b` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `a * b` | 将`a`乘以`b` |'
- en: '| `a / b` | Divide `a` by `b` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `a / b` | 将`a`除以`b` |'
- en: '| `a // b` | Floor-divide `a` by `b`, dropping any fractional remainder |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `a // b` | 通过`b`进行地板除法，去除任何小数余数 |'
- en: '| `a ** b` | Raise `a` to the `b` power |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `a ** b` | 将`a`提升到`b`次方 |'
- en: '| `a & b` | `True` if both `a` and `b` are `True`; for integers, take the bitwise
    `AND` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `a & b` | 如果`a`和`b`都为`True`，则为`True`；对于整数，取位`AND` |'
- en: '| `a &#124; b` | `True` if either `a` or `b` is `True`; for integers, take
    the bitwise `OR` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `a | b` | 如果`a`或`b`中的任何一个为`True`，则为`True`；对于整数，取位`OR` |'
- en: '| `a ^ b` | For Booleans, `True` if `a` or `b` is `True`, but not both; for
    integers, take the bitwise `EXCLUSIVE-OR` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `a ^ b` | 对于布尔值，如果`a`或`b`为`True`，但不是两者都为`True`；对于整数，取位`异或` |'
- en: '| `a == b` | `True` if `a` equals `b` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `a == b` | 如果`a`等于`b`，则为`True` |'
- en: '| `a != b` | `True` if `a` is not equal to `b` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `a != b` | 如果`a`不等于`b`，则为`True` |'
- en: '| `a < b`, a <= b | `True` if `a` is less than (less than or equal to) `b`
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `a < b`，a <= b | 如果`a`小于（小于或等于）`b`，则为`True` |'
- en: '| `a > b, a >= b` | `True` if `a` is greater than (greater than or equal to)
    `b` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `a > b, a >= b` | 如果`a`大于（大于或等于）`b`，则为`True` |'
- en: '| `a is b` | `True` if `a` and `b` reference the same Python object |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `a is b` | 如果`a`和`b`引用相同的Python对象，则为`True` |'
- en: '| `a is not b` | `True` if `a` and `b` reference different Python objects |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `a is not b` | 如果`a`和`b`引用不同的Python对象，则为`True` |'
- en: 'To check if two variables refer to the same object, use the `is` keyword. Use
    `is` `not` to check that two objects are not the same:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查两个变量是否引用同一对象，请使用`is`关键字。使用`is not`来检查两个对象是否不相同：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since the `list` function always creates a new Python list (i.e., a copy),
    we can be sure that `c` is distinct from `a`. Comparing with `is` is not the same
    as the `==` operator, because in this case we have:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`list`函数始终创建一个新的Python列表（即一个副本），我们可以确保`c`与`a`不同。与`==`运算符不同，使用`is`不同，因为在这种情况下我们有：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A common use of `is` and `is` `not` is to check if a variable is `None`, since
    there is only one instance of `None`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`和`is not`的常见用法是检查变量是否为`None`，因为`None`只有一个实例：'
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Mutable and immutable objects
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可变和不可变对象
- en: 'Many objects in Python, such as lists, dictionaries, NumPy arrays, and most
    user-defined types (classes), are *mutable*. This means that the object or values
    that they contain can be modified:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的许多对象，如列表、字典、NumPy数组和大多数用户定义的类型（类），都是*可变*的。这意味着它们包含的对象或值可以被修改：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Others, like strings and tuples, are immutable, which means their internal
    data cannot be changed:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 其他，如字符串和元组，是不可变的，这意味着它们的内部数据不能被更改：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Remember that just because you *can* mutate an object does not mean that you
    always *should*. Such actions are known as *side effects*. For example, when writing
    a function, any side effects should be explicitly communicated to the user in
    the function’s documentation or comments. If possible, I recommend trying to avoid
    side effects and *favor immutability*, even though there may be mutable objects
    involved.**  **### Scalar Types
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，仅因为您*可以*改变对象并不意味着您总是*应该*这样做。这些操作被称为*副作用*。例如，在编写函数时，任何副作用都应明确地在函数的文档或注释中向用户传达。如果可能的话，我建议尽量避免副作用并*偏爱不可变性*，即使可能涉及可变对象。**
    **### 标量类型
- en: Python has a small set of built-in types for handling numerical data, strings,
    Boolean (`True` or `False`) values, and dates and time. These "single value" types
    are sometimes called *scalar types*, and we refer to them in this book as *scalars*
    . See [Table 2.2](#tbl-table_python_scalar_types) for a list of the main scalar
    types. Date and time handling will be discussed separately, as these are provided
    by the `datetime` module in the standard library.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Python具有一小组内置类型，用于处理数字数据、字符串、布尔（`True`或`False`）值以及日期和时间。这些“单值”类型有时被称为*标量类型*，我们在本书中将它们称为*标量*。请参阅[表2.2](#tbl-table_python_scalar_types)以获取主要标量类型的列表。日期和时间处理将单独讨论，因为这些由标准库中的`datetime`模块提供。
- en: 'Table 2.2: Standard Python scalar types'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2：标准Python标量类型
- en: '| Type | Description |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `None` | The Python “null” value (only one instance of the `None` object
    exists) |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `None` | Python的“null”值（只存在一个`None`对象的实例） |'
- en: '| `str` | String type; holds Unicode strings |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `str` | 字符串类型；保存Unicode字符串 |'
- en: '| `bytes` | Raw binary data |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `bytes` | 原始二进制数据 |'
- en: '| `float` | Double-precision floating-point number (note there is no separate
    `double` type) |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 双精度浮点数（请注意没有单独的`double`类型） |'
- en: '| `bool` | A Boolean `True` or `False` value |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | 布尔值`True`或`False` |'
- en: '| `int` | Arbitrary precision integer |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 任意精度整数 |'
- en: Numeric types
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数字类型
- en: 'The primary Python types for numbers are `int` and `float`. An `int` can store
    arbitrarily large numbers:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 数字的主要Python类型是`int`和`float`。`int`可以存储任意大的数字：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Floating-point numbers are represented with the Python `float` type. Under
    the hood, each one is a double-precision value. They can also be expressed with
    scientific notation:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数用Python的`float`类型表示。在底层，每个都是双精度值。它们也可以用科学计数法表示：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Integer division not resulting in a whole number will always yield a floating-point
    number:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 整数除法如果结果不是整数，将始终产生一个浮点数：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To get C-style integer division (which drops the fractional part if the result
    is not a whole number), use the floor division operator `//`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得C风格的整数除法（如果结果不是整数，则丢弃小数部分），请使用地板除法运算符`//`：
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Strings
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Many people use Python for its built-in string handling capabilities. You can
    write *string literals* using either single quotes `''` or double quotes `"` (double
    quotes are generally favored):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '许多人使用Python是因为其内置的字符串处理功能。您可以使用单引号`''`或双引号`"`（通常更喜欢双引号）编写*字符串字面值*： '
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The Python string type is `str`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Python字符串类型是`str`。
- en: 'For multiline strings with line breaks, you can use triple quotes, either `''''''`
    or `"""`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于带有换行符的多行字符串，可以使用三引号，即`'''`或`"""`：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It may surprise you that this string `c` actually contains four lines of text;
    the line breaks after `"""` and after `lines` are included in the string. We can
    count the new line characters with the `count` method on `c`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串`c`实际上包含四行文本可能会让您感到惊讶；在`"""`之后和`lines`之后的换行符包含在字符串中。我们可以使用`c`上的`count`方法来计算换行符的数量：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Python strings are immutable; you cannot modify a string:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Python字符串是不可变的；您不能修改一个字符串：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To interpret this error message, read from the bottom up. We tried to replace
    the character (the "item") at position 10 with the letter `"f"`, but this is not
    allowed for string objects. If we need to modify a string, we have to use a function
    or method that creates a new string, such as the string `replace` method:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要解释此错误消息，请从下往上阅读。我们尝试用字母`"f"`替换位置10处的字符（“项”），但对于字符串对象来说，这是不允许的。如果我们需要修改一个字符串，我们必须使用一个创建新字符串的函数或方法，比如字符串`replace`方法：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Afer this operation, the variable `a` is unmodified:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作后，变量`a`保持不变：
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Many Python objects can be converted to a string using the `str` function:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Python对象可以使用`str`函数转换为字符串：
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Strings are a sequence of Unicode characters and therefore can be treated like
    other sequences, such as lists and tuples:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是Unicode字符序列，因此可以像其他序列（如列表和元组）一样对待：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The syntax `s[:3]` is called *slicing* and is implemented for many kinds of
    Python sequences. This will be explained in more detail later on, as it is used
    extensively in this book.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`s[:3]`语法称为*切片*，对于许多种类的Python序列都有实现。稍后将更详细地解释这一点，因为它在本书中被广泛使用。'
- en: 'The backslash character `\` is an *escape character*, meaning that it is used
    to specify special characters like newline `\n` or Unicode characters. To write
    a string literal with backslashes, you need to escape them:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠字符`\`是一个*转义字符*，意味着它用于指定特殊字符，如换行符`\n`或Unicode字符。要编写带有反斜杠的字符串字面值，您需要对其进行转义：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If you have a string with a lot of backslashes and no special characters, you
    might find this a bit annoying. Fortunately you can preface the leading quote
    of the string with `r`, which means that the characters should be interpreted
    as is:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个带有许多反斜杠且没有特殊字符的字符串，您可能会觉得有点烦人。幸运的是，您可以在字符串的前导引号前加上`r`，这意味着应该按原样解释字符：
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `r` stands for *raw*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`r`代表*原始*。'
- en: 'Adding two strings together concatenates them and produces a new string:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个字符串相加会将它们连接在一起并生成一个新字符串：
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'String templating or formatting is another important topic. The number of ways
    to do so has expanded with the advent of Python 3, and here I will briefly describe
    the mechanics of one of the main interfaces. String objects have a `format` method
    that can be used to substitute formatted arguments into the string, producing
    a new string:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串模板或格式化是另一个重要主题。随着Python 3的出现，进行此操作的方式数量已经扩展，这里我将简要描述其中一个主要接口的机制。字符串对象具有一个`format`方法，可用于将格式化参数替换为字符串中，生成一个新字符串：
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In this string:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字符串中：
- en: '`{0:.2f}` means to format the first argument as a floating-point number with
    two decimal places.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{0:.2f}`表示将第一个参数格式化为带有两位小数的浮点数。'
- en: '`{1:s}` means to format the second argument as a string.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{1:s}`表示将第二个参数格式化为字符串。'
- en: '`{2:d}` means to format the third argument as an exact integer.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{2:d}`表示将第三个参数格式化为精确整数。'
- en: 'To substitute arguments for these format parameters, we pass a sequence of
    arguments to the `format` method:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要为这些格式参数替换参数，我们将一系列参数传递给`format`方法：
- en: '[PRE62]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Python 3.6 introduced a new feature called *f-strings* (short for *formatted
    string literals*) which can make creating formatted strings even more convenient.
    To create an f-string, write the character `f` immediately preceding a string
    literal. Within the string, enclose Python expressions in curly braces to substitute
    the value of the expression into the formatted string:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.6引入了一个名为*f-strings*（即*格式化字符串字面值*）的新功能，可以使创建格式化字符串更加方便。要创建f-string，只需在字符串字面值之前立即写入字符`f`。在字符串中，用大括号括起Python表达式，以将表达式的值替换为格式化字符串中的值：
- en: '[PRE63]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Format specifiers can be added after each expression using the same syntax
    as with the string templates above:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 格式说明符可以在每个表达式后添加，使用与上面字符串模板相同的语法：
- en: '[PRE64]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: String formatting is a deep topic; there are multiple methods and numerous options
    and tweaks available to control how values are formatted in the resulting string.
    To learn more, consult the [official Python documentation](https://docs.python.org/3/library/string.html).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串格式化是一个深入的主题；有多种方法和大量选项和调整可用于控制结果字符串中的值的格式。要了解更多，请参阅[官方Python文档](https://docs.python.org/3/library/string.html)。
- en: Bytes and Unicode
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字节和Unicode
- en: 'In modern Python (i.e., Python 3.0 and up), Unicode has become the first-class
    string type to enable more consistent handling of ASCII and non-ASCII text. In
    older versions of Python, strings were all bytes without any explicit Unicode
    encoding. You could convert to Unicode assuming you knew the character encoding.
    Here is an example Unicode string with non-ASCII characters:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Python（即Python 3.0及更高版本）中，Unicode已成为一流的字符串类型，以实现更一致地处理ASCII和非ASCII文本。在旧版本的Python中，字符串都是字节，没有任何明确的Unicode编码。您可以假设您知道字符编码来转换为Unicode。这里是一个带有非ASCII字符的示例Unicode字符串：
- en: '[PRE65]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can convert this Unicode string to its UTF-8 bytes representation using
    the `encode` method:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`encode`方法将此Unicode字符串转换为其UTF-8字节表示：
- en: '[PRE66]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Assuming you know the Unicode encoding of a `bytes` object, you can go back
    using the `decode` method:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您知道`bytes`对象的Unicode编码，您可以使用`decode`方法返回：
- en: '[PRE67]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'While it is now preferable to use UTF-8 for any encoding, for historical reasons
    you may encounter data in any number of different encodings:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最好使用UTF-8进行任何编码，但出于历史原因，您可能会遇到各种不同编码的数据：
- en: '[PRE68]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It is most common to encounter `bytes` objects in the context of working with
    files, where implicitly decoding all data to Unicode strings may not be desired.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文件时，最常见的是遇到`bytes`对象，其中不希望将所有数据隐式解码为Unicode字符串。
- en: Booleans
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'The two Boolean values in Python are written as `True` and `False`. Comparisons
    and other conditional expressions evaluate to either `True` or `False`. Boolean
    values are combined with the `and` and `or` keywords:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的两个布尔值分别写为`True`和`False`。比较和其他条件表达式的结果要么为`True`，要么为`False`。布尔值可以使用`and`和`or`关键字组合：
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'When converted to numbers, `False` becomes `0` and `True` becomes `1`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当转换为数字时，`False`变为`0`，`True`变为`1`：
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The keyword `not` flips a Boolean value from `True` to `False` or vice versa:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`not`可以将布尔值从`True`翻转为`False`，反之亦然：
- en: '[PRE71]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Type casting
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'The `str`, `bool`, `int`, and `float` types are also functions that can be
    used to cast values to those types:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`str`、`bool`、`int`和`float`类型也是可以用来将值转换为这些类型的函数：'
- en: '[PRE72]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note that most nonzero values when cast to `bool` become `True`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，大多数非零值在转换为`bool`时会变为`True`。
- en: None
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: None
- en: '`None` is the Python null value type:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`是Python的空值类型：'
- en: '[PRE73]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`None` is also a common default value for function arguments:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`也是函数参数的常见默认值：'
- en: '[PRE74]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Dates and times
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 日期和时间
- en: 'The built-in Python `datetime` module provides `datetime`, `date`, and `time`
    types. The `datetime` type combines the information stored in `date` and `time`
    and is the most commonly used:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的Python `datetime`模块提供了`datetime`、`date`和`time`类型。`datetime`类型结合了`date`和`time`中存储的信息，是最常用的类型：
- en: '[PRE75]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Given a `datetime` instance, you can extract the equivalent `date` and `time`
    objects by calling methods on the `datetime` of the same name:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个`datetime`实例，您可以通过在具有相同名称的`datetime`上调用方法来提取等效的`date`和`time`对象：
- en: '[PRE76]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `strftime` method formats a `datetime` as a string:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`strftime`方法将`datetime`格式化为字符串：'
- en: '[PRE77]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Strings can be converted (parsed) into `datetime` objects with the `strptime`
    function:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以使用`strptime`函数转换（解析）为`datetime`对象：
- en: '[PRE78]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: See [Table 11.2](/book/time-series#tbl-table_datetime_formatting) for a full
    list of format specifications.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[表11.2](/book/time-series#tbl-table_datetime_formatting)以获取完整的格式规范列表。
- en: 'When you are aggregating or otherwise grouping time series data, it will occasionally
    be useful to replace time fields of a series of `datetime`s—for example, replacing
    the `minute` and `second` fields with zero:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当您聚合或以其他方式对时间序列数据进行分组时，偶尔会有必要替换一系列`datetime`的时间字段，例如，将`minute`和`second`字段替换为零：
- en: '[PRE79]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Since `datetime.datetime` is an immutable type, methods like these always produce
    new objects. So in the previous example, `dt` is not modified by `replace`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`datetime.datetime`是不可变类型，这些方法总是会产生新对象。因此，在前面的例子中，`dt`不会被`replace`修改：
- en: '[PRE80]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The difference of two `datetime` objects produces a `datetime.timedelta` type:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`datetime`对象的差产生一个`datetime.timedelta`类型：
- en: '[PRE81]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The output `timedelta(17, 7179)` indicates that the `timedelta` encodes an offset
    of 17 days and 7,179 seconds.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 输出`timedelta(17, 7179)`表示`timedelta`编码了17天和7179秒的偏移量。
- en: 'Adding a `timedelta` to a `datetime` produces a new shifted `datetime`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 将`timedelta`添加到`datetime`会产生一个新的偏移`datetime`：
- en: '[PRE82]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Control Flow
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制流
- en: Python has several built-in keywords for conditional logic, loops, and other
    standard *control flow* concepts found in other programming languages.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Python有几个内置关键字用于条件逻辑、循环和其他标准*控制流*概念，这些概念在其他编程语言中也可以找到。
- en: if, elif, and else
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: if、elif和else
- en: 'The `if` statement is one of the most well-known control flow statement types.
    It checks a condition that, if `True`, evaluates the code in the block that follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句是最为人熟知的控制流语句类型之一。它检查一个条件，如果为`True`，则评估后面的代码块：'
- en: '[PRE83]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'An `if` statement can be optionally followed by one or more `elif` blocks and
    a catchall `else` block if all of the conditions are `False`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句后面可以选择跟随一个或多个`elif`代码块和一个全捕获的`else`代码块，如果所有条件都为`False`：'
- en: '[PRE84]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If any of the conditions are `True`, no further `elif` or `else` blocks will
    be reached. With a compound condition using `and` or `or`, conditions are evaluated
    left to right and will short-circuit:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何条件为`True`，则不会继续执行任何`elif`或`else`代码块。使用`and`或`or`的复合条件，条件从左到右进行评估并会短路：
- en: '[PRE85]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In this example, the comparison `c > d` never gets evaluated because the first
    comparison was `True`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，比较`c > d`永远不会被评估，因为第一个比较是`True`。
- en: 'It is also possible to chain comparisons:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以链接比较：
- en: '[PRE86]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: for loops
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: for循环
- en: '`for` loops are for iterating over a collection (like a list or tuple) or an
    iterater. The standard syntax for a `for` loop is:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环用于遍历集合（如列表或元组）或迭代器。`for`循环的标准语法是：'
- en: '[PRE87]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You can advance a `for` loop to the next iteration, skipping the remainder
    of the block, using the `continue` keyword. Consider this code, which sums up
    integers in a list and skips `None` values:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`continue`关键字将`for`循环推进到下一个迭代，跳过代码块的其余部分。考虑这段代码，它对列表中的整数求和并跳过`None`值：
- en: '[PRE88]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'A `for` loop can be exited altogether with the `break` keyword. This code sums
    elements of the list until a 5 is reached:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`break`关键字完全退出`for`循环。这段代码将列表元素求和，直到达到5为止：
- en: '[PRE89]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The `break` keyword only terminates the innermost `for` loop; any outer `for`
    loops will continue to run:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`关键字仅终止最内层的`for`循环；任何外部的`for`循环将继续运行：'
- en: '[PRE90]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'As we will see in more detail, if the elements in the collection or iterator
    are sequences (tuples or lists, say), they can be conveniently *unpacked* into
    variables in the `for` loop statement:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在更详细地看到的，如果集合或迭代器中的元素是序列（例如元组或列表），它们可以方便地在`for`循环语句中*解包*为变量：
- en: '[PRE91]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: while loops
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: while循环
- en: 'A `while` loop specifies a condition and a block of code that is to be executed
    until the condition evaluates to `False` or the loop is explicitly ended with
    `break`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环指定一个条件和一个要执行的代码块，直到条件评估为`False`或循环被显式地使用`break`结束为止：'
- en: '[PRE92]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: pass
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pass
- en: '`pass` is the “no-op” (or "do nothing") statement in Python. It can be used
    in blocks where no action is to be taken (or as a placeholder for code not yet
    implemented); it is required only because Python uses whitespace to delimit blocks:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`pass`是Python中的“空操作”（或“什么也不做”）语句。它可以在不需要执行任何操作的代码块中使用（或作为尚未实现的代码的占位符）；它仅仅是因为Python使用空格来分隔代码块：'
- en: '[PRE93]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: range
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 范围
- en: 'The `range` function generates a sequence of evenly spaced integers:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`函数生成一系列均匀间隔的整数：'
- en: '[PRE94]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'A start, end, and step (which may be negative) can be given:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 可以给定起始点、终点和步长（可以是负数）：
- en: '[PRE95]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'As you can see, `range` produces integers up to but not including the endpoint.
    A common use of `range` is for iterating through sequences by index:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`range` 生成的整数是直到但不包括终点的。`range` 的一个常见用途是通过索引迭代序列：
- en: '[PRE96]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'While you can use functions like `list` to store all the integers generated
    by `range` in some other data structure, often the default iterator form will
    be what you want. This snippet sums all numbers from 0 to 99,999 that are multiples
    of 3 or 5:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以使用`list`等函数将`range`生成的所有整数存储在其他数据结构中，但通常默认的迭代器形式会是您想要的。这段代码将从0到99,999之间是3或5的倍数的所有数字相加：
- en: '[PRE97]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: While the range generated can be arbitrarily large, the memory use at any given
    time may be very small.**  **## 2.4 Conclusion
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然生成的范围可以任意大，但在任何给定时间内的内存使用可能非常小。**  **## 2.4 结论
- en: This chapter provided a brief introduction to some basic Python language concepts
    and the IPython and Jupyter programming environments. In the next chapter, I will
    discuss many built-in data types, functions, and input-output utilities that will
    be used continuously throughout the rest of the book.******
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了一些基本的Python语言概念以及IPython和Jupyter编程环境。在下一章中，我将讨论许多内置数据类型、函数和输入输出工具，这些内容将在本书的其余部分中持续使用。
