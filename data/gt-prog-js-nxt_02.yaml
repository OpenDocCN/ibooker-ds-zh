- en: Lesson 3\. Bundling modules with Browserify
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3课：使用Browserify打包模块
- en: Modules are a big part of the additions to JavaScript. As you’ll learn in this
    lesson, transpiling alone is not enough for modules. This is because the most
    defining aspect of modules is that they break your code into seperate files. This
    means that you’ll need to *bundle* them into one file. There are several popular
    tools for bundling JavaScript modules; two popular up-and-coming options are Webpack
    and Rollup. In this lesson you’ll use one of the first ones that hit the scene,
    Browserify.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是JavaScript新增功能的重要组成部分。正如你将在本课中学到的，仅进行转译对于模块来说是不够的。这是因为模块最定义性的方面是将你的代码分割成单独的文件。这意味着你需要将它们*打包*成一个文件。有几种流行的工具可以用于打包JavaScript模块；两个流行的上升选项是Webpack和Rollup。在本课中，你将使用最早出现的其中之一，Browserify。
- en: 3.1\. What’s a module?
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1. 什么是模块？
- en: Many programming languages support modularized code. Ruby calls these pieces
    of modularized code *gems*, Python calls them *eggs*, and Java calls them *packages*.
    JavaScript never had official support for this concept until ES2015 with the introduction
    of *modules*. A module is an individual file of modularized JavaScript code. Becuase
    JavaScript was so late to this party, many community solutions for modules in
    JavaScript were created, the most ubiquitous being node.js modules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言都支持模块化代码。Ruby将这些模块化代码称为*gem*，Python称为*egg*，Java称为*packages*。JavaScript直到ES2015引入*模块*概念之前都没有官方支持这一概念。模块是单个模块化JavaScript代码文件。由于JavaScript在这个领域来得太晚，因此为JavaScript中的模块创建了多种社区解决方案，其中最普遍的是node.js模块。
- en: 3.2\. How modules work in Node.js
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2. Node.js中的模块是如何工作的
- en: Node.js has a fantastic module system with NPM. NPM is the Node package manager
    that comes bundled with Node.js. With roughly a quarter of a million packages
    published to NPM’s registry and billions of downloads a month, NPM is one of the
    richest ecosystems of code in the world.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js拥有一个出色的模块系统，配合NPM使用。NPM是随Node.js一起打包的Node包管理器。大约有25万个包发布到NPM的注册库，每月下载量达数十亿次，NPM是世界上代码生态系统最丰富的之一。
- en: There is a specific way to import and export modules in Node.js. When referring
    to Node.js-style modules, many people use the term *CommonJS*, which is a specification
    originally called ServerJS that was created so that many server-side JavaScript
    implementations could all share a compatible module definition. Only one server-side
    JavaScript implementation took off—Node.js—so it wasn’t necessary to standardize
    their module definition. So while Node’s module definition is similar to and often
    called CommonJS, strictly speaking it is not.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中有一种特定的方式来导入和导出模块。当提到Node.js风格的模块时，许多人使用*CommonJS*这个术语，这是一个最初被称为ServerJS的规范，它被创建出来是为了让许多服务器端JavaScript实现能够共享一个兼容的模块定义。只有一个服务器端JavaScript实现流行起来——Node.js——因此没有必要标准化它们的模块定义。所以尽管Node的模块定义与CommonJS相似，并且经常被称为CommonJS，但严格来说并不是。
- en: The module system in Node.js allows developers to separate their programs into
    modules that encapsulate logic and only expose necessary APIs. Because a module
    only exposes what is explicitly exported, there is no need to wrap everything
    in an immediately invoked function expression. Better yet, because the modules
    are only available where imported, they do not pollute the global namespace, protecting
    against accidental naming collisions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中的模块系统允许开发者将程序分割成封装逻辑并仅暴露必要API的模块。由于模块只暴露显式导出的内容，因此没有必要将所有内容包裹在一个立即执行的函数表达式中。更好的是，因为模块仅在导入的地方可用，它们不会污染全局命名空间，从而防止意外的命名冲突。
- en: 3.3\. What is Browserify?
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3. 什么是Browserify？
- en: '*Broswerify* is a tool that lets you define modules, the same way Node.js does
    during development, and then bundle them into a single file. Browserify operates
    on an entry point, your main JavaScript file, and analyzes what scripts are imported.
    It then runs on all those scripts as well, eventually building a tree of all the
    dependencies that are needed. Browserify then generates a single JavaScript file
    with all the required modules bundled into it while maintaining their proper scoping
    and namespacing. This bundled JavaScript file can then be included in a webpage
    on the frontend. This allows front-end developers to write modularized JavaScript
    and even utilize the rich ecosystem of all the packages published to NPM. Browserify
    was named after its ability to write code in a Node.js fashion and use Node.js
    modules in the browser.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*Browserify*是一个工具，它允许你以与Node.js在开发期间相同的方式定义模块，然后将它们打包成一个单独的文件。Browserify在入口点操作，即你的主JavaScript文件，并分析哪些脚本被导入。然后它还会运行所有这些脚本，最终构建一个所需所有依赖项的树。Browserify随后生成一个包含所有所需模块的单个JavaScript文件，同时保持它们适当的范围和命名空间。这个打包的JavaScript文件可以随后被包含在前端网页中。这允许前端开发者编写模块化的JavaScript，甚至利用所有发布到NPM的丰富生态系统。Browserify之所以得名，是因为它能够以Node.js风格编写代码并使用浏览器中的Node.js模块。'
- en: 3.4\. How does Browserify help with ES6 modules?
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4. Browserify是如何帮助处理ES6模块的？
- en: You learned in [lesson 2](kindle_split_010_split_000.xhtml#ch02) that Babel
    transpiles your ESNext code so you can execute it in a browser. But Babel doesn’t
    supply you with a module system. It simply translates your ESNext source to an
    ES5 destination and leaves the developer with the task of solving the bundling.
    ES2015, on the other hand, does define a formal module specification for JavaScript.
    So how can you use ES2015 modules today if Babel doesn’t expose a module loader?
    What if you could get Browserify and Babel to work together so that Babel could
    transpile the ES2015 modules into the kind of modules that Browserify likes to
    work with, and then Browserify could take it from there? Luckily Browserify has
    the concept of *transforms*. Transforms allow the code to be transformed before
    being operated on by Browserify. There is a transform for Babel called *babelify*.
    When you use babelify, each file will be transpiled before being sent to Browserify,
    allowing you to use ES2015 modules.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第2课](kindle_split_010_split_000.xhtml#ch02)中学到了Babel将你的ESNext代码转换为可以在浏览器中执行的形式。但是Babel并不提供模块系统。它只是将你的ESNext源代码转换为ES5目标代码，并留给开发者解决打包的任务。另一方面，ES2015确实为JavaScript定义了一个正式的模块规范。那么，如果Babel没有暴露模块加载器，你今天如何使用ES2015模块呢？如果你能让Browserify和Babel一起工作，使得Babel能够将ES2015模块转换为Browserify喜欢处理的模块类型，然后Browserify继续处理，会怎么样呢？幸运的是，Browserify有*转换*的概念。转换允许在代码被Browserify操作之前对其进行转换。有一个名为*babelify*的Babel转换器。当你使用babelify时，每个文件在发送到Browserify之前都会被转换，这样你就可以使用ES2015模块。
- en: 3.5\. Setting up Browserify with Babel
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5. 使用Babel设置Browserify
- en: Now that you understand what Browserify is and the role it plays, let’s install
    it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Browserify是什么以及它所扮演的角色，让我们来安装它。
- en: 3.5.1\. Installing Browserify
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.1. 安装Browserify
- en: 'First globally install Browserify. Execute the following shell command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先全局安装Browserify。执行以下shell命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This installs Browserify globally, so it can be used for any project. You won’t
    need to install it again unless you want to upgrade to a newer version.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在全局范围内安装Browserify，因此它可以用于任何项目。除非你想升级到新版本，否则你不需要再次安装它。
- en: 3.5.2\. Setting up a project using babelify
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.2. 使用babelify设置项目
- en: 'Now that you have Browserify, you can get started by creating a new project
    called babelify_example. Create a new folder called babelify_example containing
    a .babelrc file, a dist folder, and a src folder, with the src folder containing
    an index.js and an app.js so that your project structure looks like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了Browserify，你可以通过创建一个名为babelify_example的新项目来开始。创建一个名为babelify_example的新文件夹，包含一个.babelrc文件、一个dist文件夹和一个src文件夹，其中src文件夹包含一个index.js和一个app.js，这样你的项目结构看起来就像这样：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now in your terminal, cd (change directory) to your project’s root folder,
    initialize as an NPM project with babelify and the other Babel presets and plugins
    you used in the previous chapter:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的终端中，cd（更改目录）到你的项目根文件夹，使用babelify以及你在上一章中使用过的其他Babel预设和插件初始化为一个NPM项目：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice that you did not install the babel-cli package. This is because you’re
    now using Browserify with babelify and thus no longer need the Babel CLI (command
    line interface). Go ahead and add the same Babel config from your previous lesson
    to the .babelrc file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到你没有安装babel-cli包。这是因为你现在正在使用Browserify和babelify，因此不再需要Babel CLI（命令行界面）。继续添加你之前课程中的相同Babel配置到.babelrc文件中：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'OK, you should now be all set to start using Browserify with babelify! Test
    it out by writing a small module to `check` for you. In the app.js file, add the
    following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你现在应该已经准备好开始使用Browserify和babelify了！通过编写一个小模块来测试它。在app.js文件中添加以下代码：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now in the index.js file, add the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在index.js文件中，添加以下代码：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Fantastic. Now bundle this with the following shell command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。现在使用以下shell命令打包：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If everything was set up correctly, your dist folder should now contain a new
    bundle.js file with some transpiled JavaScript code inside of it. Let’s break
    down that command. The first argument to Browserify is `src/index.js`. This tells
    Browserify that this is the *entry point* of your application—entry point meaning
    the root JavaScript file that imports other modules. Then the `--transform babelify`
    tells Browserify to use the babelify transform to transpile your code before bundling.
    The `--outfile dist/bundle.js` specifies what the destination or *output file*
    is for your bundled and transpiled source code. Finally, the `--debug` flag is
    necessary to include source maps, which wouldn’t be included without it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，你的dist文件夹现在应该包含一个包含一些转换后的JavaScript代码的新bundle.js文件。让我们分解这个命令。Browserify的第一个参数是`src/index.js`。这告诉Browserify这是你的应用程序的*入口点*——入口点意味着导入其他模块的根JavaScript文件。然后`--transform
    babelify`告诉Browserify在打包之前使用babelify转换来转换你的代码。`--outfile dist/bundle.js`指定了打包和转换后的源代码的*输出文件*。最后，`--debug`标志是必要的，以包含源映射，没有它则不会包含。
- en: You can see see a list of the available arguments to Browserify by running
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来查看Browserify可用的参数列表：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now test your code with Node.js. If you’ve never used Node.js to execute JavaScript
    before, don’t fret. You already have it installed, and telling it to execute JavaScript
    is as simple as pointing it to a JavaScript file. So tell Node to execute your
    transpiled bundle.js file by executing the following shell script:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用Node.js测试你的代码。如果你以前从未使用Node.js执行JavaScript，不要担心。你已经有它安装了，告诉它执行JavaScript就像指向一个JavaScript文件一样简单。所以告诉Node执行你的转换后的bundle.js文件，通过执行以下shell脚本：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You should be greeted with an enthusiastic
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会收到热情的
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Don’t worry about understanding the semantics of how modules work just yet.
    We will cover that in [lessons 20](kindle_split_032_split_000.xhtml#ch20) and
    [21](kindle_split_033_split_000.xhtml#ch21). For now, get your bundle working
    in the browser instead of Node. Create an index.html file at the root of your
    project with the following contents:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心现在就理解模块的工作语义。我们将在[第20课](kindle_split_032_split_000.xhtml#ch20)和[第21课](kindle_split_033_split_000.xhtml#ch21)中介绍。现在，先在你的浏览器中让你的打包工作起来，而不是在Node中。在你的项目根目录中创建一个index.html文件，内容如下：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now open your index.html in your web browser. Check the console; if using Google
    Chrome, select Menu > More Tools > Developer Tools, then select the Console tab.
    You should see the same quote in your console: *Yahoo! modules are working!!*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在你的网络浏览器中打开你的index.html。检查控制台；如果使用Google Chrome，请选择菜单 > 更多工具 > 开发者工具，然后选择控制台标签。你应该在你的控制台中看到相同的引用：*Yahoo!
    模块正在工作！！*
- en: 'Let’s recap what you’ve done so far:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下你到目前为止所做的一切：
- en: You created a module with a `check` method to log a message in app.js.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在app.js中创建了一个具有`check`方法的模块来记录消息。
- en: In your index.js, you imported the module and invoked the `check` method.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的index.js中，你导入了模块并调用了`check`方法。
- en: You used Browserify and Babel to transpile and bundle your JavaScript.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用了Browserify和Babel来转换和打包你的JavaScript。
- en: You then included your bundled code in an HTML page and saw that it works!
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后你在HTML页面中包含了你的打包代码，并看到它工作得很好！
- en: That encompasses all the steps necessary to execute all the code in this book.
    The remaining chapters will assume that you are set up and able to execute your
    examples.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括了执行本书中所有代码所需的所有步骤。接下来的章节将假设你已经设置好并且能够执行你的示例。
- en: Don’t forget to recompile (via executing the `browserify` command) whenever
    you make a change to your source files so that your bundle.js reflects your latest
    code. (Look into watchify for automatic bundling.) You can add the Browserify
    shell command as an NPM script in your package.json to make it easier to run.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你修改源文件时，不要忘记重新编译（通过执行 `browserify` 命令），以确保你的 bundle.js 反映你最新的代码。（了解 watchify
    以实现自动捆绑。）你可以在 package.json 中添加 Browserify 壳命令作为 NPM 脚本，以便更容易运行。
- en: 3.6\. Alternatives to Browserify
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6\. Browserify 的替代方案
- en: 'There are plenty of other ways to transpile and bundle your ESNext code. Webpack
    and Rollup are currently very popular options. Which one works best for your project
    will depend a lot on the details of your project. Babel has good setup examples
    for different scenarios that you can check out here: [http://babeljs.io/docs/setup](http://babeljs.io/docs/setup).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他方法可以将你的 ESNext 代码进行转译和捆绑。Webpack 和 Rollup 目前是非常受欢迎的选项。哪个最适合你的项目将很大程度上取决于你项目的细节。Babel
    为不同的场景提供了良好的设置示例，你可以在这里查看：[http://babeljs.io/docs/setup](http://babeljs.io/docs/setup)。
- en: Summary
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, you learned how to set up Browserify to bundle your ES2015 modules.
    For more infomation on modules, see [lessons 20](kindle_split_032_split_000.xhtml#ch20)–[21](kindle_split_033_split_000.xhtml#ch21).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，你学习了如何设置 Browserify 以捆绑你的 ES2015 模块。有关模块的更多信息，请参阅[第 20 节](kindle_split_032_split_000.xhtml#ch20)–[第
    21 节](kindle_split_033_split_000.xhtml#ch21)。
