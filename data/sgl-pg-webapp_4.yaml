- en: Appendix B. Testing an SPA
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录B. 测试SPA
- en: '|  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This appendix covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本附录涵盖**'
- en: Setting up test modes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置测试模式
- en: Selecting a test framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择测试框架
- en: Setting up nodeunit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置nodeunit
- en: Creating a test suite
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建测试套件
- en: Adjusting SPA modules for test settings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整SPA模块以进行测试设置
- en: '|  |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This appendix builds on code we’ve completed in [chapter 8](kindle_split_020.html#ch08).
    Before starting, you should have the project files from [chapter 8](kindle_split_020.html#ch08),
    as we’ll be adding to them. We recommend you copy the entire directory structure
    you created in [chapter 8](kindle_split_020.html#ch08) into a new “appendix_B”
    directory and update them there.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录基于我们在[第8章](kindle_split_020.html#ch08)中完成的代码。在开始之前，你应该有[第8章](kindle_split_020.html#ch08)中的项目文件，因为我们将在此基础上添加内容。我们建议您将[第8章](kindle_split_020.html#ch08)中创建的整个目录结构复制到一个新的“appendix_B”目录中，并在那里更新它们。
- en: We’re fans of test-driven development and have worked *gonzo* projects where
    the *generation* of tests was automated. A permutation tool was used to automatically
    generate thousands of regression tests by simply describing the APIs and their
    expected behavior. If a developer modified code, it had to pass the regression
    tests before it could be checked in to the repository. And when a new API was
    introduced, the developer added the description to the configuration, and hundreds
    or thousands of new tests were generated automatically. This practice resulted
    in exceptional quality, as code coverage was great, and we rarely had a regression
    of any sort.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是测试驱动开发的粉丝，并参与过*gonzo*项目，其中测试的*生成*是自动化的。使用排列工具通过简单地描述API及其预期行为来自动生成数千个回归测试。如果开发者修改了代码，它必须通过回归测试后才能被提交到仓库。当引入新的API时，开发者将描述添加到配置中，然后自动生成数百或数千个新测试。这种做法导致了卓越的质量，因为代码覆盖率很高，我们很少出现任何类型的回归。
- en: Although we love these sorts of regression tests, we won’t be so ambitious in
    this appendix. We only have enough space and time to get your feet wet, not give
    you a bath. Instead we’ll set up test modes, discuss their use, and then create
    a test suite using jQuery and a test framework. We’re testing later than we’d
    like for a real project—we prefer to write our tests along with our code because
    it helps clarify what the code is supposed to do. And, as if to prove the point,
    we found and fixed two issues while writing this appendix.^([[1](#app02fn01)])
    Now let’s discuss the test modes we want for an SPA.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们喜欢这类回归测试，但在这个附录中我们不会如此雄心勃勃。我们只有足够的空间和时间让你试试水，而不是给你洗个澡。相反，我们将设置测试模式，讨论它们的使用，然后使用jQuery和一个测试框架创建一个测试套件。我们测试的时间比我们希望的更晚——我们更喜欢在编写代码的同时编写测试，因为这有助于阐明代码应该做什么。而且，就像是为了证明这一点一样，我们在编写这个附录时发现了并修复了两个问题。[^([1](#app02fn01))]
    现在让我们讨论我们希望SPA拥有的测试模式。
- en: '¹ If you must know, they were: 1) The online person list wasn’t being properly
    cleared on sign-out, and 2) calls to `spa.model.chat.get_chatee()` were returning
    an out-of-date object after the chatee’s avatar had been updated. Both bugs are
    fixed in [chapter 6](kindle_split_017.html#ch06).'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 如果您想知道，它们是：1) 在注销时，在线人员列表没有被正确清除，2) 在聊天者的头像更新后，对`spa.model.chat.get_chatee()`的调用返回了一个过时的对象。这两个错误已在[第6章](kindle_split_017.html#ch06)中修复。
- en: B.1\. Set up test modes
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1\. 设置测试模式
- en: 'We use at least four different test modes when developing an SPA. These modes
    should generally be used in the order presented:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发SPA时，我们至少使用四种不同的测试模式。这些模式通常应按以下顺序使用：
- en: Test the Model without a browser using fake data (mode 1).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模拟数据（模式1）在不使用浏览器的情况下测试模型。
- en: Test the user interface using fake data (mode 2).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模拟数据（模式2）测试用户界面。
- en: Test the Model without a browser using live data (mode 3).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用实时数据（模式3）在不使用浏览器的情况下测试模型。
- en: Test the Model and user interface using live data (mode 4).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用实时数据（模式4）测试模型和用户界面。
- en: We need to be able switch easily between test modes so we may quickly identify,
    isolate, and solve issues. A corollary to this goal is that we should use the
    same code for all modes. We want to run tests without a browser (modes 1 and 3),
    and with a browser (modes 2 and 4).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够轻松地在测试模式之间切换，以便我们能够快速识别、隔离和解决问题。这个目标的推论是，我们应该为所有模式使用相同的代码。我们希望在无需浏览器的情况下运行测试（模式1和3），以及在带有浏览器的情况下运行测试（模式2和4）。
- en: '[Figure B.1](#app02fig01) shows the modules used when we test the Model without
    a browser using fake data (mode 1). This test mode should typically be used first
    to ensure the Model API works exactly as designed.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[图B.1](#app02fig01)显示了我们在使用模拟数据（模式1）不使用浏览器测试模型时使用的模块。这种测试模式通常应首先使用，以确保模型API按设计工作。'
- en: Figure B.1\. Testing the Model without a browser using fake data (mode 1)
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.1\. 使用假数据（模式 1）在没有浏览器的情况下测试模型
- en: '![](bfig01_alt.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](bfig01_alt.jpg)'
- en: '[Figure B.2](#app02fig02) shows the modules used when we test the user interface
    using fake data (mode 2). This is a great mode to isolate View- and Controller-related
    bugs after the Model has been tested.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 B.2](#app02fig02) 展示了在用假数据（模式 2）测试用户界面时使用的模块。这是在模型测试之后隔离视图和控制器相关错误的好模式。'
- en: Figure B.2\. Testing the View and Controller using fake data (mode 2)
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.2\. 使用假数据（模式 2）测试视图和控制器
- en: '![](bfig02_alt.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](bfig02_alt.jpg)'
- en: '[Figure B.3](#app02fig03) shows the modules used when we test the Model without
    a browser using live data (mode 3). This helps isolate problems with the server
    API.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 B.3](#app02fig03) 展示了在用实时数据（模式 3）测试模型而不使用浏览器时使用的模块。这有助于隔离服务器 API 的问题。'
- en: Figure B.3\. Testing the Model using the test suite and live data (mode 3)
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.3\. 使用测试套件和实时数据（模式 3）测试模型
- en: '![](bfig03_alt.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](bfig03_alt.jpg)'
- en: '[Figure B.4](#app02fig04) shows the modules used when we test the user interface
    using live data (mode 4). This allows the user to test the full stack, and is
    really the full application. Test freaks (or aspiring freaks like ourselves) call
    this *integration testing*.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 B.4](#app02fig04) 展示了在用实时数据（模式 4）测试用户界面时使用的模块。这允许用户测试整个栈，实际上就是整个应用程序。测试狂热者（或者像我们这样的有志狂热者）称这为
    *集成测试*。'
- en: Figure B.4\. Integration testing with live data (mode 4)
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.4\. 使用实时数据（模式 4）进行集成测试
- en: '![](bfig04_alt.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](bfig04_alt.jpg)'
- en: We minimize the number of issues we find in mode 4 if we do a good job testing
    with the other modes. And once we do find an issue in mode 4, we should try to
    isolate it in a simpler mode, starting at mode 1\. When it comes to resolving
    issues effectively, mode 4 is like the moon—it’s an interesting place to visit,
    but you don’t want to live there.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在其他模式下做好测试工作，我们可以在模式 4 中找到的问题数量就会最小化。一旦我们在模式 4 中找到问题，我们应该尝试在更简单的模式下隔离它，从模式
    1 开始。当谈到有效地解决问题时，模式 4 就像月亮——它是一个有趣的地方去参观，但你不想在那里生活。
- en: 'In this section, we’ll make the changes necessary so we can use the browser
    interface with both live and fake data (modes 2 and 4). Here’s what we need to
    do:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进行必要的更改，以便我们可以使用浏览器界面同时使用实时数据和假数据（模式 2 和 4）。以下是我们需要做的事情：
- en: Create the `spa.model.setDataMode` Model method to switch between fake and live
    data.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `spa.model.setDataMode` 模型方法以在假数据和实时数据之间切换。
- en: Update the Shell to inspect the value of a URI query argument, `fake`, during
    initialization. Have it then set the data mode using `spa.model.setDataMode`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始化时更新 Shell 以检查 URI 查询参数 `fake` 的值。然后使用 `spa.model.setDataMode` 设置数据模式。
- en: 'The `spa.model.setDataMode` method is easy to add to the Model, as we only
    need to change the module-scope `isFakeData` variable. The following listing shows
    the update. Changes are shown in **bold**:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`spa.model.setDataMode` 方法很容易添加到模型中，因为我们只需要更改模块作用域的 `isFakeData` 变量。以下列表显示了更新。更改以
    **粗体** 显示：'
- en: Listing B.1\. Add `setDataMode` to the Model—webapp/public/js/spa.model.js
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.1\. 将 `setDataMode` 添加到模型中—webapp/public/js/spa.model.js
- en: '![](372fig01_alt.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](372fig01_alt.jpg)'
- en: 'Our next step is to adjust the Shell to read the URI query arguments on initialization
    and then call `spa.model.setDataMode` (you know, the method we just added). This
    change is surgical, as shown in the following listing. Changes are shown in **bold**:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是调整 Shell，使其在初始化时读取 URI 查询参数，然后调用 `spa.model.setDataMode`（你知道，我们刚刚添加的方法）。这个更改是手术性的，如下列所示。更改以
    **粗体** 显示：
- en: Listing B.2\. Set data mode in the Shell—webapp/public/js/spa.shell.js
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.2\. 在 Shell 中设置数据模式—webapp/public/js/spa.shell.js
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First let’s enter our webapp directory and install the modules (`npm install`)
    and then start the node application (`node app.js`). When we open our browser
    document with the `fake` flag (`http://localhost:3000/spa.html?fake`), fake data
    will be used with the interface (mode 2).^([[2](#app02fn02)]) If we open the browser
    document without the `fake` flag (`http://localhost:3000/spa.html`), live data
    will be used instead (mode 4). In the upcoming sections we’ll discuss how to test
    our SPA without the browser (modes 1 and 3). First, let’s decide on a test framework.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们进入我们的 webapp 目录并安装模块（`npm install`），然后启动节点应用程序（`node app.js`）。当我们用 `fake`
    标志打开浏览器文档（`http://localhost:3000/spa.html?fake`）时，将使用假数据与界面（模式 2）进行测试。如果我们不使用
    `fake` 标志打开浏览器文档（`http://localhost:3000/spa.html`），则将使用实时数据（模式 4）。在接下来的章节中，我们将讨论如何在没有浏览器的情况下测试我们的
    SPA（模式 1 和 3）。首先，让我们决定一个测试框架。
- en: ² Yes, we *know* the query argument parsing is a hack. In production we’d use
    a much more robust library routine.
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 是的，我们知道查询参数解析是一个hack。在生产环境中，我们会使用一个更健壮的库函数。
- en: B.2\. Select a test framework
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2\. 选择测试框架
- en: We’ve designed our SPA architecture so we may easily test the Model without
    the use of a browser. We’ve found that when the Model works exactly as designed,
    the expense to fix user interface bugs tends to be trivial. We’ve also found that
    humans are often (but not always) more effective at interface testing than scripts
    are.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计我们的SPA架构，以便我们可以轻松地在不使用浏览器的情况下测试模型。我们发现，当模型完全按设计工作，修复用户界面错误的开销往往微不足道。我们还发现，人类在界面测试方面通常（但不总是）比脚本更有效。
- en: Instead of a browser, we’ll use Node.js to test the Model. This will allow us
    to easily and automatically run test suites during development and prior to deployment.
    And because we’re not dependent on a browser, tests are simpler to write, maintain,
    and extend.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Node.js来测试模型，而不是浏览器。这将使我们能够在开发期间和部署之前轻松自动运行测试套件。而且因为我们不依赖于浏览器，测试编写、维护和扩展都更简单。
- en: Node.js has many test frameworks that have years of use and refinement. Let’s
    be wise and use one instead of hacking our own. Here’s a list of some that we
    found interesting for one reason or another:^([[3](#app02fn03)])
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js有许多经过多年使用和改进的测试框架。让我们明智地选择一个，而不是自己编写。以下是我们发现的一些有趣的框架列表：^([[3](#app02fn03)])
- en: ³ See [https://github.com/joyent/node/wiki/modules#testing](https://github.com/joyent/node/wiki/modules#testing)
    for an exhaustive list.
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 请参阅[https://github.com/joyent/node/wiki/modules#testing](https://github.com/joyent/node/wiki/modules#testing)以获取完整的列表。
- en: '*jasmine-jquery*—Can “watch” jQuery events.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*jasmine-jquery*—可以“监视”jQuery事件。'
- en: '*mocha*—Popular and similar to nodeunit but with better reporting.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mocha*—流行的测试框架，类似于nodeunit但具有更好的报告功能。'
- en: '*nodeunit*—Popular, with simple yet powerful tools.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*nodeunit*—流行的，具有简单而强大的工具。'
- en: '*patr*—Uses promises (similar to jQuery `$.Deferred` objects) for asynchronous
    testing.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*patr*—使用promises（类似于jQuery `$.Deferred`对象）进行异步测试。'
- en: '*vows*—Popular asynchronous BDD framework.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*vows*—流行的异步BDD框架。'
- en: '*zombie*—Popular full-stack headless featuring a WebKit engine.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*zombie*—流行的全栈无头测试框架，具有WebKit引擎。'
- en: Zombie is inclusive and is intended to test the user interface as well as the
    Model. It even includes its own instance of the WebKit rendering engine so tests
    can check rendered elements. We won’t pursue this kind of testing here because
    it’s expensive and tedious to install, set up, and maintain—and this is an appendix,
    *not another book*. Although we find jasmine-jquery and patr interesting for the
    reasons listed here, we feel they don’t have the level of support we need. Mocha
    and vows are popular, but we want to start simpler.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Zombie是一个包容性的测试框架，旨在测试用户界面以及模型。它甚至包括自己的WebKit渲染引擎实例，以便测试可以检查渲染的元素。我们不会在这里追求这种测试，因为它安装、设置和维护成本高昂且繁琐——这是一个附录，*不是另一本书*。尽管我们发现jasmine-jquery和patr因其列出的原因而有趣，但我们觉得它们没有我们需要的支持水平。Mocha和vows很流行，但我们想从简单开始。
- en: This leaves us with nodeunit, which is popular, powerful, simple, and also integrates
    nicely with our IDE. Let’s set it up.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了nodeunit，它流行、强大、简单，并且与我们的IDE集成良好。让我们设置它。
- en: B.3\. Set up nodeunit
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3\. 设置nodeunit
- en: 'Before we can install nodeunit, we need to ensure Node.js is installed as outlined
    in [chapter 7](kindle_split_019.html#ch07). Once Node.js is available, we need
    to install two `npm` packages to get node-unit ready to run our test suite:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们安装nodeunit之前，我们需要确保Node.js已按[第7章](kindle_split_019.html#ch07)中概述的方式安装。一旦Node.js可用，我们需要安装两个`npm`包来使node-unit准备好运行我们的测试套件：
- en: '`jquery`—We need to install the Node.js version of jQuery because our Model
    uses global custom events, and this requires jQuery and the jquery.event.gevent
    plugin. As an added bonus, installation of this package provides a mocked browser
    environment. So if we wanted to test DOM manipulation we could.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery`—我们需要安装jQuery的Node.js版本，因为我们的模型使用全局自定义事件，这需要jQuery和jquery.event.gevent插件。作为额外的奖励，安装此包提供了一个模拟的浏览器环境。所以如果我们想测试DOM操作，我们就可以做到。'
- en: '`nodeunit`—This provides the nodeunit command-line tool. When we run our test
    suite, we’ll use the `nodeunit` command instead of `node`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodeunit`—这提供了nodeunit命令行工具。当我们运行测试套件时，我们将使用`nodeunit`命令而不是`node`。'
- en: 'We like to install these packages system-wide so they can be used by all Node.js
    projects. We may do so using the `-g` switch and installing them as root (or administrator,
    if you’re on Windows). The following should work for Linux and Mac:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢在系统范围内安装这些包，这样它们就可以被所有 Node.js 项目使用。我们可以使用 `-g` 开关并将它们作为 root（或在 Windows
    上是管理员）安装。以下适用于 Linux 和 Mac：
- en: Listing B.3\. Installing jQuery and nodeunit system-wide
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.3\. 在系统范围内安装 jQuery 和 nodeunit
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that you may need to tell your execution environment where to find the
    system Node.js libraries by setting the `NODE_PATH` environment variable. In Linux
    or Mac, this can be done by adding to your ~/.bashrc file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可能需要通过设置 `NODE_PATH` 环境变量来告诉你的执行环境在哪里可以找到系统 Node.js 库。在 Linux 或 Mac 上，这可以通过向你的
    ~/.bashrc 文件中添加以下内容来完成：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will ensure the `NODE_PATH` is set every time you start a new terminal
    session.^([[4](#app02fn04)]) Now that we have Node.js, jQuery, and nodeunit installed,
    let’s prepare our modules for testing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保每次你启动一个新的终端会话时都会设置 `NODE_PATH`。[^[[4](#app02fn04)]] 现在，我们已经安装了 Node.js、jQuery
    和 nodeunit，让我们为测试准备我们的模块。
- en: ⁴ For a currently running session, type `export PATH=/usr/lib/node_modules`.
    Depending on how Node.js is installed, the path may vary. On Mac, you might try
    /usr/local/share/npm/lib/node_modules.
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 对于当前会话，输入 `export PATH=/usr/lib/node_modules`。根据 Node.js 的安装方式，路径可能会有所不同。在
    Mac 上，你可能尝试 /usr/local/share/npm/lib/node_modules。
- en: B.4\. Create the test suite
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4\. 创建测试套件
- en: As of [chapter 6](kindle_split_017.html#ch06), we have all the ingredients for
    successful testing of our Model using known data (thanks to the Fake module) and
    a well-defined API. [Figure B.5](#app02fig05) shows how we plan to test the Model:^([[5](#app02fn05)])
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到 [第 6 章](kindle_split_017.html#ch06) 为止，我们已经有了使用已知数据（多亏了 Fake 模块）和定义良好的 API
    成功测试我们模型的所有成分。[图 B.5](#app02fig05) 展示了我们计划如何测试模型：[^[[5](#app02fn05)]]
- en: ⁵ The astute interloper will notice that this figure is a lazy, pixel-perfect
    copy of one presented earlier. We should get paid by the column-inch...
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 精明的闯入者会注意到这个图是一个懒散的、像素完美的复制之前展示过的图。我们应该按列英寸来付费...
- en: Figure B.5\. Testing the Model using the test suite and fake data (mode 1)
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 B.5\. 使用测试套件和模拟数据测试模型（模式 1）
- en: '![](bfig05_alt.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![bfig05_alt.jpg](bfig05_alt.jpg)'
- en: Before we can start testing, we need to get Node.js to load our modules. Let’s
    do that next.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始测试之前，我们需要让 Node.js 加载我们的模块。让我们接下来这样做。
- en: B.4.1\. Get Node.js to load our modules
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.4.1\. 让 Node.js 加载我们的模块
- en: Node.js handles global variables differently than browsers. Unlike browser JavaScript,
    variables in a file are local by default. Effectively, Node.js wraps all library
    files in an anonymous function. The way we make a variable available across all
    modules is to make it a property of the top-level object. And the-top level object
    in Node.js is not `window`, like it is in browsers, but is instead called—wait
    for it—`global`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 处理全局变量的方式与浏览器不同。与浏览器 JavaScript 不同，文件中的变量默认是局部的。实际上，Node.js 将所有库文件包裹在一个匿名函数中。我们使变量在所有模块中可用的方法是将其作为顶层对象的属性。在
    Node.js 中，顶层对象不是 `window`，像在浏览器中那样，而是称为——等等——`global`。
- en: 'Our modules are designed for use by the browser. But with ingenuity, we can
    have Node.js use them with little modification. Here’s how we do it: our entire
    application runs in the single namespace (object) of `spa`. So if we declare a
    `global.spa` attribute in our Node.js test script before we load our modules,
    everything should work as expected.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计模块是为了浏览器使用。但通过巧妙的方法，我们可以让 Node.js 在稍作修改后使用它们。以下是我们的做法：我们的整个应用程序都在 `spa`
    的单个命名空间（对象）中运行。因此，如果我们在我们加载模块之前在 Node.js 测试脚本中声明一个 `global.spa` 属性，一切应该都能按预期工作。
- en: Now before all that evaporates from our short-term memories, let’s start our
    test suite, webapp/public/nodeunit_suite.js, as shown in the following listing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些内容从我们的短期记忆中消失之前，让我们开始我们的测试套件，webapp/public/nodeunit_suite.js，如下所示列表。
- en: Listing B.4\. Declare our namespace in the test suite—webapp/public/nodeunit_suite.js
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.4\. 在测试套件中声明我们的命名空间—webapp/public/nodeunit_suite.js
- en: '![](376fig01_alt.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![376fig01_alt.jpg](376fig01_alt.jpg)'
- en: 'We only need to adjust the root JavaScript file (webapp/public/js/spa.js) to
    finish loading our modules. Our adjustment allows the test suite to use the correct
    global `spa` variable as shown in the next listing. Changes are shown in **bold**:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要调整根 JavaScript 文件（webapp/public/js/spa.js）以完成模块的加载。我们的调整使得测试套件能够使用正确的全局
    `spa` 变量，如下所示列表。变更以**粗体**显示：
- en: Listing B.5\. Adjust our root SPA JavaScript—webapp/public/js/spa.js
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.5\. 调整我们的根 SPA JavaScript—webapp/public/js/spa.js
- en: '![](376fig02_alt.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![376fig02_alt.jpg](376fig02_alt.jpg)'
- en: 'Now that we’ve created a `global.spa` variable, we can load our modules much
    like we did with our browser document ([webapp/public/spa.html](http://webapp/public/spa.html)).
    First we’ll load our third-party modules like jQuery and TaffyDB, and make sure
    *their* global variables are also available (`jQuery`, `$`, and `TAFFY`, if you
    must know). Then we can load our jQuery plugins and then our SPA modules. We won’t
    load our Shell or feature modules, because we don’t need them to test the Model.
    Let’s update our unit test file while these thoughts still linger in our consciousness.
    Changes are shown in **bold**:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个 `global.spa` 变量，我们可以像处理我们的浏览器文档（[webapp/public/spa.html](http://webapp/public/spa.html)）一样加载我们的模块。首先，我们将加载第三方模块，如jQuery和TaffyDB，并确保它们的全局变量也可用（如果你必须知道的话，是
    `jQuery`、`$` 和 `TAFFY`）。然后我们可以加载我们的jQuery插件，然后是我们的SPA模块。我们不会加载我们的Shell或功能模块，因为我们不需要它们来测试模型。让我们在意识中仍然保留这些想法的同时更新我们的单元测试文件。变化以**粗体**显示：
- en: Listing B.6\. Adding the libraries and our modules—webapp/public/nodeunit_suite.js
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表B.6\. 添加库和我们的模块—webapp/public/nodeunit_suite.js
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Whoops, we got ambitious and snuck in a short test script at the end of our
    listing. Although we eventually want to use nodeunit to run this file, we’ll use
    Node.js to run it first to ensure it’s loading the libraries properly. Indeed,
    when we run our test suite using Node.js we see something like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，我们在列表的末尾偷偷加入了一个简短的测试脚本。虽然我们最终希望使用nodeunit来运行这个文件，但我们将首先使用Node.js来运行它，以确保它正确地加载了库。确实，当我们使用Node.js运行我们的测试套件时，我们会看到类似以下的内容：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you’re playing along at home, please be patient. It takes three seconds before
    we see any output because the Fake module pauses that long before completing a
    sign-in request. And it takes another eight seconds after the output for Node.js
    to finish running. That’s because Fake module uses timers when emulating the server
    (timers are created by the `setTimeout` and `setInterval` methods). Until those
    timers are complete, Node.js considers the program “running” and doesn’t exit.
    We’ll come back to this issue later. Now let’s get familiar with nodeunit.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在家中参与，请耐心等待。我们将在三秒后看到任何输出，因为模拟模块在完成登录请求之前会暂停这么长时间。输出后还需要另外八秒，Node.js 才能完成运行。这是因为模拟模块在模拟服务器时使用计时器（计时器由
    `setTimeout` 和 `setInterval` 方法创建）。在这些计时器完成之前，Node.js 会认为程序“正在运行”并且不会退出。我们稍后会回到这个问题。现在让我们熟悉一下nodeunit。
- en: B.4.2\. Set up a single nodeunit test
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.4.2\. 设置单个nodeunit测试
- en: 'Now that we have Node.js loading our libraries, we can focus on setting up
    our node-unit tests. First let’s get comfortable with nodeunit all by itself.
    The steps to running a successful test are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了Node.js加载我们的库，我们可以专注于设置我们的node-unit测试。首先，让我们独自熟悉一下nodeunit。运行成功测试的步骤如下：
- en: Declare the test functions.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明测试函数。
- en: In each test function, tell the `test` object how many assertions to expect
    using `test.expect( <count> )`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个测试函数中，使用 `test.expect( <count> )` 告诉 `test` 对象期望多少个断言。
- en: In each test, run the assertions; for example `test.ok( true );`.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个测试中运行断言；例如 `test.ok( true );`。
- en: At the end of each test, tell the test object that this test is complete using
    `test.done()`.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个测试结束时，使用 `test.done()` 告诉测试对象这个测试已完成。
- en: Export the list of tests to be run *in order*. Each test will be run only after
    the prior test is complete.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按顺序导出要运行的测试列表。每个测试都将在前一个测试完成后才运行。
- en: Run the test suite using `nodeunit <filename>`.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `nodeunit <filename>` 运行测试套件。
- en: '[Listing B.7](#app02list07) shows a nodeunit script using these steps for a
    single test. Please read the annotations as they provide helpful insight:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表B.7](#app02list07) 展示了一个使用这些步骤进行单个测试的nodeunit脚本。请阅读注释，因为它们提供了有价值的见解：'
- en: Listing B.7\. Our first nodeunit test—webapp/public/nodeunit_test.js
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表B.7\. 我们的第一个nodeunit测试—webapp/public/nodeunit_test.js
- en: '![](378fig01_alt.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](378fig01_alt.jpg)'
- en: 'When we run `nodeunit nodeunit_test.js` we should see the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `nodeunit nodeunit_test.js` 时，我们应该看到以下输出：
- en: '![](378fig02.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](378fig02.jpg)'
- en: Now let’s combine our nodeunit experience with the code we want tested.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将我们的nodeunit经验与我们要测试的代码结合起来。
- en: B.4.3\. Create our first real test
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.4.3\. 创建我们的第一个真实测试
- en: 'We’ll now convert our first example into a real test. We can use nodeunit and
    jQuery deferred objects to avoid the pitfalls of testing event-driven code. First,
    we rely on the fact that nodeunit won’t proceed to a new test until the prior
    test declares it’s finished by executing `test.done()`. This makes testing easier
    to write and understand. Second, we can use a deferred object in jQuery to invoke
    `test.done()` only after the required `spa-login` event has been published. This
    then allows the script to proceed to the next test. Let’s update our test suite
    as shown in [listing B.8](#app02list08). Changes are shown in **bold**:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将第一个示例转换为真实测试。我们可以使用nodeunit和jQuery延迟对象来避免测试事件驱动代码的陷阱。首先，我们依赖于nodeunit在先前的测试通过执行`test.done()`声明完成之前不会继续到新的测试。这使得测试更容易编写和理解。其次，我们可以使用jQuery中的延迟对象在所需的`spa-login`事件发布后调用`test.done()`。这然后允许脚本继续到下一个测试。让我们更新我们的测试套件，如[列表
    B.8](#app02list08)所示。更改以**粗体**显示：
- en: Listing B.8\. Our first real test—webapp/public/nodeunit_suite.js
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.8\. 我们的第一个真实测试—webapp/public/nodeunit_suite.js
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we run the test suite using `nodeunit ./nodeunit_suite.js` we should see
    the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`nodeunit ./nodeunit_suite.js`运行测试套件时，我们应该看到以下输出：
- en: '![](380fig01.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![380fig01.jpg](380fig01.jpg)'
- en: Now that we’ve successfully implemented a single test, let’s map out the tests
    we want to have in our suite and discuss how we’ll ensure they execute in the
    correct sequence.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功实现了一个单个测试，让我们规划出我们希望在套件中拥有的测试，并讨论我们将如何确保它们按正确的顺序执行。
- en: B.4.4\. Map the events and tests
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.4.4\. 映射事件和测试
- en: When we tested the Model manually in [chapters 5](kindle_split_016.html#ch05)
    and [6](kindle_split_017.html#ch06), waiting for some process to complete before
    typing in the next test came naturally. It’s obvious to humans that we must wait
    for sign-in to complete before we can test messaging. But this isn’t obvious to
    a test suite.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第 [5](kindle_split_016.html#ch05) 和 [6](kindle_split_017.html#ch06) 章手动测试模型时，在输入下一个测试之前等待某些进程完成是自然而然的。对人类来说，显然我们必须在测试消息之前等待登录完成。但对测试套件来说，这并不明显。
- en: We must map out a sequence of events and tests for our test suite to work. One
    benefit of writing test suites is that it makes us analyze and understand our
    code more completely. Sometimes we find more bugs when writing tests than when
    running them.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为我们的测试套件规划一系列的事件和测试，以便其能够正常工作。编写测试套件的一个好处是，它使我们能够更全面地分析和理解我们的代码。有时我们在编写测试时发现的错误比在运行测试时更多。
- en: 'Let’s first design a test plan for our suite. We want to test the Model as
    our imaginary user, Fred, puts our SPA through its paces. Here is what we’d like
    Fred to do, with labels:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为我们的套件设计一个测试计划。我们希望测试模型，就像我们的想象用户Fred一样，让我们的SPA经受考验。以下是Fred需要做的事情，带有标签：
- en: '`testInitialState`—Test the initial state of the Model.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testInitialState`—测试模型的初始状态。'
- en: '`loginAsFred`—Sign in as Fred and test the user object before the process completes.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loginAsFred`—以Fred的身份登录并测试在进程完成之前用户对象。'
- en: '`testUserAndPeople`—Test the online-user list and the user details.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testUserAndPeople`—测试在线用户列表和用户详情。'
- en: '`testWilmaMsg`—Receive a message from Wilma and test the message details.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testWilmaMsg`—接收Wilma的消息并测试消息细节。'
- en: '`sendPebblesMsg`—Change the chatee to Pebbles and send her a message.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendPebblesMsg`—将聊天对象更改为Pebbles并发送给她一条消息。'
- en: '`testMsgToPebbles`—Test the content of the message sent to Pebbles.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testMsgToPebbles`—测试发送给Pebbles的消息的内容。'
- en: '`testPebblesResponse`—Test the content of a response message sent by Pebbles.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testPebblesResponse`—测试Pebbles发送的响应消息的内容。'
- en: '`updatePebblesAvtr`—Update data for Pebbles’ avatar.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updatePebblesAvtr`—更新Pebbles头像的数据。'
- en: '`testPebblesAvtr`—Test the update of Pebbles’ avatar.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testPebblesAvtr`—测试Pebbles头像的更新。'
- en: '`logoutAsFred`—Sign out as Fred.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logoutAsFred`—以Fred的身份登出。'
- en: '`testLogoutState`—Test the state of the Model after sign-out.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testLogoutState`—测试登出后模型的状态。'
- en: 'Our test framework, nodeunit, runs tests in the order presented, and won’t
    proceed to the next test until the prior test has declared that it has finished.
    This works to our advantage, as we want to ensure that specific events have occurred
    before certain tests are run. For example, we want a user sign-in event to occur
    before we test the online person list. Let’s map out our test plan with the events
    that need to occur before we can proceed from each test, as shown in [listing
    B.9](#app02list09). Note that our test names match the labels from our plan exactly,
    and they’re human-readable:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试框架 nodeunit 按照呈现的顺序运行测试，并且不会继续到下一个测试，直到先前的测试声明它已完成。这对我们来说是有利的，因为我们想确保在运行某些测试之前特定事件已经发生。例如，我们想在测试在线人员列表之前，用户登录事件发生。让我们绘制我们的测试计划，其中包含在我们可以从每个测试继续之前需要发生的事件，如图
    [列表 B.9](#app02list09) 所示。请注意，我们的测试名称与计划中的标签完全匹配，并且它们是可读的：
- en: Listing B.9\. Test plan with blocking events detailed
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.9\. 详细说明带有阻塞事件的测试计划
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This plan is linear and easy to understand. In the next section, we’ll put our
    plan into practice.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此计划是线性的，易于理解。在下一节中，我们将将我们的计划付诸实践。
- en: B.4.5\. Create the test suite
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: B.4.5\. 创建测试套件
- en: We can now add some utilities and incrementally add tests to our suite. At each
    step we’ll run the suite to check our progress.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一些实用工具，并逐步添加测试到我们的套件中。在每一步中，我们将运行套件以检查我们的进度。
- en: Add Tests for Initial State and Sign-In
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加初始状态和登录测试
- en: 'We’ll begin our test suite by writing some utilities and adding our first three
    tests to check the initial Model state, have Fred sign in, and then check the
    user and person list attributes. We’ve found that tests typically fall into two
    categories:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从编写一些实用工具并添加前三个测试开始我们的测试套件，以检查初始模型状态，让弗雷德登录，然后检查用户和人员列表属性。我们发现测试通常分为两类：
- en: Validation tests where many assertions (like `user.name === ‘Fred'` ) are used
    to check the correctness of program data. These tests often don’t block.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证测试中使用了多个断言（例如 `user.name === 'Fred'`）来检查程序数据的正确性。这些测试通常不会阻塞。
- en: Control tests that perform actions like signing in, sending a message, or updating
    an avatar. These tests rarely have many assertions and often block progress until
    an event-based condition is met.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制测试执行诸如登录、发送消息或更新头像等操作。这些测试很少有很多断言，并且通常在满足基于事件的条件之前会阻塞进度。
- en: We’ve found it is best to embrace this natural division, and we name our tests
    accordingly. Validation tests are named `test<something>`, and the control tests
    are named after what they do, like `loginAsFred.`
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现最好接受这种自然划分，并相应地命名我们的测试。验证测试命名为 `test<something>`，而控制测试则根据它们执行的操作命名，例如 `loginAsFred.`。
- en: The `loginAsFred` test requires that the sign-in be complete *and* the list
    of online users be updated before allowing nodeunit to proceed to the `testUserAndPeople`
    test. This is accomplished by having the `$t` jQuery collection subscribe handlers
    for the `spa-login` and `spa-listchange` events. The test suite then uses jQuery
    deferred objects to ensure these events occur *before*`loginAsFred` executes `test.done()`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`loginAsFred` 测试要求在允许 nodeunit 继续执行 `testUserAndPeople` 测试之前，登录必须完成 *并且* 在线用户列表已更新。这是通过
    `$t` jQuery 集合订阅 `spa-login` 和 `spa-listchange` 事件来实现的。然后测试套件使用 jQuery 延迟对象来确保这些事件在
    `loginAsFred` 执行 `test.done()` 之前发生。'
- en: 'Let’s update the test suite as shown in [listing B.10](#app02list10). As always,
    please read the annotations as they provide additional insight. The comments we
    built for our test plan in [listing B.9](#app02list09) are shown in **bold**:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新测试套件，如图 [列表 B.10](#app02list10) 所示。像往常一样，请阅读注释，因为它们提供了额外的见解。我们在 [列表 B.9](#app02list09)
    中为测试计划构建的注释以粗体显示：
- en: Listing B.10\. Add our first two tests—webapp/public/nodeunit_suite.js
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.10\. 添加我们的前两个测试—webapp/public/nodeunit_suite.js
- en: '![](app02list10-0.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](app02list10-0.jpg)'
- en: '![](app02list10-1.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](app02list10-1.jpg)'
- en: 'When we run our test suite (`nodeunitnodeunit_suite.js`) we should see output
    like so:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试套件（`nodeunitnodeunit_suite.js`）时，我们应该看到如下输出：
- en: '![](386fig1.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](386fig1.jpg)'
- en: The suite takes about 12 seconds to return control to the console because JavaScript
    has active timers that need to complete. Don’t worry about that—it’ll be a non-issue
    by the time we complete the test suite. Now let’s add tests for message transactions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 套件大约需要 12 秒才能将控制权返回到控制台，因为 JavaScript 有活动计时器需要完成。不用担心，当我们完成测试套件时，这将成为一个非问题。现在让我们添加消息事务的测试。
- en: Add Tests for Message Transactions
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加消息事务测试
- en: We’ll now add the next four tests from our test plan. These are a nice logical
    group, as they all test issues with sending and receiving messages. The tests
    include `testWilmaMsg`, `sendPebblesMsg`, `testMsgToPebbles`, and `testPebblesResponse`.
    We feel the names provide a good summary of what each test does.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从我们的测试计划中添加接下来的四个测试。这些测试是一个很好的逻辑组，因为它们都测试了发送和接收消息的问题。测试包括 `testWilmaMsg`、`sendPebblesMsg`、`testMsgToPebbles`
    和 `testPebblesResponse`。我们认为这些名称很好地总结了每个测试的功能。
- en: 'When we add our tests, we’ll need a few more jQuery deferred objects to ensure
    serial progression. [Listing B.11](#app02list11) shows this implementation. Please
    read the annotations as they detail how blocking is accomplished on these new
    tests. All changes are shown in **bold**:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加我们的测试时，我们需要更多的 jQuery 延迟对象以确保序列化进度。[列表 B.11](#app02list11) 展示了这种实现。请阅读注释，因为它们详细说明了在这些新测试上如何实现阻塞。所有更改都以**粗体**显示：
- en: Listing B.11\. Add tests for message transactions—webapp/public/nodeunit_suite.js
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.11\. 为消息事务添加测试—webapp/public/nodeunit_suite.js
- en: '![](app02list11-0.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](app02list11-0.jpg)'
- en: '![](app02list11-1.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](app02list11-1.jpg)'
- en: 'When we run our test suite (`nodeunitnodeunit_suite.js`) we should see output
    like so:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的测试套件（`nodeunitnodeunit_suite.js`）时，我们应该看到如下输出：
- en: '![](389fig01.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](389fig01.jpg)'
- en: The suite takes just as long to return from execution as before, but now we
    see the new tests. Specifically, the suite is now waiting for, and then testing,
    the message Wilma sends to the user. Now let’s add more tests to complete our
    test suite.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 套件从执行中返回所需的时间与之前一样长，但现在我们看到了新的测试。具体来说，套件现在正在等待并测试威尔玛向用户发送的消息。现在让我们添加更多测试以完成测试套件。
- en: Add Tests for Avatars, Sign-Out, and Signed-Out State
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为头像、注销和注销状态添加测试
- en: 'We’ll now complete our test suite by adding the four remaining tests from our
    plan. Again, we use deferred objects to ensure certain events are received before
    we allow one test to proceed to another. [Listing B.12](#app02list12) shows the
    additional tests. Changes are shown in **bold**:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过添加计划中的剩余四个测试来完成我们的测试套件。同样，我们使用延迟对象来确保在允许一个测试继续到另一个测试之前，某些事件已被接收。[列表
    B.12](#app02list12) 展示了额外的测试。所有更改都以**粗体**显示：
- en: Listing B.12\. Additional tests—webapp/public/nodeunit_suite.js
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.12\. 额外测试—webapp/public/nodeunit_suite.js
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we run our test suite (`nodeunitnodeunit_suite.js`) we should see output
    like so:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的测试套件（`nodeunitnodeunit_suite.js`）时，我们应该看到如下输出：
- en: '![](392fig01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](392fig01.jpg)'
- en: We’ve completed the test suite according to our plan. We can run this suite
    automatically before checking updates into a repository (think “commit hook”).
    Such a practice shouldn’t slow us down but instead *accelerate* our development
    by preventing regressions and ensuring quality. This is an example of designing
    quality *into* a product instead of testing the product only after it has been
    “finished.”
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经按照我们的计划完成了测试套件。我们可以在将更新检查到存储库之前自动运行此套件（想想“提交钩”）。这种做法不应该减慢我们的进度，而应该通过防止回归并确保质量来*加速*我们的开发。这是在设计产品时将质量*融入*产品，而不是仅在产品“完成”后对其进行测试的例子。
- en: 'Alas, one glaring problem remains: the test suite currently never exits. Sure,
    the terminal shows 25 assertions being completed, but control is never returned
    to the terminal or any other calling process. This prevents us from automating
    the run of the test suite. In the next section we’ll discuss why this happens
    and what we can do about it.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个明显的问题仍然存在：当前的测试套件永远不会退出。当然，终端显示了 25 个断言已完成，但控制权从未返回到终端或任何其他调用进程。这阻止了我们自动化测试套件的运行。在下一节中，我们将讨论为什么会发生这种情况以及我们可以做什么。
- en: B.5\. Adjust SPA modules for tests
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.5\. 调整 SPA 模块以进行测试
- en: One troublesome question Node.js (and by extension, nodeunit) encounters is
    *how does it know when execution of a test suite is complete?* This is an example
    of the classic computer science *halting problem*, and isn’t trivial in any event-driven
    language. In general, Node.js considers an application complete when it can find
    no code to execute and it has no pending transactions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js（以及通过扩展，nodeunit）遇到的一个麻烦问题是*它如何知道测试套件的执行何时完成？*这是一个经典的计算机科学*停机问题*的例子，在任何事件驱动语言中都不是微不足道的。一般来说，Node.js
    认为一个应用程序完成时，它找不到要执行的代码，并且没有挂起的交易。
- en: Up to this point, our code has been designed for continuous use without consideration
    for an exit condition outside of closing the browser tab. When a tester uses mode
    2 (testing in a browser using fake data) and signs out, our Fake module starts
    a `setTimeout` in anticipation of another sign-in.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的代码是为连续使用而设计的，没有考虑到关闭浏览器标签之外的退出条件。当测试者使用模式 2（在浏览器中使用假数据进行测试）并登出时，我们的
    Fake 模块会启动一个 `setTimeout` 以期待另一个登录。
- en: Our test suite, like some film genres, requires an explicit ending. Therefore,
    if we intend to *ever* see our test suite complete this side of a `SIGTERM` or
    `SIGKILL`, we need to use a *test setting*.^([[6](#app02fn06)]) A test setting
    is a configuration or directive required for testing, but not required for “production”
    use.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试套件，就像一些电影类型一样，需要一个明确的结尾。因此，如果我们打算 **永远** 在 `SIGTERM` 或 `SIGKILL` 这一边看到我们的测试套件完成，我们需要使用一个
    *测试设置*。^([[6](#app02fn06)]) 测试设置是测试所需的配置或指令，但不是“生产”使用所需的。
- en: ⁶ Let’s be clear—we need this program to exit because our automated commit hook
    will rely on analysis of the exit code. No exit means no exit code, which means
    no automation, which of course is unacceptable.
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ 让我们明确——我们需要这个程序退出，因为我们的自动化提交钩子将依赖于对退出代码的分析。没有退出意味着没有退出代码，这意味着没有自动化，这当然是不可以接受的。
- en: As you might gather, we’d rather minimize test settings so we can prevent them
    from introducing their own bugs. Sometimes, they’re unavoidable. In this case
    we need a test setting to stop our Fake module from constantly respawning timers.
    This will allow our suite to exit so we can use scripts to automate the run of
    the test suite and interpret the results.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所料，我们宁愿最小化测试设置，以防止它们引入自己的错误。有时，这是不可避免的。在这种情况下，我们需要一个测试设置来阻止我们的 Fake 模块不断重新启动计时器。这将允许我们的套件退出，以便我们可以使用脚本来自动化测试套件的运行并解释结果。
- en: 'We can perform the following steps to prevent Fake from restarting timers after
    sign-out:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行以下步骤来防止 Fake 在登出后重新启动计时器：
- en: 'In the test suite, add a `true` argument to the sign-out call like so: `spa.model.people(
    true )`. This directive (which we call the *do_not_reset* flag) informs the Model
    that after a sign-out, we don’t want it to reset values in preparation for another
    sign-in.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试套件中，将 `true` 参数添加到登出调用中，如下所示：`spa.model.people( true )`。这个指令（我们称之为 *do_not_reset*
    标志）通知模型，在登出后，我们不想让它重置值以准备另一个登录。
- en: In the Model’s `spa.model.people.logout` method, accept an optional `do_not_reset`
    argument. Pass this value as the single argument to the `chat._leave` method.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模型 `spa.model.people.logout` 方法中，接受一个可选的 `do_not_reset` 参数。将此值作为单个参数传递给 `chat._leave`
    方法。
- en: In the Model’s `spa.model.chat._leave` method, accept an optional `do_not_reset`
    argument. Pass this value as the data when sending the `leavechat` message to
    the back end.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模型 `spa.model.chat._leave` 方法中，接受一个可选的 `do_not_reset` 参数。在发送 `leavechat` 消息到后端时，将此值作为数据传递。
- en: Change Fake (webapp/public/js/spa.fake.js) to ensure the `leavechat` callback
    treats the received data as a `do_not_reset` flag. When the `leavechat` callback
    sees that the data it received has the value of `true`, it should *not* restart
    timers after sign-out.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Fake (webapp/public/js/spa.fake.js) 更改为确保 `leavechat` 回调将接收到的数据视为 `do_not_reset`
    标志。当 `leavechat` 回调看到它接收到的数据值为 `true` 时，它应该 **不** 在登出后重新启动计时器。
- en: 'Though that’s more work than we’d hoped (we were looking for *no additional
    work*), this only requires minor surgery on three files. Let’s start with the
    test suite and add the `do_not_reset` directive to our `logout` method call as
    shown in [listing B.13](#app02list13). The one-word addition is shown in **bold**:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这比我们预期的要更多的工作（我们希望没有额外的任务），但这只需要对三个文件进行微调。让我们从测试套件开始，并将 `do_not_reset` 指令添加到我们的
    `logout` 方法调用中，如 [列表 B.13](#app02list13) 所示。这个单词的增加以 **粗体** 显示：
- en: Listing B.13\. Add `do_not_reset` to suite—webapp/public/nodeunit_suite.js
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.13\. 将 `do_not_reset` 添加到套件—webapp/public/nodeunit_suite.js
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let’s add the `do_not_reset` argument in the Model as shown in the following
    listing. Changes are shown in **bold**:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在模型中添加 `do_not_reset` 参数，如下列所示。更改以 **粗体** 显示：
- en: Listing B.14\. Add `do_not_reset` to the Model—webapp/public/js/spa.model.js
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.14\. 将 `do_not_reset` 添加到模型—webapp/public/js/spa.model.js
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, let’s update the Fake module to consider the `do_not_reset` directive
    when sending a `leavechat` message. Changes are shown in **bold**:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们更新 Fake 模块，使其在发送 `leavechat` 消息时考虑 `do_not_reset` 指令。更改以 **粗体** 显示：
- en: Listing B.15\. Add `do_not_reset` to Fake—webapp/public/js/spa.fake.js
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 B.15\. 将 `do_not_reset` 添加到 Fake—webapp/public/js/spa.fake.js
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After the updates, we can run `nodeunit nodeunit_suite.js` and watch the test
    suit run *and exit*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后，我们可以运行`nodeunit nodeunit_suite.js`并观察测试套件运行*并退出*：
- en: '![](395fig01.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](395fig01.jpg)'
- en: The exit code of the suite will be the number of failed assertions. Therefore
    if all the tests pass, the exit code will be 0 (we can inspect the exit code on
    Linux and Mac using `echo $?`). A script can use this exit status (and other output)
    to do things like block the deployment of a build, or send an email to a concerned
    developer or project manager.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 套件的退出代码将是失败的断言数量。因此，如果所有测试都通过，退出代码将是0（我们可以在Linux和Mac上使用`echo $?`来检查退出代码）。脚本可以使用这个退出状态（以及其他输出）来做诸如阻止构建部署，或者向相关开发者或项目经理发送电子邮件等事情。
- en: B.6\. Summary
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.6. 摘要
- en: Testing is a practice that helps us develop faster and better. A well-run project
    is designed from the start for multiple test modes, and tests are written with
    the code to help identify and resolve issues quickly and efficiently. Almost everyone
    has worked at some time on a project where each advancement seemed to come with
    a matching failure in stuff that *used* to work. Consistent, early, and well-designed
    tests can prevent regressions and facilitate rapid progress.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一种帮助我们更快、更好地开发的实践。一个运行良好的项目从一开始就被设计为支持多种测试模式，并且测试代码与代码一起编写，以帮助快速有效地识别和解决问题。几乎每个人在某个时候都曾在项目中工作过，每个进步似乎都伴随着曾经工作良好的东西的匹配失败。一致、早期和精心设计的测试可以防止回归并促进快速进步。
- en: This appendix showed four test modes and discussed how to set them up and when
    to use them. We selected nodeunit as our test framework. We were then able to
    test our Model without the use of a web browser. When we created our test suite,
    we used jQuery deferred objects and test directives to ensure our tests occurred
    in the correct sequence. Finally, we showed how to adjust modules so tests can
    be successfully run in a test environment.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录展示了四种测试模式，并讨论了如何设置它们以及何时使用它们。我们选择了nodeunit作为我们的测试框架。这样我们就可以在不使用网络浏览器的情况下测试我们的模型。在创建测试套件时，我们使用了jQuery延迟对象和测试指令来确保测试按正确的顺序执行。最后，我们展示了如何调整模块以便在测试环境中成功运行测试。
- en: We hope you found our presentation enlightening and inspirational. Happy testing!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您觉得我们的演示富有启发性和鼓舞人心。祝您测试愉快！
