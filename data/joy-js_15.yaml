- en: appendix B. Typed JavaScript<T>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B. 强类型JavaScript<T>
- en: 'As we reflect on everything that we’ve covered about JavaScript in this book,
    it’s hard to think that anything could be missing. But the web is a living, breathing
    creature, and we can count on JavaScript to continue evolving in the years to
    come. Believe it or not, I skipped many important topics so that this book could
    fit in your hands (or on your mobile device). But I felt that one of these topics
    was important to discuss, at least in a small appendix: types for JavaScript.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾这本书中关于JavaScript的所有内容时，很难想象还有什么遗漏。但网络是一个活生生的、有呼吸的生物，我们可以期待JavaScript在未来几年继续进化。信不信由你，我跳过了许多重要的话题，以便这本书能握在你的手中（或放在你的移动设备上）。但我感觉其中有一个话题很重要，至少在附录中讨论一下：JavaScript的类型。
- en: In the programming world, there’s always been the epic struggle of choosing
    between typed and untyped languages. If you’ve read this far, you’ve already made
    that decision. Type systems come in many flavors. The spectrum includes strongly
    typed, statically typed, weakly typed, optionally typed, dynamically typed, and
    many more variations. What’s the reason for picking one over the other? You can
    ask ten people and get ten different answers. Although JavaScript is and always
    will be dynamically typed, this topic has received more attention as languages
    such as TypeScript, Elm, PureScript, and Reason continue to gain momentum. Where
    does this leave JavaScript?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程世界中，一直存在着在强类型和弱类型语言之间进行史诗般的斗争。如果你已经读到这儿，你已经做出了那个决定。类型系统有很多种风味。这个光谱包括强类型、静态类型、弱类型、可选类型、动态类型以及许多其他变体。选择一种类型而不是另一种类型的原因是什么？你可以问十个人，得到十个不同的答案。尽管JavaScript始终是动态类型的，但随着像TypeScript、Elm、PureScript和Reason这样的语言继续获得动力，这个话题已经引起了更多的关注。这又把JavaScript置于何地？
- en: Fortunately, you don’t have to switch to another language; you can use pluggable
    type extensions, which are widely used in industry, particularly with React’s
    PropTypes feature.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不必切换到另一种语言；你可以使用可插拔的类型扩展，这在工业界广泛使用，尤其是在React的PropTypes特性中。
- en: Having a type system is valuable because it helps prevent certain classes of
    errors. Computers are more effective than humans at parsing structured data, and
    types are restrictions or boundaries that provide the necessary structure to your
    code. By removing the freedom of being able to assign a variable to anything you
    can imagine, the computer can do its job much more effectively before you even
    type `npm` `start`. Think of types as placing the virtual walls you use to close
    off a section of the house with your smart vacuum cleaner; the device cleans much
    better that way.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有类型系统是有价值的，因为它有助于防止某些类别的错误。计算机在解析结构化数据方面比人类更有效，类型是提供必要结构的限制或边界。通过移除将变量分配给任何你能想象的东西的自由，计算机可以在你甚至输入`npm
    start`之前更有效地完成其工作。将类型想象成用你的智能吸尘器关闭房屋某个区域的虚拟墙壁；这样设备清洁得更好。
- en: This appendix teaches you some features of the third-party, pluggable Flow type
    system for JavaScript ([https://flow.org](https://flow.org/)), which is an alternative
    to TypeScript if you want to continue using JavaScript. You’ll learn about the
    benefits that a type checker can bring to a JavaScript project and the ways to
    annotate a variety of objects in your code. Even though I’m using Flow as a reference
    implementation for types, the library itself is not what’s important; the concepts
    are. The specific type annotations provided by Flow look similar to the ones provided
    by TypeScript, as well as ones you can find in some early TC39 strawman proposals.
    It’s likely that what you’ll learn here will be compatible with any upcoming proposal
    that JavaScript decides to adopt.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个附录教你一些关于第三方、可插拔的Flow类型系统（[https://flow.org](https://flow.org/)）的特性，如果你想在继续使用JavaScript的同时，它是一个TypeScript的替代品。你将了解类型检查器可以为JavaScript项目带来的好处以及如何在代码中注释各种对象。尽管我使用Flow作为类型的一个参考实现，但库本身并不重要；重要的是概念。Flow提供的特定类型注释看起来与TypeScript提供的类似，以及你可以在一些早期的TC39
    strawman提案中找到的类型注释。你在这里学到的很可能会与JavaScript决定采纳的任何即将到来的提案兼容。
- en: It’s a bit uncommon for a book on JavaScript to talk about static types, but
    this book isn’t your conventional JavaScript book, after all.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一本关于JavaScript的书来说，谈论静态类型有点不常见，但毕竟这本书不是一本常规的JavaScript书。
- en: B.1 First, what?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.1 首先，是什么？
- en: A bit of history is in order. JavaScript is considered to be the poster child
    for dynamically typed languages. So you’d be surprised to find out that a type
    system almost landed in JavaScript many years ago. The ECMAScript 4 proposal ([http://mng.bz/NYe7](http://mng.bz/NYe7))
    defined a type system for ECMAScript-based languages that JavaScript could adopt
    naturally. If you skim the document, you’ll find many similarities with the contents
    of this appendix. The type system was never officially released, however, due
    to (among other things) a lack of consensus among the big players of the time,
    including Macromedia, Netscape, and Microsoft.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一点历史背景。JavaScript 被认为是动态类型语言的典范。所以你会发现，多年前几乎在 JavaScript 中实现了一个类型系统。ECMAScript
    4 提案([http://mng.bz/NYe7](http://mng.bz/NYe7))为基于 ECMAScript 的语言定义了一个类型系统，JavaScript
    可以自然地采用。如果你浏览一下文档，你会发现其中许多内容与附录中的内容相似。然而，由于（包括 Macromedia、Netscape 和 Microsoft
    在内）当时的大玩家之间缺乏共识，这个类型系统从未正式发布。
- en: But the conversation didn’t stop there. For some time now, other big web companies
    have tried to take a stab at this feature outside the standardization committees
    by creating new languages that compile to JavaScript or by pushing open source
    libraries that extend JavaScript syntax with annotations (such as metaprogramming)
    that a type checker tool can verify.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但对话并没有就此结束。在一段时间内，其他大型网络公司一直在尝试通过创建编译到 JavaScript 的新语言或通过推动开源库来扩展 JavaScript
    语法（例如，使用元编程等注释），这些注释可以被类型检查工具验证，从而在标准化委员会之外尝试这个功能。
- en: 'As you know, JavaScript is a weak, dynamically typed language. Now let’s add
    a third dimension: optionally typed (also known as pluggable types). Let’s unpack
    the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，JavaScript 是一种弱类型、动态类型的语言。现在让我们增加一个维度：可选类型（也称为可插拔类型）。让我们来分解以下内容：
- en: '*Weak*—refers to the programming language’s ability to convert data types implicitly
    depending on use. It’s an optimistic approach to figuring out what the developer
    is trying to do. Here are a few examples (and see whether you can guess the last
    one):'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*弱类型*—指的是编程语言根据使用情况隐式转换数据类型的能力。这是一种乐观的方法，用来推测开发者试图做什么。以下是一些例子（看看你是否能猜出最后一个）：'
- en: '[PRE0]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Dynamic*—Variable types are enforced at runtime instead of at compile time.
    The same variable can hold values of different types. Here’s an example:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态类型*—变量类型在运行时而不是在编译时强制执行。同一个变量可以持有不同类型的值。以下是一个例子：'
- en: '[PRE1]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Optionally (pluggable) typed*—A pluggable type system is a collection of meta-annotations
    that you can bind to an optional type checker. In basic terms, the type system
    should not get in your way if you opt out; it’s purely optional. Also, you should
    be able to add type information progressively in places where you need it. Optional
    types are not an all-or-nothing deal. Section B.3 talks about some of the type
    annotations that you can use.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可选（可插拔）类型*—一个可插拔的类型系统是一组你可以绑定到可选类型检查器的元注释。简单来说，如果你选择不使用，类型系统不应该妨碍你；它是纯可选的。此外，你应该能够在需要的地方逐步添加类型信息。可选类型不是全有或全无的交易。B.3
    节讨论了你可以使用的一些类型注释。'
- en: 'JavaScript’s type system is dynamic and weak, accompanied by a set of primitives
    you know well: `string`, `boolean`, `number`, `symbol`, `null`, `function`, and
    `undefined`. Don’t forget the quirky handling of `null`, which resolves to `object`.
    These primitive types don’t define any properties. So you might ask how this operation
    is possible: `3.14159` `.toFixed(2)`. Invoking a method is possible because you
    can use their corresponding object wrappers—`String`, `Number`, and so on—to work
    with these types directly or indirectly. By *indirectly*, I mean that code written
    as `''0''.repeat(64)` gets automatically wrapped (boxed) and converted to `new`
    `String(''0'').repeat(64)`, which does let you call methods.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的类型系统是动态和弱的，伴随着你熟悉的几个原始类型：`string`、`boolean`、`number`、`symbol`、`null`、`function`
    和 `undefined`。不要忘记对 `null` 的奇特处理，它解析为 `object`。这些原始类型不定义任何属性。所以你可能想知道这个操作是如何可能的：`3.14159`
    `.toFixed(2)`。调用一个方法是因为你可以使用它们相应的对象包装器—`String`、`Number` 等—直接或间接地与这些类型一起工作。通过
    *间接地*，我指的是以 `'0'.repeat(64)` 编写的代码会自动包装（装箱）并转换为 `new` `String('0').repeat(64)`，这确实让你可以调用方法。
- en: With this basic set of types, we’ve been able to build an infinite amount of
    applications. These types are provided by the system; in JavaScript, you have
    no way to define your own custom data types. You can fix that situation by overlaying
    a type system, however.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个基本类型集，我们已经能够构建无限多的应用程序。这些类型由系统提供；在JavaScript中，你无法定义自己的自定义数据类型。然而，你可以通过叠加一个类型系统来解决这个问题。
- en: In this appendix, you’ll be using the Flow library from Facebook. Like Babel,
    Flow plugs into your development tool belt. This library is simple to install
    and run, so I won’t bore you with the details. Rather, I’ll focus on the concepts,
    beginning by describing the benefits that types add to your JavaScript code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，你将使用Facebook的Flow库。像Babel一样，Flow可以集成到你的开发工具链中。这个库易于安装和运行，所以我不想让你感到无聊，细节我就不展开了。相反，我将专注于概念，首先描述类型为你的JavaScript代码带来的好处。
- en: B.2 Benefits and drawbacks of statically typed JavaScript
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.2 静态类型JavaScript的优缺点
- en: In this section, I briefly go over some of the general benefits of programming
    with types. The goal is not to go in depth into this subject; tons of other books
    do a much more thorough job. The goal, rather, is to give you an idea of the benefits
    of using types to write enterprise-scale applications and how types fit under
    the modern JavaScript development umbrella.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将简要介绍使用类型编程的一些一般性优点。目标不是深入探讨这个主题；许多其他书籍都做了更彻底的工作。相反，目标是让你了解使用类型编写企业级应用程序的优点，以及类型如何适应现代JavaScript开发环境。
- en: I’m sure we’ve all asked ourselves at some point whether static wins over dynamic
    typing. The debate is probably evenly split. It’s important to mention that good
    coding practices can go a long way; by following best practices and using the
    language properly, you can write JavaScript code that is easy to read and reason
    about despite not having type hints of any kind.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信我们都在某个时刻问过自己，静态类型是否优于动态类型。这场辩论可能平分秋色。重要的是要提到，良好的编码实践可以走得很远；通过遵循最佳实践并正确使用语言，即使没有任何类型的提示，你也可以编写易于阅读和推理的JavaScript代码。
- en: Without a doubt, type information is incredibly valuable because it gives you
    code correctness—a measure of how your code adheres to the protocols and interfaces
    that you designed. (Are all your input and output types compatible, for example,
    and do your objects have the correct shape?) The importance of types stems from
    their ability to restrict and make your code more rigid and structured. These
    features are good, especially in JavaScript, in which you’re free to do anything
    and everything. As Reginald Braithwaite eloquently put it, “The strength of JavaScript
    is that you can do anything. The weakness is that you will.”
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，类型信息非常有价值，因为它为你提供了代码正确性——衡量你的代码遵循你设计的协议和接口的程度。（例如，所有输入和输出类型是否兼容，你的对象是否有正确的形状？）类型的重要性源于它们能够限制并使你的代码更加严格和结构化。这些特性在JavaScript中尤其有用，因为你可以自由地做任何事。正如Reginald
    Braithwaite巧妙地所说，“JavaScript的强大之处在于你可以做任何事情。弱点在于你将会。”
- en: To set the tone, the next listing shows our proof-of-work algorithm with type
    information.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设定基调，接下来的列表展示了我们的带有类型信息的证明工作算法。
- en: Listing B.1 Proof-of-work code with type information
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表B.1 带类型信息的证明工作代码
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ proofOfWork is a function of type Block => Block.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ proofOfWork是一个类型为Block => Block的函数。
- en: ❷ hashPrefix is a variable of type string.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ hashPrefix是一个类型为string的变量。
- en: Notice the “`:` `<type>`” labels in front of all variables and function signatures
    in listing B.1\. Functions and their return values should be typed as the input
    parameters. In this case, `proofOfWork` is a function that takes a `Block` object
    and returns a `Block` object—in short, a function from `Block` to `Block` or `Block`
    => `Block`. By having a clear contract, you can build correct expectations for
    how your APIs are meant to be used. Technically speaking, you can catch a lot
    of potential errors in the flow of your code at an early stage. Although this
    example may seem to be overkill for simple scripts or rapid prototype code, the
    benefits of a type system are obvious as the size of your code increases and refactoring
    becomes more complex. Also, IDEs can provide smart suggestions and checks that
    can make you more confident and productive.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意列表B.1中所有变量和函数签名前面的“`:` `<type>`”标签。函数及其返回值应该与输入参数进行类型匹配。在这种情况下，`proofOfWork`是一个接受`Block`对象并返回`Block`对象的函数——简而言之，一个从`Block`到`Block`或`Block`
    => `Block`的函数。通过有一个清晰的合约，你可以为你的API应该如何使用建立正确的预期。从技术上讲，你可以在代码流中早期捕捉到很多潜在的错误。尽管这个例子对于简单的脚本或快速原型代码来说可能有些过度，但随着代码规模的增加和重构变得更加复杂，类型系统的优势是显而易见的。此外，IDE可以提供智能建议和检查，这可以使你更有信心并提高生产力。
- en: Another benefit of types is that a compiler can trace through and look for inconsistencies
    in the inputs and outputs of your functions. So if you change the contract of
    some function from a major refactoring, you can be notified right away of any
    errors without having to run the function. Compilers help you catch hidden bugs
    that can occur as a result of type coercion. Your code might behave as though
    it works locally due to some hacky coercion rules (such as converting a string
    to a number or a truthy Boolean result), but most likely, it will fail with production-level
    use patterns. By that time, it’s too late to fix any problems.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 类型的另一个好处是编译器可以追踪并查找函数输入和输出的不一致性。所以，如果你因为重大重构而更改某些函数的合约，你将立即收到任何错误的通知，而无需运行该函数。编译器帮助你捕捉到由于类型强制而产生的隐藏bug。你的代码可能因为某些狡猾的强制规则（例如将字符串转换为数字或真值布尔结果）而表现得好像在本地工作，但很可能会在生产级使用模式中失败。到那时，修复任何问题都太晚了。
- en: Multiple studies and surveys suggest that type information reduces the number
    of bugs by at least 15%. In fact, the statically typed programming language Elm
    claims to have no runtime execution errors, ever. (By the way, Elms compiles to
    JavaScript.)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 多项研究和调查表明，类型信息至少可以减少15%的bug数量。事实上，静态类型编程语言Elm声称从未有过运行时执行错误。（顺便说一句，Elm编译成JavaScript。）
- en: The fact that you code with JavaScript doesn’t mean you don’t care about types,
    however. You always need to know the type of the variable you’re working with
    to determine how to use it, which causes unnecessary burden on your already-overloaded
    brain. We JavaScript developers are forced to write lots of tests that cover as
    many paths of the code as possible to free us from carrying the entire structure
    of our applications in our heads.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你用JavaScript编码并不意味着你不关心类型。你总是需要知道你正在处理的变量的类型，以确定如何使用它，这会给你的已经超负荷的大脑带来不必要的负担。我们JavaScript开发者被迫编写大量的测试，尽可能覆盖代码的各个路径，以便从在脑海中携带整个应用程序结构中解放出来。
- en: NOTE To clarify, a type system is not a replacement for well-written tests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了澄清，类型系统不是良好编写的测试的替代品。
- en: Types shine beyond quick prototype scripts. For large enterprise development,
    the perceived additional typing time they add is probably much less than what
    you’d spend writing comments to explain how a function is used. Like tests, types
    help you document your code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 类型在快速原型脚本之外也能发光。对于大型企业开发来说，它们增加的感知打字时间可能远小于你用来编写注释解释函数如何使用的时间。就像测试一样，类型帮助你记录代码。
- en: 'Here’s a list of some of the benefits you gain from type checking, in no particular
    order:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个列表，列出了从类型检查中获得的一些好处，不分先后顺序：
- en: '*Self-documentation* —Types guide development and can even make you more productive
    by allowing IDEs to infer more information about your code. If you see a variable
    named `str`, for example, does it refer to a string or to an observable stream?
    You’ll never know unless you have full context or crack open the code. You can
    use JSDoc to add documentation, which helps the IDE achieve some guidance, but
    it’s limited, and no check is being done.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自文档化* —类型指导开发，甚至可以通过允许 IDE 推断更多关于你的代码的信息来使你更有效率。例如，如果你看到一个名为 `str` 的变量，它是字符串还是可观察的流？除非你有完整的上下文或打开代码，否则你永远不会知道。你可以使用
    JSDoc 添加文档，这有助于 IDE 获得一些指导，但它有限，并且没有进行检查。'
- en: '*Structured, rigid code* —Types are your application’s blueprint. JavaScript’s
    object system is notorious for being flexible and malleable, allowing you to add
    properties to and remove properties from an object at runtime. This feature makes
    code hard to reason about, as you have to keep track of when objects might change
    state. Ease the cognitive load by defining the object’s shape ahead of time. This
    practice will make you think twice about mishandling object properties, and if
    you do, the type checker might warn you.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结构化、严格的代码* —类型是应用程序的蓝图。JavaScript 的对象系统因其灵活性和可塑性而臭名昭著，允许你在运行时向对象添加属性或从对象中删除属性。这个特性使得代码难以推理，因为你必须跟踪对象何时可能改变状态。通过提前定义对象的形状来减轻认知负担。这种做法会让你在处理对象属性时三思而后行，如果你确实处理不当，类型检查器可能会警告你。'
- en: '*No API misuse* — Because you can check inputs and outputs, you can avoid misusing
    or abusing APIs. Flow comes with type definitions for JavaScript core APIs out
    of the box. Without it, a subtle error occurs where `new` `Array("2")` is accepted
    when you meant to create an array of size `2`, as in `new` `Array(2)`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*避免 API 误用* —因为你可以检查输入和输出，所以你可以避免误用或滥用 API。Flow 默认为 JavaScript 核心API提供类型定义。没有它，当你想创建大小为
    `2` 的数组时，`new Array("2")` 这样的微妙错误会被接受，而实际上应该是 `new Array(2)`。'
- en: Also, the type system can prevent you from calling functions with fewer arguments
    than it’s declared to accept. The check for `Math.pow(2)` fails because you’re
    missing the second exponent parameter, for example.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，类型系统可以防止你调用比声明接受的参数更少的函数。例如，对 `Math.pow(2)` 的检查失败，因为你缺少第二个指数参数。
- en: '*Autocheck of invariants* —An *invariant* is an assertion that must always
    hold true during the life cycle of an object. An example is “A block’s difficulty
    value must not exceed 4.” You’d have to write code to check this invariant at
    the constructor each time or use the type system to check it for you.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不变量的自动检查* —一个 *不变量* 是一个在对象的整个生命周期中必须始终为真的断言。一个例子是“一个区块的难度值不能超过 4。”你必须在构造函数中每次都编写代码来检查这个不变量，或者使用类型系统来帮你检查。'
- en: '*Refactoring with greater confidence* —Types can ensure that contracts are
    not violated by moving or changing the structure of your code.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更有信心的重构* —类型可以确保在移动或更改代码结构时不会违反合约。'
- en: '*Improved performance* —Types help you write code that is easier to optimize
    in some JavaScript engines, such as V8\. As you know, JavaScript allows you to
    call functions with as many arguments as you want. That’s not the case if you
    use types. The reason is that the restrictions imposed by the type checker ensure
    that functions remain monomorphic (guaranteed to have one input type) or at least
    polymorphic (two to four input types). The fewer input type variations a compiler
    has to account for on a given function, the better you can use the fast inline
    caches present inside the JavaScript engine to generate the most optimal performance.
    It’s easier to optimize storage on an array of equally typed values (all strings,
    for example) than it is for an array of two or three types.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*改进的性能* —类型帮助你编写在 V8 等一些 JavaScript 引擎中更容易优化的代码。正如你所知，JavaScript 允许你调用你想要的任意数量的参数。如果你使用类型，情况就不同了。原因是类型检查器施加的限制确保函数保持单态性（保证有一个输入类型）或至少多态性（两个到四个输入类型）。编译器在特定函数上必须考虑的输入类型变化越少，你就能更好地利用
    JavaScript 引擎内现有的快速内联缓存来生成最佳性能。优化一个类型相同的数组（例如所有都是字符串）的存储比优化包含两种或三种类型的数组要容易得多。'
- en: '*Reduced potential for runtime execution errors* —Types can free you from a
    whole class of errors that usually manifest as `TypeError` and `ReferenceError``.`
    These errors can slip into production systems undetected and are hard to debug.
    Table B.1 summarizes some of these issues.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*减少运行时执行错误的可能性* —类型可以帮助你避免一类通常表现为 `TypeError` 和 `ReferenceError` 的错误。这些错误可能未经检测就进入生产系统，并且难以调试。表
    B.1 总结了一些这些问题。'
- en: Table B.1 Errors preventable by type checking. All these errors can be caught
    during development instead of at runtime.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表 B.1 可通过类型检查避免的错误。所有这些错误都可以在开发期间而不是在运行时捕获。
- en: '| Description | Code | Runtime error | Type check |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 描述 | 代码 | 运行时错误 | 类型检查 |'
- en: '| Calling an `undefined` property | `let foo = undefined;``foo();` | `TypeError:
    foo` is not a function | Cannot call `foo` because `undefined` is not a function
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 调用一个 `undefined` 属性 | `let foo = undefined;` `foo();` | `TypeError: foo is
    not a function` | 不能调用 `foo`，因为 `undefined` 不是一个函数 |'
- en: '| Using an invalid LHS value | `function foo() {}``if(foo() = ''bar'') {``}`
    | `ReferenceError:` Invalid left side in assignment | Invalid left side in assignment
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 使用无效的 LHS 值 | `function foo() {}` `if(foo() = ''bar'') {}` | `ReferenceError:`
    Invalid left side in assignment | 赋值左侧无效 |'
- en: '| Reading properties from `null` | `let someVal = null;``console.log(someVal`.foo);
    | `TypeError:` Cannot read property `''foo''` of `null` | Cannot get `someVal.foo`
    because property `foo` is missing in `null` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 从 `null` 读取属性 | `let someVal = null;` `console.log(someVal.foo);` | `TypeError:`
    Cannot read property `''foo''` of `null` | 不能获取 `someVal.foo`，因为 `null` 中缺少属性
    `foo` |'
- en: '| Setting properties on `null` | `let someVal = null;``someVal.foo = 1;` |
    `TypeError:` Cannot set property `''foo``''` of `null` | `TypeError:` Cannot set
    property `''foo``''` of `null` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 在 `null` 上设置属性 | `let someVal = null;` `someVal.foo = 1;` | `TypeError:`
    Cannot set property `''foo''` of `null` | `TypeError:` Cannot set property `''foo''`
    of `null` |'
- en: As mentioned earlier, the language Elm claims that static typing is one of the
    reasons why it has no runtime execution errors. This won’t be the case for JavaScript,
    but at least you can see that a large chunk of errors are preventable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Elm 语言声称静态类型是它没有运行时执行错误的原因之一。对于 JavaScript 来说，情况并非如此，但至少你可以看到，大量错误是可以预防的。
- en: 'For the sake of argument, here are some drawbacks of using types:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了辩论的目的，以下是使用类型的一些缺点：
- en: '*Steep learning curve* —In a dynamic language, some concepts can be expressed
    with simple code. Adding type information to functions can be daunting because
    to make this information useful, you need to capture the variations of input and
    outputs that a function, such as `curry`, can handle. This task requires advanced
    understanding of the type system. Also, types for a function that relies mostly
    on data present in its lexical scope (closure) are not terribly useful.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习曲线陡峭* —在动态语言中，一些概念可以用简单的代码表达。向函数添加类型信息可能令人望而却步，因为要使这些信息有用，你需要捕获函数（如 `curry`）可以处理的输入和输出的变化。这项任务需要高级的类型系统理解。此外，对于主要依赖于其词法作用域（闭包）中存在的数据的函数类型，这些类型并不非常有用。'
- en: '*Not portable* —At the moment, JavaScript does not define any formal proposal
    for a type system. Such a proposal may be a reality in the distant future, but
    we’re quite far from one. Although there is some general consensus about the look
    and feel, as demonstrated by some of the leading tools, the type system is still
    vendor-specific.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不可移植* —目前，JavaScript 没有定义任何正式的类型系统提案。这样的提案可能在遥远的未来成为现实，但我们离它还很远。尽管一些领先工具展示了关于外观和感觉的一些共识，但类型系统仍然是供应商特定的。'
- en: '*Poor error reporting* —Some type errors can be opaque and hard to trace, especially
    when implementing advanced type signatures.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误报告不佳* —一些类型错误可能难以理解且难以追踪，尤其是在实现高级类型签名时。'
- en: Now that you understand the benefits and drawbacks of adding types, let’s look
    at some of Flow’s type annotations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了添加类型的利弊，让我们来看看 Flow 的类型注释。
- en: B.3 Type annotations
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.3 类型注释
- en: Types are compile time metadata that can describe runtime values. Although Flow
    has the capability to infer the types of your variables by analyzing your code,
    it’s still helpful to annotate it at key places to enable a much deeper analysis.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是编译时元数据，可以描述运行时值。尽管 Flow 能够通过分析你的代码来推断变量的类型，但在关键位置进行注释仍然很有帮助，以便进行更深入的分析。
- en: Flow is complete and extensive, and it offers a wide variety of type annotations,
    of which I’ll discuss a few. The Flow compiler analyzes files that have the `//@flow`
    pragma comment at the top. After Flow checks your files, and if everything looks
    good, you need to remove these annotations (because they are not valid JavaScript
    at the moment) by using another library or any transpiler, such as Babel.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Flow是完整且广泛的，它提供了各种类型注解，其中我将讨论一些。Flow编译器分析顶部带有`//@flow`指令注释的文件。在Flow检查您的文件后，如果一切看起来都很好，您需要使用另一个库或任何转译器（如Babel）来删除这些注解（因为它们目前不是有效的JavaScript）。
- en: 'I can’t cover the myriad type annotations available in Flow, but these six
    are used frequently in daily coding:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法涵盖Flow中可用的众多类型注解，但以下六种在日常编码中经常使用：
- en: Class types
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类类型
- en: Interface types
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口类型
- en: Object types
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象类型
- en: Function types
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数类型
- en: Generic types
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类型
- en: Union types
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合类型
- en: B.3.1 Class types
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3.1 类类型
- en: 'As in other statically typed, object-oriented languages, classes operate both
    as values and as types. Here’s an example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他静态类型、面向对象的语言中，类既作为值也作为类型操作。以下是一个示例：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This form of typing is known as nominal typing. You can also type the methods
    and fields inside the class, which is where you get the most benefit. The next
    listing shows an example with the `Block` class. I’ve omitted some parts for demonstration
    purposes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的表示称为命名类型。您还可以对类内部的方法和字段进行类型注解，这是您获得最大好处的地方。下一个列表显示了`Block`类的示例。为了演示目的，我省略了一些部分。
- en: Listing B.2 `Block` class with type information
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表B.2 带有类型信息的`Block`类
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Uses my own custom type called “Difficulty”
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用我自定义的名为“难度”的类型
- en: ❷ “mixed” can be used as a placeholder for an array that can hold any type of
    object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ “mixed”可以用作可以包含任何类型对象的数组的占位符。
- en: The type system will ensure that the properties of this class are used properly
    and assigned to the correct values. The line
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统将确保此类属性被正确使用并分配给正确的值。该行
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'is valid, whereas this one issues a type warning:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 是有效的，而这一种会发出类型警告：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the type checker prevents me from using `string` in place of
    `number` in the constructor. Classes like `Block` naturally become types and are
    processed by Flow accordingly. In section B.3.2, we take a look at interface types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，类型检查器阻止我在构造函数中使用`string`代替`number`。像`Block`这样的类自然成为类型，并由Flow相应处理。在B.3.2节中，我们将查看接口类型。
- en: B.3.2 Interface types
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3.2 接口类型
- en: An interface is like a class, but it applies more broadly and has no implementation.
    Interfaces capture a set of reusable properties that multiple classes can implement.
    Remember from chapter 7 that our main model objects (`Block`, `Transaction`, and
    `Blockchain`) implemented a custom `[Symbol('toJson')]` property as a hook for
    a custom JSON serialization. This check happens at runtime, however, and nothing
    verifies whether an object implements this contract until you run the algorithm.
    Interfaces are a much better solution to this problem. Let’s model the same solution
    for which we used symbols in chapter 7, this time using interfaces, as shown in
    the next listing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接口就像一个类，但应用范围更广且没有实现。接口捕获了一组可重用的属性，多个类可以实现。记住第7章中，我们的主要模型对象（`Block`、`Transaction`和`Blockchain`）实现了一个自定义的`[Symbol('toJson')]`属性作为自定义JSON序列化的钩子。然而，这个检查是在运行时发生的，并且没有任何东西会在您运行算法之前验证对象是否实现了此协议。接口是解决这个问题的更好方案。让我们为第7章中使用符号的相同解决方案建模，这次使用接口，如下一个列表所示。
- en: Listing B.3 Using interfaces instead of symbols
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表B.3 使用接口而不是符号
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Block is required to provide implementation of the interface methods from
    which it inherits.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `Block`必须提供从其继承的接口方法的实现。
- en: 'Failing to provide the implementation results in the following type error:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 未提供实现会导致以下类型错误：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Aside from classes and interfaces, object literals can also be typed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类和接口之外，对象字面量也可以进行类型注解。
- en: B.3.3 Object types
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3.3 对象类型
- en: 'As you saw earlier, you can assign an object the type of the class of which
    it’s an instance. Another option is to describe the structure or shape annotated
    when the object is created. This form of typing applies to object literals. Recall
    from chapter 4 that `Money` is a constructor function that returns an object with
    properties such as `currency`, `amount`, `equals`, `toString`, `plus`, and `minus`.
    We can define that data structure in the following way:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如你之前所见，你可以将对象分配给其类的类型。另一种选择是在对象创建时描述结构或形状。这种类型的声明适用于对象字面量。回想一下第4章，`Money`是一个构造函数，它返回一个具有`currency`、`amount`、`equals`、`toString`、`plus`和`minus`等属性的对象。我们可以以下述方式定义该数据结构：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`MoneyObj` describes the shape of the object resulting from calling the `Money`
    function constructor. Also, if you were to mistype the name of a property, the
    type checker will let you know right away:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoneyObj`描述了调用`Money`函数构造函数后生成的对象的形状。此外，如果你误输了属性的名称，类型检查器会立即告诉你：'
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You won’t mind this helpful hint either:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不会介意这个有用的提示：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you know, `Money` is a function object, which means that you need to describe
    both the input as well as the output. This type is known as a function type.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，`Money`是一个函数对象，这意味着你需要描述输入以及输出。这种类型被称为函数类型。
- en: B.3.4 Function types
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3.4 函数类型
- en: 'The basic structure of a function type declaration is similar to that of an
    arrow function. It describes input types, followed by fat-arrow (`=>`), followed
    by the return type:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型声明的基本结构与箭头函数类似。它描述了输入类型，然后是粗箭头（`=>`），然后是返回类型：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the case of `Money`, the constructor accepts `currency` and `amount`. If
    you were to inspect its type signature, it would look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Money`的情况下，构造函数接受`currency`和`amount`。如果你要检查其类型签名，它看起来会是这样：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s a more interesting example from our functional programming topics in
    chapter 5\. Recall that `Validation.Success` integrates the `Functor` mixin, which
    means that it has the ability to `map` functions to it. This trivial example may
    jog your memory:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个来自第5章功能编程主题的更有趣的例子。回想一下，`Validation.Success`集成了`Functor`混入，这意味着它具有将函数映射到它的能力。这个简单的例子可能会唤起你的记忆：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The next listing shows a simplified type definition for `Success`, which includes
    `Functor.map`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了`Success`的简化类型定义，其中包括`Functor.map`。
- en: Listing B.4 Static-typing a `Success` functor
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表B.4 静态类型化`Success`函子
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Unary type constructor
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一元类型构造函数
- en: ❷ map is structure-preserving. It accepts a function and returns an instance
    of the same type (Success in this case).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `map`是结构保持的。它接受一个函数并返回相同类型的实例（在这种情况下是`Success`）。
- en: Note In this appendix, I’m using a simple and concrete type definition of `map`.
    Theoretically, `map` should be defined generically for all types, also known as
    a Higher-Kinded Type (HKT), used in functional languages such as Haskell. HKTs
    require a powerful type system and are beyond what you can do with Flow and similar
    JavaScript libraries.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本附录中，我使用了一个简单具体的`map`类型定义。从理论上讲，`map`应该为所有类型（也称为高阶类型，HKT）进行泛型定义，这在像Haskell这样的函数式语言中使用。HKT需要强大的类型系统，并且超出了Flow和类似JavaScript库所能做到的。
- en: You may notice some weird annotations enclosed in comparison operators, such
    as `<T>`. These *generic* or *polymorphic types* occur often in software, especially
    when dealing with data structures and the Algebraic Data Type (ADT) pattern. Notice
    that `map` accepts a function (`T` `=>` `Z`) and returns `Success`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到一些奇怪的注释被包含在比较运算符中，例如`<T>`。这些*泛型*或*多态类型*在软件中很常见，尤其是在处理数据结构和代数数据类型（ADT）模式时。注意`map`接受一个函数（`T`
    `=>` `Z`）并返回`Success`。
- en: 'If you were to provide anything other than a function to `map`, the type checker
    would bark at you:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向`map`提供除函数之外的其他任何内容，类型检查器会向你发出警告：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The type system infers from its right-side value that `fn` is a `string`. This
    code caught that I was trying to use that value as a function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统从其右侧值推断出`fn`是一个`string`。这段代码捕捉到我试图将那个值用作函数。
- en: B.3.5 Generic types
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3.5 泛型类型
- en: Generic programming is incredibly powerful and enables any unknown type (usually
    known as `T`) to be used as a parameter to some algorithm. The algorithms you
    write might involve using different types of data structures, such as collections
    or ADTs, to be used as containers for the type of data you’re dealing with. A
    data structure that accepts a type parameter is known as a parameterized type.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型编程非常强大，它允许任何未知类型（通常称为`T`）作为某些算法的参数。你编写的算法可能涉及使用不同类型的数据结构，如集合或ADT，作为处理的数据类型的容器。接受类型参数的数据结构被称为参数化类型。
- en: 'Normally, when you code JavaScript (or any language, for that matter), you
    should stick to best practices to guide your coding effort. One example is creating
    arrays. An array, by definition, should be an indexed collection of like-typed
    items. But nothing prevents you from inserting elements of different types (other
    than the dreadful effort of writing the code to process this array). An array
    like this one is valid JavaScript:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你编写JavaScript（或任何语言，无论如何），你应该坚持最佳实践来指导你的编码工作。一个例子是创建数组。根据定义，数组应该是一个同类型项的索引集合。但没有什么可以阻止你插入不同类型的元素（除了编写处理此数组的代码的可怕努力）。这样的数组是有效的JavaScript：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I hate to see the function mapped to this array, as it probably will contain
    lots of `if`/`else` conditions trying to handle every type known in JavaScript.
    A type signature for this type of array would be `Array<mixed>`, which is unbounded
    and accepts any mix of types available in the language. Types are about restrictions,
    and in this case, restrictions are good.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我不喜欢看到这个函数映射到这个数组上，因为它可能包含大量的`if`/`else`条件，试图处理JavaScript中已知的所有类型。这种数组的类型签名将是`Array<mixed>`，它是无界的，接受语言中可用的任何类型混合。类型是关于限制的，在这种情况下，限制是有益的。
- en: Good JavaScript developers rarely mix types in the same array object, unless
    perhaps to create pairs of objects. Most of the time, we stick to the same type.
    How can you enforce this practice? You can set boundaries on the types of objects
    you accept. You could define an array of strings
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的JavaScript开发者很少在同一个数组对象中混合类型，除非可能是为了创建对象的成对。大多数时候，我们坚持使用相同的类型。你如何强制执行这种做法？你可以设定你接受的类型边界。你可以定义一个字符串数组
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'or an array of `Block` objects:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是一个`Block`对象的数组：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'At times, however, you don’t know the type of the items you’ll receive, but
    you want to benefit from type safety. Suppose that we call this type `T`. Let’s
    discuss an example with an ADT. A `Validation` container that can lift any type
    can be defined as `Validation<T>`, and the success branch would inherit this type
    as well (`Success<T>`):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你不知道你将接收到的项的类型，但你想从类型安全中受益。假设我们称这个类型为`T`。让我们通过一个ADT的例子来讨论。一个可以提升任何类型的`Validation`容器可以定义为`Validation<T>`，成功分支也会继承这个类型（`Success<T>`）：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice that I am passing the type parameter to key APIs such as `of`, `get`,
    and `map`. This technique adds type checking to every aspect of this API. Here’s
    an example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我正在将类型参数传递给`of`、`get`和`map`等关键API。这种技术将类型检查添加到这个API的每个方面。以下是一个示例：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Unfolding the container is checked as well:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 展开容器也会进行检查：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here’s an example that shows you a type violation on a mapped function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，展示了在映射函数上的类型违规：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note You may have noticed that the type checker sometimes uses the primitive
    name of a type (`number`) or the wrapped version (`Number`). This situation happens
    when the violation involves accessing a property. Because primitives don’t have
    properties, JavaScript would attempt to wrap the primitive automatically before
    invoking a method such as `toUpperCase``()`. In this case, the `Number` wrapper
    type doesn’t declare that function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可能已经注意到，类型检查器有时会使用类型的原始名称（`number`）或包装版本（`Number`）。这种情况发生在违反涉及访问属性时。因为原始类型没有属性，JavaScript会在调用方法（如`toUpperCase()`）之前自动包装原始类型。在这种情况下，`Number`包装类型没有声明该函数。
- en: Furthermore, the type checker can perform deep checks by capturing type information
    in those parameters and applying it to the flow of your code. In the case of `map`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，类型检查器可以通过捕获这些参数中的类型信息并将其应用于代码的流程来执行深度检查。在`map`的情况下
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'two type parameters are bound in this signature: `T` and `Z`. `T` is the type
    of the container’s value—`number`, in this case. `Z` stores the result and is
    inferred from the structure of your code. In this case, the type checker sees
    that `toUpperCase``()` is a method that does not appear in the shape of type `Number`
    and alerts you accordingly.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在此签名中绑定两个类型参数：`T` 和 `Z`。`T` 是容器值的类型——在本例中是 `number`。`Z` 存储结果，并从你的代码结构中推断出来。在这种情况下，类型检查器看到
    `toUpperCase()` 是一个不在 `Number` 类型形状中出现的函数，并相应地警告你。
- en: 'To show you the reach of the type checker, suppose that you were to `map` a
    second time. The environment you had on the first `map` call would transfer to
    the second call. `Z` would send its type into `T`, and the result would be captured
    once more by `Z`. Here’s an example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示类型检查器的范围，假设你再次进行 `map` 调用。第一次 `map` 调用时的环境会传递到第二次调用。`Z` 会将其类型发送到 `T`，并且结果会被
    `Z` 再次捕获。以下是一个示例：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Figure B.1 traces the inference process.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.1 追踪了推理过程。
- en: '![](../Images/B-1.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B-1.png)'
- en: Figure B.1 The sequence of `map` calls, tracing the flow of types to find an
    invalid operation (exponentiation) being performed on a string
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.1 `map` 调用的序列，追踪类型流以找到在字符串上执行的不合法操作（指数运算）
- en: As you can see in figure B.1, after the value is converted to a string on the
    first call to `map`, the second call fails because `x` gets bound to `string`
    before the code attempts to perform arithmetic.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 B.1 所示，在第一次 `map` 调用将值转换为字符串后，第二次调用失败，因为在尝试执行算术运算之前，`x` 被绑定到 `string`。
- en: 'Another compelling use case for generic programming is streams. Providing type
    semantics to stream-based code gives you the chaining power of observables as
    well as code correctness applied to your business logic. Before we look at an
    example, as a fun little exercise, let’s use the annotations we’ve learned so
    far to describe the main interfaces of a stream. Because the `Observable` class
    is already loaded, we’ll use the convention of prefixing interfaces with `I.`
    So we get `IObservable`, `Observer`, and `ISubscription`, using a mix of generic
    interfaces, object, and function types:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型编程的另一个令人信服的使用案例是流。为基于流的代码提供类型语义，你将获得可观察者的链式操作能力，以及应用于你的业务逻辑的代码正确性。在我们查看示例之前，作为一个有趣的小练习，让我们使用迄今为止学到的注解来描述流的主要接口。因为
    `Observable` 类已经加载，我们将使用在接口前加 `I.` 的约定。因此我们得到 `IObservable`、`Observer` 和 `ISubscription`，使用混合的泛型接口、对象和函数类型：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the variable having the type information `IObservable`, there’s no need
    to follow the `$` suffix convention any longer. There’s no doubt that you’re working
    with an observable. In this example, the type `T` bound to `number` flows through
    the entire `Observable` declaration, and the type checker can test it at every
    step of the pipeline:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量具有 `IObservable` 类型的信息时，不再需要遵循 `$` 后缀约定。毫无疑问，你正在处理一个可观察者。在这个例子中，绑定到 `number`
    的类型 `T` 流过整个 `Observable` 声明，类型检查器可以在管道的每一步测试它：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The type system analyzes the sequence of calls and checks for compatibility
    between the observable operators and your business logic. Suppose that you inadvertently
    pass an incompatible function to one of the operators:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统分析调用序列，并检查可观察操作符与你的业务逻辑之间的兼容性。假设你无意中向操作符传递了一个不兼容的函数：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can create another flow diagram like figure B.2\. The final type annotation
    I’ll discuss is related to what we learned about in chapter 5.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建另一个类似于图 B.2 的流程图。我将讨论的最后一个类型注解与我们第 5 章学到的内容相关。
- en: '![](../Images/B-2.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B-2.png)'
- en: Figure B.2 Tracing the flow of types through the observable stream. Mapping
    `toUpper` causes a violation, as the expected event type is `number`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.2 追踪类型流通过可观察流。调用 `toUpper` 导致违规，因为预期的事件类型是 `number`。
- en: B.3.6 Union types
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3.6 联合类型
- en: A union type or choice type (such as `Validation`) signature defines a type
    that can be in one of a finite set of states at a time. You may know this type
    as an *enumeration* or *enum*. The `Block` class declares a parameter of type
    `Difficulty`. This type is a `number` that controls the amount of effort that
    the proof-of-work algorithm is required to spend. With a difficulty value of `5`,
    for example, completing the proof of work could take hours, if not days. You’d
    definitely want to control the range of possible values.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型或选择类型（如`Validation`）的签名定义了一个类型，该类型一次可以处于有限集合中的某个状态。你可能知道这种类型为枚举或`enum`。`Block`类声明了一个类型为`Difficulty`的参数。这种类型是一个`number`，它控制工作量证明算法需要花费的努力量。例如，难度值为`5`时，完成工作量证明可能需要数小时，甚至数天。你肯定想控制可能值的范围。
- en: 'To describe the possible values that this type can take, use a logical `OR`
    (`|`)operator, symbolizing union:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要描述此类型可以采取的可能值，使用逻辑`OR`（`|`）运算符，表示联合：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A value of `0` turns off proof of work and completes instantly. As you turn
    the knob higher, `proofOfWork` takes a lot more effort to run.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`的值会关闭工作量证明并立即完成。当你将旋钮调得更高时，`proofOfWork`需要更多的努力来运行。'
- en: 'Another common use case represents log levels like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的用例是表示日志级别如下：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Enumerations work seamlessly with `switch` statements, as the next listing shows.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举与`switch`语句无缝配合，如以下列表所示。
- en: Listing B.5 Using different log levels with an enum and a `switch` statement
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表B.5 使用枚举和`switch`语句的不同日志级别
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ There’s no need for a default clause because you’re guaranteed that this variable
    can be in no other state.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由于你可以保证这个变量不会处于其他任何状态，因此不需要默认条款。
- en: 'We can also use union types on custom objects. In chapter 5, we implemented
    the `Validation` ADT, which is a disjoint union with two branches: `Success` and
    `Failure`. Like `Difficulty`, the `Validation` object can be in only one of these
    two states. We can symbolize that condition in the same way. Here’s `Validation`
    with both of its branches:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在自定义对象上使用联合类型。在第5章中，我们实现了`Validation` ADT，它是一个具有两个分支的分离联合：`Success`和`Failure`。像`Difficulty`一样，`Validation`对象只能处于这两种状态之一。我们可以用相同的方式表示这种条件。以下是包含其两个分支的`Validation`：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, the `Failure` case is a much simpler type because it’s not meant
    to carry a value, which is why I used the keyword `<any>` to represent no type
    information needed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Failure`情况是一个更简单的类型，因为它不打算携带值，这就是为什么我使用关键字`<any>`来表示不需要任何类型信息。
- en: The union operator is modeling two disjointed branches of code (figure B.3).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 联合运算符正在模拟代码的两个分离分支（图B.3）。
- en: '![](../Images/B-3.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/B-3.png)'
- en: Figure B.3 Union type annotations model a logical `OR` describing two disjointed
    control flows.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图B.3 联合类型注解模型了一个描述两个分离控制流的逻辑`OR`。
- en: 'You can use this type directly or indirectly in our `Block` class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接或间接地在我们的`Block`类中使用此类型：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This variation is equivalent and works the same way:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化是等效的，并且以相同的方式工作：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In my experience, types with classes, interfaces, objects, functions, generics,
    and unions are the ones that occur most often in day-to-day code and are likely
    to be the first included in any future proposal. But you can use many other type
    annotations. I encourage you to read about this technology on your own if you
    find it interesting. A good article to start with is at [http://code.sgo.to/proposal-optional-types](http://code.sgo.to/proposal-optional-types).
    Knowing what signatures are and what they mean will still be important for communicating
    efficiently about how functions are used and composed with the rest of your code.
    The good news is that type information is not an all-or-nothing route. You can
    start to add types progressively as you become more comfortable with them.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，具有类、接口、对象、函数、泛型和联合的类型在日常代码中最为常见，并且很可能会被任何未来的提案首先包括。但你可以使用许多其他类型注解。如果你对此技术感兴趣，我鼓励你自行阅读相关内容。一篇不错的入门文章可以在[http://code.sgo.to/proposal-optional-types](http://code.sgo.to/proposal-optional-types)找到。了解签名是什么以及它们的意义对于有效地沟通函数如何与你的其他代码一起使用和组合仍然很重要。好消息是类型信息不是全有或全无的途径。随着你对它们越来越熟悉，你可以逐步开始添加类型。
- en: 'The JavaScript community has been active in this regard, developing everything
    from third-party extension libraries such as Flow to alt-JS languages such as
    Elm and PureScript. If you’re intrigued, some early proposals sitting in stage
    0 revive the types conversation that left off in the days of ECMAScript 4:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 社区在这方面一直非常活跃，从第三方扩展库如 Flow 到替代 JS 语言如 Elm 和 PureScript，无所不包。如果你对此感兴趣，一些处于
    0 阶段的早期提案重新点燃了在 ECMAScript 4 时代中断的类型讨论：
- en: '[http://mng.bz/MXDn](http://mng.bz/MXDn)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mng.bz/MXDn](http://mng.bz/MXDn)'
- en: '[http://mng.bz/aovB](http://mng.bz/aovB)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mng.bz/aovB](http://mng.bz/aovB)'
- en: Feel free to dig into these proposals if you’re interested in learning more.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多信息，请随意深入研究这些提案。
