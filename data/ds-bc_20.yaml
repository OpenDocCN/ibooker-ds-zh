- en: 16 Extracting text from web pages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16 从网页中提取文本
- en: This section covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖
- en: Rendering web pages with HTML
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML渲染网页
- en: The basic structure of HTML files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML文件的基本结构
- en: Extracting text from HTML files with the Beautiful Soup library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Beautiful Soup库从HTML文件中提取文本
- en: Downloading HTML files from online sources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从在线来源下载HTML文件
- en: The internet is a great resource for text data. Millions of web pages offer
    limitless text content in the form of news articles, encyclopedia pages, scientific
    papers, restaurant reviews, political discussions, patents, corporate financial
    statements, job postings, etc. All these pages can be analyzed if we download
    their Hypertext Markup Language (HTML) files. A *markup language* is a system
    for annotating documents that distinguishes the annotations from the document
    text. In the case of HTML, these annotations are instructions on how to visualize
    a web page.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网是文本数据的一个巨大资源。数百万个网页以新闻文章、百科全书页面、科学论文、餐厅评论、政治讨论、专利、公司财务报表、职位发布等形式提供了无限量的文本内容。如果我们下载这些网页的超文本标记语言（HTML）文件，所有这些页面都可以进行分析。*标记语言*是一种用于注释文档的系统，它将注释与文档文本区分开来。在HTML的情况下，这些注释是关于如何可视化网页的指令。
- en: Web page visualization is usually carried out using a web browser. First, the
    browser downloads the page’s HTML based on its web address, the URL. Next, the
    browser parses the HTML document for layout instructions. Finally, the browser’s
    rendering engine formats and displays all images and text per the markup specifications.
    The rendered page can easily be read by a human being.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 网页的可视化通常使用网页浏览器进行。首先，浏览器根据网页地址（URL）下载页面的HTML。接下来，浏览器解析HTML文档以获取布局指令。最后，浏览器的渲染引擎根据标记规范格式化和显示所有图像和文本。渲染后的页面可以很容易地被人类阅读。
- en: Of course, during large-scale data analysis, we don’t need to render every page.
    Computers can process document texts without requiring any visualization. Thus,
    when analyzing HTML documents, we can focus on the text while skipping over the
    display instructions. Nonetheless, we shouldn’t totally ignore the annotations—they
    can provide us with valuable information. For example, the annotated title of
    a document can summarize the document’s contents concisely. Therefore, we can
    benefit by discerning that title from an annotated paragraph in the document.
    If we can distinguish between various document parts, we can run a more informed
    investigation. Consequently, a basic knowledge of HTML structure is imperative
    for online text analysis. With this in mind, we begin this section by reviewing
    the HTML structure. Then we learn how to parse that structure using Python libraries.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在进行大规模数据分析时，我们不需要渲染每个页面。计算机可以在不需要任何可视化的情况下处理文档文本。因此，在分析HTML文档时，我们可以专注于文本，而跳过显示指令。尽管如此，我们也不应该完全忽略注释——它们可以为我们提供有价值的信息。例如，文档的注释标题可以简洁地总结文档的内容。因此，我们可以通过从文档的注释段落中区分出标题来受益。如果我们能够区分不同的文档部分，我们就可以进行更明智的调查。因此，对于在线文本分析来说，基本了解HTML结构是必不可少的。考虑到这一点，我们首先回顾HTML结构。然后我们学习如何使用Python库来解析这个结构。
- en: Note If you are already familiar with basic HTML, feel free to skip ahead to
    subsection 16.2.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您已经熟悉基本的HTML，请自由跳转到子节16.2。
- en: 16.1 The structure of HTML documents
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 HTML文档的结构
- en: 'An HTML document is composed of HTML elements. Each element corresponds to
    a document component. For instance, the document’s title is an element; every
    single paragraph in the document is also an element. The starting location of
    an element is demarcated by a start tag: for instance, the start tag of a title
    is `<title>`, and the start tag of a paragraph is `<p>`. Every start tag begins
    and ends with angled brackets, `<>`. Adding a forward slash to the tag transforms
    it into an end tag. The endpoints of most elements are demarcated by end tags:
    thus the immediate text of a title is followed by `</title>`, and the text of
    a paragraph is followed by `</p>`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文档由HTML元素组成。每个元素对应于文档的一个组件。例如，文档的标题是一个元素；文档中的每个段落也是元素。元素的起始位置由起始标签界定：例如，标题的起始标签是`<title>`，段落的起始标签是`<p>`。每个起始标签都以尖括号`<>`开始和结束。在标签中添加一个正斜杠将其转换为结束标签。大多数元素的终点由结束标签界定：因此，标题的紧随其后的文本是`</title>`，段落的文本是`</p>`。
- en: 'Shortly, we explore many common HTML tags. But first we must introduce the
    most important HTML tag: `<html>`, which specifies the start of the entire HTML
    document. Let’s utilize that tag to create a document composed of just a single
    word: *Hello*. We generate the contents of the document by coding `html_contents
    = "<html>Hello</html>"`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将探讨许多常见的HTML标签。但首先，我们必须介绍最重要的HTML标签：`<html>`，它指定了整个HTML文档的开始。让我们利用这个标签创建一个只包含单词*Hello*的文档。我们通过编码`html_contents
    = "<html>Hello</html>"`来生成文档的内容。
- en: Listing 16.1 Defining a simple HTML string
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.1 定义简单的HTML字符串
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: HTML contents are intended to be rendered in a web browser. Thus, we can visualize
    `html_contents` by saving it to a file and then loading it in a browser of our
    choice. Alternatively, we can render `html_contents` directly in an IPython Jupyter
    Notebook. We simply need to import `HTML` and `display` from `IPython.core.display`.
    Then, executing `display(HTML(html_contents))` will display the rendered output
    (figure 16.1).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: HTML内容旨在在网页浏览器中渲染。因此，我们可以通过将其保存到文件并在我们选择的浏览器中加载来可视化`html_contents`。或者，我们可以在IPython
    Jupyter Notebook中直接渲染`html_contents`。我们只需从`IPython.core.display`导入`HTML`和`display`。然后，执行`display(HTML(html_contents))`将显示渲染后的输出（图16.1）。
- en: Listing 16.2 Rendering an HTML string
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.2 渲染HTML字符串
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Defines a single-line render function to repeatedly visualize our HTML using
    less code
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个单行渲染函数，以更少的代码重复可视化我们的HTML
- en: '![](../Images/16-01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-01.png)'
- en: 'Figure 16.1 A rendered HTML document. It contains a single word: *Hello*.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 一个渲染的HTML文档。它包含一个单词：*Hello*。
- en: We’ve rendered our HTML document. It’s not very impressive—the body is composed
    of a single word. Furthermore, the document lacks a title. Let’s assign the document
    a title using the `<title>` tag. We’ll set the title to something simple, like
    *Data Science is Fun*. To do so, we begin by creating a title string that is equal
    to `"<title>Data Science is Fun</title>"`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经渲染了我们的HTML文档。它并不非常令人印象深刻——主体由一个单词组成。此外，文档缺少标题。让我们使用`<title>`标签给文档分配一个标题。我们将标题设置为像*数据科学很有趣*这样的简单内容。为此，我们首先创建一个等于`"<title>Data
    Science is Fun</title>"`的标题字符串。
- en: Listing 16.3 Defining a title in HTML
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.3 在HTML中定义标题
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we nest the title in `<html>` and `</html>` by running `html_contents =
    f"<html>{title}Hello</html>"` and then render the updated contents (figure 16.2).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过运行`html_contents = f"<html>{title}Hello</html>"`将标题嵌套在`<html>`和`</html>`中，然后渲染更新后的内容（图16.2）。
- en: '![](../Images/16-02.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-02.png)'
- en: Figure 16.2 A rendered HTML document. The document’s title does not appear in
    the rendered output—only the word *Hello* is visible.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 一个渲染的HTML文档。文档的标题没有出现在渲染输出中——只有单词*Hello*是可见的。
- en: Listing 16.4 Adding a title to the HTML string
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.4 向HTML字符串添加标题
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our output is identical to what we saw before! The title does not appear in
    the body of the rendered HTML; it only appears in the title bar of the web browser
    (figure 16.3).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果与我们之前看到的是一样的！标题没有出现在渲染的HTML的主体中；它只出现在网页浏览器的标题栏中（图16.3）。
- en: '![](../Images/16-03.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-03.png)'
- en: Figure 16.3 A web browser rendering of the HTML document. The document’s title
    appears in the browser’s title bar.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 网页浏览器渲染的HTML文档。文档的标题出现在浏览器的标题栏中。
- en: 'Despite its partial invisibility, the title provides us with very important
    information: it summarizes the contents of the document. For instance, in a job
    listing, the title directly summarizes the nature of the job. Thus, the title
    reflects vital information despite its absence from the body of the document.
    This critical distinction is commonly emphasized using `<head>` and `<body>` tags.
    The content delimited by the HTML `<body>` tag will appear in the body of the
    output. Meanwhile, `<head>` delimits vital information that is not rendered in
    the body. Let’s emphasize this distinction by nesting `title` in the *head* element
    of the HTML. We also nest the visible *Hello* in the *body* element of the contents.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它部分不可见，但标题为我们提供了非常重要的信息：它总结了文档的内容。例如，在职位列表中，标题直接总结了工作的性质。因此，尽管标题没有出现在文档的主体中，但它反映了关键信息。这种关键的区别通常通过使用`<head>`和`<body>`标签来强调。由HTML
    `<body>`标签定义的内容将出现在输出体的主体中。同时，`<head>`定义了不在主体中渲染的关键信息。让我们通过将`title`嵌套在HTML的*head*元素中来强调这种区别。我们还将可见的*Hello*嵌套在内容的*body*元素中。
- en: Listing 16.5 Adding a head and body to the HTML string
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.5 向HTML字符串添加head和body
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Occasionally, we want to display a document’s title in the body of a page. For
    instance, in a job posting, the employer will likely want to show the title of
    the job. This visualized title is referred to as the page *header* and is demarcated
    with the `<h1>` tag. Of course, that tag is nested in `<body>`, where all visualized
    content is found. Let’s add a header to the body of our HTML (figure 16.4).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想在页面的主体中显示文档的标题。例如，在招聘启事中，雇主可能希望显示工作的标题。这个可视化的标题被称为页面的 *标题*，并用 `<h1>` 标签标记。当然，这个标签嵌套在
    `<body>` 中，其中包含所有可视化的内容。让我们给我们的 HTML 主体添加一个标题（图 16.4）。
- en: Listing 16.6 Adding a header to the HTML string
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.6 向 HTML 字符串添加标题
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ HTML elements can be nested like Russian nesting dolls. Here we nest the header
    element inside the body element, and we nest both the body and title elements
    in the <html> and </html> tags.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ HTML 元素可以像俄罗斯套娃一样嵌套。在这里，我们在 body 元素内部嵌套标题元素，并将 body 和标题元素都嵌套在 `<html>` 和 `</html>`
    标签中。
- en: '![](../Images/16-04.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-04.png)'
- en: Figure 16.4 A rendered HTML document. A large header appears in the rendered
    output.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4 一个渲染的 HTML 文档。渲染输出中出现了一个大的标题。
- en: Our single word looks awkward relative to the large header. Generally, HTML
    documents are intended to have more than one word in the body—they usually contain
    multiple sentences in multiple paragraphs. As previously mentioned, such paragraphs
    are marked with a `<p>` tag.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单个单词与大的标题相比显得有些笨拙。通常，HTML 文档旨在在主体中包含多个单词——它们通常包含多个段落中的多个句子。如前所述，这样的段落用 `<p>`
    标签标记。
- en: 'Let’s add two consecutive paragraphs to our HTML (figure 16.5). We compose
    these dummy paragraphs from sequences of repeating words: the first paragraph
    features the phrase *Paragraph 0* repeating 40 times; in the subsequent paragraph,
    we replace 0 with 1.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的 HTML 中添加两个连续的段落（图 16.5）。我们通过重复的单词序列来组成这些虚拟段落：第一个段落包含重复 40 次的短语 *Paragraph
    0*；在随后的段落中，我们将 0 替换为 1。
- en: Listing 16.7 Adding paragraphs to the HTML string
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.7 向 HTML 字符串添加段落
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](../Images/16-05.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-05.png)'
- en: Figure 16.5 A rendered HTML document. Two paragraphs appear in the rendered
    output.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.5 一个渲染的 HTML 文档。渲染输出中出现了两个段落。
- en: We’ve inserted paragraph elements into our HTML. These elements are distinguishable
    by their internal text. However, their `<p>` tags are both identical; an HTML
    parser cannot easily distinguish between the first and second tags. Occasionally,
    it’s worth making the difference between tags much more pronounced (particularly
    if each paragraph is formatted uniquely). We can discriminate between `<p>` tags
    by assigning each tag a unique ID, which can be inserted directly into the tag
    brackets. For example, we identify the first paragraph as *paragraph 0* by writing
    `<p id="paragraph 0">`. The added `id` is referred to as an *attribute* of the
    paragraph element. Attributes are inserted into element start tags to track useful
    tag information.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将段落元素插入到我们的 HTML 中。这些元素可以通过它们的内部文本来区分。然而，它们的 `<p>` 标签都是相同的；HTML 解析器无法轻易区分第一个和第二个标签。偶尔，使标签之间的差异更加明显是有价值的（尤其是如果每个段落都有独特的格式）。我们可以通过为每个标签分配一个唯一的
    ID 来区分 `<p>` 标签，这个 ID 可以直接插入到标签括号中。例如，我们通过写入 `<p id="paragraph 0">` 来识别第一个段落为
    *paragraph 0*。添加的 `id` 被称为段落元素的 *属性*。属性被插入到元素开始标签中，以跟踪有用的标签信息。
- en: We now add `id` attributes to our paragraph tags. Later, we utilize these attributes
    to distinguish between the paragraphs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们向我们的段落标签添加 `id` 属性。稍后，我们将利用这些属性来区分段落。
- en: Listing 16.8 Adding `id` attributes to the paragraphs
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.8 向段落添加 `id` 属性
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: HTML attributes play many critical roles. They are especially necessary when
    linking between documents. The internet is built on top of *hyperlinks*, which
    are clickable texts that connect web pages. Clicking a hyperlink takes you to
    a new HTML document. Each hyperlink is marked by an anchor tag, `<a>`, which makes
    the text clickable. However, additional information is required to specify the
    address of the linked document. We can provide that information using the `href`
    attribute, where *href* stands for *hypertext reference*. For instance, demarcating
    text with `<a href="https://www.manning .com">` links that text to the Manning
    website.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 属性扮演着许多关键角色。它们在文档之间链接时尤其必要。互联网建立在 *超链接* 之上，超链接是连接网页的可点击文本。点击超链接会将您带到一个新的
    HTML 文档。每个超链接都由一个锚点标签 `<a>` 标记，这使得文本可点击。然而，还需要额外的信息来指定链接文档的地址。我们可以使用 `href` 属性来提供这些信息，其中
    *href* 代表 *超文本引用*。例如，使用 `<a href="https://www.manning .com">` 标记的文本会将文本链接到 Manning
    网站。
- en: Next, we create a hyperlink that reads *Data Science Bookcamp* and link that
    clickable text to the website for this book. Then we insert the hyperlink into
    a new paragraph and assign that paragraph an ID of `paragraph 3` (figure 16.6).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个链接，内容为 *Data Science Bookcamp*，并将这个可点击文本链接到这本书的网站。然后我们将这个链接插入到一个新的段落中，并给这个段落分配一个
    ID 为 `paragraph 3`（图 16.6）。
- en: '![](../Images/16-06.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-06.png)'
- en: Figure 16.6 A rendered HTML document. One more paragraph has been added to the
    rendered output, containing a clickable link to *Data Science Bookcamp*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.6 一个渲染的 HTML 文档。渲染输出中已添加一个包含到 *Data Science Bookcamp* 可点击链接的额外段落。
- en: Listing 16.9 Adding a hyperlink to the HTML string
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.9 将链接添加到 HTML 字符串中
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Creates a clickable hyperlink. Clicking the words Data Science Bookcamp will
    take a user to the book’s online URL.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个可点击的链接。点击“Data Science Bookcamp”这些词会将用户带到书的在线 URL。
- en: HTML text elements can vary in complexity. Beyond just headers and paragraphs,
    we can also visualize lists of texts in an HTML document. Suppose, for instance,
    that we wish to display a list of popular data science libraries. We start by
    defining that list in Python.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 文本元素可以具有不同的复杂度。除了标题和段落之外，我们还可以在 HTML 文档中可视化文本列表。例如，如果我们想显示一组流行的数据科学库列表，我们首先在
    Python 中定义这个列表。
- en: Listing 16.10 Defining a list of data science libraries
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.10 定义数据科学库列表
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now we demarcate every item in our list with an `<li>` tag, which stands for
    *list item*. We store these items in an `items` string.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 `<li>` 标签标记列表中的每个项目，其中 `<li>` 代表 *列表项*。我们将这些项目存储在 `items` 字符串中。
- en: Listing 16.11 Demarcating list items with an `<li>` tag.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.11 使用 `<li>` 标签标记列表项。
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we nest the `items` string in a `<ul>` tag, where `ul` stands for
    *unstructured list*. Then we append the unstructured list to the body of our HTML.
    We also insert a second header between the paragraphs and the list: *Common Data
    Science Libraries*. We use the `<h2>` tag to differentiate between the second
    header and the first (figure 16.7).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 `<ul>` 标签中嵌套 `items` 字符串，其中 `ul` 代表 *非结构化列表*。然后我们将非结构化列表添加到 HTML 的主体中。我们还在段落和列表之间插入了一个第二个标题：*常见数据科学库*。我们使用
    `<h2>` 标签来区分第二个标题和第一个（图 16.7）。
- en: Listing 16.12 Adding an unstructured list to the HTML string
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.12 将非结构化列表添加到 HTML 字符串中
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](../Images/16-07.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-07.png)'
- en: Figure 16.7 A rendered HTML document. The updated document contains a bulleted
    list of common data science libraries.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.7 一个渲染的 HTML 文档。更新的文档包含常见数据科学库的带点列表。
- en: The data science libraries have been rendered as a list of bulleted points.
    Each bullet occupies a separate line. Traditionally, such bullet points are used
    to signify diverse conceptual categories, ranging from data science libraries
    to breakfast foods to required skills in a job posting.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学库已渲染为带点的列表。每个项目点占一行。传统上，这样的项目点用于表示不同的概念类别，从数据科学库到早餐食品，再到工作招聘中所需技能。
- en: 'At this point, it’s worth noting that our HTML body is divided into two distinct
    parts: the first part corresponds to a sequence of three paragraphs, and the second
    part corresponds to the bulleted list. Typically, such divisions are captured
    using special `<div>` tags that allow frontend engineers to track the divided
    elements and customize their formatting accordingly. Usually, each `<div>` tag
    is distinguished by some attribute. If the attribute is unique to a division,
    then that attribute is an `id`; if the attribute is shared by more than one division,
    a special `class` signifier is used.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，值得注意的是我们的HTML主体被分为两个不同的部分：第一部分对应三个段落序列，第二部分对应项目符号列表。通常，这样的划分是通过特殊的`<div>`标签来实现的，这些标签允许前端工程师跟踪分割的元素并相应地自定义它们的格式。通常，每个`<div>`标签都有一个属性来区分。如果该属性对某个部分是唯一的，那么该属性就是一个`id`；如果该属性被多个部分共享，则使用特殊的`class`标识符。
- en: For consistency’s sake, we divide our two sections by nesting them in two different
    divisions. The first division is assigned a `paragraph` ID, and the second is
    assigned a `list` ID. Additionally, since both divisions only contain text, we
    assign a `text` class attribute to each one. We also add a third empty division
    to the body; we’ll update it later. The ID and class of this empty division are
    both set to `empty`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性，我们通过将它们嵌套在两个不同的分割中来划分我们的两个部分。第一个分割被分配了一个`paragraph` ID，第二个被分配了一个`list`
    ID。此外，由于这两个分割只包含文本，我们给每个都分配了一个`text`类属性。我们还添加了一个第三个空的分割到主体中；我们稍后会更新它。这个空分割的ID和类都被设置为`empty`。
- en: Listing 16.13 Adding divisions to the HTML string
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.13 向HTML字符串添加分割
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ The third division is empty, but it can still be accessed by both class and
    ID. Later, we will access this division to insert additional text.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 第三个分割是空的，但它仍然可以通过类和ID访问。稍后，我们将访问这个分割以插入额外的文本。
- en: Common HTML elements and attributes
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 常见HTML元素和属性
- en: '`<html>..</html>`—Demarcates the entire HTML document.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<html>..</html>`—标记整个HTML文档。'
- en: '`<title>..</title>`—The title of the document. This title appears in a web
    browser’s title bar but not in the browser’s rendered contents.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<title>..</title>`—文档的标题。这个标题出现在网页浏览器的标题栏中，但不在浏览器的渲染内容中。'
- en: '`<head>..</head>`—The head of the document. The information in the head is
    not intended to appear in the browser’s rendered contents.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<head>..</head>`—文档的头部。头部中的信息不打算在浏览器的渲染内容中显示。'
- en: '`<body>..</body>`—The body of the document. The information in the body is
    intended to appear in a browser’s rendered contents.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<body>..</body>`—文档的主体。主体中的信息旨在在浏览器的渲染内容中显示。'
- en: '`<h1>..</h1>`—A header in the document. It is generally rendered in large,
    bold letters.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<h1>..</h1>`—文档中的标题。它通常以大号粗体字母显示。'
- en: '`<h2>..</h2>`—A header in the document whose formatting slightly differs from
    `<h1>`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<h2>..</h2>`—文档中的标题，其格式略不同于`<h1>`。'
- en: '`<p>..</p>`—A single paragraph in the document.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<p>..</p>`—文档中的单个段落。'
- en: '`<p id="unique_id">..</p>`—A single paragraph in the document containing a
    unique `id` attribute that is not shared by any other document elements.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<p id="unique_id">..</p>`—文档中包含一个唯一`id`属性的单个段落，该属性不与其他文档元素共享。'
- en: '`<a href="http:/ /www.manning.com">..</a>`—A clickable text hyperlink. Clicking
    the text sends a user to the URL specified in the `href` attribute.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<a href="http:/ /www.manning.com">..</a>`—一个可点击的文本超链接。点击文本会将用户发送到`href`属性中指定的URL。'
- en: '`<ul>..</ul>`—An unstructured list composed of individual list items that appear
    as bullet points in a browser’s rendered contents.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ul>..</ul>`—由单个列表项组成的无结构列表，这些列表项在浏览器的渲染内容中以项目符号的形式出现。'
- en: '`<li>..</li>`—An individual list item in an unstructured list.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<li>..</li>`—无结构列表中的单个列表项。'
- en: '`<div>..</div>`—A division demarcating a specific subsection of the document.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div>..</div>`—标记文档特定子部分的分割。'
- en: '`<div class="category_class">..</div>`—A division demarcating a specific subsection
    of the document. The division is assigned a category class by way of the `class`
    attribute. Unlike a unique ID, this class can be shared across other divisions
    in the HTML.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div class="category_class">..</div>`—标记文档特定子部分的分割。该分割通过`class`属性分配了一个类别类。与唯一的ID不同，这个类可以在HTML的其他分割中共享。'
- en: We’ve made many changes to our `html_contents` string. Let’s review its altered
    contents.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`html_contents`字符串进行了许多修改。让我们回顾其修改后的内容。
- en: Listing 16.14 Printing the altered HTML string
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.14 打印修改后的HTML字符串
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The printed output is a mess! The HTML contents are nearly unreadable. Also,
    extracting individual elements from `html_contents` is exceedingly difficult.
    Imagine if we wanted to extract the title of the HTML document: we’d need to first
    split `html_ contents` on the `>` bracket. Then we’d have to iterate over the
    split results, stopping at the string that’s equal to `<title`. Next, we’d need
    to go one index over and extract the string containing the title’s text. Finally,
    we’d have to clean the title string by splitting on the remaining `<` bracket.
    This convoluted title-extraction process is illustrated next.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的输出一团糟！HTML内容几乎无法阅读。此外，从`html_contents`中提取单个元素极其困难。想象一下，如果我们想提取HTML文档的标题：我们需要首先在`>`括号上分割`html_contents`。然后，我们必须遍历分割结果，直到找到等于`<title`的字符串。接下来，我们需要向前移动一个索引并提取包含标题文本的字符串。最后，我们必须通过在剩余的`<`括号上分割来清理标题字符串。这个复杂的标题提取过程将在下面进行说明。
- en: Listing 16.15 Extracting the HTML title using basic Python
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.15 使用基本的Python提取HTML标题
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Iterates over each substring that follows >
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 遍历每个跟随`>`的子字符串
- en: ❷ The substring ends on the title start tag. Thus, the next substring equals
    the title.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 子字符串在标题开始标签处结束。因此，下一个子字符串等于标题。
- en: Is there a cleaner way to extract elements from HTML documents? Yes! We don’t
    need to manually parse the documents. Instead, we can use the external Beautiful
    Soup library.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有一种更干净的方法可以从HTML文档中提取元素？是的！我们不需要手动解析文档。相反，我们可以使用外部的Beautiful Soup库。
- en: 16.2 Parsing HTML using Beautiful Soup
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 使用Beautiful Soup解析HTML
- en: We start by installing the Beautiful Soup library. Then we import the `BeautifulSoup`
    class from `bs4`. Following a common convention, we import `BeautifulSoup` as
    simply `bs`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先安装Beautiful Soup库。然后从`bs4`导入`BeautifulSoup`类。遵循一个常见的约定，我们将`BeautifulSoup`简单地导入为`bs`。
- en: Note Call `pip install bs4` from the command line terminal to install the Beautiful
    Soup library.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 从命令行终端调用`pip install bs4`来安装Beautiful Soup库。
- en: Listing 16.16 Importing the `BeautifulSoup` class
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.16 导入`BeautifulSoup`类
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We now initialize the `BeautifulSoup` class by running `bs(html_contents)`.
    In keeping with convention, we assign the initialized object to a `soup` variable
    (listing 16.17).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过运行`bs(html_contents)`初始化`BeautifulSoup`类。按照惯例，我们将初始化的对象分配给`soup`变量（列表16.17）。
- en: Note By default, the `bs` class uses Python’s built-in HTML parser to extract
    the HTML contents. However, more efficient parsers are available through external
    libraries. One popular library is called lxml, which can be installed by running
    `pip install lxml`. After installation, the lxml parser can be used during `bs`
    initialization. We simply need to execute `bs(html_contents, 'lxml')`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 默认情况下，`bs`类使用Python的内置HTML解析器来提取HTML内容。然而，通过外部库可以获得更高效的解析器。一个流行的库叫做lxml，可以通过运行`pip
    install lxml`来安装。安装后，lxml解析器可以在`bs`初始化期间使用。我们只需要执行`bs(html_contents, 'lxml')`。
- en: Listing 16.17 Initializing `BeautifulSoup` using an HTML string
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.17 使用HTML字符串初始化`BeautifulSoup`
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our `soup` object tracks all elements in the parsed HTML. We can output these
    elements in a clean, readable format by running the `soup.prettify()` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`soup`对象跟踪解析的HTML中的所有元素。我们可以通过运行`soup.prettify()`方法以干净、可读的格式输出这些元素。
- en: Listing 16.18 Printing readable HTML with Beautiful Soup
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.18 使用Beautiful Soup打印可读的HTML
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Suppose we want to access an individual element, such as the title. The `soup`
    object provides that access through its `find` method. Running `soup.find('title')`
    returns all content enclosed in the title’s start and end tags.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想访问单个元素，例如标题。`soup`对象通过其`find`方法提供这种访问。运行`soup.find('title')`返回标题开始和结束标签之间的所有内容。
- en: Listing 16.19 Extracting the title with Beautiful Soup
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.19 使用Beautiful Soup提取标题
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The outputted `title` appears to be an HTML string demarcated by the title
    tags. However, our `title` variable is not a string: it’s an initialized Beautiful
    Soup `Tag` class. We can verify by printing `type(title)`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的`title`看起来是一个由标题标签界定的HTML字符串。然而，我们的`title`变量不是一个字符串：它是一个初始化的Beautiful Soup
    `Tag`类。我们可以通过打印`type(title)`来验证。
- en: Listing 16.20 Outputting the title’s data type
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.20 输出标题的数据类型
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Each `Tag` object contains a `text` attribute, which maps to the text in the
    tag. Thus, printing `title.text` returns *Data Science is Fun*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Tag`对象都包含一个`text`属性，它映射到标签中的文本。因此，打印`title.text`返回*数据科学很有趣*。
- en: Listing 16.21 Outputting the title’s text attribute
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.21 输出标题的文本属性
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We’ve accessed our `title` tag by running `soup.find('title')`. We can also
    access that same tag simply by running `soup.title`. Therefore, running `soup.title.text`
    returns a string equal to `title.text`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过运行`soup.find('title')`来访问我们的`title`标签。我们也可以简单地通过运行`soup.title`来访问相同的标签。因此，运行`soup.title.text`返回一个等于`title.text`的字符串。
- en: Listing 16.22 Accessing the title’s text attribute from `soup`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.22 从`soup`中访问标题的文本属性
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this same manner, we can access the body of our document by running `soup.body`.
    Next, we output all the text in the body of our HTML.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，我们可以通过运行`soup.body`来访问我们文档的正文。接下来，我们输出HTML正文中的所有文本。
- en: Listing 16.23 Accessing the body’s `text` attribute from `soup`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.23 从`soup`中访问正文体的`text`属性
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our output is an aggregation of all the text in the body. This text blob includes
    all headers, bullet points, and paragraphs. It is virtually unreadable. Rather
    than outputting all the text, we should instead narrow the scope of our output.
    Let’s print the text of just the first paragraph by printing `body.p.text.` Alternatively,
    printing `soup.p.text` generates the same output.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输出的结果是正文中的所有文本的聚合。这个文本块包括所有标题、项目符号和段落。它几乎无法阅读。与其输出所有文本，我们不如缩小输出范围。让我们通过打印`body.p.text`来仅打印第一段的文本。或者，打印`soup.p.text`会产生相同的输出。
- en: Listing 16.24 Accessing the text of the first paragraph
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.24 访问第一段的文本
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Accessing `body.p` returns the first paragraph in `body`. How do we access the
    remaining two paragraphs? Well, we can utilize the `find_all` method. Running
    `body.find_ all('p')` returns a list of all the paragraph tags in the body.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`body.p`返回`body`中的第一个段落。我们如何访问剩余的两个段落？嗯，我们可以利用`find_all`方法。运行`body.find_all('p')`返回正文中的所有段落标签列表。
- en: Listing 16.25 Accessing all paragraphs in the body
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.25 在正文中访问所有段落
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Similarly, we access our list of bullet points by running `body.find_all('li')`.
    Let’s utilize `find_all` to print all the bulleted libraries in the body.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们通过运行`body.find_all('li')`来访问我们的项目符号列表。让我们利用`find_all`来打印正文中的所有项目符号列表。
- en: Listing 16.26 Accessing all bullet points in the body
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.26 在正文中访问所有项目符号
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `find` and `find_all` methods allow us to search the elements by tag type
    and attribute. Suppose we wish to access an element with a unique ID of `x`. To
    search on that attribute ID, we simply need to execute `find(id='x')`. With this
    in mind, let’s output the text of the final paragraph whose assigned ID is `paragraph_2`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`和`find_all`方法允许我们通过标签类型和属性来搜索元素。假设我们希望访问一个具有唯一ID `x`的元素。要搜索该属性ID，我们只需执行`find(id=''x'')`。考虑到这一点，让我们输出分配ID为`paragraph_2`的最后一个段落的文本。'
- en: Listing 16.27 Accessing a paragraph by ID
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.27 通过ID访问一个段落
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The contents of `paragraph_2` include a web link to *Data Science Bookcamp*.
    The actual URL is stored in the `href` attribute. Beautiful Soup permits us to
    access any attribute using the `get` method. Thus, running `paragraph_2.get('id')`
    returns *paragraph 2*. Running `paragraph_2.a.get('href')` returns the URL; let’s
    print it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`paragraph_2`的内容包括一个指向*数据科学书营*的网页链接。实际的URL存储在`href`属性中。Beautiful Soup允许我们使用`get`方法访问任何属性。因此，运行`paragraph_2.get(''id'')`返回*段落
    2*。运行`paragraph_2.a.get(''href'')`返回URL；让我们打印它。'
- en: Listing 16.28 Accessing an attribute in a tag
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.28 在标签中访问一个属性
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: All attribute IDs have unique values assigned to them in our HTML. However,
    not all of our attributes are unique. For instance, two of our three division
    elements share the `class` attribute of `text`. Meanwhile, the third division
    element contains a unique class that’s set to `empty`. Running `body.find_all('div')`
    returns all three division elements. How do we obtain just those two divisions
    where the class is set to `text`? We just need to run `body.find_all('div', class_='text')`.
    The added `class_` parameter limits our results to those divisions where the class
    is set appropriately. Listing 16.29 searches for these divisions and outputs their
    text contents.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的HTML中，所有属性ID都分配了唯一的值。然而，并不是所有的属性都是唯一的。例如，我们三个分部元素中的两个共享`class`属性为`text`。同时，第三个分部元素包含一个设置为`empty`的唯一类。运行`body.find_all('div')`返回所有三个分部元素。我们如何只获取那些设置为`text`的类别的两个分部？我们只需要运行`body.find_all('div',
    class_='text')`。添加的`class_`参数将结果限制在那些类设置适当的分部。列表16.29搜索这些分部并输出它们的文本内容。
- en: Note Why do we run `find_all` on `class_` rather than `class`? Well, in Python,
    the `class` keyword is a restricted identifier, which is used to define novel
    classes. Beautiful Soup allows for a special `class_` parameter to get around
    this keyword restriction.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意为什么我们在`class_`上运行`find_all`而不是`class`？嗯，在Python中，`class`是一个受限标识符，用于定义新类。Beautiful
    Soup允许使用特殊的`class_`参数来绕过这个关键字限制。
- en: Listing 16.29 Accessing divisions by their shared `class` attribute
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.29 通过共享的`class`属性访问分区
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So far, we’ve used Beautiful Soup to access elements in the HTML. However, the
    library also allows us to edit individual elements. For example, given a `tag`
    object, we can delete that object by running `tag.decompose()`. The `decompose`
    method removes that element from all our data structures, including `soup`. Thus,
    calling `body.find (id='paragraph 0').decompose()` will remove all traces of the
    first paragraph. Also, calling `soup.find(id='paragraph 1').decompose()` will
    delete the second paragraph from both the `soup` and `body` objects. After these
    deletions, only the third paragraph will remain. Let’s confirm.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用Beautiful Soup来访问HTML中的元素。然而，这个库还允许我们编辑单个元素。例如，给定一个`tag`对象，我们可以通过运行`tag.decompose()`来删除该对象。`decompose`方法将该元素从所有我们的数据结构中删除，包括`soup`。因此，调用`body.find(id='paragraph
    0').decompose()`将删除第一个段落的全部痕迹。同样，调用`soup.find(id='paragraph 1').decompose()`将从`soup`和`body`对象中删除第二个段落。在这些删除之后，只剩下第三个段落。让我们确认。
- en: Listing 16.30 Paragraph deletion with Beautiful Soup
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.30 使用Beautiful Soup删除段落
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ The decompose method deletes the paragraph from all nested tag objects. Deleting
    the paragraph from soup also deletes it from body, and vice versa.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `decompose`方法从所有嵌套的标签对象中删除段落。从soup中删除段落也会从body中删除，反之亦然。
- en: Additionally, we’re able to insert new tags into the HTML. Suppose we wish to
    insert a new paragraph into our final empty division. To do so, we must first
    create a new paragraph element. Running `soup.new_tag('p')` returns an empty paragraph
    `Tag` object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还能将新标签插入到HTML中。假设我们希望将一个新段落插入到我们最终的空分区中。为此，我们必须首先创建一个新的段落元素。运行`soup.new_tag('p')`返回一个空的段落`Tag`对象。
- en: Listing 16.31 Initializing an empty paragraph `Tag`
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.31 初始化一个空的段落`Tag`
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Next, we must update the initialized paragraph’s text by assigning it to `new_paragraph.string`.
    Running `new_paragraph.string = x` sets the paragraph’s text to equal `x`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须通过将其赋值给`new_paragraph.string`来更新初始化的段落文本。运行`new_paragraph.string = x`将段落的文本设置为等于`x`。
- en: Listing 16.32 Updating the text of an empty paragraph
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.32 更新空段落的文本
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, we append the updated `new_paragraph` to an existing `Tag` object.
    Given two `Tag` objects, `tag1` and `tag2`, we can insert `tag1` into `tag2` by
    running `tag2.append (tag1)`. Thus, running `soup.find(id='empty').append(new_paragraph)`
    should append the paragraph to the empty division. Let’s update our HTML and then
    confirm the changes by rendering the updated results (figure 16.8).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将更新的`new_paragraph`追加到一个现有的`Tag`对象中。给定两个`Tag`对象`tag1`和`tag2`，我们可以通过运行`tag2.append(tag1)`将`tag1`插入到`tag2`中。因此，运行`soup.find(id='empty').append(new_paragraph)`应该将段落追加到空分区中。让我们更新我们的HTML，然后通过渲染更新后的结果（图16.8）来确认更改。
- en: '![](../Images/16-08.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-08.png)'
- en: Figure 16.8 A rendered HTML document. The document has been edited, two of the
    three original paragraphs have been removed, and a new paragraph has been inserted.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 一个渲染的HTML文档。文档已被编辑，三个原始段落中的两个已被删除，并插入了一个新段落。
- en: Listing 16.33 Paragraph insertion with Beautiful Soup
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.33 使用Beautiful Soup插入段落
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Common Beautiful Soup methods
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的Beautiful Soup方法
- en: '`soup` = `bs(html_contents)`—Initializes a `BeautifulSoup` object from the
    HTML elements in the parsed `html_contents`.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`soup = bs(html_contents)`—从解析的`html_contents`中的HTML元素初始化一个`BeautifulSoup`对象。'
- en: '`soup.prettify()`—Returns the parsed HTML document in a clean, easily readable
    format.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`soup.prettify()`—以干净、易于阅读的格式返回解析的HTML文档。'
- en: '`title = soup.title`—Returns a `Tag` object associated with the title element
    of a parsed document.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title = soup.title`—返回与解析文档的标题元素相关联的`Tag`对象。'
- en: '`title = soup.find(''title'')`—Returns a `Tag` object associated with the title
    element of a parsed document.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title = soup.find(''title'')`—返回与解析文档的标题元素相关联的`Tag`对象。'
- en: '`tag_object = soup.find(''element_tag'')`—Returns a `Tag` object associated
    with the first HTML element demarcated by the specified `element_tag` tag.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag_object = soup.find(''element_tag'')`—返回与指定`element_tag`标签所标记的第一个HTML元素相关联的`Tag`对象。'
- en: '`tag_objects = soup.find_all(''element_tag'')`—Returns a list of all `Tag`
    objects demarcated by the specified `element_tag` tag.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag_objects = soup.find_all(''element_tag'')`—返回一个包含指定`element_tag`标签的所有`Tag`对象的列表。'
- en: '`tag_object = soup.find(id=''unique_id'')`—Returns a `Tag` object that contains
    the specified unique `id` attribute.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag_object = soup.find(id=''unique_id'')`—返回包含指定唯一`id`属性的`Tag`对象。'
- en: '`tag_objects = soup.find_all(''element_tag'', class_=''category_ class'')`—Returns
    a list of `Tag` objects that are demarcated by the specified `element_tag` tag
    and that contain the specified class attribute.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag_objects = soup.find_all(''element_tag'', class_=''category_class'')`—返回一个包含指定`element_tag`标签和指定类属性的`Tag`对象的列表。'
- en: '`tag_object = soup.new_tag(''element_tag'')`—Creates a new `Tag` object whose
    HTML element type is specified by the `element` tag.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag_object = soup.new_tag(''element_tag'')`—创建一个新的`Tag`对象，其HTML元素类型由`element`标签指定。'
- en: '`tag_object.decompose()`—Deletes the `Tag` object from `soup`.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag_object.decompose()`—从`soup`中删除`Tag`对象。'
- en: '`tab_object.append(tag_object2)`—Given two `Tag` objects, `tag_object` and
    `tag_object2`, inserts `tag_object2` into `tag_object`.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tab_object.append(tag_object2)`—给定两个`Tag`对象，`tag_object`和`tag_object2`，将`tag_object2`插入到`tag_object`中。'
- en: '`tag_object.text`—Returns all visible text in a `Tag` object.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag_object.text`—返回`Tag`对象中的所有可见文本。'
- en: '`tag_object.get(''attribute'')`—Returns an HTML attribute that has been assigned
    to the `Tag` object.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag_object.get(''attribute'')`—返回分配给`Tag`对象的HTML属性。'
- en: 16.3 Downloading and parsing online data
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3 下载和解析在线数据
- en: The Beautiful Soup library allows us to easily parse, analyze, and edit HTML
    documents. In most cases, these documents must be downloaded directly from the
    web. Let’s briefly review the procedure for downloading HTML files using Python’s
    built-in `urllib` module. We start by importing the `urlopen` function from `urllib.request`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Beautiful Soup库允许我们轻松解析、分析和编辑HTML文档。在大多数情况下，这些文档必须直接从网络下载。让我们简要回顾使用Python内置的`urllib`模块下载HTML文件的步骤。我们首先从`urllib.request`导入`urlopen`函数。
- en: Note The `urlopen` function is sufficient when downloading a single HTML document
    from a single, unsecured online page. However, for more complicated downloads,
    you should consider using the external Requests library ([https://requests.readthedocs.io](https://requests.readthedocs.io)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当从单个不安全的在线页面下载单个HTML文档时，`urlopen`函数是足够的。然而，对于更复杂的下载，你应该考虑使用外部的Requests库（[https://requests.readthedocs.io](https://requests.readthedocs.io)）。
- en: Listing 16.34 Importing the `urlopen` function
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.34 导入`urlopen`函数
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Given the URL of an online document, we can download the associated HTML contents
    by running `urlopen(url).read()`. Next, we use `urlopen` to download the Manning
    website for this book. Then we print the first 1,000 characters of the downloaded
    HTML.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 给定在线文档的URL，我们可以通过运行`urlopen(url).read()`下载相关的HTML内容。然后，我们使用`urlopen`下载此书的Manning网站。然后我们打印下载的HTML的前1,000个字符。
- en: Warning The following code will only run with a valid internet connection. Also,
    the downloaded HTML may change with alterations to the website.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：以下代码仅在有效的互联网连接下运行。此外，下载的HTML可能会随着网站的改变而改变。
- en: Listing 16.35 Downloading an HTML document
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.35 下载HTML文档
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ The urlopen function establishes a network connection with the specified URL.
    That connection is tracked using a special URLopener object. Calling the object’s
    read method downloads text from the established connection.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `urlopen`函数与指定的URL建立网络连接。该连接通过一个特殊的URLopener对象进行跟踪。调用该对象的read方法从建立的连接下载文本。
- en: Let’s extract the title from our messy HTML using Beautiful Soup.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Beautiful Soup从杂乱的HTML中提取标题。
- en: Listing 16.36 Accessing the title with Beautiful Soup
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.36 使用Beautiful Soup获取标题
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using our `soup` object, we can further analyze the page. For instance, we can
    extract the division that contains an *about the book* header to print a description
    of this book.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`soup`对象，我们可以进一步分析页面。例如，我们可以提取包含`关于本书`标题的`div`元素，以打印本书的描述。
- en: Warning Online HTML is continually updated. Future updates to the Manning site
    may cause the following code to malfunction. Readers who encounter differences
    between expected and actual outputs are encouraged to manually explore the HTML
    to extract the book description.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在线HTML是持续更新的。Manning网站的将来更新可能会导致以下代码出现故障。遇到预期输出与实际输出不一致的读者，鼓励手动探索HTML以提取书籍描述。
- en: Listing 16.37 Accessing a description of this book
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.37 获取本书的描述
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Iterates over the divisions in the page
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 遍历页面中的所有`div`元素
- en: ❷ Checks if a division header is present
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查是否存在标题分区
- en: ❸ Prints the book’s description once the “about” section has been identified
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一旦识别出“关于”部分，就打印出书籍的描述
- en: We are now ready to use Beautiful Soup to parse job postings as part of our
    case study solution.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 Beautiful Soup 来解析职位发布信息，作为我们的案例研究解决方案的一部分。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: HTML documents are composed of nested elements that provide auxiliary information
    about the text. Most elements are defined by a start tag and an end tag.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML 文档由嵌套元素组成，这些元素提供了关于文本的辅助信息。大多数元素由起始标签和结束标签定义。
- en: The text in some elements is intended to be rendered in a browser. Traditionally,
    this rendered information is nested in the *body* element of the document. Other
    non-rendered texts (such as the document’s title) are nested in the document’s
    *head* element.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些元素中的文本旨在在浏览器中渲染。传统上，这种渲染信息嵌套在文档的 *body* 元素中。其他非渲染文本（如文档的标题）嵌套在文档的 *head* 元素中。
- en: Attributes can be inserted into HTML start tags to track additional tag information.
    Unique `id` attributes can help distinguish tags of the same type. Furthermore,
    `class` attributes can be used to track elements by category. Unlike the unique
    `id`, the `class` attribute can be shared by multiple elements in the same category.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将属性插入到 HTML 起始标签中，以跟踪额外的标签信息。独特的 `id` 属性可以帮助区分相同类型的标签。此外，`class` 属性可以用来按类别跟踪元素。与唯一的
    `id` 不同，`class` 属性可以被同一类别中的多个元素共享。
- en: Manually extracting text from HTML is difficult to do in basic Python. Fortunately,
    the Beautiful Soup library simplifies the text-extraction process. Beautiful Soup
    allows us to query elements by tag type and assigned attribute values. Furthermore,
    the library permits us to edit the underlying HTML.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基本 Python 中手动从 HTML 中提取文本是困难的。幸运的是，Beautiful Soup 库简化了文本提取过程。Beautiful Soup
    允许我们通过标签类型和指定的属性值查询元素。此外，该库允许我们编辑底层的 HTML。
- en: Using Python’s built-in `urlopen` function, we can download HTML files directly
    from the web. Then we can analyze the text in these files using Beautiful Soup.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 的内置 `urlopen` 函数，我们可以直接从网络上下载 HTML 文件。然后我们可以使用 Beautiful Soup 分析这些文件中的文本。
