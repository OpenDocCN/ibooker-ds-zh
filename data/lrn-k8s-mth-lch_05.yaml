- en: 4 Configuring applications with ConfigMaps and Secrets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 配置应用程序的 ConfigMaps 和 Secrets
- en: One of the great advantages of running apps in containers is that you eliminate
    the gaps between environments. The deployment process promotes the same container
    image through all your test environments up to production, so each deployment
    uses the exact same set of binaries as the previous environment. You’ll never
    again see a production deployment fail because the servers are missing a dependency
    that someone manually installed on the test servers and forgot to document. Of
    course, differences do occur between environments, and you provide for that by
    injecting configuration settings into containers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中运行应用程序的一个巨大优势是消除了环境之间的差距。部署过程通过所有测试环境直至生产环境推广相同的容器镜像，因此每个部署都使用与先前环境完全相同的二进制文件集。你将再也不必担心生产部署失败，因为服务器缺少在测试服务器上手动安装但忘记记录的依赖项。当然，环境之间仍然存在差异，你通过将配置设置注入容器来提供这种差异。
- en: 'Kubernetes supports configuration injection with two resource types: ConfigMaps
    and Secrets. Both types can store data in any reasonable format, and that data
    lives in the cluster independent of any other resources. Pods can be defined with
    access to the data in ConfigMaps and Secrets, with different options for how that
    data gets surfaced. In this chapter, you’ll learn all the ways to manage configuration
    in Kubernetes, which are flexible enough to meet the requirements for any application.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 支持使用两种资源类型进行配置注入：ConfigMaps 和 Secrets。这两种类型都可以以任何合理的格式存储数据，并且这些数据在集群中独立于其他资源存在。Pod
    可以定义访问 ConfigMaps 和 Secrets 中的数据，以及如何展示这些数据的不同选项。在本章中，你将学习所有管理 Kubernetes 中配置的方法，这些方法足够灵活，可以满足任何应用程序的需求。
- en: 4.1 How Kubernetes supplies configuration to apps
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 Kubernetes 如何向应用程序提供配置
- en: 'You create ConfigMap and Secret objects like other resources in Kubernetes—using
    kubectl, either with `create` commands or by applying a YAML specification. Unlike
    other resources, they don’t do anything; they’re just storage units intended for
    small amounts of data. Those storage units can be loaded into a Pod, becoming
    part of the container environment, so the application in the container can read
    the data. Before we even get to those objects, we’ll look at the simplest way
    to provide configuration settings: using environment variables.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像创建其他 Kubernetes 资源一样创建 ConfigMap 和 Secret 对象——使用 kubectl，无论是通过 `create`
    命令还是通过应用 YAML 规范。与其它资源不同，它们不执行任何操作；它们只是用于存储少量数据的存储单元。这些存储单元可以被加载到 Pod 中，成为容器环境的一部分，因此容器中的应用程序可以读取这些数据。在我们接触到这些对象之前，我们将看看提供配置设置的
    simplest 方法：使用环境变量。
- en: Try it now Environment variables are a core operating system feature in Linux
    and Windows, and they can be set at the machine level so any app can read them.
    They’re commonly used, and all containers have some, which are set by the operating
    system inside the container and by Kubernetes. Make sure your Kubernetes lab is
    up and running.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 环境变量是 Linux 和 Windows 的核心操作系统功能，它们可以在机器级别设置，因此任何应用程序都可以读取它们。它们被广泛使用，所有容器都有一些，这些由容器内的操作系统和
    Kubernetes 设置。确保你的 Kubernetes 实验室正在运行。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see from my output shown in figure 4.1 that the hostname variable exists
    in the container and is populated by Kubernetes, but the custom Kiamol variable
    doesn’t exist.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从图 4.1 中我的输出中看到，容器中存在 hostname 变量，并由 Kubernetes 填充，但自定义的 Kiamol 变量不存在。
- en: '![](../Images/4-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-1.jpg)'
- en: Figure 4.1 All Pod containers have some environment variables set by Kubernetes
    and the container OS.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 所有 Pod 容器都由 Kubernetes 和容器操作系统设置了一些环境变量。
- en: In this exercise, the application is just the Linux `printenv` tool, but the
    principle is the same for any application. Many technology stacks use environment
    variables as a basic configuration system. The simplest way to provide those settings
    in Kubernetes is by adding environment variables in the Pod specification. Listing
    4.1 shows an updated Pod spec for the sleep Deployment, which adds the Kiamol
    environment variable.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，应用程序只是 Linux 的 `printenv` 工具，但对于任何应用程序，原理都是相同的。许多技术栈使用环境变量作为基本的配置系统。在
    Kubernetes 中提供这些设置的 simplest 方法是在 Pod 规范中添加环境变量。列表 4.1 显示了 sleep 部署的更新 Pod 规范，其中添加了
    Kiamol 环境变量。
- en: Listing 4.1 sleep-with-env.yaml, a Pod spec with environment variables
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 sleep-with-env.yaml，一个包含环境变量的 Pod 规范
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Environment variables are static for the life of the Pod; you can’t update any
    values while the Pod is running. If you need to make configuration changes, you
    need to perform an update with a replacement Pod. You should get used to the idea
    that deployments aren’t just for new feature releases; you’ll also use them for
    configuration changes and software patches, and you must design your apps to handle
    frequent Pod replacements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量在 Pod 的整个生命周期中是静态的；在 Pod 运行期间无法更新任何值。如果您需要做出配置更改，您需要使用替换 Pod 来执行更新。您应该习惯于这样的想法：部署不仅仅用于新功能发布；您还会使用它们进行配置更改和软件补丁，并且您必须设计应用程序以处理频繁的
    Pod 替换。
- en: Try it now Update the sleep Deployment with the new Pod spec from listing 4.1,
    adding an environment variable that is visible inside the Pod container.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 使用列表 4.1 中的新 Pod 规范更新 sleep 部署，添加一个在 Pod 容器内部可见的环境变量。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: My output, in figure 4.2, shows the result-a new container with the Kiamol environment
    variable set, running in a new Pod.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我在图 4.2 中的输出显示了结果——一个新的容器，其中设置了 Kiamol 环境变量，在一个新的 Pod 中运行。
- en: '![](../Images/4-2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-2.jpg)'
- en: Figure 4.2 Adding environment variables to a Pod spec makes the values available
    in the Pod container.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 向 Pod 规范中添加环境变量使值在 Pod 容器中可用。
- en: The important thing about the previous exercise is that the new app is using
    the same Docker image; it’s the same application with all the same binaries—only
    the configuration settings have changed between deployments. Setting environment
    values inline in the Pod specification is fine for simple settings, but real applications
    usually have more complex configuration requirements, which is when you use ConfigMaps.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 之前练习的重要之处在于新应用程序使用的是相同的 Docker 镜像；这是一个具有所有相同二进制文件的应用程序——只是在部署之间配置设置发生了变化。在 Pod
    规范中直接设置环境值对于简单的设置来说是可以的，但真实的应用程序通常有更复杂的配置需求，这就是您使用 ConfigMaps 的时候。
- en: A ConfigMap is just a resource that stores some data that can be loaded into
    a Pod. The data can be a set of key-value pairs, a blurb of text, or even a binary
    file. You can use key-value pairs to load Pods with environment variables, text
    to load any type of config file—JSON, XML, YAML, TOML, INI—and binary files to
    load license keys. One Pod can use many ConfigMaps, and each ConfigMap can be
    used by many Pods. Figure 4.3 shows some of those options.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 只是一个存储可以加载到 Pod 中的数据的资源。数据可以是一组键值对、一段文本或甚至是二进制文件。您可以使用键值对来加载带有环境变量的
    Pods，使用文本来加载任何类型的配置文件——JSON、XML、YAML、TOML、INI——以及使用二进制文件来加载许可证密钥。一个 Pod 可以使用多个
    ConfigMaps，每个 ConfigMap 也可以被多个 Pods 使用。图 4.3 展示了一些这些选项。
- en: '![](../Images/4-3.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-3.jpg)'
- en: Figure 4.3 ConfigMaps are separate resources, which can be attached to zero
    or more Pods.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 ConfigMaps 是独立的资源，可以附加到零个或多个 Pod 上。
- en: We’ll stick with the simple sleep Deployment to show the basics of creating
    and using ConfigMaps. Listing 4.2 shows the environment section of an updated
    Pod specification, which uses one environment variable defined in the YAML and
    a second loaded from a ConfigMap.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将坚持使用简单的 sleep 部署来展示创建和使用 ConfigMaps 的基本原理。列表 4.2 显示了更新后的 Pod 规范的环境部分，它使用在
    YAML 中定义的一个环境变量，以及从 ConfigMap 中加载的第二个变量。
- en: Listing 4.2 sleep-with-configMap-env.yaml, loading a ConfigMap into a Pod
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 sleep-with-configMap-env.yaml，将 ConfigMap 加载到 Pod 中
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you reference a ConfigMap in a Pod specification, the ConfigMap needs to
    exist before you deploy the Pod. This spec expects to find a ConfigMap called
    `sleep-config-literal` with key-value pairs in the data, and the easiest way to
    create that is by passing the key and value to a kubectl command.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Pod 规范中引用了 ConfigMap，则在部署 Pod 之前，ConfigMap 必须存在。此规范期望找到一个名为 `sleep-config-literal`
    的 ConfigMap，其中包含数据中的键值对，并且创建它的最简单方法是通过将键和值传递给 kubectl 命令。
- en: Try it now Create a ConfigMap by specifying the data in the command, then check
    the data and deploy the updated sleep app to use the ConfigMap.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 通过在命令中指定数据来创建一个 ConfigMap，然后检查数据并将更新的 sleep 应用程序部署以使用 ConfigMap。
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We won’t use kubectl `describe` commands much in this book because the output
    is usually verbose and would use up most of a chapter, but it’s definitely something
    to experiment with. Describing Services and Pods gives you a lot of useful information
    in a readable format. You can see my output in figure 4.4, which includes the
    key-value data shown from describing the ConfigMap.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不会过多使用 kubectl `describe` 命令，因为输出通常是冗长的，可能会占用整章的内容，但它确实是一个值得实验的东西。描述服务和
    Pod 可以以可读的格式提供大量有用的信息。您可以在图 4.4 中看到我的输出，其中包括从描述 ConfigMap 中显示的键值数据。
- en: '![](../Images/4-4.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-4.jpg)'
- en: Figure 4.4 Pods can load individual data items from ConfigMaps and rename the
    key.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 Pods 可以从 ConfigMaps 中加载单个数据项并重命名键。
- en: Creating ConfigMaps from literal values is fine for individual settings, but
    it gets cumbersome fast if you have a lot of configuration data. As well as specifying
    literal values on the command line, Kubernetes lets you load ConfigMaps from files.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从字面值创建 ConfigMaps 对于单个设置来说是可以的，但如果你有很多配置数据，这会很快变得繁琐。除了在命令行上指定字面值之外，Kubernetes
    还允许你从文件中加载 ConfigMaps。
- en: 4.2 Storing and using configuration files in ConfigMaps
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 在 ConfigMaps 中存储和使用配置文件
- en: Options for creating and using ConfigMaps have evolved over many Kubernetes
    releases, so they now support practically every configuration variant you can
    think of. These sleep Pod exercises are a good way to show the variations, but
    they’re getting a bit boring, so we’ll just have one more before we move on to
    something more interesting. Listing 4.3 shows an environment file—a text file
    with key-value pairs that can be loaded to create one ConfigMap with multiple
    data items.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和使用 ConfigMaps 的选项在许多 Kubernetes 版本中已经演变，因此现在它们几乎支持你所能想到的每一种配置变体。这些 sleep
    Pod 练习是展示这些变分的良好方式，但它们有点无聊，所以我们将在转向更有趣的内容之前再进行一次练习。列表 4.3 显示了一个环境文件——一个包含键值对的文本文件，可以加载以创建一个包含多个数据项的
    ConfigMap。
- en: Listing 4.3 ch04.env, a file of environment variables
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 ch04.env，环境变量文件
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Environment files are a useful way to group multiple settings, and Kubernetes
    has explicit support for loading them into ConfigMaps and surfacing all the settings
    as environment variables in a Pod container.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 环境文件是分组多个设置的有用方式，Kubernetes 明确支持将它们加载到 ConfigMaps 中，并在 Pod 容器中将所有设置作为环境变量公开。
- en: Try it now Create a new ConfigMap populated from the environment file in listing
    4.3, then deploy an update to the sleep app to use the new settings.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 创建一个新的 ConfigMap，它由列表 4.3 中的环境文件填充，然后部署 sleep 应用程序的更新以使用新设置。
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: My output, in figure 4.5, shows the `printenv` command reading all the environment
    variables and showing the ones with Kiamol names, but it might not be the result
    you expect.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出，如图 4.5 所示，显示 `printenv` 命令正在读取所有环境变量并显示具有 Kiamol 名称的变量，但可能不是你预期的结果。
- en: '![](../Images/4-5.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-5.jpg)'
- en: Figure 4.5 A ConfigMap can have multiple data items, and the Pod can load them
    all.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 ConfigMap 可以有多个数据项，Pod 可以加载它们全部。
- en: This exercise showed you how to create a ConfigMap from a file. It also showed
    you that Kubernetes has rules of precedence for applying environment variables.
    The Pod spec you just deployed, shown in listing 4.4, loads all environment variables
    from the ConfigMap, but it also specifies explicit environment values with some
    of the same keys.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习向你展示了如何从文件中创建 ConfigMap。它还展示了 Kubernetes 在应用环境变量方面有优先级规则。你刚刚部署的 Pod 规范，如列表
    4.4 所示，从 ConfigMap 中加载了所有环境变量，但它还指定了一些具有相同键的显式环境值。
- en: Listing 4.4 sleep-with-configMap-env-file.yaml, multiple ConfigMaps in a Pod
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 sleep-with-configMap-env-file.yaml，Pod 中的多个 ConfigMaps
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So the environment variables defined with `env` in the Pod spec override the
    values defined with `envFrom` if there are duplicate keys. It’s useful to remember
    that you can override any environment variables set in the container image or
    in ConfigMaps by explicitly setting them in the Pod spec—a quick way to change
    a configuration setting when you’re tracking down problems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 Pod 规范中使用 `env` 定义的环境变量会覆盖 `envFrom` 中定义的具有重复键的值。记住这一点很有用，即你可以通过在 Pod 规范中显式设置它们来覆盖容器镜像或
    ConfigMaps 中设置的任何环境变量——这是一种快速更改配置设置的方法，当你正在追踪问题时。
- en: Environment variables are well supported, but they only get you so far, and
    most application platforms prefer a more structured approach. In the rest of the
    exercises in this chapter, we’ll use a web application that supports a hierarchy
    of configuration sources. Default settings are packaged in a JSON file in the
    Docker image, and the app looks in other locations at run time for JSON files
    with settings that override the defaults—and all the JSON settings can be overridden
    with environment variables. Listing 4.5 shows the Pod spec for the first deployment
    we’ll use.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量得到了很好的支持，但它们只能带你走这么远，并且大多数应用程序平台更喜欢一种更结构化的方法。在本章的其余练习中，我们将使用一个支持配置源层次结构的
    Web 应用程序。默认设置打包在 Docker 镜像中的一个 JSON 文件中，应用程序在运行时会查找其他位置的 JSON 文件，这些文件包含覆盖默认设置的设置，并且所有
    JSON 设置都可以用环境变量覆盖。列表 4.5 显示了我们将要使用的第一个部署的 Pod 规范。
- en: Listing 4.5 todo-web.yaml, a web app with configuration settings
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 todo-web.yaml，一个带有配置设置的 Web 应用
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This run of the app will use all the default settings from the JSON configuration
    file in the image, except for the default logging level, which is set as an environment
    variable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的运行将使用镜像中 JSON 配置文件的默认设置，除了默认的日志级别，它被设置为环境变量。
- en: Try it now Run the app without any additional configuration, and check its behavior.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 运行应用而不进行任何额外配置，并检查其行为。
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The demo app is a simple to-do list (which will be distressingly familiar to
    readers of *Learn Docker in a Month of Lunches*). In its current setup, it lets
    you add and view items, but there should also be a `/config` page we can use in
    nonproduction environments to view all the configuration settings. As you can
    see in figure 4.6, that page is empty, and the app logs a warning that someone
    tried to access it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 演示应用是一个简单的待办事项列表（对《一个月午餐时间学 Docker》的读者来说可能会感到令人沮丧的熟悉）。在其当前设置中，它允许你添加和查看项目，但还应该有一个
    `/config` 页面，我们可以在非生产环境中使用它来查看所有配置设置。如图 4.6 所示，该页面为空，应用记录了一个警告，表明有人尝试访问它。
- en: '![](../Images/4-6.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-6.jpg)'
- en: Figure 4.6 The app mostly works, but we need to set additional configuration
    values.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 应用基本工作，但我们还需要设置额外的配置值。
- en: The configuration hierarchy in use here is a very common approach. If you’re
    not familiar with it, appendix C in the ebook is the chapter “Application Configuration
    Management in Containers” from *Learn Docker in a Month of Lunches*, which explains
    it in detail. This example is a .NET Core app that uses JSON, but you see similar
    configuration systems using a variety of file formats in Java Spring apps, Node.js,
    Go, Python, and more. In Kubernetes, you use the same app configuration approach
    with them all.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的配置层次结构是一个非常常见的做法。如果你不熟悉它，电子书的附录 C 中的章节“容器中的应用配置管理”来自《一个月午餐时间学 Docker》，它对此进行了详细解释。这个例子是一个使用
    JSON 的 .NET Core 应用，但你也会看到在 Java Spring 应用、Node.js、Go、Python 等多种文件格式中使用的类似配置系统。在
    Kubernetes 中，你可以使用相同的所有应用配置方法。
- en: Default app settings are baked into the container image. This could be just
    the settings which apply in every environment, or it could be a full set of configuration
    options, so without any extra setup, the app runs in development mode (that’s
    helpful for developers who can quickly start the app with a simple Docker `run`
    command).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认应用设置已经嵌入到容器镜像中。这可能只是适用于每个环境的设置，或者可能是一个完整的配置选项集，因此无需任何额外设置，应用就可以在开发模式下运行（这对开发者来说很有帮助，他们可以用简单的
    Docker `run` 命令快速启动应用）。
- en: The actual settings for each environment are stored in a ConfigMap and surfaced
    into the container filesystem. Kubernetes presents the configuration data as a
    file in a known location, which the app checks and merges with the content from
    the default file.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个环境的实际设置都存储在 ConfigMap 中，并显示在容器文件系统中。Kubernetes 将配置数据作为已知位置的一个文件呈现，应用会检查并合并来自默认文件的内容。
- en: Any settings that need to be tweaked can be applied as environment variables
    in the Pod specification for the Deployment.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要调整的任何设置都可以作为 Deployment 的 Pod 规范中的环境变量应用。
- en: Listing 4.6 shows the YAML specification for the development configuration of
    the to-do app. It contains the contents of a JSON file, which the app will merge
    with the default JSON configuration file in the container image, with a setting
    to make the config page visible.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 显示了待办事项应用的开发配置的 YAML 规范。它包含一个 JSON 文件的全部内容，应用将与此容器镜像中的默认 JSON 配置文件合并，并设置一个使配置页面可见的选项。
- en: Listing 4.6 todo-web-config-dev.yaml, a ConfigMap specification
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 todo-web-config-dev.yaml，一个 ConfigMap 规范
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can embed any kind of text configuration file into a YAML spec, as long
    as you’re careful with the whitespace. I prefer this to loading ConfigMaps directly
    from configuration files because it means you can consistently use the kubectl
    `apply` command to deploy every part of your app. If I wanted to load the JSON
    file directly, I’d need to use the kubectl `create` command for configuration
    resources and `apply` for everything else.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何类型的文本配置文件嵌入到 YAML 规范中，只要你注意空格的使用。我更喜欢这种方法，因为它意味着你可以一致地使用 kubectl `apply`
    命令来部署应用的所有部分。如果我想直接加载 JSON 文件，我需要使用 kubectl `create` 命令来配置资源，并使用 `apply` 命令来处理其他所有内容。
- en: The ConfigMap definition in listing 4.6 contains just a single setting, but
    it’s stored in the native configuration format for the app. When we deploy an
    updated Pod spec, the setting will be applied and the config page will be visible.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 中的 ConfigMap 定义只包含一个设置，但它以应用的本地配置格式存储。当我们部署更新的 Pod 规范时，该设置将被应用，并且配置页面将可见。
- en: Try it now The new Pod spec references the ConfigMap, so that needs to be created
    first by applying the YAML, then we update the to-do app Deployment.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 新的 Pod 规范引用了 ConfigMap，因此需要先通过应用 YAML 创建它，然后我们更新待办事项应用的 Deployment。
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can see my output in figure 4.7\. The config page loads correctly now, so
    the new Deployment configuration is merging in the settings from the ConfigMap
    to override the default setting in the image, which blocked access to that page.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图 4.7 中看到我的输出。现在配置页面正确加载了，因此新的 Deployment 配置正在合并 ConfigMap 中的设置以覆盖镜像中的默认设置，这阻止了对该页面的访问。
- en: '![](../Images/4-7.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-7.jpg)'
- en: Figure 4.7 Loading ConfigMap data into the container filesystem, where the app
    loads config files
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 将 ConfigMap 数据加载到容器文件系统中，其中应用加载配置文件
- en: 'This approach needs two things: your application needs to be able to merge
    in the ConfigMap data, and your Pod specification needs to load the data from
    the ConfigMap into the expected file path in the container filesystem. We’ll see
    how that works in the next section.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法需要两件事：你的应用需要能够合并 ConfigMap 数据，你的 Pod 规范需要将数据从 ConfigMap 加载到容器文件系统中的预期文件路径。我们将在下一节中看到它是如何工作的。
- en: 4.3 Surfacing configuration data from ConfigMaps
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 从 ConfigMap 中暴露配置数据
- en: The alternative to loading configuration items into environment variables is
    to present them as files inside directories in the container. The container filesystem
    is a virtual construct, built from the container image and other sources. Kubernetes
    can use ConfigMaps as a filesystem source—they are mounted as a directory, with
    a file for each data item. Figure 4.8 shows the setup you’ve just deployed, where
    the data item in the ConfigMap is surfaced as a file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将配置项加载到环境变量中的替代方法是将其作为容器目录内的文件呈现。容器文件系统是一个虚拟结构，由容器镜像和其他源构建。Kubernetes 可以使用 ConfigMap
    作为文件系统源——它们作为目录挂载，每个数据项对应一个文件。图 4.8 显示了你刚刚部署的设置，其中 ConfigMap 中的数据项以文件的形式呈现。
- en: '![](../Images/4-8.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-8.jpg)'
- en: Figure 4.8 ConfigMaps can be loaded as directories in the container filesystem.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 ConfigMap 可以作为容器文件系统中的目录加载。
- en: 'Kubernetes manages this strange magic with two features of the Pod spec: *volumes*,
    which make the contents of the ConfigMap available to the Pod, and *volume mounts*,
    which load the contents of the ConfigMap volume into a specified path in the Pod
    container. Listing 4.7 shows the volumes and mounts you deployed in the previous
    exercise.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 通过 Pod 规范的两个功能管理这种奇怪的魔法：*卷*，它使 ConfigMap 的内容可用于 Pod，以及 *卷挂载*，它将 ConfigMap
    卷的内容加载到 Pod 容器中的指定路径。列表 4.7 显示了你之前练习中部署的卷和挂载。
- en: Listing 4.7 todo-web-dev.yaml, loading a ConfigMap as a volume mount
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 todo-web-dev.yaml，将 ConfigMap 作为卷挂载加载
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The important thing to realize here is that the ConfigMap is treated like a
    directory, with multiple data items, which each become files in the container
    filesystem. In this example, the application loads its default settings from the
    file at `/app/appsettings.json`, and then it looks for a file at `/app/config/config.json`,
    which can contain settings to override the defaults. The `/app/config` directory
    doesn’t exist in the container image; it is created and populated by Kubernetes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要认识到的重要事情是，ConfigMap 被当作一个目录处理，包含多个数据项，每个数据项在容器文件系统中都成为文件。在这个例子中，应用从 `/app/appsettings.json`
    中的文件加载其默认设置，然后它寻找 `/app/config/config.json` 中的文件，该文件可以包含覆盖默认设置的设置。`/app/config`
    目录在容器镜像中不存在；它是由 Kubernetes 创建并填充的。
- en: Try it now The container filesystem appears as a single storage unit to the
    application, but it has been built from the image and the ConfigMap. Those sources
    have different behaviors.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 容器文件系统对应用来说表现为一个单一的存储单元，但它是由镜像和 ConfigMap 构建的。这些源有不同的行为。
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: My output, in figure 4.9, shows that the JSON configuration files exist in the
    expected locations for the app, but the ConfigMap files are managed by Kubernetes
    and delivered as read-only files.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出，如图 4.9 所示，显示应用预期的位置存在 JSON 配置文件，但 ConfigMap 文件由 Kubernetes 管理，并以只读文件的形式交付。
- en: '![](../Images/4-9.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-9.jpg)'
- en: Figure 4.9 The container filesystem is built by Kubernetes from the image and
    the ConfigMap.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 容器文件系统是由 Kubernetes 从镜像和 ConfigMap 构建的。
- en: Loading ConfigMaps as directories is flexible, and you can use it to support
    different approaches to app configuration. If your configuration is split across
    multiple files, you can store it all in a single ConfigMap and load it all into
    the container. Listing 4.8 shows the data items for an update to the to-do ConfigMap
    with two JSON files that separate the settings for application behavior and logging.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ConfigMap 作为目录加载是灵活的，你可以用它来支持不同的应用程序配置方法。如果你的配置分散在多个文件中，你可以将它们全部存储在一个 ConfigMap
    中，并将它们全部加载到容器中。列表 4.8 展示了更新待办 ConfigMap 的数据项，其中包含两个 JSON 文件，分别用于应用程序行为和日志记录的设置。
- en: Listing 4.8 todo-web-config-dev-with-logging.yaml, a ConfigMap with two files
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.8 todo-web-config-dev-with-logging.yaml，一个包含两个文件的 ConfigMap
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What happens when you deploy an update to a ConfigMap that a live Pod is using?
    Kubernetes delivers the updated files to the container, but what happens next
    depends on the application. Some apps load configuration files into memory when
    they start and then ignore any changes in the config directory, so changing the
    ConfigMap won’t actually change the app configuration until the Pods are replaced.
    This application is more thoughtful—it watches the config directory and reloads
    any file changes, so deploying an update to the ConfigMap will update the application
    configuration.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你部署一个正在使用的 ConfigMap 的更新时会发生什么？Kubernetes 将更新后的文件传递到容器中，但接下来发生什么取决于应用程序。一些应用程序在启动时将配置文件加载到内存中，然后忽略配置目录中的任何更改，因此更改
    ConfigMap 不会实际更改应用程序配置，直到 Pod 被替换。这个应用程序更加周到——它会监视配置目录并重新加载任何文件更改，因此部署到 ConfigMap
    的更新将更新应用程序配置。
- en: Try it now Update the app configuration with the ConfigMap from listing 4.9\.
    That increases the logging level, so the same Pod will now start writing more
    log entries.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 使用列表 4.9 中的 ConfigMap 更新应用程序配置。这将提高日志级别，因此相同的 Pod 现在将开始写入更多的日志条目。
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see my output in figure 4.10\. The sleep is there to give the Kubernetes
    API time to roll out the new configuration files to the Pod; after a couple of
    minutes, the new configuration is loaded, and the app is operating with enhanced
    logging.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图 4.10 中看到我的输出。这里的 sleep 是为了给 Kubernetes API 时间将新的配置文件滚动到 Pod；几分钟之后，新的配置被加载，应用程序以增强的日志记录方式运行。
- en: '![](../Images/4-10.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-10.jpg)'
- en: Figure 4.10 ConfigMap data is cached, so it takes couple of minutes for updates
    to reach Pods.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 ConfigMap 数据被缓存，因此更新需要几分钟才能到达 Pod。
- en: Volumes are a powerful option for loading config files, especially with apps
    like this, which react to changes and update settings on the fly. Bumping up the
    logging level without having to restart your app is a great help in tracking down
    issues. You need to be careful with your configuration, though, because volume
    mounts don’t necessarily work the way you expect. If the mount path for a volume
    already exists in the container image, then the ConfigMap directory overwrites
    it, replacing all the contents, which can cause your app to fail in exciting ways.
    Listing 4.9 shows an example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 卷是一个强大的选项，用于加载配置文件，特别是对于这种对更改做出反应并实时更新设置的应用程序。在不重启应用程序的情况下提高日志级别，有助于追踪问题。然而，你需要小心配置，因为卷挂载不一定按你预期的样子工作。如果卷的挂载路径已经在容器镜像中存在，那么
    ConfigMap 目录将覆盖它，替换所有内容，这可能导致你的应用程序以令人兴奋的方式失败。列表 4.9 展示了一个例子。
- en: Listing 4.9 todo-web-dev-broken.yaml, a Pod spec with a misconfigured mount
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.9 todo-web-dev-broken.yaml，一个配置错误的 Pod 规范
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a broken Pod spec, where the ConfigMap is loaded into the `/app` directory
    rather than the `/app/config` directory. The author probably intended this to
    merge the directories, adding the JSON config files to the existing app directory.
    Instead, it’s going to wipe out the application binaries.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个损坏的 Pod 规范，其中 ConfigMap 被加载到 `/app` 目录而不是 `/app/config` 目录。作者可能本意是想合并这两个目录，将
    JSON 配置文件添加到现有的应用程序目录中。然而，它将会清除应用程序的二进制文件。
- en: Try it now The Pod spec from listing 4.9 removes all the app binaries, so the
    replacement Pod won’t start. See what happens next.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 列表 4.9 中的 Pod 规范移除了所有应用程序的二进制文件，所以替换后的 Pod 不会启动。看看接下来会发生什么。
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The results here are interesting: the deployment breaks the app, and yet the
    app carries on working. That’s Kubernetes watching out for you. Applying the change
    creates a new Pod, and the container in that Pod immediately exits with an error,
    because the binary it tries to load no longer exists in the app directory. Kubernetes
    restarts the container a few times to give it a chance, but it keeps failing.
    After three tries, Kubernetes takes a rest, as you can see in figure 4.11.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里得到的结果很有趣：部署破坏了应用，但应用仍在继续工作。这是 Kubernetes 在为你留意。应用更改创建了一个新的 Pod，但该 Pod 中的容器立即因为错误而退出，因为它试图加载的二进制文件不再存在于应用目录中。Kubernetes
    重启容器几次以给它一个机会，但它一直失败。尝试了三次后，Kubernetes 休息一下，如图 4.11 所示。
- en: '![](../Images/4-11.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-11.jpg)'
- en: Figure 4.11 If an updated deployment fails, then the original Pod isn’t replaced.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 如果更新的部署失败，则原始 Pod 不会被替换。
- en: 'Now we have two Pods, but Kubernetes doesn’t remove the old Pod until the replacement
    is running successfully, which it never will in this case because we’ve broken
    the container setup. The old Pod isn’t removed and still happily serves requests;
    the new Pod is in a failed state, but Kubernetes periodically keeps restarting
    the container in the hope that it might have fixed itself. This is a situation
    to watch out for: the `apply` command seems to work, and the app carries on working,
    but it’s not using the manifest you’ve applied.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个 Pod，但 Kubernetes 不会删除旧的 Pod，直到替换的 Pod 成功运行，但在这个情况下永远不会发生，因为我们破坏了容器设置。旧的
    Pod 没有被删除，仍然愉快地处理请求；新的 Pod 处于失败状态，但 Kubernetes 定期重启容器，希望它可能已经修复了自己。这是一个需要注意的情况：`apply`
    命令似乎工作正常，应用仍在继续工作，但它没有使用你应用的模式。
- en: We’ll fix that now and show one final option for surfacing ConfigMaps in the
    container filesystem. You can selectively load data items into the target directory,
    rather than loading every data item as its own file. Listing 4.10 shows the updated
    Pod spec. The mount path has been fixed, but the volume is set to deliver only
    one item.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将修复它，并展示在容器文件系统中暴露 ConfigMaps 的最后一个选项。你可以选择性地将数据项加载到目标目录中，而不是将每个数据项作为自己的文件加载。列表
    4.10 显示了更新的 Pod 规范。挂载路径已经修复，但卷被设置为仅传递一个项目。
- en: Listing 4.10 todo-web-dev-no-logging.yaml, mounting a single ConfigMap item
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 todo-web-dev-no-logging.yaml，挂载单个 ConfigMap 项目
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This specification uses the same ConfigMap, so it is just an update to the
    deployment. This will be a cascading update: it will create a new Pod, which will
    start correctly, and then Kubernetes will remove the two previous Pods.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范使用相同的 ConfigMap，因此它只是对部署的更新。这将是一个级联更新：它将创建一个新的 Pod，该 Pod 将正确启动，然后 Kubernetes
    将删除两个之前的 Pod。
- en: Try it now Deploy the spec from listing 4.10, which rolls out the updated volume
    mount to fix the app but also ignores the logging JSON file in the ConfigMap.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：部署列表 4.10 中的规范，该规范将更新卷挂载以修复应用，但同时也忽略了 ConfigMap 中的日志 JSON 文件。
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Figure 4.12 shows my output. The app is working again, but it sees only a single
    configuration file, so the enhanced logging settings don’t get applied.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 展示了我的输出。应用再次工作，但它只看到一个配置文件，因此增强的日志设置没有得到应用。
- en: '![](../Images/4-12.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-12.jpg)'
- en: Figure 4.12 Volumes can surface selected items from a ConfigMap into a mount
    directory.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 卷可以将 ConfigMap 中的选定项目暴露到挂载目录中。
- en: ConfigMaps support a wide range of configuration systems. Between environment
    variables and volume mounts you should be able to store app settings in ConfigMaps
    and apply them however your app expects. The separation between the configuration
    spec and the app spec also supports different release workflows, allowing different
    teams to own different parts of the process. One thing you shouldn’t use ConfigMaps
    for, however, is any sensitive data—they’re effectively wrappers for text files
    with no additional security semantics. For configuration data that you need to
    keep secure, Kubernetes provides Secrets.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMaps 支持广泛的配置系统。在环境变量和卷挂载之间，你应该能够在 ConfigMaps 中存储应用设置，并以应用期望的方式应用它们。配置规范与应用规范之间的分离也支持不同的发布工作流程，允许不同的团队拥有流程的不同部分。然而，你不应该使用
    ConfigMaps 来存储任何敏感数据——它们实际上是没有任何额外安全语义的文本文件的包装器。对于需要保持安全性的配置数据，Kubernetes 提供了
    Secrets。
- en: 4.4 Configuring sensitive data with Secrets
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 使用 Secrets 配置敏感数据
- en: Secrets are a separate type of resource, but they have a similar API to ConfigMaps.
    You work with them in the same way, but because they’re meant to store sensitive
    information, Kubernetes manages them differently. The main differences are all
    around minimizing exposure. Secrets are sent only to nodes that need to use them
    and are stored in memory rather than on disk; Kubernetes also supports encryption
    both in transit and at rest for Secrets.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets是一种独立的资源类型，但它们具有与ConfigMaps相似的API。您以相同的方式与它们交互，但由于它们旨在存储敏感信息，Kubernetes以不同的方式管理它们。主要区别都围绕着最小化暴露。Secrets仅发送给需要使用它们的节点，并且存储在内存中而不是磁盘上；Kubernetes还支持对Secrets进行传输和静止加密。
- en: 'Secrets are not encrypted 100% of the time, though. Anyone who has access to
    Secret objects in your cluster can read the unencrypted values. There is an obfuscation
    layer: Kubernetes can read and write Secret data with Base64 encoding, which isn’t
    really a security feature but does prevent accidental exposure of secrets to someone
    looking over your shoulder.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Secrets并非总是加密的。任何可以访问您集群中Secret对象的用户都可以读取未加密的值。有一个混淆层：Kubernetes可以使用Base64编码读取和写入Secret数据，这并不是真正的安全功能，但可以防止秘密意外暴露给在您身后窥视的人。
- en: Try it now You can create Secrets from a literal value, passing the key and
    data into the kubectl command. The retrieved data is Base64 encoded.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 您可以从字面值创建Secrets，通过将键和数据传递给kubectl命令。检索到的数据是Base64编码的。
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see from the output in figure 4.13 that Kubernetes treats Secrets differently
    from ConfigMaps. The data values aren’t shown in the kubectl `describe` command,
    only the names of the item keys, and when you do fetch the data, it’s shown encoded,
    so you need to pipe it into a decoder to read it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从图4.13的输出中看到，Kubernetes对待Secrets和ConfigMaps的方式不同。数据值在kubectl `describe`命令中不会显示，只有项目键的名称，并且当您实际获取数据时，它会以编码的形式显示，因此您需要将其传递到解码器中才能读取。
- en: '![](../Images/4-13.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图4-13](../Images/4-13.jpg)'
- en: Figure 4.13 Secrets have a similar API to ConfigMaps, but Kubernetes tries to
    avoid accidental exposure.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13显示，Secrets与ConfigMaps具有相似的API，但Kubernetes试图避免意外暴露。
- en: That precaution doesn’t apply when Secrets are surfaced inside Pod containers.
    The container environment sees the original plain text data. Listing 4.11 shows
    a return to the sleep app, configured to load the new Secret as an environment
    variable.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当Secrets在Pod容器内部暴露时，这种预防措施不适用。容器环境看到的是原始的纯文本数据。列表4.11显示了返回到sleep应用程序，配置为将新的Secret作为环境变量加载。
- en: Listing 4.11 sleep-with-secret.yaml, a Pod spec loading a Secret
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.11 sleep-with-secret.yaml，一个加载Secret的Pod规范
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The specification to consume Secrets is almost the same as for ConfigMaps—a
    named environment variable can be loaded from a named item in a Secret. This Pod
    spec delivers the Secret item in its original form to the container.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 消费Secrets的规范几乎与ConfigMaps相同——一个命名环境变量可以从Secret中的命名项中加载。此Pod规范以原始形式将Secret项传递到容器中。
- en: Try it now Run a simple sleep Pod that uses the Secret as an environment variable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 运行一个简单的sleep Pod，它使用Secret作为环境变量。
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Figure 4.14 shows the output. In this case the Pod is using only a Secret, but
    Secrets and ConfigMaps can be mixed in the same Pod spec, populating environment
    variables or files or both.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14展示了输出结果。在这种情况下，Pod仅使用了一个Secret，但Secrets和ConfigMaps可以在同一个Pod规范中混合使用，填充环境变量或文件或两者兼而有之。
- en: '![](../Images/4-14.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图4-14](../Images/4-14.jpg)'
- en: Figure 4.14 Secrets loaded into Pods are not Base64 encoded.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14显示，加载到Pod中的Secrets不是Base64编码的。
- en: You should be wary of loading Secrets into environment variables. Securing sensitive
    data is all about minimizing its exposure. Environment variables can be read from
    any process in the Pod container, and some application platforms log all environment
    variable values if they hit a critical error. The alternative is to surface Secrets
    as files, if the application supports it, which gives you the option of securing
    access with file permissions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该小心将Secrets加载到环境变量中。保护敏感数据的关键在于最小化其暴露。环境变量可以从Pod容器中的任何进程中读取，并且一些应用程序平台在遇到关键错误时会记录所有环境变量的值。另一种选择是将Secrets作为文件暴露出来，如果应用程序支持的话，这为您提供了使用文件权限来保护访问权限的选项。
- en: To round off this chapter, we’ll run the to-do app in a different configuration
    where it uses a separate database to store items, running in its own Pod. The
    database server is Postgres using the official image on Docker Hub, which reads
    logon credentials from configuration values in the environment. Listing 4.12 shows
    a YAML spec for creating the database password as a Secret.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章，我们将以不同的配置运行待办事项应用程序，其中它使用单独的数据库来存储项目，在它自己的Pod中运行。数据库服务器是Postgres，使用Docker
    Hub上的官方镜像，它从环境中的配置值读取登录凭证。列表4.12显示了创建数据库密码作为秘密的YAML规范。
- en: Listing 4.12 -todo-db-secret-test.yaml, a Secret for the database user
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.12 -todo-db-secret-test.yaml，数据库用户的秘密
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This approach states the password in plain text in the `stringData` field,
    which gets encoded to Base64 when you create the Secret. Using YAML files for
    Secrets poses a tricky problem: it gives you a nice consistent deployment approach,
    at the cost of having all your sensitive data visible in source control.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在`stringData`字段中以纯文本形式声明密码，当创建秘密时，该密码会被编码为Base64。使用YAML文件作为秘密会带来一个棘手的问题：它提供了一个非常好的一致部署方法，但代价是所有敏感数据都可见于源代码控制。
- en: In a production scenario, you would keep the real data out of the YAML file,
    using placeholders instead, and do some additional processing as part of your
    deployment—some thing like injecting the data into the placeholder from a GitHub
    Secret. Whichever approach you take, remember that once the Secret exists in Kubernetes,
    it’s easy for anyone who has access to read the value.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产场景中，你会将真实数据从YAML文件中移除，使用占位符代替，并在部署过程中进行一些额外的处理——例如，从GitHub秘密中注入数据到占位符。无论你采取哪种方法，请记住，一旦秘密存在于Kubernetes中，任何有权访问的人都可以轻松地读取其值。
- en: Try it now Create a Secret from the manifest in listing 4.12, and check the
    data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看：从列表4.12中的清单创建一个秘密，并检查数据。
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can see in figure 4.15 that the string is encoded to Base64\. The outcome
    is the same as it would be if the specification used the normal data field and
    set the password value in Base64 directly in the YAML.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图4.15中看到字符串被编码为Base64。结果与如果规范使用了正常的数据字段并在YAML中直接以Base64设置密码值是相同的。
- en: '![](../Images/4-15.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图4-15](../Images/4-15.jpg)'
- en: Figure 4.15 Secrets created from string data are encoded, but the original data
    is also stored in the object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 从字符串数据创建的秘密被编码，但原始数据也存储在对象中。
- en: To use that Secret as the Postgres password, the image gives us a couple of
    options. We can load the value into an environment variable called `POSTGRES_PASSWORD`—not
    ideal—or we can load it into a file and tell Postgres where to load the file,
    by setting the `POSTGRES_PASSWORD_FILE` environment variable. Using a file means
    we can control access permissions at the volume level, which is how the database
    is configured in code listing 4.13.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此秘密作为Postgres密码使用，镜像为我们提供了几个选项。我们可以将值加载到名为`POSTGRES_PASSWORD`的环境变量中——这不是最佳选择——或者我们可以将其加载到文件中，并通过设置`POSTGRES_PASSWORD_FILE`环境变量告诉Postgres在哪里加载该文件。使用文件意味着我们可以在卷级别控制访问权限，这就是代码列表4.13中数据库的配置方式。
- en: Listing 4.13 todo-db-test.yaml, a Pod spec mounting a volume from a secret
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.13 todo-db-test.yaml，一个从秘密挂载卷的Pod规范
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When this Pod is deployed, Kubernetes loads the value of the Secret item into
    a file at the path /secrets/postgres_password. That file will be set with 0400
    permissions, which means it can be read by the container user but not by any other
    users. The environment variable is set for Postgres to load the password from
    that file, which the Postgres user has access to, so the database will start with
    credentials set from the Secret.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当此Pod部署时，Kubernetes将秘密项的值加载到路径为/secrets/postgres_password的文件中。该文件将设置为0400权限，这意味着它只能被容器用户读取，不能被任何其他用户读取。为Postgres设置环境变量，以便从该文件加载密码，该密码Postgres用户可以访问，因此数据库将使用从秘密设置的凭据启动。
- en: Try it now Deploy the database Pod, and verify the database starts correctly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看：部署数据库Pod，并验证数据库是否正确启动。
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Figure 4.16 shows the database starting up and waiting for connections—indicating
    it has been configured correctly—and the final output verifies that the file permissions
    are set as expected.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16显示了数据库正在启动并等待连接——表明它已正确配置——并且最终输出验证了文件权限已设置为预期。
- en: '![](../Images/4-16.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图4-16](../Images/4-16.jpg)'
- en: Figure 4.16 If the app supports it, configuration settings can be read by files
    populated from Secrets.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 如果应用程序支持，配置设置可以通过从秘密中填充的文件读取。
- en: All that’s left is to run the app itself in the test configuration, so it connects
    to the Postgres database rather than using a local database file for storage.
    There’s lots more YAML for that, to create a ConfigMap, Secret, Deployment, and
    Service, but it’s all using features we’ve covered already, so we’ll just go ahead
    and deploy.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是以测试配置运行应用程序本身，因此它连接到Postgres数据库而不是使用本地数据库文件进行存储。为此需要更多的YAML，以创建ConfigMap、Secret、Deployment和服务，但这些都是我们已经介绍过的功能，所以我们直接部署。
- en: Try it now Run the to-do app so it uses the Postgres database for storage.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 运行待办事项应用程序，使其使用Postgres数据库进行存储。
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: My output is shown in figure 4.17, where the plain text contents of the Secret
    JSON file are shown inside the web Pod container.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我的结果如图4.17所示，其中Secret JSON文件的纯文本内容显示在Web Pod容器内。
- en: '![](../Images/4-17.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-17.jpg)'
- en: Figure 4.17 Loading app configuration into Pods and surfacing ConfigMaps and
    Secrets as JSON files
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 将应用程序配置加载到Pod中，并将ConfigMaps和Secrets作为JSON文件暴露出来
- en: Now when you add to-do items in the app, they are stored in the Postgres database,
    so storage is separated from the application runtime. You can delete the web Pod;
    its controller will start a replacement with the same configuration, which connects
    to the same database Pod, so all the data from the original web Pod is still available.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您在应用程序中添加待办事项时，它们将存储在Postgres数据库中，因此存储与应用程序运行时分离。您可以删除Web Pod；其控制器将启动具有相同配置的替换Pod，该Pod连接到相同的数据库Pod，因此原始Web
    Pod的所有数据仍然可用。
- en: This has been a pretty exhaustive look at configuration options in Kubernetes.
    The principles are quite simple—loading ConfigMaps or Secrets into environment
    variables or files—but there are a lot of variations. You need a good understanding
    of the nuances so you can manage app configuration in a consistent way, even if
    your apps all have different configuration models.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Kubernetes中配置选项的相当详尽的审视。原则相当简单——将ConfigMaps或Secrets加载到环境变量或文件中——但是有很多变体。您需要很好地理解这些细微差别，以便以一致的方式管理应用程序配置，即使您的应用程序都具有不同的配置模型。
- en: 4.5 Managing app configuration in Kubernetes
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 在Kubernetes中管理应用程序配置
- en: 'Kubernetes gives you the tools to manage app configuration using whatever workflow
    fits for your organization. The core requirement is for your applications to read
    configuration settings from the environment, ideally with a hierarchy of files
    and environment variables. Then you have the flexibility to use ConfigMaps and
    Secrets to support your deployment process. You have two factors to consider in
    your design: do you need your apps to respond to live configuration updates, and
    how will you manage Secrets?'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes为您提供了使用适合您组织的任何工作流程来管理应用程序配置的工具。核心要求是您的应用程序从环境中读取配置设置，理想情况下具有文件和环境变量的层次结构。然后您可以使用ConfigMaps和Secrets来支持您的部署过程。在设计时，您需要考虑两个因素：您是否需要应用程序响应实时配置更新，以及您将如何管理Secrets？
- en: If live updates without a Pod replacement are important to you, then your options
    are limited. You can’t use environment variables for settings, because any changes
    to those result in a Pod replacement. You can use a volume mount and load configuration
    changes from files, but you need to deploy changes by updating the existing ConfigMap
    or Secret objects. You can’t change the volume to point to a new config object,
    because that’s a Pod replacement too.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对于您来说，无需替换Pod的实时更新很重要，那么您的选择有限。您不能使用环境变量进行设置，因为对那些变量的任何更改都会导致Pod替换。您可以使用卷挂载并从文件中加载配置更改，但您需要通过更新现有的ConfigMap或Secret对象来部署更改。您不能更改卷以指向新的配置对象，因为这同样属于Pod替换。
- en: The alternative to updating the same config object is to deploy a new object
    every time with some versioning scheme in the object name and updating the app
    Deployment to reference the new object. You lose live updates but gain an audit
    trail of configuration changes and have an easy option to revert back to previous
    settings. Figure 4.18 shows those options.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 更新相同配置对象的一种替代方案是在对象名称中包含某种版本控制方案，每次部署一个新对象，并将应用的部署更新为引用新对象。您将失去实时更新，但可以获得配置更改的审计跟踪，并且可以轻松地恢复到以前的设置。图4.18显示了这些选项。
- en: '![](../Images/4-18.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-18.jpg)'
- en: Figure 4.18 You can choose your own approach to configuration management, supported
    by Kubernetes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18 您可以选择自己的配置管理方法，由Kubernetes支持。
- en: The other question is how you manage sensitive data. Large organizations might
    have dedicated configuration management teams who own the process of deploying
    configuration files. That fits nicely with a versioned approach to ConfigMaps
    and Secrets, where the configuration management team deploys new objects from
    literals or controlled files in advance of the deployment.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是如何管理敏感数据。大型组织可能拥有专门的配置管理团队，负责部署配置文件的过程。这与对ConfigMaps和Secrets的版本化方法非常吻合，配置管理团队在部署之前从字面值或受控文件中部署新对象。
- en: An alternative is a fully automated deployment, where ConfigMaps and Secrets
    are created from YAML templates in source control. The YAML files contain placeholders
    instead of sensitive data, and the deployment process replaces them with real
    values from a secure store, like Azure KeyVault, before applying them. Figure
    4.19 compares those options.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是完全自动化的部署，其中ConfigMaps和Secrets从源控制中的YAML模板创建。YAML文件包含占位符而不是敏感数据，在应用之前，部署过程将它们替换为从安全存储（如Azure
    KeyVault）中的实际值。图4.19比较了这些选项。
- en: '![](../Images/4-19.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-19.jpg)'
- en: Figure 4.19 Secret management can be automated in deployment or strictly controlled
    by a separate team.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 在部署中可以自动化管理密钥，或者由一个独立的团队严格控制。
- en: You can use any approach that works for your teams and your application stacks,
    remembering that the goal is for all configuration settings to be loaded from
    the platform, so the same container image is deployed in every environment.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用适合你团队和应用程序堆栈的任何方法，记住目标是从平台加载所有配置设置，因此相同的容器镜像在所有环境中部署。
- en: It’s time to clean up your cluster. If you’ve followed along with all the exercises
    (and of course you have!), you’ll have a couple of dozen resources to remove.
    I’ll introduce some useful features of kubectl to help clear everything out.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候清理你的集群了。如果你已经跟随所有的练习（当然你做到了！），你将有一二十个资源需要移除。我将介绍一些kubectl的有用功能来帮助你清理所有内容。
- en: Try it now The kubectl `delete` command can read a YAML file and delete the
    resources defined in the file. And if you have multiple YAML files in a directory,
    you can use the directory name as the argument to `delete` (or `apply`), and it
    will run over all the files.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 kubectl `delete` 命令可以读取YAML文件并删除文件中定义的资源。如果你在目录中有多个YAML文件，你可以使用目录名作为`delete`（或`apply`）的参数，它将运行所有文件。
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 4.6 Lab
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 实验室
- en: 'If you’re reeling from all the options Kubernetes gives you to configure apps,
    this lab is going to help. In practice, your apps will have their own ideas about
    configuration management, and you’ll need to model your Kubernetes Deployments
    to suit the way your apps expect to be configured. That’s what you need to do
    in this lab with a simple app called Adminer. Here we go:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你被Kubernetes提供的配置应用选项搞得晕头转向，这个实验室将帮助你。在实践中，你的应用将有自己的配置管理想法，你需要根据你的应用期望的配置方式来建模你的Kubernetes部署。这就是在这个实验室中一个简单的名为Adminer的应用需要做的事情。让我们开始吧：
- en: Adminer, a web UI for administering SQL databases, can be a handy tool to run
    in Kubernetes when you’re troubleshooting database issues.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adminer，一个用于管理SQL数据库的Web UI，当你在调试数据库问题时，在Kubernetes中运行它可能是一个方便的工具。
- en: Start by deploying the YAML files in the `ch04/lab/postgres` folder, then deploy
    the ch04/lab/adminer.yaml file to run Adminer in its basic state.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，部署`ch04/lab/postgres`文件夹中的YAML文件，然后部署`ch04/lab/adminer.yaml`文件以在基本状态下运行Adminer。
- en: Find the external IP for your Adminer Service, and browse to port 8082\. Note
    that you need to specify a database server and that the UI design is stuck in
    the 1990s. You can confirm the connection to Postgres by using `postgres` as the
    database name, username, and password.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到你的Adminer服务的公网IP，并浏览到端口8082。请注意，你需要指定一个数据库服务器，并且UI设计卡在20世纪90年代。你可以通过使用`postgres`作为数据库名称、用户名和密码来确认与Postgres的连接。
- en: Your job is to create and use some config objects in the Adminer Deployment
    so that the database server name defaults to the lab’s Postgres Service, and the
    UI uses the much nicer design called `price`.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的任务是创建并使用一些配置对象在Adminer部署中，以便数据库服务器名称默认为实验室的Postgres服务，并且UI使用名为`price`的更美观的设计。
- en: You can set the default database server in an environment variable called `ADMINER_DEFAULT_SERVER`.
    Let’s call this sensitive data, so it should use a Secret.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在名为`ADMINER_DEFAULT_SERVER`的环境变量中设置默认数据库服务器。让我们称这些为敏感数据，因此它们应该使用密钥。
- en: The UI design is set in the environment variable `ADMINER_DESIGN`; that’s not
    sensitive, so a ConfigMap will do nicely.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI设计设置在环境变量`ADMINER_DESIGN`中；这不是敏感信息，所以使用ConfigMap就足够好了。
- en: 'This will take a little bit of investigation and some thought on how to surface
    the configuration settings, so it’s good practice for real application configuration.
    My solution is posted on GitHub for you to check your approach: [https://github.com/sixeyed/kiamol/blob/master/ch04/lab/README.md](https://github.com/sixeyed/kiamol/blob/master/ch04/lab/README.md).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一点调查和对如何展示配置设置的思考，因此这对于实际应用程序的配置来说是一个好的实践。我的解决方案已发布在GitHub上，供您检查您的方案：[https://github.com/sixeyed/kiamol/blob/master/ch04/lab/README.md](https://github.com/sixeyed/kiamol/blob/master/ch04/lab/README.md).
