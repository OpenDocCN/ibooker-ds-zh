- en: 4 Pipelines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 管道
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Stages in a GitOps CI/CD pipeline
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitOps CI/CD管道中的阶段
- en: Promoting code, image, and environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送代码、镜像和环境
- en: Rollback
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回滚
- en: Compliance pipeline
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合规性管道
- en: This chapter builds on the concepts learned in chapter 3 and discusses how pipelines
    are created to build and test application code and then deploy it to different
    environments. You will also learn about different promotion strategies and how
    to revert, reset, or roll back application changes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于第3章学到的概念，讨论了如何创建管道来构建和测试应用程序代码，然后将其部署到不同的环境。您还将了解不同的推广策略以及如何撤销、重置或回滚应用程序更改。
- en: We recommend you read chapters 1, 2, and 3 before reading this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您在阅读本章之前阅读第1章、第2章和第3章。
- en: 4.1 Stages in CI/CD pipelines
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 CI/CD管道中的阶段
- en: '*Continuous* *integration* (CI) is a software development practice in which
    all developers merge code changes in a central repository (Git). With CI, each
    code change (commit) triggers an automated build-and-test stage for the given
    repo and provides feedback to the developer(s) who made the change. The main difference
    between GitOps compared to traditional CI is that with GitOps, the CI pipeline
    also updates the application manifest with the new image version after the build
    and test stages have been completed successfully.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续集成*（CI）是一种软件开发实践，其中所有开发者将代码更改合并到中央仓库（Git）中。使用CI，每次代码更改（提交）都会触发针对给定仓库的自动构建和测试阶段，并向进行了更改的开发者提供反馈。与传统的CI相比，GitOps的主要区别在于，在构建和测试阶段成功完成后，GitOps的CI管道还会更新应用程序清单以包含新的镜像版本。'
- en: '*Continuous delivery* (CD) is the practice of automating the entire software
    release process. CD includes infrastructure provisioning in addition to deployment.
    What makes GitOps CD different from traditional CD is using a GitOps operator
    to monitor the manifest changes and orchestrate the deployment. As long as the
    CI build is complete and the manifest is updated, the GitOps operator takes care
    of the eventual deployment.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续交付*（CD）是自动整个软件发布过程的实践。CD包括基础设施提供和部署。使GitOps CD与传统CD不同的地方是使用GitOps操作员来监控清单更改并编排部署。只要CI构建完成且清单已更新，GitOps操作员就会负责最终的部署。'
- en: Note Please refer to section 2.5 for GitOps CI/CD and operator basics.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：请参阅第2.5节以了解GitOps CI/CD和操作员基础知识。
- en: 'This chapter takes an in-depth look at a comprehensive CI/CD pipeline and why
    it is important for software development. A CI/CD pipeline is a collection of
    stages, and each stage performs a specific task to achieve the following objectives:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了全面的CI/CD管道及其在软件开发中的重要性。CI/CD管道是一系列阶段的集合，每个阶段执行特定任务以实现以下目标：
- en: '*Productivity*—Provide valuable feedback for the developers early in the development
    cycle in terms of design, coding style, and quality without context switching.
    Code review, unit test, code coverage, code analysis, integration test, and run-time
    vulnerability are essential stages for design, quality, and security feedback
    to the developers.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生产力*—在开发周期的早期阶段，就设计、编码风格和质量提供有价值的反馈，而不需要切换上下文。代码审查、单元测试、代码覆盖率、代码分析、集成测试和运行时漏洞检测是设计、质量和安全反馈给开发者的关键阶段。'
- en: '*Security*—Detect code and component vulnerabilities that are attack surfaces
    for potential exploitation. A vulnerability scan can detect security issues with
    third-party libraries. A run-time vulnerability scan can detect run-time security
    issues with code.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全性*—检测代码和组件漏洞，这些漏洞是潜在利用的攻击面。漏洞扫描可以检测第三方库中的安全问题。运行时漏洞扫描可以检测代码的运行时安全问题。'
- en: '*Defect escape*—Reduce failure of customer interactions and costly rollback.
    A new release is typically providing new features or enhancing existing ones.
    If the features do not provide the correct functionality, the consequence will
    be customer dissatisfaction and potential revenue loss. Unit tests verify correctness
    at the module level, and functional tests verify correctness across two or more
    modules.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缺陷逃逸*—减少客户交互失败和昂贵的回滚。新版本通常提供新功能或增强现有功能。如果功能不能提供正确的功能，后果将是客户不满和潜在的收入损失。单元测试在模块级别验证正确性，而功能测试在两个或更多模块之间验证正确性。'
- en: '*Scalability*—Discover scalability issues before the production release. Unit
    tests and functional tests can verify the features’ correctness, but these stages
    cannot detect problems such as memory leaks, thread leaks, or resource contention
    issues. Canary release is a way to deploy the new version to detect scalability
    issues using production traffic and dependencies.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可扩展性*—在生产发布之前发现可扩展性问题。单元测试和功能测试可以验证功能的正确性，但这些阶段无法检测内存泄漏、线程泄漏或资源竞争等问题。金丝雀发布是一种通过生产流量和依赖关系部署新版本以检测可扩展性问题的方法。'
- en: '*Time to market*—Deliver features to customers quicker. With a fully automated
    CI/CD pipeline, there is no time-intensive manual work to deploy the software.
    The code can be released as soon as it passes all stages in the pipeline.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上市时间*—更快地将功能交付给客户。使用完全自动化的 CI/CD 管道，无需耗时的人工工作来部署软件。代码可以在通过管道中所有阶段后立即发布。'
- en: '*Reporting*—Insight for continuous improvement and metrics for auditability.
    CI/CD pipeline execution time in minutes versus hours can affect developers’ behavior
    and productivity. Continuously monitoring and improving the pipeline execution
    time can dramatically improve team productivity. Collecting and storing build
    metrics is also required for many regulatory audits. Please refer to the CI and
    CD metrics publishing stages for detail.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*报告*—持续改进的洞察和可审计性的指标。CI/CD 管道执行时间以分钟与小时相比，可能会影响开发者的行为和生产力。持续监控和改进管道执行时间可以显著提高团队生产力。收集和存储构建指标也是许多监管审计的必要条件。请参阅
    CI 和 CD 指标发布阶段以获取详细信息。'
- en: 4.1.1 GitOps continuous integration
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 GitOps 持续集成
- en: Figure 4.1 illustrates a comprehensive CI pipeline building on the GitOps CI/CD
    (figure 2.9) in chapter 2\. The boxes in gray are new stages for a complete CI
    solution. This section will help you plan and design stages relevant to your business
    based on your complexity, maturity, and compliance requirements.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 展示了基于第 2 章中 GitOps CI/CD（图 2.9）的全面 CI 管道构建。灰色框是完整 CI 解决方案的新阶段。本节将帮助您根据您的复杂性、成熟度和合规性要求规划并设计相关的阶段。
- en: '![](Images/CH04_F01_Yuen.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F01_Yuen.png)'
- en: Figure 4.1 These are the stages in a GitOps CI pipeline. White boxes are from
    the GitOps CI pipeline from figure 2.9, and gray boxes are the additional stages
    for building a complete CI pipeline.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 这些是 GitOps CI 管道中的阶段。白色框来自图 2.9 中的 GitOps CI 管道，灰色框是构建完整 CI 管道的附加阶段。
- en: Prebuild stages
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 预构建阶段
- en: The following stages are also known as *static analysis* stages. They are a
    combination of manual and automated scanning of the code before the code is built
    and packaged into a Docker image.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下阶段也称为 *静态分析* 阶段。它们是在代码构建和打包成 Docker 镜像之前对代码进行手动和自动扫描的组合。
- en: Pull request/code review
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取请求/代码审查
- en: All CI/CD pipelines should always start with a pull request, which allows code
    review to ensure consistency between design and implementation and catch other
    potential errors. As discussed in chapter 1, code review also helps share best
    practices, coding standards, and team cohesion.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 CI/CD 管道都应该始终从拉取请求开始，这允许代码审查以确保设计和实现之间的一致性，并捕捉其他潜在错误。如第 1 章所述，代码审查还有助于分享最佳实践、编码标准和团队凝聚力。
- en: Vulnerability scan
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞扫描
- en: Open source libraries can provide many functionalities without custom development,
    but those libraries can also come with vulnerabilities, defects, and licensing
    issues. Integrating an open source library scanning tool like Nexus Vulnerability
    Scanner can detect known vulnerabilities and licensing issues early in the development
    cycle and remediate the problems by either upgrading the libraries or using alternative
    libraries.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 开源库可以在不进行定制开发的情况下提供许多功能，但这些库也可能包含漏洞、缺陷和许可问题。集成开源库扫描工具，如 Nexus 漏洞扫描器，可以在开发周期的早期检测已知漏洞和许可问题，并通过升级库或使用替代库来修复问题。
- en: Note The old saying “If it ain’t broke, don’t fix it” doesn’t work anymore in
    the rapidly changing software industry. Vulnerabilities are discovered every day
    with open source libraries, and it is prudent to upgrade as soon as possible to
    avoid being exposed to exploits. At Intuit, we leverage open source software heavily
    to accelerate our development. Instead of doing an annual security audit, we now
    have a vulnerability scan step in our CI pipelines to detect and address security
    issues regularly during the development cycle.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在快速变化的软件行业中，老话“如果没问题，就别修”已经不再适用。每天都会发现开源库中的漏洞，因此尽快升级是谨慎的做法，以避免被利用。在 Intuit，我们大量使用开源软件来加速我们的开发。我们不再进行年度安全审计，而是在
    CI 流程中添加了一个漏洞扫描步骤，以便在开发周期中定期检测和解决安全问题。
- en: Code analysis
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分析
- en: While manual code review is excellent for design and implementation consistency,
    coding standards, duplicate code, and code complexity issues (aka code smells)^([1](#pgfId-1083171))
    are better suited to an automated linting or code analysis tool such as SonarQube.
    These tools are not a replacement for code review, but they can catch the mundane
    issues more effectively.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然手动代码审查对于设计和实现的一致性非常好，但对于编码标准、重复代码和代码复杂度问题（即代码异味）来说，更适合使用自动化的代码检查或代码分析工具，如
    SonarQube。这些工具不是代码审查的替代品，但它们可以更有效地捕捉到一些日常问题。
- en: Note It is unrealistic to expect every minor issue to be fixed before the new
    code can be deployed. With tools such as SonarQube, the trend data is also reported
    so the team can see how their code smell is getting better or worse over time
    so the team can address these issues before they have gone too far.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：期望在部署新代码之前解决每一个小问题是不现实的。使用 SonarQube 等工具时，趋势数据也会被报告，这样团队可以看到他们的代码质量是如何随时间变好或变差的，以便在问题恶化之前解决这些问题。
- en: Exercise 4.1
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.1
- en: To prevent known security issues with your open source library, what stage(s)
    do you need to plan in your CI/CD pipeline?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止你的开源库中已知的安全问题，你需要在 CI/CD 流程中计划哪些阶段？
- en: To ensure implementation matching the design, what stage(s) do you need to plan
    in your CI/CD pipeline?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保实现与设计相匹配，你需要在 CI/CD 流程中计划哪些阶段？
- en: Build stages
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 构建阶段
- en: After static analysis, it is time to build the code. In addition to building
    and creating the deployable artifact (aka Docker image), unit (module) testing
    and the effectiveness of the unit tests (code coverage) are integral parts of
    the build process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态分析之后，是构建代码的时候了。除了构建和创建可部署的工件（即 Docker 镜像）之外，单元测试（模块测试）及其有效性（代码覆盖率）是构建过程中的重要部分。
- en: Build
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 构建
- en: The build stage typically starts with downloading the dependency libraries before
    the project source code’s actual compilation. (Scripting languages such as Python
    and Node.js do not require compilation.) For compiled languages like Java, Ruby,
    and Go, the code is compiled into bytecode/machine binary using the respective
    compiler. Additionally, the generated binary and its dependency libraries need
    to be packaged into a deployable unit (such as jar or war in Java) for deployment.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 构建阶段通常在项目源代码的实际编译之前开始下载依赖库。（例如 Python 和 Node.js 这样的脚本语言不需要编译。）对于像 Java、Ruby
    和 Go 这样的编译语言，代码会被编译成字节码/机器二进制代码，使用相应的编译器。此外，生成的二进制代码及其依赖库需要被打包成一个可部署单元（例如 Java
    中的 jar 或 war 文件）以便部署。
- en: Note In our experience, the most time-consuming portion of the build is downloading
    the dependencies. It is highly recommended to cache your dependencies in your
    build system to reduce the build time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：根据我们的经验，构建过程中最耗时的部分是下载依赖项。强烈建议你在构建系统中缓存依赖项以减少构建时间。
- en: Unit test
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试
- en: A unit test is for verifying a small piece of code doing what it is supposed
    to do. Unit tests should have no dependencies on code outside the unit tested.
    Unit testing mainly focuses on testing the functionality of individual units only
    and does not uncover the issues that arise when different modules are interacting
    with each other. During unit testing, external calls are typically “mocked” to
    eliminate dependencies issues and reduce the test execution time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是为了验证一小段代码是否按照预期执行。单元测试不应依赖于单元测试之外的代码。单元测试主要关注测试单个单元的功能，并不揭示不同模块交互时出现的问题。在单元测试期间，外部调用通常会被“模拟”以消除依赖性问题并减少测试执行时间。
- en: Note In a unit test, mock objects can simulate the behavior of complex, real
    objects and are therefore useful when a real object is impractical or impossible
    to incorporate into a unit test.^([2](#pgfId-1083203)) In our experience, mocking
    is a required investment and will save the team time (faster test execution) and
    effort (troubleshooting flaky tests).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '注意：在单元测试中，模拟对象可以模拟复杂、真实对象的行为，因此当真实对象不切实际或不可能纳入单元测试时非常有用。[2](#pgfId-1083203)
    根据我们的经验，模拟是一个必要的投资，并将为团队节省时间（更快的测试执行）和精力（调试不可靠的测试）。 '
- en: Code coverage
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Code coverage measures the percentage of code that is covered by automated unit
    tests. Code coverage measurement simply determines which statements in a body
    of code have been executed through a test run and which statements have not. In
    general, a code coverage system instruments the source code and gathers the run-time
    information to generate a report on the test suite’s code coverage.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率衡量的是自动化单元测试覆盖的代码百分比。代码覆盖率测量简单地确定在测试运行中哪些代码语句被执行，哪些代码语句未被执行。通常，代码覆盖率系统会对源代码进行仪器化，并收集运行时信息以生成关于测试套件代码覆盖率的报告。
- en: Code coverage is a critical part of a feedback loop in the development process.
    As tests are developed, code coverage highlights aspects of the code that may
    not be adequately tested and require additional testing. This loop continues until
    coverage meets some specified target. Coverage should follow an 80-20 rule as
    increasing coverage values becomes difficult and return diminishes. Coverage measurement
    is not a replacement for thorough code review and programming best practices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是开发过程中反馈循环的关键部分。随着测试的开发，代码覆盖率突出了代码中可能未得到充分测试的方面，并需要额外的测试。这个循环会一直持续到覆盖率达到某个指定的目标。覆盖率应遵循80-20规则，因为提高覆盖率值变得困难，而回报减少。覆盖率测量不能替代彻底的代码审查和编程最佳实践。
- en: Note Driving code coverage percentages higher alone can lead to wrong behavior
    and may actually lower quality. Code coverage measures the percentage of lines
    being executed but does not measure the correctness of the code. 100-percent code
    coverage with partial assertions will *not* achieve the quality goal of unit testing.
    Our recommendation is to focus on increasing the number of unit tests and code
    coverage over time instead of focusing on an absolute code coverage number.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：仅提高代码覆盖率百分比可能会导致错误的行为，实际上可能会降低质量。代码覆盖率衡量的是正在执行的代码行百分比，但不衡量代码的正确性。带有部分断言的100%代码覆盖率不会实现单元测试的质量目标。我们的建议是，随着时间的推移，专注于增加单元测试和代码覆盖率，而不是专注于绝对代码覆盖率数字。
- en: Docker build
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Docker构建
- en: A Docker image is the deployable unit for Kubernetes. Once code has been built,
    you can create the Docker image with a unique image id for your build artifacts
    by creating a Dockerfile and executing the `docker` `build` command. A Docker
    image should have its unique naming convention, and each version should be tagged
    with a unique version number. Additionally, you can also run a Docker image scanning
    tool at this stage to detect potential vulnerability issues with your base images
    and dependencies.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像是Kubernetes的部署单元。一旦代码构建完成，你可以通过创建Dockerfile并执行`docker build`命令来创建具有唯一镜像ID的Docker镜像，用于你的构建工件。Docker镜像应遵循其独特的命名约定，并且每个版本都应该用唯一的版本号进行标记。此外，你还可以在此阶段运行Docker镜像扫描工具，以检测基础镜像和依赖项中潜在的安全漏洞问题。
- en: Docker Tag and Git Hash Since Git creates a unique hash for each commit, it
    is recommended to use the Git hash to tag the Docker image instead of creating
    an arbitrary version number. In addition to uniqueness, each Docker image can
    easily trace back to the Git repo history using the Git hash to determine the
    exact code in the Docker image. Please refer to section 2.5.2 for additional information.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Docker标签和Git哈希 由于Git为每个提交创建一个唯一的哈希值，因此建议使用Git哈希来标记Docker镜像，而不是创建一个任意的版本号。除了唯一性之外，每个Docker镜像都可以通过Git哈希轻松回溯到Git仓库的历史记录，以确定Docker镜像中的确切代码。请参阅第2.5.2节以获取更多信息。
- en: Docker push
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Docker推送
- en: The newly built Docker image needs to be published to a Docker registry^([3](#pgfId-1083226))
    for Kubernetes to orchestrate the eventual deployment. A Docker registry is a
    stateless, highly scalable server-side application that stores and lets you distribute
    Docker images. For in-house development, the best practice is to host a private
    registry to have tight control over where the images are stored. Please refer
    to chapter 6 for how best to host a secured private Docker registry.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 新构建的Docker镜像需要发布到Docker注册表^([3](#pgfId-1083226))，以便Kubernetes可以编排最终的部署。Docker注册表是一个无状态的、高度可扩展的服务端应用程序，用于存储和分发Docker镜像。对于内部开发，最佳实践是托管一个私有注册表，以便对镜像的存储位置有更紧密的控制。请参阅第6章了解如何最佳地托管安全的私有Docker注册表。
- en: Exercise 4.2
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.2
- en: Plan the build stage(s) required so code coverage metrics can be measured.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 规划所需的构建阶段（s），以便可以测量代码覆盖率指标。
- en: If the image is tagged with the latest tag, can you tell what was packaged in
    the Docker image?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果镜像带有最新的标签，你能告诉我Docker镜像中包含了什么吗？
- en: GitOps CI stages
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps CI阶段
- en: With traditional CI, the pipeline will end after the build stages. With GitOps,
    additional GitOps specific stages are required to update the manifest for the
    eventual deployment. Please refer to figure 4.1.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的CI中，管道将在构建阶段结束后结束。在GitOps中，需要额外的GitOps特定阶段来更新清单以实现最终的部署。请参阅图4.1。
- en: Git clone config repo
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Git克隆配置仓库
- en: Assuming your Kubernetes config is stored in a separate repo, this stage performs
    a Git clone to clone the Kubernetes config to the build environment for the subsequent
    stage to update your manifest.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的Kubernetes配置存储在一个单独的仓库中，此阶段执行Git克隆操作，将Kubernetes配置克隆到构建环境，以便后续阶段更新你的清单。
- en: Update manifests
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 更新清单
- en: Once you have the manifests in your build environment, you can update the manifests
    with the newly created image id using a configuration management tool like Kustomize.
    Depending on your deployment strategy, one or more environment-specific manifests
    are updated with the new image id. Please refer to chapter 3 for additional information
    on Kustomize.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在构建环境中有了清单，你可以使用配置管理工具（如Kustomize）使用新创建的镜像ID更新清单。根据你的部署策略，一个或多个环境特定的清单会更新为新镜像ID。有关Kustomize的更多信息，请参阅第3章。
- en: Git commit and push
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Git提交和推送
- en: Once the manifests are updated with a new image id, the last step is to commit
    the manifests back to the Git repo. The CI pipeline is complete at this point.
    Your GitOps operator detects the change in your manifests and deploys the change
    to the Kubernetes cluster. The following is an example of implementing the three
    stages with the Git command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦清单使用新的镜像ID更新，最后一步是将清单提交回Git仓库。此时CI管道完成。你的GitOps操作员会检测到清单中的变化，并将更改部署到Kubernetes集群。以下是一个使用Git命令实现三个阶段的示例。
- en: Postbuild stages
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 构建后阶段
- en: After everything is complete for the GitOps CI, additional stages are needed
    to gather metrics for continuous improvement and audit reporting and to notify
    the team of the build status.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitOps CI的所有工作完成后，还需要额外的阶段来收集指标以实现持续改进和审计报告，并通知团队构建状态。
- en: Publish CI metrics
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 发布CI指标
- en: CI metrics should be stored in a separate data store for
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: CI指标应存储在单独的数据存储中
- en: '*Build issues*—Development teams need relevant data to triage issues with build
    failure or unit test failure.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建问题*——开发团队需要相关数据来对构建失败或单元测试失败的问题进行分类。'
- en: '*CI*—Long build time can affect engineering teams’ behavior and productivity.
    Reduction in code coverage can potentially result in more production defects.
    Having historical build time and code coverage metrics enables teams to monitor
    trending, decrease build time, and increase code coverage.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CI*——长的构建时间可能会影响工程团队的行为和生产力。代码覆盖率的减少可能会导致生产缺陷增加。拥有历史构建时间和代码覆盖率指标使团队能够监控趋势，减少构建时间，并增加代码覆盖率。'
- en: '*Compliance requirements*—For SOC2 or PCI requirements, build information such
    as test results, who did the release, and what was released are required to be
    maintained anywhere from 14 months up to 7 years.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*合规性要求*——对于SOC2或PCI要求，需要维护诸如测试结果、谁进行了发布以及发布了什么等信息，这些信息需要从14个月到7年不等的时间。'
- en: Note It is costly to maintain build history for greater than one year for most
    build systems. One alternative is to export the build metrics to external storage,
    such as S3, to fulfill the compliance and reporting requirements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于大多数构建系统来说，维护超过一年的构建历史记录是昂贵的。一个替代方案是将构建指标导出到外部存储，如S3，以满足合规性和报告要求。
- en: Build notification
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 构建通知
- en: For CI/CD deployment, most teams would prefer the “No news is good news” model,
    which means that if all stages are successful, they don’t need to be bothered
    with the build status. In the case of build issues, teams should be informed right
    away so they can get feedback and rectify the problem. This stage is typically
    implemented using team messaging or an email system, so teams can be notified
    as soon as the CI/CD pipeline is complete.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CI/CD部署，大多数团队更喜欢“无消息即好消息”模型，这意味着如果所有阶段都成功，他们不需要担心构建状态。在构建出现问题时，团队应立即得到通知，以便他们可以获取反馈并纠正问题。此阶段通常通过团队消息或电子邮件系统实现，以便在CI/CD管道完成后立即通知团队。
- en: Exercise 4.3
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.3
- en: What are the steps for the development team to determine build status if there
    is no build notification?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有构建通知，开发团队应采取哪些步骤来确定构建状态？
- en: Is 80% code coverage good or bad?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 80%的代码覆盖率是好是坏？
- en: Hint Trending.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 提示趋势。
- en: If the CI/CD pipeline typically takes an hour to run, what other tasks can developers
    do during that time? What if the CI/CD pipeline takes 10 minutes instead?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CI/CD管道通常需要一小时来运行，那么开发者在这段时间内可以做哪些其他任务？如果CI/CD管道只需要10分钟呢？
- en: '![](Images/CH04_F02_Yuen.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F02_Yuen.png)'
- en: Figure 4.2 Prebuild will involve code review and static analysis. After build
    completion, GitOps CI will update the manifest (subsequently deployed by GitOps
    operator).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2预构建将涉及代码审查和静态分析。构建完成后，GitOps CI将更新清单（随后由GitOps操作员部署）。
- en: Exercise 4.4
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.4
- en: There are two challenges with the GitOps stages, and this exercise will provide
    the steps to address these issues.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps阶段有两个挑战，这个练习将提供解决这些问题的步骤。
- en: Which Git user should you use to track the manifest update and commit?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该使用哪个Git用户来跟踪清单更新和提交？
- en: How do you handle concurrent CI builds which can update the repo simultaneously?
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何处理可能同时更新仓库的并发CI构建？
- en: Before you start, please fork the repo [https://github.com/gitopsbook/resources.git](https://github.com/gitopsbook/resources.git).
    This exercise will assume that your local computer is the build system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始之前，请将仓库[https://github.com/gitopsbook/resources.git](https://github.com/gitopsbook/resources.git)进行分叉。这个练习将假设您的本地计算机是构建系统。
- en: 'Clone the repo from Git. We will assume that guestbook.yaml in the folder chapter-04/exercise4.4
    is your application manifest:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Git克隆仓库。我们将假设文件夹chapter-04/exercise4.4中的guestbook.yaml是您的应用程序清单：
- en: '[PRE0]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use `git config` to specify the committer user email and name. Depending on
    your requirement, you can use a service account or the actual committer account:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`git config`指定提交者的用户电子邮件和姓名。根据您的需求，您可以使用服务账户或实际的提交者账户：
- en: '[PRE1]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note Please refer to section 4.2.1 for creating strong identity guarantees.
    The specified-user also needs to exist in your remote Git repo.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意请参考第4.2.1节以创建强大的身份保证。指定的用户也需要存在于您的远程Git仓库中。
- en: 'Let’s assume that the new Docker image has the Git hashtag `zzzzzz`. We will
    update the manifest with tag `zzzzzz`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设新的Docker镜像具有Git标签`zzzzzz`。我们将使用标签`zzzzzz`更新清单：
- en: '[PRE2]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note To keep it simple, we will use cd to update the manifest in this exercise.
    Typically, you should be using config tools like Kustomize to update the image
    id.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意为了简化，在这个练习中我们将使用cd来更新清单。通常，您应该使用像Kustomize这样的配置工具来更新镜像ID。
- en: 'Next, we will commit the change to the manifest:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将将更改提交到清单：
- en: '[PRE3]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Given the repo could be updated by others, we will run Git `rebase` to pull
    down any new commit(s) to our local branch:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于仓库可能被其他人更新，我们将运行Git `rebase`以拉取任何新的提交到我们的本地分支：
- en: '[PRE4]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we are ready to push the updated manifest back to the repo and let the
    GitOps operator do its deployment magic:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备将更新的清单推回仓库，并让GitOps操作员执行其部署魔法：
- en: '[PRE5]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 4.1.2 GitOps continuous delivery
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 GitOps持续交付
- en: Figure 4.3 illustrates a comprehensive CD pipeline building on the GitOps CI/CD
    (chapter 2). The boxes in gray are new stages for a complete CD solution. Depending
    on your complexity, maturity, and compliance requirements, you can pick and choose
    the relevant stages for your business.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3展示了基于GitOps CI/CD（第2章）的综合CD管道构建。灰色框是完整CD解决方案的新阶段。根据您的复杂性、成熟度和合规性要求，您可以挑选和选择适合您业务的相关阶段。
- en: '![](Images/CH04_F03_Yuen.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F03_Yuen.png)'
- en: Figure 4.3 These are the stages in a GitOps CD pipeline. White boxes are from
    the GitOps CI pipeline from figure 2.9, and gray boxes are the additional stages
    for building a complete CI pipeline.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 这是GitOps CD管道中的阶段。白色框来自图2.9中的GitOps CI管道，灰色框是构建完整CI管道的附加阶段。
- en: Note The stages in the diagram depict the logical sequence. In practice, the
    GitOps stages are triggered by manifest changes in the Git repo and executed independently
    from the rest of the stages.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意图中的阶段表示逻辑顺序。在实践中，GitOps阶段由Git仓库中的清单更改触发，并独立于其他阶段执行。
- en: GitOps CD stages
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps CD阶段
- en: These are logical stages performed by the GitOps operator to deploy based on
    manifest change.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是GitOps操作员根据清单更改执行的逻辑阶段，以进行部署。
- en: Git clone config repo
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Git clone配置仓库
- en: The GitOps operator detects changes in your repo and performs a Git clone to
    get your Git repo’s latest manifests.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps操作员检测仓库中的更改，并执行Git clone以获取Git仓库的最新清单。
- en: Discover manifests
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 发现清单
- en: The GitOps Operator also determines any delta between the manifests in Kubernetes
    versus the latest manifests from Git repo. If there is no difference, the GitOps
    operator stops at this point.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps操作员还会确定Kubernetes中的清单与Git仓库的最新清单之间的任何差异。如果没有差异，GitOps操作员将在此处停止。
- en: Kubectl apply
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl apply
- en: If the GitOps operator determines differences between Kubernetes manifests and
    Git repo manifests, the GitOps operator applies the new manifests to Kubernetes
    using the `kubectl` `apply` command.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果GitOps操作员确定Kubernetes清单与Git仓库清单之间的差异，则GitOps操作员将使用`kubectl apply`命令将新清单应用到Kubernetes上。
- en: Note Please refer to chapter 2 for details.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意请参阅第2章以获取详细信息。
- en: Postdeployment stages
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后阶段
- en: After the image is deployed, we can test the new code end to end against dependencies
    and run-time vulnerability.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 部署镜像后，我们可以测试新代码与依赖项和运行时漏洞的端到端。
- en: Integration tests
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration testing is a type of testing to check if different modules are working
    correctly together. Once the image is deployed in the QA environment, integration
    testing can test across multiple modules and other external systems like databases
    and services. Integration testing aims to discover issues that arise when different
    modules interact to perform a higher-level function that cannot be covered by
    unit tests.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是一种测试类型，用于检查不同的模块是否正确协同工作。一旦镜像在QA环境中部署，集成测试就可以跨多个模块和其他外部系统（如数据库和服务）进行测试。集成测试旨在发现当不同模块交互以执行无法通过单元测试覆盖的高级功能时出现的问题。
- en: Note Since the GitOps operator handles the deployment outside of the pipeline,
    deployment might not be completed before the functional tests execute. Exercise
    4.6 discusses the steps required to make integration tests working with GitOps
    CD.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意由于GitOps操作员在管道之外处理部署，部署可能在实际测试执行之前未完成。练习4.6讨论了使集成测试与GitOps CD一起工作的步骤。
- en: Run-time vulnerability
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时漏洞
- en: Run-time vulnerabilities are traditionally detected by penetration testing.
    *Penetration testing*, also called pen testing or ethical hacking, is the practice
    of testing a computer system, network, or web application to find security vulnerabilities
    that an attacker could exploit. Typical run-time vulnerabilities are SQL injection,
    command injection, or issuing insecure cookies. Instead of doing penetration testing
    in a production system (which is costly and after the fact), the QA environment
    can be instrumented using an agent tool like Contrast^([4](#pgfId-1083405)) while
    executing the integration tests to detect any run-time vulnerabilities early in
    the development cycle.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时漏洞传统上通过渗透测试来检测。*渗透测试*，也称为pen testing或道德黑客，是测试计算机系统、网络或Web应用程序以寻找攻击者可能利用的安全漏洞的实践。典型的运行时漏洞包括SQL注入、命令注入或发布不安全的cookie。而不是在生产系统中进行渗透测试（这既昂贵又事后的），在执行集成测试时可以使用像Contrast^([4](#pgfId-1083405))这样的代理工具对QA环境进行配置，以在开发周期早期检测任何运行时漏洞。
- en: Publish CD metrics
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 发布CD指标
- en: CD metrics should be stored in a separate data store for
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: CD指标应存储在单独的数据存储中，
- en: '*Run-time issues*—Development teams need relevant data to triage issues with
    deployment, integration test failures, or run-time vulnerabilities.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行时问题*——开发团队需要相关数据来对部署、集成测试失败或运行时漏洞进行分类。'
- en: '*Compliance requirements*—For SOC2 or PCI requirements, build information such
    as test results, who did the release, and what was released are required to be
    maintained anywhere from 14 months up to 7 years.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*合规性要求*——对于SOC2或PCI要求，需要维护有关测试结果、谁进行了发布以及发布了什么等信息，这些信息可能需要从14个月到7年不等。'
- en: Exercise 4.5
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.5
- en: Design a CD pipeline that can detect SQL injection vulnerabilities.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个可以检测SQL注入漏洞的CD管道。
- en: Hint SQL injection is a run-time vulnerability.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 提示SQL注入是一种运行时漏洞。
- en: Exercise 4.6
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.6
- en: This exercise covers how you can ensure changes are applied to Kubernetes and
    the deployment completes successfully. We will use frontend-deployment.yaml as
    our manifest.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习涵盖如何确保更改应用到 Kubernetes 并成功完成部署。我们将使用 frontend-deployment.yaml 作为我们的清单文件。
- en: Listing 4.1 frontend-deployment.yaml
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 frontend-deployment.yaml
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run `kubectl` `diff` to determine if the frontend-deployment.yaml manifest
    is applied to Kubernetes. `exit` `status` `1` means the manifest is not in Kubernetes:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `kubectl` `diff` 以确定 frontend-deployment.yaml 清单是否已应用到 Kubernetes。`exit`
    `status` `1` 表示清单不在 Kubernetes 中：
- en: '[PRE7]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Apply the manifest to Kubernetes:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将清单应用到 Kubernetes：
- en: '[PRE8]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Rerun `kubectl` `diff`, and you should see the manifest applied with exit status
    0\. Kubernetes will start the deployment after the manifest update:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行 `kubectl` `diff`，你应该看到清单已应用且退出状态为 0。Kubernetes 将在清单更新后开始部署：
- en: '[PRE9]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Repeatedly run `kubectl` `rollout` `status` until the deployment is fully complete:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复运行 `kubectl` `rollout` `status`，直到部署完全完成：
- en: '[PRE10]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In production, you would automate this work using a script with a loop and sleep
    around the `kubectl` `rollout` `status` command.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，您将使用一个带有循环和 `kubectl` `rollout` `status` 命令的休眠的脚本来自动化这项工作。
- en: Listing 4.2 DeploymentWait.sh
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 DeploymentWait.sh
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Initializes the RETRY variable to 0
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 RETRY 变量初始化为 0
- en: ❷ Defines the kubectl rollout status command
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义 kubectl rollout status 命令
- en: ❸ Loops exit condition when kubectl rollout status is true or the RETRY variable
    equals 120\. This example waits up to 20 minutes (120 x 10 seconds).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当 kubectl rollout status 为真或 RETRY 变量等于 120 时退出循环。此示例等待最多 20 分钟（120 x 10 秒）。
- en: ❹ Executes the kubectl rollout status command
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 执行 kubectl rollout status 命令
- en: ❺ Increments the RETRY variable by 1
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将 RETRY 变量增加 1
- en: ❻ Sleeps for 10 seconds
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 等待 10 秒
- en: 4.2 Driving promotions
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 驱动推广
- en: Now that we have covered all the stages in the CI/CD pipeline, we can take a
    look at how the CI/CD pipeline can automate the promotion of code, image, and
    environment. An automated environment promotion’s main benefit is to enable your
    team to deploy new code to production faster and more reliably.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了 CI/CD 管道中的所有阶段，我们可以看看 CI/CD 管道如何自动化代码、镜像和环境的推广。自动化环境推广的主要好处是使您的团队能够更快、更可靠地将新代码部署到生产环境中。
- en: 4.2.1 Code vs. manifest vs. app config
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 代码 vs. 清单 vs. 应用配置
- en: 'In chapter 3, we started the discussion of the Git strategy consideration for
    working with GitOps. We discussed the benefit of keeping code and Kubernetes manifests
    in separate repos for more flexible deployment choices, better access control,
    and auditability. Where should we maintain application configuration for environment-specific
    dependencies such as database connection or distributed cache? There are several
    options for maintaining the environment configuration:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章，我们开始讨论与 GitOps 一起工作时对 Git 策略的考虑。我们讨论了将代码和 Kubernetes 清单保存在单独的仓库中以实现更灵活的部署选择、更好的访问控制和可审计性的好处。我们应该在哪里维护针对特定环境依赖的应用配置，例如数据库连接或分布式缓存？维护环境配置有几种选择：
- en: '*Docker image*—All environment-specific app config files can be bundled in
    the Docker image. This strategy works best to quickly package legacy applications
    (with all environment app config bundled) into Kubernetes. The disadvantage is
    that creating a new environment requires a full build and cannot reuse existing
    images.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker 镜像*—所有环境特定的应用配置文件都可以打包在 Docker 镜像中。这种策略最适合快速打包带有所有环境应用配置的遗留应用程序（打包到
    Kubernetes 中）。缺点是创建新环境需要完整的构建，并且不能重用现有镜像。'
- en: C*onfigMaps*—ConfigMaps are native resources in Kubernetes and are stored in
    the Kubernetes `etcd` database. The disadvantage is that Pods need to be restarted
    if the ConfigMap is updated.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C*onfigMaps*—ConfigMaps 是 Kubernetes 的原生资源，存储在 Kubernetes 的 `etcd` 数据库中。缺点是如果更新
    ConfigMap，Pod 需要重新启动。
- en: '*Config repo*—Storing app config in a separate repo can achieve the same result
    as a ConfigMap. The added benefit is that the Pod can pick up changes in the application
    configuration dynamically (such as using Spring Cloud Config in Java).'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Config repo*—将应用程序配置存储在单独的仓库中可以达到与 ConfigMap 相同的效果。额外的优点是 Pod 可以动态地获取应用程序配置中的更改（例如，在
    Java 中使用 Spring Cloud Config）。'
- en: Note Given an environment consisting of code, manifest, and app config, any
    error in the repo changes could result in a production outage. Any changes to
    the code, manifest, or app config repo should follow strict pull request/code
    review to ensure correctness.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：给定由代码、清单和应用程序配置组成的 环境，任何仓库更改中的错误都可能导致生产中断。对代码、清单或应用程序配置仓库的任何更改都应遵循严格的拉取请求/代码审查，以确保正确性。
- en: Exercise 4.7
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.7
- en: Assume the code, manifest, and app config are kept in a single repo. You need
    to update the manifest for one of the environment’s replicas from X to Y. How
    can you commit the change only for GitOps deployment without building another
    image?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设代码、清单和应用程序配置保存在单个仓库中。您需要更新环境中副本的清单，从X更新到Y。您如何仅对GitOps部署进行更改提交，而不需要构建另一个镜像？
- en: 4.2.2 Code and image promotion
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 代码和图像推广
- en: Promotion is defined as “the act or fact of being raised in position or rank.”
    Code promotion means the code changes are committed to a feature branch and merged
    (promoted) with the master branch through a pull request. Once a new image is
    built and published by CI, it is then deployed (promoted) by the GitOps CD operator
    (section 4.1).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 推广被定义为“提升地位或等级的行为或事实。”代码推广意味着代码更改被提交到特性分支，并通过拉取请求与主分支合并（推广）。一旦CI构建并发布了一个新镜像，它随后将由GitOps
    CD操作员（第4.1节）部署（推广）。
- en: Note Imagine you are building a math library with addition and subtraction functions.
    You will first clone the master branch to create a new branch called addition.
    Once you complete implementing the addition functionality, you commit the code
    to the addition branch and generate a pull request to merge to the master branch.
    GitOps CI will create a new image and update the manifest. The GitOps operator
    will eventually deploy the new image. Then you can repeat the process to implement
    the subtraction functionality.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 想象你正在构建一个包含加法和减法功能的数学库。你首先会克隆主分支以创建一个名为addition的新分支。一旦你完成了加法功能的实现，你将代码提交到addition分支，并生成一个拉取请求以合并到主分支。GitOps
    CI将创建一个新镜像并更新清单。GitOps操作员最终将部署新镜像。然后你可以重复此过程以实现减法功能。
- en: The code repo branching strategy has a direct impact on the image-promotion
    process. Next, we discuss the pros and cons of a single- versus multibranching
    strategy for the image-promotion process.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 代码仓库分支策略对图像推广过程有直接影响。接下来，我们将讨论单分支与多分支策略在图像推广过程中的优缺点。
- en: Single-branch strategy
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 单分支策略
- en: '*Single-branch* *strategy* is also called feature-branch workflow.^([5](#pgfId-1083556))
    In this strategy, the master branch is the official project history. Developers
    create short-lived feature branches for development. Once developers finish the
    feature, the changes are merged back to the master branch through the PR process.
    The CI build will be triggered when the PR is approved to bundle the new code
    into a new Docker image.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*单分支* *策略* 也被称为特性分支工作流程.^([5](#pgfId-1083556)) 在此策略中，主分支是官方项目历史。开发者创建短生命周期的特性分支进行开发。一旦开发者完成特性，通过PR流程将更改合并回主分支。当PR被批准时，CI构建将被触发，将新代码打包成新的Docker镜像。'
- en: With single-branch development, every image from the CI build can be promoted
    to any environment and used for a production release. If you need to roll back,
    you can redeploy with any older images from the Docker registry. This strategy
    is excellent and works best if your service can be deployed independently (aka
    microservice) and enables your team to do frequent production releases.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单分支开发，CI构建的每个镜像都可以推广到任何环境并用于生产发布。如果您需要回滚，可以使用Docker注册表中任何较旧的镜像重新部署。这种策略非常出色，如果您的服务可以独立部署（即微服务）并允许您的团队进行频繁的生产发布，则效果最佳。
- en: '![](Images/CH04_F04_Yuen.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F04_Yuen.png)'
- en: Figure 4.4 In the single-branch strategy, only the master branch is long-lived,
    and all feature branches will be short-lived. There is only one CI build for the
    master branch.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 在单分支策略中，只有主分支是长期存在的，所有特性分支都是短期存在的。主分支只有一个CI构建。
- en: Multibranch strategy
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 多分支策略
- en: A *multibranch strategy* is typically for larger projects that require close
    coordination of external dependencies and release planning. There are many variations
    of the multibranch strategy. For this discussion, we use the Gitflow workflow^([6](#pgfId-1083584))
    as an example. With Gitflow, the develop branch has the official project history,
    and the master branch has the last production release history. The CI build is
    configured for the develop branch for C. For feature development, developers create
    short-lived feature branches and merge changes to the develop branch once the
    feature is complete.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*多分支策略*通常用于需要紧密协调外部依赖和发布计划的大型项目。多分支策略有很多变体。在本讨论中，我们使用Gitflow工作流程^([6](#pgfId-1083584))作为示例。在Gitflow中，develop分支包含官方项目历史，master分支包含最后的发布历史。CI构建为develop分支配置C。对于功能开发，开发者在功能完成时创建短期功能分支并将更改合并到develop分支。'
- en: When a release is planned, a short-lived release branch is forked from the latest
    development branch, and testing and bug fixing continue in this branch until the
    code is ready for production deployment. Hence, a separate CI build needs to be
    configured to build new Docker images from the release branch. Once the release
    is complete, all changes are merged into the develop and master branches.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当计划发布时，会从最新开发分支创建一个短期发布的分支，并在该分支中进行测试和错误修复，直到代码准备好进行生产部署。因此，需要配置一个单独的CI构建来从发布分支构建新的Docker镜像。一旦发布完成，所有更改都将合并到开发和主分支。
- en: Unlike the single-branch strategy, only the release CI build images can ever
    be deployed to production. All images from the develop branch can only be used
    for preprod testing and integration. If rollback is needed, only images built
    from the release branch can be used. If roll-forward (or hotfix) is required for
    a production issue, a hotfix branch must be forked from the master branch, and
    a separate CI build created for the hotfix image.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与单分支策略不同，只有发布CI构建的镜像可以部署到生产环境。所有来自develop分支的镜像只能用于预生产测试和集成。如果需要回滚，只能使用从发布分支构建的镜像。如果需要向前推进（或热修复）生产问题，必须从master分支创建hotfix分支，并为hotfix镜像创建单独的CI构建。
- en: '![](Images/CH04_F05_Yuen.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F05_Yuen.png)'
- en: Figure 4.5 In the multibranch strategy, there will be multiple long-lived branches,
    and each long-lived branch will have its own CI pipeline. In this example, the
    long-lived branches are develop, master, and hotfix.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 在多分支策略中，将有多个长期分支，每个长期分支都将有自己的CI管道。在这个例子中，长期分支是develop、master和hotfix。
- en: Exercise 4.8
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.8
- en: Your service needs to release a feature on a specific date. Using a multibranch
    strategy, design a successful release.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您的服务需要在特定日期发布一个功能。使用多分支策略，设计一个成功的发布。
- en: Using a single-branch strategy, design a successful release for the specific
    date.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单分支策略，为特定日期设计一个成功的发布。
- en: Hint Feature flag.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：功能标志。
- en: 4.2.3 Environment promotion
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 环境推广
- en: In this section, we will discuss how to promote an image from preproduction
    to our production environment. The reason for having multiple environments and
    promoting the change is to shift as much testing as possible in the lower environment
    (shifting left), so we can detect and correct errors early in the development
    cycle.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何将镜像从预生产环境推广到我们的生产环境。拥有多个环境和推广更改的原因是将尽可能多的测试转移到较低的环境（左移），这样我们可以在开发周期的早期检测和纠正错误。
- en: There are two aspects to environment promotion. The first one is the environment
    infrastructure. As we discussed in chapter 3, Kustomize is the preferred config
    management tool to promote the new image to each environment, and the GitOps operator
    will do the rest!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 环境推广有两个方面。第一个方面是环境基础设施。正如我们在第3章中讨论的，Kustomize是推广新镜像到每个环境的首选配置管理工具，GitOps操作员将完成剩余的工作！
- en: The second aspect is the application itself. Since the Docker image is the immutable
    binary, injecting the environment-specific app config will configure the application
    to behave for the specific environment.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方面是应用程序本身。由于Docker镜像是不变的二进制文件，注入特定环境的应用程序配置将配置应用程序以适应特定环境。
- en: In chapter 3, we introduced QA, E2E, Stage, and Prod environments and discussed
    each environment’s unique purpose in the development cycle. Let’s review the stages
    that are important for each environment.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们介绍了质量保证（QA）、端到端（E2E）、阶段和产品（Prod）环境，并讨论了每个环境在开发周期中的独特目的。让我们回顾一下对每个环境都重要的阶段。
- en: QA
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 质量保证（QA）
- en: 'The QA environment is the first environment running the new image for verifying
    the correctness of the code during execution with external dependencies. The following
    stages are critical for the QA environment:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: QA环境是第一个运行新镜像以验证代码在执行过程中与外部依赖项正确性的环境。以下阶段对于QA环境至关重要：
- en: Functional test
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: Run-time vulnerability
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时漏洞
- en: Publish metrics
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布指标
- en: E2E
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: E2E
- en: The E2E environment is primarily for other applications to test out existing
    or prerelease features. E2E environments should be monitored and operated similar
    to the Prod environment because E2E outage could potentially block the CI/CD pipelines
    of other services. An optional verification stage (sanity testing with the subset
    of the functional tests) is applicable for the E2E environment to ensure its correctness.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: E2E环境主要用于其他应用程序测试现有或预发布功能。E2E环境应像Prod环境一样进行监控和操作，因为E2E中断可能会潜在地阻塞其他服务的CI/CD管道。对于E2E环境，可选的验证阶段（使用功能测试子集进行健全性测试）适用于确保其正确性。
- en: Stage
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段
- en: The Stage environment will typically connect to the production dependencies
    to ensure all production dependencies are in place before the production release.
    For example, a new version might depend on DB schema updates or message queues
    to be configured before it can be deployed. Testing with staging can guarantee
    all production dependencies are correct and avoid production issues.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段环境通常将连接到生产依赖项，以确保在生产发布之前所有生产依赖项都已就绪。例如，新版本可能依赖于数据库模式更新或消息队列配置，然后才能部署。使用预发布环境进行测试可以保证所有生产依赖项都是正确的，并避免生产问题。
- en: PROD
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: PROD
- en: Canary release
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀发布
- en: Canary release^([7](#pgfId-1083659)) is a technique to reduce the risk of introducing
    a new software version in production by slowly rolling out the change to a small
    subset of users before rolling it out to the entire infrastructure and making
    it available to everybody. We will have an in-depth discussion in chapter 5 of
    canary release and how it can be implemented in Kubernetes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀发布^([7](#pgfId-1083659))是一种技术，通过在将更改缓慢推出到整个基础设施并使其对所有用户可用之前，先将其推出到一小部分用户，以降低在生产中引入新软件版本的风险。我们将在第5章深入讨论金丝雀发布及其如何在Kubernetes中实现。
- en: Release ticket
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 发布票据
- en: Given the complexity and distributed nature of application services, a release
    ticket is crucial for your production support team in case of a production incident.
    A release ticket will assist the production incident team in knowing what was
    deployed/changed by whom and what to roll back to if needed. Besides, release
    tracking is a must for compliance requirements.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到应用服务的复杂性和分布式特性，发布票据在生产事故发生时对您的生产支持团队至关重要。发布票据将帮助生产事故团队了解是谁部署/更改了什么，以及如果需要的话，应该回滚到什么状态。此外，发布跟踪对于合规性要求是必须的。
- en: 4.2.4 Putting it all together
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 将所有内容整合在一起
- en: This chapter started with defining the GitOps CI/CD pipeline to build a Docker
    image, verify the image, and deploy it to an environment. Then we discussed environment
    promotion with stages that are important for each environment. Figure 4.6 is an
    example of what a full Gitops CI/CD pipeline looks like with environment promotion.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从定义GitOps CI/CD管道开始，用于构建Docker镜像，验证镜像并将其部署到环境中。然后我们讨论了环境升级，其中每个环境都重要的阶段。图4.6展示了完整的Gitops
    CI/CD管道在环境升级方面的示例。
- en: Serial or Parallel Even though the diagram describes each stage as serial, many
    modern pipelines can support running stages in parallel. For example, notification
    and metric publishing are mutually exclusive and can be executed in parallel to
    reduce the pipeline execution time.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 串行或并行 尽管该图将每个阶段描述为串行，但许多现代管道可以支持并行运行阶段。例如，通知和指标发布是互斥的，可以并行执行以减少管道执行时间。
- en: 4.3 Other pipelines
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 其他管道
- en: The CI/CD pipeline is primarily for your “happy path” deployment where your
    changes are working as expected and life is good, but we all know that’s not the
    reality. From time to time, unexpected issues will arise in the production environment,
    and we will need to either roll back the environment or release hotfixes to mitigate
    the problem. With software-as-a-service (SaaS), the highest priority is to recover
    from the production issues as quickly as possible; and in most cases, a rollback
    is required to the previously known good state for a timely recovery.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 管道主要用于你的“快乐路径”部署，其中你的更改按预期工作，生活很美好，但我们都知道那不是现实。时不时地，生产环境中会出现意外问题，我们需要回滚环境或发布热补丁来减轻问题。在软件即服务（SaaS）中，最高优先级是尽快从生产问题中恢复；在大多数情况下，需要回滚到之前已知良好的状态以实现及时恢复。
- en: For specific compliance standards, such as Payment Card Industry (PCI),^([8](#pgfId-1087610))
    production releases require a second person’s approval to ensure no single person
    can release changes to production. PCI also requires an annual audit that mandates
    reporting of the approval records. Given our original CI/CD pipeline will deploy
    changes to production per single PR, we need to enhance our pipeline to support
    compliance and auditability.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定的合规标准，如支付卡行业（PCI），^([8](#pgfId-1087610)) 生产版本需要第二个人的批准，以确保没有一个人可以发布到生产环境的更改。PCI
    还要求进行年度审计，强制报告批准记录。鉴于我们的原始 CI/CD 管道将根据单个 PR 将更改部署到生产环境，我们需要增强我们的管道以支持合规性和可审计性。
- en: '![](Images/CH04_F06_Yuen.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F06_Yuen.png)'
- en: Figure 4.6 A CI/CD pipeline completes with environment promotion for single-branch
    development. For multibranch development, additional stages are required for branch
    promotion before environment promotion.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 一个 CI/CD 管道完成单分支开发的环环相扣。对于多分支开发，在环境提升之前需要额外的阶段来提升分支。
- en: 4.3.1 Rollback
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 回滚
- en: Even if you have planned all the review, analysis, and testing stages in your
    CI/CD pipeline, eliminating all production issues is still impossible. Depending
    on the severity of the problem, you can either roll forward with fixes or roll
    back to restore your service to a previously known good state. Since our production
    environment consists of the manifest (which contains the Docker image id) and
    the application configuration for the environment, the rollback process could
    roll back the app config, manifest, or both repos. With GitOps, our rollback process
    is once again controlled by Git changes, and the GitOps operator will take care
    of the eventual deployment. (If the app config repo also needs to be rolled back,
    you just need to roll back the changes in app config first before rolling back
    the manifest since only manifest changes can trigger a deployment, not app config
    changes.) Git Revert and Git Reset^([9](#pgfId-1083711)) are two ways to roll
    back changes in Git.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在 CI/CD 管道中规划了所有审查、分析和测试阶段，消除所有生产问题仍然是不可能的。根据问题的严重程度，你可以选择继续应用修复或回滚到之前已知良好的状态。由于我们的生产环境由清单（包含
    Docker 镜像 ID）和环境的配置文件组成，回滚过程可能会回滚应用配置、清单或两个仓库。使用 GitOps，我们的回滚过程再次由 Git 变更控制，GitOps
    运营商将负责最终的部署。（如果应用配置仓库也需要回滚，你只需先回滚应用配置中的更改，然后再回滚清单，因为只有清单更改可以触发部署，而不是应用配置更改。）Git
    Revert 和 Git Reset^([9](#pgfId-1083711)) 是在 Git 中回滚更改的两种方式。
- en: Git Revert The `git` `revert` command can be considered an undo command. Instead
    of removing the commit from the project history, it figures out how to invert
    the changes introduced by the commit and appends a new commit with the resulting
    inverse content. This prevents Git from losing history, which is essential for
    the integrity of your revision history (compliance and auditability) and for reliable
    collaboration. Please refer to the graphic at the top of figure 4.7 for an illustration.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Git Revert `git revert` 命令可以被视为一个撤销命令。它不是从项目历史中删除提交，而是找出如何反转由提交引入的更改，并附加一个包含结果逆内容的新的提交。这防止
    Git 丢失历史记录，这对于你修订历史的完整性（合规性和可审计性）以及可靠的协作至关重要。请参考图 4.7 顶部的图形说明。
- en: Git Reset The `git reset` command does a couple of things, depending on how
    it is invoked. It modifies the index (the so-called staging area), or it changes
    which commit a branch head is currently pointing at. This command may alter existing
    history (by changing the commit that a branch references). Please refer to the
    graphic at the bottom of figure 4.7 for an illustration. Since this command can
    alter history, we do not recommend using `git` `reset` if compliance and auditability
    are important.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Git 重置 `git reset` 命令根据其调用方式执行一些操作。它修改索引（所谓的暂存区），或者更改当前分支头指向的提交。此命令可能会更改现有历史记录（通过更改分支引用的提交）。请参考图
    4.7 底部的图形说明。由于此命令可以更改历史记录，我们不推荐在合规性和可审计性很重要的情况下使用 `git` `reset`。
- en: '![](Images/CH04_F07_Yuen.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F07_Yuen.png)'
- en: Figure 4.7 `git` `revert` works like an undo command with history preserved.
    `git` `reset`, on the other hand, modifies the history to reset the changes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 `git` `revert` 的工作方式类似于具有历史保留的撤销命令。另一方面，`git` `reset` 修改历史记录以重置更改。
- en: Figure 4.8 is an example of a rollback pipeline. This pipeline will start with
    `git` `revert` and `git` `commit` to roll back the manifest to the previously
    known good state. After a pull request is generated from the “revert” commit,
    approver(s) can approve and merge the PR to the manifest master branch. Once again,
    the GitOps operator will do its magic and roll back the application based on the
    updated manifest.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 是一个回滚管道的示例。该管道将从 `git` `revert` 和 `git` `commit` 开始，将清单回滚到之前已知的好状态。从“revert”提交生成拉取请求后，审批者可以批准并合并
    PR 到清单主分支。再次，GitOps 操作员将执行其魔法并根据更新的清单回滚应用程序。
- en: '![](Images/CH04_F08_Yuen.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F08_Yuen.png)'
- en: Figure 4.8 The rollback pipeline involves reverting the manifest to a previous
    commit, generating a new pull request, and finally approving the PR.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 回滚管道涉及将清单回滚到之前的提交，生成一个新的拉取请求，并最终批准该 PR。
- en: Exercise 4.9
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.9
- en: 'This exercise will go over the steps required to revert the image id from “zzzzzz”
    to “yyyyyy.” This exercise will use `git` `revert` so the commit history is preserved.
    Before you start, please fork the repo [https://github.com/gitopsbook/resources.git](https://github.com/gitopsbook/resources.git).
    This exercise will assume your local computer is the build system:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习将介绍将镜像 ID 从“zzzzzz”回滚到“yyyyyy”所需的步骤。本练习将使用 `git` `revert` 以保留提交历史。在开始之前，请将仓库
    [https://github.com/gitopsbook/resources.git](https://github.com/gitopsbook/resources.git)
    分支。本练习将假设您的本地计算机是构建系统：
- en: 'Clone the repo from Git. We will assume that guestbook.yaml in the folder chapter-04/exercise4.9
    is your application manifest:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Git 克隆仓库。我们将假设文件夹 chapter-04/exercise4.9 中的 guestbook.yaml 是您的应用程序清单：
- en: '[PRE12]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Use `git config` to specify the committer user email and name. Depending on
    your requirement, you can use either a service account or the actual committer
    account:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `git config` 指定提交者用户电子邮件和姓名。根据您的需求，您可以使用服务帐户或实际的提交者帐户：
- en: '[PRE13]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note Please refer to chapter 6 for creating strong identity guarantees. The
    user that is specified also needs to exist in your remote Git repo.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 请参考第 6 章以创建强大的身份保证。指定的用户还需要存在于您的远程 Git 仓库中。
- en: 'Let’s review the Git history:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回顾 Git 历史：
- en: '[PRE14]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'From the history, you will see “`eb1a692029a9f4e4ae65de8c11135c56ff23 5722`”
    for image hash zzzzzz. If we revert this commit, the manifest will have an image
    hash yyyyyy:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从历史记录中，您将看到用于镜像哈希 zzzzzz 的“`eb1a692029a9f4e4ae65de8c11135c56ff23 5722`”。如果我们回滚此提交，清单将具有镜像哈希
    yyyyyy：
- en: '[PRE15]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we are ready to push the revert of the manifest by pushing back to the
    repo and let the GitOps operator do its deployment magic:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备通过推送到仓库并让 GitOps 操作员执行其部署魔法来推送清单的回滚：
- en: '[PRE16]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 4.3.2 Compliance pipeline
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 合规性管道
- en: A compliance pipeline essentially needs to ensure second-person approval for
    production release and record by whom, when, and what gets released. In our case,
    we have created one CI/CD pipeline for preproduction development and a separate
    pipeline for production release. The preproduction CI/CD pipeline’s last stage
    will generate a PR to update the production manifest with the latest image id.
    When the approver wants to release a particular image to production, he/she can
    simply approve the respective PR and the Prod environment will be updated by the
    GitOps operator. Figure 4.9 illustrates the stages for compliance CI/CD and production
    release pipelines.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 合规性管道本质上需要确保对生产发布的第二人称批准，并记录谁、何时以及发布了什么。在我们的案例中，我们为预生产开发和生产发布创建了单独的CI/CD管道。预生产CI/CD管道的最后阶段将生成一个PR来更新生产清单的最新镜像ID。当审批者想要将特定镜像发布到生产时，他/她只需简单地批准相应的PR，GitOps操作员将更新Prod环境。图4.9说明了合规性CI/CD和生产发布管道的阶段。
- en: Exercise 4.10
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.10
- en: 'This exercise will create a new branch with your production manifest update
    and create a pull request back to the remote repo for approval. Before you start,
    please fork the repo [https://github.com/gitops-k8s/resources.git](https://github.com/gitops-k8s/resources.git).
    This exercise will assume your local computer is the build system:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习将创建一个包含您的生产清单更新的新分支，并创建一个pull request回推到远程仓库以供批准。在您开始之前，请分叉仓库[https://github.com/gitops-k8s/resources.git](https://github.com/gitops-k8s/resources.git)。此练习将假设您的本地计算机是构建系统：
- en: 'Install the `hub`[10](#pgfId-1083773) CLI for pull request creation. The hub
    CLI tool works with GitHub to fork branches and create pull requests:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装用于创建pull request的`hub`[10](#pgfId-1083773) CLI。hub CLI工具与GitHub协作，分叉分支并创建pull
    request：
- en: '[PRE17]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Clone the repo from Git. We will assume that guestbook.yaml in the folder chapter-04
    is your application manifest:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Git克隆仓库。我们将假设文件夹chapter-04中的guestbook.yaml是您的应用程序清单：
- en: '[PRE18]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use `git` `config` to specify the committer user email and name. Depending
    on your requirement, you can use a service account or the actual committer account:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`git` `config`指定提交者的用户电子邮件和姓名。根据您的需求，您可以使用服务账户或实际的提交者账户：
- en: '[PRE19]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](Images/CH04_F09_Yuen.png)'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F09_Yuen.png)'
- en: Figure 4.9 With the compliance pipeline, there is a separate production pipeline
    from the preprod CI/CD pipeline. At the end of the CI/CD pipeline, there is a
    stage to generate a new PR with the new image id to the production manifest repository.
    Any PR getting approved will be deployed into the production.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.9 在合规性管道中，有一个从预生产CI/CD管道分离的生产管道。在CI/CD管道的末尾，有一个阶段用于生成一个包含新镜像ID的新PR到生产清单仓库。任何获得批准的PR都将部署到生产环境中。
- en: Note Please refer to chapter 6, section 6.2, for creating strong identity guarantees.
    The user specified also needs to exist in your remote Git repo.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：请参阅第6章第6.2节，以创建强大的身份保证。用户指定的内容也需要存在于您的远程Git仓库中。
- en: 'Create a new release branch:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的发布分支：
- en: '[PRE20]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s assume that the new Docker image has the Git hashtag zzzzzz. We will
    update the manifest with the tag zzzzzz:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设新的Docker镜像具有Git标签zzzzzz。我们将更新清单以包含标签zzzzzz：
- en: '[PRE21]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will commit the change to the manifest:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将将更改提交到清单：
- en: '[PRE22]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Given that the repo could be updated by others, we will run `git rebase` to
    pull down any new commit(s) to our local branch:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于仓库可能被其他人更新，我们将运行`git rebase`以拉取任何新的提交到我们的本地分支：
- en: '[PRE23]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Fork the repo:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分叉仓库：
- en: '[PRE24]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Push the changes to your new remote:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改推送到您的新远程仓库：
- en: '[PRE25]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Open a pull request for the topic branch you’ve just pushed. This will also
    open up an editor for you to edit the pull request description. Once you save
    the description, this command will create the pull request:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您刚刚推送的主题分支打开一个pull request。这也会为您打开一个编辑器来编辑pull request描述。一旦保存描述，此命令将创建pull
    request：
- en: '[PRE26]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now you can go back to your remote repo and review and approve the pull request
    in your browser.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以回到您的远程仓库，并在浏览器中审查和批准pull request。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '`git` `rebase` can mitigate conflict due to concurrent pipeline execution.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git` `rebase`可以减轻由于并发管道执行而引起的冲突。'
- en: Continuously running `kubectl` `rollout` `status` can ensure that deployment
    is complete and ready for running functional tests in GitOps CD.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续运行`kubectl` `rollout` `status`可以确保部署完成并准备好在GitOps CD中进行功能测试。
- en: Having code, manifest, and app config in separate repos will give you the best
    flexibility as infrastructure and code can evolve separately.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码、清单和应用程序配置保存在单独的仓库中将为您提供最佳灵活性，因为基础设施和代码可以独立发展。
- en: The single-branch strategy is great for smaller projects as every CI image can
    be promoted to production with zero branch management.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单分支策略非常适合小型项目，因为每个CI镜像都可以直接升级到生产环境，无需进行分支管理。
- en: A multibranch strategy is excellent for larger projects with external dependencies
    and release planning. The downside is that multiple long-lived branches must be
    maintained, and only release images can be deployed to production.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多分支策略非常适合具有外部依赖和发布计划的大型项目。缺点是必须维护多个长期分支，并且只能将发布镜像部署到生产环境。
- en: A complete CI/CD pipeline will include environment promotion and stages for
    static analysis, build, unit/integration testing, and publishing build metrics/notification.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个完整的CI/CD管道将包括环境升级、静态分析、构建、单元/集成测试以及发布构建指标/通知的阶段。
- en: Rollback of a production environment with GitOps is simply reverting the manifest
    to the previous commit (image id).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitOps回滚生产环境只是将清单回滚到之前的提交（镜像ID）。
- en: GitOps pipelines naturally support compliance and auditability because all changes
    are generated as pull requests with approval and history.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitOps管道自然支持合规性和可审计性，因为所有更改都以带有批准和历史的拉取请求的形式生成。
- en: '* * *'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1. [https://en.wikipedia.org/wiki/Code_smell](https://en.wikipedia.org/wiki/Code_smell).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 1. [https://en.wikipedia.org/wiki/Code_smell](https://en.wikipedia.org/wiki/Code_smell).
- en: 2.[https://en.wikipedia.org/wiki/Mock_object](https://en.wikipedia.org/wiki/Mock_object).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 2.[https://en.wikipedia.org/wiki/Mock_object](https://en.wikipedia.org/wiki/Mock_object).
- en: 3.[https://docs.docker.com/registry/](https://docs.docker.com/registry/).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 3.[https://docs.docker.com/registry/](https://docs.docker.com/registry/).
- en: 4.[https://www.contrastsecurity.com/](https://www.contrastsecurity.com/).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 4.[https://www.contrastsecurity.com/](https://www.contrastsecurity.com/).
- en: 5.[https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 5.[https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow).
- en: 6.[https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 6.[https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow).
- en: 7.[https://martinfowler.com/bliki/CanaryRelease.html](https://martinfowler.com/bliki/CanaryRelease.html).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 7.[https://martinfowler.com/bliki/CanaryRelease.html](https://martinfowler.com/bliki/CanaryRelease.html).
- en: 8.[https://en.wikipedia.org/wiki/Payment_card_industry](https://en.wikipedia.org/wiki/Payment_card_industry).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 8.[https://en.wikipedia.org/wiki/Payment_card_industry](https://en.wikipedia.org/wiki/Payment_card_industry).
- en: 9.[https://www.atlassian.com/git/tutorials/undoing-changes/git-reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 9.[https://www.atlassian.com/git/tutorials/undoing-changes/git-reset](https://www.atlassian.com/git/tutorials/undoing-changes/git-reset).
- en: 10.[https://github.com/github/hub](https://github.com/github/hub).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 10.[https://github.com/github/hub](https://github.com/github/hub).
