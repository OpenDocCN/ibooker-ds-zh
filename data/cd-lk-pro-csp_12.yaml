- en: 8 Stubbing, generics, and coupling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 模拟、泛型和耦合
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating the `Booking` repository class using test-driven development
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试驱动开发创建`Booking`仓库类
- en: Separation of concerns and coupling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点和耦合分离
- en: Programming with generics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型编程
- en: Unit testing with stubs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模拟进行单元测试
- en: 'This chapter sees the continuation of our short-term mission to implement repositories
    for every entity in the database. If we look at the larger picture, we can remind
    ourselves why we implement these repositories in the first place: Aljen van der
    Meulen, the CEO of Flying Dutchman Airlines, wants us to bring their old codebase
    into the modern era. We received an OpenAPI specification to adhere to (the service
    needs to integrate with a flight search aggregator), and we settled on using the
    repository/service pattern in our new codebase. Figure 8.1 shows where we are
    in the scheme of the book.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续我们短期任务的一部分，即实现数据库中每个实体的仓库。如果我们从更大的角度来看，我们可以提醒自己为什么最初要实现这些仓库：飞利浦·范德梅伦，荷兰飞行的首席执行官，希望我们将他们的旧代码库带入现代时代。我们收到了一个OpenAPI规范以遵守（服务需要与航班搜索聚合器集成），并且我们决定在我们的新代码库中使用仓库/服务模式。图8.1显示了我们在本书方案中的位置。
- en: '![](../Images/08_01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08_01.png)'
- en: Figure 8.1 In this chapter, we’ll implement the `BookingRepository` class. In
    chapters 6 and 7, we implemented the `CustomerRepository` class. That just leaves
    the `AirportRepository` and `FlightRepository` classes for the repository section
    of our codebase. We’ll implement those in the next chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 在本章中，我们将实现`BookingRepository`类。在第6章和第7章中，我们实现了`CustomerRepository`类。这就只剩下代码库的仓库部分中的`AirportRepository`和`FlightRepository`类了。我们将在下一章中实现它们。
- en: 'In chapters 6 and 7, we implemented the repository class for the `Customer`
    entity. This time around, we’ll focus on the `Booking` entity. After reading this
    chapter, I hope you are familiar with the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章和第7章中，我们实现了`Customer`实体的仓库类。这次，我们将关注`Booking`实体。阅读完本章后，我希望你熟悉以下内容：
- en: The Liskov substitution principle
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Liskov替换原则
- en: Separation of concerns and coupling
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点和耦合分离
- en: How to use generics
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用泛型
- en: How to write watertight input-validation code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写严密的输入验证代码
- en: Using optional parameters
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可选参数
- en: And, of course, much more.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有更多。
- en: 8.1 Implementing the Booking repository
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 实现预订仓库
- en: 'So far in our quest to refactor and implement a new version of the FlyingDutchmanAirlines
    codebase, we have set up Entity Framework Core and implemented a database access
    layer (chapter 5) as well as a `Customer` repository class (chapters 6 and 7).
    In this section, we’ll start writing the `BookingRepository` class, shown in figure
    8.2\. Revisiting the `Booking` model, we see we have three fields: `BookingID`
    (the primary key), `FlightNumber`, and `CustomerID` (the foreign key to `Customer.CustomerID`).
    The integer is nullable because there may not be a foreign key. Of course, a booking
    without a customer is an oddity, so this should not happen.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的重构和实现FlyingDutchmanAirlines代码库新版本的过程中，我们已经设置了Entity Framework Core，实现了数据库访问层（第5章）以及`Customer`仓库类（第6章和第7章）。在本节中，我们将开始编写`BookingRepository`类，如图8.2所示。回顾`Booking`模型，我们看到我们有三个字段：`BookingID`（主键）、`FlightNumber`和`CustomerID`（外键，指向`Customer.CustomerID`）。整数是可空的，因为可能没有外键。当然，没有客户的预订是一种异常情况，所以这种情况不应该发生。
- en: '![](../Images/08_02.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08_02.png)'
- en: Figure 8.2 The `Booking` class and Booking table. Because the `Booking` class
    is reverse-engineered from the database schema, the isomorphic relationship between
    code and database is strong.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 `Booking`类和预订表。由于`Booking`类是从数据库模式逆向工程得到的，因此代码和数据库之间的同构关系很强。
- en: 'We only have one endpoint dealing with Booking, `POST /Booking`, which creates
    a new booking in the database. Because we are doing only one thing, we need only
    one public method in our new `BookingRepository`: `CreateBooking`. But first things
    first—we should create the `BookingRepository` class in the RepositoryLayer folder
    and the respective test class in the FlyingDutchmanAirlines_Tests project (along
    with the skeleton for the success test case), as shown in the next code sample.
    At the risk of repeating myself, the plan is to create one repository per database
    entity (`Customer`, `Booking`, `Airport`, and `Flight`). A repository class contains
    small methods that interact with the database through the database access layer.
    A service layer class calls those repositories, gathering information to present
    back to a controller class. We discussed the repository/service pattern in section
    5.2.4.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有一个端点用于处理预订，`POST /Booking`，它在数据库中创建一个新的预订。因为我们只做一件事，所以我们的新`BookingRepository`只需要一个公共方法：`CreateBooking`。但首先，我们应该在RepositoryLayer文件夹中创建`BookingRepository`类，以及在FlyingDutchmanAirlines_Tests项目中相应的测试类（包括成功测试用例的框架），如下面的代码示例所示。为了避免重复，计划是每个数据库实体（`Customer`、`Booking`、`Airport`和`Flight`）创建一个存储库。存储库类包含与数据库交互的小方法，通过数据库访问层进行操作。服务层类调用这些存储库，收集信息以返回给控制器类。我们在5.2.4节中讨论了存储库/服务模式。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As in the previous chapters, we’ll use test-driven development to ensure our
    code functions the way we want it to and to prevent future regressions when extending
    the code. In section 6.1, I introduced test-driven development (light) as a technique
    to increase the likelihood of our code being correct and testable. In test-driven
    development, we create unit tests before we write logic implementations. Because
    we build up both the tests and the actual logic at the same time, we keep verifying
    the code against our expectations during development, saving us the hassle of
    having to fix bugs that come up if we were to write unit tests after implementing
    all the code, as shown in the next listing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，我们将使用测试驱动开发来确保我们的代码按预期工作，并在扩展代码时防止未来的回归。在第6.1节中，我介绍了测试驱动开发（轻量级）作为一种技术，以提高我们的代码正确性和可测试性的可能性。在测试驱动开发中，我们在编写逻辑实现之前创建单元测试。因为我们同时构建测试和实际逻辑，所以我们会在开发过程中不断验证代码是否符合我们的预期，从而避免在实现所有代码后编写单元测试时需要修复的bug，如下面的列表所示。
- en: Listing 8.1 A skeleton `BookingRepositoryTests` class
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 `BookingRepositoryTests`类的框架
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ The TestInitialize method runs before every test.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `TestInitialize`方法在每次测试之前运行。
- en: ❷ Creates an in-memory SQL database
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个内存中的SQL数据库
- en: ❸ Creates an instance of BookingRepository, using DI to pass in the database
    context
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用依赖注入（DI）传递数据库上下文来创建`BookingRepository`实例
- en: ❹ Asserts that the BookingRepository instance was created successfully
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言`BookingRepository`实例创建成功
- en: 'Before we move on, let’s revisit how the old code implemented the `Booking`-related
    code and the improvements we identified. The old code crammed all the code related
    to every entity into one class: `FlightController`. When you have implementation
    details inside of a controller, especially those that deal with a different entity
    than the controller does, you tightly couple the implementation details of the
    database to the controller. Ideally, we would have some abstraction layers (such
    as services, repositories, and database access layers) between the controller
    and the database. Let’s imagine that, after developing the codebase, you want
    to change the database vendor from Microsoft Azure to Amazon AWS. If you tightly
    couple your controllers to the database, you have to change every controller you
    have when you switch vendors. If you abstracted the database logic by introducing
    a repository/service pattern with a database access layer, loosening the coupling
    between database and controller, you would have to make changes only in the database
    access layer. For us, within the context of a `BookingRepository`, we want to
    extract out the code that actually inserts a new `Booking` object into the database
    as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们回顾一下旧代码是如何实现与 `Booking` 相关的代码以及我们确定的改进。旧代码将所有与每个实体相关的代码都挤在一个类中：`FlightController`。当你将实现细节放在控制器内部时，特别是那些与控制器处理的实体不同的实现细节，你会将数据库的实现细节与控制器紧密耦合。理想情况下，我们希望在控制器和数据库之间有一些抽象层（如服务、存储库和数据库访问层）。让我们想象一下，在开发代码库之后，你想将数据库供应商从
    Microsoft Azure 更改为 Amazon AWS。如果你将控制器与数据库紧密耦合，那么在切换供应商时，你必须更改你拥有的每个控制器。如果你通过引入具有数据库访问层的存储库/服务模式来抽象数据库逻辑，松散数据库与控制器之间的耦合，那么你只需要在数据库访问层进行更改。对于我们来说，在
    `BookingRepository` 的上下文中，我们希望提取出将新的 `Booking` 对象实际插入数据库的代码，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The rest of the original code also manually grabs some of the data tied to foreign
    key constraints. We’ll look at how to deal with foreign keys in a service layer
    class in section 11.3.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 原始代码的其余部分也手动获取了一些与外键约束相关联的数据。我们将在第 11.3 节中查看如何在服务层类中处理外键。
- en: 8.2 Input validation, separation of concerns, and coupling
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 输入验证、关注点分离和耦合
- en: 'In this section, we’ll mimic the approach we took when adding a customer to
    the database in chapter 6 and apply it to bookings as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将模仿我们在第 6 章中添加客户到数据库时采取的方法，并将其应用于预订，如下所示：
- en: Validate the inputs.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证输入。
- en: Create a new instance of type `Booking`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `Booking` 类型的新的实例。
- en: Add the new instance to Entity Framework Core’s `DbSet<Booking>` by calling
    it through the database context.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过数据库上下文调用，将新实例添加到 Entity Framework Core 的 `DbSet<Booking>` 中。
- en: 'The `CreateBooking` method has two inputs: a `customerID` and a `flightNumber`.
    They are both of type `integer` and have the following identical validation rules:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateBooking` 方法有两个输入：一个 `customerID` 和一个 `flightNumber`。它们都是 `integer` 类型，并且具有以下相同的验证规则：'
- en: '`customerID` and `flightNumber` must be positive integers.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customerID` 和 `flightNumber` 必须是正整数。'
- en: '`customerID` and `flightNumber` need to be valid when matched against existing
    flights and customers.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当与现有航班和客户匹配时，`customerID` 和 `flightNumber` 需要是有效的。
- en: 'The proposed validation rules mean we need to check the `DbSet` collections
    for `Customer` and `Flight` to verify that they contain entries matching the input
    information. The issue is, however, that we do not want to deal with `DbSet`s
    of entities other than `Booking` in the `BookingRepository` due to separation
    of concerns. Additionally, we do not want to deal with the foreign key constraints
    on the repository level but rather on the service level. For a repository/service
    architecture, a good rule of thumb is this: keep your repositories dumb and your
    services smart. This means that your repository methods should be methods with
    a stringent adherence to the single-responsibility principle (discussed in the
    introduction of chapter 6), whereas this adherence is a bit laxer on the service
    side.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的验证规则意味着我们需要检查 `DbSet` 集合中的 `Customer` 和 `Flight`，以验证它们是否包含与输入信息匹配的条目。然而，问题在于，由于关注点的分离，我们不想在
    `BookingRepository` 中处理除 `Booking` 之外的实体的 `DbSet`。此外，我们不想在存储库级别处理外键约束，而是在服务级别处理。对于存储库/服务架构，一个好的经验法则是这样的：让你的存储库保持简单，让你的服务保持智能。这意味着你的存储库方法应该是严格遵循单一职责原则（在第
    6 章引言中讨论）的方法，而服务侧的这种遵循则稍微宽松一些。
- en: Services can call whatever repository methods they need to fulfill their tasks.
    A repository method should not have to call a different repository to do their
    job. If you find yourself cross-calling between repositories, take a step back
    and reread section 5.2.4 on the repository/service pattern again. In the `BookingService`
    in chapters 10 and 11, we’ll look at how to write a service that manages these
    concerns, but for now, it suffices to understand why we do not want to call `DbSet<Customer>`
    and `DbSet<Flight>` in `BookingRepository`. In the end, it all boils down to separation
    of concerns and coupling.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以调用它们完成任务所需的任何仓库方法。仓库方法不应该需要调用另一个仓库来完成它们的工作。如果你发现自己正在在仓库之间进行交叉调用，请退一步，重新阅读第5.2.4节关于仓库/服务模式的说明。在第10章和第11章的`BookingService`中，我们将探讨如何编写一个管理这些关注点的服务，但到目前为止，理解我们为什么不想在`BookingRepository`中调用`DbSet<Customer>`和`DbSet<Flight>`就足够了。最终，一切都归结为关注点分离和耦合。
- en: '| ![](../Images/ThumbsUp.png)   |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| ![点赞](../Images/ThumbsUp.png)   |'
- en: Separation of concerns and coupling
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点分离和耦合
- en: “Separation of concerns” is a term coined by Edsger Dijkstra in his paper “On
    the Role of Scientific Thought” (EWD 447, Springer-Verlag, 1982). At its most
    basic level, it means that a “concern” should do only one concrete thing. But
    what is a “concern”? A concern is a mental model of a programming module, which
    can take the form ofthings like methods or a class. When we take separation of
    concerns to the class level and apply it to `BookingRepository`, we might say
    that the `BookingRepository` should concern itself only with operations on the
    Booking database table. This means that retrieving information from the Customer
    table, for example, is not within the scope of the concern. If we apply it to
    a method, we could say that a method needs to do one singular thing and nothing
    else. This is a very important clean code tenet because it helps us to develop
    code that is readable and maintainable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: “关注点分离”这个术语是由Edsger Dijkstra在他的论文《论科学思维的作用》（EWD 447，Springer-Verlag，1982年）中提出的。在最基本层面上，这意味着一个“关注点”应该只做一件具体的事情。但什么是“关注点”呢？关注点是一个编程模块的心理模型，它可以表现为方法或类等形式。当我们把关注点分离提升到类级别，并将其应用于`BookingRepository`时，我们可能会说`BookingRepository`应该只关注对预订数据库表的操作。这意味着从客户表检索信息等操作并不在关注点的范围内。如果我们将其应用于方法，我们可以说一个方法需要做一件单一的事情，其他的事情都不做。这是非常重要的清洁代码原则，因为它帮助我们开发出可读性和可维护性强的代码。
- en: 'We discussed the concept of writing code that reads like a narrative using
    small methods before. This is that same concept. In his monumental work *Clean
    Code: A Handbook of Agile Software Craftsmanship* (Prentice-Hall, 2008), Robert
    C. Martin touches on this subject many times. One particular occasion is the section
    appropriately titled “Do One Thing.” He tells us that “Functions should do one
    thing. They should do it well. They should do it only.” If we hold this message
    in the back of our heads when we write code, we are one step ahead of the curve
    when it comes to writing amazing code. We discussed the single-responsibility
    principle, which concerns itself with writing clean methods that do only one thing,
    in chapter 6.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '我们之前讨论过使用小方法编写像叙事一样的代码的概念。这就是同一个概念。在罗伯特·C·马丁的巨著《Clean Code: A Handbook of Agile
    Software Craftsmanship》（Prentice-Hall，2008年）中，罗伯特·C·马丁多次提到了这个主题。其中一个特别的场合是标题为“Do
    One Thing”的章节。他告诉我们：“函数应该只做一件事情。它们应该做得很好。它们应该只做这件事。”如果我们把这条信息记在心里编写代码，那么在编写出色代码方面，我们就已经领先一步了。我们在第6章讨论了单一职责原则，它关注于编写只做一件事情的清洁方法。'
- en: 'What is coupling, and how does it relate to the idea of separation of concerns?
    Coupling is a different angle with which to approach the problem of separation
    of concerns. Coupling is a metric that quantifies how integrated one class is
    with another. If classes are highly coupled, it means that they depend highly
    on each other. We call this tight coupling. We do not want tight coupling. Tight
    coupling often results in methods calling a lot of other methods at the wrong
    architectural level: think about the `BookingRepository` calling the `FlightRepository`
    to retrieve information about a flight.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合是什么，它与关注点分离的理念有何关联？耦合是从另一个角度来处理关注点分离问题的一个度量。耦合是一个量化一个类与另一个类之间集成程度的指标。如果类之间高度耦合，这意味着它们高度依赖于彼此。我们称之为紧密耦合。我们不希望有紧密耦合。紧密耦合通常会导致方法在错误的结构级别调用很多其他方法：想想`BookingRepository`调用`FlightRepository`来检索航班信息。
- en: 'Loose coupling is when two methods (or systems) are not very dependent on each
    other and can execute independently (and, therefore, be changed with minimal side
    effects). Larry Constantine coined the term *coupling*, which first appeared in
    the book *Structured Design: Fundamentals of a Discipline of Computer Program
    and Systems Design* (Prentice-Hall, 1979) by Constantine and Edward Yourdon. When
    trying to determine the amount of coupling between two things, one can ask the
    question that Constantine and Yourdon pose in their book: “How much of one module
    must be known to understand another module?”'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 松散耦合是指两个方法（或系统）之间相互依赖性不强，可以独立执行（因此，可以以最小的副作用进行更改）。拉里·康斯坦丁提出了“耦合”这个术语，该术语首次出现在康斯坦丁和爱德华·尤尔顿合著的书籍《结构化设计：计算机程序和系统设计学科的基础》（Prentice-Hall，1979年）中。当试图确定两个事物之间的耦合程度时，可以提出康斯坦丁和尤尔顿在书中提出的问题：“为了理解另一个模块，必须了解多少关于一个模块的信息？”
- en: '|'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: How much of `CustomerRepository` and `FlightRepository` must be known to understand
    `BookingRepository`? How strong is the interconnection between the repositories?
    If we handle the coupling at the service level, the repositories should have very
    loose coupling and a high degree of separation of concerns.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解`CustomerRepository`和`FlightRepository`，需要了解多少内容？它们之间的相互连接有多强？如果我们处理服务层的耦合，则存储库应该具有非常松散的耦合和高度的关注点分离。
- en: 'Going back to input validation: although we do not have to check whether the
    foreign key constraints between the customer and flight database tables are valid,
    we do implicitly check them when we save the changes to the database. The database
    balks if a change is requested that violates a key constraint.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 回到输入验证：尽管我们不必检查客户和航班数据库表之间的外键约束是否有效，但我们在保存数据库更改时隐式地检查它们。如果请求的更改违反了键约束，数据库将拒绝更改。
- en: 'Remember when we discussed having methods that can take any input, even faulty
    ones, and still return an appropriate result? If we get a bad `customerID` or
    `flightNumber` input, the call to update the database will throw an exception
    and we’ll catch it. By catching the exception, we can control the data and execution
    flow and throw a custom exception of our own to tell the user something went wrong,
    as shown in the next listing. Validating our inputs becomes easy: check whether
    the input is a positive integer, and we are set.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们讨论过拥有可以接受任何输入（即使是错误的输入）并仍然返回适当结果的方法吗？如果我们得到一个坏的`customerID`或`flightNumber`输入，更新数据库的调用将抛出异常，我们将捕获它。通过捕获异常，我们可以控制数据和执行流程，并抛出我们自己的自定义异常来告诉用户出了问题，如下一列表所示。验证我们的输入变得简单：检查输入是否为正整数，然后我们就可以设置了。
- en: Listing 8.2 BookingRepository.CreateBooking method with basic input-validation
    logic
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2 BookingRepository.CreateBooking方法的基本输入验证逻辑
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ CreateBooking requires a customerID and flightNumber.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ CreateBooking方法需要customerID和flightNumber。
- en: '❷ Validates the input arguments: customerID and flightNumber need to be positive
    integers.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 验证输入参数：customerID和flightNumber需要是正整数。
- en: ❸ If the input arguments are invalid, throws an ArgumentException
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果输入参数无效，将抛出ArgumentException异常
- en: 'C# provides an exception that we can use when arguments are invalid in a method:
    `ArgumentException`. We want to throw an exception of type `ArgumentException`
    when `customerID` or `flightNumber` is not a positive integer. To throw an `ArgumentException`,
    we pass in an error message (of type `string`) to the `ArgumentException` and
    use the `throw new` pattern to instantiate and throw a new instance of `ArgumentException`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: C#提供了一种异常，我们可以在方法参数无效时使用：ArgumentException。当customerID或flightNumber不是正整数时，我们希望抛出ArgumentException类型的异常。为了抛出ArgumentException，我们将错误消息（类型为string）传递给ArgumentException，并使用`throw
    new`模式实例化和抛出一个新的ArgumentException实例。
- en: '| ![](../Images/LightBulb.png)   | Within C#, certain types have classes that
    wrap the type and extend on them by providing additional functionality. An example
    of this is the `String` class and the `string` type. Note the casing on both the
    class and the type. It is C# convention that a class starts with an uppercase
    character, whereas a type often starts with a lowercase one. For most types and
    their wrapping classes, you can often use them interchangeably (until you need
    to use a method exposed by the class—for `String`, this could be `IsNullOrEmpty`).
    Do note that `String` and `string` typically resolve to the same underlying Intermediate
    Language code. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/LightBulb.png)   | 在 C# 中，某些类型有包装类型的类，这些类通过提供额外的功能来扩展它们。一个例子是
    `String` 类和 `string` 类型。注意类和类型的大小写。C# 的约定是一个类以大写字母开头，而一个类型通常以小写字母开头。对于大多数类型及其包装类，你通常可以互换使用它们（直到你需要使用类公开的方法——对于
    `String`，这可能是 `IsNullOrEmpty`）。请注意，`String` 和 `string` 通常解析为相同的底层中间语言代码。 |'
- en: After the input-validation code throws the `ArgumentException`, a developer
    may see the message we passed in and wonder what went wrong. Developers would
    love to see what the actual arguments are, but we don’t want to return the input
    arguments in an error message and expose those outside of the method (or potentially
    to the end user). Can you imagine using an application and getting back an error
    message containing the actual input argument values? Surely any UI engineer or
    UX designer would take issue with that. Of course, there are always exceptions
    to this (perhaps you also control the only client this service ever uses). We
    would do well to at least log these arguments to the console so that a developer
    stands a better chance at recovering these values. Some companies use technologies
    such as Splunk to automatically capture logs written to the console and store
    them in a searchable database. To write to the console, we use the `Console.WriteLine`
    method, as shown in the next listing. If you don’t want to write to the console,
    ASP.NET has dedicated logging functionality you can use (see the MSDN ASP.NET
    documentation for more information). You could also use a third-party logging
    library such as Log4net or NLog. I prefer to use the simplest type of logging
    that gets the job done. In this case, logging to the console is good enough.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入验证代码抛出 `ArgumentException` 之后，开发者可能会看到我们传递的消息并想知道出了什么问题。开发者们当然希望看到实际的参数值，但我们不希望在错误消息中返回输入参数并暴露给方法外部（或潜在地给最终用户）。你能想象使用一个应用程序并得到一个包含实际输入参数值的错误消息吗？当然，任何
    UI 工程师或 UX 设计师都会对此提出异议。当然，总有例外（也许你也控制着这个服务唯一使用的客户端）。我们至少应该将这些参数记录到控制台，这样开发者就有更好的机会恢复这些值。一些公司使用像
    Splunk 这样的技术来自动捕获写入控制台并存储在可搜索数据库中的日志。要写入控制台，我们使用 `Console.WriteLine` 方法，如下一列表所示。如果你不想写入控制台，ASP.NET
    提供了专门的日志记录功能供你使用（有关更多信息，请参阅 MSDN ASP.NET 文档）。你也可以使用像 Log4net 或 NLog 这样的第三方日志库。我更喜欢使用最简单的日志记录类型，以完成任务。在这种情况下，将日志记录到控制台就足够了。
- en: Listing 8.3 `BookingRepository.CreateBooking` method with string interpolation
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 使用字符串插值的 `BookingRepository.CreateBooking` 方法
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Logs the invalid argument values to the console by using string interpolation
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过字符串插值将无效的参数值记录到控制台
- en: 'The string we write to the console is an interpolated string. With string interpolation,
    we can interpolate (or inline) expressions and values in a string without having
    to explicitly concatenate multiple strings together (string concatenation still
    happens under the hood). We create interpolated strings by prefixing the string
    itself with the dollar character: `$`. Then, we insert values and expressions
    (even method calls) directly into the string by wrapping them in curly braces.
    The string `{customerID}` interpolates the value of `customerID`, as shown in
    figure 8.3.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写入控制台的字符串是一个插值字符串。使用字符串插值，我们可以在字符串中插入（或内联）表达式和值，而无需显式地将多个字符串连接在一起（字符串连接仍然在底层发生）。我们通过在字符串本身前加上美元符号
    `$` 来创建插值字符串。然后，我们通过将它们包裹在花括号中来直接将值和表达式（甚至方法调用）插入到字符串中。字符串 `{customerID}` 插值了
    `customerID` 的值，如图 8.3 所示。
- en: '![](../Images/08_03.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_03.png)'
- en: Figure 8.3 String interpolation allows us to inline variable values into strings.
    When using string interpolation, prefix the string with a dollar character (`$`)
    and wrap the variables you want to use in curly braces (`{[variable]}`).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 字符串插值允许我们将变量值内联到字符串中。当使用字符串插值时，在字符串前加上美元符号（`$`），并用花括号（`{[variable]}`）括住你想要使用的变量。
- en: The compiler converts an interpolated string to a C# statement that concatenates
    a bunch of strings. The syntactical sugar provided by string interpolation is
    an excellent and idiomatic way of crafting readable strings. Because strings are
    immutable, using string interpolation does not remove the performance drawbacks
    of using string concatenation. String interpolation can actually perform worse
    than normal string concatenation because of the additional overhead involved,
    with strings being immutable. We also need to unit-test our input-validation logic.
    The unit test should make assertions based on invalid input arguments and verify
    that the input-validation logic throws an error of type `ArgumentException` when
    the input arguments are invalid (negative integers), as shown in the next listing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将插值字符串转换为 C# 语句，该语句连接了一堆字符串。字符串插值提供的语法糖是构建可读字符串的极好且惯用的方式。因为字符串是不可变的，使用字符串插值并不会消除使用字符串连接的性能缺点。实际上，由于额外的开销，字符串插值可能比正常的字符串连接表现得更差，因为字符串是不可变的。我们还需要对输入验证逻辑进行单元测试。单元测试应根据无效输入参数进行断言，并验证当输入参数无效（负整数）时，输入验证逻辑抛出类型为
    `ArgumentException` 的错误，如下一列表所示。
- en: Listing 8.4 Using the `DataRow` method attribute
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.4 使用 `DataRow` 方法属性
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ The [DataRow] method attribute runs tests with the specified test data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `[DataRow]` 方法属性使用指定的测试数据运行测试。
- en: ❷ This test expects an exception of type ArgumentException to be thrown.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个测试期望抛出一个 `ArgumentException` 类型的异常。
- en: ❸ Calls the CreateBooking method and awaits it
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用 `CreateBooking` 方法并等待它
- en: 'The `CreateBooking_Failure_InvalidInputs` unit test combines a couple of different
    techniques we used before, described next:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateBooking_Failure_InvalidInputs` 单元测试结合了我们之前使用的一些不同技术，下面将进行描述：'
- en: Using the `[DataRow]` method attribute, we provide the unit test with test data
    without having to write separate unit tests for all three test cases.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `[DataRow]` 方法属性，我们为单元测试提供了测试数据，而无需为所有三个测试用例编写单独的单元测试。
- en: Using the `[ExpectedException]` method attribute, we tell the MSTest runner
    that the method should throw an exception of type `ArgumentException` during test
    execution.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `[ExpectedException]` 方法属性，我们告诉 MSTest 运行器，在测试执行期间，该方法应该抛出一个类型为 `ArgumentException`
    的异常。
- en: Assigning the `_repository` field to a new instance of `BookingRepository` in
    the `TestInitialize` method.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `TestInitialize` 方法中将 `_repository` 字段赋值给 `BookingRepository` 的新实例。
- en: When the `CreateBooking_Failure_InvalidInputs` unit test runs, and we use the
    `[DataRow]` method attribute, we check for three separate test cases, as shown
    in table 8.1.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `CreateBooking_Failure_InvalidInputs` 单元测试运行时，我们使用 `[DataRow]` 方法属性，检查三个单独的测试用例，如表
    8.1 所示。
- en: Table 8.1 Three different test cases run in BookingRepositoryTests.cs `CreateBooking_Failure_InvalidInputs`
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1 在 BookingRepositoryTests.cs 中运行的三个不同测试用例 `CreateBooking_Failure_InvalidInputs`
- en: '| `customerID` | `flightNumber` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `customerID` | `flightNumber` |'
- en: '| –1 | 0 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| –1 | 0 |'
- en: '| 0 | –1 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 0 | –1 |'
- en: '| –1 | –1 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| –1 | –1 |'
- en: All test cases in table 8.1 are sets of input arguments to `CreateBooking` that
    fail the input-validation logic, causing the `CreateBooking` method to throw an
    `ArgumentException`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1 中的所有测试用例都是 `CreateBooking` 方法输入验证逻辑失败的输入参数集，导致 `CreateBooking` 方法抛出 `ArgumentException`。
- en: Exercises
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 8.1
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.1
- en: 'Fill in the blank: Within the context of separation of concerns, a concern
    refers to __________.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 填空：在关注点分离的背景下，一个关注点指的是 __________。
- en: a. a worrisome thought
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: a. 一个令人担忧的想法
- en: b. a business
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: b. 一个业务
- en: c. a logical module
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: c. 一个逻辑模块
- en: Exercise 8.2
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.2
- en: True or false? If two classes heavily depend on each other, we speak of loose
    coupling.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？如果两个类高度依赖彼此，我们称之为松耦合。
- en: Exercise 8.3
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.3
- en: 'Fill in the blanks: In a repository/service architecture, actual database queries
    should be made on the __________ level, whereas calls to the methods doing the
    database queries should be made on the __________ level.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 填空：在一个仓库/服务架构中，实际数据库查询应该在 __________ 级别进行，而调用执行数据库查询的方法应该在 __________ 级别进行。
- en: a. c. repository; service
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: a. c. 仓库；服务
- en: b. service; repository
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: b. 服务；仓库
- en: c. service; service
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: c. 服务；服务
- en: d. repository; repository
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: d. 仓库；仓库
- en: Exercise 8.4
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.4
- en: What would this print to the console if `fruit` is “kiwi”? `Console.WriteLine($"I
    enjoy eating {fruit} ");`
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`fruit`是“奇异果”，这将打印到控制台的内容是什么？`Console.WriteLine($"我喜欢吃 {fruit} ");`
- en: a. Nothing; it results in a compiler error.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: a. 什么也不做；它会导致编译错误。
- en: b. “I enjoy eating {fruit}”
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: b. “我喜欢吃{fruit}”
- en: c. “I enjoy eating kiwi”
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: c. “我喜欢吃奇异果”
- en: d. “$I enjoy eating kiwi”
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: d. “$我喜欢吃奇异果”
- en: Exercise 8.5
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 练习8.5
- en: True or false? A string is mutable. This means it is a reference type where
    every change made to a string overwrites the same location in memory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？字符串是可变的。这意味着它是一个引用类型，其中对字符串的任何更改都会覆盖内存中的同一位置。
- en: 8.3 Using object initializers
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 使用对象初始化器
- en: 'In the previous section, we validated the input arguments to `CreateBooking`
    and learned about separation of concerns, coupling, and string interpolation.
    In this section, we’ll take the method a step further by adding the logic to add
    a new booking to the database. To add a booking to the database, we need to perform
    the following four major steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们验证了`CreateBooking`的输入参数，并了解了关注点分离、耦合和字符串插值。在本节中，我们将通过添加将新预订添加到数据库的逻辑来进一步扩展该方法。要将预订添加到数据库，我们需要执行以下四个主要步骤：
- en: Create a new instance of type `Booking` in the `CreateBooking` method.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CreateBooking`方法中创建`Booking`类型的新实例。
- en: Populate the new instance of `Booking` with the `customerID` and `flightNumber`
    arguments.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`customerID`和`flightNumber`参数填充新的`Booking`实例。
- en: Add the new instance of `Booking` to Entity Framework Core’s internal `DbSet
    <Booking>`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`Booking`实例添加到Entity Framework Core的内部`DbSet <Booking>`。
- en: Save the changes to the database asynchronously.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步保存对数据库的更改。
- en: 'To start, we can easily take care of the first two steps: create a new instance
    of type `Booking` in the `CreateBooking` method, and populate it with the `customerID`
    and `flightNumber` arguments, as shown in the following listing.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以轻松地处理前两个步骤：在`CreateBooking`方法中创建`Booking`类型的新实例，并用`customerID`和`flightNumber`参数填充它，如下面的列表所示。
- en: 'Listing 8.5 `BookingRepository.CreateBooking`: create and populate a `Booking`
    instance'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 `BookingRepository.CreateBooking`：创建并填充`Booking`实例
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Validates the input arguments
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 验证输入参数
- en: ❷ Creates a new instance of type Booking
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建`Booking`类型的新实例
- en: ❸ Assigns the customerID input argument to the appropriate property in newBooking
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将customerID输入参数分配给newBooking中适当的属性
- en: ❹ Assigns the flightNumber input argument to the appropriate property in newBooking
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将flightNumber输入参数分配给newBooking中适当的属性
- en: 'There we go, just as ordered: one instance of type `Booking`. We also populated
    the `CustomerId` and `FlightNumber` properties with our validated input arguments.
    Something irks me about the code in listing 8.5, though: it’s possible for the
    population of fields on a new instance to become very cumbersome if we have to
    keep typing `[instance].[property] = [value]`. Remember our discussion of object
    initializers in section 6.2.5? This minor change in syntax (another case of syntactic
    sugar), shown here, can make a sizeable difference when initializing an object
    with large amounts of properties you need to set:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像命令一样，我们得到了：一个`Booking`类型的实例。我们还用验证过的输入参数填充了`CustomerId`和`FlightNumber`属性。尽管如此，列表8.5中的代码让我感到有些烦恼：如果我们必须不断地输入`[instance].[property]
    = [value]`，那么在新实例上填充字段可能会变得非常繁琐。还记得我们在6.2.5节中关于对象初始化器的讨论吗？这里语法上的微小变化（另一种语法糖的例子），在初始化具有大量需要设置的属性的对象时，可以产生显著的差异：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It really is a “squashing” of the regular object property assignment code into
    one block, as shown in figure 8.4\. Object initializers also work when dealing
    with collections such as lists (they are called *collection initializers* when
    using them on collections; of course, you could nest an object initializer inside
    a collection initializer).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 确实是将常规对象属性赋值代码“压缩”成一个块，如图8.4所示。对象初始化器在处理集合（如列表）时也有效（当在集合上使用时，它们被称为*集合初始化器*；当然，你可以在集合初始化器内部嵌套对象初始化器）。
- en: '![](../Images/08_04.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_04.png)'
- en: 'Figure 8.4 Contrasting approaches to object initialization: with and without
    using an object initializer. John is an unqualified zookeeper who looks after
    a majestic giraffe, an angry penguin, and a dangerous corgi.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 对象初始化的对比方法：使用和不使用对象初始化器。约翰是一个不合格的动物园管理员，他照顾着一头雄伟的长颈鹿、一只愤怒的企鹅和一只危险的柯基。
- en: All that is left for us to do is attempt to add `newBooking` to the database
    and save the changes to the database asynchronously. We need to make sure that
    we have no issues in adding the `Booking` instance to the database, so we wrap
    the logic to save the changes in a `try-catch` statement, throwing a custom exception
    (`CouldNotAddBookingToDatabaseException`, which inherits from `CouldNotAddEntityToDatabaseException`,
    which inherits from `Exception`) when a database error occurs. When this exception
    is thrown (as with any exception in the repository layer), we catch the exception
    again back in the service layer. I leave it to you to create the custom exceptions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩下的任务就是尝试将 `newBooking` 添加到数据库中，并异步保存对数据库的更改。我们需要确保在将 `Booking` 实例添加到数据库时没有问题，因此我们将保存更改的逻辑包裹在
    `try-catch` 语句中，当发生数据库错误时抛出一个自定义异常（`CouldNotAddBookingToDatabaseException`，它继承自
    `CouldNotAddEntityToDatabaseException`，而 `CouldNotAddEntityToDatabaseException`
    继承自 `Exception`）。当抛出此异常（与仓库层中的任何异常一样）时，我们在服务层再次捕获异常。我将创建自定义异常的任务留给你。
- en: To save the new booking to the database using `SaveChangesAsync`, we need to
    `await` the `SaveChangesAsync` call. Awaiting the `CreateBooking` method means
    it has to execute asynchronously. To accomplish this, we change the type of the
    method to be `Task` and add the `async` keyword to the method signature, as shown
    in the following listing.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `SaveChangesAsync` 将新的预订保存到数据库，我们需要 `await` `SaveChangesAsync` 调用。等待 `CreateBooking`
    方法意味着它必须异步执行。为了实现这一点，我们将方法的类型更改为 `Task` 并在方法签名中添加 `async` 关键字，如下面的代码示例所示。
- en: Listing 8.6 BookingRepository.cs `CreateBooking` complete
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 BookingRepository.cs `CreateBooking` 完整
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Validates the input arguments
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 验证输入参数
- en: ❷ Creates and initializes a new instance of Booking using an object initializer
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用对象初始化器创建并初始化一个新的 Booking 实例
- en: ❸ Adds the new booking to EF Core’s internal DbSet<Booking>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将新的预订添加到 EF Core 的内部 DbSet<Booking>
- en: ❹ Saves changes to the database asynchronously
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 异步保存更改到数据库
- en: ❺ Catches any exception that was thrown in the try-block
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 捕获在 try 块中抛出的任何异常
- en: ❻ Writes developer information to the console
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将开发人员信息写入控制台
- en: ❼ Throws an exception of type CouldNotAddBookingToDatabaseException
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 抛出类型为 CouldNotAddBookingToDatabaseException 的异常
- en: Instead of using hardcoded SQL statements and messing with disposing of objects
    and using statements, we used Entity Framework Core and simple code to achieve
    the same result.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用硬编码的 SQL 语句，也没有处理对象释放和语句使用的问题，而是使用了 Entity Framework Core 和简单的代码来实现相同的结果。
- en: 'So, what is next? I’m sure you know by now: we need to fix our success case
    unit test. That should be easy enough, though. All we need to do is send in valid
    input arguments. But what if we have a database error? We can have valid values
    for `customerID` and `flightNumber` and still error out because of a database
    exception.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来是什么？我相信你现在已经知道了：我们需要修复我们的成功用例单元测试。这应该足够简单。我们只需要发送有效的输入参数。但是，如果我们遇到数据库错误怎么办？即使我们有有效的
    `customerID` 和 `flightNumber`，也可能因为数据库异常而失败。
- en: 8.4 Unit testing with stubs
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 使用模拟进行单元测试
- en: 'In this section, I introduce you to the wonderful world of stubbing. Stubbing,
    within the context of unit testing, is the act of executing a stub class (a class
    that acts as a certain class but overrides implementations) instead of the original
    class. We left the previous section as we were about to test for the possibility
    of the `CreateBooking` method throwing a `CouldNotAddBookingToDatabase` exception
    because of a database error. To test for a thrown `Exception`, we need to set
    aside the success test case for a bit longer and focus on stubbing and a new test
    method: `CreateBooking_Failure_DatabaseError`. I prefer using snake case for test
    unit tests, as shown in the next code sample, but opinions differ on this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您介绍模拟的奇妙世界。在单元测试的上下文中，模拟是指执行一个模拟类（充当某个类但覆盖实现）而不是原始类。我们留下上一节，因为我们正要测试
    `CreateBooking` 方法可能因为数据库错误而抛出 `CouldNotAddBookingToDatabase` 异常的可能性。为了测试抛出的 `Exception`，我们需要暂时放下成功测试用例，并专注于模拟和新的测试方法：`CreateBooking_Failure_DatabaseError`。我更喜欢使用蛇形命名法为测试单元测试命名，如以下代码示例所示，但对此的看法各不相同：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A stub is a piece of code (potentially a whole class) that takes the place of
    a normal class at runtime. A stub redirects to itself method calls made to the
    original class and executes overridden versions of those methods. Method redirection
    and overriding are especially useful in unit testing because they allow us to
    mimic error conditions by redirecting method calls and throwing exceptions when
    we want them thrown.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 存根是一段代码（可能是一个完整的类），它在运行时替代了普通类。存根将针对原始类的调用重定向到自身，并执行那些方法的覆盖版本。方法重定向和覆盖在单元测试中特别有用，因为它们允许我们通过重定向方法调用并在需要时抛出异常来模拟错误条件。
- en: Looking at the `CreateBooking` method, we want to verify that we can handle
    an error coming out of the database or the internals of Entity Framework Core
    correctly. But how do we handle a database exception? The easiest way is to expand
    on our redirection of the dependency injection `FlyingDutchmanAirlinesContext`.
    We still want to use an in-memory database, but we also want to make sure we throw
    an exception when a certain method is called. What if we create a class (a stub)
    that inherits from `FlyingDutchmanAirlinesContext` and then inject that into `CreateBooking`,
    as shown in figure 8.5?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `CreateBooking` 方法，我们想要验证我们能否正确处理从数据库或 Entity Framework Core 内部传出的错误。但我们如何处理数据库异常呢？最简单的方法是扩展我们的依赖注入
    `FlyingDutchmanAirlinesContext` 的重定向。我们仍然想使用内存数据库，但我们也想确保在调用某个方法时抛出异常。如果我们创建一个类（一个存根），它从
    `FlyingDutchmanAirlinesContext` 继承，然后将其注入到 `CreateBooking` 中，如图 8.5 所示会怎样？
- en: '![](../Images/08_05.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_05.png)'
- en: Figure 8.5 Redirecting `SaveChangesAsync` through `FlyingDutchmanAirlinesContext_Stub`.
    The repository calls the `SaveChangesAsync` method on the dependency injection
    `FlyingDutchmanAirlinesContext_Stub`. The stub calls the base class and determines
    what value to return in a `switch` statement.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 通过 `FlyingDutchmanAirlinesContext_Stub` 重定向 `SaveChangesAsync`。仓库在依赖注入
    `FlyingDutchmanAirlinesContext_Stub` 上调用 `SaveChangesAsync` 方法。存根调用基类，并在 `switch`
    语句中确定返回什么值。
- en: Let’s create a new folder in the FlyingDutchmanAirlines_Tests project called
    Stubs and a new class called `FlyingDutchmanAirlinesContext_Stub`, as shown in
    the next listing. This class inherits from `FlyingDutchmanAirlinesContext`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 FlyingDutchmanAirlines_Tests 项目中创建一个新的文件夹名为 Stubs，以及一个名为 `FlyingDutchmanAirlinesContext_Stub`
    的新类，如下所示。这个类从 `FlyingDutchmanAirlinesContext` 继承。
- en: Listing 8.7 A skeleton stub for `FlyingDutchmanAirlinesContext`
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 `FlyingDutchmanAirlinesContext` 的存根骨架
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ The class inherits from the original nonstubbed class, allowing us to use
    it in its place.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 该类从原始非存根类继承，允许我们用它来替代。
- en: Going back to `BookingRepositoryTests`, we swap in the stub for the context
    and see if our tests still pass, as shown in the following code sample.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `BookingRepositoryTests`，我们用存根替换上下文，并查看我们的测试是否仍然通过，如下面的代码示例所示。
- en: Listing 8.8 `BookingRepositoryTests` initializing a stub instead of the original
    class
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 `BookingRepositoryTests` 初始化存根而不是原始类
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ The backing field’s type is the nonstubbed class.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 存储字段的类型是非存根类。
- en: ❷ The DbContextBuilder pattern uses the nonstubbed class for a generic type.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `DbContextBuilder` 模式使用非存根类作为泛型类型。
- en: ❸ We can assign the backing field a new instance of the stub because of polymorphism.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 由于多态性，我们可以为存储字段分配存根的新实例。
- en: ❹ The repository accepts our stub in place of the nonstubbed class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 仓库接受我们的存根类代替非存根类。
- en: The code in listing 8.8 does not compile. Because we did not define an explicit
    constructor for the stub, the CLR creates an implicit default constructor when
    we create a new instance of `FlyingDutchmanAirlines_Stub`. But `FlyingDutchmanAirlinesContext`
    (the base/nonstubbed class) has a second constructor that takes in the `DbContextOptions<FlyingDutchmanAirlinesContext>`
    type that we need if we want to use an in-memory database. Because the stub inherits
    from the nonstub, we should be able to call `FlyingDutchmanAirlinesContext_Stub`’s
    parent’s constructor, as depicted in figure 8.6\. The parent is `FlyingDutchmanAirlinesContext`,
    after all.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 中的代码无法编译。因为我们没有为存根定义显式构造函数，当创建 `FlyingDutchmanAirlines_Stub` 的新实例时，CLR
    创建了一个隐式的默认构造函数。但是 `FlyingDutchmanAirlinesContext`（基类/非存根类）有一个接受 `DbContextOptions<FlyingDutchmanAirlinesContext>`
    类型的第二个构造函数，如果我们想使用内存数据库，就需要这个类型。因为存根从非存根继承，我们应该能够调用 `FlyingDutchmanAirlinesContext_Stub`
    的父类构造函数，如图 8.6 所示。毕竟，父类是 `FlyingDutchmanAirlinesContext`。
- en: '![](../Images/08_06.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_06.png)'
- en: Figure 8.6 When a derived class’s constructor includes a call to the base class’s
    constructor, the base class’s constructor always executes first. Here, the constructor
    of `RockAndRollHallOfFame` executes before the constructor of `RosettaTharpe`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 当派生类的构造函数包含对基类构造函数的调用时，基类的构造函数总是首先执行。在这里，`RockAndRollHallOfFame`的构造函数在`RosettaTharpe`的构造函数之前执行。
- en: To make the code compile and be able to use the stub in place of the nonstubbed
    class, we need to create a constructor that can deliver an instance of the stub
    with all the hooks to the base class (the nonstub) intact. We have overridden
    no methods in the stub yet, so every call to the stub should automatically go
    to the nonstub. To redirect the method call to our stubbed logic, we need a constructor
    that calls the base class’s constructor. Adding a constructor that calls the base
    class’s constructor guarantees us an instance of the base class that we can use
    in our redirection story.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码能够编译，并且能够使用存根代替非存根类，我们需要创建一个构造函数，该构造函数可以提供一个带有所有钩子到基类（非存根）的存根实例。我们尚未在存根中重写任何方法，因此对存根的每次调用都应该自动转到非存根。为了将方法调用重定向到我们的存根逻辑，我们需要一个调用基类构造函数的构造函数。添加一个调用基类构造函数的构造函数可以保证我们得到一个基类实例，我们可以在重定向故事中使用它。
- en: 'To call a base class’s constructor, add `: base ([arguments])` to a regular
    constructor, replacing `[arguments]` with whatever arguments you want to pass
    into the base’s constructor, as shown in the next code snippet. This is similar
    to using the `super` keyword in Java or Python. Note that the CLR always calls
    a base’s constructor before our own (a derived) constructor. So, if you want to
    do processing in your own constructor that has a base constructor call, be aware
    of that.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '要调用基类的构造函数，在常规构造函数中添加`: base ([arguments])`，将`[arguments]`替换为你想要传递给基类构造函数的任何参数，如以下代码片段所示。这类似于在Java或Python中使用`super`关键字。请注意，CLR始终在我们自己的（派生的）构造函数之前调用基类的构造函数。因此，如果你想在具有基类构造函数调用的自己的构造函数中执行处理，请注意这一点。'
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Explicitly defining this constructor forces the code to always pass in a type
    of `DbContextOptions<FlyingDutchmanAirlinesContext>` to instantiate a new `FlyingDutchmanAirlines_Stub`.
    Now we can compile the code and run all the tests. Everything passes because,
    besides a redirect to the stub, nothing has changed. All method calls to the stub
    currently still go to the nonstubbed version of `FlyingDutchmanAirlinesContext`
    because of inheritance and the lack of overridden methods in the stub. We can
    use `FlyingDutchmanAirlinesContext_Stub` as if it were an instance of `FlyingDutchmanAirlinesContext`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 明确定义此构造函数强制代码始终传递一个`DbContextOptions<FlyingDutchmanAirlinesContext>`类型的参数来实例化一个新的`FlyingDutchmanAirlines_Stub`。现在我们可以编译代码并运行所有测试。一切通过，因为除了重定向到存根之外，没有其他变化。由于继承和在存根中未重写方法，对存根的当前所有方法调用仍然转到`FlyingDutchmanAirlinesContext`的非存根版本。我们可以像使用`FlyingDutchmanAirlinesContext`的实例一样使用`FlyingDutchmanAirlinesContext_Stub`。
- en: The Liskov substitution principle (polymorphism)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Liskov替换原则（多态）
- en: 'This type of polymorphism is most often attributed to Barbara Liskov, a computer
    scientist (and winner of both the John von Neumann Medal and the Turing Award)
    who, together with Jeannette Wing, published a paper that describes the Liskov
    substitution principle:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的多态通常归功于计算机科学家Barbara Liskov（同时也是约翰·冯·诺伊曼奖章和图灵奖的获得者），她与Jeannette Wing一起发表了一篇论文，描述了Liskov替换原则：
- en: “Let ø(*x*) be a property provable about objects *x* of type *T*. Then ø(*y*)
    should be true for objects *y* of type *S* where *s* is a subtype of *T*.”[^a](#pgfId-1201645)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: “设ø(*x*)是关于类型*T*的对象*x*的可证明属性。那么对于类型*S*的对象*y*，其中*s*是*T*的子类型，ø(*y*)应该是真实的。”[^a](#pgfId-1201645)
- en: You may have to read that twice to get the gist of it. What Liskov and Wing
    tell us is that when using the Liskov substitution principle flavor of polymorphism,
    if you have a type (`Kit-Kat`) that is a subtype of a different type (`Candy`),
    the type *S* (`Kit-Kat`) should be able to do everything that *T* (`Candy`) can
    do. One can apply the duck-typing test to such an object—“If it looks like a duck,
    swims like a duck, and quacks like a duck, then it’s probably a duck”—to determine
    whether we can use type *S* as if it were type *T*. The Liskov substitution principle
    is often considered one of the major tenets of clean code and helps us write code
    that is reusable with an appropriate level of abstraction.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要读两遍才能抓住其精髓。Liskov 和 Wing 告诉我们，当使用 Liskov 替换原则风格的泛型时，如果你有一个类型（`Kit-Kat`）是另一个类型（`Candy`）的子类型，类型
    *S*（`Kit-Kat`）应该能够做类型 *T*（`Candy`）能做的所有事情。可以对这样的对象应用鸭子类型测试——“如果它看起来像鸭子，游泳像鸭子，嘎嘎叫像鸭子，那么它可能就是鸭子”——以确定我们是否可以使用类型
    *S* 而像使用类型 *T* 一样。Liskov 替换原则通常被认为是清洁代码的主要原则之一，它帮助我们编写具有适当抽象级别的可重用代码。
- en: '* * *'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^a Barbara H. Liskov and Jeannette M. Wing’s *A Behavioral Notion of Subtyping*
    (ACM Transactions on Programming Languages and Systems (TOPLAS), 1994).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ^a Barbara H. Liskov 和 Jeannette M. Wing 的 *A Behavioral Notion of Subtyping*（ACM
    Transactions on Programming Languages and Systems (TOPLAS)，1994）。
- en: 'Before we implement any logic, according to the TDD gods, we need to add an
    assertion to our unit test and make it fail. (If we remember the stoplight phases
    of TDD, we are now in the green phase, going to red.) The code path we want to
    test (but have not yet implemented) results in a thrown exception of type `CouldNotAddBookingToDatabaseException`.
    In the `try-catch` block surrounding the code where we add the new booking to
    the database, we call and wait on the `SaveChangesAsync` method. What if we could
    make that method throw an exception based on a certain condition, such as if we
    set the `customerID` on the new `Booking` object to something else besides `1`?
    We can achieve that goal by overriding the `SaveChangesAsync` method in our stub.
    The method signature for the overridden version of `SaveChangesAsync` in our stub
    is a bit gnarly (when overriding a method, one has to keep the same method signature),
    but we can get through it step by step, as shown here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现任何逻辑之前，根据 TDD 的神祇，我们需要在我们的单元测试中添加一个断言并使其失败。（如果我们还记得 TDD 的红绿灯阶段，我们现在处于绿色阶段，即将变为红色。）我们想要测试的代码路径（但我们还没有实现）会导致抛出类型为
    `CouldNotAddBookingToDatabaseException` 的异常。在围绕将新预订添加到数据库的代码的 `try-catch` 块中，我们调用并等待
    `SaveChangesAsync` 方法。如果我们能根据某个条件（例如，如果我们将新 `Booking` 对象的 `customerID` 设置为除了 `1`
    以外的其他值）使该方法抛出异常会怎样？我们可以通过在我们的存根中重写 `SaveChangesAsync` 方法来实现这个目标。我们存根中重写的 `SaveChangesAsync`
    方法的签名有点复杂（在重写方法时，必须保持相同的方法签名），但我们可以一步一步地完成它，如下所示：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Besides `override` (which you should be familiar with), we see the following
    two unfamiliar concepts wrapped in overridden method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `override`（你应该很熟悉）之外，我们还在重写的方法中看到了以下两个不熟悉的概念：
- en: Generics (which we have seen in action before)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型（我们之前已经看到过其应用）
- en: Optional parameters
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选参数
- en: Settle in, because those are two exciting topics.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 坐下来吧，因为这两个话题都非常激动人心。
- en: 8.5 Programming with generics
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 使用泛型编程
- en: 'In this section, I lift the veil on a topic we have seen quite a few times
    already in the book but have never explored beyond its funky syntax: generics.
    We have worked with generics right from the start. Anytime you see this pattern,
    you are working with generics: `[type]<[differentType]>`. Examples of generics
    syntax in action are `List<string>`, `DbSet<Customer>`, and `EntityEntry<TEntity>`.
    If you are familiar with Java generics or C++ templates, this section should feel
    familiar to you.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将揭开一个我们在书中已经多次见过但从未深入探讨的话题的神秘面纱：泛型。我们从一开始就使用了泛型。每次当你看到这个模式时，你就是在使用泛型：`[类型]<[不同类型]>`。泛型语法在实际应用中的例子有
    `List<string>`、`DbSet<Customer>` 和 `EntityEntry<TEntity>`。如果你熟悉 Java 泛型或 C++ 模板，本节应该会感觉比较熟悉。
- en: 'Generics is a concept that allows us to restrict classes, methods, and collections
    in terms of what types they can deal with. For example, a collection often has
    a generic version and a nongeneric version: A `List` is nongeneric, whereas a
    `List` of `Tiger`s (`List<Tiger>`) is generic. The `List<Tiger>` collection works
    with any class that can be cast to `Tiger` (the `Tiger` class itself or a derived
    class). A `HashSe`t is nongeneric, whereas a `HashSet` of `Baklava` (`HashSet<Baklava>`)
    is generic. An example of a method using a generic argument in the “wild” is the
    `Heapsort` method, used by the `Sort` method in `Systems.Collections.Generic.ArraySortHelper`
    class to perform the heap sort algorithm[¹](#pgfId-1201700) on the input, as shown
    here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是一个概念，它允许我们根据它们可以处理哪些类型来限制类、方法和集合。例如，一个集合通常有一个泛型版本和一个非泛型版本：`List`是非泛型的，而`List<Tiger>`（`List<Tiger>`）是泛型的。`List<Tiger>`集合与任何可以转换为`Tiger`（`Tiger`类本身或其派生类）的类一起工作。`HashSe`t是非泛型的，而`HashSet<Baklava>`（`HashSet<Baklava>`）是泛型的。一个使用泛型参数的“野”方法的例子是`Heapsort`方法，它在`Systems.Collections.Generic.ArraySortHelper`类中的`Sort`方法中使用，以在输入上执行堆排序算法[¹](#pgfId-1201700)，如下所示：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Heapsort` method accepts a generic argument of `T[]`, representing an array
    of keys to be sorted, and a generic argument of `IComparer<T>`, representing a
    comparison object.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Heapsort`方法接受一个泛型参数`T[]`，表示要排序的键数组，以及一个泛型参数`IComparer<T>`，表示比较对象。'
- en: Even though you typically encounter generics in collections, methods and classes
    are not immune to using them, either. So, what does a generic type look like?
    We know how to *use* them, but not yet how to *make* them. A generic class or
    method uses the “generic type” of `<T>`. Any letter is fine, however, as long
    as you are consistent within the scope of the class or method signature. You may
    want to restrict the types that can use your method or class. Constricting the
    use of generics to a specific type or subset of types is done by using generic
    constraints.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你通常在集合、方法和类中遇到泛型，但它们也不是不能使用泛型。那么，泛型类型看起来是什么样子呢？我们知道如何*使用*它们，但还没有学会如何*创建*它们。一个泛型类或方法使用“泛型类型”`<T>`。任何字母都可以，只要你在这个类或方法签名的作用域内保持一致。你可能想限制可以使用你的方法或类的类型。通过使用泛型约束将泛型的使用限制为特定类型或类型的子集。
- en: 'To create a generic constraint, postfix a clause to the respective method or
    class signature saying “`where T : [type]`.” For example, if we wanted to create
    a generic class that would accept only instances of type `Attribute` for `T`,
    we would do the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '要创建泛型约束，在相应的方法或类签名后添加一个子句，说“`where T : [type]`”。例如，如果我们想创建一个只接受类型`Attribute`实例的泛型类，我们会这样做：'
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Or, when we want to create a generic method that accepts only `Lists` of 16-bit
    integers (signified as `Int16` or `short`) we can say
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，当我们想创建一个只接受16位整数列表（表示为`Int16`或`short`）的泛型方法时，我们可以这样说
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Methods can also have input parameters of a generic type (be it `T`, `X`, `Y`,
    or whatever letter you fancy). Finally, we can have multiple generic types in
    one class or method and multiple generic constraints, as shown next:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也可以有泛型类型的输入参数（无论是`T`、`X`、`Y`还是你喜欢的任何字母）。最后，我们可以在一个类或方法中拥有多个泛型类型和多个泛型约束，如下所示：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, `MyGenericMethod` has two generic types: `T`, which maps to `List<Int16``>`,
    and `Y`, which is constrained to be of type `RSA`. The `RSA` type is the base
    class for all Rivest–Shamir–Adleman (RSA) encryption functionality in .NET. `Y`
    being constrained to `RSA` does not mean that classes using polymorphism to act
    as an `RSA` type are forbidden; you can use those without a problem. Constraints
    are rarely used, but it is good to be aware of them. In fact, to find a reasonably
    good example of constraints used in .NET itself, we have to dig quite deep. We
    can find it, however, in the `WindowsIdentity` class through the `GetTokenInformation`
    method, shown here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MyGenericMethod`有两个泛型类型：`T`，映射到`List<Int16>`，和`Y`，被约束为`RSA`类型。`RSA`类型是.NET中所有Rivest–Shamir–Adleman
    (RSA)加密功能的基础类。`Y`被约束为`RSA`并不意味着使用多态作为`RSA`类型的类是被禁止的；你可以使用它们而不会有问题。约束很少使用，但了解它们是好的。实际上，为了找到.NET本身中合理良好的约束示例，我们必须深入挖掘。我们可以在`WindowsIdentity`类通过`GetTokenInformation`方法找到它，如下所示：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `GetTokenInformation` method returns the requested field (determined by
    the passed-in `TokenInformationClass` instance) from the currently held Windows
    token. The type of the requested field can be anything, as long as it is a struct.
    This is signified by the constraint on the generic `T`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetTokenInformation`方法从当前持有的Windows令牌返回请求的字段（由传入的`TokenInformationClass`实例确定）。请求的字段类型可以是任何类型，只要它是struct。这由泛型`T`上的约束表示。'
- en: 8.6 Providing default arguments by using optional parameters
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 使用可选参数提供默认参数
- en: In the previous section, we started our dissection of the new concepts in the
    `SaveChangesAsync` method signature by looking at generics. In this section, we’ll
    finish that expedition and consider optional parameters.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们通过查看泛型来开始对`SaveChangesAsync`方法签名中新概念的剖析。在本节中，我们将完成这次探险，并考虑可选参数。
- en: 'Optional parameters are parameters in a method signature that have a default
    value assigned to them (inside the signature). The CLR uses the default assigned
    value as the argument value if you do not pass in an appropriate argument. Consider
    the following method signature:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数是在方法签名中分配了默认值的参数（在签名内）。如果未传递适当的参数，CLR将使用分配的默认值作为参数值。考虑以下方法签名：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `isPaid` parameter is assigned a value directly in the method signature.
    This is what we call an *optional parameter*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`isPaid`参数直接在方法签名中分配值。这就是我们所说的*可选参数*。'
- en: '![](../Images/08_06_UN01.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_06_UN01.png)'
- en: The CLR assigns an optional parameter to the default value specified in the
    method signature if we pass in no matching argument. The parameter is truly optional
    but is still available to the method with the set value. We can call the `BuildHouse`
    method in two ways, as shown in the next listing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有传递匹配的参数，CLR会将可选参数分配给方法签名中指定的默认值。参数确实是可选的，但仍然可以使用设置的值。我们可以以两种方式调用`BuildHouse`方法，如下一列表所示。
- en: Listing 8.9 Calling a method on optional parameters
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.9 在可选参数上调用方法
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ The optional parameter isPaid has the value of true.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 可选参数isPaid的值为true。
- en: ❷ The optional parameter isPaid has the value of false.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 可选参数isPaid的值为false。
- en: In the first example, we use the optional parameter’s (`isPaid`) default assigned
    value of `true`. In the second one, we assign a value of `false`. In both cases,
    the method’s logic has access to an initialized version of `isPaid`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们使用了可选参数（`isPaid`）的默认分配值`true`。在第二个例子中，我们分配了一个值`false`。在这两种情况下，方法逻辑都可以访问初始化后的`isPaid`版本。
- en: '| ![](../Images/LightBulb.png)   | method OVERLOADING WITH OPTIONAL PARAMETERS
    If you overload a method with only the addition of an optional parameter and do
    provide not an argument for the optional parameter, the CLR ignores the overload
    with the optional parameter and calls the original method. For example, if we
    have two methods called `BuildHouse(int width, int height)` and `BuildHouse(int
    width, int height, bool isPaid = true)` and we do not pass in an argument for
    `isPaid`, the CLR calls the `BuildHouse(int width, int height)` version. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/LightBulb.png)   | 方法可选参数重载 如果你只通过添加一个可选参数来重载方法，并且没有为可选参数提供参数，CLR会忽略带有可选参数的重载并调用原始方法。例如，如果我们有两个名为`BuildHouse(int
    width, int height)`和`BuildHouse(int width, int height, bool isPaid = true)`的方法，并且我们没有为`isPaid`传递参数，CLR会调用`BuildHouse(int
    width, int height)`版本。 |'
- en: 'A word of caution, however: we can never follow optional parameters with nonoptional
    parameters. The compiler requires optional parameters to be the last in the line
    of arguments. The compiler requiring optional parameters to come last in the parameter
    list means that the following change of the `BuildHouse` method signature does
    not compile:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个注意事项：我们绝不能在非可选参数后面跟可选参数。编译器要求可选参数必须是参数列表中的最后一个。编译器要求可选参数放在参数列表的最后意味着以下对`BuildHouse`方法签名的更改无法编译：
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Under the hood, an optional argument functions as a regular argument but has
    the additional `[opt]` keyword added to the generated Intermediate Language code.
    Because the argument of type `CancellationToken` is optional in the `SaveChangesAsync`
    method, it is up to us whether we want to pass it in. Keep in mind that we need
    to add it to our method signature because we want to override the base’s `SaveChangesAsync`
    method, whose signature contains the optional `CancellationToken` parameter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，一个可选参数作为一个普通参数使用，但会在生成的中间语言代码中添加 `[opt]` 关键字。因为 `SaveChangesAsync` 方法中的
    `CancellationToken` 类型的参数是可选的，所以是否传递它取决于我们。记住，我们需要将其添加到我们的方法签名中，因为我们想覆盖包含可选 `CancellationToken`
    参数的基类 `SaveChangesAsync` 方法。
- en: The CancellationToken class
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancellationToken` 类'
- en: You can cancel database queries in progress by using an instance of `CancellationToken`
    and calling the `CancellationToken.Cancel()` method. Cancellation tokens are also
    used to notify other parts of your code of a canceled request. We don’t use these
    in our code because our requests are simple insertions and retrievals of single
    records with limited foreign key constraints.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `CancellationToken` 的实例并调用 `CancellationToken.Cancel()` 方法来取消正在进行的数据库查询。取消令牌还用于通知代码的其他部分已取消请求。我们不在我们的代码中使用这些，因为我们的请求是简单的单条记录的插入和检索，并且具有有限的键约束。
- en: If you were to kick off a stored procedure that could take minutes to execute,
    you may want to cancel it under some edge condition. In that case, use a cancellation
    token. If we do not pass in an instance of `CancellationToken`, the CLR assigns
    a new instance to the argument on its own.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动了一个可能需要几分钟才能执行的过程，你可能希望在某种边缘情况下取消它。在这种情况下，请使用一个取消令牌。如果我们不传递 `CancellationToken`
    的实例，CLR 会自动为该参数分配一个新的实例。
- en: 'Our stub’s overridden `SaveChangesAsync` method currently has the following
    one statement inside it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们存根覆盖的 `SaveChangesAsync` 方法目前包含以下一个语句：
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The overridden `SaveChangesAsync` method returns a call to the base (nonstub)
    class’s version of `AddAsync`. Returning a call to the base class’s method does
    not work for us. In effect, we overrode the `SaveChangesAsync` method only to
    have it act like a nonoverridden version of it. We need to replace the call to
    the nonstub base version of the `SaveChangesAsync` method with our implementation.
    We’ll do this in the next section.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖的 `SaveChangesAsync` 方法返回对基类（非存根）类 `AddAsync` 方法的调用。返回对基类方法的调用对我们不起作用。实际上，我们覆盖
    `SaveChangesAsync` 方法只是为了让它表现得像未覆盖的版本一样。我们需要用我们的实现来替换对非存根基类 `SaveChangesAsync`
    方法的调用。我们将在下一节中这样做。
- en: 8.7 Conditionals, Func, switches, and switch expressions
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7 条件语句、Func、switch 和 switch 表达式
- en: 'Let’s remember why we are going through this ordeal in the first place: we
    want to unit-test the database exception code path and make sure the code handles
    the exception gracefully. In this section, we’ll take a step forward and implement
    the logic inside the stubbed `SaveChangesAsync` method. We’ll discuss conditionals,
    the `Func` type, switches, and `switch` expressions.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住我们最初为什么要经历这个磨难：我们想要单元测试数据库异常代码路径，并确保代码能够优雅地处理异常。在本节中，我们将向前迈出一大步，并在存根 `SaveChangesAsync`
    方法中实现逻辑。我们将讨论条件语句、`Func` 类型、switch 和 switch 表达式。
- en: To use the stubbed `SaveChangesAsync` method, we need some way to differentiate
    between success and failure paths. We definitely do not want to throw an exception
    every single time the `CreateBooking` method calls `SaveChangesAsync`. Because
    the value of `customerID` is within our control, why don’t we base our stub logic
    around that? If we throw an exception when we set the `entity.CustomerID` to any
    positive integer but “`1`” (an arbitrary number—we just need a number to control
    the code flow with), we can test the database exception code branch without breaking
    existing tests.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用存根 `SaveChangesAsync` 方法，我们需要一种方法来区分成功和失败路径。我们绝对不希望在 `CreateBooking` 方法每次调用
    `SaveChangesAsync` 时都抛出异常。因为 `customerID` 的值在我们控制之下，为什么我们不围绕它来构建我们的存根逻辑呢？如果我们将
    `entity.CustomerID` 设置为任何正整数但不是“`1`”（一个任意数字——我们只需要一个数字来控制代码流程），我们就可以测试数据库异常代码分支，而不会破坏现有的测试。
- en: We can use a variety of ways to check whether `entity.CustomerID` is a positive
    integer of value `1`. We could write a simple conditional that checks whether
    the `CustomerID` is `1` and return the base class’s `AddAsync` result, or else
    throw an exception, as shown in the next listing. We do, however, need to grab
    the `Booking` object we just added to the internal `DbSet<Booking>` through the
    `CreateBooking` method from the context because the `Booking` object is not passed
    into the `SaveChangesAsync` method.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用各种方法来检查`entity.CustomerID`是否是值为`1`的正整数。我们可以编写一个简单的条件来检查`CustomerID`是否为`1`，并返回基类的`AddAsync`结果，或者抛出异常，如下一个列表所示。然而，我们需要从上下文中通过`CreateBooking`方法获取我们刚刚添加到内部`DbSet<Booking>`中的`Booking`对象，因为`Booking`对象没有被传递到`SaveChangesAsync`方法中。
- en: Listing 8.10 Implementing a stubbed version of `SaveChangesAsync`
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.10 实现一个`SaveChangesAsync`的模拟版本
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Overrides the nonstub’s SaveChangesAsync method
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 覆盖非模拟的`SaveChangesAsync`方法
- en: ❷ Checks if the entity’s CustomerID is 1 or not
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查实体的CustomerID是否为1
- en: ❸ Throws an exception if the CustomerID is not 1
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果CustomerID不是1则抛出异常
- en: ❹ Calls the base’s SaveChangesAsync if CustomerID is 1
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果CustomerID是1则调用基的`SaveChangesAsync`
- en: Because there is only one `Booking` in the base’s `Booking DbSet` (we added
    it in `CreateBooking` before calling `SaveChangesAsync`), we can use the `First`
    LINQ method to select the booking.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在基的`Booking DbSet`中只有一个`Booking`（我们在调用`SaveChangesAsync`之前在`CreateBooking`中添加了它），我们可以使用`First`
    LINQ方法来选择预订。
- en: 8.7.1 The ternary conditional operator
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.1 三元条件运算符
- en: To condense the code further, we can also combine the conditional into a simple
    return statement paired with the ternary conditional operator (`?:`), as shown
    in the following code listing.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步压缩代码，我们还可以将条件组合成一个简单的返回语句，并配以三元条件运算符（`?:`），如下面的代码列表所示。
- en: Listing 8.11 Using a ternary conditional operator to condense a conditional
    return block
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.11 使用三元条件运算符来压缩条件返回块
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Is the Booking’s CustomerID set to 1?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 预订的CustomerID是否设置为1？
- en: '❷ True condition: throws an exception'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 正确条件：抛出异常
- en: '❸ False condition: Calls the nonstub’s SaveChangesAsync'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 错误条件：调用非模拟的`SaveChangesAsync`
- en: '| ![](../Images/LightBulb.png)   | TERNARY conditional OPERATOR MNEMONIC If
    you ever get confused as to what the order of operations in a ternary conditional
    operator is, a good mnemonic is “`expression ? true : false`.” |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/LightBulb.png)   | 三元条件运算符助记符：如果你对三元条件运算符中的操作顺序感到困惑，一个好的助记符是“`expression
    ? true : false`。” |'
- en: Both using an `if` statement and the ternary conditional operator approaches
    would work fine, but what if we ever want to expand on our conditional branches?
    Sure, we could create unlimited `else` clauses to tack onto the conditional, but
    that would become an annoyance when the number of conditional clauses grows larger
    and larger.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是使用`if`语句还是三元条件运算符方法都可以正常工作，但如果我们想扩展我们的条件分支怎么办？当然，我们可以创建无限多的`else`子句附加到条件上，但当条件子句的数量越来越多时，这会变得很麻烦。
- en: 8.7.2 Branching using an array of functions
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.2 使用函数数组进行分支
- en: We could also do something more technical, such as creating an array of `Func<Task
    <int>>` objects that use a lambda delegate and calling them using the value of
    `CustomerID` as the index to the list, then invoking the delegate to execute the
    appropriate logic, as shown in the next code sample.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以做一些更技术性的事情，比如创建一个`Func<Task<int>>`对象的数组，使用lambda委托，并使用`CustomerID`的值作为列表的索引来调用它们，然后调用委托来执行适当的逻辑，如下一个代码示例所示。
- en: Listing 8.12 Using a `Func<Task<int>>` and invoking lambda delegates by index
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.12 使用`Func<Task<int>>`并通过索引调用lambda委托
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Creates an array of Func’s of Task of Integer (Func<T<Y>>)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个Func的Task的整数（Func<T<Y>>）数组
- en: ❷ This Task throws an exception.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个任务会抛出异常。
- en: ❸ This Task returns the base call’s SaveChangesAsync integer result.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这个任务返回基调用`SaveChangesAsync`的整数结果。
- en: ❹ Invokes a Task using Booking.CustomerID as the index to functions
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用Booking.CustomerID作为索引调用函数
- en: Using a `Func<Task<int>>[]` is surely a bit excessive and works only for specific
    index values. If the `functions` array has only two elements, and the `CustomerID`
    is `2` (remember, in C# collections are zero-based), we would receive an out-of-range
    exception because the requested element’s index is higher than the last element
    in the collection.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Func<Task<int>>[]`可能有点过度，并且仅适用于特定的索引值。如果`functions`数组只有两个元素，而`CustomerID`是`2`（记住，在C#中集合是零基的），我们会收到一个越界异常，因为请求的元素的索引高于集合中的最后一个元素。
- en: 8.7.3 Switch statements and expressions
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.3 `switch`语句和表达式
- en: Instead of using a simple conditional, a conditional with a ternary conditional
    operator, or invoking a `Task` based on an index, I advocate for the use of the
    trusted old `switch` statement, shown next.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用简单的条件语句、三元条件运算符的条件语句，或者根据索引调用一个`Task`，我主张使用可靠的旧式`switch`语句，如下所示。
- en: Listing 8.13 Using a regular `switch` statement to branch code
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.13 使用常规`switch`语句进行代码分支
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Switches logic branches based on the CustomerId value
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 根据CustomerId值切换逻辑分支
- en: ❷ If CustomerId is 1, calls the nonstub SaveChangesAsync
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果CustomerId为1，则调用非存根的SaveChangesAsync
- en: '❸ If no other cases match, executes the default: throws an exception'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果没有其他情况匹配，则执行默认操作：抛出异常
- en: In the `switch` statement of listing 8.13, we execute the regular, nonoverridden
    `SaveChangesAsync` path for `CustomerId`s of `1`. In a `switch` statement, if
    no cases match, it looks for a `default` case and executes that. If you do not
    provide a `default` case, and there are no case matches, the `switch` statement
    won’t execute any case. Here, the default case is when `CustomerId` is anything
    but `1`. Our `default` case throws an exception.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表8.13的`switch`语句中，我们执行了针对`CustomerId`为`1`的常规、非重写的`SaveChangesAsync`路径。在`switch`语句中，如果没有匹配的情况，它会查找`default`情况并执行它。如果你没有提供`default`情况，并且没有匹配的情况，则`switch`语句不会执行任何情况。在这里，`default`情况是当`CustomerId`不是`1`时。我们的`default`情况会抛出异常。
- en: C# 8 introduced a new feature for `switch` statements called `switch` *expressions*.
    It allows us to write slightly more concise `switch` statements by using syntax
    similar to lambda expressions, as shown in the following listing.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8引入了`switch`语句的新特性，称为`switch` *表达式*。它允许我们通过使用类似于lambda表达式的语法来编写稍微简洁的`switch`语句，如下所示。
- en: Listing 8.14 Using `switch` expressions to branch code
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.14 使用`switch`表达式进行代码分支
- en: '[PRE27]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Returns the result of the switch statement
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回`switch`语句的结果
- en: ❷ Calls the nonstub SaveChangesAsync if CustomerID is 1
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当CustomerID为1时，调用非存根的SaveChangesAsync
- en: '❸ The default case: throws an exception'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 默认情况：抛出异常
- en: 'Using a `switch` expression can condense your long `switch` statements quite
    a bit. We should also see whether the code throws a `CouldNotAddBookingToDatabaseException`.
    To do this, the appropriate unit test must use the following `[ExpectedException]`
    method attribute:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`switch`表达式可以大大简化你的长`switch`语句。我们还应该查看代码是否抛出了`CouldNotAddBookingToDatabaseException`异常。为此，适当的单元测试必须使用以下`[ExpectedException]`方法属性：
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s run the test. Lo and behold, it passes! We are now ready to come back
    to, and wrap up, our final test for `BookingRepository`: `BookingRepository_Success.`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试。结果令人惊讶，它通过了！我们现在可以回到并完成对`BookingRepository`的最终测试：`BookingRepository_Success。`
- en: As things stand now, we have only a skeleton of a method, but all we have to
    do is pass in valid arguments to `CreateBooking`, as shown in the next listing.
    There is no output from the `CreateBooking` method, so any assertions we make
    need to be done on Entity Framework Core’s internal `DbSet<Booking>`. We want
    to assert that a `Booking` was indeed created in the in-memory database and that
    it has a `CustomerID` of `1`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如此看来，我们目前只有一个方法框架，但我们只需向`CreateBooking`传递有效的参数，如下一个列表所示。`CreateBooking`方法没有输出，因此我们进行的任何断言都需要在Entity
    Framework Core的内部`DbSet<Booking>`上完成。我们想要断言确实在内存数据库中创建了一个`Booking`，并且它有一个`CustomerID`为`1`。
- en: Listing 8.15 Completed `BookingRepository.CreateBooking_Success` unit test
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.15 完成的`BookingRepository.CreateBooking_Success`单元测试
- en: '[PRE29]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Creates the booking in the in-memory database
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在内存数据库中创建预订
- en: ❷ Retrieves the booking from the in-memory database
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从内存数据库中检索预订
- en: ❸ Verifies that the booking is not null
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 验证预订不为空
- en: ❹ Verifies that the booking has the correct CustomerID
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 验证预订具有正确的CustomerID
- en: ❺ Verifies that the booking has the correct FlightNumber
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 验证预订具有正确的FlightNumber
- en: 'Let’s run the test and see what happens. Hang on! The `CreateBooking_Success`
    test fails. But why? It says the method threw an exception of type `CouldNotAddBookingToDatabaseException`.
    We fell into one of the most common pitfalls that Entity Framework Core offers:
    we did not save our changes to the `DbSet<Booking>` (and to the database) before
    accessing it.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试看看会发生什么。等等！`CreateBooking_Success`测试失败了。但是为什么？它说方法抛出了一个类型为`CouldNotAddBookingToDatabaseException`的异常。我们陷入了Entity
    Framework Core提供的最常见陷阱之一：在访问它之前，我们没有将更改保存到`DbSet<Booking>`（以及数据库）中。
- en: 8.7.4 Querying for pending changes in Entity Framework Core
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.4 在Entity Framework Core中查询挂起的更改
- en: If we look back at the `SaveChangesAsync` method in the stub, we see that we
    access `context.Booking` before calling `base.SaveChangesAsync`. Accessing the
    `Booking DbSet` before saving any changes we made to the internal `DbSet`s to
    the database means that there is nothing in the booking collection yet, causing
    a `NullReferenceException`, which we catch in the `CreateBooking` method. The
    `CreateBooking` method then throws a `CouldNotAddBookingToDatabaseException`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾模拟中的 `SaveChangesAsync` 方法，我们会看到在调用 `base.SaveChangesAsync` 之前访问 `context.Booking`。在将我们对内部
    `DbSet` 所做的任何更改保存到数据库之前访问 `Booking DbSet` 意味着在预订集合中还没有任何内容，这会导致 `NullReferenceException`，我们在
    `CreateBooking` 方法中捕获它。然后，`CreateBooking` 方法会抛出 `CouldNotAddBookingToDatabaseException`。
- en: 'The solution is simple: call `base.SaveChangesAsync` before accessing `context
    .Booking`. Because we are using an in-memory database, we can commit a `Booking`
    object to the database during the failure path unit test because the `TestInitialize`
    method creates a new instance of the database context (and implicitly wipes the
    database) before the next test. The important part of the test is that the exception
    gets thrown. That means we do not need the `default` case in our `switch` statement
    anymore. That being said, let’s change the executed logic on the non-`default`
    statement to return an integer of value `1`. The `SaveChangesAsync` method returns
    (in a nonstubbed scenario) the number of entries written to the database. I see
    no reason to deviate from that pattern in the stub. We are mimicking its operations,
    after all.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案很简单：在访问 `context.Booking` 之前调用 `base.SaveChangesAsync`。因为我们使用的是内存数据库，所以在失败路径单元测试期间我们可以将
    `Booking` 对象提交到数据库，因为 `TestInitialize` 方法在下一个测试之前创建了一个新的数据库上下文实例（并且隐式地清除了数据库）。测试的重要部分是异常被抛出。这意味着我们不再需要在
    `switch` 语句中包含 `default` 的情况。话虽如此，让我们将非 `default` 语句上执行的逻辑更改为返回值为 `1` 的整数。`SaveChangesAsync`
    方法（在非模拟场景中）返回写入数据库的条目数。我认为在模拟中没有理由偏离这个模式。毕竟，我们是在模仿它的操作。
- en: The only purpose of the nondefault `switch` value (in this scenario) is to satisfy
    the required return type of `Task<int>`. By returning a value of `0`, we complete
    the method and do no harm. We still throw an exception in case `CustomerID` is
    anything but `1`, as shown in the next listing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，非默认 `switch` 值的唯一目的是满足 `Task<int>` 所需的返回类型。通过返回一个值为 `0` 的值，我们完成方法并且没有造成伤害。我们仍然在
    `CustomerID` 不是 `1` 的情况下抛出异常，如下一个列表所示。
- en: Listing 8.16 Stubbed `SaveChangesAsync` method with base `SaveChangesAsync`
    call
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.16 使用基类 `SaveChangesAsync` 调用的模拟 `SaveChangesAsync` 方法
- en: '[PRE30]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Calls the nonstub SaveChangesAsync
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用非模拟的 SaveChangesAsync
- en: ❷ Switches based on the CustomerId
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 根据 CustomerId 进行切换
- en: ❸ If the CustomerID is 1, returns a 0
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果 CustomerID 是 1，则返回 0
- en: ❹ If the CustomerID is not 1, throws an exception
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果 CustomerID 不是 1，则抛出异常
- en: 'If we run the test now, we see it passes. However, we have an additional problem
    to consider here. Currently, we’re throwing an exception if the `CustomerId` is
    anything but `1`, but our changes have already been saved to the database. We
    really should test the `CustomerID` before saving to the database. To do this,
    we need to be able to access the pending changes to the database. Entity Framework
    Core lets us do this by querying its internal `StateTracker` for entities with
    an `EntityState` of `Added` as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行测试，它会通过。然而，这里我们还有一个额外的问题需要考虑。目前，如果 `CustomerId` 不是 `1`，我们会抛出异常，但我们的更改已经保存到数据库中。我们实际上应该在保存到数据库之前测试
    `CustomerID`。为此，我们需要能够访问数据库的挂起更改。Entity Framework Core 允许我们通过查询其内部的 `StateTracker`
    来获取具有 `EntityState` 为 `Added` 的实体，如下所示：
- en: '[PRE31]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The resulting `IEnumerable` collection contains only our pending changes. What
    we really want, though, is the `Entity` objects on the pending changes. We can
    use a LINQ `Select` statement to grab only the `Entity` objects, as shown here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的 `IEnumerable` 集合仅包含我们挂起的更改。然而，我们真正想要的是挂起更改中的 `Entity` 对象。我们可以使用 LINQ 的 `Select`
    语句来仅获取 `Entity` 对象，如下所示：
- en: '[PRE32]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'From here, we can cast the `EntityEntry` to our `Booking` type and grab the
    `CustomerId`. To cast (and select only) the entities mapped to a `Booking`, we
    can use the `OfType<T>` method on the `IEnumerable` as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以将 `EntityEntry` 强制转换为我们的 `Booking` 类型并获取 `CustomerId`。为了将（并选择）映射到 `Booking`
    的实体进行强制转换（和选择），我们可以在 `IEnumerable` 上使用 `OfType<T>` 方法，如下所示：
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can use these instances of `Booking` to verify we don’t have any pending
    changes with a `CustomerId` of `1`, like so:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些 `Booking` 实例来验证我们没有任何带有 `CustomerId` 为 `1` 的挂起更改，如下所示：
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: All we have to do is throw an exception in case we do have such a pending change.
    If we don’t, then we can go ahead and save the changes to the database, as shown
    in the following code sample.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是抛出一个异常，以防我们确实有这种挂起的更改。如果没有，我们就可以继续将更改保存到数据库中，如下面的代码示例所示。
- en: Listing 8.17 Checking for valid `CustomerID` in stub before saving to the database
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.17 在保存到数据库之前在存根中检查有效的 `CustomerID`
- en: '[PRE35]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To make sure we didn’t break anything, let’s run all the unit tests in the
    solution. It seems that the `CreateBooking_Success` test case passes when run
    individually but not when run in tandem with the other tests. The test runner
    reports back that an exception of type `CouldNotAddBookingToDatabaseException`
    was thrown. Well, we went straight from an Entity Framework Core pitfall into
    an inheritance pitfall: when creating a new instance of a class, the base class
    does not get instantiated if it already exists. When we request a new instance
    of `FlyingDutchmanAirlinesContext _Stub`, the CLR does not instantiate an instance
    of its parent (`FlyingDutchmanAirlinesContext`) if one already exists. In practical
    terms, this means we are dealing with the same database context across unit tests,
    and, therefore, the contents of the in-memory database do not get wiped after
    every test. Therefore, when we execute the `CreateBooking_Success` test case,
    there is a chance that a lingering `Booking` instance remains in the database.
    Because we request the first booking’s `CustomerID` from the context in our overridden
    `SaveChangesAsync` method, we could end up getting one with a wrong `CustomerID`.
    What can we do about this? Either of the following two approaches may work for
    us here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们没有破坏任何东西，让我们在解决方案中运行所有的单元测试。似乎当单独运行时，`CreateBooking_Success` 测试用例通过，但与其他测试一起运行时则不通过。测试运行器报告说抛出了一个类型为
    `CouldNotAddBookingToDatabaseException` 的异常。嗯，我们直接从 Entity Framework Core 的陷阱跳到了继承的陷阱：当创建一个新实例的类时，如果基类已经存在，则不会实例化基类。当我们请求
    `FlyingDutchmanAirlinesContext _Stub` 的新实例时，如果其父类（`FlyingDutchmanAirlinesContext`）已经存在，CLR
    不会实例化其父类。在实践中，这意味着我们在单元测试中处理的是同一个数据库上下文，因此内存数据库的内容在每次测试后不会清除。因此，当我们执行 `CreateBooking_Success`
    测试用例时，有可能数据库中仍然存在一个残留的 `Booking` 实例。因为我们从上下文中在我们的重写 `SaveChangesAsync` 方法中请求第一个预订的
    `CustomerID`，我们可能会得到一个错误的 `CustomerID`。我们能做什么呢？以下两种方法中的任何一种都可能对我们有效：
- en: Manually clear the database’s `DbSet<Booking>` in the `TestInitialize` method.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `TestInitialize` 方法中手动清除数据库的 `DbSet<Booking>`。
- en: Use Entity Framework Core’s `EnsureDeleted` method, which checks whether a database
    is deleted. If the database is still alive, `EnsureDeleted` unceremoniously deletes
    the database anyway.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Entity Framework Core 的 `EnsureDeleted` 方法，该方法检查数据库是否被删除。如果数据库仍然存在，`EnsureDeleted`
    会毫不犹豫地删除数据库。
- en: Both approaches work equally well, but to keep things interesting, let’s try
    our hand at using the `EnsureDeleted` method. We could call the `EnsureDeleted`
    method in either the `TestInitialize` method or in the constructor of `FlyingDutchmanAirlines
    _Stub`. In my view, we are better off putting it in the stub’s constructor, as
    shown in the next listing. Using the `EnsureDeleted` method is very much related
    to us using a stub, and I like to keep the `TestInitialize` methods as similar
    as possible between test classes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法效果相同，但为了保持有趣，让我们尝试使用 `EnsureDeleted` 方法。我们可以在 `TestInitialize` 方法或 `FlyingDutchmanAirlines
    _Stub` 的构造函数中调用 `EnsureDeleted` 方法。在我看来，我们最好将其放在存根的构造函数中，如下一列表所示。使用 `EnsureDeleted`
    方法与我们使用存根非常相关，我喜欢在测试类之间保持 `TestInitialize` 方法尽可能相似。
- en: Listing 8.18 Use `EnsureDeleted` to delete an in-memory database
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.18 使用 `EnsureDeleted` 删除内存数据库
- en: '[PRE36]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Deletes the nonstub’s in-memory database
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 删除非存根的内存数据库
- en: If we now run all our tests, we see that the `CreateBooking_Success` test case
    passes quite nicely.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行所有的测试，我们会看到 `CreateBooking_Success` 测试用例运行得相当好。
- en: And with that, we’ve completed the `BookingRepository`. You are now well versed
    in the worlds of generics, optional parameters, switch expressions, and the Liskov
    substitution principle.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了 `BookingRepository`。你现在对泛型、可选参数、switch 表达式和 Liskov 替换原则的世界了如指掌。
- en: Exercises
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 8.6
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.6
- en: True or false? When using a stub, you have to overload the base class’s methods.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？当使用存根时，你必须重载基类的方法。
- en: Exercise 8.7
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.7
- en: Because of which principle were we able to use an instance of `FlyingDutchmanContext_Stub`
    as if it were an instance of type `FlyingDutchmanContext`?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哪个原则，我们才能将 `FlyingDutchmanContext_Stub` 的一个实例用作 `FlyingDutchmanContext` 类型的实例？
- en: a. The Liskov substitution principle
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: a. Liskov 替换原则
- en: b. The DRY principle
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: b. DRY 原则
- en: c. The Phragmén–Lindelöf principle
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: c. Phragmén–Lindelöf 原则
- en: Exercise 8.8
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.8
- en: When programming with generics, can I add an instance of type `float` to a `List<bool>`?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用泛型编程时，我能否将 `float` 类型的实例添加到 `List<bool>` 中？
- en: a. Yes
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: a. 是
- en: b. No
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: b. 否
- en: c. Let me Stack Overflow that for you.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: c. 让我帮你 Stack Overflow。
- en: Exercise 8.9
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.9
- en: 'What is this an example of? `where T : Queue<int>`'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '这是什么例子？`where T : Queue<int>`'
- en: a. A generic collection
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: a. 一个泛型集合
- en: b. A generic generalization
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: b. 一个通用的泛化
- en: c. A generic constraint
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: c. 一个泛型约束
- en: Exercise 8.10
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.10
- en: True or false? We can use generics only with classes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 真或假？我们只能与类一起使用泛型。
- en: Exercise 8.11
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.11
- en: True or false? Classes with generics can have only one generic constraint.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 真或假？具有泛型的类只能有一个泛型约束。
- en: Exercise 8.12
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.12
- en: True or false? You cannot have a generic type as a type of method parameter.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 真或假？你不能将泛型类型用作方法参数的类型。
- en: Exercise 8.13
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.13
- en: True or false? The use of optional parameters is optional.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 真或假？使用可选参数是可选的。
- en: Exercise 8.14
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.14
- en: In a method’s parameter list, where do optional parameters go?
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法参数列表中，可选参数放在哪里？
- en: a. At the start
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: a. 在开始时
- en: b. At the end
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: b. 在末尾
- en: c. Anywhere
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: c. 任何地方
- en: Exercise 8.15
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.15
- en: True or false? Like a default implicit constructor, if you do not declare a
    `default` case in a `switch` statement, the compiler generates it for you and
    executes the first case you specified.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 真或假？就像默认隐式构造函数一样，如果你在 `switch` 语句中没有声明 `default` 情况，编译器会为你生成它并执行你指定的第一个情况。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Separation of concerns means that we want to isolate modules of logic from each
    other. This ensures that our code is testable and atomic. Atomic code is more
    readable and extendable.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点分离意味着我们希望将逻辑模块彼此隔离。这确保了我们的代码是可测试的和原子的。原子代码更易于阅读和扩展。
- en: Coupling refers to how integrated two “concerns” are. Tight coupling can mean
    that a certain class deeply depends on another class, whereas loose coupling between
    two classes means a class can be changed and expanded without causing an issue
    for the other class. Classes with tight coupling are more difficult to maintain,
    because you can easily introduce side effects when you don’t know the full extent
    of the dependencies.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 耦合指的是两个“关注点”如何集成。紧密耦合可能意味着某个类深度依赖于另一个类，而两个类之间的松耦合则意味着一个类可以更改和扩展，而不会对另一个类造成问题。具有紧密耦合的类更难以维护，因为你不知道依赖关系的全部范围时，很容易引入副作用。
- en: You can inline values from variables into a string by using string interpolation.
    This makes it easy to construct complex strings without using the explicit concatenation
    operator.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用字符串插值将变量的值内联到字符串中。这使得在不使用显式连接运算符的情况下构建复杂字符串变得容易。
- en: Strings are immutable. Any operator (concatenation, deletion, replacements)
    on a string causes the CLR to allocate a new area in memory for the new copy of
    the string. This means that if you do a lot of operations of a string, every step
    (concatenation, deletion) along the way results in new memory allocations. This
    is important to keep in mind when dealing with many concatenations or deletions.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串是不可变的。对字符串的任何操作（连接、删除、替换）都会导致 CLR 在内存中为字符串的新副本分配一个新的区域。这意味着如果你对字符串进行很多操作，每一步（连接、删除）都会导致新的内存分配。在处理许多连接或删除时，这一点很重要。
- en: When assigning numerous properties to values after instantiating a new object,
    using the object initializer allows for condensed and more readable syntax. Object
    initializers are the idiomatic way to instantiate complex objects when no appropriate
    constructor is provided.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实例化新对象后向值分配多个属性时，使用对象初始化器允许使用更紧凑和更易读的语法。当没有提供适当的构造函数时，对象初始化器是实例化复杂对象的惯用方式。
- en: The Liskov substitution principle states that a subtype of a type should be
    able to do everything the parent type can do. This means that we can use a subtype
    as if it were the parent type. The Liskov substitution principle explains why
    we can use polymorphism.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Liskov 替换原则指出，一个类型的子类型应该能够做父类型能做的所有事情。这意味着我们可以像使用父类型一样使用子类型。Liskov 替换原则解释了为什么我们可以使用多态。
- en: A stub is a piece of code that uses the Liskov substitution principle to act
    as if it were its parent class (or functionality) while overriding and redirecting
    certain methods to guarantee certain functionality. Stubs are very useful for
    throwing exceptions and returning specific responses when unit testing.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟代码是一个使用Liskov替换原则来充当其父类（或功能）的代码片段，同时覆盖和重定向某些方法以确保特定功能。模拟代码在单元测试中非常有用，可以抛出异常并返回特定响应。
- en: Generics allow us to constrict classes, methods, or types to work with a certain
    type. For example, a `Stack<MaineCoon>` or a `List<ISnack>` uses generics to constrain
    their functionality to a certain type or group of types. Constraining your code
    in this way is a useful technique to control your data types and ensuring that
    they stay within your expectations throughout your code.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型允许我们将类、方法或类型约束为使用特定类型。例如，`Stack<MaineCoon>`或`List<ISnack>`使用泛型来约束其功能以适应特定类型或类型组。以这种方式约束代码是一种有用的技术，可以控制数据类型并确保它们在整个代码中符合预期。
- en: Optional parameters allow us to define nonrequired arguments for methods. An
    optional parameter takes on the value of the defined value if no matching argument
    is passed into the method. Optional parameters are useful when our code relies
    on multiple possible sets of parameter values, but we can continue processing
    if we do not pass in a specific parameter.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选参数允许我们为方法定义非必需的参数。如果没有传递匹配的参数，可选参数将采用定义的值。当我们的代码依赖于多个可能的参数值集时，可选参数非常有用，即使我们没有传递特定参数，我们也可以继续处理。
- en: The Entity Framework Core `EnsureDeleted` method checks whether a database is
    deleted. If it is not, it deletes it. This comes in handy when working with an
    in-memory database during testing to ensure no remnants of previous test data
    remain.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Entity Framework Core的`EnsureDeleted`方法检查数据库是否已被删除。如果没有，则将其删除。这在测试期间与内存数据库一起工作时非常有用，以确保没有之前测试数据的残留。
- en: '* * *'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: ^(1.)For details on the heapsort algorithm, see A. K. Dewdney’s *New Turing
    Omnibus*, chapter 40, “Heaps and Merges” (W.H. Freeman and Company, 1993) or Robert
    Sedgewick and Kevin Wayne’s *Algorithms*, chapter 2.7, “Heapsort” (4th edition;
    Pearson Education, Inc., 2011).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: (1.)关于堆排序算法的详细信息，请参阅A. K. Dewdney的《新图灵 Omnibus》，第40章，“堆和合并”（W.H. Freeman and
    Company，1993年）或Robert Sedgewick和Kevin Wayne的《算法》，第2.7章，“堆排序”（第4版；Pearson Education,
    Inc.，2011年）。
