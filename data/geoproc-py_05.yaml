- en: Chapter 6\. Manipulating geometries with OGR
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章 使用OGR操作几何体
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Creating points, lines, and polygons from scratch
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从零开始创建点、线和多边形
- en: Editing existing geometries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑现有几何体
- en: Thus far we’ve talked about using OGR to read and write vector datasets and
    how to edit attribute values, but you haven’t manipulated the geometries in any
    way. If you want to create your own data and not use someone else’s, you’ll need
    to know how to work with the actual geometries. For example, if you have a time
    series of GPS coordinates from a hiking or bicycling trip, you can create a line
    that represents the route you took. You can even compare the timestamps from the
    GPS locations to the timestamps on the photos you took to create a point dataset
    showing where you stopped to take pictures.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了如何使用OGR读取和写入矢量数据集以及如何编辑属性值，但你还没有以任何方式操作几何体。如果你想创建自己的数据而不是使用别人的，你需要知道如何与实际的几何体一起工作。例如，如果你有一系列来自徒步或骑自行车旅行的GPS坐标时间序列，你可以创建一条代表你走过的路线的线。你甚至可以将GPS位置的时间戳与你在照片上的时间戳进行比较，以创建一个点数据集，显示你停下来拍照的位置。
- en: You might even need to know how to manipulate geometries to better display existing
    data. For example, say you want to create a map using your photo points and link
    them to the actual photos. Certain locations will probably have multiple photos
    in the same spot. You can deal with this many ways, but one way is to offset each
    point a little in a different direction so that it looks like a cluster of points
    instead of only one. But to do this, you need to know how to manipulate the point
    geometries themselves.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可能需要了解如何操作几何体以更好地显示现有数据。例如，假设你想使用你的照片点创建地图并将它们链接到实际的照片。某些位置可能在同一地点有多个照片。你可以用多种方式处理这种情况，但一种方法是将每个点稍微向不同方向偏移，使其看起来像是一组点而不是一个点。但要做到这一点，你需要知道如何操作点几何体本身。
- en: You can also manipulate and combine geometries to create new ones. For example,
    if you want to create a simple map of riparian areas from a stream dataset, and
    you assume that the riparian zones stretch one meter on either side of a stream,
    you can create a polygon that surrounds each stream, with the edges of the polygon
    one meter out on each side of the water. If two streams join, then these polygons
    will overlap near their confluence, and you can combine the overlapping polygons
    into one using a union operation. You’ll learn how to do all of this, and more,
    in the next two chapters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以操作和组合几何体以创建新的几何体。例如，如果你想从一个河流数据集中创建一个简单的河岸区域地图，并且你假设河岸区域在河流两侧延伸一米，你可以创建一个围绕每条河流的多边形，多边形的边缘在水的每侧向外延伸一米。如果两条河流汇合，那么这些多边形将在它们的汇合处重叠，你可以使用并集操作将重叠的多边形合并成一个。你将在接下来的两个章节中学习如何做所有这些，以及更多。
- en: Before you can do any of this, however, you need to be acquainted with the different
    types of geometries.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在你能够做任何这些之前，你需要熟悉不同类型的几何体。
- en: 6.1\. Introduction to geometries
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 几何体简介
- en: You have several kinds of geometries with which you can work, points being the
    simplest. All other types are made up of points connected by straight line segments,
    and the points are what store the coordinate values, so points can be thought
    of as the building blocks of geometries. These points that are used to build other
    geometries are called *vertices*, and there can be thousands of vertices per geometry,
    if needed. For example, line geometries are an ordered collection of points that
    are connected by straight line segments, with a vertex at every location where
    the line needs to change direction. A line representing a short dead-end street
    wouldn’t require many vertices, but one representing the Amazon River in much
    detail would need thousands. Polygons are somewhat similar to lines, but they’re
    closed, meaning the first and last vertex are identical and they enclose a specific
    area. You’ll start with creating and editing points and work your way up to the
    more complicated geometries as you go along.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以与几种几何形状一起工作，点是最简单的。所有其他类型都是由通过直线段连接的点组成的，而这些点存储坐标值，因此可以将点视为几何形状的基本构建块。用于构建其他几何形状的点称为
    *顶点*，如果需要，每个几何形状可以有数千个顶点。例如，线几何形状是由通过直线段连接的有序点集合，每个需要改变方向的线段位置都有一个顶点。代表短死胡同街道的线可能不需要很多顶点，但代表亚马逊河的详细线则需要数千个。多边形与线
    somewhat 类似，但它们是封闭的，这意味着第一个和最后一个顶点是相同的，并且它们围成一个特定的区域。你将从创建和编辑点开始，随着学习的深入，逐步过渡到更复杂的几何形状。
- en: '|  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: A vertex is a point where two line segments of a geometry meet. Vertices hold
    coordinates for the ends of each line segment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个顶点是一个几何形状中两条线段相交的点。顶点保存每个线段末端的坐标。
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Although many geometries live only in a two-dimensional (2D) Cartesian coordinate
    plane with x and y coordinates, it’s also possible to have three-dimensional (3D)
    geometry objects with z values. These z values are typically used to represent
    elevation, but can also be used for other data, such as maximum annual temperature.
    Technically, these geometries are considered 2.5D instead of 3D in OGR, because
    OGR doesn’t take the z values into account when performing spatial operations.
    One thing to be aware of is that although you can add z values to 2D geometries,
    they’ll be ignored when writing the data to a file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多几何形状仅存在于二维（2D）笛卡尔坐标系平面中，具有 x 和 y 坐标，但也可以有具有 z 值的三维（3D）几何对象。这些 z 值通常用于表示高程，但也可以用于其他数据，例如最大年温度。技术上，这些几何形状在
    OGR 中被认为是 2.5D 而不是 3D，因为 OGR 在执行空间操作时不考虑 z 值。需要注意的一点是，尽管你可以将 z 值添加到 2D 几何形状中，但在将数据写入文件时，它们将被忽略。
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Geometries with only x and y coordinates are considered 2D. Geometries with
    an additional z coordinate are considered 2.5D instead of 3D in OGR because the
    z values aren’t taken into account when performing spatial operations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 x 和 y 坐标的几何形状被认为是二维的。在 OGR 中，具有附加 z 坐标的几何形状被认为是 2.5D 而不是 3D，因为当执行空间操作时，z
    值不被考虑。
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: It’s probably easiest to work with simple geometries when you’re beginning,
    so you’ll learn to create different geometry types by re-creating the fictional
    yard shown in [figure 6.1](#ch06fig01). If you use your imagination when looking
    at this figure, hopefully you can envision a yard with a house in the middle,
    rectangular garden beds to the east, a sidewalk on the north side (solid line),
    stone pathways (dotted lines), a fire pit (star), and outdoor water spigots (circles).
    Although you’ll create this scenario in two-dimensional space, the same concepts
    apply to 2.5D geometries.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，与简单几何形状一起工作可能最容易，因此你将学习通过重新创建图 6.1 中显示的虚构庭院来创建不同的几何类型。当你查看这个图时，如果你发挥想象力，希望你能想象出一个中间有房子的庭院，东边有矩形花园床，北边有人行道（实线），石子小径（虚线），篝火（星号），以及户外水龙头（圆形）。虽然你将在二维空间中创建这个场景，但同样的概念也适用于
    2.5D 几何形状。
- en: Figure 6.1\. The fictional yard whose geometries you’ll create throughout this
    chapter. Coordinates are in meters.
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1\. 你将在本章中创建其几何形状的虚构庭院。坐标以米为单位。
- en: '![](06fig01_alt.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig01_alt.jpg)'
- en: Although the shapes shown in [figure 6.1](#ch06fig01) are simple, the concepts
    are exactly the same as working with complex geometries. You can apply the material
    you learn here to real-world scenarios.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然图 6.1 中显示的形状很简单，但概念与处理复杂几何形状时完全相同。你可以将在这里学到的材料应用到现实世界的场景中。
- en: 6.2\. Working with points
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 处理点
- en: Points consist of an east/west x coordinate, a north/south y coordinate, and
    sometimes a vertical z coordinate that’s commonly used for elevation. You’re probably
    familiar with the x coordinate being called *longitude* and the y coordinate called
    *latitude*. These terms are appropriate when a geographic coordinate system is
    being used, where latitude ranges from -90 to 90 and longitude is between -180
    and 180\. If the coordinates have been projected into a Cartesian coordinate system,
    such as UTM, then common terms are *easting* for the x coordinate and *northing*
    for the y.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 点由一个东西向的x坐标、一个南北向的y坐标，有时还有一个用于高度的垂直z坐标组成。你可能熟悉x坐标被称为*经度*，y坐标被称为*纬度*。当使用地理坐标系统时，这些术语是合适的，其中纬度范围从-90到90，经度在-180和180之间。如果坐标已经被投影到笛卡尔坐标系中，如UTM，那么常见的术语是x坐标的*东西方向*和y坐标的*南北方向*。
- en: Points are used to represent items that have only one set of coordinates. Points
    don’t have a length, width, area, or any other measurement. Despite this, the
    features represented by points on a map vary depending on scale, and those features
    might have an area in real life. For example, a map of France would most likely
    represent Paris as a single point, while a map of the Île-de-France region would
    show more detail, with the Paris city boundaries represented as polygons and major
    landmarks such as the Eiffel Tower shown as points. As the scale changes, the
    areas of features represented by points will also change, similar to the way the
    area covered by the Eiffel Tower is much smaller than that covered by Paris.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 点用于表示只有一组坐标的项目。点没有长度、宽度、面积或其他测量值。尽管如此，地图上由点表示的特征会根据比例尺而变化，这些特征在现实生活中可能有面积。例如，法国地图很可能会将巴黎表示为一个单点，而Île-de-France地区的地图会显示更多细节，巴黎城市边界以多边形表示，而像埃菲尔铁塔这样的主要地标则以点表示。随着比例尺的变化，由点表示的特征面积也会变化，类似于埃菲尔铁塔覆盖的面积远小于巴黎。
- en: 6.2.1\. Creating and editing single points
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1\. 创建和编辑单点
- en: Looking at the yard diagram, you can see that the fire pit is a perfect candidate
    to be represented as a single point, so let’s build it. [Figure 6.2](#ch06fig02)
    shows a close-up of the area so that you can see the coordinates.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 观察yard图，你可以看到篝火坑是表示为单点的理想候选，让我们来构建它。[图6.2](#ch06fig02)显示了该区域的特写，以便你可以看到坐标。
- en: Figure 6.2\. You can use a single point to hold the fire pit geometry, shown
    here as a star.
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2\. 您可以使用一个单点来表示篝火坑的几何形状，这里显示为一个星形。
- en: '![](06fig02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig02.jpg)'
- en: 'Unless you have a text representation of the geometry you want to build, the
    first step to building any type of geometry with OGR is to create an empty `Geometry`
    object using one of the constants from [table 6.1](#ch06table01). Go ahead and
    do this in an interactive window so that you can get immediate results:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你有你想要构建的几何形状的文本表示，否则使用OGR构建任何类型几何的第一步是使用[表6.1](#ch06table01)中的某个常量创建一个空的`Geometry`对象。请在一个交互式窗口中这样做，以便你可以立即得到结果：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Table 6.1\. OGR constants denoting geometry types
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.1\. 表示几何类型的OGR常量
- en: '| Geometry type | 2D constant | 2.5D constant |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 几何类型 | 2D常量 | 2.5D常量 |'
- en: '| --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Point | wkbPoint | wkbPoint25D |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| Point | wkbPoint | wkbPoint25D |'
- en: '| Multipoint | wkbMultiPoint | wkbMultiPoint25D |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| Multipoint | wkbMultiPoint | wkbMultiPoint25D |'
- en: '| Line | wkbLineString | wkbLineString25D |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| Line | wkbLineString | wkbLineString25D |'
- en: '| Multiline | wkbMultiLineString | wkbMultiLineString25D |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| Multiline | wkbMultiLineString | wkbMultiLineString25D |'
- en: '| Polygon ring | wkbLinearRing | n/a |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| Polygon ring | wkbLinearRing | n/a |'
- en: '| Polygon | wkbPolygon | wkbPolygon25D |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| Polygon | wkbPolygon | wkbPolygon25D |'
- en: '| Multipolygon | wkbMultiPolygon | wkbMultiPolygon25D |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| Multipolygon | wkbMultiPolygon | wkbMultiPolygon25D |'
- en: '| Geometry collection | wkbGeometryCollection | wkbGeometryCollection25D |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| Geometry collection | wkbGeometryCollection | wkbGeometryCollection25D |'
- en: Once you have the geometry, you can start adding vertices. Points only have
    one vertex, which you add with the `AddPoint` function. This function wants x,
    y, and an optional z.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了几何形状，你就可以开始添加顶点。点只有一个顶点，你可以使用`AddPoint`函数添加。这个函数需要x、y和一个可选的z。
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That’s it! You now have a fully functional point object with a northing of
    11.5 and an easting of 59.5\. The coordinates can be retrieved if needed using
    `GetX`, `GetY`, and `GetZ`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你现在有一个完全功能化的点对象，其南北向为11.5，东西向为59.5。如果需要，可以使用`GetX`、`GetY`和`GetZ`检索坐标：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remember that in Python you can set multiple variables at once, so `x` is assigned
    the results of `GetX` and `y` gets the results of `GetY`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 Python 中你可以一次设置多个变量，所以 `x` 被分配了 `GetX` 的结果，而 `y` 获得了 `GetY` 的结果。
- en: You can also print geometry objects in WKT format if you want to verify that
    things look okay, although this can get ugly pretty fast with geometry types other
    than points.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要验证一切看起来是否正常，可以将几何对象打印为 WKT 格式，尽管对于除点以外的几何类型，这可能会很快变得很丑陋。
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that the WKT shows a z value of `0`, but you created a 2D point. That’s
    not going to hurt anything, so there’s no reason to worry about it. You could
    even set a z value yourself, although it would be ignored when it came time to
    write the geometry out to a file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，WKT 显示 z 值为 `0`，但你创建了一个 2D 点。这不会造成任何伤害，所以没有必要担心。你甚至可以自己设置 z 值，尽管在将几何体写入文件时它会被忽略。
- en: 'Unless you want to see the coordinate values, an easier way to visualize your
    geometries as you create them is to use the `VectorPlotter` class that we introduced
    in [chapter 3](kindle_split_011.html#ch03), although this is boring with a single
    point:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你想看到坐标值，否则在创建几何体时可视化你的几何体的一种更简单的方法是使用我们在第 3 章[中介绍的 `VectorPlotter` 类]，尽管对于单个点来说这很无聊：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What if you realize later that your GPS was slightly off and the y coordinate
    is 13 instead of 11.5? The easiest way to solve the problem is to call `AddPoint`
    again, but with the correct coordinates. You can verify the results by plotting
    the new geometry with a different marker ([figure 6.3](#ch06fig03)) or by printing
    the WKT:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你后来意识到你的 GPS 略有偏差，y 坐标是 13 而不是 11.5 会怎么办？解决这个问题的最简单方法是再次调用 `AddPoint`，但使用正确的坐标。你可以通过使用不同的标记绘制新的几何体（[图
    6.3](#ch06fig03)）或通过打印 WKT 来验证结果：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Figure 6.3\. The original and edited fire pit geometries. The edited one has
    the square marker.
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.3\. 原始和编辑后的火坑几何体。编辑后的有一个正方形标记。
- en: '![](06fig03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig03.jpg)'
- en: Why doesn’t this add a second set of coordinates to the geometry, as the name
    `AddPoint` implies? Points are a special case because they’re only allowed one
    set of coordinates, so any existing ones are overwritten. You’ll see later that
    `AddPoint` has different behavior when applied to other geometry types.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个操作没有像 `AddPoint` 名称暗示的那样向几何体添加第二组坐标？点是一个特殊情况，因为它们只允许一组坐标，所以任何现有的坐标都会被覆盖。你将在后面看到
    `AddPoint` 在应用于其他几何类型时具有不同的行为。
- en: 'If you like to make life a little more complicated, or want to be more consistent
    with how vertices are edited with other geometry types, you can use `SetPoint(point,
    x, y, [z])` instead, where `point` is the index of the vertex to edit. Because
    point geometries contain only one vertex, this parameter is always zero when dealing
    with points:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢让生活变得稍微复杂一些，或者想要与其他几何类型编辑顶点时保持一致性，你可以使用 `SetPoint(point, x, y, [z])` 代替，其中
    `point` 是要编辑的顶点的索引。因为点几何体只包含一个顶点，所以在处理点时此参数始终为零：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To create a 2.5D point, specify the 2.5D type when you create it and then provide
    a z coordinate along with the x and y:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 2.5D 点，在创建时指定 2.5D 类型，然后提供与 x 和 y 一起的 z 坐标：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Other than the addition of a third coordinate value, working with 2.5D points
    is the same as working with 2D points.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加一个第三维坐标值之外，使用 2.5D 点与使用 2D 点的工作方式相同。
- en: '6.2.2\. Creating and editing multipoints: multiple points as one geometry'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2\. 创建和编辑多点：将多个点作为一个几何体
- en: Multipoint geometries contain one or more points in a single object. This means
    that multiple points can be attached to a single feature rather than requiring
    a separate feature per point. For example, a dataset with multiple points might
    be the locations of all fire hydrants within city boundaries, where each hydrant
    is treated as a unique feature. Perhaps you also want to map outdoor water faucets
    in private yards. In this case, you might treat all spigots in an individual yard
    as one multipoint item so that you have only one feature per yard. In fact, that’s
    what you’ll do with the yard example. Three faucets are shown as circles in [figure
    6.4](#ch06fig04), and you’ll build one multipoint object with three vertices to
    represent them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 多点几何体包含一个或多个点在一个单独的对象中。这意味着多个点可以附加到单个要素上，而不是每个点都需要一个单独的要素。例如，包含多个点的数据集可能是城市边界内所有消防栓的位置，其中每个消防栓被视为一个独特的要素。也许你还想在私人院子里绘制户外水龙头。在这种情况下，你可能会将单个院子里所有的水龙头视为一个多点项，这样你就有了一个院子一个要素。实际上，你将使用院子示例。图
    6.4[中]显示了三个水龙头，你将使用三个顶点构建一个多点对象来表示它们。
- en: Figure 6.4\. You can use a multipoint geometry to hold the water spigot geometries,
    shown here as dots.
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4。你可以使用多点几何图形来保存水龙头几何图形，这里显示为点。
- en: '![](06fig04.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片06fig04](06fig04.jpg)'
- en: 'To create a multipoint geometry, you need to create at least two geometries.
    You need at least one point object and also a multipoint object to hold the points.
    Referring back to [table 6.1](#ch06table01), you can see that the correct OGR
    constant for a multipoint object is `wkbMultiPoint`. You create the points exactly
    as before and then add them to your multipoint geometry. Here’s one way to do
    this, using coordinates obtained from [figure 6.4](#ch06fig04):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个多点几何图形，你需要创建至少两个几何图形。你需要至少一个点对象，以及一个多点对象来保存这些点。参考[表6.1](#ch06table01)，你可以看到多点对象的正确OGR常量是`wkbMultiPoint`。你将点创建得与之前完全一样，然后将它们添加到你的多点几何图形中。这里有一种方法，使用从[图6.4](#ch06fig04)获得的坐标来完成此操作：
- en: '![](111fig01_alt.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片111fig01_alt](111fig01_alt.jpg)'
- en: Notice that it’s fine to reuse the same point geometry each time. A copy of
    the point object is added to the multipoint when `AddGeometry` is invoked, so
    the original point can be edited later without affecting the coordinates that
    have already been added to the multipoint. You could, of course, create a new
    point object for each vertex, but reusing the geometry saves a little overhead.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次重用相同的点几何图形是可以的。当调用`AddGeometry`时，会向多点添加点对象的副本，因此可以在不影响已经添加到多点中的坐标的情况下稍后编辑原始点。当然，你可以为每个顶点创建一个新的点对象，但重用几何图形可以节省一点开销。
- en: 'Once again, you can plot the geometry and print the WKT to see what it looks
    like:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你可以绘制几何图形并打印WKT来查看其外观：
- en: '![](111fig02_alt.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片111fig02_alt](111fig02_alt.jpg)'
- en: With a multipoint object, the WKT string separates each coordinate in the set
    with a comma. As with a regular point object, the x, y, and z coordinates for
    a single point are separated by spaces. Notice also that the vertices are listed
    in the same order you added them. That’s extremely important if you need to access
    one later—you can always be sure of which point you’re getting because their order
    doesn’t change.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多点对象，WKT字符串使用逗号分隔集合中的每个坐标。与常规点对象一样，单个点的x、y和z坐标由空格分隔。注意，顶点的列表顺序与添加它们的顺序相同。如果你需要稍后访问它们，这一点非常重要——你可以始终确信你得到的是哪个点，因为它们的顺序不会改变。
- en: 'You can get a specific point from a multipoint geometry by passing the index
    of the desired point to `GetGeometryRef`. The first point added has index 0, the
    second has index 1, and so on. Once you have an individual point, you can edit
    it the same way as a single point. Because `GetGeometryRef` returns a reference
    to the point inside the multipoint instead of a copy, the multipoint is automatically
    updated when the point is changed. For example, this would get the second faucet
    and then edit its coordinates:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过传递所需点的索引到`GetGeometryRef`来从多点几何图形中获取一个特定点。第一个添加的点索引为0，第二个为索引1，依此类推。一旦你有一个单独的点，你可以像编辑单个点一样编辑它。因为`GetGeometryRef`返回的是多点内部点的引用而不是副本，所以当点被更改时，多点会自动更新。例如，这将获取第二个水龙头并编辑其坐标：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can also find out how many points are in a multipoint object, which is useful
    if you need to loop through them all. For example, to move all spigots two meters
    to the east, you’d need to loop through the points and add 2 to each x coordinate
    while leaving the y coordinates unchanged. The results are shown in [figure 6.5](#ch06fig05).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以找出一个多点对象中有多少个点，这在你需要遍历所有点时很有用。例如，要将所有水龙头向东移动两米，你需要遍历这些点，并将每个x坐标加2，同时保持y坐标不变。结果在[图6.5](#ch06fig05)中显示。
- en: Figure 6.5\. The original and edited water spigot multipoint geometries. The
    edited geometry uses square markers.
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5。原始和编辑后的水龙头多点几何图形。编辑后的几何图形使用正方形标记。
- en: '![](06fig05.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片06fig05](06fig05.jpg)'
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you’ll see in the rest of this chapter, working with other geometry types
    directly builds on these concepts that you’ve learned for points.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章的其余部分将看到的，直接使用其他几何类型是在你已经学过的点概念的基础上构建的。
- en: 6.3\. Working with lines
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3。处理线
- en: As mentioned earlier, lines are a sequence of vertices, or points, connected
    by straight line segments. [Figure 6.6](#ch06fig06) shows a line with its vertices,
    although normally you don’t see markers for the vertices when a line is drawn.
    A line can’t change direction, no matter how slightly, without a vertex to end
    one segment and start another. Therefore, a line that looks like a smooth curve
    is a large number of short straight segments, all joined together by vertices.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，线是一系列顶点，或点，通过直线段连接。[图6.6](#ch06fig06)显示了一条线和其顶点，尽管通常在绘制线时看不到顶点的标记。线不能改变方向，无论多小，除非有一个顶点来结束一个段并开始另一个。因此，看起来像平滑曲线的线实际上是由许多短直线段组成，所有这些段都通过顶点连接在一起。
- en: Figure 6.6\. A line and the vertices connecting each segment
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.6\. 一条线和连接每个线段的顶点
- en: '![](06fig06.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig06.jpg)'
- en: Adding more vertices, and therefore a larger number of shorter segments, gives
    you more control over the shape of the line. Think about how you’d draw the coastline
    of Great Britain using a series of straight lines. As you can see from [figure
    6.7](#ch06fig07), accuracy is greatly improved by using shorter lines. The same
    concept applies to any line geometry. The more detail required, the more vertices
    you need to add. Keep in mind that the more vertices you have, the more complicated
    the geometry object is and the more time it takes to process, so don’t add unnecessary
    vertices. In fact, you might want to simplify geometries so that they use fewer
    vertices if you’re going to serve data over the web. See the `Simplify` function
    in appendix C if you need to do this. (Appendixes C through E are available online
    on the Manning Publications website at [https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python).)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更多的顶点，因此更多的更短的线段，可以让你更好地控制线的形状。想想你是如何用一系列直线来绘制大不列颠的海岸线的。正如你从[图6.7](#ch06fig07)中可以看到的，使用更短的线可以大大提高精度。这个概念适用于任何线几何。需要更多的细节，就需要添加更多的顶点。记住，你拥有的顶点越多，几何对象就越复杂，处理所需的时间就越长，所以不要添加不必要的顶点。实际上，如果你打算在网络上提供数据，你可能想要简化几何形状，以便它们使用更少的顶点。如果你需要这样做，请参阅附录C中的`Simplify`函数。（附录C至E可在Manning
    Publications网站上在线获取，网址为[https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python)。）
- en: Figure 6.7\. The solid line follows the coast of Great Britain more closely
    because it has more vertices, and therefore more and shorter line segments, than
    the dotted line. More detail for lines and polygons can be achieved by using more
    vertices.
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.7\. 实线更紧密地遵循大不列颠的海岸线，因为它比虚线有更多的顶点，因此有更多的更短的线段。通过使用更多的顶点可以获得线和多边形的更多细节。
- en: '![](06fig07.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig07.jpg)'
- en: Lines can be used to represent linear features such as roads, streams, or pipelines.
    A line is a good choice if you want to show one coastline of an island, such as
    the example in [figure 6.7](#ch06fig07), but a polygon is a better choice if you
    want to represent the entire island. You’ll use a simple line object to model
    the sidewalk bordering the make-believe yard and the oddly shaped parking strip
    ([figure 6.8](#ch06fig08)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 线可以用来表示线性特征，如道路、溪流或管道。如果你想显示一个岛屿的海岸线，例如[图6.7](#ch06fig07)中的示例，那么线是一个不错的选择，但如果你想表示整个岛屿，多边形是一个更好的选择。你将使用一个简单的线对象来模拟围绕虚构庭院和形状奇特的停车带的边界（[图6.8](#ch06fig08)）。
- en: Figure 6.8\. You can use a line to hold the sidewalk geometry, shown here as
    the thick green line.
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.8\. 你可以使用线来保持人行道几何形状，这里显示为粗绿色的线。
- en: '![](06fig08.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig08.jpg)'
- en: The line you’ll build for the sidewalk contains a small number of vertices,
    but the technique for working with longer and more-complex lines is exactly the
    same.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要为人行道构建的线包含少量顶点，但处理更长和更复杂的线的技巧是完全相同的。
- en: 6.3.1\. Creating and editing single lines
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1\. 创建和编辑单一线
- en: 'As with points, the first step to creating a line geometry is to create an
    empty `Geometry` object and then add the vertices. Although the direction you
    traverse the line when adding coordinates isn’t important, the vertices must be
    added in order. Try creating the line representing the sidewalk shown in [figure
    6.8](#ch06fig08), going from west to east:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与点一样，创建线几何的第一步是创建一个空的`Geometry`对象，然后添加顶点。虽然添加坐标时你遍历线的方向并不重要，但顶点必须按顺序添加。尝试创建[图6.8](#ch06fig08)中显示的人行道线，从西向东：
- en: '![](114fig01_alt.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](114fig01_alt.jpg)'
- en: Remember how `AddPoint` overwrote existing coordinates in point objects? That
    doesn’t happen here because lines consist of many vertices instead of only one,
    so a new vertex is added to the end of the line instead of overwriting the only
    allowed point.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 记得 `AddPoint` 是如何覆盖点对象中现有坐标的吗？这里不会发生这种情况，因为线由许多顶点组成，而不是只有一个，所以会在线的末尾添加一个新的顶点而不是覆盖唯一允许的点。
- en: 'Again, you can verify that things are working as expected by plotting the geometry
    or printing the WKT:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你可以通过绘制几何体或打印 WKT 来验证一切是否按预期工作：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As before, the coordinates for a vertex are separated by spaces, and individual
    vertices are separated by commas. Because you know that the vertices are always
    in the same order that they were added to the line, you could use `SetPoint` to
    change the x coordinate for the last vertex (the one with index 3) in the sidewalk:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，顶点的坐标由空格分隔，单个顶点由逗号分隔。因为你知道顶点总是按照它们被添加到线上的顺序排列，所以你可以使用 `SetPoint` 来更改人行道中最后一个顶点（索引为
    3 的顶点）的 x 坐标：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can find out how many vertices a line contains and then loop through all
    of them if necessary. For example, if you suddenly realize that the sidewalk is
    one meter too far south, you can nudge it north by looping through all of the
    vertices and adding one to each y coordinate ([figure 6.9](#ch06fig09)):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找出一条线包含多少个顶点，并在必要时遍历所有顶点。例如，如果你突然意识到人行道向南多了一米，你可以通过遍历所有顶点并将每个 y 坐标加一来将其向北微调（[图
    6.9](#ch06fig09)）：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Figure 6.9\. The original and edited sidewalk line geometries. The edited one
    is shown with the dotted line.
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.9\. 原始和编辑过的人行道线几何体。编辑过的是用虚线表示的。
- en: '![](06fig09.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig09.jpg)'
- en: Notice that you use `GetX` and `GetY` again, but now you need to provide the
    index of the vertex you want. You also might wonder why you use `GetPointCount`
    instead of `GetGeometryCount` as you did for multipoints, and that’s a good question.
    The reason is because `GetGeometryCount` tells you how many individual geometry
    objects are combined to make up one multigeometry, and it returns zero if the
    object isn’t a multigeometry. The `GetPointCount` function, on the other hand,
    returns the number of vertices in a geometry, and it returns zero for multigeometries
    because they’re made of other geometries instead of vertices.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你再次使用了 `GetX` 和 `GetY`，但现在你需要提供你想要的顶点的索引。你也可能想知道为什么你使用 `GetPointCount` 而不是像处理多点时那样使用
    `GetGeometryCount`，这是一个很好的问题。原因是 `GetGeometryCount` 告诉你有多少个单独的几何体对象组合成一个多几何体，如果对象不是多几何体，则返回零。另一方面，`GetPointCount`
    函数返回几何体中的顶点数量，对于多几何体返回零，因为它们由其他几何体而不是顶点组成。
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use `GetGeometryCount` to determine the number of geometries contained in a
    collection of geometries (such as a multigeometry or a polygon), and use `GetPointCount`
    to determine the number of vertices in a single geometry. The `GetGeometryCount`
    function will always return zero for a single geometry, and `GetPointCount` will
    always return zero for a collection of geometries.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `GetGeometryCount` 来确定一个几何体集合（例如多几何体或多边形）中包含的几何体数量，并使用 `GetPointCount` 来确定单个几何体中的顶点数量。`GetGeometryCount`
    函数对于单个几何体始终返回零，而 `GetPointCount` 对于几何体集合始终返回零。
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'What if you later realize that the shape of the sidewalk is all wrong because
    it’s missing a vertex? If you still have the coordinates for each vertex, then
    the easiest thing is probably to create a new sidewalk geometry using all of the
    vertices. But if your landscaper only gave you the coordinates of the missing
    vertex and told you that it needed to be inserted between the second and third
    vertices, as shown in [figure 6.10](#ch06fig10), you’d need to insert it in your
    line. You can solve this problem multiple ways, but I think the easiest is to
    get a list of all the vertices, insert a new set of coordinates into the list,
    and then use the list to create a new geometry. You can use `GetPoints` to get
    the list of vertices in a line, where each vertex is in the form of a tuple with
    x, y, and z coordinates. Here’s what that list looks like for the original sidewalk:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你后来意识到人行道的形状完全错误，因为它缺少一个顶点怎么办？如果你仍然有每个顶点的坐标，那么最简单的方法可能是使用所有顶点创建一个新的人行道几何形状。但是，如果你的景观设计师只给了你缺失顶点的坐标，并告诉你它需要插入到第二个和第三个顶点之间，如图[图6.10](#ch06fig10)所示，你需要在你的线中插入它。你可以通过多种方式解决这个问题，但我认为最简单的方法是获取所有顶点的列表，将一组新的坐标插入到列表中，然后使用该列表创建一个新的几何形状。你可以使用`GetPoints`获取线中的顶点列表，其中每个顶点都是以包含x、y和z坐标的元组形式存在。以下是原始人行道的该列表的示例：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Figure 6.10\. The dotted line shows changes to make to the sidewalk by inserting
    a new vertex between the existing second and third vertices.
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.10. 虚线显示了通过在现有的第二个和第三个顶点之间插入新的顶点来对人行道进行的修改。
- en: '![](06fig10.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig10.jpg)'
- en: 'A handy feature of lists is that you can easily insert items into the *i*th
    position using the `list[i:i]` syntax. The following example gets the list of
    sidewalk vertices and then inserts a tuple containing new x and y coordinates
    in between the second and third vertices:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的一个方便的特性是，你可以使用`list[i:i]`语法轻松地在第*i*个位置插入项目。以下示例获取人行道顶点的列表，然后在第二个和第三个顶点之间插入包含新x和y坐标的元组：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see that the original vertices are still there, but the new vertex has
    been inserted at index 2\. This vertex doesn’t have a z coordinate because one
    wasn’t provided in the inserted tuple. The fact that the original coordinates
    do have z values is unimportant, because this is a 2D geometry and they should
    all be zero anyway.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到原始顶点仍然存在，但新的顶点已经插入到索引2的位置。因为这个顶点没有z坐标，因为在插入的元组中没有提供。原始坐标确实有z值并不重要，因为这是一个二维几何形状，它们都应该为零。
- en: 'Now you have a list of tuples, but how do you turn it into a line geometry,
    like that in [figure 6.11](#ch06fig11)? The easiest way is to take advantage of
    the Python `*` operator to expand the tuples to individual parameters and pass
    them in turn to `AddPoint`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个元组列表，但如何将其转换为线几何形状，就像[图6.11](#ch06fig11)中那样？最简单的方法是利用Python的`*`运算符将元组展开成单独的参数，并依次传递给`AddPoint`：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Figure 6.11\. The original sidewalk line geometry and one with another vertex
    inserted in the middle
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.11. 原始的人行道线几何形状以及中间插入另一个顶点的情况
- en: '![](06fig11.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig11.jpg)'
- en: '|  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The Python `*` operator**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python的`*`运算符**'
- en: 'The `*` operator unpacks the contents of a tuple or list into separate items
    so they can be passed as parameters to a function. Take this example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`运算符将元组或列表的内容解包成单独的项，以便可以将它们作为参数传递给函数。以下是一个例子：'
- en: '![](116fig01_alt.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](116fig01_alt.jpg)'
- en: Using the `*` operator explodes `vertex` into two parameters that are successfully
    passed to `AddPoint`. Forgetting the `*` operator only passes one parameter, a
    tuple. But `AddPoint` expects at least two parameters, an x and a y, so it fails.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`*`运算符将`vertex`解包成两个参数，这些参数成功传递给了`AddPoint`。忘记使用`*`运算符只会传递一个参数，即一个元组。但是`AddPoint`至少需要两个参数，一个x和一个y，所以它失败了。
- en: '|  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'This is easy to expand to a larger number of edits if needed. For example,
    what if you want to add new points after the existing 5th, 11th, 19th, and 26th
    vertices, as shown by the dotted line in [figure 6.12](#ch06fig12)? As you look
    at the following code, see if you can figure out why you’d want to add the vertices
    at the end of the line first:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，这很容易扩展到更多的编辑。例如，如果你想在现有的第5个、第11个、第19个和第26个顶点之后添加新的点，如图[图6.12](#ch06fig12)中的虚线所示？当你查看以下代码时，看看你是否能弄清楚为什么你想要先在线的末尾添加顶点：
- en: '![](117fig01_alt.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](117fig01_alt.jpg)'
- en: Figure 6.12\. The results of inserting multiple vertices into a line geometry.
    The original is shown with a solid line, and the edited is drawn as a dotted line.
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.12. 将多个顶点插入到线几何体中的结果。原始图以实线显示，编辑后的图以虚线绘制。
- en: '![](06fig12.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig12.jpg)'
- en: Once you insert an item into a list, then the indices of the later items are
    changed. If you insert the points after the 5th vertex first, then the original
    11th vertex will now have an index of 13, because two points were added earlier
    in the list. You’ll have to keep track of how many items you inserted so that
    you can get the later indices right. That’s certainly doable, but why bother if
    you can avoid the problem altogether by working backward?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将项目插入到列表中，则后续项目的索引就会改变。如果您首先在第五个顶点之后插入点，则原始的第十一个顶点现在将具有13的索引，因为列表中之前已经添加了两个点。您必须跟踪您插入了多少个项目，以便正确获取后续索引。这当然是可以做到的，但为什么还要麻烦，如果您可以通过反向工作来避免整个问题呢？
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you need to insert or delete multiple items in a list (whether the list contains
    vertices or something else), you’ll find that life is easier if you start from
    the end and work backward so you don’t inadvertently change indexes that you still
    need to use.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在列表中插入或删除多个项目（无论列表中包含顶点还是其他内容），您会发现如果从末尾开始并反向工作，生活会更轻松，这样您就不会无意中更改您仍然需要使用的索引。
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'If you don’t want to create a new line geometry, you can modify the original
    instead. This adds one vertex to the `sidewalk` line without creating a copy:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想创建新的线几何体，您可以修改原始的线。这向`sidewalk`线添加了一个顶点，而不创建副本：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But this uses `SetPoint` to edit five vertices when the original `sidewalk`
    only has four. How can you possibly change a vertex that doesn’t exist? It turns
    out that `SetPoint` will add a vertex at the requested index, along with any missing
    vertices in between. For example, if the line has ten vertices (so the highest
    index is 9) and you use `SetPoint` to create a vertex with index 15, it will also
    create vertices with indices 10 through 14\. Be careful, though, because any vertices
    it adds as fillers are initialized to (0, 0), which is probably not what you want.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但这使用`SetPoint`编辑了五个顶点，而原始的`sidewalk`只有四个。您怎么可能改变一个不存在的顶点呢？结果证明，`SetPoint`会在请求的索引处添加一个顶点，以及任何缺失的顶点。例如，如果线有十个顶点（因此最高索引是9），您使用`SetPoint`创建一个索引为15的顶点，它还会创建索引为10到14的顶点。但请注意，它添加的任何填充顶点都初始化为(0,
    0)，这可能不是您想要的。
- en: Creating points from lines
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从线创建点
- en: Sometimes you need to get the vertices of a line as individual points. By this
    time, you know how to create points and also how to manipulate individual line
    vertices, so turning the vertices into points shouldn’t be too difficult. All
    you need to do is loop through the line vertices, get the coordinates, and create
    a point using those coordinates. The following listing shows a function that does
    this.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要将线的顶点作为单独的点获取。到这时，您已经知道如何创建点以及如何操作单个线顶点，因此将顶点转换为点不应该太难。您需要做的就是遍历线顶点，获取坐标，并使用这些坐标创建一个点。以下列表显示了一个执行此操作的函数。
- en: Listing 6.1\. Function to create a point layer from a line layer
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1. 从线层创建点层的函数
- en: '![](118fig01_alt.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](118fig01_alt.jpg)'
- en: This function takes a data source, the name of an existing line layer, and the
    name of a new point layer. It creates the point layer and copies all of the attribute
    fields from the line to the point layer. Then it loops through all of the line
    features and creates a point feature for each vertex, which also contains the
    same attribute values as the line it came from.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受数据源、现有线层的名称以及新点层的名称。它创建点层并将所有属性字段从线复制到点层。然后它遍历所有线要素并为每个顶点创建一个点要素，该点要素还包含来自其来源线的相同属性值。
- en: '6.3.2\. Creating and editing multilines: multiple lines as one geometry'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2. 创建和编辑多线：将多条线作为单一几何体
- en: As with multipoints, multiline objects contain one or more lines that are treated
    as if they were one. The collection of channels in a braided river is a good candidate
    for this geometry type. As shown in [figure 6.13](#ch06fig13), you can also treat
    the stone pathways running through the yard as a multiline object.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与多点类似，多行对象包含一条或多条被视为单一对象的线。编织河流中的渠道集合是这种几何类型的良好候选。如图6.13[图](#ch06fig13)所示，您还可以将穿过庭院的石路视为多行对象。
- en: Figure 6.13\. You can use a multiline to hold the garden path geometries, shown
    here as dotted lines.
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.13。你可以使用多线来保存花园路径几何形状，这里以虚线表示。
- en: '![](06fig13.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig13.jpg)'
- en: 'As with any multigeometry, you need to create each component separately and
    then add it to the main geometry, so you need at least one regular line object
    along with your multiline. The following code shows how to create the multiple
    paths from [figure 6.13](#ch06fig13):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何多几何形状一样，你需要单独创建每个组件，然后将其添加到主几何形状中，因此你至少需要一个常规线对象以及你的多线。以下代码显示了如何从[图6.13](#ch06fig13)创建多个路径：
- en: '![](119fig01_alt.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](119fig01_alt.jpg)'
- en: This is similar to creating a multipoint. The first thing you do is create the
    three separate line geometries that make up the pathways. After creating those,
    you create a multiline geometry and add the paths in order. It doesn’t matter
    if you wait until all of the individual lines are created and then create the
    multiline, or if you create the multiline up front and add the individual lines
    as you go along. You can even reuse one line object for each path, but you’d need
    to add the path to the multiline immediately after adding its vertices, and call
    `Empty` on the path geometry to clear out the old vertices before starting on
    the next pathway.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这与创建多点类似。你首先需要创建构成路径的三条独立的线几何形状。创建这些之后，你创建一个多线几何形状，并按顺序添加路径。无论你是等到所有单独的线都创建完毕然后再创建多线，还是一开始就创建多线并在进行中添加单独的线，都可以。你甚至可以重复使用每个路径的一个线对象，但你需要在其顶点添加后立即将路径添加到多线中，并在开始下一个路径之前对路径几何形状调用`Empty`以清除旧顶点。
- en: 'Let’s take a look at the guts of your new multiline:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看你新多线的内部结构：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each inner line is inside its own set of parentheses, and they’re listed in
    the same order as they were added to the multiline. Again, it’s important that
    OGR preserves this order so that you always know which line is which.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个内部线都在它自己的括号内，并且它们的顺序与它们添加到多线中的顺序相同。同样，OGR保留这个顺序非常重要，这样你总是知道哪条线是哪条。
- en: 'To edit a vertex once it’s been added to the multiline, you first need to grab
    the single line that you want to edit, the same way you did with multipoints.
    Once you have that, you can edit the vertices the same way you would a regular
    line. To edit the second vertex in the first path added to the multiline, you
    can do something like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑已添加到多线的顶点，你首先需要获取你想要编辑的单条线，就像你处理多点时做的那样。一旦你有了它，你可以像编辑常规线一样编辑顶点。要编辑添加到多线中的第一条路径的第二个顶点，你可以这样做：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can use the concepts you’ve already learned about getting inner geometries
    and editing lines to move the whole multiline two units to the east and three
    to the south, with the results shown in [figure 6.14](#ch06fig14):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用你已经学到的关于获取内部几何形状和编辑线的概念，将整个多线向东移动两个单位，向南移动三个单位，结果如[图6.14](#ch06fig14)所示：
- en: '![](120fig01_alt.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](120fig01_alt.jpg)'
- en: Figure 6.14\. The original and edited pathway multiline geometries. The edited
    one is drawn as a dotted line.
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.14。原始和编辑后的路径多线几何形状。编辑后的一个是用虚线绘制的。
- en: '![](06fig14.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig14.jpg)'
- en: Hopefully you feel comfortable constructing and editing lines by this point,
    and you’ll see in the next section that working with polygons is only slightly
    more complicated.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到这一点你感觉舒适地构建和编辑线，你将在下一节中看到，使用多边形的工作方式仅稍微复杂一些。
- en: 6.4\. Working with polygons
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4. 使用多边形
- en: Polygons are used to represent things that have area, unlike a point or line.
    City boundaries and lakes are two examples of data that could be modeled as polygons.
    Instead of a polygon being made up of a list of vertices, like a line, they’re
    made of rings. This is because polygons can have holes in them, like a donut,
    and a separate ring is required for the outer polygon and for each of the holes.
    A simple polygon with no holes in it is still made up of one ring. Like lines,
    rings are made up of a series of vertices connected by straight line segments,
    but the first and last vertices are the same so that they form a closed ring.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形用于表示具有面积的事物，与点或线不同。城市边界和湖泊是两种可以建模为多边形的数据示例。与线一样，多边形不是由顶点列表组成，而是由环组成。这是因为多边形可以有洞，就像甜甜圈一样，需要单独的环来表示外部多边形和每个洞。一个没有洞的简单多边形仍然由一个环组成。与线一样，环由一系列通过直线段连接的顶点组成，但第一个和最后一个顶点是相同的，这样它们就形成了一个封闭的环。
- en: Like lines, ring vertices need to be added in order, but you have other considerations
    as well. The line segments making up a polygon’s perimeter shouldn’t touch or
    cross, as shown in [figure 6.15](#ch06fig15). OGR will allow you to create a polygon
    like this, but calculations on it are apt to be wrong, even if they run without
    errors. You can check for problems like this by calling `IsValid` on a geometry,
    which you should make a habit of if you’re building your own geometries. Note
    that polygons that don’t have a width—so they look like a line—are also invalid.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与线一样，环顶点需要按顺序添加，但你还有其他考虑因素。组成多边形周界的线段不应接触或交叉，如图6.15所示。OGR将允许你创建这样的多边形，但对其进行的计算可能会出错，即使它们没有错误地运行。你可以通过在几何形状上调用`IsValid`来检查这类问题，如果你正在构建自己的几何形状，你应该养成这种习惯。请注意，没有宽度——看起来像线——的多边形也是无效的。
- en: Figure 6.15\. The polygon on the left is valid, but the other two are not because
    the line segments intersect and split the polygon.
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.15。左边的多边形是有效的，但其他两个不是，因为线段相交并分割了多边形。
- en: '![](06fig15.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig15.jpg)'
- en: Returning to the yard example, let’s start by creating a polygon for the entire
    yard boundary ([figure 6.16](#ch06fig16)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 回到院落示例，让我们首先创建整个院落边界的多边形([图6.16](#ch06fig16))。
- en: Figure 6.16\. You can use a polygon to hold the yard boundary, shown here as
    the thick solid line.
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.16。你可以使用多边形来保存院落边界，这里显示为粗实线。
- en: '![](06fig16.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig16.jpg)'
- en: Once again, you’ll work with simple polygons in the examples, but your new knowledge
    can be easily applied to more-complex geometries.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你将在示例中使用简单的多边形，但你可以轻松地将你的新知识应用到更复杂的几何形状中。
- en: 6.4.1\. Creating and editing single polygons
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.1. 创建和编辑单个多边形
- en: A polygon is like a multigeometry in the sense that it consists of a set of
    geometries. All polygons are made of rings, which in turn are made of vertices.
    A simple polygon only has one ring, but you still need to create a ring object
    and then add it to the polygon. As with lines, use `AddPoint` to add a vertex
    to a ring. Vertices need to be added in order, but the direction around the perimeter
    can vary depending on the format you want to use to store the data. For example,
    shapefiles specify that the outer rings are in clockwise order, but GeoJSON doesn’t
    specify an order. Because of details like this, it’s probably a good idea to read
    up about the format you intend to use. But no matter the direction, the first
    and last vertices must have the same coordinates so they close the ring. To do
    this, you can either make sure the last vertex added has identical coordinates
    to the first one, or you can call `CloseRings` on the ring or polygon after adding
    all vertices. The latter method is the one used here to create the yard outline
    shown in [figure 6.16](#ch06fig16). The example starts with the upper left vertex
    and traverses the perimeter in counter-clockwise direction.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形就像是由一组几何形状组成的多几何形状。所有的多边形都是由环组成的，而环又是由顶点组成的。一个简单的多边形只有一个环，但你仍然需要创建一个环对象并将其添加到多边形中。与线一样，使用`AddPoint`向环中添加顶点。顶点需要按顺序添加，但围绕周界的方向可以根据你想要使用的存储数据格式而变化。例如，shapefiles指定外环是顺时针顺序，但GeoJSON没有指定顺序。由于这样的细节，了解你打算使用的格式可能是个好主意。但无论方向如何，第一个和最后一个顶点必须具有相同的坐标，以便它们闭合环。为此，你可以确保最后一个添加的顶点与第一个具有相同的坐标，或者你可以在添加所有顶点后对环或多边形调用`CloseRings`。后一种方法就是在这里创建[图6.16](#ch06fig16)中显示的院落轮廓所使用的方法。示例从左上角的顶点开始，以逆时针方向遍历周界。
- en: '![](122fig01_alt.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](122fig01_alt.jpg)'
- en: 'You can make sure things look okay by plotting the geometry and printing the
    WKT:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过绘制几何形状并打印WKT来确保一切看起来正常：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The WKT contains all of the coordinates for the ring, but notice that the coordinate
    list is inside a second set of parentheses. This is because the vertices make
    up a ring inside the polygon. You’ll see later there can be more than one ring
    within a polygon, which is why the ring needs to be delineated with its own set
    of parentheses.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: WKT包含环的所有坐标，但请注意，坐标列表位于另一组括号内。这是因为顶点构成了多边形内的一个环。你将在后面看到，多边形内可以有多个环，这就是为什么环需要用自己的一组括号来界定。
- en: 'If you were to call `GetPointCount` on `yard`, the response would be zero because
    the vertices belong to the ring that’s inside the polygon. This is similar to
    how multigeometries won’t admit to having vertices, but they’ll confess to containing
    other geometries. The `yard` variable would claim to have one geometry if you
    queried it with `GetGeometryCount`, and that one geometry is the ring. Because
    of this, to edit a polygon’s vertices you need to get the ring first, and then
    edit the ring the same way you edit lines. This example grabs the ring and shifts
    it five map units to the west, which automatically moves the whole polygon, as
    seen in [figure 6.17](#ch06fig17):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用`GetPointCount`在`yard`上，响应将是零，因为顶点属于多边形内部的环。这与多几何形状不会承认有顶点，但会承认包含其他几何形状的方式相似。如果你用`GetGeometryCount`查询`yard`变量，它会声称有一个几何形状，而这个几何形状是一个环。因此，要编辑多边形的顶点，你需要首先获取环，然后以编辑线条相同的方式编辑环。这个例子获取环并将其向西移动五个地图单位，这会自动移动整个多边形，如[图6.17](#ch06fig17)所示：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Figure 6.17\. The original and edited yard polygon geometries. The original
    is drawn with a solid line.
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.17\. 原始和编辑后的庭院多边形几何形状。原始图是用实线绘制的。
- en: '![](06fig17.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig17.jpg)'
- en: 'You can insert vertices into polygon rings using the same method that you used
    for lines. For example, you can cut one of the sharp corners off of the yard by
    getting the ring and replacing the third vertex with two different vertices ([figure
    6.18](#ch06fig18)):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用与线条相同的方法向多边形环中插入顶点。例如，你可以通过获取环并将第三个顶点替换为两个不同的顶点来从庭院中裁剪掉一个尖锐的角([图6.18](#ch06fig18))：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Figure 6.18\. The original yard geometry and one with the third vertex replaced
    with two other vertices.
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.18\. 原始庭院几何形状和其中一个第三个顶点被两个其他顶点替换后的形状。
- en: '![](06fig18.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig18.jpg)'
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Creating a linestring with the same beginning and ending vertices won’t create
    a ring that can be used to build a polygon. Instead, it will be a line that happens
    to stop at the same place it started. It still won’t have an area, perimeter,
    or any other properties specific to polygons.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 创建具有相同起始和结束顶点的线字符串不会创建可以用来构建多边形的环。相反，它将是一条恰好停止在它开始的地方的线。它仍然没有面积、周长或任何特定于多边形的其他属性。
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Creating lines from polygons
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从多边形创建线条
- en: Sometimes you need to convert polygons to lines. To do this, you need to create
    a line from each ring inside the polygon. I’ve had luck copying the rings into
    line features, but the following listing shows how to do it by creating a line
    from a ring instead. Similarly to the `line_to_point_layer` function in [listing
    6.1](#ch06ex01), this function requires a data source, the name of the existing
    polygon layer, and the name for a new line layer. It creates a new line layer
    with the same attributes as the polygon layer, and then for each polygon feature,
    copies each ring to a line and inserts a new feature in the line layer.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要将多边形转换为线条。为此，你需要从多边形内部创建每条环的线条。我尝试将环复制到线要素中，但以下列表显示了如何通过从环创建线条来完成此操作。类似于[列表6.1](#ch06ex01)中的`line_to_point_layer`函数，此函数需要一个数据源、现有多边形层的名称以及新线层的名称。它创建一个具有与多边形层相同属性的新线层，然后对于每个多边形要素，将每个环复制到线条中，并在线层中插入一个新要素。
- en: Listing 6.2\. Function to create a line layer from a polygon layer
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.2\. 从多边形层创建线层的函数
- en: '![](124fig01_alt.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](124fig01_alt.jpg)'
- en: After creating a new layer to hold the lines, the function starts iterating
    through the polygons in the original layer, and creates a new line for each ring
    in the polygon. To do this, each time it finds a ring, it creates an empty line
    object and then iterates through the ring’s vertices. The coordinates for each
    ring vertex are used to create a new vertex in the line, so you get a line containing
    all of the same vertices as the ring. Lines, however, aren’t closed even if the
    first and last vertices are the same. If you plot the line, it will look like
    a polygon, but it doesn’t have the concept of an area or anything else specific
    to polygons.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个新的层来存储线条之后，函数开始遍历原始层中的多边形，并为多边形中的每个环创建一条新线。为此，每次它找到一个环时，它都会创建一个空的线对象，然后遍历环的顶点。每个环顶点的坐标用于在线条中创建一个新的顶点，因此你得到一个包含与环相同所有顶点的线条。然而，即使第一个和最后一个顶点相同，线条也不会闭合。如果你绘制这条线，它看起来像一个多边形，但它没有面积或任何特定于多边形的其他概念。
- en: '6.4.2\. Creating and editing multipolygons: multiple polygons as one geometry'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.2\. 创建和编辑多边形：将多个多边形作为一个几何形状
- en: If you’ve read this far, you can guess that a multipolygon is a geometry made
    of one or more individual polygons. A classic example of this is the Hawaiian
    Islands. This archipelago makes up the state of Hawaii and is usually represented
    as one geometry in datasets covering the United States, but it’s obviously made
    of several islands. The collection of islands makes up one state, the same way
    a collection of polygons makes up one multipolygon. An example is shown in [figure
    6.19](#ch06fig19).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读到这儿，你可以猜到多边形是由一个或多个单独的多边形组成的几何形状。一个典型的例子是夏威夷群岛。这个群岛组成了夏威夷州，通常在覆盖美国的数据集中表示为一个几何形状，但它显然由几个岛屿组成。岛屿的集合组成一个州，就像多边形的集合组成一个多边形一样。一个例子显示在[图6.19](#ch06fig19)中。
- en: Figure 6.19\. You can use a multipolygon to hold the garden boxes, shown here
    as the two rectangles.
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.19。你可以使用多边形来包含花园箱，这里以两个矩形显示。
- en: '![](06fig19.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![06fig19.jpg]'
- en: You can probably also figure out how to create a multipolygon, because you don’t
    need to know anything new. You create the individual polygons and add them to
    a multipolygon, and that’s all there is to it. For example, the following listing
    shows how you can treat the garden boxes in [figure 6.19](#ch06fig19) as a multipolygon
    made of two individual raised beds.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也能猜出如何创建多边形，因为你不需要了解任何新知识。你创建单独的多边形，并将它们添加到多边形中，这就是全部内容。例如，以下列表显示了如何将[图6.19](#ch06fig19)中的花园箱视为由两个单独的升高床组成的多边形。
- en: Listing 6.3\. Creating a multipolygon
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.3。创建多边形
- en: '![](125fig01_alt.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![125fig01_alt.jpg]'
- en: 'Let’s look at the WKT for this multipolygon:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个多边形的WKT：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here you have two polygons inside of a multipolygon, each inside its own set
    of parentheses, and each one of these contains one ring in another set of parentheses.
    Once again, everything is in the same order that you added it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你有两个多边形在多边形内部，每个都在它自己的括号内，而且每个都包含另一个括号中的一环。再次强调，一切都是按照你添加它们的顺序排列的。
- en: Editing a multipolygon is similar to what you’ve already seen, although it has
    one more step because you need to get each inner polygon and then get the ring
    from that before you can edit vertices. [Figure 6.20](#ch06fig20) shows the result
    of moving the garden boxes one map unit to the east and half a unit to the north.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑多边形与之前看到的方法类似，尽管它多了一步，因为在你能够编辑顶点之前，你需要获取每个内部多边形，然后从该多边形中获取环。[图6.20](#ch06fig20)显示了将花园箱向东移动一个地图单位，向北移动半个单位的结果。
- en: Figure 6.20\. The original and edited garden box multipolygon geometries. The
    edited one is drawn with a dashed line.
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.20。原始和编辑过的花园箱多边形几何形状。编辑过的用虚线绘制。
- en: '![](06fig20.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![06fig20.jpg]'
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now you know how to work with single and multi-geometries, but you still have
    the special case of polygons with holes. Keep reading to learn how these are different
    than multipolygons.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何处理单几何和多几何，但你仍然有特殊的多边形带洞的情况。继续阅读以了解这些与多边形的不同之处。
- en: '6.4.3\. Creating and editing polygons with holes: donuts'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.3。创建和编辑带洞的多边形：甜甜圈
- en: What about polygons with holes in them, like donuts? These are different than
    multipolygons, because the hole is the absence of a polygon, not a second polygon.
    This is why polygons need to be made of rings. One ring defines the outer edge
    of the donut, and another delineates the hole. You need to add the outer ring
    to the polygon first, and subsequent rings define holes in the geometry. To illustrate
    how to do this, try cutting the house out of the yard polygon ([figure 6.21](#ch06fig21)).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 那么关于内部有洞的多边形，比如甜甜圈呢？这些与多边形不同，因为洞是多边形的缺失，而不是第二个多边形。这就是为什么多边形需要由环组成。一个环定义了甜甜圈的外边缘，另一个环则勾勒出洞。你需要首先将外环添加到多边形中，然后后续的环定义几何中的洞。为了说明如何做到这一点，尝试从庭院多边形中切出房屋（[图6.21](#ch06fig21)）。
- en: Figure 6.21\. You can use a polygon with a hole for the yard boundary with the
    house cut out of the middle, shown here as the thick solid line.
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.21。你可以使用带洞的多边形作为庭院边界，中间切出房屋，这里以粗实线显示。
- en: '![](06fig21.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![06fig21.jpg]'
- en: Listing 6.4\. Creating a polygon with a hole
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.4。创建带洞的多边形
- en: '![](126fig01_alt.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![126fig01_alt.jpg]'
- en: 'Likely, creating a donut was easier than you expected. Now if you take a look
    at the WKT, you’ll see two rings shown inside the polygon:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，制作甜甜圈比你预期的要容易。现在如果你看一下WKT，你会看到在多边形内部显示了两个环：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The holes are taken into account when using the polygon. For example, the area
    of the yard polygon is equal to the area of the lot with the house subtracted
    out. The hole in the polygon isn’t considered part of the geometry when using
    the spatial analysis tools shown in the next section, either.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用多边形时，会考虑孔洞。例如，院子多边形的面积等于减去房屋面积后的地块面积。在下一节中展示的空间分析工具使用时，多边形中的孔洞也不被视为几何体的一部分。
- en: The only difference when editing a polygon like this is that you need to loop
    through each of the rings instead of assuming only one exists ([figure 6.22](#ch06fig22)).
    In practice, you shouldn’t ever assume only one ring exists, anyway, because that
    assumption could come back to haunt you later.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当编辑此类多边形时，唯一的区别是您需要遍历每个环，而不是假设只有一个环（[图 6.22](#ch06fig22)）。实际上，您永远不应该假设只有一个环存在，因为这个假设可能会在以后回来困扰您。
- en: Figure 6.22\. The original and edited yard polygon geometries with the house
    cut out. The original is filled and the edited one is hatched.
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.22\. 原始和编辑后的院子多边形几何体，房屋已被裁剪。原始的是填充的，编辑的是网状的。
- en: '![](06fig22.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig22.jpg)'
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using other modules to work with geometries**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用其他模块处理几何体**'
- en: Now that you understand how to deal with geometries using OGR, other geometry
    libraries, such as Fiona, should be easy to understand. Lines are still created
    by an ordered collection of vertices, and polygons are still made up of rings.
    The underlying theory about geometries doesn’t change, although the method of
    accessing them does.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何使用 OGR 处理几何体，其他几何体库，如 Fiona，应该很容易理解。线仍然是由有序顶点集合创建的，多边形仍然由环组成。关于几何体的基本理论没有变化，尽管访问它们的方法有所改变。
- en: Fiona, for example, is a library for reading and writing vector data that’s
    built on top of OGR. Fiona doesn’t use special geometry types, but instead uses
    Python lists to store vertices. The lists are filled with tuples that contain
    the vertex coordinates. For example, a ring is a list of tuples, and a polygon
    is a list of rings. A polygon with one ring is a list that contains another list
    that contains tuples for the vertices. The Fiona user manual is excellent and
    can be found online at [http://toblerity.org/fiona/manual.html](http://toblerity.org/fiona/manual.html).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Fiona 是一个基于 OGR 的读取和写入矢量数据的库。Fiona 不使用特殊的几何类型，而是使用 Python 列表来存储顶点。列表填充了包含顶点坐标的元组。例如，一个环是一个元组列表，一个多边形是一个环的列表。一个只有一个环的多边形是一个包含另一个包含顶点元组的列表。Fiona
    的用户手册非常优秀，可在网上找到，地址为 [http://toblerity.org/fiona/manual.html](http://toblerity.org/fiona/manual.html)。
- en: Shapely is another outstanding module that’s designed for working with geometries,
    but not reading and writing data. Unlike Fiona, it does have special data types
    for geometries, but that’s why it can do spatial analysis, unlike Fiona. Even
    though it has its own data types, the general ideas are still the same. The detailed
    user manual for Shapely is available online at [http://toblerity.org/shapely/manual.html](http://toblerity.org/shapely/manual.html).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely 是另一个专为处理几何体而设计的出色模块，但它不用于读取和写入数据。与 Fiona 不同，它确实有专门用于几何体的数据类型，这就是为什么它可以进行空间分析，而
    Fiona 则不能。尽管它有自己的数据类型，但基本思想仍然是相同的。Shapely 的详细用户手册可在网上找到，地址为 [http://toblerity.org/shapely/manual.html](http://toblerity.org/shapely/manual.html)。
- en: '|  |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.5\. Summary
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5\. 概述
- en: A geometry consists of a collection of vertices. In the cases of lines and polygons,
    the vertices are connected by line segments to form shapes.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何体由顶点集合组成。在直线和多边形的情况下，顶点通过线段连接形成形状。
- en: Multigeometries consist of multiple geometries combined into one. This allows
    features such as Hawaii to be represented with a single geometry object.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多几何体是由多个几何体组合而成的。这使得像夏威夷这样的特征可以用单个几何体对象来表示。
- en: Geometries in OGR are either 2D or 2.5D. The 2.5D geometries have z values,
    but they’re ignored during analyses, which is why they aren’t considered 3D.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OGR 中的几何体是 2D 或 2.5D。2.5D 几何体有 z 值，但在分析过程中被忽略，这就是为什么它们不被视为 3D 的原因。
- en: All polygon geometries are made up of one or more rings.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有多边形几何体都由一个或多个环组成。
