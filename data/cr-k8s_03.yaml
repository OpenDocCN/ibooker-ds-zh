- en: 3 Let’s build a Pod
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 让我们构建一个Pod
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Exploring the basics of Linux primitives
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Linux原语的基本知识
- en: Utilizing Linux primitives in Kubernetes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Linux原语在Kubernetes中
- en: Building your own Pod without using Docker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用Docker构建自己的Pod
- en: Why certain Kubernetes plugins have evolved over time
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么某些Kubernetes插件随着时间的推移而演变
- en: This chapter gives you an introduction to building a Pod via several Linux *primitives*
    that already exist in your OS. These are the fundamental building blocks in the
    Linux OS for process management, and we’ll soon learn that they can be used to
    build more sophisticated administrative programs or accomplish basic day-to-day
    tasks that require access to OS-level functionality in an ad hoc manner. The importance
    of these primitives is that they both inspire and implement many important aspects
    of Kubernetes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过介绍使用您操作系统中已经存在的几个Linux *原语*来构建Pod。这些是Linux操作系统中的进程管理的基本构建块，我们很快就会了解到它们可以用来构建更复杂的行政程序或以临时方式完成需要访问操作系统级功能的基本日常任务。这些原语的重要性在于，它们既启发了又实现了Kubernetes的许多重要方面。
- en: We’ll also look at the reasons why we need *CNI providers*, which are executable
    programs that provide Pods with IP addresses. Finally, we’ll review the role the
    kubelet plays in starting a container. Let’s begin with a little appetizer to
    contextualize what you’ll learn in the next few sections.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨为什么我们需要 *CNI提供者*，这些是可执行程序，为Pod提供IP地址。最后，我们将回顾kubelet在启动容器中扮演的角色。让我们先从一个简短的介绍开始，以便了解接下来几节将要学习的内容。
- en: The Guestbook application sandbox
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Guestbook应用程序沙盒
- en: In chapter 15, we’ll go through a realistic Kubernetes application with a frontend,
    networking, and a backend. Don’t hesitate to skip over to that chapter if you
    want a high-level overview of how Kubernetes Pods work from an application perspective.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在第15章中，我们将通过一个具有前端、网络和后端的实际Kubernetes应用程序进行讲解。如果您想从应用的角度获得Kubernetes Pods工作的高级概述，不妨跳转到那一章。
- en: Figure 3.1 demonstrates the nature of creating and running a Pod in Kubernetes.
    It’s highly simplified, and we’ll evolve some of the details in this figure in
    further chapters. For now, what’s worth noting is that there’s a long stretch
    of time between when a Pod is first created and when it is declared as being in
    a running state. Assuming you’ve run a few Pods yourself, you’re probably well
    aware of this latency. What’s going on during this time period? A flurry of Linux
    primitives that you likely don’t use in your everyday life are getting summoned
    to create what is known as a *container*. In short
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1展示了在Kubernetes中创建和运行Pod的本质。它非常简化，我们将在后续章节中进一步阐述这个图中的某些细节。现在，值得注意的是，Pod首次创建和被宣布为运行状态之间存在一段很长的时间。假设您自己运行过一些Pod，您可能非常清楚这种延迟。在这段时间里发生了什么？一系列您在日常生活中可能不会使用的Linux原语被召唤起来，以创建所谓的
    *容器*。简而言之
- en: The kubelet has to find out that it is supposed to be running a container.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubelet必须找出它应该运行一个容器。
- en: The kubelet (by talking to a container runtime) then launches a *pause container*,
    which gives the Linux OS time to create a network for a container. This pause
    container is the predecessor of the actual application that we’ll run. It exists
    for the purpose of creating an initial home to bootstrap our new container network
    process and its process ID (PID).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubelet（通过与容器运行时通信）然后启动一个 *pause容器*，这给Linux操作系统留出时间来为容器创建网络。这个pause容器是我们将要运行的实际应用程序的前身。它存在是为了创建一个初始的家，以便引导我们的新容器网络进程及其进程ID（PID）。
- en: The state of the various components during startup oscillate as demonstrated
    in each swimlane in figure 3.1\. For example, a CNI provider is mostly idle with
    the exception of the time it takes to bind the pause container to a network namespace.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动过程中，各种组件的状态如图3.1中的每个泳道所示，会进行振荡。例如，CNI提供者在将pause容器绑定到网络命名空间的时间之外，大部分时间都是空闲的。
- en: '![](../Images/CH03_F01_love.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F01_love.png)'
- en: Figure 3.1 Bootstrapping with Linux primitives
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 使用Linux原语引导
- en: In figure 3.1, the x-axis represents the relative timescale of a Pod’s startup.
    Several operations take place over time, which involve the mounting of *subpaths*
    (the wiring of external storage directories that our container reads or writes).
    These occur in the same timeframe preceding the 30-second mark where our Pod enters
    the running state. As mentioned, various Linux commands use basic Linux primitives,
    triggered by the kubelet, in order to get a Pod into its ultimate running state.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.1中，x轴表示Pod启动的相对时间尺度。在一段时间内会发生几个操作，这些操作涉及*子路径*（外部存储目录的布线，我们的容器读取或写入）。这些操作发生在Pod进入运行状态前的30秒标记之前的同一时间范围内。正如提到的，各种Linux命令使用由kubelet触发的Linux基本原语，以便将Pod带入其最终的运行状态。
- en: Storage, bind mounts, and subpaths
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 存储、绑定挂载和子路径
- en: Storage in Kubernetes Pods typically involves *bind mounting* (attaching a folder
    from one location to another location). This allows containers to “see” a directory
    at a specific subpath in their file tree. This is a basic Linux function that
    is commonly used when mounting an NFS share, for example, outside of the container
    world.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Pods中的存储通常涉及*绑定挂载*（将一个文件夹从一个位置附加到另一个位置）。这允许容器在其文件树中的特定子路径“看到”一个目录。这是一个基本的Linux功能，在挂载NFS共享等操作中经常使用。
- en: Bind mounts are used under the hood in all sorts of systems to implement a lot
    of Kubernetes critical functionality. This includes allowing access to storage
    for Pods. We can use tools like `nsenter` to investigate which directories are
    available to an isolated process, without actually relying on the usage of a container
    runtime (such as Docker or crictl).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定挂载在各种系统中被用于实现许多Kubernetes关键功能。这包括允许Pod访问存储。我们可以使用像`nsenter`这样的工具来调查哪些目录可供隔离进程使用，而实际上并不依赖于容器运行时（如Docker或crictl）的使用。
- en: Because `nsenter` is a simple Linux executable that operates against the base
    OS APIs, it’s always usable regardless of whether or not you are in a particular
    Kubernetes distribution. Thus, you can use it even if Docker or crictl aren’t
    available. For Windows clusters, of course, you can’t rely on `nsenter`, and you
    might be more dependent on container runtime tooling when investigating low-level
    problems.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`nsenter`是一个简单的Linux可执行文件，它针对的是基础OS API，因此无论你是否在特定的Kubernetes发行版中，它总是可用的。因此，即使Docker或crictl不可用，你也可以使用它。对于Windows集群，当然，你不能依赖`nsenter`，在调查底层问题时，你可能更依赖于容器运行时工具。
- en: 'As an example of the foundational nature of these primitives, we can take a
    look at the comments for the following code that lives in the pkg/volume/util/subpath/subpath
    _linux.go file of Kubernetes itself, located here: [http://mng.bz/8Ml2](http://mng.bz/8Ml2).
    This demonstrates the pervasiveness of these primitives in a Kubernetes implementation:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这些原语基础性质的例子，我们可以查看以下代码的注释，这些代码位于Kubernetes本身的`pkg/volume/util/subpath/subpath_linux.go`文件中，位于此处：[http://mng.bz/8Ml2](http://mng.bz/8Ml2)。这展示了这些原语在Kubernetes实现中的普遍性：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Creates the target for the bind mount of a subpath
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建子路径绑定挂载的目标
- en: After the function `prepareSubpathTarget` creates the target for the subpath’s
    bind mount, the subpath is then accessible inside a container, even though it
    is created on the kubelet. Previously, an `NsEnterMounter` function provided this
    functionality in order to accomplish various directory operations inside containers.
    You may not need to read this code again. However, it’s informative to know that
    there are vestiges of `nsenter` referenced in Kubernetes itself.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在`prepareSubpathTarget`函数创建子路径的绑定挂载目标之后，子路径就可以在容器内部访问了，即使它是创建在kubelet上的。之前，`NsEnterMounter`函数提供了这种功能，以便在容器内部完成各种目录操作。你可能不需要再次阅读这段代码。然而，了解Kubernetes本身中引用了`nsenter`的遗迹是有帮助的。
- en: Historically, `nsenter` was utilized at various times in Kubernetes to work
    around bugs or idiosyncrasies in how container runtimes managed storage. In much
    the same way, if you ever do run into an issue related to storage or directory
    mounting, it’s nice to know there are Linux tools that can do the same thing as
    the kubelet and your container runtime, double-checking where a problem exists;
    `nsenter` is just one example of a simple Linux command.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，`nsenter`在Kubernetes中多次被用来解决容器运行时在管理存储方面的错误或怪癖。同样，如果你遇到与存储或目录挂载相关的问题，了解有Linux工具可以做到与kubelet和你的容器运行时相同的事情，检查问题所在的位置是很有用的；`nsenter`只是简单Linux命令的一个例子。
- en: 3.1 Looking at Kubernetes primitives with kind
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 使用kind查看Kubernetes原语
- en: Let’s get started with a simple cluster where we can prove a few of these concepts.
    There’s no easier way to create a reference to the Kubernetes environment than
    by using `kind` ([https://kind.sigs.k8s.io](https://kind.sigs.k8s.io)), a developer
    tool for Kubernetes. This will be the baseline for many of the experiments we
    do in this book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个简单的集群开始，我们可以用它来证明这些概念中的几个。没有比使用`kind`（[https://kind.sigs.k8s.io](https://kind.sigs.k8s.io)）更容易创建Kubernetes环境引用的方法，`kind`是一个Kubernetes的开发者工具。这将是我们在本书中进行的许多实验的基础。
- en: First, we’ll need to set up a simple Linux environment so we can explore such
    concepts. Because we’ll use `kind`, this allows you to run Kubernetes clusters
    (single or multi-node) inside a container runtime, such as Docker Enginer. `kind`
    works on any OS by creating a new container for every node. We can compare a `kind`
    cluster to a real-world cluster, as table 3.1 demonstrates.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置一个简单的Linux环境，这样我们就可以探索这些概念。因为我们将使用`kind`，这允许您在容器运行时（如Docker Enginer）内部运行Kubernetes集群（单节点或多节点）。`kind`通过为每个节点创建一个新的容器来在任何操作系统上运行。我们可以将`kind`集群与表3.1所示的现实世界集群进行比较。
- en: Table 3.1 Comparing `kind` to a “real” cluster
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1比较`kind`与“真实”集群
- en: '| Cluster type | Administrator | Kubelet type | Swap-enabled |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 集群类型 | 管理员 | Kubelet类型 | 允许交换 |'
- en: '| `kind` | You (the Docker user) | Docker container | Yes (not for production
    use) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `kind` | 您（Docker用户） | Docker容器 | 是（不适用于生产环境） |'
- en: '| GKE (Google Kubernetes Engine) | Google | A GCE (Google Compute Engine) node
    | No |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| GKE（Google Kubernetes Engine） | Google | 一个GCE（Google计算引擎）节点 | 否 |'
- en: '| Cluster API | A running master cluster | A VM in whatever provider cloud
    you’ve chosen | No |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 集群API | 运行中的主集群 | 您选择的任何云提供商中的虚拟机 | 否 |'
- en: Table 3.1 compares the architecture of a `kind` cluster with the regular clusters
    we run in production. There are many aspects of `kind` that are not production-friendly.
    For example, because it enables swapping resources, this ultimately means containers
    might be utilizing disk space for their memory. This has obvious performance and
    compute costs that might be incurred if many containers suddenly need more memory
    to operate. The benefit of `kind`, however, is evident as an exercise where learning
    is the priority, and
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1比较了`kind`集群与我们在生产中运行的常规集群的架构。`kind`的许多方面都不适合生产。例如，因为它允许资源交换，这最终意味着容器可能会利用磁盘空间作为它们的内存。如果许多容器突然需要更多内存来运行，这可能会产生明显的性能和计算成本。然而，`kind`的好处在于，当学习是重点时，这一点是显而易见的。
- en: It costs nothing.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不花费任何费用。
- en: It can be installed in seconds.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在几秒钟内安装。
- en: It can be rebuilt in seconds, if needed.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，它可以在几秒钟内重建。
- en: It can run basic Kubernetes functionality with no issues.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以无问题地运行基本的Kubernetes功能。
- en: It is capable of running almost any networking or storage provider, so it is
    realistic enough to get started with Kubernetes.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能够运行几乎任何网络或存储提供商，因此它足够现实，可以开始使用Kubernetes。
- en: In our case, we’ll use a `kind` Docker container to not only run a few Kubernetes
    examples, but also to use it as a lightweight Linux VM that we can hack around
    inside of. We’ll conclude the chapter by diving into Kubernetes networking internals,
    looking at how we can use the `iptables` command to route traffic inside a Kubernetes
    cluster.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将使用`kind`Docker容器不仅运行一些Kubernetes示例，而且将其用作一个轻量级的Linux虚拟机，我们可以在其中进行修改。我们将通过深入研究Kubernetes网络内部，查看我们如何使用`iptables`命令在Kubernetes集群内部路由流量来结束本章。
- en: Setting up your computer
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 设置您的计算机
- en: 'Before we get started, here’s a quick note on setting up your computer. We
    assume you’re comfortable using the [https://kubernetes.io](https://kubernetes.io)
    website and various search engines to find the most up-to-date information on
    how to install things, and that you have at least some basic Linux experience
    installing packages for some distribution. In general, we won’t give you specific
    instructions for all of the minute tasks we carry out, but keep in mind that you
    will need a Linux environment to follow along in this chapter:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，这里有一个关于设置您的计算机的快速说明。我们假设您熟悉使用[https://kubernetes.io](https://kubernetes.io)网站和各种搜索引擎来查找有关如何安装的最新信息，并且您至少有一些基本的Linux经验，可以安装某些发行版的软件包。一般来说，我们不会为您提供所有细微任务的特定说明，但请记住，您将需要一个Linux环境来跟随本章的内容：
- en: If you are running Windows, you will need to install a VM with Linux on it using
    VMware Fusion, VirtualBox, or Hyper-V.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在运行Windows，您将需要使用VMware Fusion、VirtualBox或Hyper-V安装带有Linux的虚拟机。
- en: If you are running Linux, you can try many of these examples with or without
    a `kind` cluster.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在运行 Linux，你可以尝试使用这些示例，无论是有还是没有 `kind` 集群。
- en: If you are running a Mac, you can simply download the Docker desktop, and you’ll
    be all set.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在运行 Mac，你可以简单地下载 Docker 桌面，然后你就可以设置好了。
- en: If you don’t have all this set up yet, we encourage you to take the time to
    do so. If you are a Linux user, you probably are quite used to a DIY setup of
    different programming tools. For others, simply searching for “Running Linux containers
    on Windows” or “How to run Docker on OS X” will get you up and running within
    a few minutes. Almost every modern OS supports running Docker in one way or other.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有设置好所有这些，我们鼓励你花时间去做。如果你是 Linux 用户，你可能已经习惯了不同编程工具的 DIY 设置。对于其他人来说，只需搜索“在
    Windows 上运行 Linux 容器”或“如何在 OS X 上运行 Docker”等，你就可以在几分钟内开始运行。几乎每个现代操作系统都以某种方式支持运行
    Docker。
- en: 3.2 What is a Linux primitive?
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 什么是 Linux 原语？
- en: As mentioned previously, Linux primitives are the fundamental building blocks
    in the Linux OS. Tools like `iptables`, `ls`, `mount`, and many other basic programs
    available in most Linux distributions are examples of such primitives. You’ve
    almost surely used at least some of these commands before if you’ve worked on
    any kind of technology related to software development. For example, the `ls`
    command is one of the first tools anyone using a Linux terminal learns. It lists
    all the files in your current directory. If you send it an argument (such as `/tmp`,
    for example), then it lists all the files in that directory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Linux 原语是 Linux 操作系统的基本构建块。例如，`iptables`、`ls`、`mount` 以及大多数 Linux 发行版中可用的许多其他基本程序都是此类原语的例子。如果你在软件开发相关的任何技术领域工作过，你几乎肯定使用过其中的一些命令。例如，`ls`
    命令是任何使用 Linux 终端的人首先学习的工具之一。它列出了你当前目录中的所有文件。如果你向它发送一个参数（例如 `/tmp`），那么它将列出该目录中的所有文件。
- en: 'Knowing the basics of these tools gives you a powerful leg-up in understanding
    the myriad of new plugins and add-ons in the Kubernetes ecosystem. That’s because
    they all are largely built on the same set of fundamental building blocks:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些工具的基本知识让你在理解 Kubernetes 生态系统中众多新插件和附加组件时具有强大的优势。这是因为它们大多都是建立在同一套基本构建块之上的：
- en: '*The network proxy,* `kube-proxy`, *creates iptables rules, and these rules
    are often inspected to debug container networking issues in large clusters.* Running
    `iptables -L` in a Kubernetes node illustrates this. Container Network Interface
    (CNI) providers also use this network proxy as well (for example, for various
    tasks related to NetworkPolicies implementation).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*网络代理* `kube-proxy` *创建 iptables 规则，这些规则通常被检查以调试大型集群中的容器网络问题。在 Kubernetes 节点上运行
    `iptables -L` 可以说明这一点。容器网络接口 (CNI) 提供商也使用这个网络代理（例如，用于与 NetworkPolicies 实现相关的各种任务）。'
- en: '*The Container Storage Interface (CSI) defines a socket for communication between
    the kubelet and storage technologies.* This includes resources such as Pure, GlusterFS,
    vSAN, Elastic Block Store (EBS), Network File System (NFS), and so on. For example,
    running `mount` in a cluster shows you the container and volume mounts managed
    by Kubernetes without relying on `kubectl` or any other non-native OS tools, and,
    thus, is a common debugging technique when troubleshooting low-level storage errors
    in Kubernetes.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*容器存储接口 (CSI) 定义了 kubelet 和存储技术之间的通信套接字。这包括 Pure、GlusterFS、vSAN、弹性块存储 (EBS)、网络文件系统
    (NFS) 等资源。例如，在集群中运行 `mount` 可以显示 Kubernetes 管理的容器和卷挂载，而不依赖于 `kubectl` 或任何其他非原生
    OS 工具，因此，这是在 Kubernetes 中调试底层存储错误时的常见调试技术。*'
- en: '*Container runtime commands like* `unshare` *and* `mount` *are used when creating
    isolated processes.* These often need to be run by technologies that create the
    container. The essential ability to run these commands (which often require root
    privileges) is an important security boundary when it comes to modeling threats
    in a Kubernetes cluster.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在创建隔离进程时，会使用像* `unshare` *和* `mount` *这样的容器运行时命令。这些命令通常需要由创建容器的技术运行。运行这些命令（通常需要
    root 权限）的能力是当在 Kubernetes 集群中建模威胁时的重要安全边界。*'
- en: The way we access the `ls` tool is typically from a shell or by combining many
    shell commands together into a shell script. Many Linux commands can be run from
    the shell, and often they return textual output that can be used as input to the
    next command. The reason we often access `ls` as part of a broader script is so
    that we can combine it with other programs (for example, to run a command on all
    files in a directory). This brings us back to the topic of Kubernetes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过shell访问`ls`工具，或者通过将许多shell命令组合成一个shell脚本。许多Linux命令可以从shell中运行，并且通常它们会返回文本输出，这些输出可以用作下一个命令的输入。我们通常将`ls`作为更广泛脚本的一部分来访问的原因是，我们可以将其与其他程序结合使用（例如，在目录中的所有文件上运行命令）。这又把我们带回了Kubernetes的话题。
- en: 3.2.1 Linux primitives are resource management tools
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 Linux基本操作是资源管理工具
- en: An important part of system administration involves managing resources on a
    machine. Although `ls` seems like a simple program, it’s also a powerful resource
    management tool in that regard. Administrators use this program daily to find
    large files or to check whether a user has the ability to do basic actions in
    cases of permissions errors reported by users or other programs. It allows us
    to find
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理的一个重要部分涉及管理机器上的资源。尽管`ls`看起来像是一个简单的程序，但在资源管理方面，它也是一个强大的工具。管理员每天都会使用这个程序来查找大文件或检查用户是否有能力在用户或其他程序报告权限错误的情况下执行基本操作。它使我们能够找到
- en: Whether we can access a certain file
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否可以访问某个文件
- en: What files are available in an arbitrary directory
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任意目录中可用的文件有哪些
- en: What capabilities that file has (for example, can it be executed?)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该文件具有哪些功能（例如，它是否可执行？）
- en: 'Speaking of files, that brings us to the next aspect of Linux primitives: *everything
    is a file*. This is a key differentiator between Linux and other OSs such as Windows.
    In fact, when running Windows nodes in a Kubernetes cluster, the ability to inspect
    and monitor the status of events can be more complicated because there is no uniform
    representation of objects. For example, many Windows objects are stored in memory,
    accessible only through Windows APIs, and are not accessible through the filesystem.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 说到文件，这让我们想到了Linux基本操作的下一个方面：*一切皆文件*。这是Linux与其他操作系统（如Windows）之间的一个关键区别。事实上，当在Kubernetes集群中运行Windows节点时，检查和监控事件状态的能力可能会更复杂，因为没有统一的对象表示。例如，许多Windows对象存储在内存中，只能通过Windows
    API访问，而不能通过文件系统访问。
- en: “Everything is a file” is unique to Linux
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: “一切皆文件”是Linux的独特之处
- en: In Windows, the administration of machines often requires editing the Windows
    Registry. This requires running custom programs and often using the Windows GUI.
    There are ways to perform many aspects of system administration using PowerShell
    and other tools; however, it is not generally possible to administer an entire
    Windows OS by simply reading and writing files.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，机器的管理通常需要编辑Windows注册表。这需要运行自定义程序，并且通常需要使用Windows GUI。使用PowerShell和其他工具执行许多系统管理方面的工作是有方法的；然而，通常不可能仅通过读取和写入文件来管理整个Windows操作系统。
- en: In contrast, it is quite common for Linux administrators to perform almost all
    aspects of system administration by managing plain text files. For example, administrators
    are well aware of the /proc directory, which has real-time information about running
    processes. This can be managed as if it were just a directory of files in many
    ways, even though it is not a “normal” directory in any sense.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Linux管理员通常通过管理纯文本文件来执行系统管理的几乎所有方面。例如，管理员非常了解/proc目录，它包含有关正在运行进程的实时信息。在许多方面，它可以像管理文件目录一样进行管理，尽管它从任何意义上说都不是一个“正常”的目录。
- en: 3.2.2 Everything is a file (or a file descriptor)
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 一切都是文件（或文件描述符）
- en: Linux primitives, in some sense, are almost always doing something to manipulate,
    move, or provide an abstraction over a file of some sort. This is because *everything*
    you’ll need to build with Kubernetes was originally built to work on Linux, and
    Linux is entirely designed to use the file abstraction as a control primitive.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的基本操作，从某种意义上讲，几乎总是对某种类型的文件进行操作、移动或提供抽象。这是因为你将需要用Kubernetes构建的*所有*东西最初都是为Linux设计的，而Linux完全是为了使用文件抽象作为控制原语而设计的。
- en: For example, the `ls` command operates on files. It looks at a file (which is
    a directory) and reads the filenames inside of that file. It then prints those
    strings to another file, known as standard out. Standard out is not a typical
    file that we would normally think about; rather, it is a file that, when written
    to, magically makes stuff show up in our terminals. When we say that in Linux
    everything is a file, we really mean it!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`ls`命令作用于文件。它查看一个文件（即目录）并读取该文件内的文件名。然后它将这些字符串打印到另一个文件，称为标准输出。标准输出不是一个我们通常会考虑的典型文件；相反，它是一个文件，当我们写入时，神奇地在我们的终端中显示内容。当我们说在Linux中一切都是文件时，我们真的是这个意思！
- en: '*A directory is a file, but it contains the names of other files.*'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*目录也是一个文件，但它包含其他文件的名称.*'
- en: '*Devices are also represented as files to the Linux kernel.* Because devices
    are accessible as files, this means that you can use commands like `ls` to confirm
    whether an Ethernet device, for example, is attached inside a container.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设备也被表示为文件给Linux内核.* 因为设备可以作为文件访问，这意味着你可以使用像`ls`这样的命令来确认例如以太网设备是否在容器内连接。'
- en: '*Sockets and pipes are also files, which processes can use locally for communications.*
    Later, we’ll see how the CSI heavily utilizes this abstraction for defining a
    way that the kubelet can talk to volume providers, providing storage for our Pods.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*套接字和管道也是文件，进程可以在本地使用它们进行通信.* 之后，我们将看到CSI如何大量利用这种抽象来定义kubelet与卷提供者通信的方式，为我们的Pod提供存储。'
- en: 3.2.3 Files are composable
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 文件是可组合的
- en: 'Combining the previous concepts of files and resource management, we now come
    to the most important point about Linux primitives: they are composable into higher-level
    actions. Using a pipe (`|`), we can take the output from one command and process
    it in another command. One of the most popular incantations of this command is
    to combine `ls` with the `grep` commands to filter specific files and list them.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 结合之前关于文件和资源管理的概念，我们现在来到Linux原语最重要的一个点：它们可以组合成更高级的操作。使用管道（`|`），我们可以将一个命令的输出传递给另一个命令进行处理。这个命令最流行的用法之一是将`ls`与`grep`命令结合，以过滤特定文件并列出它们。
- en: 'A common Kubernetes administration task, for example, might be to confirm that
    etcd is running and healthy inside a cluster. If running as a container, one can
    run the following command inside a node that’s running the Kubernetes control
    plane components (which almost always run the critical etcd process):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个常见的Kubernetes管理任务可能是确认etcd在集群内运行且健康。如果作为容器运行，可以在运行Kubernetes控制平面组件（几乎总是运行关键的etcd进程）的节点上运行以下命令：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Likewise, if you were on a Kubernetes cluster of unknown origin, you could
    find out where etcd-related configuration resources resided. You might run something
    like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你在一个来源不明的Kubernetes集群中，你可以找出与etcd相关的配置资源所在的位置。你可能运行如下命令：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: etcd in a container?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 容器中的etcd？
- en: 'You may be wondering why etcd is running in a container. A brief note so as
    not to give you the wrong idea: In production clusters, it is common to run etcd
    in a place separate from the rest of your containers. This can prevent competition
    over precious disk and CPU resources. Many smaller or developer clusters, however,
    run all control-plane components in a single place for simplicity. That said,
    many Kubernetes solutions have demonstrated that etcd can run well in a container
    as long as the volumes for this container are stored on a local disk so that they
    are not lost on container restarts.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么etcd在容器中运行。简短地说明一下，以免给你错误的印象：在生产集群中，通常将etcd运行在与其他容器不同的地方。这可以防止对宝贵的磁盘和CPU资源的竞争。然而，许多较小的或开发者集群为了简单起见，将所有控制平面组件运行在同一个地方。话虽如此，许多Kubernetes解决方案已经证明，只要这个容器的卷存储在本地磁盘上，那么etcd就可以在容器中良好运行，这样在容器重启时就不会丢失。
- en: That’s about as far as we can go with the theory. From here on out, we’re going
    to get our hands dirty and run a lot of Linux commands that allow us to build
    our own Pod-like behavior from scratch. But before we go down that road, we’ll
    use `kind` to set up a cluster that we can play with.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们可以用理论走到的尽头。从现在开始，我们将动手操作，运行大量的Linux命令，从零开始构建自己的Pod-like行为。但在我们走这条路之前，我们将使用`kind`来设置一个我们可以玩耍的集群。
- en: 3.2.4 Setting up kind
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 设置kind
- en: With Kubernetes and Docker, `kind` is a clever tool maintained by the Kubernetes
    community. It builds Kubernetes clusters inside Docker containers with no other
    dependencies. This allows developers to simulate realistic clusters with many
    nodes locally, without needing to make VMs or use other heavy-weight constructs.
    It is not a production Kubernetes provider and is only used for development or
    research purposes. In order to follow along, we’ll build some `kind` clusters,
    and for this chapter, our first cluster can be built by following the instructions
    at [http://mng.bz/voVm](http://mng.bz/voVm).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Kubernetes 和 Docker 一起，`kind` 是由 Kubernetes 社区维护的一个聪明工具。它使用无其他依赖项在 Docker
    容器内构建 Kubernetes 集群。这允许开发者本地模拟具有许多节点的真实集群，无需创建虚拟机或使用其他重型结构。它不是一个生产级 Kubernetes
    提供商，仅用于开发或研究目的。为了跟随本书，我们将构建一些 `kind` 集群，对于本章，我们的第一个集群可以通过遵循 [http://mng.bz/voVm](http://mng.bz/voVm)
    中的说明来构建。
- en: '`kind` installs in just a few seconds on any OS and allows us to run Kubernetes
    inside Docker. We’ll treat each Docker container as a VM and execute into these
    containers to investigate various properties of Linux in general. The workflow
    for setting up kind as a basic Kubernetes hacking environment is simple:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind` 在任何操作系统上只需几秒钟即可安装，并允许我们在 Docker 内运行 Kubernetes。我们将把每个 Docker 容器视为一个虚拟机，并执行到这些容器中以调查
    Linux 的一般特性。将 `kind` 设置为基本 Kubernetes 开发环境的流程很简单：'
- en: Install Docker.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Docker。
- en: Install `kubectl` to /usr/local/bin/kubectl.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `kubectl` 安装到 /usr/local/bin/kubectl。
- en: Install `kind` to /usr/local/bin/kind.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `kind` 安装到 /usr/local/bin/kind。
- en: Test the installation by running `kubectl` `get` `pods`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `kubectl get pods` 测试安装。
- en: Why are we using `kind`? This book has a lot of examples, so if you want to
    run them yourself (which we encourage, but it isn’t required for reading along),
    you’ll need a Linux environment of some sort. And because we’re talking about
    Kubernetes, we’ve gone with `kind` for the reasons stated earlier. However, if
    you are an advanced user, don’t feel obligated to use `kind`. If you are familiar
    with a lot of this stuff and just want to dive in to get to the hard parts, you
    can also run many of these commands on any Kubernetes cluster. But, of course,
    we assume you’ll be running these on some variant of Linux because cgroups, Linux
    namespaces, and other fundamental Kubernetes primitives aren’t available on commercial
    OS distros like Windows and Mac OS X out of the box.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么使用 `kind`？本书有很多示例，如果您想亲自运行它们（我们鼓励这样做，但阅读本书并不需要这样做），您将需要一个某种 Linux 环境。由于我们谈论的是
    Kubernetes，我们选择了 `kind`，原因如前所述。然而，如果您是高级用户，您不必觉得有义务使用 `kind`。如果您熟悉很多这方面的内容，只想深入挖掘以到达难点，您也可以在任何
    Kubernetes 集群上运行许多这些命令。但当然，我们假设您将在某种 Linux 变体上运行这些命令，因为 cgroups、Linux 命名空间和其他
    Kubernetes 基本原语在 Windows 和 Mac OS X 等商业操作系统发行版中默认不可用。
- en: Windows users
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户
- en: '`kind` is installable as a Windows executable. We encourage you to look at
    [https://kind.sigs.k8s.io/docs/user/quick-start/](https://kind.sigs.k8s.io/docs/user/quick-start/).
    It even has Choco `install` commands that you can run. If you are a Windows user,
    you can run all the commands in this book inside Windows Subsystem for Linux (WSL
    2), which is a lightweight Linux VM that can be run readily on any Windows machine.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind` 可以作为 Windows 可执行文件安装。我们鼓励您查看 [https://kind.sigs.k8s.io/docs/user/quick-start/](https://kind.sigs.k8s.io/docs/user/quick-start/)。它甚至有
    Choco `install` 命令可以运行。如果您是 Windows 用户，您可以在 Windows 子系统 for Linux (WSL 2) 中运行本书中的所有命令，这是一个轻量级的
    Linux 虚拟机，可以在任何 Windows 机器上轻松运行。'
- en: Note that you can also run `kubectl` as a Windows executable to connect to a
    remote cluster on any cloud as well. And, although we seem biased toward Linux
    and OS X in this book, we are fully supportive of you running these commands on
    a Windows machine!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您还可以将 `kubectl` 作为 Windows 可执行文件运行，以连接到任何云上的远程集群。尽管我们在本书中似乎更倾向于 Linux 和 OS
    X，但我们完全支持您在 Windows 机器上运行这些命令！
- en: 'Once `kind` is installed, you can create a cluster. To do that, use these commands:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 `kind`，您就可以创建一个集群。为此，请使用以下命令：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Deletes the kind cluster if a previous cluster is running
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果之前有集群正在运行，则删除 `kind` 集群
- en: ❷ Starts your kind cluster
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 启动您的友好集群
- en: 'Now you can see the Pods running in the cluster. To get a list of the Pods,
    issue the command in the following code snippet, which also shows sample output
    from the command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以看到集群中正在运行的 Pods。要获取 Pods 列表，请执行以下代码片段中的命令，它还显示了该命令的示例输出：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you''re wondering where your Kubernetes node is, you''re in luck! It can
    be listed easily by simply asking Docker:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道你的Kubernetes节点在哪里，你很幸运！你可以通过简单地询问Docker来轻松列出它：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, if you are a system administrator and want to be able to ssh into your
    nodes, you're also in luck. We can get into your Kubernetes node by running
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你是系统管理员并且想要能够通过ssh连接到你的节点，你也很幸运。我们可以通过运行以下命令进入你的Kubernetes节点：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: along with commands such as those shown earlier in this section. You would run
    these from inside the node (which is really a container).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以及本节前面显示的命令。你将需要在节点内部（实际上是一个容器）运行这些命令。
- en: By the way, you might be wondering how it is that Kubernetes can run in Docker.
    Does this mean that Docker containers can spin up other Docker containers? Absolutely.
    If you look at the Docker image for kind ([http://mng.bz/nYg5](http://mng.bz/nYg5)),
    you can see exactly how it works. In particular, you can see all the Linux primitives
    it installs, which include some of the ones we've already discussed. Reading through
    this code is a great homework assignment to attempt after completing this chapter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你可能想知道Kubernetes是如何在Docker中运行的。这难道意味着Docker容器可以启动其他Docker容器吗？绝对可以。如果你查看kind的Docker镜像（[http://mng.bz/nYg5](http://mng.bz/nYg5)），你可以看到它是如何工作的。特别是，你可以看到它安装的所有Linux原语，其中包括我们之前讨论的一些。阅读这段代码是在完成本章后尝试的一个很好的家庭作业。
- en: 3.3 Using Linux primitives in Kubernetes
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 在Kubernetes中使用Linux原语
- en: The way core features in Kubernetes work often links back, either indirectly
    or directly, to the way that basic Linux primitives work. These primitives form
    a scaffold for running containers that you will continually come back to after
    you understand them. Over time, you’ll find that many technologies that use buzzwords
    like “service mesh” or “container native storage” boil down to cleverly assembled
    menageries of the same basic fundamental OS functionality.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的核心功能通常与基本Linux原语的工作方式相关联，无论是间接还是直接。这些原语构成了运行容器的支架，在你理解它们之后，你将不断回到这里。随着时间的推移，你会发现许多使用像“服务网格”或“容器原生存储”这样的热词的技术，最终归结为巧妙组装的相同基本操作系统功能的大杂烩。
- en: 3.3.1 The prerequisites for running a Pod
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 运行Pod的前提条件
- en: 'As a reminder, a *Pod* is the fundamental execution unit in a Kubernetes cluster:
    it is the way that we define containers that will run in our data center. Although
    there are theoretical scenarios where one might use Kubernetes for tasks other
    than running containers, we’re not concerned with such outliers in this book.
    After all, we assume you are interested in running and understanding Kubernetes
    in a traditional context like the rest of us on planet earth.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，*Pod*是Kubernetes集群中的基本执行单元：它是我们在数据中心中定义将运行的容器的途径。尽管存在一些理论场景，其中一个人可能会使用Kubernetes来完成除了运行容器之外的任务，但我们在这本书中不关注这样的异常情况。毕竟，我们假设你对在像地球上其他地方的人一样传统的环境中运行和理解Kubernetes感兴趣。
- en: 'In order to create a Pod, we rely on the ability to implement isolation, networking,
    and process management. These constructs can be achieved by using the many utilities
    already available in the Linux OS. In fact, some of these utilities might be considered
    *required* functionality, without which a kubelet would not be able to do the
    necessary tasks to start a Pod. Let’s take a quick look at some of the programs
    (or *primitives*) that we rely on daily in our Kubernetes clusters:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个Pod，我们依赖于实现隔离、网络和进程管理的功能。这些结构可以通过使用Linux OS中已经可用的许多实用程序来实现。实际上，其中一些实用程序可能被认为是*必需的*功能，没有这些功能，kubelet将无法执行启动Pod所需的必要任务。让我们快速看一下我们在Kubernetes集群中每天依赖的一些程序（或*原语*）：
- en: '`swapoff`—A command that disables memory swapping, which is a known prerequisite
    for running Kubernetes in a manner that honors CPU and memory settings.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swapoff`—一个禁用内存交换的命令，这是以尊重CPU和内存设置的方式运行Kubernetes的已知前提条件。'
- en: '`iptables`—A core requirement (usually) of the network proxy, which creates
    iptables rules to send service traffic to our Pods.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iptables`—网络代理的核心需求（通常是），它创建iptables规则将服务流量发送到我们的Pods。'
- en: '`mount`—This command (mentioned earlier) projects a resource to a particular
    location in your path (for example, it allows you to expose a device as a folder
    in your home directory).'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mount`—这个命令（之前提到过）将资源投影到你的路径中的特定位置（例如，它允许你将设备作为文件夹暴露在你的家目录中）。'
- en: '`systemd`—This command usually starts the kubelet, which is the core process
    that runs in a cluster to manage all your containers.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd`——这个命令通常启动 kubelet，它是集群中运行的核心进程，用于管理你所有的容器。'
- en: '`socat`—This command allows you to establish a bidirectional stream of information
    between processes; `socat` is an essential part of how the `kubectl port-forward`
    command works.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socat`——这个命令允许你在进程之间建立双向信息流；`socat` 是 `kubectl port-forward` 命令工作的关键部分。'
- en: '`nsenter`—A tool for entering into various namespaces of a process so you can
    see what’s going on (from a networking, storage, or process perspective). In the
    same way that a namespace in Python has certain modules with local names, a Linux
    namespace has certain resources that aren’t locally addressable from the outside
    world. For example, the unique IP address of a Pod in a Kubernetes cluster is
    not shared by other Pods, even on the same node, because each Pod (usually) runs
    in a separate namespace.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nsenter`——这是一个工具，用于进入进程的各种命名空间，以便你可以看到正在发生的事情（从网络、存储或进程的角度）。与 Python 中的命名空间具有某些具有本地名称的模块一样，Linux
    命名空间具有某些资源，这些资源不能从外部世界本地访问。例如，Kubernetes 集群中 Pod 的唯一 IP 地址不会与其他 Pod 共享，即使在同一节点上，因为每个
    Pod（通常）都在一个单独的命名空间中运行。'
- en: '`unshare`—A command that allows a process to create child processes running
    in isolation from a network, mount, or PID perspective. We’ll use it thoroughly
    in this chapter to explore the famous *Pid 1 phenomenon* in containers, where
    every container in a Kubernetes cluster thinks it’s the only program in the entire
    world.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unshare`——这是一个允许进程创建与网络、挂载或 PID 视角隔离的子进程的命令。在本章中，我们将彻底使用它来探索容器中的著名 *Pid 1
    现象*，在 Kubernetes 集群中，每个容器都认为自己是整个世界上唯一的程序。'
- en: '`unshare` can also isolate mounts (the `/` location) and network namespaces
    (the IP addresses), and thus is the most direct analog to `docker run` that exists
    in a raw Linux OS.'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`unshare` 也可以隔离挂载点（`/` 位置）和网络命名空间（IP 地址），因此它是原生 Linux 操作系统中与 `docker run` 最直接对应的命令。'
- en: '`ps`—A program that lists running processes. The kubelet needs to continually
    monitor processes to find out when they exited and so on. By using `ps` to list
    processes, you can determine if there are “zombie” processes in your cluster or
    if a privileged container has gone rogue (creating many new subprocesses) and
    so on.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps`——一个列出正在运行进程的程序。kubelet 需要持续监控进程，以确定它们何时退出等。通过使用 `ps` 列出进程，你可以确定你的集群中是否有“僵尸”进程，或者是否有特权容器变得失控（创建了许多新的子进程）等。'
- en: 3.3.2 Running a simple Pod
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 运行一个简单的 Pod
- en: 'Before we see how to utilize these commands, let’s take a look at a Pod, using
    our `kind` cluster to create it. Normally, you wouldn’t manually create a Pod
    but, rather, a Deployment, a DaemonSet, or a Job. For now, it’s best to leave
    those high-level constructs out and create a simple, lonely Pod. We’ll create
    a Pod by running `kubectl create` `-f` `pod.yaml` after composing the YAML file
    in the following code snippet. But before we create it, let’s go over two quick
    notes about this YAML file so as not to confuse you:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解如何使用这些命令之前，让我们看看如何使用我们的 `kind` 集群创建一个 Pod。通常，你不会手动创建 Pod，而是创建一个 Deployment、DaemonSet
    或 Job。现在，最好先不考虑这些高级结构，创建一个简单、孤立的 Pod。我们将通过在以下代码片段中编写 YAML 文件后运行 `kubectl create`
    `-f` `pod.yaml` 来创建一个 Pod。但在创建之前，让我们快速过一下这个 YAML 文件的两个注意事项，以免你感到困惑：
- en: '*If you’re wondering what the BusyBox image is all about, the BusyBox Pod is
    just a minimal Linux image that you can run to investigate default container behavior.*
    Although examples oftentimes use the NGINX Pod as a standard, we choose BusyBox
    because it comes with the `ip a` command and bundles other basic utilities. Often
    times, production-grade microservices strip binaries from their containers to
    reduce potential vulnerability footprints.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果你想知道 BusyBox 镜像是什么，BusyBox Pod 只是一个你可以运行的极简 Linux 镜像，用于调查默认容器行为。尽管通常使用 NGINX
    Pod 作为标准，但我们选择 BusyBox，因为它包含了 `ip a` 命令以及其他一些基本实用工具。很多时候，生产级别的微服务会从容器中移除二进制文件以减少潜在的安全漏洞足迹。*'
- en: '*If you’re wondering why we define a* `webapp-port`*, you’re on the right track!*
    It serves no purpose other than to help get you familiar with the syntax of a
    Pod definition. We’re not running any service on port 80, but if you were to replace
    this image with something like NGINX, that port would then be a load-balanced
    endpoint that you can use to point to a Kubernetes service.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果你想知道为什么我们要定义一个* `webapp-port`*，你正在正确的道路上!* 它没有任何作用，除了帮助你熟悉 Pod 定义中的语法。我们不会在端口
    80 上运行任何服务，但如果你要用类似 NGINX 这样的东西替换这个镜像，那么这个端口将是一个负载均衡的端点，你可以用它来指向 Kubernetes 服务。'
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ The label’s metadata lets us select this Pod as a load-balancer target or
    as a filter in a query to the Kubernetes API server.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 标签的元数据让我们可以选择这个 Pod 作为负载均衡的目标或作为对 Kubernetes API 服务器的查询中的过滤器。
- en: ❷ This docker.io image name has to be real and pullable from the internet or
    tagged as a local container image.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个 docker.io 镜像名称必须是真实的，可以从互联网上拉取，或者标记为本地容器镜像。
- en: ❸ Creates the Pod in the Kubernetes default namespace
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在 Kubernetes 默认命名空间中创建 Pod
- en: Not to be confused with the `kind` tool we used to create this cluster, the
    `kind` API field in our Pod definition tells the API server when we create this
    Pod what type of API object it is. If we enter the wrong thing here (for example,
    `Service`), then the API server tries to create a different object. Thus, the
    first part of defining our Pod is defining it as a type (or *kind*) of Pod. Later,
    in this section, we will run a command to see the routing and IP configuration
    of this Pod, so keep this snippet handy!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不要与用于创建此集群的 `kind` 工具混淆，我们在 Pod 定义中的 `kind` API 字段告诉 API 服务器当我们创建此 Pod 时它是什么类型的
    API 对象。如果我们在这里输入错误的内容（例如，`Service`），那么 API 服务器会尝试创建不同的对象。因此，定义我们的 Pod 的第一步是将其定义为一种类型（或
    *kind*）。稍后，在本节中，我们将运行一个命令来查看此 Pod 的路由和 IP 配置，所以请保留这个片段以便使用！
- en: 'After creating the Pod, let’s look at the visibility of its processes to our
    OS when started. It is, indeed, registered in the OS. The following `ps -ax` command
    is a quick and simple way to list all processes on a system, including those that
    might not have a terminal. The *x* is particularly important because we are dealing
    with systems rather than user-level software, and we want a global count of all
    programs running to illustrate process visibility for pedagogical reasons:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Pod 之后，让我们看看其进程在启动时对我们操作系统的可见性。确实，它在操作系统中注册了。下面的 `ps -ax` 命令是一种快速简单的方法，可以列出系统上的所有进程，包括可能没有终端的进程。*x*
    特别重要，因为我们处理的是系统而不是用户级软件，我们想要所有正在运行的程序的全局计数，以说明教学原因：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Counts how many processes were run originally
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算最初运行了多少个进程
- en: ❷ Creates a Pod
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个 Pod
- en: ❸ Counts how many processes are running after Pod creation
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算在 Pod 创建后运行了多少个进程
- en: 3.3.3 Exploring the Pod’s Linux dependencies
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 探索 Pod 的 Linux 依赖关系
- en: We’ve now run a Pod in a cluster. This Pod runs a program, which needs access
    to fundamental compute units like CPU, memory, disk, and so on. How does this
    Pod differ from a regular program? Well, from an end-user perspective, it’s no
    different at all. For example, like any normal program, our Pod
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在集群中运行了一个 Pod。这个 Pod 运行一个程序，该程序需要访问像 CPU、内存、磁盘等基本计算单元。这个 Pod 与常规程序有什么不同？嗯，从最终用户的角度来看，它根本没有任何不同。例如，像任何正常程序一样，我们的
    Pod
- en: Uses shared libraries or OS-specific low-level utilities, allowing it to consume
    keyboard input, list files, and so on.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用共享库或特定于操作系统的低级实用程序，允许它消耗键盘输入、列出文件等。
- en: Has access to a client that can work with an implementation of the TCP/IP stack
    so that network calls and receipts can be made. (These are often called *system
    calls*.)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以访问一个客户端，它可以与 TCP/IP 堆栈的实现一起工作，以便进行网络调用和接收。（这些通常被称为 *系统调用*。）
- en: Needs some kind of memory address space to guarantee that other programs won’t
    overwrite its memory.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要某种内存地址空间来保证其他程序不会覆盖其内存。
- en: When creating this Pod, the kubelet does many of the same activities that anyone
    might undertake when attempting to run a computer program on a server. It
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建此 Pod 时，kubelet 执行了许多任何人在尝试在服务器上运行计算机程序时可能会执行的活动。它
- en: Creates an isolated home for the program to run in (with CPU, memory, and namespace
    limitations)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为程序创建一个隔离的运行环境（带有 CPU、内存和命名空间限制）
- en: Ensures that its home has a working Ethernet connection
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保其家有一个工作的以太网连接
- en: Gives the program access to some basic files for resolving DNS or for accessing
    storage
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给程序访问一些基本文件，用于解析 DNS 或访问存储
- en: Tells the program it’s safe to move in and start up
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉程序它可以安全地进入并启动
- en: Waits for the program to exit
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待程序退出
- en: Cleans up the program’s house and used resources
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理程序的家和使用的资源
- en: We’ll find that almost everything we do in Kubernetes is a replication of regular,
    old administrative tasks that we’ve been doing for decades. In other words, the
    kubelet is just running the Linux system administrator’s playbook for us.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会发现，在 Kubernetes 中我们所做的几乎所有事情都是复制了我们几十年来一直在做的常规管理任务。换句话说，kubelet 只是在为我们运行
    Linux 系统管理员的操作手册。
- en: We can visualize this process as a Pod *life cycle*, a cyclical process that
    reflects the fundamental control loop, which defines what the kubelet itself continually
    does while it’s running (figure 3.2). Because containers in a Pod can die at any
    time, there is a control loop to bring them back to life in these cases. Such
    control loops happen in a “fractal” way throughout Kubernetes. In fact, one might
    say Kubernetes itself is just an intricately organized collection of clever control
    loops that allow us to run and manage containers at large scale in an automated
    fashion.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个过程可视化为 Pod 的 *生命周期*，这是一个循环过程，反映了基本控制循环，它定义了 kubelet 在运行时持续执行的操作（图 3.2）。由于
    Pod 中的容器可能在任何时候死亡，因此存在一个控制循环来在这些情况下使它们复活。在整个 Kubernetes 中，这样的控制循环以“分形”的方式发生。事实上，可以说
    Kubernetes 本身就是一个由巧妙控制循环组成的复杂组织，这些控制循环使我们能够以自动化的方式大规模运行和管理容器。
- en: '![](../Images/CH03_F02_Love.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F02_Love.png)'
- en: Figure 3.2 The kubelet/Pod life cycle control loop
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 kubelet/Pod 生命周期控制循环
- en: One of the lowest-level control loops is the kubelet/Pod life cycle itself.
    In figure 3.2, we represent the termination of the kubelet as a dot. As long as
    the kubelet runs, there is a continuous reconciliation loop, where we can check
    for Pods and start them. Although we reference `nsenter` again as one of the downstream
    actions of the kubelet, note that the use of `nsenter` (which can run and manage
    containers on Linux), is not going to translate to other container runtimes or
    OSs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个最低级别的控制循环就是 kubelet/Pod 生命周期本身。在图 3.2 中，我们将 kubelet 的终止表示为一个点。只要 kubelet
    运行，就存在一个持续的协调循环，我们可以检查 Pod 并启动它们。虽然我们再次引用 `nsenter` 作为 kubelet 的下游操作之一，但请注意，`nsenter`（可以在
    Linux 上运行和管理容器）的使用不会翻译到其他容器运行时或操作系统。
- en: As we will learn shortly, a Pod can be attained ultimately as the result of
    running a variety of these commands in the right order at the right time to enable
    the lovely features we discussed in our previous chapter. The result of our newly
    created Pod shows several status fields, which are worth inspecting.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们很快就会了解到的那样，Pod 最终可以通过在正确的时间和顺序运行各种命令来获得，从而实现我们在上一章中讨论的可爱功能。我们新创建的 Pod 显示了几个状态字段，这些字段值得检查。
- en: Where does Docker fit into all of this?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 在其中扮演什么角色呢？
- en: If you’re somewhat new to Kubernetes, you might be wondering when we’re going
    to start talking about Docker. Actually, we won’t talk much about Docker at all,
    as it’s increasingly a developer tool that is not relevant to server-side container
    solutions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对于 Kubernetes 还有些陌生，你可能想知道我们什么时候开始讨论 Docker。实际上，我们不会过多地讨论 Docker，因为它越来越成为一个与服务器端容器解决方案无关的开发者工具。
- en: Although Kubernetes shipped with native-Docker support for many years, as of
    Kubernetes 1.20, the deprecation process for supporting Docker explicitly is well
    under way, and eventually, Kubernetes itself will have no knowledge whatsoever
    of any container runtime. Thus, although the kubelet maintains the life cycle
    of Pods in terms of their resource usage, it defers to an interface known as the
    CRI (Container Runtime Interface) to start and stop Pods, as well as to pull down
    images for containers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Kubernetes 多年来一直支持原生 Docker，但截至 Kubernetes 1.20，支持 Docker 的弃用过程已经全面展开，最终
    Kubernetes 本身将完全不知道任何容器运行时。因此，尽管 kubelet 在资源使用方面维护 Pod 的生命周期，但它将启动和停止 Pod 以及拉取容器镜像的任务委托给名为
    CRI（容器运行时接口）的接口。
- en: The most common implementation of the CRI is *containerd*, and in fact, Docker
    itself uses containerd under the hood. The CRI represents some (but not all) of
    containerd’s functionality in a minimal interface, making it easy for people to
    implement their own container runtimes for Kubernetes. The standard containerd
    executable presents the kubelet with a CRI, and when this CRI is called, containerd
    (the service) calls programs like runc (for Linux containers) or hcsshim (for
    Windows containers), again, under the hood.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: CRI最常见实现是*containerd*，实际上，Docker本身在底层使用containerd。CRI以最小接口的形式表示containerd的一些（但不是全部）功能，这使得人们很容易为Kubernetes实现自己的容器运行时。标准的containerd可执行文件向kubelet提供CRI，当调用这个CRI时，containerd（服务）会调用runc（Linux容器）或hcsshim（Windows容器）等程序，再次在底层。
- en: 'Once a Pod is running in Kubernetes (or, at least, once Kubernetes knows it’s
    supposed to be running a Pod), you can see that the `Pod` object in the API server
    has new status information. On your own, try running the following to see this
    information:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Pod在Kubernetes中运行（或者至少Kubernetes知道它应该运行一个Pod），你就可以看到API服务器中的`Pod`对象有新的状态信息。你可以尝试运行以下命令来查看这些信息：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You’ll see a large YAML file. Because we promised our Pod its own IP address
    and a healthy place to run its processes, let’s now confirm these resources are
    available. We do this by using `jsonpath` in our query to find specific details.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个大的YAML文件。因为我们承诺我们的Pod有自己的IP地址和运行其进程的健康环境，现在让我们确认这些资源是可用的。我们通过在查询中使用`jsonpath`来找到特定的细节。
- en: Inspecting a Pod using JSONPath
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSONPath检查Pod
- en: 'Filtering out the attributes from `status`, let’s take a look at a few of these
    fields. In the meanwhile, we’ll also use the JSONPath functionality of Kubernetes
    to filter the specific information we want. For example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从`status`中过滤掉属性，让我们看看这些字段中的几个。同时，我们也会使用Kubernetes的JSONPath功能来过滤我们想要的具体信息。例如：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Queries for our Pod’s state
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 查询我们Pod的状态
- en: ❷ Queries for our Pod’s IP address
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 查询我们Pod的IP地址
- en: ❸ Queries for the IP address of the host we’re running on
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查询我们运行的主机的IP地址
- en: Note You may notice that, in addition to the new status information on your
    pod.yaml, you also have some new information in its `spec` stanza. This is because
    the API server may need to fix a few elements of your Pod before submitting it.
    For example, things like `terminationMessagePath` and `dnsPolicy`, which often
    require no changes by a user, can be added for you after you define your Pod.
    In some organizations, you may also have a customized admission controller in
    place, which “looks” at incoming objects and modifies them before they are passed
    to your API server (for example, to add hard CPU or memory limits on containers
    in large data centers).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可能注意到，除了pod.yaml中的新状态信息之外，你还在其`spec`部分有一些新的信息。这是因为API服务器可能需要在提交Pod之前修复一些元素。例如，像`terminationMessagePath`和`dnsPolicy`这样的东西，通常不需要用户进行更改，可以在定义Pod后为你添加。在一些组织中，你可能还实施了一个自定义的准入控制器，它在将对象传递到API服务器之前“查看”传入的对象并对其进行修改（例如，在大型数据中心中为容器添加硬CPU或内存限制）。
- en: In any case, using the previous commands
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，使用之前的命令
- en: We can see our Pod is being monitored by the OS, and it’s status is Running.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看到我们的Pod正在被操作系统监控，并且它的状态是运行中。
- en: We can see that the Pod lives in a separate IP space (called a network namespace)
    from our host, 10.244.0.11/16\.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看到Pod生活在与我们的主机不同的IP空间（称为网络命名空间）中，10.244.0.11/16。
- en: Inspecting the data that we mounted into our Pod
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们挂载到Pod中的数据
- en: 'One such field that Kubernetes graciously gives to all its Pods is the `default-token.`
    volume. This gives our Pods a certificate allowing them to communicate to the
    API server and to “phone home.” In addition to Kubernetes volumes, we also give
    our Pods DNS information. To view this, you can run `mount` inside the Pod by
    executing `kubectl` `exec`. For example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes慷慨地提供给所有Pod的一个字段是`default-token.`卷。这给我们的Pod提供了一个证书，允许它们与API服务器通信并“回家”。除了Kubernetes卷之外，我们还为Pod提供了DNS信息。要查看这些信息，你可以在Pod内部运行`mount`命令，通过执行`kubectl
    exec`。例如：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we can see that the *mount* command, when run inside our container,
    actually shows that the file /etc/resolv.conf (which tells Linux where DNS servers
    are located) is mounted from another location. This location (/dev/sda1) is where
    the volume resides on our host, which has the corresponding resolv.conf file.
    In fact, in our example, there are other entries in `mount` for other files, many
    of which are actually symbolically linked back to our /dev/sda1 directory on the
    host. This directory usually corresponds to a folder in /var/lib/containerd. You
    can locate this file by running
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到，当我们在容器内运行`*mount*`命令时，实际上显示的是文件`/etc/resolv.conf`（它告诉Linux DNS服务器所在的位置）是从另一个位置挂载的。这个位置（`/dev/sda1`）是卷在我们主机上的位置，那里有相应的`resolv.conf`文件。实际上，在我们的例子中，`mount`命令还有其他文件的条目，其中许多实际上是通过符号链接回主机上的`/dev/sda1`目录。这个目录通常对应于`/var/lib/containerd`中的一个文件夹。你可以通过运行以下命令来定位这个文件：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Don’t get too hung up on this detail. It’s part of the underlying implementation
    of the kubelet, but it’s nice to know that these files do exist on your system
    and can be found in a pinch using standard Linux tools (if your cluster is behaving
    badly, for instance).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于纠结这个细节。它是kubelet底层实现的一部分，但知道这些文件确实存在于你的系统中，并且可以在需要时使用标准Linux工具（例如，如果你的集群表现不佳）找到，这很好。
- en: In a VM, the *hypervisor* (the thing that makes VMs) has no idea what processes
    VMs are running. In a containerized environment, however, all processes made by
    containerd (or Docker or any other container runtime) are actively managed by
    the OS itself. This allows the kubelet to do a lot of fine-grained cleanup and
    management tasks, and it also allows the kubelet to expose important information
    about container status to the API server.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机中，*虚拟机管理程序*（创建虚拟机的东西）并不知道虚拟机正在运行什么进程。然而，在容器化环境中，所有由containerd（或Docker或任何其他容器运行时）创建的进程都由操作系统本身积极管理。这允许kubelet执行许多细粒度的清理和管理任务，同时也允许kubelet向API服务器暴露有关容器状态的重要信息。
- en: More importantly, this indicates to us that you as an administrator, and indeed
    the kubelet itself, are capable of managing and querying processes, inspecting
    volumes for those processes, and even killing those processes when necessary.
    Although some of this might be obvious to you, we illustrate this because we want
    to drive home the point that in most Linux environments, the things we call containers
    are just processes created with a few isolated bells and whistles that enable
    them to play nicely with hundreds of other processes in a microservices cluster.
    Pods and processes alike aren’t necessarily all that different from regular programs
    that you might run. In summary, our Pod
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，这表明你作为管理员，以及kubelet本身，能够管理和查询进程，检查这些进程的卷，甚至在必要时终止这些进程。尽管其中一些可能对你来说很显然，我们之所以展示这一点，是因为我们想要强调，在大多数Linux环境中，我们称之为容器的那些东西，只是通过一些隔离的铃声和哨声创建的进程，使它们能够与微服务集群中的数百个其他进程良好地协作。Pod和进程与您可能运行的常规程序并没有太大的不同。总之，我们的Pod
- en: '*Has a storage volume with a certificate for accessing our API server.* This
    gives Pods, in general, a simple way to access the internal Kubernetes API if
    they want to. It is also the basis for the Operator or Controller patterns, which
    allow Kubernetes Pods to create other Pods, services, and so on.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*具有用于访问我们的API服务器的证书的存储卷。`这为Pods提供了一种简单的方法来访问内部Kubernetes API，如果它们想要的话。这也是Operator或Controller模式的基础，这些模式允许Kubernetes
    Pods创建其他Pods、服务等等。'
- en: '*Has an IP address in the 10 subnet that is specific to it.* This isn’t the
    same as the host IP address in the 172 subnet.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*具有一个特定的10子网IP地址。`这与172子网中的主机IP地址不同。'
- en: '*Serves traffic on port 80 of its internal namespace on the IP address 10.244.0.11.*
    Other Pods in our cluster can access this as well.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*在其内部命名空间上的IP地址10.244.0.11的端口80上提供服务。`我们集群中的其他Pod也可以访问这个端口。'
- en: '*Runs happily in our cluster.* It now has a container with a unique PID that
    is entirely manageable and visible to our host.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*在我们的集群中运行得很好。`现在它有一个具有唯一PID的容器，这对于我们的主机来说是完全可管理和可见的。'
- en: Note that we have yet to do something with iptables for routing traffic to our
    Pod. When you create a Pod without a service, you don’t actually set up networking
    in the way Kubernetes is usually designed. Although our Pod’s IP address is findable
    within the cluster, there is no way to load balance traffic to our Pod’s various
    other brothers and sisters. For this, we need labels and label selectors associated
    with services. We will address Kubernetes networking later in chapter 4.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还没有对 iptables 进行操作以将流量路由到我们的 Pod。当你创建一个没有服务的 Pod 时，你实际上并没有按照 Kubernetes
    通常设计的方式设置网络。尽管我们的 Pod 的 IP 地址在集群中是可查找的，但没有任何方法可以将流量负载均衡到 Pod 的其他兄弟和姐妹。为此，我们需要与服务关联的标签和标签选择器。我们将在第
    4 章中稍后讨论 Kubernetes 网络。
- en: Now that you’ve explored the basic functionality of a simple Pod in a real cluster,
    we’ll look at how we can build this functionality on our own by using basic Linux
    primitives. Going through the process of building this functionality *without
    a cluster* exposes you to many core competencies that will improve your understanding
    of how a Kubernetes installation works, how to administer large clusters, and
    how to troubleshoot container runtimes in the wild. Strap in and get ready for
    an exciting ride!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经探索了真实集群中简单 Pod 的基本功能，我们将看看我们如何可以通过使用基本的 Linux 原语来构建这个功能。通过构建这个功能的过程（没有集群）会让你接触到许多核心能力，这将提高你对
    Kubernetes 安装工作原理的理解，如何管理大型集群，以及如何在野外调试容器运行时。系好安全带，准备享受一次刺激的旅程！
- en: 3.4 Building a Pod from scratch
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 从零开始构建 Pod
- en: We’re about to go back in time as we’re going to attempt to build a container
    management system before the existence of Kubernetes. Where should we start? We’ve
    previously gone over four fundamental aspects of our Pod, in particular
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回到过去，因为我们将尝试在 Kubernetes 存在之前构建一个容器管理系统。我们应该从哪里开始？我们之前已经讨论过我们 Pod 的四个基本方面，特别是
- en: Storage
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储
- en: IP addressing
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP 地址分配
- en: Network isolation
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络隔离
- en: Process identification
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程识别
- en: We’ll have to use our base Linux OS to implement this functionality. Fortunately,
    our `kind` cluster already has a basic Linux OS that we can use locally, so we
    don’t need to create a dedicated Linux VM for this exercise.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不使用我们的基础 Linux 操作系统来实现这个功能。幸运的是，我们的 `kind` 集群已经有一个基本的 Linux 操作系统，我们可以用它来本地使用，因此我们不需要为这个练习创建一个专门的
    Linux 虚拟机。
- en: Will this Pod actually work?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Pod 真的能工作吗？
- en: This isn’t the type of Pod you’d run in the real world; it will be fraught with
    manual hacks, and the process we follow to build it won’t scale to production
    workloads. But, at the kernel of what we do here, we will be reflecting the same
    process that the kubelet goes through when creating containers in any cloud or
    data center.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是你会在现实世界中运行的 Pod 类型；它将充满手动操作，我们构建它的过程不会扩展到生产工作负载。但是，在我们所做事情的核心，我们将反映 kubelet
    在任何云或数据中心创建容器时所经过的相同过程。
- en: 'Let’s get into our `kind` cluster and start hacking! This can easily be done
    by listing your `kind` container ID by running `docker` `ps` `|` `grep` `kind`
    `|` `cut` `-d''` `''` `-f` `1` and then by running `docker` `exec` `-t` `-i` `container_id`
    `/bin/sh` to jump into one of these nodes. Because we will edit a text file in
    our `kind` cluster, let’s install the Vim editor or any other editor you might
    be used to with the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入我们的 `kind` 集群并开始动手！这可以通过运行 `docker ps | grep kind | cut -d' ' -f 1` 来列出你的
    `kind` 容器 ID，然后通过运行 `docker exec -t -i container_id /bin/sh` 来跳入这些节点之一。因为我们将编辑
    `kind` 集群中的文本文件，所以让我们使用以下命令安装 Vim 编辑器或你可能习惯使用的任何其他编辑器：
- en: '[PRE13]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In case you’re new to Kubernetes and `kind` (and your head is spinning here),
    yes, you’re right; we’re doing some meta stuff right now. Essentially, we are
    simulating a real cluster as well as the SSH debugging that we all know and love.
    The methodology of running `docker` `exec` on a `kind` cluster container is (roughly)
    the equivalent of `ssh`’ing into a real Kubernetes node in a real cluster.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚接触 Kubernetes 和 `kind`（并且你现在感到有些头晕），是的，你说得对；我们现在正在做一些元操作。本质上，我们正在模拟一个真实的集群以及我们所有人都熟悉和喜爱的
    SSH 调试。在 `kind` 集群容器上运行 `docker exec` 的方法（大致上）相当于在真实集群中的真实 Kubernetes 节点上执行 `ssh`。
- en: 3.4.1 Creating an isolated process with chroot
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 使用 chroot 创建隔离的进程
- en: To begin, we’ll create a container in the most distilled sense—a folder that
    has exactly what it needs to run a Bash shell and absolutely nothing else (as
    figure 3.3 shows). This is done using the famous `chroot` command. (In its early
    days, Docker was referred to as “chroot on steroids.”)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将以最纯净的方式创建一个容器——一个文件夹，它恰好包含运行 Bash shell 所需的一切，绝对没有其他东西（如图 3.3 所示）。这是使用著名的
    `chroot` 命令完成的。（在其早期，Docker 被称为“加强版的 chroot”）
- en: '![](../Images/CH03_F03_Love.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F03_Love.png)'
- en: Figure 3.3 The `chroot` namespace compared with the host root filesystem
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 `chroot` 命名空间与主机根文件系统的比较
- en: 'The purpose of `chroot` is to create an isolated root for a process. There
    are three steps to this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`chroot` 的目的是为进程创建一个隔离的根目录。这个过程有三个步骤：'
- en: Decide what program you want to run and where on your filesystem it should run.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定你想要运行什么程序以及它在你的文件系统中的运行位置。
- en: Create an environment for the process to run. There are many Linux programs
    that live in the lib64 directory, which are required to run even something like
    Bash. These need to be loaded into the new root.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为进程创建一个运行环境。有许多 Linux 程序位于 lib64 目录中，即使运行像 Bash 这样的程序也需要它们。这些需要被加载到新的根目录中。
- en: Copy the program you want to run to the chrooted location.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你想要运行的程序复制到 chroot 位置。
- en: Finally, you can run your program, and it will be in perfect filesystem isolation.
    This means that it won’t be able to see or touch other information on your filesystem
    (it won’t be able to edit files in /etc/ or /bin/, for example).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以运行你的程序，它将在完美的文件系统隔离中运行。这意味着它将无法看到或触摸你的文件系统上的其他信息（例如，它无法编辑 /etc/ 或 /bin/
    中的文件）。
- en: Sound familiar? It should! When we run Docker containers, whether in Kubernetes
    or not, we always have this type of clean, isolated environment to run in. In
    fact, if you take a gander at issues in Kubernetes itself, you’re guaranteed to
    find many past and present issues and questions around `chroot`-based functionality.
    Now, let’s see how `chroot` works by running a Bash terminal in a chrooted namespace.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来熟悉吗？应该如此！当我们运行 Docker 容器时，无论是在 Kubernetes 中还是不在 Kubernetes 中，我们总是有这种干净、隔离的环境来运行。实际上，如果你查看
    Kubernetes 自身的 issue，你肯定能找到许多关于基于 `chroot` 功能的过去和现在的问题和疑问。现在，让我们通过在 chroot 命名空间中运行一个
    Bash 终端来了解 `chroot` 的工作原理。
- en: 'The following script creates a box where we can run a Bash script or other
    Linux program. This has no other visibility into the broader system and no conflicts,
    meaning that if we want to run `rm -rf /` inside the box, we can do so without
    destroying all the files in our actual OS. Of course, we don’t recommend you try
    this at home, unless you’re on a disposable machine, because one tiny mistake
    might end up in a lot of data loss. For our purposes, we’ll store this script
    locally as chroot.sh, in case we want to reuse it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本创建了一个盒子，我们可以在其中运行 Bash 脚本或其他 Linux 程序。它对更广泛系统没有其他可见性，也没有冲突，这意味着如果我们想在盒子内运行
    `rm -rf /`，我们可以这样做而不会破坏我们实际操作系统中的所有文件。当然，我们不推荐你在家里尝试这样做，除非你在一个可丢弃的机器上，因为一个小错误可能会导致大量数据丢失。为了我们的目的，我们将此脚本作为
    chroot.sh 本地存储，以防我们想要重用它：
- en: '[PRE14]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Makes our box with the bin and lib directories as dependencies for our Bash
    program
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使我们的盒子具有 bin 和 lib 目录，作为我们的 Bash 程序的依赖项
- en: ❷ Copies all the programs from our base OS into this box so we can run Bash
    in our root directory
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将我们基础操作系统中的所有程序复制到这个盒子中，这样我们就可以在我们的根目录中运行 Bash
- en: ❸ Copies the library dependencies of these programs into the lib/ directories
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将这些程序的库依赖复制到 lib/ 目录中
- en: ❹ Mounts the /proc directory to this location
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将 /proc 目录挂载到这个位置
- en: '❺ This is the important part: we start our isolated Bash process in a sandboxed
    directory.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 这部分很重要：我们在一个沙盒目录中启动我们的隔离 Bash 进程。
- en: Remember that our root directory’s forward slash (`/`) will not have any programs
    that we don’t explicitly load. This means that `/` has no global access to our
    regular Linux path, where normal programs you run every day live. Thus, in the
    previous code example, we copied `kill` and `ps` (two essential programs) directly
    into our /home/ namespace/box/bin directory. And because we mounted the /proc
    directory into our chrooted process, we can see and access the processes in our
    host. This allows us to use `ps` to explore the security boundaries of our chrooted
    process. At this point, you should see that
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们的根目录的正斜杠（`/`）将不会有我们不明确加载的程序。这意味着 `/` 对我们的常规 Linux 路径没有全局访问权限，那里有我们每天运行的正常程序。因此，在前面的代码示例中，我们将
    `kill` 和 `ps`（两个基本程序）直接复制到我们的 /home/namespace/box/bin 目录中。而且因为我们已经将 /proc 目录挂载到我们的
    chroot 进程中，我们可以看到并访问主机中的进程。这允许我们使用 `ps` 来探索 chroot 进程的安全边界。此时，你应该看到：
- en: Some commands like `cat` or `ps` aren’t available in our chrooted process, while
    `ps` and `kill` will be runnable as in any Linux OS.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些命令如 `cat` 或 `ps` 在我们的 chroot 进程中不可用，而 `ps` 和 `kill` 将可以在任何 Linux 操作系统中运行。
- en: Other commands that run (like `ls /`) return quite different results than what
    you’d normally see in a full-blown OS.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他运行中的命令（如 `ls /`）返回的结果与你在完整的操作系统中所看到的结果大不相同。
- en: 'Unlike what you might see when running a VM on your host, there is no increased
    performance cost or latency to running or executing things in this chrooted environment,
    because it’s just a regular Linux command. In case you didn’t run this on your
    own, the results look something like this:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与你在主机上运行虚拟机时可能看到的情况不同，在这个 chroot 环境中运行或执行事物没有增加性能成本或延迟，因为这只是一个常规的 Linux 命令。如果你没有亲自运行它，结果看起来可能像这样：
- en: '[PRE15]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is instructive to run `ls` from the root of a Linux OS if you have one around
    as a comparison. When you’re done exploring your barren `chroot` desert, go ahead
    and type `exit` to return to your regular OS. Whew, that was scary!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一台 Linux 操作系统作为比较，从其根目录运行 `ls` 是很有教育意义的。当你探索完你那荒芜的 `chroot` 沙漠后，继续输入 `exit`
    返回到你的常规操作系统。哇，那真是个惊吓！
- en: Isolated `chroot` environments are on the most foundational building blocks
    of the container revolution that we live in today, although it was known for quite
    some time as “the poor man’s VM.” The chroot command is often used by Linux administrators
    and Python developers to perform isolated testing and to run specific programs.
    If you read the earlier section with the “chroot on steroids” reference, maybe
    this is now beginning to make sense.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的 `chroot` 环境是我们今天所生活的容器革命的最基础的构建块之一，尽管它长期以来一直被称为“穷人的虚拟机”。`chroot` 命令通常被 Linux
    管理员和 Python 开发者用来执行隔离测试和运行特定程序。如果你阅读了前面提到的“加强版的 chroot”部分，现在可能开始理解这一点了。
- en: 3.4.2 Using mount to give our process data to work with
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 使用 `mount` 为我们的进程提供数据
- en: 'Containers typically need access to storage that lives elsewhere: in the cloud
    or on a host machine. The `mount` command allows you to take a device and expose
    it to any directory under the `/` (root) directory in your OS. You typically use
    `mount` to expose disks as folders. In our running `kind` cluster, for example,
    issuing `mount` shows us several folders managed by Kubernetes, which are exposed
    to specific containers in a specific location.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通常需要访问存储在别处的存储：在云端或在主机机器上。`mount` 命令允许你将一个设备暴露在你操作系统 `/`（根）目录下的任何目录中。你通常使用
    `mount` 来将磁盘作为文件夹暴露。例如，在我们的运行中的 `kind` 集群中，执行 `mount` 会显示由 Kubernetes 管理的几个文件夹，这些文件夹被暴露在特定位置的具体容器中。
- en: The simplest use of `mount` from an administrative perspective is to create
    a well-known, constant folder location for a disk point that can live in some
    other arbitrary place. For example, let’s say we want to run the previous program,
    but we want it to write data to a temporary place that we can scrap later. We
    could do a simple operation such as `mount` `--bind` `/tmp/` `/home/namespace/box/data`
    to create a /data directory in the previous chrooted program. Then, any user in
    that namespace would conveniently have a /data directory which they can use to
    access files in our /tmp directory.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从管理角度来看，`mount` 的最简单用途是为一个可以生活在其他任意位置的磁盘点创建一个已知、恒定的文件夹位置。例如，假设我们想要运行前面的程序，但我们希望它将数据写入一个我们可以稍后丢弃的临时位置。我们可以执行一个简单的操作，如
    `mount` `--bind` `/tmp/` `/home/namespace/box/data`，在先前的 chroot 程序中创建一个 /data
    目录。然后，该命名空间中的任何用户都可以方便地拥有一个 /data 目录，他们可以使用它来访问我们的 /tmp 目录中的文件。
- en: 'Note that this opens up a security hole! After we mount the contents of /tmp
    to containers, anybody can now manipulate or read its contents. This is actually
    why the `hostPath` functionality of Kubernetes volumes is often disabled in production
    clusters. In any case, let’s confirm that we can get some data into our container
    that we created in the last section using a few basic Linux primitives:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这会打开一个安全漏洞！在我们将/tmp的内容挂载到容器之后，任何人现在都可以操纵或读取其内容。这实际上就是为什么Kubernetes卷的`hostPath`功能在生产集群中通常被禁用的原因。无论如何，让我们通过使用一些基本的Linux原语来确认我们能否将一些数据放入我们在上一节中创建的容器中：
- en: '[PRE16]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And there you have it! You’ve now created something that’s much like a container
    and that now has access to storage. We’ll look at the more advanced aspects of
    containerization later, including namespaces for protecting CPU, memory, and network-related
    resources. Now, just for fun, let’s run `ps` and see what other processes are
    floating around in our container. Notice that we’ll see ours and a few other processes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你现在创建了一个类似于容器的东西，并且现在可以访问存储。我们将在稍后探讨容器化的更高级方面，包括用于保护CPU、内存和网络相关资源的命名空间。现在，为了好玩，让我们运行`ps`并看看在我们的容器中漂浮着哪些其他进程。注意，我们会看到我们的进程和一些其他进程：
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 3.4.3 Securing our process with unshare
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3 使用unshare保护我们的进程
- en: Great! So far, we’ve created a sandbox for our process and a folder that can
    penetrate the sandbox. Seems pretty close to a Pod, right? Not yet. Although our
    chrooted program is isolated from other files (for example, when we run `ls` inside
    of it, we only see the files explicitly mounted in the chroot0.sh script), is
    it secure? It turns out that putting blinders on a process isn’t quite the same
    as securing it. As a quick example
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！到目前为止，我们已经为我们的流程创建了一个沙盒，以及一个可以穿透沙盒的文件夹。这看起来已经很接近Pod了，对吧？还不是。尽管我们的chroot程序与其他文件隔离（例如，当我们在这个程序内部运行`ls`时，我们只能看到在chroot0.sh脚本中明确挂载的文件），但这是否安全呢？结果证明，给一个进程戴上眼罩并不完全等同于保护它。作为一个简单的例子
- en: Run `ps` `-ax` inside your `kind` cluster by having Docker execute into it as
    we did earlier.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过让Docker像我们之前做的那样执行到`kind`集群中，在`kind`集群内部运行`ps -ax`。
- en: Grab the ID of the kubelet (for example, 744). To make this easier, you can
    run `ps` `-ax` `|` `grep` `kubelet`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取kubelet的ID（例如，744）。为了使这个过程更容易，你可以运行`ps -ax | grep kubelet`。
- en: Run the chroot0.sh namespace script again.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行chroot0.sh命名空间脚本。
- en: Run `kill` `744` at the `bash-5.0#` prompt.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bash-5.0#`提示符下运行`kill 744`。
- en: You’ll immediately see that you just killed the kubelet! Even though our chrooted
    process couldn’t access other folders (because we moved the location of `/` to
    a new root), it can find and kill critical system processes in one fell swoop.
    Thus, if this was our container, we would have definitely just found a CVE (Common
    Vulnerabilities and Exposures) liability that could bring down an entire cluster.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你会立即看到你刚刚杀死了kubelet！尽管我们的chroot程序无法访问其他文件夹（因为我们把`/`的位置移动到了一个新的根目录），但它可以一举找到并杀死关键系统进程。因此，如果这是我们容器的话，我们肯定刚刚发现了一个CVE（常见漏洞和暴露）的漏洞，这可能会使整个集群崩溃。
- en: If you want to be really naughty, you can even kill this process by running
    `kill 74994`. This results in the `bash-5.0#`-terminated line being printed in
    a final gasp by your unsuspecting chroot0.sh process. Thus, not only can other
    processes see the chroot0 process, but they have the power to kill and control
    it as well. This is where the `unshare` command comes into play.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的很淘气，甚至可以通过运行`kill 74994`来结束这个进程。这会导致`bash-5.0#`终止行被你的未察觉的chroot0.sh进程在最后的喘息中打印出来。因此，不仅其他进程可以看到chroot0进程，他们还有权结束和控制它。这就是`unshare`命令发挥作用的地方。
- en: Recall when we “looked around” and saw a few Pods with larger numbers for their
    PIDs? This tells us that our process is able to access the proc directory to see
    what’s going on. One of the first problems you might need to solve if building
    a production containerization environment is *isolation*. If you run `ps -ax`
    from this inside of this process, it will be immediately obvious why isolation
    is important to solve; if a container has full access to the host, it could damage
    it permanently, for example, by killing the kubelet process or deleting system-critical
    files.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当我们“四处张望”时，看到了一些PID较大的Pod？这告诉我们我们的进程能够访问proc目录以查看发生了什么。如果你在构建生产容器化环境时需要解决的首要问题之一是*隔离*。如果你从这个进程内部运行`ps
    -ax`，你会立即明白隔离为什么很重要；如果一个容器可以完全访问主机，它可能会永久性地损坏它，例如，通过杀死kubelet进程或删除系统关键文件。
- en: 'Using the `unshare` command, however, we can use `chroot` to run Bash in an
    isolated terminal with a truly disengaged process space. That is, this time, we
    won’t be able to kill the kubelet. The following example uses the `unshare` command
    to accomplish this bit of isolation:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`unshare`命令，我们可以使用`chroot`在独立的终端中运行Bash，并具有真正分离的进程空间。也就是说，这次我们将无法杀死kubelet。以下示例使用`unshare`命令来完成这项隔离：
- en: '[PRE18]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Creates a new shell running in a namespace
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在命名空间中创建一个新的shell
- en: ❷ Observes all processes visible to the namespace; seems kind of low, right?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 观察命名空间中可见的所有进程；这似乎有点低，对吧？
- en: Wow! Our previous process thought it was running as 79455, but now it’s running
    in the exact same container. This process started with the `unshare` command actually
    “thinking” that its PID is 1\. Normally, PID 1 is the process ID of the first
    thing that comes alive in your OS (systemd). Thus, this time around, by using
    `unshare` to launch `chroot`, we have
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们之前的过程认为它在以79455的身份运行，但现在它正在精确相同的容器中运行。这个进程实际上是从`unshare`命令开始的，它“认为”它的PID是1。通常，PID
    1是操作系统（systemd）中第一个活跃进程的进程ID。因此，这次，通过使用`unshare`来启动`chroot`，我们做到了
- en: An isolated process
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个独立的进程
- en: An isolated filesystem
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个独立的文件系统
- en: The ability to still edit specific files from our filesystem in /tmp
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仍然能够从我们的文件系统中编辑/tmp中的特定文件
- en: This is now beginning to look a lot like a Kubernetes Pod. In fact, if you `exec`
    into any running Kubernetes Pod, you’ll see a similar PS (Process Status) table.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它开始看起来非常像Kubernetes Pod。实际上，如果你`exec`进入任何正在运行的Kubernetes Pod，你会看到一个类似的PS（进程状态）表。
- en: 3.4.4 Creating a network namespace
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.4 创建一个网络命名空间
- en: 'Although the previous command isolated the process from our other processes,
    it still uses the same network. If we want to run the same program with a new
    network, we can again use the `unshare` command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管之前的命令将进程与其他进程隔离，但它仍然使用相同的网络。如果我们想用新的网络运行相同的程序，我们还可以再次使用`unshare`命令：
- en: '[PRE19]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we compare this Pod with a real Pod running in a normal Kubernetes cluster,
    we will see a single, more important distinction: the lack of a functioning `eth0`
    device. If we were to run our earlier BusyBox Pod with the `ip a` (which we will
    do in the next section), we would see a much more vibrant network with a usable
    `eth0` device. This is the difference between a container that has a network (often
    known as a CNI in the Kubernetes world) and a chrooted process. As mentioned earlier,
    chrooted processes are the heart of containerization, Docker, and ultimately,
    Kubernetes itself, but they aren’t in and of themselves useful for running containerized
    applications because of these much needed accoutrements.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个Pod与在正常Kubernetes集群中运行的Pod进行比较，我们会看到一个单一、更重要区别：缺少一个功能正常的`eth0`设备。如果我们运行我们之前带有`ip
    a`（我们将在下一节中这样做）的BusyBox Pod，我们会看到一个具有可用的`eth0`设备的更加活跃的网络。这是具有网络（在Kubernetes世界中通常称为CNI）的容器和chroot进程之间的区别。如前所述，chroot进程是容器化、Docker以及最终Kubernetes本身的核心，但它们本身并不仅仅对运行容器化应用有用，因为这些必需的附件。
- en: 3.4.5 Checking whether a process is healthy
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.5 检查进程是否健康
- en: 'As an exercise for you, run `exit` and get back into your regular terminal
    in our `kind` cluster. Do you notice a difference between the output of `ip a`?
    You certainly should! In fact, if you run in an isolated network, the cURL program
    (whose command can be copied in just like `kill` and `ls`) will not work to pull
    down information from outside addresses, whereas it works just fine when running
    inside the original chrooted namespace. The reason is that when we created a new
    network namespace, we lost the routing and IP information for our container, which
    was inherited from the `hostNetwork` namespace. To demonstrate this, run `curl`
    `172.217.12.164` (this is the static IP address of google.com) in these two scenarios:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，运行`exit`并回到我们`kind`集群中的常规终端。你注意到`ip a`的输出有区别吗？你当然应该注意到！实际上，如果你在一个独立的网络中运行，cURL程序（其命令可以像`kill`和`ls`一样复制）将无法从外部地址获取信息，而它在原始chroot命名空间内运行时却可以正常工作。原因是当我们创建一个新的网络命名空间时，我们失去了从`hostNetwork`命名空间继承的容器路由和IP信息。为了演示这一点，运行`curl`
    `172.217.12.164`（这是google.com的静态IP地址）在这两种场景下：
- en: Running chroot0.sh
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行chroot0.sh
- en: Running the previous `unshare` command
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行之前的`unshare`命令
- en: In both cases, you are running a chrooted process; however, in the latter case,
    the process has a new network and process namespace. Although the process namespace
    seems to be OK, the network namespace looks a little empty compared to a typical
    real-world process (for example, there’s no meaningful IP information in the previous
    example). Let’s take a look at what a “real” container networking stack looks
    like.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你都在运行一个chroot进程；然而，在后一种情况下，进程有一个新的网络和进程命名空间。尽管进程命名空间看起来似乎没问题，但与典型的现实世界进程相比，网络命名空间看起来有点空。让我们看看一个“真实”的容器网络堆栈是什么样的。
- en: 'Let’s recreate our original pod.yaml that ran a BusyBox container. This time,
    we’ll take a look at its networking information and then we can ruthlessly delete
    it again. Note that there have been cases where CNI providers exhibit bugs when
    restarting containers fast. In that case, containers are launched without an IP
    address. This comparison is an important one to keep in mind when debugging container
    networking errors in production scenarios. Concretely, the restarting of StatefulSet
    containers, which are meant to preserve IP addresses, is a common scenario wherein
    a container’s networking stack might, unfortunately, resemble the previous scenario.
    The following code illustrates what a container has for a network (as contrasted
    with our chrooted process in the previous section):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新创建之前运行BusyBox容器的原始pod.yaml文件。这次，我们将查看其网络信息，然后我们可以无情地再次删除它。请注意，在快速重启容器时，CNI提供者可能会出现错误。在这种情况下，容器将没有IP地址启动。在生产场景中调试容器网络错误时，这种比较是一个需要记住的重要点。具体来说，StatefulSet容器的重启，这些容器旨在保留IP地址，是一个容器网络堆栈可能不幸地类似于之前场景的常见场景。以下代码说明了容器拥有的网络（与上一节中的chroot进程相比）：
- en: '[PRE20]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Creates the original pod.yaml example from earlier in this chapter
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建本章早些时候的原始pod.yaml示例
- en: ❷ Runs a command to list its network interfaces
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 运行一个命令来列出其网络接口
- en: We see a stark contrast here. In the previous process namespace, where we couldn’t
    even run a simple `curl` command, we had no `eth0` device, but in this container,
    we clearly do. You can delete this pod.yaml file if you want. And, as usual, there’s
    no need for any hard feelings—BusyBox containers don’t take themselves too seriously.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了鲜明的对比。在前一个进程命名空间中，我们甚至无法运行一个简单的`curl`命令，我们没有`eth0`设备，但在这个容器中，我们显然有。如果你想删除这个pod.yaml文件，可以这样做。而且，像往常一样，没有必要有任何负面情绪——BusyBox容器并不太认真对待自己。
- en: 'We’ll revisit some networking concepts again in the context of iptables and
    IP routing later in this chapter. First, let’s finish our initial tour of Linux
    container creation primitives. Then we’ll look at the most commonly toggled parameter
    for typical Kubernetes applications in production: cgroup’s `limits`.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面关于iptables和IP路由的背景下再次回顾一些网络概念。首先，让我们完成对Linux容器创建原语的初步探索。然后，我们将查看典型Kubernetes应用程序在生产中最常调整的参数：cgroup的`limits`。
- en: 3.4.6 Adjusting CPU with cgroups
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.6 使用cgroups调整CPU
- en: 'Control groups (abbreviated as *cgroups*) are those knobs we all know and love.
    These allow us to give more or less CPU and memory to applications running in
    our clusters, which need that extra boost of vigor. If you run Kubernetes at work,
    you’ve likely turned these knobs on and off before. We can easily amend our earlier
    BusyBox container to use more or less CPU by issuing the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 控制组（简称*cgroups*）是我们所有人都熟悉并喜爱的旋钮。这些旋钮允许我们给在集群中运行的应用程序提供更多或更少的CPU和内存，这些应用程序需要额外的活力。如果你在工作中运行Kubernetes，你很可能已经开关过这些旋钮。我们可以通过以下命令轻松修改我们之前的BusyBox容器，以使用更多或更少的CPU：
- en: '[PRE21]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Tells Kubernetes to create a cgroup to limit (or not) available CPU
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 告诉Kubernetes创建一个cgroup来限制（或不限制）可用的CPU
- en: 3.4.7 Creating a resources stanza
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.7 创建资源段落
- en: 'We’ll manually walk through the steps that the kubelet goes through when we
    define a cgroup’s limits. Note that the actual way that this is defined can be
    configured in any given Kubernetes distribution by the `--cgroup-driver` flag.
    (*Cgroup drivers* are the architectural components in Linux that are used to allocate
    cgroup resources, and typically, we use systemd as the Linux driver.) Nevertheless,
    the core logical steps of running a container in Kubernetes, which involve making
    a suitable sandbox for the process to execute inside of, are essentially the same,
    even if you deviate from a traditional containerd/Linux architecture. In fact,
    with Windows kubelets, the same `resources` stanza is honored using an entirely
    different set of implementation details. To define the cgroup’s limits, use these
    steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将手动走过kubelet在定义cgroup限制时经过的步骤。请注意，实际上这种方式可以在任何给定的Kubernetes发行版中通过`--cgroup-driver`标志进行配置。（*Cgroup驱动*是Linux中的架构组件，用于分配cgroup资源，通常我们使用systemd作为Linux驱动。）尽管如此，在Kubernetes中运行容器的核心逻辑步骤，涉及为进程创建一个合适的沙盒来执行，基本上是相同的，即使你偏离了传统的containerd/Linux架构。实际上，对于Windows
    kubelet，相同的`resources`部分使用完全不同的实现细节来尊重。要定义cgroup的限制，请使用以下步骤：
- en: Create a PID (we already did this). This is called the Pod sandbox in Kubernetes.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个PID（我们已这样做）。这在Kubernetes中被称为Pod沙盒。
- en: Write the limits for that PID to the OS.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该PID的限制写入操作系统。
- en: 'First, from inside your running chroot0 script, get its PID by running `echo
    $$`. Jot this number down. For us, the value was 79455\. Next, we’ll go through
    a series of steps to put this particular process in a situation where it can only
    use a small number of bytes. In doing so, we’ll be able to estimate how much memory
    the `ls` command needs to execute:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从你的运行中的chroot0脚本内部，通过运行`echo $$`来获取其PID。把这个数字记下来。对我们来说，这个值是79455。接下来，我们将通过一系列步骤将这个特定的进程置于只能使用少量字节的情境中。这样做，我们就能估算出`ls`命令执行所需的内存量：
- en: '[PRE22]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Creates a cgroup
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个cgroup
- en: ❷ Allocates our container only 10 bytes of memory, making it incapable of doing
    basic work
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 只为我们的容器分配10字节内存，使其无法进行基本工作
- en: ❸ Ensures the container doesn’t allocate swap space (Kubernetes almost always
    runs this way)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 确保容器不分配交换空间（Kubernetes几乎总是这样运行）
- en: ❹ Tells our OS that the process for this cgroup is 79455 (the chroot0 Bash process)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 告诉我们的操作系统，这个cgroup的进程是79455（chroot0 Bash进程）
- en: 'Note that, in the example, creating the /chroot0 directory triggers an OS action
    to make a full cgroup that contains memory, CPU, and so on. Now, going back into
    your Bash terminal started in the chroot0.sh script, a simple command like `ls`
    will fail. Depending on your OS, you may get another equally dismal response as
    the one that follows; however, either way, this command should fail:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在示例中，创建/chroot0目录会触发操作系统动作来创建一个包含内存、CPU等在内的完整cgroup。现在，回到你在chroot0.sh脚本中启动的Bash终端，一个简单的命令如`ls`将会失败。根据你的操作系统，你可能得到另一个同样令人沮丧的响应，然而，无论如何，这个命令都应该失败：
- en: '[PRE23]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That’s it! You’ve now created your own process that is isolated from other files,
    limited in its memory footprint, and also runs in an isolated process space, where
    it thinks it’s the only process in the entire world. This is the natural state
    of being for any Pod in a Kubernetes cluster. From here on out, we’ll explore
    how Kubernetes expands this baseline of functionality to enable a complex, dynamic,
    and resilient distributed system.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你现在已经创建了自己的进程，它与其他文件隔离，内存占用有限，并且在一个隔离的进程空间中运行，它认为自己是世界上唯一的进程。这是Kubernetes集群中任何Pod的自然状态。从现在开始，我们将探讨Kubernetes如何扩展这个功能基线，以实现一个复杂、动态和健壮的分布式系统。
- en: 3.5 Using our Pod in the real world
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 在现实世界中使用我们的Pod
- en: A real container is depicted in figure 3.4\. Although we’ve learned a lot in
    this chapter, it’s best to keep in mind that a typical microservice might need
    to communicate with a lot of other services, which often means mounting new certificates
    to those. Additionally, discovering other services using internal DNS is always
    tricky and is an enormous part of the benefit of the Kubernetes model for managing
    microservices at scale. Because we didn’t have a chance to add the ability to
    query an API for internal services and we didn’t explore the automated injection
    of credentials to talk to such services in a secure manner, we can’t say that
    our tiny prototypical cgroup and namespaces example can be used in the real world.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4展示了真实容器的示例。尽管我们在这个章节中学到了很多，但最好记住，一个典型的微服务可能需要与许多其他服务进行通信，这通常意味着需要将这些服务挂载到新的证书上。此外，使用内部DNS发现其他服务总是很棘手，这是Kubernetes模型在规模上管理微服务的巨大优势之一。因为我们没有机会添加查询内部服务API的能力，也没有探索以安全方式与这些服务进行自动注入凭据，所以我们不能说我们的微型原型cgroup和命名空间示例可以在现实世界中使用。
- en: In figure 3.4, you’ll note that our container is able to talk to other containers
    in our cluster. In order for this to happen, it needs an IP address. Because our
    Pod was created without a properly configured network namespace and distinct IP
    address, however, it will not be able to make any kind of direct TCP connections
    to its downstream dependent services.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.4中，你会注意到我们的容器能够与集群中的其他容器通信。然而，由于我们的Pod是在没有正确配置网络命名空间和独立IP地址的情况下创建的，因此它将无法与其下游依赖服务建立任何类型的直接TCP连接。
- en: '![](../Images/CH03_F04_Love.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F04_Love.png)'
- en: Figure 3.4 An example of a real container
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 容器的一个示例
- en: We’ll now dive a little bit into what it means to have a networked container.
    Recall that earlier, when we attempted to look at this aspect of our Bash process,
    we saw that it only had one IP address, and it wasn’t specific to our container.
    This means that there will be no way to route incoming traffic to any service
    that we run in that process over a port. (Note that we’re not suggesting anyone
    run a web server in Bash, but we used Bash as a metaphor for any program, including
    the most common type of containers, TCP services.)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将稍微深入探讨拥有网络化容器意味着什么。回想一下，在我们之前尝试查看Bash进程的这个方面时，我们看到了它只有一个IP地址，并且这个IP地址并不是针对我们的容器的。这意味着将无法将传入流量路由到我们在该进程中运行的任何服务的端口上。（请注意，我们并不是建议任何人在Bash中运行Web服务器，但我们使用Bash作为任何程序，包括最常见的容器类型，TCP服务的隐喻。）
- en: To begin to illuminate this part of the puzzle, we’ll now briefly learn about
    some basic Linux networking primitives. This sets the stage for the various aspects
    of Kubernetes networking that we’ll cover later.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始阐明这个谜团的一部分，我们现在将简要了解一些基本的Linux网络原语。这为我们将要覆盖的Kubernetes网络的各种方面奠定了基础。
- en: 3.5.1 The networking problem
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1 网络问题
- en: Any Kubernetes container might need to have
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Kubernetes容器可能都需要
- en: Traffic routed directly to it for in-cluster or Pod-to-Pod connectivity
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接将流量路由到它以实现集群内或Pod到Pod的连接
- en: Traffic routed out of it to access another Pod or the internet
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将流量从它路由出去以访问另一个Pod或互联网
- en: Traffic load balanced to it to serve as an endpoint behind a service with a
    static IP address
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将流量负载均衡到它，作为具有静态IP地址的服务后端端点
- en: To allow these operations, we need metadata about Pods to be published to other
    parts of Kubernetes (this is the API Server’s job), and we need to constantly
    monitor their state (the kubelet’s job) so that this state is updated and populated
    over time. Pods, thus, have a lot more than a container command and a Docker image.
    They have *labels* and well-defined *specifications* for how their state is published,
    so they can be recreated on the fly alongside a cast of kubelet-provided functionality.
    This ensures IP addresses and DNS rules are always up to date. Labels are self-evident
    in the schema of a Pod. By specifications, we mean to say that Pods have well-defined
    states, restart logic, and guarantees around IP address reachability within a
    cluster.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许这些操作，我们需要将Pod的元数据发布到Kubernetes的其他部分（这是API服务器的任务），并且我们需要持续监控它们的状态（kubelet的任务），以确保这个状态随着时间的推移得到更新和填充。因此，Pod不仅仅有容器命令和Docker镜像。它们有*标签*和如何发布其状态的明确*规范*，这样它们就可以在kubelet提供的功能旁边即时重建。这确保了IP地址和DNS规则始终是最新的。标签在Pod的模式中是显而易见的。当我们提到规范时，我们的意思是Pod有明确的状态、重启逻辑以及关于集群内IP地址可达性的保证。
- en: Note that we’ll again use a Linux environment to explore these aspects. You
    are welcome to rebuild your `kind` cluster if you want, in case you broke something
    in the furious hacking in the previous sections. You can do this by running `kind`
    `delete cluster` `--name=kind` followed by `kind` `create` `cluster`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还将再次使用 Linux 环境来探索这些方面。如果您愿意，可以重新构建您的 `kind` 集群，以防在前面的章节中疯狂破解时破坏了某些内容。您可以通过运行
    `kind` `delete cluster` `--name=kind` 然后跟 `kind` `create` `cluster` 来完成此操作。
- en: 3.5.2 Utilizing iptables to understand how kube-proxy implements Kubernetes
    services
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.2 利用 iptables 理解 kube-proxy 如何实现 Kubernetes 服务
- en: Kubernetes services define an API contract that says, “If you access this IP
    address, you’ll forward to one of many possible endpoints automatically.” They
    are, thus, the backbone of the Kubernetes user experience when it comes to deploying
    microservices. In most clusters, these networking rules are entirely implemented
    by the `kube-proxy` that’s most often configured to use the iptables program to
    do low-level network routing.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 服务定义了一个 API 合同，表示“如果您访问此 IP 地址，您将自动转发到许多可能的端点之一。”因此，它们是 Kubernetes
    用户在部署微服务时的用户体验的骨干。在大多数集群中，这些网络规则完全由 `kube-proxy` 实现，`kube-proxy` 通常配置为使用 iptables
    程序进行低级网络路由。
- en: 'The iptables program adds rules to the kernel, which are then processed linearly
    to deal with network traffic, and it is the most common way that Kubernetes services
    are implemented in order to route traffic to Pods. Note that iptables is not required
    for basic Pod networking (that is handled by the CNI; however, almost any real-world
    Kubernetes cluster is consumed by the end users through services). Thus, the iptables
    and its various incantations are one of the most fundamental primitives required
    for reasoning about a Kubernetes network. In a traditional setting (outside of
    Kubernetes), each iptables rule is appended to the kernel’s networking stack by
    using the `-A ...` syntax like so:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: iptables 程序向内核添加规则，然后按顺序处理以处理网络流量，这是 Kubernetes 服务实现路由流量的最常见方式。请注意，iptables
    对于基本的 Pod 网络不是必需的（这由 CNI 处理；然而，几乎任何现实世界的 Kubernetes 集群都是通过服务被最终用户消费的）。因此，iptables
    及其各种变体是推理 Kubernetes 网络的最基本原语之一。在传统设置（Kubernetes 之外）中，每个 iptables 规则都通过使用 `-A
    ...` 语法附加到内核的网络堆栈，如下所示：
- en: '[PRE24]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This command says to drop any traffic coming from 10.1.2.3\. However, a Pod
    needs a lot more than a few firewall rules. It needs at least
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令指示丢弃来自 10.1.2.3 的任何流量。然而，Pod 需要的不仅仅是几条防火墙规则。它至少需要
- en: The ability to accept traffic as a service endpoint
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够作为服务端点接受流量
- en: The ability to send traffic to the outside world from its own endpoint
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够从其自己的端点向外部世界发送流量
- en: The ability to track ongoing TCP connections (in Linux, this is done with the
    conntrack module, a part of the Linux kernel)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够跟踪正在进行的 TCP 连接（在 Linux 中，这是通过 conntrack 模块完成的，它是 Linux 内核的一部分）
- en: Let’s see how real service networking rules (running in `kind`) are implemented.
    We won’t be reusing our Pod anymore because to attach it to an IP address, we
    would actually need a running, routable software-defined network. Instead, we’ll
    keep it simple. Let’s look at the `iptables-save | grep hostnames` command, which
    shows all of the glue being used to hold our network together.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看真实的网络服务规则（在 `kind` 中运行）是如何实现的。我们不会再次使用我们的 Pod，因为要将它连接到 IP 地址，实际上需要一个正在运行且可路由的软件定义网络。相反，我们将保持简单。让我们看看
    `iptables-save | grep hostnames` 命令，它显示了所有用于将我们的网络连接在一起的粘合剂。
- en: 3.5.3 Using the kube-dns Pod
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.3 使用 kube-dns Pod
- en: The `kube-dns` Pod is a good example to study because it represents the type
    of Pod you would typically run in a Kubernetes app. The `kube-dns` Pod
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`kube-dns` Pod 是一个很好的学习例子，因为它代表了您通常在 Kubernetes 应用程序中运行的 Pod 类型。`kube-dns`
    Pod'
- en: Runs in any Kubernetes cluster
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可在任何 Kubernetes 集群中运行
- en: Has no special privileges and uses the regular old Pod network rather than the
    host network
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有特殊权限，并使用常规的 Pod 网络，而不是主机网络
- en: Sends traffic to port 53, which is universally known as the DNS port standard
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将流量发送到端口 53，这是众所周知的标准 DNS 端口
- en: Already runs in your `kind` cluster by default
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下已在您的 `kind` 集群中运行
- en: 'Just as the Pod we made earlier was incapable of accessing the internet, it
    was also unable to receive any traffic. When we ran `ip a`, the Pod didn’t have
    its own IP address. In Kubernetes, a CNI provider provides a unique IP address
    and routing rules to access this address. We can investigate these routes with
    the `ip route` command like so:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前创建的 Pod 无法访问互联网一样，它也无法接收任何流量。当我们运行 `ip a` 时，Pod 没有自己的 IP 地址。在 Kubernetes
    中，CNI 提供商提供唯一的 IP 地址和路由规则来访问此地址。我们可以使用 `ip route` 命令来调查这些路由，如下所示：
- en: '[PRE25]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the code snippet, IP routes are defined to send traffic to specific veth
    devices. These devices are made for us by our networking plugin. How do the Kubernetes
    Services route traffic to them? For this, we can look at the iptables program’s
    output. If we run `iptables-save`, we can grep out the `10.244.0.*` addresses
    (the specific addresses will vary depending on your cluster and on how many Pods
    it might have) and see that there are egress rules, which enable these to make
    outgoing TCP connections.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，IP 路由被定义为将流量发送到特定的 veth 设备。这些设备由我们的网络插件为我们创建。Kubernetes 服务如何将流量路由到它们？为此，我们可以查看
    iptables 程序的输出。如果我们运行 `iptables-save`，我们可以使用 grep 查找 `10.244.0.*` 地址（具体地址将根据您的集群以及可能拥有的
    Pod 数量而变化），并看到存在出口规则，这些规则允许它们建立出站 TCP 连接。
- en: Routing traffic into our DNS Pods with service rules
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务规则将流量路由到我们的 DNS Pod
- en: 'Internal traffic is routed to our DNS Pods by the following rules, using the
    `-j` option that tells the Kernel “if something is trying to access the KUBE-SVC-ERIFX
    rule, send it to the KUBE-SEP-IT2Z rule.” The `-j` option in an iptables rule
    stands for *jump* (as in “jump to another rule”). The jump rule forwards network
    traffic to a service endpoint (a Pod) as in the next example:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 内部流量通过以下规则路由到我们的 DNS Pod，使用 `-j` 选项告诉内核“如果有人试图访问 KUBE-SVC-ERIFX 规则，将其发送到 KUBE-SEP-IT2Z
    规则。”iptables 规则中的 `-j` 选项代表 *跳转*（就像“跳转到另一个规则”）。跳转规则将网络流量转发到服务端点（一个 Pod），如下例所示：
- en: '[PRE26]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Defining rules for our individual Pods with endpoint rules
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用端点规则定义我们单个 Pod 的规则
- en: 'When traffic from a service is received, it is routed using the following `KUBE-SEP`
    rules. These Pods access the external internet or receive traffic. For example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到来自服务的流量时，它将使用以下 `KUBE-SEP` 规则进行路由。这些 Pod 访问外部互联网或接收流量。例如：
- en: '[PRE27]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In case it isn’t obvious from the example, the final destination port for any
    traffic headed to these IP addresses goes to port 53\. This is the endpoint where
    the `kube-dns` Pod serves its traffic (the IP address of the CoreDNS Pod that
    is running). If one of these Pods becomes unhealthy, then the specific rule for
    `KUBE-SEP-IT2Z` will be reconciled by the network proxy, `kube-proxy`, so that
    traffic only forwards to the healthy copies of our DNS Pods. Note that `kube-dns`
    is the name of our service, and CoreDNS is the Pod that implements our `kube-dns`
    service endpoint.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从示例中不明显，任何前往这些 IP 地址的流量的最终目标端口是 53。这是 `kube-dns` Pod 提供其流量的端点（运行 CoreDNS Pod
    的 IP 地址）。如果这些 Pod 中的任何一个变得不健康，那么 `KUBE-SEP-IT2Z` 的特定规则将由网络代理 `kube-proxy` 进行协调，以确保流量仅转发到我们
    DNS Pod 的健康副本。请注意，`kube-dns` 是我们服务的名称，CoreDNS 是实现我们 `kube-dns` 服务端点的 Pod。
- en: The network proxy’s entire purpose in life is to continually update and manage
    these simple rulesets so that any node in a Kubernetes cluster can forward traffic
    into Kubernetes services, which is why we often refer to it generically as the
    Kubernetes network proxy or the Kubernetes service proxy.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 网络代理在其一生中的全部目的就是不断地更新和管理这些简单的规则集，以便 Kubernetes 集群中的任何节点都可以将流量转发到 Kubernetes
    服务，这就是我们通常将其通称为 Kubernetes 网络代理或 Kubernetes 服务代理的原因。
- en: 3.5.4 Considering other issues
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.4 考虑其他问题
- en: Storage, scheduling, and restarts are all issues that we haven’t discussed yet.
    Each one of these issues affects any enterprise application. For example, a traditional
    data center might require migration of a database from one server to another and
    then need migration of application servers connecting to that database in a way
    that is complimentary to the new data center topology. In Kubernetes, we also
    need to take into account these age-old primitives.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 存储、调度和重启是我们尚未讨论的问题。这些问题中的每一个都会影响任何企业应用程序。例如，传统的数据中心可能需要将数据库从一个服务器迁移到另一个服务器，然后需要以与新数据中心拓扑相补充的方式迁移连接到该数据库的应用程序服务器。在
    Kubernetes 中，我们还需要考虑这些古老的原始方法。
- en: Storage
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 存储
- en: In addition to issues with networking, our Pod also might need access to many
    different kinds of storage. For example, what if we had a large Network Attached
    Storage (NAS) that all of our containers need to use, and we needed to periodically
    change the way this NAS was mounted? In our previous example, this would mean
    modifying our shell commands and changing the way we mount volumes, one at a time.
    Doing this for hundreds or thousands of processes without extra infrastructure
    tooling to automate the process would be untenable for obvious reasons. However,
    even with such tooling, we would need a way to define these storage types and
    to report if attachments to these mounted storage volumes were failing. This is
    managed by Kubernetes StorageClasses, PersistentVolumes, and PersistentVolumeClaims.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 除了网络问题之外，我们的Pod可能还需要访问许多不同类型的存储。例如，如果我们有一个所有容器都需要使用的大的网络附加存储（NAS），并且我们需要定期更改这个NAS的挂载方式，会怎样呢？在我们的前一个例子中，这意味着修改我们的shell命令，并逐个更改挂载卷的方式。显然，如果没有额外的基础设施工具来自动化这个过程，对于数百或数千个进程来说，这样做是不可行的。然而，即使有了这样的工具，我们仍然需要一种方法来定义这些存储类型，并报告这些挂载存储卷的附加是否失败。这是由Kubernetes的StorageClasses、PersistentVolumes和PersistentVolumeClaims来管理的。
- en: Scheduling
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 调度
- en: We discussed in the previous chapter how the scheduling of Pods is a complex
    process in and of itself. Remember when we set the cgroups up previously? Imagine
    what might happen if we made the memory too high or if we ran our container in
    an environment where there wasn’t enough memory to allocate its memory requests.
    In either of these cases, we might actually bring down an entire node in our Kubernetes
    cluster. Having a scheduler that is smart enough to put a Pod in a place where
    the cgroup hierarchy is able to match the resource requirements of our Pod is
    another key feature that requires Kubernetes.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了Pod的调度本身就是一个复杂的过程。还记得我们之前设置cgroups的情况吗？想象一下，如果我们把内存设置得太高，或者在我们的容器运行在一个内存不足以分配其内存请求的环境中，会发生什么。在这两种情况下，我们可能会使我们的Kubernetes集群中的整个节点崩溃。拥有一个足够智能的调度器，能够将Pod放置在cgroup层次结构能够匹配Pod资源需求的位置，这是Kubernetes的另一个关键特性，这也是为什么需要Kubernetes的原因。
- en: Scheduling is a generic problem in computer science, so we should note here
    that there are alternative scheduling tools, such as Nomad ([https://www.nomadproject.io/](https://www.nomadproject.io/)),
    that solve the scheduling problem in a Kubernetes-agnostic manner for data centers.
    That said, the Kubernetes scheduler specializes in simple, container-centric,
    and predictable choices of nodes for Pods we want to run, based on parameters
    such as affinity, CPU, memory, storage availability, data center topology, and
    so on.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 调度是计算机科学中的一个通用问题，因此我们应该在这里指出，存在一些替代的调度工具，例如Nomad ([https://www.nomadproject.io/](https://www.nomadproject.io/))，它们以Kubernetes无关的方式解决数据中心中的调度问题。话虽如此，Kubernetes调度器专门针对我们想要运行的Pod，基于亲和性、CPU、内存、存储可用性、数据中心拓扑等参数，提供简单、以容器为中心和可预测的节点选择。
- en: Upgrades and restarts
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 升级和重启
- en: The Bash commands we ran to create our Pod won’t work well if the PID of our
    Pod keeps changing or if we forget to record it in the first place. As you might
    recall, we need to write down the PID for certain operations. If we want to run
    a more sophisticated app than bin or Bash, we may find that we need to delete
    data from a folder, add new data to a folder, and then restart our script. Again,
    this process is essentially impossible to do at scale with shell scripts due to
    the high volume of concurrency and locking required to manage directories, processes,
    and mounts for several applications at a time.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建Pod时运行的Bash命令，如果我们的Pod的PID不断变化，或者我们一开始就忘记记录它，将不会很好地工作。如您所记得的，我们需要为某些操作写下PID。如果我们想要运行比bin或Bash更复杂的应用程序，我们可能会发现我们需要从文件夹中删除数据，向文件夹中添加新数据，然后重启我们的脚本。同样，由于需要管理多个应用程序的目录、进程和挂载，并且需要处理高并发和锁定，这个过程在规模上几乎是不可能用shell脚本完成的。
- en: Managing the stale processes and/or cgroups associated with a Pod that might
    no longer be running is an important part of running containerized workloads at
    large scales, especially in the context of microservices that are meant to be
    portable and ephemeral. The Kubernetes data model for applications, which most
    often is thought of in terms of Deployments, StatefulSets, Jobs, and DaemonSets,
    accounts for upgrading in a graceful manner.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 管理与Pod相关的陈旧进程和/或cgroups，这些Pod可能已经不再运行，是大规模运行容器化工作负载的重要部分，尤其是在微服务（旨在可移植和短暂）的上下文中。Kubernetes应用程序的数据模型，通常以部署、有状态集、作业和守护进程集的形式考虑，能够以优雅的方式处理升级。
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Kubernetes itself is a union of various Linux primitives.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes本身是各种Linux基本功能的联合体。
- en: You can build a Pod-like construct in any Linux distribution using `chroot`.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `chroot` 在任何Linux发行版中构建类似Pod的结构。
- en: Storage, scheduling, and networking need to be managed in a sophisticated way
    if we want our Pod to run in a production scenario.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储管理、调度和网络需要以复杂的方式进行管理，如果我们希望我们的Pod在生产环境中运行。
- en: '`iptables` is a Linux primitive that can be used to forward traffic or create
    firewalls in a flexible manner.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iptables` 是一种Linux基本功能，可以灵活地用于转发流量或创建防火墙。'
- en: Kubernetes services are implemented by the `kube-proxy`, which is usually running
    in `iptables` mode.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes服务是通过 `kube-proxy` 实现的，它通常在 `iptables` 模式下运行。
