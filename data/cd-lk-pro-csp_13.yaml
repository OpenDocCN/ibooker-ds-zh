- en: 9 Extension methods, streams, and abstract classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 扩展方法、流和抽象类
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using streams to redirect console output
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流重定向控制台输出
- en: Using abstract classes to provide common functionality across derived classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象类在派生类之间提供通用功能
- en: Using the `AddRange` LINQ method to add many things to a collection at once
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AddRange` LINQ方法一次性向集合中添加许多东西
- en: Using the `SortedList` collection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SortedList`集合
- en: Using extension methods to extend existing types with new functionality
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用扩展方法扩展现有类型以添加新功能
- en: Refactoring “magic numbers”
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构“魔法数字”
- en: 'In sections 3.1 and 3.2, the CEO of Flying Dutchman Airlines tasked us with
    creating a new version of the existing FlyingDutchmanAirlines codebase. The existing
    codebase is old and riddled with design flaws, and does not play nice with the
    new API requirements put in place by a newly signed business deal with a search
    aggregator. In chapters 3 and 4, we considered the existing codebase and earmarked
    potential improvements. In chapter 5, we started our refactor and implemented
    a database access layer with Entity Framework Core. Following that, in chapters
    5 through 8 we implemented (and tested) two repositories out of the following
    four required classes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在3.1和3.2节中，飞剪航空公司（Flying Dutchman Airlines）的CEO委托我们创建现有FlyingDutchmanAirlines代码库的新版本。现有的代码库很旧，充斥着设计缺陷，并且与新签订的商业协议中搜索聚合商提出的新API要求不兼容。在第3章和第4章中，我们考虑了现有的代码库，并标记了潜在的提升点。在第5章中，我们开始了重构工作，并使用Entity
    Framework Core实现了数据库访问层。随后，在第5章至第8章中，我们从以下四个必需的类中实现了（并测试了）两个存储库：
- en: '`CustomerRepository`—We implemented this repository class in chapters 6 and
    7.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomerRepository`—我们在第6章和第7章实现了这个存储库类。'
- en: '`BookingRepository`—We implemented this repository class in chapter 8.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BookingRepository`—我们在第8章实现了这个存储库类。'
- en: '`AirportRepository`—We implement this repository class in this chapter.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AirportRepository`—我们在本章实现这个存储库类。'
- en: '`FlightRepository`—We implement this repository class in this chapter.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlightRepository`—我们在本章实现这个存储库类。'
- en: See figure 9.1 for where we are in the scheme of the book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 见图9.1了解我们在本书结构中的位置。
- en: '![](../Images/09_01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09_01.png)'
- en: Figure 9.1 In this chapter, we’ll implement both the `AirportRepository` and
    `FlightRepository` classes. These are the last two required repositories to finish
    the repository section of our refactor.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1在本章中，我们将实现`AirportRepository`和`FlightRepository`类。这是完成重构中存储库部分的最后两个必需的存储库。
- en: Having learned things such as test-driven development, the DRY principle, Liskov
    substitution principle, and LINQ, as well as being familiar with the overall structure
    and testing patterns of these repositories by now, we can pick up speed as we
    finish the repository layer in this chapter by implementing `AirportRepository`
    and `FlightRepository`. We’ll also learn about abstract classes (an alternative
    to interfaces that forces us to implement the same method in all derived classes)
    and revisit extension methods (section 9.6) so we can provide new functionality
    to existing types.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习诸如测试驱动开发、DRY原则、Liskov替换原则和LINQ等内容，并且现在对这些存储库的整体结构和测试模式已经很熟悉，我们可以在本章通过实现`AirportRepository`和`FlightRepository`来加快速度，完成存储库层的重构。我们还将了解抽象类（作为接口的替代品，它强制我们在所有派生类中实现相同的方法）并重新审视扩展方法（第9.6节），以便我们可以为现有类型提供新的功能。
- en: 9.1 Implementing the Airport repository
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 实现机场存储库
- en: 'In chapters 6 through 8, we followed a basic first step when starting an implementation:
    creating skeleton classes for both the repository and unit tests. I follow the
    same approach in this chapter.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章至第8章中，我们在开始实现时遵循了一个基本的第一步：为存储库和单元测试创建骨架类。我在本章也遵循了同样的方法。
- en: The `AirportRepository` skeleton uses dependency injection, which injects an
    instance of type `FlyingDutchmanAirlinesContext` into `AirportRepository`’s explicit
    (nondefault) constructor, as shown in figure 9.2\. The constructor assigns the
    injected `FlyingDutchmanAirlinesContext` to a private backing field. Additionally,
    the access modifier of the `AirportRepository` class is public. The `AirportRepositoryTest`
    class has a `TestInitialize` method that initializes the `FlyingDutchmanAirlinesContext`
    and assigns it to a private backing field, so we can use a fresh instance of the
    in-memory database in every unit test. The `TestInitialize` method also instantiates
    and assigns a new instance of `AirportRepository` to a private backing field.
    A `[TestClass]` attribute annotates the `AirportRepositoryTest` class. If any
    of that sounds confusing to you, please revisit chapters 6 and 7, where I show
    you in detail how to set up these skeleton classes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`AirportRepository` 模板使用依赖注入，将 `FlyingDutchmanAirlinesContext` 类的一个实例注入到 `AirportRepository`
    的显式（非默认）构造函数中，如图 9.2 所示。构造函数将注入的 `FlyingDutchmanAirlinesContext` 分配给一个私有后置字段。此外，`AirportRepository`
    类的访问修饰符是公共的。`AirportRepositoryTest` 类有一个 `TestInitialize` 方法，该方法初始化 `FlyingDutchmanAirlinesContext`
    并将其分配给一个私有后置字段，这样我们就可以在每次单元测试中使用内存数据库的新实例。`TestInitialize` 方法还实例化并分配一个新的 `AirportRepository`
    实例到私有后置字段。`[TestClass]` 属性注解了 `AirportRepositoryTest` 类。如果这些内容让你感到困惑，请回顾第 6 章和第
    7 章，我在那里详细展示了如何设置这些模板类。'
- en: '![](../Images/09_02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09_02.png)'
- en: Figure 9.2 Whether you create a regular class or a test class, the first step
    is to create the actual class file. If you are working on a regular class, proceed
    to add dependency injection to the class and constructor. If you created a test
    class, you could also set up an optional `TestInitialize` method.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 不论是创建一个常规类还是一个测试类，第一步都是创建实际的类文件。如果你正在处理一个常规类，请继续向类和构造函数中添加依赖注入。如果你创建了一个测试类，你也可以设置一个可选的
    `TestInitialize` 方法。
- en: When we deal with the `Airport` entity, what HTTP actions do we need to support?
    Conventional wisdom says that for every entity, we need logic that corresponds
    to the commonly grouped create-read-update-delete (CRUD) actions. I beg to differ.
    I say, only expose and implement what you need to do your job. With `Airport`,
    it makes little sense for us to expose the ability to create, update, or delete
    data in the `Airport` table through the API. All we need is a read operation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理 `Airport` 实体时，我们需要支持哪些 HTTP 动作？传统观点认为，对于每个实体，我们需要与常见分组创建-读取-更新-删除（CRUD）操作相对应的逻辑。我不同意这种观点。我说，只暴露和实现你需要完成工作的内容。对于
    `Airport` 来说，通过 API 暴露在 `Airport` 表中创建、更新或删除数据的能力几乎没有意义。我们需要的只是一个读取操作。
- en: 9.2 Getting an Airport out of the database by its ID
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 通过 ID 从数据库获取机场
- en: 'What does a read operation map do within the context of the `AirportRepository`?
    We need to “read” the `Airport` entity from the database, meaning we should return
    an `Airport` when given its ID. We did something similar in section 6.2, where
    we returned a `Customer` object from the database when given its ID. In this section,
    we’ll start our implementation of the method needed to return an `Airport` from
    the database: `GetAirportByID`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AirportRepository` 的上下文中，读取操作映射做了什么？我们需要“读取”数据库中的 `Airport` 实体，这意味着当给定其 ID
    时，我们应该返回一个 `Airport`。我们在第 6.2 节中做了类似的事情，当时当给定其 ID 时，我们从数据库返回了一个 `Customer` 对象。在本节中，我们将开始实现从数据库返回
    `Airport` 所需的方法：`GetAirportByID`。
- en: 'But, as always, first comes the red-light stage of test-driven development—the
    success case unit test for `GetAirportByID`, shown next:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但，就像往常一样，测试驱动开发的第一步是红灯阶段——`GetAirportByID` 的成功用例单元测试，如下所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we attempt to compile this, not only do we get a compile error saying
    that the compiler cannot find `GetAirportByID` (which we expected because we have
    not implemented the method yet), but we also have another compile error, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试编译这段代码时，不仅会得到一个编译错误，表明编译器找不到 `GetAirportByID` 方法（因为我们还没有实现这个方法，所以这是预料之中的），而且还会出现另一个编译错误，如下所示：
- en: '`"The await operator can only be used within an async method."`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`"await 操作符只能在异步方法中使用。"`'
- en: You will undoubtedly get this error many times throughout your C# career, because
    it is easy to forget to mark a method that is awaiting something as `async` and
    with the appropriate return value (`Task`).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你无疑会在你的 C# 生涯中多次遇到这个错误，因为很容易忘记标记一个等待某个操作的方法为 `async` 并具有适当的返回值（`Task`）。
- en: 'NOTE As discussed in section 6.2.8, asynchronous methods expect a return of
    type `Task`. If you want to return nothing (`void`), use the nongeneric version:
    `Task`. If you want to return an actual value, use the generic version `Task<T>`,
    where `T` is your return type. For example, to return a Boolean[¹](#pgfId-1210921)
    value along with a `Task`, use `Task<bool>`. `Task` represents a single unit of
    work (a concern).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如第6.2.8节所述，异步方法期望返回类型为`Task`。如果你想返回空值（`void`），请使用非泛型版本：`Task`。如果你想返回实际值，请使用泛型版本`Task<T>`，其中`T`是你的返回类型。例如，为了返回一个布尔值[¹](#pgfId-1210921)并伴随一个`Task`，请使用`Task<bool>`。`Task`代表一个单独的工作单元（一个关注点）。
- en: 'To refresh our memories, if we want to convert a method from executing synchronously
    to executing asynchronously, we need to use the `async` keyword and a return type
    of `Task` or `Task<T``> (`if the `Task` returns some data) in the method signature
    as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了刷新我们的记忆，如果我们想将一个方法从同步执行转换为异步执行，我们需要在方法签名中使用`async`关键字和一个返回类型为`Task`或`Task<T>`（如果`Task`返回一些数据），如下所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To compile the code and pass the success case unit test (the green stage of
    test-driven development), we need to create a `GetAirportByID` method that accepts
    an argument of type `integer` in `AirportRepository`, as shown here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译代码并通过成功案例单元测试（测试驱动开发的绿色阶段），我们需要在`AirportRepository`中创建一个接受`integer`类型参数的`GetAirportByID`方法，如下所示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we compile our code and run the `GetAirportByID_Success` test case now,
    we see that it passes. Obviously, the code in `GetAirportByID` is not really doing
    much for us. It simply returns a new instance of type `Airport` instead of a particular
    entry from the database. I want to try an experiment with you, my dear reader:
    for one minute, I want you to think about the four major steps necessary to retrieve
    an `Airport` object from the database. Ready? Go!'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在编译代码并运行`GetAirportByID_Success`测试用例，我们会看到它通过了。显然，`GetAirportByID`中的代码并没有真正为我们做很多事情。它只是返回一个新的`Airport`类型实例，而不是从数据库中返回特定的条目。我想和你，我亲爱的读者，做一个实验：我想让你在一分钟内思考从数据库中检索`Airport`对象所需的四个主要步骤。准备好了吗？开始！
- en: 'A minute has passed? Are you sure? Okay, then, let’s move on. In broad strokes,
    the four major steps we need to undertake follow and are shown in figure 9.3:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一分钟过去了？你确定吗？好吧，那么，让我们继续。大致来说，我们需要执行的四个主要步骤如下，并在图9.3中展示：
- en: Validate the given `airportID`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证给定的`airportID`。
- en: Retrieve the correct `Airport` from the database.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中检索正确的`Airport`。
- en: Handle any potential `Exception` from the database with a custom exception.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自定义异常处理数据库中可能出现的任何`Exception`。
- en: Return the found `Airport` instance.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回找到的`Airport`实例。
- en: '![](../Images/09_03.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09_03.png)'
- en: Figure 9.3 The steps involved with returning an `Airport` from the database.
    First, we check if the given input arguments are valid. If not, we throw and handle
    the exception. If the inputs are valid, we attempt to get the correct `Airport`
    from the database. If the database encounters a problem, we throw and handle the
    exception. If we encountered no errors, we return the found `Airport` instance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 从数据库返回`Airport`所涉及的步骤。首先，我们检查给定的输入参数是否有效。如果不是，我们抛出并处理异常。如果输入有效，我们尝试从数据库中获取正确的`Airport`。如果数据库遇到问题，我们抛出并处理异常。如果没有遇到错误，我们返回找到的`Airport`实例。
- en: If you feel adventurous, I invite you to implement the `GetAirportByID` method
    following those broad steps. Come back to the book after you have completed the
    implementation and compare my implementation with yours. If my implementation
    differs from yours, that is okay. If you have the tests to back up your functionality,
    and they pass, you can be assured your code is great. (Your code being clean is
    a different matter altogether and not measurable by tests. To check the cleanliness
    of your code, use the clean code checklist in appendix B.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到好奇，我邀请你按照以下大致步骤实现`GetAirportByID`方法。完成实现后，回到书中比较我的实现和你的实现。如果我的实现与你的不同，那也是可以的。如果你有测试来支持你的功能，并且测试通过，你可以确信你的代码是优秀的。（你的代码是否整洁完全是另一回事，并且不能通过测试来衡量。要检查代码的整洁性，请使用附录B中的整洁代码清单。）
- en: 'I offer you one last word of advice before embarking on this grand adventure:
    keep it simple. Early in my career, I thought I was being clever when using very
    obscure corners of a programming language and odd algorithms. This led to code
    that was unreadable for anybody (including me) and, by extension, unmaintainable.
    Be clever by keeping it simple (or just complicated enough, depending on your
    outlook on life).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这次伟大冒险之前，我给你提供最后一个建议：保持简单。在我职业生涯的早期，我认为自己在使用编程语言的非常隐蔽的角落和奇特的算法时很聪明。这导致代码对任何人（包括我自己）都难以阅读，并且因此难以维护。通过保持简单（或者根据你对生活的看法，足够复杂）来变得聪明。
- en: 9.3 Validating the AirportID input parameter
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 验证机场ID输入参数。
- en: 'As discussed in section 9.2, the four steps to getting an `Airport` from the
    database follow:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如第9.2节所述，从数据库获取`机场`的四个步骤如下：
- en: Validate the given `airportID`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证给定的`airportID`。
- en: Retrieve the correct `Airport` from the database.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中检索正确的`机场`信息。
- en: Handle any potential `Exception` from the database with a custom exception.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理数据库中任何潜在的`异常`，使用自定义异常进行处理。
- en: Return the found `Airport` instance.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回找到的`机场`实例。
- en: 'In this section, we’ll tackle the first of the four: validate the user input.
    The `GetAirportByID` method accepts one argument of type `integer`. The `AirportID`
    should be a positive integer (an integer greater than or equal to `0`). To test
    that `AirportID` is a positive integer, we use a similar conditional to the one
    we wrote in the `GetCustomerByID` and `CreateBooking` methods: if the argument’s
    value is invalid, write a log to the console and throw an `ArgumentException`
    exception, as shown in the next listing. The log written to the console uses string
    interpolation to inline the value of `airportID`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解决四个问题中的第一个：验证用户输入。`GetAirportByID`方法接受一个类型为`整数`的参数。`AirportID`应该是一个正整数（一个大于或等于`0`的整数）。为了测试`AirportID`是否为正整数，我们使用与在`GetCustomerByID`和`CreateBooking`方法中编写的类似条件：如果参数的值无效，则将日志写入控制台并抛出`ArgumentException`异常，如下一列表所示。写入控制台日志使用字符串插值将`airportID`的值内联。
- en: Listing 9.1 Validating the `airportID` argument in `GetAirportByID`
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 验证`GetAirportByID`中的`airportID`参数。
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Determines whether airportID has a valid value
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 判断机场ID是否具有有效的值。
- en: ❷ Logs the AirportID value to the console for developers
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将机场ID值记录到控制台以供开发人员查看。
- en: ❸ Throws an exception of type ArgumentException
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 抛出`ArgumentException`类型的异常。
- en: ❹ Returns a new instance of Airport. We’ll change this implementation in this
    chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 返回一个新的`机场`实例。我们将在本章中更改此实现。
- en: 'That looks good. But you know what is coming next, don’t you? We need to add
    a failure case unit test that checks for invalid input values. We know we can
    use the `[DataRow]` method attribute to supply the failure case unit test with
    a multitude of test data, but what data should we supply? Well, we have only one
    invalid input data point we need to test: a negative integer.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错。但你知道接下来会发生什么，不是吗？我们需要添加一个检查无效输入值的失败案例单元测试。我们知道我们可以使用`[DataRow]`方法属性为失败案例单元测试提供多种测试数据，但我们应该提供什么数据呢？嗯，我们只有一个无效输入数据点需要测试：一个负整数。
- en: 'Because we need to test only one data point, we don’t need the `[DataRow]`
    method attribute. We can use the `[DataRow]` method attribute with a unit test
    that deals with only one piece of data, but that would be overkill. If we’re testing
    only one data point, it is cleaner to do without the `[DataRow]` method attribute,
    as shown next:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们只需要测试一个数据点，所以我们不需要`[DataRow]`方法属性。我们可以使用`[DataRow]`方法属性与仅处理一个数据点的单元测试一起使用，但这将是过度设计。如果我们只测试一个数据点，那么不使用`[DataRow]`方法属性会更简洁，如下所示：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `GetAirportByID_Failure_InvalidInput` unit test passes a negative (and,
    therefore, invalid) integer to the `GetAirportByID` method. We expect the `GetAirportByID`
    method to see we supplied it with an invalid `AirportID` argument. Following that,
    we expect the method to log a message to the console and throw an `ArgumentException`.
    How do we verify that the `GetAirportByID` method threw the expected exception
    of type `ArgumentException`? We need the `[ExpectedException(typeof(ArgumentException))]`
    method attribute annotating the unit test as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAirportByID_Failure_InvalidInput`单元测试将一个负数（因此是无效的）整数传递给`GetAirportByID`方法。我们期望`GetAirportByID`方法看到我们向它提供了一个无效的`AirportID`参数。随后，我们期望该方法将消息记录到控制台并抛出`ArgumentException`。我们如何验证`GetAirportByID`方法抛出了预期的`ArgumentException`异常？我们需要使用`[ExpectedException(typeof(ArgumentException))]`方法属性注释单元测试，如下所示：'
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We run the tests, and everything passes. Is there anything else we can test
    for input validation? With `GetCustomerByName`, we were satisfied with asserting
    that the input validation code in `GetCustomerByName` threw an exception of type
    `ArgumentException` in case of invalid input. But the `GetAirportByName` method
    also logs a message to the console. We should probably check for that.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行了测试，一切顺利。我们还能测试哪些输入验证？使用`GetCustomerByName`，我们对`GetCustomerByName`中的输入验证代码在无效输入的情况下抛出`ArgumentException`类型的异常表示满意。但是`GetAirportByName`方法也向控制台记录了一条消息。我们可能需要检查这一点。
- en: 9.4 Output streams and being specifically abstract
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 输出流及其具体抽象
- en: To verify that we logged a message to the console, we need access to the console’s
    contents. The trick to retrieving console output is to provide an alternative
    output and set the console to write to that output. In this section, we’ll discuss
    how to circumvent console output to our own data stream.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们是否向控制台记录了消息，我们需要访问控制台的内容。检索控制台输出的技巧是提供替代输出并将控制台设置为写入该输出。在本节中，我们将讨论如何绕过控制台输出到我们自己的数据流。
- en: WARNING The concept of a stream in C# differs from using the Streams API in
    Java. In Java, using the Streams API is almost akin to using LINQ in C#. This
    section explains the C# concept of streams.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：C#中流的概念与Java中使用Streams API不同。在Java中，使用Streams API几乎类似于在C#中使用LINQ。本节解释了C#中的流概念。
- en: 'The `Console` class is a wrapper around an input and an output stream of data.
    A stream represents a sequence of data, often in bytes. The `Console` class deals
    with the following three data streams, shown in figure 9.4:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console`类是数据输入和输出流的包装器。流表示一系列数据，通常是字节。`Console`类处理以下三个数据流，如图9.4所示：'
- en: A `System.IO.TextReader`, which represents the input stream
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.IO.TextReader`，它表示输入流'
- en: A `System.IO.TextWriter`, which represents the output stream
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.IO.TextWriter`，它表示输出流'
- en: A `System.IO.TextWriter`, which represents the error stream.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.IO.TextWriter`，它表示错误流。'
- en: '![](../Images/09_04.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4](../Images/09_04.png)'
- en: Figure 9.4 A possible life cycle from input to output. First, keyboard input
    (1) is sent to the input stream (2). Then, some processing is done inside the
    application (this can be anything you want). Following processing, if an exception
    was thrown, the error is written to the error stream (3). If there is no exception,
    information is written to the output stream (3). Finally, the error and output
    streams are displayed in the console (4).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 从输入到输出的可能生命周期。首先，键盘输入（1）被发送到输入流（2）。然后，在应用程序内部进行一些处理（这可以是任何你想要的内容）。处理之后，如果抛出了异常，错误被写入错误流（3）。如果没有异常，信息被写入输出流（3）。最后，错误和输出流在控制台中显示（4）。
- en: Within the context of a `Console` application, the input stream handles any
    keyboard input. The output stream is where we write anything we want displayed
    in the output. The error stream is where exceptions are logged. We do not have
    access to the default `TextReader` and `TextWriter`s, but we can specify our own
    by using the `Console`’s `SetOut`, `SetIn`, and `SetError` methods.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Console`应用程序的上下文中，输入流处理任何键盘输入。输出流是我们想要在输出中显示任何内容的地方。错误流是记录异常的地方。我们没有访问默认的`TextReader`和`TextWriter`，但我们可以通过使用`Console`的`SetOut`、`SetIn`和`SetError`方法来指定自己的。
- en: By instantiating our instance of type `StringWriter` (a data stream dealing
    with strings) and hanging onto a reference to that variable while using it as
    the `Console`’s output stream, we can get the history data pretty easily. Instead
    of writing to some intangible output stream, the `Console.WriteLine` method writes
    to our `StringWriter`, as shown in figure 9.5\. Take note that some programming
    languages such as Java distinguish between input and output streams on a type
    level. C# does not do this. You can use any `Stream`-derived class as an input
    or output stream.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实例化我们的`StringWriter`类型实例（一种处理字符串的数据流）并在使用它作为`Console`的输出流的同时保留对该变量的引用，我们可以轻松地获取历史数据。与写入一些无形输出流不同，`Console.WriteLine`方法将写入我们的`StringWriter`，如图9.5所示。请注意，一些编程语言（如Java）在类型级别上区分输入和输出流。C#不这样做。您可以使用任何`Stream`派生类作为输入或输出流。
- en: '![](../Images/09_05.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5](../Images/09_05.png)'
- en: 'Figure 9.5 When redirecting console output to a `StringWriter` instance, the
    output and error streams write to the `StringWriter` instance instead of to the
    regular console output. The life cycle from figure 9.4 changes: first, keyboard
    input (1) is sent to the input stream (2). Then, some processing is done inside
    the application (this can be anything you want). Following processing, if an exception
    was thrown, the error is written to the error stream (3). If we don’t get an exception,
    information is written to the output stream (3). Finally, the error and output
    streams are written to our `StringWriter` instance (4).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 当将控制台输出重定向到`StringWriter`实例时，输出和错误流将写入`StringWriter`实例而不是常规控制台输出。从图9.4的生命周期变化：首先，键盘输入（1）被发送到输入流（2）。然后，在应用程序内部进行一些处理（这可以是任何你想要的东西）。处理之后，如果抛出了异常，错误将被写入错误流（3）。如果没有抛出异常，信息将被写入输出流（3）。最后，错误和输出流被写入我们的`StringWriter`实例（4）。
- en: The `Stream` base class is the foundation for all data streams. `Stream` is
    an `abstract` class and the base class for many derived classes (such as `StringWriter`)
    that deal with a sequence of bytes. A `StringWriter` is a stream that deals with
    a sequence of bytes and exposes functionalities based on those bytes representing
    strings (and because, under the hood, a string is an array of characters—therefore,
    characters). Because all derived classes from `Stream` implement the `IDisposable`
    interface, we need to clean up the instantiated `Stream` once we are done with
    it, or we risk a memory leak.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`基类是所有数据流的基石。`Stream`是一个`抽象`类，也是许多派生类（如`StringWriter`）的基类，这些类处理一系列字节。`StringWriter`是一种处理一系列字节并基于这些字节表示字符串（因为，在底层，字符串是一个字符数组——因此，字符）的功能。由于所有从`Stream`派生的类都实现了`IDisposable`接口，所以我们一旦完成对其实例的处理，就需要清理实例化的`Stream`，否则我们可能会遇到内存泄漏。'
- en: Abstract classes
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类
- en: An abstract class is a class that cannot directly be instantiated or be static.
    You can instantiate a concrete subclass of an abstract class, which indirectly
    instantiates the abstract class. We can make a class abstract by using the `abstract`
    keyword in the class’s signature. Abstract classes are a different way of supporting
    inheritance and, by extension, polymorphism. We often use abstract classes as
    “base” classes, sitting on top of an inheritance chain. As opposed to interfaces,
    abstract classes can provide method bodies (as long as the method itself is *not*
    abstract) and use access modifiers. This means that abstract classes are often
    used to spread a specific implementation of a method across derived classes. An
    abstract method must be overridden in a concrete implementation. Abstract methods
    are implicitly `virtual` and can be said to indicate an “incomplete” method because
    they cannot contain a method body. Abstract methods can live only in abstract
    classes. Derived classes must override abstract methods and extend functionality
    per their requirements or be marked as abstract themselves.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是一个不能直接实例化或静态的类。你可以实例化一个抽象类的具体子类，这间接实例化了抽象类。我们可以通过在类的签名中使用`abstract`关键字来使一个类成为抽象类。抽象类是支持继承和扩展多态的另一种方式。我们经常使用抽象类作为“基”类，位于继承链的顶部。与接口不同，抽象类可以提供方法体（只要方法本身不是抽象的）并使用访问修饰符。这意味着抽象类通常用于在派生类中传播特定方法的特定实现。抽象方法必须在具体实现中重写。抽象方法是隐式`virtual`的，可以说它们表示一个“不完整”的方法，因为它们不能包含方法体。抽象方法只能存在于抽象类中。派生类必须重写抽象方法并根据其需求扩展功能，或者自己被标记为抽象。
- en: To use our `Console` output stream, we need to instantiate an instance of type
    `StringWriter``,` wrap the stream in a `using` statement, and set it to the `console`’s
    output stream. Then, once all processing is done, we retrieve the `StringWriter`’s
    contents and assert that the output matches our expectations, as shown next.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的`Console`输出流，我们需要实例化一个`StringWriter`类型的实例，用`using`语句包装流，并将其设置为`console`的输出流。然后，一旦所有处理完成，我们检索`StringWriter`的内容，并断言输出符合我们的预期，如以下所示。
- en: Listing 9.2 Define our console output stream
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.2 定义我们的控制台输出流
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Creates a StringWriter, and promises to dispose of it safely
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个`StringWriter`，并承诺安全地处理它
- en: ❷ Sets our StringWriter instance as the Console’s output
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将我们的`StringWriter`实例设置为控制台的输出
- en: ❸ GetAirportByID writes to the StringWriter and throws an exception.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `GetAirportByID`写入`StringWriter`并抛出异常。
- en: ❹ Asserts that the outputStream contains the expected logged output
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言输出流包含预期的日志输出
- en: 'Run the test. You’ll see it passes. But what if I told you that the test passing
    is a red herring? It’s great that the test passes, but are we actually testing
    everything we want to test? I think not. Let’s step through the code execution
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试。你会看到它通过了。但如果我告诉你，测试通过是一个误导？测试通过是好事，但我们实际上测试了我们想要测试的所有内容吗？我认为不是。让我们按照以下步骤逐步执行代码：
- en: The `TestInitialize` method executes.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TestInitialize` 方法执行。'
- en: The `GetAirportByID_Failure_InvalidInput` method starts.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetAirportByID_Failure_InvalidInput` 方法开始执行。'
- en: The unit test creates a `StringWriter`, sets it as the console’s output stream,
    and enters `GetAirportByID`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试创建一个 `StringWriter`，将其设置为控制台的输出流，并进入 `GetAirportByID`。
- en: We check if the passed-in `AirportID` is valid or not (it is not).
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查传入的 `AirportID` 是否有效（它不是有效的）。
- en: The code writes an error log to our `StringWriter` stream.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将错误日志写入我们的 `StringWriter` 流。
- en: The method throws an `Exception` of type `ArgumentException`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法抛出一个类型为 `ArgumentException` 的 `Exception`。
- en: The method is aborted.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法被终止。
- en: The test stops execution because an `Exception` was thrown and not caught.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试停止执行，因为抛出了一个 `Exception` 而没有被捕获。
- en: The test determines that the expected `Exception` was thrown and marks the test
    as “passed.”
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试确定预期的 `Exception` 被抛出，并将测试标记为“通过”。
- en: Turns out, we did not assert based on the console’s output stream at all. Because
    we did not catch the `ArgumentException` thrown in `GetAirportByID`, the unit
    test stopped executing before the code got to the `outputStream` assertion.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们没有基于控制台的输出流进行断言。因为我们没有捕获 `GetAirportByID` 中抛出的 `ArgumentException`，单元测试在代码到达
    `outputStream` 断言之前就停止执行了。
- en: To fix this, we should catch the `ArgumentException`, execute the output stream
    assertion, and then throw another exception of type `ArgumentException` to satisfy
    the `ExpectedException` method attribute, all inside the `GetAirportByID_Failure_
    InvalidInput` unit test, as shown in the next listing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题，我们应该捕获 `ArgumentException`，执行输出流断言，然后在 `GetAirportByID_Failure_InvalidInput`
    单元测试中抛出另一个类型为 `ArgumentException` 的异常，以满足 `ExpectedException` 方法属性，所有这些操作都在 `GetAirportByID_Failure_InvalidInput`
    单元测试中完成，如下一列表所示。
- en: Listing 9.3 Catching the thrown `ArgumentException` in a unit test
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 在单元测试中捕获抛出的 `ArgumentException`
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Catches the ArgumentException thrown in GetAirportByID
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 捕获在 GetAirportByID 中抛出的 ArgumentException
- en: ❷ Asserts that outputStream’s content and the logged error are equal
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 断言 outputStream 的内容和记录的错误日志相等
- en: ❸ Throws a new ArgumentException for the ExpectedException attribute
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为 ExpectedException 属性抛出新的 ArgumentException
- en: There is one catch, though. This code does not compile, because once the `GetAirportByID`
    throws `ArgumentException` and the unit test’s `try-catch` block catches the exception,
    `outputStream` is out of scope, as shown in figure 9.6.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个 `catch`，但这段代码无法编译，因为一旦 `GetAirportByID` 抛出 `ArgumentException` 并且单元测试的
    `try-catch` 块捕获了异常，`outputStream` 就超出了作用域，如图 9.6 所示。
- en: '![](../Images/09_06.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09_06.png)'
- en: Figure 9.6 The `outputStream` variable is out of scope in the `catch` code block.
    The scope of `outputStream` reaches until the end of the `using` code block.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 在 `catch` 代码块中，`outputStream` 变量超出了作用域。`outputStream` 的作用域延伸到 `using`
    代码块的末尾。
- en: Because `outputStream` is out of scope, we cannot access it or its value anymore.
    If only we could extend the scope of `outputStream` but also correctly dispose
    of the instance. We could put the entire `try-catch` inside the `using` statement,
    but I prefer to have the `using` statement contain as little code as possible.
    Perhaps we can use the old-fashioned way of manually disposing of `outputStream`
    by adding a call to `outputStream.Dispose` in a `finally` block. We would also
    need to instantiate the `StringWriter` outside of the `try-catch-finally`, then,
    as shown in the following code sample.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `outputStream` 超出了作用域，所以我们不能再访问它或它的值。如果我们能扩展 `outputStream` 的作用域，同时正确地处理实例，那该多好。我们可以将整个
    `try-catch` 放在 `using` 语句中，但我更喜欢让 `using` 语句包含尽可能少的代码。也许我们可以使用老式的方法，通过在 `finally`
    块中添加对 `outputStream.Dispose` 的调用来手动处理 `outputStream`。我们还需要在 `try-catch-finally`
    之外实例化 `StringWriter`，然后，如以下代码示例所示。
- en: Listing 9.4 Correcting the scope issue for `outputStream`
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.4 修复 `outputStream` 的作用域问题
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Creates our outputStream
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建我们的 outputStream
- en: ❷ Tells the console to use outputStream as the output stream
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 告诉控制台使用 outputStream 作为输出流
- en: ❸ Calls the GetAirportByID method
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用 GetAirportByID 方法
- en: ❹ Catches the ArgumentException thrown in GetAirportByID
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 捕获在 GetAirportByID 中抛出的 ArgumentException
- en: ❺ Asserts that outputStream’s contents match the expected error log
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 断言 outputStream 的内容与预期的错误日志匹配
- en: ❻ Throws a new ArgumentException for the ExpectedException attribute
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 为ExpectedException属性抛出新的ArgumentException
- en: ❼ Disposes of outputStream
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 释放outputStream
- en: Now that the `outputStream` variable is within scope, when we assert that the
    `outputStream` contents contain the error logged in `GetAirportByID`, we can compile
    the unit test and run it. It passes. We can now point to the `GetAirportByID_Failure_
    InvalidInput` and say that we know that our input validation code works.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`outputStream`变量在作用域内，当我们断言`outputStream`的内容包含在`GetAirportByID`中记录的错误时，我们可以编译单元测试并运行它。它通过了。现在我们可以指向`GetAirportByID_Failure_
    InvalidInput`并说我们知道我们的输入验证代码是有效的。
- en: '| ![](../Images/LightBulb.png)   |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| ![灯泡](../Images/LightBulb.png)   |'
- en: Rethrowing exceptions and keeping your stack traces
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重新抛出异常并保留你的堆栈跟踪
- en: 'The code in listing 9.4 has us catch an exception of type `ArgumentException`
    and then throw a new exception of the same type. This works fine for a lot of
    use cases, but what if you want to rethrow the same exception? You have two simple
    ways of doing this: you can use the `throw` keyword with or without a reference
    to the caught exception variable as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4中的代码让我们捕获一个类型为`ArgumentException`的异常，然后抛出一个相同类型的新的异常。这对于许多用例来说工作得很好，但如果你想要重新抛出相同的异常呢？你有两种简单的方法来做这件事：你可以使用带有或不带有捕获的异常变量引用的`throw`关键字，如下所示：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Both ways of rethrowing exceptions work. There is one catch, however: rethrowing
    an exception can result in a loss of the stack trace information preserved along
    with an exception. To make sure you have access to the exception’s stack trace
    after rethrowing the exception, we need to do things slightly differently and
    dive deep into a dark corner of .NET: the `ExceptionDispatchInfo` class.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 两种重新抛出异常的方法都有效。然而，有一个问题：重新抛出异常可能会导致与异常一起保留的堆栈跟踪信息丢失。为了确保在重新抛出异常后可以访问异常的堆栈跟踪，我们需要做些不同的事情，深入.NET的一个黑暗角落：`ExceptionDispatchInfo`类。
- en: 'The `ExceptionDispatchInfo` class allows us to save a specific state of an
    exception, including its stack frame. Doing this prevents the exception stack
    frame from being wiped out by a new stack frame when rethrowing. To save an exception’s
    state, we need to pass in the exception’s `InnerException` property (which contains
    the state that threw the original exception) to the `ExceptionDispatchInfo.Capture`
    method. After that, we can call the `Throw` method, as follows, and it is business
    as usual:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceptionDispatchInfo`类允许我们保存一个异常的特定状态，包括其堆栈帧。这样做可以防止在重新抛出异常时，异常的堆栈帧被新的堆栈帧覆盖。为了保存异常的状态，我们需要将异常的`InnerException`属性（它包含引发原始异常的状态）传递给`ExceptionDispatchInfo.Capture`方法。之后，我们可以调用`Throw`方法，如下所示，一切照旧：'
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Rethrowing an `Exception` by capturing its current state through the `ExceptionDispatchInfo`
    class safeguards your original exception’s internal information, including the
    stack trace, from being overridden.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ExceptionDispatchInfo`类捕获异常的当前状态可以保护原始异常的内部信息，包括堆栈跟踪，不被覆盖。
- en: '|'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 9.5 Querying the database for an Airport object
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 查询机场对象数据库
- en: 'After section 9.4, we have the foundation for the `AirportRepository.GetAirportByID`
    method along with input validation of the `AirportID` argument. We know what an
    abstract class is and how to use a stream. In this section, we’ll finish the implementation
    of `GetAirportByID`. To do so, we need to the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在9.4节之后，我们有了`AirportRepository.GetAirportByID`方法的基础，以及`AirportID`参数的输入验证。我们知道什么是抽象类以及如何使用流。在本节中，我们将完成`GetAirportByID`的实现。为此，我们需要做以下几件事：
- en: Query Entity Framework Core’s `DbSet<Airport>` for the matching `Airport` object.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询Entity Framework Core的`DbSet<Airport>`以获取匹配的`Airport`对象。
- en: Make sure that, in case of a database problem, we throw the appropriate custom
    exception.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在数据库出现问题时，抛出适当的自定义异常。
- en: Have unit tests that cover both success and failure code branches.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有单元测试覆盖成功和失败代码分支。
- en: We asked Entity Framework Core to give us an entity when given an ID before
    (section 7.1.2), so I won’t hold your hand too tightly through implementing the
    following code for that. In fact, if you feel like it, give it a whirl before
    moving on. For bonus points, use test-driven development to verify your code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在7.1.2节中，我们要求Entity Framework Core在给定ID时给我们一个实体，所以我在实现以下代码时不会过于严格。实际上，如果你愿意的话，在继续之前先试一试。作为加分项，使用测试驱动开发来验证你的代码。
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s take a quick look now at the `return` statement, which is where the meat
    and potatoes of this section takes place:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们快速看一下 `return` 语句，这是本节的核心所在：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can break down the return statement into the following four steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将返回语句分解为以下四个步骤：
- en: '`await`—Execute the expression asynchronously and wait for completion.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`await`—异步执行表达式并等待完成。'
- en: '`_context.Airport.FirstOrDefaultAsync`—Retrieve the first match (based on the
    expression in step 3) or the default value for the entity (null in the case of
    `Airport`) asynchronously.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_context.Airport.FirstOrDefaultAsync`—异步检索第一个匹配项（基于第 3 步中的表达式）或实体的默认值（在 `Airport`
    的情况下为 `null`）。'
- en: '`a => a.AirportId == airportID`—This is the predicate that is the matching
    expression for step 2\. The predicate says to return the first element in the
    `Airport` collection that matches its `AirportId`.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a => a.AirportId == airportID`—这是第 2 步的匹配表达式谓词。谓词指示返回与 `AirportId` 匹配的 `Airport`
    集合中的第一个元素。'
- en: '`?? throw new` `AirportNotFoundException();`—Using the null-coalescing operator,
    if steps 2 and 3 returned the default value of `null`, we throw an `AirportNotFoundException`.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`?? throw new` `AirportNotFoundException();`—使用空合并运算符，如果第 2 步和第 3 步返回了 `null`
    的默认值，我们抛出 `AirportNotFoundException`。'
- en: 'In that brief `return` statement, we combined six separate techniques that
    make C# awesome: asynchronous programming is used to get the expression’s completion
    and return values; Entity Framework Core lets us query its internal `DbSet`s for
    entities, maintaining an isomorphic relationship between the database and running
    code; the `FirstOrDefaultAsync` LINQ method enumerates over a collection and returns
    a value based on a predicate; we use a lambda expression as the predicate to match
    `Airport` objects to `AirportID`’s; the null-coalescing operator checks for a
    returned null pointer and executes its expression; and a custom exception, using
    inheritance, is thrown.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个简短的 `return` 语句中，我们结合了六种不同的技术，使 C# 变得非常出色：异步编程用于获取表达式的完成和返回值；Entity Framework
    Core 允许我们查询其内部的 `DbSet`s 以实体，保持数据库和运行代码之间的同构关系；`FirstOrDefaultAsync` LINQ 方法遍历集合并根据谓词返回一个值；我们使用
    lambda 表达式作为谓词来匹配 `Airport` 对象与 `AirportID`；空合并运算符检查返回的空指针并执行其表达式；并且抛出一个使用继承的自定义异常。
- en: '![](../Images/09_06_UN01.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09_06_UN01.png)'
- en: 'We kind of cheated on implementing `GetAirportByID` with test-driven development:
    we did not follow the red-green stoplight pattern to its minutest detail. That
    is okay. Like every technique (and like everything I tell you to do), we shouldn’t
    be hamstrung by the rules, as long as we make sure we deliver everything correctly.
    For us, that means we need to finish the success case unit test for `GetAirportByID`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在实现 `GetAirportByID` 时有点作弊，使用测试驱动开发：我们没有遵循红绿灯模式的最小细节。这是可以的。就像每一种技术（以及我告诉你们做的每一件事）一样，我们不应该被规则束缚，只要我们确保正确地交付一切。对我们来说，这意味着我们需要完成
    `GetAirportByID` 的成功用例单元测试。
- en: What do we need to finish the `GetAirportByID_Success` test case (and with that,
    the `AirportRepository`)?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要完成 `GetAirportByID_Success` 测试用例（以及 `AirportRepository`）需要什么？
- en: Add an `Airport` object to the in-memory database in the `TestInitialize` method.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TestInitialize` 方法中将 `Airport` 对象添加到内存数据库中。
- en: Attempt to retrieve the newly added `Airport` object from the database by calling
    `GetAirportByID` along with the appropriate `airportID`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试通过调用 `GetAirportByID` 并附带适当的 `airportID` 从数据库中检索新添加的 `Airport` 对象。
- en: Assert that the returned object is the same as the `Airport` object we stored
    in the database before calling `GetAirportByID`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言返回的对象与我们调用 `GetAirportByID` 之前存储在数据库中的 `Airport` 对象相同。
- en: Listing 9.5 Basic `TestInitialize` method and a skeleton `GetAirportByID` unit
    test
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 基本的 `TestInitialize` 方法和一个 `GetAirportByID` 单元测试框架
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Creates a new instance of Airport (Nuuk, Greenland; GOH)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的机场实例（格陵兰的努克；GOH）
- en: ❷ Adds the Airport instance to EF Core’s internal database set
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将机场实例添加到 EF Core 的内部数据库集中
- en: ❸ Saves the Airport object to the in-memory database
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将机场对象保存到内存数据库中
- en: ❹ Asserts that the retrieved Airport matches the saved Airport
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言检索到的机场与保存的机场匹配
- en: 'When we run the test, however, it does not pass. The compiler throws an exception
    because, as shown next, we use the `FlyingDutchmanAirlinesContext_Stub`, which
    overrides the `SaveChangesAsync` method and throws an exception when there are
    no `Booking` instances in the database with a `CustomerId` of `1`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们运行测试时，它并没有通过。编译器抛出异常，因为，如以下所示，我们使用了`FlyingDutchmanAirlinesContext_Stub`，它覆盖了`SaveChangesAsync`方法，并在数据库中没有具有`CustomerId`为`1`的`Booking`实例时抛出异常：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is what I like to call “controlled biting in the ass,” and I’m sorry for
    leading you down the wrong path on purpose. If we had taken a moment to reflect
    on our implementation when we wrote the code, we could have seen this coming,
    but then a teaching moment would have been lost.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我所说的“有控制的屁股咬”，我为故意引导你走错路而道歉。如果我们当时在写代码时花点时间反思我们的实现，我们就能预见这个问题，但那样的话，一个教学时刻就会丢失。
- en: Because we did not add any bookings to the database in the `AirportRepositoryTest`’s
    `TestInitialize` method, the `SaveChangesAsync` method throws an exception. To
    solve this, let’s create a conditional in the stub’s `SaveChangesAsync` method
    that checks whether we have an entity in the `Booking DbSet`. If no booking exists
    in the database, the code skips the `Booking` code block. Alternatively, you could
    create a different stub for this test. The thinking behind this is that a stub
    should only ever have the logic for one specific test. This is a valid approach,
    but for the sake of brevity and simplicity, we are sticking with the one stub.
    Similarly, we can check if there are any pending changes for an `Airport` model,
    as shown next.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`AirportRepositoryTest`的`TestInitialize`方法中没有向数据库添加任何预订，`SaveChangesAsync`方法抛出异常。为了解决这个问题，让我们在存根的`SaveChangesAsync`方法中创建一个条件，检查我们是否有`Booking
    DbSet`中的实体。如果数据库中没有预订存在，代码将跳过`Booking`代码块。或者，你也可以为这个测试创建一个不同的存根。背后的想法是，存根应该始终只包含一个特定测试的逻辑。这是一个有效的方法，但为了简洁和简单，我们坚持使用一个存根。同样，我们也可以检查是否有对`Airport`模型的挂起更改，如下所示。
- en: Listing 9.6 Overriding `SaveChangesAsync` in our stub
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.6 在我们的存根中覆盖`SaveChangesAsync`
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Retrieves all pending changes for Airport
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取所有机场的挂起更改
- en: ❷ Checks if pending changes for Airport are found
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查是否找到机场的挂起更改
- en: ❸ If no pending changes for Airport are found, throws an exception
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果找不到机场的挂起更改，将抛出异常
- en: By adding the extra logic in the stub, the test passes. As always, let’s ask
    ourselves, what more can we test? Well, we covered our major code branches, but
    what if we want to make sure that we can get an airport from a database that contains
    more than one `Airport` object? So far, all the in-memory databases we used in
    our testing have contained only one record of the entity we were testing on. We
    can use the techniques we picked up before, as well as a new concept I shall introduce
    you to in just a second that adds multiple instances of `Airport` to the in-memory
    database and makes assertions on them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在存根中添加额外的逻辑，测试通过了。一如既往，让我们问问自己，我们还能测试什么？嗯，我们已经覆盖了主要的代码分支，但如果我们想确保我们可以从一个包含多个`Airport`对象的数据库中获取机场，怎么办？到目前为止，我们在测试中使用的所有内存数据库都只包含我们正在测试的实体的一个记录。我们可以使用之前学到的技术，以及我将在下一秒介绍的新概念，将多个`Airport`实例添加到内存数据库中并对它们进行断言。
- en: 'Think about this for a minute: what is a suitable way to add multiple objects
    of the same type to a collection? What if I tell you that to do that, we need
    to operate on a collection? I hope you jumped out of your chair (or bed, if you
    use this book to fall asleep at night) and cried, “We can use a LINQ method!”'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这个问题：将相同类型的多个对象添加到集合中的合适方法是什么？如果我说，为了做到这一点，我们需要在集合上操作，你希望你会从椅子上跳起来（或者如果你在晚上用这本书睡觉，从床上跳起来）并喊道，“我们可以使用
    LINQ 方法！”
- en: AddRange and SortedList<T>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: AddRange 和 SortedList<T>
- en: 'The LINQ method `AddRange` lets you add multiple entries to a collection at
    once`.` “Range” refers to a range of objects, usually stored in a different collection.
    Because this is a LINQ method, it is not only available with Entity Framework
    Core, it’s also available across the entire C# landscape. To use the `AddRange`
    functionality, we need the following two things:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 方法 `AddRange` 允许你一次性向集合中添加多个条目。“范围”指的是一系列对象，通常存储在不同的集合中。因为这是一个 LINQ 方法，它不仅适用于
    Entity Framework Core，还适用于整个 C# 环境。要使用 `AddRange` 功能，我们需要以下两个东西：
- en: A collection of objects we want to put into a different collection. We use a
    collection created and populated in the `TestInitialize` method for this.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要放入另一个集合中的对象集合。我们使用在`TestInitialize`方法中创建并填充的集合来完成此操作。
- en: A collection to store the objects in—in this case, EF Core’s `DbSet<Airport>`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储对象的集合——在这种情况下，EF Core的`DbSet<Airport>`。
- en: First, we create a collection. The `System.Collections` and `System.Collections
    .Generics` namespaces contain many collections we can sample and use. There are
    the usual candidates such as `List<T>`, `ArrayList<T>`, `LinkedList<T>`, and `Dictionary
    <T, X>`, but we also have more esoteric collections such as `BitArray` or `SynchronizedReadOnlyCollection<T>`.
    We can use the `AddRange` method on any of the collections (generic or not) that
    C# provides.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个集合。`System.Collections`和`System.Collections.Generics`命名空间包含许多我们可以采样和使用的集合。有常见的候选者，如`List<T>`、`ArrayList<T>`、`LinkedList<T>`和`Dictionary<T,
    X>`，但我们也有更神秘的集合，如`BitArray`或`SynchronizedReadOnlyCollection<T>`。我们可以使用C#提供的任何集合（泛型或非泛型）上的`AddRange`方法。
- en: Why don’t we have some fun, take the scenic route, and use a special collection
    called `SortedList<T>`? Alternatively, you could add all entries to a generic
    `List<T>` and call its `Sort` method. Because `SortedList<T>` is a generic collection,
    we find it in the `System.Collections.Generics` namespace. If we want to use the
    `System.Collections .Generics` namespace, that means we also have to import the
    namespace.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不让我们有点乐趣，走风景路线，并使用一个名为`SortedList<T>`的特殊集合呢？或者，你也可以将所有条目添加到一个泛型`List<T>`中，并调用它的`Sort`方法。因为`SortedList<T>`是一个泛型集合，所以我们可以在`System.Collections.Generics`命名空间中找到它。如果我们想使用`System.Collections.Generics`命名空间，这意味着我们还需要导入该命名空间。
- en: 'A `SortedList` allows for the collection to be sorted. To use a `SortedList`,
    we just have to add some data and, sometimes, specify how we want to sort the
    elements. A `SortedList` containing integers sorts elements by integer value,
    whereas a `SortedList` containing strings sorts elements alphabetically. If we
    want to sort an object (such as instances of type `Airport`), however, there is
    a catch: `SortedList`, when used with a nonprimitive type, turns into `SortedList<K,
    V>`, where `K` is a sortable primitive type and `V` is our object.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedList`允许对集合进行排序。要使用`SortedList`，我们只需添加一些数据，有时还需要指定我们想要如何排序元素。包含整数的`SortedList`按整数值排序元素，而包含字符串的`SortedList`按字母顺序排序元素。然而，如果我们想对一个对象（如`Airport`类型的实例）进行排序，那么有一个问题：当与非原始类型一起使用时，`SortedList`变成了`SortedList<K,
    V>`，其中`K`是可排序的原始类型，而`V`是我们的对象。'
- en: We want to sort objects of type `Airport`. Let’s keep things interesting and
    sort them alphabetically by IATA code, rather than `AirportID`. This means we
    use the string primitive type as the first generic type in `SortedList<K, V>`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想对`Airport`类型的对象进行排序。让我们保持有趣，并按IATA代码的字母顺序对它们进行排序，而不是`AirportID`。这意味着我们在`SortedList<K,
    V>`中将字符串原始类型用作第一个泛型类型。
- en: 'We start by creating a `SortedList<string, Airport>` in the `TestInitialize`
    method and populate it with a handful of objects. Beginning with the airport we
    already added in the `TestInitialize` method (GOH—Nuuk, Greenland), we add `Airport`
    elements for PHX (Phoenix, AZ), DDH (Bennington, VT), and RDU (Raleigh-Durham,
    NC) as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`TestInitialize`方法中创建一个`SortedList<string, Airport>`，并用一些对象填充它。从我们在`TestInitialize`方法中已经添加的机场（GOH—Nuuk，格陵兰）开始，我们按照以下方式添加`Airport`元素：PHX（凤凰城，亚利桑那州），DDH（本宁顿，佛蒙特州），和RDU（罗利-达勒姆，北卡罗来纳州）。
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When inspecting the `SortedList<string, Airport>` after all those additions,
    we see an alphabetically sorted collection shown in figure 9.7: `"DDH"` -> `"GOH"`
    -> `"PHX"` -> `"RDU"`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加所有这些之后检查`SortedList<string, Airport>`，我们看到图9.7中显示的按字母顺序排序的集合：“DDH” -> “GOH”
    -> “PHX” -> “RDU”。
- en: '![](../Images/09_07.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7](../Images/09_07.png)'
- en: Figure 9.7 `SortedList` takes in data and sorts that data based on a sorting
    type. In this example, we sort based on the string primitive type. This results
    in an alphabetically sorted collection.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 `SortedList`接收数据并根据排序类型对数据进行排序。在这个例子中，我们根据字符串原始类型进行排序。这导致了一个按字母顺序排序的集合。
- en: 'To add the values from the sorted list to the in-memory database, we use the
    `AddRange` LINQ method on the `context`’s `DbSet<Airport>` as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要将排序列表中的值添加到内存数据库中，我们使用`context`的`DbSet<Airport>`上的`AddRange` LINQ方法，如下所示：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Adding all the values from the `SortedList<string, Airport>` to the `DbSet<Airport>`
    using `AddRange` is a piece of cake. Back when I asked you to think about what
    the best way to add a collection of elements to a different collection was, you
    may have thought we had to use a `foreach` loop and manually add all elements
    to the database. Under the hood, that is exactly what is happening when we use
    `AddRange,` but I for one am very thankful for the syntactical sugar that LINQ
    offers us. It saves a lot of typing, and using `AddRange` increases code clarity
    as well because the code is still very readable and condensed. That being said,
    we need to be sure we call the `SortedList<string, Airport>`’s `Value` property
    in the `AddRange` call, or else we would get the key-value pairs in the list instead
    of the `Airport` instances. Because `DbSet<Airport>` has a generic constraint
    around the `Airport` type, we cannot add instances of type `string` to the collection.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `AddRange` 将 `SortedList<string, Airport>` 中的所有值添加到 `DbSet<Airport>` 中轻而易举。回想一下，当我让你思考将一组元素添加到不同集合中的最佳方法时，你可能认为我们必须使用
    `foreach` 循环并手动将所有元素添加到数据库中。实际上，当我们使用 `AddRange` 时，背后正是这样操作的，但我非常感激 LINQ 给我们的语法糖。它节省了很多打字，而且使用
    `AddRange` 还提高了代码的可读性和简洁性。话虽如此，我们确实需要确保在 `AddRange` 调用中调用 `SortedList<string,
    Airport>` 的 `Value` 属性，否则我们将会得到列表中的键值对而不是 `Airport` 实例。由于 `DbSet<Airport>` 对 `Airport`
    类型有泛型约束，我们不能将 `string` 类型的实例添加到集合中。
- en: 'To be safe, let’s run all existing tests and verify we broke nothing with this
    implementation. It looks like we are good. Now for the fun part: asserting that
    the entities entered into the database are there and that we can retrieve them.
    We can inline the `AirportId`s by using the familiar `[DataRow]` method attribute.
    Then, we call `GetAirportByID` and contrast the returned `Airport` instance to
    what we retrieve from the database directly from the context by using the `airportId`
    passed in by the MSTest runner, as shown in the next listing.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，让我们运行所有现有的测试并验证我们没有因为这种实现而破坏任何东西。看起来我们做得很好。现在轮到有趣的部分了：断言进入数据库的实体确实存在，并且我们可以检索它们。我们可以通过使用熟悉的
    `[DataRow]` 方法属性内联 `AirportId`s。然后，我们调用 `GetAirportByID` 并将返回的 `Airport` 实例与 MSTest
    运行器传入的 `airportId` 直接从上下文中检索到的结果进行对比，如下一个列表所示。
- en: Listing 9.7 Using the `DataRow` attribute to test for `GetAirportByID` success
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 使用 `DataRow` 属性测试 `GetAirportByID` 成功
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Uses the [DataRow] method attribute to inline test data
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 [DataRow] 方法属性内联测试数据
- en: ❷ Retrieves the matching Airport (based on AirportId) from the database
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从数据库中检索匹配的机场（基于 AirportId）
- en: ❸ Asserts the retrieved Airport instance against the one in the database
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言检索到的机场实例与数据库中的实例一致
- en: We could also have created a hardcoded `Airport` instance, added that to the
    database in our test setup, and used it to check that the correct `Airport` was
    inserted. This approach is fine, but I prefer to query the in-memory database
    in every test. This is more explicit because you don’t rely on some code done
    in a different spot to run the test you are looking at. All that is left for us
    to do before declaring the `AirportRepository` finished is to write a unit test
    for the database exception logic branch.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建一个硬编码的 `Airport` 实例，将其添加到测试设置中的数据库中，并使用它来检查是否正确插入了 `Airport`。这种方法是可行的，但我更喜欢在每个测试中查询内存数据库。这更明确，因为你不需要依赖其他地方编写的代码来运行你正在查看的测试。在我们宣布
    `AirportRepository` 完成之前，我们还需要为数据库异常逻辑分支编写单元测试。
- en: Testing for a database exception with a stub
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存根测试数据库异常
- en: In this section, we’ll test the logic branch where the database encounters an
    error during the call to `SaveChangesAsync`. To test the database exception logic
    path, we have to update `FlyingDutchmanContext_Stub`’s overridden `SaveChangesAsync`
    method to perform a `switch` based on the airport’s ID. If `AirportID` evaluates
    to anything other than `0`, `1`, `2`, or `3` (because we used those values for
    `AirportId`s in the success test case), the stub throws an exception. How about
    we use an integer value of `10` for this, as shown in the next code sample? It’s
    as good as any number.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将测试数据库在调用 `SaveChangesAsync` 时遇到错误的逻辑分支。为了测试数据库异常逻辑路径，我们必须更新 `FlyingDutchmanContext_Stub`
    中重写的 `SaveChangesAsync` 方法，根据机场的 ID 执行 `switch` 操作。如果 `AirportID` 评估结果不是 `0`、`1`、`2`
    或 `3`（因为我们使用了这些值作为成功测试用例中的 `AirportId`），则存根会抛出异常。我们是否可以使用下一个代码示例中的整数值 `10` 呢？这和任何数字一样好。
- en: Listing 9.8 Changing the stub’s `SaveChangesAsync` to test `AirportRepository`
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8 将存根的 `SaveChangesAsync` 更改为测试 `AirportRepository`
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Switches expression based on AirportId
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 根据机场ID切换表达式
- en: ❷ If AirportID is 10, throws an exception
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果机场ID是10，则抛出异常
- en: '❸ The default case: returns out of the method'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 默认情况：从方法中返回
- en: 'Now, for the unit test, let’s create a new unit test method called `GetAirportByID_
    Failure_DatabaseException`. Because the `GetAirportByID` method throws an exception
    of type `AirportNotFoundException` when a database error occurs, the unit test
    needs to expect this. We use our trusted `[ExpectedException]` method attribute
    for this as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了进行单元测试，让我们创建一个新的单元测试方法，名为 `GetAirportByID_Failure_DatabaseException`。因为当数据库发生错误时，`GetAirportByID`
    方法会抛出类型为 `AirportNotFoundException` 的异常，单元测试需要预期这种情况。我们使用我们信任的 `[ExpectedException]`
    方法属性来实现，如下所示：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The test should pass. And with that, we wrapped up `AirportRepository`. We have
    only one more to go before we implement the service layer.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该通过。就这样，我们完成了 `AirportRepository` 的实现。在我们实现服务层之前，我们只剩下一个要完成。
- en: 9.6 Implementing the Flight repository
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 实现飞行仓库
- en: 'Although it may not seem like it, we are actually almost done with most of
    the heavy work required to implement the Flying Dutchman Airlines next-gen API
    for FlyTomorrow. Because we perform most of the logic in the repository layer
    classes, the services and controllers act more as pass-throughs and data combiners.
    The most complicated logic inside a codebase often finds itself inside the repository
    layer due to the inherent complexity of dealing with a database. In a repository/service
    pattern, after implementing all the repositories, you have the logic that manipulates
    the state of a model wrapped up. But we are not quite there yet: in this section,
    we’ll implement the `FlightRepository` along with the appropriate unit tests.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来可能不是这样，但实际上我们几乎完成了实现飞往明天航空公司下一代 API 所需的大部分繁重工作。因为我们大多数逻辑都在仓库层类中执行，所以服务和控制器更像是一个中继器和数据组合器。代码库中最复杂的逻辑通常发现自己位于仓库层，因为处理数据库的固有复杂性。在仓库/服务模式中，在实现所有仓库之后，你将拥有操作模型状态的逻辑封装起来。但我们还没有完全完成：在本节中，我们将实现
    `FlightRepository` 以及相应的单元测试。
- en: 'Go ahead and create the skeleton classes of `FlightRepository` and `FlightRepositoryTests`.
    As with `AirportRepository`, we need only one method in `FlightRepository`: `GetFlightByFlightNumber`.
    Before continuing, please also create a barebones `GetFlightByFlightNumber` method
    in `FlightRepository`. If you get stuck, see chapters 6 and 7 for more detailed
    walk-throughs.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建 `FlightRepository` 和 `FlightRepositoryTests` 的骨架类。与 `AirportRepository`
    一样，我们只需要在 `FlightRepository` 中实现一个方法：`GetFlightByFlightNumber`。在继续之前，请也在 `FlightRepository`
    中创建一个空的 `GetFlightByFlightNumber` 方法。如果你遇到困难，请参阅第 6 章和第 7 章以获取更详细的说明。
- en: 'The `GetFlightByFlightNumber` method accepts the following three parameters
    of type `\1`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFlightByFlightNumber` 方法接受以下三个类型为 `\1` 的参数：'
- en: '`flightNumber`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flightNumber`'
- en: '`originAirportId`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`originAirportId`'
- en: '`destinationAirportId`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destinationAirportId`'
- en: 'The `originAirportId` and `destinationAirportId` parameters signify the airports
    from which the flight departs (`originAirportId`) and arrives (`destinationAirportId`).
    The IDs of the airports are subject to a foreign key constraint in the database.
    This means that in a `Flight` instance, the `originAirportId` and `destinationAirportId`
    point to specific `Airport` instances in the database matched based on their IDs.
    All three input parameters need to be a non-negative integer. We could use only
    the flight number to identify the flight and not bother with the extra airport
    details. In order to teach you how to retrieve data by using foreign key constraints,
    we’ll use and retrieve the airport IDs. Previously, in the `BookingRepository.CreateBooking`
    method, we defined a conditional code block that checked whether the input parameters
    of `customerID` and `flightNumber` were valid arguments matched against the same
    validation rule we have for `originAirportId` and `destinationAirportId` (they
    need to be positive integers) as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`originAirportId` 和 `destinationAirportId` 参数表示航班起飞的机场 (`originAirportId`)
    和到达的机场 (`destinationAirportId`)。机场的 ID 在数据库中受到外键约束。这意味着在一个 `Flight` 实例中，`originAirportId`
    和 `destinationAirportId` 会指向数据库中基于其 ID 匹配的特定 `Airport` 实例。所有三个输入参数都需要是非负整数。我们可以仅使用航班号来识别航班，而不必担心额外的机场详情。为了教您如何使用外键约束检索数据，我们将使用并检索机场
    ID。之前，在 `BookingRepository.CreateBooking` 方法中，我们定义了一个条件代码块，该代码块检查 `customerID`
    和 `flightNumber` 的输入参数是否是有效的参数，这些参数与我们对 `originAirportId` 和 `destinationAirportId`
    的验证规则相同（它们需要是正整数），如下所示：'
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can use this code for the input validation of the `originAirportId` and
    `destinationAirportId` parameters of `GetFlightByFlightNumber`. But we don’t just
    want to copy and paste the code: that would be a violation of the DRY principle,
    and copying and pasting is just bad practice in general. Instead, we should extract
    the conditional into a method accessible to both the `BookingRepository` and the
    `FlightRepository`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此代码对 `GetFlightByFlightNumber` 的 `originAirportId` 和 `destinationAirportId`
    参数进行输入验证。但我们不想只是复制和粘贴代码：这将违反 DRY 原则，而且复制和粘贴通常是一种不好的做法。相反，我们应该将条件提取到一个方法中，该方法对
    `BookingRepository` 和 `FlightRepository` 都是可访问的。
- en: 'We could name the method `IsPositive`, have it take an `integer` as a parameter,
    check whether it is more than (or equal to) zero, and return that result. Then,
    we could instantiate a new instance of `BookingRepository` in `FlightRepository`
    and access the `IsPositive` method, as shown next:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将该方法命名为 `IsPositive`，它接受一个 `integer` 作为参数，检查它是否大于（或等于）零，并返回该结果。然后，我们可以在
    `FlightRepository` 中实例化一个新的 `BookingRepository` 实例，并访问 `IsPositive` 方法，如下所示：
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This seems messy and is a good example of bad coupling. If `FlightRepository`
    makes a method call to `BookingRepository`, we banish them to a dependent and
    coexisting life. In that scenario, changing the `BookingRepository` may have unintended
    consequences in `FlightRepository`. Instead, we can create an extension method
    on the `integer` type that determines whether an integer is positive (more than
    or equal to 0).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很混乱，是糟糕耦合的一个好例子。如果 `FlightRepository` 调用 `BookingRepository` 的方法，我们将它们放在一起，共同生活。在这种情况下，修改
    `BookingRepository` 可能会对 `FlightRepository` 产生意外的后果。相反，我们可以在 `integer` 类型上创建一个扩展方法，以确定一个整数是否为正（大于或等于
    0）。
- en: 9.6.1 The IsPositive extension method and “magic numbers”
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.1 `IsPositive` 扩展方法和“魔法数字”
- en: First, we want to make sure we separate our extension method from other code.
    Let’s create a new class called `ExtensionMethods`. We place this in the root
    of the `FlyingDutchmanAirlines` project, as shown in figure 9.8, because creating
    a special folder (also called ExtensionMethods) to contain a single class would
    be overkill (unless you expect multiple files in the respective folder in the
    future).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想确保我们将扩展方法与其他代码分开。让我们创建一个新的类，称为 `ExtensionMethods`。我们将这个类放在 `FlyingDutchmanAirlines`
    项目的根目录下，如图 9.8 所示，因为为包含单个类创建一个特殊的文件夹（也称为 ExtensionMethods）将是过度设计（除非你预计将来该文件夹中会有多个文件）。
- en: '![](../Images/09_08.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09_08.png)'
- en: Figure 9.8 The `ExtensionMethods` class is placed at the root of the FlyingDutchmanAirlines
    project. `ExtensionMethods` are not an architectural layer, nor will we have more
    than one of them, so leaving the class in the root is fine.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 `ExtensionMethods` 类放置在 FlyingDutchmanAirlines 项目的根目录下。`ExtensionMethods`
    不是一个架构层，我们也不会有多个，所以将类留在根目录下是可以的。
- en: 'Our `ExtensionMethods` class can have an access modifier of `internal` because
    we are not writing a unit test specifically for the extension method. The `internal`
    access modifier is perfect for us in this case because we can scope the access
    to only the `FlyingDutchmanAirlinesNextGen` solution. The unit test coverage for
    the `ExtensionMethods` class is implicit and done through unit tests that cover
    methods calling the respective extension method. The `ExtensionMethods` class
    should also be static because we want to use the same instance of the class across
    the codebase. There is no need to instantiate a new instance of `ExtensionMethods`
    every time we want to check if an integer is positive, nor does the extension
    method we write change any object states. Previously, I held a diatribe about
    the pitfalls of using `static`. A class meant to wrap a collection of `ExtensionMethods`
    is supposed to be static, as shown here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ExtensionMethods`类可以具有`internal`访问修饰符，因为我们不是专门为扩展方法编写单元测试。在这种情况下，`internal`访问修饰符对我们来说非常合适，因为我们可以将访问范围仅限于`FlyingDutchmanAirlinesNextGen`解决方案。`ExtensionMethods`类的单元测试覆盖率是隐式的，并通过覆盖调用相应扩展方法的单元测试来完成。`ExtensionMethods`类还应该是静态的，因为我们希望在代码库中跨实例使用同一个类的实例。每次我们想要检查一个整数是否为正时，没有必要实例化一个新的`ExtensionMethods`实例，我们编写的扩展方法也不会改变任何对象的状态。之前，我谈到了使用`static`的陷阱。旨在封装一组`ExtensionMethods`的类应该是静态的，如下所示：
- en: '[PRE23]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To create an extension method, as discussed in section 6.3.2, we use the `this`
    keyword followed by the type we want to create an extension method for as part
    of the parameter list. You can create extension methods for any type (interfaces,
    classes, primitive types) as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建扩展方法，如第6.3.2节所述，我们在参数列表中使用`this`关键字，后面跟着我们想要为它创建扩展方法的类型。你可以为任何类型（接口、类、原始类型）创建扩展方法，如下所示：
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](../Images/09_08_UN02.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8](../Images/09_08_UN02.png)'
- en: Within the scope of the `FlyingDutchmanAirlinesNextGen` project (because of
    `ExtensionMethods` and `IsPositive`’s `internal` access modifier), we can now
    call the `IsPositive` on *every* instance of type `integer`, as shown in figure
    9.9.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FlyingDutchmanAirlinesNextGen`项目的作用域内（由于`ExtensionMethods`和`IsPositive`的`internal`访问修饰符），我们现在可以在类型`integer`的每个实例上调用`IsPositive`，如图9.9所示。
- en: '![](../Images/09_09.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9](../Images/09_09.png)'
- en: Figure 9.9 The `IsPositive` extension method is available to all integers. For
    example, `airportID` can call the `IsPositive` method.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 `IsPositive`扩展方法对所有整数都可用。例如，`airportID`可以调用`IsPositive`方法。
- en: Compiling extension methods
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 编译扩展方法
- en: Extension methods sound great, but how are they executed? The call to the `IsPositive`
    extension method is resolved by the compiler at compile time. When the compiler
    encounters the `IsPositive` method call, it first checks if a method exists within
    the scope of the calling class. If not, which is the case we find ourselves in,
    the compiler checks for any public `static` methods in static classes with the
    same name. If a found `static` method also operates on the correct type (by using
    the `this` keyword in the method’s parameter list), the compiler has found a match
    and generates the Intermediate Language code that calls the method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法听起来很棒，但它们是如何执行的？对`IsPositive`扩展方法的调用是在编译时由编译器解析的。当编译器遇到`IsPositive`方法调用时，它首先检查调用类的作用域内是否存在该方法。如果没有，即我们目前所处的情形，编译器会检查静态类中是否存在具有相同名称的任何公共`static`方法。如果找到的`static`方法也操作正确的类型（通过在方法参数列表中使用`this`关键字），编译器就找到了匹配项，并生成调用该方法的中间语言代码。
- en: 'Do note that, as with any method, if you have two extension methods with the
    same name and operating type but in different classes, the compiler cannot resolve
    which one to call. When this happens, the compiler throws an ambiguity compiler
    error: “CS0121 The call is ambiguous between the following methods or properties
    [*method/ property 1*] and [*method/property 2*].” To resolve an ambiguity error,
    you need to give the compiler enough information so it can determine which method
    to call.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与任何方法一样，如果你有两个具有相同名称和操作类型但位于不同类中的扩展方法，编译器无法解析调用哪一个。当这种情况发生时，编译器会抛出一个歧义编译错误：“CS0121
    调用在以下方法或属性[*方法/属性 1*]和[*方法/属性 2*]之间是模糊的。”为了解决歧义错误，你需要给编译器足够的信息，以便它可以确定调用哪个方法。
- en: 'As far as the actual logic inside the `IsPositive` method goes, all we have
    to do is return whether the input argument is more than or equal to zero as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`IsPositive`方法内部的实际逻辑，我们只需返回输入参数是否大于或等于零，如下所示：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Nice and simple. You just wrote your first extension method!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 简单明了。你刚刚编写了你的第一个扩展方法！
- en: We have a little cleanup to do before we move on. We need to remove the conditional
    code block that validates the input arguments to the `BookingRepository .CreateBooking`
    method, replacing it with a call to our brand-new `IsPositive` extension method.
    In the input validation code, we have to negate the call to `IsPositive`, as shown
    next, because we want to know when the input argument is *not* a positive integer.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，我们需要做一些清理工作。我们需要移除验证 `BookingRepository.CreateBooking` 方法输入参数的条件代码块，用对我们的全新
    `IsPositive` 扩展方法的调用来替换它。在输入验证代码中，我们必须对 `IsPositive` 的调用取反，如下所示，因为我们想知道输入参数不是正整数的情况。
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: An identical conditional in `AirportRepository.GetAirportByID` remains that
    I leave for you to remove and replace. Not only do we now adhere to the DRY principle,
    but the calls to the `IsPositive` extension method are more readable than checking
    whether something is more than or equal to zero. A new developer would not intuitively
    know why we are checking whether something is more than zero. A random hardcoded
    number like that is what we call a “magic number.” By writing code that is explicit
    and doesn’t use a magic number, any developer can see that we are checking whether
    `customerID` and `flightNumber` are *not* positive integers.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AirportRepository.GetAirportByID` 中的相同条件仍然留给你去移除和替换。我们不仅现在遵循DRY原则，而且对 `IsPositive`
    扩展方法的调用比检查某个数是否大于或等于零更易读。一个新开发者可能不会直观地知道我们为什么检查某个数是否大于零。这样的随机硬编码数字就是我们所说的“魔法数字”。通过编写明确且不使用魔法数字的代码，任何开发者都可以看到我们正在检查
    `customerID` 和 `flightNumber` 是否不是正整数。
- en: '| ![](../Images/ThumbsUp.png)   |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| ![点赞](../Images/ThumbsUp.png)   |'
- en: Magic numbers
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法数字
- en: Suppose we are writing code to handle the steering of a car. Imagine what a
    method to move a car forward looks like. Have a look at the following code block.
    Is there anything wrong with it?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在编写处理汽车转向的代码。想象一下移动汽车前进的方法看起来是什么样子。看看下面的代码块。它有什么问题吗？
- en: '[PRE27]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `MoveCarForward` method has the following two interesting aspects:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveCarForward` 方法有两个有趣的特点：'
- en: First, we know we can use a switch or `switch` expressions to condense this
    code a bit, but we’ll let that one go. We just want to clean up the code with
    minimal destruction of the existing pattern.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们知道我们可以使用 switch 或 switch 表达式来稍微压缩一下这段代码，但我们会放过这个。我们只想以最小的破坏性清理代码。
- en: Second, the code determines the direction the car moves in by comparing the
    direction input argument against predefined numbers. The numbers represent cardinal
    points in degrees as mapped out on a unit circle. That is not clear from the current
    code unless you have that knowledge. Numbers that appear randomly in code, hardcoded
    and without context, are what we call magic numbers.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，代码通过比较方向输入参数与预定义的数字来确定汽车移动的方向。这些数字代表在单位圆上映射出的度数上的基本方向。除非你有这方面的知识，否则这一点在当前代码中并不明显。代码中随机出现的数字，硬编码且没有上下文，就是我们所说的魔法数字。
- en: These numbers (0, 90, 270, and 360) are meaningless unless we know the context
    of what they should represent. We can do better than that.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些数字（0、90、270和360）如果没有我们知道它们应该代表什么上下文，就没有意义。我们可以做得更好。
- en: When hardcoding numbers like that, you risk a developer unfamiliar with your
    intentions changing the number to “fix” something. If you had provided more context
    around what they represent, the code would be more readable, and the developer
    would likely not have touched their values. To do this, I suggest extracting the
    numbers into private constants. The value of a constant is defined at compile
    time and cannot change at run time. This ensures that the value never changes
    from what you defined it to be.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当硬编码这样的数字时，你冒着开发者不了解你的意图而更改数字以“修复”某事的危险。如果你提供了更多关于它们代表什么的上下文，代码将更易读，开发者可能不会更改它们的值。为此，我建议将数字提取到私有常量中。常量的值在编译时定义，在运行时不能更改。这确保了值永远不会从你定义的值改变。
- en: 'With `MoveCarForward`, we can isolate four potential constants: `DEGREES_NORTH_
    LOWER_BOUND`, `DEGREES_NORTH_UPPER_BOUND`, `DEGREES_WEST`, and `DEGREES_EAST`.
    It is my preference to always use snake casing (all letters are uppercase and
    punctuation, including spaces, are replaced by underscores) for constants, as
    shown next. This clarifies that a given variable has an immutable, predefined
    value.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MoveCarForward`，我们可以隔离四个潜在的常量：`DEGREES_NORTH_LOWER_BOUND`、`DEGREES_NORTH_UPPER_BOUND`、`DEGREES_WEST`和`DEGREES_EAST`。我更喜欢始终使用蛇形大小写（所有字母都是大写，标点符号包括空格都替换为下划线），如下所示。这清楚地表明一个给定的变量有一个不可变的、预定义的值。
- en: '[PRE28]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code is much more readable. We know now exactly what the magic numbers
    represent. In fact, there are no magic numbers anymore. Whenever you see a hardcoded
    numerical representation of anything, ask yourself, should I refactor this magic
    number to a constant or a local variable?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的可读性更强。我们现在确切地知道这些神奇数字代表什么。事实上，再也没有神奇数字了。每次你看到任何东西的硬编码数值表示时，问问自己，我应该将这个神奇数字重构为常量或局部变量吗？
- en: '|'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Of course, we need to run the unit tests for `BookingRepository` before we move
    on. I advise running every unit test in your test suite every time you make a
    change instead of limiting yourself to the tests in just the file you are messing
    with. Luckily, they pass. This is good because the only thing we did so far was
    extract existing logic into an extension method.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在我们继续之前，我们需要运行`BookingRepository`的单元测试。我建议每次你进行更改时都运行你的测试套件中的每个单元测试，而不仅仅局限于你正在弄乱的那个文件中的测试。幸运的是，它们都通过了。这是因为到目前为止，我们唯一做的事情就是将现有逻辑提取到扩展方法中。
- en: Let’s use our new extension method to validate the `originAirportId` and `destinationAirportId`
    input arguments in `FlightRepository.GetFlightByFlightNumber`, as shown in the
    next listing. In case one of the input arguments is invalid, we throw an exception
    of type `ArgumentException` and log a message to the console.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们新的扩展方法来验证`FlightRepository.GetFlightByFlightNumber`中的`originAirportId`和`destinationAirportId`输入参数，如下所示的下一条列表。如果其中一个输入参数无效，我们抛出类型为`ArgumentException`的异常，并将消息记录到控制台。
- en: Listing 9.9 `GetFlightByFlightNumber` airport `Ids` input validation
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.9 `GetFlightByFlightNumber`机场`Ids`输入验证
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Calls the extension method to validate the input arguments
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用扩展方法来验证输入参数
- en: ❷ Logs the invalid arguments to the console
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将无效参数记录到控制台
- en: ❸ Throws an ArgumentException if the input is invalid
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果输入无效则抛出`ArgumentException`
- en: ❹ Returns a temporary new instance of Flight. We’ll change this implementation
    in section 9.6.2.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 返回一个临时的新`Flight`实例。我们将在第9.6.2节中更改此实现。
- en: 'To prove our code works as expected, we create the next two unit tests:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明我们的代码按预期工作，我们创建了以下两个单元测试：
- en: '`GetFlightByFlightnumber_Failure_InvalidOriginAirport`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetFlightByFlightnumber_Failure_InvalidOriginAirport`'
- en: '`GetFlightByFlightnumber_Failure_InvalidDestinationAirport`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetFlightByFlightnumber_Failure_InvalidDestinationAirport`'
- en: 'Both the unit tests should verify that the `GetFlightByFlightNumber` method
    throws an exception of type `FlightNotFoundException` during execution of the
    respective test as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个单元测试都应该验证在执行相应的测试期间，`GetFlightByFlightNumber`方法抛出类型为`FlightNotFoundException`的异常，如下所示：
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'That takes care of the input validation for the `originAirportId` and `destinationAirportId`
    input arguments. But what about `flightNumber`? We can quickly add a conditional
    to check whether `flightNumber` is a positive integer. If `flightNumber` is not
    a positive integer, we want to log a message to the console and throw an error
    of our new exception type (I leave this for you to implement) called `FlightNotFoundException`
    as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这就处理了`originAirportId`和`destinationAirportId`输入参数的输入验证。但`flightNumber`怎么办呢？我们可以快速添加一个条件来检查`flightNumber`是否为正整数。如果`flightNumber`不是一个正整数，我们希望向控制台记录一条消息并抛出我们新异常类型的错误（我留给你来实现），称为`FlightNotFoundException`，如下所示：
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We also need a unit test to prove that the `GetFlightByFlightnumber` method
    throws an error of exception `FlightNotFoundException` when `flightNumber` is
    an invalid input argument, as shown here:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个单元测试来证明当`flightNumber`是一个无效的输入参数时，`GetFlightByFlightnumber`方法会抛出异常`FlightNotFoundException`，如下所示：
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 9.6.2 Getting a flight out of the database
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.2 从数据库中获取航班
- en: Let’s recap what we have done so far with the `FlightRepository` and `FlightRepositoryTests`
    classes. In the previous sections, we created and partially implemented a `GetFlightByFlightNumber`
    method in the `FlightRepository` class. The `GetFlightByFlightNumber` method currently
    performs input validation on the input `if` arguments (`flightNumber`, `originAirportId`,
    and `destinationAirportID`) and returns a placeholder `Flight` instance. We also
    created three unit tests in the `FlightRepositoryTests` class that check the input
    validations for their invalid input argument cases.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下到目前为止使用 `FlightRepository` 和 `FlightRepositoryTests` 类所做的工作。在前面的章节中，我们在
    `FlightRepository` 类中创建并部分实现了 `GetFlightByFlightNumber` 方法。当前的 `GetFlightByFlightNumber`
    方法对输入参数（`flightNumber`、`originAirportId` 和 `destinationAirportID`）进行输入验证，并返回一个占位符
    `Flight` 实例。我们还在 `FlightRepositoryTests` 类中创建了三个单元测试，用于检查无效输入参数情况下的输入验证。
- en: In this section, we implement the actual logic to retrieve a `Flight` instance
    from the database given its flight number. To do this, we take the same approach
    as we have done so many times before. We query the database’s `DbSet<Flight>`
    for the matching flight. If the database throws an exception, we log the problem
    to the console with a developer-friendly message and throw a new exception. If
    all goes well, we return the found object of type `Flight`. But first, let’s create
    the success case unit test and success setup code in `TestInitialize` shown next.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们实现实际逻辑以从数据库中检索给定航班号的 `Flight` 实例。为此，我们采取了与之前多次使用相同的方法。我们查询数据库的 `DbSet<Flight>`
    以获取匹配的航班。如果数据库抛出异常，我们将问题记录到控制台，并使用开发者友好的消息抛出新的异常。如果一切顺利，我们返回找到的 `Flight` 类型的对象。但在做之前，让我们创建
    `TestInitialize` 中显示的成功用例单元测试和成功设置代码。
- en: Listing 9.10 Testing `GetFlight`
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 测试 `GetFlight`
- en: '[PRE33]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Creates and populates an instance of Flight
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建并填充一个 `Flight` 实例
- en: ❷ Adds the flight object to the EF Core’s internal DbSet<Flight>
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将航班对象添加到 EF Core 的内部 DbSet<Flight>
- en: ❸ Saves the flight to the in-memory database
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将航班保存到内存数据库中
- en: ❹ Executes GetFlightByFlightNumber
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 执行 GetFlightByFlightNumber
- en: ❺ Gets the flight from the database
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 从数据库获取航班
- en: ❻ Compares the flight from GetFlightByFlightNumber against the database’s flight
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将 GetFlightByFlightNumber 获取的航班与数据库中的航班进行比较
- en: 'The `GetFlightByFlightNumber_Success` unit test fails because we are returning
    a temporary new (empty) instance of `Flight` in `GetFlightByFlightNumber`. We
    should change that to return the first match in the database when given the `flightNumber`.
    We can use the same pattern for returning a database entity we used in `AirportRepository.GetAirportByID`:
    use a LINQ `FirstOrDefaultAsync` call to select an entity or return a default
    value (null in this case), followed by the null-coalescing operator, which throws
    an exception in case of null, as shown next:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFlightByFlightNumber_Success` 单元测试失败，因为我们正在 `GetFlightByFlightNumber` 中返回一个临时的新（空）`Flight`
    实例。我们应该将其更改为在给定 `flightNumber` 时返回数据库中的第一个匹配项。我们可以使用与 `AirportRepository.GetAirportByID`
    中使用的相同模式来返回数据库实体：使用 LINQ 的 `FirstOrDefaultAsync` 调用来选择实体或返回默认值（在这种情况下为 null），然后是空合并运算符，它在出现
    null 的情况下抛出异常，如下所示：'
- en: '[PRE34]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code either returns the correct instance of `Airport` as found in the database
    or throws an exception of type `AirportNotFoundException`. But who is to believe
    us without seeing the success case unit test pass and having a failure case unit
    test ready as well? Well, fear no more. With this code change, the `GetFlightByFlightNumber_
    Success` unit test passes.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码要么返回数据库中找到的正确 `Airport` 实例，要么抛出 `AirportNotFoundException` 类型的异常。但如果没有看到成功用例单元测试通过，并且有一个失败用例单元测试准备就绪，谁会相信我们呢？不用担心。随着这个代码更改，`GetFlightByFlightNumber_Success`
    单元测试通过了。
- en: 'All that is left for us to do before we wrap up both the `FlightRepository`
    and this chapter is to create a unit test that proves the `GetFlightByFlightNumber`
    method exception of type `FlightNotFoundException` if the input arguments of `flightNumber`,
    `originAirportId`, and `destinationAirportId` are correct but a database error
    threw an exception, as shown next. We have done this a couple of times by now,
    so if you want to give it a shot on your own before looking at the code: go ahead,
    I’ll wait.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成 `FlightRepository` 和本章之前，我们还需要做的是创建一个单元测试，以证明如果输入参数 `flightNumber`、`originAirportId`
    和 `destinationAirportId` 正确，但数据库错误抛出异常，则 `GetFlightByFlightNumber` 方法会抛出 `FlightNotFoundException`
    类型的异常，如下所示。到目前为止，我们已经这样做了几次，所以如果你想在查看代码之前自己尝试一下：请继续，我会等待。
- en: '[PRE35]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And voilà! There it is: one finished `FlightRepository`. We now have the following
    four repositories in our `FlyingDutchmanAirlinesNextGen` codebase:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！就在那里：一个完成的 `FlightRepository`。现在在我们的 `FlyingDutchmanAirlinesNextGen` 代码库中有以下四个存储库：
- en: '`AirportRepository`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AirportRepository`'
- en: '`BookingRepository`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BookingRepository`'
- en: '`CustomerRepository`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomerRepository`'
- en: '`FlightRepository`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlightRepository`'
- en: 'That means we wrapped up the repository portion of the refactor. In the next
    chapter, we’ll go up one level in our architecture and implement the service layer.
    But here is the excellent news: we have completed the heavy lifting. Implementing
    the repository methods first guarantees usable and small methods that do only
    one thing (and do them well). This helps us in the service layer, where we can
    say “give me A, B, and C” and have methods that do each of those operations without
    side effects.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们已经完成了重构的存储库部分。在下一章中，我们将提升架构的一个级别，并实现服务层。但是，这里有令人兴奋的消息：我们已经完成了繁重的工作。首先实现存储库方法保证了可用的且功能单一的方法（并且做得很好）。这有助于我们在服务层，我们可以说“给我
    A、B 和 C”，并且有执行这些操作而不产生副作用的方法。
- en: Exercises
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 9.1
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.1
- en: In test-driven development, the red stage means that
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试驱动开发中，红色阶段表示
- en: a. Your code compiles and the test passes.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: a. 你的代码编译并通过了测试。
- en: b. Your code does not compile or/and the test does not pass.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: b. 你的代码没有编译或测试没有通过。
- en: Exercise 9.2
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.2
- en: In test-driven development, the green stage means that
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试驱动开发中，绿色阶段表示
- en: a. Your code compiles and the test passes.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: a. 你的代码编译并通过了测试。
- en: b. Your code does not compile or/and the test does not pass.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: b. 你的代码没有编译或测试没有通过。
- en: Exercise 9.3
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.3
- en: True or false? You cannot use the `[DataRow]` attribute if you have only one
    data point to test with.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？如果你只有一个数据点进行测试，你不能使用 `[DataRow]` 属性。
- en: Exercise 9.4
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.4
- en: Data streams usually store their data as a sequence of what?
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流通常将它们的数据存储为一系列什么？
- en: a. Slow-moving water that ripples through the landscape
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: a. 在景观中缓慢流动并产生涟漪的水
- en: b. Bytes
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: b. 字节
- en: Exercise 9.5
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.5
- en: True or false? Classes that do not have any derived classes are implicitly abstract.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？没有派生类的类隐式地是抽象的。
- en: Exercise 9.6
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.6
- en: True or false? Every method in an abstract class also needs to be abstract.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？抽象类中的每个方法也必须是抽象的。
- en: Exercise 9.7
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.7
- en: True or false? An abstract method can live in a nonabstract class.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？抽象方法可以存在于非抽象类中。
- en: Exercise 9.8
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.8
- en: True or false? Abstract methods cannot contain a method body. They are supposed
    to be overridden by derived classes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？抽象方法不能包含方法体。它们应该被派生类覆盖。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The abstract class `Stream` is used as the base for many derived classes such
    as `StringWriter` and `TextReader`. We can use streams to deal with continuous
    streams of data such as strings or integers.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类 `Stream` 被用作 `StringWriter` 和 `TextReader` 等派生类的基类。我们可以使用流来处理连续的数据流，如字符串或整数。
- en: We can redirect the console output to an instance of type `StringWriter`. This
    is helpful when testing console output because we can retrieve the contents of
    a `StringWriter` and check for the expected logged data.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将控制台输出重定向到 `StringWriter` 类型的实例。这在测试控制台输出时很有用，因为我们可以检索 `StringWriter` 的内容并检查预期的日志数据。
- en: An abstract class is a class with the `abstract` keyword attached. Abstract
    classes cannot be instantiated or be static. Abstract classes support methods
    with bodies (given the methods are not abstract). They are often used as base
    classes to provide identical implementations of specific methods to all derived
    classes.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类是一个带有 `abstract` 关键字的类。抽象类不能被实例化或声明为静态。抽象类支持具有方法体（假设这些方法不是抽象的）的方法。它们通常用作基类，为所有派生类提供特定方法的相同实现。
- en: The LINQ `AddRange` method allows us to add the contents of one collection (or
    “range” of objects) to another collection. This saves a lot of manual typing and
    iterating over collections.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ 的 `AddRange` 方法允许我们将一个集合（或“对象范围”）的内容添加到另一个集合中。这可以节省大量的手动输入和遍历集合的时间。
- en: A `SortedList<T>` is a generic collection that automatically sorts the input
    data. `SortedList`s are useful for when you need to have a sorted collection and
    do not want to perform manual sorting.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortedList<T>` 是一个泛型集合，它自动对输入数据进行排序。`SortedList` 在你需要有一个排序的集合且不希望进行手动排序时非常有用。'
- en: Extension methods are static methods that extend the functionality of the type
    they perform operations on. Extension methods are often used to execute commonly
    used functionality on primitive types. This means that extension methods are often
    useful in fixing DRY principle violations.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法是扩展它们执行操作的类型的静态方法。扩展方法通常用于在原始类型上执行常用功能。这意味着扩展方法在修复DRY原则（Don't Repeat Yourself）违反方面通常很有用。
- en: Magic numbers are hardcoded values that have no additional context attached
    to them. You often find them in algorithms or conditionals. When seeing a hard-coded
    number with no explanation, it is often hard to figure out what it represents.
    Consider refactoring it out into a local variable of a class-level constant.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 魔数是硬编码的值，它们没有附加的上下文信息。你经常在算法或条件语句中找到它们。当看到没有解释的硬编码数字时，通常很难弄清楚它代表什么。考虑将其重构为一个类级别的常量的局部变量。
- en: '* * *'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^(1.)Why is Boolean capitalized and `bool` is not? When we speak of Boolean
    values, we mean truth values (true and false) through the lens of Boolean algebra.
    Boolean algebra was invented by English mathematician George Bool and first showed
    up in his work *The Mathematical Analysis of Logic: Being an Essay towards a Calculus
    of Deductive Reasoning* (Bool, 1847). When we talk about a `bool`, we mean the
    type inside the C# programming language representing Boolean truth values and
    backed by `System.Boolean`.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '(1.)为什么布尔（Boolean）首字母大写而`bool`则不是？当我们谈论布尔值时，我们是通过布尔代数的视角来指代真值（真和假）。布尔代数是由英国数学家乔治·布尔（George
    Bool）发明的，首次出现在他的著作《逻辑数学分析：演绎推理微积分的论文》（*The Mathematical Analysis of Logic: Being
    an Essay towards a Calculus of Deductive Reasoning*，Bool, 1847）中。当我们提到一个`bool`时，我们指的是C#编程语言中代表布尔真值的类型，并由`System.Boolean`支持。'
