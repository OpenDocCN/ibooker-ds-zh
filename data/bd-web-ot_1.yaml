- en: Part 2\. Building the WoT
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分\. 构建物联网
- en: In [Part 2](#part02) we describe how to build the Web of Things, and we show
    how to implement the various layers of the Web of Things architecture that was
    introduced in [Part 1](kindle_split_007.html#part01).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二部分](#part02)中，我们描述了如何构建物联网，并展示了如何实现[第一部分](kindle_split_007.html#part01)中引入的物联网架构的各个层次。
- en: '[Chapter 6](kindle_split_014.html#ch06) is a quick introduction to the modern
    web architecture and describes how it can be applied to embedded devices and the
    Web of Things.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](kindle_split_014.html#ch06) 是对现代网络架构的快速介绍，并描述了它如何应用于嵌入式设备和物联网。'
- en: '[Chapter 7](kindle_split_015.html#ch07) shows how to implement the concepts
    presented in the previous chapter on various devices.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](kindle_split_015.html#ch07) 展示了如何在各种设备上实现前一章中提出的概念。'
- en: '[Chapter 8](kindle_split_016.html#ch08) introduces the issues of discoverability
    and findability and shows how to use the web techniques to expose and share metadata
    about the services and capabilities of web-connected devices.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](kindle_split_016.html#ch08) 介绍了可发现性和可查找性问题，并展示了如何使用Web技术来公开和共享关于网络连接设备的服务和功能元数据。'
- en: '[Chapter 9](kindle_split_017.html#ch09) offers a quick introduction to web
    security and how to connect devices to the web and share their data in a secure
    manner.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](kindle_split_017.html#ch09) 提供了关于网络安全以及如何以安全方式将设备连接到网络并共享其数据的快速介绍。'
- en: '[Chapter 10](kindle_split_018.html#ch10) shows how to use the techniques and
    methods presented in the previous chapters in order to rapidly build hybrid Web
    of Things applications called physical mashups.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](kindle_split_018.html#ch10) 展示了如何使用前几章中介绍的技术和方法来快速构建名为物理混合应用（physical
    mashups）的混合Web物联网应用。'
- en: 'Chapter 6\. Access: Web APIs for Things'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. 访问：物件的Web API
- en: '*This chapter covers*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Designing APIs for Things based on the REST principles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于REST原则设计物件的API
- en: Implementing RESTful Things with HTTP and WebSockets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP和WebSockets实现RESTful物件
- en: Representing resources with JSON and MessagePack
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON和MessagePack表示资源
- en: Allowing cross-site requests using CORS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许使用CORS进行跨站请求
- en: Using WebSockets and web hooks to implement real-time communication with Things
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WebSockets和Web钩子实现与物件的实时通信
- en: Looking at HTTP/2, the future of HTTP
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探讨HTTP/2，HTTP的未来
- en: By now, it should be clear that the central idea behind the Web of Things is
    to make it easy for devices, services, and applications to talk to each other
    by using patterns and standards that are similar to anything else on the web.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，应该已经很清楚，物联网背后的核心思想是通过使用与网络上的任何其他事物相似的模式和标准，使设备、服务和应用程序能够相互通信。
- en: In this chapter, we’ll describe in detail what those patterns are and will show
    you how to use them to implement web APIs for physical objects. Before jumping
    headfirst into code, a little bit of theory is needed, so we’ll start by exploring
    the fundamentals of the modern web architecture. First, we’ll introduce REST,
    which defines the core architecture of the web. Afterward, we’ll propose a set
    of guidelines and a methodology to design RESTful APIs for physical devices so
    that HTTP clients can easily read data from their sensors or send control commands
    to them. Finally, we’ll expose the limitations of REST APIs over HTTP when it
    comes to real-time sensor data and notifications, and we’ll describe how the latest
    developments in web technologies such as WebSockets can be used to provide push
    notifications for the Web of Things.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细描述这些模式是什么，并展示如何使用它们来实现物理对象的Web API。在深入代码之前，我们需要一点理论，因此我们将从探索现代网络架构的基本原理开始。首先，我们将介绍REST，它定义了网络的核心理架。之后，我们将提出一套指南和方法来设计用于物理设备的RESTful
    API，以便HTTP客户端可以轻松地从它们的传感器读取数据或将控制命令发送给它们。最后，我们将讨论REST API在HTTP上处理实时传感器数据和通知时的局限性，并描述如何利用Web技术如WebSockets的最新发展来为物联网提供推送通知。
- en: 6.1\. Devices, resources, and web Things
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 设备、资源和Web物件
- en: 'Let’s start our discovery of the first layer of the Web of Things architecture
    we presented in the previous chapter. This layer is aptly named Access because
    it covers the most fundamental piece of the WoT puzzle: how to connect a Thing
    to the web so that it can be accessed using standard web tools and libraries.
    By the end of this chapter, you’ll have gained a sound understanding of HTTP and
    WebSockets and how to use them for physical objects. This will allow you to model
    the services and data offered by your Things with a clean, RESTful API that other
    developers and devices can easily understand and use. [Figure 6.1](#ch06fig01)
    illustrates the Access layer of the Web of Things.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上一章中介绍的物联网架构的第一层开始探索。这一层恰当地命名为“访问”，因为它涵盖了物联网拼图中最基本的部分：如何将一个“物”连接到互联网，以便可以使用标准的Web工具和库来访问它。到本章结束时，你将获得对HTTP和WebSockets以及如何用于物理对象的深刻理解。这将使你能够使用干净、RESTful的API来建模你的“物”提供的服务和数据，其他开发者和设备可以轻松理解和使用。![图6.1](#ch06fig01)展示了物联网的访问层。
- en: Figure 6.1\. The Access layer of the Web of Things. This layer assumes that
    Things are connected in some way to the internet and focuses on how devices and
    their resources (properties, services, data, sensors, and so on) can be exposed
    as web APIs.
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1\. 物联网的访问层。这一层假设“物”以某种方式连接到互联网，并关注设备及其资源（属性、服务、数据、传感器等）如何作为Web API公开。
- en: '![](06fig01_alt.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig01_alt.jpg)'
- en: 6.1.1\. Representational State Transfer
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1\. 表现性状态转移
- en: If you’ve ever used web APIs, you’ve certainly come across the term REST or
    RESTful. Representational State Transfer (REST) is a set of architectural principles
    that any distributed system can adopt and that was formalized in Roy Fielding’s
    PhD thesis:^([[1](#ch06fn01)])
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过Web API，你肯定遇到过REST或RESTful这个术语。表现性状态转移（REST）是一套架构原则，任何分布式系统都可以采用，并在Roy
    Fielding的博士论文中得到了正式化：^([[1](#ch06fn01)])
- en: ¹
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Source: [http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm).'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm).
- en: '*REST provides a set of architectural constraints that, when applied as a whole,
    emphasizes scalability of component interactions, generality of interfaces, independent
    deployment of components, and intermediary components to reduce interaction latency,
    enforce security, and encapsulate legacy systems.*'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*REST提供了一套架构约束，当整体应用时，强调组件交互的可扩展性、接口的通用性、组件的独立部署，以及中间件组件以减少交互延迟、加强安全性和封装遗留系统。*'
- en: In short, if the architecture of any distributed system follows the REST constraints,
    that system is said to be RESTful. The idea is that when each component of the
    system (servers and clients) complies with those constraints, the interactions
    between the components are well defined and thus fairly predictable. This maximizes
    interoperability and scalability of the system, which is essential for a global
    system such as the web. These properties are what made the web so successful,
    and that’s because HTTP—the Application layer protocol at the heart of the World
    Wide Web—is based on REST! Another RESTful protocol is CoAP, which we introduced
    in [chapter 5](kindle_split_012.html#ch05) and which will be discussed further
    in [chapter 7](kindle_split_015.html#ch07). REST was designed to enable a large-scale
    distributed system for multimedia content (aka hypermedia), and as the success
    of the web can attest, it’s been working pretty well. Let’s see what those constraints
    are.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果任何分布式系统的架构遵循REST约束，那么该系统就被认为是RESTful的。其理念是，当系统的每个组件（服务器和客户端）都遵守这些约束时，组件之间的交互就得到了很好的定义，因此是相当可预测的。这最大化了系统的互操作性和可扩展性，这对于像互联网这样的全球系统至关重要。正是这些特性使得互联网如此成功，而这正是因为HTTP——万维网核心的应用层协议——是基于REST的！另一个RESTful协议是CoAP，我们在第5章（kindle_split_012.html#ch05）中介绍了它，并在第7章（kindle_split_015.html#ch07）中将进一步讨论。REST被设计用来支持大规模的分布式多媒体内容（也称为超媒体）系统，正如互联网的成功所证明的那样，它运作得相当不错。让我们看看这些约束是什么。
- en: 'Constraint #1—client-server'
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 约束#1——客户端-服务器
- en: Interactions between components are based on the *request-response* pattern,
    where a client sends a request to a server and gets back a response. This maximizes
    decoupling between components because clients don’t need to know anything about
    the implementation of the server, only how to send the request to get the data
    they want. Likewise, servers don’t need to know about the state of clients or
    how that data will be used. Such a separation of concerns between data, control
    logic, and presentation improves scalability and portability because loose coupling
    means each component can exist and evolve independently.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 组件之间的交互基于*请求-响应*模式，其中客户端向服务器发送请求并获取响应。这种模式最大化了组件之间的解耦，因为客户端不需要了解服务器实现的任何信息，只需知道如何发送请求以获取所需的数据。同样，服务器也不需要了解客户端的状态或数据将如何被使用。这种在数据、控制逻辑和展示之间的关注点分离提高了可扩展性和可移植性，因为松散耦合意味着每个组件可以独立存在和演进。
- en: 'Constraint #2—uniform interfaces'
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '约束 #2—统一接口'
- en: Loose coupling between components can be achieved only when using a uniform
    interface that all components in the system respect. Unambiguous, simple, and
    standard interfaces that can be easily extended for all sorts of content and scenarios
    have largely contributed to the success of the web as an open and participatory
    system. This is also essential for the Web of Things because new, unknown devices
    can be added to and removed from the system at any time, and interacting with
    them will require minimal effort.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在系统中的所有组件都遵守统一接口的情况下，才能实现组件之间的松散耦合。明确、简单且易于扩展的接口（适用于各种内容和场景）在很大程度上促成了互联网作为一个开放和参与式系统的成功。这对于物联网同样至关重要，因为新的、未知的设备可以随时添加到系统中，也可以随时从系统中移除，与之交互将需要最少的努力。
- en: 'Constraint #3—stateless'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '约束 #3—无状态'
- en: The client context and state should be kept only on the client, not on the server.
    Because each request to the server should contain the client state, visibility
    (monitoring and debugging of the server), robustness (recovering from network
    or application failures), and scalability are improved. Of course, servers and
    applications can be stateful because this constraint simply requires that interactions
    between clients and servers contain information about each other’s state.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端上下文和状态应仅保留在客户端，而不是服务器上。因为每个对服务器的请求都应该包含客户端状态，可见性（服务器的监控和调试）、健壮性（从网络或应用故障中恢复）和可扩展性都会得到改善。当然，服务器和应用程序可以是状态的，因为这一约束仅仅要求客户端和服务器之间的交互包含彼此状态的信息。
- en: 'Constraint #4—cacheable'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '约束 #4—可缓存'
- en: Caching is a key element in the performance (loading time) of the web today
    and therefore its usability. Clients and intermediaries can store some data locally,
    which boosts their loading time, because that data doesn’t need to be fetched
    from the actual server for each request. Servers can define policies as when data
    expires and when updates must be reloaded from the server. This leads to better
    performance because fewer client-server interactions improve server scalability
    and also reduce latency.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是当今网络性能（加载时间）的关键要素，因此也是其可用性的关键。客户端和中间件可以本地存储一些数据，这提高了它们的加载时间，因为每次请求都不需要从实际服务器获取这些数据。服务器可以定义策略，例如数据何时过期以及何时必须从服务器重新加载更新。这导致性能得到提升，因为减少客户端-服务器交互提高了服务器的可扩展性，并减少了延迟。
- en: 'Constraint #5—layered system'
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '约束 #5—分层系统'
- en: Uniform interfaces make it easy to design a layered system, which means that
    several intermediate components can hide what’s behind them. Layered systems make
    it possible to use intermediary servers to further improve scalability and response
    times. For example, distributed caches or content delivery networks (CDNs) such
    as Akamai^([[2](#ch06fn02)]) can cache data in various locations throughout the
    globe to allow clients to retrieve some data faster. This is possible because
    clients rarely need to know if they interact with the target server or some other
    proxy along the way. Another benefit of layered systems is that it enables encapsulation
    of legacy protocols and systems–for example, gateways to proprietary protocols–which
    makes it simpler to enforce various security policies.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 统一接口使得设计分层系统变得容易，这意味着几个中间组件可以隐藏它们背后的内容。分层系统使得使用中间服务器进一步改善可扩展性和响应时间成为可能。例如，分布式缓存或内容分发网络（CDN）如Akamai^([[2](#ch06fn02)])可以在全球各个位置缓存数据，以便客户端能够更快地检索某些数据。这是可能的，因为客户端很少需要知道它们是否与目标服务器或其他代理交互。分层系统的另一个好处是它使得封装旧协议和系统（例如，到专有协议的网关）成为可能，这使得执行各种安全策略变得简单。
- en: ²
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.akamai.com](http://www.akamai.com)'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.akamai.com](http://www.akamai.com)'
- en: 6.1.2\. Why do we need a uniform interface?
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2. 我们为什么需要一个统一的接口？
- en: As you can tell, these constraints are largely responsible for making the web
    work. Without them, the web wouldn’t be as open, scalable, flexible, and efficient
    as it is today, and it would have become another ghost in the closed and proprietary
    systems paradise. Remember CompuServe?^([[3](#ch06fn03)]) Exactly!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些约束在很大程度上是使Web工作起来的原因。没有它们，Web就不会像今天这样开放、可扩展、灵活和高效，它将成为另一个封闭和专有系统天堂中的幽灵。还记得CompuServe吗？^([[3](#ch06fn03)])
    正是如此！
- en: ³
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'CompuServe was the first major commercial online service in the United States.
    It implemented services on top of the internet (and other networks) using mainly
    proprietary protocols. The service competed with the open World Wide Web for several
    years but lost the game and was completely shut down in 2011: [https://en.wikipedia.org/wiki/CompuServe](https://en.wikipedia.org/wiki/CompuServe).'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CompuServe 是美国第一个主要的商业在线服务。它主要使用专有协议在互联网（和其他网络）上提供服务。该服务与开放的万维网竞争了数年，但最终败北，并于2011年完全关闭：[https://en.wikipedia.org/wiki/CompuServe](https://en.wikipedia.org/wiki/CompuServe)。
- en: 'The most important of these constraints is the uniform interface because limiting
    all possible interactions to a subset of generic and well-defined operations offers
    several advantages. First, using a uniform interface such as that defined by HTTP
    minimizes the coupling between components, which helps us design more scalable
    and robust applications. Second, we can use a web-like mindset to design applications:
    markup languages, event-based browser interactions, scripting languages, URLs,
    and the like. Third, HTTP traffic on port 80 is the only protocol that’s always
    permitted by most firewalls. Fourth, it makes it easy to hide low-level protocol
    details behind simple, high-level abstractions, which promotes openness, programmability,
    and reusability of services and data regardless of how they’re actually stored
    or encoded.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约束中最重要的就是统一的接口，因为将所有可能的交互限制在通用且定义良好的操作子集内提供了几个优点。首先，使用如HTTP定义的统一接口可以最小化组件之间的耦合，这有助于我们设计更可扩展和更健壮的应用程序。其次，我们可以使用类似Web的思维来设计应用程序：标记语言、基于事件的浏览器交互、脚本语言、URL等。第三，80端口的HTTP流量是大多数防火墙唯一允许的协议。第四，它使得在简单的高级抽象背后隐藏低级协议细节变得容易，这促进了服务和数据（无论它们实际如何存储或编码）的开放性、可编程性和可重用性。
- en: 'Our point here is that what REST and HTTP have done for the web, they can also
    do for the Web of Things. As long as a Thing follows the same rules as the rest
    of the web—that is, shares this uniform interface—that Thing is truly part of
    the web. In the end, the goal of the Web of Things is this: make it possible for
    any physical object to be accessed via the same uniform interface as the rest
    of the web. This is exactly what the Access layer enables and, as we’ll describe
    in the rest of this section, the uniform interface of the web is based on these
    four principles:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的要点是，REST和HTTP为Web所做的一切，它们也可以为物联网做到。只要一个“物”遵循与Web其他部分相同的规则——即共享这个统一接口——那么这个“物”就真正是Web的一部分。最终，物联网的目标是：使任何物理对象都能通过与其他Web部分相同的统一接口访问。这正是访问层所能实现的，正如我们将在本节余下的部分所描述的，Web的统一接口基于以下四个原则：
- en: '***Addressable resources—*** A *resource* is any concept or piece of data in
    an application that needs to be referenced or used. Every resource must have a
    unique identifier and should be addressable using a unique referencing mechanism.
    On the web, this is done by assigning every resource a unique URL.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可访问的资源—*** *资源*是应用程序中需要引用或使用的任何概念或数据。每个资源都必须有一个唯一的标识符，并且应该使用唯一的引用机制进行访问。在网络上，这是通过为每个资源分配一个唯一的URL来实现的。'
- en: '***Manipulation of resources through representations—*** Clients interact with
    services using multiple representations of their resources. Those representations
    include HTML, which is used for browsing and viewing content on the web, and JSON,
    which is better for machine-readable content.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***通过表示形式操作资源—*** 客户端通过其资源的多个表示形式与服务交互。这些表示形式包括HTML，用于在网络上浏览和查看内容，以及JSON，更适合机器可读内容。'
- en: '***Self-descriptive messages—*** Clients must use only the methods provided
    by the protocol—`GET`, `POST`, `PUT`, `DELETE,` and `HEAD` among others—and stick
    to their meaning as closely as possible. Responses to those operations must use
    only well-known response codes—HTTP status codes, such as 200, 302, 404, and 500.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***自描述消息—*** 客户端必须仅使用协议提供的方法—`GET`、`POST`、`PUT`、`DELETE`和`HEAD`等，并且尽可能紧密地遵循其含义。对这些操作的响应必须仅使用众所周知的响应代码—例如HTTP状态代码200、302、404和500。'
- en: '***Hypermedia as the engine of the application state (HATEOAS)—*** Servers
    shouldn’t keep track of each client’s state because stateless applications are
    easier to scale. Instead, application state should be addressable via its own
    URL, and each resource should contain links and information about what operations
    are possible in each state and how to navigate across states. HATEOAS is particularly
    useful at the Find layer, so we’ll discuss it in more detail in [chapter 8](kindle_split_016.html#ch08).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***超媒体作为应用状态引擎（HATEOAS）—*** 服务器不应跟踪每个客户端的状态，因为无状态应用程序更容易扩展。相反，应用状态应通过其自身的URL进行访问，并且每个资源应包含关于在每种状态下可能进行的操作以及如何在不同状态之间导航的信息。HATEOAS在查找层特别有用，因此我们将在第8章中更详细地讨论它。[链接](https://kindle_split_016.html#ch08)。'
- en: 'Thanks to such a simple, uniform interface and to the wide availability of
    HTTP clients and libraries, RESTful services can be reused and recombined easily,
    without requiring prior knowledge about the specifics of any resource, because
    those can be discovered and understood on the fly, as will be shown in section
    Principle 4: Hypermedia as the Engine of Application State. In the rest of this
    section, we describe in more detail how those four principles are put into practice
    with HTTP, and then we’ll show how to use them when designing RESTful APIs for
    Things. Finally, for each of those principles, we’ll propose a set of rules to
    help you build web-friendly APIs for your Things.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这样一个简单、统一的接口以及HTTP客户端和库的广泛可用性，RESTful服务可以轻松重用和组合，无需了解任何资源的具体知识，因为这些可以在运行时发现和理解，正如将在第4个原则：超媒体作为应用状态引擎中所示。在本节的其余部分，我们将更详细地描述如何使用HTTP将这些四个原则付诸实践，然后我们将展示如何设计RESTful
    API用于事物。最后，对于这些原则中的每一个，我们将提出一套规则，以帮助您为您的物品构建友好的Web API。
- en: '6.1.3\. Principle 1: addressable resources'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3\. 原则1：可访问的资源
- en: REST is a *resource-oriented architecture (ROA)*, where every component of a
    system or an application (a sensor, its sampling frequency, a variable, and so
    on) is called a *resource*. A resource is explicitly identified and can be individually
    addressed. With HTTP, this is done using the well-known *Uniform Resource Identifier
    (URI)* standard scheme defined in RFC 3986.^([[4](#ch06fn04)]) Using the exact
    same standard naming scheme as all other web resources allows you to seamlessly
    integrate Things and their properties into the web because their functions, data,
    or sensors can be linked to, shared, bookmarked, and used just like anything else
    on the web.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一种*面向资源的架构（ROA）*，其中系统或应用程序的每个组件（一个传感器、其采样频率、一个变量等）都称为*资源*。资源被明确标识，并且可以单独访问。使用HTTP，这是通过在RFC
    3986中定义的众所周知的*统一资源标识符（URI）*标准方案来完成的。[注4](#ch06fn04)] 使用与其他所有网络资源相同的精确标准命名方案，您可以将事物及其属性无缝集成到网络中，因为它们的函数、数据或传感器可以像网络上的任何其他内容一样链接、共享、书签和使用。
- en: ⁴
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See [https://tools.ietf.org/html/rfc3986](https://tools.ietf.org/html/rfc3986).
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看 [https://tools.ietf.org/html/rfc3986](https://tools.ietf.org/html/rfc3986)。
- en: 'A URI is a sequence of characters that unambiguously identifies an abstract
    or physical resource. There are many possible types of URIs, but the ones we care
    about here are those used by HTTP to both identify and locate on a network a resource
    on the web, which is called the *URL (Uniform Resource Locator)* for that resource.
    From this, we generalize that any URL of resources in the Web of Things must follow
    the following syntax:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: URI 是一系列字符，它明确地标识了一个抽象或物理资源。有许多可能的 URI 类型，但在这里我们关注的是那些 HTTP 用于在网络上标识和定位 Web
    上的资源，这些资源被称为该资源的 *URL（统一资源定位符）*。由此，我们推广认为，Web of Things 中的任何资源 URL 都必须遵循以下语法：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the Web of Things, `<scheme>` is always either `http` or `https`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Web of Things 中，`<scheme>` 总是 `http` 或 `https`。
- en: '`<authority>` is a host with optional port or access credentials.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<authority>` 是一个带有可选端口或访问凭证的主机。'
- en: '`<path>` is any hierarchical path to the resource, which must start with `/`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<path>` 是指向资源的任何层次路径，必须以 `/` 开头。'
- en: Last come optional query parameters and/or fragments.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后是可选的查询参数和/或片段。
- en: 'An important and powerful consequence of this is the addressability and portability
    of resource identifiers: they become unique (internet- or intranet-wide) and can
    be resolved by any HTTP library or tool (for example, a browser) and they can
    be bookmarked, exchanged in emails, used in instant messaging tools, encoded in
    QR codes, used in RFID tags, and broadcasted by beacons, as you’ll see in in [chapter
    7](kindle_split_015.html#ch07).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个重要且强大的后果是资源标识符的可寻址性和可移植性：它们变得唯一（互联网或内网范围内）并且可以被任何 HTTP 库或工具（例如，浏览器）解析，它们可以被书签、在电子邮件中交换、在即时通讯工具中使用、编码在二维码中、在
    RFID 标签中使用，以及通过信标广播，正如你将在第 7 章[中看到的那样](kindle_split_015.html#ch07)。
- en: '|  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The nerd corner: URL vs. URI**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术角落：URL 与 URI**'
- en: A URL is a type of URI that identifies a resource via a representation of its
    primary access mechanism—for example, its network location—rather than by some
    other attributes it may have. On the web, a URL is a URI beginning with the [http://scheme](http://scheme)
    and resolvable through HTTP. Also, note that the root URL of a device doesn’t
    require the device to be connected and accessible publicly over the web. The URL
    works equally well inside a local area network.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: URL 是一种 URI 类型，通过其主访问机制（例如，其网络位置）的表示来标识资源，而不是通过它可能具有的其他属性。在网络上，URL 是以 [http://scheme](http://scheme)
    开头的 URI，并且可以通过 HTTP 解析。此外，请注意，设备的根 URL 不需要设备连接并且可以通过互联网公开访问。URL 在局域网内同样有效。
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Every device on the Web of Things must have a root URL that corresponds to
    its network address, and here are a few examples of root URLs for various devices:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Web of Things 上的每个设备都必须有一个与其网络地址相对应的根 URL，以下是一些各种设备的根 URL 示例：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the Web of Things we can have several types of resources. Although some
    of them represent Things and their actual properties, others can be entirely virtual
    (a mashup, a data processing service, and so on):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web of Things 中，我们可以有几种类型的资源。尽管其中一些代表事物及其实际属性，但其他一些可以是完全虚拟的（例如，一个混合体、数据处理服务等等）：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Resources on the web are often organized in a hierarchy defined by a path.
    This hierarchical way of organizing and linking resources is particularly relevant
    in the physical world because it can be used to identify not only the resources
    of a Thing and how Things relate to each other but also the relationship between
    Things and their physical location. We can also identify collections of resources,
    which are resources themselves:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 网上的资源通常按照路径定义的层次结构组织。这种组织和链接资源的方式在物理世界中尤其相关，因为它不仅可以用来标识事物的资源以及事物之间的关系，还可以用来标识事物与其物理位置之间的关系。我们还可以标识资源集合，这些集合本身也是资源：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It’s interesting to step back for a second and think about what these URLs mean
    in the grand scheme of internet protocols we looked at before. As shown in [figure
    6.2](#ch06fig02), there’s a lot to learn from a Thing URL!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，退后一步思考一下，在我们之前查看的互联网协议的大背景下，这些 URL 有什么意义。如图 6.2 所示，从 Thing URL 中有很多东西可以学习！
- en: Figure 6.2\. A Thing URL and the protocols each bit of the URL refers to. The
    first part specifies the protocol we use, here HTTP+TLS/SSL (HTTPS); then the
    domain is resolved by DNS to an IP address, the port is used by TCP to know what
    process to redirect to, and finally the REST resource is shown.
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.2\. 一个 Thing URL 及其指向的协议。URL 的第一部分指定了我们使用的协议，这里为 HTTP+TLS/SSL（HTTPS）；然后通过
    DNS 将域名解析为 IP 地址，端口由 TCP 使用以知道要重定向到哪个进程，最后显示 REST 资源。
- en: '![](06fig02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig02.jpg)'
- en: 'Let’s make this more concrete by taking the example of our Raspberry Pi. You
    can see in [figure 6.3](#ch06fig03) how the different resources are related to
    each other and how you can construct the URL for any element of your Pi. From
    this hierarchy, you can see first that any device must have a root URL ([http://devices.webofthings.io/pi](http://devices.webofthings.io/pi)).
    Then, it has various sensors (light, temperature, and so on) and actuators (such
    as LEDs). The URL of each element is constructed by appending its name to the
    path of its predecessor in the hierarchy. For instance, the light sensor will
    have the following URL:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过我们的Raspberry Pi的例子来使这个概念更具体。你可以在[图6.3](#ch06fig03)中看到不同的资源是如何相互关联的，以及你如何为Pi的任何元素构造URL。从这个层次结构中，你可以首先看到任何设备都必须有一个根URL([http://devices.webofthings.io/pi](http://devices.webofthings.io/pi))。然后，它有各种传感器（如光、温度等）和执行器（如LED）。每个元素的URL是通过将其名称附加到其层次结构中前一个元素的路径上构建的。例如，光传感器的URL如下：
- en: '![](150fig01.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](150fig01.jpg)'
- en: Figure 6.3\. An example of URL structure of the various resources on a Raspberry
    Pi. The full URL of the X-axis reading of the acceleration sensor of the Pi highlighted
    in bold is [http://devices.webofthings.io/pi/sensors/accel/x](http://devices.webofthings.io/pi/sensors/accel/x).
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3\. Raspberry Pi上各种资源URL结构的示例。加粗的X轴加速度传感器的完整URL是[http://devices.webofthings.io/pi/sensors/accel/x](http://devices.webofthings.io/pi/sensors/accel/x)。
- en: '![](06fig03_alt.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig03_alt.jpg)'
- en: All the components of a device can be mapped into a similar resource tree, where
    each sensor, actuator, or system property of the device is assigned its own URL.
    This way, every component of your device fully blends into the web and becomes
    a distinct web resource that anyone on the web can address and interact with.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的所有组件都可以映射到一个类似的资源树中，其中每个传感器、执行器或系统属性都分配了自己的URL。这样，你设备的每个组件都完全融入网络，成为一个独特的网络资源，任何人都可以通过网络对其进行寻址和交互。
- en: 'In [chapter 8](kindle_split_016.html#ch08) we’ll look at semantics and will
    propose a naming scheme for resources. For now, it’s worth noting that there are
    no official rules about the semantics of resources’ identifiers. Nevertheless,
    you should adhere to the following guidelines for all your resources:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](kindle_split_016.html#ch08)中，我们将探讨语义并提出资源命名方案。现在，值得注意的是，关于资源标识符的语义没有官方规则。尽管如此，你应该遵守以下指南来处理所有资源：
- en: '***Use descriptive names.*** Because the resource names appear in the URLs,
    using names with some semantic value can be of great help to developers and users.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***使用描述性的名称。*** 因为资源名称会出现在URL中，使用具有语义价值的名称对开发者和用户都有很大帮助。'
- en: '***Don’t use verbs in URLs.*** Avoid using verbs—for example, lock or start—and
    use names where you can: /garagedoor/openDoor is bad; /garagedoor/status is much
    better. Verbs are for HTTP methods, not for URLs!'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***在URL中不要使用动词。*** 避免使用动词——例如，锁定或启动——并在可能的情况下使用名称：/garagedoor/openDoor是不好的；/garagedoor/status要好得多。动词用于HTTP方法，而不是用于URL！'
- en: '***Use the plural form for aggregate resources.*** If a Thing has several sensors,
    they should be accessible via a parent resource called /sensors. But you would
    use /accel for the accelerometer because there’s only one such sensor, although
    it provides values for three dimensions.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***对于聚合资源使用复数形式。*** 如果一个实体有多个传感器，它们应该可以通过一个名为/sensors的父资源访问。但你会使用/accel来表示加速度计，尽管它提供了三个维度的值，但只有一个这样的传感器。'
- en: 'Design rules #1—addressable resources'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '设计规则 #1—可寻址资源'
- en: 'The first principle we looked at emphasizes that every element in your web
    Thing, service, or application becomes an addressable web resource. From this,
    we propose the following set of design rules to follow when implementing web Things:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨的第一个原则强调，你网络中的每个元素，无论是网络实体、服务还是应用程序，都成为一个可寻址的网络资源。基于这一点，我们提出以下设计规则，以遵循实现网络实体时的规则：
- en: '***Web Things must be an HTTP server.*** Simply put, if you can’t send an HTTP
    request to a device, then it’s not part of the Web of Things. To ensure maximal
    compatibility, web Things must always support HTTP version 1.1—ideally v2 as well,
    but not only v2—because it’s currently the most widely used version of the protocol.
    Thanks to the layered architecture of REST, the HTTP server doesn’t need to be
    actually hosted on the device itself. We’ll describe the various integration patterns
    in [chapter 7](kindle_split_015.html#ch07).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Web Things必须是一个HTTP服务器。*** 简而言之，如果你不能向设备发送HTTP请求，那么它就不是物联网的一部分。为了确保最大兼容性，Web
    Things必须始终支持HTTP版本1.1——理想情况下也支持v2，但不仅仅是v2——因为它是目前最广泛使用的协议版本。多亏了REST的分层架构，HTTP服务器实际上不需要托管在设备本身上。我们将在第7章（kindle_split_015.html#ch07）中描述各种集成模式。'
- en: '***Web Things should use secure*** HTTP *connections (HTTPS).* When possible,
    a Thing should offer only secure connections. This is essential if the Thing is
    accessible from the outside world.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Web Things应使用安全的*** HTTP *连接（HTTPS）。* 当可能时，事物应仅提供安全连接。如果事物可以从外部世界访问，这是至关重要的。'
- en: '***Web Things must have a root resource accessible via an HTTP URL.*** A client
    application must have a URL to send the HTTP request to. The URL doesn’t need
    to be externally accessible or public; it can be the IP address of a device on
    your LAN.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Web Things必须有一个可通过HTTP URL访问的根资源。*** 客户端应用程序必须有一个URL来发送HTTP请求。该URL不需要对外公开或公开；它可以是您局域网中设备的IP地址。'
- en: '***Web Things must expose their properties using a hierarchical structure.***
    Things must expose their properties using a hierarchical structure to facilitate
    discovery of their resources. A specific model and resource structure will be
    proposed in [chapter 8](kindle_split_016.html#ch08).'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Web Things必须使用分层结构来公开其属性。*** 事物必须使用分层结构来公开其属性，以促进其资源的发现。在第8章（kindle_split_016.html#ch08）中将提出一个特定的模型和资源结构。'
- en: '6.1.4\. Principle 2: manipulation of resources through representations'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.4\. 原则2：通过表示操纵资源
- en: A challenge in computer-based communication is how to encode information so
    that it can be universally decoded and understood. On the web, *Multipurpose Internet
    Mail Extensions (MIME)* types have been introduced as standards to describe various
    data formats transmitted over the internet, such as images, video, or audio. The
    MIME type for an image encoded as PNG is expressed with image/png and an MP3 audio
    file with audio/mp3\. The Internet Assigned Numbers Authority (IANA) maintains
    the list of the all the official MIME media types.^([[5](#ch06fn05)])
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机通信中的一个挑战是如何编码信息，以便它可以被普遍解码和理解。在互联网上，*多用途互联网邮件扩展（MIME）*类型已被引入作为标准，用于描述通过互联网传输的各种数据格式，如图像、视频或音频。以PNG编码的图像的MIME类型表示为image/png，MP3音频文件为audio/mp3。互联网数字分配机构（IANA）维护所有官方MIME媒体类型的列表.^([[5](#ch06fn05)])
- en: ⁵
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Online: [http://www.iana.org/assignments/media-types/](http://www.iana.org/assignments/media-types/).'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在线：[http://www.iana.org/assignments/media-types/](http://www.iana.org/assignments/media-types/).
- en: A resource as defined previously is only a concept—an abstract idea of a thing—and
    not the thing itself. The tangible instance of a resource is called a *representation*,
    which is a standard encoding of a resource using a MIME type. Web browsers typically
    support quite a few representations, such as (HTML, GIF, and MPEG; or can use
    plugins or external applications to render them, such as PDF, vCards, or Flash).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，资源只是一个概念——一个事物的抽象想法——而不是事物本身。资源的有形实例称为*表示*，它使用MIME类型对资源进行标准编码。Web浏览器通常支持相当多的表示，例如（HTML、GIF和MPEG；或者可以使用插件或外部应用程序来渲染它们，如PDF、vCards或Flash）。
- en: HTTP defines a simple mechanism called *content negotiation* that allows clients
    to request a preferred data format they want to receive from a specific service.
    Using the `Accept` header, clients can specify the format of the representation
    they want to receive as a response. Likewise, servers specify the format of the
    data they return using the `Content-Type` header. To illustrate this principle,
    let’s look at what happens when you enter the URL of the Pi in your browser. The
    following listing shows the request and the response messages.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP定义了一种简单的机制，称为*内容协商*，允许客户端请求从特定服务接收的偏好数据格式。使用`Accept`头，客户端可以指定他们希望作为响应接收的表示格式的格式。同样，服务器使用`Content-Type`头指定它们返回的数据的格式。为了说明这个原则，让我们看看当你在浏览器中输入Pi的URL时会发生什么。以下列表显示了请求和响应消息。
- en: Listing 6.1\. A simple HTTP request and response
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.1\. 简单的 HTTP 请求和响应
- en: '![](151fig01.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](151fig01.jpg)'
- en: 'As you can see, the request, which is a simplified version of what your browser
    actually sends, contains the following header: `Accept: text/html`, which instructs
    the server to return an HTML representation of the Pi, the Pi root page you saw
    in [chapter 2](kindle_split_009.html#ch02). By default, browsers request HTML
    files they can render and allow human users to interact with the resource. But
    in some cases, HTTP clients don’t want HTML and would prefer a machine-readable
    format such as JSON OR XML—for example, when the client is an application and
    not a web browser. This can be done by using another value for the `Accept:` header,
    as shown in the next two listings.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，这个请求是一个简化的版本，它实际上发送的内容，包含以下头信息：`Accept: text/html`，指示服务器返回 Pi 的 HTML 表示形式，即您在
    [第 2 章](kindle_split_009.html#ch02) 中看到的 Pi 根页面。默认情况下，浏览器请求它们可以渲染的 HTML 文件，并允许人类用户与资源交互。但在某些情况下，HTTP
    客户端不希望是 HTML，而更希望是机器可读的格式，例如 JSON 或 XML——例如，当客户端是一个应用程序而不是网页浏览器时。这可以通过使用 `Accept:`
    头的另一个值来实现，如接下来的两个列表所示。'
- en: Listing 6.2\. Requesting an XML return payload using the `Accept` header
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2\. 使用 `Accept` 头请求 XML 返回负载
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Listing 6.3\. Requesting a JSON return payload using the `Accept` header
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.3\. 使用 `Accept` 头请求 JSON 返回负载
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can use various encoding formats to describe sensor data so that it can
    be understood and processed by other applications, and obviously not all servers
    will support all of them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用各种编码格式来描述传感器数据，以便其他应用程序可以理解和处理它，并且显然不是所有服务器都支持所有这些格式。
- en: 'The `Accept:` header of an HTTP request can also contain not just one but a
    weighted list of media types the client understands—for example, `application/json;q=1,
    application/xml;q=0.5`. The server then tries to serve the best possible format
    (as requested by the client using the parameter `q` as a quality factor) it knows
    about and specifies it in the `Content-Type` of the HTTP response. In our case
    the Pi can’t offer XML and hence would return a JSON representation and set the
    HTTP header to `Content-Type: application/json`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 'HTTP 请求的 `Accept:` 头可以包含客户端理解的一个或多个带权重的媒体类型列表——例如，`application/json;q=1, application/xml;q=0.5`。然后服务器会尝试提供它知道的最好可能的格式（根据客户端使用参数
    `q` 作为质量因子请求的），并在 HTTP 响应的 `Content-Type` 中指定它。在我们的例子中，Pi 无法提供 XML，因此会返回 JSON
    表示形式，并将 HTTP 头设置为 `Content-Type: application/json`。'
- en: JSON and beyond for the Web of Things
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Web 物联网的 JSON 及其超越
- en: The format we suggest for web Things is JSON. JSON is particularly suited for
    web applications because it’s lightweight, portable, and self-contained and can
    be easily parsed in browsers using JavaScript, as well as by every programming
    language out there! It’s a lighter alternative to XML because it requires less
    processing power and bandwidth and is also easier on the eyes of a developer.
    But even if JSON is lightweight, it isn’t a binary format because it’s still text.
    Alternative representation formats make sense when a more efficient format is
    needed—for instance, because of the memory limitations of a device or the fact
    that it runs on batteries. A number of formats can translate JSON into a binary
    format.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议用于 Web 物联网的格式是 JSON。JSON 特别适合 Web 应用程序，因为它轻量级、便携且自包含，并且可以使用 JavaScript 在浏览器中轻松解析，也可以由任何编程语言解析！它比
    XML 更轻量级，因为它需要的处理能力和带宽更少，对开发者的眼睛也更友好。但即使 JSON 轻量级，它也不是二进制格式，因为它仍然是文本。当需要更有效的格式时，例如，由于设备的内存限制或它运行在电池上，替代表示格式才有意义。有许多格式可以将
    JSON 转换为二进制格式。
- en: 'MessagePack^([[6](#ch06fn06)]) is one of our favorite alternatives. It’s supported
    by libraries for all popular programming languages, including client-side JavaScript,
    Node.js, and C. MessagePack isn’t an official MIME media type, but you can still
    ask for it in a content-negotiation process. A common way of dealing with unofficial
    MIME types is to use the `x-` extension, so if you want your client to ask for
    MessagePack, use `Content-Type: application/x-msgpack`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'MessagePack^([[6](#ch06fn06)]) 是我们最喜欢的替代方案之一。它支持所有流行的编程语言的库，包括客户端 JavaScript、Node.js
    和 C。MessagePack 不是一个官方的 MIME 媒体类型，但在内容协商过程中您仍然可以请求它。处理非官方 MIME 类型的一种常见方式是使用 `x-`
    扩展名，因此如果您想让您的客户端请求 MessagePack，请使用 `Content-Type: application/x-msgpack`。'
- en: ⁶
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://msgpack.org/](http://msgpack.org/)'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://msgpack.org/](http://msgpack.org/)'
- en: 'Design rules #2–content negotiation'
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '设计规则 #2–内容协商'
- en: 'Based on what you’ve just learned, we propose the following rules to follow
    when implementing your web Things:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 基于您刚刚学到的内容，我们提出以下规则，供您在实现您的Web Things时遵循：
- en: '***Web Things must support JSON as their default representation.*** Your Thing
    can support as many representations as it wants, as long as it accepts at the
    minimum JSON in requests and can return a JSON representation when requested.
    Always use CamelCase; for example, `lastValue` instead of `Last-Value` or `last_value,`
    for object names in JSON payloads.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Web Things必须支持JSON作为它们的默认表示形式。*** 您的实体可以支持它想要的任何表示形式，只要它至少接受JSON请求，并在请求时可以返回JSON表示。始终使用驼峰式命名法；例如，在JSON有效载荷中的对象名称应使用`lastValue`而不是`Last-Value`或`last_value`。'
- en: '***Web Things support UTF8 encoding for requests and responses.*** A web Thing
    can support many other encoding formats (for example, it can describe the services
    it offers in Chinese or Russian), but it has to support UTF8 for any resource
    at the very least.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Web Things支持UTF8编码的请求和响应。*** Web Thing可以支持许多其他编码格式（例如，它可以描述其提供的服务为中文或俄语），但至少它必须支持UTF8编码的任何资源。'
- en: '***Web Things may offer an HTML interface/representation (UI).*** In addition
    to a computer-friendly API, devices should also offer a human-friendly user interface
    that’s accessible from a web browser. This is especially useful for consumer products
    to make it easy for users to access, control, and troubleshoot their devices.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Web Things可能提供HTML界面/表示（UI）。*** 除了计算机友好的API之外，设备还应提供人类友好的用户界面，可以通过网络浏览器访问。这对于消费产品来说特别有用，因为它可以方便用户访问、控制和故障排除他们的设备。'
- en: '6.1.5\. Principle 3: self-descriptive messages'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.5\. 原则 3：自描述消息
- en: REST emphasizes a uniform interface between components to reduce coupling between
    operations and their implementation. This requires every resource to support a
    standard, common set of operations with clearly defined semantics and behavior.
    HTTP defines a fixed set of operations that every resource can support, also called
    verbs or methods. The most commonly used among them are `GET`, `POST`, `PUT`,
    `DELETE`, and `HEAD`. Although it seems that you could do everything with just
    `GET` and `POST`, it’s important to correctly use all four verbs to avoid bad
    surprises in your applications or introducing security risks.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: REST强调组件之间的统一接口，以减少操作与其实现之间的耦合。这要求每个资源都支持一个标准、通用的操作集，具有明确定义的语义和行为。HTTP定义了一个固定的操作集，每个资源都可以支持，也称为动词或方法。其中最常用的有`GET`、`POST`、`PUT`、`DELETE`和`HEAD`。虽然看起来您似乎只需要`GET`和`POST`就能做所有事情，但正确使用所有四个动词对于避免应用程序中的意外或引入安全风险非常重要。
- en: 'Constraining operations to these methods is one of the keys to enabling loose
    coupling of services because clients only need to support mechanisms to handle
    these methods. In the Web of Things, these operations map rather naturally because
    Things usually offer quite simple and atomic services that can usually be reduced
    to the four basic CRUD operation types: create, read, update, and delete.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将操作限制在这些方法之一是启用服务松耦合的关键之一，因为客户端只需要支持处理这些方法的机制。在物联网中，这些操作映射得相当自然，因为事物通常提供相当简单和原子的服务，这些服务通常可以简化为四种基本的CRUD操作类型：创建、读取、更新和删除。
- en: GET
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: GET
- en: '`GET` is a read-only operation, as shown in [listing 6.4](#ch06ex04). It’s
    both a safe and idempotent operation. *Safe* means that invoking a `GET` doesn’t
    change the state of the server at all (read-only). *Idempotent* means that no
    matter how many times you apply the operation, it won’t have an effect on the
    resource state. Reading an HTML document with an HTTP `GET` request once or 10
    times won’t change the resource state.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`是一个只读操作，如[列表 6.4](#ch06ex04)所示。它既安全又幂等。*安全*意味着调用`GET`不会以任何方式改变服务器的状态（只读）。*幂等*意味着无论您应用此操作多少次，都不会对资源状态产生影响。使用HTTP
    `GET`请求一次或十次读取HTML文档不会改变资源状态。'
- en: Listing 6.4\. `GET` to read a resource (the temperature sensor of our Pi)
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.4\. `GET` 读取资源（我们的Pi的温度传感器）
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this listing, we want to know the latest value of the temperature sensor;
    therefore, this is a read-only operation. Because we specify the encoding to be
    JSON, the response payload contains a JSON message with the value 37\. You might
    be thinking “37 what?” The answer to this will be provided in [chapter 8](kindle_split_016.html#ch08),
    when we discuss semantics.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们想知道温度传感器的最新值；因此，这是一个只读操作。因为我们指定了编码为JSON，所以响应有效载荷包含一个包含值37的JSON消息。您可能会想“37是什么？”这个答案将在[第8章](kindle_split_016.html#ch08)中提供，当我们讨论语义时。
- en: In some cases, an HTTP client might not need the full response payload, such
    as when the client wants only to verify if a resource is available or has been
    updated recently. In this situation, the client might use the `HEAD` verb instead
    of the `GET`, which does essentially the same thing but returns only the headers
    and not the payload. This is particularly useful when the request is sent to a
    resource-constrained device, where every byte counts.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，HTTP客户端可能不需要完整的响应有效负载，例如当客户端只想验证资源是否可用或最近是否已更新时。在这种情况下，客户端可能会使用`HEAD`动词而不是`GET`，它实际上做的是同样的事情，但只返回头部而不是有效负载。这在请求发送到资源受限的设备时尤其有用，因为每个字节都很宝贵。
- en: POST
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: POST
- en: '`POST` is both a non-idempotent and unsafe operation of HTTP, which means it
    not only will change the server status but also will have a different result each
    time it’s called. `POST` should be used only to create a new instance of something
    that doesn’t have its own URL yet, such as a new user in a system or bank account.
    The request in the following listing creates a message to be shown on the LCD
    display for 30 seconds.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`是HTTP中既非幂等又非安全的操作，这意味着它不仅会改变服务器状态，而且每次调用都会有不同的结果。`POST`应该仅用于创建尚未拥有自己的URL的新实例，例如系统中的新用户或银行账户。以下列表中的请求创建了一条将在LCD显示屏上显示30秒的消息。'
- en: Listing 6.5\. `POST` to create a new resource
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.5\. `POST`用于创建新资源
- en: '![](155fig01_alt.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](155fig01_alt.jpg)'
- en: The URL of the resource you’ve just created, the message to be displayed, should
    always be returned in the answer via the `Location` header. This URL now allows
    you to interact with the resource you just created, which you can update or delete
    later on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建的资源URL，要显示的消息，应始终通过`Location`头部在答案中返回。这个URL现在允许你与刚刚创建的资源进行交互，你可以稍后更新或删除它。
- en: As you’ll see in the next chapters, in some cases the result of a `POST` might
    not be instantaneous. For example, when you’d like to control an actuator, such
    as to move the arm of a robot, it may take a few seconds or minutes for the operation
    to be executed. Likewise, if your request gets buffered (for example, when messages
    are queued instead of being displayed right away), your request will be treated
    asynchronously. For synchronous requests processed instantly, such as resource
    creation, you should return a `201 Created`. For all asynchronous operations,
    you should return a `202 Accepted`, which means that the resource will eventually
    be created.^([[7](#ch06fn07)])
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在下一章中将会看到的，在某些情况下，`POST`请求的结果可能不会立即出现。例如，当你想要控制一个执行器，比如移动机器人的手臂时，操作可能需要几秒钟或几分钟才能执行。同样，如果你的请求被缓冲（例如，当消息被排队而不是立即显示时），你的请求将被异步处理。对于立即处理的同步请求，例如资源创建，你应该返回`201
    Created`。对于所有异步操作，你应该返回`202 Accepted`，这意味着资源最终将被创建.^([[7](#ch06fn07)])
- en: ⁷
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'RFC 2616, section 10.2.3: [https://www.ietf.org/rfc/rfc2616](https://www.ietf.org/rfc/rfc2616).'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: RFC 2616，第10.2.3节：[https://www.ietf.org/rfc/rfc2616](https://www.ietf.org/rfc/rfc2616).
- en: PUT
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: PUT
- en: '`PUT` is usually modeled as an idempotent but unsafe update method. You should
    use `PUT` to update something that already exists and has its own URL, such as
    when you change the name of a user or add a deposit to their bank account, but
    not to create a new resource. Unlike `POST`, it’s idempotent because sending the
    same `PUT` message once or 10 times will have the same effect, whereas a `POST`
    would create 10 different resources. In the next example we change the color of
    LED 4 with its new RGB value as a parameter encoded as a JSON object.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`通常被建模为一个幂等但不安全的更新方法。你应该使用`PUT`来更新已经存在并拥有自己的URL的东西，例如当你更改用户的姓名或向他们的银行账户添加存款时，但不用于创建新资源。与`POST`不同，它是幂等的，因为发送相同的`PUT`消息一次或十次会产生相同的效果，而`POST`会创建10个不同的资源。在下一个示例中，我们使用新的RGB值作为参数编码为JSON对象来更改LED
    4的颜色。'
- en: Listing 6.6\. `PUT` to update an existing resource (change the colors of the
    LEDs)
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.6\. `PUT`用于更新现有资源（更改LED的颜色）
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should use `PUT` only to change something that already exists, not to create
    a new resource—use `POST` for that. In the Web of Things, this means `PUT` should
    be used to change the status of something (LED 4), to open/close the door of the
    garage, and the like. As you’ll see later, there’s a thin line when choosing whether
    to send commands to a device via `PUT` or `POST`. As a rule of thumb, if the command
    will be executed immediately without being buffered, then you should use `PUT`.
    But if you need to buffer the requests, typically when several users will access
    the same resource at the same time (for example, the LCD screen of our Pi in [chapter
    2](kindle_split_009.html#ch02)), then you’re creating a resource (an item in a
    waitlist) that will change the status at a later stage, so you should use `POST`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您应仅使用`PUT`来更改已存在的东西，而不是创建新资源——为此应使用`POST`。在物联网中，这意味着`PUT`应用于更改某物的状态（例如LED 4），打开/关闭车库门等。您将在后面看到，在决定是否通过`PUT`或`POST`向设备发送命令时，有一条很细的界限。一般来说，如果命令将立即执行而不会被缓冲，那么您应使用`PUT`。但如果需要缓冲请求，通常当多个用户同时访问同一资源时（例如，我们第2章中的Pi的LCD屏幕），您正在创建一个将在以后改变状态的资源（等待列表中的项目），因此您应使用`POST`。
- en: DELETE
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: DELETE
- en: '`DELETE` is an idempotent, unsafe method that should be used only to delete
    a resource. Typically, you’d use this verb to permanently remove a resource from
    a Thing, such as when you delete a subscription to a topic or a rule on the device,
    as the next listing shows.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE`是一个幂等且不安全的方法，应仅用于删除资源。通常，您会使用这个动词永久地从实体中删除资源，例如，当您删除对主题的订阅或设备上的规则时，如下一个列表所示。'
- en: Listing 6.7\. `DELETE` to remove an existing resource
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.7\. 使用`DELETE`删除现有资源
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because you use `DELETE` to remove a resource from an object, the URL of the
    resource you’re sending the request to will no longer be accessible once the request
    has been executed. If you want to remove a device from a gateway, you should use
    a `DELETE`. But if you want to disable a sensor, it would be a state change; therefore
    you should use a `PUT`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您使用`DELETE`从对象中删除资源，因此您发送请求的资源URL在请求执行后将不再可访问。如果您想从网关中删除设备，应使用`DELETE`。但如果您想禁用传感器，这将是一个状态变化；因此您应使用`PUT`。
- en: Error codes
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 错误代码
- en: HTTP also offers a way of expressing errors and exceptions. The status of an
    HTTP response is represented by standardized status codes sent back as part of
    the header in the HTTP response message. There are several dozen codes, each of
    which has well-known meanings for HTTP clients; these codes and their meanings
    are listed in the specification of HTTP 1.1.^([[8](#ch06fn08)])
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP还提供了一种表达错误和异常的方式。HTTP响应的状态由作为HTTP响应消息头一部分发送的标准状态码表示。有几十个这样的代码，每个代码对HTTP客户端都有众所周知的含义；这些代码及其含义列在HTTP
    1.1规范中。（[[8](#ch06fn08)]）
- en: ⁸
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Section 10 of RFC2616.
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: RFC2616的第10节。
- en: In the Web of Things, these codes are valuable because they provide a lightweight
    but powerful way of notifying abnormal and successful request execution. As an
    example, a `POST` request on `/pi/sensors/humidity/` in the previous example will
    return a `405 Method Not Allowed` status code. The client understands from that
    status code that it can’t send the `POST` verb to this resource, so there’s no
    point in trying again in the future.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网中，这些代码非常有价值，因为它们提供了一种轻量级但强大的方式来通知异常和成功的请求执行。例如，在上一个示例中，对`/pi/sensors/humidity/`的`POST`请求将返回`405
    方法不允许`状态码。客户端从该状态码中理解，它不能向该资源发送`POST`动词，因此未来再尝试也没有意义。
- en: 'HTTP defines a list of standard status codes to be returned by the server upon
    reception of every request. The most commonly used are these:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP定义了一个标准状态码列表，服务器在接收到每个请求时返回。最常用的包括以下这些：
- en: '`200 Ok`—Returned upon successful completion of a request. Another common flavor
    of this code is `204 No Content`.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200 正常`—请求成功完成时返回。此代码的另一种常见形式是`204 无内容`。'
- en: '`201 Created`—Returned when a new resource has been successfully created. The
    header `Location` contains the URI of the resource that has been created.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`201 已创建`—当新资源成功创建时返回。头部`Location`包含已创建资源的URI。'
- en: '`202 Accepted`—Returned for asynchronous operations when the request has been
    accepted but the resource not yet created.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`202 已接受`—当请求已被接受但资源尚未创建时，用于异步操作返回。'
- en: '`401 Unauthorized`—Either the request requires user authentication or the authorization
    failed using the given credentials.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`401 未授权`——请求需要用户身份验证，或者使用提供的凭证授权失败。'
- en: '`404 Not Found`—The requested resource or document has not been found on the
    server.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404 未找到`——请求的资源或文档在服务器上未找到。'
- en: '`500 Internal Server Error`—The server encountered an error that prevented
    it from fulfilling the request.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500 内部服务器错误`——服务器遇到错误，无法完成请求。'
- en: '`501 Service Unavailable`—The server can’t handle the request at this time
    due to maintenance or temporary overload.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`501 服务不可用`——服务器由于维护或临时过载而无法处理请求。'
- en: CORS—enabling client-side JavaScript to access resources
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: CORS——启用客户端JavaScript访问资源
- en: Although accessing web resources from different origins located on various servers
    in any server-side application doesn’t pose any problem, JavaScript applications
    running in web browsers can’t easily access resources across origins for security
    reasons. What we mean by this is that a bit of client-side JavaScript code loaded
    from the domain apples.com won’t be allowed by the browser to retrieve particular
    representations of resources from the domain oranges.com using particular verbs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在服务器端应用程序中从不同源的服务器访问网络资源不会引起任何问题，但由于安全原因，运行在浏览器中的JavaScript应用程序不能轻易地跨源访问资源。我们这里所说的意思是，从apples.com域加载的一小段客户端JavaScript代码不会被浏览器允许使用特定的动词从oranges.com域检索特定的资源表示。
- en: Generally speaking, browsers can do only simple cross-site requests, such as
    loading images from another site, but can’t request other types of representations
    such as JSON or JavaScript. For example, the `PUT /pi/actuators/leds/4` request
    of [listing 6.6](#ch06ex06) wouldn’t be authorized by the browser. This security
    mechanism is known as the *same-origin policy* and is there to ensure that a site
    can’t load any scripts from another domain. In particular, it ensures that a site
    can’t misuse cookies to use your credentials to log onto another site. Let’s look
    at an example to illustrate this. You log into facebook.com`,` which creates a
    cookie that your browser will send alongside each request to facebook.com. If
    the browser would allow cross-site requests, a script loaded from apples.com could
    send a request to facebook.com using your Facebook cookie, thus pretending to
    be you on Facebook!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，浏览器只能执行简单的跨站请求，例如从另一个网站加载图片，但不能请求其他类型的表示，如JSON或JavaScript。例如，[列表6.6](#ch06ex06)中的`PUT
    /pi/actuators/leds/4`请求不会被浏览器授权。这种安全机制被称为*同源策略*，其目的是确保一个网站不能从另一个域名加载任何脚本。特别是，它确保一个网站不能滥用cookies来使用您的凭证登录到另一个网站。让我们通过一个例子来说明这一点。您登录到facebook.com，这会在您的浏览器中创建一个cookie，每次向facebook.com发送请求时都会随请求一起发送。如果浏览器允许跨站请求，从apples.com加载的脚本就可以使用您的Facebook
    cookie向facebook.com发送请求，从而假装成您在Facebook上！
- en: Clearly, this security mechanism is a good thing, but it also means that interacting
    with the API of web Things directly from JavaScript code in the browser is not
    allowed by default. Hold on! Then how did you manage to access [http://devices.webofthings.io](http://devices.webofthings.io)
    to talk to our WoT Pi in [chapter 2](kindle_split_009.html#ch02)? Fortunately
    for us, a new standard mechanism called *cross-origin resource sharing (CORS)*^([[9](#ch06fn09)])
    has been developed and is well supported by most modern browsers and web servers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种安全机制是好事，但也意味着从浏览器中的JavaScript代码直接与Web Things的API交互默认是不被允许的。等等！那么您是如何在[第2章](kindle_split_009.html#ch02)中访问[http://devices.webofthings.io](http://devices.webofthings.io)并与我们的WoT
    Pi通信的呢？幸运的是，一个新的标准机制*跨源资源共享（CORS）*[[9](#ch06fn09)]已经被开发出来，并且得到了大多数现代浏览器和Web服务器的良好支持。
- en: ⁹
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See [http://enable-cors.org/](http://enable-cors.org/) and [http://www.w3.org/TR/cors/](http://www.w3.org/TR/cors/).
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看[http://enable-cors.org/](http://enable-cors.org/)和[http://www.w3.org/TR/cors/](http://www.w3.org/TR/cors/)。
- en: When a script in the browser wants to make a cross-site request, it needs to
    include an `Origin` header containing the origin domain. The server replies with
    an `Access-Control-Allow-Origin` header that contains the list of allowed origin
    domains (or `*` to allow all origin domains). The next listing provides an example
    of CORS in action for the request and response corresponding to exercise 2.1 of
    [chapter 2](kindle_split_009.html#ch02).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器中的脚本想要执行跨站请求时，它需要包含一个包含源域的`Origin`头。服务器会回复一个包含允许的源域列表（或`*`以允许所有源域）的`Access-Control-Allow-Origin`头。下一个列表提供了一个CORS操作的示例，对应于[第2章](kindle_split_009.html#ch02)的2.1练习的请求和响应。
- en: Listing 6.8\. `GET` request to a resource using CORS
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.8\. 使用CORS对资源进行`GET`请求
- en: '![](158fig01_alt.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](158fig01_alt.jpg)'
- en: When the browser receives the reply, it will check to see if the `Access-Control-Allow-Origin`
    corresponds to the origin, and if it does, it will allow the cross-site request.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器接收到回复时，它将检查`Access-Control-Allow-Origin`是否与源对应，如果是，它将允许跨站请求。
- en: For verbs other than `GET`/`HEAD`, or when using `POST` with representations
    other than `application/x-www-form-urlencoded, multipart/form-data`, or `text/plain,`
    an additional request called *preflight* is needed. A preflight request is an
    HTTP request with the verb `OPTIONS` that’s used by a browser to ask the target
    server whether it’s safe to send the cross-origin request. An example of a preflight
    request is shown in [figure 6.4](#ch06fig04).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于除`GET`/`HEAD`之外的动词，或者当使用除`application/x-www-form-urlencoded`、`multipart/form-data`或`text/plain`之外的表示进行`POST`时，需要一个额外的请求，称为*预检请求*。预检请求是一个带有`OPTIONS`动词的HTTP请求，浏览器使用它来询问目标服务器是否安全地发送跨源请求。一个预检请求的示例显示在[图6.4](#ch06fig04)中。
- en: Figure 6.4\. A preflight request corresponding to exercise 5 of [chapter 2](kindle_split_009.html#ch02).
    The JavaScript needs to send a `POST` to another server with a `Content-Type`
    header. The server replies with the allowed origin, methods, and headers. Because
    they match what the script wanted, the call will be authorized.
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4\. 对应于第2章[练习5](kindle_split_009.html#ch02)的预检请求。JavaScript需要向另一个服务器发送带有`Content-Type`头的`POST`请求。服务器回复允许的源、方法和头。因为它们与脚本想要的匹配，所以调用将被授权。
- en: '![](06fig04_alt.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig04_alt.jpg)'
- en: Although there are a number of additional options in the CORS specification,
    we won’t go into more detail because that would require an entire book.^([[10](#ch06fn10)])
    But this should provide you enough understanding of why it’s important to know
    what CORS is and how to apply it in the WoT.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CORS规范中有很多额外的选项，但我们将不会深入探讨，因为这需要整本书的内容。[10](#ch06fn10) 但这应该足以让你理解为什么了解CORS是什么以及如何在WoT中应用它很重要。
- en: ^(10)
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^[(10)](#)
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There’s a really good book on the subject called *CORS in Action* by Monsur
    Hossain (Manning Publications, 2014).
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于这个主题，有一本名为《CORS in Action》的好书，作者是Monsur Hossain（Manning Publications，2014年）。
- en: 'Design rules #3–self-descriptive messages'
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '设计规则 #3–自描述消息'
- en: 'To summarize, we can define four simple design rules based on the self-descriptive
    messages principle of REST:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们可以根据REST的自描述消息原则定义四个简单的设计规则：
- en: '***Web Things must support the `GET`, `POST`, `PUT`, and `DELETE` HTTP verbs.***
    To benefit from the advantages offered by RESTful architectures, the uniform interface
    constraint is instrumental. In a Web of Things context, `GET` is used to retrieve
    a sensor resource, such as a temperature reading; `POST` is used to create a new
    resource that will get a new URL—for example, to create a rule; `PUT` to update
    an actuator resource given its URL—for example, updating an LED; and `DELETE`
    to remove a resource, such as a rule.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Web Things必须支持`GET`、`POST`、`PUT`和`DELETE`HTTP动词。*** 为了从RESTful架构提供的好处中受益，统一的接口约束是至关重要的。在物联网的上下文中，`GET`用于检索传感器资源，例如温度读数；`POST`用于创建一个将获得新URL的新资源——例如创建规则；`PUT`用于更新给定URL的执行器资源——例如更新LED；`DELETE`用于删除资源，例如规则。'
- en: '***Web Things must implement HTTP status codes 20x, 40x, 50x.*** As mentioned,
    it’s important to use HTTP verbs as intended. Of course, it’s unrealistic for
    every web Thing to support all of them, but the device should at least support
    one of each group—for example, 200 if the request was successful; 400 for client
    errors, meaning the request was invalid; and 500 for server error, meaning the
    request was valid but couldn’t be fulfilled because of the server.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Web Things必须实现HTTP状态码20x、40x、50x。*** 如前所述，按照预期使用HTTP动词非常重要。当然，每个Web Things都支持所有这些是不现实的，但设备至少应该支持每组中的一个——例如，如果请求成功，则为200；对于客户端错误，即请求无效，则为400；对于服务器错误，即请求有效但服务器无法完成，则为500。'
- en: '***Web Things must support a `GET` on their root URL.*** Ideally, every resource
    should support the `GET` verb, so that clients can always retrieve its representations.
    But at the very least, the root URL must support `GET` so that a client is always
    able to access information about the device.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Web Things必须支持根URL上的`GET`操作。*** 理想情况下，每个资源都应该支持`GET`动词，以便客户端可以始终检索其表示。但至少，根URL必须支持`GET`，以便客户端始终能够访问设备信息。'
- en: '***Web Things should support CORS.*** Both simple and preflight CORS requests
    should be supported to allow direct access by applications in web browsers.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Web 实体应支持 CORS。*** 应支持简单和预检 CORS 请求，以允许网络浏览器中的应用程序直接访问。'
- en: '6.1.6\. Principle 4: Hypermedia as the Engine of Application State'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.6\. 原则 4：超媒体作为应用状态引擎
- en: 'The fourth principle of REST is known as *Hypermedia as the Engine of Application
    State (HATEOAS)*. Although this might be the worst acronym in the history of computer
    science, this principle isn’t as bad as it sounds. It contains two subconcepts:
    hypermedia and application state.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: REST 的第四个原则被称为 *超媒体作为应用状态引擎 (HATEOAS)*。尽管这可能是有史以来计算机科学中最糟糕的缩写，但这个原则并不像听起来那么糟糕。它包含两个子概念：超媒体和应用状态。
- en: Hypermedia
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 超媒体
- en: This fourth principle is centered on the notion of *hypermedia*, the idea of
    using links as connections between related ideas. Hypermedia was proposed in the
    early 1960s by Ted Nelson as a generalization of hypertext that includes various
    media formats in addition to text, such as video, images, or sounds. Links have
    become highly popular thanks to web browsers yet are by no means limited to human
    use. For example, UUIDs used to identify RFID tags are also links. Consider the
    abridged HTML fragment in the following listing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第四个原则围绕着 *超媒体* 的概念，即使用链接作为相关想法之间的连接。超媒体在 20 世纪 60 年代初期由 Ted Nelson 提出，作为超文本的推广，除了文本之外还包括各种媒体格式，如视频、图像或声音。由于网络浏览器的普及，链接变得非常流行，但它们并不仅限于人类使用。例如，用于识别
    RFID 标签的 UUID 也是一种链接。考虑以下列表中的简化的 HTML 片段。
- en: Listing 6.9\. HTML representation of the Raspberry Pi root resource
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.9\. Raspberry Pi 根资源的 HTML 表示
- en: '[PRE9]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Based on this representation of the device, you can easily follow these links
    to retrieve additional information about the subresources of the device, such
    as where to find its documentation. Instead of describing the entire structure
    of a web Thing and all its subresources into a single document that has to be
    maintained separately, such a tree-based model maps conveniently to the Things’
    resource tree shown in [figure 6.3](#ch06fig03) because every layer in the tree
    acts as a proxy that hides the layer underneath. Conveniently, this also enables
    us to retrieve and parse such a large file every time the structure changes because
    we only need to retrieve the resources we’re interested in.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此设备的表示，您可以轻松地通过这些链接检索有关设备子资源的更多信息，例如如何找到其文档。而不是将整个网络实体的结构和所有子资源描述在一个单独的文档中，该文档需要单独维护，这种基于树的模型方便地映射到
    [图 6.3](#ch06fig03) 中显示的实体的资源树，因为树中的每一层都充当一个代理，隐藏其下的层。方便的是，这也使我们能够在结构更改时检索和解析这样一个大文件，因为我们只需要检索我们感兴趣的资源。
- en: HATEOAS
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: HATEOAS
- en: The *application state*—the *AS* in HATEOAS—refers to a step in a process or
    workflow, similar to a state machine, and REST requires the *engine* of application
    state to be hypermedia driven.^([[11](#ch06fn11)]) Okay, great, but what does
    this mean? Simply that each possible state of your device or application needs
    to be a RESTful resource with its own unique URL, where any client can retrieve
    a representation of the current state and also the possible transitions to other
    states. Resource state, such as the status of an LED, is kept on the server and
    each request is answered with a representation of the current state and with the
    necessary information on how to change the resource state, such as turn off the
    LED or open the garage door.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*应用状态*——HATEOAS 中的 *AS*——指的是一个过程或工作流中的一个步骤，类似于状态机，REST 要求应用状态引擎由超媒体驱动。[11](#ch06fn11)
    好的，很好，但这意味着什么呢？简单地说，您的设备或应用程序的每个可能状态都需要是一个具有自己唯一 URL 的 RESTful 资源，任何客户端都可以检索当前状态的表示以及转换到其他状态的可能的过渡。资源状态，如
    LED 的状态，保留在服务器上，每个请求都通过当前状态的表示以及如何更改资源状态（如关闭 LED 或打开车库门）的必要信息来回答。'
- en: ^(11)
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([11](#ch06fn11))
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)'
- en: In other words, applications can be stateful as long as client state is not
    kept on the server and state changes within an application happen by following
    links, which meets the self-contained-messages constraint. Links are very important
    in the Web of Things because they enable clients to *discover* related resources,
    either by browsing in the case of a human user following links on pages, or by
    crawling in the case of a machine.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，只要客户端状态不在服务器上保持，并且应用程序内部的状态变化是通过跟随链接来实现的，那么应用程序就可以是有状态的，这符合自包含消息的约束。在物联网中，链接非常重要，因为它们使客户端能够
    *发现* 相关资源，无论是对于人类用户在网页上跟随链接进行浏览的情况，还是对于机器进行爬取的情况。
- en: In short, linking resources allows them to be dynamically discovered and rearranged
    without having to keep a sitemap somewhere. We’ll explain this in detail and experiment
    with it in [chapter 8](kindle_split_016.html#ch08), but for now let’s use the
    example shown in [listing 6.9](#ch06ex09). From the HTML representation you can
    see that there’s a link to a resource called “links.” As we’ll detail later, you
    could send a `GET` request to that resource to retrieve a JSON object with all
    the resources offered by the device, which is shown in the next listing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，通过链接资源，它们可以动态地被发现和重新排列，而无需在某个地方保持站点地图。我们将在第 8 章中详细解释这一点，并对其进行实验，但现在让我们使用
    [列表 6.9](#ch06ex09) 中所示的示例。从 HTML 表示形式中，你可以看到有一个指向名为“links”的资源的链接。正如我们稍后将要详细说明的，你可以向该资源发送一个
    `GET` 请求，以检索包含设备提供的所有资源的 JSON 对象，这将在下一列表中展示。
- en: Listing 6.10\. JSON representation of the “links” resource of a Raspberry Pi
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.10\. 树莓派“links”资源的 JSON 表示形式
- en: '[PRE10]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Thanks to this document, any HTTP client will be able to use the methods described
    in [chapter 8](kindle_split_016.html#ch08) to find the various resources and services
    offered by this device, what they mean, and how to interact with them. When a
    client requests an HTML representation of that same resource, such as your browser,
    you’ll see this same content but with actual links you can click on.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这份文档，任何 HTTP 客户端都将能够使用第 8 章中描述的方法来查找该设备提供的各种资源和服务，它们的意义以及如何与之交互。当客户端请求该资源的
    HTML 表示形式时，例如你的浏览器，你会看到相同的内容，但带有你可以点击的实际链接。
- en: OPTIONS
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: OPTIONS
- en: In the previous section we looked at HTTP verbs. A less-known HTTP verb implemented
    by most HTTP servers is quite helpful in terms of discovering what can be performed
    on resources. The `OPTIONS` verb can be used to retrieve the list of operations
    permitted by a resource, as well as metadata about invocations on this resource.
    This is a very useful feature in a programmable Web of Things, because it allows
    applications to find out what operations are allowed by a resource at runtime,
    simply by knowing the resource’s URL; see the next listing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了 HTTP 动词。大多数 HTTP 服务器实现的一个不太为人所知的 HTTP 动词在发现可以在资源上执行的操作方面非常有用。`OPTIONS`
    动词可以用来检索资源允许的操作列表，以及关于在此资源上调用元数据。在可编程的物联网中，这是一个非常有用的功能，因为它允许应用程序通过仅知道资源的 URL 就能在运行时找出资源允许的操作；请参见下一列表。
- en: Listing 6.11\. Using `OPTIONS` to retrieve the verbs supported by a resource
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.11\. 使用 `OPTIONS` 获取资源支持的动词
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As an example, [listing 6.10](#ch06ex10) is an `OPTIONS` request on `pi/sensors/humidity/`
    returning `GET, OPTIONS` to tell the client that the resource supports only those
    two verbs. Combining links with the `OPTIONS` verb means that clients can discover
    the resources available for a Thing but also what operations can be performed
    on a newly discovered resource.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[列表 6.10](#ch06ex10) 是对 `pi/sensors/humidity/` 的 `OPTIONS` 请求，返回 `GET, OPTIONS`
    以告知客户端该资源只支持这两个动词。将链接与 `OPTIONS` 动词结合意味着客户端可以发现事物的可用资源，以及可以对新发现的资源执行的操作。
- en: 'Design rules #4–HATEOAS'
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '设计规则 #4–HATEOAS'
- en: 'The fourth set of design rules emphasizes the ability to link resources logically
    so that clients can discover the resources of Things and the links between them,
    their operations, and parameters:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第四组设计规则强调逻辑上链接资源的能力，以便客户端可以发现事物的资源及其之间的链接、操作和参数：
- en: '***Web Things should support browsability with links.*** This means that web
    Things should always offer links to the resources related to them in the resource
    hierarchy, particularly to parent and children resources. This enables discovering
    all the resources of a Thing by browsing the ones that can be used by both humans
    and applications (crawlers). Ideally, links should be present in all representations.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Web Things 应支持通过链接进行浏览性。*** 这意味着 Web Things 应始终提供指向与其相关的资源在资源层次结构中的链接，尤其是父资源和子资源。这可以通过浏览人类和应用（爬虫）都可以使用的资源来发现一个事物的所有资源。理想情况下，链接应存在于所有表示中。'
- en: '***Web Things may support `OPTIONS` for each of its resources.*** When possible,
    sending an HTTP request to any resource should return the list of verbs supported
    by that resource. This is a useful piece of the HATEOAS puzzle because clients
    can automatically determine what they can do with a resource just by knowing its
    URL.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Web Things 可能支持其每个资源的 `OPTIONS`。*** 当可能时，向任何资源发送 HTTP 请求应返回该资源支持的动词列表。这是
    HATEOAS 拼图中的一个有用部分，因为客户端只需知道资源的 URL 就可以自动确定他们可以使用该资源做什么。'
- en: 6.1.7\. Summary—web Things design process
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.7\. 摘要—Web 事物设计过程
- en: 'In this section, we’ve shown that APIs for Things can be built by reusing patterns
    from the architecture of the web. Instead of using the web solely as a transport
    protocol, we make Things an integral part of the web and its infrastructure by
    using HTTP for what it was intended: as an Application layer protocol.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已表明可以通过重用 Web 架构中的模式来构建事物的 API。我们不是仅仅将 Web 用作传输协议，而是通过使用 HTTP 作为其预期用途：作为应用层协议，将事物作为
    Web 及其基础设施的组成部分。
- en: Five-step design process for web Things APIs
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Web Things API 的五步设计过程
- en: 'We described how a RESTful architecture makes it possible to use HTTP as a
    universal protocol for web-connected devices. We described the process of web-enabling
    Things, which are summarized in the five main steps of the web Things design process:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了如何使用 RESTful 架构使 HTTP 成为连接到网络的设备的通用协议。我们描述了使事物网络化的过程，该过程总结为 Web Things
    设计过程的五个主要步骤：
- en: '**1**.  *Integration strategy*—Choose a pattern to integrate Things to the
    internet and the web, either directly or through a proxy or gateway. This will
    be covered in [chapter 7](kindle_split_015.html#ch07), so we’ll skip this step
    for now.'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  *集成策略*—选择一种模式将事物集成到互联网和 Web 中，无论是直接还是通过代理或网关。这将在第 7 章（kindle_split_015.html#ch07）中介绍，所以我们现在将跳过这一步骤。'
- en: '**2**.  *Resource design*—Identify the functionality or services of a Thing
    and organize the hierarchy of these services. This is where we apply design rule
    #1: addressable resources.'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  *资源设计*—识别事物的功能或服务，并组织这些服务的层次结构。这就是我们应用设计规则 #1：可寻址资源的地方。'
- en: '**3**.  *Representation design—*Decide which representations will be served
    for each resource. The right representation will be selected by the clients, thanks
    to design rule #2: content negotiation.'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  *表示设计—*决定为每个资源提供哪些表示。正确的表示将由客户端选择，归功于设计规则 #2：内容协商。'
- en: '**4**.  *Interface design—*Decide which commands are possible for each service,
    along with which error codes. Here we apply design rule #3: self-descriptive messages.'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  *界面设计—*决定每个服务可能的命令以及相应的错误代码。在这里，我们应用设计规则 #3：自描述消息。'
- en: '**5**.  *Resource linking design—*Decide how the different resources are linked
    to each other and especially how to expose those resources and links, along with
    the operations and parameters they can use. In this final step we use design rule
    #4: Hypermedia as the Engine of Application State.'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**.  *资源链接设计—*决定不同资源之间的链接方式，特别是如何暴露这些资源及其链接，以及它们可以使用哪些操作和参数。在这一最后步骤中，我们使用设计规则
    #4：超媒体作为应用状态引擎。'
- en: '6.2\. Beyond REST: the real-time Web of Things'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 超越 REST：实时 Web 事物
- en: Until now, our interface has offered access only through HTTP. With this protocol,
    clients always initiate the communication with a server by sending requests and
    expecting a response in return; this is known as *request-response* communication.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的界面仅通过 HTTP 提供访问。使用此协议，客户端通过发送请求并期望获得响应来与服务器进行通信；这被称为 *请求-响应* 通信。
- en: 'In the Web of Things this pattern works well when the clients only need to
    send requests to a Thing. This is the case, for example, when a mobile application
    wants to retrieve the value of a sensor reading or when a web application is used
    to unlock a door. Unfortunately, the request-response model is insufficient for
    a number of IoT use cases. More precisely, it doesn’t match event-driven use cases
    where events must be communicated (pushed) to the clients as they happen. In this
    section we look at this issue in more detail and propose how to extend the request-response
    model of HTTP by using another web-friendly application protocol: WebSocket!'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网中，当客户端只需要向设备发送请求时，这种模式效果很好。例如，当移动应用想要检索传感器的读数值，或者当Web应用用于解锁门时。不幸的是，请求-响应模型对于许多物联网用例来说是不够的。更确切地说，它不适用于需要将事件（推送）作为事件发生时与客户端通信的事件驱动用例。在本节中，我们将更详细地探讨这个问题，并提出如何通过使用另一个Web友好的应用协议——WebSocket来扩展HTTP的请求-响应模型！
- en: 6.2.1\. The WoT needs events!
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1\. WoT需要事件！
- en: A client-initiated model isn’t practical for applications where notifications
    need to be sent asynchronously by a device to clients as soon as they’re produced.
    For example, a security camera or smoke alarm must be able to send an alert immediately
    when any anomaly has been detected and shouldn’t have to wait a until a client
    asks for this information. Consider the PIR sensor that we added to our Pi in
    [chapter 4](kindle_split_011.html#ch04). As a recap, a PIR sensor can detect when
    a person passes by. Using a request-response pattern with REST over HTTP isn’t
    efficient because we have to constantly poll the Pi for the latest value of the
    PIR sensor. Not only is this inefficient, but we might also miss an intruder if
    we don’t poll at the right moment. As shown in [figure 6.5](#ch06fig05), *polling*
    is one way of circumventing the problem.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要设备异步地将通知发送给客户端的应用来说，客户端发起的模型并不实用。例如，安全摄像头或烟雾报警器必须在检测到任何异常时立即发送警报，而不必等到客户端请求此信息。考虑我们在[第4章](kindle_split_011.html#ch04)中添加到我们的Pi上的PIR传感器。作为回顾，PIR传感器可以检测到有人经过。使用通过HTTP的REST请求-响应模式并不高效，因为我们必须不断轮询Pi以获取PIR传感器的最新值。这不仅效率低下，而且如果我们没有在正确的时间轮询，我们可能会错过入侵者。如图6.5所示，*轮询*是绕过这个问题的方法之一。
- en: 'Figure 6.5\. Basic polling: a client app sends requests to a web Thing at regular
    intervals. The results the client app gets are not synchronized with new values
    available from the sensor.'
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5\. 基本轮询：客户端应用以固定时间间隔向Web设备发送请求。客户端应用获取的结果与传感器新可用的值不同步。
- en: '![](06fig05.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig05.jpg)'
- en: The idea is that clients can request updates periodically from a web Thing by
    sending a `GET` request to the Thing on a regular basis. Although near real-time
    behavior can be simulated by a client sending the same request continuously—for
    example, every second—this approach is inefficient for most applications because
    it consumes unnecessary bandwidth and processor time. Most of the requests will
    end up with empty responses (`304 Not Modified`) or with the same response as
    long as the value observed remains unchanged. This is suboptimal for two reasons.
    First, it generates a great number of HTTP calls, and a large part of these calls
    are void. Because reducing the number of HTTP calls to the minimum is key in scaling
    web applications, this model doesn’t scale well when the number of clients increases.
    Second, a large amount of HTTP calls is a problem for battery-powered devices
    where only strictly necessary data should be sent.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是客户端可以通过定期向设备发送`GET`请求，从Web设备请求更新。尽管客户端可以通过连续发送相同的请求来模拟接近实时行为——例如，每秒一次——但对于大多数应用来说，这种方法效率低下，因为它消耗了不必要的带宽和处理时间。大多数请求最终会得到空响应（`304
    Not Modified`）或与观察到的值保持不变的相同响应。这有两个原因不够理想。首先，它产生了大量的HTTP调用，其中很大一部分是无效的。因为减少对Web应用进行扩展时HTTP调用的数量是关键，所以当客户端数量增加时，这种模型扩展性不好。其次，大量的HTTP调用对于仅应发送严格必要数据的电池供电设备来说是个问题。
- en: 6.2.2\. Publish/subscribe
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2\. 发布/订阅
- en: Interactive and reactive applications for the Web of Things require a simple
    and flexible mechanism to send events or receive notifications. What’s really
    needed on top of the request-response pattern is a model called publish/subscribe
    (*pub/sub*) that allows further decoupling between data consumers (*subscribers*)
    and producers (*publishers*). Publishers send messages to a central server, called
    a *broker*, that handles the routing and distribution of the messages to the various
    subscribers, depending on the type or content of messages. The simplest analogy
    is a chat room—some are public, and some are private. Sometimes you chat with
    only one person, and sometimes thousands. For devices, it would be the same thing.
    A publisher can send notifications into a *topic* (think chat room). Interested
    consumers can subscribe to one or several channels to receive all the notifications
    pushed by producers in that channel. Topics in pub/sub protocols are usually specified
    as arbitrary strings so it’s easy for us to map the REST resources of our web
    Things to pub/sub topics.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于物联网（Web of Things）的交互式和反应式应用，需要一个简单灵活的机制来发送事件或接收通知。在请求-响应模式之上真正需要的是一个称为发布/订阅（pub/sub）的模型，它允许进一步解耦数据消费者（subscribers）和数据生产者（publishers）。生产者向一个称为代理（broker）的中心服务器发送消息，该代理负责根据消息的类型或内容将消息路由和分发到各个订阅者。最简单的类比是聊天室——有的公开，有的私密。有时你只和一个人聊天，有时和成千上万的人。对于设备来说，情况也是一样的。一个生产者可以向一个主题（想象成聊天室）发送通知。感兴趣的消费者可以订阅一个或多个频道，以接收该频道中生产者推送的所有通知。在pub/sub协议中，主题通常指定为任意字符串，这样我们就可以轻松地将我们的Web
    Things的REST资源映射到pub/sub主题上。
- en: 'Let’s look at a practical example of how this would work for our Pi. As shown
    in [figure 6.6](#ch06fig06), a number of clients subscribe to a topic managed
    by a broker. Whenever a client wants to update a topic, it sends a message to
    the broker—that is, it publishes the message via the broker. The broker in turn
    sends it to all the topic’s subscribers. Note that the broker could be the Thing
    itself or an external broker somewhere on the web. In the left side of [figure
    6.6](#ch06fig06), Client A subscribes to the following topic: [http://devices.webofthings.io/pi/sensors/temperature](http://devices.webofthings.io/pi/sensors/temperature).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个实际例子，看看这对我们的树莓派（Pi）是如何工作的。如图6.6所示，许多客户端订阅了一个由代理（broker）管理的主题。每当一个客户端想要更新一个主题时，它会向代理发送一个消息——也就是说，它通过代理发布消息。代理随后将消息发送给所有订阅该主题的客户端。请注意，代理可以是事物本身，也可以是网络上某个地方的外部代理。在图6.6的左侧，客户端A订阅了以下主题：[http://devices.webofthings.io/pi/sensors/temperature](http://devices.webofthings.io/pi/sensors/temperature)。
- en: 'Figure 6.6\. Left: subscription pattern in a pub/sub. Client A subscribes to
    temperature updates, clients B and C to PIR updates. They all subscribe via the
    broker, which maintains a list of who has subscribed to what topic. Right: publication
    pattern. An intruder is detected, so the Thing publishes a PIR update to the broker.
    The broker delivers the update to clients B and C.'
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.6。左：pub/sub中的订阅模式。客户端A订阅温度更新，客户端B和C订阅PIR更新。他们都通过代理订阅，代理维护着一个订阅者列表，记录了谁订阅了什么主题。右：发布模式。检测到入侵者，因此事物向代理发布PIR更新。代理将更新传递给客户端B和C。
- en: '![](06fig06_alt.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6](06fig06_alt.jpg)'
- en: We’ll shorten the topic here to `/temperature` for readability. Clients B and
    C subscribe to `/pir` via the broker. The right part of [figure 6.6](#ch06fig06)
    shows the publication mechanism. Someone passed by the sensor, so the Thing generates
    a PIR sensor update notification to inform all the listeners. The broker knows
    which clients are currently listening for the `/pir` topic, so it immediately
    sends this update to clients B and C.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，我们将主题缩短为`/temperature`。客户端B和C通过代理订阅`/pir`。图6.6的右侧显示了发布机制。有人经过传感器，因此事物生成PIR传感器更新通知，通知所有听众。代理知道哪些客户端正在监听`/pir`主题，因此它立即将此更新发送给客户端B和C。
- en: 'Now that we have the pattern we needed on top of request-response interactions,
    the question is how to implement it with technologies supported on the web—and
    hopefully also by common web browsers. Speaking in terms of layers, we need a
    web application protocol that can support the implementation of a pub/sub system.
    There are a number of candidates to achieve that, and we’ll look at three techniques:
    webhooks, Comet, and WebSockets.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了请求-响应交互所需的上层模式，问题是如何利用网络支持的技术来实现它，并且希望也能被常见的网络浏览器所支持。从层次结构的角度来说，我们需要一个能够支持实现发布/订阅系统的网络应用协议。为此，有多个候选方案，我们将探讨三种技术：webhooks、Comet和WebSockets。
- en: 6.2.3\. Webhooks—HTTP callbacks
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.3\. Webhooks—HTTP回调
- en: The simplest way to implement a publish-subscribe system over HTTP without breaking
    the REST model is to treat every entity as both a client and a server. This way,
    both web Things and web applications can act as HTTP clients by initiating requests
    to other servers, and they can host a server that can respond to other requests
    at the same time. This pattern is called *webhooks* or *HTTP callbacks* and has
    become popular on the web for enabling different servers to talk to each other.
    For example, this is the mechanism used by PayPal to confirm to eBay—or any other
    shopping site—that your payment has been accepted.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在不破坏REST模型的情况下，通过HTTP实现发布/订阅系统的最简单方法是将每个实体都视为客户端和服务器。这样，Web设备和Web应用都可以作为HTTP客户端，通过向其他服务器发起请求来行动，并且它们可以同时托管一个服务器来响应其他请求。这种模式被称为*webhooks*或*HTTP回调*，在网络上变得流行，用于使不同的服务器能够相互通信。例如，这是PayPal用来向eBay或任何其他购物网站确认您的付款已被接受所使用的机制。
- en: The implementation of this model is fairly simple. All we need is to implement
    a REST API on both the Thing and on the client, which then becomes a server as
    well. This means that when the Thing has an update, it `POST`s it via HTTP to
    the client, as shown in [figure 6.7](#ch06fig07). This implies that the client
    must implement an HTTP server with a REST API that can be accessed by the Thing—for
    example, by having a public URL. The detail of the necessary calls is shown in
    the following listing.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型的实现相当简单。我们只需要在设备和客户端上实现一个REST API，这样客户端也就变成了服务器。这意味着当设备有更新时，它通过HTTP `POST`到客户端，如图6.7所示。这意味着客户端必须实现一个HTTP服务器，并带有可以由设备访问的REST
    API——例如，通过拥有一个公开的URL。必要的调用细节如下所示。
- en: Figure 6.7\. A webhook mechanism implemented between a Thing and a client. The
    client subscribes to the humidity resource via a `POST` on the Thing API. The
    Thing then informs the server of humidity changes via a `POST` on the client API.
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.7\. 在设备和客户端之间实现的webhook机制。客户端通过在设备API上`POST`来订阅湿度资源。设备随后通过在客户端API上`POST`来通知服务器湿度变化。
- en: '![](06fig07_alt.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig07_alt.jpg)'
- en: Listing 6.12\. Subscription via a webhook
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.12\. 通过webhook进行订阅
- en: '![](ch06ex12-0.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06ex12-0.jpg)'
- en: '![](ch06ex12-1.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06ex12-1.jpg)'
- en: 'Webhooks are a conceptually simple way to implement bidirectional communication
    between clients and servers by turning everything into a server. As you’ve just
    seen, webhooks can also be used to implement a pub/sub for the Web of Things.
    But webhooks have one big drawback: because they need the subscriber to have an
    HTTP server to push the notification, this works only when the subscriber has
    a publicly accessible URL or IP address. In the real world this is very limiting
    because it will rarely be the case outside server-to-server (or Thing-to-Thing!)
    communication. Consider the case of a JavaScript application running in your browser
    that wants to get notifications from a Thing: even if there was a hacky way for
    the application to start an HTTP server inside your web browser,^([[12](#ch06fn12)])
    it’s unlikely that the firewall of your network would allow incoming requests
    from the internet to your machine.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Webhooks是一种通过将所有内容转换为服务器来实现客户端和服务器之间双向通信的概念上简单的方法。正如您刚才看到的，webhooks也可以用来实现物联网的发布/订阅。但webhooks有一个很大的缺点：因为它们需要订阅者拥有一个HTTP服务器来推送通知，所以这只有在订阅者有一个公开可访问的URL或IP地址时才有效。在现实世界中，这非常有限，因为除了服务器到服务器（或设备到设备！）通信之外，很少会有这种情况。考虑一个运行在您的浏览器中的JavaScript应用程序，它想要从设备获取通知的情况：即使应用程序有在您的网络浏览器内部启动HTTP服务器的方法，^([12](#ch06fn12))，但您的网络防火墙不太可能允许来自互联网的请求到达您的机器。
- en: ^(12)
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([12](#ch06fn12))
- en: ''
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that this can be done by writing a custom plugin for your browser that
    will allow it to interact with Things. But using such non-standard extensions
    is a no-go in the real world because it severely limits the vision of a seamlessly
    accessible Web of Things.
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，这可以通过编写一个自定义插件来实现，该插件允许浏览器与事物交互。但在现实世界中，使用这种非标准的扩展是不可行的，因为它严重限制了无缝访问物联网的愿景。
- en: 6.2.4\. Comet—hacking HTTP for a real-time web
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.4\. Comet—为实时Web破解HTTP
- en: The limitations of webhooks when it comes to browser applications led to a number
    of workarounds to deal with the problem of real-time events on the web. *Comet*
    is an umbrella term that refers to a range of techniques for circumventing the
    limitations of HTTP polling and webhooks by introducing event-based communication
    over HTTP. This model enables web servers to push data back to the browser without
    the client requesting it explicitly. Since browsers were initially not designed
    with server-sent events in mind, web application developers have exploited several
    specification loopholes to implement Comet-like behavior, each with different
    benefits and drawbacks.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到浏览器应用程序时，Webhooks的限制导致了许多解决方案来处理网页上实时事件的问题。"Comet"是一个总称，指的是一系列通过在HTTP上引入基于事件的通信来绕过HTTP轮询和Webhooks限制的技术。这种模型使得Web服务器能够在客户端没有明确请求的情况下将数据推送到浏览器。由于浏览器最初并没有考虑到服务器发送事件，因此Web应用程序开发人员已经利用了几个规范漏洞来实现类似Comet的行为，每种方法都有其不同的优点和缺点。
- en: Among them is a technique called *long polling*, illustrated in [figure 6.8](#ch06fig08).
    With long polling, a client sends a standard HTTP request to the server, but instead
    of receiving the response right away, the server holds the request until an event
    is received from the sensor, which is then injected into the response returned
    to the client’s request that was held idle. As soon as the client receives the
    response, it immediately sends a new request for an update, which will be held
    until the next update comes from the sensor, and so on. The latency for events
    to reach the client is thus minimized. But the client must be put on hold with
    an open HTTP request that’s waiting for an answer and must send a request after
    each response. This increases the load on the server and forces the clients to
    send unnecessary messages.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 其中包括一种称为*长轮询*的技术，如图6.8所示。使用长轮询，客户端向服务器发送一个标准的HTTP请求，但服务器不会立即响应，而是保留该请求，直到从传感器接收到事件，然后将其注入到返回给客户端的空闲请求的响应中。一旦客户端收到响应，它立即发送一个新的请求以获取更新，该请求将被保留，直到从传感器收到下一个更新，依此类推。因此，事件到达客户端的延迟被最小化。但是，客户端必须保持在一个打开的HTTP请求中，等待答案，并且在每次响应后都必须发送一个请求。这增加了服务器的负载，并迫使客户端发送不必要的消息。
- en: 'Figure 6.8\. Long polling: a client sends a request, which is kept on hold
    until an event is received from the sensor, at which point it gets forwarded by
    the web Thing to the client as the response of their initial request. After that,
    they reinitiate a new request, which will be kept open in the same way until a
    new value from the sensor is retrieved.'
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.8\. 长轮询：客户端发送一个请求，该请求被保留，直到从传感器接收到事件，此时它被Web Thing转发给客户端作为其初始请求的响应。之后，它们重新发起一个新的请求，该请求将以相同的方式保持打开状态，直到从传感器检索到新的值。
- en: '![](06fig08_alt.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig08_alt.jpg)'
- en: 6.2.5\. WebSockets
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.5\. WebSocket
- en: Although workarounds like Comet helped move things forward, they are patches,
    not solutions. Comet and other long polling solutions are inefficient. Webhooks
    are impractical in the case of web browsers.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管像Comet这样的解决方案有助于推进事物的发展，但它们只是修补，而不是真正的解决方案。Comet和其他长轮询解决方案效率低下。在Web浏览器的情况下，Webhooks不切实际。
- en: 'But not all hope is lost! A more recent, true web protocol for push communications
    has emerged: WebSocket! WebSocket^([[13](#ch06fn13)]) is part of the HTML5 specification.
    The increasing support for HTML5 in most recent web and mobile web browsers means
    WebSocket is becoming ubiquitously available to all web apps. Just like for REST
    over HTTP, this ubiquitous support makes WebSocket a fairly good candidate to
    implement pub/sub support in the Web of Things.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非所有的希望都破灭了！一个更近期的、真正的推送通信Web协议已经出现：WebSocket！WebSocket^([[13](#ch06fn13)])是HTML5规范的一部分。HTML5在大多数最新的Web和移动Web浏览器中得到越来越多的支持，这意味着WebSocket对所有Web应用程序都是普遍可用的。就像HTTP上的REST一样，这种普遍的支持使得WebSocket成为在物联网中实现pub/sub支持的相当好的候选者。
- en: ^(13)
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(13)
- en: ''
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Reference: [http://www.websocket.org/](http://www.websocket.org/).'
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参考：[http://www.websocket.org/](http://www.websocket.org/).
- en: In [chapter 2](kindle_split_009.html#ch02), you experimented with building a
    WebSockets client and were exposed to the simple client API of WebSockets giving
    access to the protocol directly via JavaScript running in your browser. Here,
    we’ll focus in more detail on the WebSockets protocol and how to use it to implement
    a pub/sub mechanism for web Things.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](kindle_split_009.html#ch02)中，你尝试构建了一个 WebSocket 客户端，并接触到了 WebSocket 的简单客户端
    API，该 API 通过浏览器中运行的 JavaScript 直接访问协议。在这里，我们将更详细地关注 WebSocket 协议以及如何使用它来实现 Web
    Things 的 pub/sub 机制。
- en: WebSocket protocol handshake
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: WebSocket 协议握手
- en: WebSockets enables a full-duplex communication channel over a single TCP connection.
    In plain English, this means that it creates a permanent link between the client
    and the server that both the client and the server can use to send messages to
    each other. Unlike techniques we’ve seen before, such as Comet, WebSocket is standard
    and opens a TCP socket. This means it doesn’t need to encapsulate custom, non-web
    content in HTTP messages or keep the connection artificially alive as is needed
    with Comet implementations.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 在单个 TCP 连接上启用全双工通信通道。用简单的话说，这意味着它创建了一个客户端和服务器之间的永久链接，客户端和服务器都可以使用它来互相发送消息。与之前我们看到的技术不同，如
    Comet，WebSocket 是标准的，并打开一个 TCP 套接字。这意味着它不需要在 HTTP 消息中封装自定义的非网页内容，也不需要像 Comet 实现那样人工保持连接活跃。
- en: A WebSocket connection is initialized, creating a *handshake*, as networking
    nerds would put it, in three steps, as shown in [figure 6.9](#ch06fig09). The
    first step is to send an HTTP call to the server with a special header asking
    for the protocol to be upgraded to WebSockets. If the web server supports WebSockets,
    it will reply with a `101 Switching Protocols` status code, acknowledging the
    opening of a full-duplex TCP socket.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 连接通过三个步骤初始化，就像网络爱好者所说的那样，创建了一个 *握手*，如图 6.9 所示。第一步是向服务器发送一个带有特殊头部的
    HTTP 请求，要求将协议升级到 WebSocket。如果 web 服务器支持 WebSocket，它将以 `101 Switching Protocols`
    状态码回复，确认全双工 TCP 套接字的打开。
- en: Figure 6.9\. A WebSockets protocol handshake. First, the connection is opened
    via a `GET` request for a protocol upgrade. Then the persistent TCP connection
    is opened, and the client and server can exchange data frames. One of the parties
    (server or client) eventually sends a control frame to signal that the communication
    is over and can be closed.
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.9\. WebSocket 协议握手。首先，通过一个用于协议升级的 `GET` 请求打开连接。然后打开持久的 TCP 连接，客户端和服务器可以交换数据帧。最终，一方（服务器或客户端）发送一个控制帧来表示通信结束并可以关闭。
- en: '![](06fig09.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig09.jpg)'
- en: 'Let’s look at a concrete example using the PIR sensor we set up in [chapter
    4](kindle_split_011.html#ch04), which runs on our Pi at [http://devices.webofthings.io/pi/sensors/pir](http://devices.webofthings.io/pi/sensors/pir).
    If you access this address with your browser, you’ll get the HTML representation
    of the PIR sensor. Similarly, if you access it and ask for it using the `Content-Type:
    application/json` header shown previously, you’ll get the value of the PIR sensor
    in JSON; this is REST over HTTP, implemented as you’ve seen before. Now, using
    the same resource, you can also ask for WebSockets content by asking for a protocol
    upgrade, as shown in the next listing.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看看一个具体的例子，使用我们在[第4章](kindle_split_011.html#ch04)中设置的 PIR 传感器，该传感器在我们的 Pi
    上运行在 [http://devices.webofthings.io/pi/sensors/pir](http://devices.webofthings.io/pi/sensors/pir)。如果你用浏览器访问这个地址，你会得到
    PIR 传感器的 HTML 表示形式。同样，如果你访问它并使用之前显示的 `Content-Type: application/json` 头部请求它，你会得到
    PIR 传感器的值，这是通过 HTTP 实现的 REST；正如你之前所看到的。现在，使用相同的资源，你也可以通过请求协议升级来请求 WebSocket 内容，如下一个列表所示。'
- en: Listing 6.13\. Client request in a WebSockets handshake
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.13\. WebSocket 握手中的客户端请求
- en: '![](169fig01_alt.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](169fig01_alt.jpg)'
- en: What’s really interesting here is that the call to upgrade the protocol is issued
    via HTTP. This means that a client wanting real-time data can always ask for a
    REST resource to be delivered via WebSockets and fall back to pure HTTP in case
    the server doesn’t support WebSockets. In the case of our `devices.webofthings.io`
    server, it does support WebSockets and will reply with an acknowledgement of the
    protocol upgrade, as shown in the following listing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这里真正有趣的是，升级协议的调用是通过 HTTP 发起的。这意味着想要实时数据的客户端始终可以请求通过 WebSocket 交付 REST 资源，如果服务器不支持
    WebSocket，则回退到纯 HTTP。在我们的 `devices.webofthings.io` 服务器的情况下，它支持 WebSocket，并将回复协议升级的确认，如下面的列表所示。
- en: Listing 6.14\. Server response in a WebSockets handshake
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.14\. WebSocket 握手中的服务器响应
- en: '![](170fig01_alt.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](170fig01_alt.jpg)'
- en: The full handshake between the client and the server offering values for the
    PIR sensor via WebSockets is shown in [figure 6.10](#ch06fig10).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器通过WebSockets提供PIR传感器值的完整握手过程在[图6.10](#ch06fig10)中展示。
- en: Figure 6.10\. A WebSocket protocol handshake in action as seen in the Network
    tool of Firefox. The client requests a protocol upgrade that the server accepts.
    From then on, the client and the server can send each other messages over the
    TCP connection, which will be kept open until the client or server decides to
    close it.
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.10。Firefox网络工具中看到的WebSocket协议握手动作。客户端请求协议升级，服务器接受。从那时起，客户端和服务器可以通过TCP连接互相发送消息，该连接将保持打开状态，直到客户端或服务器决定关闭它。
- en: '![](06fig10_alt.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig10_alt.jpg)'
- en: Once the initial handshake takes place, the client and the server will be able
    to send messages back and forth over the open TCP connection; these messages are
    not HTTP messages but WebSockets data frames. Text and binary data frames can
    be sent in either direction and simultaneously. The overhead of each WebSockets
    data frame is 2 bytes, which is small compared to the 871-byte overhead of an
    HTTP message metadata (headers and the like). Add to this the overhead of IP,
    TCP, and TLS (see [chapter 9](kindle_split_017.html#ch09)), and you have an additional
    60–100 bytes per message! This makes WebSockets communication a lot less bandwidth-consuming
    than HTTP.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成初始握手，客户端和服务器将能够通过开放的TCP连接来回发送消息；这些消息不是HTTP消息，而是WebSockets数据帧。文本和二进制数据帧可以双向同时发送。每个WebSockets数据帧的开销是2字节，与HTTP消息元数据（如标题等）的871字节开销相比很小。再加上IP、TCP和TLS的开销（见[第9章](kindle_split_017.html#ch09)），每条消息将额外增加60-100字节！这使得WebSockets通信比HTTP消耗的带宽少得多。
- en: The syntax and semantics of the messages they exchange are open, but the `Sec-WebSocket-Protocol`
    request header can be used to specify a protocol to use inside the data frames
    (in this example, we use “wot,” which is a fictive sub-protocol). The registered
    sub-protocols are managed by the Internet Assigned Numbers Authority (IANA).^([[14](#ch06fn14)])
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 他们交换的消息的语法和语义是开放的，但可以使用`Sec-WebSocket-Protocol`请求头来指定数据帧内部使用的协议（在这个例子中，我们使用“wot”，这是一个虚构的子协议）。已注册的子协议由互联网数字分配机构（IANA）管理.^([[14](#ch06fn14)])
- en: ^(14)
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(14)
- en: ''
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.iana.org/assignments/websocket/websocket.xml](http://www.iana.org/assignments/websocket/websocket.xml)'
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.iana.org/assignments/websocket/websocket.xml](http://www.iana.org/assignments/websocket/websocket.xml)'
- en: WebSockets for the WoT
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物联网的WebSockets
- en: What’s really interesting with WebSockets for the Web of Things is that they
    use standard internet and web technologies. Because they open a TCP connection
    over port 80, WebSockets aren’t blocked by firewalls and can traverse proxies.
    Then, because they work in the browser and are bootstrapped via HTTP, they let
    us use a lot of the principles we looked at when exploring HTTP and REST. First,
    the hierarchical structure of Things and their resources as URLs can be reused
    as-is for WebSockets. As you saw in [listing 6.14](#ch06ex14), we can subscribe
    to events for a Thing’s resource by using its corresponding URL and asking for
    a protocol upgrade to WebSockets. Moreover, WebSockets do not dictate the format
    of messages that are sent back and forth. This means we can happily use JSON and
    give messages the structure and semantics we’ll work on in [chapter 8](kindle_split_016.html#ch08).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于物联网的WebSockets来说，真正有趣的是它们使用了标准的互联网和Web技术。因为它们通过80端口打开TCP连接，所以WebSockets不会被防火墙阻止，并且可以穿越代理。然后，因为它们在浏览器中工作，并且通过HTTP启动，这使得我们可以使用在探索HTTP和REST时考虑到的许多原则。首先，事物的分层结构和它们的资源作为URL可以原样重用于WebSockets。正如你在[列表6.14](#ch06ex14)中看到的，我们可以通过使用相应的URL并请求将协议升级到WebSockets来订阅事物的资源事件。此外，WebSockets不指定来回发送的消息的格式。这意味着我们可以愉快地使用JSON，并为消息赋予我们在[第8章](kindle_split_016.html#ch08)中将工作的结构和语义。
- en: Moreover, because WebSockets consist of an initial handshake followed by basic
    message framing layered over TCP, they can be directly implemented on many platforms
    supporting TCP/IP—not just web browsers. They can also be used to wrap several
    other internet-compatible protocols to make them web-compatible. One example is
    MQTT, a well-known pub/sub protocol for the IoT that can be integrated to the
    web of browsers via WebSockets. You’ll see that in more detail in the next chapter.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于 WebSocket 由一个初始握手和随后在 TCP 上层叠的基本消息帧组成，它们可以直接在许多支持 TCP/IP 的平台上实现——而不仅仅是网页浏览器。它们还可以用来封装其他与互联网兼容的协议，使它们成为网页兼容。一个例子是
    MQTT，这是一个著名的物联网 pub/sub 协议，可以通过 WebSocket 集成到网页浏览器中。你将在下一章中更详细地了解这一点。
- en: The permanent link created by WebSocket communication is interesting in an Internet
    of Things context, especially when considering applications wanting to observe—or
    subscribe to—real-world properties such as environmental sensors. Finally, WebSockets
    offer all of these benefits with significantly reduced bandwidth consumption when
    compared to HTTP polling, for example. The drawback, however, is that keeping
    a TCP connection permanently open can lead to an increase in battery consumption
    and is harder to scale than HTTP on the server side.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网的背景下，WebSocket 通信创建的永久链接很有趣，尤其是在考虑希望观察或订阅现实世界属性（如环境传感器）的应用程序时。最后，与 HTTP
    轮询相比，WebSocket 显著降低了带宽消耗。然而，缺点是保持 TCP 连接始终开启可能会导致电池消耗增加，并且比 HTTP 在服务器端更难扩展。
- en: '6.2.6\. The future: from HTTP/1.1 to HTTP/2'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.6\. 未来：从 HTTP/1.1 到 HTTP/2
- en: When used correctly, HTTP/1.1 is a great protocol to build web services, as
    you saw in this chapter. But it dates back to 1999\. Remember that time? Back
    then, we were using Windows 95 and using wired phones to call each other, and
    the IoT term had just been coined! We also mainly used HTTP to display hit counters,
    sitemaps, and animated “under construction” gifs, but not to display much real-time
    data and certainly not to interact with devices.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确使用时，HTTP/1.1 是构建网络服务的一个优秀协议，正如你在本章中看到的。但它可以追溯到 1999 年。你还记得那个时代吗？当时，我们使用 Windows
    95，用有线电话互相通话，物联网这个术语才刚刚被提出！我们主要使用 HTTP 来显示点击计数器、网站地图和动画的“建设中”gif，但并不是用来显示很多实时数据，更不是用来与设备交互。
- en: Clearly, the web has evolved tremendously since then, and the need for scalability,
    performance, real-time messaging, and security has increased significantly. As
    a result, the internet is about to fully embrace a revolution called IPv6 (see
    [chapter 5](kindle_split_012.html#ch05)) and another called HTTP/2.^([[15](#ch06fn15)])
    The new protocol wasn’t designed specifically for the IoT, but the creators of
    this new protocol clearly took into account some of the needs of the IoT. HTTP/2
    focuses on a number of improvements over HTTP/1.1 and can easily run on your Pi!^([[16](#ch06fn16)])
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，自那时以来，网络已经发生了巨大的变化，对可扩展性、性能、实时消息传递和安全性的需求显著增加。因此，互联网即将全面拥抱一场名为 IPv6 的革命（见[第
    5 章](kindle_split_012.html#ch05))，以及另一场名为 HTTP/2 的革命.^([[15](#ch06fn15)]) 新协议并非专门为物联网设计，但新协议的创造者显然考虑到了物联网的一些需求。HTTP/2
    专注于在 HTTP/1.1 上进行多项改进，并且可以轻松运行在你的 Pi 上！^([[16](#ch06fn16)])
- en: ^(15)
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(15)
- en: ''
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://http2.github.io](http://http2.github.io)'
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://http2.github.io](http://http2.github.io)'
- en: ^(16)
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(16)
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are already several implementations of HTTP/2 for Node.js. Should you
    want to experiment with HTTP/2 on your Pi, you should try the `node-http2` module
    available on [https://github.com/molnarg/node-http2](https://github.com/molnarg/node-http2).
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 已经有几种 HTTP/2 的 Node.js 实现。如果你想在你 Pi 上尝试 HTTP/2，你应该尝试在 [https://github.com/molnarg/node-http2](https://github.com/molnarg/node-http2)
    上可用的 `node-http2` 模块。
- en: Performance improvements
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 性能改进
- en: This new version of HTTP allows multiplexing responses—that is, sending responses
    in parallel. This fixes the head-of-line blocking problem of HTTP/1.x where only
    one request can be outstanding on a TCP/IP connection at a time^([[17](#ch06fn17)]).
    Furthermore, it fosters clients and servers to use a single TCP connection on
    which requests and responses are sent in streams.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的 HTTP 版本允许多路复用响应——也就是说，并行发送响应。这解决了 HTTP/1.x 的首部阻塞问题，当时在 TCP/IP 连接上一次只能有一个请求是挂起的^([[17](#ch06fn17)]）。此外，它鼓励客户端和服务器使用单个
    TCP 连接，在该连接上请求和响应以流的形式发送。
- en: ^(17)
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(17)
- en: ''
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In HTTP/1.1 pipelining was proposed to fix this problem but it did not completely
    address the problem and is hard to deploy; see [https://devcentral.f5.com/articles/http-pipelining-a-security-risk-without-real-performance-benefits](https://devcentral.f5.com/articles/http-pipelining-a-security-risk-without-real-performance-benefits).
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在HTTP/1.1中提出了流水线技术来解决这个问题，但它并没有完全解决这个问题，并且难以部署；参见[https://devcentral.f5.com/articles/http-pipelining-a-security-risk-without-real-performance-benefits](https://devcentral.f5.com/articles/http-pipelining-a-security-risk-without-real-performance-benefits)。
- en: This is an interesting feature for the WoT because it leads to a more efficient
    use of connections, which reduces the overhead of HTTP. It also leads to faster
    transmissions and hence potential savings in terms of battery power required to
    communicate.^([[18](#ch06fn18)])
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于WoT来说是一个有趣的功能，因为它导致连接的更高效使用，从而减少了HTTP的开销。它还导致传输速度更快，因此有可能在通信所需的电池功率方面节省能源.^([[18](#ch06fn18)])
- en: ^(18)
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(18)
- en: ''
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Akamai developed a simple page that lets you experiment with these improvements:
    [https://http2.akamai.com/demo](https://http2.akamai.com/demo).'
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Akamai开发了一个简单的页面，让您可以尝试这些改进：[https://http2.akamai.com/demo](https://http2.akamai.com/demo)。
- en: More efficient formats
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更高效的格式
- en: HTTP/2 also introduces compressed headers using an efficient and low-memory
    compression format,^([[19](#ch06fn19)]) unlike GZIP, the most common compression
    format used on top of HTTP. This reduces the size of each HTTP request and response.
    In addition, whereas HTTP/1.1 was an ASCII protocol—that is, a protocol transmitting
    ASCII characters—HTTP/2 uses binary framing, meaning that it transmits binary
    streams of data. Binary protocols are more efficient to parse and more compact.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2还引入了使用高效且低内存压缩格式的压缩头，^([[19](#ch06fn19)])与在HTTP之上最常用的压缩格式GZIP不同。这减少了每个HTTP请求和响应的大小。此外，HTTP/1.1是一个ASCII协议——即传输ASCII字符的协议——而HTTP/2使用二进制帧，这意味着它传输二进制数据流。二进制协议在解析上更高效，且更紧凑。
- en: ^(19)
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(19)
- en: ''
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Called HPACK: Header Compression for HTTP/2\. See: [https://datatracker.ietf.org/doc/rfc7541/](https://datatracker.ietf.org/doc/rfc7541/).'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 称为HPACK：HTTP/2的头压缩。参见：[https://datatracker.ietf.org/doc/rfc7541/](https://datatracker.ietf.org/doc/rfc7541/)。
- en: All of this is particularly interesting for the “Web of resource-limited Things”
    because it means the size of packets is significantly smaller, allowing for devices
    with limited RAM to happily deal with HTTP/2.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都特别有趣，因为“资源受限的物联网”意味着数据包的大小显著减小，允许具有有限RAM的设备愉快地处理HTTP/2。
- en: Server push
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 服务器推送
- en: Finally, HTTP/2 introduces the notion of *server push*. Concretely, this means
    that the server can provide content to clients without having to wait for them
    to send a request. In the long run, widespread adoption of server push over HTTP/2
    might even remove the need for an additional protocol for push like WebSocket
    or webhooks.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，HTTP/2引入了*服务器推送*的概念。具体来说，这意味着服务器可以在不需要等待客户端发送请求的情况下向客户端提供内容。从长远来看，HTTP/2上服务器推送的广泛应用甚至可能消除像WebSocket或webhooks这样的推送协议的需求。
- en: HTTP/2 and the Web of Things
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: HTTP/2与物联网
- en: 'This overview of the features of HTTP/2 and what they mean for the Web of Things
    is by no means complete, but it shows that the future of the web will make an
    even better Web of Things. Interestingly enough, you won’t have to change your
    approach very much: the implementation of HTTP will change, but not the API you
    build on top of it, because the semantics of HTTP remain unchanged with HTTP/2\.
    Thus, anything you’ll learn in the reminder of this book will be applicable to
    HTTP/2 as well!'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这对HTTP/2的功能及其对物联网的影响的概述远非完整，但它表明网络的未来将使物联网变得更加出色。有趣的是，您不需要改变太多方法：HTTP的实现将改变，但您构建在其上的API不会改变，因为HTTP/2的语义保持不变。因此，您在本书的剩余部分学到的任何内容都将适用于HTTP/2！
- en: The HTTP/2 specification was officially accepted in February 2015, and several
    browsers such as Chrome, Firefox, and Opera have started supporting it. This means
    that the standard is about to be globally deployed and will soon make the Web
    of Things a lot more efficient!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2规范于2015年2月正式通过，Chrome、Firefox和Opera等几个浏览器已经开始支持它。这意味着该标准即将在全球范围内部署，并将很快使物联网变得更加高效！
- en: 6.3\. Summary
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3. 摘要
- en: When applied correctly, the REST architecture is an excellent substrate on which
    to create large-scale and flexible distributed systems.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当正确应用时，REST架构是创建大规模和灵活分布式系统的优秀基础。
- en: REST APIs are interesting and easily applicable to enable access to data and
    services of physical objects and other devices.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST API非常有趣，并且易于应用，可以启用对物理对象和其他设备的访问。
- en: Various mechanisms, such as content negotiation and caching of Hypermedia as
    the Engine of Application State (HATEOAS), can help in creating great APIs for
    Things.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种机制，如内容协商和作为应用状态引擎的Hypermedia（HATEOAS）的缓存，有助于创建出色的物联API。
- en: A five-step design process (integration strategy, resource design, representation
    design, interface design, and resource linking) allows anyone to create a meaningful
    REST API for Things based on industry best practices.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个五步设计过程（集成策略、资源设计、表示设计、界面设计和资源链接）允许任何人根据行业最佳实践为物联创建有意义的REST API。
- en: The latest developments in the real-time web, such as WebSockets, allow creating
    highly scalable, distributed, and heterogeneous real-time data processing applications.
    Devices that speak directly to the web can easily use web-based push messaging
    to stream their sensor data efficiently.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时Web的最新发展，如WebSockets，允许创建高度可扩展、分布式和异构的实时数据处理应用。直接与网络通信的设备可以轻松使用基于Web的推送消息来高效地流式传输其传感器数据。
- en: HTTP/2 will bring a number of interesting optimizations for Things, such as
    multiplexing and compression.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP/2将为物联带来许多有趣的优化，例如多路复用和压缩。
- en: You’ve had an in-depth look at REST and HTTP, but if you’re hungry for more
    you might want to have a look at the very good *RESTful Web Services* by Leonard
    Richardson and Sam Ruby (O’Reilly Media, 2007)^([[20](#ch06fn20)]) or browse to
    the WoT Publications page,^([[21](#ch06fn21)]) where you’ll find a number of resources
    about using REST for real-world devices.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经深入了解了REST和HTTP，但如果你还想了解更多，你可能想看看Leonard Richardson和Sam Ruby所著的非常好的*RESTful
    Web Services*（O’Reilly Media，2007）[[20](#ch06fn20)]，或者浏览到WoT Publications页面[[21](#ch06fn21)]，在那里你可以找到许多关于使用REST为现实世界设备提供资源的方法。
- en: ^(20)
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([20](#ch06fn20))
- en: ''
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://shop.oreilly.com/product/9780596529260.do](http://shop.oreilly.com/product/9780596529260.do)'
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://shop.oreilly.com/product/9780596529260.do](http://shop.oreilly.com/product/9780596529260.do)'
- en: ^(21)
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([21](#ch06fn21))
- en: ''
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://webofthings.org/publications/](http://webofthings.org/publications/)'
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://webofthings.org/publications/](http://webofthings.org/publications/)'
- en: After being introduced to so much theory about REST, HTTP, and WebSockets, you
    might be wondering how to actually implement all of this on your Things. Get ready—this
    is what the next chapter will focus on. You’ll learn how to implement the patterns
    you’ve learned about in this chapter so that you can access any device, regardless
    of whether it’s internet-connected or not. Get your coding fingers ready; in the
    next chapter you’ll need them a lot more!
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了这么多关于REST、HTTP和WebSockets的理论之后，你可能想知道如何在你的物联设备上实际实现这些内容。准备好吧——这就是下一章将关注的内容。你将学习如何实现本章中你所学到的模式，以便你可以访问任何设备，无论它是否连接到互联网。准备好你的编码手指；在下一章中，你将需要它们更多！
- en: Chapter 7\. Implementing web Things
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章\. 实现Web物联
- en: '*This chapter covers*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Exploring the three possible patterns to implement web Things
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索实现Web物联的三个可能模式
- en: Giving access to sensors and actuators via web protocols
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Web协议提供传感器和执行器的访问
- en: Building REST and WebSockets APIs on your Pi with Node.js and Express
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的Pi上使用Node.js和Express构建REST和WebSockets API
- en: Building CoAP devices and connecting them to the web
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建CoAP设备并将它们连接到网络
- en: Using MQTT on your Pi to connect to the EVRYTHNG API
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的Pi上使用MQTT连接到EVRYTHNG API
- en: In the previous chapter, we focused on how to design a clean web API for physical
    Things. This chapter builds on the principles you learned and describes how to
    actually implement those APIs for real Things.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们关注了如何为物理物联设计一个干净的Web API。本章基于你所学到的原则，描述了如何实际实现这些API。
- en: The next sections detail the three different ways to implement a web Thing API
    so it deals with the implementation strategy. Here, we focus on the integration
    patterns of Things to the web, answering the question, “Where do we actually implement
    the API of the Thing to integrate it to the web?” This question is important because
    not all Things are equal! As you saw in [chapter 5](kindle_split_012.html#ch05),
    some Things can have internet access and implement web protocols natively. But
    for other Things that are more computationally or power-constrained, web protocols
    might be challenging.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 下文详细介绍了实现Web Thing API的三个不同方法，以处理实现策略。在这里，我们关注将事物集成到网络中的集成模式，回答问题：“我们实际上在哪里实现事物的API以将其集成到网络中？”这个问题很重要，因为并非所有事物都是平等的！正如你在[第5章](kindle_split_012.html#ch05)中看到的，一些事物可以访问互联网并原生实现Web协议。但对于计算能力或功耗受限的其他事物，Web协议可能具有挑战性。
- en: 7.1\. Connecting devices to the web
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. 将设备连接到网络
- en: The most straightforward integration pattern is the *direct integration pattern*.
    It can be used for devices that support HTTP and TCP/IP and can therefore expose
    a web API directly. This pattern is particularly useful when a device can directly
    connect to the internet; for example, it uses Wi-Fi or Ethernet. Second, we explore
    the *gateway integration pattern*, where resource-constrained devices can use
    non-web protocols to talk to a more powerful device (the gateway), which then
    exposes a REST API for those non-web devices. This pattern is particularly useful
    for devices that can’t connect directly to the internet; for example, they support
    only Bluetooth or ZigBee or they have limited resources and can’t serve HTTP requests
    directly. Third, the *cloud integration pattern* allows a powerful and scalable
    web platform to act as a gateway. This is useful for any device that can connect
    to a cloud server over the internet, regardless of whether it uses HTTP or not,
    and that needs more capability than it would be able to offer alone.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的集成模式是*直接集成模式*。它可以用于支持HTTP和TCP/IP的设备，因此可以直接暴露Web API。当设备可以直接连接到互联网时，这种模式特别有用；例如，它使用Wi-Fi或以太网。其次，我们探讨*网关集成模式*，资源受限的设备可以使用非Web协议与更强大的设备（网关）通信，然后该网关为这些非Web设备暴露REST
    API。这种模式对于无法直接连接到互联网的设备特别有用；例如，它们只支持蓝牙或ZigBee，或者它们资源有限，无法直接处理HTTP请求。第三，*云集成模式*允许强大的可扩展Web平台充当网关。这对于任何可以通过互联网连接到云服务器的设备都很有用，无论它是否使用HTTP，并且需要比它单独提供更多的功能。
- en: 'Choosing one of these patterns is the first step in the web Things design process
    presented in [chapter 6](kindle_split_014.html#ch06). After that, we can apply
    steps 2–4 of the design process. Step 5 will be covered in greater detail in [chapter
    8](kindle_split_016.html#ch08):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](kindle_split_014.html#ch06)中介绍的Web Things设计流程的第一步是选择这些模式之一。之后，我们可以应用设计流程的步骤2-4。第5步将在[第8章](kindle_split_016.html#ch08)中更详细地介绍：
- en: '**1**.  *Integration strategy*—Choose a pattern to integrate Things to the
    internet and the web. The patterns are presented in this chapter.'
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  *集成策略*—选择将事物集成到互联网和Web的模式。这些模式在本章中介绍。'
- en: '**2**.  *Resource design*—Identify the functionality or services of a Thing,
    and organize the hierarchy of these services.'
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  *资源设计*—识别事物的功能或服务，并组织这些服务的层次结构。'
- en: '**3**.  *Representation design*—Decide which representations will be served
    for each resource.'
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  *表示设计*—决定为每个资源提供哪些表示。'
- en: '**4**.  *Interface design*—Decide which commands are possible for each service,
    along with which error codes.'
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  *接口设计*—决定每个服务可能的命令，以及相应的错误代码。'
- en: '**5**.  *Resource linking design*—Decide how the different resources are linked
    to each other.'
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**.  *资源链接设计*—决定不同的资源如何相互链接。'
- en: '|  |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The reference WoT server—webofthings.js**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考WoT服务器—webofthings.js**'
- en: Over the next few chapters, you’ll learn how to implement a full-featured Web
    of Things server that allows connecting any device to the web based on the WoT
    architecture and concepts presented throughout this book. Each chapter will extend
    the code written in the previous one, so you’ll get the most out of this book
    by reading the next chapters in order. By doing so, at the end of the book you
    will have built from scratch a complete, extensible, and secure framework to implement
    web Things.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，您将学习如何实现一个功能齐全的物联网服务器，该服务器允许根据本书中介绍的WoT架构和概念将任何设备连接到网络。每一章都将扩展前一章中编写的代码，因此您可以通过按顺序阅读下一章来从本书中获得最大收益。通过这样做，到本书结束时，您将从头开始构建一个完整、可扩展和安全的框架来实现网络事物。
- en: 'If you can’t wait, you could also download the latest version of the reference
    implementation of the Web of Things: webofthings.js. You can find it on our GitHub^([[a](#ch07fn1a)])
    or directly on npm^([[b](#ch07fn2a)]) and use it in your own projects, applications,
    or devices. And please, do send us your feedback and pull requests—we’d love for
    this framework to evolve way beyond this book.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您迫不及待，也可以下载物联网参考实现的最新版本：webofthings.js。您可以在我们的GitHub^([[a](#ch07fn1a)])或直接在npm^([[b](#ch07fn2a)])上找到它，并在您自己的项目、应用程序或设备中使用它。并且，请向我们发送您的反馈和拉取请求——我们希望这个框架能够超越本书的内容。
- en: ^a
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/webofthings/webofthings.js](https://github.com/webofthings/webofthings.js)'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://github.com/webofthings/webofthings.js](https://github.com/webofthings/webofthings.js)'
- en: ^b
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^b
- en: ''
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.npmjs.com/package/webofthings](https://www.npmjs.com/package/webofthings)'
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://www.npmjs.com/package/webofthings](https://www.npmjs.com/package/webofthings)'
- en: '|  |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.2\. Direct integration pattern—REST on devices
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 直接集成模式——设备上的REST
- en: The first and easiest way to implement a web Thing API is directly on a Thing,
    as shown in [figure 7.1](#ch07fig01). This requires the Thing to be accessible
    via internet protocols (TCP/IP) and be able to host an HTTP server directly. Crazy
    idea, we hear you say? Well, web servers aren’t that big and can easily fit on
    the smallest devices out there. Some of the smallest HTTP servers can work with
    less than 50 bytes of RAM,^([[1](#ch07fn01)]) TCP/IP stack included, which makes
    it possible for even tiny and cheap 8-bit devices to speak HTTP. This also means
    that your Pi—or any other Linux device you use—can definitely implement a web
    server to provide access to its resources through a REST API.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 实现网络事物API的第一种也是最简单的方法是在事物上直接实现，如图7.1所示。这要求事物可以通过互联网协议（TCP/IP）访问，并且能够直接托管HTTP服务器。疯狂的想法，我们听到您这么说？好吧，Web服务器并不大，可以轻松地安装在最小的设备上。一些最小的HTTP服务器可以在少于50字节的RAM上运行，包括TCP/IP堆栈，这使得即使是微型且廉价的8位设备也能使用HTTP。这也意味着您的Pi——或您使用的任何其他Linux设备——肯定可以实现Web服务器，通过REST
    API提供对资源的访问。
- en: ¹
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: MiniWeb is an example of an extremely small web server; see [http://miniweb.sourceforge.net/](http://miniweb.sourceforge.net/).
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MiniWeb是一个极小的Web服务器的例子；请参阅[http://miniweb.sourceforge.net/](http://miniweb.sourceforge.net/)。
- en: Figure 7.1\. Direct integration pattern. In this pattern the web Things are
    Wi-Fi–connected lamps that run an embedded HTTP server and therefore offer a Web
    of Things API directly. This allows web Thing clients, such as mobile applications
    or other web Things, to communicate with the lamps directly over HTTP. Image used
    with permission from [http://model.webofthings.io](http://model.webofthings.io).
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1\. 直接集成模式。在这个模式中，网络事物是Wi-Fi连接的灯具，运行嵌入式HTTP服务器，因此可以直接提供物联网API。这允许网络事物客户端，如移动应用程序或其他网络事物，直接通过HTTP与灯具通信。图片经[http://model.webofthings.io](http://model.webofthings.io)许可使用。
- en: '![](07fig01_alt.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig01_alt.jpg)'
- en: Although it’s possible to implement web protocols on the vast majority of embedded
    devices, the direct integration pattern is the perfect choice when the device
    isn’t battery powered and when direct access from clients such as mobile web apps
    is required. A good example is home automation, where power is usually available
    and low-latency local interactions are important—for instance, turning lights
    on/off. In the rest of this section, we’ll show how to implement a WoT server
    directly on your Pi so that it can directly speak web protocols and join the Web
    of Things club.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在大多数嵌入式设备上都可以实现网络协议，但当设备不是由电池供电且需要客户端如移动网页应用直接访问时，直接集成模式是最佳选择。一个很好的例子是家庭自动化，通常电力供应充足，低延迟的本地交互很重要——例如，开关灯。在本节的其余部分，我们将展示如何在您的Pi上直接实现WoT服务器，以便它可以直接使用网络协议并加入物联网俱乐部。
- en: 7.2.1\. Creating a WoT server
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. 创建WoT服务器
- en: 'Let’s begin by setting up a web server on your Pi. Node.js is primarily meant
    for building web applications, so you could easily build one from scratch just
    as you did in [chapter 3](kindle_split_010.html#ch03). But because we’re switching
    gears and want to implement a full-blown REST API, a large number of Node.js frameworks
    can help us.^([[2](#ch07fn02)]) For simplicity’s sake, we’ll use the most popular:
    Express.^([[3](#ch07fn03)])'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 Pi 上设置一个 Web 服务器开始。Node.js 主要用于构建 Web 应用程序，所以你可以像在第 3 章中做的那样从头开始构建一个。但因为我们正在转换方向，并希望实现一个完整的
    REST API，大量的 Node.js 框架可以帮助我们。[^([2](#ch07fn02))] 为了简化起见，我们将使用最受欢迎的：Express。[^([3](#ch07fn03))]
- en: ²
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A number of the most popular web/REST frameworks for Node.js are listed here:
    [http://nodeframework.com/](http://nodeframework.com/).'
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里列出了 Node.js 最受欢迎的 Web/REST 框架：[http://nodeframework.com/](http://nodeframework.com/)。
- en: ³
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://expressjs.com/](http://expressjs.com/)'
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://expressjs.com/](http://expressjs.com/)'
- en: The architecture of the server you’ll build is shown in [figure 7.2](#ch07fig02).
    It revolves around a central model that plugins can update and observe. Furthermore,
    all the sensors and actuators are available as web resources thanks to the use
    of the Express framework.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 你将构建的服务器架构在 [图 7.2](#ch07fig02) 中显示。它围绕一个中央模型构建，插件可以更新和观察。此外，所有传感器和执行器都作为 Web
    资源可用，这得益于 Express 框架的使用。
- en: 'Figure 7.2\. The components architecture of our WoT server: The servers use
    the Express framework. The rest of the system is built around a model that plugins
    can observe and change. The plugins are built on other Node libraries, providing
    access to physical resources via GPIOs.'
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.2\. 我们 WoT 服务器的组件架构：服务器使用 Express 框架。系统的其余部分围绕一个插件可以观察和更改的模型构建。插件建立在其他 Node
    库之上，通过 GPIO 提供对物理资源的访问。
- en: '![](07fig02_alt.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig02_alt.jpg)'
- en: We’ll deploy this code on the Pi, but if you don’t yet own a Pi, don’t worry;
    with a few exceptions, you’ll be able to run all the examples in this chapter
    on your computer. But it’ll be more fun on a Pi. Just saying!^([[4](#ch07fn04)])
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Pi 上部署此代码，但如果你还没有 Pi，不要担心；除了少数例外，你将能够在你的计算机上运行本章中的所有示例。但用 Pi 来做会更有趣！[^([4](#ch07fn04))]
- en: ⁴
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Check out the special deals offered by our partners: [http://book.webofthings.io](http://book.webofthings.io).'
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看我们合作伙伴提供的特别优惠：[http://book.webofthings.io](http://book.webofthings.io)。
- en: 'Express: a Node.js web framework'
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Express：Node.js Web 框架
- en: '*Express* is much more than a web server; it’s a complete framework that handles
    pretty much everything modern web applications need, from RESTful APIs to HTML
    and CSS templating engines, database connectors, cookie management, and even social
    network integration. Express also has a large developer community and a variety
    of plugins.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '*Express* 不仅仅是一个 Web 服务器；它是一个完整的框架，几乎可以处理现代 Web 应用程序需要的所有功能，从 RESTful API 到
    HTML 和 CSS 模板引擎、数据库连接器、cookie 管理，甚至社交网络集成。Express 还拥有庞大的开发者社区和多种插件。'
- en: Although Express will run smoothly on the Pi and most other Linux devices, it’s
    worth pointing out that Express isn’t the lightest way to implement web APIs for
    IoT devices. But as you’ll see on numerous occasions, such a flexible framework
    allows us to quickly extend our web Thing APIs and implement the various patterns
    we’ll encounter.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Express 在 Pi 和大多数其他 Linux 设备上运行顺畅，但值得注意的是，Express 并不是为物联网设备实现 Web API 的最轻量级方式。但正如你将在许多场合看到的那样，这种灵活的框架使我们能够快速扩展我们的
    Web Thing API 并实现我们将遇到的多种模式。
- en: We’ll now show how to create a WoT server based on Express.^([[5](#ch07fn05)])
    The project’s structure is shown in the following listing. You could reproduce
    this structure and install Express via NPM. Alternatively, you could clone the
    project from the book’s GitHub repository,^([[6](#ch07fn06)]) which is available
    in the folder chapter7-implementation/part1-2-direct-gateway/.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将展示如何基于 Express 创建一个 WoT 服务器。[^([5](#ch07fn05))] 项目的结构如下所示。你可以复制这个结构并通过
    NPM 安装 Express。或者，你可以从书籍的 GitHub 仓库克隆项目，[http://book.webofthings.io](http://book.webofthings.io)，它位于文件夹
    chapter7-implementation/part1-2-direct-gateway/ 中。[^([6](#ch07fn06))]
- en: ⁵
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although you can certainly run these commands directly on the Pi, it’s easier
    and more practical to develop applications on your laptop or desktop computer
    and then pull the code via Git on the Pi, as explained in [chapter 4](kindle_split_011.html#ch04).
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然你当然可以直接在 Pi 上运行这些命令，但更方便、更实际的做法是在你的笔记本电脑或台式计算机上开发应用程序，然后通过 Git 在 Pi 上拉取代码，正如第
    4 章所述。[http://book.webofthings.io](http://book.webofthings.io)。
- en: ⁶
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See [http://book.webofthings.io](http://book.webofthings.io).
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看 [http://book.webofthings.io](http://book.webofthings.io)。
- en: Listing 7.1\. WoT server for Pi project directory structure
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.1\. Pi项目WoT服务器目录结构
- en: '[PRE12]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 7.2.2\. Resource design
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2\. 资源设计
- en: 'You now have all the elements in place to implement your API, so let’s start
    with the first step of our process: the *resource design*. You first need to consider
    the physical resources on your device and map them into REST resources. Starting
    from the Pi you configured in [chapter 4](kindle_split_011.html#ch04), your device
    should have at least an LED, a passive infrared (PIR) sensor and possibly a temperature
    sensor, and a humidity sensor. If you don’t have all these sensors, don’t worry.
    We’ll show you how to simulate them as well! These sensors and actuators can be
    mapped into the resource tree shown in [figure 7.3](#ch07fig03).'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经拥有了实现API所需的所有元素，让我们从我们流程的第一步开始：*资源设计*。首先，您需要考虑设备上的物理资源，并将它们映射到REST资源中。从您在[第4章](kindle_split_011.html#ch04)中配置的Pi开始，您的设备至少应该有一个LED、一个被动红外（PIR）传感器，可能还有一个温度传感器和一个湿度传感器。如果您没有所有这些传感器，不要担心。我们将向您展示如何模拟它们！这些传感器和执行器可以映射到[图7.3](#ch07fig03)中显示的资源树中。
- en: Figure 7.3\. The resource tree of your Pi with a number of sensors and actuators
    and their hierarchy. Each resource gets a URL formed by following the path to
    this resource. As an example, the URL of the passive infrared sensor would be
    http://localhost:8484/pi/sensors/pir.
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.3\. 您的Pi资源树，包含多个传感器和执行器及其层次结构。每个资源都通过遵循到该资源的路径获得一个URL。例如，被动红外传感器的URL将是http://localhost:8484/pi/sensors/pir。
- en: '![](07fig03_alt.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![07fig03_alt.jpg](07fig03_alt.jpg)'
- en: 'Step 1: Create the resource model'
  id: totrans-394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第1步：创建资源模型
- en: You can now map this tree into a JSON file that your application will use to
    expose your desired URL structure. Create or open the resources/resources.json
    file that contains the object shown in the next listing.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以将此树映射到您的应用程序将使用的JSON文件中，以公开您希望的结构化的URL。创建或打开包含下一列表中对象的resources/resources.json文件。
- en: 'Listing 7.2\. /resources/resources.json: JSON model of the Pi resources'
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表7.2\. /resources/resources.json: Pi资源的JSON模型'
- en: '[PRE13]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, you create the resources/model.js file, which imports our JSON model
    as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您创建resources/model.js文件，如下所示导入我们的JSON模型：
- en: '[PRE14]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This file loads the JSON model of our Pi from the resources.json file, and `exports`
    will make this object available as a node module that you can use in your application.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件从resources.json文件加载我们的Pi的JSON模型，`exports`将此对象作为您可以在应用程序中使用的node模块提供。
- en: 'Step 2: Create the Express routes'
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第2步：创建Express路由
- en: You can now bind these resources to URLs that your web server will reply to.
    In Express and many other web frameworks, the URL of a resource is defined by
    a *route*. You define those routes in two files available in the routes/ folder
    (actuators.js and sensors.js), which are shown in the next two listings.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以将这些资源绑定到您的Web服务器将响应的URL上。在Express和许多其他Web框架中，资源的URL由一个*路由*定义。您在routes/文件夹中的两个文件（actuators.js和sensors.js）中定义这些路由，如下一两个列表所示。
- en: 'Listing 7.3\. /routes/sensors.js: routes for sensors'
  id: totrans-403
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表7.3\. /routes/sensors.js: 传感器路由'
- en: '![](181fig01_alt.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![181fig01_alt.jpg](181fig01_alt.jpg)'
- en: 'Step 3: Create an Express application'
  id: totrans-405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第3步：创建Express应用程序
- en: Now that the routes are ready, you need to load them inside an HTTP server,
    which is done in the servers/http.js file. The content of this file is shown in
    the following listing and is in essence an HTTP server wrapped inside the Express
    framework.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在路由已经准备好了，您需要在HTTP服务器中加载它们，这通过servers/http.js文件完成。该文件的内容如下所示，本质上是一个包裹在Express框架中的HTTP服务器。
- en: 'Listing 7.4\. /servers/http.js: Express application'
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表7.4\. /servers/http.js: Express应用程序'
- en: '![](182fig01_alt.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![182fig01_alt.jpg](182fig01_alt.jpg)'
- en: 'You need one more file before you can test your implementation: wot-server.js,
    shown in the next listing. This is the entry point of your WoT Pi server and is
    in charge of starting the servers with the right configuration.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在您测试实现之前，需要再添加一个文件：wot-server.js，如下一列表所示。这是您的WoT Pi服务器的入口点，负责以正确的配置启动服务器。
- en: 'Listing 7.5\. /wot-server.js: application entry point'
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表7.5\. /wot-server.js: 应用程序入口点'
- en: '![](182fig02_alt.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![182fig02_alt.jpg](182fig02_alt.jpg)'
- en: You can now test your server from your PC by starting the app via your terminal
    as usual.^([[7](#ch07fn07)]) Once it’s started, you’ll be able to access the resources
    with your browser—for example, the temperature sensor at http://localhost:8484/pi/sensors/temperature
    or the list of actuators at http://localhost:8484/pi/actuators. In both cases,
    you’ll get the JSON payload corresponding to your request. Obviously, if you run
    the code on your Pi, replace localhost with the IP address or name (raspberrypi.local)
    of your Pi.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过在终端中启动应用程序来测试您的服务器，就像通常一样.^([[7](#ch07fn07)]) 一旦启动，您将能够使用浏览器访问资源——例如，温度传感器在
    http://localhost:8484/pi/sensors/temperature 或执行器列表在 http://localhost:8484/pi/actuators。在这两种情况下，您将获得与您的请求相对应的
    JSON 有效负载。显然，如果您在 Pi 上运行代码，请将 localhost 替换为 Pi 的 IP 地址或名称（raspberrypi.local）。
- en: ⁷
  id: totrans-413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After you run an `npm install` in the `wot-pi/` folder, run `node wot-server.js`
    or `nodemon wot-server.js`, as shown in [chapter 3](kindle_split_010.html#ch03).
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 `wot-pi/` 文件夹中运行 `npm install` 后，运行 `node wot-server.js` 或 `nodemon wot-server.js`，如
    [第 3 章](kindle_split_010.html#ch03) 中所示。
- en: 'Step 4: Bind the sensors to the server'
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 4 步：将传感器绑定到服务器
- en: This is all nice, but currently all we return are bits of the JSON model in
    [listing 7.2](#ch07ex02), and the real-world data—the actual temperature—is missing!
    You need to put some sensor data from your Pi into the server. You’ll do this
    by creating a number of plugins*,* one per sensor or actuator*.* Each sensor plugin
    should update the model each time new data is read from the sensor. A sensor plugin
    should at least have the functions shown in the following listing. All plugins
    are inside the plugins/ directory. The implementation of the PIR sensor plugin
    is shown in the next listing and is essentially an extension of the pir.js code
    you wrote in [chapter 4](kindle_split_011.html#ch04).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来不错，但目前我们返回的只是 [列表 7.2](#ch07ex02) 中的 JSON 模型的一部分，以及缺失的实际世界数据——实际的温度！您需要将
    Pi 上的某些传感器数据放入服务器中。您将通过创建多个插件*，*每个传感器或执行器一个插件*，*来完成此操作。每个传感器插件应在从传感器读取新数据时更新模型。传感器插件至少应具有以下列表中显示的函数。所有插件都在
    plugins/ 目录中。PIR 传感器插件的实现如下一列表所示，它本质上是对 [第 4 章](kindle_split_011.html#ch04) 中编写的
    pir.js 代码的扩展。
- en: 'Listing 7.6\. /plugins/internal/pirPlugin.js: PIR sensor plugin'
  id: totrans-418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.6\. /plugins/internal/pirPlugin.js: PIR 传感器插件'
- en: '![](ch07ex06-0.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex06-0.jpg)'
- en: '![](ch07ex06-1.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex06-1.jpg)'
- en: 'The code for the temperature and humidity sensor is shown in the next listing,
    except for one new function: `connectHardware()`, which uses the `node-dht-sensor`
    library introduced in [chapter 4](kindle_split_011.html#ch04).'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 温湿度和传感器代码如下一列表所示，除了一个新函数：`connectHardware()`，它使用在 [第 4 章](kindle_split_011.html#ch04)
    中介绍的 `node-dht-sensor` 库。
- en: 'Listing 7.7\. /plugins/internal/DHT22SensorPlugin.js: temperature and humidity
    sensor plugin'
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.7\. /plugins/internal/DHT22SensorPlugin.js: 温湿度传感器插件'
- en: '![](184fig01_alt.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![](184fig01_alt.jpg)'
- en: The code for the two plugins clearly shares a number of common functions, so
    as an exercise you might want to extract the common features into a JavaScript
    prototype. If you don’t know how to do that, don’t worry; we’ll illustrate this
    when we improve the code in [chapter 8](kindle_split_016.html#ch08).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 两个插件的代码明显共享了许多公共函数，因此作为练习，您可能希望将公共功能提取到一个 JavaScript 原型中。如果您不知道如何做，不要担心；我们将在
    [第 8 章](kindle_split_016.html#ch08) 改进代码时说明这一点。
- en: You can now install your plugins on your server by requiring them from the wot-server.js
    file and starting each plugin with the right parameters, as shown in the following
    listing.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过从 wot-server.js 文件中引入它们并使用正确的参数启动每个插件来在您的服务器上安装您的插件，如下所示。
- en: Listing 7.8\. Integrating the plugins to wot-server.js
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.8\. 将插件集成到 wot-server.js 中
- en: '![](185fig01_alt.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](185fig01_alt.jpg)'
- en: Run your server again and open the humidity sensor page at http://localhost:8484/pi/sensors/humidity.
    Refresh the page several times; this should give you different values each time.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行您的服务器并打开湿度传感器页面，网址为 http://localhost:8484/pi/sensors/humidity。刷新页面几次；每次应该得到不同的值。
- en: Test it with real hardware on your Pi
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在您的 Pi 上使用真实硬件进行测试
- en: 'Simulating sensors is nice, but using real ones is way nicer! To use real sensors
    on your Pi, you first need to install the libraries that connect the sensors.
    The problem is that these libraries aren’t supported on non-IoT platforms like
    your laptop, so if you add the dependencies via `npm install --save`, you won’t
    be able to install your code on your PC anymore. Don’t worry: there’s a way out!
    NPM allows you to set an `optionalDependencies` object for the package.json file.
    The idea is that `npm install` won’t fail if a dependency in `optionalDependencies`
    can’t be installed. Go ahead and add the following code in your package.json file;
    the first dependency supports the PIR sensor and LEDs, and the second one supports
    the temperature and humidity sensor (if you have one):'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟传感器是不错的，但使用真实的传感器则更好！要在你的Pi上使用真实传感器，你首先需要安装连接传感器的库。问题是这些库不支持像你的笔记本电脑这样的非IoT平台，所以如果你通过`npm
    install --save`添加依赖项，你将无法再在PC上安装你的代码。别担心：有解决办法！NPM允许你为package.json文件设置一个`optionalDependencies`对象。想法是，如果`optionalDependencies`中的依赖项无法安装，`npm
    install`不会失败。继续在你的package.json文件中添加以下代码；第一个依赖项支持PIR传感器和LED，第二个依赖项支持温度和湿度传感器（如果你有）：
- en: '[PRE15]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, run `npm install` on your Pi to install these dependencies. Now modify
    the parameters of the plugins you want to enable with `{''simulate'': false}`
    and run your application on the Pi;^([[8](#ch07fn08)]) this will connect to physical
    drivers. Your Pi is now exposing its real sensor data and actuators to the world
    via a web API. You can access them via REST using the address of your Pi, for
    example, [http://raspberrypi.local:8484/pi/sensors/pir](http://raspberrypi.local:8484/pi/sensors/pir).'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，在你的Pi上运行`npm install`来安装这些依赖项。现在，使用`{''simulate'': false}`修改你想要启用的插件的参数，并在Pi上运行你的应用程序；^([[8](#ch07fn08)])
    这将连接到物理驱动器。现在，你的Pi正通过Web API向世界公开其实际传感器数据和执行器。你可以通过REST使用你的Pi地址访问它们，例如，[http://raspberrypi.local:8484/pi/sensors/pir](http://raspberrypi.local:8484/pi/sensors/pir)。'
- en: ⁸
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you did set up the temperature and humidity sensor, you’ll need to run the
    code with sudo: `sudo node wot-server.js`.'
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你已经设置了温度和湿度传感器，你需要使用sudo运行代码：`sudo node wot-server.js`。
- en: 7.2.3\. Representation design
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3\. 表示设计
- en: The next step of the design process is the *representation design*. REST is
    agnostic of a particular format or representation of the data. We mentioned that
    JSON is a must to guarantee interoperability, but it isn’t the only interesting
    data representation available. In this section you’ll add support for two more.
    You’ll add HTML support because this allows you to browse your Pi and discover
    its resources in a human-friendly way. For this first step, you’ll use a simple
    JSON-to-HTML library called `json2html`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 设计过程的下一步是*表示设计*。REST对特定的数据格式或表示是中立的。我们提到JSON是保证互操作性的必需品，但它并不是唯一有趣的数据表示。在本节中，你将添加对两种更多表示的支持。你将添加HTML支持，因为这允许你以人性化的方式浏览你的Pi并发现其资源。为此第一步，你将使用一个简单的JSON到HTML库，称为`json2html`。
- en: While you’re at it, let’s also add support for MessagePack, a more compressed
    and binary alternative to JSON that was briefly introduced in [chapter 6](kindle_split_014.html#ch06).
    MessagePack can easily be mapped to JSON but is more compact than JSON, which
    makes it interesting for resource-constrained Things that communicate over low-bandwidth
    networks. There are libraries for encoding and decoding MessagePack in most popular
    programming languages, so adding support for it in your server is merely a matter
    of installing the `msgpack5` module for Node.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 当你忙于这些时，让我们也添加对MessagePack的支持，这是一种比JSON更紧凑的二进制替代品，在[第6章](kindle_split_014.html#ch06)中简要介绍过。MessagePack可以轻松映射到JSON，但比JSON更紧凑，这使得它在通过低带宽网络通信的资源受限的设备中很有趣。大多数流行编程语言都有用于编码和解码MessagePack的库，因此在你的服务器中添加对它的支持只是安装Node的`msgpack5`模块的问题。
- en: Implementing a representation converter middleware
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现表示转换中间件
- en: There are several ways of supporting other representations in Express, but we
    propose a modular way based on the middleware pattern. Many Node libraries, including
    Express, support the idea of chaining functions that have access to the request
    (`req`) response (`res`) objects in a request-response cycle. This pattern allows
    for extensibility while keeping the code clean and modular. In essence, a middleware
    can execute code that changes the request or response objects and can then decide
    to respond to the client or call the next middleware in the stack using the `next()`
    function. The chain of middleware we’ll implement here is shown in [figure 7.4](#ch07fig04).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Express 中支持其他表示的方法有很多，但我们提出了一种基于中间件模式的模块化方法。许多 Node 库，包括 Express，都支持在请求-响应周期中访问请求（`req`）和响应（`res`）对象的函数链式调用。这种模式允许扩展性，同时保持代码干净和模块化。本质上，一个中间件可以执行更改请求或响应对象的代码，然后可以使用
    `next()` 函数决定响应客户端或调用堆栈中的下一个中间件。我们将要实现的中间件链在[图 7.4](#ch07fig04)中显示。
- en: 'Figure 7.4\. The middleware chain implemented for the WoT server: each middleware
    is added to the Express application with the `app.use()` function. Then, each
    middleware gets a reference to the request object, the response object, and the
    next middleware in the chain.'
  id: totrans-441
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.4\. 为 WoT 服务器实现的中间件链：每个中间件都是通过 `app.use()` 函数添加到 Express 应用程序的。然后，每个中间件都会获得对请求对象、响应对象和链中下一个中间件的引用。
- en: '![](07fig04_alt.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig04_alt.jpg)'
- en: 'The stub of a typical middleware looks like this:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 典型中间件的存根看起来如下：
- en: '[PRE16]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We use this pattern to implement a representation converter supporting MessagePack
    and HTML representations. First, install the two libraries via NPM (`npm install
    node-json2html msgpack5`). The middleware code is located in middleware/converter.js,
    as shown in [listing 7.9](#ch07ex09). Essentially, our representation converter
    middleware will implement the content negotiation pattern described in [chapter
    6](kindle_split_014.html#ch06), where it looks for the `Accept` header in a request
    and tries to deliver a representation in the format the client asked for. If it
    doesn’t recognize the format, it will return JSON by default.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这种模式来实现一个支持 MessagePack 和 HTML 表示的表示转换器。首先，通过 NPM 安装这两个库（`npm install node-json2html
    msgpack5`）。中间件代码位于 middleware/converter.js 中，如[列表 7.9](#ch07ex09)所示。本质上，我们的表示转换器中间件将实现第[6章](kindle_split_014.html#ch06)中描述的内容协商模式，其中它会在请求中查找
    `Accept` 头，并尝试提供客户端请求的格式表示。如果它不识别该格式，则默认返回 JSON。
- en: 'Listing 7.9\. /middleware/converter.js: implementing representation middleware'
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.9\. /middleware/converter.js: 实现表示中间件'
- en: '![](ch07ex09-0.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch07ex09-0.jpg)'
- en: '![](ch07ex09-1.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch07ex09-1.jpg)'
- en: Now that the middleware is ready, you need to modify the routes of your server
    so they call the next middleware in the chain, the representation converter, rather
    than answering the request directly. You can easily implement this inside the
    two route files, sensors.js and actuators.js, by replacing every `res.send(resource)`
    with `req.result = resource` and `next()`. The following listing shows the changes
    for the sensor’s routes, so make sure you apply those changes to the actuator’s
    routes as well.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在中间件已经准备好了，你需要修改服务器的路由，使它们调用链中的下一个中间件，即表示转换器，而不是直接响应请求。你可以在两个路由文件 sensors.js
    和 actuators.js 中轻松实现这一点，通过将每个 `res.send(resource)` 替换为 `req.result = resource`
    和 `next()`。以下列表显示了传感器的路由更改，所以请确保也将这些更改应用到执行器的路由上。
- en: Listing 7.10\. Calling the next middleware in sensors.js
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.10\. 在 sensors.js 中调用下一个中间件
- en: '![](188fig01_alt.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![图片](188fig01_alt.jpg)'
- en: 'Finally, you need to add the middleware to the Express application so that
    it gets called in the middleware chain. In http.js, first require the middleware
    with `converter = require(''./../middleware/converter'')` and add it to the chain
    by calling `app.use(converter())`. Because your converter middleware responds
    to the client, make sure you add it last, after `app.get(''pi'')`, or it will
    bypass any other middleware. Test your new server on your Pi (or PC) from your
    browser: [http://raspberrypi.local:8484/pi/sensors/pir](http://raspberrypi.local:8484/pi/sensors/pir).
    You should now see a minimalist HTML representation of the PIR sensor. Now use
    cURL to request other types of representations by setting the `Accept` header
    to the desired MIME type (`application/json` for JSON and `application/x-msgpack`
    for MessagePack) as shown here:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要将中间件添加到 Express 应用程序中，以便它在中间件链中被调用。在 http.js 中，首先使用 `converter = require('./../middleware/converter')`
    引入中间件，并通过调用 `app.use(converter())` 将其添加到链中。因为你的转换中间件响应客户端，确保你在 `app.get('pi')`
    之后添加它，否则它将绕过任何其他中间件。从你的浏览器中测试你的新服务器（或 PC）：[http://raspberrypi.local:8484/pi/sensors/pir](http://raspberrypi.local:8484/pi/sensors/pir)。你现在应该看到一个
    PIR 传感器的简约 HTML 表示。现在使用 cURL 通过设置 `Accept` 头到所需的 MIME 类型（JSON 为 `application/json`，MessagePack
    为 `application/x-msgpack`）来请求其他类型的表示，如下所示：
- en: '[PRE17]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Your server is now capable of serving three different representations—JSON,
    HTML, and MessagePack—for all the resources it offers. All this thanks to a middleware
    that’s 20 lines long! How’s that for an illustration of the power of open web
    standards and Node.js?
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 你的服务器现在可以为它提供的所有资源提供三种不同的表示——JSON、HTML 和 MessagePack。所有这些都要归功于一个 20 行长的中间件！这是对开放网络标准和
    Node.js 力量的一个很好的说明吗？
- en: 7.2.4\. Interface design
  id: totrans-455
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.4\. 接口设计
- en: So far so good, but you’re only able to `GET` resources from your Pi over HTTP.
    What about the other verbs like `PUT` and `POST`? What about HTTP status codes?
    What about using WebSockets to subscribe to sensor data? This is the goal of the
    *interface design* step.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，但你只能通过 HTTP 从你的 Pi 上获取资源。其他动词如 `PUT` 和 `POST` 呢？HTTP 状态码呢？使用 WebSockets
    订阅传感器数据呢？这是接口设计步骤的目标。
- en: Adding a body parser
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加一个主体解析器
- en: 'The `GET` verb is enough for sensors because you only read them, but what if
    you want to change the actuators—for example, turning on/off an LED or changing
    its color? The first step is to inform Express that you’re happy to receive JSON
    payloads from clients. Adding an HTTP body parser to the middleware chain does
    just this. In http.js require the body-parser module: `bodyParser = require(''body-parser'')`.
    Also add the middleware at the beginning of the chain. Why the beginning? You
    want to parse the body of the HTTP message first to make it available to all other
    middleware: `app.use(bodyParser.json())`.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传感器来说，`GET` 动词就足够了，因为你只需要读取它们，但如果你想要改变执行器——例如，打开/关闭一个 LED 或改变其颜色呢？第一步是通知 Express
    你愿意接收来自客户端的 JSON 负载。在中间件链中添加一个 HTTP 主体解析器就可以做到这一点。在 http.js 中，引入 body-parser 模块：`bodyParser
    = require('body-parser')`。同时，将中间件添加到链的起始位置。为什么是起始位置？你想要首先解析 HTTP 消息的主体，以便所有其他中间件都可以使用：`app.use(bodyParser.json())`。
- en: Supporting other HTTP verbs
  id: totrans-459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 支持其他 HTTP 动词
- en: Your server can now handle incoming JSON messages as well, so let’s add support
    to update the state of the Pi LED using a `PUT` request. To add support for `PUT`,
    you need to extend again the routes in actuators.js. Transform the route for `/leds/:id`
    as shown in the next listing.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 你的服务器现在也可以处理传入的 JSON 消息，所以让我们添加对使用 `PUT` 请求更新 Pi LED 状态的支持。要添加对 `PUT` 的支持，你需要再次扩展
    actuators.js 中的路由。将 `/leds/:id` 的路由转换为以下列表。
- en: Listing 7.11\. Adding `PUT` support for LEDs in /routes/actuators.js
  id: totrans-461
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.11\. 在 /routes/actuators.js 中为 LED 添加 `PUT` 支持
- en: '![](189fig01_alt.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![](189fig01_alt.jpg)'
- en: 'You can now update the state of the LED by running a `PUT` request on the LED
    resource with the appropriate JSON payload. In cURL this looks like the following:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过在 LED 资源上运行带有适当 JSON 负载的 `PUT` 请求来更新 LED 的状态。在 cURL 中，这看起来像以下内容：
- en: '[PRE18]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you’re successful, you’ll see the following in the Node console: `Changed
    LED 1 value to` `true`.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功了，你将在 Node 控制台中看到以下内容：`Changed LED 1 value to` `true`。
- en: Binding actuators to the server
  id: totrans-466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将执行器绑定到服务器
- en: 'This is all nice but it actually only updates your model; it doesn’t actuate
    the real world! To change this behavior you need to write an LED plugin that has
    a similar structure to the sensor plugins but with a notable exception: it has
    an `observe()` function. `observe()` is needed for actuator plugins, and its goal
    is to observe changes in the model and report them to the physical world.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来不错，但实际上它只更新了您的模型；它并没有激活现实世界！要改变这种行为，您需要编写一个具有类似结构但有一个显著区别的 LED 插件：它有一个 `observe()`
    函数。`observe()` 函数对于执行器插件是必需的，其目标是观察模型的变化并将它们报告给物理世界。
- en: 'The core of this implementation is using the `Object.observe()` function.^([[9](#ch07fn09)])
    This allows you to asynchronously observe the changes happening to an object by
    registering a callback to be invoked whenever a change in the observed object
    is detected:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的核心理念是使用 `Object.observe()` 函数.^([[9](#ch07fn09)]) 这允许您通过注册一个回调函数来异步观察对象的变化，每当检测到观察对象的变化时，该回调函数将被调用：
- en: ⁹
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that this function has been supported by Node since version 0.11.13 and
    is available in the current Node LTS v4.X we use for this book, but it could be
    removed in the future LTS, so make sure you use node 4.X LTS for this to work.
    See [http://www.infoq.com/news/2015/11/object-observe-withdrawn](http://www.infoq.com/news/2015/11/object-observe-withdrawn).
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，这个功能自 Node 0.11.13 版本以来就已经被支持，并且在我们这本书中使用的当前 Node LTS v4.X 中可用，但它在未来的 LTS
    版本中可能会被移除，所以请确保您使用 node 4.X LTS 来确保其正常工作。请参阅 [http://www.infoq.com/news/2015/11/object-observe-withdrawn](http://www.infoq.com/news/2015/11/object-observe-withdrawn)。
- en: '[PRE19]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s use this feature to implement your LED plugin. It uses the `on/off` library
    to change the state of the GPIO the LED is connected to. Note that to keep things
    simple, this code supports only one LED (LED #1), but feel free to extend it to
    support more as an exercise. Inside `observe` you register a callback to be triggered
    whenever the model of your LEDs changes. It is inside this callback that you actually
    change the state of the GPIO, as shown in the next listing.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们利用这个特性来实现您的 LED 插件。它使用 `on/off` 库来改变连接到 GPIO 的 LED 的状态。请注意，为了保持简单，此代码仅支持一个
    LED（LED #1），但请随意将其扩展以支持更多作为练习。在 `observe` 中，您注册一个回调函数，以便在您的 LED 模型发生变化时触发。实际上，您是在这个回调函数中改变
    GPIO 的状态，如下一列表所示。'
- en: 'Listing 7.12\. /plugins/internal/ledsPlugin.js: LED plugin'
  id: totrans-474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.12\. /plugins/internal/ledsPlugin.js: LED 插件'
- en: '![](ch07ex12-0.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex12-0.jpg)'
- en: '![](ch07ex12-1.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex12-1.jpg)'
- en: 'Add this plugin to the list of initialized plugins in wot-server.js and set
    the simulation to false: `ledsPlugin.start({''simulate'': false})`. Run it on
    your Pi and try the last cURL request again against the URL of your Pi; this time
    the LED should turn on! Yeah, we know. It’s *just* an LED, but, oh my, this feels
    so good. Welcome to the IoT!'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '将此插件添加到 wot-server.js 中初始化插件的列表中，并将模拟设置为 false：`ledsPlugin.start({''simulate'':
    false})`。在您的 Pi 上运行它，并再次尝试针对您的 Pi 的 URL 进行最后的 cURL 请求；这次 LED 应该会亮起！是的，我们知道。这只是个
    LED，但，哦，这感觉真好。欢迎来到物联网！'
- en: 7.2.5\. Pub/sub interface via WebSockets
  id: totrans-478
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.5\. 通过 WebSocket 的 Pub/sub 接口
- en: The last part in our interface design step is to support publish/subscribe via
    WebSockets. Our goal is to offer the ability to subscribe via WebSockets on all
    our resources by a simple protocol upgrade to WebSockets.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 我们界面设计步骤的最后一部分是支持通过 WebSocket 进行发布/订阅。我们的目标是提供一个简单的协议升级到 WebSocket 的能力，以便通过
    WebSocket 订阅我们所有的资源。
- en: There are several implementations of WebSockets for Node. The most complete
    and best-known one is probably Socket.io, which is more than a WebSocket server.
    It also supports fallbacks for clients that don’t support WebSockets; for example,
    long polling as shown in [chapter 6](kindle_split_014.html#ch06). We suggest you
    have a closer look at Socket.io, but for the server of our Pi we’ll choose a pure
    and high-performing WebSockets implementation called WS.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Node，有几种 WebSocket 的实现。最完整和最知名的一个可能是 Socket.io，它不仅仅是一个 WebSocket 服务器。它还支持不支持
    WebSocket 的客户端的回退；例如，如第 6 章中所示的长轮询。我们建议您更仔细地查看 Socket.io，但为了我们的 Pi 服务器，我们将选择一个纯且高性能的
    WebSocket 实现，称为 WS。
- en: The implementation of the WS integration is illustrated in [figure 7.5](#ch07fig05).
    You create a WebSocket server and attach a listener to the main HTTP server of
    Express to listen for protocol upgrade requests to WebSockets; see [chapter 5](kindle_split_012.html#ch05).
    You then take these upgrade requests and use the URL of the request to observe
    the corresponding resource in the model. Whenever a change is detected, you propagate
    the change to the client via the open WebSockets connection.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: WS 集成的实现如图 7.5 所示。你创建一个 WebSocket 服务器，并将其监听器附加到 Express 的主要 HTTP 服务器上，以监听 WebSocket
    协议升级请求；参见[第 5 章](kindle_split_012.html#ch05)。然后，你接收这些升级请求，并使用请求的 URL 来观察模型中的相应资源。每当检测到变化时，你通过开放的
    WebSocket 连接将变化传播给客户端。
- en: 'Figure 7.5\. Sequence diagram of the WebSockets implementation of the WoT server:
    the WebSocket server is reacting to clients opening a WebSocket connection via
    an HTTP upgrade request by observing the corresponding resource;, for example,
    `/temp`. Whenever a new value for the resource is available, the WebSocket server
    sends it over the TCP connection it maintains open with the client.'
  id: totrans-482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.5\. WoT 服务器 WebSocket 实现的序列图：WebSocket 服务器通过观察相应的资源（例如，`/temp`）来响应客户端通过
    HTTP 升级请求打开 WebSocket 连接；每当资源的可用新值出现时，WebSocket 服务器通过它与客户端保持的开放 TCP 连接发送它。
- en: '![](07fig05_alt.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![07fig05_alt.jpg](07fig05_alt.jpg)'
- en: To integrate this into your WoT server on the Pi, first install the WS module
    (`npm install --save ws`). Then implement the WebSocket server as shown in the
    next listing.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此集成到 Pi 上的 WoT 服务器中，首先安装 WS 模块（`npm install --save ws`）。然后按照以下列表实现 WebSocket
    服务器。
- en: 'Listing 7.13\. /server/websockets.js: WebSockets server'
  id: totrans-485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.13\. /server/websockets.js: WebSockets 服务器'
- en: '![](ch07ex13-0.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
  zh: '![ch07ex13-0.jpg](ch07ex13-0.jpg)'
- en: '![](ch07ex13-1.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![ch07ex13-1.jpg](ch07ex13-1.jpg)'
- en: The last step to enable the support for WebSockets is to initialize the WebSockets
    server after starting the HTTP server in wot-server.js. Modify the call to `listen()`
    to include a callback that starts the WebSockets server, as shown in the following
    listing.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 WebSocket 支持的最后一步是在 wot-server.js 中启动 HTTP 服务器后初始化 WebSocket 服务器。修改对 `listen()`
    的调用，包括一个回调，以启动 WebSocket 服务器，如下列所示。
- en: Listing 7.14\. Enabling the WebSockets server in wot-server.js
  id: totrans-489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.14\. 在 wot-server.js 中启用 WebSockets 服务器
- en: '[PRE20]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That’s it! You can now subscribe to all the resources on the web Thing with
    WebSockets and be informed whenever the state of a resource changes. You can use
    any WebSockets client—for example, a web page, such as the example you saw in
    [chapter 2](kindle_split_009.html#ch02). Try adapting it to subscribe to your
    WoT Pi, or you can use the /public/websocketsClient.html file in any recent browser.
    When you open this file in your browser, you’ll see the WebSockets messages in
    the JavaScript console of your developer tools, as shown in [figure 7.6](#ch07fig06).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你现在可以通过 WebSocket 订阅 Web 上的所有资源，并在资源状态发生变化时得到通知。你可以使用任何 WebSocket 客户端——例如，一个网页，如你在[第
    2 章](kindle_split_009.html#ch02)中看到的示例。尝试将其修改为订阅你的 WoT Pi，或者你可以在任何最近的浏览器中使用 /public/websocketsClient.html
    文件。当你在这个文件中打开浏览器时，你将在你的开发者工具的 JavaScript 控制台中看到 WebSocket 消息，如图 7.6 所示。
- en: Figure 7.6\. Subscribing to temperature updates via WebSockets using a simple
    WebSockets client in Firefox. The upper part shows the protocol upgrade process
    and the lower part the incoming messages pushed from the Thing (a Pi here) directly
    to the browser-based client.
  id: totrans-492
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.6\. 使用 Firefox 中的简单 WebSocket 客户端通过 WebSocket 订阅温度更新。上半部分显示协议升级过程，下半部分显示从设备（这里是一个
    Pi）直接推送到基于浏览器的客户端的消息。
- en: '![](07fig06_alt.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![07fig06_alt.jpg](07fig06_alt.jpg)'
- en: '|  |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The nerd corner—I want better JavaScript!**'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术角落——我想更好的 JavaScript！**'
- en: The WoT server we built in this section was kept extremely simple in terms of
    the code to ensure everyone could follow along. The code could be made a lot cleaner
    and more reusable by applying a number of JavaScript good practices and patterns.
    If you know JavaScript, a good exercise is to modularize the code; for instance,
    by starting with prototypes to factorize a large chunk of plugin code. In [chapter
    8](kindle_split_016.html#ch08) you’ll see an improved version of the framework
    we presented here, but don’t hesitate to build your own right now!
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中构建的 WoT 服务器在代码方面保持极其简单，以确保每个人都能跟上。通过应用一些 JavaScript 良好实践和模式，代码可以变得更加简洁和可重用。如果你了解
    JavaScript，一个很好的练习是将代码模块化；例如，从原型开始，以分解大量插件代码。在[第 8 章](kindle_split_016.html#ch08)中，你将看到我们在这里展示的框架的改进版本，但你现在就可以不犹豫地构建自己的版本！
- en: '|  |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.2.6\. Summary—direct integration pattern
  id: totrans-498
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.6\. 摘要——直接集成模式
- en: 'In this section, we showed how to rapidly build a complete Web of Things API
    that not only can run on actual devices and talk to actual sensors and actuators,
    but also can support many advanced capabilities, such as content negotiation and
    push support via WebSockets. But there’s a whole range of devices where you won’t
    have the luxury of running Node natively. A solution for these cases is described
    in the next section, where we provide another pattern for non-HTTP/WebSockets
    devices: the gateway integration pattern.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了如何快速构建一个完整的物联网API，它不仅可以在实际设备上运行并与实际传感器和执行器通信，而且还支持许多高级功能，如内容协商和通过WebSockets的推送支持。但是，有一系列设备，你无法享受在本地运行Node的奢侈。下一节将描述这些情况下的解决方案，我们将提供另一种非HTTP/WebSockets设备的模式：网关集成模式。
- en: 7.3\. Gateway integration pattern—CoAP example
  id: totrans-500
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 网关集成模式——CoAP示例
- en: In the previous section, you transformed your Pi into a web Thing by creating
    an HTTP and WebSockets API for its sensors. This worked well because your Pi was
    not battery powered, had access to a decent bandwidth (Wi-Fi/Ethernet), and had
    more than enough RAM and storage for Node. But not all devices are so lucky. Native
    support for HTTP/WS or even TCP/IP isn’t always possible or even desirable. For
    battery-powered devices, Wi-Fi or Ethernet is often too much of a power drag,
    so they need to rely on low-power protocols such as ZigBee or Bluetooth instead.
    Does it mean those devices can’t be part of the Web of Things? Certainly not,
    as illustrated in [figure 7.7](#ch07fig07).
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你通过为你的树莓派传感器创建HTTP和WebSockets API将其转换为一个Web设备。这很有效，因为你的树莓派不是电池供电的，有足够的带宽（Wi-Fi/Ethernet），并且有足够的RAM和存储空间来运行Node。但并非所有设备都这么幸运。对HTTP/WS或甚至TCP/IP的原生支持并不总是可能，甚至可能不是所希望的。对于电池供电的设备，Wi-Fi或以太网可能会消耗太多的电量，因此它们需要依赖于低功耗协议，如ZigBee或蓝牙。这意味着这些设备不能成为物联网的一部分吗？当然不是，如图7.7所示。
- en: Figure 7.7\. Gateway integration pattern. In this case, the web Thing can’t
    directly offer a web API because the device might not support HTTP directly. An
    application gateway is working as a proxy for the Thing by offering a web API
    in the Thing’s name. This API could be hosted on the router in the case of Bluetooth
    or on another device that exposes the web Thing API; for example, via CoAP.
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.7\. 网关集成模式。在这种情况下，Web设备不能直接提供Web API，因为设备可能不支持HTTP。一个应用网关通过以设备的名义提供Web API作为设备的代理。这个API可以托管在路由器上，例如在蓝牙的情况下，或者在其他暴露Web设备API的设备上；例如，通过CoAP。
- en: '![](07fig07_alt.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![07fig07_alt.jpg](07fig07_alt.jpg)'
- en: Such devices can also be part of the Web of Things as long as there’s an intermediary
    somewhere that can expose the device’s functionality through a WoT API like the
    one we described previously. These intermediaries are called *application gateways*
    (we’ll call them WoT gateways hereafter), and they can talk to Things using any
    non-web application protocols and then translate those into a clean REST WoT API
    that any HTTP client can use. Some gateways can also do more than simply translate
    across protocols. They can add a layer of security or authentication, aggregate
    and store data temporarily, expose semantic descriptions for Things that don’t
    have any, and so on.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备也可以成为物联网的一部分，只要某个中间设备能够通过我们之前描述的WoT API（如我们之前描述的那样）暴露设备的函数。这些中间设备被称为*应用网关*（在此之后我们将它们称为WoT网关），它们可以使用任何非Web应用协议与设备通信，然后将这些协议转换为任何HTTP客户端都可以使用的干净RESTful
    WoT API。一些网关还能执行比简单协议转换更多的功能。它们可以添加一层安全或认证，临时聚合和存储数据，为没有语义描述的设备提供描述，等等。
- en: To better understand what a WoT gateway is and what it can do for non-web devices,
    let’s look at a concrete example where we expose a CoAP device using an HTTP and
    WebSockets API. As you’ve seen before, CoAP is an interesting protocol based on
    REST, but because it isn’t HTTP and uses UDP instead of TCP, a gateway that translates
    CoAP messages from/to HTTP is needed. It’s therefore ideal for device-to-device
    communication over low-power radio communication, but you can’t talk to a CoAP
    device from a JavaScript application in your browser without installing a special
    plugin or browser extension. Let’s fix this by using your Pi as a WoT gateway
    to CoAP devices.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 WoT 网关是什么以及它能为非网络设备做什么，让我们看看一个具体的例子，其中我们使用 HTTP 和 WebSocket API 暴露一个
    CoAP 设备。正如你之前所看到的，CoAP 是一个基于 REST 的有趣协议，但由于它不是 HTTP，并且使用 UDP 而不是 TCP，因此需要一个网关来将
    CoAP 消息从/到 HTTP 进行转换。因此，它非常适合在低功耗无线电通信中进行设备到设备的通信，但你不能在没有安装特殊插件或浏览器扩展的情况下从你的浏览器中的
    JavaScript 应用程序与 CoAP 设备进行通信。让我们通过使用你的 Pi 作为 WoT 网关到 CoAP 设备来解决这个问题。
- en: 7.3.1\. Running a CoAP server
  id: totrans-506
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1\. 运行 CoAP 服务器
- en: Start by creating a simple CoAP resource. For the sake of simplicity—and to
    keep your budget in check—you’ll simulate a CoAP device on your computer. Of course,
    you could also buy a resource-constrained device such as an Arduino Uno and install
    CoAP on it.^([[10](#ch07fn10)])
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个简单的 CoAP 资源。为了简化——并且为了控制你的预算——你将在你的计算机上模拟一个 CoAP 设备。当然，你也可以购买一个资源受限的设备，如
    Arduino Uno，并在其上安装 CoAP.^([[10](#ch07fn10)])
- en: ^(10)
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10)
- en: ''
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For instance, using the microcoap implementation available here: [https://github.com/1248/microcoap](https://github.com/1248/microcoap).'
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，使用这里可用的 microcoap 实现：[https://github.com/1248/microcoap](https://github.com/1248/microcoap)。
- en: There are a number of libraries for CoAP on Node but our favorite is `coap`
    (run `npm install coap` to install it). An implementation of a minimal CoAP server
    is provided in /servers/coap.js, shown in the following listing.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: Node 上有多个 CoAP 库，但我们最喜欢的是 `coap`（运行 `npm install coap` 来安装它）。在 /servers/coap.js
    中提供了一个最小 CoAP 服务器的实现，如下所示。
- en: 'Listing 7.15\. coap.js: a simple CoAP server'
  id: totrans-512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.15\. coap.js：一个简单的 CoAP 服务器
- en: '![](ch07ex15-0.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex15-0.jpg)'
- en: '![](ch07ex15-1.jpg)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex15-1.jpg)'
- en: 'You’ll likely realize that this code isn’t very different from what you’ve
    learned in the last two chapters. That’s because CoAP is heavily inspired by HTTP
    and REST but adapted for the requirements of low-power embedded systems. Because
    CoAP is using UDP and not HTTP/TCP, you can’t access these resources directly
    from your browser via a CoAP URI: coap://localhost:5683/co2.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会意识到这段代码与你在前两章中学到的并没有太大区别。这是因为 CoAP 受 HTTP 和 REST 的启发很大，但为了适应低功耗嵌入式系统的需求而进行了调整。由于
    CoAP 使用 UDP 而不是 HTTP/TCP，你不能直接通过 CoAP URI：coap://localhost:5683/co2 从你的浏览器中直接访问这些资源。
- en: But you can use an excellent plugin for Firefox called Copper.^([[11](#ch07fn11)])
    Once the plugin is installed, start the CoAP server (node coap.js in the servers
    directory) and you’ll be able to access the resources you just created by typing
    the CoAP URI; for example, coap://localhost:5683/co2, in Firefox’s address bar.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以使用一个名为 Copper 的优秀 Firefox 插件.^([[11](#ch07fn11)]) 一旦安装了插件，启动 CoAP 服务器（在服务器目录中运行
    node coap.js）并你可以通过在 Firefox 的地址栏中输入 CoAP URI 来访问你刚刚创建的资源；例如，coap://localhost:5683/co2。
- en: ^(11)
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(11)
- en: ''
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://addons.mozilla.org/en-US/firefox/addon/copper-270430/](https://addons.mozilla.org/en-US/firefox/addon/copper-270430/)'
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://addons.mozilla.org/en-US/firefox/addon/copper-270430/](https://addons.mozilla.org/en-US/firefox/addon/copper-270430/)'
- en: 7.3.2\. Proxying CoAP via a gateway
  id: totrans-520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2\. 通过网关代理 CoAP
- en: The next step is to proxy CoAP requests to HTTP so that you can access CoAP
    devices from web browsers. Here you’ll extend your WoT gateway to provide access
    to CoAP devices via your Pi.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将 CoAP 请求代理到 HTTP，这样你就可以通过网页浏览器访问 CoAP 设备。在这里，你将扩展你的 WoT 网关以通过你的 Pi 提供对
    CoAP 设备的访问。
- en: Transforming your Pi into a WoT gateway requires two simple steps. First, you
    create a CoAP plugin, which is essentially a CoAP client creating a new device
    in our model. Second, you create routes for the resources the CoAP device has
    to offer. The code for the CoAP plugin is shown in the next listing. Because most
    of the code is just like the other temperature/humidity sensor plugins, we focus
    on what’s different.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的 Pi 转换为 WoT 网关需要两个简单的步骤。首先，你创建一个 CoAP 插件，这本质上是在我们的模型中创建一个新的 CoAP 客户端。其次，你为
    CoAP 设备必须提供的资源创建路由。CoAP 插件的代码在下一列表中显示。由于大部分代码与其他温度/湿度传感器插件类似，我们关注的是不同之处。
- en: 'Listing 7.16\. /plugins/external/coapPlugin.js: a simple CoAP plugin'
  id: totrans-523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.16\. /plugins/external/coapPlugin.js：一个简单的 CoAP 插件
- en: '![](ch07ex16-0.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex16-0.jpg)'
- en: '![](ch07ex16-1.jpg)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch07ex16-1.jpg)'
- en: 'Then you need to add the routes for the resources for your CoAP device. To
    keep it simple, you connect only a CO2 sensor, but feel free to extend this to
    support any other resources you want. You need to add these routes in /routes/things.js:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您需要为您的CoAP设备添加资源路由。为了简化，您只需连接一个CO2传感器，但您可以自由扩展以支持您想要的任何其他资源。您需要在 /routes/things.js
    中添加这些路由：
- en: '[PRE21]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You load the router as a middleware in /servers/http.js, binding it to `/things`.
    This means the CoAP device will be accessible on `/things/coapDevice/sensors/co2`,
    which makes sense because it’s a Thing managed by the Pi, which acts as a proxy,
    not the Pi itself. Finally, you require and start the CoAP plugin in wot-server.js:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 您将路由器作为中间件加载到 /servers/http.js 中，并将其绑定到 `/things`。这意味着CoAP设备将在 `/things/coapDevice/sensors/co2`
    上可访问，这是有意义的，因为这是一个由Pi管理的实体，Pi充当代理，而不是Pi本身。最后，在 wot-server.js 中引入并启动CoAP插件：
- en: '[PRE22]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If everything works, you should be able to access the simulated CoAP device
    through the Pi gateway using HTTP. First, start the CoAP server on your PC (`node
    coap.js`) and then the gateway on your Pi (`node wot-server.js`), and finally,
    try to run the following cURL:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，您应该能够通过Pi网关使用HTTP访问模拟的CoAP设备。首先，在您的PC上启动CoAP服务器（`node coap.js`），然后启动Pi上的网关（`node
    wot-server.js`），最后，尝试运行以下cURL命令：
- en: '[PRE23]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should get the sensor readings as a MessagePack representation. You can
    also try to use a snippet of JavaScript that connects to the CoAP CO2 sensor via
    WebSockets (for example, use the file /public/websocketsClient.html) or even point
    your browser at [http://raspberrypi.local:8484/things/coapDevice/sensors/co2](http://raspberrypi.local:8484/things/coapDevice/sensors/co2).
    All of these will work, even if the CoAP device can’t serve MessagePack or HTML
    representations and can’t speak WebSockets. This is the *gateway pattern in action*:
    it seamlessly integrates the CoAP device to the web of browsers!'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该以MessagePack表示形式获取传感器读数。您还可以尝试使用一段JavaScript代码通过WebSockets连接到CoAP CO2传感器（例如，使用文件
    /public/websocketsClient.html）或甚至将浏览器指向 [http://raspberrypi.local:8484/things/coapDevice/sensors/co2](http://raspberrypi.local:8484/things/coapDevice/sensors/co2)。所有这些方法都将有效，即使CoAP设备无法提供MessagePack或HTML表示，也无法使用WebSockets。这是
    *网关模式* 的实际应用：它无缝地将CoAP设备集成到浏览器网络中！
- en: This was a very short introduction to CoAP. If you want to learn more about
    this young and growing web-inspired protocol, start by exploring the CoAP technology
    portal.^([[12](#ch07fn12)])
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对CoAP的一个非常简短的介绍。如果您想了解更多关于这个年轻且不断发展的受网络启发的协议的信息，请从探索CoAP技术门户开始.^([[12](#ch07fn12)])
- en: ^(12)
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(12)
- en: ''
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://coap.technology/](http://coap.technology/)'
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://coap.technology/](http://coap.technology/)'
- en: '|  |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The nerd corner—I want a generic CoAP proxy**'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术角落—I想要一个通用的CoAP代理**'
- en: 'Even though CoAP isn’t supported by the web of browsers, it offers an interesting
    tradeoff for resource- or battery-constrained devices, especially when considering
    device-to-device communication. It’s similar to HTTP, so the translation is easier
    because we don’t need to map between different data models and could use the same
    JSON model over both HTTP and CoAP. The translation we illustrated here was simple
    but not generic: we needed to manually map a CoAP resource to HTTP routes. Building
    a generic HTTP proxy for CoAP devices is possible and not overly complex. Should
    you want to try, you’ll find a number of examples on the web.^([[a](#ch07fn1c)])'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管CoAP不被浏览器网络支持，但它为资源或电池受限的设备提供了一个有趣的权衡，尤其是在考虑设备间通信时。它与HTTP类似，因此翻译更容易，因为我们不需要在不同数据模型之间进行映射，并且可以在HTTP和CoAP上使用相同的JSON模型。我们在这里展示的翻译很简单，但不是通用的：我们需要手动将CoAP资源映射到HTTP路由。为CoAP设备构建通用的HTTP代理是可能的，并且并不过于复杂。如果您想尝试，您将在网上找到许多示例.^([[a](#ch07fn1c)])
- en: ^a
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For instance, here: [https://github.com/morkai/h5.coap/blob/master/example/http-proxy.js](https://github.com/morkai/h5.coap/blob/master/example/http-proxy.js).'
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，这里：[https://github.com/morkai/h5.coap/blob/master/example/http-proxy.js](https://github.com/morkai/h5.coap/blob/master/example/http-proxy.js)。
- en: '|  |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.3.3\. Summary—gateway integration pattern
  id: totrans-544
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.3. 摘要——网关集成模式
- en: For some devices, it might not make sense to support HTTP or WebSockets directly,
    or it might not even be possible, such as when they have very limited resources
    like memory or processing, when they can’t connect to the internet directly (such
    as your Bluetooth activity tracker), or when they’re battery-powered. Those devices
    will use more optimized communication or application protocols and thus will need
    to rely on a more powerful gateway that connects them to the Web of Things, such
    as your mobile phone to upload the data from your Bluetooth bracelet, by bridging/translating
    various protocols. Here we implemented a simple gateway from scratch using Express,
    but you could also use other open source alternatives such as OpenHab^([[13](#ch07fn13)])
    or The Thing System.^([[14](#ch07fn14)])
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些设备，直接支持HTTP或WebSocket可能没有意义，或者甚至不可能，例如当它们具有非常有限的资源，如内存或处理能力时，当它们无法直接连接到互联网（例如您的蓝牙活动追踪器）时，或者当它们是电池供电时。这些设备将使用更优化的通信或应用协议，因此需要依赖更强大的网关来将它们连接到物联网，例如您的手机通过桥接/翻译各种协议上传您的蓝牙手环中的数据。在这里，我们从头开始使用Express实现了一个简单的网关，但您也可以使用其他开源替代方案，例如OpenHab^([[13](#ch07fn13)])或The
    Thing System.^([[14](#ch07fn14)])
- en: ^(13)
  id: totrans-546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(13)
- en: ''
  id: totrans-547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.openhab.org/](http://www.openhab.org/)'
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.openhab.org/](http://www.openhab.org/)'
- en: ^(14)
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(14)
- en: ''
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/TheThingSystem/steward](https://github.com/TheThingSystem/steward)'
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://github.com/TheThingSystem/steward](https://github.com/TheThingSystem/steward)'
- en: 7.4\. Cloud integration pattern—MQTT over EVRYTHNG
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4\. 云集成模式—通过EVRYTHNG的MQTT
- en: As you saw in the previous sections, it’s possible to implement WoT servers
    directly on devices or via gateways. This is sufficient in many situations, but
    as soon as you need to manage large quantities of devices and data, you’ll need
    to have a much more powerful and scalable platform to store and process the data.
    The cloud integration pattern, shown in [figure 7.8](#ch07fig08), is an extension
    of the gateway pattern where the gateway is a remote server that devices and applications
    access via the internet.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前几节所看到的，可以在设备或网关上直接实现WoT服务器。这在许多情况下是足够的，但一旦需要管理大量设备和数据，就需要一个更强大、可扩展的平台来存储和处理数据。图7.8所示的云集成模式是网关模式的扩展，其中网关是一个远程服务器，设备和应用程序通过互联网访问。
- en: Figure 7.8\. Cloud integration pattern. In this pattern, the Thing can’t directly
    offer a Web API. But a cloud service acts as a powerful application gateway, offering
    many more features in the name of the Thing. In this particular example, the web
    Thing connects via MQTT to a cloud service, which exposes the web Thing API via
    HTTP and the WebSockets API. Cloud services can also offer many additional features
    such as unlimited data storage, user management, data visualization, stream processing,
    support for many concurrent requests, and more.
  id: totrans-554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.8\. 云集成模式。在这个模式中，实体无法直接提供Web API。但云服务作为强大的应用网关，以实体的名义提供更多功能。在这个特定的例子中，Web实体通过MQTT连接到云服务，该服务通过HTTP和WebSocket
    API公开Web实体API。云服务还可以提供许多附加功能，例如无限数据存储、用户管理、数据可视化、流处理、支持大量并发请求等。
- en: '![](07fig08_alt.jpg)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig08_alt.jpg)'
- en: Using a cloud server has several advantages. First, because it doesn’t have
    the physical constraints of devices and gateways, it’s much more scalable and
    can process and store a virtually unlimited amount of data. This also allows a
    cloud platform to support many protocols at the same time, handle protocol translation
    efficiently, and act as a scalable intermediary that can support many more concurrent
    clients than an IoT device could. Second, those platforms can have many features
    that might take considerable time to build from scratch, from industry-grade security,
    to specialized analytics capabilities, to flexible data visualization tools and
    user and access management. This means you can get started building complex applications
    in a fraction of time. Third, because those platforms are natively connected to
    the web, data and services from your devices can be easily integrated into third-party
    systems to extend your devices.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云服务器有几个优点。首先，因为它没有设备和网关的物理限制，所以它具有更高的可扩展性，可以处理和存储几乎无限量的数据。这也使得云平台能够同时支持许多协议，高效地处理协议转换，并作为可扩展的中介，支持比物联网设备更多的并发客户端。其次，这些平台可以拥有许多可能需要相当长时间从头开始构建的功能，从行业级安全到专门的分析能力，再到灵活的数据可视化工具和用户及访问管理。这意味着你可以用极短的时间开始构建复杂的应用程序。第三，因为这些平台与互联网原生连接，所以你的设备的数据和服务可以轻松集成到第三方系统中，以扩展你的设备。
- en: 'Over the years, many cloud platforms have appeared, and they usually share
    similar characteristics: creating virtual devices in the cloud that can permanently
    talk to their physical counterparts, storing all the data generated by the devices,
    and visualizing that data in multiple ways. Xively^([[15](#ch07fn15)]) (ex-Cosm,
    ex-Pachube) was one of the earliest ones; its simple API allowed developers throughout
    the world to quickly connect devices to the cloud. There are many other ones you
    can use for your projects, such as ThingWorx,^([[16](#ch07fn16)]) ThingSpeak,^([[17](#ch07fn17)])
    Carriots,^([[18](#ch07fn18)]) and thethings.io.^([[19](#ch07fn19)])'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，出现了许多云平台，它们通常具有相似的特征：在云中创建虚拟设备，这些设备可以永久与其物理对应设备通信，存储设备生成所有数据，并以多种方式可视化这些数据。Xively^([[15](#ch07fn15)])（前Cosm，前Pachube）是其中之一；它简单的API允许全球的开发者快速将设备连接到云。你可以为你的项目使用许多其他平台，例如ThingWorx^([[16](#ch07fn16)]),
    ThingSpeak^([[17](#ch07fn17)]), Carriots^([[18](#ch07fn18)]), 和 thethings.io^([[19](#ch07fn19)])。
- en: ^(15)
  id: totrans-558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(15)
- en: ''
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://xively.com/](https://xively.com/)'
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://xively.com/](https://xively.com/)'
- en: ^(16)
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(16)
- en: ''
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.thingworx.com/](http://www.thingworx.com/)'
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.thingworx.com/](http://www.thingworx.com/)'
- en: ^(17)
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(17)
- en: ''
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://thingspeak.com/](https://thingspeak.com/)'
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://thingspeak.com/](https://thingspeak.com/)'
- en: ^(18)
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(18)
- en: ''
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.carriots.com/](https://www.carriots.com/)'
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://www.carriots.com/](https://www.carriots.com/)'
- en: ^(19)
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(19)
- en: ''
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://thethings.io/](https://thethings.io/)'
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://thethings.io/](https://thethings.io/)'
- en: 'In this section, we’ll teach you how to connect to our favorite IoT platform
    ever: EVRYTHNG. Okay, we might be biased because we built it! But at least it
    will help you learn quickly about the advantages of the cloud integration pattern.
    Started in 2011, EVRYTHNG was also the first IoT platform to apply the Web of
    Things principles, so it should feel familiar! In this section, you’ll learn how
    to implement a basic web-connected power plug, as shown in [figure 7.9](#ch07fig09).
    The plug monitors the energy consumption of the device attached to it and permanently
    sends this data to the cloud. These readings will be permanently stored in the
    cloud. In addition, the plug is permanently connected to the cloud using MQTT
    (which we described in [chapter 5](kindle_split_012.html#ch05)), which means that
    the cloud can send commands to it at any time with minimal latency.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将教你如何连接到我们最喜欢的物联网平台：EVRYTHNG。好吧，我们可能有点偏见，因为我们就是构建它的！但至少它将帮助你快速了解云集成模式的优势。EVRYTHNG始于2011年，也是第一个应用物联网原则的物联网平台，所以它应该感觉熟悉！在本节中，你将学习如何实现一个基本的网络连接电源插头，如图7.9所示。该插头监控连接到它的设备的能源消耗，并将这些数据永久发送到云中。这些读数将永久存储在云中。此外，该插头通过MQTT（我们在第5章中描述过）永久连接到云，这意味着云可以在任何时间以最小的延迟向它发送命令。
- en: Figure 7.9\. A physical device connects to a cloud platform using MQTT over
    TCP/IP and talks to its proxy on the web—called Thng. An external application
    can then talk to the Thng using a simple HTTP client.
  id: totrans-574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.9。一个物理设备通过TCP/IP使用MQTT连接到云平台，并通过其Web上的代理（称为Thng）进行通信。然后，外部应用程序可以使用简单的HTTP客户端与Thng通信。
- en: '![](07fig09_alt.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig09_alt.jpg)'
- en: Afterward, we’ll implement a simple web application using HTML and JavaScript
    that subscribes to the plug using WebSockets, displays the current consumption
    in real time, and also allows you to turn the plug on and off. You’ll find all
    the source code you need in the folder chapter7-implementation/part3-cloud of
    the book’s GitHub repository.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将实现一个简单的Web应用程序，使用HTML和JavaScript订阅插头，实时显示当前消耗，并允许你打开和关闭插头。你需要的所有源代码都可以在本书GitHub仓库的chapter7-implementation/part3-cloud文件夹中找到。
- en: 7.4.1\. Set up your EVRYTHNG account
  id: totrans-577
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.1\. 设置你的EVRYTHNG账户
- en: The first thing you need to do is create an EVRYTHNG account and log into it.^([[20](#ch07fn20)])
    Don’t worry; it’s quick and it won’t cost you a dime to implement this exercise.
    EVRYTHNG services are completely free for non-commercial projects! To get you
    up to speed, you can check out our quick tutorial for how to use it.^([[21](#ch07fn21)])
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是创建一个EVRYTHNG账户并登录进去.^([[20](#ch07fn20)]) 别担心；这很快，而且实施这个练习不会花你一分钱。EVRYTHNG服务对非商业项目是完全免费的！为了让你快速上手，你可以查看我们关于如何使用它的快速教程.^([[21](#ch07fn21)])
- en: ^(20)
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(20)
- en: ''
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You can do it here: [https://dashboard.evrythng.com/signup](https://dashboard.evrythng.com/signup).'
  id: totrans-581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在这里完成：[https://dashboard.evrythng.com/signup](https://dashboard.evrythng.com/signup)。
- en: ^(21)
  id: totrans-582
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(21)
- en: ''
  id: totrans-583
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Quick introduction to EVRYTHNG: [https://developers.evrythng.com](https://developers.evrythng.com)'
  id: totrans-584
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: EVRYTHNG快速入门：[https://developers.evrythng.com](https://developers.evrythng.com)
- en: Once you’ve created your account, you’ll need your account API key (called *operator
    API key*^([[22](#ch07fn22)])). This key will allow you to create and manage the
    digital identities for your device in the cloud and interact with them. It’s critical
    that you don’t share it with anyone because this API key is so powerful that it
    can delete every Thng—this is not a typo; EVRYTHNG likes to drop vowels—in your
    account. Don’t even share it with your girlfriend/boyfriend or best buddy! Unless
    he’s really a great guy, in which case it might be okay—or not!
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了你的账户，你将需要你的账户API密钥（称为*操作员API密钥*^([[22](#ch07fn22)])）。这个密钥将允许你在云中创建和管理你的设备的数字身份，并与它们交互。绝对不要与他人分享它，因为这个API密钥非常强大，它可以删除你账户中的每一个Thng——这不是一个打字错误；EVRYTHNG喜欢省略元音——这很重要！甚至不要与你的女朋友/男朋友或最好的朋友分享！除非他真的非常棒，在这种情况下，可能可以——或者也可能不行！
- en: ^(22)
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(22)
- en: ''
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Find it here: [https://dashboard.evrythng.com/account](https://dashboard.evrythng.com/account).'
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这里找到它：[https://dashboard.evrythng.com/account](https://dashboard.evrythng.com/account)。
- en: In this section you set up your account so that you can connect your devices
    and applications to the engine. You could also do all the following steps from
    the EVRYTHNG dashboard or via POSTman. In this section, we’ll show you how to
    use cURL so that you can easily run those requests from your terminal and also
    see the details of the various HTTP requests. You can append the `--verbose` flag
    to the request to see more details about your request.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你设置账户以便可以将你的设备和应用程序连接到引擎。你也可以从EVRYTHNG仪表板或通过POSTman执行所有以下步骤。在本节中，我们将向你展示如何使用cURL，这样你就可以轻松地从你的终端运行这些请求，并查看各种HTTP请求的详细信息。你可以在请求中添加`--verbose`标志来查看更多关于你的请求的详细信息。
- en: '|  |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Set up your account data automatically**'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动设置你的账户数据**'
- en: You’ll have to manually create a few entities in your EVRYTHNG account by running
    various HTTP requests against our cloud, as described in steps 1–4\. If you run
    into any problems or you don’t want to do this all manually, we’ve prepared a
    cool script for you that does steps 1–4 automatically, which is described at the
    end of this section. The script is called setup.sh and you can run it from the
    terminal of your Pi with
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 你将不得不手动在你的EVRYTHNG账户中创建一些实体，通过对我们云的多个HTTP请求来实现，如步骤1–4所述。如果你遇到任何问题或者你不想手动完成所有这些，我们为你准备了一个很酷的脚本，它会自动完成步骤1–4，这个脚本在本节的末尾有描述。这个脚本叫做setup.sh，你可以从你的Pi的终端运行它。
- en: '[PRE24]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: where `XXX` is your operator API key. You’ll see a matrix-like effect that not
    only runs all the commands you’ve seen to create those entities for you but also
    saves them into a config.json file that you’ll need in the next section. You’re
    now ready to experience the full power of the cloud implementation pattern.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`XXX`是你的操作员API密钥。你会看到一个类似矩阵的效果，它不仅运行你看到的所有命令为你创建这些实体，还将它们保存到一个config.json文件中，你将在下一节中需要这个文件。现在你已经准备好体验云实现模式的全部功能了。
- en: '|  |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Step 1—Create a project and an application
  id: totrans-596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第1步——创建一个项目和应用程序
- en: 'Before we start, you must copy and paste these two lines in your terminal,
    which will define two shell *environment variables* that the cURL requests in
    this section will use:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，你必须复制并粘贴以下两行到你的终端中，这将定义两个shell *环境变量*，这些cURL请求在本节中将会使用：
- en: '[PRE25]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Obviously, replace `YOUR-API-KEY` with your own operator API key before you
    run it. You’ll have to define quite a few other environment variables in the same
    way in this section.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在运行之前，你需要将`YOUR-API-KEY`替换成你自己的操作员API密钥。在这个部分，你将不得不以同样的方式定义相当多的其他环境变量。
- en: 'The first thing you’ll do is to create a project inside your account. A *project*
    is a placeholder (a scope) that allows you to separate the various elements you’ll
    generate (Thngs and data). Also, you’ll need a project to create applications
    that can access some of your data because you don’t want to use your operator
    API key in client applications. Paste the following request into your terminal:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 你要做的第一件事是在你的账户中创建一个项目。一个*项目*是一个占位符（一个范围），它允许你分离你将生成的各种元素（Thngs和数据）。此外，你需要一个项目来创建可以访问你一些数据的应用程序，因为你不想在客户端应用程序中使用你的操作员API密钥。将以下请求粘贴到你的终端中：
- en: '[PRE26]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If this request wasn’t successful make sure the `SERVER` and `EVRYTHNG_API_KEY`
    environment variables are correct, which you can test by running `echo $SERVER`
    in your terminal. If it was successful, you should receive a `201 Created` response
    that looks like this:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个请求没有成功，请确保`SERVER`和`EVRYTHNG_API_KEY`环境变量是正确的，你可以通过在终端中运行`echo $SERVER`来测试它们。如果成功了，你应该会收到一个`201
    Created`响应，看起来像这样：
- en: '[PRE27]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that there’s now an `id` field in the object, which contains the EVRYTHNG
    ID of the project you created. Go ahead and save this value into the environment
    variable `$PROJECT_ID` as you did when you pasted the `EVRYTHNG_API_KEY="XXX"`
    earlier, by pasting `PROJECT_ID=YYY` into your terminal, where `YYY` is the ID
    of the project you just created—`PROJECT_ID=UCkWEEKnPe5wWhgbdhSfwnGc`, in this
    example.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在对象中有一个`id`字段，它包含你创建的项目EVRYTHNG ID。像之前粘贴`EVRYTHNG_API_KEY="XXX"`时那样，将这个值保存到环境变量`$PROJECT_ID`中，通过在你的终端中粘贴`PROJECT_ID=YYY`，其中`YYY`是你刚刚创建的项目的ID——在这个例子中是`PROJECT_ID=UCkWEEKnPe5wWhgbdhSfwnGc`。
- en: 'Once you’ve created your first project, you can create an application in it.
    An application will give you another API key (an *App API key*) that you can use
    in the client application we’ll build later. This one isn’t so dangerous, because
    what it can do is very limited; basically it only allows you to create users.
    To create an application, send the following cURL request in your terminal:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了你的第一个项目，你就可以在其中创建一个应用程序。应用程序会为你提供一个额外的API密钥（一个*应用程序API密钥*），你可以在我们稍后构建的客户端应用程序中使用它。这个密钥并不那么危险，因为它能做的事情非常有限；基本上它只允许你创建用户。要创建一个应用程序，请在你的终端中发送以下cURL请求：
- en: '[PRE28]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Again, just like you did for projects, store the ID returned in the response
    inside the `$APP_ID` environment variable. Also, note the API key in the response;
    you’ll use it to build your web application later on. Now you’re ready to create
    a web Thing in our cloud.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，就像你为项目做的那样，将响应中返回的ID存储在`$APP_ID`环境变量中。还要注意响应中的API密钥；你将在稍后构建你的Web应用程序时使用它。现在你已准备好在我们的云中创建一个Web
    Thing。
- en: Step 2—Create your first products and Thngs
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第2步——创建你的第一个产品和Thngs
- en: 'A *product* is a *class* of physical objects (think TV model or car type) but
    not a unique *instance* (think serial number). You shouldn’t use products to store
    data about physical objects. They’re a conceptual entity, a model of a physical
    object, and should only contain information that many physical objects of this
    class share—attributes such as size, image, weight, and color—but no real-time
    information such as location, sensor readings, or current state. Create a product
    using the following request:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*产品*是一类物理对象（比如电视型号或汽车类型）的*类别*，而不是一个独特的*实例*（比如序列号）。你不应该使用产品来存储有关物理对象的数据。它们是一个概念实体，一个物理对象的模型，应该只包含许多此类物理对象共享的信息——如大小、图像、重量和颜色——但不包含实时信息，如位置、传感器读数或当前状态。使用以下请求创建一个产品：
- en: '[PRE29]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note the `?project=$PROJECT_ID` query parameter, which tells EVRYTHNG to store
    this product inside the project we created earlier. Store the product ID in the
    `$PRODUCT_ID` variable.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`?project=$PROJECT_ID`查询参数，它告诉EVRYTHNG将此产品存储在我们之前创建的项目中。将产品ID存储在`$PRODUCT_ID`变量中。
- en: '*Thngs*, on the other hand, are the digital representation of unique instances
    of physical objects: the Thing you hold in your hands! For each unique device
    or object you want to web-enable, you’ll need to create a unique Thng. You can
    do it like this:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*Thngs*是物理对象独特实例的数字表示：你手中的事物！对于你想要网络化的每个独特设备或对象，你都需要创建一个独特的Thng。你可以这样做：
- en: '[PRE30]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can see that we’re also sending the product ID in this request. Keep track
    of the ID of the Thng returned in the payload in the `$THNG_ID` variable.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们也在这个请求中发送了产品ID。请跟踪在payload中返回的Thng ID，并存储在`$THNG_ID`变量中。
- en: Step 3—Create a device API key
  id: totrans-615
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第3步—创建设备API密钥
- en: 'Technically, you could use your operator API key to update the property of
    your Thng, but it’s unwise to use this on a production device for various security
    reasons. Instead, you can easily generate a *Thng API key* that allows your device
    to see and edit only itself. Send a `POST` (using your operator API key) to the
    end point [https://api.evrythng.com/auth/evrythng/thngs](https://api.evrythng.com/auth/evrythng/thngs)
    with the ID of your Thng, as follows:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你可以使用你的操作员API密钥来更新你的Thng属性，但由于各种安全原因，在产品设备上使用此方法是不明智的。相反，你可以轻松生成一个*Thng
    API密钥*，允许你的设备仅查看和编辑自身。使用你的操作员API密钥发送一个`POST`请求（使用你的操作员API密钥）到端点[https://api.evrythng.com/auth/evrythng/thngs](https://api.evrythng.com/auth/evrythng/thngs)，并带上你的Thng
    ID，如下所示：
- en: '[PRE31]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You’ll get this in return:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下内容：
- en: '[PRE32]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `thngApiKey` field contains an API key that allows the device to see and
    update itself. Store its value in the `$THNG_API_KEY` environment variable.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '`thngApiKey`字段包含一个API密钥，允许设备查看和更新自身。将其值存储在`$THNG_API_KEY`环境变量中。'
- en: Step 4—Change properties
  id: totrans-621
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第4步—更改属性
- en: If you’ve successfully completed the previous lines, you’ll now have a project,
    an application, a product, and an instance of this product in your account. You
    can see them in your dashboard. Now you’re going to update the properties of your
    smart plug. A *property* is an array of data that you can update any time and
    that’s stored permanently inside the engine. You can continuously update each
    property individually and retrieve it anytime.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功完成了前面的行，你现在将有一个项目、一个应用程序、一个产品以及该产品的一个实例在你的账户中。你可以在仪表板上看到它们。现在你将更新你的智能插头的属性。*属性*是一个数据数组，你可以随时更新并永久存储在引擎内部。你可以连续更新每个属性，并在任何时候检索它。
- en: 'To update one or more properties, use the device API key and send a `POST`
    request to the `thngs/$THNG_ID/properties` endpoint, using this request:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新一个或多个属性，使用设备API密钥，并发送一个`POST`请求到`thngs/$THNG_ID/properties`端点，使用此请求：
- en: '[PRE33]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now you can navigate to the page of your Thng in the EVRYTHNG dashboard, which
    is shown in [figure 7.10](#ch07fig10). There you’ll see the information about
    this plug and its properties changing in real time as you run this request several
    times with different values.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以导航到EVRYTHNG仪表板中你的Thng的页面，如图7.10所示。在那里，你会看到有关这个插头及其属性的信息随着你多次运行此请求并使用不同的值而实时变化。
- en: Figure 7.10\. See the smart plug directly from the dashboard and the properties
    being updated in real time.
  id: totrans-626
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.10. 从仪表板直接查看智能插头及其属性实时更新。
- en: '![](07fig10_alt.jpg)'
  id: totrans-627
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig10_alt.jpg)'
- en: 7.4.2\. Create your MQTT client application
  id: totrans-628
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.2. 创建你的MQTT客户端应用程序
- en: In the previous section, you learned how to set up your EVRYTHNG account to
    create web Things for any physical object you want to connect to the web. You
    did this using cURL commands to learn about the endpoints and how they work, but
    obviously this is not how your device will talk to the engine.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何设置你的EVRYTHNG账户以创建任何你想要连接到网络的物理对象的网络事物。你是通过使用cURL命令来了解端点和它们的工作方式来做到这一点的，但显然这不是你的设备与引擎通信的方式。
- en: For this project, you’ll write a simple Node application that simulates a smart
    plug and that you can run from your Pi or on your PC. The application uses the
    Thng API key (created in step 3 of the previous exercise) to open a permanent
    connection to the EVRYTHNG engine over MQTT and update its properties every five
    seconds.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将编写一个简单的Node应用程序，模拟一个智能插头，你可以在你的Pi或PC上运行它。该应用程序使用Thng API密钥（在上一练习的第3步中创建）通过MQTT打开到EVRYTHNG引擎的永久连接，并每五秒更新其属性。
- en: Open the file simple-plug.js and look at the code. Before you can execute it,
    you’ll need a config.json file with the IDs and API keys of your EVRYTHNG account.
    If you ran the setup.sh bash script instead of going through the four manual steps,
    it will have generated this file for you. Otherwise, create a copy of the file
    config-sample.json named config.json and put the Thng ID (step 2 of previous section)
    and the Thng API key (step 3) in it, as shown in the following listing.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 打开simple-plug.js文件并查看代码。在你可以执行它之前，你需要一个包含你的EVRYTHNG账户ID和API密钥的config.json文件。如果你运行了setup.sh
    bash脚本而不是通过四个手动步骤进行，它将为你生成此文件。否则，创建一个名为config.json的config-sample.json文件的副本，并将Thng
    ID（上一节的步骤2）和Thng API密钥（步骤3）放入其中，如下所示。
- en: 'Listing 7.17\. simple-plug.js: simulated power plug that connects to EVRYTHNG
    via MQTT'
  id: totrans-632
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.17\. simple-plug.js：通过MQTT连接到EVRYTHNG的模拟电源插头
- en: '![](ch07ex17-0.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch07ex17-0.jpg)'
- en: '![](ch07ex17-1.jpg)'
  id: totrans-634
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch07ex17-1.jpg)'
- en: You can see that this example connects to EVRYTHNG via secure MQTT (MQTTS) and
    subscribes to all property updates. It then calls the function `updateProperties()`
    every five seconds, which simulates typical current and voltage readings a real
    plug might measure, and finally sends the readings to the cloud by updating the
    properties of the Thng, as you did in the step 4 of the previous section.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这个示例通过安全的MQTTS连接到EVRYTHNG，并订阅了所有属性更新。然后，它每五秒钟调用一次`updateProperties()`函数，模拟实际插头可能测量的典型电流和电压读数，并最终通过更新Thng的属性将读数发送到云，就像你在上一节步骤4中所做的那样。
- en: 'You can then go back to the Thngs page in the dashboard and start the simulated
    device by running the Node code: `npm install` and `node simple-plug.js`. You
    can now go back to the Dashboard tab to see the properties of the plug being updated
    in real time, as shown in [figure 7.10](#ch07fig10).'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以回到仪表板中的Thngs页面，通过运行Node代码来启动模拟设备：`npm install`和`node simple-plug.js`。现在，你可以回到仪表板选项卡，查看插头的属性正在实时更新，如图7.10所示[figure
    7.10](#ch07fig10)。
- en: 7.4.3\. Use actions to control the power plug
  id: totrans-637
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.3\. 使用操作来控制电源插头
- en: You’ve built a device that’s permanently connected to the internet and that
    pushes its updates to a service via MQTT. This illustrates how using a cloud engine
    can allow you to rapidly build web-connected devices without implementing a local
    gateway.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经构建了一个始终连接到互联网并通过MQTT推送其更新的设备。这说明了使用云引擎如何允许你快速构建网络连接设备，而无需实现本地网关。
- en: 'At this point, you’re probably thinking, “Okay, great, but how do I send commands
    to the plug to turn it on or off?” Fair enough! The simplest answer is this: because
    the device has subscribed to all properties using MQTT, it will receive a message
    each time any property in the EVRYTHNG cloud changes. Indeed, the text you see
    in the terminal is displayed by the `console.log()` statement in that callback
    function. With the Node application running, go to the dashboard, click the property
    `status` of the Thng, and set it to `false`. You’ll see this change immediately
    in your terminal:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能正在想，“好吧，很好，但我该如何向插头发送命令来打开或关闭它？”完全合理！最简单的答案是：因为这个设备已经通过MQTT订阅了所有属性，所以每当EVRYTHNG云中的任何属性发生变化时，它都会收到一条消息。确实，你在终端中看到的文本是由那个回调函数中的`console.log()`语句显示的。当Node应用程序运行时，转到仪表板，点击Thng的`status`属性，并将其设置为`false`。你将立即在终端中看到这个变化：
- en: '[PRE34]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You could then modify that callback handler to trigger something else in your
    code when this happens, and this will work fine.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以修改那个回调处理程序，以便在发生这种情况时在代码中触发其他操作，这将工作得很好。
- en: But this isn’t the best option because you must carefully keep track of which
    properties the device should set and which ones should only be changed by applications.
    Besides, a property is only a single value; therefore, you’d have to use several
    properties if you wanted to send commands to your device that have multiple input
    parameters; for example, setting the RGB value of several LEDs.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不是最佳选择，因为你必须仔细跟踪设备应该设置的属性以及哪些属性应该只由应用程序更改。此外，属性只是一个单一值；因此，如果你想向设备发送具有多个输入参数的命令，你将不得不使用多个属性；例如，设置几个LED的RGB值。
- en: 'For this reason, you’ll use *actions* to send more complex commands with several
    input parameters. For this, you can look at the more advanced plug-with-control.js.
    If you’ve run the bash script in [section 7.4.1](#ch07lev2sec10), it will have
    created an *action type* called `_setStatus` for you. If not, you’ll have to create
    it yourself using this command:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您将使用 *actions* 发送包含多个输入参数的更复杂的命令。为此，您可以查看更高级的 plug-with-control.js。如果您已运行
    [7.4.1 节](#ch07lev2sec10) 中的 bash 脚本，它将为您创建一个名为 `_setStatus` 的 *动作类型*。如果没有，您将必须使用以下命令自行创建：
- en: '[PRE35]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Before you create actions, you need to change your device application so that
    it also subscribes to the `actions/` resource and does something each time it
    receives a specific action. You can open the file plug-with-control.js where the
    callback functions have been modified, as shown in the next listing.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建动作之前，您需要更改您的设备应用程序，使其也订阅 `actions/` 资源，并在每次接收到特定动作时执行某些操作。您可以打开文件 plug-with-control.js，其中回调函数已被修改，如下一列表所示。
- en: 'Listing 7.18\. plug-with-control.js: subscribe and handle actions pushed from
    the server'
  id: totrans-646
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.18\. plug-with-control.js: 订阅并处理从服务器推送的动作'
- en: '![](ch07ex18-0.jpg)'
  id: totrans-647
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex18-0.jpg)'
- en: '![](ch07ex18-1.jpg)'
  id: totrans-648
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex18-1.jpg)'
- en: 'You can now run this second code, and you’ll still see when properties are
    updated. But for now, open a second terminal and send a `_setStatus` command to
    the Thng in your engine, using the following request:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以运行此第二段代码，您仍然会在属性更新时看到它。但到目前为止，请打开第二个终端，并使用以下请求向您的引擎中的 Thng 发送 `_setStatus`
    命令：
- en: '[PRE36]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Study carefully the content of the response payload because it contains much
    more information that you’ve sent. Our cloud uses your IP address to determine
    the location of the action. If you refresh the page, you’ll see this action appear
    on your Thng page in the dashboard, along with a map of it.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细研究响应负载的内容，因为它包含的信息比您发送的要多得多。我们的云使用您的 IP 地址来确定动作的位置。如果您刷新页面，您将在仪表板中的 Thng 页面上看到此动作，以及它的地图。
- en: 7.4.4\. Create a simple web control application
  id: totrans-652
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.4\. 创建一个简单的网络控制应用程序
- en: So far, you’ve written a Node application that allows a Pi to connect to a cloud
    service and receive push notifications instantly, even if your device is behind
    firewalls or NAT boxes. The benefit of using a cloud service is that it allows
    you to use a uniform interface such as a REST API, properties, or actions to talk
    to any device connected to the cloud, regardless of whether the device talks to
    EVRYTHNG using the REST API, MQTT, or another protocol. This means you can build
    a generic client application and it will work with any Thng in the platform. It
    also makes access to your Things much more scalable because clients don’t talk
    to your Things directly, but rather through a cloud intermediary representing
    the state of the Thing, like a mirror or a shadow.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经编写了一个 Node 应用程序，允许 Pi 连接到云服务并立即接收推送通知，即使您的设备位于防火墙或 NAT 网关之后。使用云服务的优点是它允许您使用统一的接口，如
    REST API、属性或动作，与连接到云的任何设备进行通信，无论该设备是否使用 REST API、MQTT 或其他协议进行通信。这意味着您可以构建一个通用的客户端应用程序，并且它将与平台上的任何
    Thng 一起工作。它还使对您的“事物”的访问更具可扩展性，因为客户端不是直接与您的“事物”交谈，而是通过代表“事物”状态的云中介进行交谈，就像一面镜子或一个影子。
- en: A simple web application using the cloud
  id: totrans-654
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用云的一个简单网络应用程序
- en: The next step is to build a simple web application that can interact with the
    device via its Thng, subscribe to its properties using WebSockets, and display
    them as soon as the device sends them. This application should also be able to
    push commands to the device via the REST API of the cloud platform.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是构建一个简单的网络应用程序，它可以与设备通过其 Thng 交互，使用 WebSockets 订阅其属性，并在设备发送它们时立即显示。此应用程序还应能够通过云平台的
    REST API 向设备推送命令。
- en: 'We built such an application for you, so go ahead and open the file part3-cloud/client/plug.html
    in your editor—or, of course, feel free to build your own! Provide the Thng ID
    and your operator API key here as query parameters in the URL:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为您构建了这样一个应用程序，所以请继续在您的编辑器中打开文件 part3-cloud/client/plug.html——或者，当然，您也可以自由地构建自己的应用程序！在这里，将
    Thng ID 和您的操作者 API 密钥作为 URL 中的查询参数提供：
- en: '[PRE37]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can now start the plug-with-control.js Node application we used in the previous
    section and open plug.html in your browser. Within a few seconds, you should see
    the properties changing and a graph being updated in real time. This application
    connects to your Thng in EVRYTHNG, subscribes to its properties using WebSockets,
    and updates the page as soon as property updates are received from the engine.
    Because the code is long and uses quite a few excellent libraries to do the heavy
    work, we’ll show only the most interesting bits here. First, you create a toggle
    button that sends a `_setStatus` action each time it’s used, as shown in the following
    listing.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以启动我们在上一节中使用的 plug-with-control.js Node 应用程序，并在你的浏览器中打开 plug.html。在几秒钟内，你应该会看到属性在实时变化，并且图表也在更新。这个应用程序连接到你的
    EVRYTHNG 中的 Thng，使用 WebSocket 订阅其属性，并在从引擎接收到属性更新时立即更新页面。由于代码很长，并且使用了相当多的优秀库来完成繁重的工作，我们在这里只展示最有趣的片段。首先，你创建一个切换按钮，每次使用时都会发送一个
    `_setStatus` 动作，如下面的列表所示。
- en: 'Listing 7.19\. client/plug.html: attach a handler to the toggle button'
  id: totrans-659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.19\. client/plug.html: 将处理程序附加到切换按钮'
- en: '[PRE38]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You create a button and use the Bootstrap Toggle^([[23](#ch07fn23)]) library
    to make it look pretty. Each time this button is triggered, the `sendAction()`
    function will be called, which looks like the code shown in the next listing.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个按钮，并使用 Bootstrap Toggle^([[23](#ch07fn23)]) 库来让它看起来更美观。每次这个按钮被触发时，`sendAction()`
    函数将被调用，其代码如下所示。
- en: ^(23)
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(23)
- en: ''
  id: totrans-663
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.bootstraptoggle.com/](http://www.bootstraptoggle.com/)'
  id: totrans-664
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.bootstraptoggle.com/](http://www.bootstraptoggle.com/)'
- en: 'Listing 7.20\. client/plugs.html: the `sendAction()` function'
  id: totrans-665
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.20\. client/plugs.html: `sendAction()` 函数'
- en: '![](210fig01_alt.jpg)'
  id: totrans-666
  prefs: []
  type: TYPE_IMG
  zh: '![](210fig01_alt.jpg)'
- en: Each time this function is called, it will `POST` an action in the engine that
    will be received by your device—exactly as you saw in the previous section.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 每次这个函数被调用时，它将在引擎中`POST`一个动作，这个动作将被你的设备接收——正如你在上一节中看到的那样。
- en: Oh, and don’t forget to turn on the plug with the button you just created; otherwise
    you won’t see anything on the graph!
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，别忘了用你刚刚创建的按钮打开插头；否则，你不会在图表上看到任何东西！
- en: Subscribing via WebSockets
  id: totrans-669
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过 WebSocket 订阅
- en: 'Second, you need to subscribe your client application to all property updates
    using WebSockets. In principle, this is similar to what you did with MQTT in the
    previous section. The idea is that you create a few HTML placeholders to display
    the current property values. For each property you want to display, you create
    a list item that looks like this:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你需要使用 WebSocket 订阅你的客户端应用程序的所有属性更新。原则上，这与你在上一节中使用的 MQTT 类似。想法是创建一些 HTML 占位符来显示当前的属性值。对于你想要显示的每个属性，你创建一个看起来像这样的列表项：
- en: '[PRE39]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that the `id` must be set to `value-status` and the same property name
    as in the engine. Let’s now see how to connect and process WebSockets messages,
    as the following listing shows.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`id` 必须设置为 `value-status`，并且与引擎中的属性名称相同。现在让我们看看如何连接和处理 WebSocket 消息，如下面的列表所示。
- en: Listing 7.21\. Connecting to WebSockets and handling property updates
  id: totrans-673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.21\. 连接到 WebSocket 并处理属性更新
- en: '![](210fig02_alt.jpg)'
  id: totrans-674
  prefs: []
  type: TYPE_IMG
  zh: '![](210fig02_alt.jpg)'
- en: This is similar to MQTT but entirely web-based and running in your web browser
    with no dependencies to install. Each time any property is updated you’ll receive
    a corresponding JSON message over the WebSocket channel because you subscribed
    to the properties topic.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 MQTT 类似，但完全是基于 Web 的，并在你的 Web 浏览器中运行，无需安装任何依赖项。每次任何属性更新时，你将通过 WebSocket 通道接收到相应的
    JSON 消息，因为你已经订阅了属性主题。
- en: Using QR codes to identify Things
  id: totrans-676
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用二维码来识别物品
- en: 'Before we finish this section, let’s do a final trick. For this, you’ll need
    to deploy plug.html and the ui/ folder file somewhere in the cloud—for instance,
    on GitHub pages.^([[24](#ch07fn24)]) If you want to take the short route, we’ve
    deployed this file for you as well, and you can access it here (after replacing
    XXX with your operator API key and YYY with your Thng ID): [https://webofthings.github.io/wot-book/plug.html?key=XXX&thngId=YYY](https://webofthings.github.io/wot-book/plug.html?key=XXX&thngId=YYY).
    If you ran the script earlier in the previous section, it will have created a
    redirection for your Thng automatically; scan the QR code or click the short URL
    and you’ll land on that link automatically. Otherwise, you can create it using
    the Setup Redirector button as shown in [figure 7.11](#ch07fig11).'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本节之前，让我们来做一个最后的技巧。为此，您需要将plug.html和ui/文件夹文件部署到云中的某个位置——例如，GitHub pages.^([[24](#ch07fn24)])
    如果您想走捷径，我们已为您部署了这个文件，您可以通过以下链接访问它（将XXX替换为您的运营商API密钥，将YYY替换为您的Thng ID）：[https://webofthings.github.io/wot-book/plug.html?key=XXX&thngId=YYY](https://webofthings.github.io/wot-book/plug.html?key=XXX&thngId=YYY).
    如果您在上一节中提前运行了脚本，它将自动为您创建一个Thng的重定向；扫描二维码或点击短URL，您将自动跳转到该链接。否则，您可以使用图7.11中所示的设置重定向按钮来创建它。
- en: ^(24)
  id: totrans-678
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(24)
- en: ''
  id: totrans-679
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://pages.github.com/](https://pages.github.com/)'
  id: totrans-680
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://pages.github.com/](https://pages.github.com/)'
- en: Figure 7.11\. How to create a short URL redirecting to the user interface of
    your device
  id: totrans-681
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.11. 如何创建一个重定向到您设备用户界面的短URL
- en: '![](07fig11_alt.jpg)'
  id: totrans-682
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig11_alt.jpg)'
- en: Put the full path to the file in the redirect expression—the previous URL with
    your own credentials—and click Create Redirection. You now have a short URL and
    a corresponding QR code that you can update anytime and that allows you to see
    and control your device by scanning it with your phone. QR codes or NFC tags are
    a great way to serialize the URLs of Things and make them physically discoverable
    by mobile phones.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 在重定向表达式中输入文件的完整路径——带有您自己凭证的先前URL——然后点击创建重定向。现在您有一个短URL和一个相应的二维码，您可以在任何时候更新它们，并通过扫描手机上的二维码来查看和控制您的设备。二维码或NFC标签是序列化事物URL的绝佳方式，使它们可以通过手机物理发现。
- en: 'Note that you should not share this QR code or URL with anyone: it contains
    your operator API key! This was only to make a point, but you should never expose
    your API keys in this manner.'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您不应该与任何人分享这个二维码或URL：它包含您的运营商API密钥！这只是为了说明问题，但您永远不应该以这种方式暴露您的API密钥。
- en: 7.4.5\. Summary—cloud integration pattern
  id: totrans-685
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.5. 摘要——云集成模式
- en: Let’s take some time to reflect on all you’ve done in this section. How did
    it feel to be able to do so much in so little time? Thanks to the open and flexible
    APIs of a Web of Things cloud platform such as EVRYTHNG, you’ve written a simple
    Node application that can talk to its digital identity in the cloud using MQTT.
    You’ve also built a basic HTML/JavaScript application that displays data from
    your device in real time and can send commands to it even if it doesn’t have a
    REST API.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来反思一下在本节中您所做的一切。在这么短的时间内完成这么多事情感觉如何？多亏了像EVRYTHNG这样的Web of Things云平台的开放和灵活API，您已经编写了一个简单的Node应用程序，它可以使用MQTT与其云中的数字身份进行通信。您还构建了一个基本的HTML/JavaScript应用程序，它可以实时显示来自您的设备的数据，并且即使它没有REST
    API，也可以向它发送命令。
- en: This is where the cloud integration pattern shines. Because most of the complexity
    of this system lives inside the cloud platform, you have less need to worry about
    scalability, reliability, or security. A cloud platform allows you, a digital
    product developer, to drastically reduce the time it takes to build web-connected
    devices and provides various powerful features, such as visualization, data storage,
    and access control. Because the front-end application uses only HTML/JS/CSS, you
    have a uniform interface to control any device regardless of whether it speaks
    HTTP or not, because the cloud system can seamlessly handle the translation across
    protocols.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是云集成模式大放异彩的地方。因为这个系统的复杂性大部分都存在于云平台内部，您就不必过多担心可扩展性、可靠性或安全性。云平台允许您，一个数字产品开发者，大大缩短构建网络连接设备所需的时间，并提供各种强大的功能，如可视化、数据存储和访问控制。因为前端应用程序只使用HTML/JS/CSS，您有一个统一的接口来控制任何设备，无论它是否支持HTTP，因为云系统可以无缝处理协议之间的转换。
- en: 'Why would you ever use the direct connectivity pattern? There are several good
    reasons for still natively providing APIs on Things. Think, for instance, about
    latency: a local call is almost always faster than a call through the cloud. Or
    think about monitoring and control when the internet is down. Because of this,
    the best compromise for real-world WoT products is quite often to offer both local
    and cloud access.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你会选择使用直接连接模式呢？仍然在“事物”上原生提供API有几个很好的理由。例如，考虑延迟：本地调用几乎总是比通过云的调用快。或者考虑在互联网断开时进行监控和控制。因此，对于现实世界的WoT产品来说，最佳折衷方案通常是提供本地和云访问。
- en: 7.5\. Summary
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5. 概述
- en: 'There are three main integration patterns for connecting Things to the web:
    direct, gateway, and cloud.'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接“事物”到Web的主要集成模式有三个：直接、网关和云。
- en: 'Regardless of the pattern you choose, you’ll have to work through the following
    steps: resource design, representation design, and interface design.'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论你选择哪种模式，你都需要完成以下步骤：资源设计、表示设计和接口设计。
- en: Direct integration allows local access to the web API of a Thing. You tried
    this by building an API for your Pi using the Express Node framework.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接集成允许对“事物”的Web API进行本地访问。你通过使用Express Node框架为Pi构建API来尝试了这种方法。
- en: The resource design step in Express was implemented using routes, each route
    representing the path to the resources of your Pi.
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Express中，资源设计步骤是通过路由实现的，每个路由代表Pi资源路径。
- en: We used the idea of middleware to implement support for different representations—for
    example, JSON, MessagePack, and HTML—in the representation design step.
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在表示设计步骤中使用了中间件的概念来实现对不同表示的支持——例如，JSON、MessagePack和HTML。
- en: The interface design step was implemented using HTTP verbs on routes as well
    as by integrating a WebSockets server using the `ws` Node module.
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口设计步骤是通过在路由上使用HTTP动词以及通过集成使用`ws`Node模块的WebSockets服务器来实现的。
- en: Gateway integration allows integrating Things without web APIs (or not supporting
    web or even internet protocols) to the WoT by providing an API for them. You tried
    this by integrating a CoAP device via a gateway on your cloud.
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关集成允许通过为它们提供API将没有Web API（或不支持Web甚至互联网协议）的“事物”集成到WoT中。你通过在云上通过网关集成CoAP设备来尝试了这种方法。
- en: Cloud integration uses servers on the web to act as shadows or proxies for Things.
    They augment the API of Things with such features as scalability, analytics, and
    security. You tried this by using the EVRYTHNG cloud.
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云集成使用网络上的服务器作为“事物”的影子或代理。它们通过可扩展性、分析和安全性等特性增强了“事物”的API。你通过使用EVRYTHNG云来尝试了这种方法。
- en: Now that we’ve created web APIs for Things, the next few chapters will be about
    making these APIs even more powerful and interesting. In the next chapter, we’ll
    explore the resource-linking design step as well as the issues of findability
    and discoverability. In essence, we’ll look at how a web Thing can expose its
    API in a way that makes it easy to be found, understood, and used by other applications,
    web Things, or even human beings!
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为“事物”创建了Web API，接下来的几章将介绍如何使这些API更加强大和有趣。在下一章中，我们将探讨资源链接设计步骤以及可查找性和可发现性问题。本质上，我们将研究Web“事物”如何以易于被其他应用程序、Web“事物”甚至人类找到、理解和使用的方式公开其API！
- en: 'Chapter 8\. Find: Describe and discover web Things'
  id: totrans-699
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章：查找：描述和发现Web“事物”
- en: '*This chapter covers*'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Learning the basics of discoverability (methods and protocols)
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习可发现性的基础知识（方法和协议）
- en: Understanding how to do web-level discovery (linking/crawling)
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何进行Web级发现（链接/爬取）
- en: Proposing a model to describe web Things and their capabilities
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提出一个模型来描述Web“事物”及其功能
- en: Extending the basic model with additional Semantic Web formats
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加额外的语义网格式扩展基本模型
- en: In the previous two chapters, we explored extensively the various integration
    patterns for connecting your Things to the web, which is the first layer of the
    WoT architecture we introduced in [chapter 6](kindle_split_014.html#ch06). We
    illustrated how using web standards as the connective tissue between heterogeneous
    devices significantly improves interoperability between components in an internet-scale
    system and thus is the core foundation of the Web of Things. Nevertheless, without
    a universal format to describe web Things and their capabilities, integrating
    web Things and applications still requires a consequent effort for developers.
    Having a single and common data model that all web Things can share would further
    increase interoperability and ease of integration by making it possible for applications
    and services to interact without the need to tailor the application manually for
    each specific device. This is an essential cornerstone of the WoT because it means
    that the hotel control center example we introduced in [chapter 1](kindle_split_008.html#ch01)
    could seamlessly discover, understand, and read data and send commands to any
    device on the Web of Things, regardless of its capabilities or its manufacturer.
    The ability to easily discover and understand any entity of the Web of Things—what
    it is and what it does—is called *findability*.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们广泛探讨了将你的Things连接到Web的各种集成模式，这是我们在第6章中引入的WoT架构的第一层。我们说明了如何使用Web标准作为异构设备之间的连接组织，这显著提高了互联网规模系统中组件之间的互操作性，因此是物联网的核心基础。尽管如此，如果没有一个通用的格式来描述Web
    Things及其功能，集成Web Things和应用程序仍然需要开发者付出持续的努力。拥有一个所有Web Things都可以共享的单个和通用数据模型将进一步通过使应用程序和服务能够无需为每个特定设备手动调整应用程序来提高互操作性和易于集成。这是WoT的一个基本基石，因为它意味着我们第1章中引入的酒店控制中心示例可以无缝地发现、理解和读取Web
    of Things上的任何设备的数据，并发送命令，无论其功能或制造商如何。能够轻松发现和理解Web of Things中的任何实体——它是什么以及它能做什么——的能力被称为*可发现性*。
- en: How to achieve such a level of interoperability—making web Things findable—is
    the purpose of the second layer, Find, of the WoT architecture and is what this
    chapter focuses on. The goal of the Find layer is to offer a uniform data model
    that all web Things can use to expose their metadata using only web standards
    and best practices. *Metadata* means the description of a web Thing, including
    the URL, name, current location, and status, and of the services it offers, such
    as sensors, actuators, commands, and properties. First, this is useful for discovering
    web Things as they get connected to a local network or to the web. Second, it
    allows applications, services, and other web Things to search for and find new
    devices without installing a driver for that Thing. By the end of this chapter,
    you’ll understand how to expose the metadata of any web Thing in a universal and
    interoperable way using network discovery protocols, such as mDNS; lightweight
    data models, such as the Web Thing Model; and Semantic Web standards, such as
    JSON-LD.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实现这样的互操作性水平——使Web Things可被发现——是WoT架构中“查找”这一第二层的目的，也是本章的重点所在。查找层的目的是提供一个统一的数据模型，所有Web
    Things都可以使用它来仅通过Web标准和最佳实践来暴露其元数据。“元数据”指的是Web Things的描述，包括URL、名称、当前位置和状态，以及它提供的各种服务，如传感器、执行器、命令和属性。首先，这对于发现连接到本地网络或网络的Web
    Things非常有用。其次，它允许应用程序、服务和其他Web Things在无需为该设备安装驱动程序的情况下搜索和找到新设备。到本章结束时，你将了解如何使用网络发现协议（如mDNS）、轻量级数据模型（如Web
    Thing Model）和语义Web标准（如JSON-LD）以通用和互操作的方式暴露任何Web Things的元数据。
- en: 8.1\. The findability problem
  id: totrans-707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1. 可发现性问题
- en: 'Once a device becomes a web Thing using the methods we presented in the previous
    two chapters, it can be interacted with using HTTP and WebSocket requests. This
    sounds great in theory, but for this to also work in practice, we must first solve
    three fundamental problems, as shown in [figure 8.1](#ch08fig01):'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设备使用我们在前两章中介绍的方法成为Web Things，它就可以通过HTTP和WebSocket请求进行交互。这在理论上听起来很棒，但要使其在实践中也能工作，我们必须首先解决三个基本问题，如图8.1所示：
- en: Figure 8.1\. The three problems of findability in the Web of Things. How can
    a client application find nearby web Things, interact with them, and understand
    what these things are and do?
  id: totrans-709
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1. 物联网中可发现性的三个问题。客户端应用程序如何找到附近的Web Things，与之交互，并理解这些事物是什么以及它们能做什么？
- en: '![](08fig01_alt.jpg)'
  id: totrans-710
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1](08fig01_alt.jpg)'
- en: '**1**.  How do we know *where* to send the requests, such as root URL/resources
    of a web Thing?'
  id: totrans-711
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 我们如何知道**发送请求**的位置，例如一个Web Thing的根URL/资源？'
- en: '**2**.  How do we know *what* requests to send and *how*; for example, verbs
    and the format of payloads?'
  id: totrans-712
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 我们如何知道要发送什么请求以及如何发送；例如，动词和有效载荷的格式？'
- en: '**3**.  How do we know the *meaning* of requests we send and responses we get,
    that is, semantics?'
  id: totrans-713
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 我们如何知道我们发送的请求和收到的响应的意义，即语义？'
- en: To better understand these problems, let’s get back to the smart hotel scenario
    from [chapter 1](kindle_split_008.html#ch01). Imagine Lena, an Estonian guest
    staying in room 202 of the hotel. Lena would like to pop up her phone so she can
    turn on the heat. The first question is how can Lena—or her phone, or an app on
    her phone—find the root URL of the heater? This is often called the *bootstrap
    problem*. This problem is concerned with how the initial link between two entities
    on the Web of Things can be established. The simplest solution to this problem
    would be to write the root URL on the desk or on the wall of the room. Another
    solution would be to encode the URL into a QR code printed on a card or use an
    NFC tag upon her check-in, so Lena could scan it with her phone. A more complex
    solution would be to install an application on her phone that searches for devices
    with heating capabilities nearby. These approaches will be the subject of [section
    8.2](#ch08lev1sec2). Finally, a web-friendly solution would be for her to Google
    for nearby heaters; we’ll look into that in [section 8.4](#ch08lev1sec4).
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些问题，让我们回到第1章中的智能酒店场景。[章节1](kindle_split_008.html#ch01)。想象一下Lena，一位住在酒店202号房的爱沙尼亚客人。Lena想要打开手机来打开加热。第一个问题是Lena——或者她的手机，或者她手机上的一个应用——如何找到加热器的根URL？这通常被称为**引导问题**。这个问题关注的是如何在物联网中建立两个实体之间的初始链接。解决这个问题最简单的办法是将根URL写在桌面上或房间的墙上。另一个解决办法是将URL编码到卡片上打印的QR码或使用NFC标签，这样Lena就可以用手机扫描它。一个更复杂的解决办法是在她的手机上安装一个应用程序，该应用程序可以搜索附近具有加热功能的设备。这些方法将是第8.2节的主题。最后，一个友好的Web解决方案是让她在Google上搜索附近的加热器；我们将在第8.4节中探讨这一点。
- en: Let’s assume for now that Lena enters the root URL of the heater on her phone.
    Ideally, she would see a pretty user interface in her native Estonian that allows
    her to figure out right away which button turns on the heat. In this case, a clean
    and user-centric web interface can solve problem 3 because humans would be able
    to read and understand how to do this. Problem 2 also would be taken care of by
    the web page, which would hardcode which request to send to which endpoint.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在Lena在她的手机上输入了加热器的根URL。理想情况下，她会看到一个漂亮的以爱沙尼亚语为母语的用户界面，这让她能够立即知道哪个按钮可以打开加热。在这种情况下，一个干净且以用户为中心的Web界面可以解决第三个问题，因为人类能够阅读并理解如何操作。第二个问题也会由网页解决，它会硬编码发送到哪个端点的请求。
- en: 'But what if the heater has no user interface, only a RESTful API?^([[1](#ch08fn01)])
    Because Lena is an experienced front-end developer and never watches TV, she decides
    to build a simple JavaScript app to control the heater. Now she faces the second
    problem: even though she knows the URL of the heater, how can she find out the
    structure of the heater API? What resources (endpoints) are available? Which verbs
    can she send to which resource? How can she specify the temperature she wants
    to set? How does she know if those parameters need to be in Celsius or Fahrenheit
    degrees?'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果加热器没有用户界面，只有RESTful API呢？^([[1](#ch08fn01)]) 因为Lena是一位经验丰富的前端开发者，而且从不看电视，她决定构建一个简单的JavaScript应用程序来控制加热器。现在她面临第二个问题：尽管她知道加热器的URL，但她如何找到加热器API的结构？有哪些资源（端点）可用？她可以向哪个资源发送哪些动词？她如何指定她想要设置的温度？她如何知道这些参数是否需要以摄氏度或华氏度表示？
- en: ¹
  id: totrans-717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-718
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If the manager ever finds this out, he should probably fire the guy who was
    responsible for selecting this heater in the first place because it fails to address
    design rule #2 of [chapter 6](kindle_split_014.html#ch06) by not providing a user
    interface.'
  id: totrans-719
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果经理发现了这一点，他可能应该解雇最初负责选择这个加热器的人，因为这个加热器没有提供用户界面，未能满足第6章中提到的设计规则#2。
- en: Usually, application developers rely on written documentation that describes
    the various API endpoints and resources available on the Thing (problem 2) and
    the meaning of those (problem 3). But in some cases, a more automated way to discover
    the resources of a REST API at runtime might be useful. If there was a way for
    Lena—or the app she wrote—to interrogate on the fly any web Thing and find out
    what services/data it offers, without having to read the documentation, her app
    would work with any heating device, regardless of its manufacturer.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用开发者依赖于描述事物上可用的各种API端点和资源的书面文档（问题2）以及它们的含义（问题3）。但在某些情况下，一种更自动化的方式在运行时发现REST
    API的资源可能是有用的。如果Lena——或者她编写的应用程序——能够即时查询任何Web事物并找出它提供的服务/数据，而不必阅读文档，那么她的应用程序就可以与任何加热设备一起工作，无论其制造商如何。
- en: Providing a web-based solution for these three problems is the goal of the Find
    layer, as shown in [figure 8.2](#ch08fig02). In the rest of this chapter, we’ll
    propose a set of tools and techniques for how web Things can expose their data
    resource so that users, applications, and Things can easily find and interact
    with them.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 为这三个问题提供基于Web的解决方案是查找层的目标，如图8.2所示。在本章的其余部分，我们将提出一套工具和技术，以展示Web事物如何暴露其数据资源，使用户、应用程序和事物能够轻松找到并与之交互。
- en: Figure 8.2\. The Find layer of the Web of Things. This layer relates to how
    one can easily understand the nature of things, what they relate to, how to access
    their documentation, what their API endpoints are, and how to access those (what
    parameters and their types). It also relates to the meaning of these properties
    in a standard way.
  id: totrans-722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2\. 物联网的查找层。这一层涉及如何轻松理解事物的本质，它们之间的关系，如何访问它们的文档，它们的API端点是什么，以及如何访问这些端点（包括参数及其类型）。它还涉及以标准方式解释这些属性的意义。
- en: '![](08fig02_alt.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig02_alt.jpg)'
- en: 8.2\. Discovering Things
  id: totrans-724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 事物发现
- en: 'We begin our journey in findability by comparing several solutions to the bootstrap
    problem. In short, how can an app or Thing find the root URL of a web Thing it
    has never encountered before? This problem deals with two scopes: first, how to
    find web Things that are physically nearby—for example, within the same local
    network—and second, how to find web Things that are not in the same local network—for
    example, find devices over the web. Finding web Things in a local network can
    be done using network discovery methods described in [section 8.2.1](#ch08lev2sec1).
    To find web Things beyond the same local network, we’ll rely on resource discovery
    and search, as described in [section 8.2.2](#ch08lev2sec2). Let’s now look at
    these methods in more detail.'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从比较几个用于引导问题的解决方案开始我们的查找之旅。简而言之，一个应用或事物如何找到它之前从未遇到过的Web事物的根URL？这个问题涉及两个范围：首先，如何找到物理上附近（例如，在同一本地网络内）的Web事物；其次，如何找到不在同一本地网络中的Web事物——例如，通过互联网找到设备。在本地网络中查找Web事物可以使用[第8.2.1节](#ch08lev2sec1)中描述的网络发现方法来完成。为了找到同一本地网络之外的Web事物，我们将依赖于资源发现和搜索，如[第8.2.2节](#ch08lev2sec2)所述。现在让我们更详细地看看这些方法。
- en: 8.2.1\. Network discovery
  id: totrans-726
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1\. 网络发现
- en: In a computer network, the ability to automatically discover new participants
    is common. In your LAN at home, as soon as a device connects to the network, it
    automatically gets an IP address using *DHCP^([[2](#ch08fn02)])* (*Dynamic Host
    Configuration Protocol*). But only the DHCP server knows the device is in your
    network, so what about the other hosts in your network? Once the device has an
    IP address, it can then broadcast data packets that can be caught by other machines
    on the same network. As you saw in [chapter 5](kindle_split_012.html#ch05), a
    broadcast or multicast of a message means that this message isn’t sent to a particular
    IP address but rather to a group of addresses (multicast) or to everyone (broadcast),
    which is done over UDP. This announcement process is called a network discovery
    protocol, and it allows devices and applications to find each other in local networks.
    This process is commonly used by various discovery protocols such as multicast
    Domain Name System (mDNS),^([[3](#ch08fn03)]) Digital Living Network Alliance
    (DLNA),^([[4](#ch08fn04)]) and Universal Plug and Play (UPnP).^([[5](#ch08fn05)])
    For example, most internet-connected TVs and media players can use DLNA to discover
    network-attached storage (NAS) in your network and read media files from it. Likewise,
    your laptop can find and configure printers on your network with minimal effort
    thanks to network-level discovery protocols such as Apple Bonjour that are built
    into iOS and OSX.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机网络中，自动发现新参与者的能力很常见。在你家里的局域网中，一旦设备连接到网络，它就会自动使用 *DHCP^([[2](#ch08fn02)])*
    (*动态主机配置协议*) 获取一个 IP 地址。但只有 DHCP 服务器知道设备在你的网络中，那么你的网络中的其他主机怎么办？一旦设备有了 IP 地址，它就可以广播数据包，这些数据包可以被同一网络上的其他机器捕获。正如你在[第
    5 章](kindle_split_012.html#ch05)中看到的，消息的广播或多播意味着这个消息不是发送到特定的 IP 地址，而是发送到一组地址（多播）或发送给所有人（广播），这是通过
    UDP 完成的。这个过程被称为网络发现协议，它允许设备和应用程序在本地网络中找到彼此。这个过程通常被各种发现协议使用，如多播域名系统 (mDNS)^([[3](#ch08fn03)]),
    数字生活网络联盟 (DLNA)^([[4](#ch08fn04)]), 和通用即插即用 (UPnP)^([[5](#ch08fn05)]). 例如，大多数互联网连接的电视和媒体播放器可以使用
    DLNA 来发现网络附加存储 (NAS) 并从中读取媒体文件。同样，你的笔记本电脑可以通过内置在 iOS 和 OSX 中的网络级发现协议，如 Apple Bonjour，以最小的努力找到并配置网络中的打印机。
- en: ²
  id: totrans-728
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-729
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'DHCP: [http://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol](http://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol).'
  id: totrans-730
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'DHCP: [动态主机配置协议](http://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol).'
- en: ³
  id: totrans-731
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-732
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Multicast_DNS](http://en.wikipedia.org/wiki/Multicast_DNS)'
  id: totrans-733
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[多播 DNS](http://en.wikipedia.org/wiki/Multicast_DNS)'
- en: ⁴
  id: totrans-734
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-735
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Digital_Living_Network_Alliance](http://en.wikipedia.org/wiki/Digital_Living_Network_Alliance)'
  id: totrans-736
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[数字生活网络联盟](http://en.wikipedia.org/wiki/Digital_Living_Network_Alliance)'
- en: ⁵
  id: totrans-737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-738
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Universal_Plug_and_Play](http://en.wikipedia.org/wiki/Universal_Plug_and_Play)'
  id: totrans-739
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[通用即插即用](http://en.wikipedia.org/wiki/Universal_Plug_and_Play)'
- en: mDNS
  id: totrans-740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: mDNS
- en: In mDNS, clients can discover new devices on a network by listening for mDNS
    messages such as the one in the following listing. The client populates the local
    DNS tables as messages come in, so, once discovered, the new service—here a web
    page of a printer—can be used via its local IP address or via a URI usually ending
    with the .local domain. In this example, it would be [http://evt-bw-brother.local](http://evt-bw-brother.local).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在 mDNS 中，客户端可以通过监听如以下列表中的 mDNS 消息来发现网络上的新设备。随着消息的到来，客户端填充本地 DNS 表，因此一旦发现，新的服务——这里是一个打印机的网页——可以通过其本地
    IP 地址或通过通常以 .local 域名结尾的 URI 来使用。在这个例子中，它将是 [http://evt-bw-brother.local](http://evt-bw-brother.local)。
- en: Listing 8.1\. An mDNS message from a printer
  id: totrans-742
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.1\. 来自打印机的 mDNS 消息
- en: '![](218fig01_alt.jpg)'
  id: totrans-743
  prefs: []
  type: TYPE_IMG
  zh: '![](218fig01_alt.jpg)'
- en: This is also the protocol that your Pi uses to broadcast its raspberrypi.local
    URL (see [chapter 4](kindle_split_011.html#ch04)) to all nearby computers listening
    with an mDNS client.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是你的 Pi 使用来广播其 raspberrypi.local URL 的协议（见[第 4 章](kindle_split_011.html#ch04)），向所有使用
    mDNS 客户端监听的附近计算机。
- en: 'The limitation of mDNS, and of most network-level discovery protocols, is that
    the network-level information can’t be directly accessed from the web. You could,
    of course, write JavaScript code that relies on predefined .local domains, but
    this would be merely a hack not supported by all browsers. This is also the reason
    why many mobile browsers can’t resolve these addresses: they don’t have an mDNS
    client populating the local DNS record in the background.'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: mDNS和大多数网络级发现协议的限制在于，网络级信息不能直接从网络中访问。当然，你可以编写依赖于预定义的.local域名的JavaScript代码，但这仅仅是一个所有浏览器都不支持的hack。这也是为什么许多移动浏览器无法解析这些地址的原因：它们没有mDNS客户端在后台填充本地DNS记录。
- en: '|  |'
  id: totrans-746
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The nerd corner—I want my Pi to say “Bonjour!”**'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术角落——我想让我的Pi说“Bonjour!”**'
- en: Your Pi already enables mDNS via the Avahi library to broadcast its .local URL,
    but you could do a lot more with mDNS, such as describing the HTTP services your
    WoT server provides (just like for the printer in [listing 8.1](#ch08ex01)). The
    experimental `node_mdns` Node library^([[a](#ch08fn1a)]) builds on top of Avahi
    and lets you programmatically implement this and more. To get started with the
    library, look at the code sample we provided in the mdns folder of this chapter
    on GitHub.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Pi已经通过Avahi库启用mDNS来广播其.local URL，但您可以使用mDNS做更多的事情，例如描述您的WoT服务器提供的HTTP服务（就像[列表8.1](#ch08ex01)中的打印机一样）。实验性的`node_mdns`
    Node库^([[a](#ch08fn1a)])建立在Avahi之上，让您能够以编程方式实现这一点以及更多。要开始使用此库，请查看我们在GitHub上此章节的mdns文件夹中提供的代码示例。
- en: ^a
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-750
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/agnat/node_mdns](https://github.com/agnat/node_mdns).'
  id: totrans-751
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://github.com/agnat/node_mdns](https://github.com/agnat/node_mdns).'
- en: 'Note: this module doesn’t always run smoothly on the Pi, so you might have
    to fall back to your PC. If you’d still like to try it on the Pi, make sure you
    install the additionally required Debian packages via `apt-get install libavahi-compat-libdnssd-dev`.'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：此模块在Pi上不一定运行顺畅，因此您可能需要回退到您的PC。如果您仍然想在Pi上尝试，请确保通过`apt-get install libavahi-compat-libdnssd-dev`安装所需的额外Debian软件包。
- en: '|  |'
  id: totrans-753
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Network discovery on the web
  id: totrans-754
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 网络发现
- en: If mDNS doesn’t work in all browsers, how can a web application running on your
    mobile phone or tablet find nearby web Things? Or, why can’t you find the web
    Things in your house by following links on a page? An easy solution would be to
    write a custom plugin for Firefox or Chrome that can talk to those network-level
    discovery protocols. But this doesn’t solve the problem because in place of enabling
    web-based resource discovery using web standards, devices would still need to
    implement one or more non-web network discovery protocols. In consequence, web
    Thing client applications would also need to speak and understand these protocols,
    which defeats the purpose of the Web of Things.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 如果mDNS在所有浏览器上都不工作，那么运行在您的手机或平板电脑上的Web应用程序如何找到附近的Web设备？或者，为什么您不能通过页面上的链接找到家中的Web设备？一个简单的解决方案是为Firefox或Chrome编写一个自定义插件，使其能够与这些网络级发现协议通信。但这并不能解决问题，因为代替使用基于Web标准的基于Web的资源发现，设备仍然需要实现一个或多个非Web网络发现协议。结果，Web设备客户端应用程序也需要能够使用和了解这些协议，这违背了物联网的目的。
- en: Because HTTP is an Application layer protocol, it doesn’t know a thing about
    what’s underneath—the network protocols used to shuffle HTTP requests around.
    It also doesn’t need to care—that is, unless a web Thing or application needs
    to know about other resources in the same network. The real question here is why
    the configuration and status of a router is only available through a web page
    for humans and not accessible via a REST API. Put simply, why don’t all routers
    also offer a secure API where its configuration can be seen and changed by others’
    devices and applications in your network?
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 因为HTTP是一个应用层协议，它对底层的网络协议一无所知——这些协议用于在网络中移动HTTP请求。它也不需要关心这一点——除非一个网络设备或应用程序需要了解同一网络中的其他资源。真正的问题是，为什么路由器的配置和状态只能通过网页供人类访问，而不能通过REST
    API访问。简单来说，为什么不是所有的路由器都提供一种安全的API，允许网络中的其他设备和应用程序查看和更改其配置？
- en: Providing such an API is easy to do.^([[6](#ch08fn06)]) For example, you can
    install an open-source operating system for routers such as OpenWrt^([[7](#ch08fn07)])
    and modify the software to expose the IP addresses assigned by the DHCP server
    of the router as a JSON document. This way, you use the existing HTTP server of
    your router to create an API that exposes the IP addresses of all the devices
    in your network. This makes sense because almost all networked devices today,
    from printers to routers, already come with a web user interface. Other devices
    and applications can then retrieve the list of IP addresses in the network via
    a simple HTTP call (step 2 in [figure 8.3](#ch08fig03)) and then retrieve the
    metadata of each device in the network by using their IP address (step 3 of [figure
    8.3](#ch08fig03)).
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 提供这样的API做起来很简单.^([[6](#ch08fn06)]) 例如，你可以安装一个针对路由器的开源操作系统，如OpenWrt^([[7](#ch08fn07)))，并修改软件以将路由器DHCP服务器分配的IP地址作为JSON文档暴露出来。这样，你就可以利用路由器现有的HTTP服务器创建一个API，该API暴露了你网络中所有设备的IP地址。这样做是有意义的，因为今天几乎所有联网设备，从打印机到路由器，都已经配备了Web用户界面。其他设备和应用程序可以通过简单的HTTP调用（[图8.3](#ch08fig03)中的步骤2）检索网络中的IP地址列表，然后通过使用它们的IP地址检索网络中每个设备的元数据（[图8.3](#ch08fig03)中的步骤3）。
- en: ⁶
  id: totrans-758
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-759
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This was proposed in Vlad’s PhD thesis: [http://www.slideshare.net/vladounet/vlad-trifa-final-phd-thesis-defense-at-eth-zurich](http://www.slideshare.net/vladounet/vlad-trifa-final-phd-thesis-defense-at-eth-zurich).'
  id: totrans-760
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这一想法在Vlad的博士论文中提出：[Vlad Trifa在苏黎世联邦理工学院最终博士论文答辩](http://www.slideshare.net/vladounet/vlad-trifa-final-phd-thesis-defense-at-eth-zurich)。
- en: ⁷
  id: totrans-761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-762
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://openwrt.org/](https://openwrt.org/)'
  id: totrans-763
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[OpenWrt官网](https://openwrt.org/)'
- en: Figure 8.3\. LAN-level resource discovery. Assuming that all web Things expose
    their root resource on port 80, web Thing clients can get their IPs from the router
    and then query each device to extract their metadata.
  id: totrans-764
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.3\. 局域网级别的资源发现。假设所有Web Things都在端口80上暴露它们的根资源，Web Things客户端可以从路由器获取它们的IP地址，然后查询每个设备以提取它们的元数据。
- en: '![](08fig03_alt.jpg)'
  id: totrans-765
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig03_alt.jpg)'
- en: Because routers usually have the base network address of the local network,
    you can easily write a web app that periodically queries the routing table, keeps
    track of the new devices connected to the network, and registers the devices in
    the network. The same pattern can be used with any other device on the network,
    where any web Thing—say, a set-top box or NAS—could continuously search for new
    devices in the network using various protocols, understand their services, and
    then act as a bridge to these devices by generating on the fly a new WoT API for
    those devices.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路由器通常具有本地网络的基址，你可以轻松编写一个Web应用程序，该应用程序定期查询路由表，跟踪连接到网络的新的设备，并在网络中注册设备。相同的模式可以用于网络上的任何其他设备，其中任何Web
    Things——比如机顶盒或NAS——都可以使用各种协议连续搜索网络中的新设备，理解它们提供的服务，然后通过动态生成针对这些设备的新WoT API来作为这些设备的桥梁。
- en: 8.2.2\. Resource discovery on the web
  id: totrans-767
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2\. 网络资源发现
- en: 'Although network discovery does the job locally, it doesn’t propagate beyond
    the boundaries of local networks. Thinking in wider terms, several questions remain
    open: in a Web of Things with billions of Things accessible on the World Wide
    Web, how do we find new Things when they connect, how do we understand the services
    they offer, and can we search for the right Things and their data in composite
    applications?'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然网络发现可以在本地完成任务，但它不会传播到本地网络之外。从更广泛的角度来看，还有一些问题悬而未决：在一个有数十亿设备可以通过万维网访问的物联网中，当新设备连接时，我们如何找到它们，我们如何理解它们提供的服务，我们能否在复合应用程序中搜索正确的设备和它们的数据？
- en: The web faced a similar challenge when it shifted from a catalog of a few thousand
    pages with text and images in the early nineties to an exponentially growing collection
    of web applications, documents, and multimedia content including movies and music,
    games, and other service types. In those early days, AltaVista and Yahoo were
    successful in curating this growing collection of documents. But as the web started
    to grow exponentially, it became obvious that managing the list of resources on
    the web manually was a dead end. Around this time (~1998), Google appeared out
    of nowhere and pretty much wiped out any other search engine because it could
    automatically index millions of pages and allow users to rapidly and accurately
    find relevant content in this massive catalog.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络在九十年代初从仅有几千页包含文本和图像的目录转变为指数级增长的包含网络应用、文档和多媒体内容的集合，包括电影、音乐、游戏和其他服务类型时，它面临了类似的挑战。在那些早期，AltaVista
    和 Yahoo 成功地整理了这一不断增长的文档集合。但随着网络的指数级增长，很明显，手动管理网络上的资源列表是一条死胡同。大约在这个时候（~1998年），Google
    突然出现，几乎消灭了任何其他搜索引擎，因为它能够自动索引数百万页，并允许用户快速准确地在这个庞大的目录中找到相关内容。
- en: On the web, new resources (pages) are discovered through hyperlinks. Search
    engines periodically parse all the pages in their database to find outgoing links
    to other pages. As soon as a link to a page not yet indexed is found, that new
    page is parsed and added to directory. This process is known as *web crawling*.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上，新资源（页面）是通过超链接发现的。搜索引擎定期解析其数据库中的所有页面，以找到指向其他页面的出站链接。一旦发现指向尚未索引的页面的链接，该新页面就会被解析并添加到目录中。这个过程被称为*网络爬虫*。
- en: Crawling the API of web Things
  id: totrans-771
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 爬取网络事物的API
- en: 'We can apply the process of web crawling to Things as well: in [chapter 2](kindle_split_009.html#ch02)
    you used an HTML-based UI for the WoT Pi, and in [chapter 5](kindle_split_012.html#ch05)
    you saw how to create HTML representations of resources. By adding links to the
    sub-resources in the HTML code, we make it possible to crawl web Things with the
    simple pseudo-code shown in the next listing.'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将网络爬虫的过程应用到事物上：在[第2章](kindle_split_009.html#ch02)中，你使用了基于HTML的用户界面来为WoT
    Pi，而在[第5章](kindle_split_012.html#ch05)中，你看到了如何创建资源的HTML表示。通过在HTML代码中添加子资源的链接，我们使得使用下一列表中所示简单伪代码来爬取网络事物成为可能。
- en: Listing 8.2\. Pseudocode for crawling the HTML representation of Things
  id: totrans-773
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2\. 爬取事物HTML表示的伪代码
- en: '[PRE40]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: From the root HTML page of the web Thing, the crawler can find the sub-resources,
    such as sensors and actuators, by discovering outgoing links and can then create
    a resource tree of the web Thing and all its resources. The crawler then uses
    the HTTP `OPTIONS` method to retrieve all verbs supported for each resource of
    the web Thing. Finally, the crawler uses content negotiation to understand which
    format is available for each resource. As an exercise, we suggest you try implementing
    this crawler for the API of the Pi you created in [chapter 7](kindle_split_015.html#ch07).
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络事物的根HTML页面开始，爬虫可以通过发现出站链接来找到子资源，例如传感器和执行器，然后可以创建网络事物及其所有资源的资源树。然后，爬虫使用HTTP
    `OPTIONS`方法检索网络事物每个资源支持的动词。最后，爬虫使用内容协商来了解每个资源可用的格式。作为一个练习，我们建议你尝试实现用于你在[第7章](kindle_split_015.html#ch07)中创建的Pi的API的此爬虫。
- en: HATEOAS and web linking
  id: totrans-776
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: HATEOAS和网页链接
- en: This simple crawling approach is a good start, but it also has several limitations.
    First, all links are treated equally because there’s no notion of the *nature*
    of a link; the link to the user interface and the link to the actuator resource
    look the same—they’re just URLs. Then, it requires the web Thing to offer an HTML
    interface, which might be too heavy for resource-constrained devices. Finally,
    it also means that a client needs to both understand HTML and JSON to work with
    our web Things.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的爬取方法是一个良好的开始，但它也有几个局限性。首先，所有链接都被同等对待，因为没有关于链接*性质*的概念；用户界面和执行器资源的链接看起来相同——它们只是URL。然后，它要求网络事物提供一个HTML界面，这可能对资源受限的设备来说太重了。最后，这也意味着客户端需要理解HTML和JSON才能与我们的网络事物一起工作。
- en: A better solution for discovering the resources of any REST API is to use the
    HATEOAS principle we presented in [section 6.1.6](kindle_split_014.html#ch06lev2sec6)
    to describe relationships between the various resources of a web Thing. A simple
    method to implement HATEOAS with REST APIs is to use the mechanism of *web linking*
    defined in RFC 5988.^([[8](#ch08fn08)]) The idea is that the response to any HTTP
    request to a resource always contains a set of links to related resources—for
    example, the *previous*, *next*, or *last* page that contains the results of a
    search. These links would be contained in the `Link:` HTTP header of the response.
    Although a similar mechanism was already supported with the `LINK`^([[9](#ch08fn09)])
    element in the HTML 4 specification, encoding the links as HTTP headers introduces
    a more general framework to define relationships between resources outside the
    representation of the resource—directly at the HTTP level. As a result, links
    can be always described in the same way regardless of the media type requested
    by the client, such as JSON or HTML. This type of linking is also the one supported
    by the Constrained Application Protocol we discussed in the previous chapters.^([[10](#ch08fn10)])
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 发现任何REST API资源的更好解决方案是使用我们在[第6.1.6节](kindle_split_014.html#ch06lev2sec6)中提出的HATEOAS原则来描述Web
    Thing各种资源之间的关系。实现HATEOAS的简单方法是在RFC 5988中定义的*Web链接*机制。其思想是，对任何资源发出的HTTP请求的响应总是包含一组相关资源的链接——例如，包含搜索结果的*上一页*、*下一页*或*最后一页*。这些链接将包含在响应的`Link:`
    HTTP头中。尽管HTML 4规范中的`LINK`元素已经支持了类似的机制，但将链接编码为HTTP头引入了一个更通用的框架来定义资源表示之外的资源之间的关系——直接在HTTP级别。因此，无论客户端请求的媒体类型如何，如JSON或HTML，链接都可以始终以相同的方式进行描述。这种类型的链接也是我们在前几章中讨论的约束应用协议所支持的。^([[8](#ch08fn08)])
- en: ⁸
  id: totrans-779
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-780
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://tools.ietf.org/html/rfc5988](https://tools.ietf.org/html/rfc5988)'
  id: totrans-781
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://tools.ietf.org/html/rfc5988](https://tools.ietf.org/html/rfc5988)'
- en: ⁹
  id: totrans-782
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-783
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.w3.org/TR/html401/struct/links.html#edef-LINK](http://www.w3.org/TR/html401/struct/links.html#edef-LINK)'
  id: totrans-784
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.w3.org/TR/html401/struct/links.html#edef-LINK](http://www.w3.org/TR/html401/struct/links.html#edef-LINK)'
- en: ^(10)
  id: totrans-785
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10)
- en: ''
  id: totrans-786
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://tools.ietf.org/html/rfc6690](https://tools.ietf.org/html/rfc6690)'
  id: totrans-787
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://tools.ietf.org/html/rfc6690](https://tools.ietf.org/html/rfc6690)'
- en: 'When doing an HTTP GET on any Web Thing, the response should include a `Link`
    header that contains links to related resources. In particular, you should be
    able to get information about the device, its resources (API endpoints), and the
    documentation of the API using only `Link` headers. Following is an example HTTP
    query sent to a WoT gateway:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 当对任何Web Thing执行HTTP GET操作时，响应应包含一个包含相关资源链接的`Link`头。特别是，你应该能够仅通过`Link`头获取有关设备、其资源（API端点）和API文档的信息。以下是一个发送到WoT网关的示例HTTP查询：
- en: '[PRE41]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, the response contains a set of links to the resources of the
    web Thing in the `Link` header. The URL of each resource is contained between
    angle brackets (`<URL>`) and the type of the link is denoted by `rel="X"`, where
    `X` is the type of the relation. If the URL is not an absolute URL—that is, it
    doesn’t start with http:// or https://—it’s interpreted in the context of the
    current request path, to which the relative URL will be appended. In this example,
    the documentation of the web Thing will therefore become `devices.webofthings.io/help`.
    Note that the link element can be any valid URI and therefore could well be hosted
    on the device itself, on a gateway, or anywhere else on the web. Some reserved
    and standardized relationship types are defined by IANA, but those are mainly
    relevant to the classic web of multimedia documents. Because no set of relationship
    types has been proposed for physical objects and for the Web of Things, we’ll
    propose one in this chapter. In the previous example, you could see that the root
    page of the Web of Things gateway contains links to the following four resources.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，响应包含了一组链接到Web Thing资源的`Link`头。每个资源的URL包含在尖括号`<URL>`之间，链接的类型由`rel="X"`表示，其中`X`是关系的类型。如果URL不是绝对URL——也就是说，它不以http://或https://开头——它将在当前请求路径的上下文中被解释，相对URL将被附加到该路径。在本例中，Web
    Thing的文档因此将成为`devices.webofthings.io/help`。请注意，链接元素可以是任何有效的URI，因此它可能托管在设备本身、网关或网络上的任何其他地方。一些保留和标准化的关系类型由IANA定义，但这些主要与经典的多媒体文档网络相关。因为尚未为物理对象和物联网提出一套关系类型，所以我们将在本章中提出一套。在前面的例子中，你可以看到物联网网关的根页面包含了对以下四个资源的链接。
- en: rel=“model”
  id: totrans-791
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: rel=“model”
- en: This is a link to a Web Thing Model resource; see [section 8.3.1](#ch08lev2sec3).
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个指向Web Thing模型资源的链接；参见[第8.3.1节](#ch08lev2sec3)。
- en: rel=“type”
  id: totrans-793
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: rel=“type”
- en: This is a link to a resource that contains additional metadata about this web
    Thing.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含关于此Web Thing的额外元数据的资源的链接。
- en: rel=“help”
  id: totrans-795
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: rel=“help”
- en: 'This relationship type is a link to the documentation, which means that a GET
    to `devices.webofthings.io/help` would return the documentation for the API in
    a human-friendly (HTML) or machine-readable (JSON) format. The documentation doesn’t
    need to be hosted on the device itself but could be hosted anywhere—for example,
    on the manufacturer’s website, in which case the header would look like this:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系类型是一个指向文档的链接，这意味着对`devices.webofthings.io/help`的GET请求将返回API的文档，以人类友好（HTML）或机器可读（JSON）的格式。文档不需要在设备本身上托管，但可以托管在任何地方——例如，在制造商的网站上，在这种情况下，标题将如下所示：
- en: '[PRE42]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This allows maintaining and continuously updating the documentation of multiple
    devices deployed in the wild and running various firmware versions, without the
    need to host it directly on the device but in the cloud.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许维护和持续更新在野外部署的多个设备及其各种固件版本的文档，而无需直接在设备上托管，而是在云端托管。
- en: rel=“ui”
  id: totrans-799
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: rel=“ui”
- en: 'This relationship type is a link to a graphical user interface (GUI) for interacting
    with the web Thing. The UI must be implemented using HTML so that it can be accessed
    with any browser, and it should be responsive to allow various device types to
    interact with the web Thing. Note that the GUI can—but doesn’t have to—be hosted
    on the device itself as long as the GUI application can access the web Thing and
    its resources. In the following example, the GUI is hosted on GitHub and takes
    as a parameter the root URL of the web Thing to control:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系类型是一个指向与Web Thing交互的图形用户界面（GUI）的链接。用户界面必须使用HTML实现，以便任何浏览器都可以访问，并且它应该能够响应，以便各种设备类型可以与Web
    Thing交互。请注意，GUI可以（但不一定）在设备本身上托管，只要GUI应用程序可以访问Web Thing及其资源。在以下示例中，GUI托管在GitHub上，并接受要控制的Web
    Thing的根URL作为参数：
- en: '[PRE43]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In some situations you won’t be able to modify the HTTP headers of the response
    returned by a web Thing. If this is the case, you’ll need to insert them in the
    HTML or JSON representation of the resource. We’ll show how you do this in [sections
    8.3.3](#ch08lev2sec5) for JSON and [8.4.1](#ch08lev2sec10) for HTML.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能无法修改Web Thing返回的响应的HTTP头。如果是这种情况，您需要在资源的HTML或JSON表示中插入它们。我们将在[第8.3.3节](#ch08lev2sec5)（针对JSON）和[第8.4.1节](#ch08lev2sec10)（针对HTML）中展示如何这样做。
- en: 8.3\. Describing web Things
  id: totrans-803
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3. 描述Web Thing
- en: 'The ability to discover the root URL and resources of a web Thing solves the
    first part of the findability problem and is enough to interact with the web Thing
    if it provides a user interface—the root URL returns an HTML page. But knowing
    only the root URL is insufficient to interact with the Web Thing API because we
    still need to solve the second problem mentioned at the beginning of this chapter:
    how can an application know which payloads to send to which resources of a web
    Thing? In other words, what possible parameters and their type are supported by
    each end point, what will be the effect of a given request, what possible error/success
    messages will be returned, and what do those mean?'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 发现Web Thing的根URL和资源的能力解决了可发现问题的第一部分，如果它提供了一个用户界面，那么仅此就足以与Web Thing交互——根URL返回一个HTML页面。但只知道根URL是不够的，因为我们需要解决本章开头提到的第二个问题：应用程序如何知道应该向Web
    Thing的哪些资源发送哪些有效负载？换句话说，每个端点支持哪些可能的参数及其类型，给定的请求会产生什么效果，将返回哪些可能的错误/成功消息，以及这些意味着什么？
- en: 'This question can be summarized as follows: how can we formally describe the
    API offered by any web Thing? As you can see in [figure 8.4](#ch08fig04), there
    are various ways to do this, ranging from no shared data model between the API
    of a web Thing (1), all the way to semantically defining every possible interaction
    with a web Thing (4). Semantic Web Things maximize interoperability by ensuring
    that client applications can discover new Things and use them at runtime automatically,
    without any human in the loop.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以总结如下：我们如何正式描述任何Web Thing提供的API？正如您在[图8.4](#ch08fig04)中看到的那样，有各种方法可以做到这一点，从Web
    Thing API之间没有共享数据模型（1）到语义上定义与Web Thing的每一种可能的交互（4）。语义WebThing通过确保客户端应用程序可以自动发现新的Thing并在运行时使用它们，从而最大化互操作性，无需人工介入。
- en: Figure 8.4\. The various levels for describing web Things. Any device can have
    an HTTP API (1). Web Things (2) are HTTP servers that follow the requirements
    proposed in [chapter 6](kindle_split_014.html#ch06); thus, APIs are more consistent,
    predictable, and easier to use. Using a shared model will make the web Thing more
    interoperable (3). Finally, adding semantic annotations will ensure stronger contracts
    between web Things and also more flexibility to define formally each element of
    the web Thing API (4).
  id: totrans-806
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.4. 描述 Web Thing 的不同级别。任何设备都可以有一个 HTTP API（1）。Web Thing（2）是遵循[第6章](kindle_split_014.html#ch06)中提出的要求的
    HTTP 服务器；因此，API 更一致、可预测且易于使用。使用共享模型将使 Web Thing 更具互操作性（3）。最后，添加语义注解将确保 Web Thing
    之间有更强的合同，同时也为正式定义 Web Thing API 的每个元素提供更多灵活性（4）。
- en: '![](08fig04_alt.jpg)'
  id: totrans-807
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig04_alt.jpg)'
- en: The simplest solution is to provide a written documentation for the API of your
    web Thing so that developers can use it (1 and 2 in [figure 8.4](#ch08fig04)).
    This implies that a developer must read the documentation about your web Thing,
    understand what requests they can send to it and what each does, and finally implement
    the various API calls with correct parameters for each call. This approach, however,
    is insufficient to automatically find new devices, understand what they are, and
    what services they offer. In addition, manual implementation of the payloads is
    more error-prone because the developer needs to ensure that all the requests they
    send are valid. This becomes especially tricky when the API documentation differs
    from the actual API running on the device, which can happen when the API changes
    but not the documentation. Or simply when the documentation is...hmm...ungracious
    in the first place. Sadly, most APIs in the Internet of Things are in this situation
    because they don’t make it easy or even possible to write applications that can
    dynamically generate a user interface for a device only by knowing its root URL.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案是为您的 Web Thing 的 API 提供书面文档，以便开发者可以使用它（[图8.4](#ch08fig04)中的1和2）。这意味着开发者必须阅读有关您的
    Web Thing 的文档，了解他们可以向其发送哪些请求以及每个请求的作用，并最终使用正确的参数实现各种 API 调用。然而，这种方法不足以自动发现新设备，了解它们是什么以及它们提供的服务。此外，手动实现有效载荷更容易出错，因为开发者需要确保他们发送的所有请求都是有效的。当
    API 文档与设备上实际运行的 API 不同时，这尤其棘手，这可能发生在 API 发生变化但文档没有变化的情况下。或者简单地说，当文档一开始就……嗯……不够友好。遗憾的是，物联网中的大多数
    API 都处于这种状况，因为它们没有使编写仅通过了解其根 URL 就能动态生成设备用户界面的应用程序变得容易或甚至可能。
- en: 'As will be shown in the rest of this chapter, all hope is not lost—quite the
    opposite! By using a unique data model to define formally the API of any web Thing
    (the Web Thing Model) as described in [section 8.3.2](#ch08lev2sec4), we’ll have
    a powerful basis to describe not only the metadata but also the operations of
    any web Thing in a standard way (cases 3 and 4 of [figure 8.4](#ch08fig04)). This
    is the cornerstone of the Web of Things: creating a model to describe physical
    Things with the right balance between expressiveness—how flexible the model is—and
    usability—how easy it is to describe *any* web Thing with that model. Achieving
    this balance is necessary in order to achieve global-scale interoperability and
    adoption, and this is what we’ll do in the remainder of this chapter.'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章其余部分将要展示的，并非所有的希望都已丧失——恰恰相反！通过使用一个独特的数据模型来正式定义任何 Web Thing 的 API（如[8.3.2节](#ch08lev2sec4)所述的
    Web Thing 模型），我们将拥有一个强大的基础来以标准方式描述任何 Web Thing 的元数据和操作（[图8.4](#ch08fig04)中的案例3和4）。这是物联网的基石：创建一个模型来描述物理事物，在表达性——模型有多灵活——和可用性——使用该模型描述任何
    Web Thing 有多容易——之间取得适当的平衡。实现这种平衡对于实现全球规模的互操作性和采用是必要的，这也是本章剩余部分我们将要做的。
- en: 8.3.1\. Introducing the Web Thing Model
  id: totrans-810
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1. 介绍 Web Thing 模型
- en: Once we find a web Thing and understand its API structure, we still need a method
    to describe what that device is and does. In other words, we need a conceptual
    model of a web Thing that can describe the resources of a web Thing using a set
    of well-known concepts.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到一个 Web Thing 并了解其 API 结构，我们仍然需要一个方法来描述该设备是什么以及它能做什么。换句话说，我们需要一个 Web Thing
    的概念模型，它可以使用一组公认的概念来描述 Web Thing 的资源。
- en: In the previous chapters, we showed how to organize the resources of a web Thing
    using the `/sensors` and `/actuators` end points. But this works only for devices
    that actually have sensors and actuators, not for complex objects and scenarios
    that are common in the real world that can’t be mapped to actuators or sensors.
    To achieve this, the core model of the Web of Things must be easily applicable
    for any entity in the real world, ranging from packages in a truck, to collectible
    card games, to orange juice bottles. This section provides exactly such a model,
    which is called the *Web Thing Model*.^([[11](#ch08fn11)])
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们展示了如何使用`/sensors`和`/actuators`端点来组织Web Thing的资源。但这只适用于实际上具有传感器和执行器的设备，不适用于现实世界中常见的复杂对象和场景，这些对象和场景无法映射到执行器或传感器。为了实现这一点，物联网的核心模型必须易于应用于现实世界中的任何实体，从卡车上的包裹到收藏卡牌游戏，再到橙汁瓶。本节提供的就是这样一个模型，被称为*Web
    Thing模型*^([11](#ch08fn11)))
- en: ^(11)
  id: totrans-813
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([11](#ch08fn11))
- en: ''
  id: totrans-814
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At the time of writing, the Web Thing Model ([http://model.webofthings.io](http://model.webofthings.io))
    is also an official W3C member submission. This does not mean it is a standard
    yet, but it means it will influence the standardization efforts around the Web
    of Things within the Web of Things Interest Group ([http://www.w3.org/WoT/IG/](http://www.w3.org/WoT/IG/)).
    EVRYTHNG (and hence Vlad and Dom) is part of the Web of Things Interest Group
    at W3C.
  id: totrans-815
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在撰写本文时，Web Thing模型([http://model.webofthings.io](http://model.webofthings.io))也是W3C的一个官方成员提交。这并不意味着它是一个标准，但它的意思是它将影响Web
    of Things兴趣小组([http://www.w3.org/WoT/IG/](http://www.w3.org/WoT/IG/))周围的物联网标准化工作。EVRYTHNG（因此是Vlad和Dom）是W3C物联网兴趣小组的一部分。
- en: Because this model is more abstract and covers more use cases than the ones
    we used in previous chapters, it’s also a bit more complex to understand and use,
    and that’s why we only introduce it now. But don’t worry—by the end of this chapter,
    it will all make sense to you and you’ll see that you can easily adapt it for
    any Web of Things scenario you can think of. Not only that, but with the reference
    implementation of this model you’ll find in this chapter, you’ll also be able
    to implement truly interoperable web Things and WoT applications that reach the
    full potential of the Web of Things. Let’s get started!
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个模型比我们在前几章中使用的模型更抽象，覆盖了更多的用例，因此它也稍微复杂一些，理解和使用起来也更困难，这就是为什么我们只在这里介绍它。但不用担心——到本章结束时，一切都会对你来说变得有意义，你也会看到你可以轻松地将其适应任何你能想到的物联网场景。不仅如此，通过本章中提供的这个模型的参考实现，你还将能够实现真正互操作的物联网和WoT应用，充分发挥物联网的潜力。让我们开始吧！
- en: 'Note that to make it easier for you to discover the Web Thing Model and try
    the examples in this section, we deployed a web Thing in the cloud: [http://gateway.webofthings.io](http://gateway.webofthings.io).
    In the next section, you’ll learn how to implement and run the same web Thing
    server your Pi or laptop, so feel free to revisit these examples on your own web
    Things later.'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了使你更容易发现Web Thing模型并尝试本节中的示例，我们在云中部署了一个Web Thing：[http://gateway.webofthings.io](http://gateway.webofthings.io)。在下一节中，你将学习如何在你自己的Pi或笔记本电脑上实现和运行相同的Web
    Thing服务器，所以你可以随时在自己的物联网上回顾这些示例。
- en: Entities
  id: totrans-818
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实体
- en: 'As we described earlier, the Web of Things is composed of web Things. But what
    is a web Thing concretely? A web Thing is a digital representation of a physical
    object—a Thing—accessible on the web. Think of it like this: your Facebook profile
    is a digital representation of yourself, so a web Thing is the “Facebook profile”
    of a physical object. Examples of web Things are the virtual representations of
    garage door, a bottle of soda, an apartment, a TV, and so on. The web Thing is
    a web resource that can be hosted directly on the device, if it can connect to
    the web, or on an intermediate in the network such as a gateway or a cloud service
    that bridges non-web devices to the web. All web Things should have the following
    resources as illustrated in [figure 8.5](#ch08fig05):'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所描述的，物联网由Web Thing组成。但具体来说，什么是Web Thing呢？Web Thing是物理对象——即实体——的数字表示，可以在网络上访问。可以这样想：你的Facebook个人资料是你自己的数字表示，所以Web
    Thing就是一个物理对象的“Facebook个人资料”。Web Thing的例子包括车库门的虚拟表示、一瓶汽水、一套公寓、一台电视等等。Web Thing是一个可以直接在设备上托管或托管在网络中的中间件（如网关或云服务，它将非网络设备连接到网络）的Web资源。所有Web
    Thing都应该具有以下资源，如图8.5所示：
- en: Figure 8.5\. The resources of a web Thing. Web Thing clients can interact with
    the various resources of the web Thing. The model resource provides metadata for
    discovery, properties are the variables of the Things (data, sensor, state, and
    so on), and actions are the function calls (commands supported by the web Thing).
    When the web Thing is also a gateway to other (non-web) Things, the Thing’s resource
    is a proxy to the non-web Things.
  id: totrans-820
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.5。网络实体的资源。网络实体客户端可以与网络实体的各种资源进行交互。模型资源提供了用于发现的元数据，属性是实体的变量（数据、传感器、状态等），而动作是网络实体支持的功能调用（命令）。当网络实体也是其他（非网络）实体的网关时，实体的资源是代理到非网络实体的。
- en: '![](08fig05_alt.jpg)'
  id: totrans-821
  prefs: []
  type: TYPE_IMG
  zh: '![08fig05_alt.jpg](08fig05_alt.jpg)'
- en: '***Model—*** A web Thing always has a set of metadata that defines various
    aspects about it such as its name, description, or configurations.'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***模型—*** 网络实体始终有一组元数据，用于定义其各个方面，如名称、描述或配置。'
- en: '***Properties—*** A property is a variable of a web Thing. Properties represent
    the internal state of a web Thing. Clients can subscribe to properties to receive
    a notification message when specific conditions are met; for example, the value
    of one or more properties changed.'
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***属性—*** 属性是网络实体中的一个变量。属性代表网络实体的内部状态。客户端可以订阅属性，以便在满足特定条件时接收通知消息；例如，一个或多个属性值发生变化。'
- en: '***Actions—*** An action is a function offered by a web Thing. Clients can
    invoke a function on a web Thing by sending an action to the web Thing. Examples
    of actions are “open” or “close” for a garage door, “enable” or “disable” for
    a smoke alarm, and “scan” or “check in” for a bottle of soda or a place. The direction
    of an action is from the client to the web Thing.'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***动作—*** 动作是网络实体提供的一个函数。客户端可以通过向网络实体发送动作来在网络上调用一个函数。动作的例子包括车库门的“打开”或“关闭”，烟雾报警器的“启用”或“禁用”，以及苏打水瓶或地点的“扫描”或“签到”。动作的方向是从客户端到网络实体。'
- en: '***Things—*** A web Thing can be a gateway to other devices that don’t have
    an internet connection. This resource contains all the web Things that are proxied
    by this web Thing. This is mainly used by clouds or gateways because they can
    proxy other devices.'
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***实体—*** 网络实体可以是连接到没有互联网连接的其他设备的网关。这个资源包含所有由这个网络实体代理的网络实体。这主要用于云或网关，因为它们可以代理其他设备。'
- en: Each web Thing can use this model to expose its capabilities. In the next section
    we examine these in more detail, especially what they look like. Describing the
    entire model in this book would take a few more chapters, so we limit ourselves
    to the strict essentials needed to understand what it is and how you can use it.
    We invite you to refer to the online description of the Web Thing Model to see
    the entire description with the various entities and fields you can use. You won’t
    need this information to follow this chapter, but it will help when you will want
    to adapt the model for your own devices and products. Furthermore, this model
    is heavily built on the concepts you learned in [chapters 6](kindle_split_014.html#ch06)
    and [7](kindle_split_015.html#ch07), so you’re definitely not starting from scratch!
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络实体都可以使用这个模型来展示其功能。在下一节中，我们将更详细地探讨这些内容，特别是它们的外观。在本书中描述整个模型需要几章的内容，所以我们只限于理解它是什么以及如何使用它的严格必要要素。我们邀请您参考网络实体模型的在线描述，以查看包含您可以使用的各种实体和字段的完整描述。您在跟随本章内容时不需要这些信息，但在您想要为自己的设备和产品调整模型时，这些信息将有所帮助。此外，这个模型在很大程度上建立在您在[第6章](kindle_split_014.html#ch06)和[第7章](kindle_split_015.html#ch07)中学到的概念之上，所以您绝对不是从零开始！
- en: 8.3.2\. Metadata
  id: totrans-827
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2。元数据
- en: In the Web Thing Model, all web Things must have some associated metadata to
    describe what they are. This is a set of basic fields about a web Thing, including
    its identifiers, name, description, and tags, and also the set of resources it
    has, such as the actions and properties. A GET on the root URL of any web Thing
    (`{WT}` in the following listing) always returns the metadata using this format,
    which is JSON by default.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络实体模型中，所有网络实体都必须有一些关联的元数据来描述它们是什么。这是一组关于网络实体的基本字段，包括其标识符、名称、描述和标签，以及它拥有的资源集合，如动作和属性。对任何网络实体的根URL（以下列表中的`{WT}`）的GET请求始终以这种格式返回元数据，默认情况下是JSON格式。
- en: 'Listing 8.3\. `GET {WT}`: retrieve the metadata of a web Thing'
  id: totrans-829
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3。`GET {WT}`：检索网络实体的元数据
- en: '[PRE44]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see here, the returned payload contains the basic information about
    the web Thing. The links to the various resources of this web Thing are contained
    in the `Link:` header of the response; see [section 8.2.2](#ch08lev2sec2). You
    can then follow each link to get more information about each of those resources.
    A `GET {WT}/model` will return the entire model of the web Thing, including the
    details of the actions or properties available.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此处所见，返回的有效负载包含 Web 事物的基本信息。此 Web 事物的各种资源的链接包含在响应的 `Link:` 标头中；参见[第 8.2.2
    节](#ch08lev2sec2)。然后您可以通过每个链接获取有关每个资源的更多信息。`GET {WT}/model` 将返回 Web 事物的整个模型，包括可用动作或属性的详细信息。
- en: 8.3.3\. Properties
  id: totrans-832
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3\. 属性
- en: Web Things can also have properties. A *property* is a collection of data values
    that relate to some aspect of the web Thing. Typically, you’d use properties to
    model any dynamic time series of data that a web Thing exposes, such as the current
    and past states of the web Thing or its sensor values—for example, the temperature
    or humidity sensor readings. Because properties should always capture the most
    up-to-date state of the web Thing, they’re generally updated by the web Things
    themselves as soon as the value changes and not by web Thing clients or applications.
    Let’s look at the properties of our web Thing by doing a GET on the `{WT}/properties`
    resource, as shown in the following listing.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: Web 事物也可以有属性。*属性*是一组与 Web 事物某些方面相关的数据值。通常，您会使用属性来模拟 Web 事物公开的任何动态时间序列数据，例如 Web
    事物的当前和过去状态或其传感器值——例如，温度或湿度传感器的读数。由于属性应始终捕获 Web 事物的最新状态，因此它们通常在值更改时由 Web 事物本身更新，而不是由
    Web 事物客户端或应用程序更新。让我们通过在 `{WT}/properties` 资源上执行 GET 请求来查看我们 Web 事物的属性，如下面的列表所示。
- en: 'Listing 8.4\. `GET {WT}/properties`: retrieve the properties of a web Thing'
  id: totrans-834
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 8.4\. `GET {WT}/properties`: 获取 Web 事物的属性'
- en: '[PRE45]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can see the current values of the various sensors on the Raspberry Pi, such
    as the temperature and PIR and when they were last changed. Let’s now look at
    one of them in more detail in the next listing.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Raspberry Pi 上查看各种传感器的当前值，例如温度、PIR 以及它们最后一次更改的时间。现在让我们在下一个列表中更详细地查看其中之一。
- en: Listing 8.5\. Retrieve the temperature property
  id: totrans-837
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.5\. 获取温度属性
- en: '[PRE46]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A GET on a specific property will return an array of value objects like the
    one shown here. Each value object has one or more fields, such as `t` for the
    actual temperature sensor reading, and the `timestamp` when the value was recorded.
    Some sensors might have several dimensions; for example, an acceleration sensor
    will have three dimensions, called values, one for each axis: X, Y, and Z.'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 对特定属性的 GET 请求将返回一个值对象数组，如此处所示。每个值对象有一个或多个字段，例如 `t` 用于实际的温度传感器读数，以及记录值时的 `timestamp`。某些传感器可能有多个维度；例如，加速度传感器将有三个维度，称为值，每个轴一个：X、Y
    和 Z。
- en: 8.3.4\. Actions
  id: totrans-840
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.4\. 动作
- en: '*Actions* are another important type of resources of a web Thing because they
    represent the various commands that can be sent to that web Thing. Examples of
    actions are “open/close the garage door,” “turn on the living room light, set
    its brightness to 50%, and set the color to red,” and “turn off the TV in 30 minutes.”
    In theory, you could also use properties to change the status of a web Thing,
    but this can be a problem when both an application and the web Thing itself want
    to edit the same property. This is where actions can help. Let’s draw a parallel
    to better grasp the concept: actions represent the public interface of a web Thing
    and properties are the private parts. Much like in any programming languages,
    you can access the public interface, and whatever is private remains accessible
    only for privileged parties, like the instance itself or, in this case, the web
    Thing. But limiting access to actions—that is, the public interface—also allows
    you to implement various control mechanisms for external requests such as access
    control, data validation, updating a several properties atomically, and the like.'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作* 是 Web Thing 的另一种重要资源类型，因为它们代表了可以发送到该 Web Thing 的各种命令。操作的例子包括“打开/关闭车库门”、“打开客厅灯光，将其亮度设置为
    50%，并将颜色设置为红色”，以及“30 分钟后关闭电视”。理论上，您也可以使用属性来更改 Web Thing 的状态，但当一个应用程序和 Web Thing
    本身都想要编辑相同的属性时，这可能会成为一个问题。这就是操作可以发挥作用的地方。让我们通过类比来更好地理解这个概念：操作代表了 Web Thing 的公共接口，而属性则是私有部分。就像在任何编程语言中一样，您可以访问公共接口，而任何私有部分仅对特权方（如实例本身或在这种情况下，Web
    Thing）可访问。但限制对操作的访问——即公共接口——也允许您实现各种控制机制，例如访问控制、数据验证、原子性地更新多个属性等。'
- en: Actions are also particularly useful when the command you want to send to a
    web Thing is much more complex than setting a simple value; for example, when
    you want to send a PDF to a printer or when the action might not be automatically
    executed. You can find the list of actions a given web Thing supports by sending
    a `GET {WT}/actions` request, as in the next listing.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要发送到 Web Thing 的命令比设置简单值更复杂时，操作尤其有用；例如，当您想要向打印机发送 PDF 或当操作可能不会自动执行时。您可以通过发送
    `GET {WT}/actions` 请求来找到给定 Web Thing 支持的操作列表，如下一列表所示。
- en: 'Listing 8.6\. `GET {WT}/actions`: retrieve the actions supported by a web Thing'
  id: totrans-843
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.6\. `GET {WT}/actions`：检索 Web Thing 支持的操作
- en: '[PRE47]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The response payload contains an array with the name and ID of each action the
    web Thing supports. More details about these actions are available in the `{WT}/model`
    resource, which describes what each action does and how to invoke it (which parameters
    to use, what their value should be, and so on). Let’s examine the details of the
    action `ledState` in the model in the following listing.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 响应有效负载包含一个数组，其中包含 Web Thing 支持的每个操作的名称和 ID。关于这些操作的更多详细信息可在 `{WT}/model` 资源中找到，该资源描述了每个操作的作用以及如何调用它（使用哪些参数，它们的值应该是多少等）。让我们在下一列表中检查模型中
    `ledState` 操作的详细信息。
- en: 'Listing 8.7\. `GET {WT}/model`: the `actions` object of a web Thing model'
  id: totrans-846
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7\. `GET {WT}/model`：Web Thing 模型的 `actions` 对象
- en: '![](230fig01_alt.jpg)'
  id: totrans-847
  prefs: []
  type: TYPE_IMG
  zh: '![图片](230fig01_alt.jpg)'
- en: 'The `actions` object of the Web Thing Model has an object called `resources`,
    which contains all the types of actions (commands) supported by this web Thing.
    In this example, only one action is supported: the `"ledState":{}` object, where
    `ledState` is the ID of this action. The `values` object contains the possible
    parameters that can be sent when creating the action. Here, the action accepts
    two values: `ledId` (the ID of the LED to change as a string) and `state` (the
    target state as a Boolean), both of which are required. Actions are sent to a
    web Thing with a POST to the URL of the action `{WT}/actions/{id}`, where `id`
    is the ID of the action (`ledState`), as shown in the next listing.'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: Web Thing Model 的 `actions` 对象包含一个名为 `resources` 的对象，其中包含此 Web Thing 支持的所有类型的操作（命令）。在本例中，仅支持一个操作：`"ledState":{}`
    对象，其中 `ledState` 是此操作的 ID。`values` 对象包含在创建操作时可以发送的可能参数。在此处，操作接受两个值：`ledId`（要更改的
    LED 的 ID，作为字符串）和 `state`（目标状态，作为布尔值），两者都是必需的。操作通过向操作的 URL 发送 POST 请求发送到 Web Thing，该
    URL 为 `{WT}/actions/{id}`，其中 `id` 是操作的 ID (`ledState`)，如下一列表所示。
- en: 'Listing 8.8\. `POST {WT}/actions/ledState`: turn on LED 3'
  id: totrans-849
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.8\. `POST {WT}/actions/ledState`：打开 LED 3
- en: '[PRE48]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can see that the payload is an object where the different fields correspond
    to the `values` object for that action (see [listing 8.7](#ch08ex07)). The response
    of the request will usually be `204 NO CONTENT` if it is executed immediately
    or `202 ACCEPTED` if the action will be executed at a later time. If the web Thing
    keeps track of all actions it receives, you can see the list of all actions with
    a GET on the `{WT}/actions/{actionId}` resource. You’ll find more details about
    actions and how to use them in the Web Thing Model reference online.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，有效载荷是一个对象，其中不同的字段对应于该动作的`values`对象（参见[列表8.7](#ch08ex07)）。如果立即执行该请求，通常响应将是`204
    NO CONTENT`，如果动作将在稍后执行，则响应将是`202 ACCEPTED`。如果Web Thing跟踪它接收到的所有动作，你可以通过在`{WT}/actions/{actionId}`资源上执行GET来查看所有动作的列表。你可以在Web
    Thing模型在线参考中找到有关动作及其在Web Thing模型中使用方式的更多详细信息。
- en: 8.3.5\. Things
  id: totrans-852
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.5\. Things
- en: As shown in [figure 8.5](#ch08fig05), a web Thing can act as a gateway between
    the web and devices that aren’t connected to the internet. In this case, the gateway
    can expose the resources—properties, actions, and metadata—of those non-web Things
    using the web Thing. The web Thing then acts as an Application-layer gateway for
    those non-web Things as it converts incoming HTTP requests for the devices into
    the various protocols or interfaces they support natively. For example, if your
    WoT Pi has a Bluetooth dongle, it can find and bridge Bluetooth devices nearby
    and expose them as web Things.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图8.5](#ch08fig05)所示，Web Thing可以作为互联网未连接的设备和网络之间的网关。在这种情况下，网关可以使用Web Thing公开那些非Web
    Thing的资源——属性、动作和元数据。然后，Web Thing作为非Web Thing的应用层网关，将针对设备的传入HTTP请求转换为它们原生支持的协议或接口。例如，如果你的WoT
    Pi有一个蓝牙适配器，它可以找到并桥接附近的蓝牙设备，并将它们公开为Web Thing。
- en: The resource that contains all the web Things proxied by a web Thing gateway
    is `{WT}/things`, and performing a GET on that resource will return the list of
    all web Things currently available, as shown in the following listing.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有由Web Thing网关代理的Web Thing的资源是`{WT}/things`，对该资源执行GET将返回当前所有可用的Web Thing列表，如下所示。
- en: 'Listing 8.9\. `GET {WT}/things`: the `things` object of the Web Thing Model'
  id: totrans-855
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.9\. `GET {WT}/things`：Web Thing模型的`things`对象
- en: '[PRE49]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can then access the web Thing for each of those resources by accessing its
    ID if it’s an absolute URL, or by appending it to the Things resource URL (`{WT}/things/{id}`)
    and send actions or retrieve its properties like you would with any other web
    Thing. The Things resource is mainly relevant when a web Thing is a gateway or
    a cloud service but also if the web Thing has a number of other devices connected
    to it; for example, via USB, Bluetooth, or any other type of interface.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过访问其ID（如果它是绝对URL）或将其附加到Things资源URL（`{WT}/things/{id}`）来访问每个资源的Web Thing，就像访问任何其他Web
    Thing一样发送动作或检索其属性。当Web Thing是一个网关或云服务时，Things资源主要相关，但如果Web Thing连接了多个其他设备，例如通过USB、蓝牙或任何其他类型的接口，它也相关。
- en: 8.3.6\. Implementing the Web Thing Model on the Pi
  id: totrans-858
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.6\. 在Pi上实现Web Thing模型
- en: Now that you’ve seen the basics of the Web Thing Model, it’s time to dig into
    the most important parts of its implementation.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Web Thing模型的基础，是时候深入其实现的最重要部分了。
- en: '|  |'
  id: totrans-860
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**How to get the code**'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何获取代码**'
- en: There’s a copious amount of code behind the implementation of the Web Thing
    Model we just presented, so instead of describing each line of code, we’ll focus
    on the most important or tricky parts. You’ll find the full code on GitHub; see
    [http://book.webofthings.io](http://book.webofthings.io). The examples for this
    chapter are located in the chapter8-semantics folder. Go to the webofthingsjs-unsecure
    folder and run `npm install` followed by `node wot.js`.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才介绍的Web Thing模型实现背后有大量的代码，所以我们不会描述每一行代码，而是会关注最重要的或最棘手的部分。你可以在GitHub上找到完整的代码；请参阅[http://book.webofthings.io](http://book.webofthings.io)。本章的示例位于chapter8-semantics文件夹中。转到webofthingsjs-unsecure文件夹，运行`npm
    install`，然后运行`node wot.js`。
- en: Because the code is using the webofthings.js project (the reference implementation
    of the Web Thing Model), you *must* clone the Git repository with the `–-recursive`
    option to make sure all the sub-modules of this chapter are also retrieved.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 因为代码使用了webofthings.js项目（Web Thing模型的参考实现），你必须使用`–-recursive`选项克隆Git仓库，以确保检索到本章的所有子模块。
- en: '|  |'
  id: totrans-864
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The WoT Pi model
  id: totrans-865
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: WoT Pi模型
- en: The first thing we want to do now is to use the Web Thing Model to describe
    the Pi and its capabilities. This means extending the simpler sensor/actuator
    model we wrote in [chapter 7](kindle_split_015.html#ch07). The tree structure
    of the Pi modeled using the Web Thing Model is shown in [figure 8.6](#ch08fig06)
    and the corresponding JSON model can be found in the /resources/piNoLd.json file.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要做的第一件事是使用 Web Thing 模型来描述 Pi 及其功能。这意味着扩展我们在第 7 章中编写的简单传感器/执行器模型。使用 Web
    Thing 模型建模的 Pi 的树结构如图 8.6 所示，相应的 JSON 模型可以在 /resources/piNoLd.json 文件中找到。
- en: Figure 8.6\. Resource tree of the Pi implementing the Web Thing Model. The notion
    of sensors and actuators is replaced by the idea of properties (variables) and
    actions (functions). Some of the resources, such as type or product, can be external
    references.
  id: totrans-867
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.6\. 实现 Web Thing 模型的 Pi 的资源树。传感器和执行器的概念被属性（变量）和操作（函数）的概念所取代。一些资源，如类型或产品，可以是外部引用。
- en: '![](08fig06_alt.jpg)'
  id: totrans-868
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig06_alt.jpg)'
- en: The listing that follows shows the model of the temperature property shown in
    [listing 8.5](#ch08ex05).
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了 [列表 8.5](#ch08ex05) 中所示的温度属性模型。
- en: Listing 8.10\. Temperature property for Pi
  id: totrans-870
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10\. Pi 的温度属性
- en: '![](233fig01_alt.jpg)'
  id: totrans-871
  prefs: []
  type: TYPE_IMG
  zh: '![](233fig01_alt.jpg)'
- en: Remember that the properties of our model are variables or private interfaces
    of the web Thing and therefore shouldn’t be changed by external clients, only
    by the device itself. Properties can be modified through actions, which you can
    see as functions or public interfaces a web client can invoke on a web Thing.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们模型中的属性是网络实体的变量或私有接口，因此不应该由外部客户端更改，而应由设备本身更改。属性可以通过操作进行修改，您可以将操作视为函数或公开接口，网络客户端可以在网络实体上调用。
- en: An action is a contract between the clients and the Things. When an action is
    created, the web Thing must know what to do with it; you’ll see an implementation
    of an action shortly. Likewise, the client must know the format and semantics
    of the action, such as which parameters can be sent.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 操作是客户端和网络实体之间的合同。当创建操作时，网络实体必须知道如何处理它；您将很快看到操作的实现。同样，客户端必须知道操作的格式和语义，例如可以发送哪些参数。
- en: In order for clients to easily access the resources of a web Thing, the entire
    model of the Thing should be easily retrievable by the client. Once the model
    is ready, we make it accessible through the `/model` resource, which returns the
    entire piNoLd.json file.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使客户端能够轻松访问网络实体的资源，整个实体的模型应该能够被客户端轻松检索。一旦模型准备就绪，我们通过 `/model` 资源使其可访问，该资源返回整个
    piNoLd.json 文件。
- en: Validating your model with JSON schema
  id: totrans-875
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 JSON 模式验证您的模型
- en: 'Creating your model file so that it complies with the Web Thing Model can be
    a daunting task because this model is significantly more complex than the one
    we used in [chapter 7](kindle_split_015.html#ch07), for example. This is unfortunately
    the price we pay for better interoperability and real-world readiness. Luckily,
    there’s a tool that can help us: JSON schemas.^([[12](#ch08fn12)]) A JSON schema
    is a way to formalize the model of a JSON payload; it’s basically the XML schema
    (XSD) of JSON. The Web Thing Model provides a Web Thing Model–compliant JSON schema
    that you can use to validate the JSON model of your Things. To use it, download
    it^([[13](#ch08fn13)]) and then use a JSON schema validator library such as `JSONSchema`
    for Node.js,^([[14](#ch08fn14)]) or use an online validator such as the good JSON
    Schema Lint.^([[15](#ch08fn15)])'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 创建您的模型文件以使其符合 Web Thing 模型可能是一项艰巨的任务，因为此模型比我们在第 7 章中使用的模型复杂得多。遗憾的是，这是我们为了更好的互操作性和实际应用准备所付出的代价。幸运的是，有一个工具可以帮助我们：JSON
    模式。[12](#ch08fn12) JSON 模式是正式化 JSON 有效负载模型的一种方式；它基本上是 JSON 的 XML 模式（XSD）。Web Thing
    模型提供了一个符合 Web Thing Model 的 JSON 模式，您可以使用它来验证您的实体的 JSON 模型。要使用它，请下载它[13](#ch08fn13)，然后使用
    Node.js 的 JSONSchema 库[14](#ch08fn14)，或者使用在线验证器，如良好的 JSON Schema Lint[15](#ch08fn15)。
- en: ^(12)
  id: totrans-877
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(12)
- en: ''
  id: totrans-878
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://json-schema.org/](http://json-schema.org/)'
  id: totrans-879
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://json-schema.org/](http://json-schema.org/)'
- en: ^(13)
  id: totrans-880
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(13)
- en: ''
  id: totrans-881
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://model.webofthings.io/models/wot-schema.json](http://model.webofthings.io/models/wot-schema.json)'
  id: totrans-882
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://model.webofthings.io/models/wot-schema.json](http://model.webofthings.io/models/wot-schema.json)'
- en: ^(14)
  id: totrans-883
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(14)
- en: ''
  id: totrans-884
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/tdegrunt/jsonschema](https://github.com/tdegrunt/jsonschema)'
  id: totrans-885
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://github.com/tdegrunt/jsonschema](https://github.com/tdegrunt/jsonschema)'
- en: ^(15)
  id: totrans-886
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(15)
- en: ''
  id: totrans-887
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://jsonschemalint.com/](http://jsonschemalint.com/)'
  id: totrans-888
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://jsonschemalint.com/](http://jsonschemalint.com/)'
- en: Extending the WoT server for discovery—architecture
  id: totrans-889
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 扩展 WoT 服务器以进行发现——架构
- en: There are many ways to implement this model on the Pi, but the simplest way
    to do it is to extend the architecture on top of what you implemented in [chapter
    7](kindle_split_015.html#ch07). The key idea is to put the Web Thing Model in
    the middle. The properties of the model will be updated by the different plugins
    connected to the sensors; for example, the temperature or PIR plugins. The plugins
    managing actuators will listen for incoming actions by observing the model. Finally,
    clients request resources and the server sends them a subset of the model as a
    response. Look at [figure 8.7](#ch08fig07) to see the key parts of this implementation.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pi上实现此模型有许多方法，但最简单的方法是在您在[第7章](kindle_split_015.html#ch07)中实现的基础上扩展架构。关键思想是将Web
    Thing Model放在中间。模型的属性将由连接到传感器的不同插件更新；例如，温度或PIR插件。管理执行器的插件将监听模型中的传入动作。最后，客户端请求资源，服务器将模型的一个子集作为响应发送给它们。查看[图8.7](#ch08fig07)以了解此实现的关键部分。
- en: 'Figure 8.7\. Implementation strategy of our Pi web Thing: the model is in the
    middle. It’s used by the routes creator to create the REST resources and their
    corresponding endpoints. Sensor plugins—for example, PIR—update the model whenever
    fresh data is read from a sensor. Actuator plugins listen for actions sent by
    clients, execute the action, and finally update the model when the action has
    been executed successfully; for example, they update the properties that have
    changed as a result of the action.'
  id: totrans-891
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.7\. 我们Pi网络事物的实现策略：模型位于中间。它被路由创建者用来创建REST资源及其对应的端点。传感器插件（例如，PIR）在从传感器读取新数据时更新模型。执行器插件监听客户端发送的动作，执行动作，并在动作成功执行后最终更新模型；例如，它们更新因动作而改变的性质。
- en: '![](08fig07_alt.jpg)'
  id: totrans-892
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig07_alt.jpg)'
- en: Dynamic routing
  id: totrans-893
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动态路由
- en: In [chapter 7](kindle_split_015.html#ch07), we manually created Express routes.
    Here, because we implemented a well-known contract (the Web Thing Model), we’re
    able to automatically generate the routes with little effort. To do this we first
    load the model and create the routes accordingly inside the /routes/routesCreator.js
    file. The code in the next listing shows the creation of the root resource.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](kindle_split_015.html#ch07)中，我们手动创建了Express路由。在这里，因为我们实现了一个知名合同（Web Thing
    Model），所以我们能够轻松地自动生成路由。为此，我们首先加载模型，并在/route/routesCreator.js文件中相应地创建路由。下一个列表中的代码展示了根资源的创建。
- en: 'Listing 8.11\. /routes/routesCreator.js: root resource route'
  id: totrans-895
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表8.11\. /routes/routesCreator.js: 根资源路由'
- en: '![](235fig01_alt.jpg)'
  id: totrans-896
  prefs: []
  type: TYPE_IMG
  zh: '![](235fig01_alt.jpg)'
- en: The code for the Thing (`/`), model (`/model`), properties `(/properties/...`),
    and actions `(/actions/...`) resources is similar. The next listing how to create
    the routes related to actions.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 事物（`/`）、模型（`/model`）、属性（`(/properties/...`））和动作（`(/actions/...`））资源的代码类似。下一个列表展示了如何创建与动作相关的路由。
- en: 'Listing 8.12\. /routes/routesCreator.js: actions resources routes'
  id: totrans-898
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表8.12\. /routes/routesCreator.js: 动作资源路由'
- en: '![](ch08ex12-0.jpg)'
  id: totrans-899
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08ex12-0.jpg)'
- en: '![](ch08ex12-1.jpg)'
  id: totrans-900
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08ex12-1.jpg)'
- en: 'You can see that the routes are created using two helper functions, defined
    in utils.js, that map the model to the resource representation as specified in
    the Web Thing Model:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，路由是通过两个辅助函数创建的，这些函数定义在utils.js中，它们将模型映射到Web Thing Model中指定的资源表示：
- en: '`extractFields(fields, model)` creates a new object by copying only the necessary
    fields from the model.'
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extractFields(fields, model)` 通过仅从模型中复制必要的字段来创建一个新的对象。'
- en: '`modelToResources(subModel, withValue)` transforms a subset of the model into
    an array of resources; for example, it extracts all the properties from the model
    with their latest values to create the `/properties` resource.'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modelToResources(subModel, withValue)` 将模型的一个子集转换为一个资源数组；例如，它从模型中提取所有属性及其最新值以创建
    `/properties` 资源。'
- en: Plugins
  id: totrans-904
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 插件
- en: 'Because the Web Thing Model is based on the concepts of actions, not just properties
    (like our implementation in [chapter 7](kindle_split_015.html#ch07)), we need
    to adapt the plugins to react to incoming actions. The basic concept is shown
    in [figure 8.7](#ch08fig07): sensor plugins (for example, the temperature and
    humidity plugin, the PIR plugin) still update properties just like in the code
    of [chapter 7](kindle_split_015.html#ch07). But actuator plugins will listen for
    incoming actions by observing the model and will update properties when changing
    their state after an action has been executed.'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Web Thing 模型基于动作的概念，而不仅仅是属性（就像我们在第 7 章中的实现），我们需要调整插件以对传入的动作做出反应。基本概念在[图 8.7](#ch08fig07)中显示：传感器插件（例如，温度和湿度插件、PIR
    插件）仍然像在第 7 章的代码中一样更新属性。但执行器插件将通过观察模型来监听传入的动作，并在动作执行后改变其状态时更新属性。
- en: You can find the code for the new plugins in the /plugins/internal directory.
    You’ll notice that unlike in [chapter 7](kindle_split_015.html#ch07), all plugins
    inherit now from a corePlugin.js module. This helps us group the code common to
    all plugins into an abstract plugin that other concrete plugins will inherit from
    and extend*.* This can be done using a JavaScript feature called *prototypal inheritance*.
    If you have no clue what we’re talking about here, don’t worry. All you need to
    remember is that the all the code shared by all plugins is implemented in corePlugin.js,
    whereas all the functionality that’s specific to a plugin is implemented in the
    concrete plugin modules themselves; for example, pirPlugin.js.^([[16](#ch08fn16)])
    The most important part of the corePlugin.js file is shown in the next listing.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 /plugins/internal 目录中找到新插件的代码。你会注意到，与第 7 章不同，现在所有插件都从 corePlugin.js 模块继承。这有助于我们将所有插件共有的代码分组到一个抽象插件中，其他具体插件将从这个插件继承并扩展。这可以通过使用名为
    *原型继承* 的 JavaScript 功能来实现。如果你对我们在这里谈论的内容毫无头绪，不要担心。你只需要记住的是，所有插件共享的代码都实现在 corePlugin.js
    中，而特定于插件的全部功能都实现在具体的插件模块中；例如，pirPlugin.js.^([[16](#ch08fn16)]) corePlugin.js 文件最重要的部分在下一列表中显示。
- en: ^(16)
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^((16))
- en: ''
  id: totrans-908
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you’d like to learn more about prototypical inheritance in JavaScript, the
    Mozilla JavaScript portal is a good place to start: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain).
    Or you can use any of the JavaScript or Node.js books we recommended in [chapter
    3](kindle_split_010.html#ch03).'
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 JavaScript 中原型继承的信息，Mozilla JavaScript 站点是开始的好地方：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)。或者，你可以使用我们在第
    3 章中推荐的所有 JavaScript 或 Node.js 书籍中的任何一本。[第 3 章](kindle_split_010.html#ch03)。
- en: 'Listing 8.13\. /plugins/corePlugin.js: generic plugin for common features'
  id: totrans-910
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 8.13\. /plugins/corePlugin.js: 通用功能的插件'
- en: '![](ch08ex13-0.jpg)'
  id: totrans-911
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08ex13-0.jpg)'
- en: '![](ch08ex13-1.jpg)'
  id: totrans-912
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08ex13-1.jpg)'
- en: As a result, concrete plugins are much shorter and simpler because they can
    use the functionality from the corePlugin.js module. All these plugins have to
    do now is register which property they will update and which actions they will
    listen to (observe). Obviously, they also have to implement the hardware connectivity
    part (GPIOs) as well as what to do with the hardware when an action they listen
    to is performed through the REST API. All the plugins are in the /plugins directory.
    To understand how all this works, take a closer look at the LED plugin shown in
    the next listing.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，具体的插件要短得多，也简单得多，因为它们可以使用 corePlugin.js 模块的功能。现在所有这些插件需要做的只是注册它们将更新哪个属性以及它们将监听哪些操作（观察）。显然，它们还必须实现硬件连接部分（GPIOs），以及当它们通过
    REST API 监听到的操作执行时，对硬件的处理。所有插件都在 /plugins 目录下。要了解这一切是如何工作的，请仔细查看下一列表中所示的 LED 插件。
- en: 'Listing 8.14\. /plugins/ledsPlugin.js: LED plugin working with the Web Thing
    Model'
  id: totrans-914
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 8.14\. /plugins/ledsPlugin.js: 与 Web Thing 模型一起工作的 LED 插件'
- en: '![](ch08ex14-0.jpg)'
  id: totrans-915
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08ex14-0.jpg)'
- en: '![](ch08ex14-1.jpg)'
  id: totrans-916
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08ex14-1.jpg)'
- en: If you have other devices at home, we invite you to extend the Web Thing Model
    for your devices and adapt this implementation so you can expose those devices
    as web Things so that they can be part of the Web of Things.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你家中有其他设备，我们邀请你扩展你的设备的 Web Thing 模型，并调整此实现，以便你可以将这些设备作为 Web Thing 暴露出来，这样它们就可以成为物联网的一部分。
- en: 8.3.7\. Summary—the Web Thing Model
  id: totrans-918
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.7\. 摘要——Web Thing 模型
- en: In this section, we introduced the Web Thing Model, a simple JSON-based data
    model for a web Thing and its resources. We also showed how to implement this
    model using Node.js and run it on a Raspberry Pi. We showed that this model is
    quite easy to understand and use, and yet is sufficiently flexible to represent
    all sorts of devices and products using a set of properties and actions. The goal
    is to propose a uniform way to describe web Things and their capabilities so that
    any HTTP client can find web Things and interact with them. This is sufficient
    for most use cases, and this model has all you need to be able to generate user
    interfaces for web Things automatically, as we’ll show in [chapter 10](kindle_split_018.html#ch10).
    If the hotel room where our Estonian friend Lena is staying would only offer a
    Web Thing Model and an API like this for all the devices and services in the room,
    she would be happy and could build her dream app in no time! Sadly, the Web of
    Things is nowhere near this vision yet because such a model for the Web of Things
    has been missing. Until now, that is!
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了Web Thing模型，这是一个基于JSON的简单数据模型，用于描述Web Thing及其资源。我们还展示了如何使用Node.js实现此模型，并在Raspberry
    Pi上运行它。我们展示了这个模型既易于理解和使用，又足够灵活，可以通过一组属性和动作来表示各种设备和产品。目标是提出一种统一的方式来描述Web Thing及其功能，以便任何HTTP客户端都可以找到Web
    Thing并与之交互。这对于大多数用例来说已经足够了，这个模型包含了你生成Web Thing用户界面所需的所有内容，正如我们将在第10章中展示的那样。如果我们的爱沙尼亚朋友Lena所住的酒店房间只提供这样的Web
    Thing模型和API，她将会很高兴，并且可以立即构建她的梦想应用！遗憾的是，物联网的Web还远未达到这个愿景，因为这样的物联网模型一直缺失。直到现在，情况才有所改变！
- en: 8.4\. The Semantic Web of Things
  id: totrans-920
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4. 物联网的语义网
- en: In an ideal world, search engines and any other applications on the web could
    also understand the Web Thing Model. Given the root URL of a web Thing, any application
    could retrieve its JSON model and understand what the web Thing is and how to
    interact with it. But this is not yet the case because the Web Thing Model we
    proposed isn’t a standard. The question now is how to expose the Web Thing Model
    using an existing web standard so that the resources are described in a way that
    means something to other clients. The answer lies in the notion of the Semantic
    Web and, more precisely, the notion of linked data that we introduce in this section.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，搜索引擎和任何其他网络应用都能够理解Web Thing模型。给定一个Web Thing的根URL，任何应用都可以检索其JSON模型，并理解这个Web
    Thing是什么以及如何与之交互。但这还不是现实，因为我们提出的Web Thing模型不是一个标准。现在的问题是，如何使用现有的网络标准来暴露Web Thing模型，使得资源以对其他客户端有意义的方式进行描述。答案在于语义网的概念，以及更精确地说，本节中我们引入的链接数据概念。
- en: '*Semantic Web* refers to an extension of the web that promotes common data
    formats to facilitate meaningful data exchange between machines. Thanks to a set
    of standards defined by the World Wide Web Consortium (W3C), web pages can offer
    a standardized way to express relationships among them so that machines can understand
    the meaning and content of those pages. In other words, the Semantic Web makes
    it easier to find, share, reuse, and process information from any content on the
    web thanks to a common and extensible data description and interchange format.'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '*语义网*指的是对网络的扩展，它通过推广通用的数据格式来促进机器之间的有意义数据交换。得益于万维网联盟（W3C）定义的一套标准，网页可以提供一种标准化的方式来表达它们之间的关系，以便机器可以理解这些页面的意义和内容。换句话说，语义网通过一个通用和可扩展的数据描述和交换格式，使得从任何网络内容中查找、共享、重用和处理信息变得更加容易。'
- en: 8.4.1\. Linked data and RDFa
  id: totrans-923
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1. 链接数据和RDFa
- en: When search engines find and index content from the web, most of the data on
    web pages is unstructured. This makes it difficult to understand what a web page
    is about. Is this page about someone? Or is it about a restaurant, a movie, a
    birthday party, or a product? HTML pages have only a limited ability to tell web
    clients or search engines what they talk about. All you can do is to define a
    summary and a set of keywords. The HTML specification alone doesn’t define a shared
    vocabulary that allows you to describe in a standard and non-ambiguous manner
    the elements on a page and what they relate to.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 当搜索引擎找到并索引网络上的内容时，网页上的大部分数据都是非结构的。这使得很难理解网页的主题。这个页面是关于某人的吗？还是关于一家餐厅、一部电影、一个生日派对或一个产品？HTML页面只有有限的描述能力，告诉网络客户端或搜索引擎它们在谈论什么。你所能做的只是定义一个摘要和一组关键词。仅HTML规范本身并没有定义一个共享词汇表，允许你以标准和非歧义的方式描述页面上的元素及其相关内容。
- en: Linked data
  id: totrans-925
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 链接数据
- en: Enter the vision of linked data,^([[17](#ch08fn17)]) which is a set of best
    practices for publishing and connecting structured data on the web, so that web
    resources can be interlinked in a way that allows computers to automatically understand
    the type and data of each resource. This is particularly appealing because any
    application that understands the type of a resource can then collect, process,
    and aggregate data from different sources uniformly, regardless of where it was
    published.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 进入链接数据的概念，^([[17](#ch08fn17))) 这是一套在网络上发布和连接结构化数据的最佳实践，以便网络资源可以以允许计算机自动理解每个资源类型和数据的方式相互链接。这一点尤其吸引人，因为任何理解资源类型的应用程序都可以收集、处理和统一聚合来自不同来源的数据，无论这些数据在哪里发布。
- en: ^(17)
  id: totrans-927
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(17)
- en: ''
  id: totrans-928
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://linkeddata.org/](http://linkeddata.org/)'
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://linkeddata.org/](http://linkeddata.org/)'
- en: This vision has been strongly driven by complex and heavy standards and tools
    centered on the Resource Description Framework^([[18](#ch08fn18)]) (RDF) and various
    controlled vocabularies, known as ontologies. Although powerful and expressive,
    RDF would be overkill for most simple scenarios, and this is why a simpler method
    to structure content on the web is desirable.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 这一愿景受到了围绕资源描述框架^([[18](#ch08fn18))) (RDF) 和各种称为本体论的控制词汇的复杂和重型标准和工具的强烈推动。尽管RDF功能强大且表达能力强，但对于大多数简单场景来说，它可能过于冗余，这就是为什么需要一个更简单的方法来在网络上结构化内容。
- en: ^(18)
  id: totrans-931
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(18)
- en: ''
  id: totrans-932
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.w3.org/RDF/](http://www.w3.org/RDF/)'
  id: totrans-933
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.w3.org/RDF/](http://www.w3.org/RDF/)'
- en: To overcome the limited descriptive power of the web without the heavy machinery
    of RDF, RDFa^([[19](#ch08fn19)]) offers an interesting tradeoff. This standard
    emerged as a lighter version of RDF that can be embedded into HTML code. Designed
    for both humans and machines, RDFa is a simple and lightweight way to annotate
    structured information such as products, people, places, and events directly within
    HTML pages. Most search engines can use these annotations to generate better search
    listings and make it easier to find your websites.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服没有RDF（资源描述框架）重型机器的情况下，网络描述能力的局限性，RDFa^([[19](#ch08fn19)]) 提供了一种有趣的权衡。这个标准作为一个更轻量级的RDF版本出现，可以嵌入到HTML代码中。RDFa旨在服务于人类和机器，是一种简单且轻量级的方法，可以直接在HTML页面中注释结构化信息，如产品、人物、地点和事件。大多数搜索引擎都可以使用这些注释来生成更好的搜索列表，并使查找您的网站变得更加容易。
- en: ^(19)
  id: totrans-935
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(19)
- en: ''
  id: totrans-936
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://rdfa.info/](http://rdfa.info/)'
  id: totrans-937
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://rdfa.info/](http://rdfa.info/)'
- en: Using RDFa to annotate the elements of the Web Things Model directly in the
    HTML representation of your device is particularly useful because search engines
    could then find and understand your web Things, without having to understand the
    JSON representation of the Web Thing Model. Putting it bluntly, using RDFa to
    describe the metadata of a web Thing will make that web Thing findable and searchable
    by Google. Although Google supports several data types, such as products, recipes,
    and events,^([[20](#ch08fn20)]) there is no specific type for the Web of Things.
    Let’s look at how we can create our own data types and use them within RDFa.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RDFa直接在您的设备的HTML表示中注释Web Things模型元素特别有用，因为搜索引擎可以找到并理解您的Web Things，而无需理解Web
    Thing模型的JSON表示。直白地说，使用RDFa描述Web Things的元数据将使该Web Things可由Google找到和搜索。尽管Google支持多种数据类型，如产品、食谱和事件，^([[20](#ch08fn20)))
    但Web of Things没有特定的类型。让我们看看我们如何创建自己的数据类型并在RDFa中使用它们。
- en: ^(20)
  id: totrans-939
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(20)
- en: ''
  id: totrans-940
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Learn more about Google’s support for markups: [https://developers.google.com/structured-data/rich-snippets/](https://developers.google.com/structured-data/rich-snippets/).'
  id: totrans-941
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 了解更多关于Google对标记的支持：[https://developers.google.com/structured-data/rich-snippets/](https://developers.google.com/structured-data/rich-snippets/)。
- en: RDFa primer
  id: totrans-942
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: RDFa入门
- en: To annotate any content using RDFa, we must either reuse an existing vocabulary
    or create a new one. A *vocabulary,*^([[21](#ch08fn21)]) also called a *taxonomy*,
    is a set of terms (fields) that can be used to annotate a certain type of element,
    along with a definition of what each field refers to. For example, if we only
    want to expose basic information about a Raspberry Pi, such as its name, description,
    or an image, we could use the products vocabulary supported by Google.^([[22](#ch08fn22)])
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用RDFa注释任何内容，我们必须重用现有的词汇表或创建一个新的。*词汇表*，也称为*分类法*，是一组可以用来注释特定类型元素的术语（字段），以及每个字段所指内容的定义。例如，如果我们只想公开有关树莓派的基本信息，如其名称、描述或图片，我们可以使用Google支持的产品词汇表.^([[22](#ch08fn22)])
- en: ^(21)
  id: totrans-944
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(21)
- en: ''
  id: totrans-945
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'RDFa offers a simple explanation: [http://www.w3.org/TR/rdfa-lite/#vocab-typeof-and-property](http://www.w3.org/TR/rdfa-lite/#vocab-typeof-and-property).'
  id: totrans-946
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: RDFa 提供了一个简单的解释：[http://www.w3.org/TR/rdfa-lite/#vocab-typeof-and-property](http://www.w3.org/TR/rdfa-lite/#vocab-typeof-and-property)。
- en: ^(22)
  id: totrans-947
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(22)
- en: ''
  id: totrans-948
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Google’s Product annotation format: [https://developers.google.com/structured-data/rich-snippets/products](https://developers.google.com/structured-data/rich-snippets/products).'
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 谷歌的产品注释格式：[https://developers.google.com/structured-data/rich-snippets/products](https://developers.google.com/structured-data/rich-snippets/products)。
- en: 'Unfortunately, this format doesn’t allow exposing the properties or actions
    of our Web Thing Model because there isn’t a vocabulary for the web Things we
    can reuse. But we can define our own based on the Web Thing Model reference found
    here: [http://model.webofthings.io](http://model.webofthings.io).'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，此格式不允许公开我们的 Web Thing 模型的属性或操作，因为我们没有可以重用的 Web Thing 词汇。但我们可以根据此处找到的 Web
    Thing 模型参考定义自己的：[http://model.webofthings.io](http://model.webofthings.io)。
- en: In the following listing,^([[23](#ch08fn23)]) we show how the WoT Pi can expose
    its JSON model using RDFa and our own Web of Things vocabulary. Start the WoT
    Pi server from our GitHub repository, as shown in [section 8.3.6](#ch08lev2sec8).
    By accessing the root resource of your WoT Pi with your browser, you’ll see the
    following HTML code.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中^([[23](#ch08fn23)])，我们展示了如何使用 RDFa 和我们自己的物联网词汇来公开 WoT Pi 的 JSON 模型。从我们的
    GitHub 仓库启动 WoT Pi 服务器，如[第 8.3.6 节](#ch08lev2sec8)所示。通过使用您的浏览器访问您的 WoT Pi 的根资源，您将看到以下
    HTML 代码。
- en: ^(23)
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(23)
- en: ''
  id: totrans-953
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that to improve readability, the extract shown in [listing 8.15](#ch08ex15)
    is a shorter version of the actual HTML code returned by the web Thing implementation
    you’re using in this chapter.
  id: totrans-954
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，为了提高可读性，[列表 8.15](#ch08ex15) 中显示的提取是实际由您在本章使用的 Web Thing 实现返回的 HTML 代码的简短版本。
- en: Listing 8.15\. The HTML representation of the root resource with RDFa annotations
  id: totrans-955
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.15\. 带有 RDFa 注释的根资源 HTML 表示形式
- en: '[PRE50]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can see that most HTML tags have some unfamiliar attributes^([[24](#ch08fn24)])
    defined by RDFa:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，大多数 HTML 标签都有一些由 RDFa 定义的未知属性^([[24](#ch08fn24)))：
- en: ^(24)
  id: totrans-958
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(24)
- en: ''
  id: totrans-959
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Lean more about HTML attributes here: [http://www.w3schools.com/html/html_attributes.asp](http://www.w3schools.com/html/html_attributes.asp).'
  id: totrans-960
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这里了解更多关于 HTML 属性的信息：[http://www.w3schools.com/html/html_attributes.asp](http://www.w3schools.com/html/html_attributes.asp)。
- en: '`vocab` defines the vocabulary used for that element, in this case the Web
    of Things Model vocabulary defined previously.'
  id: totrans-961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vocab` 定义了该元素使用的词汇，在本例中是之前定义的物联网模型词汇。'
- en: '`property` defines the various fields of the model such as name, ID, or description.'
  id: totrans-962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`property` 定义了模型的各个字段，例如名称、ID 或描述。'
- en: '`typeof` defines the type of those elements in relation to the vocabulary of
    the element.'
  id: totrans-963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typeof` 定义了这些元素相对于元素词汇的类型。'
- en: This allows other applications to parse the HTML representation of the device
    and automatically understand which resources are available and how they work.
    In particular, because Web of Things search engines will become increasingly popular
    (or will when Google supports and understands the Web Thing Model), physical devices,
    their data, and services will be easily indexed and searchable in real time.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许其他应用程序解析设备的 HTML 表示形式，并自动理解哪些资源可用以及它们如何工作。特别是，由于物联网搜索引擎将越来越受欢迎（或者当谷歌支持并理解
    Web Thing 模型时），物理设备、其数据和服务的实时索引和搜索将变得容易。
- en: Adding RDFa to your WoT Pi
  id: totrans-965
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为您的 WoT Pi 添加 RDFa
- en: To offer RDFa annotations for your WoT Pi, you’ll need to extend the HTML representation
    of its resources. In [chapter 7](kindle_split_015.html#ch07) you saw a simple
    way of returning HTML based on converter middleware. The problem with this approach
    is that you had to create the HTML code inside the converter middleware, which
    wasn’t very clean. A much better method in Express is to use *templating engines*.
    These modules offer the ability to create HTML templates that are dynamically
    filled with data when an HTML representation is requested. We installed a templating
    engine called Handlebars^([[25](#ch08fn25)]) in the project of [chapter 8](#ch08),
    but feel free to install it yourself as described in the nerd corner that follows.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 要为您的 WoT Pi 提供RDFa 注释，您需要扩展其资源的 HTML 表示形式。在[第 7 章](kindle_split_015.html#ch07)中，您看到了基于转换中间件返回
    HTML 的简单方法。这种方法的问题是在转换中间件内部创建 HTML 代码，这并不很干净。在 Express 中，一个更好的方法是使用 *模板引擎*。这些模块提供了在请求
    HTML 表示形式时动态填充数据的 HTML 模板创建能力。我们在[第 8 章](#ch08)的项目中安装了一个名为 Handlebars^([[25](#ch08fn25)])
    的模板引擎，但您也可以按照随后的“极客角落”中描述的方式自行安装它。
- en: ^(25)
  id: totrans-967
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(25)
- en: ''
  id: totrans-968
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/wycats/handlebars.js/](https://github.com/wycats/handlebars.js/)'
  id: totrans-969
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://github.com/wycats/handlebars.js/](https://github.com/wycats/handlebars.js/)'
- en: Once the templating engine is installed, all you need to do is to create HTML
    templates that contain your RDFa code. As an example, [listing 8.16](#ch08ex16)
    is a snippet of the HTML template for the root resource of the Pi.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了模板引擎，你所需要做的就是创建包含你的RDFa代码的HTML模板。例如，[列表8.16](#ch08ex16)是Pi根资源的HTML模板片段。
- en: '|  |'
  id: totrans-971
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The nerd corner—Install a templating engine**'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '**极客角落——安装模板引擎**'
- en: 'To use a templating engine for your WoT Pi, install the `consolidate` module^([[a](#ch08fn1b)])
    (`npm install –-save consolidate`); this module facilitates the integration of
    many templating engines to Express. In our case we’ll use the Handlebars templating
    module, which you can install via NPM as well (`npm install –-save handlebars`).
    Once it’s installed, you need to tell your Express app to use it by adding the
    following code to the http.js file:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 要为你的WoT Pi安装模板引擎，请安装`consolidate`模块^([[a](#ch08fn1b)]) (`npm install –-save
    consolidate`)；此模块便于将多个模板引擎集成到Express中。在我们的例子中，我们将使用Handlebars模板模块，你也可以通过NPM安装它(`npm
    install –-save handlebars`)。一旦安装完成，你需要通过向http.js文件中添加以下代码来告诉你的Express应用使用它：
- en: ^a
  id: totrans-974
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-975
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/tj/consolidate.js](https://github.com/tj/consolidate.js)'
  id: totrans-976
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://github.com/tj/consolidate.js](https://github.com/tj/consolidate.js)'
- en: '[PRE51]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|  |'
  id: totrans-978
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 8.16\. Templating HTML view in Express with RDFa tags
  id: totrans-979
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.16\. 在Express中使用RDFa标签模板HTML视图
- en: '![](242fig01_alt.jpg)'
  id: totrans-980
  prefs: []
  type: TYPE_IMG
  zh: '![](242fig01_alt.jpg)'
- en: Then, extend the converter.js middleware to inject the variables needed for
    your RDFa and to invoke the templating engine, as shown in the next listing.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，扩展converter.js中间件以注入你的RDFa所需的变量，并调用模板引擎，如以下列表所示。
- en: 'Listing 8.17\. /middleware/converter.js: extending the converter'
  id: totrans-982
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表8.17\. /middleware/converter.js: 扩展转换器'
- en: '![](243fig01_alt.jpg)'
  id: totrans-983
  prefs: []
  type: TYPE_IMG
  zh: '![](243fig01_alt.jpg)'
- en: That’s it! The HTML pages of your Pi now offer RDFa annotations, ready for the
    actors of the Semantic Web (for example, clients and search engines) to consume
    that data.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你的Pi的HTML页面现在提供了RDFa注释，可供语义网的参与者（例如，客户端和搜索引擎）消费这些数据。
- en: '8.4.2\. Agreed-upon semantics: Schema.org'
  id: totrans-985
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.2\. 约定的语义：Schema.org
- en: The tools of the Semantic Web can be used to describe pretty much anything.
    For instance, we could use RDFa to add more semantic description on top of our
    Web Thing Model. We could create a vocabulary that describes that a web Thing
    is a washing machine or smart door lock. The issue with the approach would be
    that only applications in our ecosystem would understand these specific vocabularies.
    We could push it one step further and turn these vocabularies into standards.
    But this is time-consuming and would often lead to competing standards because
    each manufacturer would want their own vocabulary.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 语义网工具可以用来描述几乎所有的事物。例如，我们可以使用RDFa在我们的Web Thing模型上添加更多的语义描述。我们可以创建一个词汇表，描述一个网络事物是洗衣机或智能门锁。这种方法的问题在于，只有我们生态系统中的应用程序才能理解这些特定的词汇表。我们可以更进一步，将这些词汇表变成标准。但这很耗时，并且通常会因每个制造商都希望有自己的词汇表而导致竞争标准。
- en: A more recent approach is to rely on more lightweight collaborative repositories.
    These repositories offer simple schema for specific semantic descriptions. They
    provide de facto ways of describing simple concepts such as things, people, and
    locations.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更近的方法是依赖更轻量级的协作仓库。这些仓库为特定的语义描述提供了简单的模式。它们提供了描述简单概念（如事物、人物和地点）的既定方式。
- en: Schema.org^([[26](#ch08fn26)]) has become the most popular of these collaborative
    repositories. It hosts a set of well-defined schemas for all sorts of structured
    data on the internet. In their own words,
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: Schema.org^([[26](#ch08fn26)])已成为最受欢迎的这些协作仓库之一。它托管了一组在互联网上所有种类的结构化数据的高定义模式。用他们自己的话说，
- en: ^(26)
  id: totrans-989
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(26)
- en: ''
  id: totrans-990
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://schema.org/](http://schema.org/)'
  id: totrans-991
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://schema.org/](http://schema.org/)'
- en: '*Schema.org is a collaborative, community activity with a mission to create,
    maintain, and promote schemas for structured data on the Internet, on web pages,
    in email messages, and beyond. Schema.org vocabulary can be used with many different
    encodings, including RDFa, Microdata and JSON-LD. These vocabularies cover entities,
    relationships between entities and actions, and can easily be extended through
    a well-documented extension model. Over 10 million sites use Schema.org to markup
    their web pages and email messages. Many applications from Google, Microsoft,
    Pinterest, Yandex and others already use these vocabularies to power rich, extensible
    experiences.*'
  id: totrans-992
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Schema.org是一个协作的社区活动，其使命是创建、维护和推广互联网上、网页上、电子邮件消息中以及更多地方的标准化数据模式。Schema.org词汇可以与许多不同的编码一起使用，包括RDFa、Microdata和JSON-LD。这些词汇涵盖了实体、实体之间的关系和动作，并且可以通过一个良好记录的扩展模型轻松扩展。超过1000万个网站使用Schema.org来标记他们的网页和电子邮件消息。许多来自Google、Microsoft、Pinterest、Yandex和其他公司的应用程序已经使用这些词汇来提供丰富、可扩展的体验。*'
- en: ''
  id: totrans-993
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Extract from [http://schema.org/](http://schema.org/)*'
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*摘自[http://schema.org/](http://schema.org/)*'
- en: In other words, not only can anyone directly reuse the models from schema.org
    to describe their web resources in a more standard way, but doing so will also
    make them automatically findable and understandable by many other websites and
    services. Google, Yahoo!, and Microsoft Bing, for instance, can parse the schema.org
    vocabulary for people. If you create a product description page using a serialization
    of this vocabulary—for example, using RDFa—to describe a product, a search engine
    will know you’re talking about a product and will render the results accordingly.
    Similarly, the Person vocabulary is used to identify pages that describe human
    beings, and the Place vocabulary is used to attach physical locations to web pages
    that are taken into account when using location-based search queries, such as
    via Google Maps. Search engines aren’t the only clients that use these vocabularies;
    mail clients such as Gmail,^([[27](#ch08fn27)]) web browsers, and other web-based
    discovery tools are also starting to understand them.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，不仅任何人都可以直接重用schema.org中的模型以更标准的方式描述他们的网络资源，而且这样做还将使它们自动被许多其他网站和服务发现和理解。例如，Google、Yahoo!和Microsoft
    Bing可以解析schema.org词汇以供人类使用。如果您使用这种词汇的序列化（例如，使用RDFa）来描述一个产品，搜索引擎将知道您在谈论一个产品，并将相应地呈现结果。同样，Person词汇用于识别描述人类的页面，而Place词汇用于将物理位置附加到网页上，当使用基于位置的搜索查询时（例如通过Google
    Maps），这些位置会被考虑在内。使用这些词汇的客户端不仅仅是搜索引擎；邮件客户端如Gmail、网络浏览器和其他基于网络的发现工具也开始理解它们。
- en: ^(27)
  id: totrans-996
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(27)
- en: ''
  id: totrans-997
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://developers.google.com/gmail/markup/overview](https://developers.google.com/gmail/markup/overview)'
  id: totrans-998
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/gmail/markup/overview](https://developers.google.com/gmail/markup/overview)'
- en: In the Web of Things, these agreed-upon vocabularies can readily be used to
    improve the findability of Things, as we’ll illustrate next with a small example
    using a growing format called JSON-LD.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网中，这些达成一致的词汇可以很容易地用来提高事物的可发现性，正如我们接下来将通过一个使用日益增长的格式JSON-LD的小例子来展示的。
- en: 8.4.3\. JSON-LD
  id: totrans-1000
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.3\. JSON-LD
- en: The schemas available on schema.org aren’t bound to a particular format. You
    can obviously use them in RDFa but you can also use them in Microdata^([[28](#ch08fn28)])
    as another way of representing linked data within HTML. On top of that, the schemas
    are available in a more recent format called JSON-LD (JSON-based serialization
    for Linked Data).
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: schema.org上可用的模式不受特定格式的限制。显然，您可以使用它们在RDFa中使用，也可以在Microdata中使用，作为在HTML中表示链接数据的另一种方式。除此之外，这些模式还以一个更新的格式提供，称为JSON-LD（基于JSON的链接数据序列化）。
- en: ^(28)
  id: totrans-1002
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(28)
- en: ''
  id: totrans-1003
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://html.spec.whatwg.org/multipage/microdata.html](https://html.spec.whatwg.org/multipage/microdata.html)'
  id: totrans-1004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://html.spec.whatwg.org/multipage/microdata.html](https://html.spec.whatwg.org/multipage/microdata.html)'
- en: JSON-LD is an interesting and lightweight semantic annotation format for linked
    data that, unlike RDFa and Microdata, is based on JSON.^([[29](#ch08fn29)]) It’s
    a simple way to semantically augment JSON documents by adding context information
    and hyperlinks for describing the semantics of the different elements of a JSON
    objects.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-LD是一种有趣且轻量级的语义注释格式，用于链接数据，与RDFa和Microdata不同，它基于JSON。这是一种通过添加上下文信息和超链接来描述JSON对象不同元素语义的简单方法，以语义增强JSON文档。
- en: ^(29)
  id: totrans-1006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(29)
- en: ''
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'JSON-LD can also be embedded in HTML: [http://www.w3.org/TR/json-ld/#embedding-json-ld-in-html-documents](http://www.w3.org/TR/json-ld/#embedding-json-ld-in-html-documents).'
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JSON-LD也可以嵌入到HTML中：[http://www.w3.org/TR/json-ld/#embedding-json-ld-in-html-documents](http://www.w3.org/TR/json-ld/#embedding-json-ld-in-html-documents)。
- en: Getting started with JSON-LD can be a little tricky because at the time of writing
    JSON-LD is not yet an official standard, but rather an evolving W3C recommendation.^([[30](#ch08fn30)])
    A good place to start is the official JSON-LD page,^([[31](#ch08fn31)]) where
    you’ll find a number of tutorials, examples, and a playground to test your JSON-LD
    payloads. In this section, we focus on only the bare minimum you’ll need to understand
    how to use it for the examples we provide.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用JSON-LD可能会有点棘手，因为撰写本文时，JSON-LD还不是官方标准，而是一个不断发展的W3C推荐。[30](#ch08fn30) 一个好的起点是官方JSON-LD页面，[31](#ch08fn31)
    在那里您可以找到许多教程、示例和一个用于测试您的JSON-LD负载的沙盒。在本节中，我们只关注您将需要了解如何使用它的基本内容，以便理解我们提供的示例。
- en: ^(30)
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(30)
- en: ''
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The latest version of the recommendation is available here: [http://www.w3.org/TR/json-ld/](http://www.w3.org/TR/json-ld/).'
  id: totrans-1012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 推荐的最新版本可在以下位置找到：[http://www.w3.org/TR/json-ld/](http://www.w3.org/TR/json-ld/)。
- en: ^(31)
  id: totrans-1013
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(31)
- en: ''
  id: totrans-1014
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://json-ld.org](http://json-ld.org)'
  id: totrans-1015
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://json-ld.org](http://json-ld.org)'
- en: JSON-LD extends the JSON language with a number of keywords represented by the
    special names of JSON properties starting with the `@` sign. The most important
    keywords are summarized in [table 8.1](#ch08table01).
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-LD通过使用以`@`符号开头的特殊名称表示的JSON属性关键字扩展了JSON语言。最重要的关键字总结在[表8.1](#ch08table01)中。
- en: Table 8.1\. The three main reserved keywords the JSON-LD language adds to JSON
  id: totrans-1017
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表8.1\. JSON-LD语言添加到JSON中的三个主要保留关键字
- en: '| Key | Description | Example |'
  id: totrans-1018
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-1019
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| @context | URL referencing a particular schema | [http://schema.org/Person](http://schema.org/Person)
    |'
  id: totrans-1020
  prefs: []
  type: TYPE_TB
  zh: '| @context | 指向特定模式的URL | [http://schema.org/Person](http://schema.org/Person)
    |'
- en: '| @id | Unique identifier (usually a URI) | [http://dbpedia.org/page/Mahatma_Gandhi](http://dbpedia.org/page/Mahatma_Gandhi)
    |'
  id: totrans-1021
  prefs: []
  type: TYPE_TB
  zh: '| @id | 唯一标识符（通常是URI） | [http://dbpedia.org/page/Mahatma_Gandhi](http://dbpedia.org/page/Mahatma_Gandhi)
    |'
- en: '| @type | A URL referencing the type of a value | [http://www.w3.org/2001/XMLSchema#dateTime](http://www.w3.org/2001/XMLSchema#dateTime)
    |'
  id: totrans-1022
  prefs: []
  type: TYPE_TB
  zh: '| @type | 指向值类型的URL | [http://www.w3.org/2001/XMLSchema#dateTime](http://www.w3.org/2001/XMLSchema#dateTime)
    |'
- en: On its own, JSON-LD is just another format for adding semantics to data. But
    when using it with standard schemas, such as those available on schema.org, it
    can be powerful because it lets you reference an agreed-upon context to semantically
    describe your data.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-LD本身只是为数据添加语义的另一种格式。但与标准模式一起使用时，例如在schema.org上可用的模式，它可以非常强大，因为它允许您引用一个已商定的上下文来语义描述您的数据。
- en: JSON-LD for Things
  id: totrans-1024
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JSON-LD用于物联网
- en: Let’s look at a simple example. We’ll use the Product schema described on schema.org^([[32](#ch08fn32)])
    to add some semantic data to our Pi. After all, our Pi is also a product, so it
    does make sense! The following listing shows a modified version of the `pi.json`
    model that uses the JSON-LD vocabulary for products.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子。我们将使用schema.org上描述的产品模式[32](#ch08fn32)来为我们Pi添加一些语义数据。毕竟，我们的Pi也是一个产品，所以这样做是有意义的！以下列表显示了`pi.json`模型的修改版本，它使用产品词汇表中的JSON-LD。
- en: ^(32)
  id: totrans-1026
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(32)
- en: ''
  id: totrans-1027
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://schema.org/Product](http://schema.org/Product)'
  id: totrans-1028
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://schema.org/Product](http://schema.org/Product)'
- en: 'Listing 8.18\. resources/piJsonLd.json: adding JSON-LD to our JSON model'
  id: totrans-1029
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.18\. resources/piJsonLd.json：将JSON-LD添加到我们的JSON模型中
- en: '![](245fig01_alt.jpg)'
  id: totrans-1030
  prefs: []
  type: TYPE_IMG
  zh: '![](245fig01_alt.jpg)'
- en: JSON-LD uses a different MIME or media type than JSON. Thanks to HTTP’s content-negotiation
    mechanism you saw earlier, you only have to add a small bit of code to your converter.js
    middleware, as shown in the next listing, to start serving JSON-LD.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-LD使用的MIME或媒体类型与JSON不同。多亏了您之前看到的HTTP内容协商机制，您只需在converter.js中间件中添加一小段代码，就像下一个列表中所示，就可以开始提供JSON-LD。
- en: 'Listing 8.19\. middleware/converter.js: adding support for JSON-LD representations'
  id: totrans-1032
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.19\. middleware/converter.js：添加对JSON-LD表示的支持
- en: '![](246fig01_alt.jpg)'
  id: totrans-1033
  prefs: []
  type: TYPE_IMG
  zh: '![](246fig01_alt.jpg)'
- en: 'Now go ahead and try to request JSON-LD on the root resource of your Pi with
    the `Accept: application/ld+json` header, and you’ll get JSON-LD data returned.'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: '现在请尝试使用`Accept: application/ld+json`头在您的Pi的根资源上请求JSON-LD，您将得到返回的JSON-LD数据。'
- en: Findability and beyond
  id: totrans-1035
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可发现性及其超越
- en: This simple example already illustrates the essence of JSON-LD it gives a context
    to the content of a JSON document. As a consequence, all clients that understand
    the [http://schema.org/Product](http://schema.org/Product) context will be able
    to automatically process this information in a meaningful way. This is the case
    with search engines, for example. Google and Yahoo! process JSON-LD payloads using
    the Product schema to render special search results; as soon as it gets indexed,
    our Pi will be known by Google and Yahoo! as a Raspberry Pi product. This means
    that the more semantic data we add to our Pi, the more findable it will become.
    As an example, try adding a location to your Pi using the Place schema,^([[33](#ch08fn33)])
    and it will eventually become findable by location.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子已经说明了 JSON-LD 的本质，它为 JSON 文档的内容提供了上下文。因此，所有理解 [http://schema.org/Product](http://schema.org/Product)
    上下文的客户端都能够以有意义的方式自动处理这些信息。例如，搜索引擎就是这样做的。谷歌和雅虎使用产品模式处理 JSON-LD 有效载荷，以呈现特殊的搜索结果；一旦被索引，我们的
    Pi 就会被谷歌和雅虎识别为 Raspberry Pi 产品。这意味着我们为 Pi 添加的语义数据越多，它就越容易被找到。例如，尝试使用位置模式为您的 Pi
    添加位置[^([33](#ch08fn33)))，它最终将可以通过位置找到。
- en: ^(33)
  id: totrans-1037
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(33)
- en: ''
  id: totrans-1038
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://schema.org/Place](http://schema.org/Place)'
  id: totrans-1039
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://schema.org/Place](http://schema.org/Place)'
- en: We could also use this approach to create more specific schemas on top of the
    Web Thing Model; for instance, an agreed-upon schema for the data and functions
    a washing machine or smart lock offers. This would facilitate discovery and enable
    automatic integration with more and more web clients.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用这种方法在 Web Thing Model 上创建更具体的模式；例如，为洗衣机或智能锁提供的数据和功能达成一致的模式。这将促进发现，并使与越来越多的网络客户端自动集成成为可能。
- en: 8.4.4\. Beyond the book
  id: totrans-1041
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.4\. 超越书籍
- en: As you’ve realized, a common Application layer protocol is essential but not
    sufficient to achieve interoperability. A higher-level model to describe the metadata
    and functionality of the Web of Things along with a standard set of APIs are needed
    to build interoperable applications and devices. The Web Thing Model we introduced
    in [section 8.3](#ch08lev1sec3) bridges this gap and is an excellent starting
    point for building your next Web of Things device, gateway, or cloud.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所意识到的那样，一个通用的应用层协议对于实现互操作性是必要的，但并不足够。我们需要一个更高层次的模型来描述物联网的元数据和功能，以及一组标准 API，以构建互操作的应用程序和设备。我们在第
    8.3 节中引入的 Web Thing Model 桥接了这一差距，并且是构建您下一个物联网设备、网关或云的绝佳起点。
- en: At the time of writing, this model has been published as a W3C Member Submission.
    Although it isn’t an official standard, it might serve as a basis for working
    groups, and we invite you to follow the upcoming standardization efforts within
    the W3C Web of Things consortium.^([[34](#ch08fn34)])
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，此模型已作为 W3C 会员提交出版。尽管它不是官方标准，但它可能作为工作组的基础，我们邀请您关注 W3C Web of Things 协同体内的即将到来的标准化努力。[^([34](#ch08fn34))]
- en: ^(34)
  id: totrans-1044
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(34)
- en: ''
  id: totrans-1045
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.w3.org/WoT](http://www.w3.org/WoT)'
  id: totrans-1046
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.w3.org/WoT](http://www.w3.org/WoT)'
- en: The battle for semantics and models for the IoT is strategic and will not only
    involve open standards. In the home automation space, Apple HomeKit and Google
    Weave will likely play an important role. We’re at a critical turning point in
    the development of the IoT, and relying on standards created by large companies
    might not be the best option for individual consumers. Therefore, independent
    institutions such as the W3C will have to play a vital role in the future of the
    web and WoT.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网的语义和模型之战是战略性的，不仅会涉及开放标准。在家庭自动化领域，Apple HomeKit 和 Google Weave 可能会扮演重要角色。我们在物联网的发展中处于一个关键的转折点，依赖于大公司创建的标准可能不是个人消费者最佳的选择。因此，像
    W3C 这样的独立机构将在未来网络和 WoT 的未来中发挥至关重要的作用。
- en: 8.5\. Summary
  id: totrans-1048
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5\. 摘要
- en: The ability to find nearby devices and services is essential in the Web of Things
    and is known as the bootstrap problem. Several protocols can help in discovering
    the root URL of Things, such as mDNS/Bonjour, QR codes or NFC tags.
  id: totrans-1049
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在物联网中找到附近设备和服务的功能至关重要，这被称为引导问题。几个协议可以帮助发现事物的根 URL，例如 mDNS/Bonjour、二维码或 NFC 标签。
- en: The last step of the web Things design process, resource linking design (also
    known as HATEOAS in REST terms), can be implemented using the web linking mechanism
    in HTTP headers.
  id: totrans-1050
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络事物设计过程的最后一步，资源链接设计（在 REST 术语中也称为 HATEOAS），可以使用 HTTP 头中的网络链接机制来实现。
- en: Beyond finding the root URL and sub-resources, client applications also need
    a mechanism to discover and understand what data or services a web Thing offers.
  id: totrans-1051
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了找到根URL和子资源之外，客户端应用程序还需要一种机制来发现和理解Web Thing提供的数据或服务。
- en: The services of Things can be modeled as properties (variables), actions (functions),
    and links. The Web Thing Model offers a simple, flexible, fully web-compatible,
    and extensible data model to describe the details of any web Thing. This model
    is simple to adapt for your devices and easy to use for your products and applications.
  id: totrans-1052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物联网的服务可以被建模为属性（变量）、动作（函数）和链接。Web Thing模型提供了一个简单、灵活、完全兼容Web、可扩展的数据模型，用于描述任何Web
    Thing的详细信息。这个模型很容易适应你的设备，并且对你的产品和应用来说易于使用。
- en: The Web Thing Model can be extended with more specific semantic descriptions
    such as those based on JSON-LD and available from the Schema.org repository.
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web Thing模型可以通过更多具体的语义描述进行扩展，例如基于JSON-LD的描述，这些描述可以从Schema.org仓库中获取。
- en: Although internet access is the bare minimum required to be part of the Web
    of Things, you’ve seen that a shared and open data model to describe a web Thing
    will maximize interoperability without sacrificing flexibility and ease of use.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然互联网接入是成为Web of Things的一部分所必需的最低要求，但你已经看到，一个共享和开放的数据模型来描述Web Thing将最大化互操作性，而不会牺牲灵活性和易用性。
- en: 'Now that you’ve learned how to open, expose, find, and use web Things in the
    World Wide Web, you’re ready for the next challenge—and layer—of the Web of Things:
    how to share web Things securely over open networks such as the web. In the next
    chapter, we’ll first show you how to secure your web Things using state of the
    art methods and best practices. Afterward, you’ll learn how to use your existing
    social network account in order to share your devices with your friends. Finally,
    we’ll show how to implement best practices of web security and data sharing on
    your WoT Pi.'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何在万维网上打开、公开、查找和使用Web Thing，你已经准备好迎接下一个挑战——Web of Things的下一层：如何在开放的网络上如Web安全地共享Web
    Thing。在下一章中，我们将首先向你展示如何使用最先进的方法和最佳实践来保护你的Web Thing。之后，你将学习如何使用你现有的社交网络账户来与你的朋友分享你的设备。最后，我们将展示如何在你的WoT
    Pi上实施Web安全和数据共享的最佳实践。
- en: 'Chapter 9\. Share: Securing and sharing web Things'
  id: totrans-1056
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章：分享：保护与共享Web Thing
- en: '*This chapter covers*'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: A short overview of security risks and issues on the Web of Things
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web of Things上的安全风险和问题的简要概述
- en: A brief theoretical introduction to HTTPS, certificates, and encryption
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTPS、证书和加密的简要理论介绍
- en: Best practices and techniques for web-based authorization and access control
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Web的授权和访问控制的最佳实践和技术
- en: Learning to implement these best practices and tools on your Raspberry Pi
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在你的树莓派上实施这些最佳实践和工具
- en: Implementing the Social Web of Things in the WoT gateway
  id: totrans-1062
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WoT网关中实现社交Web of Things
- en: In most cases, Internet of Things deployments involve a group of devices that
    communicate with each other or with various applications within closed networks—rarely
    over open networks such as the internet. It would be fair to call such deployments
    the “intranets of Things” because they’re essentially isolated, private networks
    that only a few entities can access. But the real power of the Web of Things lies
    in opening up these lonely silos and facilitating interconnection between devices
    and applications at a large scale.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，物联网部署涉及一组设备，它们在封闭网络中相互通信或与各种应用程序通信——很少通过如互联网这样的开放网络。这样的部署可以公平地被称为“物联网的内部网络”，因为它们本质上是被隔离的、私有的网络，只有少数实体可以访问。但Web
    of Things的真正力量在于打开这些孤立的孤岛，并促进大规模的设备和应用程序之间的互联。
- en: Why would you even want this? When it comes to a critical IoT system such as
    a network of industrial machines in a large factory in Shenzhen, the security
    system of the British Museum, or simply own collection of smart devices at home,
    you certainly don’t want these networks to be open to anyone. But when it comes
    to public data such as data.gov initiatives, real-time traffic/weather/pollution
    conditions in a city, or a group of sensors deployed in a jungle or a volcano,
    it would be great to ensure that the general public or researchers anywhere in
    the world could access that data. This would enable anyone to create new innovative
    applications with it and possibly generate substantial economic, environmental,
    and social value. Another use case is the smart hotel scenario presented in [chapter
    1](kindle_split_008.html#ch01), where hotel guests (and only *they*) should have
    access to some services and devices in their room (and only *there*) during their
    stay (and only *then*). Because the public infrastructure is becoming not only
    digital but also pervasive, the earlier we could build, deploy, and scale those
    systems while maximizing the ability to share data between devices, users, and
    applications, the better it would be for all of us. How to share this data in
    secure and flexible way is what Layer 3 provides, as shown in [figure 9.1](#ch09fig01).
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么会想要这样做呢？当涉及到一个关键的物联网系统，比如深圳一家大型工厂的工业机器网络、大英博物馆的安全系统，或者仅仅是家中的智能设备集合时，你当然不希望这些网络对任何人开放。但是，当涉及到公共数据，如data.gov倡议、城市中的实时交通/天气/污染状况，或者部署在丛林或火山中的传感器群组时，确保全球的公众或研究人员能够访问这些数据将是非常好的。这将使任何人都能利用这些数据创建新的创新应用，并可能产生巨大的经济、环境和社交价值。另一个用例是第1章中提到的智能酒店场景[第1章](kindle_split_008.html#ch01)，其中酒店客人（只有他们）在其入住期间（只有那时）应该能够访问其房间中的一些服务和设备（只有那里）。因为公共基础设施正在变得不仅数字化，而且无处不在，我们越早构建、部署和扩展这些系统，同时最大化设备、用户和应用程序之间共享数据的能力，对我们所有人来说就越好。如何在安全且灵活的方式下共享这些数据，这正是第三层所提供的，如图9.1[图9.1](#ch09fig01)所示。
- en: Figure 9.1\. The Share layer of the Web of Things. This layer focuses on how
    devices and their resources must be secured so that they can only be accessed
    by authorized users and applications.
  id: totrans-1065
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1\. 物联网的共享层。此层关注的是如何确保设备和它们的资源得到保护，以便只有授权用户和应用能够访问。
- en: '![](09fig01.jpg)'
  id: totrans-1066
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1](09fig01.jpg)'
- en: 'The prerequisite for this is to use a common protocol and data format between
    devices and applications, which we covered extensively in the previous chapters.
    But once devices are connected to a public network, the most important problem
    to solve is how to ensure that only a specific set of users can access only a
    specific set of resources at a specific time and in a specific manner. In the
    next sections we’ll show how to do this by building on the concepts and tools
    you’ve already seen. First, we’ll show how Layer 3 of the WoT architecture covers
    the security of Things: how to ensure that only authorized parties can access
    a given resource. Then we’ll show how to use existing trusted systems to allow
    sharing physical resources via the web.'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的先决条件是在设备和应用程序之间使用通用的协议和数据格式，这在之前的章节中我们已经进行了详细阐述。但是，一旦设备连接到公共网络，最重要的待解决问题是如何确保只有特定的一组用户可以在特定时间以特定方式访问特定的一组资源。在接下来的几节中，我们将通过构建你已经了解的概念和工具来展示如何实现这一点。首先，我们将展示WoT架构的第三层如何覆盖设备安全：如何确保只有授权方可以访问特定的资源。然后，我们将展示如何利用现有的可信系统通过互联网共享物理资源。
- en: 9.1\. Securing Things
  id: totrans-1068
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 确保设备安全
- en: 'Right now, the hottest topic (or potato, to be more accurate!) of the IoT world
    is arguably security.^([[1](#ch09fn01)]) We keep hearing all over the news about
    the IoT and the endless possibilities of an all-connected world. Sadly, this vision
    is also continuously tainted by major security breaches: personal information,
    credit card data, sensitive documents, or passwords from millions of users being
    stolen by hackers. Such happenings not only can severely hurt the reputation of
    a company but also can have disastrous effects for the users. Ultimately, every
    security breach hurts the entire web because it erodes the overall trust of users
    in technology. No one wants their smart fridges sending spam emails^([[2](#ch09fn02)])
    about dubious pills, inheritances, or unclaimed lottery gains.'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，物联网世界最热门的话题（或者更准确地说，是“土豆”）无疑是安全问题。[^1](#ch09fn01) 我们在新闻中不断听到关于物联网和全连接世界的无限可能性。遗憾的是，这一愿景也不断受到重大安全漏洞的玷污：数百万用户的个人信息、信用卡数据、敏感文件或密码被黑客窃取。此类事件不仅可能严重损害公司的声誉，而且可能对用户造成灾难性的影响。最终，每一次安全漏洞都会损害整个网络，因为它侵蚀了用户对技术的整体信任。没有人希望他们的智能冰箱发送关于可疑药品、遗产或未领取的彩票收益的垃圾邮件。[^2](#ch09fn02)
- en: ¹
  id: totrans-1070
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-1071
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://venturebeat.com/2016/01/16/ces-2016-the-largest-collection-of-insecure-devices-in-the-world](http://venturebeat.com/2016/01/16/ces-2016-the-largest-collection-of-insecure-devices-in-the-world)'
  id: totrans-1072
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://venturebeat.com/2016/01/16/ces-2016-the-largest-collection-of-insecure-devices-in-the-world](http://venturebeat.com/2016/01/16/ces-2016-the-largest-collection-of-insecure-devices-in-the-world)'
- en: ²
  id: totrans-1073
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-1074
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.theguardian.com/technology/2014/jan/21/fridge-spam-security-phishing-campaign](http://www.theguardian.com/technology/2014/jan/21/fridge-spam-security-phishing-campaign)'
  id: totrans-1075
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.theguardian.com/technology/2014/jan/21/fridge-spam-security-phishing-campaign](http://www.theguardian.com/technology/2014/jan/21/fridge-spam-security-phishing-campaign)'
- en: Security in the Web of Things is even more critical than in the web. Because
    web Things are physical objects that will be deployed everywhere in the real world,
    the risks associated with IoT attacks can be catastrophic. Digitally augmented
    devices allow collecting much more information about people with a fine-grained
    resolution, such as when you got your last insulin shot, what time you go jogging
    and where, and the like. But more important, unauthorized access to physical objects
    can be dangerous—remotely controlling your brand new BMW^([[3](#ch09fn03)]) or
    house,^([[4](#ch09fn04)]) anyone? Despite those risks, recent reports have shown
    a sad state of affairs in the world of IoT security.^([[5](#ch09fn05)]) Although
    many vulnerabilities—called *exploits* in hacker parlance—are widely known and
    patches for them are readily available, it has been reported that the majority
    of IoT solutions don’t comply with even the most basic security best practices;
    think clear-text passwords and communications, invalid certificates, old software
    versions with exploitable bugs, and so on. In other words, you don’t even have
    to be a security expert to use existing weaknesses in many services or devices
    and gain access to unauthorized content.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网中的安全问题甚至比网络中的安全问题更为关键。因为物联网设备是将在现实世界的各个地方部署的物理对象，与物联网攻击相关的风险可能是灾难性的。数字增强设备可以以细粒度收集关于人们的大量信息，例如你上次注射胰岛素的时间、你跑步的时间和地点等等。但更重要的是，对物理对象的未经授权访问可能是危险的——远程控制你的全新宝马[^3](#ch09fn03)或房屋[^4](#ch09fn04)，这可能吗？尽管存在这些风险，但最近的报告显示物联网安全领域的情况令人沮丧。[^5](#ch09fn05)
    尽管许多漏洞——在黑客术语中被称为“漏洞”——是众所周知的，并且针对它们的补丁也容易获得，但据报道，大多数物联网解决方案甚至不遵守最基本的最佳安全实践；想想明文密码和通信、无效证书、带有可利用漏洞的旧软件版本等等。换句话说，你甚至不需要是安全专家，就可以利用许多服务或设备中现有的弱点，获取未经授权的内容。
- en: ³
  id: totrans-1077
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-1078
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.wired.com/2015/08/bmw-benz-also-vulnerable-gm-onstar-hack/](http://www.wired.com/2015/08/bmw-benz-also-vulnerable-gm-onstar-hack/)'
  id: totrans-1079
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.wired.com/2015/08/bmw-benz-also-vulnerable-gm-onstar-hack/](http://www.wired.com/2015/08/bmw-benz-also-vulnerable-gm-onstar-hack/)'
- en: ⁴
  id: totrans-1080
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-1081
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.forbes.com/sites/kashmirhill/2013/07/26/smart-homes-hack/](http://www.forbes.com/sites/kashmirhill/2013/07/26/smart-homes-hack/)'
  id: totrans-1082
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.forbes.com/sites/kashmirhill/2013/07/26/smart-homes-hack/](http://www.forbes.com/sites/kashmirhill/2013/07/26/smart-homes-hack/)'
- en: ⁵
  id: totrans-1083
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-1084
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “Insecurity in the Internet of Things,” [https://www.symantec.com/iot/](https://www.symantec.com/iot/).
  id: totrans-1085
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见“物联网中的不安全因素”，[https://www.symantec.com/iot/](https://www.symantec.com/iot/).
- en: This book is not about network security, so don’t expect to become an expert
    in this field by the end of this chapter. But because it’s such a crucial issue
    for any production system or consumer product connected to the internet, we’ll
    cover the basics you need to know when building IoT solutions in the form of a
    set of best practices for building secure and reliable devices and applications.
    If you can’t wait any longer, an excellent resource is the Open Web Application
    Security Project (OWASP) Internet of Things project,^([[6](#ch09fn06)]) which
    contains useful, down-to-earth, and practical information about how to build safer
    IoT applications and systems.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不是关于网络安全，所以不要期望在本章结束时成为这个领域的专家。但是，由于这对于任何连接到互联网的生产系统或消费产品来说都是一个关键问题，我们将以构建安全可靠设备和应用程序的最佳实践的形式，介绍您在构建物联网解决方案时需要了解的基本知识。如果您迫不及待，一个极好的资源是开放网络应用安全项目（OWASP）的物联网项目^([[6](#ch09fn06)]），它包含有关如何构建更安全的物联网应用程序和系统的有用、实用和实际信息。
- en: ⁶
  id: totrans-1087
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-1088
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.owasp.org/index.php/OWASP_Internet_of_Things_Project](https://www.owasp.org/index.php/OWASP_Internet_of_Things_Project)'
  id: totrans-1089
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[OWASP物联网项目](https://www.owasp.org/index.php/OWASP_Internet_of_Things_Project)'
- en: 'Roughly speaking, securing the IoT comes down to solving three major problems
    summarized in [figure 9.2](#ch09fig02):'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 大体来说，确保物联网的安全归结为解决三个主要问题，这些问题在[图9.2](#ch09fig02)中总结：
- en: Figure 9.2\. The three principal challenges in securing the IoT. First, communications
    must be encrypted to prevent unauthorized entities from reading the messages between
    a client and a server. Second, the client must be sure they are really talking
    to whom they they are. Third, the server must be sure that a message comes from
    an authorized client allowed to send that request.
  id: totrans-1091
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2\. 确保物联网安全的三个主要挑战。首先，通信必须加密，以防止未经授权的实体读取客户端和服务器之间的消息。其次，客户端必须确保他们确实在与他们交谈的人交流。第三，服务器必须确保消息来自被允许发送该请求的授权客户端。
- en: '![](09fig02_alt.jpg)'
  id: totrans-1092
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig02_alt.jpg)'
- en: First, we must consider how to encrypt the communications between two entities
    (for example, between an app and a web Thing) so that a malicious interceptor—a
    “man in the middle”—can’t access the data being transmitted in clear text. This
    is referred to as securing the channel and will be covered in [section 9.1.1](#ch09lev2sec1).
  id: totrans-1093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们必须考虑如何加密两个实体之间的通信（例如，应用程序和Web物品之间的通信），以便恶意拦截者——“中间人”——无法访问以明文形式传输的数据。这被称为保护通道，将在[第9.1.1节](#ch09lev2sec1)中讨论。
- en: Second, we must find a way to ensure that when a client talks to a host, it
    can ensure that the host is really “himself,” which is the topic discussed in
    [section 9.1.2](#ch09lev2sec2). For example, in [chapter 4](kindle_split_011.html#ch04),
    you downloaded and installed NOOBS from our website. But you did so via HTTP instead
    of HTTPS, and we didn’t provide an SHA checksum available for that image over
    HTTPS. In essence, you had to trust that whatever you downloaded was really what
    we gave you and not a corrupted OS image inserted by an attacker.
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，我们必须找到一种方法来确保当客户端与主机通信时，它可以确保主机确实是“他自己”，这是[第9.1.2节](#ch09lev2sec2)中讨论的主题。例如，在[第4章](kindle_split_011.html#ch04)中，您从我们的网站上下载并安装了NOOBS。但是您是通过HTTP而不是HTTPS来做的，我们没有提供通过HTTPS可用的SHA校验和。本质上，您必须相信您下载的确实是我们所提供的，而不是攻击者插入的损坏的操作系统镜像。
- en: Third, we must ensure that the correct access control is in place. We need to
    set up a method to control which user can access what resource of what server
    or Thing and when and then to ensure that the user is really who they claim to
    be. This topic will be covered in [section 9.2](#ch09lev1sec2).
  id: totrans-1095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，我们必须确保正确的访问控制措施得到实施。我们需要设置一种方法来控制哪个用户可以访问哪个服务器或物品的资源，以及何时访问，然后确保用户确实是他们声称的那个人。这个主题将在[第9.2节](#ch09lev1sec2)中讨论。
- en: 'After exploring these three problems and their solutions, in [section 9.3](#ch09lev1sec3)
    we’ll blur another line: the one between the Social Web and the Web of Things.
    We’ll put together everything you’ve learned so far to build an application that
    allows you to use third-party social network identities to share Things with your
    friends.'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了这三个问题和它们的解决方案之后，在[第9.3节](#ch09lev1sec3)中，我们将模糊另一条界限：社交网络和物联网之间的界限。我们将把迄今为止所学的一切整合起来，构建一个应用程序，允许您使用第三方社交网络身份与您的朋友分享物品。
- en: 9.1.1\. Encryption 101
  id: totrans-1097
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1\. 加密基础
- en: As you’ve seen before, there’s more to security than encryption. Nevertheless,
    encryption is an essential ingredient for any secure system. Without encryption,
    any attempt to secure a Thing will be in vain because attackers can sniff the
    communication and understand the security mechanisms that were put in place.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所见，安全不仅仅是加密。尽管如此，加密是任何安全系统的基本要素。没有加密，任何尝试保护事物的尝试都将徒劳无功，因为攻击者可以嗅探通信并理解所实施的安全机制。
- en: 'Using a web protocol without encryption can be compared to sending a postcard
    via snail mail: anyone can read the content of the postcard at any stage. Adding
    encryption to a web protocol is like putting the postcard in a thick and sealed
    envelope: even if you can see the envelope, you can’t read the card!'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未加密的Web协议可以比作通过蜗牛邮件发送明信片：任何人都可以在任何阶段阅读明信片的内容。将加密添加到Web协议中就像将明信片放入厚厚的密封信封中：即使你能看到信封，你也无法阅读卡片！
- en: Symmetric encryption
  id: totrans-1100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对称加密
- en: The oldest form of encoding a message is *symmetric encryption*. The idea is
    that the sender and receiver share a secret key that can be used to both encode
    and decode a message in a specific way; for example, by substituting or shifting
    some characters by a number. This type of encryption is the easiest to put in
    place for resource-limited IoT devices, but the problem is that as soon someone
    discovers the key, they can decode and encode any message. To use a symmetric
    key successfully, the key has to be shared with trusted parties securely, such
    as by giving the key to the recipient in person.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 信息编码的最古老形式是*对称加密*。其理念是发送者和接收者共享一个秘密密钥，该密钥可以用来以特定方式编码和解码信息；例如，通过替换或移位某些字符。这种加密方式对于资源有限的物联网设备来说最容易实施，但问题是，一旦有人发现了密钥，他们就可以解码和编码任何信息。要成功使用对称密钥，必须安全地将密钥与受信任的各方共享，例如亲自将密钥交给接收者。
- en: Asymmetric encryption
  id: totrans-1102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 非对称加密
- en: In the internet era, another method called *asymmetric encryption* has become
    popular because it doesn’t require a secret to be shared between parties. This
    method uses two related keys, one public and the other private (secret), as shown
    in [figure 9.3](#ch09fig03). A host can freely share its public key with anyone
    over the internet. When any client wants to send a message to the host, it can
    use the public key to encode the message before sending it. Once a message is
    encoded with the public key, it can be decoded only with the private key that’s
    known only by the host. This way, any message sent by a client (for example, a
    web app) to a server (for example, a web Thing) can be opened only by the server
    and not by an eavesdropper.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网时代，另一种称为*非对称加密*的方法变得流行，因为它不需要在各方之间共享秘密。这种方法使用两个相关的密钥，一个是公钥，另一个是私钥（秘密），如图9.3所示。[图9.3](#ch09fig03)。主机可以自由地将其公钥与互联网上的任何人分享。当任何客户端想要向主机发送消息时，它可以使用公钥在发送之前对消息进行编码。一旦消息用公钥编码，就只能用只有主机知道的私钥来解码。这样，任何客户端（例如，Web应用）发送给服务器（例如，Web设备）的消息只能由服务器打开，而不能由窃听者打开。
- en: Figure 9.3\. Asymmetric encryption in an IoT context. The heater shares its
    public key with Lena. It’s then up to Lena’s mobile app to encrypt messages sent
    to the heater. Thanks to the power of cryptography, the only way to decrypt the
    message is with the private key of the heater.
  id: totrans-1104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3。物联网环境中的非对称加密。加热器将其公钥与Lena分享。然后，由Lena的移动应用来加密发送给加热器的消息。多亏了密码学的力量，解密消息的唯一方法就是使用加热器的私钥。
- en: '![](09fig03_alt.jpg)'
  id: totrans-1105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig03_alt.jpg)'
- en: '9.1.2\. Web security with TLS: the S of HTTPS!'
  id: totrans-1106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2. 使用TLS的Web安全：HTTPS中的S！
- en: Fortunately, there are standard protocols for securely encrypting data between
    clients and servers on the web. The best known protocol for this is Secure Sockets
    Layer (SSL). SSL has long been the technology that sits behind the *S* in HTTPS,
    which is the method used to encrypt all the communications between your browser
    and a web server. But a number of important vulnerabilities in the SSL protocol
    have been discovered over the years, making it possible for attackers to crack
    the security SSL provides. In 2014, major vulnerabilities in the SSL 3.0 protocols
    were found; for example, POODLE,^([[7](#ch09fn07)]) Heartbleed,^([[8](#ch09fn08)])
    and Shellshock.^([[9](#ch09fn09)]) These events inked the death of this protocol,
    which was replaced by the much more secure but conceptually similar Transport
    Layer Security (TLS).^([[10](#ch09fn10)])
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，存在标准协议，可以在客户端和服务器之间安全地加密数据。其中最著名的协议是安全套接字层（SSL）。SSL长期以来一直是HTTPS中“S”背后的技术，这是浏览器和网站服务器之间加密所有通信的方法。但多年来，SSL协议中发现了许多重要漏洞，使得攻击者能够破解SSL提供的安全。2014年，SSL
    3.0协议中发现了重大漏洞；例如，POODLE^([[7](#ch09fn07)]), Heartbleed^([[8](#ch09fn08)]), 和Shellshock^([[9](#ch09fn09)]).
    这些事件标志着该协议的终结，它被更安全但概念上相似的传输层安全性（TLS）所取代.^([[10](#ch09fn10)])
- en: ⁷
  id: totrans-1108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-1109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://blog.mozilla.org/security/2014/10/14/the-poodle-attack-and-the-end-of-ssl-3-0/](https://blog.mozilla.org/security/2014/10/14/the-poodle-attack-and-the-end-of-ssl-3-0/)'
  id: totrans-1110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://blog.mozilla.org/security/2014/10/14/the-poodle-attack-and-the-end-of-ssl-3-0/](https://blog.mozilla.org/security/2014/10/14/the-poodle-attack-and-the-end-of-ssl-3-0/)'
- en: ⁸
  id: totrans-1111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-1112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Heartbleed](https://en.wikipedia.org/wiki/Heartbleed)'
  id: totrans-1113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Heartbleed](https://en.wikipedia.org/wiki/Heartbleed)'
- en: ⁹
  id: totrans-1114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-1115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Shellshock_(software_bug)](https://en.wikipedia.org/wiki/Shellshock_(software_bug))'
  id: totrans-1116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Shellshock_(software_bug)](https://en.wikipedia.org/wiki/Shellshock_(software_bug))'
- en: ^(10)
  id: totrans-1117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10)
- en: ''
  id: totrans-1118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The long legacy of SSL means that today the acronym SSL is used as an umbrella
    term for both TLS and SSL.
  id: totrans-1119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SSL的长期历史意味着今天，SSL这个缩写被用作TLS和SSL的总称。
- en: This highlights two important points. First, no method or system is secure forever.
    Second, open protocols—and especially web protocols—are closely monitored and
    fixed as soon as flaws are identified. In consequence, all communications over
    the Web of Things are to be encrypted with TLS. We won’t give a full description
    of TLS here because it would take a chapter on its own—or a whole book, for that
    matter—but we’ll review the basics of TLS and focus on the key concepts while
    simplifying the complex bits.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 这突出了两个重要观点。首先，没有任何方法或系统是永远安全的。其次，开放协议——尤其是网络协议——一旦发现漏洞，就会受到密切监控并及时修复。因此，所有在物联网上的通信都应该使用TLS加密。在这里，我们不会对TLS进行完整描述，因为它需要单独的一章——或者整本书，但我们会回顾TLS的基本知识，并关注关键概念，同时简化复杂部分。
- en: TLS 101
  id: totrans-1121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: TLS 101
- en: Despite its name, TLS is an Application layer protocol (see [chapter 5](kindle_split_012.html#ch05)).
    TLS not only secures HTTP (HTTPS) communication but is also the basis of secure
    WebSocket (WSS) and secure MQTT (MQTTS). TLS has two main roles. First, it helps
    the client ensure that the server is who it says it is; this is the SSL/TLS authentication.
    Second, it guarantees that the data sent over the communication channel can’t
    be read by anyone other than the client and the server involved in the transaction
    (also known as SSL/TLS encryption).
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名为TLS，但它是一种应用层协议（参见[第5章](kindle_split_012.html#ch05)）。TLS不仅保障了HTTP（HTTPS）通信的安全，也是安全WebSocket（WSS）和安全MQTT（MQTTS）的基础。TLS有两个主要角色。首先，它帮助客户端确保服务器就是它所声称的那样；这就是SSL/TLS认证。其次，它保证通过通信通道发送的数据只能被参与交易的客户和服务器读取（也称为SSL/TLS加密）。
- en: 'A typical TLS exchange between a client and a server is shown in [figure 9.4](#ch09fig04).^([[11](#ch09fn11)])
    This is what happens when you use your browser to connect to an HTTPS website,
    such as [https://manning.com](https://manning.com). Here’s a summary of the most
    important steps:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器之间典型的TLS交换如图9.4所示。[图9.4](#ch09fig04).^([[11](#ch09fn11)]) 这就是当你使用浏览器连接到HTTPS网站，如[https://manning.com](https://manning.com)时会发生的情况。以下是最重要的步骤总结：
- en: ^(11)
  id: totrans-1124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(11)
- en: ''
  id: totrans-1125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you want an even simpler way of explaining TLS to your cat, check “What’s
    Behind the Padlock”: [https://casecurity.org/wp-content/uploads/2013/01/ssl-1200.jpg](https://casecurity.org/wp-content/uploads/2013/01/ssl-1200.jpg).'
  id: totrans-1126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想用更简单的方式向你的猫解释TLS，请查看“垫锁背后的秘密”：[https://casecurity.org/wp-content/uploads/2013/01/ssl-1200.jpg](https://casecurity.org/wp-content/uploads/2013/01/ssl-1200.jpg)。
- en: 'Figure 9.4\. SSL/TLS handshake: the client and the server first negotiate the
    protocols and encryption algorithms, and then the server sends its certificate
    chain to prove who it is to the client. Finally, the client sends a preMasterSecret
    from which the client and server derive a masterSecret used to encrypt all the
    future messages.'
  id: totrans-1127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4\. SSL/TLS握手：客户端和服务器首先协商协议和加密算法，然后服务器将其证书链发送给客户端以证明其身份。最后，客户端发送一个preMasterSecret，客户端和服务器从中推导出一个masterSecret，用于加密所有未来的消息。
- en: '![](09fig04_alt.jpg)'
  id: totrans-1128
  prefs: []
  type: TYPE_IMG
  zh: '![09fig04_alt.jpg](09fig04_alt.jpg)'
- en: '**1**.  The client, such as a mobile app, tells the server, such as a web Thing,
    which protocols and encryption algorithms it supports. This is somewhat similar
    to the content negotiation process we described in [chapter 6](kindle_split_014.html#ch06).'
  id: totrans-1129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 客户端，例如一个移动应用，会告诉服务器，例如一个Web设备，它支持哪些协议和加密算法。这有点类似于我们在[第6章](kindle_split_014.html#ch06)中描述的内容协商过程。'
- en: '**2**.  The server sends the public part of its certificate to the client.
    The goal here is for the client to make sure it knows who the server is. All web
    clients have a list of certificates they trust.^([[12](#ch09fn12)]) In the case
    of your Pi, you can find them in /etc/ssl/certs. SSL certificates form a trust
    chain, meaning that if a client doesn’t trust certificate S1 that the server sends
    back, but it trusts certificate S2 that was used to sign S1, the web client can
    accept S1 as well.'
  id: totrans-1130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 服务器将其证书的公钥发送给客户端。这里的目的是让客户端确保它知道服务器的身份。所有网络客户端都有一个它们信任的证书列表。[12](#ch09fn12)
    在你的Pi上，你可以在/etc/ssl/certs中找到它们。SSL证书形成了一个信任链，这意味着如果客户端不相信服务器发送的证书S1，但它信任用于签署S1的证书S2，那么网络客户端也可以接受S1。'
- en: ''
  id: totrans-1131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ^(12)
  id: totrans-1132
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([12](#ch09fn12))
- en: ''
  id: totrans-1133
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Firefox and Chrome, for example, trust certificates signed by those CAs; see
    [https://mozillacaprogram.secure.force.com/CA/IncludedCACertificateReport](https://mozillacaprogram.secure.force.com/CA/IncludedCACertificateReport).
  id: totrans-1134
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Firefox和Chrome等浏览器信任由这些CA签发的证书；请参阅[https://mozillacaprogram.secure.force.com/CA/IncludedCACertificateReport](https://mozillacaprogram.secure.force.com/CA/IncludedCACertificateReport)。
- en: '**3**.  The rest of the process generates a key from the public certificates.
    This key is then used to encrypt the data going back and forth between the server
    and the client in a secure manner. Because this process is dynamic, only the client
    and the server know how to decrypt the data they exchange during this session.
    This means the data is now securely encrypted: if an attacker manages to capture
    data packets, they will remain meaningless.'
  id: totrans-1135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 其余的过程从公钥证书生成一个密钥。然后，这个密钥被用来以安全的方式加密服务器和客户端之间来回传输的数据。因为这个过程是动态的，所以只有客户端和服务器知道如何解密他们在会话期间交换的数据。这意味着数据现在被安全地加密了：如果攻击者设法捕获数据包，它们将毫无意义。'
- en: 9.1.3\. Enabling HTTPS and WSS with TLS on your Pi
  id: totrans-1136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.3\. 在你的Pi上启用带有TLS的HTTPS和WSS
- en: Now that you’ve seen the theory, it’s time for a bit of practice! Let’s secure
    the API of your WoT Pi to ensure that traffic between the Pi and its clients is
    encrypted. Note that the process we define here works as well on all the other
    Linux devices we talked about—for example, the Intel Edison or the BeagleBone—as
    well as on any Linux- or Unix-based machines. Go ahead and generate a certificate.
    First, you need to make sure the OpenSSL library is installed. On your Pi go to
    the /resources directory and run
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了理论，是时候进行一些实践了！让我们确保你的WoT Pi的API安全，以确保Pi和其客户端之间的流量被加密。请注意，我们在这里定义的过程同样适用于我们讨论的所有其他Linux设备——例如，Intel
    Edison或BeagleBone——以及任何基于Linux或Unix的机器。继续生成一个证书。首先，你需要确保OpenSSL库已安装。在你的Pi上，前往/resources目录并运行
- en: '[PRE52]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This should tell you something along the lines of `openssl is already the newest
    version.` Or it will be installed if not present. Now, to generate the certificates,
    run
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会告诉你类似“openssl已经是最新版本。”的消息。如果没有安装，它将被安装。现在，要生成证书，请运行
- en: '[PRE53]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Because this command is self-explanatory we won’t detail it. No? Fine, let’s
    dig into it! The command does two things in one. First, it generates a private
    key (`-newkey rsa:2048 -keyout privateKey.pem)` that will be used to sign the
    certificate using the sha256 hashing algorithm. While it does this, you’ll see
    a `Generating a 2048 bit RSA private key` message followed by a prompt to provide
    a passphrase, essentially a password to protect your private key. Make sure you
    keep this one safe because you’ll need it soon!
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此命令是自我解释的，我们不会详细说明。不？好吧，让我们深入探讨！该命令在一件事中做了两件事。首先，它生成一个私钥（`-newkey rsa:2048
    -keyout privateKey.pem`），该私钥将用于使用sha256哈希算法签署证书。在此过程中，你会看到一个“生成2048位RSA私钥”的消息，然后是一个提示提供密码短语，实际上是一个用于保护你的私钥的密码。确保你将其安全保存，因为你很快就会需要它！
- en: Second, it will generate a new certificate (`-out caCert.pem`) that will last
    for 1,095 days using the x509 data format, and it also prompts you with a few
    questions, as shown in [listing 9.1](#ch09ex01). The common name is the hostname
    for which this certificate should be valid; for example, `raspberrypi.local` if
    you’re on your Pi or `localhost` if you’re running these examples on your machine.
    The information you provide here will be exposed in the certificate and will be
    visible to all clients.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它将生成一个新的证书（`-out caCert.pem`），使用x509数据格式，有效期将长达1,095天，并且会提示你几个问题，如[列表9.1](#ch09ex01)所示。通用名称是此证书应有效的主机名；例如，如果你在Pi上，则为`raspberrypi.local`，如果你在这些示例中在自己的机器上运行，则为`localhost`。你在此处提供的信息将在证书中公开，并且对所有客户端可见。
- en: Listing 9.1\. Information requested when generating a self-signed certificate
  id: totrans-1143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1\. 生成自签名证书时请求的信息
- en: '![](255fig01_alt.jpg)'
  id: totrans-1144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](255fig01_alt.jpg)'
- en: 'At the end of this process, two files will be generated:'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程结束时，将生成两个文件：
- en: '*caCert.pem* is the public part of the certificate your Pi server will send
    to the clients when connecting to it via TLS.'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '`caCert.pem`是Pi服务器在通过TLS连接到它时发送给客户端的证书的公共部分。'
- en: '*privateKey.pem* is the private key of your Pi server and hence should be kept,
    well...private.'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: '`privateKey.pem`是Pi服务器的私钥，因此应该保密。'
- en: You’re now ready to turn your Pi unencrypted HTTP and WS APIs into secure HTTPS
    and WSS APIs. All you need to do is modify the code of the wot-server.js file
    at the root of your WoT PI project (see [chapters 7](kindle_split_015.html#ch07)
    and [8](kindle_split_016.html#ch08)). Copy the content of wot-server.js into a
    new wot-server-secure.js file and modify it as shown in the following listing,
    which enables HTTPS and WSS.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好将你的Pi未加密的HTTP和WS API转换为安全的HTTPS和WSS API。你需要做的只是修改WoT PI项目根目录下的wot-server.js文件的代码（参见[第7章](kindle_split_015.html#ch07)和[第8章](kindle_split_016.html#ch08)）。将wot-server.js的内容复制到一个新的wot-server-secure.js文件中，并按以下列表修改它，以启用HTTPS和WSS。
- en: Listing 9.2\. Modifying the WoT Pi server to serve HTTPS and WSS content
  id: totrans-1149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.2\. 修改WoT Pi服务器以提供HTTPS和WSS内容
- en: '![](ch09ex02-0.jpg)'
  id: totrans-1150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09ex02-0.jpg)'
- en: '![](ch09ex02-1.jpg)'
  id: totrans-1151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09ex02-1.jpg)'
- en: 'Finally, modify the wot.js file to require wot-server-secure.js, and start
    the server by running `nodewot.js`. Now, go to https://localhost:8484/properties/pir
    in your browser. You should get a warning saying that the connection is not private.
    What this really means appears in the small print: `ERR_CERT_AUTHORITY_INVALID.`
    This means that the certificate was generated by you and not by a certificate
    authority (CA) trusted by your browser. There are two ways to fix this: you can
    buy a certificate from a trusted CA, as explained in the next section, or you
    can tell your computer to trust the certificate you just created. The best way
    to do this is by adding the certificate to the trust store of your browser. The
    operation will differ depending on which environment you’re using, but here’s
    how to add it to Firefox: click I Understand The Risk (because now you do, don’t
    you?), Add Exception, and finally Confirm Security Exception. Other browsers like
    Chrome use the trust store of the underlying operating system. Hence, to ensure
    Chrome accepts your certificate, go to Preferences > Settings > Show Advanced
    Settings; in HTTPS/SSL click Manage Certificates. This should open the trust store
    of your operating system, where you can import the certificate. Adding self-signed
    SSL certificates directly to your operating system^([[13](#ch09fn13)]) will make
    it much easier for you to develop secure applications for your Pi.'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，修改 wot.js 文件以要求加载 wot-server-secure.js，并通过运行 `nodewot.js` 来启动服务器。现在，请在浏览器中访问
    https://localhost:8484/properties/pir。你应该会收到一个警告，说明连接不是私有的。这实际上意味着什么在细小字迹中显示出来：`ERR_CERT_AUTHORITY_INVALID`。这意味着证书是由你生成的，而不是由你的浏览器信任的证书颁发机构（CA）生成的。有两种方法可以解决这个问题：你可以从受信任的
    CA 购买证书，如下一节所述，或者你可以告诉你的计算机信任你刚刚创建的证书。最好的方法是将其添加到浏览器信任存储中。操作将取决于你使用的环境，但以下是将其添加到
    Firefox 的方法：点击“我了解风险”（因为你现在确实了解了，不是吗？），添加异常，最后确认安全异常。其他浏览器如 Chrome 使用底层操作系统的信任存储。因此，为了确保
    Chrome 接受你的证书，请转到“首选项”>“设置”>“显示高级设置”；在 HTTPS/SSL 中点击“管理证书”。这应该会打开操作系统的信任存储，在那里你可以导入证书。直接将自签名
    SSL 证书添加到你的操作系统^([[13](#ch09fn13)]) 将使你更容易为你的 Pi 开发安全的应用程序。
- en: ^(13)
  id: totrans-1153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(13)
- en: ''
  id: totrans-1154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://blog.getpostman.com/2014/01/28/using-self-signed-certificates-with-postman/](http://blog.getpostman.com/2014/01/28/using-self-signed-certificates-with-postman/)'
  id: totrans-1155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://blog.getpostman.com/2014/01/28/using-self-signed-certificates-with-postman/](http://blog.getpostman.com/2014/01/28/using-self-signed-certificates-with-postman/)'
- en: Once your browser trusts the certificate of your WoT Pi, you should be able
    to get the content returned and the browser should display the usual lock icon
    on the address bar. If you click it, you’ll see the details of your TLS certificate,
    as shown in [figure 9.5](#ch09fig05).
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的浏览器信任了你的 WoT Pi 的证书，你应该能够获取返回的内容，并且浏览器应该在地址栏上显示通常的锁图标。如果你点击它，你会看到你的 TLS
    证书的详细信息，如图 [9.5](#ch09fig05) 所示。
- en: Figure 9.5\. The server of the WoT Pi can now be accessed via HTTPS. The details
    of the secure connection and certificates can be reviewed by clicking the small
    lock icon on the address bar.
  id: totrans-1157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.5\. 现在可以通过 HTTPS 访问 WoT Pi 的服务器。可以通过点击地址栏上的小锁图标来查看安全连接和证书的详细信息。
- en: '![](09fig05_alt.jpg)'
  id: totrans-1158
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig05_alt.jpg)'
- en: Beyond self-signed certificates
  id: totrans-1159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 有关自签名证书之外的
- en: 'Clearly, having to deal with all these security exceptions isn’t nice, but
    these exceptions exist for a reason: to warn clients that part of the security
    usually covered by SSL/TLS can’t be guaranteed with the certificate you generated.
    Basically, although the encryption of messages will work with a self-signed certificate
    (the one you created with the previous command), the authenticity of the server
    (the Pi) can’t be guaranteed. In consequence, the chain of trust is broken—problem
    2 of [figure 9.2](#ch09fig02). In an IoT context, this means that attackers could
    pretend to be the Thing you think you’re talking to. This isn’t a big deal when
    your Things are accessible only on the local network, but as soon as you make
    them available on the web, this becomes critical.'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，不得不处理所有这些安全异常并不愉快，但这些异常存在是有原因的：为了警告客户端，通常由 SSL/TLS 覆盖的部分安全性不能保证使用你生成的证书。基本上，尽管消息的加密将使用自签名证书（你使用上一条命令创建的证书）工作，但服务器（Pi）的真实性无法保证。因此，信任链被打破——这是
    [图 9.2](#ch09fig02) 中的问题 2。在物联网环境中，这意味着攻击者可以假装成你认为是你正在与之交谈的设备。当你的设备仅限于本地网络时，这并不是什么大问题，但一旦你将它们放在网络上，这就会变得至关重要。
- en: The common way to generate certificates that guarantee the authenticity of the
    server is to get them from a well-known and trusted certificate authority (CA).
    There are a number of them on the web, such as Thawte, Symantec, and GeoTrust.
    The good thing about certificates issued by such CAs is that they verify who created
    the certificates, albeit with various degrees of rigor. This means that a client
    has a greater certainty of which server it’s talking to (authentication). In consequence,
    these certificates, or certificates generated using these, are trusted by a number
    of clients such as web browsers. More concretely, this means that web browsers
    and operating systems have these certificates in their trust store.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 生成保证服务器真实性的证书的常见方式是从知名且受信任的证书颁发机构（CA）获取。网上有许多这样的CA，例如Thawte、Symantec和GeoTrust。这类CA颁发的证书的好处是，它们会验证谁创建了证书，尽管严谨程度各不相同。这意味着客户端对其所交谈的服务器有更大的确定性（认证）。因此，这些证书或使用这些证书生成的证书被许多客户端（如网页浏览器）所信任。更具体地说，这意味着网页浏览器和操作系统将它们存储在信任存储中。
- en: 'The problem is that certificates issued by well-known CAs are certainly not
    free. The business of selling web security is a lucrative one! A direct and unfortunate
    consequence of this is that a number of sites use cheaper CAs that do a poorer
    job of checking to whom they deliver certificates, or they decide to not use secured
    connections at all. But this is rapidly changing: a number of major actors on
    the web, such as Mozilla, Akamai, Cisco, and the Internet Security Research Group,
    got together to create the Let’s Encrypt^([[14](#ch09fn14)]) project, an automated
    CA providing free and secure certificates for the public’s benefit. There are
    even ways to automatically generate certificates using Let’s Encrypt from a Raspberry
    Pi running a Node server with Express.^([[15](#ch09fn15)]) Now that you have the
    basics of TLS, you should consider this when moving your Pi to the World *Wild*
    Wide Web.'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，由知名CA（证书颁发机构）颁发的证书当然不是免费的。出售网络安全业务是一项有利可图的业务！这种做法的直接且不幸的后果是，许多网站使用成本较低的CA，这些CA在检查证书发放对象方面做得较差，或者他们决定完全不使用加密连接。但这种状况正在迅速改变：网络上的许多主要参与者，如Mozilla、Akamai、Cisco和互联网安全研究小组，共同发起创建了Let’s
    Encrypt^([[14](#ch09fn14)])项目，这是一个为公众利益提供免费和安全的CA自动化项目。甚至可以使用运行Express的Node服务器从Raspberry
    Pi上自动生成Let’s Encrypt证书.^([[15](#ch09fn15)]) 现在你已经了解了TLS的基础知识，当你将你的Pi迁移到万维网时，你应该考虑这一点。
- en: ^(14)
  id: totrans-1163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(14)
- en: ''
  id: totrans-1164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://letsencrypt.org](https://letsencrypt.org)'
  id: totrans-1165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://letsencrypt.org](https://letsencrypt.org)'
- en: ^(15)
  id: totrans-1166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(15)
- en: ''
  id: totrans-1167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/DylanPiercey/auto-sni](https://github.com/DylanPiercey/auto-sni)'
  id: totrans-1168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://github.com/DylanPiercey/auto-sni](https://github.com/DylanPiercey/auto-sni)'
- en: '|  |'
  id: totrans-1169
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The nerd corner—I want my Pi to be on the web!**'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术角落——我想让我的Pi上网！**'
- en: Once the development and testing phase of your WoT Pi is finished, you’ll likely
    want to make it accessible over the web with its own public domain; for example,
    mypi.webofthings.io. To do this, you could use Yaler,^([[a](#ch09fn1a)]) which
    is a great service and open source project that offers a relay to securely access
    your embedded devices through your firewall and supports mobile Things connecting
    to different networks. Alternatively, if you want to go the DIY route, you can
    use a dynamic DNS service—unless you already have a fixed IP address—that keeps
    monitoring the IP address of your home router to determine when it changes. There
    are a number of those, but Duck DNS is straightforward and free. Moreover, it
    provides clear explanations of how to install it on a Pi.^([[b](#ch09fn2a)]) Once
    this is set up, you’ll also have to set up port forwarding on your home router.^([[c](#ch09fn3a)])
    Then, you might also need to generate (or buy) a certificate with a common name
    corresponding to the new Duck DNS subdomain of your Pi; for example, mypi.duckdns.org.
    Once you’ve done all of this, your Pi should be truly on the world-wide Web of
    Things. But your Pi will also be ready for attackers to try to hack it, so make
    sure you protect it well, at the very least by reading to the end of this chapter
    and implementing the concepts we describe!
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的WoT Pi的开发和测试阶段完成时，你可能会想要通过自己的公共域名使其可通过网络访问；例如，mypi.webofthings.io。为此，你可以使用Yaler，^([[a](#ch09fn1a)])
    这是一个出色的服务和开源项目，它提供了一个中继，可以安全地通过防火墙访问你的嵌入式设备，并支持移动事物连接到不同的网络。或者，如果你想走DIY路线，你可以使用动态DNS服务——除非你已经有一个固定的IP地址——它会持续监控你的家庭路由器的IP地址以确定何时发生变化。有许多这样的服务，但Duck
    DNS简单且免费。此外，它提供了如何在Pi上安装它的清晰说明.^([[b](#ch09fn2a)]) 一旦设置好，你还需要在你的家庭路由器上设置端口转发.^([[c](#ch09fn3a)])
    然后，你可能还需要生成（或购买）一个与Pi的新Duck DNS子域对应的通用名称证书；例如，mypi.duckdns.org。一旦完成所有这些，你的Pi应该真正地连接到全球物联网。但你的Pi也将准备好让攻击者尝试攻击它，所以请确保你很好地保护它，至少要阅读到本章的结尾并实施我们描述的概念！
- en: ^a
  id: totrans-1172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-1173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.yaler.net/raspberrypi](https://www.yaler.net/raspberrypi)'
  id: totrans-1174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://www.yaler.net/raspberrypi](https://www.yaler.net/raspberrypi)'
- en: ^b
  id: totrans-1175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^b
- en: ''
  id: totrans-1176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.duckdns.org/install.jsp#pi](http://www.duckdns.org/install.jsp#pi)'
  id: totrans-1177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.duckdns.org/install.jsp#pi](http://www.duckdns.org/install.jsp#pi)'
- en: ^c
  id: totrans-1178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^c
- en: ''
  id: totrans-1179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://portforward.com/](http://portforward.com/)'
  id: totrans-1180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://portforward.com/](http://portforward.com/)'
- en: '|  |'
  id: totrans-1181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.2\. Authentication and access control
  id: totrans-1182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2\. 身份验证和访问控制
- en: 'Once we encrypt the communication between Things and clients as shown in the
    previous section, we want to enable only some applications to access it. Let’s
    get back to our hotel scenario to understand this issue. The hotel control center
    application needs to have full access to all devices in the network and the ability
    to configure and administer them. But Lena, who stays in room 212, only needs
    to access the devices and services in that room. Besides, she shouldn’t be able
    to configure them, only to send a limited set of commands. First, this means that
    the Things—or a gateway to which Things are connected—need to be able to know
    the sender of each request (*identification*). Second, devices need to trust that
    the sender really is who they claim to be (*authentication*). Third, the devices
    also need to know if they should accept or reject each request depending on the
    identity of this sender and which request has been sent (*authorization*). If
    encryption is like sending a postcard in a sealed envelope, authentication and
    authorization are like sending that envelope via registered mail: the postman
    will deliver the letter only to the correct recipient as long as they can prove
    their identity with a valid ID.'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将事物与客户端之间的通信加密，如前节所示，我们只想允许某些应用程序访问它。让我们回到我们的酒店场景来理解这个问题。酒店控制中心应用程序需要完全访问网络中的所有设备，并具有配置和管理它们的能力。但是，住在212号房的Lena只需要访问那个房间的设备和服务。此外，她不应该能够配置它们，而只能发送一组有限的命令。首先，这意味着事物或连接到事物的网关需要能够知道每个请求的发送者（*识别*）。其次，设备需要信任发送者确实是他们声称的那个人（*身份验证*）。第三，设备还需要知道它们是否应该根据发送者的身份和发送的请求来接受或拒绝每个请求（*授权*）。如果加密就像在密封的信封中发送明信片一样，那么身份验证和授权就像通过挂号信发送那个信封：邮递员只有在他们能够用有效的身份证证明自己的身份的情况下，才会将信件递送给正确的收件人。
- en: 9.2.1\. Access control with REST and API tokens
  id: totrans-1184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1\. 使用REST和API令牌进行访问控制
- en: Nowadays, we go through this authentication process all the time on the web,
    namely every time we enter our username and password on a website. When we use
    our username/password to log into a website, we initiate a secure session with
    the server that’s stored for a limited time in the server application’s memory
    or in a local browser cookie. During that time, we can send other requests to
    the server without authenticating again. This method (called *server-based authentication*)
    is usually stateful because the state of the client is stored on the server. But
    as you saw in [chapter 6](kindle_split_014.html#ch06), HTTP is a stateless protocol;
    therefore, using a server-based authentication method goes against this principle
    and poses certain problems. First, the performance and scalability of the overall
    systems are limited because each session must be stored in memory and overhead
    increases when there are many authenticated users. Second, this authentication
    method poses certain security risks—for example, cross-site request forgery.^([[16](#ch09fn16)])
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在网络上经常经历这个认证过程，即每次我们在网站上输入用户名和密码时。当我们使用用户名/密码登录网站时，我们与服务器启动一个安全的会话，该会话存储在服务器应用程序的内存中或本地浏览器cookie中，有效期为有限时间。在此期间，我们可以发送其他请求到服务器而无需再次认证。这种方法（称为*基于服务器的认证*）通常是状态性的，因为客户端的状态存储在服务器上。但正如您在[第6章](kindle_split_014.html#ch06)中看到的，HTTP是一个无状态协议；因此，使用基于服务器的认证方法违反了这一原则，并带来了一定的问题。首先，整个系统的性能和可扩展性受到限制，因为每个会话都必须存储在内存中，当有大量认证用户时，开销会增加。其次，这种认证方法存在一定的安全风险——例如，跨站请求伪造.^([[16](#ch09fn16)])
- en: ^(16)
  id: totrans-1186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(16)
- en: ''
  id: totrans-1187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This method exploits the fact that a malicious website can use your browser
    to send requests on your behalf to another website you’re logged into. See [https://en.wikipedia.org/wiki/Cross-site_request_forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery).
  id: totrans-1188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此方法利用了恶意网站可以使用您的浏览器代表您向已登录的另一个网站发送请求的事实。请参阅[https://en.wikipedia.org/wiki/Cross-site_request_forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)。
- en: To circumvent these issues, an alternative method called *token-based authentication*
    has become popular and is used by most web APIs. The idea is that a secret token—a
    long string of characters—that’s unique for each client can be used to authenticate
    each request sent by that client. Because this token is added to the headers or
    query parameters of each HTTP request sent to the server, all interactions remain
    stateless. Because no session or state needs to be kept on the server(s), applications
    can be scaled horizontally without having to worry about where the session of
    each user is stored.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了规避这些问题，一种称为*基于令牌的认证*的替代方法已经变得流行，并被大多数Web API所使用。其想法是，一个秘密令牌——一个对每个客户端唯一的字符长字符串——可以用来认证该客户端发送的每个请求。因为此令牌被添加到发送到服务器的每个HTTP请求的头部或查询参数中，所以所有交互都保持无状态。因为不需要在服务器（s）上保留会话或状态，应用程序可以在水平扩展时无需担心每个用户的会话存储位置。
- en: 'Obviously, the API token should be generated using a cryptographically secure
    pseudo-random generator^([[17](#ch09fn17)]) and should be treated like a password:
    stored in an encrypted manner.'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，API令牌应该使用密码学安全的伪随机数生成器生成^([[17](#ch09fn17)])，并且应该像密码一样处理：以加密方式存储。
- en: ^(17)
  id: totrans-1191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(17)
- en: ''
  id: totrans-1192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator)'
  id: totrans-1193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator)'
- en: To generate an API token with Node.js, you can use the `crypto.randomBytes()`
    function.^([[18](#ch09fn18)]) You’ll find the function in the /utils/utils.js
    file shown in the next listing.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Node.js生成API令牌，您可以使用`crypto.randomBytes()`函数.^([[18](#ch09fn18)]) 您可以在下一列表中显示的/utils/utils.js文件中找到此函数。
- en: ^(18)
  id: totrans-1195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(18)
- en: ''
  id: totrans-1196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)'
  id: totrans-1197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)'
- en: 'Listing 9.3\. utils/utils.js: generate a crypto-secure API token'
  id: totrans-1198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表9.3\. utils/utils.js: 生成加密安全的API令牌'
- en: '[PRE54]'
  id: totrans-1199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can call this function by uncommenting the following line in the http.js
    file:'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在http.js文件中取消注释以下行来调用此函数：
- en: '[PRE55]'
  id: totrans-1201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When you launch the WoT Pi server, you’ll see in the terminal a new API token,
    which you can copy and paste into the value of the `apiToken` key in the resources/auth.json
    file. This will be the API token you need to send any request to your Pi.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动WoT Pi服务器时，你将在终端看到一个新API令牌，你可以将其复制并粘贴到resources/auth.json文件中`apiToken`键的值。这将是你需要发送到Pi的API令牌。
- en: You’ll now modify the WoT Pi application so that for each request that comes
    in, you check if the request is signed using a valid API token; see the following
    listing. The best way to do this is to use the middleware pattern shown in the
    previous section. You’ll create an auth.js file in the middleware folder, which
    has a function that will be called each time a new request comes to your API and
    which checks if it is signed and valid.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在需要修改WoT Pi应用程序，以便对于每个进入的请求，你都要检查该请求是否使用有效的API令牌进行签名；请参阅以下列表。最好的做法是使用前一个章节中展示的中间件模式。你将在中间件文件夹中创建一个auth.js文件，该文件包含一个函数，每次有新的请求到达你的API时都会被调用，并检查其是否已签名且有效。
- en: 'Listing 9.4\. auth.js: authentication middleware'
  id: totrans-1204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表9.4\. auth.js: 认证中间件'
- en: '![](261fig01_alt.jpg)'
  id: totrans-1205
  prefs: []
  type: TYPE_IMG
  zh: '![](261fig01_alt.jpg)'
- en: 'Finally, you need to add this middleware function to the middleware chain in
    servers/http.js. Start by requiring the middleware with `auth = require(''./../middleware/auth''),`
    then add it to the chain using `app.use(auth());` right after the CORS middleware.
    Now, run the WoT server once again and then try accessing https://localhost:8484/properties/pir.
    You should now get an error message. Try again with https://localhost:8484/properties/pir?token=YOUR_TOKEN
    (or with Postman by adding the `Authorization` header with your token as value)
    and it should work: your API now requires a valid token!'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要将这个中间件函数添加到servers/http.js中的中间件链中。首先使用`auth = require('./../middleware/auth'),`引入中间件，然后使用`app.use(auth());`将其添加到链中，紧随CORS中间件之后。现在，再次运行WoT服务器，然后尝试访问https://localhost:8484/properties/pir。你现在应该会收到一个错误消息。再次尝试使用https://localhost:8484/properties/pir?token=YOUR_TOKEN（或者通过Postman添加带有你的令牌作为值的`Authorization`头）应该可以工作：你的API现在需要有效的令牌！
- en: In this minimal example, you manually check each request against a hard-coded
    API token. We wanted to show you the basics of how token-based authentication
    works, so this is not a robust and scalable solution ready for production applications.
    You’ll need to use a more elaborate solution that suits your use case and devices.
    Will you have many different users that all need to have their own API token,
    or is it fine to have only a single token? How granular does your access control
    need to be? How often will you need to add, remove, or change these permissions?
    As an exercise, you’re welcome to extend this simple token-based implementation
    to support many users and tokens and also the various end points of your Thing
    (including WebSockets interactions; see /servers/websocket.js for a solution).
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最小示例中，你将手动检查每个请求是否与硬编码的API令牌匹配。我们想要向你展示基于令牌的认证的基本工作原理，因此这不是一个健壮且可扩展的解决方案，不适合生产应用。你需要使用一个更复杂的解决方案，以适应你的用例和设备。你会有很多不同的用户，每个用户都需要自己的API令牌吗？或者只有一个令牌就足够了？你的访问控制需要多细粒度？你需要多久更改一次这些权限？作为一个练习，你可以扩展这个简单的基于令牌的实现，以支持多个用户和令牌，以及你的设备（包括WebSocket交互；参见/servers/websocket.js以获取解决方案）。
- en: '|  |'
  id: totrans-1208
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The nerd corner—I want better tokens!**'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术角落——我想要更好的令牌！**'
- en: Generating tokens manually and implementing a minimal token-based authentication
    system from scratch as shown before is a great exercise to help you understand
    how it works. But for anything more than that, you’ll be better off using an actual
    standard. JSON Web Tokens^([[a](#ch09fn4a)]) (JWT) is particularly interesting
    here because it not only generates secure tokens but also offers a standard mechanism
    to send encrypted payloads over insecure connections. In other words, JWT makes
    it possible to send secure content over HTTP and WebSocket packets without using
    TLS. This is particularly appealing for the WoT because it removes the self-generated
    certificate warnings in the browser you encountered earlier because certificates
    aren’t required for interactions between an app and Thing within a local network.
    It’s certainly not as standard and battle-tested as TLS, but we’ve had some promising
    results in our own tests. There are JWT libraries for many languages including
    Node.js, so go ahead and give it a try!
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 人工生成令牌并从头开始实现一个基于令牌的最小认证系统，就像之前展示的那样，是一个很好的练习，可以帮助你理解它是如何工作的。但对于任何超出这个范围的事情，你最好使用一个实际的标准。JSON
    Web Tokens^([[a](#ch09fn4a)])（JWT）在这里特别有趣，因为它不仅生成安全的令牌，还提供了一个标准机制来在非安全连接上发送加密的有效负载。换句话说，JWT使得在HTTP和WebSocket数据包上发送安全内容成为可能，而无需使用TLS。这对于WoT来说尤其有吸引力，因为它消除了你之前在浏览器中遇到的自动生成的证书警告，因为在本地网络中应用程序与事物之间的交互不需要证书。它当然不如TLS标准化和经过实战检验，但我们在自己的测试中已经取得了一些有希望的结果。JWT库支持许多语言，包括Node.js，所以你可以尝试一下！
- en: ^a
  id: totrans-1211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-1212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://jwt.io](https://jwt.io)'
  id: totrans-1213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://jwt.io](https://jwt.io)'
- en: '|  |'
  id: totrans-1214
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '9.2.2\. OAuth: a web authorization framework'
  id: totrans-1215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2. OAuth：一个Web授权框架
- en: In the previous section, we gave a brief introduction to API tokens, how they
    work, and how you can implement them on web Things. API tokens are a good starting
    point, and along with encryption (TLS), they are arguably the bare minimum a WoT
    device should offer in terms of security. But as soon as we need to share the
    resources of a device with several users having different authorization rights,
    simple API tokens like the ones we’ve introduced present two challenges.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们简要介绍了API令牌，它们的工作原理以及如何在Web Things上实现它们。API令牌是一个良好的起点，并且与加密（TLS）一起，它们可以说是WoT设备在安全方面应该提供的最基本功能。但是，一旦我们需要将设备的资源与具有不同授权权限的多个用户共享，我们之前介绍的简单API令牌就面临两个挑战。
- en: First, we need a process for web applications to generate and retrieve tokens
    dynamically, ideally through an API. Obviously, we can’t just create an API endpoint
    that returns tokens. This would be insecure and we’d be back where we started
    because we’d need to secure that API as well. Besides, creating a bespoke mechanism
    to get tokens wouldn’t foster interoperability; it would make the process complicated
    and bespoke for each device and/or API.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个流程，让Web应用程序能够动态地生成和检索令牌，理想情况下是通过API。显然，我们不能仅仅创建一个返回令牌的API端点。这将是不安全的，我们又会回到起点，因为我们也需要保护这个API。此外，创建一个获取令牌的定制机制不会促进互操作性；它会使过程变得复杂，并为每个设备/或API定制。
- en: Second, API tokens shouldn’t be valid forever. API tokens, just like passwords,
    should change regularly. We should also be able to invalidate any token manually
    when needed. This ensures that when an API token has leaked, we can disable it.
    But again, creating a custom API to renew tokens wouldn’t foster interoperability
    between web clients and web Things.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，API令牌不应永久有效。API令牌，就像密码一样，应该定期更换。我们还应该能够在需要时手动使任何令牌失效。这确保了当API令牌泄露时，我们可以禁用它。但再次强调，创建一个用于续订令牌的定制API不会促进Web客户端和Web
    Things之间的互操作性。
- en: 'What to do? It turns out there’s a web standard coming to our rescue: OAuth.^([[19](#ch09fn19)])
    OAuth is an open standard for authorization and is essentially a mechanism for
    a web or mobile app to delegate the authentication of a user to a third-party
    trusted service*;* for example, Facebook, LinkedIn, or Google. OAuth makes this
    delegated authentication process secure and simple by dynamically generating access
    tokens using only web protocols. OAuth also allows sharing resources and between
    applications. For instance, you can allow some of your Facebook friends to securely
    access some of your documents on Google.'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 该怎么办？事实证明，有一个网络标准即将来拯救我们：OAuth.^([[19](#ch09fn19)]) OAuth是一个开放标准，用于授权，本质上是一种机制，允许Web或移动应用将用户的认证委托给第三方可信服务*；*例如，Facebook、LinkedIn或Google。OAuth通过仅使用Web协议动态生成访问令牌，使委托认证过程既安全又简单。OAuth还允许应用程序之间共享资源。例如，您可以允许一些Facebook朋友安全地访问您在Google上的一些文档。
- en: ^(19)
  id: totrans-1220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(19)
- en: ''
  id: totrans-1221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)'
  id: totrans-1222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)'
- en: 'In short, OAuth standardizes how to authenticate users, generate tokens with
    an expiration date, regenerate tokens, and provide access to resources in a secure
    and standard manner over the web. Sound like exactly what we need, doesn’t it?
    Let’s see how to do this in practice using the most recent version of the OAuth
    standard: OAuth 2.0.'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，OAuth标准化了如何在网络上以安全且标准的方式验证用户、生成带有过期日期的令牌、更新令牌以及提供对资源的访问。听起来这正是我们所需要的，不是吗？让我们看看如何使用最新的OAuth标准：OAuth
    2.0来实现这一点。
- en: OAuth roles
  id: totrans-1224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: OAuth角色
- en: 'A typical OAuth scenario involves four roles:'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的OAuth场景涉及四个角色：
- en: '***A resource owner—*** This is the user who wants to authorize an application
    to access one of their trusted accounts; for example, your Facebook account.'
  id: totrans-1226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***资源所有者—*** 这是想要授权应用程序访问其信任账户之一的用户；例如，您的Facebook账户。'
- en: '***The resource server—*** Is the server providing access to the resources
    the user wants to share? In essence, this is a web API accepting OAuth tokens
    as credentials.'
  id: totrans-1227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***资源服务器—*** 是提供用户想要共享的资源访问权限的服务器吗？本质上，这是一个接受OAuth令牌作为凭证的Web API。'
- en: '***The authorization server—*** This is the OAuth server managing authorizations
    to access the resources. It’s a web server offering an OAuth API to authenticate
    and authorize users. In some cases, the resource server and the authorization
    server can be the same, such as in the case of Facebook.'
  id: totrans-1228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***授权服务器—*** 这是管理访问资源授权的OAuth服务器。它是一个提供OAuth API以验证和授权用户的Web服务器。在某些情况下，资源服务器和授权服务器可以是同一个，例如在Facebook的情况下。'
- en: '***The application—*** This is the web or mobile application that wants to
    access the resources of the user. To keep the trust chain, the application has
    to be known by the authorization server in advance and has to authenticate itself
    using a secret token, which is an API key known only by the authorization server
    and the application.'
  id: totrans-1229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***应用程序—*** 这是想要访问用户资源的Web或移动应用程序。为了保持信任链，应用程序必须在授权服务器中预先知道，并必须使用一个秘密令牌进行身份验证，这个令牌是一个只有授权服务器和应用程序知道的API密钥。'
- en: The flow of a typical OAuth-delegated authentication mechanism is shown in [figure
    9.6](#ch09fig06). At the end of the token exchange process, the application will
    know who the user is and will be able to access resources on the resource server
    on behalf of the user. The application can then also renew the token before it
    expires using an optional refresh token or by running the authorization process
    again.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的OAuth委托认证机制的流程如图9.6所示。在令牌交换过程结束时，应用程序将知道用户是谁，并将能够代表用户访问资源服务器上的资源。然后，应用程序还可以使用可选的刷新令牌或重新运行授权过程来在令牌过期之前更新令牌。
- en: Figure 9.6\. OAuth delegated authentication and access flow. The application
    asks the user if they want to give it access to resources on a third-party trusted
    service (resource server). If the user accepts, an authorization grant code is
    generated. This code can be exchanged for an access token with the authorization
    server. To make sure the authorization server knows the application, the application
    has to send an app ID and app secret along with the authorization grant code.
    The access token can then be used to access protected resources within a certain
    scope from the resource server.
  id: totrans-1231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.6。OAuth委托认证和访问流程。应用程序会询问用户是否希望授予它访问第三方可信服务（资源服务器）上的资源的权限。如果用户接受，将生成一个授权授予代码。此代码可以与授权服务器交换以获取访问令牌。为了确保授权服务器知道应用程序，应用程序必须发送一个应用程序ID和应用程序密钥，以及授权授予代码。然后可以使用访问令牌从资源服务器访问一定范围内的受保护资源。
- en: '![](09fig06_alt.jpg)'
  id: totrans-1232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig06_alt.jpg)'
- en: OAuth has become a successful protocol, and as a consequence, a large number
    of services on the web such as social networks (for example, Facebook, Google+,
    LinkedIn, and Twitter), developer services (for example, GitHub and BitBucket),
    and many other websites (such as TripAdvisor and Meetup) support OAuth. But what
    about the IoT? How does OAuth relate to our web Things?
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth已经成为一个成功的协议，因此，许多网络服务，如社交网络（例如，Facebook、Google+、LinkedIn和Twitter）、开发者服务（例如，GitHub和BitBucket）以及许多其他网站（如TripAdvisor和Meetup）都支持OAuth。但是，物联网呢？OAuth如何与我们的网络事物相关？
- en: OAuth and the Web of Things
  id: totrans-1234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: OAuth和网络事物
- en: For a start, if all Things become OAuth servers in place of generating API tokens,
    web clients will then have a standard way to obtain tokens to access the resources
    of devices.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果所有事物都成为OAuth服务器而不是生成API令牌，网络客户端将有一个标准的方式来获取令牌以访问设备的资源。
- en: Let’s get back to our hotel scenario once again. Lena is the user in [figure
    9.6](#ch09fig06) and she has a user account on the heater unit of [figure 9.2](#ch09fig02),
    which is both the authorization server and the resource server. Lena uses a mobile
    app to control the heater, as shown in [figure 9.6](#ch09fig06). The application
    asks Lena to log into the heater with her user account, and then the application
    exchanges the resulting authorization grant for an access token from the heater
    unit. The heater unit accepts the access token and provides access to the heater
    to the application on behalf of Lena.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回到我们的酒店场景。Lena是图9.6中的用户，她在图9.2中的暖气单元上有一个用户账户，该单元既是授权服务器也是资源服务器。Lena使用一个移动应用程序来控制暖气，如图9.6所示。应用程序要求Lena使用她的用户账户登录暖气，然后应用程序将生成的授权授予交换为暖气单元的访问令牌。暖气单元接受访问令牌，并代表Lena向应用程序提供暖气访问权限。
- en: If Lena was interacting with her heater in her home, this would be a practical
    scenario. But in the case of the hotel, that means that the heater and all other
    devices would need to know about Lena and all the other hotel clients. Besides,
    all devices would also need to know all the applications that would interact with
    them and would need to have generated a secret token for each of them. It’s pretty
    obvious this approach would be a nightmare to maintain!
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Lena在与她家的暖气互动，这将是一个实际场景。但在酒店的情况下，这意味着暖气和其他所有设备都需要了解Lena和其他所有酒店客户。此外，所有设备还需要了解所有将与它们交互的应用程序，并且需要为每个应用程序生成一个秘密令牌。很明显，这种方法维护起来将会是一场噩梦！
- en: Implementing an OAuth server on a Linux-based embedded device such as the Pi
    or the Intel Edison isn’t hard because the protocol isn’t really heavy. But maintaining
    the list of all applications, users, and their access scope on each Thing is clearly
    not going to work and scale for the IoT. We’ll look at a better approach in the
    next section.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Linux的嵌入式设备上实现OAuth服务器，如Pi或Intel Edison并不困难，因为该协议并不真正复杂。但是，维护每个事物上所有应用程序、用户及其访问范围的列表显然不会适用于物联网。我们将在下一节中探讨一个更好的方法。
- en: '|  |'
  id: totrans-1239
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The nerd corner—I want my Pi to be an OAuth server!**'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: '**极客角落——我想让我的Pi成为一个OAuth服务器！**'
- en: If you do want to turn your Pi into an OAuth server, go ahead! It will be a
    good exercise to help you better understand the protocol and will actually make
    the implementation in the next section more secure. A good place to start is the
    `node-oauth2-server` Node.js module for Express, which should run seamlessly on
    your Pi, Edison, or BeagleBone.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想将你的 Pi 转换成一个 OAuth 服务器，那就去做吧！这将是一个很好的练习，帮助你更好地理解协议，实际上也会使下一节的实现更加安全。一个不错的起点是
    Express 的 `node-oauth2-server` Node.js 模块，它应该可以在你的 Pi、Edison 或 BeagleBone 上无缝运行。
- en: '|  |'
  id: totrans-1242
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.3\. The Social Web of Things
  id: totrans-1243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3. 物联网的社会网络
- en: Using OAuth to manage access control to Things is tempting, but not if each
    Thing has to maintain its own list of users and application. This is where the
    gateway integration pattern we discovered in [chapter 7](kindle_split_015.html#ch07)
    can help. What if you had only a single proxy that would know the Things you have
    at home (or in the entire hotel) and also know the various users involved, so
    it could manage access control in place of these Things? “But then I still have
    to create user accounts on this proxy for each user,” we hear you say. Of course,
    you could do that, but a much better approach would be to use the notion of delegated
    authentication offered by OAuth, which allows you to use the accounts you already
    have with OAuth providers you trust, such as Facebook, Twitter, or LinkedIn.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OAuth 来管理对 Things 的访问控制很有吸引力，但如果每个 Thing 都必须维护自己的用户和应用列表，那就不是这样了。这就是我们在第
    7 章 [chapter 7](kindle_split_015.html#ch07) 中发现的网关集成模式能帮到的地方。如果你只有一个代理，它不仅知道你家里（或整个酒店）的
    Things，还知道所有相关的用户，那么它就可以代替这些 Things 来管理访问控制，这会怎么样呢？“但是我还是得在这个代理上为每个用户创建用户账户，”我们听到你这么说。当然，你可以这样做，但更好的方法是用
    OAuth 提供的委托认证概念，这允许你使用你在信任的 OAuth 提供商（如 Facebook、Twitter 或 LinkedIn）上已有的账户。
- en: Not only does this approach allow you to reuse the user accounts you already
    have in other web services, but it also allows you share access to your devices
    via existing social network relationships. These concepts are often referred to
    as the Social Web of Things.^([[20](#ch09fn20)]) Let’s see what this would look
    like in more detail. As with all things security, this won’t be the easiest ride
    but will definitely be a rewarding one.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不仅允许你重用你在其他网络服务中已有的用户账户，还允许你通过现有的社交网络关系共享对设备的访问。这些概念通常被称为物联网的社会网络.^([[20](#ch09fn20)])
    让我们更详细地看看这会是什么样子。就像所有与安全相关的事情一样，这不会是最容易的旅程，但绝对是一次值得的旅程。
- en: ^(20)
  id: totrans-1246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(20)
- en: ''
  id: totrans-1247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The Social Web of Things was a concept developed in Dom’s thesis ([http://webofthings.org/2011/12/01/phd-web-of-things-app-archi/](http://webofthings.org/2011/12/01/phd-web-of-things-app-archi/))
    based on the Friends and Things project: [http://webofthings.org/2010/02/02/sharing-in-a-web-of-things/](http://webofthings.org/2010/02/02/sharing-in-a-web-of-things/).'
  id: totrans-1248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 物联网的社会网络是 Dom 在他的论文 [http://webofthings.org/2011/12/01/phd-web-of-things-app-archi/](http://webofthings.org/2011/12/01/phd-web-of-things-app-archi/)
    中提出的一个概念，基于 Friends and Things 项目：[http://webofthings.org/2010/02/02/sharing-in-a-web-of-things/](http://webofthings.org/2010/02/02/sharing-in-a-web-of-things/)。
- en: 9.3.1\. A Social Web of Things authentication proxy
  id: totrans-1249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1. 物联网的社会网络认证代理
- en: The idea of the Social Web of Things is to create an authentication proxy that
    controls access to all Things it proxies by identifying users of client applications
    using trusted third-party services. The detailed steps for this workflow are shown
    in [figure 9.7](#ch09fig07).
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网的社会网络的想法是创建一个认证代理，通过识别客户端应用程序的用户使用受信任的第三方服务来控制它所代理的所有 Things 的访问。这个工作流程的详细步骤在
    [图 9.7](#ch09fig07) 中展示。
- en: 'Figure 9.7\. Social Web of Things authentication proxy: the auth proxy first
    establishes a secret with the Thing over a secure channel. Then, a client app
    requests access to a resource via the auth proxy. It authenticates itself via
    an OAuth server (here Facebook) and gets back an access token. This token is then
    used to access resources on the Thing via the auth proxy. For instance, the /temp
    resource is requested by the client app and given access via the auth proxy forwarding
    the request to the Thing and relaying the response to the client app.'
  id: totrans-1251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.7. 物联网的社会网络认证代理：认证代理首先通过安全通道与 Thing 建立一个密钥。然后，客户端应用程序通过认证代理请求访问资源。它通过 OAuth
    服务器（这里为 Facebook）进行身份验证，并获取一个访问令牌。然后，这个令牌被用来通过认证代理访问 Thing 上的资源。例如，客户端应用程序请求 /temp
    资源，并通过认证代理将请求转发到 Thing，并将响应转达到客户端应用程序。
- en: '![](09fig07_alt.jpg)'
  id: totrans-1252
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig07_alt.jpg)'
- en: 'Again, we have four actors: a Thing, a user using a client application, an
    authentication proxy, and a social network (or any other service with an OAuth
    server). The client app can use the authentication proxy and the social network
    to access resources on the Thing. This concept can be implemented in three phases:'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有四个参与者：一个设备、一个使用客户端应用的用户、一个认证代理和一个社交网络（或任何具有OAuth服务器的其他服务）。客户端应用可以使用认证代理和社交网络来访问设备上的资源。这个概念可以在三个阶段中实现：
- en: '**1**.  The first phase is the *Thing proxy trust*. The goal here is to ensure
    that the proxy can access resources on the Thing securely. If the Thing is protected
    by an API token (device token), it could be as simple as storing this token on
    the proxy. If the Thing is also an OAuth server, this step follows an OAuth authentication
    flow, as shown in [figure 9.6](#ch09fig06). Regardless of the method used to authenticate,
    after this phase the auth proxy has a secret that lets it access the resources
    of the Thing.'
  id: totrans-1254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 第一阶段是**设备代理信任**阶段。这里的目的是确保代理可以安全地访问设备的资源。如果设备受API令牌（设备令牌）保护，那么这可以简单地将此令牌存储在代理上。如果设备也是OAuth服务器，则此步骤遵循OAuth认证流程，如[图9.6](#ch09fig06)所示。无论使用哪种认证方法，在这个阶段之后，认证代理都有一个秘密，允许它访问设备的资源。'
- en: '**2**.  The second phase is the *delegated authentication* step. Here, the
    user in the client app authenticates via an OAuth authorization server as in [figure
    9.6](#ch09fig06). The authentication proxy uses the access token returned by the
    authorization server to identify the user of the client app and checks to see
    if the user is authorized to access the Thing. If so, the proxy returns the access
    token or generates a new one to the client app.'
  id: totrans-1255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 第二阶段是**委托认证**步骤。在这里，客户端应用中的用户通过OAuth授权服务器进行认证，如[图9.6](#ch09fig06)所示。认证代理使用授权服务器返回的访问令牌来识别客户端应用的用户，并检查用户是否有权访问该设备。如果有，代理将访问令牌或生成一个新的令牌返回给客户端应用。'
- en: '**3**.  The last phase is the *proxied access* step. Once the client app has
    a token, it can use it to access the resources of the Thing through the authentication
    proxy. If the token is valid, the authentication proxy will forward the request
    to the Thing using the secret (device token) it got in phase 1 and send the response
    back to the client app.'
  id: totrans-1256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 最后阶段是**代理访问**步骤。一旦客户端应用获得令牌，它就可以使用它通过认证代理访问设备的资源。如果令牌有效，认证代理将使用在第一阶段获得的秘密（设备令牌）将请求转发到设备，并将响应发送回客户端应用。'
- en: In order not to leak any tokens at any step, all the communication has to be
    encrypted using TLS. The details for each phase are summarized in [figure 9.7](#ch09fig07).
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不在任何步骤中泄露任何令牌，所有通信都必须使用TLS进行加密。每个阶段的详细信息总结在[图9.7](#ch09fig07)中。
- en: Leveraging social networks
  id: totrans-1258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 利用社交网络
- en: 'You might have noticed that we overlooked one step in the process: how does
    the auth proxy know what resources a user can access, or even if they can access
    any resources at all? Someone needs to configure the proxy with a number of user
    identifiers corresponding to the users who can access the system along with a
    list of resources they can access. In the case of our hotel, we could ask the
    guests to log in with their Facebook accounts or, even better, with the Booking.com
    profile they used to book the hotel room in the first place! Then we could save
    their social identifiers in the auth proxy, along with the paths to the devices
    in their room. In the case of a home automation system, you can even imagine granting
    access to lists of friends or relatives. [Figure 9.8](#ch09fig08) is an example
    of a user interface on the auth proxy that can let you share resources with your
    friends.'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们在过程中遗漏了一步：认证代理如何知道用户可以访问哪些资源，甚至他们是否可以访问任何资源？有人需要配置代理，包括与可以访问系统的用户相对应的一组用户标识符以及他们可以访问的资源列表。在我们的酒店案例中，我们可以要求客人使用他们的Facebook账户登录，或者更好的是，使用他们最初预订酒店房间时使用的Booking.com个人资料！然后我们可以在认证代理中保存他们的社交标识符，以及他们房间中设备的路径。在家庭自动化系统的案例中，甚至可以想象授予朋友或亲戚访问列表的权限。[图9.8](#ch09fig08)是认证代理上的一个用户界面示例，可以让你与朋友共享资源。
- en: 'Figure 9.8\. User interface of a Social Web of Things authorization proxy:
    First (upper left), the UI allows the user to select a Thing to be shared and
    (lower left) the resource of the Thing that should be shared; for example, /temperature.
    Then (upper right) it lets the owner of the Thing log into their social network,
    such as Facebook, and (lower right) select a friend to share with or a list of
    friends. Here we share the temperature sensor of the Spot1 device with Dom’s sister
    via Facebook. [Source: Friends and Things Social Web of Things project^([[21](#ch09fn21)])]'
  id: totrans-1260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.8\. 社交物联网授权代理的用户界面：首先（左上角），UI允许用户选择要共享的设备以及（左下角）应共享的设备资源；例如，/temperature。然后（右上角）它允许设备所有者登录到他们的社交网络，例如Facebook，以及（右下角）选择要共享的朋友或朋友列表。在这里，我们通过Facebook与Dom的妹妹共享Spot1设备的温度传感器。[来源：朋友和事物社交物联网项目^([[21](#ch09fn21)])]
- en: ^(21)
  id: totrans-1261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(21)
- en: ''
  id: totrans-1262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://webofthings.org/2010/02/02/sharing-in-a-web-of-things/](http://webofthings.org/2010/02/02/sharing-in-a-web-of-things/)'
  id: totrans-1263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://webofthings.org/2010/02/02/sharing-in-a-web-of-things/](http://webofthings.org/2010/02/02/sharing-in-a-web-of-things/)'
- en: '![](09fig08_alt.jpg)'
  id: totrans-1264
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig08_alt.jpg)'
- en: 'The good news is that nothing here needs to be hard-coded. Thanks to the fact
    that our Things speak web (see [chapters 5](kindle_split_012.html#ch05) and [6](kindle_split_014.html#ch06)),
    we can discover their resources (see [chapter 7](kindle_split_015.html#ch07))
    and map them to our connections on various OAuth-compliant social networks! This
    is the very idea of the Social Web of Things: instead of creating abstract access
    control lists, we can reuse existing social structures as a basis for sharing
    our Things. Because social networks increasingly reflect our social relationships,
    we can reuse that knowledge to share access to our Things with friends via Facebook,
    or work colleagues via LinkedIn.'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是这里不需要硬编码任何内容。多亏了我们的设备都支持Web（参见[第5章](kindle_split_012.html#ch05)和[第6章](kindle_split_014.html#ch06)），我们可以发现它们的资源（参见[第7章](kindle_split_015.html#ch07)），并将它们映射到我们在各种OAuth兼容社交网络上的连接！这正是社交物联网的核心理念：我们不是创建抽象的访问控制列表，而是可以重用现有的社交结构作为共享我们设备的基础。因为社交网络越来越多地反映了我们的社会关系，我们可以重用这些知识，通过Facebook与朋友共享我们设备的访问权限，或者通过LinkedIn与工作同事共享。
- en: 9.3.2\. Implementing a Social WoT authentication proxy
  id: totrans-1266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. 实现一个社交WoT认证代理
- en: Now that you’ve seen the theory, let’s put this into practice and implement
    a simple authentication proxy for the Social Web of Things, as shown in [figure
    9.9](#ch09fig09).
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了理论，让我们将其付诸实践，并实现一个简单的社交物联网认证代理，如图9.9所示。
- en: 'Figure 9.9\. A Social Web of Things authentication proxy for your Pi: client
    apps obtain a token via OAuth on Facebook; this token can then be used to access
    the Pi resources via the auth proxy. The auth proxy must be accessible on the
    web, or at least on the same network as the client app, but the Pi can be on a
    local network as long as the auth proxy can access it.'
  id: totrans-1268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.9\. 为您的Pi设计的社交物联网认证代理：客户端应用通过Facebook的OAuth获取令牌；然后可以使用此令牌通过认证代理访问Pi资源。认证代理必须在网络上可访问，或者至少与客户端应用在同一个网络中，但只要认证代理可以访问，Pi可以位于本地网络中。
- en: '![](09fig09_alt.jpg)'
  id: totrans-1269
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig09_alt.jpg)'
- en: The complete code for this part is located in the chapter9-sharing/social-auth
    folder, but we’ll only look at the details of some parts here. The proxy could
    be built directly on top of the WoT Pi code we built in the previous chapters,
    but as we said before, it makes more sense to implement it as a standalone proxy
    that can be deployed either on the Pi or somewhere else because it might proxy
    the access to more than one device.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分完整的代码位于第9章-sharing/social-auth文件夹中，但在这里我们只查看一些部分的细节。代理可以直接建立在我们在前几章中构建的WoT
    Pi代码之上，但正如我们之前所说的，将其实现为一个独立的代理，可以在Pi上或其它地方部署，这更有意义，因为它可能代理多个设备的访问。
- en: Creating a Facebook application
  id: totrans-1271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建Facebook应用程序
- en: Before we can begin coding, we need to make sure that Facebook knows our auth
    proxy as an authorized Facebook application. To create a Facebook app, you’ll
    need a Facebook account and to apply for a Facebook developer account. If you’re
    not into cat videos or holiday selfies and therefore don’t have a Facebook account,
    feel free to pick another OAuth provider such as Google, Twitter, or GitHub and
    replace “Facebook” with the OAuth provider you picked in all the following sections.
    We won’t detail how to implement support for other providers, but the principle
    will be similar, so you shouldn’t have too much trouble doing this exercise.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，我们需要确保 Facebook 知道我们的身份验证代理是一个授权的 Facebook 应用程序。要创建一个 Facebook 应用，你需要一个
    Facebook 账户并申请一个 Facebook 开发者账户。如果你不感兴趣于猫咪视频或假日自拍，因此没有 Facebook 账户，你可以自由选择其他 OAuth
    提供商，例如 Google、Twitter 或 GitHub，并在所有后续章节中将“Facebook”替换为你选择的 OAuth 提供商。我们不会详细说明如何实现对其他提供商的支持，但原则将是相似的，所以你在这项练习中不应该遇到太多麻烦。
- en: Go to [https://developers.facebook.com](https://developers.facebook.com) and
    apply for a Facebook developer account if you don’t already have one. Under My
    Apps select Register As A Developer. Then you can select My Apps > Add A New App.
    Select Website, give your app a name, and select Skip Quick Start. You should
    now have a new Facebook app; fill the fields as shown in [figure 9.10](#ch09fig10)
    by clicking Settings under your app name.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有 Facebook 开发者账户，请访问 [https://developers.facebook.com](https://developers.facebook.com)
    并申请一个。在“我的应用”下选择“注册为开发者”。然后你可以选择“我的应用”>“添加新应用”。选择“网站”，给你的应用起一个名字，并选择跳过快速入门。现在你应该有一个新的
    Facebook 应用；通过点击你的应用名称下的“设置”来填写字段，如图 9.10 所示。
- en: Figure 9.10\. Setting up a new Facebook application for our Social WoT auth
    proxy. The app ID and secret will be used by Facebook to authenticate our app.
  id: totrans-1274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.10\. 为我们的 Social WoT 身份验证代理设置新的 Facebook 应用程序。应用 ID 和密钥将由 Facebook 用于验证我们的应用。
- en: '![](09fig10_alt.jpg)'
  id: totrans-1275
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig10_alt.jpg)'
- en: 'Once you’ve done this, you can note the two bits of information you need: the
    app ID and the app secret of your Facebook application. You’ll need to send these
    to Facebook to authenticate your client app. Note that until your app is published
    publicly, only you and the people you invite as developers/admins will be able
    to log in via this Facebook app.'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，你可以记录下你需要的信息：你的 Facebook 应用的应用 ID 和应用密钥。你需要将这些信息发送给 Facebook 以验证你的客户端应用。请注意，直到你的应用公开发布，只有你和你邀请的开发者/管理员才能通过这个
    Facebook 应用登录。
- en: 'Passport.js: the authentication middleware for Express'
  id: totrans-1277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Passport.js：Express 的身份验证中间件
- en: Now that your Facebook app is ready, you need to integrate it into your code.
    You begin by creating a simple Express application with an HTTPS server. You can
    find this application in chapter9-sharing/social-auth/authProxy.js, but we won’t
    detail it here because it’s similar to the Express apps you created in [chapter
    8](kindle_split_016.html#ch08) and the previous sections. Next, you’ll create
    the component that authenticates users via Facebook. You implement it using one
    of the most popular Node.js modules, Passport.js.^([[22](#ch09fn22)]) Passport
    is an impressive authentication middleware that provides simple integration of
    a number of authentication techniques—more than 300!—including OAuth and, hence,
    all the social networks implementing it.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的 Facebook 应用已经准备好了，你需要将其集成到你的代码中。你首先创建一个简单的 Express 应用程序，并带有 HTTPS 服务器。你可以在第
    9 章的 sharing/social-auth/authProxy.js 中找到这个应用程序，但在这里我们不会详细说明，因为它与你在第 8 章和前几节中创建的
    Express 应用程序类似。接下来，你将创建一个通过 Facebook 验证用户的组件。你可以使用最流行的 Node.js 模块之一来实现它，即 Passport.js.^([[22](#ch09fn22)])
    Passport 是一个令人印象深刻的身份验证中间件，它提供了一系列简单的身份验证技术集成——超过 300 种！——包括 OAuth，因此也涵盖了所有实现
    OAuth 的社交网络。
- en: ^(22)
  id: totrans-1279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(22)
- en: ''
  id: totrans-1280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://passportjs.org/](http://passportjs.org/)'
  id: totrans-1281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://passportjs.org/](http://passportjs.org/)'
- en: After installing Passport via `npm install --s passport`, you install the Facebook
    authentication module of Passport, called a *strategy*, via `npm install --s passport-facebook`.
    If you want to authenticate via Twitter, LinkedIn, or GitHub, you’ll need to install
    the corresponding Passport strategy; for example, `passport-twitter` or `passport-linkedin`.
    As long as you pick a network that supports OAuth, the implementation of the proxy
    with your chosen authentication strategy will be almost the same as the one used
    for Facebook.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 `npm install --s passport` 安装 Passport 之后，你将通过 `npm install --s passport-facebook`
    安装 Passport 的 Facebook 身份验证模块，称为策略。如果你想通过 Twitter、LinkedIn 或 GitHub 进行身份验证，你需要安装相应的
    Passport 策略；例如，`passport-twitter` 或 `passport-linkedin`。只要选择一个支持 OAuth 的网络，使用你选择的身份验证策略实现的代理将与
    Facebook 的实现几乎相同。
- en: Implementing a Facebook authentication strategy
  id: totrans-1283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现一个 Facebook 身份验证策略
- en: You’re now ready to add Facebook authentication support to your proxy. The providers/facebook.js
    file shows you how to do that. As shown in the following listing, you have to
    implement a number of functions to work with a Passport strategy.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好为你的代理添加 Facebook 身份验证支持了。`providers/facebook.js` 文件展示了如何实现这一点。如下所示，你需要实现一系列函数来与
    Passport 策略一起工作。
- en: 'Listing 9.5\. providers/facebook.js: a Facebook authentication strategy'
  id: totrans-1285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.5\. providers/facebook.js: 一个 Facebook 身份验证策略'
- en: '![](ch09ex05-0.jpg)'
  id: totrans-1286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09ex05-0.jpg)'
- en: '![](ch09ex05-1.jpg)'
  id: totrans-1287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09ex05-1.jpg)'
- en: At first sight, this flow might seem a bit complex. It consists of a number
    of routes that redirect the user to a Facebook login page and back from Facebook
    to your proxy alongside a code that can be exchanged for a token. Passport takes
    care of all the nitty-gritty details for you. The good news is that all authentication
    strategies have to implement the same methods, so what you learned here can be
    applied to other social networks as well!
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这个流程可能看起来有些复杂。它包括一系列路由，将用户重定向到 Facebook 登录页面，并从 Facebook 返回到你的代理，同时还有一个可以用来交换令牌的代码。Passport
    会为你处理所有琐碎的细节。好消息是，所有身份验证策略都必须实现相同的方法，所以在这里学到的知识也可以应用到其他社交网络上！
- en: This was the core of the Facebook authentication mechanism, and now you also
    need to make sure users have a user interface (HTML views) for all the routes
    you created. You can certainly write HTML pages from scratch, but it’s easier
    to reuse Handlebars, the templating engine we used in the previous chapters. The
    pages we created are located in the /views folder. At a minimum you’ll need a
    login.html page with a link to /auth/facebook to trigger the authentication process.
    You’ll also need an account.html page to which the user will be redirected upon
    a successful Facebook authentication.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 这曾是 Facebook 身份验证机制的核心，现在你还需要确保用户有一个用户界面（HTML 视图）来访问你创建的所有路由。当然，你可以从头开始编写 HTML
    页面，但使用我们在前几章中使用的模板引擎 Handlebars 会更容易一些。我们创建的页面位于 `/views` 文件夹中。至少，你需要一个 `login.html`
    页面，其中包含指向 `/auth/facebook` 的链接以触发身份验证过程。你还需要一个 `account.html` 页面，用户在成功完成 Facebook
    身份验证后将被重定向到该页面。
- en: Implementing access control lists
  id: totrans-1290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现访问控制列表
- en: Now that your application allows users to authenticate via Facebook using OAuth,
    you need to decide which user can access which resource on which Thing. In essence,
    you need to create an access control list (ACL). There are various ways to implement
    ACLs, such as by storing them in the local database. To keep things simple, you’ll
    use a JSON configuration file, which can be found in config/acl.json and is shown
    in the next listing. This file keeps track of which users can access which resources
    on your Pi.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的应用程序允许用户通过 OAuth 使用 Facebook 进行身份验证，你需要决定哪些用户可以访问哪些 Thing 上的哪些资源。本质上，你需要创建一个访问控制列表（ACL）。实现
    ACL 的方法有很多，例如将它们存储在本地数据库中。为了简化问题，你将使用一个 JSON 配置文件，该文件位于 `config/acl.json` 中，并在下一列表中展示。该文件跟踪哪些用户可以访问你的
    Pi 上的哪些资源。
- en: 'Listing 9.6\. config/acl.json: the access control list JSON file'
  id: totrans-1292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.6\. config/acl.json: 访问控制列表 JSON 文件'
- en: '![](ch09ex06-0.jpg)'
  id: totrans-1293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09ex06-0.jpg)'
- en: '![](ch09ex06-1.jpg)'
  id: totrans-1294
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09ex06-1.jpg)'
- en: A difficulty might be finding the user IDs of users you want to share with using
    their social network identifier. A good way is to ask them to log in first because
    this will display their social network ID on the account page you got back from
    Facebook. Alternatively, you can use the Facebook Graph API explorer^([[23](#ch09fn23)])
    tool. Make sure you add your own ID in the ACL!
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的困难之一是找到你想要通过社交网络标识符共享的用户ID。一个好方法是请他们先登录，因为这将在从Facebook返回的账户页面上显示他们的社交网络ID。或者，你也可以使用Facebook
    Graph API探索器^([[23](#ch09fn23)]) 工具。确保你在ACL中添加了自己的ID！
- en: ^(23)
  id: totrans-1296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(23)
- en: ''
  id: totrans-1297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://developers.facebook.com/tools/explorer/](https://developers.facebook.com/tools/explorer/)'
  id: totrans-1298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://developers.facebook.com/tools/explorer/](https://developers.facebook.com/tools/explorer/)'
- en: Now that your ACL is in place, you need to check what you get back from Facebook
    against it to ensure the users who are trying to log in are really welcome. Similarly,
    you need to check that they can access the Things’ resources requested. You implement
    this using a middleware in /middleware/auth.js, as shown in the next listing.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在ACL已经设置好了，你需要将Facebook返回的内容与你设置的内容进行比对，以确保尝试登录的用户确实是受欢迎的。同样，你需要检查他们是否有权访问请求的实体资源。你可以通过在`/middleware/auth.js`中使用中间件来实现这一点，如下一列表所示。
- en: 'Listing 9.7\. Authorizing user requests: /middleware/auth.js'
  id: totrans-1300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.7\. 授权用户请求：/middleware/auth.js
- en: '![](ch09ex07-0.jpg)'
  id: totrans-1301
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex07-0.jpg)'
- en: '![](ch09ex07-1.jpg)'
  id: totrans-1302
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex07-1.jpg)'
- en: Proxying resources of Things
  id: totrans-1303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实体的资源代理
- en: 'Finally, you need to implement the actual proxying: once a request is deemed
    valid by the middleware, you need to contact the Thing that serves this resource
    and proxy the results back to the client. This part is no different from any other
    HTTP proxy. To implement it, you’ll use a blazing-fast Node module for building
    proxies called `node-http-proxy`.^([[24](#ch09fn24)]) Install it via `npm install
    --save http-proxy`. Then use this module to build another middleware in /middleware/proxy.js,
    as shown in the next listing.'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要实现实际的代理功能：一旦中间件认为请求有效，你需要联系提供该资源的实体，并将结果代理回客户端。这部分与其他任何HTTP代理没有区别。要实现它，你将使用一个用于构建代理的快速Node模块，名为`node-http-proxy`。^([[24](#ch09fn24)])
    通过`npm install --save http-proxy`来安装它。然后使用此模块在`/middleware/proxy.js`中构建另一个中间件，如下一列表所示。
- en: ^(24)
  id: totrans-1305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(24)
- en: ''
  id: totrans-1306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/nodejitsu/node-http-proxy](https://github.com/nodejitsu/node-http-proxy)'
  id: totrans-1307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://github.com/nodejitsu/node-http-proxy](https://github.com/nodejitsu/node-http-proxy)'
- en: 'Listing 9.8\. Proxying requests to Things: /middleware/proxy.js'
  id: totrans-1308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.8\. 代理请求到实体：/middleware/proxy.js
- en: '![](275fig01_alt.jpg)'
  id: totrans-1309
  prefs: []
  type: TYPE_IMG
  zh: '![](275fig01_alt.jpg)'
- en: That’s it! You should now have a full Social Web of Things authentication proxy.
    To test it, run `node authProxy.js`. Then, start the WoT Pi using `node wot.js`
    with simple token authentication enabled, as shown in [section 9.2.1](#ch09lev2sec4),
    or with OAuth if you implemented it.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你现在应该已经拥有了一个完整的社交物联网认证代理。要测试它，运行`node authProxy.js`。然后，使用简单令牌认证启动WoT Pi，如[第9.2.1节](#ch09lev2sec4)中所示，或者如果你实现了OAuth，则使用OAuth。
- en: 'Try to access a resource of your Pi via the proxy with an invalid token; for
    example, [https://raspberrypi.local:5050/properties/pir?token=1234](https://raspberrypi.local:5050/properties/pir?token=1234).
    As expected, this will return an error: `Not authorized for this resource!`'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用无效令牌通过代理访问你的树莓派资源；例如，[https://raspberrypi.local:5050/properties/pir?token=1234](https://raspberrypi.local:5050/properties/pir?token=1234)。正如预期的那样，这将返回一个错误：`未授权访问此资源！`
- en: 'Now, let’s get an access token to issue a valid request: start by browsing
    to [https://IP:5050/login](https://IP:5050/login). This should prompt you to log
    in on Facebook (if your browser doesn’t have a Facebook login cookie sitting in
    the cupboard) and then should ask you if you authorize the proxy Facebook app
    to access your profile. If you accept, you’ll land on your profile page, as shown
    in [figure 9.11](#ch09fig11), where you can see your access token. Copy it and
    open [https://raspberrypi.local:5050/properties/pir?token=YOUR-TOKEN](https://raspberrypi.local:5050/properties/pir?token=YOUR-TOKEN)
    once again, but this time with your new token. If everything works, you should
    get the HTML representation of the PIR sensor. Take a deep breath and think about
    what you just did: you merged the Social Web with the physical world!'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们获取一个访问令牌以发出有效请求：首先浏览到[https://IP:5050/login](https://IP:5050/login)。这应该会提示你在Facebook上登录（如果你的浏览器中没有放置在橱柜中的Facebook登录cookie），然后会询问你是否授权代理Facebook应用程序访问你的个人资料。如果你接受，你将到达你的个人资料页面，如图9.11所示，在那里你可以看到你的访问令牌。复制它，然后再次打开[https://raspberrypi.local:5050/properties/pir?token=YOUR-TOKEN](https://raspberrypi.local:5050/properties/pir?token=YOUR-TOKEN)，但这次使用你的新令牌。如果一切正常，你应该会得到PIR传感器的HTML表示。深吸一口气，思考你刚才所做的事情：你将社交网络与物理世界合并了！
- en: Figure 9.11\. First, Facebook will prompt the user to accept the application
    request. After a successful Facebook authentication, the user is redirected to
    their Account page on the auth proxy, where they can retrieve their access token
    to be used in subsequent calls to the Things behind the proxy.
  id: totrans-1313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.11。首先，Facebook将提示用户接受应用程序请求。在成功完成Facebook身份验证后，用户将被重定向到auth代理上的账户页面，在那里他们可以检索用于后续调用代理后事物的访问令牌。
- en: '![](09fig11_alt.jpg)'
  id: totrans-1314
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig11_alt.jpg)'
- en: '|  |'
  id: totrans-1315
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The nerd corner—I want more of this!**'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术角落——我想要更多这样的内容！**'
- en: 'As usual, there are many possible ways of extending this example because we
    kept the implementation simple. Here are a few extension ideas: you could use
    what you learned in [chapter 8](kindle_split_016.html#ch08) to implement a system
    for the proxy to automatically discover web Thing model-compliant Things. You
    could also make the ACL much easier to deal with by implementing wildcards; for
    example, `/properties/*`. Or you could create a UI for the proxy that lets you
    share with your friends or that lets you add authorized users dynamically (for
    our hotel scenario). If you’re still hungry for more, you could also implement
    proxying for WebSockets; `node-http-proxy` supports it as well. Finally, you could
    implement an OAuth server on the Pi—for example, using `node-oauth2-server—`and
    change the proxy to dynamically get an OAuth access token from the Pi instead
    of a simple token; this would make the flow more secure and much more flexible.'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，由于我们保持了实现的简单性，因此有许多可能的方式来扩展这个例子。以下是一些扩展想法：你可以使用你在[第8章](kindle_split_016.html#ch08)中学到的知识来实现一个系统，使代理能够自动发现符合Web
    Thing模型规范的设备。你也可以通过实现通配符来使ACL更容易处理；例如，`/properties/*`。或者，你可以为代理创建一个用户界面，让你可以与朋友分享，或者让你可以动态添加授权用户（在我们的酒店场景中）。如果你仍然渴望更多，你也可以实现WebSocket的代理；`node-http-proxy`也支持它。最后，你可以在Pi上实现OAuth服务器——例如，使用`node-oauth2-server`——并将代理更改为从Pi动态获取OAuth访问令牌，而不是简单的令牌；这将使流程更加安全，并且更加灵活。
- en: '|  |'
  id: totrans-1318
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.4\. Beyond the book
  id: totrans-1319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4. 超越书本
- en: In this chapter, you learned how to blend the Social Web and the Web of Things
    to get to the Social Web of Things. Not a small achievement for a single chapter!
    Although you should certainly enjoy the moment, you should also realize that we
    barely scratched the surface of security for the IoT and the WoT. We didn’t cover
    a number of aspects, from ensuring privacy to protecting Things against distributed
    denial of service attacks or securing software and firmware updates.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将社交网络和物联网融合，以实现社交物联网。这对于一个章节来说，无疑是一个不小的成就！尽管你应该尽情享受这一刻，但你也应该意识到，我们对物联网和物联网安全只是触及了皮毛。我们没有涵盖许多方面，从确保隐私到保护设备免受分布式拒绝服务攻击，或确保软件和固件更新的安全。
- en: By definition, perfect security is unattainable. Securing computer networks
    is a constant battle between security experts and hackers, where security systems
    always need to be one step ahead because the better our machines and tools get,
    the easier it is to break secure systems. Network security should be a constant
    discipline rather than a one-off event, and you need to keep informed and updated
    as you pursue your IoT adventure.^([[25](#ch09fn25)])
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 按照定义，完美的安全是无法实现的。保护计算机网络是安全专家和黑客之间的持续战斗，其中安全系统始终需要领先一步，因为我们的机器和工具越好，就越容易破解安全系统。网络安全应该是一种持续的纪律，而不是一次性的事件，在你追求物联网冒险的过程中，你需要保持信息灵通和更新。
- en: ^(25)
  id: totrans-1322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(25)
- en: ''
  id: totrans-1323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some good bedside readings:- [http://h30499.www3.hp.com/t5/Fortify-Application-Security/HP-Study-Reveals-70-Percent-of-Internet-of-Things-Devices/ba-p/6556284](http://h30499.www3.hp.com/t5/Fortify-Application-Security/HP-Study-Reveals-70-Percent-of-Internet-of-Things-Devices/ba-p/6556284)-
    [https://www.owasp.org/index.php/Main_Page](https://www.owasp.org/index.php/Main_Page)-
    [http://arstechnica.com/security/2016/01/how-to-search-the-internet-of-things-for-photos-of-sleeping-babies/](http://arstechnica.com/security/2016/01/how-to-search-the-internet-of-things-for-photos-of-sleeping-babies/)-
    [http://techcrunch.com/2015/10/24/why-iot-security-is-so-critical](http://techcrunch.com/2015/10/24/why-iot-security-is-so-critical)
  id: totrans-1324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些好的床头阅读材料：- [HP 研究揭示 70% 的物联网设备存在安全漏洞](http://h30499.www3.hp.com/t5/Fortify-Application-Security/HP-Study-Reveals-70-Percent-of-Internet-of-Things-Devices/ba-p/6556284)-
    [OWASP 主页](https://www.owasp.org/index.php/Main_Page)- [如何在物联网中搜索睡眠婴儿的照片](http://arstechnica.com/security/2016/01/how-to-search-the-internet-of-things-for-photos-of-sleeping-babies/)-
    [为什么物联网安全如此关键](http://techcrunch.com/2015/10/24/why-iot-security-is-so-critical)
- en: 'As the IoT moves out of its teenage years and into adulthood, different focal
    points will appear. First, security will become ubiquitous and a must-have, rather
    than a nice-to-have. But just as HTTP might be too heavy for resource-limited
    devices, security protocols such as TLS and their underlying cypher suites are
    too heavy for the most resource-constrained devices. This is why lighter-weight
    versions of TLS are being developed, such as DTLS,^([[26](#ch09fn26)]) which is
    similar to TLS but runs on top of UDP instead of TCP and also has a smaller memory
    footprint. Although such protocols represent interesting evolutions, some researchers
    are looking at revolutions! For example, some researchers started looking at a
    concept they refer to as *device democracy*.^([[27](#ch09fn27)]) In this model,
    devices become more autonomous and favor peer-to-peer interactions over centralized
    cloud services. Security is ensured using a blockchain mechanism: similar to the
    way bitcoin transactions are validated by a number of independent parties in the
    bitcoin network, devices could all participate in making the IoT secure. Without
    a doubt, IoT security will change drastically in the next few years, as the web
    itself will evolve to match today’s needs.'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 随着物联网从青少年时期步入成年，不同的焦点将出现。首先，安全性将变得无处不在，成为必需品，而不仅仅是锦上添花。但正如 HTTP 可能对资源有限的设备来说过于沉重一样，TLS
    和其底层加密套件对于资源最受限的设备来说也太沉重了。这就是为什么正在开发更轻量级的 TLS 版本，例如 DTLS，^([[26](#ch09fn26)])
    它与 TLS 类似，但运行在 UDP 而不是 TCP 上，并且具有更小的内存占用。尽管这些协议代表了有趣的演变，但一些研究人员正在寻找革命！例如，一些研究人员开始研究他们称之为
    *设备民主* 的概念。^([[27](#ch09fn27))) 在这个模型中，设备变得更加自主，并倾向于点对点交互而不是集中式云服务。安全性通过区块链机制得到保证：类似于比特币交易在比特币网络中由多个独立方验证的方式，设备都可以参与使物联网安全。毫无疑问，物联网安全将在未来几年发生巨大变化，因为网络本身也将演变以适应今天的需要。
- en: ^(26)
  id: totrans-1326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(26)
- en: ''
  id: totrans-1327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security](https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security)'
  id: totrans-1328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[数据报传输层安全](https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security)'
- en: ^(27)
  id: totrans-1329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(27)
- en: ''
  id: totrans-1330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www-935.ibm.com/services/us/gbs/thoughtleadership/internetofthings/](http://www-935.ibm.com/services/us/gbs/thoughtleadership/internetofthings/)'
  id: totrans-1331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[IBM 物联网服务](http://www-935.ibm.com/services/us/gbs/thoughtleadership/internetofthings/)'
- en: '|  |'
  id: totrans-1332
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The nerd corner—I want the future of secure application management!**'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术角落——我想要安全应用管理的未来！**'
- en: 'As mentioned before, managing applications or firmware updates on an embedded
    device can be tricky to get right and secure: if you don’t do it right, such as
    by using an insecure HTTP server, attackers could use your update mechanism to
    inject whatever they like on your customers’ devices! Luckily, as the IoT matures,
    interesting, secure, and scalable solutions appear to help you deploy code on
    your Things. As an example, resin.io lets you use Git to push new versions of
    your code to all your Things or to a selection of them. It also uses Docker containers
    to package and run several applications in isolation on embedded devices, which
    improves portability, security, and stability. Finally, it works well with Node.js
    and the Pi and is free if you have a small number of devices, so go ahead and
    try it.^([[a](#ch09fn5a)])'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在嵌入式设备上管理应用程序或固件更新可能很难正确且安全地进行：如果您没有正确操作，例如使用不安全的HTTP服务器，攻击者可能会利用您的更新机制在您的客户设备上注入他们想要的任何内容！幸运的是，随着物联网的成熟，出现了有趣、安全且可扩展的解决方案，以帮助您在您的“物”上部署代码。例如，resin.io允许您使用Git将新版本的代码推送到您的所有“物”或其中的一部分。它还使用Docker容器在嵌入式设备上独立打包和运行多个应用程序，这提高了可移植性、安全性和稳定性。最后，它与Node.js和Pi兼容，如果您拥有少量设备，它是免费的，所以您可以尝试一下.^([[a](#ch09fn5a)])
- en: ^a
  id: totrans-1335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-1336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://resin.io](https://resin.io)'
  id: totrans-1337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://resin.io](https://resin.io)'
- en: '|  |'
  id: totrans-1338
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.5\. Summary
  id: totrans-1339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5. 摘要
- en: 'You must cover four basic principles to secure IoT systems: encrypted communication,
    server authentication, client authentication, and access control.'
  id: totrans-1340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须涵盖四个基本原理来确保物联网系统的安全：加密通信、服务器认证、客户端认证和访问控制。
- en: Encrypted communication ensures attackers can’t read the content of messages.
    It uses encryption mechanisms based on symmetric or asymmetric keys.
  id: totrans-1341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密通信确保攻击者不能读取消息的内容。它使用基于对称或非对称密钥的加密机制。
- en: 'You should use TLS to encrypt messages on the web. TLS is based on asymmetric
    keys: a public key and a private server key.'
  id: totrans-1342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该在网络上使用TLS加密消息。TLS基于非对称密钥：一个公钥和一个私有的服务器密钥。
- en: Server authentication ensures attackers can’t pretend to be the server. On the
    web, this is achieved by using SSL (TLS) certificates. The delivery of these certificates
    is controlled through a chain of trust where only trusted parties called certificate
    authorities can deliver certificates to identify web servers.
  id: totrans-1343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器认证确保攻击者不能伪装成服务器。在网络上，这通过使用SSL（TLS）证书来实现。这些证书的发放通过信任链来控制，只有被称为证书授权机构的可信方才能发放证书以识别网络服务器。
- en: Instead of buying certificates from a trusted third party, you can create self-signed
    TLS certificates on a Raspberry Pi. The drawback is that web browsers will flag
    the communication as unsecure because they don’t have the CA certificate in their
    trust store.
  id: totrans-1344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在Raspberry Pi上创建自签名的TLS证书，而不是从可信的第三方购买证书。缺点是，由于它们没有在信任存储中拥有CA证书，网络浏览器会将通信标记为不安全。
- en: You can achieve client authentication using simple API tokens. Tokens should
    rotate on a regular basis and should be generated using crypto secure random algorithms
    so that their sequence can’t be guessed.
  id: totrans-1345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用简单的API令牌实现客户端认证。令牌应定期轮换，并且应使用加密安全的随机算法生成，以确保其序列无法被猜测。
- en: The OAuth protocol can be used to generate API tokens in a dynamic, standard,
    and secure manner and is supported by many embedded Linux devices such as the
    Raspberry Pi.
  id: totrans-1346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth协议可以以动态、标准和安全的方式生成API令牌，并且被许多嵌入式Linux设备（如Raspberry Pi）支持。
- en: The delegated authentication mechanism of OAuth relies on other OAuth providers
    to authenticate users and create API tokens. As an example, a user of a Thing
    can be identified using Facebook via OAuth.
  id: totrans-1347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth的委托认证机制依赖于其他OAuth提供者来认证用户并创建API令牌。例如，一个“物”的用户可以通过OAuth使用Facebook来识别。
- en: You can implement access control for Things to reflect your social contacts
    by creating an authentication proxy using OAuth for clients’ authentication and
    contacts from social networks.
  id: totrans-1348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过创建用于客户端认证和社交网络联系人的认证代理来实现对“物”的访问控制，以反映您的社交联系。
- en: 'Now that you’ve seen how to secure your web-connected Things so that their
    data and services can be securely shared and accessed over the web, it’s time
    to move to the final layer of the WoT architecture: Compose. In the next chapter,
    you’ll see how to take all the components you learned about in this book and combine
    them to build a whole new generation of web applications: physical mashups. Integrating
    real-time data from numerous physical sources directly within web applications
    and services is without doubt the future of the web. We want to make sure you
    have the tools you need to get there in no time!'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何确保你的Web连接事物可以安全地共享和通过Web访问其数据和服务的安全性，现在是时候转向WoT架构的最后一层：组合层。在下一章中，你将看到如何将本书中你所学到的所有组件结合起来，构建新一代的Web应用程序：物理混合应用。在Web应用程序和服务中直接集成来自众多物理源的真实时间数据无疑是Web的未来。我们想确保你拥有所需的工具，以便迅速实现这一点！
- en: 'Chapter 10\. Compose: Physical mashups'
  id: totrans-1350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章\. 组合：物理混合应用
- en: '*This chapter covers*'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Automatically generating user interfaces for web Things using their model
  id: totrans-1352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型自动生成Web Things的用户界面
- en: Using box and arrow mashup editors to combine web Things and web resources.
  id: totrans-1353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用框和箭头混合编辑器组合Web事物和Web资源。
- en: Creating complex workflows for web Things in minutes with wizard mashup editors
  id: totrans-1354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用向导混合编辑器在几分钟内为Web Things创建复杂的工作流程
- en: We’ve come quite a long way since the beginning of this book! We’ve implemented
    web protocols on Things to make them accessible over the web. We’ve modeled and
    semantically described Things with web-friendly formats and languages to facilitate
    their discovery and interoperability. We’ve secured Things with state-of-the-art
    web security protocols and best practices and then shared them over the web to
    make their resources accessible to our friends on various social networks. Now
    is probably a good time to step back and understand why we’ve worked through all
    these different layers. Things that are accessible through these layers can now
    be integrated to any web application or service seamlessly and effortlessly because
    web Things have become first-class citizens of the web!
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 自从本书开始以来，我们已经走了很长的路！我们在事物上实现了Web协议，使它们可以通过Web访问。我们使用Web友好的格式和语言对事物进行建模和语义描述，以促进它们的发现和互操作性。我们使用最先进的Web安全协议和最佳实践来保护事物，然后在Web上共享它们，使我们的朋友可以在各种社交网络上访问它们。现在可能是回顾并理解我们为什么通过所有这些不同层次的好时机。通过这些层次可访问的事物现在可以无缝且轻松地集成到任何Web应用程序或服务中，因为Web事物已经成为Web的第一公民！
- en: The last layer—Compose, shown in [figure 10.1](#ch10fig01)—is all about using
    what you’ve learned and built so far to create new applications. You turned Things
    into web LEGO^® bricks; now it’s time to unleash your inner artist and create
    a collection of amazing sculptures! In this chapter, we’ll first show you how
    to use the API of Things to build user interfaces that can accommodate and adapt
    to the things they discover.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一层——组合层，如图10.1所示——主要是利用你迄今为止所学和构建的内容来创建新的应用程序。你将事物变成了Web乐高积木；现在是你释放内心艺术家的时候，创作一系列惊人的雕塑！在本章中，我们将首先向你展示如何使用事物的API构建用户界面，使其能够适应和调整它们发现的事物。
- en: Figure 10.1\. The Compose layer of the Web of Things architecture. This layer
    focuses on building web applications that can control Things or combine data and
    services from various sources to deliver complex processes. It brings the concept
    of web mashups to the Internet of Things.
  id: totrans-1357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1\. 物联网架构的组合层。这一层专注于构建可以控制事物或从各种来源组合数据和服务的Web应用程序，以提供复杂的过程。它将Web混合应用的概念引入物联网。
- en: '![](10fig01_alt.jpg)'
  id: totrans-1358
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig01_alt.jpg)'
- en: 'Then we’ll look at *physical mashups*: composite web applications that combine
    Things and web services. You’ll learn how to use mashup tools to rapidly build
    complex workflows by wiring together data and services from various sources. Because
    all components of your application are web APIs, you don’t have to worry about
    data integration and can focus solely on the wiring and logic of your application.'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探讨*物理混合应用*：结合事物和Web服务的复合Web应用程序。你将学习如何使用混合工具通过连接来自各种来源的数据和服务来快速构建复杂的工作流程。因为你的应用程序的所有组件都是Web
    API，你不必担心数据集成，可以专注于应用程序的连接和逻辑。
- en: 10.1\. Building a simple app—automated UI generation
  id: totrans-1360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1\. 构建简单应用程序——自动UI生成
- en: The ultimate goal of the various layers of the Web of Things architecture is
    to enable as many applications as possible to discover, understand, and interact
    with other Things with minimal effort. Many IoT scenarios involve users interacting
    with all sorts of devices using various applications. As you saw earlier, one
    of the problems of the IoT is that every device needs a custom application, which
    is inconvenient for users. If we could have a universal application that’s capable
    of controlling any device, it would be much more interesting. The Web of Things
    makes this possible by using the Web Thing Model, and this section will show you
    how to start building this universal remote control.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网架构各层的最终目标是尽可能减少努力，使尽可能多的应用程序能够发现、理解和与其他事物交互。许多物联网场景涉及用户使用各种应用程序与各种设备交互。正如您之前所看到的，物联网的一个问题是每个设备都需要一个定制的应用程序，这对用户来说很不方便。如果我们能有一个能够控制任何设备的通用应用程序，那就更有趣了。物联网通过使用Web
    Thing模型实现了这一点，本节将向您展示如何开始构建这个通用遥控器。
- en: 10.1.1\. A universal user interface for web Things
  id: totrans-1362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1. 物联网的通用用户界面
- en: 'The Web Thing model you implemented in [chapter 8](kindle_split_016.html#ch08)
    and secured in [chapter 9](kindle_split_017.html#ch09) describes in a standard
    format the various actions supported by a device, along with its properties and
    additional metadata. Based on this you can easily write a client application that
    automatically generates a user interface for any web Thing and then displays the
    properties in real time and sends commands (actions) to the web Thing. The architecture
    of this application is shown in [figure 10.2](#ch10fig02) and is the first step
    toward a universal remote control for web Things: even without having any a priori
    knowledge about a specific web Thing it just discovered, it can use the Thing’s
    Web Thing Model document to generate a custom user interface and bind it to the
    Thing to control it and/or visualize its data in real time.'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 您在[第8章](kindle_split_016.html#ch08)中实现的Web Thing模型，并在[第9章](kindle_split_017.html#ch09)中进行了安全保护，以标准格式描述了设备支持的各种动作，以及其属性和附加元数据。基于此，您可以轻松编写一个客户端应用程序，该应用程序可以自动为任何Web
    Thing生成用户界面，并在实时显示属性的同时发送命令（动作）到Web Thing。该应用程序的架构如图10.2所示，这是构建物联网通用遥控器的第一步：即使没有关于它刚刚发现的特定Web
    Thing的任何先验知识，它也可以使用该事物的Web Thing模型文档来生成自定义用户界面，并将其绑定到事物上以控制它和/或实时可视化其数据。
- en: Figure 10.2\. The universal remote control for web Things. A web Thing client
    application (pure JavaScript/HTML) can find nearby devices, retrieve their Web
    Thing Model description, and use it to generate a custom user interface tailored
    for that specific device.
  id: totrans-1364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2. 物联网的通用遥控器。一个Web Thing客户端应用程序（纯JavaScript/HTML）可以找到附近的设备，检索它们的Web Thing模型描述，并使用它来生成针对该特定设备的定制用户界面。
- en: '![](10fig02_alt.jpg)'
  id: totrans-1365
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig02_alt.jpg)'
- en: You can find a simple application that does that on the GitHub repository of
    this book in the folder chapter10-mashups/UI, so let’s open the file UI.html and
    analyze its contents.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub仓库中找到这样一个简单应用程序，位于chapter10-mashups/UI文件夹中，因此让我们打开文件UI.html并分析其内容。
- en: The first thing this web application does is retrieve the model of a Thing with
    the `getModel()` function shown in the following listing. This function is called
    when the page is loaded with the URL of the model given as parameter.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Web应用程序首先做的事情是使用以下列表中所示的`getModel()`函数检索一个事物的模型。当页面加载并给出模型URL作为参数时，会调用此函数。
- en: Listing 10.1\. Retrieve the JSON model of a web Thing with jQuery
  id: totrans-1368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.1. 使用jQuery检索Web Thing的JSON模型
- en: '![](282fig01_alt.jpg)'
  id: totrans-1369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](282fig01_alt.jpg)'
- en: Once you’ve retrieved the JSON model of the web Thing, you use its contents
    to generate the user interface for it. First, you use the metadata of the web
    Thing—name, description, hostname, port, and so on—to generate a human-friendly
    description of the web Thing and its purpose. Then, you use the description of
    the actions to create UI elements that send commands to the web Thing, as shown
    in [figure 10.3](#ch10fig03). Finally, you use the description of the properties
    to generate UI elements that render the data of the web Thing (you can see this
    in action in [figure 10.4](#ch10fig04)).
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您检索到Web Thing的JSON模型，您就使用其内容来生成它的用户界面。首先，您使用Web Thing的元数据——名称、描述、主机名、端口等——来生成Web
    Thing及其用途的人性化描述。然后，您使用动作的描述来创建UI元素，这些元素会向Web Thing发送命令，如图10.3所示。最后，您使用属性的描述来生成渲染Web
    Thing数据的UI元素（您可以在图10.4中看到这一过程）。
- en: Figure 10.3\. An HTML form to create `ledState` actions based on the web Thing
    model for a Raspberry Pi
  id: totrans-1371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.3\. 基于Raspberry Pi的Web Thing模型的`ledState`动作的HTML表单
- en: '![](10fig03_alt.jpg)'
  id: totrans-1372
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig03_alt.jpg)'
- en: Before we dive headfirst into the code that generates the HTML form, start the
    WoT Pi server as you did in the previous chapters with `node wot.js` and make
    sure the secure version is started (the first line of the wot.js should require
    `'./wot-server-secure'`). You can now open the UI.html file in your browser and
    pass the token of your WoT Pi as a query parameter in the URL (`UI.html?token=YOUR_TOKEN`).
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们一头扎进生成HTML表单的代码之前，按照前几章的做法，使用`node wot.js`启动WoT Pi服务器，并确保启动了安全版本（wot.js的第一行应该require
    `'./wot-server-secure'`）。你现在可以在浏览器中打开UI.html文件，并将你的WoT Pi的令牌作为URL的查询参数传递（`UI.html?token=YOUR_TOKEN`）。
- en: 'Now GET the model of your WoT Pi and review the `Action`s element of the model,
    as shown in the next listing. You can see that the Pi has only one action, called
    `ledState`. This action requires two input parameters, or values: `ledId` (an
    enum that can be `1`, `2`, or `ALL`) and `state` (a boolean for the desired state
    of the LED).'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，获取你的WoT Pi的模型，并查看模型中的`Action`元素，如下一列表所示。你可以看到，Pi只有一个动作，称为`ledState`。此动作需要两个输入参数或值：`ledId`（一个可以是`1`、`2`或`ALL`的枚举）和`state`（一个表示LED所需状态的布尔值）。
- en: Listing 10.2\. The `actions` object of the Web Thing Model for our Pi
  id: totrans-1375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2\. 我们Pi的Web Thing模型的`actions`对象
- en: '![](ch10ex02-0.jpg)'
  id: totrans-1376
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch10ex02-0.jpg)'
- en: '![](ch10ex02-1.jpg)'
  id: totrans-1377
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch10ex02-1.jpg)'
- en: The corresponding web form to create such an action is shown in [figure 10.3](#ch10fig03).
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此类动作的相应Web表单如图10.3所示。
- en: Now, let’s see the corresponding HTML code behind this HTML form, shown in the
    following listing. It’s certainly not the simplest piece of code because we use
    the `Bootstrap` library to make it look pretty (hence the complex tree of HTML
    elements), so please bear with us.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个HTML表单背后的相应HTML代码，如下一列表所示。这当然不是最简单的代码片段，因为我们使用了`Bootstrap`库来使其看起来更美观（因此有复杂的HTML元素树），所以请耐心等待。
- en: Listing 10.3\. The HTML code of the form to create an `ledState` action
  id: totrans-1380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.3\. 创建`ledState`动作的表单的HTML代码
- en: '[PRE56]'
  id: totrans-1381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In summary, here’s a simple HTML form with two inputs—the LED ID and the desired
    state—and a button to send the action. For each action of any web Thing, we need
    to generate such a form with the appropriate input parameters they support. Let’s
    now dissect the `generateActions()` function shown in the following listing, which
    does exactly this.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，这里有一个简单的HTML表单，包含两个输入——LED ID和所需状态——以及一个发送动作的按钮。对于任何Web Thing的每个动作，我们都需要生成这样的表单，包含它们支持的适当输入参数。现在让我们分析下一列表中显示的`generateActions()`函数，它正是这样做的。
- en: Listing 10.4\. The `generateActions()` function
  id: totrans-1383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.4\. `generateActions()`函数
- en: '![](ch10ex04-0.jpg)'
  id: totrans-1384
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch10ex04-0.jpg)'
- en: '![](ch10ex04-1.jpg)'
  id: totrans-1385
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch10ex04-1.jpg)'
- en: Once this code has generated a form for each action of the web Thing, we can
    now do the same for its properties. Look at the PIR and LED properties of the
    model of our Pi in the next listing.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这段代码为Web Thing的每个动作生成了一个表单，我们现在可以为它的属性做同样的事情。看看下一列表中我们Pi模型的PIR和LED属性。
- en: Listing 10.5\. The PIR and LED properties of the Pi Web Thing Model
  id: totrans-1387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.5\. Pi Web Thing模型的PIR和LED属性
- en: '[PRE57]'
  id: totrans-1388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We want our generator to create the HTML output shown in [figure 10.4](#ch10fig04)
    to display those properties.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的生成器创建如图10.4所示的HTML输出以显示这些属性。
- en: Figure 10.4\. An HTML view of the PIR and LED properties of the WoT Pi
  id: totrans-1390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4\. WoT Pi的PIR和LED属性的HTML视图
- en: '![](10fig04_alt.jpg)'
  id: totrans-1391
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig04_alt.jpg)'
- en: Just as we did for actions, we’ll generate the HTML elements to display the
    properties as shown in [figure 10.4](#ch10fig04) and then create a WebSocket subscription
    to each property so we can display the latest value of each property as it’s sent
    by the web Thing. All of this is done with the `generateProperties()` function
    shown in the next listing.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们对动作所做的那样，我们将生成HTML元素来显示属性，如图10.4所示，然后为每个属性创建一个WebSocket订阅，以便我们可以显示每个属性的最新值，就像Web
    Thing发送的那样。所有这些都是在下一列表中显示的`generateProperties()`函数中完成的。
- en: Listing 10.6\. The `generateProperties()` function
  id: totrans-1393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.6\. `generateProperties()`函数
- en: '![](ch10ex06-0.jpg)'
  id: totrans-1394
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch10ex06-0.jpg)'
- en: '![](ch10ex06-1.jpg)'
  id: totrans-1395
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch10ex06-1.jpg)'
- en: Start a secure WoT Pi server and open [https://raspberrypi.local:8484/?token=X](https://raspberrypi.local:8484/?token=X).
    Make sure you replace X with the actual API token of your WoT Pi, as you did in
    [section 9.2.1](kindle_split_017.html#ch09lev2sec4). Once you accept the certificate
    by adding a security exception (see [section 9.1.3](kindle_split_017.html#ch09lev2sec3)),
    you should see the root page of your Pi. After that, you can open the UI.html
    file and append `?token=X` (again, with X being your Pi token) to the URL, and
    you should see the WoT UI page that was automatically generated, along with the
    actions and properties.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 启动安全的WoT Pi服务器并打开[https://raspberrypi.local:8484/?token=X](https://raspberrypi.local:8484/?token=X)。确保您用实际的WoT
    Pi API令牌替换X，就像在[第9.2.1节](kindle_split_017.html#ch09lev2sec4)中做的那样。一旦您通过添加安全异常（见[第9.1.3节](kindle_split_017.html#ch09lev2sec3)）接受证书，您应该能看到Pi的根页面。之后，您可以打开UI.html文件，并将`?token=X`（再次，X是您的Pi令牌）追加到URL中，您应该能看到自动生成的WoT
    UI页面，包括操作和属性。
- en: So what?
  id: totrans-1397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 那又如何？
- en: In this section, we explored a simple web application that can generate on the
    fly a custom user interface to interact with any web Thing without knowing anything
    other than the web Thing’s URL. We hope this was a convincing illustration of
    the important role played by the Find layer we presented in [chapter 8](kindle_split_016.html#ch08).
    By now, it should be clear why having a uniform format—the web Thing model—to
    describe physical objects and their capabilities is a key enabler of the Web of
    Things at scale.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了可以即时生成自定义用户界面以与任何Web Things交互的简单Web应用程序，而无需了解除了Web Things的URL之外的其他任何信息。我们希望这足以说明我们在第8章中介绍的Find层所扮演的重要角色。到目前为止，应该很清楚为什么拥有一个统一的格式——Web
    Things模型——来描述物理对象及其能力是物联网规模化的关键推动力。
- en: With fewer than 200 lines of code, the example we provided is only a starting
    point and certainly not a real, production-quality application. There are many
    more things we could improve, but we’ll leave this part as an exercise to stimulate
    your imagination. For example, you could extend the `generateActions()` function
    to display a slider for numeric input values, or you could validate that all required
    parameters are provided before sending an action. Also, you can explore more interesting
    ways to display the properties in real time. Let us know what you come up with,
    and don’t hesitate to send us pull requests with your improvements and ideas—we’re
    looking forward to hearing from you!
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不到200行代码，我们提供的示例只是一个起点，绝对不是一个真正的、生产级别的应用程序。我们还有很多可以改进的地方，但我们将这部分留作练习，以激发您的想象力。例如，您可以扩展`generateActions()`函数以显示用于数值输入的滑块，或者您可以在发送操作之前验证是否提供了所有必需的参数。此外，您还可以探索更多有趣的方式来实时显示属性。告诉我们您的想法，不要犹豫向我们发送包含您改进和想法的拉取请求——我们期待您的反馈！
- en: 10.2\. Physical mashups
  id: totrans-1400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2. 物理混合应用
- en: Implementing layers 1–3 of the WoT architecture allows you not only to automatically
    create UIs and applications to interact with web Things but also to seamlessly
    blend web Things with any other services and data sources on the web.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 实现WoT架构的第1至3层不仅允许您自动创建与Web Things交互的UI和应用程序，而且可以无缝地将Web Things与网络上的任何其他服务和数据源融合在一起。
- en: 'Layer 4 focuses on this problem: how to easily combine data from various sources
    to create more-complex applications. A web mashup is an application that takes
    several web resources and uses them to create a new, hybrid application. Unlike
    traditional forms of integration, mashups focus mainly on opportunistic integration
    occurring on the web for an end user’s personal use. The concept of mashups can
    also be applied to the Web of Things, in the form of *physical mashups.*^([[1](#ch10fn01)])
    These are web applications that combine services from physical Things with services
    from virtual web resources.'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 第4层专注于这个问题：如何轻松地将来自各种来源的数据组合起来以创建更复杂的应用程序。Web混合应用是一种将多个Web资源结合起来创建新的、混合应用的应用程序。与传统的集成方式不同，混合应用主要关注为最终用户个人使用在网络上发生的偶然性集成。混合应用的概念也可以应用于物联网，以*物理混合应用*的形式。这些是结合了物理Things的服务和虚拟Web资源服务的Web应用程序。
- en: ¹
  id: totrans-1403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-1404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We first described the concept of physical mashups in a research paper called
    “Towards the Web of Things: Web Mashups for Embedded Devices,” and this became
    one of the core topics of Dom’s PhD thesis. Both are available from [http://webofthings.org/publications/](http://webofthings.org/publications/).'
  id: totrans-1405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在名为“迈向物联网：嵌入式设备的Web混合”的研究论文中首次描述了物理混合的概念，这成为了Dom博士论文的核心主题之一。两者都可以在[http://webofthings.org/publications/](http://webofthings.org/publications/)找到。
- en: If you read [chapter 2](kindle_split_009.html#ch02), you should already be familiar
    with the notion of physical mashups. In [section 2.6](kindle_split_009.html#ch02lev1sec6)
    (exercise 5), you combined a temperature sensor on the Pi with weather data from
    the web, an LCD screen, and a webcam—all of this with JavaScript and web APIs.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了[第2章](kindle_split_009.html#ch02)，你应该已经熟悉了物理混合的概念。在[第2.6节](kindle_split_009.html#ch02lev1sec6)（练习5）中，你将Pi上的温度传感器与来自网络的天气数据、LCD屏幕和摄像头结合起来——所有这些操作都是通过JavaScript和Web
    API完成的。
- en: 'Now that your Pi has a web API, you can create mashups with any programming
    language that supports HTTP, WebSockets, JSON and TLS (hint: pretty much all of
    them). In this chapter you’ll see that you can also create physical mashups without
    writing a single line of code! Thanks to great web tools such as boxes and wires
    or wizard-based editors, you’ll be able to create complex and powerful composite
    applications within minutes!'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然你的Pi有了Web API，你就可以使用支持HTTP、WebSockets、JSON和TLS（提示：几乎所有的语言都支持）的任何编程语言来创建混合。在本章中，你将看到你也可以不写一行代码就创建物理混合！多亏了像盒子和电线或基于向导的编辑器这样的优秀Web工具，你将在几分钟内就能创建复杂而强大的复合应用程序！
- en: '10.2.1\. Boxes and wires mashups for the Physical Web: Node-RED'
  id: totrans-1408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1\. 物理网中的盒子和电线混合：Node-RED
- en: 'Creating physical mashups using JavaScript gives you the most flexibility.
    The fact that all the Things you include in your mashups are using web protocols
    makes it straightforward. But it still requires a significant amount of work and
    programming skills when compared to the mashup technique we’ll look at next: *boxes
    and wires* editors. The idea of these tools is to make the mashup-creation process
    a lot easier by transforming programming into a visual experience consisting of
    connecting boxes to form a workflow.'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript创建物理混合提供了最大的灵活性。由于你混合中包含的所有事物都使用Web协议，这使得操作变得简单。但是，与我们将要探讨的下一项混合技术（*盒子和电线*编辑器）相比，它仍然需要大量的工作和编程技能。这些工具的想法是通过将编程转化为一个视觉体验，即通过连接盒子来形成一个工作流程，从而使混合创建过程变得更加容易。
- en: 'Basically, the *boxes* are ready-made modules that abstract operations, such
    as GETting data from a REST API, and the *wires* between the modules represent
    the flow of data or control. You can see an example in [figure 10.5](#ch10fig05).
    There are a number of boxes and wires mashup tools on the web, but one of them
    is especially geared for creating IoT mashups: Node-RED.^([[2](#ch10fn02)]) Node-RED
    is a visual tool for wiring the Internet of Things. It’s an open source project
    supporting a number of protocols but with a strong focus on web protocols and
    benefiting from a large community of developers creating new modules on an almost
    daily basis.'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，*盒子*是预先制作好的模块，它们抽象操作，例如从REST API获取数据，而模块之间的*电线*代表数据或控制的流动。你可以在[图10.5](#ch10fig05)中看到一个示例。网上有许多盒子和电线混合工具，但其中之一特别适合创建物联网混合：Node-RED.^([[2](#ch10fn02)])
    Node-RED是一个用于连接物联网的视觉工具。它是一个开源项目，支持多种协议，但重点在于Web协议，并受益于一个庞大的开发者社区，他们几乎每天都在创建新的模块。
- en: ²
  id: totrans-1411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-1412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://nodered.org/](http://nodered.org/)'
  id: totrans-1413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://nodered.org/](http://nodered.org/)'
- en: 'Figure 10.5\. The Node-RED user interface: the nodes (left) are dragged and
    dropped to create workflows by connecting them with wires, sending the data from
    one node to another.'
  id: totrans-1414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.5\. Node-RED用户界面：节点（左侧）通过电线连接拖放以创建工作流程，将数据从一个节点发送到另一个节点。
- en: '![](10fig05_alt.jpg)'
  id: totrans-1415
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig05_alt.jpg)'
- en: '|  |'
  id: totrans-1416
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The nerd corner—Let’s do it in the browser!**'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术角落——让我们在浏览器中完成它！**'
- en: Node-RED is built on top of Node.js and hence is a server-side JavaScript mashup
    tool. This has the big advantage of being able to run mashup workflows even when
    your browser is closed, but it requires installing and running more tools. Running
    mashups entirely in the browser, without the need for server code, is also possible.
    Back when Node-RED didn’t exist, we created our own client-side physical mashup
    editor called *wot-a-mashup*. This tool was built on top of ClickScript,^([[a](#ch10fn1a)])
    a nice visual programming language environment running in the browser. You’re
    more than welcome to give it a try by cloning it on GitHub.^([[b](#ch10fn2a)])
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: Node-RED建立在Node.js之上，因此是一个服务器端JavaScript混合应用工具。这有一个很大的优点，即即使在浏览器关闭的情况下也能运行混合应用工作流程，但它需要安装和运行更多的工具。完全在浏览器中运行混合应用，无需服务器代码，也是可能的。在Node-RED还不存在的时候，我们创建了自己的客户端物理混合应用编辑器，名为*wot-a-mashup*。这个工具建立在ClickScript之上，^([[a](#ch10fn1a)])一个运行在浏览器中的不错的可视化编程语言环境。你完全可以在GitHub上克隆它来尝试使用.^([[b](#ch10fn2a)])
- en: ^a
  id: totrans-1419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-1420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://clickscript.ch](http://clickscript.ch)'
  id: totrans-1421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://clickscript.ch](http://clickscript.ch)'
- en: ^b
  id: totrans-1422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^b
- en: ''
  id: totrans-1423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://github.com/webofthings/wot-a-mashup](https://github.com/webofthings/wot-a-mashup)'
  id: totrans-1424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://github.com/webofthings/wot-a-mashup](https://github.com/webofthings/wot-a-mashup)'
- en: '|  |'
  id: totrans-1425
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Getting started with Node-RED
  id: totrans-1426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Node-RED入门
- en: The good news is that Node-RED is a Node.js application, so you should be familiar
    with the tools around it. Node-RED can be installed only on your computer or in
    the cloud via NPM,^([[3](#ch10fn03)]) but it’s also available out of the box on
    your Pi. If you want the mashups you create to run continuously, it makes sense
    to deploy Node-RED on your Pi. This way, your Pi will become an always-on gateway
    that can orchestrate all the mashups in your home/hotel/business while consuming
    much less power than a PC. A number of additional Node-RED community modules are
    available specifically for the Pi; for instance, to interface with Pi hardware
    modules.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Node-RED是一个Node.js应用程序，所以你应该熟悉它周围的工具。Node-RED只能通过NPM在你的计算机或云中安装，^([[3](#ch10fn03)])但它也直接在你的树莓派上可用。如果你想创建的混合应用能够持续运行，那么在树莓派上部署Node-RED是有意义的。这样，你的树莓派将变成一个始终在线的网关，可以协调你家中/酒店/商业场所的所有混合应用，同时比PC消耗的电量少得多。还有许多专为树莓派提供的Node-RED社区模块，例如，用于与树莓派硬件模块接口的模块。
- en: ³
  id: totrans-1428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-1429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://nodered.org/docs/getting-started/installation.html](http://nodered.org/docs/getting-started/installation.html)'
  id: totrans-1430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://nodered.org/docs/getting-started/installation.html](http://nodered.org/docs/getting-started/installation.html)'
- en: 'Let’s see how you can use Node-RED to create physical mashups on top of your
    WoT Pi or any other web Thing. To start it on your Pi, use the following command:'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你如何可以使用Node-RED在你的WoT Pi或任何其他网络设备上创建物理混合应用。要在你的树莓派上启动它，请使用以下命令：
- en: '[PRE58]'
  id: totrans-1432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: That’s it! Note that Node-RED is started as a service, which means that closing
    the SSH window from which you started it won’t stop Node-RED. To stop it, use
    `node-red-stop`. If everything works, you should now be able to use the web UI
    of Node-RED by accessing [http://raspberrypi.local:1880](http://raspberrypi.local:1880)
    with any recent version of Firefox or Chrome.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！请注意，Node-RED作为服务启动，这意味着关闭你启动它的SSH窗口不会停止Node-RED。要停止它，请使用`node-red-stop`。如果一切正常，你现在应该能够通过访问[http://raspberrypi.local:1880](http://raspberrypi.local:1880)使用任何较新版本的Firefox或Chrome来使用Node-RED的Web用户界面。
- en: '|  |'
  id: totrans-1434
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The nerd corner—I want to secure Node-RED!**'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '**“极客角落——我想保护Node-RED！**”'
- en: If you made your Pi directly accessible on the web, you definitely should ensure
    Node-RED requires authentication to access it; otherwise, anyone will be able
    to reprogram your Pi as they wish! This process is straightforward. It requires
    you to generate a password and change a configuration file. This process is well
    documented online.^([[a](#ch10fn3a)])
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接将你的树莓派连接到网络上，你绝对应该确保Node-RED需要认证才能访问它；否则，任何人都可以随意重新编程你的树莓派！这个过程很简单。它需要你生成一个密码并更改一个配置文件。这个过程在网上有很好的文档说明.^([[a](#ch10fn3a)])
- en: ^a
  id: totrans-1437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-1438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://nodered.org/docs/security.html](http://nodered.org/docs/security.html)'
  id: totrans-1439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://nodered.org/docs/security.html](http://nodered.org/docs/security.html)'
- en: '|  |'
  id: totrans-1440
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The Node-RED interface is composed of three main parts, as shown in [figure
    10.5](#ch10fig05). First, you have a library of *nodes* on the left. This is where
    you can find all the boxes representing the functional bits of your mashups. Second,
    in the flow designer (center), you create your workflows (or just flows) by connecting
    different nodes together. You can configure nodes by double-clicking them in the
    flow designer. Third, the rightmost part is where you can see the documentation
    of nodes by clicking them and is also where you see the debug console.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: Node-RED界面由三个主要部分组成，如图10.5所示。首先，在左侧有一个节点库。这是您可以找到所有代表您混合应用功能块框的地方。其次，在流程设计器（中央）中，通过连接不同的节点来创建您的流程（或只是流程）。您可以通过在流程设计器中双击节点来配置节点。第三，最右侧的部分是您可以点击节点查看节点文档的地方，也是您查看调试控制台的地方。
- en: Hello World Node-RED
  id: totrans-1442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Hello World Node-RED
- en: To test all of this, let’s start by creating a simple flow that displays the
    traditional “Hello World” message. The flow is shown in [figure 10.5](#ch10fig05);
    to build it, first drag the `inject` input node and the `debug` output node onto
    the flow designer. Then, connect the extremities of both nodes together. Double-click
    the `inject` node to change the content injected by this node. Change the `Payload`
    property to a string and to contain “Hello World!” as shown in [figure 10.6](#ch10fig06).
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试所有这些功能，让我们先创建一个简单的流程，显示传统的“Hello World”消息。该流程如图10.5所示；要构建它，首先将`inject`输入节点和`debug`输出节点拖放到流程设计器中。然后，将两个节点的末端连接起来。双击`inject`节点以更改此节点注入的内容。将`Payload`属性更改为字符串，并包含“Hello
    World!”，如图10.6所示。
- en: 'Figure 10.6\. Editing nodes: when double-clicking a node, the edit dialog pops
    up where the node can be configured. This edit dialog shows the configuration
    of an `inject` output node.'
  id: totrans-1444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.6\. 编辑节点：当双击一个节点时，会弹出编辑对话框，可以在其中配置节点。此编辑对话框显示了`inject`输出节点的配置。
- en: '![](10fig06_alt.jpg)'
  id: totrans-1445
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6](10fig06_alt.jpg)'
- en: That’s it. Your first flow is ready! Now deploy it by clicking the Deploy button
    on the top right. This translates your flow into Node.js code and runs it inside
    the Node-RED process. Now, to test your flow, make sure you have the Node-RED
    debug console (on the right of the Node-RED window) visible and click the blue
    dot to the left of the `inject` module.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。您的第一个流程已经准备好了！现在通过点击右上角的Deploy按钮来部署它。这将把您的流程转换为Node.js代码，并在Node-RED进程中运行。现在，为了测试您的流程，请确保您已经打开了Node-RED调试控制台（在Node-RED窗口的右侧），并点击`inject`模块左侧的蓝色点。
- en: 'When you do this, the “Hello World” string is added to a special object called
    `msg`. This object holds the data to be passed from one node to another and can
    be either an object or an array of `msg` objects, one for the result of each node
    in the flow. In this particular case, `msg` is a single object containing the
    “Hello World” string in a `msg.payload` property. After clicking the blue Inject
    button, the workflow engine passes the `msg` object to the next node: the `debug`
    node, which displays data it receives in `msg.payload` in the debug console. This
    system basically allows you to pass data between the nodes to build workflows.
    Imagine using this to visually pass the temperature data from a node representing
    your Pi to a node representing a database.'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 当您这样做时，“Hello World”字符串会被添加到一个称为`msg`的特殊对象中。此对象持有要从一个节点传递到另一个节点的数据，可以是对象或`msg`对象的数组，每个节点在流程中的结果对应一个`msg`对象。在这种情况下，`msg`是一个包含`msg.payload`属性中的“Hello
    World”字符串的单个对象。在点击蓝色Inject按钮后，工作流程引擎将`msg`对象传递给下一个节点：`debug`节点，该节点在调试控制台中显示它接收到的`msg.payload`中的数据。这个系统基本上允许您在节点之间传递数据以构建工作流程。想象一下，使用这个来将代表您的Pi的节点中的温度数据可视地传递到代表数据库的节点。
- en: Saving workflows
  id: totrans-1448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 保存工作流程
- en: Node-RED flows can be represented and saved as JSON documents to reuse later
    or to share on the Web. To save a flow, select the flow by dragging a selection
    enclosing all nodes you want to include in the export, and click the menu next
    to Deploy on the far right of the screen. Select Export and then Clipboard. You’ll
    get the JSON document corresponding to your flow, and you can save it wherever
    you want. Then, you can use this JSON representation to share your mashup on the
    web^([[4](#ch10fn04)]) or to reimport a mashup into Node-RED by using the Import
    menu.
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: Node-RED流程可以表示并保存为JSON文档，以便以后重用或在网上共享。要保存流程，通过拖动一个选择框包围您想要包含在导出中的所有节点来选择流程，然后点击屏幕最右侧的Deploy旁边的菜单。选择Export然后Clipboard。您将获得与您的流程对应的JSON文档，您可以在任何您想要的地方保存它。然后，您可以使用此JSON表示来在网络上共享您的混合应用^([[4](#ch10fn04)])，或者通过使用导入菜单将混合应用重新导入Node-RED。
- en: ⁴
  id: totrans-1450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-1451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For instance, on the Node-RED community website: [http://flows.nodered.org/](http://flows.nodered.org/).'
  id: totrans-1452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，在Node-RED社区网站上：[http://flows.nodered.org/](http://flows.nodered.org/)。
- en: A physical mashup with Node-RED
  id: totrans-1453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于Node-RED的物理mashup
- en: Now that you’ve successfully created a simple virtual mashup with Node-RED,
    let’s see how to include the physical world using the web API of your Pi.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功使用Node-RED创建了一个简单的虚拟mashup，让我们看看如何使用Pi的Web API将物理世界包含进来。
- en: The flow you’ll build is shown in [figure 10.7](#ch10fig07) and is available
    in the book source code in chapter10-mashups/node-red/pir-websockets-twitter.json.
    The idea is to create a smart alarm mashup that receives notifications when the
    state of the PIR changes, updates the state of an LED accordingly, and sends an
    intrusion alert via Twitter. If you decided to buy one of the suggested webcams
    from the shopping list of [chapter 2](kindle_split_009.html#ch02), it should also
    take a snapshot of the intruder via the webcam and attach it to the tweet. All
    of this by connecting boxes and wires!
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要构建的流程如图10.7所示，并在第10章的源代码中提供，位于chapter10-mashups/node-red/pir-websockets-twitter.json。这个想法是创建一个智能警报mashup，当PIR的状态改变时接收通知，相应地更新LED的状态，并通过Twitter发送入侵警报。如果你决定从第2章的购物清单中购买建议的摄像头之一，它还应该通过摄像头捕捉入侵者的快照并将其附加到推文中。所有这些通过连接盒子和电线完成！
- en: Figure 10.7\. The flow of a physical mashup built with Node-RED. This physical
    mashup is a smart intruder alarm that listens for state changes of the PIR sensor
    via the WebSocket API ![](num-01.jpg). When an event arrives, Node-RED POSTs a
    `ledState` action to change the state of the LED ![](num-02.jpg)–![](num-03.jpg),
    and if the event contains a PIR sensor value of `true` ![](num-04.jpg), it GETs
    a snapshot from the webcam ![](num-05.jpg) and POSTs it on Twitter ![](num-06.jpg)–![](num-07.jpg).
  id: totrans-1456
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.7. 使用Node-RED构建的物理mashup流程。这个物理mashup是一个智能入侵警报，通过WebSocket API监听PIR传感器的状态变化![num-01.jpg]。当事件到达时，Node-RED通过POST一个`ledState`动作来改变LED的状态![num-02.jpg]–![num-03.jpg]，如果事件包含PIR传感器的值为`true`![num-04.jpg]，它通过GET从摄像头获取快照![num-05.jpg]并将其POST到Twitter![num-06.jpg]–![num-07.jpg]。
- en: '![](10fig07_alt.jpg)'
  id: totrans-1457
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig07_alt.jpg)'
- en: Let’s get started with building your workflow by referencing the steps of [figure
    10.7](#ch10fig07). First, drag and drop a `websocket` input node (step 1) and
    configure it by double-clicking it. The configuration of this node is shown in
    [figure 10.8](#ch10fig08); basically, you make it listen to the PIR WebSocket
    resource of your Pi. To do this, select Add a new websocket-client and configure
    it to ws://raspberrypi.local:8484/properties/pir^([[5](#ch10fn05)]) (the WS address
    of the PIR sensor), and make sure you select the Send/Receive Entire Message option.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从参考图10.7的步骤开始构建你的工作流程。首先，拖放一个`websocket`输入节点（步骤1），并通过双击它进行配置。这个节点的配置如图10.8所示；基本上，你让它监听Pi的PIR
    WebSocket资源。为此，选择添加一个新的websocket-client，并配置为ws://raspberrypi.local:8484/properties/pir^([[5](#ch10fn05)])（PIR传感器的WS地址），并确保你选择了发送/接收整个消息选项。
- en: ⁵
  id: totrans-1459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-1460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Secure WebSockets with self-signed certificates don’t work well on Node-RED,
    which is why we use the non-secure version of the WoT Pi for this example. If
    you have a non-self-signed certificate for your Pi, you can use the secure URL
    instead: wss://PI_URL/properties/pir.'
  id: totrans-1461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用自签名证书的Secure WebSockets在Node-RED上工作得不好，这就是为什么我们在这个例子中使用WoT Pi的非安全版本。如果你为你的Pi有一个非自签名的证书，你可以使用安全的URL：wss://PI_URL/properties/pir。
- en: Figure 10.8\. Configuration of the WebSocket input node and configuration of
    a new WebSocket client
  id: totrans-1462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.8. WebSocket输入节点配置和新的WebSocket客户端配置
- en: '![](10fig08_alt.jpg)'
  id: totrans-1463
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig08_alt.jpg)'
- en: Next, you’ll create a function node (step 2). These nodes contain bits of JavaScript
    code that can be used to transform the messages passed from one node to another
    based on certain conditions. In step 2, you use the function node to prepare a
    corresponding POST request to turn the LED on or off depending on the value of
    the PIR that was sent over WebSockets. The code of this function node is shown
    in the following listing.
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建一个函数节点（步骤2）。这些节点包含一些JavaScript代码，可以根据某些条件将一个节点传递给另一个节点的消息进行转换。在步骤2中，你使用函数节点来准备相应的POST请求，根据通过WebSocket发送的PIR的值来打开或关闭LED。这个函数节点的代码如下所示。
- en: Listing 10.7\. Prepare LED message function node
  id: totrans-1465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.7. 准备LED消息函数节点
- en: '![](293fig01_alt.jpg)'
  id: totrans-1466
  prefs: []
  type: TYPE_IMG
  zh: '![](293fig01_alt.jpg)'
- en: In step 3, you create an `http request` function node that creates an action
    on the Pi via a POST request to [http://raspberrypi.local:8484/actions/ledState](http://raspberrypi.local:8484/actions/ledState).
    The payload of this action is available to the node in `msg.payload` as prepared
    by the previous node; see [listing 10.7](#ch10ex07).
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，您创建了一个`http request`函数节点，它通过向[http://raspberrypi.local:8484/actions/ledState](http://raspberrypi.local:8484/actions/ledState)发送POST请求在Pi上创建一个动作。这个动作的有效负载作为由前一个节点准备好的内容在`msg.payload`中可用；见[列表10.7](#ch10ex07)。
- en: You should be able to test this first part of the workflow. Click Deploy and
    observe what happens when changing the state of the PIR. You just wired a sensor
    (PIR) with an actuator (LED) on the Pi using an external mashup tool!
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够测试工作流程的这一部分。点击部署，观察当改变PIR状态时会发生什么。您刚刚使用外部混合工具在Pi上连接了一个传感器（PIR）和一个执行器（LED）！
- en: 'Let’s not stop here but build the second part of the workflow. The function
    node of step 4 is a conditional node: if the `presence` value of the PIR sensor
    is `true`, it passes a message to the next node; otherwise, it interrupts this
    branch of the flow. The corresponding code is simple, the trick being that when
    a function node returns `null` the rest of the flow stops, as follows:'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不要止步于此，而是构建工作流程的第二部分。第4步的函数节点是一个条件节点：如果PIR传感器的`presence`值为`true`，它将消息传递给下一个节点；否则，它中断这个流程分支。相应的代码很简单，技巧在于当一个函数节点返回`null`时，其余的流程停止，如下所示：
- en: '[PRE59]'
  id: totrans-1470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If the `presence` value is `true`, you move on to step 5, where you take a
    snapshot using a WoT-enabled webcam. As mentioned before, if you don’t have a
    webcam offering an HTTP API, you can simply remove the nodes of steps 5 and 6\.
    If you do have a webcam, create an `http request` function node. Using the GET
    method, call the snapshot URL of the webcam (for example, `http://[IP]/snapshot.cgi?user=USER&pwd=PWD`
    in the case of a Foscam) and select binary buffer as a return type. In step 6,
    create a function node that prepares the tweet:'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`presence`值是`true`，您将进入第5步，在那里您使用支持WoT的摄像头拍摄快照。如前所述，如果您没有提供HTTP API的摄像头，您可以简单地删除第5步和第6步的节点。如果您有摄像头，创建一个`http
    request`函数节点。使用GET方法调用摄像头的快照URL（例如，在Foscam的情况下，`http://[IP]/snapshot.cgi?user=USER&pwd=PWD`），并选择二进制缓冲区作为返回类型。在第6步中，创建一个准备推文的函数节点：
- en: '[PRE60]'
  id: totrans-1472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You must copy the image in `msg.media` because this is where the `twitter`
    node expects an image to be. Step 7 is where you put the cherry on top: you send
    an intruder alert via Twitter. To do this, use a `twitter` output node and double-click
    it to configure your Twitter account by selecting Add new Twitter credentials,
    which uses OAuth (see [chapter 9](kindle_split_017.html#ch09)) to obtain a Twitter
    API token for your account.'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须复制`msg.media`中的图片，因为这是`twitter`节点期望图片所在的位置。第7步是您放置“点睛之笔”的地方：您通过Twitter发送入侵警报。为此，使用一个`twitter`输出节点，双击它以配置您的Twitter账户，选择添加新的Twitter凭据，它使用OAuth（见第9章）为您的账户获取Twitter
    API令牌。
- en: That’s it! You can now test your intruder alert workflow. Note that closing
    your browser won’t interrupt the workflow. As long as the Node-RED server runs,
    your workflow will be running, watching for the next intruder.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！您现在可以测试您的入侵警报工作流程。请注意，关闭浏览器不会中断工作流程。只要Node-RED服务器运行，您的流程就会运行，等待下一个入侵者。
- en: '|  |'
  id: totrans-1475
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The nerd corner—I want more nodes!**'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术角落——我想要更多的节点！**'
- en: Node-RED goes well beyond what we’ve implemented here. Try creating other mashups
    with your Pi and all the available nodes; for example, the `MQTT` node connecting
    to MQTT clients or the `sentiment` node analyzing if an input string is positive
    or negative. There are also hundreds of nodes from the community, ranging from
    database integrations like `node-red-node-redis` to IoT device integrations like
    `node-red-node-arduino` or IoT cloud integrations like `node-red-contrib-evrythng`
    (maintained by yours truly). All these nodes are available online.^([[a](#ch10fn4a)])
    You install them just as you’d install any Node.js module via npm. You might also
    want to create your own nodes; Node-RED also lets you do this without too much
    effort.^([[b](#ch10fn5a)])
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: Node-RED的功能远不止我们在这里实现的。尝试使用您的Pi和所有可用的节点创建其他混合应用；例如，连接到MQTT客户端的`MQTT`节点或分析输入字符串是正面还是负面的`sentiment`节点。还有来自社区的数百个节点，从数据库集成如`node-red-node-redis`到物联网设备集成如`node-red-node-arduino`或物联网云集成如`node-red-contrib-evrythng`（由我维护）。所有这些节点都在网上可用.^([[a](#ch10fn4a)])
    您可以通过npm安装它们，就像安装任何Node.js模块一样。您可能还想创建自己的节点；Node-RED也允许您轻松地做到这一点.^([[b](#ch10fn5a)])
- en: ^a
  id: totrans-1478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-1479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://flows.nodered.org/](http://flows.nodered.org/)'
  id: totrans-1480
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://flows.nodered.org/](http://flows.nodered.org/)'
- en: ^b
  id: totrans-1481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^b
- en: ''
  id: totrans-1482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://nodered.org/docs/creating-nodes/](http://nodered.org/docs/creating-nodes/)'
  id: totrans-1483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://nodered.org/docs/creating-nodes/](http://nodered.org/docs/creating-nodes/)'
- en: '|  |'
  id: totrans-1484
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '10.3\. Using wizards for physical mashups: IFTTT'
  id: totrans-1485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 使用向导进行物理混合应用：IFTTT
- en: 'Visual mashup editors such as Node-RED drastically reduce the time it takes
    to build IoT prototypes. They also significantly simplify the programming process,
    but you still have to *program* your mashups. The next mashup technique we look
    at further pushes the abstractions to simplify even more the creation of mashups.
    Wizard-based mashup tools consist of a user interface that guides you through
    a number of steps to create a customized workflow. If you’ve ever used the filter
    editor of your mail client, you must know what a wizard interface looks like:
    a number of steps to create a rule.'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 如Node-RED之类的视觉混合编辑器极大地缩短了构建物联网原型所需的时间。它们还显著简化了编程过程，但你仍然需要*编程*你的混合应用。我们接下来要探讨的下一个混合应用技术进一步将抽象推向简化混合应用创建的方向。基于向导的混合应用工具由一个用户界面组成，该界面引导你通过一系列步骤创建一个定制的工作流程。如果你曾经使用过你的邮件客户端的过滤器编辑器，你必须知道向导界面是什么样的：一系列步骤来创建一个规则。
- en: A number of wizard mashup tools are available, with Zapier^([[6](#ch10fn06)])
    and IFTTT^([[7](#ch10fn07)]) being the most popular. Both tools integrate with
    a large number of web services ranging from Google Drive to Instagram or Facebook.
    IFTTT stands for stands for “If This Then That” and is especially relevant here
    because it’s on a mission to incorporate many IoT devices and platforms, so let’s
    take a closer look at this tool.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多基于向导的混合应用工具可用，其中Zapier^([[6](#ch10fn06)])和IFTTT^([[7](#ch10fn07)])是最受欢迎的。这两个工具都与大量网络服务集成，从Google
    Drive到Instagram或Facebook。IFTTT代表“如果这个，那么那个”，在这里特别相关，因为它致力于整合许多物联网设备和平台，所以让我们更详细地看看这个工具。
- en: ⁶
  id: totrans-1488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-1489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://zapier.com](https://zapier.com)'
  id: totrans-1490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://zapier.com](https://zapier.com)'
- en: ⁷
  id: totrans-1491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-1492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://ifttt.com](https://ifttt.com)'
  id: totrans-1493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://ifttt.com](https://ifttt.com)'
- en: Basically, the tool lets you create an `if (conditions) then (actions)` statement
    without having to write a single line of code. The `conditions` and `actions`
    must be selected from a growing list of prepackaged web integrations ranging from
    Twitter to Google Drive, as well IoT integrations such as the Nest Thermostat,
    the Philips Hue lighting system, the SmartThings home automation devices, and
    the Misfit wearable devices. To create these `if-then` statements, IFTTT takes
    you through a seven-step wizard process. Once the process is finished, the newly
    created workflow will run for as long as you want it on the IFTTT servers in the
    cloud.
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这个工具让你能够创建一个`if (conditions) then (actions)`语句，而无需编写任何代码。`conditions`和`actions`必须从从Twitter到Google
    Drive等预包装的网页集成列表中选择，以及如Nest恒温器、Philips Hue照明系统、SmartThings智能家居设备和Misfit可穿戴设备等物联网集成。为了创建这些`if-then`语句，IFTTT会带你通过一个七步向导过程。一旦过程完成，新创建的工作流程将在云端的IFTTT服务器上运行，直到你想要它停止。
- en: IFTTT is a simple yet powerful system, but it doesn’t allow the general public
    to make any integration in any way you want beyond the channels offered. It does,
    however, offer the Maker channel,^([[8](#ch10fn08)]) which allows you to integrate
    with arbitrary REST APIs.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: IFTTT是一个简单而强大的系统，但它不允许公众以任何方式在提供的渠道之外进行任何集成。然而，它确实提供了制造商渠道，^([[8](#ch10fn08)])
    这允许你与任意的REST API进行集成。
- en: ⁸
  id: totrans-1496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-1497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://ifttt.com/maker](https://ifttt.com/maker)'
  id: totrans-1498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://ifttt.com/maker](https://ifttt.com/maker)'
- en: 10.3.1\. Pushing intruder alert tweets to a Google spreadsheet
  id: totrans-1499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1\. 将入侵警报推文推送到谷歌电子表格
- en: 'Let’s experiment with IFTTT and create a simple integration of our smart intrusion-detection
    system. Here’s the first workflow we want to create:'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过IFTTT进行实验，创建我们智能入侵检测系统的简单集成。这是我们想要创建的第一个工作流程：
- en: If a new Intruder Detected tweet is posted...
  id: totrans-1501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发布了一条新的“入侵检测到”推文...
- en: then log an entry in a Google spreadsheet document.
  id: totrans-1502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后在谷歌电子表格文档中记录一条条目。
- en: First, you should create a free IFTTT account^([[9](#ch10fn09)]) and log into
    your account. In the IFTTT world, workflows are called *recipes*. Start by creating
    a new recipe, as shown in [figure 10.9](#ch10fig09).
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该创建一个免费的IFTTT账户^([[9](#ch10fn09)]) 并登录到你的账户。在IFTTT的世界里，工作流程被称为*食谱*。首先创建一个新的食谱，如图10.9所示。
- en: ⁹
  id: totrans-1504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-1505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://ifttt.com/join](https://ifttt.com/join)'
  id: totrans-1506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://ifttt.com/join](https://ifttt.com/join)'
- en: 'Figure 10.9\. IFTTT workflows are called recipes. They are composed of two
    parts: a condition (this) and a reaction (that) triggered when the condition is
    met.'
  id: totrans-1507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.9. IFTTT工作流程被称为配方。它们由两部分组成：一个条件（this）和一个反应（that），当条件满足时触发。
- en: '![](10fig09_alt.jpg)'
  id: totrans-1508
  prefs: []
  type: TYPE_IMG
  zh: '![图10.09](10fig09_alt.jpg)'
- en: By clicking the “this” link you set up the condition. In IFTTT, both conditions
    and reactions are called *channels*. The channels are essentially the prepackaged
    integrations we were talking about before. Select the Twitter channel and then
    the New Tweet By A Specific User trigger, and when prompted for a Twitter user,
    provide the handle of the Twitter account you want to use—@wotbook in this example.
    That’s it for your condition. Basically, what you’ve created so far is an `if
    (new Tweet by @TwitterAccount)`.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击“this”链接，你设置条件。在IFTTT中，条件和反应都被称为“通道”。通道基本上是我们之前提到的预包装集成。选择Twitter通道，然后选择特定用户的推文触发器，当被提示输入Twitter用户时，提供你想要使用的Twitter账户的昵称——在这个例子中是@wotbook。这就是你的条件设置。基本上，你到目前为止创建的是一个`if
    (new Tweet by @TwitterAccount)`。
- en: 'Next, you need to create the reaction. Click the “that” link. Same story: select
    a channel for the reaction. We selected the Google Drive Channel and the Add Row
    To Spreadsheet option. This prompts you to connect your Google account and then
    to set up the spreadsheet and the content you want to be written to the spreadsheet.
    This step is shown in [figure 10.10](#ch10fig10).'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建反应。点击“that”链接。同样的情况：选择一个用于反应的通道。我们选择了Google Drive通道和添加行到电子表格选项。这会提示你连接你的Google账户，然后设置电子表格和你要写入电子表格的内容。这一步如图10.10所示。
- en: Figure 10.10\. Setting up the spreadsheet. IFTTT lets you add variables by clicking
    the Erlenmeyer flask icon. Here we use variables such as the Twitter user name
    (UserName), the content of the tweet (Text), and the timestamp of the Tweet (CreatedAt).
    All these fields will appear in the new row created in the Google spreadsheet
    located in an IFTTT/Twitter folder.
  id: totrans-1511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.10. 设置电子表格。IFTTT允许你通过点击Erlenmeyer烧瓶图标来添加变量。在这里，我们使用诸如Twitter用户名（UserName）、推文内容（Text）和推文的创建时间戳（CreatedAt）等变量。所有这些字段都将出现在位于IFTTT/Twitter文件夹中的Google电子表格中创建的新行中。
- en: '![](10fig10_alt.jpg)'
  id: totrans-1512
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10](10fig10_alt.jpg)'
- en: 'Finally, in step #7 of the wizard you’re ready to create your workflow by selecting
    Create Recipe, as shown in [figure 10.11](#ch10fig11). This saves the workflow
    to your account and runs it continuously for you in the cloud.'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在向导的第7步，你准备好通过选择创建配方来创建你的工作流程，如图10.11所示。这将工作流程保存到你的账户，并在云中为你持续运行。
- en: 'Figure 10.11\. Step 7 is the final step of the workflow creation process. It
    summarizes the workflow you just created: if a tweet is pushed, then add a row
    to the Google Drive spreadsheet.'
  id: totrans-1514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.11. 第7步是工作流程创建过程的最后一步。它总结了您刚刚创建的工作流程：如果推文被推送，则向Google Drive电子表格添加一行。
- en: '![](10fig11_alt.jpg)'
  id: totrans-1515
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11](10fig11_alt.jpg)'
- en: To test it, run the Node-RED code of [section 10.2](#ch10lev1sec2) and trigger
    the PIR sensor, or simulate this by tweeting from the account you selected. If
    everything works according to plan, you should see a new entry in your Google
    spreadsheet document in the IFTTT/Twitter folder, as shown in [figure 10.12](#ch10fig12).
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试它，运行[第10.2节](#ch10lev1sec2)的Node-RED代码并触发PIR传感器，或者通过你选择的账户发推文来模拟这一过程。如果一切按计划进行，你应该在你的Google电子表格文档的IFTTT/Twitter文件夹中看到一个新的条目，如图10.12所示。
- en: Figure 10.12\. When an intruder is detected by the PIR sensor on your Pi, it
    tweets it via Node-RED. IFTTT detects this and adds a corresponding entry in your
    Google spreadsheet. Here you can see three intruder detection events.
  id: totrans-1517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.12. 当你的Pi上的PIR传感器检测到入侵者时，它通过Node-RED发布推文。IFTTT检测到这一点，并在你的Google电子表格中添加相应的条目。在这里，你可以看到三个入侵检测事件。
- en: '![](10fig12_alt.jpg)'
  id: totrans-1518
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12](10fig12_alt.jpg)'
- en: 10.3.2\. Sending requests to a Thing with the Maker Channel
  id: totrans-1519
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2. 通过制造商通道向一个“物”发送请求
- en: 'The mashup we just created is pretty impressive but it impacts only the virtual
    world, a spreadsheet. What if it could also impact the physical world, such as
    by changing the state of actuators on your WoT Pi? Wouldn’t this be pretty powerful?
    It turns out you can do this via the IFTTT Maker channel. This WoT-friendly channel
    allows you to send REST requests via HTTP in the “then” part of a workflow, like
    this:'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的混合应用相当令人印象深刻，但它只影响虚拟世界，即电子表格。如果它还能影响物理世界，比如改变WoT Pi上执行器的状态呢？这不会很强大吗？实际上，你可以通过IFTTT制造商通道做到这一点。这个对WoT友好的通道允许你在工作流程的“then”部分通过HTTP发送REST请求，如下所示：
- en: '***If—*** A new Intruder Detected tweet is posted'
  id: totrans-1521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***如果——*** 新的“入侵检测”推文被发布'
- en: '***Then—*** Turn on the LED of your Pi.'
  id: totrans-1522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***然后——*** 打开您的树莓派的LED灯。'
- en: 'Start by creating a new recipe. The “if” part of the workflow is exactly the
    same as before: select the Twitter channel and then New Tweet By A Specific User.
    For the “then” part use the Maker channel and configure it as shown in [figure
    10.13](#ch10fig13).'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的食谱。工作流程的“如果”部分与之前完全相同：选择Twitter通道，然后选择“由特定用户发送的新推文”。对于“然后”部分，使用Maker通道，并按照[图10.13](#ch10fig13)中的说明进行配置。
- en: Figure 10.13\. Make a REST request via HTTP to your WoT Pi. This creates a new
    `ledState` action on your Pi by POSTing the corresponding JSON payload.
  id: totrans-1524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.13. 通过HTTP向您的WoT Pi发送REST请求。通过POST相应的JSON有效负载，在您的Pi上创建一个新的`ledState`动作。
- en: '![](10fig13_alt.jpg)'
  id: totrans-1525
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig13_alt.jpg)'
- en: Note that in order to create this recipe, your Pi needs to be securely accessible
    on the web because IFTTT runs on the web and luckily (or hopefully!) doesn’t have
    access to your local network. Refer to [chapter 9](kindle_split_017.html#ch09)
    for more information on how to do that. If you didn’t put your Pi on the web or
    don’t want to, you can instead use the connected Pi you used in [chapter 2](kindle_split_009.html#ch02)
    and display an alert on its screen whenever an intruder is detected. You can do
    this by POSTing to the following URL [http://devices.webofthings.io/pi/actuators/display/content](http://devices.webofthings.io/pi/actuators/display/content)
    a JSON object with the message to display; for example, `{"value":"Intruder Detected!"}`.
    Finally, create your workflow by selecting Create Recipe. Now, whenever a tweet
    is sent, you’ll see the LED of your Pi turning on—or a message will be displayed
    on your Pi.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了创建这个食谱，您的树莓派需要在网络上安全可访问，因为IFTTT在网络上运行，幸运的是（或者希望如此！）它无法访问您的本地网络。有关如何做到这一点的更多信息，请参阅[第9章](kindle_split_017.html#ch09)。如果您没有将树莓派放在网络上或者不想这样做，您可以使用[第2章](kindle_split_009.html#ch02)中使用的连接树莓派，并在检测到入侵者时在其屏幕上显示警报。您可以通过向以下URL
    [http://devices.webofthings.io/pi/actuators/display/content](http://devices.webofthings.io/pi/actuators/display/content)
    发送POST请求来实现，发送包含要显示的消息的JSON对象；例如，`{"value":"Intruder Detected!"}`。最后，通过选择创建食谱来创建您的流程。现在，每当发送一条推文时，您将看到您的树莓派的LED灯亮起——或者会在树莓派上显示一条消息。
- en: 10.3.3\. Pushing intruder alert tweets to a Google spreadsheet
  id: totrans-1527
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.3. 将入侵警报推文推送到Google表格
- en: 'Let’s step back for a second and reflect on what you just built. When your
    Raspberry Pi detects an intruder via the PIR sensor, Node-RED tweets a picture
    taken from your webcam. IFTTT listens for such tweets and adds a corresponding
    entry in a Google spreadsheet. The second rule goes even further and uses REST
    to turn on the LED of your Pi over the web. We were able to build such complex
    workflows in minutes thanks to the power and ubiquity of web APIs: all the actors
    in our workflow can speak to each other via web protocols. Node-RED uses the WoT
    WebSocket API of the Pi and the HTTP API of Twitter. IFTTT also uses the HTTP
    API of Twitter and the HTTP API of Google Drive. Finally, IFTTT uses the RESTful
    HTTP API of your Pi to actuate it via actions. This is the true beauty and power
    of the Web of Things!'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微退后一步，回顾一下您刚刚构建的内容。当您的树莓派通过PIR传感器检测到入侵者时，Node-RED会通过您的网络摄像头发送一张图片。IFTTT监听这样的推文，并在Google表格中添加相应的条目。第二条规则更进一步，使用REST在网络上打开您的树莓派的LED灯。我们能够在几分钟内构建如此复杂的流程，这要归功于Web
    API的力量和普及：我们流程中的所有参与者都可以通过Web协议相互通信。Node-RED使用树莓派的WoT WebSocket API和Twitter的HTTP
    API。IFTTT也使用Twitter的HTTP API和Google Drive的HTTP API。最后，IFTTT使用您的树莓派的RESTful HTTP
    API通过动作来激活它。这就是物联网的真正美和力量！
- en: '|  |'
  id: totrans-1529
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The nerd corner—More mashups!**'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: '**极客角落——更多混合应用！**'
- en: 'There are many ways to tweak the workflow you just created. As an example,
    you could use the Twitter condition “New tweet by you with hashtag” so you trigger
    the alert only for tweets with a particular # hashtag. Why stop here? IFTTT opens
    many more doors to create interesting workflows! As an example, we created another
    recipe that sends us an SMS whenever an intrusion is detected. If you want to
    create more mashups, browse [https://ifttt.com/channels](https://ifttt.com/channels)
    and look for inspiring channels. Need ideas? Try using the other sensors of your
    Pi such as the temperature or humidity sensor, logging values inside documents,
    creating visualizations, or sending weather alerts. Be creative; the cloud is
    the only limit! Note that you don’t have to use Twitter to integrate data from
    your Pi to IFTTT. You can also use the IFTTT Maker channel in the reverse direction
    to communicate with IFTTT via REST and trigger workflows. Finally, there’s a world
    beyond the mashup tools we looked at here and some are really worth a try. For
    example, Freeboard^([[a](#ch10fn6a)]) allows you create visual dashboards mashing
    up the data from various devices and integrates nicely with the Web of Things.
    Some IoT platforms also conveniently have mashup tools built in. EVRYTHNG, for
    example, provides a tool called the Reactor, which lets you write Node.js scripts
    that are run in the cloud and can be triggered each time the state of your connected
    Things change.^([[b](#ch10fn7a)])'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以调整您刚刚创建的工作流程。例如，您可以使用Twitter的条件“您的新推文带有特定#标签”，这样只有带有特定#标签的推文才会触发警报。为什么止步于此？IFTTT为您打开了更多创建有趣工作流程的大门！例如，我们创建了一个新的食谱，每当检测到入侵时都会给我们发送短信。如果您想创建更多混合应用，请浏览[https://ifttt.com/channels](https://ifttt.com/channels)，寻找有启发性的通道。需要灵感吗？尝试使用您的Pi的其他传感器，如温度或湿度传感器，在文档中记录值，创建可视化，或发送天气警报。发挥创意；云是唯一的限制！请注意，您不必使用Twitter来集成Pi的数据到IFTTT。您还可以使用IFTTT制造商通道的反向通信，通过REST与IFTTT通信并触发工作流程。最后，还有我们在这里查看的混合工具之外的世界，其中一些真的值得一试。例如，Freeboard^([[a](#ch10fn6a)])允许您创建将来自各种设备的混合数据可视仪表板，并且与物联网很好地集成。一些物联网平台也方便地内置了混合工具。例如，EVRYTHNG提供了一个名为Reactor的工具，它允许您编写在云中运行的Node.js脚本，并且每次连接的设备状态发生变化时都可以触发这些脚本.^([[b](#ch10fn7a)])
- en: ^a
  id: totrans-1532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-1533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://freeboard.io/](https://freeboard.io/)'
  id: totrans-1534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://freeboard.io/](https://freeboard.io/)'
- en: ^b
  id: totrans-1535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^b
- en: ''
  id: totrans-1536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://developers.evrythng.com/docs/reactor](https://developers.evrythng.com/docs/reactor)'
  id: totrans-1537
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://developers.evrythng.com/docs/reactor](https://developers.evrythng.com/docs/reactor)'
- en: '|  |'
  id: totrans-1538
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So what?
  id: totrans-1539
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 那又如何？
- en: The key takeaway of this section is that by moving Things and their services
    closer to the web, we can seamlessly integrate them with the very large ecosystem
    of web tools. Had we not built the API of our Pi based on web standards but rather
    on closed protocols, creating this integration would have taken significantly
    more time. The two tools we used offer different levels of integration. Node-RED
    is open and supports many standard web protocols out of the box, but it’s primarily
    a prototyping tool meant for developers and makers. On the other hand, IFTTT takes
    a much more controlled approach targeting less technically skilled users but doesn’t
    offer the same level of flexibility and configurability. In consequence, devices
    and services need to go through a selective selection process with the IFTTT team
    in order to get their own channels.
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的关键要点是，通过将事物及其服务更靠近网络，我们可以无缝地将它们集成到庞大的网络工具生态系统中。如果我们不是基于网络标准而是基于封闭协议构建我们的Pi
    API，那么创建这种集成将需要更多的时间。我们使用的两个工具提供了不同级别的集成。Node-RED是开放的，并且默认支持许多标准网络协议，但它主要是一个面向开发者和制造商的原型设计工具。另一方面，IFTTT采取了一种更加受控的方法，针对技术能力较低的用户，但并不提供相同级别的灵活性和可配置性。因此，设备和服务需要经过IFTTT团队的选择性筛选过程，才能获得自己的通道。
- en: Nevertheless, the common denominator of both platforms is the web. Using a Web
    of Things approach radically reduces the prototyping time and open the doors for
    new ideas and integration opportunities for the Internet of Things. Devices aren’t
    locked in their own closed worlds anymore but become open for integration.
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这两个平台共同的基础是网络。使用物联网方法极大地减少了原型设计时间，并为物联网的新想法和集成机会打开了大门。设备不再被锁定在自己的封闭世界中，而是可以开放进行集成。
- en: 10.4\. Beyond the book
  id: totrans-1542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4. 超越本书
- en: Mashups are important for the Web of Things because they illustrate the simplicity
    offered by the WoT approach. Let’s talk about what the future of WoT composite
    applications looks like.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 混合应用对于物联网网络非常重要，因为它们展示了物联网方法提供的简单性。让我们来谈谈物联网复合应用的未来看起来像什么。
- en: 10.4.1\. From simple mashups to big data mashups
  id: totrans-1544
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.1\. 从简单的混合应用到大数据混合应用
- en: 'The future will be about big data mashups. Very big data! Things connected
    to the web will generate an unprecedented amount of data. Think about it: 1 million
    connected devices sending a sensor reading every second to an IoT cloud means
    86.4 billion messages per day (yes, billion!) That’s roughly 170 times more than
    all tweets posted globally that same day^([[10](#ch10fn10)])!'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 未来将是大数据混合应用的时代。非常巨大的数据！连接到互联网的事物将产生前所未有的数据量。想想看：一百万个连接设备每秒向物联网云发送一个传感器读数意味着每天有8640亿条消息（是的，十亿！）这大约是全球当天发布的所有推文的170倍^([[10](#ch10fn10)])！
- en: ^(10)
  id: totrans-1546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10)
- en: ''
  id: totrans-1547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See “What Happens in an Internet Minute”: [http://www.intel.co.uk/content/www/uk/en/communications/internet-minute-infographic.html](http://www.intel.co.uk/content/www/uk/en/communications/internet-minute-infographic.html).'
  id: totrans-1548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见“一分钟的互联网发生了什么”：[http://www.intel.co.uk/content/www/uk/en/communications/internet-minute-infographic.html](http://www.intel.co.uk/content/www/uk/en/communications/internet-minute-infographic.html)。
- en: Put this in perspective with the 20 to 50 billion connected devices predicted
    for 2020 (see [chapter 1](kindle_split_008.html#ch01)) and we have a significant
    data challenge ahead of us. Yet data is the new gold, so we’d be fools not to
    exploit it! Although currently much of the focus on the IoT is on raw connectivity,
    exploiting this data is the next big wave we expect. IoT data has the potential
    to make our world smarter and more aware, but the amount of data it will generate
    will crush any of the traditional data tools we were using in the past.
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与预测到2020年将有200亿到500亿个连接设备（见[第1章](kindle_split_008.html#ch01)）进行比较，我们面前有一个重大的数据挑战。然而，数据是新的黄金，所以我们不会愚蠢地不利用它！尽管目前对物联网的关注主要集中在原始连接上，但我们预计利用这些数据将是下一个大潮。物联网数据有潜力使我们的世界变得更智能、更有意识，但它将产生的大量数据将压垮我们过去使用的所有传统数据工具。
- en: Many of the new big data techniques and technologies will help. As an example,
    considering events as they come and running queries on a stream of events instead
    of against databases should help us crunch more IoT data. Large-scale and real-time
    stream and data processing systems like Spark^([[11](#ch10fn11)]), Storm^([[12](#ch10fn12)]),
    Flink,^([[13](#ch10fn13)]) or Samza^([[14](#ch10fn14)]) are mushrooming these
    days and help us deal with these challenges. Real-time analytics techniques will
    help us create applications that can trigger alerts right when abnormal events
    happen.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 许多新的大数据技术和方法将有所帮助。例如，将事件视为它们发生时，并在事件流上运行查询而不是在数据库上，应该有助于我们处理更多的物联网数据。像Spark^([[11](#ch10fn11)]),
    Storm^([[12](#ch10fn12)]), Flink,^([[13](#ch10fn13)]) 或 Samza^([[14](#ch10fn14)])
    这样的大规模和实时流数据处理系统如今如雨后春笋般涌现，帮助我们应对这些挑战。实时分析技术将帮助我们创建能够在异常事件发生时立即触发警报的应用程序。
- en: ^(11)
  id: totrans-1551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(11)
- en: ''
  id: totrans-1552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://spark.apache.org/](https://spark.apache.org/)'
  id: totrans-1553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://spark.apache.org/](https://spark.apache.org/)'
- en: ^(12)
  id: totrans-1554
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(12)
- en: ''
  id: totrans-1555
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://storm.apache.org/](https://storm.apache.org/)'
  id: totrans-1556
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://storm.apache.org/](https://storm.apache.org/)'
- en: ^(13)
  id: totrans-1557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(13)
- en: ''
  id: totrans-1558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://flink.apache.org/](https://flink.apache.org/)'
  id: totrans-1559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://flink.apache.org/](https://flink.apache.org/)'
- en: ^(14)
  id: totrans-1560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(14)
- en: ''
  id: totrans-1561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://samza.apache.org/](http://samza.apache.org/)'
  id: totrans-1562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://samza.apache.org/](http://samza.apache.org/)'
- en: Machine learning methods and tools (a modern term for artificial intelligence)
    will help us create more intelligent applications that can analyze and learn from
    huge amounts of unstructured data and allow applications—from logistics, to public
    transportation, to city management—to adapt their behavior and make optimal decisions
    in real time. Some devices are already using these techniques. Nest^([[15](#ch10fn15)])
    thermostats, for instance, use data patterns to predict the temperature you’re
    likely to prefer in a specific room at a specific time.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习方法和工具（人工智能的现代术语）将帮助我们创建更智能的应用程序，这些应用程序可以分析并从大量非结构化数据中学习，并允许应用程序——从物流到公共交通，再到城市管理——实时调整其行为并做出最优决策。一些设备已经使用这些技术。例如，Nest^([[15](#ch10fn15)])
    恒温器使用数据模式来预测你可能在特定时间特定房间中可能喜欢的温度。
- en: ^(15)
  id: totrans-1564
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(15)
- en: ''
  id: totrans-1565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://nest.com/](https://nest.com/)'
  id: totrans-1566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://nest.com/](https://nest.com/)'
- en: Most of this data integration and processing is likely to happen in the cloud,
    so it makes sense to connect Things to the web to be able to efficiently pipe
    this data. Having said that, a certain level of filtering and intelligence will
    also be required on devices. We still have a lot of tools and techniques to build
    and improve in order to use in the most efficient manner the massive amount of
    data the IoT will generate!
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数此类数据集成和处理可能发生在云端，因此将设备连接到网络以有效地传输这些数据是有意义的。话虽如此，设备上也需要一定程度的过滤和智能。我们还有很多工具和技术需要构建和改进，以便最有效地使用物联网将产生的大量数据！
- en: 10.4.2\. A better user experience
  id: totrans-1568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.2. 更好的用户体验
- en: Data will not only make Things smarter but will also improve the way we interact
    with the physical world. Currently, many consumer products, especially electronic
    appliances, are still quite cumbersome to use. If everyday products are to become
    smarter, the way we interact with the digital world will have to change. The way
    we interact with smart products will especially have to become more intuitive
    and less obtrusive. Because sensing technologies will keep evolving, new ways
    of interacting with the digital world will become possible—far beyond a keyboard,
    touchscreen, or mouse.
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 数据不仅会使设备更智能，还会改善我们与物理世界的互动方式。目前，许多消费产品，尤其是电子产品，使用起来仍然相当繁琐。如果日常产品要变得更智能，我们与数字世界的互动方式也必须改变。我们与智能产品的互动方式尤其需要更加直观和不太干扰。因为感知技术将持续发展，与数字世界互动的新方式将变得可能——远远超出键盘、触摸屏或鼠标。
- en: User experience and interaction design for the IoT are yet in their infancy,
    but the potential to revolutionize the way we interact with machines—and soon
    the physical world, for that matter—is absolutely massive.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网的用户体验和交互设计还处于初级阶段，但其革命我们与机器互动方式——以及很快的物理世界——的潜力绝对是巨大的。
- en: Rituals that would have sounded weird or futuristic a mere 20 years ago have
    become an everyday routine for some of us. From swiping your wallet to pay for
    the bus ride home, to unlocking your door with your phone (or even an RFID body
    implant!), or the heating turning on automatically when you’re 20 minutes away
    from your home—this is only the beginning of a world that’s becoming smarter.
    Remember, however, that a better user experience ultimately also means a safer
    one, and the WoT pioneer you became through this book shouldn’t forget to put
    security higher on the list than pure usability. Don’t mess with the real world!
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 20 年前听起来奇怪或未来派的仪式，对我们中的一些人来说已经成为日常惯例。从用钱包刷公交回家，到用手机（甚至 RFID 身体植入物）解锁门，或者当你离家
    20 分钟时自动打开暖气——这只是我们正在变得智能的世界的一个开始。然而，记住，更好的用户体验最终也意味着更安全，通过这本书成为 WoT 先锋的你不应忘记将安全性放在比纯可用性更高的位置。不要在现实世界中胡来！
- en: 10.5\. Summary
  id: totrans-1572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5. 摘要
- en: Thanks to the semantic layer of the Web Thing Model combined with web APIs,
    a universal remote control web app for Things can be created using straightforward
    JavaScript code that fetches the model and crawls resources.
  id: totrans-1573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 Web Thing Model 的语义层与 Web API 的结合，可以使用简单的 JavaScript 代码创建一个通用的远程控制网页应用，该代码检索模型并爬取资源。
- en: Physical mashups are composite web applications combining virtual services with
    services provided by Things.
  id: totrans-1574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理混合是将虚拟服务与设备提供的服务相结合的复合网页应用。
- en: 'There are two big types of mashup tools: boxes and wires, and wizards.'
  id: totrans-1575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合工具主要有两大类：盒子和电线，以及巫师。
- en: Boxes and wires editors allow you to visually connect different actors of the
    virtual world and the physical world. A good example of a physical mashup editor
    is Node-RED.
  id: totrans-1576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盒子和电线编辑器允许你直观地连接虚拟世界和物理世界中的不同参与者。物理混合编辑器的一个好例子是 Node-RED。
- en: Wizard editors guide you through a number of steps to create composite applications.
    IFTTT is a physical mashup editor based on the wizard principle; it allows you
    to connect all kinds of physical Things to all kind of virtual services to create
    simple triggers and reactions.
  id: totrans-1577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 巫师编辑器引导你通过多个步骤来创建组合应用程序。IFTTT 是基于巫师原则的物理混合编辑器；它允许你将各种物理设备连接到各种虚拟服务，以创建简单的触发和反应。
- en: 'You’ve just made it through all the layers of the WoT architecture. Congrats!
    Consider yourself now ready to build the web of your Things! To keep you inspired
    for the years to come, we’ll leave you with a quote from the famed Mark Weiser,
    one of the grandfathers of the Internet of Things:'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经通过了WoT架构的所有层级。恭喜！现在你可以开始构建你的物联网络了！为了让你在未来几年里保持灵感，我们将留下著名人物马克·魏斯勒的一句话，他是物联网的奠基人之一：
- en: '*The most profound technologies are those that disappear. They weave themselves
    into the fabric of everyday life until they are indistinguishable from it.*'
  id: totrans-1579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*最深刻的技术是那些消失的技术。它们融入日常生活的织锦中，直到它们与日常生活无法区分.*'
- en: ''
  id: totrans-1580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Mark Weiser, in “The Computer for the 21st Century” (September 1991)*'
  id: totrans-1581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*马克·魏斯勒，在《21世纪的计算机》（1991年9月）一文中*'
