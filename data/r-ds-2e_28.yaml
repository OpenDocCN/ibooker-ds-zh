- en: Chapter 24\. Web Scraping
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第24章 网络抓取
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter introduces you to the basics of web scraping with [rvest](https://oreil.ly/lUNa6).
    Web scraping is a useful tool for extracting data from web pages. Some websites
    will offer an API, a set of structured HTTP requests that return data as JSON,
    which you handle using the techniques from [Chapter 23](ch23.xhtml#chp-rectangling).
    Where possible, you should use the API,^([1](ch24.xhtml#idm44771274112496)) because
    typically it will give you more reliable data. Unfortunately, however, programming
    with web APIs is out of scope for this book. Instead, we are teaching scraping,
    a technique that works whether or not a site provides an API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍使用[rvest](https://oreil.ly/lUNa6)进行网络抓取的基础知识。网络抓取是从网页中提取数据的有用工具。一些网站会提供API，这是一组结构化的HTTP请求，返回JSON格式的数据，您可以使用[第23章](ch23.xhtml#chp-rectangling)中介绍的技术处理这些数据。在可能的情况下，应该使用API，^([1](ch24.xhtml#idm44771274112496))
    因为通常它会提供更可靠的数据。不过，本书的范围不包括使用Web API进行编程。相反，我们正在教授抓取技术，这是一种无论网站是否提供API都可以使用的技术。
- en: In this chapter, we’ll first discuss the ethics and legalities of scraping before
    we dive into the basics of HTML. You’ll then learn the basics of CSS selectors
    to locate specific elements on the page and how to use rvest functions to get
    data from text and attributes out of HTML and into R. We’ll then discuss some
    techniques to figure out what CSS selector you need for the page you’re scraping,
    before finishing up with a couple of case studies and a brief discussion of dynamic
    websites.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先讨论抓取的道德和法律问题，然后深入讨论HTML的基础知识。然后，您将学习CSS选择器的基础知识，以定位页面上的特定元素，并了解如何使用rvest函数将数据从HTML的文本和属性中提取出来，并将其导入到R中。接着，我们将讨论一些确定您需要的CSS选择器的技术，最后，通过几个案例研究和对动态网站的简要讨论，结束本章。
- en: Prerequisites
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: In this chapter, we’ll focus on tools provided by rvest. rvest is a member of
    the tidyverse but is not a core member, so you’ll need to load it explicitly.
    We’ll also load the full tidyverse since we’ll find it generally useful working
    with the data we’ve scraped.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于rvest提供的工具。rvest是tidyverse的成员之一，但不是核心成员，因此您需要显式加载它。我们还将加载完整的tidyverse，因为在处理我们抓取的数据时，它通常会很有用。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Scraping Ethics and Legalities
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抓取的道德和法律问题
- en: Before we get started discussing the code you’ll need to perform web scraping,
    we need to talk about whether it’s legal and ethical for you to do so. Overall,
    the situation is complicated with regard to both of these.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论您需要执行网页抓取的代码之前，我们需要讨论这样做是否合法和道德。总体而言，涉及这两者的情况都很复杂。
- en: Legalities depend a lot on where you live. However, as a general principle,
    if the data is public, nonpersonal, and factual, you’re likely to be OK.^([2](ch24.xhtml#idm44771274043040))
    These three factors are important because they’re connected to the site’s terms
    and conditions, personally identifiable information, and copyright, as we’ll discuss.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 法律问题在很大程度上取决于您所在的地方。然而，作为一个通用原则，如果数据是公开的、非个人的和事实性的，您可能不会有问题。^([2](ch24.xhtml#idm44771274043040))
    这三个因素很重要，因为它们与网站的条款和条件、个人可识别信息以及版权有关，我们将在后文讨论。
- en: If the data isn’t public, nonpersonal, or factual or if you’re scraping the
    data specifically to make money with it, you’ll need to talk to a lawyer. In any
    case, you should be respectful of the resources of the server hosting the pages
    you are scraping. Most important, this means that if you’re scraping many pages,
    you should make sure to wait a little between each request. One easy way to do
    so is to use the [polite package](https://oreil.ly/rlujg) by Dmytro Perepolkin.
    It will automatically pause between requests and cache the results so you never
    ask for the same page twice.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据不是公开的、非个人的或不是事实性的，或者如果您抓取数据是为了盈利，您需要咨询律师。无论如何，您都应该尊重托管网页的服务器资源。最重要的是，如果您正在抓取许多页面，应该确保在每个请求之间等待一会儿。一个简单的方法是使用[Dmytro
    Perepolkin的polite包](https://oreil.ly/rlujg)，它将自动在请求之间暂停，并缓存结果，以便您不会重复请求同一页面。
- en: Terms of Service
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务条款
- en: If you look closely, you’ll find many websites include a “terms and conditions”
    or “terms of service” link somewhere on the page, and if you read that page closely,
    you’ll often discover that the site specifically prohibits web scraping. These
    pages tend to be a legal land grab where companies make very broad claims. It’s
    polite to respect these terms of service where possible, but take any claims with
    a grain of salt.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细查看，会发现许多网站在页面的某个位置包含“条款和条件”或“服务条款”的链接，如果您仔细阅读该页面，您通常会发现该网站明确禁止网络抓取。这些页面往往是公司做出非常广泛声明的法律攫取。在可能的情况下，遵守这些服务条款是一种礼貌，但要对任何主张保持怀疑态度。
- en: US courts have generally found that simply putting the terms of service in the
    footer of the website isn’t sufficient for you to be bound by them, e.g., [*HiQ
    Labs v. LinkedIn*](https://oreil.ly/mDAin). Generally, to be bound to the terms
    of service, you must have taken some explicit action such as creating an account
    or checking a box. This is why whether or not the data is *public* is important;
    if you don’t need an account to access them, it is unlikely that you are bound
    to the terms of service. Note, however, the situation is rather different in Europe
    where courts have found that terms of service are enforceable even if you don’t
    explicitly agree to them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 美国法院通常认为，仅仅将服务条款放在网站页脚中是不足以使您受其约束的，例如，[*HiQ Labs v. LinkedIn*](https://oreil.ly/mDAin)案件。一般来说，要受到服务条款的约束，您必须采取一些明确的行动，比如创建账户或勾选一个框框。这就是为什么数据是否*公开*如此重要；如果您无需账户即可访问它们，那么您很可能不受服务条款的约束。但请注意，在欧洲情况大不相同，法院认为即使您没有明确同意，服务条款也是可以强制执行的。
- en: Personally Identifiable Information
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人可识别信息
- en: Even if the data is public, you should be extremely careful about scraping personally
    identifiable information such as names, email addresses, phone numbers, dates
    of birth, etc. Europe has particularly strict laws about the collection of storage
    of such data ([GDPR](https://oreil.ly/nzJwO)), and regardless of where you live,
    you’re likely to be entering an ethical quagmire. For example, in 2016, a group
    of researchers scraped public profile information (e.g., username, age, gender,
    location, etc.) about 70,000 people on the dating site OkCupid and publicly released
    these data without any attempts for anonymization. While the researchers felt
    that there was nothing wrong with this since the data were already public, this
    work was widely condemned due to ethics concerns around identifiability of users
    whose information was released in the dataset. If your work involves scraping
    personally identifiable information, we strongly recommend reading about the OkCupid
    study^([3](ch24.xhtml#idm44771274018592)) as well as similar studies with questionable
    research ethics involving the acquisition and release of personally identifiable
    information.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 即使数据是公开的，您也应该非常小心地收集个人可识别信息，如姓名、电子邮件地址、电话号码、出生日期等。欧洲对此类数据的收集和存储有着特别严格的法律（[GDPR](https://oreil.ly/nzJwO)），而不论您身处何地，您都可能陷入伦理泥潭。例如，在2016年，一组研究人员从约7万名OkCupid约会网站用户的公开资料（例如用户名、年龄、性别、位置等）中收集了数据，并公开发布，而且并未尝试匿名化这些数据。虽然研究人员认为这没有什么问题，因为这些数据已经是公开的，但由于涉及用户可识别性的伦理问题，这项工作遭到了广泛谴责。如果您的工作涉及收集个人可识别信息，我们强烈建议您阅读关于OkCupid研究^([3](ch24.xhtml#idm44771274018592))以及涉及获取和发布个人可识别信息的类似研究，这些研究在研究伦理方面存在争议。
- en: Copyright
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版权
- en: 'Finally, you also need to worry about copyright law. Copyright law is complicated,
    but it’s worth taking a look at the [US law](https://oreil.ly/OqUgO), which describes
    exactly what’s protected: “[…] original works of authorship fixed in any tangible
    medium of expression, […].” It then goes on to describe specific categories that
    it applies to such as literary works, musical works, motion pictures, and more.
    Notably absent from copyright protection are data. This means that as long as
    you limit your scraping to facts, copyright protection does not apply. (But note
    that Europe has a separate [“sui generis” right](https://oreil.ly/0ewJe) that
    protects databases.)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还需要担心版权法。版权法很复杂，但值得看一看的是美国法律（https://oreil.ly/OqUgO），它明确了什么受到保护：“[…]以任何有形表现形式固定的原创作品，[…]”，然后进一步描述了适用于此类作品的具体类别，如文学作品、音乐作品、电影等。版权保护不包括的显著缺失的是数据。这意味着只要您将抓取限制在事实上，版权保护就不适用。（但请注意，欧洲有一个独立的[“独创性”权利](https://oreil.ly/0ewJe)，用于保护数据库。）
- en: As a brief example, in the US, lists of ingredients and instructions are not
    copyrightable, so copyright cannot be used to protect a recipe. But if that list
    of recipes is accompanied by substantial novel literary content, that is copyrightable.
    This is why when you’re looking for a recipe on the internet, there’s always so
    much content beforehand.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 举个简单的例子，在美国，成分列表和说明书不受版权保护，因此版权不能用于保护食谱。但如果该食谱列表伴随着大量独特的文学内容，那就是受版权保护的。这就是为什么当您在互联网上寻找食谱时，总是会有这么多内容出现的原因。
- en: If you do need to scrape original content (like text or images), you may still
    be protected under the [doctrine of fair use](https://oreil.ly/oFh0-). Fair use
    is not a hard and fast rule but weighs up a number of factors. It’s more likely
    to apply if you are collecting the data for research or noncommercial purposes
    and if you limit what you scrape to just what you need.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实需要抓取原始内容（如文本或图像），您可能仍然受到[公平使用原则](https://oreil.ly/oFh0-)的保护。公平使用不是一个严格的规则，而是权衡多个因素。如果您是为研究或非商业目的收集数据，并且限制您抓取的内容仅限于您所需的内容，那么公平使用更有可能适用。
- en: HTML Basics
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML 基础知识
- en: 'To scrape web pages, you need to first understand a little bit about *HTML*,
    the language that describes web pages. HTML stands for HyperText Markup Language
    and looks something like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要抓取网页，您首先需要了解一些关于 *HTML* 的知识，这是描述网页的语言。HTML 代表超文本标记语言，看起来像这样：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: HTML has a hierarchical structure formed by *elements*, which consist of a start
    tag (e.g., `<tag>`), optional *attributes* (`id='first'`), an end tag^([4](ch24.xhtml#idm44771273952560))
    (like `</tag>`), and *contents* (everything in between the start and end tags).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 由 *元素* 组成的分层结构，包括开始标签（例如 `<tag>`），可选的 *属性*（`id='first'`），结束标签^([4](ch24.xhtml#idm44771273952560))（如
    `</tag>`）和 *内容*（开始和结束标签之间的所有内容）。
- en: Since `<` and `>` are used for start and end tags, you can’t write them directly.
    Instead, you have to use the HTML *escapes* `&gt;` (greater than) and `&lt;` (less
    than). And since those escapes use `&`, if you want a literal ampersand, you have
    to escape it as `&amp;`. There are a wide range of possible HTML escapes, but
    you don’t need to worry about them too much because rvest automatically handles
    them for you.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `<` 和 `>` 用于开始和结束标签，您不能直接写入它们。相反，您必须使用 HTML *转义* `&gt;`（大于）和 `&lt;`（小于）。而且，由于这些转义使用
    `&`，如果您需要一个字面上的和符号 `&`，您必须将其转义为 `&amp;`。有各种可能的 HTML 转义，但您不需要过多担心，因为 rvest 会自动处理它们。
- en: Web scraping is possible because most pages that contain data that you want
    to scrape generally have a consistent structure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Web 抓取是可能的，因为大多数包含您想要抓取数据的页面通常具有一致的结构。
- en: Elements
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素
- en: 'There are more than 100 HTML elements. Some of the most important are:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 元素超过 100 种。其中一些最重要的包括：
- en: 'Every HTML page must be in an `<html>` element, and it must have two children:
    `<head>`, which contains document metadata like the page title, and `<body>`,
    which contains the content you see in the browser.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 HTML 页面必须位于 `<html>` 元素中，并且必须有两个子元素：`<head>`，其中包含文档元数据，如页面标题，以及 `<body>`，其中包含在浏览器中看到的内容。
- en: Block tags like `<h1>` (heading 1), `<section>` (section), `<p>` (paragraph),
    and `<ol>` (ordered list) form the overall structure of the page.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块标签如 `<h1>`（标题 1），`<section>`（章节），`<p>`（段落）和 `<ol>`（有序列表）构成页面的整体结构。
- en: Inline tags like `<b>` (bold), `<i>` (italics), and `<a>` (link) format text
    inside block tags.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联标签如 `<b>`（粗体），`<i>`（斜体）和 `<a>`（链接）会在块标签内部格式化文本。
- en: If you encounter a tag that you’ve never seen before, you can find out what
    it does with a little googling. Another good place to start is the [MDN Web Docs](https://oreil.ly/qIgHp),
    which describe just about every aspect of web programming.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到一个以前从未见过的标签，您可以通过一点搜索找出它的用途。另一个很好的起点是 [MDN Web 文档](https://oreil.ly/qIgHp)，该文档描述了网页编程的几乎所有方面。
- en: 'Most elements can have content in between their start and end tags. This content
    can be either text or more elements. For example, the following HTML contains
    a paragraph of text, with one word in bold:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数元素可以在它们的开始和结束标签之间有内容。此内容可以是文本或更多元素。例如，以下 HTML 包含了一个文本段落，其中有一个词是粗体的：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The *children* are the elements it contains, so the previous `<p>` element has
    one child, the `<b>` element. The `<b>` element has no children, but it does have
    contents (the text “name”).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*子元素* 是它包含的元素，因此前面的 `<p>` 元素有一个子元素，即 `<b>` 元素。`<b>` 元素没有子元素，但它确实有内容（文本“name”）。'
- en: Attributes
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: Tags can have named *attributes*, which look like `name1='value1' name2='value2'`.
    Two of the most important attributes are `id` and `class`, which are used in conjunction
    with Cascading Style Sheets (CSS) to control the visual appearance of the page.
    These are often useful when scraping data off a page. Attributes are also used
    to record the destination of links (the `href` attribute of `<a>` elements) and
    the source of images (the `src` attribute of the `<img>` element).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 标签可以有命名的*属性*，看起来像`name1='value1' name2='value2'`。其中两个最重要的属性是`id`和`class`，它们与层叠样式表（CSS）结合使用来控制页面的视觉外观。在从页面抓取数据时，这些属性通常很有用。属性还用于记录链接的目标（`<a>`元素的`href`属性）和图像的源（`<img>`元素的`src`属性）。
- en: Extracting Data
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取数据
- en: 'To get started scraping, you’ll need the URL of the page you want to scrape,
    which you can usually copy from your web browser. You’ll then need to read the
    HTML for that page into R with [`read_html()`](http://xml2.r-lib.org/reference/read_xml.xhtml).
    This returns an `xml_document`^([5](ch24.xhtml#idm44771273871552)) object, which
    you’ll then manipulate using rvest functions:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始抓取数据，你需要页面的URL，通常可以从浏览器中复制。然后你需要使用[`read_html()`](http://xml2.r-lib.org/reference/read_xml.xhtml)将该页面的HTML读入R。这将返回一个`xml_document`^([5](ch24.xhtml#idm44771273871552))对象，然后你可以使用rvest函数对其进行操作：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: rvest also includes a function that lets you write HTML inline. We’ll use this
    a bunch in this chapter as we teach how the various rvest functions work with
    simple examples.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: rvest还包括一个允许你在行内编写HTML的函数。在本章中，我们将使用这个函数来演示各种rvest函数如何与简单示例配合使用。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that you have the HTML in R, it’s time to extract the data of interest.
    You’ll first learn about the CSS selectors that allow you to identify the elements
    of interest and the rvest functions that you can use to extract data from them.
    Then we’ll briefly cover HTML tables, which have some special tools.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在R中有了HTML，是时候提取感兴趣的数据了。你首先会学习到CSS选择器，它们允许你识别感兴趣的元素以及可以用来从中提取数据的rvest函数。然后我们简要介绍一下HTML表格，它们有一些特殊工具。
- en: Find Elements
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找元素
- en: CSS is a tool for defining the visual styling of HTML documents. CSS includes
    a miniature language for selecting elements on a page called *CSS selectors*.
    CSS selectors define patterns for locating HTML elements and are useful for scraping
    because they provide a concise way of describing which elements you want to extract.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: CSS是用于定义HTML文档视觉样式的工具。CSS包括一种用于选择页面上元素的迷你语言，称为*CSS选择器*。CSS选择器定义了定位HTML元素的模式，对于抓取数据很有用，因为它们提供了一种简洁的描述想要提取哪些元素的方式。
- en: 'We’ll come back to CSS selectors in more detail in [“Finding the Right Selectors”](#sec-css-selectors),
    but luckily you can get a long way with just three:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[“找到正确的选择器”](#sec-css-selectors)中更详细地讨论CSS选择器，但幸运的是，你可以只用三种就能走得很远：
- en: '`p`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`p`'
- en: Selects all `<p>` elements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有`<p>`元素。
- en: '`.title`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`.title`'
- en: Selects all elements with `class` “title.”
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有`class`为“title”的元素。
- en: '`#title`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`#title`'
- en: Selects the element with the `id` attribute that equals “title.” `id` attributes
    must be unique within a document, so this will only ever select a single element.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 选择具有`id`属性等于“title”的元素。`id`属性在文档内必须是唯一的，因此这将仅选择单个元素。
- en: 'Let’s try these selectors with a simple example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来尝试这些选择器：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Use [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    to find all elements that match the selector:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)来查找所有匹配该选择器的元素：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another important function is [`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml),
    which always returns the same number of outputs as inputs. If you apply it to
    a whole document, it’ll give you the first match:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的函数是[`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml)，它始终返回与输入相同数量的输出。如果将其应用于整个文档，它将给出第一个匹配项：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There’s an important difference between [`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    and [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    when you use a selector that doesn’t match any elements. [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    returns a vector of length 0, where [`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    returns a missing value. This will be important shortly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用一个不匹配任何元素的选择器时，[`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    和 [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    之间有一个重要的区别。[`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    返回长度为 0 的向量，而 [`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    返回一个缺失值。这很快就会变得重要。
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Nesting Selections
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套选择
- en: 'In most cases, you’ll use [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    and [`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    together, typically using [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    to identify elements that will become observations and then using [`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    to find elements that will become variables. Let’s see this in action using a
    simple example. Here we have an unordered list (`<ul>)` where each list item (`<li>`)
    contains some information about four characters from *Star Wars*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您将一起使用 [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    和 [`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml)，通常使用
    [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    标识将成为观察值的元素，然后使用 [`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    查找将成为变量的元素。让我们通过一个简单的例子来看看这一点。这里我们有一个无序列表（`<ul>`），其中每个列表项（`<li>`）包含一些关于四个 *Star
    Wars* 角色的信息：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can use [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    to make a vector where each element corresponds to a different character:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    创建一个向量，其中每个元素对应不同的字符：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To extract the name of each character, we use [`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml),
    because when applied to the output of [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml),
    it’s guaranteed to return one response per element:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取每个角色的名称，我们使用 [`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml)，因为当应用于
    [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    的输出时，它保证每个元素都会返回一个响应：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The distinction between [`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    and [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    isn’t important for the name, but it is important for the weight. We want to get
    one weight for each character, even if there’s no weight `<span>`. That’s what
    [`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml) does:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于名称来说，[`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    和 [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    的区别并不重要，但对于权重来说很重要。我们希望每个角色都有一个权重，即使没有权重 `<span>`。这就是 [`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    的作用：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    finds all weight `<span>`s that are children of `characters`. There’s only three
    of these, so we lose the connection between names and weights:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    查找 `characters` 的所有权重 `<span>`，只有三个，因此我们失去了名称与权重之间的连接：'
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that you’ve selected the elements of interest, you’ll need to extract the
    data, either from the text contents or from some attributes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经选择了感兴趣的元素，需要从文本内容或某些属性中提取数据。
- en: Text and Attributes
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本和属性
- en: '[`html_text2()`](https://rvest.tidyverse.org/reference/html_text.xhtml)^([6](ch24.xhtml#idm44771273417888))
    extracts the plain-text contents of an HTML element:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[`html_text2()`](https://rvest.tidyverse.org/reference/html_text.xhtml)^([6](ch24.xhtml#idm44771273417888))
    提取 HTML 元素的纯文本内容：'
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that any escapes will be automatically handled; you’ll only ever see HTML
    escapes in the source HTML, not in the data returned by rvest.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任何转义都将自动处理；您只会在源 HTML 中看到 HTML 转义，而不会在 rvest 返回的数据中看到。
- en: '[`html_attr()`](https://rvest.tidyverse.org/reference/html_attr.xhtml) extracts
    data from attributes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[`html_attr()`](https://rvest.tidyverse.org/reference/html_attr.xhtml) 提取属性中的数据：'
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[`html_attr()`](https://rvest.tidyverse.org/reference/html_attr.xhtml) always
    returns a string, so if you’re extracting numbers or dates, you’ll need to do
    some post-processing.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[`html_attr()`](https://rvest.tidyverse.org/reference/html_attr.xhtml)总是返回一个字符串，所以如果你要提取数字或日期，你需要进行一些后处理。'
- en: Tables
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表格
- en: 'If you’re lucky, your data will be already stored in an HTML table, and it’ll
    be a matter of just reading it from that table. It’s usually straightforward to
    recognize a table in your browser: it’ll have a rectangular structure of rows
    and columns, and you can copy and paste it into a tool like Excel.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你很幸运，你的数据可能已经存储在一个HTML表中，那么读取数据只是从那个表中读取就可以了。通常在浏览器中很容易识别表格：它通常具有行和列的矩形结构，你可以复制粘贴到像Excel这样的工具中。
- en: 'HTML tables are built up from four main elements: `<table>`, `<tr>` (table
    row), `<th>` (table heading), and `<td>` (table data). Here’s a simple HTML table
    with two columns and three rows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: HTML表格由四个主要元素构成：`<table>`、`<tr>`（表行）、`<th>`（表头）和`<td>`（表格数据）。以下是一个简单的HTML表格，有两列和三行：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'rvest provides a function that knows how to read this sort of data: [`html_table()`](https://rvest.tidyverse.org/reference/html_table.xhtml).
    It returns a list containing one tibble for each table found on the page. Use
    [`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml) to
    identify the table you want to extract:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: rvest提供了一个函数，它知道如何读取这种类型的数据：[`html_table()`](https://rvest.tidyverse.org/reference/html_table.xhtml)。它返回一个列表，包含页面上找到的每个表的tibble。使用[`html_element()`](https://rvest.tidyverse.org/reference/html_element.xhtml)来识别你想要提取的表：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that `x` and `y` have automatically been converted to numbers. This automatic
    conversion doesn’t always work, so in more complex scenarios you may want to turn
    it off with `convert = FALSE` and then do your own conversion.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`x`和`y`已经自动转换为数字。这种自动转换并不总是有效，因此在更复杂的情况下，你可能希望使用`convert = FALSE`来关闭它，然后自己进行转换。
- en: Finding the Right Selectors
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找正确的选择器
- en: 'Figuring out the selector you need for your data is typically the hardest part
    of the problem. You’ll often need to do some experimenting to find a selector
    that is both specific (i.e., it doesn’t select things you don’t care about) and
    sensitive (i.e., it does select everything you care about). Lots of trial and
    error is a normal part of the process! Two main tools are available to help you
    with this process: SelectorGadget and your browser’s developer tools.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 弄清楚你需要的数据选择器通常是问题中最难的部分。你通常需要进行一些实验来找到既具体（即不选择你不关心的事物）又敏感（即选择你关心的一切）的选择器。大量的试验和错误是这个过程中的正常部分！有两个主要工具可以帮助你解决这个问题：SelectorGadget和你浏览器的开发者工具。
- en: '[SelectorGadget](https://oreil.ly/qui0z) is a JavaScript bookmarklet that automatically
    generates CSS selectors based on the positive and negative examples that you provide.
    It doesn’t always work, but when it does, it’s magic! You can learn how to install
    and use SelectorGadget either by reading the [vignette](https://oreil.ly/qui0z)
    or by watching [Mine’s video](https://oreil.ly/qNv6l).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[SelectorGadget](https://oreil.ly/qui0z)是一个JavaScript书签工具，它根据你提供的正负例自动生成CSS选择器。它并不总是有效，但当有效时，它就像魔术一样！你可以通过阅读[用户指南](https://oreil.ly/qui0z)或观看[我的视频](https://oreil.ly/qNv6l)来学习如何安装和使用SelectorGadget。'
- en: 'Every modern browser comes with some toolkit for developers, but we recommend
    Chrome, even if it isn’t your regular browser: its web developer tools are some
    of the best, and they’re immediately available. Right-click an element on the
    page and click Inspect. This will open an expandable view of the complete HTML
    page, centered on the element that you just clicked. You can use this to explore
    the page and get a sense of what selectors might work. Pay particular attention
    to the `class` and `id` attributes, since these are often used to form the visual
    structure of the page and hence make for good tools to extract the data that you’re
    looking for.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每个现代浏览器都带有一些开发工具包，但我们推荐使用Chrome，即使它不是你常用的浏览器：它的Web开发者工具是最好的，而且它们立即可用。右键单击页面上的一个元素，然后选择检查。这将打开一个可展开的视图，显示完整的HTML页面，以所点击的元素为中心。你可以使用这个工具来探索页面，了解哪些选择器可能有效。特别注意`class`和`id`属性，因为它们通常用于形成页面的视觉结构，从而为提取你寻找的数据提供良好的工具。
- en: Inside the Elements view, you can also right-click an element and choose Copy
    as Selector to generate a selector that will uniquely identify the element of
    interest.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Elements视图中，你还可以右键单击一个元素，选择Copy as Selector来生成一个可以唯一标识感兴趣元素的选择器。
- en: If either SelectorGadget or Chrome DevTools has generated a CSS selector that
    you don’t understand, try [Selectors Explained](https://oreil.ly/eD6eC), which
    translates CSS selectors into plain English. If you find yourself doing this a
    lot, you might want to learn more about CSS selectors generally. We recommend
    starting with the fun [CSS dinner](https://oreil.ly/McJtu) tutorial and then referring
    to the [MDN web docs](https://oreil.ly/mpfMF).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 SelectorGadget 或 Chrome DevTools 生成了你不理解的 CSS 选择器，请尝试 [Selectors Explained](https://oreil.ly/eD6eC)，该网站将
    CSS 选择器翻译为简单的英语。如果你经常需要这样做，可能需要更多地了解 CSS 选择器的知识。我们建议从有趣的 [CSS dinner](https://oreil.ly/McJtu)
    教程开始，然后参考 [MDN web docs](https://oreil.ly/mpfMF)。
- en: Putting It All Together
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容汇总起来
- en: Let’s put this all together to scrape some websites. There’s some risk that
    these examples may no longer work when you run them—that’s the fundamental challenge
    of web scraping; if the structure of the site changes, then you’ll have to change
    your scraping code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这些内容整合起来，爬取一些网站。这些示例在你运行时可能不再起作用，这是网络爬取的基本挑战；如果网站的结构发生变化，你将不得不改变你的爬取代码。
- en: Star Wars
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 星球大战
- en: rvest includes a very simple example in [`vignette("starwars")`](https://rvest.tidyverse.org/articles/starwars.xhtml).
    This is a simple page with minimal HTML, so it’s a good place to start. We encourage
    you to navigate to that page now and use Inspect Element to inspect one of the
    headings that’s the title of a *Star Wars* movie. Use the keyboard or mouse to
    explore the hierarchy of the HTML and see if you can get a sense of the shared
    structure used by each movie.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: rvest 在 [`vignette("starwars")`](https://rvest.tidyverse.org/articles/starwars.xhtml)
    中包含了一个非常简单的例子。这是一个具有最少 HTML 的简单页面，非常适合入门。我们鼓励你现在转到该页面，使用检查元素工具检查一个 *Star Wars*
    电影的标题，使用键盘或鼠标探索 HTML 的层次结构，看看能否理解每部电影所使用的共享结构。
- en: 'You should be able to see that each movie has a shared structure that looks
    like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到，每部电影都有一个共享的结构，看起来像这样：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our goal is to turn this data into a seven-row data frame with the variables
    `title`, `year`, `director`, and `intro`. We’ll start by reading the HTML and
    extracting all the `<section>` elements:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将这些数据转换为一个包含 `title`、`year`、`director` 和 `intro` 变量的七行数据框架。我们将从读取 HTML
    并提取所有 `<section>` 元素开始：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This retrieves seven elements matching the seven movies found on that page,
    suggesting that using `section` as a selector is good. Extracting the individual
    elements is straightforward since the data is always found in the text. It’s just
    a matter of finding the right selector:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检索出与该页面上找到的七部电影相匹配的七个元素，表明使用 `section` 作为选择器是很好的。提取单个元素非常简单，因为数据总是在文本中。只需找到正确的选择器即可：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once we’ve done that for each component, we can wrap up all the results into
    a tibble:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对每个组件都做完这些操作，我们可以将所有结果汇总到一个 tibble 中：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We did a little more processing of `released` to get a variable that will be
    easy to use later in our analysis.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `released` 做了更多处理，以获得一个稍后在分析中易于使用的变量。
- en: IMDb Top Films
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IMDb Top Films
- en: For our next task we’ll tackle something a little trickier, extracting the top
    250 movies from IMDb. At the time we wrote this chapter, the page looked like
    [Figure 24-1](#fig-scraping-imdb).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个任务，我们将处理一些更复杂的事情，从 IMDb 提取前 250 部电影。在我们撰写本章时，该页面看起来像 [Figure 24-1](#fig-scraping-imdb)。
- en: '![The screenshot shows a table with columns "Rank and Title", "IMDb Rating",
    and "Your Rating". 9 movies out of the top 250 are shown. The top 5 are the Shawshank
    Redemption, The Godfather, The Dark Knight, The Godfather: Part II, and 12 Angry
    Men.](assets/rds2_2401.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![这张截图显示了一个带有“排名与标题”、“IMDb 评分”和“你的评分”列的表格。排名前 250 名的 9 部电影显示在上面。前五名是“肖申克的救赎”、“教父”、“黑暗骑士”、“教父续集”和“十二怒汉”。](assets/rds2_2401.png)'
- en: Figure 24-1\. IMDb top movies web page taken on 2022-12-05.
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 24-1\. 2022-12-05 拍摄的 IMDb 最佳电影网页。
- en: 'This data has a clear tabular structure, so it’s worth starting with [`html_table()`](https://rvest.tidyverse.org/reference/html_table.xhtml):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据具有明确的表格结构，因此值得从 [`html_table()`](https://rvest.tidyverse.org/reference/html_table.xhtml)
    开始：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This includes a few empty columns but overall does a good job of capturing the
    information from the table. However, we need to do some more processing to make
    it easier to use. First, we’ll rename the columns to be easier to work with and
    remove the extraneous whitespace in rank and title. We will do this with [`select()`](https://dplyr.tidyverse.org/reference/select.xhtml)
    (instead of [`rename()`](https://dplyr.tidyverse.org/reference/rename.xhtml))
    to do the renaming and selecting of just these two columns in one step. Then we’ll
    remove the new lines and extra spaces and then apply [`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)
    (from [“Extract Variables”](ch15.xhtml#sec-extract-variables)) to pull out the
    title, year, and rank into their own variables.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括一些空列，但总体上可以很好地捕捉表格中的信息。然而，我们需要做一些额外的处理以使其更易于使用。首先，我们将使用 [`select()`](https://dplyr.tidyverse.org/reference/select.xhtml)（而不是
    [`rename()`](https://dplyr.tidyverse.org/reference/rename.xhtml)）重命名列名，并在一个步骤中选择这两列。然后，我们将删除换行符和额外的空格，并应用
    [`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)（来自
    [“提取变量”](ch15.xhtml#sec-extract-variables)）将标题、年份和排名分离为它们自己的变量。
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Even in this case where most of the data comes from table cells, it’s still
    worth looking at the raw HTML. If you do so, you’ll discover that we can add a
    little extra data by using one of the attributes. This is one of the reasons it’s
    worth spending a little time spelunking the source of the page; you might find
    extra data or a parsing route that’s slightly easier.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在大部分数据来自表格单元的情况下，查看原始 HTML 仍然是值得的。如果您这样做，您将发现我们可以通过使用其中的一个属性添加一些额外的数据。这是值得花一点时间来探索页面源代码的原因之一；您可能会发现额外的数据或稍微更容易的解析路径。
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can combine this with the tabular data and again apply [`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)
    to extract the bit of data we care about:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这与表格数据结合起来，并再次应用 [`separate_wider_regex()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)
    来提取我们关心的数据片段：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Dynamic Sites
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态网站
- en: So far we focused on websites where [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    returns what you see in the browser and discussed how to parse what it returns
    and how to organize that information in tidy data frames. From time to time, however,
    you’ll hit a site where [`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    and friends don’t return anything like what you see in the browser. In many cases,
    that’s because you’re trying to scrape a website that dynamically generates the
    content of the page with JavaScript. This doesn’t currently work with rvest, because
    rvest downloads the raw HTML and doesn’t run any JavaScript.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们专注于网站，[`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    返回您在浏览器中看到的内容，并讨论了如何解析它返回的内容，以及如何在整洁的数据框中组织这些信息。然而，偶尔会遇到一个网站，[`html_elements()`](https://rvest.tidyverse.org/reference/html_element.xhtml)
    和相关方法返回的内容与浏览器中看到的内容差异很大。在许多情况下，这是因为您试图抓取的网站使用 JavaScript 动态生成页面内容。目前 rvest 无法处理这种情况，因为
    rvest 只下载原始 HTML，不执行任何 JavaScript。
- en: 'It’s still possible to scrape these types of sites, but rvest needs to use
    a more expensive process: fully simulating the web browser including running all
    JavaScript. This functionality is not available at the time of writing, but it’s
    something we’re actively working on and might be available by the time you read
    this. It uses the [chromote package](https://oreil.ly/xaHTf), which actually runs
    the Chrome browser in the background, and gives you additional tools to interact
    with the site, like a human typing text and clicking buttons. Check out the [rvest
    website](https://oreil.ly/YoxV7) for more details.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 网站的这些类型仍然可以进行抓取，但 rvest 需要使用一种更昂贵的过程：完全模拟包括运行所有 JavaScript 在内的 Web 浏览器。在撰写本文时，这个功能尚不可用，但我们正在积极开发中，并可能在您阅读此文时提供。它使用了
    [chromote 软件包](https://oreil.ly/xaHTf)，实际上在后台运行 Chrome 浏览器，并提供额外的工具与网站进行交互，如人类输入文本和点击按钮。请查看
    [rvest 网站](https://oreil.ly/YoxV7) 获取更多详细信息。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned about the why, the why not, and the how of scraping
    data from web pages. First, you learned about the basics of HTML and using CSS
    selectors to refer to specific elements, and then you learned about using the
    rvest package to get data out of HTML into R. We then demonstrated web scraping
    with two case studies: a simpler scenario on scraping data on *Star Wars* films
    from the rvest package website and a more complex scenario on scraping the top
    250 films from IMDb.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了从网页中抓取数据的原因、不适合的情况以及如何操作。首先，你了解了 HTML 的基础知识以及使用 CSS 选择器引用特定元素，然后学习了如何使用
    rvest 包将数据从 HTML 中提取到 R。接着，我们通过两个案例研究演示了网页抓取：一个是从 rvest 包网站抓取 *星球大战* 电影数据的简单情况，另一个是从
    IMDb 抓取前 250 部电影数据的复杂情况。
- en: Technical details of scraping data off the web can be complex, particularly
    when dealing with sites; however, legal and ethical considerations can be even
    more complex. It’s important for you to educate yourself about both of these before
    setting out to scrape data.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从网页上抓取数据的技术细节可能很复杂，特别是处理网站时；然而，法律和道德考虑可能更加复杂。在开始抓取数据之前，了解这两者非常重要。
- en: 'This brings us to the end of the import part of the book where you’ve learned
    techniques to get data from where it lives (spreadsheets, databases, JSON files,
    and websites) into a tidy form in R. Now it’s time to turn our sights to a new
    topic: making the most of R as a programming language.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们来到了书中关于从数据源（电子表格、数据库、JSON 文件和网站）中获取数据并在 R 中整理成整洁形式的重要部分的结束。现在是时候把目光转向一个新话题了：充分利用
    R 作为一种编程语言。
- en: ^([1](ch24.xhtml#idm44771274112496-marker)) Many popular APIs already have CRAN
    packages that wrap them, so start with a little research first!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch24.xhtml#idm44771274112496-marker)) 许多流行的 API 已经有 CRAN 包装，因此首先进行一些研究！
- en: ^([2](ch24.xhtml#idm44771274043040-marker)) Obviously we’re not lawyers, and
    this is not legal advice. But this is the best summary we can give having read
    a bunch about this topic.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch24.xhtml#idm44771274043040-marker)) 显然我们不是律师，这也不是法律建议。但这是我们在这个话题上读了很多后能给出的最好总结。
- en: ^([3](ch24.xhtml#idm44771274018592-marker)) One example of an article on the
    OkCupid study was published by [Wired](https://oreil.ly/rzd7z).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch24.xhtml#idm44771274018592-marker)) OkCupid 研究的一篇文章例子由 [Wired](https://oreil.ly/rzd7z)
    发表。
- en: ^([4](ch24.xhtml#idm44771273952560-marker)) A number of tags (including `<p>`
    and `<li>)` don’t require end tags, but we think it’s best to include them because
    it makes seeing the structure of the HTML a little easier.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch24.xhtml#idm44771273952560-marker)) 一些标签（包括 `<p>` 和 `<li>`）不需要结束标签，但我们认为最好包括它们，因为这样可以更容易地看到
    HTML 的结构。
- en: ^([5](ch24.xhtml#idm44771273871552-marker)) This class comes from the [xml2
    package](https://oreil.ly/lQNBa). xml2 is a low-level package that rvest builds
    on top of.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch24.xhtml#idm44771273871552-marker)) 这个类来自于 [xml2 包](https://oreil.ly/lQNBa)。xml2
    是一个 rvest 基于其上构建的低级包。
- en: ^([6](ch24.xhtml#idm44771273417888-marker)) rvest also provides [`html_text()`](https://rvest.tidyverse.org/reference/html_text.xhtml),
    but you should almost always use [`html_text2()`](https://rvest.tidyverse.org/reference/html_text.xhtml)
    since it does a better job of converting nested HTML to text.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch24.xhtml#idm44771273417888-marker)) rvest 还提供了 [`html_text()`](https://rvest.tidyverse.org/reference/html_text.xhtml)，但你几乎总是应该使用
    [`html_text2()`](https://rvest.tidyverse.org/reference/html_text.xhtml)，因为它更好地将嵌套的
    HTML 转换为文本。
