- en: 'Chapter 3\. Growth Decompositions: Understanding Tailwinds and Headwinds'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章\. 增长分解：理解顺风和逆风
- en: '[Chapter 2](ch02.html#ch02_decom_metrix) described some techniques to find
    better metrics that can drive actions. This chapter deals with a completely different
    subject: how you can decompose metrics to understand *why* a metric changed. In
    corporate jargon these changes are usually associated with *tailwinds* or *headwinds*,
    that is, factors that positively or negatively affect the state of the company.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html#ch02_decom_metrix) 描述了一些技术，以找到能够推动行动的更好指标。本章涉及一个完全不同的主题：如何分解指标以理解指标变化的原因。在公司行话中，这些变化通常与*顺风*或*逆风*有关，即对公司状态产生积极或消极影响的因素。'
- en: Why Growth Decompositions?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要进行增长分解？
- en: Data scientists are frequently asked to help understand the root cause of a
    change in a metric. Why did revenues increase quarter over quarter (QoQ) or month
    over month (MoM)? In my experience, these are very hard questions to answer, not
    only because many things can be happening at the same time, but also because some
    of these underlying causes are not directly measurable or don’t provide enough
    variation to be informative.^([1](ch03.html#id375)) Typical examples are things
    like the state of the economy or the regulatory environment, as well as decisions
    made by competitors.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家经常被要求帮助理解指标变化的根本原因。为什么收入季度同比增长（QoQ）或月同比增长（MoM）？依我的经验，这些问题非常难以回答，不仅因为可能同时发生许多事情，而且因为一些潜在原因并不直接可测量或提供足够的变化来提供信息。^([1](ch03.html#id375))
    典型的例子包括经济状况、监管环境以及竞争对手的决策。
- en: Nonetheless, I’ve found that you can use some other source of variations that,
    when coupled with the following techniques, can give you hints of what’s going
    on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我发现当结合以下技术时，可以利用其他来源的变化来提供一些线索。
- en: Additive Decomposition
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加法分解
- en: As the name suggests, this decomposition is handy when the metric (output) you
    want to understand can be expressed as the sum of other metrics (inputs). In the
    case of two inputs, this can be expressed as <math alttext="y Subscript t Baseline
    equals y Subscript 1 comma t Baseline plus y Subscript 2 comma t"><mrow><msub><mi>y</mi>
    <mi>t</mi></msub> <mo>=</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
    . Note that I’m using a time subscript.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，当你希望理解的指标（输出）可以表示为其他指标（输入）之和时，这种分解方法非常方便。在两个输入的情况下，可以表示为 <math alttext="y
    Subscript t Baseline equals y Subscript 1 comma t Baseline plus y Subscript 2
    comma t"><mrow><msub><mi>y</mi> <mi>t</mi></msub> <mo>=</mo> <msub><mi>y</mi>
    <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub> <mo>+</mo> <msub><mi>y</mi>
    <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math> 。请注意，我使用了时间下标。
- en: 'The decomposition says that the growth of the output from <math alttext="t
    minus 1"><mrow><mi>t</mi> <mo>-</mo> <mn>1</mn></mrow></math> to <math alttext="t"><mi>t</mi></math>
    ( <math alttext="g Subscript y comma t"><msub><mi>g</mi> <mrow><mi>y</mi><mo>,</mo><mi>t</mi></mrow></msub></math>
    ) is the weighted average of the input’s growth rates:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 该分解表示从 <math alttext="t minus 1"><mrow><mi>t</mi> <mo>-</mo> <mn>1</mn></mrow></math>
    到 <math alttext="t"><mi>t</mi></math> 的输出增长（ <math alttext="g Subscript y comma
    t"><msub><mi>g</mi> <mrow><mi>y</mi><mo>,</mo><mi>t</mi></mrow></msub></math>
    ）是输入增长率的加权平均：
- en: <math alttext="g Subscript y comma t Baseline equals omega Subscript 1 comma
    t minus 1 Baseline g Subscript y 1 comma t Baseline plus omega Subscript 2 comma
    t minus 1 Baseline g Subscript y 2 comma t" display="block"><mrow><msub><mi>g</mi>
    <mrow><mi>y</mi><mo>,</mo><mi>t</mi></mrow></msub> <mo>=</mo> <msub><mi>ω</mi>
    <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <msub><mi>g</mi>
    <mrow><msub><mi>y</mi> <mn>1</mn></msub> <mo>,</mo><mi>t</mi></mrow></msub> <mo>+</mo>
    <msub><mi>ω</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <msub><mi>g</mi> <mrow><msub><mi>y</mi> <mn>2</mn></msub> <mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="g Subscript y comma t Baseline equals omega Subscript 1 comma
    t minus 1 Baseline g Subscript y 1 comma t Baseline plus omega Subscript 2 comma
    t minus 1 Baseline g Subscript y 2 comma t" display="block"><mrow><msub><mi>g</mi>
    <mrow><mi>y</mi><mo>,</mo><mi>t</mi></mrow></msub> <mo>=</mo> <msub><mi>ω</mi>
    <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <msub><mi>g</mi>
    <mrow><msub><mi>y</mi> <mn>1</mn></msub> <mo>,</mo><mi>t</mi></mrow></msub> <mo>+</mo>
    <msub><mi>ω</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <msub><mi>g</mi> <mrow><msub><mi>y</mi> <mn>2</mn></msub> <mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
- en: where weights add up to one, <math alttext="omega Subscript 1 comma t minus
    1 Baseline plus omega Subscript 2 comma t minus 1 Baseline equals 1"><mrow><msub><mi>ω</mi>
    <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo>
    <msub><mi>ω</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>=</mo> <mn>1</mn></mrow></math> .
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其中权重总和为一，<math alttext="omega Subscript 1 comma t minus 1 Baseline plus omega
    Subscript 2 comma t minus 1 Baseline equals 1"><mrow><msub><mi>ω</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ω</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>=</mo> <mn>1</mn></mrow></math> 。
- en: Importantly, the weights are the relative importance of each input *in the previous
    period*. So an input that had a larger share in *t-1* will be given more weight.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，权重是每个输入在*上一个周期*中的相对重要性。因此，在*t-1*中占较大份额的输入将被赋予更高的权重。
- en: Example
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: 'The additive setting is quite common in data warehouses where you have fact
    and dimensional tables. I’ve found that a grammar analogy helps distinguish one
    from the other: facts reflect actions or verbs, and dimensions are adverbs that
    describe the action. Fact tables usually store metrics that are relevant to the
    company, and dimensional tables store dimensions that help you understand the
    metrics.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据仓库中，加法设置非常常见，其中包括事实表和维度表。我发现语法类比有助于区分二者：事实反映动作或动词，而维度则是描述动作的副词。事实表通常存储与公司相关的度量标准，而维度表则存储帮助你理解度量标准的维度。
- en: 'Here’s a typical SQL query that generates the dataset needed as input:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成所需数据集的典型SQL查询：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For example, it can be that the metric is customer purchases and you want to
    open this by geographical regions. Since total sales must be the sum of sales
    across regions, this decomposition becomes handy. It will help you understand
    if growth rates in one or several regions are the main drivers for an acceleration
    or deceleration at the national level.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可能的指标是顾客购买量，你想按地理区域展开。由于总销售额必须是各个区域销售额的总和，这种分解方法非常方便。它将帮助你了解某个或多个区域的增长率是否是国家级加速或减速的主要驱动因素。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The sample query highlights how you can easily create an aggregate table that
    splits a metric using *different* dimensions. The process looks like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 示例查询突显了如何轻松创建一个分组表，使用*不同*维度拆分指标。整个过程如下：
- en: Create a pipeline that periodically updates the aggregate table across different
    dimensions.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个定期更新不同维度的聚合表的管道。
- en: Write a script that computes the decomposition for one dimension and outputs
    the results as a table (see the [GitHub repo](https://oreil.ly/dshp-repo)).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个脚本，计算一个维度的分解并将结果输出为表格（参见[GitHub仓库](https://oreil.ly/dshp-repo)）。
- en: Loop over all dimensions with that script.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该脚本循环遍历所有维度。
- en: The end result is a table with all sources of variations.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终结果是一个包含所有变化来源的表格。
- en: At this point, you need your knowledge of the business to identify patterns
    in the changes. This is usually the hardest part and requires extensive knowledge
    of the business.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你需要了解业务知识以识别变化中的模式。这通常是最困难的部分，需要对业务有广泛的了解。
- en: Interpretation and Use Cases
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释和用例
- en: As mentioned, with the additive decomposition, the growth rate in the output
    equals the weighted average of the growth rates in the inputs. Nonetheless, I
    prefer to think of growth contributions by each segment or dimensional value,
    where each contribution is equal to the product of the lagged weight and the corresponding
    growth rate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，通过加法分解，输出的增长率等于输入的增长率的加权平均值。尽管如此，我更倾向于思考每个段或维度值的增长贡献，其中每个贡献等于滞后权重与相应增长率的乘积。
- en: The decomposition is especially useful when you have several dimensions that
    can be used simultaneously and can jointly provide hints about the underlying
    factors.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你同时拥有多个可以同时使用且可以共同提供有关潜在因素提示的维度时，分解特别有用。
- en: Going back to the sales example, you can apply the decomposition using geographical
    regions, socioeconomic status (SES) of the store’s neighborhood, and some type
    of customer segment (e.g., by tenure).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 回到销售例子，你可以应用分解方法使用地理区域、店铺附近的社会经济地位（SES）以及某种类型的顾客分段（例如，按照在职年限）。
- en: 'The conclusion might be something like: national sales decreased 7 percentage
    points (pp) MoM mainly because:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 结论可能类似于：国家销售额月降低了7个百分点（pp），主要原因是：
- en: The Southwest region decelerated 14 pp MoM.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 西南地区月减速率为14个百分点。
- en: Stores in high SES areas decelerated faster.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高SES地区的店铺减速得更快。
- en: Deceleration was relatively uniform across tenures.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减速在各个在职年限中相对均匀。
- en: As warned earlier, notice that you are *not* really finding the root causes;
    at best you have enough hints for what’s driving the change. Is the Southwest
    region economy decelerating? Were there changes in pricing in these stores? What
    is customer satisfaction looking like in high SES customers?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提醒过的，要注意*实际上*并没有找到根本原因；最多只有足够的线索可以解释变化的驱动因素。西南地区经济是否正在减速？这些店铺的定价有变化吗？高SES顾客的客户满意度如何？
- en: '[Figure 3-1](#add_example) shows a waterfall plot of the regional contributions
    for a simulated example. In this case, there was a 4.6% decline at the national
    level, explained mainly by a strong deceleration in the Northwest region (5.8
    pp). Southwest and West regions also decelerated, and the South had a strong quarter.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](#add_example)显示了一个模拟示例的瀑布图，展示了各个地区对国家水平下降的贡献。在这种情况下，主要是由于西北地区的强烈减速（降低了5.8个百分点），导致全国水平下降了4.6%。西南和西部地区也有所减速，而南部则有一个强劲的季度。'
- en: '![additive decomposition](assets/dshp_0301.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![加法分解](assets/dshp_0301.png)'
- en: Figure 3-1\. Regional contributions to growth
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1\. 区域对增长的贡献
- en: Multiplicative Decomposition
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 乘法分解
- en: The *multiplicative decomposition* works when the output metric can be expressed
    as the product of two or more inputs. [Chapter 2](ch02.html#ch02_decom_metrix)
    showed how these arise naturally in many setups, for instance in <math alttext="p
    times q"><mrow><mi>p</mi> <mo>×</mo> <mi>q</mi></mrow></math> cases.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*乘法分解* 在输出指标可以表示为两个或多个输入的乘积时起作用。[第二章](ch02.html#ch02_decom_metrix)展示了这些在许多设置中是如何自然产生的，例如在<math
    alttext="p times q"><mrow><mi>p</mi> <mo>×</mo> <mi>q</mi></mrow></math>情况下。'
- en: 'The decomposition says that whenever <math alttext="y Subscript t Baseline
    equals y Subscript 1 comma t Baseline times y Subscript 2 comma t"><mrow><msub><mi>y</mi>
    <mi>t</mi></msub> <mo>=</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
    , then:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 分解表明，每当<math alttext="y Subscript t Baseline equals y Subscript 1 comma t Baseline
    times y Subscript 2 comma t"><mrow><msub><mi>y</mi> <mi>t</mi></msub> <mo>=</mo>
    <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub> <mo>×</mo>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
    ，那么：
- en: <math alttext="g Subscript y comma t Baseline equals g Subscript 1 comma t Baseline
    plus g Subscript 2 comma t Baseline plus g Subscript 1 comma t Baseline times
    g Subscript 2 comma t" display="block"><mrow><msub><mi>g</mi> <mrow><mi>y</mi><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>=</mo> <msub><mi>g</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <msub><mi>g</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <msub><mi>g</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>×</mo> <msub><mi>g</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="g Subscript y comma t Baseline equals g Subscript 1 comma t Baseline
    plus g Subscript 2 comma t Baseline plus g Subscript 1 comma t Baseline times
    g Subscript 2 comma t" display="block"><mrow><msub><mi>g</mi> <mrow><mi>y</mi><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>=</mo> <msub><mi>g</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <msub><mi>g</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <msub><mi>g</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>×</mo> <msub><mi>g</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
- en: In words, the growth rate in the output is equal to the sum of the growth rates
    *and* a combined effect.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，输出的增长率等于增长率的总和 *和* 一个组合效应。
- en: Example
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: 'Let’s use the revenues decomposition from [Chapter 2](ch02.html#ch02_decom_metrix)
    and see that these are the product of Average Revenue per User (ARPU) and Monthly
    Active Users (MAU):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用来自[第二章](ch02.html#ch02_decom_metrix)的收入分解，看看这些是用户平均收入（ARPU）和月活跃用户（MAU）的乘积：
- en: <math alttext="Revenues equals ARPU times MAU" display="block"><mrow><mtext>Revenues</mtext>
    <mo>=</mo> <mtext>ARPU</mtext> <mo>×</mo> <mtext>MAU</mtext></mrow></math>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Revenues equals ARPU times MAU" display="block"><mrow><mtext>Revenues</mtext>
    <mo>=</mo> <mtext>ARPU</mtext> <mo>×</mo> <mtext>MAU</mtext></mrow></math>
- en: If revenues grew, it could be because ARPU accelerated, MAU increased, or both
    changed in the same direction. More importantly, with the decomposition you can
    actually *quantify* each of these.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收入增长，可能是因为ARPU加速，MAU增加，或者两者都朝着同一个方向变化。更重要的是，通过分解，你实际上可以*量化*每一个。
- en: '[Figure 3-2](#ch3_multiplicative) shows one possible visualization of the decomposition
    for a simulated ARPU example. In this case, the main driver for MoM growth is
    a considerable acceleration in average revenue per user (contributing ~31pp or
    around 96% of the total revenue growth). Notice that the combined effect is very
    small, as it is the product of the growth rates of the inputs. Many times you
    can just drop it, if it really is negligible.^([2](ch03.html#id381))'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-2](#ch3_multiplicative)显示了一个模拟 ARPU 示例的分解可能可视化。在这种情况下，MoM 增长的主要驱动因素是用户平均收入的显著加速（贡献了约31个百分点或大约总收入增长的96%）。请注意，组合效应非常小，因为它是输入增长率的乘积。许多时候，如果确实可以忽略不计，你可以直接去掉它。^([2](ch03.html#id381))'
- en: '![multiplicative decomposition arpu](assets/dshp_0302.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![ARPU 的乘法分解](assets/dshp_0302.png)'
- en: Figure 3-2\. Multiplicative decomposition of ARPU
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. ARPU 的乘法分解
- en: Interpretation
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释
- en: In a multiplicative setting, the growth of the output is the sum of growth in
    inputs plus a combined effect. With more than two inputs, this still holds but
    you need to add the sum of the combined effects.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在乘法设置中，输出的增长是输入增长的总和加上一个组合效应。当有超过两个输入时，这仍然成立，但你需要添加组合效应的总和。
- en: Mix-Rate Decompositions
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合比率分解
- en: '*Mix-rate decompositions* take a bit from each of the additive and multiplicative
    decompositions. Suppose that your output metric is a weighted average of other
    metrics:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*混合比率分解* 从加法和乘法分解中各取一些。假设你的输出指标是其他指标的加权平均：'
- en: <math alttext="y Subscript t Baseline equals sigma-summation Underscript s Endscripts
    w Subscript s comma t Baseline x Subscript s comma t Baseline equals bold w Subscript
    bold t Baseline ModifyingAbove With bold dot bold x Subscript bold t" display="block"><mrow><msub><mi>y</mi>
    <mi>t</mi></msub> <mo>=</mo> <munder><mo>∑</mo> <mi>s</mi></munder> <msub><mi>w</mi>
    <mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub> <msub><mi>x</mi> <mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>=</mo> <msub><mi>𝐰</mi> <mi>𝐭</mi></msub> <mover accent="true"><mo>˙</mo></mover>
    <msub><mi>𝐱</mi> <mi>𝐭</mi></msub></mrow></math>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y Subscript t Baseline equals sigma-summation Underscript s Endscripts
    w Subscript s comma t Baseline x Subscript s comma t Baseline equals bold w Subscript
    bold t Baseline ModifyingAbove With bold dot bold x Subscript bold t" display="block"><mrow><msub><mi>y</mi>
    <mi>t</mi></msub> <mo>=</mo> <munder><mo>∑</mo> <mi>s</mi></munder> <msub><mi>w</mi>
    <mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub> <msub><mi>x</mi> <mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>=</mo> <msub><mi>𝐰</mi> <mi>𝐭</mi></msub> <mover accent="true"><mo>˙</mo></mover>
    <msub><mi>𝐱</mi> <mi>𝐭</mi></msub></mrow></math>
- en: where the last equality is just expressing the sum as a dot or inner product
    of the corresponding vectors (in bold).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最后一个等式只是将总和表达为相应向量的点或内积（粗体表示）。
- en: 'Let me spell out the decomposition and then explain the terms:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我详细说明分解，然后解释这些术语：
- en: <math alttext="normal upper Delta y Subscript t Baseline equals normal upper
    Delta Subscript y Superscript x Baseline plus normal upper Delta Subscript y Superscript
    w Baseline plus normal upper Delta bold w dot bold upper Delta bold x" display="block"><mrow><mi>Δ</mi>
    <msub><mi>y</mi> <mi>t</mi></msub> <mo>=</mo> <msubsup><mi>Δ</mi> <mi>y</mi> <mi>x</mi></msubsup>
    <mo>+</mo> <msubsup><mi>Δ</mi> <mi>y</mi> <mi>w</mi></msubsup> <mo>+</mo> <mi>Δ</mi>
    <mi>𝐰</mi> <mo>·</mo> <mi>Δ</mi> <mi>𝐱</mi></mrow></math>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal upper Delta y Subscript t Baseline equals normal upper
    Delta Subscript y Superscript x Baseline plus normal upper Delta Subscript y Superscript
    w Baseline plus normal upper Delta bold w dot bold upper Delta bold x" display="block"><mrow><mi>Δ</mi>
    <msub><mi>y</mi> <mi>t</mi></msub> <mo>=</mo> <msubsup><mi>Δ</mi> <mi>y</mi> <mi>x</mi></msubsup>
    <mo>+</mo> <msubsup><mi>Δ</mi> <mi>y</mi> <mi>w</mi></msubsup> <mo>+</mo> <mi>Δ</mi>
    <mi>𝐰</mi> <mo>·</mo> <mi>Δ</mi> <mi>𝐱</mi></mrow></math>
- en: 'Where:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: <math alttext="normal upper Delta y Subscript t"><mrow><mi>Δ</mi> <msub><mi>y</mi>
    <mi>t</mi></msub></mrow></math>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal upper Delta y Subscript t"><mrow><mi>Δ</mi> <msub><mi>y</mi>
    <mi>t</mi></msub></mrow></math>
- en: First difference for the output metric. I’ve found that keeping everything as
    differences—instead of growth rates—is usually all that’s needed, and it considerably
    simplifies the notation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出指标的第一差分。我发现保持一切都是差分——而不是增长率——通常就足够了，而且大大简化了符号。
- en: <math alttext="normal upper Delta Subscript y Superscript x"><msubsup><mi>Δ</mi>
    <mi>y</mi> <mi>x</mi></msubsup></math>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal upper Delta Subscript y Superscript x"><msubsup><mi>Δ</mi>
    <mi>y</mi> <mi>x</mi></msubsup></math>
- en: What would the change in the output be if the weights are kept fixed at the
    initial values, and *only* the inputs change? The notation signals that only inputs
    (superscript) are allowed to change the output (subscript).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果权重保持在初始值不变，只有输入改变，输出会发生什么变化？符号表明只允许输入（上标）改变输出（下标）。
- en: <math alttext="normal upper Delta Subscript y Superscript w"><msubsup><mi>Δ</mi>
    <mi>y</mi> <mi>w</mi></msubsup></math>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal upper Delta Subscript y Superscript w"><msubsup><mi>Δ</mi>
    <mi>y</mi> <mi>w</mi></msubsup></math>
- en: What would the change in the output be if the inputs are kept fixed at the initial
    values, and *only* the weights change?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入保持在初始值不变，只有权重改变，输出会发生什么变化？
- en: <math alttext="normal upper Delta bold w dot bold upper Delta bold x"><mrow><mi>Δ</mi>
    <mi>𝐰</mi> <mo>·</mo> <mi>Δ</mi> <mi>𝐱</mi></mrow></math>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal upper Delta bold w dot bold upper Delta bold x"><mrow><mi>Δ</mi>
    <mi>𝐰</mi> <mo>·</mo> <mi>Δ</mi> <mi>𝐱</mi></mrow></math>
- en: This is the inner product of the changes in weights and inputs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是权重和输入变化的内积。
- en: 'When I first started thinking about this decomposition, I started with the
    intuition in the second and third points, which are counterfactual (i.e., you
    can’t observe them) and quite useful for storytelling purposes. The math didn’t
    add up, so I had to go through the derivation. I once presented this to a stakeholder
    and they called it *mix-rate*; it appears that this term was used some time ago,
    but after searching the web I couldn’t find much, so I’m not really sure about
    its origin or usage. The term is good, though, as there are two potential sources
    of change:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始考虑这种分解时，我从第二和第三点的直觉开始，这些点是反事实的（即，你无法观察它们），对于讲故事目的非常有用。数学上讲不通，所以我不得不进行推导。我曾将此展示给利益相关者，他们称其为*mix-rate*；看起来这个术语在一段时间内曾被使用过，但在搜索网络后我没能找到太多相关信息，所以我对其起源或用法并不确定。不过这个术语很合适，因为存在两种潜在的变化来源：
- en: Changes in the weights (mix)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权重（mix）的变化
- en: Changes in the inputs (rates)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入（rate）的变化
- en: Example
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: 'Weighted averages arise everywhere. Think about this: you have one metric and
    customer segments. It’s intuitive to believe that the metric will be a weighted
    average of the metrics for the segments. This is always the case with ratio metrics.
    Let’s try it with the average revenue per user for two segments:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 加权平均数随处可见。想想这个：你有一个度量和客户段。直觉上认为，该度量将是各段度量的加权平均值。对于比率度量，这种情况总是成立。让我们以两个段的每用户平均收入为例来试试：
- en: <math alttext="StartLayout 1st Row 1st Column upper A upper R upper P upper
    U 2nd Column equals 3rd Column StartFraction upper R Over upper M upper A upper
    U EndFraction 2nd Row 1st Column Blank 2nd Column equals 3rd Column StartFraction
    upper R 1 plus upper R 2 Over MAU Subscript 1 Baseline plus MAU Subscript 2 Baseline
    EndFraction 3rd Row 1st Column Blank 2nd Column equals 3rd Column StartFraction
    upper R 1 Over MAU Subscript 1 Baseline EndFraction StartFraction MAU Subscript
    1 Baseline Over MAU Subscript 1 Baseline plus MAU Subscript 2 Baseline EndFraction
    plus StartFraction upper R 2 Over MAU Subscript 2 Baseline EndFraction StartFraction
    MAU Subscript 2 Baseline Over MAU Subscript 1 Baseline plus MAU Subscript 2 Baseline
    EndFraction 4th Row 1st Column Blank 2nd Column equals 3rd Column omega 1 upper
    A upper R upper P upper U 1 plus omega 2 upper A upper R upper P upper U 2 EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mi>R</mi> <mi>P</mi> <mi>U</mi></mrow></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mfrac><mi>R</mi>
    <mrow><mi>M</mi><mi>A</mi><mi>U</mi></mrow></mfrac></mtd></mtr> <mtr><mtd><mo>=</mo></mtd>
    <mtd columnalign="left"><mfrac><mrow><msub><mi>R</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi>
    <mn>2</mn></msub></mrow> <mrow><msub><mtext>MAU</mtext> <mn>1</mn></msub> <mo>+</mo><msub><mtext>MAU</mtext>
    <mn>2</mn></msub></mrow></mfrac></mtd></mtr> <mtr><mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mfrac><msub><mi>R</mi>
    <mn>1</mn></msub> <msub><mtext>MAU</mtext> <mn>1</mn></msub></mfrac> <mfrac><msub><mtext>MAU</mtext>
    <mn>1</mn></msub> <mrow><msub><mtext>MAU</mtext> <mn>1</mn></msub> <mo>+</mo><msub><mtext>MAU</mtext>
    <mn>2</mn></msub></mrow></mfrac> <mo>+</mo> <mfrac><msub><mi>R</mi> <mn>2</mn></msub>
    <msub><mtext>MAU</mtext> <mn>2</mn></msub></mfrac> <mfrac><msub><mtext>MAU</mtext>
    <mn>2</mn></msub> <mrow><msub><mtext>MAU</mtext> <mn>1</mn></msub> <mo>+</mo><msub><mtext>MAU</mtext>
    <mn>2</mn></msub></mrow></mfrac></mrow></mtd></mtr> <mtr><mtd><mo>=</mo></mtd>
    <mtd columnalign="left"><mrow><msub><mi>ω</mi> <mn>1</mn></msub> <mi>A</mi> <mi>R</mi>
    <mi>P</mi> <msub><mi>U</mi> <mn>1</mn></msub> <mo>+</mo> <msub><mi>ω</mi> <mn>2</mn></msub>
    <mi>A</mi> <mi>R</mi> <mi>P</mi> <msub><mi>U</mi> <mn>2</mn></msub></mrow></mtd></mtr></mtable></math>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column upper A upper R upper P upper
    U 2nd Column equals 3rd Column StartFraction upper R Over upper M upper A upper
    U EndFraction 2nd Row 1st Column Blank 2nd Column equals 3rd Column StartFraction
    upper R 1 plus upper R 2 Over MAU Subscript 1 Baseline plus MAU Subscript 2 Baseline
    EndFraction 3rd Row 1st Column Blank 2nd Column equals 3rd Column StartFraction
    upper R 1 Over MAU Subscript 1 Baseline EndFraction StartFraction MAU Subscript
    1 Baseline Over MAU Subscript 1 Baseline plus MAU Subscript 2 Baseline EndFraction
    plus StartFraction upper R 2 Over MAU Subscript 2 Baseline EndFraction StartFraction
    MAU Subscript 2 Baseline Over MAU Subscript 1 Baseline plus MAU Subscript 2 Baseline
    EndFraction 4th Row 1st Column Blank 2nd Column equals 3rd Column omega 1 upper
    A upper R upper P upper U 1 plus omega 2 upper A upper R upper P upper U 2 EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mi>R</mi> <mi>P</mi> <mi>U</mi></mrow></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mfrac><mi>R</mi>
    <mrow><mi>M</mi><mi>A</mi><mi>U</mi></mrow></mfrac></mtd></mtr> <mtr><mtd><mo>=</mo></mtd>
    <mtd columnalign="left"><mfrac><mrow><msub><mi>R</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>R</mi>
    <mn>2</mn></msub></mrow> <mrow><msub><mtext>MAU</mtext> <mn>1</mn></msub> <mo>+</mo><msub><mtext>MAU</mtext>
    <mn>2</mn></msub></mrow></mfrac></mtd></mtr> <mtr><mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mfrac><msub><mi>R</mi>
    <mn>1</mn></msub> <msub><mtext>MAU</mtext> <mn>1</mn></msub></mfrac> <mfrac><msub><mtext>MAU</mtext>
    <mn>1</mn></msub> <mrow><msub><mtext>MAU</mtext> <mn>1</mn></msub> <mo>+</mo><msub><mtext>MAU</mtext>
    <mn>2</mn></msub></mrow></mfrac> <mo>+</mo> <mfrac><msub><mi>R</mi> <mn>2</mn></msub>
    <msub><mtext>MAU</mtext> <mn>2</mn></msub></mfrac> <mfrac><msub><mtext>MAU</mtext>
    <mn>2</mn></msub> <mrow><msub><mtext>MAU</mtext> <mn>1</mn></msub> <mo>+</mo><msub><mtext>MAU</mtext>
    <mn>2</mn></msub></mrow></mfrac></mrow></mtd></mtr> <mtr><mtd><mo>=</mo></mtd>
    <mtd columnalign="left"><mrow><msub><mi>ω</mi> <mn>1</mn></msub> <mi>A</mi> <mi>R</mi>
    <mi>P</mi> <msub><mi>U</mi> <mn>1</mn></msub> <mo>+</mo> <msub><mi>ω</mi> <mn>2</mn></msub>
    <mi>A</mi> <mi>R</mi> <mi>P</mi> <msub><mi>U</mi> <mn>2</mn></msub></mrow></mtd></mtr></mtable></math>
- en: Note that weights are the relative share of monthly active users in the period
    for each segment. As usual, weights must add up to one.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，权重是每段月活跃用户在该期间的相对份额。通常情况下，权重必须加起来等于一。
- en: '[Figure 3-3](#ch3_mixrate) shows one possible visualization of this decomposition
    for a simulated dataset for the ARPU example (with three segments). Had there
    not been any changes in the shares, ARPU would have increased by $3.2 (*rate*);
    similarly, had there not been any changes in ARPU per segment, average revenue
    per user would have fallen by $1.6 (*mix*).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-3](#ch3_mixrate)展示了ARPU示例的模拟数据集的一种可能的可视化分解（包含三个段）。如果份额没有任何变化，ARPU会增加$3.2（*rate*）；同样，如果每个段的ARPU没有任何变化，每用户平均收入将减少$1.6（*mix*）。'
- en: '![mix rate decomposition](assets/dshp_0303.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![mix rate decomposition](assets/dshp_0303.png)'
- en: Figure 3-3\. Example of a mix-rate decomposition
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-3\. mix-rate分解示例
- en: Interpretation
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释
- en: 'The interpretation is straightforward: a change in the metric is equal to the
    sum of the partialled-out parts (that is, fixing one component at initial values
    and allowing the other to change) and the combined effect of both changes.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 解释很简单：度量的变化等于分解部分的总和（即，在初始值下固定一个组件并允许另一个组件变化）以及两者变化的联合效果。
- en: As mentioned earlier, I find the first part quite compelling for storytelling
    purposes, since you’re effectively simulating what would’ve happened if only the
    weights or the rates had changed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我发现第一部分对讲故事目的非常有吸引力，因为你实际上在模拟如果只有权重或费率发生变化会发生什么。
- en: Mathematical Derivations
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学推导
- en: Let’s dive into the math; understanding the derivation is crucial for coding
    purposes. I’ve found myself debugging a function because I did *not* use the right
    weights, or because the time subscripts were wrong.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入数学；理解推导对于编码至关重要。我发现自己因为没有使用正确的权重或者时间下标错误而调试函数。
- en: In what follows I’ll simplify by assuming only two summands (additive), multiples
    (multiplicative), or segments (mix-rate). It’s easy to check that these generalize
    to more inputs or segments (but you need to be careful, as you can see in the
    code [repo](https://oreil.ly/dshp-repo)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我将简化为仅假设两个加法项（加法）、乘法项（乘法）或段（mix-rate）。可以很容易地检查这些是否推广到更多的输入或段（但你需要小心，如你可以在代码[repo](https://oreil.ly/dshp-repo)中看到的）。
- en: Also, I denote the growth rate of <math alttext="x"><mi>x</mi></math> as <math
    alttext="g Subscript t Baseline equals StartFraction normal upper Delta x Subscript
    t Baseline Over x Subscript t minus 1 Baseline EndFraction"><mrow><msub><mi>g</mi>
    <mi>t</mi></msub> <mo>=</mo> <mfrac><mrow><mi>Δ</mi><msub><mi>x</mi> <mi>t</mi></msub></mrow>
    <msub><mi>x</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac></mrow></math>
    , with <math alttext="normal upper Delta x Subscript t colon equals x Subscript
    t minus x Subscript t minus 1"><mrow><mi>Δ</mi> <msub><mi>x</mi> <mi>t</mi></msub>
    <mo>:</mo> <mo>=</mo> <msub><mi>x</mi> <mi>t</mi></msub> <mo>-</mo> <msub><mi>x</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></math> the first difference
    of <math alttext="x"><mi>x</mi></math> .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我将<math alttext="x"><mi>x</mi></math>的增长率表示为<math alttext="g Subscript t
    Baseline equals StartFraction normal upper Delta x Subscript t Baseline Over x
    Subscript t minus 1 Baseline EndFraction"><mrow><msub><mi>g</mi> <mi>t</mi></msub>
    <mo>=</mo> <mfrac><mrow><mi>Δ</mi><msub><mi>x</mi> <mi>t</mi></msub></mrow> <msub><mi>x</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac></mrow></math>，其中<math
    alttext="normal upper Delta x Subscript t colon equals x Subscript t minus x Subscript
    t minus 1"><mrow><mi>Δ</mi> <msub><mi>x</mi> <mi>t</mi></msub> <mo>:</mo> <mo>=</mo>
    <msub><mi>x</mi> <mi>t</mi></msub> <mo>-</mo> <msub><mi>x</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></math>是<math
    alttext="x"><mi>x</mi></math>的首次差异。
- en: Additive Decomposition
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加法分解
- en: 'Since <math alttext="y"><mi>y</mi></math> is additive:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<math alttext="y"><mi>y</mi></math>是加法的：
- en: <math alttext="y Subscript t Baseline equals y Subscript 1 comma t Baseline
    plus y Subscript 2 comma t" display="block"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y Subscript t Baseline equals y Subscript 1 comma t Baseline
    plus y Subscript 2 comma t" display="block"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
- en: 'Let’s take the first differences now to get:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们首先进行差异运算以获得：
- en: <math alttext="normal upper Delta y Subscript t Baseline equals normal upper
    Delta y Subscript 1 comma t Baseline plus normal upper Delta y Subscript 2 comma
    t" display="block"><mrow><mi>Δ</mi> <msub><mi>y</mi> <mi>t</mi></msub> <mo>=</mo>
    <mi>Δ</mi> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <mi>Δ</mi> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal upper Delta y Subscript t Baseline equals normal upper
    Delta y Subscript 1 comma t Baseline plus normal upper Delta y Subscript 2 comma
    t" display="block"><mrow><mi>Δ</mi> <msub><mi>y</mi> <mi>t</mi></msub> <mo>=</mo>
    <mi>Δ</mi> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <mi>Δ</mi> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
- en: 'Finally, to get growth rates:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了获得增长率：
- en: <math alttext="StartFraction normal upper Delta y Subscript t Baseline Over
    y Subscript t minus 1 Baseline EndFraction equals StartFraction normal upper Delta
    y Subscript 1 comma t Baseline Over y Subscript 1 comma t minus 1 Baseline EndFraction
    StartFraction y Subscript 1 comma t minus 1 Baseline Over y Subscript t minus
    1 Baseline EndFraction plus StartFraction normal upper Delta y Subscript 2 comma
    t Baseline Over y Subscript 2 comma t minus 1 Baseline EndFraction StartFraction
    y Subscript 2 comma t minus 1 Baseline Over y Subscript t minus 1 Baseline EndFraction
    equals omega Subscript 1 comma t minus 1 Baseline StartFraction normal upper Delta
    y Subscript 1 comma t Baseline Over y Subscript 1 comma t minus 1 Baseline EndFraction
    plus omega Subscript 2 comma t minus 1 Baseline StartFraction normal upper Delta
    y Subscript 2 comma t Baseline Over y Subscript 2 comma t minus 1 Baseline EndFraction"
    display="block"><mrow><mfrac><mrow><mi>Δ</mi><msub><mi>y</mi> <mi>t</mi></msub></mrow>
    <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac> <mo>=</mo>
    <mfrac><mrow><mi>Δ</mi><msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow>
    <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mfrac><msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac> <mo>+</mo>
    <mfrac><mrow><mi>Δ</mi><msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mfrac><msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac> <mo>=</mo>
    <msub><mi>ω</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mfrac><mrow><mi>Δ</mi><msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow>
    <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mo>+</mo> <msub><mi>ω</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mfrac><mrow><mi>Δ</mi><msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac></mrow></math>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction normal upper Delta y Subscript t Baseline Over
    y Subscript t minus 1 Baseline EndFraction equals StartFraction normal upper Delta
    y Subscript 1 comma t Baseline Over y Subscript 1 comma t minus 1 Baseline EndFraction
    StartFraction y Subscript 1 comma t minus 1 Baseline Over y Subscript t minus
    1 Baseline EndFraction plus StartFraction normal upper Delta y Subscript 2 comma
    t Baseline Over y Subscript 2 comma t minus 1 Baseline EndFraction StartFraction
    y Subscript 2 comma t minus 1 Baseline Over y Subscript t minus 1 Baseline EndFraction
    equals omega Subscript 1 comma t minus 1 Baseline StartFraction normal upper Delta
    y Subscript 1 comma t Baseline Over y Subscript 1 comma t minus 1 Baseline EndFraction
    plus omega Subscript 2 comma t minus 1 Baseline StartFraction normal upper Delta
    y Subscript 2 comma t Baseline Over y Subscript 2 comma t minus 1 Baseline EndFraction"
    display="block"><mrow><mfrac><mrow><mi>Δ</mi><msub><mi>y</mi> <mi>t</mi></msub></mrow>
    <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac> <mo>=</mo>
    <mfrac><mrow><mi>Δ</mi><msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow>
    <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mfrac><msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac> <mo>+</mo>
    <mfrac><mrow><mi>Δ</mi><msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mfrac><msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac> <mo>=</mo>
    <msub><mi>ω</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mfrac><mrow><mi>Δ</mi><msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow>
    <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mo>+</mo> <msub><mi>ω</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mfrac><mrow><mi>Δ</mi><msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac></mrow></math>
- en: or
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: <math alttext="g Subscript y comma t Baseline equals omega Subscript 1 comma
    t minus 1 Baseline g Subscript 1 comma t Baseline plus omega Subscript 2 comma
    t minus 1 Baseline g Subscript 2 comma t" display="block"><mrow><msub><mi>g</mi>
    <mrow><mi>y</mi><mo>,</mo><mi>t</mi></mrow></msub> <mo>=</mo> <msub><mi>ω</mi>
    <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <msub><mi>g</mi>
    <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub> <mo>+</mo> <msub><mi>ω</mi>
    <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <msub><mi>g</mi>
    <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="g Subscript y comma t Baseline equals omega Subscript 1 comma
    t minus 1 Baseline g Subscript 1 comma t Baseline plus omega Subscript 2 comma
    t minus 1 Baseline g Subscript 2 comma t" display="block"><mrow><msub><mi>g</mi>
    <mrow><mi>y</mi><mo>,</mo><mi>t</mi></mrow></msub> <mo>=</mo> <msub><mi>ω</mi>
    <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <msub><mi>g</mi>
    <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub> <mo>+</mo> <msub><mi>ω</mi>
    <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <msub><mi>g</mi>
    <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
- en: Multiplicative Decomposition
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 乘法分解
- en: 'Since <math alttext="y"><mi>y</mi></math> is multiplicative:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<math alttext="y"><mi>y</mi></math>是乘法的：
- en: <math alttext="y Subscript t Baseline equals y Subscript 1 comma t Baseline
    times y Subscript 2 comma t" display="block"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y Subscript t Baseline equals y Subscript 1 comma t Baseline
    times y Subscript 2 comma t" display="block"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
- en: 'Taking a first difference of the output and adding and subtracting an extra
    term (that helps factor out extra terms):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对输出进行首次差异，并添加和减去额外项（帮助因子化额外项）：
- en: <math alttext="normal upper Delta y Subscript t Baseline equals y Subscript
    1 comma t Baseline y Subscript 2 comma t Baseline minus y Subscript 1 comma t
    minus 1 Baseline y Subscript 2 comma t minus 1 Baseline plus y Subscript 1 comma
    t Baseline y Subscript 2 comma t minus 1 Baseline minus y Subscript 1 comma t
    Baseline y Subscript 2 comma t minus 1 Baseline equals y Subscript 1 comma t Baseline
    normal upper Delta y Subscript 2 comma t Baseline plus y Subscript 2 comma t minus
    1 Baseline normal upper Delta y Subscript 1 comma t" display="block"><mrow><mi>Δ</mi>
    <msub><mi>y</mi> <mi>t</mi></msub> <mo>=</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub> <mo>-</mo>
    <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>-</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>=</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mi>Δ</mi> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mi>Δ</mi> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="normal upper Delta y Subscript t Baseline equals y Subscript
    1 comma t Baseline y Subscript 2 comma t Baseline minus y Subscript 1 comma t
    minus 1 Baseline y Subscript 2 comma t minus 1 Baseline plus y Subscript 1 comma
    t Baseline y Subscript 2 comma t minus 1 Baseline minus y Subscript 1 comma t
    Baseline y Subscript 2 comma t minus 1 Baseline equals y Subscript 1 comma t Baseline
    normal upper Delta y Subscript 2 comma t Baseline plus y Subscript 2 comma t minus
    1 Baseline normal upper Delta y Subscript 1 comma t" display="block"><mrow><mi>Δ</mi>
    <msub><mi>y</mi> <mi>t</mi></msub> <mo>=</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub> <mo>-</mo>
    <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>-</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>=</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mi>Δ</mi> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mi>Δ</mi> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
- en: 'To get growth rates, you just need to be a bit careful and remember that the
    output is multiplicative for all time periods:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得增长率，你只需要稍微小心，并记住所有时间段的输出都是乘法的：
- en: <math alttext="StartFraction normal upper Delta y Subscript t Baseline Over
    y Subscript t minus 1 Baseline EndFraction equals StartFraction y Subscript 1
    comma t Baseline Over y Subscript 1 comma t minus 1 Baseline EndFraction StartFraction
    normal upper Delta y Subscript 2 comma t Baseline Over y Subscript 2 comma t minus
    1 Baseline EndFraction plus StartFraction y Subscript 2 comma t minus 1 Baseline
    Over y Subscript 2 comma t minus 1 Baseline EndFraction StartFraction normal upper
    Delta y Subscript 1 comma t Baseline Over y Subscript 1 comma t minus 1 Baseline
    EndFraction equals left-parenthesis 1 plus g Subscript 1 comma t Baseline right-parenthesis
    g Subscript 2 comma t Baseline plus g Subscript 1 comma t Baseline equals g Subscript
    1 comma t Baseline plus g Subscript 2 comma t Baseline plus g Subscript 1 comma
    t Baseline g Subscript 2 comma t" display="block"><mrow><mfrac><mrow><mi>Δ</mi><msub><mi>y</mi>
    <mi>t</mi></msub></mrow> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mo>=</mo> <mfrac><msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mfrac><mrow><mi>Δ</mi><msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mo>+</mo> <mfrac><msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mfrac><mrow><mi>Δ</mi><msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow>
    <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>+</mo> <msub><mi>g</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>)</mo></mrow> <msub><mi>g</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <msub><mi>g</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>=</mo> <msub><mi>g</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <msub><mi>g</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <msub><mi>g</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <msub><mi>g</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction normal upper Delta y Subscript t Baseline Over
    y Subscript t minus 1 Baseline EndFraction equals StartFraction y Subscript 1
    comma t Baseline Over y Subscript 1 comma t minus 1 Baseline EndFraction StartFraction
    normal upper Delta y Subscript 2 comma t Baseline Over y Subscript 2 comma t minus
    1 Baseline EndFraction plus StartFraction y Subscript 2 comma t minus 1 Baseline
    Over y Subscript 2 comma t minus 1 Baseline EndFraction StartFraction normal upper
    Delta y Subscript 1 comma t Baseline Over y Subscript 1 comma t minus 1 Baseline
    EndFraction equals left-parenthesis 1 plus g Subscript 1 comma t Baseline right-parenthesis
    g Subscript 2 comma t Baseline plus g Subscript 1 comma t Baseline equals g Subscript
    1 comma t Baseline plus g Subscript 2 comma t Baseline plus g Subscript 1 comma
    t Baseline g Subscript 2 comma t" display="block"><mrow><mfrac><mrow><mi>Δ</mi><msub><mi>y</mi>
    <mi>t</mi></msub></mrow> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mo>=</mo> <mfrac><msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mfrac><mrow><mi>Δ</mi><msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mo>+</mo> <mfrac><msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mfrac><mrow><mi>Δ</mi><msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow>
    <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mfrac>
    <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>+</mo> <msub><mi>g</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>)</mo></mrow> <msub><mi>g</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <msub><mi>g</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>=</mo> <msub><mi>g</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <msub><mi>g</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>+</mo> <msub><mi>g</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <msub><mi>g</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></math>
- en: Note that if you have more than two inputs, you need to sum *all* combinations
    of products.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您有超过两个输入，则需要总结*所有*产品的组合。
- en: Mix-Rate Decomposition
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合速率分解
- en: 'Recall that for the mix-rate case, the output metric can be expressed as a
    weighted average of the metric for segments:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于混合速率情况，输出度量可以表示为段的度量的加权平均值：
- en: <math alttext="y Subscript t Baseline equals bold w Subscript bold t Baseline
    dot bold x Subscript bold t" display="block"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <msub><mi>𝐰</mi> <mi>𝐭</mi></msub> <mo>·</mo> <msub><mi>𝐱</mi> <mi>𝐭</mi></msub></mrow></math>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y Subscript t Baseline equals bold w Subscript bold t Baseline
    dot bold x Subscript bold t" display="block"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <msub><mi>𝐰</mi> <mi>𝐭</mi></msub> <mo>·</mo> <msub><mi>𝐱</mi> <mi>𝐭</mi></msub></mrow></math>
- en: where the weights add up to one, and bold letters denote vectors.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 其中权重加起来为一，粗体字母表示向量。
- en: In this case I’ll work backward and show that after some simplifications you
    will arrive at the original expression. Not the most elegant way, but I would
    rather do it this way instead of adding and subtracting terms that you wonder
    where they came from.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我会反向操作，并展示经过一些简化后你将得到原始表达式。这不是最优雅的方式，但我宁愿这样做，而不是添加和减去你不知道其来历的项。
- en: <math alttext="StartLayout 1st Row 1st Column normal upper Delta Subscript y
    Superscript x Baseline plus normal upper Delta Subscript y Superscript w Baseline
    plus normal upper Delta bold w dot bold upper Delta bold x 2nd Column equals 3rd
    Column ModifyingBelow bold w Subscript bold t minus bold 1 Baseline dot bold upper
    Delta bold x bold plus bold x Subscript bold t minus bold 1 Baseline dot bold
    upper Delta bold w bold plus bold upper Delta bold w dot bold upper Delta bold
    x With bottom-brace Underscript Replacing the definitions Endscripts 2nd Row 1st
    Column Blank 2nd Column equals 3rd Column ModifyingBelow normal upper Delta bold
    x dot bold left-parenthesis bold upper Delta bold w bold plus bold w Subscript
    bold t minus bold 1 Baseline bold right-parenthesis bold plus bold upper Delta
    bold w ModifyingAbove With bold dot bold x Subscript bold t minus bold 1 With
    bottom-brace Underscript Factoring out normal upper Delta bold x Endscripts 3rd
    Row 1st Column Blank 2nd Column equals 3rd Column ModifyingBelow bold x Subscript
    bold t Baseline bold w Subscript bold t minus bold x Subscript bold t minus bold
    1 Baseline bold w Subscript bold t minus bold 1 With bottom-brace Underscript
    Simplifying Endscripts 4th Row 1st Column Blank 2nd Column equals 3rd Column normal
    upper Delta y Subscript t EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><msubsup><mi>Δ</mi> <mi>y</mi> <mi>x</mi></msubsup>
    <mo>+</mo> <msubsup><mi>Δ</mi> <mi>y</mi> <mi>w</mi></msubsup> <mo>+</mo> <mi>Δ</mi>
    <mi>𝐰</mi> <mo>·</mo> <mi>Δ</mi> <mi>𝐱</mi></mrow></mtd> <mtd><mo>=</mo></mtd>
    <mtd columnalign="left"><munder><munder accentunder="true"><mrow><msub><mi>𝐰</mi>
    <mrow><mi>𝐭</mi><mo>-</mo><mn mathvariant="bold">1</mn></mrow></msub> <mo>·</mo><mi>Δ</mi><mi>𝐱</mi><mo>+</mo><msub><mi>𝐱</mi>
    <mrow><mi>𝐭</mi><mo>-</mo><mn mathvariant="bold">1</mn></mrow></msub> <mo>·</mo><mi>Δ</mi><mi>𝐰</mi><mo>+</mo><mi>Δ</mi><mi>𝐰</mi><mo>·</mo><mi>Δ</mi><mi>𝐱</mi></mrow>
    <mo>︸</mo></munder> <mrow><mtext>Replacing</mtext><mtext>the</mtext><mtext>definitions</mtext></mrow></munder></mtd></mtr>
    <mtr><mtd><mo>=</mo></mtd> <mtd columnalign="left"><munder><munder accentunder="true"><mrow><mi>Δ</mi><mi>𝐱</mi><mo>·</mo><mrow><mo>(</mo><mi>Δ</mi><mi>𝐰</mi><mo>+</mo><msub><mi>𝐰</mi>
    <mrow><mi>𝐭</mi><mo>-</mo><mn mathvariant="bold">1</mn></mrow></msub> <mo>)</mo></mrow><mo>+</mo><mi>Δ</mi><mi>𝐰</mi>
    <mover accent="true"><mo>˙</mo></mover><msub><mi>𝐱</mi> <mrow><mi>𝐭</mi><mo>-</mo><mn
    mathvariant="bold">1</mn></mrow></msub></mrow> <mo>︸</mo></munder> <mrow><mtext>Factoring</mtext><mtext>out</mtext><mi>Δ</mi><mi>𝐱</mi></mrow></munder></mtd></mtr>
    <mtr><mtd><mo>=</mo></mtd> <mtd columnalign="left"><munder><munder accentunder="true"><mrow><msub><mi>𝐱</mi>
    <mi>𝐭</mi></msub> <msub><mi>𝐰</mi> <mi>𝐭</mi></msub> <mo>-</mo><msub><mi>𝐱</mi>
    <mrow><mi>𝐭</mi><mo>-</mo><mn mathvariant="bold">1</mn></mrow></msub> <msub><mi>𝐰</mi>
    <mrow><mi>𝐭</mi><mo>-</mo><mn mathvariant="bold">1</mn></mrow></msub></mrow> <mo>︸</mo></munder>
    <mtext>Simplifying</mtext></munder></mtd></mtr> <mtr><mtd><mo>=</mo></mtd> <mtd
    columnalign="left"><mrow><mi>Δ</mi> <msub><mi>y</mi> <mi>t</mi></msub></mrow></mtd></mtr></mtable></math>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column normal upper Delta Subscript y
    Superscript x Baseline plus normal upper Delta Subscript y Superscript w Baseline
    plus normal upper Delta bold w dot bold upper Delta bold x 2nd Column equals 3rd
    Column ModifyingBelow bold w Subscript bold t minus bold 1 Baseline dot bold upper
    Delta bold x bold plus bold x Subscript bold t minus bold 1 Baseline dot bold
    upper Delta bold w bold plus bold upper Delta bold w dot bold upper Delta bold
    x With bottom-brace Underscript Replacing the definitions Endscripts 2nd Row 1st
    Column Blank 2nd Column equals 3rd Column ModifyingBelow normal upper Delta bold
    x dot bold left-parenthesis bold upper Delta bold w bold plus bold w Subscript
    bold t minus bold 1 Baseline bold right-parenthesis bold plus bold upper Delta
    bold w ModifyingAbove With bold dot bold x Subscript bold t minus bold 1 With
    bottom-brace Underscript Factoring out normal upper Delta bold x Endscripts 3rd
    Row 1st Column Blank 2nd Column equals 3rd Column ModifyingBelow bold x Subscript
    bold t Baseline bold w Subscript bold t minus bold x Subscript bold t minus bold
    1 Baseline bold w Subscript bold t minus bold 1 With bottom-brace Underscript
    Simplifying Endscripts 4th Row 1st Column Blank 2nd Column equals 3rd Column normal
    upper Delta y Subscript t EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><msubsup><mi>Δ</mi> <mi>y</mi> <mi>x</mi></msubsup>
    <mo>+</mo> <msubsup><mi>Δ</mi> <mi>y</mi> <mi>w</mi></msubsup> <mo>+</mo> <mi>Δ</mi>
    <mi>𝐰</mi> <mo>·</mo> <mi>Δ</mi> <mi>𝐱</mi></mrow></mtd> <mtd><mo>=</mo></mtd>
    <mtd columnalign="left"><munder><munder accentunder="true"><mrow><msub><mi>𝐰</mi>
    <mrow><mi>𝐭</mi><mo>-</mo><mn mathvariant="bold">1</mn></mrow></msub> <mo>·</mo><mi>Δ</mi><mi>𝐱</mi><mo>+</mo><msub><mi>𝐱</mi>
    <mrow><mi>𝐭</mi><mo>-</mo><mn mathvariant="bold">1</mn></mrow></msub> <mo>·</mo><mi>Δ</mi><mi>𝐰</mi><mo>+</mo><mi>Δ</mi><mi>𝐰</mi><mo>·</mo><mi>Δ</mi><mi>𝐱</mi></mrow>
    <mo>︸</mo></munder> <mrow><mtext>Replacing</mtext><mtext>the</mtext><mtext>definitions</mtext></mrow></munder></mtd></mtr>
    <mtr><mtd><mo>=</mo></mtd> <mtd columnalign="left"><munder><munder accentunder="true"><mrow><mi>Δ</mi><mi>𝐱</mi><mo>·</mo><mrow><mo>(</mo><mi>Δ</mi><mi>𝐰</mi><mo>+</mo><msub><mi>𝐰</mi>
    <mrow><mi>𝐭</mi><mo>-</mo><mn mathvariant="bold">1</mn></mrow></msub> <mo>)</mo></mrow><mo>+</mo><mi>Δ</mi><mi>𝐰</mi>
    <mover accent="true"><mo>˙</mo></mover><msub><mi>𝐱</mi> <mrow><mi>𝐭</mi><mo>-</mo><mn
    mathvariant="bold">1</mn></mrow></msub></mrow> <mo>︸</mo></munder> <mrow><mtext>Factoring</mtext><mtext>out</mtext><mi>Δ</mi><mi>𝐱</mi></mrow></munder></mtd></mtr>
    <mtr><mtd><mo>=</mo></mtd> <mtd columnalign="left"><munder><munder accentunder="true"><mrow><msub><mi>𝐱</mi>
    <mi>𝐭</mi></msub> <msub><mi>𝐰</mi> <mi>𝐭</mi></msub> <mo>-</mo><msub><mi>𝐱</mi>
    <mrow><mi>𝐭</mi><mo>-</mo><mn mathvariant="bold">1</mn></mrow></msub> <msub><mi>𝐰</mi>
    <mrow><mi>𝐭</mi><mo>-</mo><mn mathvariant="bold">1</mn></mrow></msub></mrow> <mo>︸</mo></munder>
    <mtext>Simplifying</mtext></munder></mtd></mtr> <mtr><mtd><mo>=</mo></mtd> <mtd
    columnalign="left"><mrow><mi>Δ</mi> <msub><mi>y</mi> <mi>t</mi></msub></mrow></mtd></mtr></mtable></math>
- en: Key Takeaways
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键要点
- en: 'These are the key takeaways from this chapter:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是本章的关键要点：
- en: Finding root causes for changes in time is usually very hard.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找时间变化的根本原因通常非常困难。
- en: You need enough variation in the drivers to estimate impacts.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要足够的驱动变化来估计影响。
- en: Growth decompositions are useful to get hints about the underlying root causes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 增长分解对于获取有关潜在根本原因的提示非常有用。
- en: 'By exploiting these extra sources of variations (from other input metrics),
    you’re able to hypothesize what drove the change. I’ve shown three decompositions
    that might work for the problem you face: additive, multiplicative, and mix-rate.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用这些额外的变化源（来自其他输入度量），你能够假设是什么驱动了变化。我展示了三种可能适用于你所面临问题的分解方法：加法、乘法和混合速率。
- en: Further Reading
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To the best of my knowledge, there’s not much published literature on this.
    My impression is that this knowledge is shared within company data teams and cultures,
    but never gets out to the more general public. I learned about the additive decomposition
    in a previous job, and worked out the other two as needed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就我所知，关于这个问题的已发表文献不多。我印象中，这些知识是在公司数据团队和文化中共享的，但从未传播到更广泛的公众中。我在以前的工作中了解了加法分解，并根据需要推导出了其他两种方法。
- en: The math is relatively straightforward, so there’s no need to develop it further.
    If you’re still interested, the methods I’ve used can be found in any introductory
    book or lecture notes on discrete calculus.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 数学相对简单，所以没有必要进一步发展。如果你仍然感兴趣，我使用的方法可以在任何关于离散微积分的入门书籍或讲义中找到。
- en: ^([1](ch03.html#id375-marker)) In [Chapter 10](ch10.html#ch10_linreg), I discuss
    why you *need* variation in the inputs to explain variation in the output metric.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#id375-marker)) 在[第10章](ch10.html#ch10_linreg)中，我讨论了为什么你需要输入变化来解释输出指标的变化。
- en: ^([2](ch03.html#id381-marker)) If you use a log transformation, you can use
    a Taylor expansion to get the same result that the growth rate of a product is
    just the sum of the growth rates of the inputs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.html#id381-marker)) 如果你使用对数变换，可以使用泰勒展开得到同样的结果，即产品的增长率只是输入增长率的总和。
