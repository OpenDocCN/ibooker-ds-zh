- en: 8 Configuration management and stable releases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 配置管理和稳定发布
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating configuration management to change application functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建配置管理以更改应用程序功能
- en: Exploring different options for configuration management
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索配置管理的不同选项
- en: Hiding new or incomplete features with configuration feature flags
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用配置功能标志隐藏新或不完整的功能
- en: Communicating software changes through release notes and versioning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过发布说明和版本控制来传达软件更改
- en: “I just can’t see how we can safely roll this out while we are still testing
    or how we can easily cut over to the new system once we are comfortable,” the
    QA lead says during a kickoff meeting. “I mean, we’ve been happy with the automated
    testing, and it has caught a few bugs already, but we can’t sign off on releasing
    this into the wild yet.”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: “我实在看不出我们如何在测试的同时安全地推出这个版本，或者我们如何在感到舒适后轻松切换到新系统，”质量保证负责人在一次启动会议上说。“我的意思是，我们对自动化测试很满意，它已经捕捉到一些错误，但我们还不能批准将其发布到野外。”
- en: “We can’t just have this sitting around, though. We need to be able to show
    that this rewrite is worth it. We have shown that we can make changes quickly
    and release often, but we need some real traffic to see how this is going to hold
    up, and the only way we can do that is if we start letting our customers use it.”
    Your project manager is beyond exasperated at this point. You’ve just gone through
    an entire rollout plan meeting, and once again, it feels like QA is stopping any
    sort of progress.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: “尽管如此，我们不能就这样放着。我们需要能够证明这次重写是值得的。我们已经证明我们可以快速做出改变并频繁发布，但我们需要一些真实流量来看到这将如何保持，而我们唯一能这样做的方式就是开始让我们的客户使用它。”此时，你的项目经理已经非常沮丧。你刚刚经历了一次整个发布计划会议，而且感觉质量保证又一次阻止了任何进展。
- en: But as you sit there, you have to feel that QA has a point. We aren’t sure how
    this will operate under different loads, and we aren’t sure how this will work
    in our entire ecosystem. You mention this, but when you get a sideways glare from
    your project manager, you start to propose a solution rather than point out a
    problem.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但当你坐下来时，你必须感觉到QA（质量保证）有道理。我们不确定在不同负载下它会如何运行，我们也不确定它在我们整个生态系统中的运作方式。你提到了这一点，但当你的项目经理给你一个侧目时，你开始提出解决方案而不是指出问题。
- en: You mention that the new system relies on the old system for translations we
    don’t currently have in the database. You also mention that the current storage
    device for your system is just an in-memory key-value store—definitely something
    you need to change if you want this to be in production.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你提到新系统依赖于旧系统进行翻译，而我们数据库中目前没有这些翻译。你还提到，你系统的当前存储设备只是一个内存中的键值存储——如果你想让它在生产中运行，这肯定是你需要改变的事情。
- en: '“Exactly my point: there are just too many changes that need to happen before
    we can even start testing it and sign off on it in production,” someone from QA
    interjects.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: “正是我的观点：在我们甚至开始测试并在生产中签字批准之前，需要发生太多的变化，”质量保证部门的人插话道。
- en: You patiently correct them. “No, we will continue to release but will slowly
    cut people over once we are sure things are working as expected. Similarly, you
    will only ship one binary, but it will be able to change based on various settings.”
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你耐心地纠正他们。“不，我们将继续发布，但一旦我们确定一切按预期工作，我们将慢慢过渡。同样，你将只发布一个二进制文件，但它将能够根据各种设置进行更改。”
- en: '“We need to list what we want to start integrating with in order to go live.”
    Your project manager stands up, grabs a marker, and writes the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “我们需要列出我们想要开始集成的项目，以便上线。”你的项目经理站起来，拿起一支记号笔，写下以下内容：
- en: Change API port.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改API端口。
- en: Add ability to change client endpoint for legacy systems.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为旧系统添加更改客户端端点的功能。
- en: Turn off client calls.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭客户端调用。
- en: Add a database for long-term storage.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个数据库用于长期存储。
- en: “Do you think you can get this done in a week? We need to get this rolling soon,”
    your project manager says. You nod; using configuration management, you can build
    a system that you can use to turn various features on and off.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: “你认为你能在一周内完成吗？我们需要尽快开始，”你的项目经理说。你点头；使用配置管理，你可以构建一个系统，你可以用它来开启和关闭各种功能。
- en: 8.1 Configuration
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 配置
- en: 'All programs deal with two things: input and output. Programs take in data
    and emit data. Some will simply print “Hello World!” (that’s the output). Some
    will only read log messages and store them in a database (that’s input). But you
    can imagine providing input to an application to make it change its functionality.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有程序都处理两件事：输入和输出。程序接收数据并输出数据。有些程序只会打印“Hello World！”（这是输出）。有些程序只会读取日志消息并将它们存储在数据库中（这是输入）。但你可以想象向应用程序提供输入以改变其功能。
- en: Take, for instance, an application that is a counter. It may look something
    like the code in the following listing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个计数器应用程序为例。它可能看起来像以下列表中的代码。
- en: Listing 8.1 `main.go`
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 `main.go`
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is simple enough, but instead of having the counter increment by one,
    maybe we want it to increment by two, so we change the line `count++` to `count`
    `=` `count` `+` `2`. Great! But now you want to increment by 100\. I hope you
    can see where we are going here. This is not scalable or transferable to other
    use cases. What if we could use just one piece of code to do this and not need
    to recompile it each time? We would provide input to the application when it started,
    which would affect its output. This input to change the functionality is known
    as a *configuration*. To configure this application, we will use what is known
    as an *environmental variable*: a variable stored in your terminal session. We
    will explore other configuration techniques in the following sections.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但是如果我们想让它每次增加的不是一，而是二，那么我们就需要将行 `count++` 改为 `count = count + 2`。太棒了！但现在你想要每次增加100。我希望你能看到我们在这里要走向何方。这既不可扩展，也无法转移到其他用例中。如果我们能只用一段代码来做这件事，而且每次都不需要重新编译，那会怎么样？我们可以在应用程序启动时提供输入，这将影响其输出。这种用于改变功能的输入被称为*配置*。为了配置此应用程序，我们将使用所谓的*环境变量*：存储在您的终端会话中的变量。在接下来的章节中，我们将探讨其他配置技术。
- en: To allow configuration, we would use something like the code in the following
    listing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许配置，我们将使用以下列表中的代码。
- en: Listing 8.2 `main.go`
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 `main.go`
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you run this code, you will see the warning message, but if you were to run
    something like `INC=2` `go` `run` `counter.go`, you would see the values increment
    by two. This seems simple but is extremely valuable, especially for things like
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你会看到警告信息，但如果你运行类似 `INC=2 go run counter.go` 这样的命令，你会看到值以二为增量增加。这看起来很简单，但非常有价值，特别是对于像
- en: Database connection information
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接信息
- en: Password salts
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码盐
- en: Client endpoints
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端端点
- en: Log levels
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志级别
- en: NOTE We will build our tools for configuration management. However, you can
    use the popular Viper library to manage configuration that way.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：我们将构建我们的配置管理工具。然而，你可以使用流行的Viper库以这种方式管理配置。
- en: How can we add configuration to our API? Can we manage the configuration in
    different ways?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将配置添加到我们的API中？我们能否以不同的方式管理配置？
- en: 8.2 Advanced configuration
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 高级配置
- en: 'For our application, we will look at adjusting our application functionality
    by loading various configurations. First, let’s identify the features we want
    to be modified:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将通过加载各种配置来调整应用程序的功能。首先，让我们确定我们想要修改的功能：
- en: Custom port number
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义端口号
- en: Storage type (database, in memory)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储类型（数据库、内存）
- en: Storage connection information (if a database)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储连接信息（如果是数据库）
- en: External client endpoint (if none, do not call)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部客户端端点（如果没有，则不调用）
- en: Let’s define this as a struct we can pass around in our application. Create
    a new package called `config`, and in it, create a file called `core.go`. In that,
    we will define a struct as in the following listing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个结构体，我们可以在应用程序中传递。创建一个新的包名为 `config`，在其中创建一个名为 `core.go` 的文件。在那里，我们将定义一个结构体，如下所示。
- en: Listing 8.3 `core.go`
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 `core.go`
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Stores the port as a string, but we will validate that it is in the proper
    format later.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将端口号存储为字符串，但我们将稍后在适当格式中验证它。
- en: ❷ This is the endpoint for our client to call and can be injected if it is not
    an empty string.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这是我们的客户端调用的端点，如果它不是空字符串，则可以注入。
- en: ❸ Actively passes in the database type for future enhancements
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 主动传递数据库类型以供未来增强
- en: ❹ This is similar to the legacy endpoint in that if it is empty, we will use
    the in-memory database.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 这与旧端点类似，如果它是空的，我们将使用内存数据库。
- en: 'Notice we put JSON text decorators on the struct. This is because we are going
    to load our configuration in three different ways:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在结构体上使用了JSON文本装饰器。这是因为我们将以三种不同的方式加载我们的配置：
- en: With environmental variables
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境变量
- en: With files
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件
- en: With flags
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标志
- en: Typically, these are the three most common ways to configure an application.
    There are other ways as well, but we’ll focus mainly on these. By defining a core
    structure around our configuration, we can create a common function that will
    allow us to go through these steps to configure our system. First, we load whatever
    variables we can through the environment, then override them from a JSON file,
    and finally rely on flags to load information into our application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些是配置应用程序的三个最常见方法。还有其他方法，但我们主要关注这些。通过在我们的配置周围定义一个核心结构，我们可以创建一个通用函数，这将允许我们通过这些步骤来配置我们的系统。首先，我们通过环境加载我们可以加载的任何变量，然后从JSON文件中覆盖它们，最后依赖于标志将信息加载到我们的应用程序中。
- en: Let’s write out our load function to work in this way. To start, we can come
    up with a set of values to start with, which we will call `defaultConfiguration`.
    Our default configuration can look like the following listing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个加载函数，使其以这种方式工作。首先，我们可以提出一组起始值，我们将称之为`defaultConfiguration`。我们的默认配置可以像以下列表那样。
- en: Listing 8.4 `core.go`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.4 `core.go`
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Creates a basic structure with just the port number as default
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个仅包含端口号的基本结构作为默认值
- en: Given this default state, we can add various ways of changing the configuration.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这种默认状态，我们可以添加各种更改配置的方法。
- en: 8.2.1 Environmental variables
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 环境变量
- en: Environmental variables are stored in a user session in the system. These values
    can be hardcoded or passed into an application by prepending the command with
    the variable. This is an easy way to inject values into a system before it starts
    and can be used dynamically if your system calls the environmental variable repeatedly.
    We will add a method to the `configuration` struct to load the variables from
    the environment and then return them to the calling method using the code in the
    following listing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量存储在系统的用户会话中。这些值可以是硬编码的，也可以通过在命令前添加变量来传递给应用程序。这是一种在系统启动前注入值到系统中的简单方法，如果系统反复调用环境变量，也可以动态使用。我们将在`configuration`结构体中添加一个方法来从环境中加载变量，然后使用以下列表中的代码将它们返回给调用方法。
- en: Listing 8.5 `core.go`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.5 `core.go`
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Inline checks if the language is set in the ENV and then updates the structs
    variable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 内联检查语言是否在ENV中设置，然后更新结构体的变量。
- en: We are checking for two variables, `DEFAULT_LANGUAGE` and `PORT`. If they are
    set, we override the configuration settings; otherwise, we use the defaults. We
    also introduce a helper method because people often want to forgo the colon in
    the port definition, so we will create a method to make sure it’s there and is
    a valid number (see the following listing).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在检查两个变量，`DEFAULT_LANGUAGE`和`PORT`。如果它们被设置，我们将覆盖配置设置；否则，我们将使用默认值。我们还引入了一个辅助方法，因为人们经常希望省略端口定义中的冒号，所以我们将创建一个方法来确保它存在并且是一个有效的数字（见以下列表）。
- en: Listing 8.6 `core.go`
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 `core.go`
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Prepends a colon if it is not present
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果不存在，则添加一个冒号
- en: ❷ Verifies that the value of the string is an integer
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 验证字符串的值是否为整数
- en: ❸ If it is not, reverts to the default port
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果不存在，则恢复到默认端口
- en: 8.2.2 File
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 文件
- en: 'While environmental variables provide an easy way of loading configurations,
    there is still a more portable way: by using a file. JSON or YAML files are common
    ways of storing and loading configuration within a system and allow for portability
    between environments. The common configuration file can be modified for your local
    environment and your production environment without changing the underlying code.
    We add a new flag to allow us to pass in a configuration file explicitly and create
    a new function to parse the file and load variables. Let’s first create a new
    function to load a configuration file through JSON using the code in the following
    listing.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然环境变量提供了一种加载配置的简单方法，但还有一种更便携的方法：通过使用文件。JSON或YAML文件是存储和加载系统内配置的常见方式，并允许在不同环境之间实现便携性。常见的配置文件可以根据您的本地环境和生产环境进行修改，而无需更改底层代码。我们添加了一个新的标志，允许我们显式传递配置文件，并创建一个新的函数来解析文件并加载变量。让我们首先创建一个新的函数，通过以下列表中的代码使用JSON加载配置文件。
- en: Listing 8.7 `core.go`
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 `core.go`
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Reads the contents of the file from the path
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从路径读取文件内容
- en: ❷ Parses the content into the struct
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将内容解析到结构体中
- en: ❸ Unmarshalling the JSON will not overwrite existing values if they are not
    present, but we want to validate for invalid settings.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果不存在，则不会覆盖现有值，但我们需要验证无效设置。
- en: 8.2.3 Flag
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 标志
- en: There are times when a user may want to inject variables more explicitly. This
    is useful when you switch environments, because environmental variables can be
    stored in a session using `export` `DEFAULT_LANGUAGE=Finnish` and will not need
    to prepend the command with the variable setting. Using `flags` is a common way
    of passing in variables to servers at runtime. More often than not, you’ve used
    flags in other areas when starting an application. Any time you’ve done `./foo
    -h`, you’ve passed an `h` flag to the service, indicating you want help with that
    application. We will add a flag to set the port, which is a common feature most
    servers provide.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，用户可能希望更明确地注入变量。这在切换环境时很有用，因为环境变量可以使用`export`命令存储在会话中，例如`DEFAULT_LANGUAGE=Finnish`，并且不需要在命令前加上变量设置。使用`flags`是在运行时向服务器传递变量的常见方式。通常情况下，你在启动应用程序时在其他区域使用了标志。每次你执行`./foo
    -h`时，你都会向服务传递一个`h`标志，表示你需要该应用程序的帮助。我们将添加一个标志来设置端口号，这是大多数服务器提供的常见功能。
- en: 'To do this, we will create a `LoadConfiguration` function that will tie all
    of our configuration pieces together (see the following listing). We will layer
    our configuration, so pay attention to which variables may be overwritten. In
    our configuration function, we will have the following order of operations:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将创建一个`LoadConfiguration`函数，将所有配置部分结合起来（见以下列表）。我们将分层配置，请注意哪些变量可能会被覆盖。在我们的配置函数中，我们将按照以下操作顺序进行：
- en: Use the default configuration.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认配置。
- en: Load a file if provided.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果提供了文件，则加载文件。
- en: Use environmental variables.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用环境变量。
- en: Use flags.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标志。
- en: Listing 8.8 `core.go`
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.8 `core.go`
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Adds flag and description of flag
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加标志及其描述
- en: ❷ Processes flags
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 处理标志
- en: ❸ Checks to see if a file is passed in
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查是否传入了文件
- en: ❹ Loads environmental variables
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 加载环境变量
- en: ❺ Checks to see if the port value is set and not empty
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查端口号是否已设置且不为空
- en: ❻ Parses our port to make sure it’s valid
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 解析端口号以确保其有效
- en: We have built a system that allows you to change the functionality without changing
    the code itself. You can imagine larger files with more configurations available
    to hide features that are under development or change functionality without needing
    to rebuild. This is a powerful tool that can be used by your team to help build
    a robust product.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了一个系统，允许你更改功能而不需要更改代码本身。你可以想象更大的文件，其中包含更多配置，可以用来隐藏开发中的功能或更改功能，而无需重新构建。这是一个强大的工具，可以由你的团队用来帮助构建一个健壮的产品。
- en: 8.3 Hiding features
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 隐藏功能
- en: Next time you are in your car, look at the steering wheel and the dashboard.
    Do you notice any pieces of plastic that look as though a button could go there?
    These are known as *blanks* and are for different types of car packages. This
    means that the same steering wheel or console can be made for all types of cars,
    but only specific cars will have buttons for those features, as shown in figure
    8.1\. An example is a button for managing heated seats. If you bought a basic
    car, this would be blank, but if you bought the luxury package, it would be there.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下次你坐在车里时，看看方向盘和仪表盘。你是否注意到任何看起来像按钮可以放置的塑料部件？这些被称为*空白*，用于不同类型的汽车包。这意味着同一款方向盘或控制台可以适用于所有类型的汽车，但只有特定车型会配备那些功能的按钮，如图8.1所示。例如，一个用于管理加热座椅的按钮。如果你购买了一款基础车型，这将是空白，但如果你购买了豪华包，它就会在那里。
- en: '![](../../OEBPS/Images/CH08_F01_Holmes4.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH08_F01_Holmes4.png)'
- en: Figure 8.1 Plastic fills expansion slots in various vehicle models.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 不同车型中的塑料填充扩展槽。
- en: This is a form of feature flagging, wherein you can build something the same
    way but adapt to which features are available to customers. This practice can
    be used to hide features from users who haven’t paid for them (free versus paid
    tier), features that are still under development, or features you want to roll
    out to only a few customers for testing.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种功能标志的形式，你可以以相同的方式构建，但适应客户可用的功能。这种做法可以用来隐藏未付费用户（免费与付费层）的功能、仍在开发中的功能，或者你只想对少数客户进行测试的功能。
- en: Now that you’ve built the ability to change your configuration, let’s update
    our code to use it. Here, we will explore modifying our application as well as
    modifying our service. In it, you will also find how this will relate to and be
    used with our dependency injection. To start, we will adjust our port number,
    and then we’ll move on to updating our client and storage code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经构建了更改配置的能力，让我们更新我们的代码来使用它。在这里，我们将探索修改我们的应用程序以及修改我们的服务。在其中，你还将找到它是如何与我们依赖注入相关联并使用的。首先，我们将调整我们的端口号，然后我们将继续更新我们的客户端和存储代码。
- en: 8.3.1 Updating the port
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 更新端口
- en: Since we have built our configuration struct, we now need to load it in our
    main method. To do this, we will simply call our `LoadConfiguration` method. Once
    we have the configuration, we can start using it in constructing our main function
    in our main binary, and not our function for simplicity. That being said, all
    of the configuration changes we explore can also be attached to our function or
    whatever application we are writing. Let’s see what updating our port number in
    our `cmd/main.go` file looks like in the following listing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经构建了我们的配置结构体，我们现在需要在主方法中加载它。为此，我们将简单地调用我们的 `LoadConfiguration` 方法。一旦我们有了配置，我们就可以开始在主二进制文件中的主函数中使用它，而不是我们的函数，以简化操作。也就是说，我们探索的所有配置更改也可以附加到我们的函数或我们正在编写的任何应用程序上。让我们看看在以下列表中更新我们的
    `cmd/main.go` 文件中的端口编号看起来是什么样子。
- en: Listing 8.9 `core.go`
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 `core.go`
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Loads our configuration
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载我们的配置
- en: ❷ Replaces the hardcoded string with the configuration port
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用配置端口替换硬编码的字符串
- en: 'Now let’s test these different configuration changes. First, create a configuration
    JSON file called `config.json`. It should look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试这些不同的配置更改。首先，创建一个名为 `config.json` 的配置 JSON 文件。它应该看起来像这样：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that we are missing some fields. This is okay since we handle the default
    values as part of the loading of the file. Let’s run through some different tests
    to see our configuration in action:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们缺少一些字段。这是可以的，因为我们把默认值作为文件加载的一部分来处理。让我们运行一些不同的测试，看看我们的配置是如何起作用的：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Great! Now let’s test our ENV var, which can be set in several ways on Unix-like
    systems. One way is to use the `export` variable, which is then stored in the
    session. The alternative way is to set the variable before the command. Here is
    an example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在让我们测试我们的环境变量（ENV var），它可以在类 Unix 系统的几种方式下设置。一种方式是使用 `export` 变量，然后它被存储在会话中。另一种方式是在命令之前设置变量。以下是一个示例：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice how the ENV variable is now taking precedence over the config file.
    Finally, we can test the port flag:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在环境变量（ENV）正在优先于配置文件。最后，我们可以测试端口标志：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All three ways of configuring our system are working. At this point, we can
    move on to using our configuration to change our connections to external services.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置系统的三种方式都在正常工作。在这个时候，我们可以继续使用我们的配置来更改我们与外部服务的连接。
- en: 8.3.2 External client
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 外部客户端
- en: In chapter 6, we explored dependency injection and interfaces. In that chapter,
    we built a static client and remote client. Here, we will decide which client
    to load based on whether the client URL is set in our configuration. To do this,
    let’s again open our `cmd/main.go` file and add the code in the following listing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 章，我们探讨了依赖注入和接口。在第 6 章中，我们构建了一个静态客户端和远程客户端。在这里，我们将根据配置中是否设置了客户端 URL 来决定加载哪个客户端。为此，让我们再次打开我们的
    `cmd/main.go` 文件，并添加以下列表中的代码。
- en: Listing 8.10 `main.go`
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 `main.go`
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Creates a variable that is of the type of the interface to pass into the handler
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个变量，其类型为接口，以便传递到处理器中
- en: ❷ By default, creates the static service
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 默认情况下创建静态服务
- en: ❸ If the legacy endpoint is set, creates a new client
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果设置了旧端点，则创建一个新的客户端
- en: ❹ Inserts that client into the creation of a remote service
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将客户端插入到远程服务的创建中
- en: ❺ Injects the service into the handler
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将服务注入到处理器中
- en: You should see that we are using our interface to help load the client we want
    and pass it into our handler. Again, we can change the environmental variables
    to affect the client endpoint. Setting it will allow you to call an external service.
    In this case, if we pass in the URL `http://hello-api.joelholmes.dev` and call
    the endpoint, we should hopefully see it respond with a valid response.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到我们正在使用我们的接口来帮助我们加载我们想要的客户端，并将其传递到我们的处理器中。同样，我们可以更改环境变量来影响客户端端点。设置它将允许你调用外部服务。在这种情况下，如果我们传递
    URL `http://hello-api.joelholmes.dev` 并调用端点，我们希望看到它以有效的响应响应。
- en: We still have some different features to build out, such as a persistent storage
    backend (e.g., a database), but we’ll handle them in the next chapter. We also
    did not incorporate the default language into our handler. I’m going to leave
    that up to the reader to handle.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些不同的功能需要构建，例如持久化存储后端（例如，数据库），但我们将它们留到下一章来处理。我们也没有将默认语言集成到我们的处理器中。我将把这个留给读者来处理。
- en: Now we have something we can pass off to our QA folks to test while we move
    forward with our development. We can continuously deploy our application with
    minor bug fixes and changes without affecting the overall system. Testing can
    now occur in parallel with development, and only after we feel that everything
    is working as planned can we release it. But now we are facing a new potential
    problem. With bugs being fixed and features being developed, how can we know what
    version of our software we are testing or releasing? How can we communicate this
    to our users and team members?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些东西可以交给我们的质量保证团队进行测试，同时我们继续我们的开发工作。我们可以持续部署我们的应用程序，进行小的错误修复和变更，而不影响整体系统。现在测试可以与开发并行进行，只有在我们觉得一切按计划进行时，我们才能发布。但现在我们面临一个新的潜在问题。随着bug的修复和功能的开发，我们如何知道我们正在测试或发布的软件版本是什么？我们如何将这个信息传达给我们的用户和团队成员？
- en: 8.4 Semantic versioning
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 语义版本控制
- en: 'To communicate with others what software version they are using, we will use
    two tools: versioning and a change log. Every time you update the software, you
    should notice that a special indicator is given about the software version being
    installed. The most common way of doing this is called *semantic versioning*.
    Figure 8.2 shows an example.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与他人沟通他们使用的软件版本，我们将使用两个工具：版本控制和变更日志。每次更新软件时，你应该注意到有一个特殊的指示器来显示正在安装的软件版本。最常见的方法被称为*语义版本控制*。图8.2展示了示例。
- en: '![](../../OEBPS/Images/CH08_F02_Holmes4.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F02_Holmes4.png)'
- en: Figure 8.2 iPhone software version
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 iPhone软件版本
- en: Now that we are releasing a product, it is important to indicate to users which
    version they should be using. Often, developers like to be on the bleeding edge
    of releases because some new features and problems have been fixed. However, this
    means you are on the bleeding edge of bugs as well. Software versioning solves
    this problem.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在发布一个产品，向用户指明他们应该使用哪个版本非常重要。通常，开发者喜欢处于发布的最前沿，因为一些新功能和问题已经被修复。然而，这也意味着你处于bug的最前沿。软件版本控制解决了这个问题。
- en: These releases often look like v1.2.3, 1.2.3-e5ad2, or 1.2.3-alpha. This is
    to indicate some information about the stability of the software along with the
    compatibility of the changes. Releases with a partial hash (e5ad2 above) or a
    Greek letter (alpha, beta, etc.) are often known as *developer builds*, which
    indicate they are not quite ready for everyone to use. A released software version
    typically has a structure like the one shown in figure 8.3.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些发布通常看起来像v1.2.3、1.2.3-e5ad2或1.2.3-alpha。这是为了表明关于软件稳定性和变更兼容性的信息。带有部分哈希（如上方的e5ad2）或希腊字母（alpha、beta等）的发布通常被称为*开发者构建*，这表明它们尚未准备好供所有人使用。发布的软件版本通常具有如图8.3所示的架构。
- en: '![](../../OEBPS/Images/CH08_F03_Holmes4.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F03_Holmes4.png)'
- en: Figure 8.3 Semantic versioning helps distinguish between large, possibly breaking,
    changes and minor fixes. The usage of this is up to the discretion of the team
    and should be communicated to consumers of products, as they may be dependent
    on certain features.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 语义版本控制有助于区分大型可能破坏性的变更和较小的修复。这种使用的决定权在于团队，并且应该与产品的消费者沟通，因为他们可能依赖于某些功能。
- en: As you can see, things such as “major” and “minor” changes are very subjective.
    The most important thing to focus on is breaking functionality. If an endpoint
    is removed or a method call is redefined, that is most likely a change in the
    major version, while a bug fix or feature may be a minor or patch fix.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，像“主要”和“次要”这样的变化非常主观。最重要的是关注破坏性功能。如果一个端点被移除或方法调用被重新定义，那么这很可能是主要版本的变更，而错误修复或新功能可能只是小版本或补丁修复。
- en: Git tags are a great way of communicating these kinds of changes and a way for
    us to integrate them into our release strategy. We want to constantly integrate
    but may not be ready to always release to the public, so we add special rules
    to our build process if a tag is pushed versus when we push small changes. In
    later chapters, we will construct a deployment process that supports the latest
    development build and a release to our production system.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签是传达这类变化和将它们整合到我们的发布策略中的绝佳方式。我们希望不断整合，但可能并不总是准备好向公众发布，因此，当推送标签与推送小更改时，我们在构建过程中添加了特殊规则。在后面的章节中，我们将构建一个支持最新开发构建和向生产系统发布的部署流程。
- en: Some APIs provide what is known as an `/info` endpoint to help communicate the
    product version to the developers and the users. An `/info` endpoint is extremely
    helpful when someone is trying to see if a release was successful or where a bug
    may have been introduced. Let’s add one to our application. In the `handlers`
    directory, create an `info.go` file (see the following listing).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 API 提供了所谓的 `/info` 端点，以帮助向开发人员和用户传达产品版本。当有人试图查看发布是否成功或可能引入了哪些错误时，`/info`
    端点非常有用。让我们在我们的应用程序中添加一个。在 `handlers` 目录中，创建一个 `info.go` 文件（见以下列表）。
- en: Listing 8.11 `info.go`
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 `info.go`
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ These are variables that will be set through the compilation process. We want
    these values to be linked to the binary instead of read through an environment
    variable because it should be associated with the binary itself.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这些变量将通过编译过程设置。我们希望这些值与二进制文件链接，而不是通过环境变量读取，因为它们应该与二进制文件本身相关联。
- en: ❷ Maps the values to the response
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将值映射到响应
- en: Let’s add this handler to the `main.go` file (see the following listing).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此处理程序添加到 `main.go` 文件中（见以下列表）。
- en: Listing 8.12 `main.go`
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.12 `main.go`
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Just like the health check, we need to add this handler to our service, but
    this time at the info endpoint.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 就像健康检查一样，我们需要将此处理程序添加到我们的服务中，但这次是在信息端点。
- en: Now we need to pass values to these variables through our build command. The
    information we are passing is the most recent tag information, the hash, and the
    build date. This can help us determine the exact change that occurred based on
    the hash and the general time since it has been released based on the build date.
    To populate these fields, we need to update our build process. Open your Makefile,
    and edit the `build` command to add some additional flags (see the following listing).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要通过我们的构建命令将这些值传递给这些变量。我们传递的信息是最新的标签信息、哈希值和构建日期。这可以帮助我们根据哈希值确定确切发生的变化，并根据构建日期确定自发布以来的一般时间。为了填充这些字段，我们需要更新我们的构建过程。打开你的
    Makefile，并编辑 `build` 命令以添加一些额外的标志（见以下列表）。
- en: Listing 8.13 Makefile
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.13 Makefile
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ We use the git command to get the most recent tag version from our repo and
    store it as a variable.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们使用 git 命令从我们的存储库获取最新的标签版本并将其存储为变量。
- en: ❷ We use the git command to get the most recent hash from our repo and store
    it as a variable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们使用 git 命令从我们的存储库获取最新的哈希值并将其存储为变量。
- en: ❸ We use the shell to grab the current timestamp of the build to help us determine
    how long it’s been since a deployment.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们使用 shell 获取构建的当前时间戳，以帮助我们确定自上次部署以来已经过去了多长时间。
- en: ❹ We combine all of these values into build flags that target variables in the
    handler package we defined so that they are embedded in the binary.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们将这些值组合成构建标志，这些标志针对我们定义的处理程序包中的变量，以便它们嵌入到二进制文件中。
- en: ❺ Adding the ldflags adds the build flags we want to the go build command.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 添加 ldflags 将我们想要的构建标志添加到 go build 命令中。
- en: 'Type `make build`, run your application using `./api`, and call the `/info`
    endpoint by using the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `make build`，使用 `./api` 运行你的应用程序，并通过以下方式调用 `/info` 端点：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You should see the results come back with the information populated. Since we
    made the change to the `build` command in the Makefile, we don’t need to make
    any changes to our pipeline to support this feature. What we do want to do is
    create a release only if our repository is tagged. Open your pipeline file again,
    and add a special rule to only do a release when we push a tag, as in the following
    listing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到带有填充信息的结果返回。由于我们在 Makefile 中的 `build` 命令进行了更改，我们不需要对我们的管道进行任何更改以支持此功能。我们真正想要做的是，只有当我们的存储库被标记时才创建发布。再次打开你的管道文件，并添加一个特殊规则，只在推送标签时进行发布，如下所示。
- en: Listing 8.14 `pipeline.`yml
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.14 `pipeline.`yml
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ We want to run our build on tags as well as pushes to the main branch.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们希望在我们的构建上运行标签以及向主分支的推送。
- en: ❷ Only run this step if it is being tagged.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 只有在标记时才运行此步骤。
- en: 8.5 Change log
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 更新日志
- en: Now that we are capturing various versions, we should have a better description
    of the changes between the release. We can automate this process by using a tool
    that will look at the commit messages we make and add them to the body of the
    release. This is great because it forces us to remember that the messages we write
    will be read by others. We will enhance this in future chapters, but let’s get
    the basics in place now. We need to edit the `deliver` section of our pipeline
    (see the following listing).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在捕获各种版本，我们应该对发布之间的变化有一个更好的描述。我们可以通过使用一个工具来自动化此过程，该工具将查看我们做出的提交信息并将它们添加到发布体中。这很好，因为它迫使我们记住我们写的消息将被其他人阅读。我们将在未来的章节中增强这一点，但现在让我们先建立基础。我们需要编辑我们的管道（`deliver`部分）（见以下列表）。
- en: Listing 8.15 `pipeline.`yml
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.15 `pipeline.`yml
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Uses this library to automatically create a Changelog to append to the release
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用此库自动创建一个更新日志以附加到发布
- en: ❷ Adds the output of the library to the body of the release
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将库的输出添加到发布体的内容中
- en: ❸ Makes these releases official by resetting the draft to false and release
    to false
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过将草稿重置为false和发布为false来使这些发布正式化
- en: 'Commit your changes and push them. Then we will tag our release with the `v0.0.1`
    release:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 提交您的更改并推送它们。然后我们将使用`v0.0.1`发布标记我们的发布：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Check your releases now, and you can see `v0.0.1` has been released! Download
    the file, and test to see if your info endpoint works. Now go to your deployment,
    and call the info endpoint. What do you see? Hopefully, you can see the version
    as well as some other information required to identify the build.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查您的发布，您可以看到`v0.0.1`已经发布！下载文件，并测试您的信息端点是否工作。现在转到您的部署，并调用信息端点。您看到了什么？希望您可以看到版本号以及识别构建所需的一些其他信息。
- en: 'When you look at the release, there should be a description that reflects the
    commit messages you’ve been writing. This becomes another location for accountability
    on the part of you and your teammates. Just as comments such as “updated text”
    aren’t very helpful to developers, they also will not be helpful to your customers.
    Instead, you should consider putting a process in place of having effective comments
    that outline the changes you’ve done. A good example of this is “Corrected the
    spelling error on the About Page” or “Created new stub API endpoint for Issue
    #43” where Issue #43 refers to some internal ticketing system.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '当您查看发布时，应该有一个描述反映了您所写的提交信息。这成为您和您的队友责任感的另一个位置。就像“更新文本”这样的评论对开发者来说并不很有帮助，它们对您的客户也没有帮助。相反，您应该考虑建立一个流程，以拥有有效的评论，概述您所做的更改。一个很好的例子是“在关于页面更正了拼写错误”或“为问题
    #43 创建了新的API端点”，其中问题 #43 指的是某个内部票务系统。'
- en: By automating this process, you help build accountability and thoughtfulness
    into your work. The main goal of a team is to find a way to work together and
    communicate effectively. Through this process, your team will gain a level of
    resilience and independence to help them feel empowered to solve existing problems
    and handle new ones that arise. This does not happen overnight but is a culture
    you need to help create.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自动化此过程，您有助于将责任感和周密性融入您的工作中。团队的主要目标是找到一种有效合作和沟通的方式。通过这个过程，您的团队将获得一定的弹性和独立性，以帮助他们感到有力量解决现有问题并处理出现的新问题。这不会一夜之间发生，但这是一个需要帮助创建的文化。
- en: 8.6 Accountability and handling failure
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 责任感和处理失败
- en: Mistakes are going to happen. They happen to every person and every team. Companies
    will often see a mistake as a failure in process or people and will add additional
    constraints and extend deployment timelines to be sure there aren’t any bugs or
    problems. Teams will be created to ensure the quality of a product before it is
    shipped, often leading to longer and longer lead times (deployment timelines).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是会发生的。每个人和每个团队都会遇到错误。公司通常会认为错误是流程或人员方面的失败，并会添加额外的约束并延长部署时间表以确保没有错误或问题。团队将被创建以确保产品在发货前的质量，这通常会导致越来越长的提前期（部署时间表）。
- en: But let’s consider the alternative. What if we accepted a failure-tolerant culture,
    that mistakes are going to happen no matter what we do? How does our culture change?
    Who finds the problems, and who solves them? How quickly can we fix them, and
    how can we learn from our mistakes?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们考虑一下替代方案。如果我们接受了一种容错文化，即无论我们做什么错误都会发生，我们的文化会如何改变？谁会发现问题，谁会解决它们？我们能够多快地修复它们，我们如何从错误中学习？
- en: This mindset is what Kent Beck often refers to as “bravery” in his various programming
    books. He describes putting processes in places such as automated testing, code
    standardization, pair programming, and many more to allow for fast development
    practices that rely on “brave” developers to be able to confront problems that
    may arise. Toyota has a similar process where anyone on an assembly line has the
    opportunity to stop all production by pulling what is called the “andon cord.”
    This simple process halts the line and triggers a light to indicate where the
    problem is located. Then everyone will swarm to that spot to see what the problem
    is, solve the problem, and learn.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种心态是肯特·贝克在他的各种编程书籍中经常提到的“勇气”。他描述了在自动化测试、代码标准化、结对编程等多个地方放置流程，以允许快速的开发实践，这些实践依赖于“勇敢”的开发者能够面对可能出现的问题。丰田有一个类似的过程，任何在生产线上的员工都有机会通过拉动被称为“andon线”的东西来停止所有生产。这个简单的流程会停止生产线并触发一个灯来指示问题所在的位置。然后，每个人都会涌向那个地方，看看问题是什么，解决问题，并从中学习。
- en: This process of learning from a problem allows the organization as a whole to
    think about mitigating problems in the future and participating in the feedback
    cycle established within its culture. This is known as a *generative culture*,
    where the organization prioritizes improvement in capacity, quality, and innovation.
    How does this compare to the risk-averse culture described before? Surely everyone
    means well in extending timelines and adding special teams to ensure quality.
    If we compare the generative culture to a *bureaucratic culture*, we see small
    differences. Where generative organizations investigate failure, bureaucratic
    organizations look for who caused the problem. Generative cultures provide freedom
    to their employees to make and improve the company and its processes, while bureaucratic
    cultures restrict responsibilities and silo groups from helping each other improve.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种从问题中学习的过程使整个组织能够思考未来减轻问题的方法，并参与其文化内部建立的反馈循环。这被称为*生成式文化*，其中组织优先考虑提高能力、质量和创新。这与之前描述的风险规避文化相比如何？当然，每个人在延长时间表和添加特殊团队以确保质量时都是出于好意。如果我们把生成式文化与*官僚主义文化*进行比较，我们会看到一些小的差异。在生成式组织中，组织会调查失败，而官僚主义组织则会寻找导致问题的人。生成式文化为其员工提供自由，让他们改进公司和其流程，而官僚主义文化则限制责任和孤岛团队之间的相互改进。
- en: Ron Westrum studied various organizations and created this typology model. His
    findings were that generative cultures can mitigate risks and increase organizational
    safety. In the development world, this means fewer bugs and major outages happening
    in production. If a problem occurs, the organization will learn from it and find
    ways to make sure it doesn’t happen again without restricting others’ abilities
    to contribute. In table 10.1, you can see a breakdown of the two distinct types
    of company cultures.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 朗·韦斯特鲁姆研究了各种组织并创建了这一类型模型。他的发现是，生成式文化可以减轻风险并提高组织的安全性。在开发世界中，这意味着在生产中发生的错误和重大故障会减少。如果出现问题，组织将从中学习并找到确保它不再发生的方法，而不会限制他人贡献的能力。在表10.1中，你可以看到两种不同公司文化的分解。
- en: Table 8.1 Types of company cultures
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 公司文化类型
- en: '| Bureaucratic | Generative |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 官僚主义 | 生成式 |'
- en: '| Information may be ignored. | Information is actively sought. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 信息可能会被忽视。 | 信息是被积极寻求的。 |'
- en: '| Messengers are tolerated. | Messengers are trained. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 传信者是被容忍的。 | 传信者是被培训的。 |'
- en: '| Responsibilities are compartmentalized. | Responsibilities are shared. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 责任被分割。 | 责任是被共享的。 |'
- en: '| Bridging between teams is allowed but discouraged. | Bridging between teams
    is rewarded. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 团队间的桥梁是允许的，但被劝阻。 | 团队间的桥梁是被奖励的。 |'
- en: '| Organization is just and merciful. | Failure causes inquiry. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 组织是公正而仁慈的。 | 失败会引起调查。 |'
- en: '| New ideas create problems. | New ideas are encouraged. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 新想法会引发问题。 | 新想法是被鼓励的。 |'
- en: What does this mean for our development team?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们开发团队意味着什么？
- en: As an organization, you need to create a generative culture for your developers
    that gives them the ability to move fast but learn from mistakes. Give a voice
    to everyone in the organization to express concerns, and try to solve problems
    as they arise. Do “blameless postmortem” meetings to help find the root cause
    and invest in improving your process. Everyone should have a voice about technical
    problems as well as team dynamics and improvements.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一家组织，你需要为你的开发者创造一个生成性文化，让他们能够快速行动，同时从错误中学习。让组织中的每个人都能够表达担忧，并尝试在问题出现时解决它们。进行“无责后事”会议，以帮助找到根本原因并投资于改进你的流程。每个人都应该对技术问题以及团队动态和改进有发言权。
- en: Since we are building tools and pipelines to move our code from implementation
    to running in production, we can use our pipeline to add more checks, guards,
    and analysis to our code before it goes to production. We can focus on making
    deployments so seamless that we can patch bugs quickly and efficiently as they
    happen or provide the ability to roll back our changes by reverting our code and
    redeploying a previous version.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在构建工具和管道，将我们的代码从实现转移到在生产中运行，我们可以在代码进入生产之前使用我们的管道添加更多的检查、守卫和分析。我们可以专注于使部署尽可能无缝，以便快速高效地修复发生的错误，或者提供通过回滚我们的代码和重新部署先前的版本来回滚更改的能力。
- en: The final and most important step is the visibility of problems as they occur.
    When a build or deployment fails, it becomes the responsibility of everyone on
    the team to not point fingers. This should be done through some alert system (email,
    Slack message, throwing a rubber chicken). The team should be able to solve the
    problem and resolve the build and deployment process before any additional work
    is done. Once the problem is resolved, work can continue. What is important is
    that just like at Toyota, everyone learns from the experience and thinks of ways
    to improve the system.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后也是最重要的一步是问题的可见性。当构建或部署失败时，这成为团队中每个人的责任，不要指手画脚。这应该通过某种警报系统（电子邮件、Slack消息、扔一个橡皮鸡）来完成。团队应该能够在任何额外工作开始之前解决问题并解决构建和部署流程。一旦问题得到解决，工作就可以继续。重要的是，就像在丰田一样，每个人都从经验中学习，并思考如何改进系统。
- en: If you have the capacity on your team, having someone monitor and gather metrics
    about your process and system can create a great feedback mechanism for finding
    areas to improve. Situations like flaky tests, long build times, frequent build
    failures, and dependency timeouts can be the result of poorly written tests, a
    slow build server, a bad development environment, and the need for artifact caching.
    But you will not know that these problems are there or how they should be prioritized
    if you aren’t gathering metrics and talking to your team.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你团队有这个能力，让某个人监控和收集关于你的流程和系统的指标，可以创建一个很好的反馈机制，以找到需要改进的领域。像易出错的测试、长的构建时间、频繁的构建失败和依赖超时等情况可能是由于编写糟糕的测试、缓慢的构建服务器、糟糕的开发环境以及需要工件缓存造成的。但如果你不收集指标并与你的团队交谈，你就不会知道这些问题是否存在或应该如何优先处理。
- en: As you type away in your editor, you hear the ding of your email. You stop,
    open it, and read the following from the QA team, “I saw you just released an
    update of the software that integrates with our existing API. The document says
    I can test this locally, and I assume it’s not running in production. This is
    pretty great! Any chance you can start implementing something similar with a database?
    It would be great to start moving in that direction with the product. Thanks!”
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在编辑器中键入时，你听到了你电子邮件的滴答声。你停下来，打开它，并阅读来自QA团队的以下内容：“我看到你刚刚发布了一个与我们的现有API集成的软件更新。文档说我可以本地测试这个，我假设它还没有在生产中运行。这真是太好了！有没有可能开始实施类似的功能与数据库？开始朝着这个方向推进产品会很好。谢谢！”
- en: You smile. It looks like you’ve convinced them you can develop hidden features
    without affecting your system. Time to start planning the database.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你微笑着。看起来你已经说服了他们你可以在不影响系统的情况下开发隐藏功能。是时候开始规划数据库了。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Configuration allows you to modify an application’s function without changing
    its code.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置允许你修改应用程序的功能，而无需更改其代码。
- en: Configuration combined with dependency injection can allow you to hide incomplete
    or untested features.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置与依赖注入相结合可以允许你隐藏不完整或未测试的功能。
- en: Semantic versioning communicates the scale of changes to a system.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义版本控制传达了系统变化的规模。
- en: Change logs provide a synopsis of the work that has been completed.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更日志提供了已完成工作的概述。
- en: Generative cultures allow for growth and change within an organization.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成性文化允许组织内部进行成长和变化。
