- en: 3 Using built-in data containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 使用内置数据容器
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Choosing lists over tuples and vice versa
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择列表而不是元组，反之亦然
- en: Sorting lists that consist of complex data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对由复杂数据类型组成的列表进行排序
- en: Using named tuples as a data container model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名元组作为数据容器模型
- en: Accessing a dictionary’s data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问字典的数据
- en: Understanding hashability and its implications for dictionaries and sets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解可哈希性和其对字典和集合的影响
- en: Applying set operations to manipulate nonset data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将集合运算应用于操作非集合数据
- en: As a general-purpose programming language, Python provides a range of built-in
    data types for different purposes, including collection types. These collection
    types of data serve as containers to hold integers, strings, instances of custom
    classes, and all other kinds of objects. In every project, we deal with multiple
    objects at the same time, and these scenarios often require data containers to
    handle these objects. Every modern language has data containers as its core data
    models, highlighting the importance of data containers as building blocks for
    any programming project. As you’ll see in chapter 14 when we build our task management
    app, we’ll use data containers for a variety of jobs, such as using a list to
    hold custom instances of the Task class (chapter 8). In this chapter, we’ll discuss
    the most common built-in data containers, including lists, tuples, dictionaries,
    and sets. Please note that this chapter isn’t intended to provide an exhaustive
    review of all the functionalities related to these data models. Instead, we’ll
    focus on essential topics that matter most in our projects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种通用编程语言，Python 为不同的目的提供了一系列内置数据类型，包括集合类型。这些数据类型的集合作为容器，用于存储整数、字符串、自定义类的实例以及所有其他类型的对象。在每一个项目中，我们同时处理多个对象，这些场景通常需要数据容器来处理这些对象。每种现代语言都有数据容器作为其核心数据模型，突显了数据容器作为任何编程项目构建块的重要性。正如你在第14章中构建任务管理应用时将看到的，我们将使用数据容器来完成各种工作，例如使用列表来存储任务类的自定义实例（第8章）。在本章中，我们将讨论最常见的一些内置数据容器，包括列表、元组、字典和集合。请注意，本章的目的不是提供与这些数据模型相关的所有功能的详尽审查。相反，我们将专注于对我们项目最重要的基本主题。
- en: Concept *Data containers*, such as lists and tuples, are objects that contain
    other objects. By contrast, strings and integers are not data containers, as they
    don’t contain other objects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 概念*数据容器*，如列表和元组，是包含其他对象的对象。相比之下，字符串和整数不是数据容器，因为它们不包含其他对象。
- en: 3.1 How do I choose between lists and tuples?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 我该如何在列表和元组之间进行选择？
- en: We often discuss lists and tuples together because of their similarity as data
    containers. Both can hold objects in an ordered fashion, and the objects are accessible
    through indexing. In many cases, we use them interchangeably. But some other cases
    may require us to pick one over the other. Suppose that you need a data container
    to store transaction records in a bank account. Should you use list or tuple?
    As another example, if you need to show a transaction’s information, such as its
    amount and date, should you use list or tuple?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表和元组作为数据容器具有相似性，我们经常将它们一起讨论。两者都可以以有序的方式存储对象，并且可以通过索引访问这些对象。在许多情况下，我们可以互换使用它们。但有些情况下可能需要我们选择其中之一。假设你需要一个数据容器来存储银行账户中的交易记录。你应该使用列表还是元组？作为另一个例子，如果你需要显示交易信息，例如金额和日期，你应该使用列表还是元组？
- en: There are numerous scenarios like these in which both options seem to be plausible,
    but we end up choosing one over the other. In this section, we’ll discuss the
    key distinguishing factors that guide our selection between lists and tuples.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类似的情况，其中两种选择似乎都是可行的，但最终我们选择了其中之一。在本节中，我们将讨论指导我们在列表和元组之间进行选择的关键区分因素。
- en: 3.1.1 Using tuples for immutability and using lists for mutability
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 使用元组实现不可变性和使用列表实现可变性
- en: 'One major difference between lists and tuples is *mutability.* Lists are mutable
    in such a way that we can modify the data of a list object: we can append new
    items to the end of a list, insert items into the middle, change the items, and
    remove items. To support this mutability, Python provides a series of methods
    in the list class, such as append, extend, and remove, and you should be familiar
    with them. Figure 3.1 shows these methods.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和元组之间的一大区别是*可变性*。列表是可变的，我们可以修改列表对象的数据：我们可以在列表的末尾添加新项，在中间插入项，更改项，以及删除项。为了支持这种可变性，Python
    在列表类中提供了一系列方法，如 append、extend 和 remove，你应该熟悉它们。图3.1显示了这些方法。
- en: '![CH03_F01_Cui](../Images/CH03_F01_Cui.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F01_Cui](../Images/CH03_F01_Cui.png)'
- en: Figure 3.1 Basic operations with lists as mutable objects
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 列表作为可变对象的基本操作
- en: Trivia Lists’ remove method deletes only the first matching item. When you’re
    removing an item that isn’t in the list, you encounter a ValueError.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 逸事：列表的 remove 方法仅删除第一个匹配的项。当你尝试删除列表中不存在的项时，你会遇到 ValueError。
- en: 'By contrast with lists, tuples are immutable; we can’t modify the data of a
    tuple object. To support this immutability feature and prevent any unnecessary
    confusion, Python has no methods to modify tuple objects. Changing a tuple’s items
    is syntactically possible, but such action results in exceptions: calling a nonexistent
    method leads to an AttributeError, and reassigning a tuple’s item leads to a TypeError,
    as the next listing shows.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表相比，元组是不可变的；我们无法修改元组对象的 数据。为了支持这种不可变特性并防止不必要的混淆，Python 没有任何修改元组对象的方法。修改元组的项在语法上是可能的，但这种操作会导致异常：调用不存在的方法会导致
    AttributeError，重新分配元组的项会导致 TypeError，如以下列表所示。
- en: Listing 3.1 Immutability of tuple objects
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 元组对象的不可变性
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Attempts to use a nonexistent method on the tuple object
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 尝试在元组对象上使用不存在的方法
- en: ❷ Attempts to assign a new value to a tuple’s item
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 尝试为元组的项分配新值
- en: 'Because of the mutability difference, you should use lists instead of tuples
    when you expect to update the data. For the task management app, we use lists
    to store the tasks because we add new tasks or remove old tasks. When you don’t
    change the stored data, you should use tuples, given their immutability. For the
    task app, we can use tuples to store a task’s metadata, such as creation time
    and user, because they are fixed. Although we can use lists where tuples are used,
    we prefer using tuples over lists in these cases for several reasons:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可变性的差异，当你期望更新数据时，你应该使用列表而不是元组。对于任务管理应用，我们使用列表来存储任务，因为我们添加新任务或删除旧任务。当你不更改存储的数据时，你应该使用元组，因为它们的不可变性。对于任务应用，我们可以使用元组来存储任务的元数据，如创建时间和用户，因为它们是固定的。尽管我们可以在元组的位置使用列表，但我们出于几个原因更喜欢在这些情况下使用元组：
- en: '*It prevents any unexpected changes to the data.* Attempting to change the
    tuples’ data would result in either an AttributeError or a TypeError (listing
    3.1).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它防止了数据发生任何意外变化。* 尝试更改元组的数据将导致 AttributeError 或 TypeError（列表 3.1）。'
- en: '*It makes clear our intention that the pertinent data should stay unchanged.*
    We use (creation_time, user) to store a task’s information instead of [creation_
    time, user] to signify that these two values are fixed.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它清楚地表明了我们的意图，即相关数据应保持不变。* 我们使用（creation_time, user）来存储任务信息，而不是[creation_time,
    user]，以表明这两个值是固定的。'
- en: '*Tuples are more memory-efficient than lists.* When a list and a tuple hold
    the same data, the list has a larger size than the tuple. The greater memory cost
    of lists results from extra overheads to support mutability. Thus, in situations
    that require many instances, we prefer using tuples because of their memory efficiency.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*元组比列表更节省内存。* 当列表和元组包含相同的数据时，列表的大小比元组大。列表更大的内存成本来自于支持可变性的额外开销。因此，在需要许多实例的情况下，我们更喜欢使用元组，因为它们的内存效率更高。'
- en: Trivia You can check an object’s memory usage by calling __sizeof__.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 逸事：你可以通过调用 __sizeof__ 来检查对象的内存使用情况。
- en: 3.1.2 Using tuples for heterogeneity and using lists for homogeneity
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 使用元组实现异质性和使用列表实现同质性
- en: We can store any data types in lists and tuples. When the items are of different
    types, or when the items hold the same type but with distinct information, we
    say that they’re *heterogeneous* from the semantic perspective. Consider a real-life
    object—say, a box. The information related to the box can include the size, material,
    and color. This information is heterogeneous, as it represents different aspects
    of the box’s characteristics. When the items are of the same type—or, more strictly,
    when the data refers to the same kind of information—we say that they’re *homogeneous.*
    When you move your home, for example, you may use multiple boxes. These boxes
    are homogeneous because they represent the same kind of objects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在列表和元组中存储任何数据类型。当项是不同类型时，或者当项具有相同的类型但具有不同的信息时，我们说它们在语义上是*异质的*。考虑一个现实生活中的对象——比如说，一个盒子。与盒子相关的信息可以包括大小、材料和颜色。这些信息是异质的，因为它们代表了盒子特性的不同方面。当项是同一类型的时候——或者更严格地说，当数据指的是同一种信息时——我们说它们是*同质的*。例如，当你搬家时，你可能使用多个盒子。这些盒子是同质的，因为它们代表了同一种对象。
- en: Lists and tuples can hold both heterogeneous and homogeneous data. Does that
    fact mean that we give lists and tuples no preference? Certainly, the major determinant
    is the mutability requirement for the data, as discussed in section 3.1.1\. Butwhen
    mutability is a lesser concern, you should use data’s homogeneity to guide your
    choice.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和元组可以存储异质和同质数据。这个事实是否意味着我们对列表和元组没有偏好？当然，主要决定因素是数据对可变性的要求，如第3.1.1节中讨论的那样。但当可变性不是主要关注点时，你应该使用数据的同质性来指导你的选择。
- en: 'Let’s consider a more concrete example in the task application. In section
    3.1.1, I mentioned that from the data-mutability perspective, it’s preferable
    to use a tuple (creation _time, user) to refer to a task’s metadata, as it consists
    of distinct pieces of information: when the task was created versus who created
    the task. You may hear people say that tuples are structural because each item
    carries independent information that contributes to the tuple object. As a result,
    tuples are the preferred data structure to hold semantically heterogeneous data.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个更具体的例子，在任务应用中。在第3.1.1节中，我提到，从数据可变性角度来看，使用元组（创建时间，用户）来引用任务的元数据是首选的，因为它由不同的信息组成：任务是在何时创建的以及谁创建了任务。你可能会听到人们说元组是结构性的，因为每个项都携带独立的信息，这些信息有助于元组对象。因此，元组是存储语义异质数据的首选数据结构。
- en: By contrast, the data stored in lists is semantically homogeneous*.* In the
    task application, the tasks belong to the same semantic category; thus, we should
    use lists to store tasks. By default, we can store the tasks based on the creation
    time in ascending order. Therefore, as shown in figure 3.2, a list is viewed as
    a linear data structure that holds homogeneous items.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，列表中存储的数据在语义上是同质的。在任务应用中，任务属于相同的语义类别；因此，我们应该使用列表来存储任务。默认情况下，我们可以根据创建时间按升序存储任务。因此，如图3.2所示，列表被视为一个线性数据结构，它包含同质项。
- en: '![CH03_F02_Cui](../Images/CH03_F02_Cui.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F02_Cui](../Images/CH03_F02_Cui.png)'
- en: Figure 3.2 Homogeneity of list items and heterogeneity of tuple items. Lists
    are often used to hold data of the same kind, termed *homogeneous data*. In the
    figure, we use a list to store multiple tasks. By contrast, tuples are often used
    to hold data with different meanings, termed heterogeneous data*.* As shown in
    the figure, we use a tuple to store the metadata of a task, which is fixed, distinct
    information.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 列表项的同质性和元组项的异质性。列表通常用于存储同种类型的数据，称为*同质数据*。在图中，我们使用列表来存储多个任务。相比之下，元组通常用于存储具有不同意义的数据，称为*异质数据*。如图所示，我们使用元组来存储任务的元数据，这些是固定且独特的信息。
- en: 3.1.3 Discussion
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 讨论
- en: From the readability perspective, using tuples to hold data gives readers a
    clear signal that the data isn’t changing. From the maintainability perspective,
    we prefer using tuples to avoid any accidental changes in the pertinent data if
    it’s expected to stay the same.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从可读性的角度来看，使用元组来存储数据给读者一个清晰的信号，表明数据不会改变。从可维护性的角度来看，我们更喜欢使用元组，以避免在预期保持不变的相关数据中发生任何意外的更改。
- en: I should note that tuples’ immutability doesn’t prevent you from changing their
    items’ data. If a tuple contains lists, such as numbers = ([1, 2], [1, 2]), it’s
    valid to change the inner lists, such as adding an item to the first list (numbers[0]
    .append(3)). This operation is valid because although we change the content of
    the inner object, the reference to the object stays the same. As you’ll see in
    chapter 10, we’ll make a distinction between objects and their references.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该指出，元组的不可变性并不能阻止你更改其项的数据。如果一个元组包含列表，例如numbers = ([1, 2], [1, 2])，那么更改内部列表（如向第一个列表添加一个项目numbers[0].append(3)）是有效的。这个操作是有效的，因为尽管我们改变了内部对象的内容，但对该对象的引用保持不变。正如你将在第10章中看到的，我们将区分对象及其引用。
- en: 3.1.4 Challenge
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.4 挑战
- en: Zoe works in a software company in the geography field. She’s building a location-based
    application, and we know that a place has a name, description, and coordinates
    (latitude and longitude). For the series of places that a user has visited, does
    she use list or tuple to store them? For each place, she needs a data model to
    host its coordinates. Should she choose list or tuple to store the latitude and
    longitude?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Zoe在一家地理领域的软件公司工作。她正在构建一个基于位置的应用程序，我们知道一个地方有一个名称、描述和坐标（纬度和经度）。对于用户访问的一系列地点，她应该使用列表还是元组来存储它们？对于每个地点，她需要一个数据模型来存储其坐标。她应该选择列表还是元组来存储纬度和经度？
- en: Hint Consider whether the stored data is mutable and/or homogeneous to help
    you make the decision.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 考虑存储的数据是否可变和/或同质，以帮助你做出决定。
- en: 3.2 How do I sort lists of complicated data using custom functions?
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 如何使用自定义函数对复杂数据的列表进行排序？
- en: Lists are sequence data (see chapter 4) whose order is determined by the insertion
    order. Because of the supported mutability, we often rearrange a list into orders
    other than the initial insertion order. Suppose that our project has a list object
    that holds tasks for a given day, as shown in the following listing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是序列数据（见第4章），其顺序由插入顺序决定。由于支持可变性，我们经常将列表重新排列成除了初始插入顺序之外的其他顺序。假设我们的项目有一个列表对象，它包含给定一天的任务，如下所示。
- en: Listing 3.2 A list object consisting of multiple dict objects
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 由多个字典对象组成的列表
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Suppose that we display the tasks in the order of their creation time or their
    urgency levels. As you’ll find out, if we sort this list of dictionaries, we’ll
    encounter a TypeError because Python doesn’t know how to compare dictionaries:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们按照任务的创建时间或紧急程度来显示任务。你会发现，如果我们对这个字典列表进行排序，我们会遇到一个TypeError，因为Python不知道如何比较字典：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this section, you’ll learn how to sort lists, particularly those consisting
    of complicated data (such as dict objects as opposed to integers and strings)
    with custom requirements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何排序列表，特别是那些由复杂数据（如与整数和字符串相比的字典对象）组成的列表，并具有自定义要求。
- en: 3.2.1 Sorting lists using the default order
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 使用默认顺序排序列表
- en: 'Because sorting lists is a common task, Python has a built-in method designed
    for sorting: the sort method. The next listing shows some simple examples of using
    sort.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于排序列表是一个常见任务，Python有一个内置的排序方法：sort方法。下面的列表显示了使用sort的一些简单示例。
- en: Listing 3.3 Sorting lists using the sort method
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 使用sort方法排序列表
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Sorts the numbers in place
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在原地排序数字
- en: ❷ Sorts the strings in place but requests that the order be reversed
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在原地排序字符串，但要求顺序反转
- en: Note that the sorting operation is conducted in place, meaning that sorting
    changes the order of the original list instead of creating a new list. Related
    to this in-place feature, sort returns None. Thus, in the interactive Python console,
    you don’t see any output after running numbers.sort() because None is automatically
    omitted for the output in the console. Another thing to note is that the default
    sorting order is ascending. If you specify the reverse parameter as True, you’ll
    get the list in descending order.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，排序操作是在原地进行的，这意味着排序改变了原始列表的顺序，而不是创建一个新的列表。与这个原地特性相关的是，sort返回None。因此，在交互式Python控制台中，运行numbers.sort()后你不会看到任何输出，因为None在控制台输出时自动省略。还有一点要注意的是，默认排序顺序是升序。如果你将reverse参数指定为True，你将得到一个降序的列表。
- en: Concept When we say that something happens to an object in place, it means that
    the process modifies the object itself. The sort method modifies the list object
    in place.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 当我们说某个对象发生了原地变化时，意味着这个过程修改了对象本身。sort方法就是修改列表对象本身。
- en: It seems that Python can’t sort a list containing different data types. In listing
    3.3, we encountered a TypeError when the list had integers, strings, and lists
    because by default, Python doesn’t know how to compare objects of different types.
    Is there any way to instruct Python to compare these objects? Section 3.2.2 discusses
    the answer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来Python不能对包含不同数据类型的列表进行排序。在列表3.3中，当列表包含整数、字符串和列表时，我们遇到了TypeError，因为默认情况下，Python不知道如何比较不同类型的对象。有没有办法让Python比较这些对象？第3.2.2节讨论了答案。
- en: 3.2.2 Using a built-in function as the sorting key
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 使用内置函数作为排序键
- en: Besides reverse, the sort method has a key parameter. As indicated by its name,
    this parameter provides a key to the sorting problem. Specifically, you should
    set key with a function, which produces a value from each item in the list. These
    derived values are used for comparison, and the derived order determines the order
    of the list’s items.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了reverse之外，sort方法还有一个key参数。正如其名所示，此参数为排序问题提供了一个键。具体来说，你应该使用一个函数来设置key，该函数从列表中的每个项目生成一个值。这些派生值用于比较，派生顺序决定了列表项的顺序。
- en: Trivia Not only the sort method has the key parameter. Some other functions,
    such as max and min, have the key parameter too. What you learn here can be applied
    to these functions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点 不仅sort方法有key参数。一些其他函数，如max和min，也有key参数。在这里学到的知识可以应用于这些函数。
- en: 'As mentioned at the end of section 3.2.1, Python doesn’t know how to compare
    between integers, strings, and lists. Notably, Python *does* know how to compare
    strings. Thus, a strategy for sorting data of different types is to convert it
    to strings by setting the key parameter:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如第3.2.1节末所述，Python不知道如何比较整数、字符串和列表。值得注意的是，Python *确实*知道如何比较字符串。因此，对不同类型数据进行排序的策略是将它们通过设置键参数转换为字符串：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the code, we use the str function (strictly, a class constructor; see section
    10.5) as the key argument, which converts each item to a string. Python sorts
    these strings as proxies, ['3', '1', '2', 'John', "['c', 'd']", "['a', 'b']"],
    producing ['1', '2', '3', 'John', "['a', 'b']", "['c', 'd']"]. Notably, each converted
    string is associated with its original object, and Python renders the sorted list
    with the raw items.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们使用str函数（严格来说是一个类构造函数；见第10.5节）作为键参数，它将每个项目转换为字符串。Python将这些字符串作为代理进行排序，['3',
    '1', '2', 'John', "['c', 'd']", "['a', 'b']"]，产生['1', '2', '3', 'John', "['a',
    'b']", "['c', 'd']"]。值得注意的是，每个转换后的字符串都与它的原始对象相关联，Python以原始项目渲染排序后的列表。
- en: 3.2.3 Using custom functions for more complicated sorting needs
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 使用自定义函数满足更复杂的排序需求
- en: Section 3.2.2 discussed how to use key to sort a list of objects of various
    types, but the example is too trivial to be useful in a real-life project. In
    listing 3.2, our task management app has a list object consisting of dict objects.
    In this section, you’ll see how to sort this kind of list object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第3.2.2节讨论了如何使用键对各种类型对象的列表进行排序，但示例过于简单，在现实项目中没有实际用途。在第3.2列表中，我们的任务管理应用有一个由字典对象组成的列表对象。在本节中，您将看到如何对这类列表对象进行排序。
- en: Although we can set str to key to make these dict objects comparable, the sorted
    list isn’t what we want; the objects are not ordered by their urgency levels.
    To address this need, we can create a custom function and set it to the key parameter,
    as the next listing shows.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以将str设置为键来使这些字典对象可比较，但排序后的列表并不是我们想要的；对象不是按其紧急程度排序的。为了满足这一需求，我们可以创建一个自定义函数并将其设置为键参数，如下一列表所示。
- en: Listing 3.4 Sorting tasks by setting a key
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 通过设置键对任务进行排序
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Each item of the list is sent to the function using_urgency_level. It’s important
    to note that this key function must take exactly one parameter, which corresponds
    to each item of the list object*.* This function extracts the tasks’ urgency levels
    according to which the sorting is conducted. Figure 3.3 shows the sorting process
    intuitively.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个项目都通过使用_urgency_level函数发送到函数。重要的是要注意，这个键函数必须恰好接受一个参数，它对应于列表对象的每个项目*.*
    此函数根据任务紧急程度提取任务紧急级别。图3.3直观地显示了排序过程。
- en: 'PEEK We can set key with a lambda function, an anonymous function created by
    using the lambda keyword. To obtain the same sorting result by using a lambda
    function, we could use tasks.sort(key=lambda x: x[''urgency''], reverse=True).
    We’ll discuss lambda functions in section 7.1.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'PEEK 我们可以使用lambda函数设置键，这是一个通过使用lambda关键字创建的匿名函数。为了使用lambda函数获得相同的排序结果，我们可以使用tasks.sort(key=lambda
    x: x[''urgency''], reverse=True)。我们将在第7.1节中讨论lambda函数。'
- en: '![CH03_F03_Cui](../Images/CH03_F03_Cui.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F03_Cui](../Images/CH03_F03_Cui.png)'
- en: Figure 3.3 The sorting process using a key function. A key function converts
    each item of the list to a corresponding value. The generated values will be used
    as intermediate items to sort the list. After the sorting, the original items
    are rendered in the order created by the intermediate items.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 使用键函数的排序过程。键函数将列表中的每个项目转换为相应的值。生成的值将用作排序列表的中间项目。排序后，原始项目将按照中间项目创建的顺序呈现。
- en: 3.2.4 Discussion
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 讨论
- en: The sort method works only with lists because it’s an instance method of lists.
    When we sort other container data types, such as tuples, sets, and dictionaries,
    we can use sorted, which can take any iterable and return a sorted list. You can
    specify a custom sorting function for sorted, too. Remember that the function
    to be set to the key argument should take exactly one parameter. When the function
    for the key argument performs a small operation, we should consider using a lambda
    function (see section 7.1).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: sort方法仅适用于列表，因为它列表的一个实例方法。当我们对其他容器数据类型进行排序，如元组、集合和字典时，我们可以使用sorted，它可以接受任何可迭代对象并返回一个排序后的列表。您也可以为sorted指定一个自定义排序函数。记住，要设置的键参数的函数必须恰好接受一个参数。当键参数的函数执行小操作时，我们应该考虑使用lambda函数（见第7.1节）。
- en: 3.2.5 Challenge
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.5 挑战
- en: In this chapter, you learned to sort tasks by using their urgency levels, as
    shown in listing 3.4\. Can you come up with a solution to order the tasks by their
    descriptions’ lengths? The longer the description is, the higher the task’s rank.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何根据任务的紧急程度对任务进行排序，如列表3.4所示。你能想出一个解决方案来根据任务描述的长度对任务进行排序吗？描述越长，任务的排名越高。
- en: Hint Custom sorting requires setting the key parameter in the sort function.
    The built-in function len can check the length of a string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：自定义排序需要在排序函数中设置key参数。内置函数len可以检查字符串的长度。
- en: 3.3 How do I build a lightweight data model using named tuples?
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 如何使用命名元组构建轻量级数据模型？
- en: The core of any project is data. If you’re building a social network app, the
    users and their connections are the data. If you’re building an e-commerce website,
    the merchandise and client information are the data. If you’re building a machine
    learning model, the features and targets are the data. For our task management
    app, we need to have a mechanism to process and handle task-related data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 任何项目的核心都是数据。如果你正在构建一个社交网络应用，用户及其连接就是数据。如果你正在构建一个电子商务网站，商品和客户信息就是数据。如果你正在构建一个机器学习模型，特征和目标是数据。对于我们的任务管理应用，我们需要有一个机制来处理和操作与任务相关的数据。
- en: If you come from an object-oriented programming (OOP) background, your intuitive
    response is probably to create custom classes to manage data. But it’s a nontrivial
    task to write a class. (You’ll learn best practices for creating a class in chapter
    8.) With the increasing complexity of our applications, we may have multiple classes
    to handle different aspects of the data flow. For simpler data models, named tuples
    can be a perfect solution, especially when our primary concern is to have a lightweight
    data model that is easy to use and holds data with little memory overhead.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自面向对象编程（OOP）的背景，你的直观反应可能是创建自定义类来管理数据。但是编写一个类是一个非平凡的任务。（你将在第8章中学习创建类的最佳实践。）随着我们应用程序的复杂性不断增加，我们可能需要多个类来处理数据流的各个方面。对于更简单的数据模型，命名元组可以是一个完美的解决方案，特别是当我们的主要关注点是拥有一个易于使用且内存开销小的轻量级数据模型时。
- en: 3.3.1 Understanding alternative data models
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 理解替代数据模型
- en: 'Before we build a data model using named tuples, it’s essential for us to know
    our options. In this section, we’re going to explore at least four other ways
    to manage the data: lists, tuples, dictionaries, and custom classes.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用命名元组构建数据模型之前，了解我们的选项是至关重要的。在本节中，我们将探讨至少四种其他管理数据的方法：列表、元组、字典和自定义类。
- en: 'To create a context, let’s say that each task in our application has the following
    pieces of information that we need to manage: title, description, and urgency
    level. The next listing shows what the data models look like using list, tuple,
    and dict.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个上下文，假设在我们的应用程序中，每个任务都有以下需要管理的信息：标题、描述和紧急程度。接下来的列表显示了使用列表、元组和字典的数据模型的样子。
- en: Listing 3.5 Using built-in data models for data management
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 使用内置数据模型进行数据管理
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Uses a list
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用列表
- en: ❷ Uses a tuple
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用元组
- en: ❸ Uses a dictionary
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用字典
- en: 'As shown in listing 3.5, these pieces of information are stored as individual
    items in list and tuple and as key-value pairs in dict. Besides using the built-in
    classes, we can create a custom class to store the data. You can find a skeleton
    of a custom class in the following code snippet (and no worries if you’re unfamiliar
    with defining custom classes; it’ll be covered in chapter 8):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表3.5所示，这些信息作为单独的项目存储在列表和元组中，作为键值对存储在字典中。除了使用内置类，我们还可以创建一个自定义类来存储数据。你可以在以下代码片段中找到一个自定义类的框架（如果你不熟悉定义自定义类，不用担心；它将在第8章中介绍）：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Although each approach is plausible in some scenarios, various drawbacks make
    them less ideal for our business need: a lightweight model to hold data.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在某种情况下每种方法都是可行的，但各种缺点使它们对我们的业务需求（一个轻量级的数据模型）不太理想。
- en: Lists are mutable, making them vulnerable to intentional and accidental changes.
    Section 3.1 also discussed that we usually use lists to hold homogenous data.
    Using a list to hold heterogeneous data isn’t a good idea. Although tuples are
    immutable, and we don’t worry about data changes, to retrieve an attribute such
    as title, we must use either the unpacking technique (section 4.4) or indexing
    (section 4.2). Neither technique is straightforward.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是可变的，这使得它们容易受到有意和无意的更改。第3.1节也讨论了，我们通常使用列表来存储同质数据。使用列表来存储异质数据不是一个好主意。尽管元组是不可变的，我们不必担心数据更改，但要检索如标题这样的属性，我们必须使用解包技术（第4.4节）或索引（第4.2节）。这两种技术都不简单。
- en: Lists and tuples don’t have meta information about what data they’re holding.
    A coworker who’s unfamiliar with the application won’t have any clues about the
    data model when they review your code. Compared with lists and tuples, dictionaries
    provide meta information, as the keys inform what the data is. To retrieve these
    attributes, however, we must use the corresponding keys (such as task_dict['title']).
    If we misspell the keys or miss a quote, we’ll encounter a KeyError or SyntaxError.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和元组没有关于它们所持数据的元信息。一个不熟悉应用程序的同事在审查你的代码时，对数据模型将没有任何线索。与列表和元组相比，字典提供了元信息，因为键说明了数据是什么。但是，要检索这些属性，我们必须使用相应的键（如task_dict['title']）。如果我们拼错了键或遗漏了引号，我们将遇到KeyError或SyntaxError。
- en: Lists, tuples, and dictionaries are generic types, and they have no ideas about
    the specifics of the data model. Thus, modern integrated development environments
    (IDEs) such as PyCharm and Visual Studio Code provide no useful autocompletion
    hints for these data structures, decreasing your coding efficiency. We can overcome
    this drawback by creating a custom class. When a Task instance is created, after
    we key in the instance and a dot, the available attributes (such as title and
    desc) are prompted automatically by your IDEs, facilitating coding speed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表、元组和字典是通用类型，它们对数据模型的特定信息一无所知。因此，现代集成开发环境（如PyCharm和Visual Studio Code）不会为这些数据结构提供有用的自动完成提示，这降低了你的编码效率。我们可以通过创建自定义类来克服这一缺点。当创建一个任务实例后，在输入实例和一个点之后，你的IDE会自动提示可用的属性（如标题和描述），从而加快编码速度。
- en: Concept An IDE provides comprehensive functionalities, such as autocompletion
    hints and real-time code analysis, to facilitate software development.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 一个集成开发环境（IDE）提供全面的功能，例如自动完成提示和实时代码分析，以促进软件开发。
- en: 'The solution of implementing a custom class can have a few complications, however:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 实现自定义类的解决方案可能会有一些复杂性：
- en: Creating a custom class requires a considerable amount of boilerplate, and for
    a simple data model such as a data holder, it is overkill to implement an entire
    custom class.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个自定义类需要相当多的样板代码，而对于像数据持有者这样的简单数据模型，实现整个自定义类是过度的。
- en: The memory cost is not negligible, particularly if you must deal with tons of
    instances.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存成本不容忽视，尤其是如果你必须处理大量的实例。
- en: Each instance of a custom class consumes more memory than an instance of named
    tuples, as discussed in section 3.3.2\. When our project evolves, we want our
    data model to do more things; we’ll move the lightweight data model to a fully
    equipped custom class (chapter 8).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如第3.3.2节所述，自定义类的每个实例比命名元组的实例消耗更多的内存。当我们的项目发展时，我们希望我们的数据模型能做更多的事情；我们将把轻量级的数据模型移动到一个完全装备的自定义类（第8章）。
- en: 3.3.2 Creating named tuples to hold data
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 创建命名元组以存储数据
- en: 'As indicated by the name, a named tuple is a kind of tuple. Named tuples are
    special because the items they hold have names associated with them. Unlike regular
    tuples, whose items are accessible by indices, named tuples support *dot notation*,
    accessing items just like accessing attributes of a custom class instance. We
    can observe these features in an example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，命名元组是一种元组。命名元组之所以特殊，是因为它们所持有的项与名称相关联。与通过索引访问项的常规元组不同，命名元组支持*点表示法*，就像访问自定义类实例的属性一样访问项。我们可以在以下示例中观察到这些功能：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Creates the named tuple class
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建命名元组类
- en: ❷ Creates an instance of the named tuple
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建命名元组的实例
- en: ❸ Accesses the instance’s attributes
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 访问实例的属性
- en: 'Note a few significant things about the named tuple technique:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意关于命名元组技术的一些重要事项：
- en: '*The instance of the named tuple has the advantage of accessing its attributes
    with dot notation.* It’s not only faster to code because of the autocompletion
    hints, but is also more readable, with a clean access pattern.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*namedtuple的实例具有使用点符号访问其属性的优势。这不仅因为自动完成提示而使编码更快，而且由于清晰的访问模式，也更易于阅读。*'
- en: '*The* namedtuple *is a factory function* *in the* collections *module**.* Because
    it’s a factory function, calling it returns a new class or a new instance object.
    In this case, we got the Task class.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*namedtuple是collections模块中的一个工厂函数*。因为它是一个工厂函数，所以调用它返回一个新的类或新的实例对象。在这种情况下，我们得到了Task类。'
- en: 'Readability Follow the convention of naming classes in Python by using the
    uppercase camel form: ClassName. When you have multiple words, every word’s first
    letter should be uppercase, as in TaskUser.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 遵循Python中类命名的约定，使用大驼峰形式：ClassName。当你有多个单词时，每个单词的首字母应大写，如TaskUser。
- en: 'In the namedtuple function, we specified the class name and its attributes
    for the class. Notably, the data model’s attributes can be set as either a single
    string (with spaces or commas as separators) or a list object (figure 3.4):'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在namedtuple函数中，我们指定了类的名称及其属性。值得注意的是，数据模型的属性可以是单个字符串（使用空格或逗号作为分隔符）或列表对象（见图3.4）：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![CH03_F04_Cui](../Images/CH03_F04_Cui.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F04_Cui](../Images/CH03_F04_Cui.png)'
- en: Figure 3.4 Creating a named tuple. The class name should follow the uppercase
    camel naming rule, and the attributes should be specified by a single string or
    a list of strings.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 创建namedtuple。类名应遵循大驼峰命名规则，属性应通过单个字符串或字符串列表指定。
- en: Readability Specify the attributes by using a single string with spaces or commas
    in the namedtuple function. The code is easier to type and read.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 在namedtuple函数中使用单个字符串（包含空格或逗号）指定属性。代码更容易输入和阅读。
- en: 'Now that you know about the named tuple, you can use the Task class to process
    the data used in our application. For simplicity, suppose that our data source
    is a string object that we receive from a particular application programming interface
    (API):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了namedtuple，你可以使用Task类来处理我们应用程序中使用的数据。为了简单起见，假设我们的数据源是从特定的应用程序编程接口（API）接收到的字符串对象：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Concept An API defines a set of ways to build and integrate different components,
    including software and hardware. A common kind of API refers to various defined
    functions that your application can call to retrieve data from another source.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 一个API定义了一组构建和集成不同组件的方法，包括软件和硬件。常见的一种API指的是应用程序可以调用来从另一个源检索数据的各种定义好的函数。
- en: 'To convert the text data to Task instance objects, here’s a possible solution:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文本数据转换为Task实例对象，以下是一个可能的解决方案：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Splits the text data into multiple rows
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将文本数据分割成多行
- en: ❷ Splits the text data with commas
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用逗号分割文本数据
- en: 'This solution uses a few techniques that you’ve learned so far, including string
    splitting and f-strings, and shows exactly how small things add up to make something
    work. To take this a step further, we can take advantage of the named tuple class
    method _make, which maps an iterable (the list created by split is an iterable;
    we’ll discuss iterables in detail in chapter 5) to the named tuple. Here’s an
    updated solution:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案使用了一些你迄今为止学到的技术，包括字符串分割和f-strings，并展示了如何将小事积累起来使某物工作。为了更进一步，我们可以利用namedtuple类方法_make，它将可迭代对象（由split创建的列表是一个可迭代对象；我们将在第5章详细讨论可迭代对象）映射到namedtuple。以下是更新后的解决方案：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: PEEK You’ll learn about class methods in section 8.2.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: PEEK 你将在第8.2节中学习关于类方法的内容。
- en: Unlike custom classes, whose instances have per-instance dict representations
    through __dict__, named tuples don’t have the underlying dict representations,
    which makes named tuples a lightweight data model with negligible memory costs.
    Named tuples can save significant amounts of memory when you need to create thousands
    of instances.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与具有通过__dict__实现的每个实例字典表示的定制类不同，namedtuple没有底层字典表示，这使得namedtuple成为一个轻量级的数据模型，内存成本可忽略不计。当需要创建数千个实例时，namedtuple可以节省大量的内存。
- en: Curious readers are encouraged to explore Python’s official website ([https://docs.python.org/3/library/collections.html](https://docs.python.org/3/library/collections.html))
    to find out about other features of named tuples, such as creating a new named
    tuple from an existing one by replacing field values and inspecting the fields’
    default values.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励好奇的读者探索Python的官方网站([https://docs.python.org/3/library/collections.html](https://docs.python.org/3/library/collections.html))，以了解命名元组的其他功能，例如通过替换字段值从现有命名元组创建新的命名元组以及检查字段的默认值。
- en: 3.3.3 Discussion
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 讨论
- en: Compared with built-in types (such as lists, tuples, and dictionaries) and custom
    classes, named tuples are a more proper, lightweight data model if your business
    concern is a model to hold data with mostly read-only access requirements. The
    popular data science Python library pandas, for example, allows you to access
    each row of its DataFrame data model as a named tuple.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与内置类型（如列表、元组和字典）和自定义类相比，如果您的业务关注的是主要用于只读访问要求的数据模型，则命名元组是一个更合适、更轻量级的数据模型。例如，流行的数据科学Python库pandas允许您将其DataFrame数据模型的每一行作为命名元组访问。
- en: Trivia Most data scientists use pandas in their daily data processing jobs.
    The library’s key data structure DataFrame represents data in the form of spreadsheets.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点大多数数据科学家在日常数据处理工作中使用pandas。该库的关键数据结构DataFrame以电子表格的形式表示数据。
- en: Because named tuples represent a new type, you should use a descriptive name
    with the first letter uppercase, as in other custom classes. In the meantime,
    make the named tuple class obvious. It is a good idea to place the code for creating
    a named tuple class at the top of a module. After all, the code is only one line,
    and you don’t want it buried.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因为命名元组代表了一种新类型，你应该使用一个描述性的名称，首字母大写，就像其他自定义类一样。同时，使命名元组类明显。将创建命名元组类的代码放在模块的顶部是一个好主意。毕竟，代码只有一行，你不想让它被埋没。
- en: 'Maintainability Place the code of creating a named tuple class in a noticeable
    location, such as at the top of a module. The code is one line, but it’s significant:
    it creates a new class.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性将创建命名元组类的代码放在一个显眼的位置，例如在模块的顶部。代码只有一行，但它是重要的：它创建了一个新类。
- en: 3.3.4 Challenge
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 挑战
- en: For the task management app, suppose that we need to update a named tuple Task(title='Laundry',
    desc='Wash clothes', urgency=3) by setting the urgency level to 4. Can you change
    the level directly? If not, how can you change it?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任务管理应用，假设我们需要通过将紧急程度级别设置为4来更新名为Task的命名元组（title='Laundry', desc='Wash clothes',
    urgency=3）。你能直接更改级别吗？如果不能，如何更改它？
- en: Hint A named tuple is a tuple object, so it’s immutable, and changing its stored
    data directly is not allowed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：命名元组是一个元组对象，因此它是不可变的，不允许直接更改其存储的数据。
- en: 3.4 How do I access dictionary keys, values, and items?
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 如何访问字典的键、值和项？
- en: The most-used built-in data types include int, float, bool, str, list, tuple,
    set, and dict. The first four types are primitive types because they’re the building
    blocks of other data types. The other four types are data containers (figure 3.5).
    What makes dict different from list, tuple, and set is the fact that it contains
    key-value pairs instead of individual objects. Through storing the key-value pairs,
    dictionaries can hold two categories of information.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的内置数据类型包括int、float、bool、str、list、tuple、set和dict。前四种类型是原始类型，因为它们是其他数据类型的基础。其他四种类型是数据容器（图3.5）。dict与list、tuple和set的不同之处在于它包含键值对而不是单个对象。通过存储键值对，字典可以持有两类信息。
- en: '![CH03_F05_Cui](../Images/CH03_F05_Cui.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F05_Cui](../Images/CH03_F05_Cui.png)'
- en: Figure 3.5 Common data models in Python, including primitive types and data
    containers
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 Python中的常见数据模型，包括原始类型和数据容器
- en: 'Suppose that we have the following dictionary to store the urgencies of some
    tasks in the task application. This dict object holds two sets of information,
    which are the titles as the keys and the urgency levels as the values:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下字典来存储任务应用中某些任务的紧急程度。这个字典对象包含两组信息，即作为键的标题和作为值的紧急程度级别：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we include dictionaries in our project, we often need to access their
    stored data: the keys, the values, and the key-value pairs. In this section, we’re
    going to explore different ways to access this data. Because we use dictionaries
    frequently in our projects, knowing how to access a dict’s data is essential for
    using this powerful data type.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将字典包含在我们的项目中时，我们经常需要访问它们存储的数据：键、值和键值对。在本节中，我们将探讨访问这些数据的不同方法。因为我们经常在我们的项目中使用字典，了解如何访问字典的数据对于使用这种强大的数据类型至关重要。
- en: 3.4.1 Using dynamic view objects (keys, values, and items) directly
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 直接使用动态视图对象（keys、values 和 items）
- en: 'Besides providing access to individual key-value pairs in a dictionary, such
    as urgencies ["Laundry"], Python provides three basic methods for retrieving a
    dictionary’s stored data across all the pairs: keys, values, and items to access
    the keys, values, and the key-value pairs, respectively. Let’s observe their basic
    uses:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供访问字典中单个键值对的方法，例如 urgency ["洗衣"]，Python 还提供了三种基本方法来检索字典存储的所有数据：keys、values
    和 items，分别用于访问键、值和键值对。让我们观察它们的基本用法：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: One assumption that many people make is that the objects created from these
    methods (keys, values, and items) are list objects. They’re not, however. They’re
    dict_ keys, dict_values, and dict_items, respectively. What’s most special about
    these data types is the fact that they’re all *dynamic view objects.* If you’re
    familiar with database terms, you should have heard of *views,* which refer to
    the virtual results computed or collated dynamically from data in the database.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人会犯的一个假设是，从这些方法（keys、values 和 items）创建的对象是列表对象。然而，它们不是。它们分别是 dict_keys、dict_values
    和 dict_items。这些数据类型最特别的地方在于它们都是 *动态视图对象*。如果你熟悉数据库术语，你应该听说过 *视图*，它指的是从数据库中的数据动态计算或汇总的虚拟结果。
- en: Trivia *Views* are the results of stored queries in a database. When the pertinent
    data is updated, the views are updated too.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 知识拓展 *视图* 是数据库中存储查询的结果。当相关数据更新时，视图也会更新。
- en: 'Like views in a database, dictionary view objects are dynamic, updated automatically
    with the change of the dict object. That is, whenever you modify the key-value
    pairs stored in a dict object, these view objects get updated. Observe this effect:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数据库中的视图一样，字典视图对象是动态的，会随着字典对象的更改自动更新。也就是说，每次你修改存储在字典对象中的键值对时，这些视图对象都会更新。观察这个效果：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This dynamic provides great convenience when we access a dictionary’s data
    because the data is in perfect sync with the dict object. By contrast, the following
    example, which doesn’t take advantage of the view object, is antipattern:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这种动态特性在我们访问字典的数据时提供了极大的便利，因为数据与字典对象完美同步。相比之下，以下不利用视图对象的示例是反模式：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We create a list for the keys. After we update the dictionary, the list stays
    the same and doesn’t sync with the dict object. Thus, you may encounter unexpected
    errors, such as trying to access a deleted item, when you use a list to track
    the keys of a dictionary instead of using the dict_keys view object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个键列表。在我们更新字典后，列表保持不变，并且不与字典对象同步。因此，当你使用列表来跟踪字典的键而不是使用 dict_keys 视图对象时，可能会遇到意外的错误，例如尝试访问已删除的项目。
- en: Maintainability Always use view objects to access a dict’s data because these
    view objects are dynamic; they will update when the dictionary’s data is updated.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性始终使用视图对象来访问字典的数据，因为这些视图对象是动态的；当字典的数据更新时，它们会自动更新。
- en: 3.4.2 Being cautious with the KeyError exception
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 小心处理 KeyError 异常
- en: 'In section 3.4.1, we discussed three ways to access all the keys and/or values
    in a dictionary. Most of the time, however, we need to access a single value by
    using *subscript notation*, which encloses the key in a pair of square brackets:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在3.4.1节中，我们讨论了访问字典中所有键和/或值的三个方法。然而，大多数时候，我们需要使用 *下标表示法* 来访问单个值，即用一对方括号括住键：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Concept Subscript notation is a common way to access data in a collection data
    type. For dict objects, using subscript notation means using keys enclosed in
    square brackets to access the corresponding values.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点下标表示法是访问集合数据类型中数据的一种常见方式。对于字典对象，使用下标表示法意味着使用方括号括住的键来访问相应的值。
- en: 'The major advantage of this method is its straightforwardness. If you have
    used dictionaries in other languages, you should be familiar with this approach.
    Thus, it is natural for you to use this feature when you access items of a dictionary.
    But unexpected errors can happen if you’re not careful with the key. The following
    code snippet shows such a problem:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是它的直接性。如果你在其他语言中使用过字典，你应该熟悉这种方法。因此，当你访问字典项时，使用这个特性是很自然的。但如果你不小心处理键，可能会发生意外的错误。以下代码片段展示了这样的问题：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When you’re accessing a key that doesn’t exist in the dictionary, you encounter
    the KeyError exception. When an exception is raised, unless it’s handled with
    the try...except... statement (section 12.3), your program crashes. We certainly
    don’t want our program to crash, so we should avoid this error by using alternative
    approaches.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试访问字典中不存在的键时，你会遇到KeyError异常。当异常被抛出时，除非它被try...except...语句（第12.3节）处理，否则你的程序会崩溃。我们当然不希望我们的程序崩溃，所以我们应该通过使用替代方法来避免这种错误。
- en: '3.4.3 Avoiding KeyError with a hygiene check first: The non-Pythonic way'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3 首先进行卫生检查以避免KeyError：非Python风格的方法
- en: 'Because we know that KeyError exceptions occur only when the keys aren’t in
    the dictionary object, we can check the key’s existence before retrieving the
    value, as in this example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道KeyError异常仅在键不在字典对象中时才会发生，所以我们可以在检索值之前检查键的存在，如下例所示：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Checks whether the key is in the dictionary
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查键是否在字典中
- en: 'This solution helps us avoid the KeyError exception, but in the meantime, it’s
    cumbersome and non-Pythonic, because Pythonic code should be concise. Now, we’re
    accessing only one item. Can you imagine accessing multiple items? We would have
    to repeat this block of code, leading to distractive duplication in the codebase.
    Code duplication should remind you of the DRY (Don’t Repeat Yourself) principle;
    we should refactor our code to remove unnecessary repetitions. Consider this code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案帮助我们避免了KeyError异常，但与此同时，它既繁琐又不符合Python风格，因为Python风格的代码应该是简洁的。现在，我们只访问一个项。你能想象访问多个项吗？我们不得不重复这段代码，导致代码库中的代码重复。代码重复应该让你想起DRY（不要重复自己）原则；我们应该重构我们的代码以消除不必要的重复。考虑以下代码：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With the refactored code, we can retrieve a task’s urgency level without worrying
    about the KeyError exception anymore:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重构代码，我们可以检索任务的紧急程度，而无需再担心KeyError异常：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The retrieve_urgency function is handy for retrieving a task’s urgency level,
    but it is hardcoded, including the dict object (urgencies) and specific semantics
    (urgency). If we access another dict’s data, we must define a similar function
    to avoid a KeyError.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: retrieve_urgency函数对于检索任务的紧急程度很有用，但它被硬编码，包括字典对象（urgencies）和特定的语义（urgency）。如果我们访问另一个字典的数据，我们必须定义一个类似的函数来避免KeyError。
- en: 'The more dictionary objects we have, the more functions we’ll have to create.
    Are you seeing a higher level of repetition here? Our Python pioneers have already
    considered this problem and have created a built-in function: the get method,
    discussed in section 3.4.4.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有的字典对象越多，我们需要创建的函数就越多。你是否在这里看到了更高层次的重用？我们的Python先驱们已经考虑了这个问题，并创建了一个内置函数：get方法，在第3.4.4节中讨论。
- en: 3.4.4 Using the get method to access a dictionary item
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.4 使用get方法访问字典项
- en: 'Because it is a dict method, we can call the get method on any dict object
    by specifying the key and a default value when the key doesn’t exist. When the
    default argument is omitted, Python uses None as the default value. The following
    code snippet shows some examples:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个字典方法，所以我们可以通过指定键和不存在时的默认值来在任何字典对象上调用get方法。当省略默认参数时，Python使用None作为默认值。以下代码片段展示了几个示例：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The get method has the advantage of not raising KeyError when the key isn’t
    in the dictionary. More importantly, it allows you to set a proper default value
    as the fallback value. You can use get whenever you retrieve values from dictionaries,
    but I prefer subscript notation, which I find to be more readable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: get方法的优势在于当键不在字典中时不会抛出KeyError。更重要的是，它允许你设置一个合适的默认值作为回退值。你可以在从字典检索值时随时使用get，但我更喜欢下标符号，我认为它更易读。
- en: 'There are scenarios in which get is preferable to subscript notation, however.
    One such scenario is when you need to deal with the variable number of keyword
    arguments (**kwargs) in a function definition. We’ll cover using **kwargs in section
    6.4\. For the time being, you only need to know that kwargs is a dict object used
    in a function and that these parameters are usually optional. Suppose that you’re
    building a Python package for the Python community, and this package has the following
    function:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，使用`get`方法比使用下标表示法更可取。一个这样的场景是在函数定义中需要处理可变数量的关键字参数（**kwargs**）。我们将在第6.4节中介绍使用**kwargs**。目前，你只需要知道kwargs是在函数中使用的字典对象，并且这些参数通常是可选的。假设你正在为Python社区构建一个Python包，并且这个包具有以下函数：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, calculate_something accepts multiple keyword arguments besides
    two positional arguments. For conciseness, you may not want to list all optional
    keyword arguments when their default values are almost always used; thus, you
    can wrap them to a dict kwargs in the function header. In the function body, you’ll
    notice that we use get multiple times, which allows us to set default values when
    the keys are missing from calling the function, and we include these proper default
    values in the get method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`calculate_something`除了两个位置参数外还接受多个关键字参数。为了简洁，你可能不希望列出所有可选关键字参数，因为它们的默认值几乎总是被使用；因此，你可以在函数头中将它们包装到`kwargs`字典中。在函数体中，你会注意到我们多次使用`get`，这允许我们在调用函数时设置缺失键的默认值，并在`get`方法中包含这些适当的默认值。
- en: 3.4.5 Watching for the setdefault method’s side effect
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.5 监视`setdefault`方法的副作用
- en: 'When people talk about alternatives to the get method, some may mention the
    setdefault method. This method is like the get method in that it also takes two
    parameters: the key and a default value as the fallback. Observe some uses of
    setdefault:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们谈论`get`方法的替代方案时，有些人可能会提到`setdefault`方法。这种方法与`get`方法类似，因为它也接受两个参数：键和一个作为后备的默认值。观察一些`setdefault`的使用情况：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code snippet shows the similarity between setdefault and get. But what
    makes setdefault differ from get is that when you call setdefault, an extra operation
    (dict[key] = default_value) occurs when the key isn’t in the dictionary:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段展示了`setdefault`和`get`之间的相似性。但使`setdefault`与`get`不同之处在于，当你调用`setdefault`时，如果键不在字典中，则会发生一个额外的操作（`dict[key]
    = default_value`）：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We previously called setdefault with the keys "Homework", "Homeworks", and
    "Grocery". Because the latter two keys were not in the dict initially, the following
    operations occurred under the hood:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用`setdefault`方法时使用了键“Homework”、“Homeworks”和“Grocery”。由于后两个键最初不在字典中，因此内部发生了以下操作：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Because of this side effect, I don’t recommend using the setdefault method.
    The name is confusing—typically, we don’t expect things to be returned by calling
    a method that involves setting a value—and an implicit operation that many people
    may not know (setting the specified default value or None if the key doesn’t exist)
    is involved.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种副作用，我不建议使用`setdefault`方法。这个名字令人困惑——通常，我们不会期望通过调用涉及设置值的函数来返回值——并且涉及一个许多人可能不知道的隐式操作（设置指定的默认值或如果键不存在则返回None）。
- en: Maintainability Avoid using the setdefault method, as it can set the missing
    key’s value in an unexpected way. Use a more explicit approach, such as the get
    method.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性：避免使用`setdefault`方法，因为它可能会以意想不到的方式设置缺失键的值。使用更明确的方法，例如`get`方法。
- en: 3.4.6 Discussion
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.6 讨论
- en: Dictionary view objects are a brilliant design that dynamically tracks a dictionary’s
    keys, values, and key-value pairs. As iterables, they can be used in a for loop
    (section 5.3) if you want to iterate the data of a dict object.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 字典视图对象是一种出色的设计，它能够动态跟踪字典的键、值和键值对。作为可迭代对象，如果想要迭代字典对象的数据，可以在for循环（第5.3节）中使用它们。
- en: Don’t feel obligated to use get whenever you access a key’s value. If you’re
    used to subscript notation, feel free to use it. Sometimes, it’s a good idea to
    use subscript notation in your own codebase, as you want any problems to surface
    during development, and raising errors is an essential mechanism for identifying
    any problems. If you misspell a key, using the get method may hide the KeyError
    exception by providing the fallback value.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问键的值时，不必总是使用`get`方法。如果你习惯于使用下标表示法，请随意使用。有时，在你的代码库中使用下标表示法是个好主意，因为你希望任何问题在开发期间都能暴露出来，而引发错误是识别任何问题的基本机制。如果你拼写了一个键，使用`get`方法可能会通过提供后备值来隐藏`KeyError`异常。
- en: 3.4.7 Challenge
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.7 挑战
- en: The built-in id function checks an object’s memory address. Running id("Hello")
    returns the address of the "Hello" object. Can you use the id function to track
    the changes of a dictionary view object, such as dict_keys? You expect the view
    object’s data to change with the update of the dict object. You should expect
    the view object’s memory address to stay.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的id函数检查对象的内存地址。运行id("Hello")返回"Hello"对象的地址。你能使用id函数跟踪字典视图对象（如dict_keys）的变化吗？你期望视图对象的数据会随着字典对象更新而变化。你应该期望视图对象的内存地址保持不变。
- en: Hint An object has the same memory address throughout its lifecycle. Even though
    the data of the object can change, the memory address should stay.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 一个对象在其生命周期内具有相同的内存地址。尽管对象的数据可以改变，但内存地址应该保持不变。
- en: 3.5 When do I use dictionaries and sets instead of lists and tuples?
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 我在什么情况下使用字典和集合而不是列表和元组？
- en: 'We have extensively discussed two data containers: tuples and lists. Python
    has no restriction regarding the data types that can be saved in them, and such
    flexibility makes them attractive data models in any project. Section 3.4 mentions
    that dict is useful because it stores key-value pairs, but how about sets? In
    addition, you may know that not all data types can be stored in dictionaries and
    sets, as the next listing shows.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经广泛讨论了两种数据容器：元组和列表。Python对可以存储在其中的数据类型没有限制，这种灵活性使它们在任何项目中都成为有吸引力的数据模型。3.4节提到，字典是有用的，因为它存储键值对，但集合呢？此外，你可能知道，并非所有数据类型都可以存储在字典和集合中，如下面的列表所示。
- en: Listing 3.6 Failed creation of dict and set objects
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 字典和集合对象创建失败
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When objects are unhashable, they can’t serve as dict keys or set items. At
    first glance, this fact appears to be a deficit that harms the usefulness of these
    two data structures. But there are good reasons for this design. In this section,
    we’ll explore how the hashable restriction benefits data retrieval with these
    two data structures and when we should use it. We’ll also study the hashable-versus-unhashable
    concept.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象不可哈希时，它们不能作为字典键或集合项使用。乍一看，这个事实似乎是一个缺陷，损害了这两个数据结构的有用性。但这个设计有很好的理由。在本节中，我们将探讨哈希限制如何有利于这两个数据结构的数据检索，以及我们应该何时使用它。我们还将研究可哈希与不可哈希的概念。
- en: 3.5.1 Taking advantage of the constant lookup efficiency
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1 利用常量查找效率
- en: 'Dictionaries store key-value pairs, and this storage pattern allows us to retrieve
    data by accessing the keys. Moreover, dictionaries have a significant advantage:
    superior lookup efficiency for retrieving specific items. Because sets have the
    same underlying storage mechanism (a hash table; see section 3.5.2) as dictionaries,
    they have the same characteristics—efficient item lookup. In this section, we’ll
    see when to prefer dictionaries or sets over lists and tuples.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 字典存储键值对，这种存储模式允许我们通过访问键来检索数据。此外，字典有一个显著的优势：在检索特定项目时具有优越的查找效率。因为集合与字典有相同的底层存储机制（哈希表；见3.5.2节），它们具有相同的特性——高效的项查找。在本节中，我们将探讨何时更倾向于使用字典或集合而不是列表和元组。
- en: Suppose that our application requires a considerable number of item retrievals
    or lookups. From a theoretic perspective, we could use a list or a set to store
    the data. We can run a simple experiment to compare the speed of retrieving a
    random item from each object with the help of timeit and random modules, as shown
    in the next listing.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的应用程序需要大量的项目检索或查找。从理论角度来看，我们可以使用列表或集合来存储数据。我们可以运行一个简单的实验来比较使用timeit和random模块从每个对象中检索随机项的速度，如下面的列表所示。
- en: Listing 3.7 Comparing data retrieval speed between lists and sets
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 列表和集合之间数据检索速度的比较
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ The string to set up the timing test
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置定时测试的字符串
- en: ❷ The string to check the membership in a set object
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查集合对象成员资格的字符串
- en: ❸ The string to check the membership in a list object
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查列表对象成员资格的字符串
- en: ❹ Finds out the average execution time
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 查找平均执行时间
- en: Trivia As part of the standard Python library, the timeit module allows us to
    examine our operations’ performance, and the random module provides functionalities
    for creating random numbers. The availability of these built-in tools is another
    manifestation of how comprehensive Python is in terms of routine tools for our
    work.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点 作为标准Python库的一部分，timeit模块允许我们检查我们操作的性能，而random模块提供了创建随机数的功能。这些内置工具的可用性是Python在日常工作工具方面全面性的另一个体现。
- en: 'In listing 3.7, we use a for loop to go over multiple conditions in which the
    list and set objects have varied numbers of items. After running the code, you’ll
    see the following output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 3.7 中，我们使用 for 循环遍历列表和集合对象具有不同数量项的多个条件。运行代码后，您将看到以下输出：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Expect to see different results due to different computers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 预期由于不同计算机而看到不同的结果。
- en: Readability We used f-strings to format the string output. Specifically, we
    applied the text alignment format specifier to create a visual structure for better
    readability.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 我们使用了 f-strings 来格式化字符串输出。具体来说，我们应用了文本对齐格式说明符来创建一个视觉结构，以增强可读性。
- en: With the increase in the number of the items in the set, the lookup time stays
    at the same magnitude, which represents constant time, known as the O(1) time
    complexity. That is, no matter how large the set grows, item lookup takes about
    the same time. By contrast, the magnitude of lookup time increases linearly as
    a function of the list’s size. Unlike sets, which use hash tables to index objects
    with hash values (section 3.5.2), lists require traverses to examine whether an
    item is contained, and the time for such traversing depends directly on the number
    of the list’s items. This contrast in time complexity highlights the benefit of
    using sets instead of lists when your business need is item lookup.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 随着集合中项目数量的增加，查找时间保持在同一量级，这代表常数时间，称为 O(1) 时间复杂度。也就是说，无论集合增长得多大，项目查找所需的时间大致相同。相比之下，查找时间的大小随着列表大小的线性增长而增加。与使用哈希表通过哈希值索引对象的集合（第
    3.5.2 节）不同，列表需要遍历来检查是否包含某个项目，这种遍历的时间直接取决于列表项的数量。这种时间复杂度的对比突出了在业务需求是项目查找时使用集合而不是列表的好处。
- en: 'This example uses a set object as the test subject for item-lookup efficiency
    to observe how we achieve O(1) time complexity. The same efficiency holds for
    dict objects, as the underlying storage mechanism is the same: using a hash table.
    Each key in a dict object and each item in a set object has a corresponding hash
    value. But what does hash mean? Section 3.5.2 discusses that topic.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用集合对象作为测试主题，以观察我们如何实现 O(1) 时间复杂度。对于 dict 对象，效率相同，因为底层存储机制是相同的：使用哈希表。dict
    对象中的每个键和集合对象中的每个项目都有一个相应的哈希值。但哈希是什么意思？第 3.5.2 节讨论了该主题。
- en: Time complexity of algorithms
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的时间复杂度
- en: In computer science, algorithms can be conceptualized as defined instructions
    for solving a problem, such as sorting a list or fetching an item from a sequence.
    Not all algorithms have the same problem-solving speed. To quantify performance,
    we use time complexity to describe the amount of time required to run an algorithm.
    To denote the time complexity, we use so-called Big O notation, in which we use
    a pair of parentheses to include a function of the number of involved items, typically
    denoted as n. O(n), for example, means that the time needed for the algorithm
    is linearly dependent on the number of items involved; O(n²) means that the time
    needed is quadratically related to the items’ count; and O(1) means that the time
    is constant and doesn’t depend on the number of items involved. The following
    figure provides a brief overview of the time complexities.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，算法可以被理解为解决问题的定义性指令，例如排序一个列表或从一个序列中检索一个项目。并非所有算法的解决问题速度都相同。为了量化性能，我们使用时间复杂度来描述运行算法所需的时间量。为了表示时间复杂度，我们使用所谓的
    Big O 符号，其中我们使用一对括号来包含涉及项数量的函数，通常表示为 n。例如，O(n) 表示算法所需的时间与涉及项的数量线性相关；O(n²) 表示所需时间与项的数量成平方关系；而
    O(1) 表示时间是常数，不依赖于涉及项的数量。以下图表提供了一个关于时间复杂性的简要概述。
- en: '![CH03_F05_UN01_Cui](../Images/CH03_F05_UN01_Cui.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F05_UN01_Cui](../Images/CH03_F05_UN01_Cui.png)'
- en: The curves of time complexity of different magnitudes. The variable n represents
    the number of items involved in the computation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 不同量级的时间复杂度曲线。变量 n 代表计算中涉及的项数。
- en: 3.5.2 Understanding hashable and hashing
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.2 理解可哈希和哈希
- en: When you create dictionaries or sets, you don’t want to experience the TypeError
    exception (listing 3.6). This exception is raised because we’re trying to use
    unhashable objects as dictionary keys or set items. As you can imagine, the opposite
    of *unhashable* is *hashable,* and it appears that only hashable objects can be
    used with dictionaries and sets. But what does hashable mean? In this section,
    you’re going to learn about both hashable and unhashable objects.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建字典或集合时，你不想遇到TypeError异常（列表3.6）。这个异常是因为我们试图使用不可哈希的对象作为字典键或集合项。正如你所想象的那样，*不可哈希*的相反是*可哈希*，并且似乎只有可哈希的对象才能与字典和集合一起使用。但可哈希是什么意思呢？在本节中，你将了解可哈希和不可哈希对象。
- en: Concept When your Python program encounters an error, we say that it raises
    an exception. Other programming languages may use *throw* to signify an error
    or exception.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 当你的Python程序遇到错误时，我们说它抛出了异常。其他编程语言可能使用*throw*来表示错误或异常。
- en: '*Hashable* isn’t an isolated concept. You have probably heard related terminologies,
    such as hash value, hashing, hash table, and hashmap. At their core, hashable
    objects use the same fundamental procedure: *hashing**.* Figure 3.6 shows the
    general process of hashing, using dictionary keys as an example. We start with
    raw data values: four strings. A hash function, which is often termed a *hasher**,*
    carries out a series of computations by using specific algorithms and outputs
    the hash values (termed hashes) for the raw data values.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*可哈希*不是一个孤立的概念。你可能听说过相关的术语，如哈希值、哈希、哈希表和hashmap。在本质上，可哈希对象使用相同的根本程序：*哈希**。*
    图3.6展示了使用字典键作为示例的哈希的一般过程。我们开始于原始数据值：四个字符串。哈希函数，通常被称为*哈希器**，通过使用特定的算法进行一系列计算，并输出原始数据值的哈希值（称为哈希）。'
- en: '![CH03_F06_Cui](../Images/CH03_F06_Cui.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F06_Cui](../Images/CH03_F06_Cui.png)'
- en: Figure 3.6 The process of hashing, using dictionary keys as an example. A hash
    function (hasher) hashes the keys of a dictionary, producing hashes as integer
    values. These hash values are uniquely associated with each of the dictionary
    keys. Different hashers are expected to produce different hashes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 使用字典键作为示例的哈希过程。哈希函数（哈希器）对字典的键进行哈希处理，生成整数形式的哈希值。这些哈希值与字典中的每个键唯一关联。期望不同的哈希器产生不同的哈希值。
- en: 'Note several key points about the hashing process:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意哈希过程的一些关键点：
- en: '*A hash function should be so computationally robust that it produces different
    hash values for different objects.* In rare cases, a hash function can produce
    the same hash value for different objects—a phenomenon termed *hash collision,*
    which must be handled according to a specified protocol.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*哈希函数应该足够计算稳健，为不同的对象产生不同的哈希值。* 在罕见的情况下，哈希函数可以为不同的对象产生相同的哈希值——这种现象被称为*哈希冲突*，必须按照指定的协议处理。'
- en: '*A hash function should be so consistent that the same objects always have
    the same hash values.* When you set a password in an application, the password
    is hashed by the hasher and stored in a database. When you try to log in again,
    the entered password string would be hashed and compared with the stored hash
    value. In these two cases, the same password should produce an identical hash
    value.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*哈希函数应该足够一致，相同的对象总是具有相同的哈希值。* 当你在应用程序中设置密码时，密码会被哈希器哈希并存储在数据库中。当你再次尝试登录时，输入的密码字符串会被哈希并与存储的哈希值进行比较。在这两种情况下，相同的密码应该产生相同的哈希值。'
- en: '*For more complicated hashers, hashing is one-way traffic.* By design (such
    as using a random number), it’s almost impossible to reverse-calculate the raw
    data based on a hash value. This irreversibility is required where cybersecurity
    is concerned. Even if hackers get a password’s hash value, they can’t figure out
    the password from the hash value (at least, not easily).'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对于更复杂的哈希器，哈希是单向交通。* 设计上（例如使用随机数），根据哈希值反向计算原始数据几乎是不可能的。这种不可逆性在网络安全方面是必需的。即使黑客得到了密码的哈希值，他们也无法从哈希值中推断出密码（至少不是轻易地）。'
- en: 'Python has implemented a hasher that produces hash values for its objects.
    Specifically, we can retrieve an object’s hash value by using the built-in hash
    function. The following code shows some examples:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Python实现了哈希器，可以为它的对象生成哈希值。具体来说，我们可以通过使用内置的hash函数来检索对象的哈希值。以下代码展示了几个示例：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Expect a different value because some hashers depend on the operating system.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 预期不同的值，因为一些哈希器依赖于操作系统。
- en: 'Not every object can produce a hash value by the hash function. Strings and
    integers are hashable, but lists are unhashable. You may wonder why lists are
    unhashable or, more broadly speaking, why dictionaries and sets are unhashable
    too. The reason is simple: these unhashable data types are mutable. By design,
    the hash function generates a hash value based on the content of an object.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个对象都能通过哈希函数生成哈希值。字符串和整数是可哈希的，但列表是不可哈希的。你可能想知道为什么列表是不可哈希的，或者更广泛地说，为什么字典和集合也是不可哈希的。原因很简单：这些不可哈希的数据类型是可变的。按照设计，哈希函数基于对象的内容生成哈希值。
- en: The content of mutable data can change after creation. If we magically make
    a list hashable, when we update the list with the changed content, we expect to
    have a different hash value. But a hash function should consistently produce the
    same hash value for the same object, and in this case, we expect the hash value
    to stay the same for the list object. Apparently, the list’s content change, resulting
    in a hash-value change, is irreconcilable with the expected consistent hash value
    for the same list object (figure 3.7).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 可变数据的内容在创建后可以改变。如果我们神奇地将列表变为可哈希的，当我们用更改后的内容更新列表时，我们期望得到不同的哈希值。但哈希函数应该始终为相同的对象生成相同的哈希值，在这种情况下，我们期望列表对象的哈希值保持不变。显然，列表内容的变化导致哈希值的变化，与对相同列表对象期望的哈希值一致性是不相容的（图3.7）。
- en: '![CH03_F07_Cui](../Images/CH03_F07_Cui.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F07_Cui](../Images/CH03_F07_Cui.png)'
- en: Figure 3.7 Irreconcilability of the hashing process for a mutable object. If
    a list is hashable, on one hand, you expect the list to produce the same hash
    value, regardless of its content, as the same object. On the other hand, after
    the list is updated, the different contents are supposed to produce different
    hash values. These two scenarios are irreconcilable.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 可变对象哈希过程的不可调和性。如果列表是可哈希的，一方面，你期望列表无论其内容如何都能产生相同的哈希值，就像相同的对象一样。另一方面，在列表更新后，不同的内容应该产生不同的哈希值。这两种情况是不可调和的。
- en: By contrast, for immutable data such as integers, strings, and tuples, the contents
    stay the same after creation. The consistency of the contents is key to applying
    a hash function to any object. Thus, all immutable data types are hashable.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，对于整数、字符串和元组等不可变数据，内容在创建后保持不变。内容的这种一致性是应用哈希函数到任何对象的关键。因此，所有不可变数据类型都是可哈希的。
- en: You may wonder whether there is a more straightforward way to determine the
    hashability of an object without using the hash function. Listing 3.8 shows a
    solution. Everything should be straightforward except the use of Hashable. For
    simplicity, you can think of Hashable as being a class and every hashable object
    as being an instance of this class.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道是否有更直接的方法来确定对象的哈希性，而不使用哈希函数。列表3.8展示了解决方案。除了使用 `Hashable` 之外，所有内容都应该很简单。为了简单起见，你可以将
    `Hashable` 视为一个类，每个可哈希对象都是这个类的实例。
- en: Listing 3.8 Checking the hashability of an object
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8 检查对象的哈希性
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Creates a list of objects of varying types
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建了一个包含不同类型对象的列表
- en: ❷ isinstance produces a Boolean value for type checking.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `isinstance` 函数用于类型检查，并返回一个布尔值。
- en: Trivia The abc submodule defines a series of abstract base classes (ABCs). It
    allows you to check whether a class provides a particular interface, such as hashable.
    In layperson’s terms, it helps you check whether an object can do some specific
    things, such as being hashed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点：`abc` 子模块定义了一系列抽象基类（ABC）。它允许你检查一个类是否提供了特定的接口，例如可哈希性。用通俗的话说，它帮助你检查一个对象是否可以执行某些特定操作，例如进行哈希。
- en: Consistent with our previous discussion, mutable data—including dictionaries,
    lists, and sets—is unhashable. By contrast, all other immutable data types are
    hashable. For built-in data types, immutability is effectively equivalent to hashability.
    Table 3.1 provides an organized view of the common data types as a function of
    mutability and hashability.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的讨论一致，可变数据——包括字典、列表和集合——是不可哈希的。相比之下，所有其他不可变数据类型都是可哈希的。对于内置数据类型，不可变性实际上等同于可哈希性。表3.1提供了一个有组织的视图，展示了根据可变性和可哈希性对常见数据类型的分类。
- en: Table 3.1 Common data types as a function of hashability
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 根据可哈希性对常见数据类型的分类
- en: '| Mutability | Hashability | Data types | Allowed as dictionary keys or set
    items |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 可变性 | 可哈希性 | 数据类型 | 是否可以作为字典键或集合元素 |'
- en: '| Mutable | Unhashable | dict, list, set | No |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 可变 | 不可哈希 | dict, list, set | 否 |'
- en: '| Immutable | Hashable | int, float, str, tuple, bool, NoneType | Yes |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 不可变 | 可哈希 | int, float, str, tuple, bool, NoneType | 是 |'
- en: 'In section 3.1, we saw the immutability of tuple objects, and we couldn’t assign
    another value to an item in the tuple object. In table 3.1, notice that strings
    are also immutable in Python. The indication is that it’s impossible to change
    a character or a substring in a string. The following code shows the immutability
    of strings:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在3.1节中，我们看到了元组对象的不可变性，我们无法给元组对象中的项赋另一个值。在表3.1中，请注意，字符串在Python中也是不可变的。这表明在字符串中更改字符或子字符串是不可能的。以下代码显示了字符串的不可变性：
- en: '[PRE32]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you need to replace a substring, don’t forget strings’ replace method, which
    creates a new string, as shown in the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要替换子字符串，不要忘记字符串的replace方法，它创建一个新的字符串，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Trivia We know that we can use the id function to check the memory address of
    an object, which should differ between objects. You can compare the string and
    its counterpart with a replacement.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点 我们知道我们可以使用id函数来检查对象的内存地址，这些地址应该在不同对象之间不同。你可以通过替换来比较字符串及其对应项。
- en: 3.5.3 Discussion
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.3 讨论
- en: Hashable is a key programming concept. Under the hood, Python uses hash tables
    as the storage mechanism for dictionaries and sets. The most significant benefit
    of using a hash table is that data retrieval has O(1) performance, making it an
    ideal data model when you want to look up items quickly. We often use set objects
    to hold data where membership is concerned, for example.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 可哈希是关键编程概念。在底层，Python使用哈希表作为字典和集合的存储机制。使用哈希表的最显著好处是数据检索具有O(1)的性能，这使得它成为当你想要快速查找项时的理想数据模型。我们经常使用集合对象来存储涉及成员资格的数据，例如。
- en: 3.5.4 Challenge
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.4 挑战
- en: 'Jennifer is learning Python because she’s pursuing a data science career. She
    has learned that a dict object can’t have duplicate keys because of the underlying
    hash table implementation. Suppose that she creates a dict object: numbers = {1:
    "one", 1.0: "one point one"}. What values do you expect the numbers to have?'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'Jennifer正在学习Python，因为她正在追求数据科学职业。她了解到由于底层哈希表实现，字典对象不能有重复的键。假设她创建了一个字典对象：numbers
    = {1: "one", 1.0: "one point one"}。你期望numbers有哪些值？'
- en: Hint When you intentionally pass duplicate keys, the value of the latter one
    overrides the value of the first one when you construct a dict object.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 当你故意传递重复的键时，在构建字典对象时，后者的值会覆盖前者的值。
- en: 3.6 How do I use set operations to check the relationships between lists?
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 我如何使用集合操作来检查列表之间的关系？
- en: 'Lists are the go-to data structure for storing homogenous data. Sometimes,
    we have multiple lists to hold similar items, and we need to determine the relationships
    between list objects. Suppose that we use an API to retrieve a list of stocks
    that are recommended by an investment analysis company. Each client’s current
    stocks are also saved as a list object. For simplicity, we have the following
    data to start with:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是存储同质数据的常用数据结构。有时，我们会有多个列表来存储相似的项目，并需要确定列表对象之间的关系。假设我们使用一个API来检索一个由投资分析公司推荐的股票列表。每个客户的当前股票也以列表对象的形式保存。为了简化，我们以下列数据开始：
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: One specific functionality of the application is to examine whether all of a
    client’s stocks are contained in the recommended list. Do you know how to address
    this problem? You can use some list methods to solve it. Like their math counterparts,
    however, set objects in Python have a series of convenient methods for checking
    relationships between set objects. In this section, we’re going to explore the
    unique operations of the set class and see how to use these operations to solve
    problems concerning relationships between lists.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的一个特定功能是检查一个客户的股票是否全部包含在推荐列表中。你知道如何解决这个问题吗？你可以使用一些列表方法来解决这个问题。然而，与它们的数学对应物一样，Python中的集合对象有一系列方便的方法来检查集合对象之间的关系。在本节中，我们将探索集合类的独特操作，并了解如何使用这些操作来解决与列表关系相关的问题。
- en: 3.6.1 Checking whether a list contains all items of another list
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.1 检查一个列表是否包含另一个列表的所有项
- en: 'Implementing the preceding feature essentially requires us to address this
    question: How can we check whether a list object contains all items of another
    list object? In this section, you’ll learn how to use set operations to address
    this feature. Without using the set operations, a beginner might consider a solution
    that involves the iteration of the list object. To implement this routine functionality,
    we create a function that we can call as often as necessary, as shown in the following
    listing.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 实现前面的功能本质上需要我们解决以下问题：我们如何检查一个列表对象是否包含另一个列表对象的全部项目？在本节中，你将学习如何使用集合操作来实现这个功能。如果不使用集合操作，初学者可能会考虑一个涉及列表对象迭代的解决方案。为了实现这个常规功能，我们创建了一个可以按需多次调用的函数，如下所示。
- en: Listing 3.9 Check whether a list contains the entirety of another list
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9 检查一个列表是否包含另一个列表的全部元素
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ “not in” checks whether an item isn’t contained in the collection.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ “not in”检查一个项目是否不包含在集合中。
- en: Maintainability Always think of creating a function when you need to provide
    a general solution for many similar use cases. When you need to modify the feature,
    you need to change only this single function instead of separate duplicate functions
    that do the same job.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 总是考虑在需要为许多类似用例提供通用解决方案时创建函数。当你需要修改功能时，你只需要更改这个单一函数，而不是执行相同工作的单独重复函数。
- en: 'The logic of the function in listing 3.9 is that if we can find any case when
    a stock isn’t in the recommended list, we say that the client’s list isn’t entirely
    contained in the recommended list. Using this logic, we iterate the items of the
    client’s list. When any stock is found not to be in the recommended list, we exit
    the function by returning False; otherwise, we return True after iterating the
    entire list. With this function, we can test a couple of cases:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9中函数的逻辑是，如果我们能找到任何股票不在推荐列表中的情况，我们就说客户的列表不完全包含在推荐列表中。使用这个逻辑，我们遍历客户的列表项。当发现任何股票不在推荐列表中时，我们通过返回False退出函数；否则，在遍历完整个列表后返回True。使用这个函数，我们可以测试几个案例：
- en: '[PRE36]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Both use cases are working as expected. But a better solution doesn’t require
    creating a function. One important principle of coding is *Don’t reinvent the
    wheel**.* If we can use an available solution, we should use it directly. Thus,
    the better solution takes advantage of set-related operations:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种用例都按预期工作。但更好的解决方案不需要创建函数。编码的一个重要原则是*不要重复造轮子*。如果我们可以使用现有的解决方案，我们应该直接使用它。因此，更好的解决方案利用了与集合相关的操作：
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Creates a set object
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个集合对象
- en: ❷ Uses the issuperset method
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用issuperset方法
- en: To use the issuperset method, we convert the list object good_stocks to a set
    object good_stocks_set. We call issuperset on the good_stocks_set and pass the
    list object client0 or client1 as an argument. As expected, we get the desired
    results. Theoretically, we can use the issubset method to implement this functionality,
    but it requires creating set objects for each client’s list, which is unnecessary
    repetition. For this reason, issuperset is better than issubset when you share
    a set object that presumably is the superset. In our case, it’s the recommended
    stock set.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用issuperset方法，我们将列表对象good_stocks转换为集合对象good_stocks_set。我们在good_stocks_set上调用issuperset，并将列表对象client0或client1作为参数传递。正如预期的那样，我们得到了所需的结果。从理论上讲，我们可以使用issubset方法来实现这个功能，但这需要为每个客户的列表创建集合对象，这是不必要的重复。因此，当你共享一个可能是超集的集合对象时，issuperset比issubset更好。在我们的情况下，这是推荐的股票集合。
- en: As you can tell, the solution that uses issuperset is more concise than the
    one that uses a custom function. More importantly, when we use a built-in function
    instead of a custom function, our program is less prone to bugs.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用issuperset的解决方案比使用自定义函数的解决方案更简洁。更重要的是，当我们使用内置函数而不是自定义函数时，我们的程序更不容易出错。
- en: Maintainability Writing functions to solve problems is great. Using existing
    functions, such as the built-in ones, is even greater!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 编写函数来解决问题是很好的。使用现有函数，例如内置函数，则更好！
- en: 3.6.2 Checking whether a list contains any element of another list
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.2 检查一个列表是否包含另一个列表的任何元素
- en: Another common scenario regarding relationships between lists is whether a list
    contains any element of another list. This section addresses that problem.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 关于列表之间关系的一个常见场景是，一个列表是否包含另一个列表的任何元素。本节将解决这个问题。
- en: To facilitate the discussion, let’s continue the example of stock recommendation.
    Suppose that we want to check whether a client’s list of stocks contains any of
    the recommended stocks. As shown in section 3.6.1, this functionality is provided
    by the iteration technique (see the following listing).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于讨论，让我们继续使用股票推荐的例子。假设我们想要检查一个客户的股票列表是否包含任何推荐的股票。如第3.6.1节所示，这种功能由迭代技术提供（见以下列表）。
- en: Listing 3.10 Checking whether a list contains any item of another list
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.10 检查一个列表是否包含另一个列表中的任何项
- en: '[PRE38]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The logic of the function in listing 3.10 is opposite to the one in listing
    3.9\. If we can find any item of the client’s list in the recommended list, our
    criterion is satisfied, and the function returns True; otherwise, there is no
    matching record, and the function returns False. The following code snippet shows
    two use cases:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.10中函数的逻辑与列表3.9中的逻辑相反。如果我们能在客户的列表中找到推荐列表中的任何项，则满足我们的标准，函数返回True；否则，没有匹配的记录，函数返回False。以下代码片段显示了两个用例：
- en: '[PRE39]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The question of whether a list contains any item of another list is essentially
    a question of whether any overlap exists between them. Unfortunately, there are
    no built-in methods to check the relationships between two list objects. Such
    methods exist for set objects, however. One key set operation creates an intersection
    between two set objects, which is exactly what we need. Here’s a solution:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是否包含另一个列表中的任何项的问题本质上是一个问题，即它们之间是否存在任何重叠。不幸的是，没有内置的方法来检查两个列表对象之间的关系。然而，对于集合对象，存在这样的方法。一个关键的集合操作是在两个集合对象之间创建交集，这正是我们所需要的。以下是一个解决方案：
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using the intersection operator &, we conveniently retrieve the intersection
    between two set objects. If we want to have the Boolean output, we can use the
    built-in bool function, which evaluates any nonempty collection data, such as
    a set here, as True.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交集运算符&，我们可以方便地检索两个集合对象之间的交集。如果我们想要得到布尔输出，我们可以使用内置的bool函数，它评估任何非空集合数据，例如这里的集合，将其评估为True。
- en: Trivia The bool function is the bool constructor, which creates a bool object
    by evaluating the item inside the parentheses. set objects are evaluated to be
    True if they contain at least one item.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点 bool函数是bool构造函数，它通过评估括号内的项来创建一个bool对象。如果集合对象至少包含一个项，则它们将被评估为True。
- en: 'Besides using & between two set objects, the intersection operation can be
    performed with the intersection method. Like issuperset, what makes intersection
    convenient is that it can take any iterable in such a way that we can send the
    list objects client0 and client1 directly to the method without converting them
    to set objects first. Observe this feature in the following code snippet:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在两个集合对象之间使用&运算符之外，还可以使用交集方法执行交集操作。与issuperset一样，使交集方便的是它可以接受任何可迭代对象，这样我们就可以直接将列表对象client0和client1发送到方法中，而无需先将它们转换为集合对象。以下代码片段中观察这一特性：
- en: '[PRE41]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In sections 3.6.1 and 3.6.2, we used set operations to examine common relationships
    between list objects. Let’s step back and take a look at more general operations
    with set objects in Python, particularly for examining the relationships between
    sets.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3.6.1节和第3.6.2节中，我们使用了集合操作来检查列表对象之间的常见关系。现在让我们回顾一下Python中集合对象的更一般操作，特别是检查集合之间的关系。
- en: 3.6.3 Dealing with multiple set objects
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.3 处理多个集合对象
- en: 'As discussed in section 3.5, set objects are best for use cases that require
    membership checking, because this operation has the O(1) complexity. Besides membership
    testing, when you have multiple set objects that are related, you may need to
    carry out operations between them. In this section, we touch base on operations
    dealing with multiple set objects. Four set operations are most common: union,
    intersection, symmetric difference, and difference (figure 3.8).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如第3.5节所述，集合对象最适合用于需要检查成员资格的场景，因为这种操作的复杂度为O(1)。除了成员资格测试之外，当你拥有多个相关的集合对象时，你可能需要在它们之间执行操作。在本节中，我们将探讨处理多个集合对象的操作。最常见的四种集合操作是：并集、交集、对称差集和差集（图3.8）。
- en: '![CH03_F08_Cui](../Images/CH03_F08_Cui.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F08_Cui](../Images/CH03_F08_Cui.png)'
- en: Figure 3.8 Set operations in Python. Four common set operations are shown with
    their respective mathematical notations, Venn diagrams, and operations in Python.
    Union consists of members from A and B. Intersection consists of members common
    to A and B. Symmetric difference consists of members of one set but not both.
    Difference consists of members of one set but not both.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 Python 中的集合操作。展示了四个常见的集合操作及其相应的数学符号、维恩图和 Python 中的操作。并集包含来自 A 和 B 的成员。交集包含
    A 和 B 共有的成员。对称差集包含一个集合的成员但不包含两个集合的成员。差集包含一个集合的成员但不包含两个集合的成员。
- en: 'All four operations have corresponding special operators, which simplify the
    syntax. The following code snippet shows these operations. As you can see, these
    operations are useful when you try to select the members that fit specific criteria,
    such as belonging to both sets (intersection) or to either set (union):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 所有四个操作都有相应的特殊操作符，这简化了语法。以下代码片段展示了这些操作。正如你所见，这些操作在尝试选择符合特定标准（如属于两个集合的交集或任一集合的并集）的成员时非常有用：
- en: '[PRE42]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Union operation with |
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 `|` 进行并集操作
- en: ❷ Intersection operation with &
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 `&` 进行交集操作
- en: ❸ Symmetric difference operation with ^
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 `^` 进行对称差集操作
- en: ❹ Difference operation with -
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 `-` 进行差集操作
- en: Trivia You may get the results in a different order. The items stored in a set
    object are unordered because they use hash tables and are not concerned with the
    item order.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点 你可能会得到不同的结果顺序。集合对象中存储的项是无序的，因为它们使用哈希表，并且不关心项的顺序。
- en: 'Besides these operations, which create a set from other sets, there are methods
    issubset and issuperset, which check the relationships between two sets. issubset
    checks whether the method caller is a subset of the other set (more generally,
    it can be any iterable), and issuperset checks the opposite. Following are some
    trivial examples:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些从其他集合创建集合的操作之外，还有 `issubset` 和 `issuperset` 方法，它们用于检查两个集合之间的关系。`issubset`
    检查调用方法是否是另一个集合的子集（更一般地说，它可以是对任何可迭代的），而 `issuperset` 检查相反的情况。以下是一些简单的例子：
- en: '[PRE43]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We have seen the four set-related operations (union, intersection, symmetric
    difference, and difference), their corresponding methods, and their respective
    operators. Interestingly, the issuperset and issubset methods have corresponding
    operators. These methods and operators are summarized in table 3.2.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了四个与集合相关的操作（并集、交集、对称差集和差集）、它们对应的方法以及各自的操作符。有趣的是，`issuperset` 和 `issubset`
    方法有对应的操作符。这些方法和操作符总结在表 3.2 中。
- en: Table 3.2 Set operators and their corresponding methods
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2 集合操作符及其对应的方法
- en: '| Set operation | Operator | Method |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 集合操作 | 操作符 | 方法 |'
- en: '| Union | &#124; | union |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 并集 | &#124; | union |'
- en: '| Intersection | & | intersection |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 交集 | & | intersection |'
- en: '| Symmetric difference | ^ | symmetric_difference |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 对称差集 | ^ | symmetric_difference |'
- en: '| Difference | - | difference |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 差集 | - | difference |'
- en: '| Checks whether one set is a superset of the other | >= | issuperset |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 检查一个集合是否是另一个集合的超集 | >= | issuperset |'
- en: '| Checks whether one set is a subset of the other | <= | issubset |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 检查一个集合是否是另一个集合的子集 | <= | issubset |'
- en: '| Checks whether one set is a strict superset of the other | > | N/A but can
    be achieved by combining issuperset and != |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 检查一个集合是否是另一个集合的严格超集 | > | N/A 但可以通过组合 issuperset 和 != 实现 |'
- en: '| Checks whether one set is a strict subset of the other | < | N/A but can
    be achieved by combining issubset and != |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 检查一个集合是否是另一个集合的严格子集 | < | N/A 但可以通过组合 issubset 和 != 实现 |'
- en: Although operators make your code more concise, they work only with set objects.
    By contrast, all these methods can take iterables as their parameters; thus, they’re
    more flexible. When you deal with iterables that aren’t set objects, you should
    consider using these methods directly, which eliminates the need to convert them
    to set objects first.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然操作符可以使你的代码更简洁，但它们只能与集合对象一起使用。相比之下，所有这些方法都可以接受可迭代对象作为它们的参数；因此，它们更灵活。当你处理不是集合对象的可迭代对象时，你应该考虑直接使用这些方法，这样可以消除首先将它们转换为集合对象的需求。
- en: Readability Prefer using the pertinent methods when you perform set operations;
    they’re not only more flexible (because they take any iterables), but also more
    understandable (because of their names).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 在执行集合操作时，优先使用相关的方法；它们不仅更灵活（因为它们接受任何可迭代对象），而且更易于理解（因为它们的名称）。
- en: 3.6.4 Discussion
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.4 讨论
- en: Set objects are the preferred data model for storing unique members, and Python
    provides a series of operations to manipulate multiple set objects and examine
    their relationships. Because lists don’t have native methods to check the relationships
    between lists, we can conveniently convert lists to sets to derive the relationships
    of the initial list objects.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 集合对象是存储唯一成员的首选数据模型，Python提供了一系列操作来操作多个集合对象并检查它们之间的关系。由于列表没有检查列表之间关系的原生方法，我们可以方便地将列表转换为集合，以推导出初始列表对象的关系。
- en: 3.6.5 Challenge
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.5 挑战
- en: When we perform the union operation between two sets, this operation generates
    a set consisting of all members from either set. Thus, this operation resembles
    an OR operation. Do you know what will happen if you use the keyword or between
    two sets? What result are you expecting for the operation {1, 2, 3} or {4, 5,
    6}? In a similar fashion, some people may liken the intersection operation to
    the AND operation. Can you guess the result of the operation {1, 2, 3} and {4,
    5, 6}?
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在两个集合之间执行并集操作时，这个操作生成一个包含来自任一集合的所有成员的集合。因此，这个操作类似于OR操作。你知道如果你在两个集合之间使用关键字or会发生什么吗？你期望这个操作的{1,
    2, 3}或{4, 5, 6}的结果是什么？以类似的方式，有些人可能将交集操作比作AND操作。你能猜出操作{1, 2, 3}和{4, 5, 6}的结果吗？
- en: Hint These evaluations are also known as *short-circuit evaluations**.* The
    or operation evaluates to the first object if the first object has a Boolean value
    of True; otherwise, it evaluates to the second object. For the and operation,
    it evaluates to the first object if the first object has a Boolean value of False;
    otherwise, it evaluates to the second object.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 这些评估也被称为*短路评估**。或操作在第一个对象具有布尔值True时评估为第一个对象；否则，它评估为第二个对象。对于与操作，如果第一个对象具有布尔值False，则它评估为第一个对象；否则，它评估为第二个对象。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Lists are a mutable data type, allowing us to add, insert, update, and delete
    items, whereas tuples are immutable in that you cannot modify them after creation.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表是可变的数据类型，允许我们添加、插入、更新和删除项，而元组是不可变的，这意味着你无法在创建后修改它们。
- en: Besides their difference in mutability, lists and tuples are different in terms
    of the homogeneity of the contained data. We use lists to hold items that are
    semantically homogeneous, and these items form a linear ordered sequence. We use
    tuples to hold items that are semantically distinct, and these items form a structural
    sequence.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了它们在可变性的差异之外，列表和元组在包含数据的同质性方面也有所不同。我们使用列表来存储语义上同质的项，这些项形成一个线性有序序列。我们使用元组来存储语义上不同的项，这些项形成一个结构序列。
- en: Default sorting can sort a list only by using the numeric or lexicographic order,
    which is rather limited. Thus, we need to understand how to use a custom function
    as a key argument to specify the sorting requirement.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认排序只能使用数值或字典序对列表进行排序，这相当有限。因此，我们需要了解如何使用自定义函数作为键参数来指定排序要求。
- en: When you need a simple data container, you should consider using named tuples,
    which allow you to create a class with one line of code. Named tuples have a few
    advantages, including memory efficiency and dot notation for attribute retrieval.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要一个简单的数据容器时，你应该考虑使用命名元组，这允许你通过一行代码创建一个类。命名元组有几个优点，包括内存效率和点符号用于属性检索。
- en: When we access all the keys, values, or key-value pairs of a dictionary, we
    prefer using the dictionary view objects because they will be updated automatically
    in sync with the underlying dictionary object.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们访问字典的所有键、值或键值对时，我们更喜欢使用字典视图对象，因为它们将与底层字典对象同步自动更新。
- en: Only hashable objects can be dictionary keys and set items in Python. Common
    hashable data types include int, float, str, tuple, bool, and NoneType.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中，只有可哈希的对象才能成为字典键和集合项。常见的可哈希数据类型包括int、float、str、tuple、bool和NoneType。
- en: With the underlying hash implementation, item lookup with dictionaries and sets
    is efficient, with a time complexity of O(1).
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于底层的哈希实现，使用字典和集合进行项查找是高效的，时间复杂度为O(1)。
- en: The get method retrieves a dictionary’s item without triggering the KeyError
    exception. It’s the preferred method when you work with dictionaries that other
    people created.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: get方法检索字典的项而不触发KeyError异常。当你与其他人创建的字典一起工作时，这是首选方法。
- en: If you work with dictionaries that you create, you may want to use subscripting
    (dict[key]), which allows any misspelling of the keys to surface by itself.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用你创建的字典，你可能想使用下标（dict[key]），这允许键的任何拼写错误自行暴露。
- en: A set is a data structure that is specialized to deal with members with unique
    values. There are multiple operations between set objects, such as union and difference.
    You can take advantage of these operations if you need to check the relationships
    between other nonset data types, such as lists.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合是一种专门用于处理具有唯一值成员的数据结构。集合对象之间存在多种操作，例如并集和差集。如果你需要检查其他非集合数据类型（如列表）之间的关系，可以利用这些操作。
