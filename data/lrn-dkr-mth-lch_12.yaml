- en: 11 Building and testing applications with Docker and Docker Compose
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 使用Docker和Docker Compose构建和测试应用程序
- en: Automation is at the heart of Docker. You describe the steps to package your
    component in a Dockerfile and use the Docker command line to execute them; you
    describe the architecture of your app in a Docker Compose file and use the Compose
    command line to start and stop the app. Command-line tools fit very neatly with
    automated processes, like jobs that run on a daily schedule or whenever developers
    push code changes. It doesn’t matter which tool you’re using to run those jobs;
    they all let you run scripted commands so you can easily integrate the Docker
    workflow with your automation server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化是Docker的核心。你通过Dockerfile描述将组件打包的步骤，并使用Docker命令行来执行这些步骤；你通过Docker Compose文件描述你的应用程序架构，并使用Compose命令行来启动和停止应用程序。命令行工具非常适合与自动化流程配合，比如每天定时运行或开发者推送代码更改时运行的作业。无论你使用哪种工具来运行这些作业，它们都允许你运行脚本命令，这样你就可以轻松地将Docker工作流程与自动化服务器集成。
- en: In this chapter you’re going to learn how to do continuous integration (CI)
    with Docker. CI is an automated process that runs regularly to build applications
    and execute a suite of tests. When the CI job is healthy, it means the latest
    code for the app is good and has been packaged and is ready to deploy as a release
    candidate. Setting up and managing CI servers and jobs used to be time consuming
    and intensive--“build manager” was a full-time role for a human in a large project.
    Docker simplifies every part of the CI process and frees people up for more interesting
    work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用Docker进行持续集成（CI）。CI是一个定期运行的自动化过程，用于构建应用程序并执行一系列测试。当CI作业健康时，这意味着应用程序的最新代码是好的，已经被打包，并作为发布候选准备部署。设置和管理CI服务器和作业曾经是耗时且密集的工作——“构建经理”在大型项目中是一个全职角色。Docker简化了CI过程的每个部分，并让人们有更多时间从事更有趣的工作。
- en: 11.1 How the CI process works with Docker
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 Docker中CI过程的工作原理
- en: The CI process is a pipeline that starts with code, executes a set of steps,
    and finishes with a tested deployable artifact. One of the challenges with CI
    is that pipelines become unique for each project--different technology stacks
    do different things in the steps and produce different types of artifacts. The
    CI server needs to work for all those unique pipelines, so every combination of
    programming language and build framework can get installed on the server, and
    it can easily become unmanageable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: CI过程是一个从代码开始，执行一系列步骤，并以经过测试的可部署工件结束的管道。CI的一个挑战是，每个项目的管道都是独特的——不同的技术堆栈在步骤中执行不同的操作并产生不同类型的工件。CI服务器需要适用于所有这些独特的管道，因此服务器上可以安装所有编程语言和构建框架的组合，这可能会变得难以管理。
- en: Docker brings consistency to the CI process because every project follows the
    same steps and produces the same type of artifact. Figure 11.1 shows a typical
    pipeline with Docker--it is triggered by a code change or a timed schedule, and
    it produces a set of Docker images. Those images contain the latest version of
    the code--compiled, tested, packaged, and pushed to a registry for distribution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Docker为CI过程带来了一致性，因为每个项目都遵循相同的步骤并产生相同类型的工件。图11.1展示了使用Docker的典型管道——它由代码更改或定时计划触发，并生成一系列Docker镜像。这些镜像包含最新版本的代码——编译、测试、打包，并推送到注册表以进行分发。
- en: '![](../Images/11-1.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图11-1](../Images/11-1.jpg)'
- en: Figure 11.1 The basic steps of a CI pipeline to build, test, and publish apps--all
    executed with Docker.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 使用Docker构建、测试和发布应用程序的基本CI管道步骤。
- en: Each step in the CI pipeline runs with Docker or Docker Compose, and all the
    work happens inside containers. You use containers to compile applications, so
    the CI server doesn’t need to have any programming languages or build SDKs installed.
    Automated unit tests run as part of the image build, so if the code is broken,
    the build fails and the CI job stops. You can also run more sophisticated end-to-end
    tests by starting the whole application with Docker Compose alongside a separate
    container that runs tests to simulate user workflows.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: CI管道中的每一步都使用Docker或Docker Compose运行，所有工作都在容器内完成。你使用容器来编译应用程序，因此CI服务器不需要安装任何编程语言或构建SDK。自动单元测试作为镜像构建的一部分运行，所以如果代码有误，构建将失败，CI作业将停止。你还可以通过启动整个应用程序（使用Docker
    Compose）以及一个运行测试的独立容器来运行更复杂的端到端测试，该容器模拟用户工作流程。
- en: 'In a Dockerized CI process, all the hard work happens in containers, but you
    still need some infrastructure components to hold everything together: a centralized
    source code system, a Docker registry to store images, and an automation server
    to run the CI jobs. There’s a huge choice of managed services you can choose from
    that all support Docker--you can mix and match GitHub with Azure DevOps and Docker
    Hub, or you could use GitLab, which provides an all-in-one solution. Or you can
    run your own CI infrastructure in Docker containers.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker化的CI流程中，所有艰苦的工作都在容器中完成，但你仍然需要一些基础设施组件来将一切整合在一起：一个集中的源代码系统、一个用于存储镜像的Docker注册库，以及一个自动化服务器来运行CI作业。你可以从众多支持Docker的托管服务中选择，这些服务都可以混合搭配——你可以将GitHub与Azure
    DevOps和Docker Hub结合使用，或者你可以使用GitLab，它提供了一站式解决方案。或者你也可以在Docker容器中运行自己的CI基础设施。
- en: 11.2 Spinning up build infrastructure with Docker
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 使用Docker启动构建基础设施
- en: No one wants to run their own infrastructure components when you can get reliable
    managed services for free, but running the build system in Docker is a very useful
    alternative to know. It’s ideal if you want to keep your source code and packaged
    images entirely within your own network--for data sovereignty or transfer speed--but
    even if you use services for everything, it’s great to have a simple backup option
    for the rare occasions when GitHub or Docker Hub have an outage, or your internet
    connection goes offline.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你可以免费获得可靠的托管服务时，没有人愿意运行自己的基础设施组件，但了解在Docker中运行构建系统是一个非常实用的替代方案。如果你希望将源代码和打包的镜像完全保留在自己的网络内——为了数据主权或传输速度——这是理想的。即使你使用服务处理所有事情，当GitHub或Docker
    Hub出现故障，或者你的互联网连接断开时，拥有一个简单的备份选项也是极好的。
- en: The three components you need can easily be run in containers using enterprise-grade
    open source software. With a single command you can run your own setup using Gogs
    for source control, the open source Docker registry for distribution, and Jenkins
    as the automation server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的三个组件可以很容易地在容器中使用企业级开源软件运行。你可以使用一条命令运行自己的设置，使用Gogs进行源代码控制，开源Docker注册库进行分发，以及Jenkins作为自动化服务器。
- en: Try it now In the `exercises` folder for this chapter, there’s a Docker Compose
    file that defines the build infrastructure. One part of the setup is different
    for Linux and Windows containers, so you’ll need to select the right files. You’ll
    also need to add an entry to your hosts file for the DNS name `registry.local`
    if you didn’t do that in section 5.3.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 在本章的`exercises`文件夹中，有一个定义构建基础设施的Docker Compose文件。设置的一部分对于Linux和Windows容器是不同的，所以你需要选择正确的文件。如果你在5.3节中没有这样做，你还需要在你的hosts文件中添加一个条目，用于DNS名称`registry.local`。
- en: '` cd ch11/exercises/infrastructure`  ` # start the app with Linux containers:`
    ` docker-compose -f docker-compose.yml -f docker-compose-linux.yml up -d`  ` #
    OR start with Windows containers:` ` docker-compose -f docker-compose.yml -f docker-compose-windows.yml
    up -d`  ` # add registry domain to local hosts file on Mac or Linux:` ` echo $''\n127.0.0.1
    registry.local'' | sudo tee -a /etc/hosts`  ` # OR on Windows:` ` Add-Content
    -Value "127.0.0.1 registry.local" -Path /windows/system32/drivers/etc/hosts` 
    ` # check containers:` ` docker container ls`'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ch11/exercises/infrastructure`  ` # 使用Linux容器启动应用:` ` docker-compose -f
    docker-compose.yml -f docker-compose-linux.yml up -d`  ` # 或者使用Windows容器启动:` ` docker-compose
    -f docker-compose.yml -f docker-compose-windows.yml up -d`  ` # 在Mac或Linux上向本地hosts文件添加注册库域名:`
    ` echo $''\n127.0.0.1 registry.local'' | sudo tee -a /etc/hosts`  ` # 或者Windows上:`
    ` Add-Content -Value "127.0.0.1 registry.local" -Path /windows/system32/drivers/etc/hosts` 
    ` # 检查容器:` ` docker container ls`'
- en: You can see my output in figure 11.2\. The commands are different on Linux and
    Windows, but the outcome is the same--you’ll have the Gogs Git server published
    to port 3000, Jenkins published to port 8080, and the registry published to port
    5000.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图11.2中看到我的输出。Linux和Windows上的命令不同，但结果相同——你将拥有发布到端口3000的Gogs Git服务器，发布到端口8080的Jenkins，以及发布到端口5000的注册库。
- en: '![](../Images/11-2.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-2.jpg)'
- en: Figure 11.2 Running your whole build infrastructure in containers with one command
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 使用一条命令在容器中运行整个构建基础设施
- en: Those three tools are interesting to work with because they support different
    levels of automation. The registry server runs in a container without any extra
    setup, so now you can push and pull images using `registry.local:5000` as the
    domain in your image tags. Jenkins uses a plugin system to add functionality,
    and you can set that up manually, or you can bundle a set of scripts in the Dockerfile
    to automate the setup for you. Gogs doesn’t really have a good automation story,
    so although it’s running, it needs some manual configuration.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个工具很有趣，因为它们支持不同级别的自动化。注册服务器在容器中运行，无需任何额外设置，因此现在您可以使用 `registry.local:5000`
    作为您的镜像标签中的域名来推送和拉取镜像。Jenkins 使用插件系统来添加功能，您可以手动设置它，或者您可以在 Dockerfile 中捆绑一组脚本来自动化设置。Gogs
    并没有很好的自动化故事，所以尽管它在运行，但仍需要一些手动配置。
- en: 'Try it now Browse to http: */ /* localhost:3000 and you’ll see the web UI for
    Gogs. The first page is the initial installation, shown in figure 11.3\. This
    is shown only on the first use of a new container. All the values are correctly
    configured; you just need to scroll down and click Install Gogs.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '现在试试吧 浏览到 http: */ /* localhost:3000，您将看到 Gogs 的 Web UI。第一页是初始安装，如图 11.3 所示。这仅在首次使用新容器时显示。所有值都已正确配置；您只需向下滚动并点击安装
    Gogs。'
- en: '![](../Images/11-3.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-3.jpg)'
- en: Figure 11.3 Running Gogs in a container. It’s an open source Git server that
    needs some manual setup.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 在容器中运行 Gogs。它是一个需要一些手动设置的开源 Git 服务器。
- en: The installation completes very quickly, and you’ll come to the sign-on page.
    There isn’t a default account, so you’ll need to click Register to create one.
    Create a user with the username `diamol` , as in figure 11.4--you can use any
    email address or password, but the Jenkins CI job expects the Gogs user to be
    called `diamol` .
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 安装非常快速，您将进入登录页面。没有默认账户，因此您需要点击注册来创建一个。创建一个用户名为 `diamol` 的用户，如图 11.4 所示--您可以使用任何电子邮件地址或密码，但
    Jenkins CI 作业期望 Gogs 用户名为 `diamol`。
- en: '![](../Images/11-4.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-4.jpg)'
- en: Figure 11.4 Creating a new user in Gogs that you can use to push source code
    to the server
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 创建一个新用户在 Gogs 中，您可以使用该用户将源代码推送到服务器
- en: Click Create New Account, and then sign in with the `diamol` username and your
    password. The final step is to create a repository--that’s where we’ll push the
    code that will trigger the CI job. Browse to http:/ /localhost:3000/repo/create
    and create a repository called `diamol` --the other details can be left empty,
    as in figure 11.5.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 点击创建新账户，然后使用 `diamol` 用户名和您的密码登录。最后一步是创建一个仓库--这是我们将会推送触发 CI 作业的代码的地方。浏览到 http:/
    /localhost:3000/repo/create 并创建一个名为 `diamol` 的仓库--其他细节可以留空，如图 11.5 所示。
- en: '![](../Images/11-5.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-5.jpg)'
- en: Figure 11.5 Creating a Git repository in Gogs where you can upload the source
    code for your apps
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 在 Gogs 中创建 Git 仓库，您可以在此处上传您应用的源代码
- en: It’s pretty frustrating to have to manually configure software when you’re running
    it in Docker, and it’s much more frustrating having to copy and paste screenshots
    into a book, but not every app lets you fully automate the installation. I could
    have built a custom image with those setup steps already done, but it’s important
    for you to see that you can’t always package things nicely into the `docker` `container`
    `run` workflow.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 Docker 中运行软件时需要手动配置软件，这相当令人沮丧，而且更令人沮丧的是需要将截图复制粘贴到书中，但并非每个应用程序都允许您完全自动化安装。我本可以构建一个包含这些设置步骤的定制镜像，但重要的是让您看到您并不总能将事物优雅地打包到
    `docker` `container` `run` 工作流程中。
- en: Jenkins is a better experience. Jenkins is a Java application, and you can package
    it as a Docker image with a set of scripts that run when the container starts.
    Those scripts can do pretty much anything--install plugins, register users, and
    create pipeline jobs. This Jenkins container does all that, so you can log straight
    in and start using it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 提供了更好的体验。Jenkins 是一个 Java 应用程序，您可以使用一组在容器启动时运行的脚本将其打包为 Docker 镜像。这些脚本几乎可以完成任何事情--安装插件、注册用户和创建管道作业。这个
    Jenkins 容器做了所有这些，因此您可以直接登录并开始使用它。
- en: '![](../Images/11-6.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-6.jpg)'
- en: Figure 11.6 Running Jenkins in a container--it is fully configured with a user
    and CI job already set up.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 在容器中运行 Jenkins -- 它已经完全配置好，包括用户和 CI 作业已经设置好。
- en: 'Try it now Browse to http: */ /* localhost:8080\. You’ll see the screen in
    figure 11.6--there’s already a job configured called `diamol` that is in the failed
    state. Click the Log In link at the top right and log in with username *diamol*
    and password *diamol* .'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。浏览到 http://localhost:8080。你会看到图 11.6 中的屏幕——那里已经有一个名为 `diamol` 的配置好的作业，它处于失败状态。点击右上角的“登录”链接，使用用户名
    *diamol* 和密码 *diamol* 登录。
- en: The Jenkins job failed because it’s configured to fetch code from the Gogs Git
    server, and there’s no code in there yet. The source code for this book is already
    a Git repository that you originally cloned from GitHub. You can add your local
    Gogs container as another Git server for the repo, and push the book’s code to
    your own infrastructure.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 作业失败是因为它被配置为从 Gogs Git 服务器获取代码，但目前还没有代码。这本书的源代码已经是一个 Git 仓库，你最初是从 GitHub
    克隆的。你可以将你的本地 Gogs 容器作为另一个 Git 服务器添加到仓库中，并将书籍的代码推送到你自己的基础设施。
- en: 'Try it now You can add an extra Git server using `git` `remote` `add` and then
    push to the remote. This uploads the code from your local machine to the Gogs
    server, which just happens to be a container on your machine too:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。你可以使用 `git remote add` 添加一个额外的 Git 服务器，然后推送远程。这会将你本地机器上的代码上传到 Gogs 服务器，而
    Gogs 服务器恰好也是你机器上的一个容器：
- en: '` git remote add local http://localhost:3000/diamol/diamol.git`  ` git push
    local`  ` # Gogs will ask you to login -` ` # use the diamol username and password
    you registered in Gogs`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '` git remote add local http://localhost:3000/diamol/diamol.git`  ` git push
    local`  ` # Gogs 将要求你登录 -` ` # 使用你在 Gogs 中注册的 diamol 用户名和密码`'
- en: Now you have the source code for the whole book in your local Git server. The
    Jenkins job is configured to look for changes to the code every minute, and if
    there are changes, it will trigger the CI pipeline. The first job run failed because
    the code repository didn’t exist, so Jenkins has put the schedule on hold. You’ll
    need to manually run the job now to start the schedule working again.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将整本书的源代码放在了你的本地 Git 服务器上。Jenkins 作业被配置为每分钟检查代码的更改，如果有更改，它将触发 CI 管道。第一次作业运行失败是因为代码仓库不存在，所以
    Jenkins 已经暂停了计划。你需要手动运行作业以再次启动计划。
- en: '![](../Images/11-7.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7](../Images/11-7.jpg)'
- en: Figure 11.7 The Jenkins job page shows the current status of the job and lets
    you manually start a build.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 Jenkins 的工作页面显示了作业的当前状态，并允许你手动启动构建。
- en: Try it now Browse to http:/ /localhost:8080/job/diamol. You’ll see the screen
    in figure 11.7, and you can click Build Now in the left-hand menu to run the job.
    If you don’t see the Build Now option, make sure you’ve logged into Jenkins with
    the `diamol` credentials.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。浏览到 http://localhost:8080/job/diamol。你会看到图 11.7 中的屏幕，你可以在左侧菜单中点击“现在构建”来运行作业。如果你看不到“现在构建”选项，请确保你已经使用
    `diamol` 凭据登录到 Jenkins。
- en: After a minute or so, the build will complete successfully, the web page will
    refresh, and you’ll see the output in figure 11.8.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 大约一分钟后，构建将成功完成，网页将刷新，你将在图 11.8 中看到输出。
- en: '![](../Images/11-8.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8](../Images/11-8.jpg)'
- en: Figure 11.8 The job page in Jenkins shows the status of the most recent builds,
    and the pipeline steps.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 Jenkins 的工作页面显示了最近构建的状态和管道步骤。
- en: 'Every part of this pipeline ran using Docker containers, taking advantage of
    a neat trick: containers running in Docker can connect to the Docker API and start
    new containers on the same Docker Engine they’re running on. The Jenkins image
    has the Docker CLI installed, and the configuration in the Compose file sets up
    Jenkins so when it runs Docker commands they get sent to the Docker Engine on
    your machine. It sounds odd, but it’s really just taking advantage of the fact
    that the Docker CLI calls into the Docker API, so CLIs from different places can
    connect to the same Docker Engine. Figure 11.9 shows how that works.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管道的每一部分都是使用 Docker 容器运行的，利用了一个巧妙的小技巧：在 Docker 中运行的容器可以连接到 Docker API 并在它们运行的同一个
    Docker 引擎上启动新的容器。Jenkins 镜像安装了 Docker CLI，而 Compose 文件中的配置设置了 Jenkins，当它运行 Docker
    命令时，这些命令会被发送到你机器上的 Docker 引擎。这听起来很奇怪，但实际上只是利用了 Docker CLI 调用 Docker API 的这一事实，因此来自不同地方的
    CLI 可以连接到同一个 Docker 引擎。图 11.9 展示了它是如何工作的。
- en: '![](../Images/11-9.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9](../Images/11-9.jpg)'
- en: Figure 11.9 Running containers with a volume to bind the private channel for
    the Docker API
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 使用卷绑定 Docker API 的私有通道运行容器
- en: The Docker CLI connects to the local Docker API by default, using a communication
    channel that is private to your machine--a socket on Linux or a named pipe on
    Windows. That communication channel can be used as a bind mount for containers,
    so when the CLI in the container runs, it’s actually connecting to the socket
    or named pipe on your machine. That unlocks some useful scenarios where apps inside
    containers can query Docker to find other containers, or start and stop new containers.
    There is also a security concern here, because the app in the container has full
    access to all the Docker features on the host, so you need to use this carefully
    with Docker images that you trust--you can trust my `diamol` images, of course.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Docker CLI 默认通过本地 Docker API 连接，使用一个仅限于您机器的私有通信通道——Linux 上的套接字或 Windows 上的命名管道。这个通信通道可以用作容器的绑定挂载，因此当容器中的
    CLI 运行时，它实际上是在连接到您机器上的套接字或命名管道。这解锁了一些有用的场景，其中容器内的应用程序可以查询 Docker 以找到其他容器，或启动和停止新的容器。这里也存在一个安全问题，因为容器中的应用程序可以完全访问主机上的所有
    Docker 功能，所以您需要谨慎使用您信任的 Docker 镜像——当然，您可以信任我的 `diamol` 镜像。
- en: Listing 11.1 shows part of the Docker Compose files you ran to start the infrastructure
    containers, focusing on the Jenkins specification. You can see the volumes are
    binding to the Docker socket in the Linux version and the named pipe in the Windows
    version--this is the address of the Docker API.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 展示了您启动基础设施容器时运行的 Docker Compose 文件的部分内容，重点关注 Jenkins 规范。您可以看到卷绑定到了 Linux
    版本的 Docker 套接字和 Windows 版本的命名管道——这是 Docker API 的地址。
- en: Listing 11.1 Binding the Docker CLI in Jenkins to the Docker Engine
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 将 Jenkins 中的 Docker CLI 绑定到 Docker 引擎
- en: '` # docker-compose.yml` ` services:` `   jenkins:` `       image: diamol/jenkins`
    `       ports:` `           - "8080:8080"` `       networks:` `           - infrastructure` 
    ` # docker-compose-linux.yml` ` jenkins:` `   volumes:` `       - type: bind`
    `           source: /var/run/docker.sock` `           target: /var/run/docker.sock` 
    ` # docker-compose-windows.yml` ` jenkins:` `   volumes:` `       - type: npipe`
    `           source: \\.\pipe\docker_engine` `             target: \\.\pipe\docker_engine`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '` # docker-compose.yml` ` services:` `   jenkins:` `       image: diamol/jenkins`
    `       ports:` `           - "8080:8080"` `       networks:` `           - infrastructure` 
    ` # docker-compose-linux.yml` ` jenkins:` `   volumes:` `       - type: bind`
    `           source: /var/run/docker.sock` `           target: /var/run/docker.sock` 
    ` # docker-compose-windows.yml` ` jenkins:` `   volumes:` `       - type: npipe`
    `           source: \\.\pipe\docker_engine` `             target: \\.\pipe\docker_engine`'
- en: That’s all the infrastructure you need. Jenkins connects to the Docker Engine
    to run Docker and Docker Compose commands, and it can connect to the Git server
    and the Docker registry by DNS because they’re all containers in the same Docker
    network. The CI process runs a single command to build the application, and all
    the complexity of the build is captured in Dockerfiles and Docker Compose files.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要的所有基础设施。Jenkins 通过连接到 Docker 引擎来运行 Docker 和 Docker Compose 命令，并且因为它与 Git
    服务器和 Docker 仓库都在同一个 Docker 网络中，所以它可以通过 DNS 连接到它们。CI 流程运行单个命令来构建应用程序，所有构建的复杂性都记录在
    Dockerfile 和 Docker Compose 文件中。
- en: 11.3 Capturing build settings with Docker Compose
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 使用 Docker Compose 捕获构建设置
- en: The job that Jenkins ran has built a new version of the random number application
    from chapter 8\. You’ve seen in chapter 10 how you can break up an application
    definition across multiple Compose files, and this app uses that approach to capture
    the details of the build settings. Listing 11.2 is from the base `docker-compose.yml`
    file in the `ch11/exercises` folder--it contains the web and API service definitions
    with environment variables in the image name.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 运行的作业构建了第 8 章中随机数应用程序的新版本。您在第 10 章中看到过如何将应用程序定义拆分到多个 Compose 文件中，这个应用程序就是使用这种方法来捕获构建设置的细节。列表
    11.2 来自 `ch11/exercises` 文件夹中的基本 `docker-compose.yml` 文件——它包含带有环境变量的镜像名称的 Web
    和 API 服务定义。
- en: Listing 11.2 A core Docker Compose file using variables in the image tags
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 使用镜像标签中的变量作为核心 Docker Compose 文件
- en: '` services:` `   numbers-api:` `       image: ${REGISTRY:-docker.io}/diamol/ch11-numbers-api:v3-build-${BUILD_NUMBER:-local}`
    `       networks:` `           - app-net`  `   numbers-web:` `       image: ${REGISTRY:-docker.io}/diamol/ch11-numbers-web:v3-build-${BUILD_NUMBER:-local}`
    `       environment:` `           - RngApi__Url=http://numbers-api/rng` `       networks:`
    `             - app-net`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '` services:` `   numbers-api:` `       image: ${REGISTRY:-docker.io}/diamol/ch11-numbers-api:v3-build-${BUILD_NUMBER:-local}`
    `       networks:` `           - app-net`  `   numbers-web:` `       image: ${REGISTRY:-docker.io}/diamol/ch11-numbers-web:v3-build-${BUILD_NUMBER:-local}`
    `       environment:` `           - RngApi__Url=http://numbers-api/rng` `       networks:`
    `             - app-net`'
- en: The environment variable syntax here includes a default value set with `:-`
    , so `${REGISTRY:-docker.io}` tells Compose to replace that token at runtime with
    the value of the environment variable called `REGISTRY` . If that environment
    variable doesn’t exist or is empty, it will use the default value `docker.io`
    , which is the domain for Docker Hub. I use the same approach with the image tag,
    so if the environment variable `BUILD_NUMBER` is set, that value goes into the
    tag; otherwise `local` gets used.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里环境变量语法包括使用 `:-` 设置的默认值，所以 `${REGISTRY:-docker.io}` 告诉 Compose 在运行时将此占位符替换为名为
    `REGISTRY` 的环境变量的值。如果该环境变量不存在或为空，它将使用默认值 `docker.io`，这是Docker Hub的域名。我使用相同的方法处理镜像标签，所以如果设置了环境变量
    `BUILD_NUMBER`，该值将用于标签；否则使用 `local`。
- en: This is a very useful pattern for supporting a CI process and a local developer
    build using the same set of artifacts. When a developer builds the API image,
    they won’t have any environment variables set, so the image will be called `docker.io/diamol/
    ch11-numbers-api:v3-build-local` . But `docker.io` is Docker Hub, which is the
    default domain, so the image will just be shown as `diamol/ch11-numbers-api:v3-build-local`
    . When the same build runs in Jenkins, the variables will be set to use the local
    Docker registry and the actual build number for the job, which Jenkins sets as
    an incrementing number, so the image name will be `registry.local:5000/` `diamol/
    ch11-numbers-api:v3-build-2` .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的模式，用于支持使用相同的一组工件进行CI流程和本地开发者构建。当开发者构建API镜像时，他们不会设置任何环境变量，所以镜像将被命名为
    `docker.io/diamol/ ch11-numbers-api:v3-build-local` 。但 `docker.io` 是Docker Hub，这是默认域名，所以镜像将仅显示为
    `diamol/ch11-numbers-api:v3-build-local` 。当相同的构建在Jenkins上运行时，变量将被设置为使用本地Docker注册表和作业的实际构建号，Jenkins将其设置为递增的数字，所以镜像名称将是
    `registry.local:5000/` `diamol/ ch11-numbers-api:v3-build-2` 。
- en: Setting a flexible image name is an important part of the CI setup, but the
    key information is specified in the override file `docker-compose-build.yml` ,
    which tells Compose where to find the Dockerfiles.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 设置灵活的镜像名称是CI设置的一个重要部分，但关键信息在覆盖文件 `docker-compose-build.yml` 中指定，它告诉 Compose
    在哪里找到 Dockerfile。
- en: 'try it now You can build the app locally using the same steps as the CI build
    pipeline. Start from a terminal session, browse to the directory for the chapter,
    and build the app with Docker Compose:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 你可以使用与CI构建管道相同的步骤在本地构建应用程序。从一个终端会话开始，浏览到章节目录，并使用Docker Compose构建应用程序：
- en: '` cd ch11/exercises`  ` # build both images:` ` docker-compose -f docker-compose.yml
    -f docker-compose-build.yml build`  ` # check the labels for the web image:` ` docker
    image inspect -f ''{{.Config.Labels}}'' diamol/ch11-numbers-api:v3-build-local`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ch11/exercises`  ` # build both images:` ` docker-compose -f docker-compose.yml
    -f docker-compose-build.yml build`  ` # check the labels for the web image:` ` docker
    image inspect -f ''{{.Config.Labels}}'' diamol/ch11-numbers-api:v3-build-local`'
- en: You can see my output in figure 11.10.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图11.10中看到我的输出。
- en: '![](../Images/11-10.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-10.jpg)'
- en: Figure 11.10 Building images with Docker Compose and checking the image labels
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 使用Docker Compose构建镜像并检查镜像标签
- en: Building the application through Docker Compose effectively runs a `docker`
    `image` `build` command for every service that has build settings specified. That
    could be a dozen images or a single one--even for one image, it’s a good practice
    to build with Compose because then your Compose file specifies the tag you want
    when you build the image. There are a few more things in this build that are part
    of a successful CI pipeline--you can see that in the final `inspect` command that
    lists the labels for the image.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Docker Compose构建应用程序实际上为每个指定了构建设置的服务运行一个 `docker` `image` `build` 命令。这可能是一打镜像或一个镜像——即使是单个镜像，使用
    Compose 构建也是一个好习惯，因为这样你的 Compose 文件就指定了构建镜像时想要的标签。在这个构建过程中还有一些其他事情是成功CI管道的一部分——你可以在列出镜像标签的最终
    `inspect` 命令中看到这些。
- en: Docker lets you apply labels to most resources--containers, images, networks,
    and volumes. They’re simple key/value pairs where you can store additional data
    about the resource. Labels are very useful on images because they get baked into
    the image and move with it--when you push or pull the image, the labels go along
    too. When you build your app with a CI pipeline, it’s important to have an audit
    trail that lets you track back from the running container to the build job that
    created it, and image labels help you do that.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Docker允许你将标签应用于大多数资源--容器、镜像、网络和卷。它们是简单的键/值对，你可以存储有关资源的额外数据。标签在镜像中非常有用，因为它们被嵌入到镜像中并随其移动--当你推送或拉取镜像时，标签也会随之移动。当你使用CI管道构建应用程序时，有一个审计跟踪对于追踪从运行容器到创建它的构建作业非常重要，镜像标签可以帮助你做到这一点。
- en: Listing 11.3 shows part of the Dockerfile for the random number API (you’ll
    find the full file in the exercises for this chapter at `numbers/numbers-api/Dockerfile.v4`
    ). There are two new Dockerfile instructions here-- `ARG` and `LABEL`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.3展示了随机数API的Dockerfile的一部分（完整的文件可以在本章的练习中找到，位于`numbers/numbers-api/Dockerfile.v4`）。这里有两个新的Dockerfile指令--
    `ARG` 和 `LABEL`。
- en: Listing 11.3 Specifying image labels and build arguments in the Dockerfile
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.3 在Dockerfile中指定镜像标签和构建参数
- en: '` # app image` ` FROM diamol/dotnet-aspnet`  ` ARG BUILD_NUMBER=0` ` ARG BUILD_TAG=local` 
    ` LABEL version="3.0"` ` LABEL build_number=${BUILD_NUMBER}` ` LABEL build_tag=${BUILD_TAG}` 
    ` ENTRYPOINT ["dotnet", "Numbers.Api.dll"]`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 应用程序镜像` ` FROM diamol/dotnet-aspnet`  ` ARG BUILD_NUMBER=0` ` ARG BUILD_TAG=local` 
    ` LABEL version="3.0"` ` LABEL build_number=${BUILD_NUMBER}` ` LABEL build_tag=${BUILD_TAG}` 
    ` ENTRYPOINT ["dotnet", "Numbers.Api.dll"]`'
- en: The `LABEL` instruction just applies the key/value pair from the Dockerfile
    to the image when it gets built. You can see `version=3.0` specified in the Dockerfile,
    and that matches the label output in figure 11.10\. The other two `LABEL` instructions
    use environment variables to set the label value, and those environment variables
    are provided by the `ARG` instructions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`LABEL` 指令只是在构建时将Dockerfile中的键/值对应用到镜像上。你可以在Dockerfile中看到指定的 `version=3.0`，这与图11.10中的标签输出相匹配。其他两个
    `LABEL` 指令使用环境变量来设置标签值，这些环境变量由 `ARG` 指令提供。'
- en: '`ARG` is very similar to the `ENV` instruction, except that it works at build
    time on the image, rather than at run time in the container. They both set the
    value of an environment variable, but for `ARG` instructions that setting only
    exists for the duration of the build, so any containers you run from the image
    don’t see that variable. It’s a great way to pass data into the build process
    that isn’t relevant for running containers. I’m using it here to provide values
    that go into the image labels--in the CI process, these record the number of the
    build and the full build name. The `ARG` instruction also sets default values,
    so when you build the image locally without passing any variables, you see `build_number:0`
    and `build_tag:local` in the image labels.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARG` 与 `ENV` 指令非常相似，不同之处在于它是在构建图像时而不是在容器运行时起作用。它们都设置环境变量的值，但对于 `ARG` 指令，这种设置只存在于构建期间，因此从该镜像运行的任何容器都不会看到该变量。这是一个将不适用于运行容器的数据传递到构建过程的好方法。我在这里使用它来提供要放入镜像标签中的值--在CI过程中，这些记录了构建的编号和完整的构建名称。`ARG`
    指令还设置默认值，因此当你本地构建镜像而不传递任何变量时，你会在镜像标签中看到 `build_number:0` 和 `build_tag:local`。'
- en: You can see how the environment settings in the CI pipeline get passed down
    into the Docker `build` command in the Compose override file. Listing 11.4 shows
    the contents of the `docker-compose-build.yml` file with all the build settings.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到CI管道中的环境设置是如何传递到Compose覆盖文件中的Docker `build` 命令的。列表11.4展示了包含所有构建设置的`docker-compose-build.yml`文件内容。
- en: Listing 11.4 Specifying build settings and reusable arguments in Docker Compose
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.4 在Docker Compose中指定构建设置和可重用参数
- en: '` x-args: &args` `   args:` `       BUILD_NUMBER: ${BUILD_NUMBER:-0}` `       BUILD_TAG:
    ${BUILD_TAG:-local}` ` services:` `   numbers-api:` `       build:` `           context:
    numbers` `           dockerfile: numbers-api/Dockerfile.v4` `           <<: *args` 
    `   numbers-web:` `       build:` `           context: numbers` `           dockerfile:
    numbers-web/Dockerfile.v4` `             <<: *args`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '` x-args: &args` `   args:` `       BUILD_NUMBER: ${BUILD_NUMBER:-0}` `       BUILD_TAG:
    ${BUILD_TAG:-local}` ` services:` `   numbers-api:` `       build:` `           context:
    numbers` `           dockerfile: numbers-api/Dockerfile.v4` `           <<: *args` 
    `   numbers-web:` `       build:` `           context: numbers` `           dockerfile:
    numbers-web/Dockerfile.v4` `             <<: *args`'
- en: This Compose file shouldn’t be too complicated unless you skipped chapter 10,
    in which case you should go back and read it. It won’t take you more than a lunchtime.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Compose文件不应该太复杂，除非你跳过了第10章，在这种情况下，你应该回去阅读它。这不会花你超过一顿午餐的时间。
- en: 'There are three parts to the `build` block in the Compose specification:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Compose规范中的`build`块有三个部分：
- en: '`context` --This is the path Docker will use as the working directory for the
    build. This is usually the current directory, which you pass with a period in
    the `docker` `image` `build` command, but here it’s the `numbers` directory--the
    path is relative to the location of the Compose file.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context` -- 这是Docker将用作构建工作目录的路径。这通常是当前目录，你通过在`docker image build`命令中使用点来传递它，但在这里是`numbers`目录——路径相对于Compose文件的位置。'
- en: '`dockerfile` --The path to the Dockerfile, relative to the context.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dockerfile` -- Dockerfile的路径，相对于上下文。'
- en: '`args` --Any build arguments to pass, which need to match the keys specified
    as `ARG` instructions in the Dockerfile. Both the Dockerfiles for this app use
    the same `BUILD_NUMBER` and `BUILD_TAG` arguments, so I’m using a Compose extension
    field to define those values once, and YAML merge to apply it to both services.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args` -- 需要传递的任何构建参数，这些参数需要与Dockerfile中`ARG`指令指定的键匹配。这个应用的两个Dockerfile都使用相同的`BUILD_NUMBER`和`BUILD_TAG`参数，所以我使用Compose扩展字段一次性定义这些值，并使用YAML合并将其应用到两个服务中。'
- en: You’ll see default values specified in lots of different places, and this is
    to make sure that support for the CI process doesn’t break other workflows. You
    should always aim for a single Dockerfile that gets built in the same way however
    the build is run. Default arguments in the Compose file mean the build succeeds
    when you run it outside of the CI environment, and defaults in the Dockerfile
    mean the image builds correctly even if you don’t use Compose.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在很多不同的地方看到指定的默认值，这是为了确保对CI过程的支撑不会破坏其他工作流程。你应该始终追求一个单一的Dockerfile，无论以何种方式构建，都能以相同的方式进行构建。Compose文件中的默认参数意味着在CI环境外运行时构建成功，而Dockerfile中的默认参数意味着即使不使用Compose，镜像也能正确构建。
- en: 'Try it now You can build the random number API image with the normal `image`
    `build` command, bypassing the setup in the Compose files. You can call the image
    whatever you like--the build succeeds and the labels get applied because of the
    defaults in the Dockerfile:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 你可以使用正常的`image build`命令构建随机数API镜像，绕过Compose文件中的设置。你可以将镜像命名为你喜欢的任何名称——构建成功并且标签被应用，因为Dockerfile中的默认值：
- en: '` # change to the numbers directory`  ` # (this is done with the context setting
    in Compose):` ` cd ch11/exercises/numbers`  ` # build the image, specifying the
    Dockerfile path and a build argument:` ` docker image build -f numbers-api/Dockerfile.v4
    --build-arg BUILD_TAG=ch11 -t numbers-api .`  ` # check the labels:` ` docker
    image inspect -f ''{{.Config.Labels}}'' numbers-api`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 将目录更改为数字目录`  ` # (这是通过Compose中的上下文设置完成的)：` ` cd ch11/exercises/numbers` 
    ` # 构建镜像，指定Dockerfile路径和构建参数：` ` docker image build -f numbers-api/Dockerfile.v4
    --build-arg BUILD_TAG=ch11 -t numbers-api .`  ` # 检查标签：` ` docker image inspect
    -f ''{{.Config.Labels}}'' numbers-api`'
- en: My output is in figure 11.11--you can see in the labels that the value `build_tag:ch11`
    was set from my `build` command, but the value `build_number:0` was set from the
    default for the `ARG` in the Dockerfile.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出在图11.11中——你可以在标签中看到，`build_tag:ch11`的值是由我的`build`命令设置的，但`build_number:0`的值是由Dockerfile中`ARG`的默认值设置的。
- en: '![](../Images/11-11.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-11.jpg)'
- en: Figure 11.11 Including default values for build arguments supports the developer
    build workflow.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 包含构建参数的默认值支持开发人员构建工作流程。
- en: There are quite a few levels of detail here just to get labels into an image,
    but it’s an important thing to get right. You should be able to run `docker` `image`
    `inspect` and find exactly where that image came from, tracking it back to the
    CI job that produced it, which in turn tracks back to the exact version of code
    that triggered the build. It’s an audit trail from the running container in any
    environment back to the source code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多细节级别，只是为了将标签放入镜像中，但这是正确设置的重要事情。你应该能够运行`docker image inspect`并找到那个镜像的确切来源，追踪回生成它的CI作业，这反过来又追踪回触发构建的确切代码版本。这是从任何环境中的运行容器回源代码的审计跟踪。
- en: 11.4 Writing CI jobs with no dependencies except Docker
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 使用除Docker之外无依赖项的CI作业编写
- en: You’ve been happily building images for the random number app in this chapter
    using Docker and Docker Compose, without needing any other tools installed on
    your machine. There are two components to the app, and both are written in .NET
    Core 3.0, but you don’t need the .NET Core SDK on your machine to build them.
    They use the multi-stage Dockerfile approach from chapter 4 to compile and package
    the app, so Docker and Compose are all you need.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经愉快地使用 Docker 和 Docker Compose 为随机数应用程序构建镜像，而无需在您的机器上安装任何其他工具。该应用程序有两个组件，两者都使用
    .NET Core 3.0 编写，但您不需要在您的机器上安装 .NET Core SDK 来构建它们。它们使用第 4 章中提到的多阶段 Dockerfile
    方法来编译和打包应用程序，因此您只需要 Docker 和 Compose。
- en: This is a major benefit of containerized CI, and it’s supported by all the managed
    build services like Docker Hub, GitHub Actions, and Azure DevOps. It means you
    no longer need a build server with lots of tools installed and for the tools to
    be kept up to date with all the developers. It also means that your build scripts
    become very simple--developers can use the exact same build scripts locally and
    get the same output as the CI pipeline, so it becomes easy to move between different
    build services.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是容器化 CI 的一个主要优势，并且所有托管构建服务（如 Docker Hub、GitHub Actions 和 Azure DevOps）都支持它。这意味着您不再需要一个安装了大量工具的构建服务器，并且工具需要与所有开发者保持更新。这也意味着您的构建脚本变得非常简单——开发者可以在本地使用完全相同的构建脚本，并获得与
    CI 管道相同的输出，因此在不同构建服务之间移动变得容易。
- en: We’re using Jenkins for our CI process, and Jenkins jobs can be configured with
    a simple text file that lives in source control along with the application code,
    Dockerfiles, and Compose files. Listing 11.5 shows part of the pipeline (from
    the file `ch11/exercises/Jenkinsfile` ) along with the batch script that the pipeline
    step executes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Jenkins 进行 CI 流程，并且 Jenkins 作业可以通过一个简单的文本文件进行配置，该文件位于源代码控制中，与应用程序代码、Dockerfile
    和 Compose 文件一起。列表 11.5 显示了管道的一部分（来自文件 `ch11/exercises/Jenkinsfile`），以及管道步骤执行的批处理脚本。
- en: Listing 11.5 The build step from the Jenkinsfile that describes the CI job
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.5：Jenkinsfile 中的构建步骤，描述 CI 作业
- en: '` # the build stage in the Jenkinsfile- it switches directory, then runs two`
    ` # shell commands - the first sets up a script file so it can be executed` ` #
    and the second calls the script:` ` stage(''Build'') {` `   steps {` `       dir(''ch11/exercises'')
    {` `           sh ''chmod +x ./ci/01-build.bat''` `           sh ''./ci/01-build.bat''`
    `           }` `   }` ` }`  ` # and this is what''s in 01-build.bat script:` ` docker-compose`
    `   -f docker-compose.yml` `   -f docker-compose-build.yml` `     build --pull`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '` # Jenkinsfile 中的构建阶段 - 它切换目录，然后运行两个` ` # shell 命令 - 第一个设置一个脚本文件以便执行` ` #
    第二个调用脚本:` ` stage(''Build'') {` `   steps {` `       dir(''ch11/exercises'') {`
    `           sh ''chmod +x ./ci/01-build.bat''` `           sh ''./ci/01-build.bat''`
    `           }` `   }` ` }`  ` # 这是 01-build.bat 脚本中的内容:` ` docker-compose` `   -f
    docker-compose.yml` `   -f docker-compose-build.yml` `     build --pull`'
- en: Well look at that--it’s just the same `docker-compose` `build` command you ran
    locally. Except it adds the `pull` flag, which means Docker will pull the latest
    version of any images it needs during the build. That’s a good habit to get into
    when you do your builds anyway, because it means you’ll always build your image
    from the latest base image with all the recent security fixes. It’s especially
    important in the CI process because there could be a change in an image your Dockerfile
    uses, which could break your app, and you want to find that out as soon as possible.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，看看这个——这正是您在本地运行的相同的 `docker-compose` `build` 命令。只不过它添加了 `pull` 标志，这意味着 Docker
    将在构建过程中拉取它需要的任何镜像的最新版本。当您进行构建时，养成这个习惯是很好的，因为它意味着您将始终从包含所有最新安全修复的基础镜像构建您的镜像。在 CI
    流程中，这尤其重要，因为 Dockerfile 使用的镜像可能会发生变化，这可能会破坏您的应用程序，并且您希望尽快发现这一点。
- en: The build step runs a simple script file--the filename ends with `.bat` so it
    runs nicely under Jenkins in a Windows container, but it also works just fine
    in a Linux container. This step runs the build, and because it’s a simple command-line
    call, all the output from Docker Compose--which is also the output from Docker--gets
    captured and stored in the build logs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 构建步骤运行一个简单的脚本文件——文件名以 `.bat` 结尾，以便在 Windows 容器中的 Jenkins 下运行良好，但它也可以在 Linux
    容器中正常运行。这一步骤执行构建，因为它是一个简单的命令行调用，所以 Docker Compose 的所有输出（也是 Docker 的输出）都被捕获并存储在构建日志中。
- en: 'Try it now You can view the logs in the Jenkins UI. Browse to http:/ /localhost
    :8080/job/diamol to see the jobs, and in the pipeline view click on the Build
    step for job #2\. Then click Logs. You can expand the steps of the build and you’ll
    see the usual Docker build output; mine is in figure 11.12.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '现在尝试一下 你可以在 Jenkins UI 中查看日志。浏览到 http:/ /localhost :8080/job/diamol 以查看作业，然后在管道视图中单击作业
    #2 的构建步骤。然后单击日志。你可以展开构建步骤，你会看到常规的 Docker 构建输出；我的输出在图 11.12 中。'
- en: '![](../Images/11-12.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-12.jpg)'
- en: Figure 11.12 Viewing the output from the pipeline build in Jenkins shows the
    usual Docker logs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 显示了在 Jenkins 中查看管道构建输出的结果，显示了常规的 Docker 日志。
- en: Each step in the build pipeline follows the same pattern; it just calls a batch
    script that does the actual work by running Docker Compose commands. This approach
    makes it easy to switch between different build services; instead of writing the
    logic in a proprietary pipeline syntax, you write it in scripts and use the pipeline
    to call the scripts. I could add pipeline files to run the build in GitLab or
    GitHub Actions, and they would call the same batch scripts.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 构建管道中的每个步骤都遵循相同的模式；它只是调用一个批处理脚本，通过运行 Docker Compose 命令来完成实际工作。这种方法使得在不同构建服务之间切换变得容易；而不是在专有管道语法中编写逻辑，你编写脚本，并使用管道来调用脚本。我可以添加管道文件以在
    GitLab 或 GitHub Actions 中运行构建，并且它们会调用相同的批处理脚本。
- en: 'The stages of the Jenkins build are all powered by containers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 构建的所有阶段都由容器驱动：
- en: Verify calls the script `00-verify.bat` , which just prints out version information
    for Docker and Docker Compose. This is a useful way to start the pipeline, because
    it verifies that the Docker dependencies are available and it records the versions
    of the tools that built the image.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Verify 调用脚本 `00-verify.bat`，该脚本仅打印 Docker 和 Docker Compose 的版本信息。这是一种启动管道的有用方式，因为它验证了
    Docker 依赖项是否可用，并记录了构建镜像的工具版本。
- en: Build calls `01-build.bat` , which you’ve already seen; it uses Docker Compose
    to build the images. The `REGISTRY` environment variable is specified in the Jenkinsfile
    so images will be tagged for the local registry.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Build 调用 `01-build.bat`，你之前已经看到过；它使用 Docker Compose 构建镜像。`REGISTRY` 环境变量在 Jenkinsfile
    中指定，以便为本地注册表标记镜像。
- en: Test calls `02-test.bat` , which uses Docker Compose to start the whole application,
    then lists out the containers and brings the application down again. This is just
    a simple illustration, but it does prove that the containers run without failing.
    In a real project you would bring up the app and then run end-to-end tests in
    another container.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Test 调用 `02-test.bat`，该脚本使用 Docker Compose 启动整个应用程序，然后列出容器并将应用程序关闭。这只是简单的说明，但它确实证明了容器可以正常运行而不会失败。在实际项目中，你会在另一个容器中启动应用程序并运行端到端测试。
- en: Push calls `03-push.bat` , which uses Docker Compose to push all the built images.
    The image tags have the local registry domain, so if the build and test stages
    are successful, the images get pushed to the registry.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Push 调用 `03-push.bat`，该脚本使用 Docker Compose 推送所有构建的镜像。镜像标签包含本地注册表域名，因此如果构建和测试阶段成功，镜像将被推送到注册表。
- en: Stages in the CI pipeline are sequential, so if there’s a failure at any point,
    the job ends. That means the registry only stores images for potential release
    candidates--any image that has been pushed to the registry must have successfully
    passed the build and test stages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: CI 管道中的阶段是顺序的，所以如果在任何地方出现失败，作业就会结束。这意味着注册表只存储潜在发布候选人的镜像--任何推送到注册表的镜像都必须成功通过构建和测试阶段。
- en: 'Try it now You have one successful build from Jenkins--build number 1 failed
    because there was no source code, and then build number 2 succeeded. You can query
    your local registry container using the REST API, and you should see just a version
    2 tag for each of the random number images:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 你从 Jenkins 中有一个成功的构建--构建编号 1 失败是因为没有源代码，然后构建编号 2 成功。你可以使用 REST API 查询你的本地注册表容器，你应该看到每个随机数镜像只有一个版本
    2 标签：
- en: '` # the catalog endpoint shows all the image repositories:` ` curl http://registry.local:5000/v2/_catalog` 
    ` # the tags endpoint shows the individual tags for one repository:` ` curl http://registry.local:5000/v2/diamol/ch11-numbers-api/tags/list`
    ` curl http://registry.local:5000/v2/diamol/ch11-numbers-web/tags/list`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 目录端点显示所有镜像仓库：` ` curl http://registry.local:5000/v2/_catalog` ` # 标签端点显示一个仓库的各个标签：`
    ` curl http://registry.local:5000/v2/diamol/ch11-numbers-api/tags/list` ` curl
    http://registry.local:5000/v2/diamol/ch11-numbers-web/tags/list`'
- en: You can see my output in figure 11.13--there are repositories for the web and
    API images, but each only has a `build-2` tag, because the first build failed
    and didn’t push any images.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图11.13中看到我的输出--有Web和API镜像的存储库，但每个都只有一个`build-2`标签，因为第一次构建失败，没有推送任何镜像。
- en: '![](../Images/11-13.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图11-13](../Images/11-13.jpg)'
- en: Figure 11.13 Sending web requests to the registry API to query the images stored
    in the container
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 向注册表API发送Web请求以查询容器中存储的镜像
- en: This is a fairly simple CI pipeline, but it shows you all the key stages of
    the build and some important best practices. The key thing is to let Docker do
    the hard work and to build the stages of your pipeline in scripts. Then you can
    use any CI tool and just plug your scripts into the tool’s pipeline definition.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的CI管道，但它展示了构建的所有关键阶段和一些重要的最佳实践。关键是要让Docker做艰苦的工作，并在脚本中构建你的管道阶段。然后你可以使用任何CI工具，只需将你的脚本插入工具的管道定义中。
- en: 11.5 Understanding containers in the CI process
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 理解CI过程中的容器
- en: Compiling and running applications in containers is just the start of what you
    can do with Docker in your CI pipeline. Docker adds a layer of consistency on
    top of all your application builds, and you can use that consistency to add many
    useful features to your pipeline. Figure 11.14 shows a more extensive CI process
    that includes security-scanning container images for known vulnerabilities and
    digitally signing images to assert their provenance.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中编译和运行应用程序只是你在CI管道中使用Docker的开始。Docker在你的所有应用程序构建之上添加了一层一致性，你可以利用这层一致性为你的管道添加许多有用的功能。图11.14展示了更广泛的CI流程，其中包括对已知漏洞进行安全扫描的容器镜像和为镜像进行数字签名以声明其来源。
- en: '![](../Images/11-14.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图11-14](../Images/11-14.jpg)'
- en: Figure 11.14 A production-grade CI pipeline that adds stages with security gates
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.14](../Images/11-14.jpg)'
- en: Docker calls this approach the secure software supply chain, and it’s important
    for all sizes of organizations because it gives you confidence that the software
    you’re about to deploy is safe. You can run tooling in your pipeline to check
    for known security vulnerabilities and fail the build if there are issues. You
    can configure your production environment to only run containers from images that
    have been digitally signed--a process that happens at the end of a successful
    build. When your containers are deployed to production, you can be certain that
    they’re running from images that came through your build process, and that they
    contain software that has passed all your tests and is free from security issues.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将这种方法称为安全软件供应链，对于所有规模的组织都至关重要，因为它让你有信心，你即将部署的软件是安全的。你可以在管道中运行工具来检查已知的安全漏洞，并在有问题时失败构建。你可以配置你的生产环境，只运行已数字签名的镜像--这个过程发生在构建成功结束时。当你的容器部署到生产环境时，你可以确信它们正在运行来自你的构建过程的镜像，并且包含通过了所有测试且没有安全问题的软件。
- en: The checks and balances you add in your pipeline work on containers and images,
    so they apply in the same way across all your application platforms. If you work
    with multiple technologies across your projects, you’ll be using different base
    images and different build steps in the Dockerfiles, but the CI pipelines will
    all be the same.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你在管道中添加的检查和平衡在容器和镜像上工作，因此它们以相同的方式应用于所有应用程序平台。如果你在项目中使用多种技术，你将使用不同的基础镜像和不同的Dockerfile构建步骤，但CI管道都将相同。
- en: 11.6 Lab
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 实验室
- en: Lab time! You’re going to build your own CI pipeline--but don’t run scared.
    We’ll use the ideas and exercises from this chapter, but the pipeline stages will
    be much simpler.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实验时间！你将构建自己的CI管道--但不要害怕。我们将使用本章中的想法和练习，但管道阶段将会更简单。
- en: 'In the lab folder for this chapter you’ll find a copy of the source code for
    the to-do app from chapter 6\. The build for that app is almost ready to go--the
    Jenkinsfile is there, the CI scripts are there, and the core Docker Compose file
    is there. There are just a couple of things for you to do:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的实验室文件夹中，你可以找到第6章待办事项应用程序的源代码副本。该应用程序的构建几乎可以立即使用--Jenkinsfile已经存在，CI脚本也存在，核心Docker
    Compose文件也存在。你只需要做几件事情：
- en: Write an override file called `docker-compose-build.yml` with the build settings.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个名为`docker-compose-build.yml`的覆盖文件，包含构建设置。
- en: Create a Jenkins job to run the pipeline.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Jenkins作业来运行管道。
- en: Push your changes to Gogs in the `diamol` repository.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的更改推送到`diamol`存储库的Gogs。
- en: 'Just three tasks, but don’t be disheartened if your first few builds fail and
    you need to check the logs and tweak some things. No one in history has ever written
    a Jenkins job that passed on the first run, so here are a few hints:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 只需完成三个任务，但如果你的前几次构建失败，需要检查日志并调整一些设置，请不要气馁。历史上没有人第一次运行就能成功编写一个 Jenkins 作业，所以这里有一些提示：
- en: Your Compose override will be similar to the one in the exercises--specifying
    the context and a build argument for the build number label.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的 Compose 覆盖设置将与练习中的类似——指定上下文和构建编号标签的构建参数。
- en: In the Jenkins UI, you click New Item to create a job, and you can copy from
    the existing `diamol` job.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Jenkins UI 中，你点击“新建项目”来创建一个作业，并且你可以从现有的 `diamol` 作业中复制内容。
- en: The new job setup will be the same except for the path to the Jenkinsfile--you’ll
    need to specify the `lab` folder instead of the `exercises` folder.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的作业设置将与 Jenkinsfile 的路径相同，除了你需要指定 `lab` 文件夹而不是 `exercises` 文件夹。
- en: 'If you’re not getting far with this, you’ll find more information in the read-me
    file in the lab folder, complete with screenshots for the Jenkins steps and sample
    build configuration for the Docker Compose file: *[https://github.com/sixeyed/diamol/blob/
    master/ch11/lab/README.md](https://github.com/sixeyed/diamol/blob/master/ch11/lab/README.md)*
    .'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这方面进展不大，你可以在实验室文件夹中的“read-me”文件中找到更多信息，其中包含 Jenkins 步骤的截图以及 Docker Compose
    文件的示例构建配置：*[https://github.com/sixeyed/diamol/blob/master/ch11/lab/README.md](https://github.com/sixeyed/diamol/blob/master/ch11/lab/README.md)*。
