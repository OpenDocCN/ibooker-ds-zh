- en: 5 Computing transformations with matrices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 使用矩阵计算变换
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Writing a linear transformation as a matrix
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将线性变换写成矩阵
- en: Multiplying matrices to compose and apply linear transformations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过矩阵相乘来组合和应用线性变换
- en: Operating on vectors of different dimensions with linear transformations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线性变换对不同维度的向量进行操作
- en: Translating vectors in 2D or 3D with matrices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用矩阵在2D或3D中平移向量
- en: 'In the culmination of chapter 4, I stated a big idea: *any* linear transformation
    in 3D can be specified by just three vectors or nine numbers total. By correctly
    selecting these nine numbers, we can achieve rotation by any angle about any axis,
    reflection across any plane, projection onto any plane, scaling by any factor
    in any direction, or any other 3D linear transformation.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章的总结中，我提出了一个重要观点：*任何*三维线性变换都可以仅用三个向量或总共九个数字来指定。通过正确选择这九个数字，我们可以实现绕任意轴旋转任意角度，沿任意平面反射，在任意平面上投影，沿任意方向按任意因子缩放，或任何其他三维线性变换。
- en: The transformation expressed as “a rotation counterclockwise by 90° about the
    z-axis” can equivalently be described by what it does to the standard basis vectors
    ***e***[1] = (1, 0, 0), ***e***[2] = (0, 1, 0), and ***e***[3] = (0, 0, 1). Namely,
    the results are (0, 1, 0), (−1, 0, 0), and (0, 0, 1). Whether we think of this
    transformation geometrically or as described by these three vectors (or nine numbers),
    we’re thinking of the same imaginary machine (figure 5.1) that operates on 3D
    vectors. The implementations might be different, but the machines still produce
    indistinguishable results.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 表达为“绕z轴逆时针旋转90°的旋转”的变换可以等价地描述为它对标准基向量***e***[1] = (1, 0, 0)，***e***[2] = (0,
    1, 0)，和***e***[3] = (0, 0, 1)的作用。具体来说，结果是(0, 1, 0)，(−1, 0, 0)，和(0, 0, 1)。无论我们是从几何角度还是通过这三个向量（或九个数字）来考虑这个变换，我们都是在思考同一个想象中的机器（图5.1）对3D向量进行操作。实现可能不同，但机器仍然产生不可区分的结果。
- en: '![](../Images/CH05_F01_Orland.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F01_Orland.png)'
- en: Figure 5.1 Two machines that do the same linear transformation. Geometric reasoning
    powers the machine on the top, while nine numbers power the one on the bottom.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：执行相同线性变换的两个机器。顶部的机器通过几何推理工作，而底部的机器通过九个数字工作。
- en: When arranged appropriately in a grid, the numbers that tell us how to execute
    a linear transformation are called a *matrix*. This chapter focuses on using these
    grids of numbers as computational tools, so there’s more number-crunching in this
    chapter than in the previous ones. Don’t let this intimidate you! When it comes
    down to it, we’re still just carrying out vector transformations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些描述如何执行线性变换的数字适当地排列成网格时，这些数字被称为*矩阵*。本章的重点是使用这些数字网格作为计算工具，因此本章比前几章有更多的数字计算。不要被这吓倒！归根结底，我们还是在执行向量变换。
- en: A matrix lets us compute a given linear transformation using the data of what
    that transformation does to standard basis vectors. All of the notation in this
    chapter serves to organize that process, which we covered in section 4.2, not
    to introduce any unfamiliar ideas. I know it can feel like a pain to learn a new
    and complicated notation, but I promise, it will pay off. We are better off being
    able to think of vectors as geometric objects or as tuples of numbers. Likewise,
    we’ll expand our mental model by thinking of linear transformations as matrices
    of numbers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵让我们能够通过该变换对标准基向量的作用来计算给定的线性变换。本章中所有的符号都是为了组织这个过程，我们在4.2节中已经讨论了这一点，而不是为了引入任何不熟悉的概念。我知道学习新的复杂符号可能会感到痛苦，但我保证，这会得到回报。我们最好能够将向量视为几何对象或数字元组。同样，我们将通过将线性变换视为数字矩阵来扩展我们的心理模型。
- en: 5.1 Representing linear transformations with matrices
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 使用矩阵表示线性变换
- en: Let’s return to a concrete example of the nine numbers that specify a 3D linear
    transformation. Suppose *a* is a linear transformation, and we know *a*(***e***[1])
    = (1, 1, 1), *a*(***e***[2]) = (1, 0, −1), and *a*(***e***[3]) = (0, 1, 1). These
    three vectors having nine components in total contain all of the information required
    to specify the linear transformation *a*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到一个具体的例子，这个例子指定了3D线性变换的九个数字。假设*a*是一个线性变换，并且我们知道*a*(***e***[1]) = (1, 1,
    1)，*a*(***e***[2]) = (1, 0, −1)，和*a*(***e***[3]) = (0, 1, 1)。这三个向量总共包含九个分量，包含了指定线性变换*a*所需的所有信息。
- en: Because we reuse this concept over and over, it warrants a special notation.
    We’ll adopt a new notation, called *matrix notation* , to work with these nine
    numbers as a representation of *a*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们反复使用这个概念，它需要一个特殊的符号。我们将采用一种新的符号，称为 *矩阵符号*，来处理这些九个数字作为 *a* 的表示。
- en: 5.1.1 Writing vectors and linear transformations as matrices
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 将向量和线性变换表示为矩阵
- en: 'Matrices are rectangular grids of numbers, and their shapes tell us how to
    interpret them. For instance, we can interpret a matrix that is a single column
    of numbers as a vector with its entries being the coordinates, ordered top to
    bottom. In this form, the vectors are called *column vectors* *.* For example,
    the standard basis for three dimensions can be written as three column vectors
    like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是数字的矩形网格，它们的形状告诉我们如何解释它们。例如，我们可以将只有一个数字列的矩阵解释为一个向量，其条目是坐标，从上到下排序。在这种形式中，向量被称为
    *列向量*。例如，三维标准基可以写成如下三个列向量：
- en: '![](../Images/CH05_F01_Orland_EQ01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F01_Orland_EQ01.png)'
- en: 'For our purposes, this notation means the same thing as ***e***[1] = (1, 0,
    0), ***e***[2] = (0, 1, 0), and ***e***[3] = (0, 0, 1). We can indicate how *a*
    transforms standard basis vectors with this notation as well:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，这个符号意味着与 ***e***[1] = (1, 0, 0), ***e***[2] = (0, 1, 0), 和 ***e***[3]
    = (0, 0, 1) 相同的意思。我们也可以用这个符号来表示 *a* 如何变换标准基向量：
- en: '![](../Images/CH05_F01_Orland_EQ02.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F01_Orland_EQ02.png)'
- en: 'The matrix representing the linear transformation *a* is the 3-by−3 grid consisting
    of these vectors squashed together side by side:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 表示线性变换 *a* 的矩阵是一个由这些向量并排挤压而成的3×3网格：
- en: '![](../Images/CH05_F01_Orland_EQ03.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F01_Orland_EQ03.png)'
- en: 'In 2D, a column vector consists of two entries, so 2 transformed vectors contain
    a total of 4 entries. We can look at the linear transformation *D* that scales
    input vectors by a multiple of 2\. First, we write how it works on basis vectors:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维中，一个列向量包含两个条目，因此两个变换后的向量总共包含4个条目。我们可以看看线性变换 *D* 如何通过2的倍数缩放输入向量。首先，我们写出它在基向量上的作用方式：
- en: '![](../Images/CH05_F01_Orland_EQ04.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F01_Orland_EQ04.png)'
- en: 'Then the matrix for *D* is obtained by putting these columns next to each other:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过将这些列并排放置，我们得到 *D* 的矩阵：
- en: '![](../Images/CH05_F01_Orland_EQ05.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F01_Orland_EQ05.png)'
- en: 'Matrices can come in other shapes and sizes, but we’ll focus on these two shapes
    for now: the single column matrices representing vectors and the square matrices
    representing linear transformations.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵可以有不同的形状和大小，但我们现在将专注于这两种形状：表示向量的单列矩阵和表示线性变换的方阵。
- en: 'Remember, there are no new concepts here, only a new way of writing the core
    idea from section 4.2: a linear transformation is defined by its results acting
    on the standard basis vectors. The way to get a matrix from a linear transformation
    is to find the vectors it produces from all of the standard basis vectors and
    combine the results side by side. Now, we’ll look at the opposite problem: how
    to evaluate *a* linear transformation given its matrix.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这里没有新的概念，只是从第4.2节的核心思想的新写法：线性变换由其在标准基向量上的作用结果定义。从线性变换得到矩阵的方法是找到它从所有标准基向量产生的向量，并将结果并排组合。现在，我们将看看相反的问题：如何根据其矩阵评估一个线性变换。
- en: 5.1.2 Multiplying a matrix with a vector
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 矩阵与向量的乘法
- en: If a linear transformation *B* is represented as a matrix, and a vector ***v***
    is also represented as a matrix (a column vector), we have all of the numbers
    required to evaluate *B*(***v***). For instance, if *B* and ***v*** are given
    by
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个线性变换 *B* 被表示为一个矩阵，并且一个向量 ***v*** 也被表示为一个矩阵（一个列向量），我们就有了评估 *B*(***v***) 所需的所有数字。例如，如果
    *B* 和 ***v*** 由以下给出
- en: '![](../Images/CH05_F01_Orland_EQ06.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F01_Orland_EQ06.png)'
- en: then the vectors *B*(***e***[1]), *B*(***e***[2]), and *B*(***e***[3]) can be
    read off of *B* as the columns of its matrix. From that point, we use the same
    procedure as before. Because ***v*** = 3***e***[1] − 2***e***[2] + 5***e***[3],
    it follows that *B*(***v***) = 3 *B*(***e***[1]) − 2 *B*(***e***[2]) + 5 *B*(***e***[3]).
    Expanding this, we get
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，向量 *B*(***e***[1])，*B*(***e***[2])，和 *B*(***e***[3]) 可以从 *B* 的矩阵中读出，作为其列。从那个点开始，我们使用之前相同的过程。因为
    ***v*** = 3***e***[1] − 2***e***[2] + 5***e***[3]，所以 *B*(***v***) = 3 *B*(***e***[1])
    − 2 *B*(***e***[2]) + 5 *B*(***e***[3])。展开这个，我们得到
- en: '![](../Images/CH05_F01_Orland_EQ07.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F01_Orland_EQ07.png)'
- en: 'and the result is the vector (1, −2, −2). Treating a square matrix as a function
    that operates on a column vector is a special case of an operation called *matrix
    multiplication* . Again, this has an impact on our notation and terminology, but
    we are simply doing the same thing: applying a linear transformation to a vector.
    Written as a matrix multiplication, it looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是向量 (1, −2, −2)。将一个方阵视为作用于列向量的函数是矩阵乘法的一个特殊情况。同样，这会影响我们的符号和术语，但我们只是在做同样的事情：对一个向量应用线性变换。写成矩阵乘法的形式，它看起来像这样：
- en: '![](../Images/CH05_F01_Orland_EQ08.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F01_Orland_EQ08.png)'
- en: As opposed to multiplying numbers, the order matters when you multiply matrices
    by vectors. In this case, *B* ***v*** is a valid product but ***v*** *B* is not.
    Shortly, we’ll see how to multiply matrices of various shapes and a general rule
    for the order in which matrices can be multiplied. For now, take my word for it
    and think of this multiplication as valid because it means applying a 3D linear
    operator to a 3D vector.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与乘以数字不同，当你用矩阵乘以向量时，顺序很重要。在这种情况下，*B* ***v*** 是一个有效的乘积，但 ***v*** *B* 不是。简而言之，我们很快就会看到如何乘以各种形状的矩阵，以及矩阵乘法的顺序的一般规则。现在，请相信我，认为这个乘法是有效的，因为它意味着对一个3D向量应用3D线性算子。
- en: 'We can write Python code that multiplies a matrix by a vector. Let’s say we
    encode the matrix *B* as a tuple-of-tuples and the vector ***v*** as a tuple as
    usual:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写Python代码来将矩阵与向量相乘。假设我们像往常一样将矩阵 *B* 编码为元组元组，将向量 ***v*** 编码为元组：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a bit different from how we originally thought about the matrix *B*.
    We originally created it by combining three columns, but here *B* is created as
    a sequence of rows. The advantage of defining a matrix in Python as a tuple of
    rows is that the numbers are laid out in the same order as we would write them
    on paper. We can, however, get the columns any time we want by using Python’s
    `zip` function (covered in appendix B):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们对矩阵 *B* 的原始想法有点不同。我们最初是通过组合三列来创建它的，但在这里 *B* 是作为一个行序列创建的。将矩阵定义为Python中的行元组的好处是数字的排列顺序与我们写在纸上的顺序相同。然而，我们可以通过使用Python的
    `zip` 函数（在附录B中介绍）在任何时候获取列：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first entry of this list is (0, 0, 1), which is the first column of *B*,
    and so on. What we want is the linear combination of these vectors, where the
    scalars are the coordinates of ***v***. To get this, we can use the `linear_combination`
    function from the exercise in section 4.2.5\. The first argument to `linear_combination`
    should be ***v***, which serves as the list of scalars, and the subsequent arguments
    should be the columns of *B*. Here’s the complete function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表的第一个元素是 (0, 0, 1)，它是 *B* 的第一列，以此类推。我们想要的是这些向量的线性组合，其中标量是 ***v*** 的坐标。为了得到这个结果，我们可以使用第4.2.5节练习中的
    `linear_combination` 函数。`linear_combination` 的第一个参数应该是 ***v***，它作为标量的列表，后续参数应该是
    *B* 的列。下面是这个完整的函数：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It confirms the calculation we did by hand with *B* and ***v*** :'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它确认了我们用 *B* 和 ***v*** 手动做的计算：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are two other mnemonic recipes for multiplying a matrix by a vector,
    both of which give the same results. To see these, let’s write a prototypical
    matrix multiplication:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种其他记忆法来乘以矩阵和向量，它们都给出相同的结果。为了看到这些，让我们写一个典型的矩阵乘法：
- en: '![](../Images/CH05_F01_Orland_EQ09.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F01_Orland_EQ09.png)'
- en: 'The result of this calculation is the linear combination of the columns of
    the matrix with the coordinates *x*, *y*, and *z* as the scalars:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算的结果是矩阵列与坐标 *x*、*y* 和 *z* 作为标量的线性组合：
- en: '![](../Images/CH05_F01_Orland_EQ10.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F01_Orland_EQ10.png)'
- en: 'This is an explicit formula for the product of a 3-by−3 matrix with a 3D vector.
    You can write a similar one for a 2D vector:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是3×3矩阵与3D向量的乘积的显式公式。你可以为2D向量写一个类似的公式：
- en: '![](../Images/CH05_F01_Orland_EQ11.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F01_Orland_EQ11.png)'
- en: 'The first mnemonic is that each coordinate of the output vector is a function
    of all the coordinates of the input vector. For instance, the first coordinate
    of the 3D output is a function *f*(*x*, *y*, *z*) = *ax* + *by* + *cz*. Moreover,
    this is a *linear function* (in the sense that you used the word in high school
    algebra); it is a sum of a number times each variable. We originally introduced
    the term “linear transformation” because linear transformations preserve lines.
    Another reason to use that term: a linear transformation is a collection of linear
    *functions* on the input coordinates that give the respective output coordinates.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个记忆法是输出向量的每个坐标都是输入向量所有坐标的函数。例如，3D输出向量的第一个坐标是函数 *f*(*x*, *y*, *z*) = *ax* +
    *by* + *cz*。此外，这是一个*线性函数*（在高中代数中你用这个词的意思）；它是每个变量的数乘之和。我们最初引入“线性变换”这个术语是因为线性变换保持直线。使用这个术语的另一个原因是：线性变换是输入坐标上的线性*函数*的集合，这些函数给出了相应的输出坐标。
- en: 'The second mnemonic presents the same formula differently: the coordinates
    of the output vector are dot products of the rows of the matrix with the target
    vector. For instance, the first row of the 3-by−3 matrix is (*a*, *b*, *c*) and
    the multiplied vector is (*x*, *y*, *z*), so the first coordinate of the output
    is (*a*, *b*, *c*) · (*x*, *y*, *z*) = *ax* + *by* + *cz*. We can combine our
    two notations to state this fact in a formula:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个记忆法以不同的方式呈现了相同的公式：输出向量的坐标是矩阵的行与目标向量的点积。例如，3x3矩阵的第一行是(*a*, *b*, *c*)，乘积向量是(*x*,
    *y*, *z*)，所以输出向量的第一个坐标是(*a*, *b*, *c*) · (*x*, *y*, *z*) = *ax* + *by* + *cz*。我们可以结合我们的两种表示法，用公式表达这个事实：
- en: '![](../Images/CH05_F01_Orland_EQ12.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH05_F01_Orland_EQ12.png)'
- en: If your eyes are starting to glaze over from looking at so many letters and
    numbers in arrays, don’t worry. The notation can be overwhelming at first, and
    it takes some time to connect it to your intuition. There are more examples of
    matrices in this chapter, and the next chapter provides more review and practice
    as well.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你因为看着数组中的这么多字母和数字而眼睛开始发花，不要担心。一开始，这种表示法可能会让人感到不知所措，并且需要一些时间才能将其与你的直觉联系起来。本章中有更多矩阵的例子，下一章提供了更多的复习和实践。
- en: 5.1.3 Composing linear transformations by matrix multiplication
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 通过矩阵乘法组合线性变换
- en: Some of the examples of linear transformations we’ve seen so far are rotations,
    reflections, rescalings, and other geometric transformations. What’s more, any
    number of linear transformations chained together give us a new linear transformation.
    In math terminology, the *composition* of any number of linear transformations
    is also a linear transformation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的线性变换的一些例子包括旋转、反射、缩放以及其他几何变换。更重要的是，任何数量的线性变换串联在一起都会给我们一个新的线性变换。在数学术语中，任何数量的线性变换的*组合*也是一个线性变换。
- en: Because any linear transformation can be represented by a matrix, any two composed
    linear transformations can be as well. In fact, if you want to compose linear
    transformations to build new ones, matrices are the best tools for the job.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因为任何线性变换都可以用一个矩阵来表示，所以任何两个组合的线性变换也可以。实际上，如果你想组合线性变换来构建新的变换，矩阵是完成这项工作的最佳工具。
- en: NOTE Let me take off my mathematician hat and put on my programmer hat for a
    moment. Suppose you want to compute the result of, say, 1,000 composed linear
    transformations operating on a vector. This can come up if you are animating an
    object by applying additional, small transformations within every frame of the
    animation. In Python, it would be computationally expensive to apply 1,000 sequential
    functions because there is computational overhead for every function call. However,
    if you were to find a matrix representing the composition of 1,000 linear transformations,
    you would boil the whole process down to a handful of numbers and a handful of
    computations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：让我暂时摘下数学家的帽子，戴上程序员的帽子。假设你想计算对向量进行1,000次组合线性变换的结果。如果你在动画中通过在动画的每一帧中应用额外的、小的变换来动画化一个对象，这种情况可能会发生。在Python中，应用1,000个连续函数的计算成本很高，因为每个函数调用都有计算开销。然而，如果你找到一个表示1,000个线性变换组合的矩阵，你就可以将整个过程简化为少量数字和少量计算。
- en: 'Let’s look at a composition of two linear transformations: *a*(*B*(***v***)),
    where the matrix representations of *a* and *B* are known to be the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个线性变换的组合：*a*(*B*(***v***))，其中*a*和*B*的矩阵表示是已知的：
- en: '![](../Images/CH05_F01_Orland_EQ13.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH05_F01_Orland_EQ13.png)'
- en: 'Here’s how the composition works step by step. First, the transformation *B*
    is applied to ***v***, yielding a new vector *B*(***v***), or *B* ***v*** if we’re
    writing it as a multiplication. Second, this vector becomes the input to the transformation
    *a*, yielding a final 3D vector as a result: *a*(*B* ***v***). Once again, we’ll
    drop the parentheses and write *a*(*B* ***v***) as the product *AB* ***v***. Writing
    this product out for ***v*** = (*x*, *y*, *z*) gives us a formula that looks like
    this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是逐步组合的过程。首先，将变换 *B* 应用到 ***v*** 上，得到一个新的向量 *B*(***v***)，或者如果我们写作乘法，就是 *B*
    ***v***。其次，这个向量成为变换 *a* 的输入，得到最终的 3D 向量作为结果：*a*(*B* ***v***)。再次，我们将括号省略，并将 *a*(*B*
    ***v***) 写作乘积 *AB* ***v***。将这个乘积展开为 ***v*** = (*x*, *y*, *z*) 给出如下公式：
- en: '![](../Images/CH05_F01_Orland_EQ14.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F01_Orland_EQ14.png)'
- en: 'If we work right to left, we know how to evaluate this. Now I’m going to claim
    that we can work left to right as well and get the same result. Specifically,
    we can ascribe meaning to the product matrix *AB* on its own; it will be a new
    matrix (to be discovered) representing the composition of the linear transformations
    *a* and *B* :'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从右到左正确操作，我们知道如何评估这个。现在我要声称，我们也可以从左到右操作并得到相同的结果。具体来说，我们可以给乘积矩阵 *AB* 赋予意义；它将是一个新的矩阵（待发现），表示线性变换
    *a* 和 *B* 的组合：
- en: '![](../Images/CH05_F01_Orland_EQ15.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F01_Orland_EQ15.png)'
- en: Now, what should the entries of this new matrix be? Its purpose is to represent
    the composition of the transformations *a* and *B*, which give us a new linear
    transformation, *AB*. As we saw, the columns of a matrix are the results of applying
    its transformation to standard basis vectors. The columns of the matrix *AB* are
    the result of applying the transformation *AB* to each of ***e***[1], ***e***[2],
    and ***e***[3].
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个新矩阵的元素应该是什么？它的目的是表示变换 *a* 和 *B* 的组合，这给我们一个新的线性变换，*AB*。正如我们所见，矩阵的列是将其变换应用于标准基向量得到的结果。矩阵
    *AB* 的列是应用变换 *AB* 到 ***e***[1]、***e***[2] 和 ***e***[3] 的结果。
- en: 'The columns of *AB* are, therefore, *AB*(***e***[1]), *AB*(***e***[2]) and
    *AB*(***e***[3]). Let’s look at the first column, for instance, which should be
    *AB*(***e***[1]) or *a* applied to the vector *B*(***e***[1]). In other words,
    to get the first column of *AB*, we multiply a matrix by a vector, an operation
    that we already practiced:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*AB* 的列是 *AB*(***e***[1])、*AB*(***e***[2]) 和 *AB*(***e***[3])。以第一列为例，它应该是
    *AB*(***e***[1]) 或者 *a* 应用到向量 *B*(***e***[1])。换句话说，要得到 *AB* 的第一列，我们需要将一个矩阵乘以一个向量，这是我们已经练习过的操作：
- en: '![](../Images/CH05_F01_Orland_EQ16.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F01_Orland_EQ16.png)'
- en: 'Similarly, we find that *AB*(***e***[2]) = (3, 2, 1) and *AB*(***e***[3]) =
    (1, 0, 0), which are the second and third columns of *AB* :'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们发现 *AB*(***e***[2]) = (3, 2, 1) 和 *AB*(***e***[3]) = (1, 0, 0)，这是 *AB*
    的第二列和第三列：
- en: '![](../Images/CH05_F01_Orland_EQ17.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F01_Orland_EQ17.png)'
- en: That’s how we do matrix multiplication. You can see there’s nothing to it besides
    carefully composing linear operators. Similarly, you can use mnemonics instead
    of reasoning through this process each time. Because multiplying a 3-by−3 matrix
    by a column vector is the same as doing three dot products, multiplying two 3-by−3
    matrices together is the same as doing nine dot products−all possible dot products
    of rows of the first matrix with columns of the second as shown in figure 5.2.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们进行矩阵乘法的方式。你可以看到，除了仔细组合线性算子之外，没有其他的事情要做。同样，你也可以使用助记符而不是每次都通过推理来完成这个过程。因为将一个
    3x3 矩阵与一个列向量相乘相当于做三个点积，将两个 3x3 矩阵相乘相当于做九个点积——即第一矩阵的行与第二矩阵的列之间所有可能的点积，如图 5.2 所示。
- en: '![](../Images/CH05_F02_Orland.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F02_Orland.png)'
- en: Figure 5.2 Each entry of a product matrix is a dot product of a row of the first
    matrix with a column of the second matrix.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 乘积矩阵的每个元素是第一矩阵的行与第二矩阵的列之间的点积。
- en: Everything we’ve said about 3-by−3 matrix multiplication applies to 2-by−2 matrices
    as well. For instance, to find the product of these 2-by−2 matrices
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的关于 3x3 矩阵乘法的一切也适用于 2x2 矩阵。例如，要找到这些 2x2 矩阵的乘积
- en: '![](../Images/CH05_F02_Orland_EQ18.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F02_Orland_EQ18.png)'
- en: 'we can take the dot products of the rows of the first with the columns of the
    second. The dot product of the first row of the first matrix with the first column
    of the second matrix is (1, 2) · (0, 1) = 2\. This tells us that the entry in
    the first row and first column of the result matrix is 2:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将第一个矩阵的行与第二个矩阵的列进行点积。第一个矩阵的第一行与第二个矩阵的第一列的点积是 (1, 2) · (0, 1) = 2。这告诉我们结果矩阵的第一行和第一列的元素是
    2：
- en: '![](../Images/CH05_F02_Orland_EQ19.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F02_Orland_EQ19.png)'
- en: 'Repeating this procedure, we can find all the entries of the product matrix:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重复此过程，我们可以找到乘积矩阵的所有元素：
- en: '![](../Images/CH05_F02_Orland_EQ20.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F02_Orland_EQ20.png)'
- en: You can do some matrix multiplication as an exercise to get the hang of it,
    but you’ll quickly prefer that your computer does the work for you. Let’s implement
    matrix multiplication in Python to make this possible.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做一些矩阵乘法的练习来熟悉它，但很快你就会更喜欢让计算机为你做这项工作。让我们在 Python 中实现矩阵乘法，以便使其成为可能。
- en: 5.1.4 Implementing matrix multiplication
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.4 实现矩阵乘法
- en: 'There are a few ways we could write our matrix multiplication function, but
    I prefer using the dot product trick. Because the result of matrix multiplication
    should be a tuple of tuples, we can write it as a nested comprehension. It takes
    in two nested tuples as well, called `a` and `b`, representing our input matrices
    *a* and *B*. The input matrix `a` is already a tuple of rows of the first matrix,
    and we can pair these up with `zip(*b)`, which is a tuple of columns of the second
    matrix. Finally, for each pair, we should take the dot product and yield it in
    the inner comprehension. Here’s the implementation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以几种方式编写我们的矩阵乘法函数，但我更喜欢使用点积技巧。因为矩阵乘法的结果应该是一个元组的元组，我们可以将其写为一个嵌套的列表推导式。它也接受两个嵌套的元组，称为
    `a` 和 `b`，代表我们的输入矩阵 *a* 和 *B*。输入矩阵 `a` 已经是第一个矩阵行的元组，我们可以用 `zip(*b)` 将它们配对，`zip(*b)`
    是第二个矩阵列的元组。最后，对于每一对，我们应该计算点积并在内部推导式中产生它。以下是实现方式：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The outer comprehension builds the rows of the result, and the inner one builds
    the entries of each row. Because the output rows are formed by the various dot
    products with rows of `a` , the outer comprehension iterates over `a`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 外部推导式构建结果矩阵的行，内部推导式构建每一行的元素。因为输出行是由与 `a` 的行进行的各种点积形成的，所以外部推导式遍历 `a`。
- en: 'Our `matrix_multiply` function doesn’t have any hard-coded dimensions. That
    means we can use it to do the matrix multiplications from the preceding 2D and
    3D examples:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `matrix_multiply` 函数没有硬编码的维度。这意味着我们可以使用它来执行前面 2D 和 3D 示例中的矩阵乘法：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Equipped with the computational tool of matrix multiplication, we can now do
    some easy manipulations of our 3D graphics.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 配备了矩阵乘法的计算工具，我们现在可以对我们的 3D 图形进行一些简单的操作。
- en: 5.1.5 3D animation with matrix transformations
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.5 使用矩阵变换进行 3D 动画
- en: To animate a 3D model, we redraw a transformed version of the original model
    in each frame. To make the model appear to move or change over time, we need to
    use different transformations as time progresses. If these transformations are
    linear transformations specified by matrices, we need a new matrix for every new
    frame of the animation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要动画化一个 3D 模型，我们需要在每一帧中重新绘制原始模型的变换版本。为了让模型看起来随时间移动或改变，我们需要使用不同的变换。如果这些变换是由矩阵指定的线性变换，那么我们需要为动画的每一帧提供一个新矩阵。
- en: Because PyGame’s built-in clock keeps track of time (in milliseconds), one thing
    we can do is to generate matrices whose entries depend on time. In other words,
    instead of thinking of every entry of a matrix as a number, we can think of it
    as a function that takes the current time, *t*, and returns a number (figure 5.3).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 PyGame 的内置时钟跟踪时间（以毫秒为单位），我们可以做的一件事是生成其元素依赖于时间的矩阵。换句话说，我们不是将矩阵的每个元素视为一个数字，而是将其视为一个函数，该函数接受当前时间
    *t* 并返回一个数字（图 5.3）。
- en: '![](../Images/CH05_F03_Orland.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F03_Orland.png)'
- en: Figure 5.3 Thinking of matrix entries as functions of time allows the overall
    matrix to change as time passes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 将矩阵元素视为时间的函数允许整体矩阵随时间变化。
- en: 'For instance, we could use these nine expressions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下九个表达式：
- en: '![](../Images/CH05_F03_Orland_EQ21.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F03_Orland_EQ21.png)'
- en: As we covered in chapter 2, cosine and sine are both functions that take a number
    and return another number as a result. The other five entries happen to not change
    over time, but if you crave consistency, you can think of these as constant functions
    (as in *f*(*t*) = 1 in the center entry). Given any value of *t*, this matrix
    represents the same linear transformation as `rotate_y_by(*t*)`. Time moves forward
    and the value of *t* increases, so if we apply this matrix transformation to each
    frame, we’ll get a bigger rotation each time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 2 章中提到的，余弦和正弦都是接受一个数字并返回另一个数字作为结果的函数。其他五个条目恰好随时间不变，但如果你追求一致性，可以将这些视为常数函数（如在中心条目中的
    *f*(*t*) = 1）。给定任何 *t* 的值，这个矩阵表示与 `rotate_y_by(*t*)` 相同的线性变换。时间向前推进，*t* 的值增加，因此如果我们将这个矩阵变换应用于每个帧，我们每次都会得到更大的旋转。
- en: 'Let’s give our `draw_model` function (covered in appendix C and used extensively
    in chapter 4) a `get_matrix` keyword argument, where the value passed to `get_matrix`
    is a function that takes time in milliseconds and returns the transformation matrix
    that should be applied at that time. In the source code file, animate_teapot.py,
    I call it like this to animate the rotating teapot from chapter 4:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给 `draw_model` 函数（在第 C 附录中介绍并在第 4 章中广泛使用）一个 `get_matrix` 关键字参数，其中传递给 `get_matrix`
    的值是一个函数，该函数接受毫秒数作为时间并返回在该时间应应用的变换矩阵。在源代码文件 animate_teapot.py 中，我这样调用它来动画化第 4 章中的旋转茶壶：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Generates a new transformation matrix for any numeric input representing time
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为任何表示时间的数值输入生成一个新的变换矩阵
- en: ❷ Converts the time to seconds so the transformation doesn’t happen too quickly
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将时间转换为秒，以便变换不会发生得太快
- en: ❸ Passes the function as a keyword argument to draw_model
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将函数作为关键字参数传递给 draw_model
- en: 'Now, `draw_model` is passed the data required to transform the underlying teapot
    model over time, but we need to use it in the function’s body. Before iterating
    over the teapot faces, we execute the appropriate matrix transformation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`draw_model` 被传递了随时间变换底层茶壶模型所需的数据，但我们需要在函数的主体中使用它。在遍历茶壶面之前，我们执行适当的矩阵变换：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Most of the function body is unchanged, so we don’t print it here.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数主体的大部分保持不变，因此我们在这里不打印它。
- en: ❷ Creates a new function inside the main while loop that applies the matrix
    for this frame
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在主 while 循环内部创建一个新的函数，用于应用此帧的矩阵
- en: ❸ Uses the elapsed milliseconds given by pygame.time.get_ticks() as well as
    the provided get_matrix function to compute a matrix for this frame
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 pygame.time.get_ticks() 提供的经过毫秒数以及提供的 get_matrix 函数来计算此帧的矩阵
- en: ❹ If no get_matrix is specified, doesn’t carry out any transformation and returns
    the vector unchanged
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果未指定 get_matrix，则不执行任何变换，并返回未改变的向量
- en: ❺ Applies the function to every polygon using polygon_map
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用 polygon_map 对每个多边形应用该函数
- en: ❻ The rest of the draw_model is the same as described in appendix C.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ draw_model 的其余部分与附录 C 中描述的相同
- en: With these changes, you can run the code and see the teapot rotate (figure 5.4).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，你可以运行代码并看到茶壶旋转（图 5.4）。
- en: '![](../Images/CH05_F04_Orland.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F04_Orland.png)'
- en: Figure 5.4 The teapot is transformed by a new matrix in every frame, depending
    on the elapsed time when the frame is drawn.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 茶壶在每个帧中通过一个新的矩阵进行变换，这取决于绘制帧时的经过时间
- en: Hopefully, I’ve convinced you with the preceding examples that matrices are
    entirely interchangeable with linear transformations. We’ve managed to transform
    and animate the teapot the same way, using only nine numbers to specify each transformation.
    You can practice your matrix skills some more in the following exercises and then
    I’ll show you there’s even more to learn from the `matrix_multiply` function we’ve
    already implemented.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 希望通过前面的示例，我已经说服你矩阵完全可以与线性变换互换。我们已经成功地将茶壶进行了变换和动画化，仅使用九个数字来指定每个变换。你可以在下面的练习中进一步练习你的矩阵技能，然后我会向你展示从我们已实现的
    `matrix_multiply` 函数中还有更多可以学习的内容。
- en: 5.1.6 Exercises
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.6 练习
- en: '| **Exercise 5.1**: Write *a* function `infer_matrix(n, transformation)` that
    takes a dimension (like 2 or 3) and a function that is a vector transformation
    assumed to be linear. It should return an *n* -by- *n* square matrix (an *n* -tuple
    of *n* -tuples of numbers, which is the matrix representing the linear transformation).
    Of course, the output is only meaningful if the input transformation is linear.
    Otherwise, it represents an entirely different function!**Solution**:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 5.1**: 编写一个函数 `infer_matrix(n, transformation)`，它接受一个维度（如 2 或 3）和一个向量变换函数，该函数假设为线性变换。它应该返回一个
    *n* × *n* 的方阵（一个由 *n* 个 *n* 元组组成的元组，这是表示线性变换的矩阵）。当然，只有当输入变换是线性的时，输出才有意义！否则，它代表一个完全不同的函数！**解答**：'
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '❶ Creates the i^(th) standard basis vector as a tuple containing a one in the
    i^(th) coordinate and zeroes in all other coordinates❷ Creates the standard basis
    as a list of n vectors❸ Defines the columns of a matrix to be the result of applying
    the corresponding linear transformation to the standard basis vectors❹ Reshapes
    the matrix to be a tuple of rows instead of a list of columns, following our conventionWe
    can test this on a linear transformation like `rotate_z_by(pi/2)` :'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建第 i 个标准基向量，它是一个包含一个在 i 坐标上的 1 和其他所有坐标上的 0 的元组❷ 创建标准基，它是 n 个向量的列表❸ 定义矩阵的列是应用相应的线性变换到标准基向量得到的结果❹
    重新排列矩阵，使其成为行的元组而不是列的列表，遵循我们的约定我们可以在像 `rotate_z_by(pi/2)` 这样的线性变换上测试它：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 5.2**: What is the result of the following product of a 2-by−2
    matrix with a 2D vector?![](../Images/CH05_F04_Orland_EQ22.png)**Solution**: The
    dot product of the vector with the first row of the matrix is −2.5 · 1.3 + 0.3
    · -0.7 = −3.46\. The dot product of the vector with the second row of the matrix
    is −2.5 · 6.5 + 0.3 · 3.2 = −15.29\. These are the coordinates of the output vector,
    so the result is:![](../Images/CH05_F04_Orland_EQ23.png) |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.2**: 以下 2 × 2 矩阵与 2D 向量相乘的结果是什么？！[](../Images/CH05_F04_Orland_EQ22.png)**解答**：向量与矩阵第一行的点积是
    −2.5 · 1.3 + 0.3 · -0.7 = −3.46。向量与矩阵第二行的点积是 −2.5 · 6.5 + 0.3 · 3.2 = −15.29。这些是输出向量的坐标，所以结果是：！[](../Images/CH05_F04_Orland_EQ23.png)
    |'
- en: '| **Exercise 5.3-Mini Project**: Write a `random_matrix` function that generates
    matrices of a specified size with random whole number entries. Use the function
    to generate five pairs of 3-by−3 matrices. Multiply each of the pairs together
    by hand (for practice) and then check your work with the `matrix_multiply` function.**Solution**:
    First, we give the `random_matrix` function arguments to specify the number of
    rows, the number of columns, and the minimum and maximum values for entries:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 5.3-迷你项目**：编写一个 `random_matrix` 函数，该函数生成具有指定大小和随机整数元素的矩阵。使用该函数生成五对 3
    × 3 矩阵。手动（为了练习）将每对矩阵相乘，然后使用 `matrix_multiply` 函数检查你的工作。**解答**：首先，我们给 `random_matrix`
    函数提供参数来指定行数、列数以及元素的最小值和最大值：'
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we can generate a random 3-by−3 matrix with entries between 0 and 10
    as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以生成一个随机的 3 × 3 矩阵，其元素介于 0 和 10 之间，如下所示：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 5.4**: For each of your pairs of matrices from the previous exercise,
    multiply them in the opposite order. Do you get the same result?**Solution**:
    Unless you get very lucky, your results will all be different. Most pairs of matrices
    give different results when multiplied in different orders. In math jargon, we
    say an operation is *commutative* if it gives the same result regardless of the
    order of inputs. For instance, multiplying numbers is a commutative operation
    because *xy* = *yx* for any choice of numbers *x* and *y*. However, matrix multiplication
    is *not* commutative because for two square matrices *a* and *B*, *AB* does not
    always equal *BA*. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.4**: 对于上一个练习中的每一对矩阵，以相反的顺序相乘。你得到相同的结果吗？**解答**：除非你非常幸运，否则你的结果都会不同。大多数矩阵对在以不同的顺序相乘时都会得到不同的结果。在数学术语中，我们说一个操作是
    *交换律*，如果它无论输入顺序如何都会得到相同的结果。例如，乘法是一个交换律操作，因为对于任何选择的数字 *x* 和 *y*，*xy* = *yx*。然而，矩阵乘法
    *不是* 交换律的，因为对于两个方阵 *a* 和 *B*，*AB* 不一定等于 *BA*。|'
- en: '| **Exercise 5.5**: In either 2D or 3D, there is a boring but important vector
    transformation called the *identity transformation* that takes in a vector and
    returns the same vector as output. This transformation is linear because it takes
    any input vector sum, scalar multiple, or linear combination and returns the same
    thing as output. What are the matrices representing the identity transformation
    in 2D and 3D, respectively? |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.5**：在二维或三维中，有一个既无聊又重要的向量变换，称为**单位变换**，它接受一个向量并返回相同的向量作为输出。这种变换是线性的，因为它接受任何输入向量的和、标量乘积或线性组合，并返回相同的结果。二维和三维中代表单位变换的矩阵分别是什么？|'
- en: '| **Solution**: In 2D or 3D, the identity transformation acts on the standard
    basis vectors and leaves them unchanged. Therefore, in either dimension, the matrix
    for this transformation has the standard basis vectors as its columns. In 2D and
    3D, these *identity matrices* are denoted by *I*[2] and *I*[3], respectively,
    and look like this:![](../Images/CH05_F04_Orland_EQ24.png) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **解答**：在二维或三维中，单位变换作用于标准基向量，并保持它们不变。因此，在任意维度中，这个变换的矩阵有标准基向量作为其列。在二维和三维中，这些**单位矩阵**分别表示为*I*[2]和*I*[3]，它们的形状如下：![](../Images/CH05_F04_Orland_EQ24.png)
    |'
- en: '| **Exercise 5.6**: Apply the matrix `((2,1,1),(1,2,1),(1,1,2))` to all the
    vectors defining the teapot. What happens to the teapot and why?**Solution**:
    The following function is included in the source file matrix_transform _teapot.py:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 5.6**：将矩阵`((2,1,1),(1,2,1),(1,1,2))`应用于定义茶壶的所有向量。茶壶会发生什么变化？为什么？**解答**：以下函数包含在源文件matrix_transform_teapot.py中：'
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running the code, we see that the front of the teapot is stretched out into
    the region where *x*, *y*, and *z* are all positive.![](../Images/CH05_F04_Orland_UN01.png)Applying
    the given matrix to all vertices of the teapotThis is because all of the standard
    basis vectors are transformed to vectors with positive coordinates: (2, 1, 1),
    (1, 2, 1), and (1, 1, 2), respectively.![](../Images/CH05_F04_Orland_UN02_right.png)![](../Images/CH05_F04_Orland_UN02_left.png)How
    the linear transformation defined by this matrix affects the standard basis vectors.A
    linear combination of these new vectors with positive scalars is stretched further
    in the +*x*, +*y*, and +*z* directions than the same linear combination of the
    standard basis. |'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，我们看到茶壶的前部被拉伸到*x*、*y*和*z*都为正的区域！[](../Images/CH05_F04_Orland_UN01.png)将给定的矩阵应用于茶壶的所有顶点这是因为在所有标准基向量都被变换为具有正坐标的向量：分别是(2,
    1, 1)，(1, 2, 1)，和(1, 1, 2)。![](../Images/CH05_F04_Orland_UN02_right.png)![](../Images/CH05_F04_Orland_UN02_left.png)由这个矩阵定义的线性变换如何影响标准基向量。这些新向量与正标量的线性组合在+*x*、+*y*和+*z*方向上比标准基向量的相同线性组合拉伸得更远。
    |
- en: '| **Exercise 5.7**: Implement `multiply_matrix_vector` in a different way by
    using two nested comprehensions: one traversing the rows of the matrix and one
    traversing the entries of each row.**Solution**:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 5.7**：通过使用两个嵌套列表推导式以不同的方式实现`multiply_matrix_vector`，一个遍历矩阵的行，另一个遍历每行的条目。**解答**：'
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 5.8**: Implement `multiply_matrix_vector` yet another way using
    the fact that the output coordinates are the dot products of the input matrix
    rows with the input vector.**Solution**: This is a simplified version of the previous
    exercise solution:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 5.8**：利用输出坐标是输入矩阵行与输入向量点积的事实，以另一种方式实现`multiply_matrix_vector`。**解答**：这是先前练习解答的简化版本：'
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 5.9−Mini Project**: I first told you what a linear transformation
    was and then showed you that any linear transformation can be represented by a
    matrix. Let’s prove the converse fact now: all matrices represent linear transformations.
    Starting with the explicit formulas for multiplying a 2D vector by a 2-by−2 matrix
    or multiplying a 3D vector by a 3-by−3 matrix, prove that algebraically. That
    is, show that matrix multiplication preserves sums and scalar multiples.**Solution**:
    I’ll show the proof for 2D; the 3D proof has the same structure but with a bit
    more writing. Suppose we have a 2-by−2 matrix called *a* with any four numbers
    *a*, *b*, *c*, and *d* as its entries. Let’s see how *a* operates on two vectors
    ***u*** and ***v*** :![](../Images/CH05_F04_Orland_UN02_right_EQ25.png)You can
    do the matrix multiplications explicitly to find *a* ***u*** and *a* ***v*** :![](../Images/CH05_F04_Orland_UN02_right_EQ26.png)And
    then we can compute *a* ***u*** + *a* ***v*** and *a*(***u*** + ***v***) and see
    that the results match:![](../Images/CH05_F04_Orland_UN02_right_EQ27.png)This
    tells us that the 2D vector transformation defined by multiplying *any* 2-by−2
    matrix preserves vector sums. Likewise, for any number *s*, we have![](../Images/CH05_F04_Orland_UN02_right_EQ28.png)So
    *s* · (*a* ***v***) and *a*(*s* ***v***) give the same results, and we see that
    multiplying by the matrix *a* preserves scalar multiples as well. These two facts
    mean that multiplying by any 2-by−2 matrix is a linear transformation of 2D vectors.
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.9-迷你项目**：我首先向你介绍了线性变换的概念，然后展示了任何线性变换都可以用矩阵来表示。现在我们来证明相反的事实：所有矩阵都表示线性变换。从乘以
    2x2 矩阵的 2D 向量或乘以 3x3 矩阵的 3D 向量的显式公式开始，从代数上证明。也就是说，要证明矩阵乘法保持和以及标量乘积。**解答**：我将展示
    2D 的证明；3D 的证明结构相同，但需要更多的文字。假设我们有一个名为 *a* 的 2x2 矩阵，其元素为任意四个数字 *a*、*b*、*c* 和 *d*。让我们看看
    *a* 如何作用于两个向量 ***u*** 和 ***v***：![](../Images/CH05_F04_Orland_UN02_right_EQ25.png)你可以通过显式进行矩阵乘法来找到
    *a* ***u*** 和 *a* ***v***：![](../Images/CH05_F04_Orland_UN02_right_EQ26.png)然后我们可以计算
    *a* ***u*** + *a* ***v*** 和 *a*(***u*** + ***v***)，并看到结果是一致的：![](../Images/CH05_F04_Orland_UN02_right_EQ27.png)这告诉我们，通过乘以任何
    2x2 矩阵定义的 2D 向量变换保持向量之和。同样，对于任何数字 *s*，我们有！[图片](../Images/CH05_F04_Orland_UN02_right_EQ28.png)所以
    *s* · (*a* ***v***) 和 *a*(*s* ***v***) 给出相同的结果，我们看到乘以矩阵 *a* 保持了标量乘积。这两个事实意味着乘以任何
    2x2 矩阵是 2D 向量的线性变换。|'
- en: '| **Exercise 5.10**: Once again, let’s use the two matrices from section 5.1.3:![](../Images/CH05_F04_Orland_UN02_right_EQ29.png)Write
    a function `compose_a_b` that executes the composition of the linear transformation
    for *a* and the linear transformation for *B*. Then use the `infer _matrix` function
    from a previous exercise in this section to show that `infer_matrix(3, compose_a_b)`
    is the same as the matrix product *AB*.**Solution**: First, we implement two functions
    `transform_a` and `transform_b` that do the linear transformations defined by
    the matrices *a* and *B*. Then, we combine these using our `compose` function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 5.10**：再次使用 5.1.3 节中的两个矩阵：![](../Images/CH05_F04_Orland_UN02_right_EQ29.png)编写一个名为
    `compose_a_b` 的函数，该函数执行 *a* 和 *B* 的线性变换的组合。然后使用本节之前练习中的 `infer_matrix` 函数来证明 `infer_matrix(3,
    compose_a_b)` 与矩阵乘积 *AB* 相同。**解答**：首先，我们实现两个函数 `transform_a` 和 `transform_b`，它们执行由矩阵
    *a* 和 *B* 定义的线性变换。然后，我们使用我们的 `compose` 函数将它们组合起来：'
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can use our `infer_matrix` function to find the matrix corresponding
    to this composition of linear transformations and compare it to the matrix product
    *AB* :'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们的 `infer_matrix` 函数来找到这个线性变换组合对应的矩阵，并将其与矩阵乘积 *AB* 进行比较：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 5.11-Mini Project**: Find two, 2-by−2 matrices, neither of which
    is the identity matrix *I*[2], but whose product *is* the identity matrix.**Solution**:
    One way to do this is to write two matrices and play with their entries until
    you get the identity matrix as a product. Another way is to think of the problem
    in terms of linear transformations. If two matrices multiplied together produce
    the identity matrix, then the composition of their corresponding linear transformations
    should produce the identity transformation.With that in mind, what are two 2D
    linear transformations whose composition is the identity transformation? When
    applied in sequence to a given 2D vector, these linear transformations should
    return the original vector as output. One such pair of transformations is rotation
    by 90° clockwise, then rotation by 270° clockwise. Applying both of these executes
    a 360° rotation that brings any vector back to its original position. The matrices
    for a 270° rotation and a 90° rotation are as follows, and their product is the
    identity matrix:![](../Images/CH05_F04_Orland_UN02_right_EQ30.png) |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.11-迷你项目**：找到两个 2×2 矩阵，它们都不是单位矩阵 *I*[2]，但它们的乘积 *是* 单位矩阵。**解答**：一种方法是编写两个矩阵，并调整它们的元素，直到得到作为乘积的单位矩阵。另一种方法是考虑这个问题在线性变换的术语中。如果两个矩阵相乘得到单位矩阵，那么它们对应线性变换的复合应该产生单位变换。考虑到这一点，有哪些二维线性变换的复合是单位变换？当依次应用于给定的二维向量时，这些线性变换应该返回原始向量作为输出。这样一对变换是顺时针旋转
    90°，然后旋转 270°。应用这两个变换执行 360° 的旋转，将任何向量返回到其原始位置。270° 旋转和 90° 旋转的矩阵如下，它们的乘积是单位矩阵：![](../Images/CH05_F04_Orland_UN02_right_EQ30.png)
    |'
- en: '| **Exercise 5.12**: We can multiply a square matrix by itself any number of
    times. We can then think of successive matrix multiplications as “raising a matrix
    to a power.” For a square matrix *a*, we can write AA as *a*² ; we can write AAA
    as *a*³ ; and so on. Write a `matrix_power(power,matrix)` function that raises
    a matrix to the specified (whole number) power.**Solution**: Here is an implementation
    that works for whole number powers greater than or equal to 1:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 5.12**: 我们可以对一个方阵进行任意次数的自乘。然后我们可以将连续的矩阵乘法视为“将矩阵提升到幂”。对于一个方阵 *a*，我们可以将
    AA 写作 *a*²；我们可以将 AAA 写作 *a*³；以此类推。编写一个 `matrix_power(power,matrix)` 函数，该函数将矩阵提升到指定的（整数）幂。**解答**：以下是一个实现，它适用于大于或等于
    1 的整数幂：'
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 5.2 Interpreting matrices of different shapes
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 不同形状矩阵的解释
- en: 'The `matrix_multiply` function doesn’t hard-code the size of the input matrices,
    so we can use it to multiply either 2-by−2 or 3-by−3 matrices together. As it
    turns out, it can also handle matrices of other sizes as well. For instance, it
    can handle these two 5-by−5 matrices:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`matrix_multiply` 函数没有硬编码输入矩阵的大小，因此我们可以用它来相乘 2×2 或 3×3 矩阵。实际上，它还可以处理其他大小的矩阵。例如，它可以处理这两个
    5×5 矩阵：'
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There’s no reason we shouldn’t take this result seriously−our functions for
    vector addition, scalar multiplication, dot products, and, therefore, matrix multiplication
    don’t depend on the dimension of the vectors we use. Even though we can’t picture
    a 5D vector, we can do all the same algebra on five tuples of numbers that we
    did on pairs and triples of numbers in 2D and 3D, respectively. In this 5D product,
    the entries of the resulting matrix are still dot products of rows of the first
    matrix with columns of the second (figure 5.5):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 没有理由我们不认真对待这个结果——我们的向量加法、标量乘法、点积以及因此矩阵乘法的函数都不依赖于我们使用的向量的维度。尽管我们无法想象五维向量，但我们可以在五个数字的元组上进行所有相同的代数运算，就像我们在二维和三维中分别对数字对和三元组进行运算一样。在这个五维乘积中，结果矩阵的元素仍然是第一个矩阵的行与第二个矩阵的列的点积（如图
    5.5）：
- en: '![](../Images/CH05_F05_Orland.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F05_Orland.png)'
- en: Figure 5.5 The dot product of a row of the first matrix with a column of the
    second matrix produces one entry of the matrix product.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 第一个矩阵的行与第二个矩阵的列的点积产生矩阵乘积的一个元素。
- en: You can’t visualize it in the same way, but you can show algebraically that
    a 5-by−5 matrix specifies a linear transformation of 5D vectors. We spend time
    talking about what kind of objects live in four, five, or more dimensions in the
    next chapter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能以同样的方式可视化它，但你可以通过代数证明一个 5×5 矩阵指定了五维向量的线性变换。我们将在下一章讨论在四维、五维或更多维度中存在的对象类型。
- en: 5.2.1 Column vectors as matrices
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 列向量作为矩阵
- en: 'Let’s return to the example of multiplying a matrix by a column vector. I already
    showed you how to do a multiplication like this, but we treated it as its own
    case with the `multiply_matrix_vector` function. It turns out `matrix_multiply`
    is capable of doing these products as well, but we have to write the column vector
    as a matrix. As an example, let’s pass the following square matrix and single-column
    matrix to our `matrix_multiply` function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到矩阵乘以列向量的例子。我已经向你展示了如何进行这种乘法，但我们将其作为一个单独的案例，使用`multiply_matrix_vector`函数来处理。结果发现`matrix_multiply`也能够进行这些乘法，但我们必须将列向量写成矩阵的形式。作为一个例子，让我们将以下方阵和单列矩阵传递给我们的`matrix_multiply`函数：
- en: '![](../Images/CH05_F05_Orland_EQ31.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F05_Orland_EQ31.png)'
- en: I claimed before that you can think of a vector and a single-column matrix interchangeably,
    so we might encode `d` as a vector `(1,1,1)`. But this time, let’s force ourselves
    to think of it as a matrix, having three rows with one entry each. Note that we
    have to write (1,) instead of (1) to make Python think of it as a 1-tuple instead
    of as a number.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，你可以将向量和单列矩阵互换地考虑，所以我们可以将`d`编码为向量（1,1,1）。但这次，让我们强迫自己将其视为一个矩阵，有三个行，每个行只有一个元素。请注意，我们必须写成（1,）而不是（1），这样Python才会将其视为一个1元组而不是一个数字。
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result has three rows with one entry each, so it is a single-column matrix
    as well. Here’s what this product looks like in matrix notation:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 结果有三个行，每个行只有一个元素，因此它也是一个单列矩阵。以下是这个乘积在矩阵表示法中的样子：
- en: '![](../Images/CH05_F05_Orland_EQ32.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F05_Orland_EQ32.png)'
- en: 'Our `multiply_matrix_vector` function can evaluate the same product but in
    a different format:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`multiply_matrix_vector`函数可以评估相同的乘积，但格式不同：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This demonstrates that multiplying a matrix and a column vector is a special
    case of matrix multiplication. We don’t need a separate function `multiply_matrix
    _vector` after all. We can further see that the entries of the output are dot
    products of the rows of the first matrix with the single column of the second
    (figure 5.6).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明矩阵和列向量的乘法是矩阵乘法的一个特例。最终我们并不需要一个单独的`multiply_matrix_vector`函数。我们还可以进一步看到输出中的项是第一个矩阵的行与第二个矩阵的单列的点积（如图5.6所示）。
- en: '![](../Images/CH05_F06_Orland.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F06_Orland.png)'
- en: Figure 5.6 An entry of the resulting vector computed as a dot product
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 结果向量的一个元素，作为点积计算得出
- en: 'On paper, you’ll see vectors represented interchangeably as tuples (with commas)
    or as column vectors. But for the Python functions we’ve written, the distinction
    is critical. The tuple (−2, 1, 0) can’t be used interchangeably with the tuple-of-tuples
    ((−2,), (1,), (0,)). Yet another way of writing the same vector would be as a
    *row vector* , or a matrix with one row. Here are the three notations for comparison:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在纸上，你会看到向量可以互换地表示为元组（带有逗号）或列向量。但对我们编写的Python函数来说，这种区别是关键的。元组（−2, 1, 0）不能与元组-of-元组（（−2,），（1,），（0,））互换使用。同样，另一种表示相同向量的方式是作为*行向量*，或者是一个只有一行的矩阵。以下是三种表示方法的比较：
- en: Table 5.1 Comparison of mathematical notations for vectors with corresponding
    Python representations
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 向量数学符号与相应的Python表示的比较
- en: '| Representation | In math notation | In Python |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 表示法 | 数学符号 | Python表示 |'
- en: '| Ordered triple (ordered tuple) | ![](../Images/CH05_F06_Orland_tableEQ01.png)
    | `v = (−2,1,0)` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 有序三元组（有序元组）| ![](../Images/CH05_F06_Orland_tableEQ01.png) | `v = (−2,1,0)`
    |'
- en: '| Column vector | ![](../Images/CH05_F06_Orland_tableEQ02.png) | `v = ((−2,),(1,),(0,))`
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 列向量 | ![](../Images/CH05_F06_Orland_tableEQ02.png) | `v = ((−2,),(1,),(0,))`
    |'
- en: '| Row vector | ![](../Images/CH05_F06_Orland_tableEQ01.png) | `v = ((−2,1,0),)`
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 行向量 | ![](../Images/CH05_F06_Orland_tableEQ01.png) | `v = ((−2,1,0),)` |'
- en: If you’ve seen this comparison in math class, you may have thought it was a
    pedantic notational distinction. Once we represent these in Python, however, we
    see that they are really three distinct objects that need to be treated differently.
    While these all represent the same geometric data, which is a 3D arrow or point
    in space, only one of these, the column vector, can be multiplied by a 3-by−3
    matrix. The row vector doesn’t work because, as shown in figure 5.7, we can’t
    take the dot product of a row of the first matrix with a column of the second.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾在数学课上看到过这种比较，你可能认为这只是繁琐的符号区别。然而，一旦我们在Python中代表这些，我们会发现它们实际上是三个需要不同对待的不同对象。虽然它们都代表相同的空间几何数据，即一个3D箭头或空间中的点，但只有其中之一，即列向量，可以与3×3矩阵相乘。行向量不行，因为，如图5.7所示，我们无法将第一个矩阵的行与第二个矩阵的列进行点积。
- en: '![](../Images/CH05_F07_Orland.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F07_Orland.png)'
- en: Figure 5.7 Two matrices that cannot be multiplied together
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 不能相乘的两个矩阵
- en: For our definition of matrix multiplication to be consistent, we can only multiply
    a matrix on the left of a *column* vector. This prompts the general question posed
    by the next section.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的矩阵乘法定义保持一致，我们只能将矩阵与一个*列向量*相乘。这引发了下一节提出的一般问题。
- en: 5.2.2 What pairs of matrices can be multiplied?
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 哪些矩阵对可以相乘？
- en: We can make grids of numbers of any dimension. When can our matrix multiplication
    formula work, and what does it mean when it does?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以制作任何维度的数字网格。我们的矩阵乘法公式何时可以工作，它工作时的意义是什么？
- en: The answer is that the number of columns of the first matrix has to match the
    number of rows of the second. This is clear when we do the matrix multiplication
    in terms of dot products. For instance, we can multiply any matrix with three
    columns by a second matrix with three rows. This means that rows of the first
    matrix and columns of the second each have three entries, so we can take their
    dot products. Figure 5.8 shows the dot product of the first row of the first matrix
    with the first column of the second matrix gives us an entry of the product matrix.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，第一矩阵的列数必须与第二矩阵的行数相匹配。当我们用点积来做矩阵乘法时，这一点是明显的。例如，我们可以将任何有三个列的矩阵与一个有三个行的第二个矩阵相乘。这意味着第一矩阵的行和第二矩阵的列各有三个元素，因此我们可以计算它们的点积。图5.8显示了第一矩阵的第一行与第二矩阵的第一列的点积，这给出了乘积矩阵的一个元素。
- en: '![](../Images/CH05_F08_Orland.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F08_Orland.png)'
- en: Figure 5.8 Finding the first entry of the product matrix
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 求乘积矩阵的第一个元素
- en: We can complete this matrix product by taking the remaining seven dot products.
    Figure 5.9 shows another entry, computed from a dot product.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过计算剩余的七个点积来完成这个矩阵乘法。图5.9显示了另一个元素，它是通过点积计算得出的。
- en: '![](../Images/CH05_F09_Orland.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F09_Orland.png)'
- en: Figure 5.9 Finding another entry of the product matrix
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 求乘积矩阵的另一个元素
- en: 'This constraint also makes sense in terms of our original definition of matrix
    multiplication: the columns of the output are each linear combinations of the
    columns of the first matrix with scalars given by a row of the second matrix (figure
    5.10).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束也符合我们原始的矩阵乘法定义：输出矩阵的每一列都是第一矩阵的列与第二矩阵的行给出的标量线性组合（图5.10）。
- en: '![](../Images/CH05_F10_Orland.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F10_Orland.png)'
- en: Figure 5.10 Each column of the result is a linear combination of the columns
    of the first matrix.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 结果的每一列都是第一矩阵的列的线性组合。
- en: I was calling the previous square matrices 2-by−2 and 3-by−3 matrices. The last
    example (figure 5.10) was the product of a 2-by−3 and a 3-by−4 matrix. When we
    describe the *dimensions* of a matrix like this, we say the number of rows first
    and then the number of columns. For instance, a 3D column vector would be a 3-by−1
    matrix.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前称那些平方矩阵为2-by-2和3-by-3矩阵。最后一个例子（图5.10）是2-by-3和3-by-4矩阵的乘积。当我们这样描述矩阵的*维度*时，我们首先说行数，然后说列数。例如，一个3D列向量将是一个3-by-1矩阵。
- en: Note Sometimes you’ll see matrix dimensions written with a multiplication sign
    as in a 3×3 matrix or a 3×1 matrix.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有时你会看到矩阵维度用乘号写成3×3矩阵或3×1矩阵。
- en: 'In this language, we can make a general statement about the shapes of matrices
    that can be multiplied: you can only multiply an *n-* by *-m* matrix by a *p*
    -by- *q* matrix if *m = p*. When that is true, the resulting matrix will be a
    *n* -by- *q* matrix. For instance, a 17×9 matrix cannot be multiplied by a 6×11
    matrix. However, a 5×8 matrix can be multiplied by an 8×10 matrix. Figure 5.11
    shows the result of the latter, which is a 5×10 matrix.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种语言中，我们可以对可以相乘的矩阵形状做出一般性陈述：只有当*m = p*时，你才能将一个*n* -by- *m*矩阵与一个*p* -by- *q*矩阵相乘。当这一点成立时，结果矩阵将是一个*n*
    -by- *q*矩阵。例如，一个17×9矩阵不能与一个6×11矩阵相乘。然而，一个5×8矩阵可以与一个8×10矩阵相乘。图5.11显示了后者的结果，它是一个5×10矩阵。
- en: '![](../Images/CH05_F11_Orland.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F11_Orland.png)'
- en: Figure 5.11 Each of the five rows of the first matrix can be paired with one
    of the ten columns of the second matrix to produce one of the 5 × 10 = 50 entries
    of the product matrix. I used stars instead of numbers to show you that any matrices
    of these sizes are compatible.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 第一矩阵的每一行都可以与第二矩阵的十列之一配对，以产生乘积矩阵的5×10=50个元素之一。我使用星号而不是数字来表明任何这些尺寸的矩阵都是兼容的。
- en: 'By contrast, you couldn’t multiply these matrices in the opposite order: a
    10×8 matrix can’t be multiplied by a 5×8 matrix. Now it’s clear how to multiply
    bigger matrices, but what do the results mean? It turns out we can learn something
    from the result: *all* matrices represent vector functions, and all valid matrix
    products can be interpreted as composition of these functions. Let’s see how this
    works.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，你不能以相反的顺序乘这些矩阵：一个10×8的矩阵不能被一个5×8的矩阵相乘。现在我们已经清楚如何乘更大的矩阵，但结果意味着什么呢？结果表明我们可以从结果中学到一些东西：**所有**矩阵都代表向量函数，所有有效的矩阵乘积都可以解释为这些函数的组合。让我们看看这是如何工作的。
- en: 5.2.3 Viewing square and non-square matrices as vector functions
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 将方阵和非方阵视为向量函数
- en: We can think of a 2×2 matrix as the data required to do a given linear transformation
    of a 2D vector. Pictured as a machine in figure 5.12, this transformation takes
    a 2D vector into its input slot and produces a 2D vector out of its output slot
    as a result.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将2×2矩阵视为执行二维向量给定线性变换所需的数据。如图5.12所示的机器，这种变换将二维向量输入其输入插槽，并从其输出插槽产生二维向量作为结果。
- en: '![](../Images/CH05_F12_Orland.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F12_Orland.png)'
- en: Figure 5.12 Visualizing a matrix as a machine that takes vectors as inputs and
    produces vectors as outputs
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 将矩阵可视化为一个输入向量并输出向量的机器
- en: 'Under the hood, our machine does this matrix multiplication:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，我们的机器执行以下矩阵乘法：
- en: '![](../Images/CH05_F12_Orland_EQ33_Orland.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F12_Orland_EQ33_Orland.png)'
- en: It’s fair to think of matrices as machines that take vectors as inputs and produce
    vectors as outputs. Figure 5.13, however, shows a matrix can’t take just any vector
    as input; it is a 2×2 matrix so it does a linear transformation of 2D vectors.
    Correspondingly, this matrix can only be multiplied by a column vector with two
    entries. Let’s split up the machine’s input and output slots to suggest that these
    take and produce 2D vectors or pairs of numbers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将矩阵视为输入向量并输出向量的机器是合理的。然而，图5.13显示，矩阵不能接受任何向量作为输入；它是一个2×2矩阵，因此它对二维向量进行线性变换。相应地，这个矩阵只能与一个有两个条目的列向量相乘。让我们将机器的输入和输出插槽分开，以表明它们接受和产生二维向量或数字对。
- en: '![](../Images/CH05_F13_Orland.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F13_Orland.png)'
- en: Figure 5.13 Refining our mental model by redrawing the machine’s input and output
    slots to indicate that its inputs and outputs are pairs of numbers
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13 通过重新绘制机器的输入和输出插槽来细化我们的心理模型，以表明其输入和输出是数字对
- en: Likewise, a linear transformation machine (figure 5.14) powered by a 3×3 matrix
    can only take in 3D vectors and produce 3D vectors as a result.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由3×3矩阵供电的线性变换机器（图5.14）只能接受3D向量并产生3D向量作为结果。
- en: '![](../Images/CH05_F14_Orland.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F14_Orland.png)'
- en: Figure 5.14 A linear transformation machine powered by a 3×3 matrix takes in
    3D vectors and outputs 3D vectors.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 由3×3矩阵供电的线性变换机器接受3D向量并输出3D向量。
- en: 'Now we can ask ourselves, what would a machine look like if it were powered
    by a non-square matrix? Perhaps the matrix would look something like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以问自己，如果机器由一个非方阵供电，它看起来会是什么样子？也许矩阵看起来会像这样：
- en: '![](../Images/CH05_F14_Orland_EQ34.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F14_Orland_EQ34.png)'
- en: As a specific example, what kinds of vectors could this 2×3 matrix act on? If
    we’re going to multiply this matrix with a column vector, the column vector must
    have three entries to match the size of the rows of this matrix. Multiplying our
    2×3 matrix by a 3×1 column vector gives us a 2×1 matrix as a result, or a 2D column
    vector. For example,
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 作为具体例子，这个2×3矩阵可以作用于哪些类型的向量？如果我们打算用这个矩阵乘以一个列向量，这个列向量必须有三个条目以匹配这个矩阵的行的大小。将我们的2×3矩阵乘以一个3×1的列向量，我们得到一个2×1的矩阵作为结果，或者一个二维列向量。例如，
- en: '![](../Images/CH05_F14_Orland_EQ35.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F14_Orland_EQ35.png)'
- en: This tells us that this 2×3 matrix represents a function taking 3D vectors to
    2D vectors. If we were to draw it as a machine, like in figure 5.15, it would
    accept 3D vectors in its input slot and produce 2D vectors from its output slot.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们这个2×3矩阵代表一个将3D向量映射到2D向量的函数。如果我们将其绘制成机器，如图5.15所示，它将接受3D向量作为其输入插槽，并从其输出插槽产生2D向量。
- en: '![](../Images/CH05_F15_Orland.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F15_Orland.png)'
- en: Figure 5.15 A machine that takes in 3D vectors and outputs 2D vectors, powered
    by a 2×3 matrix
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15 由2×3矩阵供电的机器，接受3D向量并输出2D向量
- en: 'In general, an *m* -by- *n* matrix defines a function taking *n* -dimensional
    vectors as inputs and returning *m* -dimensional vectors as outputs. Any such
    function is linear in the sense that it preserves vector sums and scalar multiples.
    It’s not a transformation because it doesn’t just modify input, it returns an
    entirely different kind of output: a vector living in a different number of dimensions.
    For this reason, we’ll use a more general terminology; we’ll call it a *linear
    function* or a *linear map*. Let’s consider an in-depth example of a familiar
    linear map from 3D to 2D.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个*m*×*n*矩阵定义了一个函数，它接受*n*维向量作为输入，并返回*m*维向量作为输出。任何这样的函数都是线性的，因为它保持向量之和和数乘。它不是一个变换，因为它不仅仅修改输入，它返回的是完全不同类型的输出：一个存在于不同维数的向量。因此，我们将使用一个更一般的术语；我们将称之为*线性函数*或*线性映射*。让我们考虑一个从3D到2D的熟悉线性映射的深入例子。
- en: 5.2.4 Projection as a linear map from 3D to 2D
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 从3D到2D的投影作为线性映射
- en: 'We already saw a vector function that accepts 3D vectors and produces 2D vectors:
    a projection of a 3D vector onto the *x*,*y* plane (section 3.5.2). This transformation
    (we can call it *P*) takes vectors of the form (*x*, *y*, *z*) and returns these
    with their *z* component deleted: (*x*, *y*). I’ll spend some time carefully showing
    why this is a linear map and how it preserves vector addition and scalar multiplication.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个接受3D向量并产生2D向量的向量函数：将3D向量投影到*x*,*y*平面（第3.5.2节）。这种变换（我们可以称之为*P*）接受形式为(*x*,
    *y*, *z*)的向量，并返回删除其*z*分量的这些向量：(*x*, *y*)。我将花一些时间仔细说明为什么这是一个线性映射以及它是如何保持向量加法和数乘的。
- en: First of all, let’s write *P* as a matrix. To accept 3D vectors and return 2D
    vectors, it should be a 2×3 matrix. Let’s follow our trusty formula for finding
    a matrix by testing the action of *P* on standard basis vectors. Remember, in
    3D the standard basis vectors are defined as ***e***[1] = (1, 0, 0), ***e***[2]
    = (0, 1, 0), and ***e***[3] = (0, 0, 1), and when we apply the projection to these
    three vectors, we get (1, 0), (0, 1), and (0, 0), respectively. We can write these
    as column vectors
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将*P*写成矩阵的形式。为了接受3D向量并返回2D向量，它应该是一个2×3矩阵。让我们遵循我们可靠的矩阵寻找公式，通过测试*P*对标准基向量的作用。记住，在3D中，标准基向量定义为***e***[1]
    = (1, 0, 0)，***e***[2] = (0, 1, 0)，和***e***[3] = (0, 0, 1)，当我们对这三个向量应用投影时，我们分别得到(1,
    0)，(0, 1)，和(0, 0)。我们可以将这些写成列向量
- en: '![](../Images/CH05_F15_Orland_EQ36.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F15_Orland_EQ36.png)'
- en: 'and then stick them together side by side to get a matrix:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将它们并排放在一起以形成一个矩阵：
- en: '![](../Images/CH05_F15_Orland_EQ37.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F15_Orland_EQ37.png)'
- en: To check this, let’s multiply it by a test vector (*a*, *b*, *c*). The dot product
    of (*a*, *b*, *c*) with (1, 0, 0) is *a*, so that’s the first entry of the result.
    The second entry is the dot product of (*a*, *b*, *c*) with (0, 1, 0), or *b*.
    You can picture this matrix as grabbing *a* and *b* from (*a*, *b*, *c*) and ignoring
    *c*(figure 5.16).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查这一点，让我们用一个测试向量(*a*, *b*, *c*)乘以它。(*a*, *b*, *c*)与(1, 0, 0)的点积是*a*，所以这是结果的第一项。第二项是(*a*,
    *b*, *c*)与(0, 1, 0)的点积，即*b*。你可以想象这个矩阵就像从(*a*, *b*, *c*)中抓取*a*和*b*，而忽略*c*（如图5.16）。
- en: '![](../Images/CH05_F16_Orland.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F16_Orland.png)'
- en: Figure 5.16 Only 1 · a contributes to the first entry of the product, and only
    1 · *b* contributes to the second entry. The other entries are zeroed out (in
    gray in the figure).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16 只有1 · a对乘积的第一项有贡献，只有1 · *b*对第二项有贡献。其他项被置零（在图中以灰色表示）。
- en: This matrix does what we want; it deletes the third coordinate of a 3D vector,
    leaving us with only the first two coordinates. It’s good news that we can write
    this projection as a matrix, but let’s also give an algebraic *proof* that this
    is a linear map. To do this, we have to show that the two key conditions of linearity
    are satisfied.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩阵做了我们想要的事情；它删除了3D向量的第三个坐标，只留下前两个坐标。我们可以把这个投影写成矩阵是个好消息，但让我们也给出一个代数*证明*，说明这是一个线性映射。为此，我们必须证明线性性的两个关键条件得到满足。
- en: Proving that projection preserves vector sums
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 证明投影保持向量之和
- en: 'If *P* is linear, any vector sum ***u*** + ***v*** = ***w*** should be respected
    by *P*. That is, *P*(***u***) + *P*(***v***) should equal *P*(***w***) as well.
    Let’s confirm this using these equations: ***u*** = (*u*[1], *u*[2], *u*[3]) and
    ***v*** = (*v*[1], *v*[2], *v*[3]). Then ***w*** = ***u*** + ***v*** so that'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*P*是线性的，那么任何向量之和***u*** + ***v*** = ***w***都应该被*P*所尊重。也就是说，*P*(***u***) +
    *P*(***v***)应该等于*P*(***w***)。让我们使用这些方程来确认这一点：***u*** = (*u*[1], *u*[2], *u*[3])和***v***
    = (*v*[1], *v*[2], *v*[3])。那么***w*** = ***u*** + ***v***，所以
- en: w = (*u*[1] + *v*[1], *u*[2] + *v*[2], *u*[3] + *v*[3])
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: w = (*u*[1] + *v*[1], *u*[2] + *v*[2], *u*[3] + *v*[3])
- en: 'Executing *P* on all of these vectors is simple because we only need to remove
    the third coordinate:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有这些向量执行 *P* 是简单的，因为我们只需要移除第三个坐标：
- en: '*P*(*u*) = (*u*[1], *u*[2])'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*(*u*) = (*u*[1], *u*[2])'
- en: '*P*(*v*) = (*v*[1], *v*[2])'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*(*v*) = (*v*[1], *v*[2])'
- en: so
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所以
- en: '*P*(*w*) = (*u*[1] + *v*[1], *u*[2] + *v*[2])'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*(*w*) = (*u*[1] + *v*[1], *u*[2] + *v*[2])'
- en: Adding *P*(***u***) and *P*(***v***), we get (*u*[1] + *v*[1], *u*[2] + *v*[2]),
    which is the same as *P*(***w***). For any three 3D vectors ***u*** + ***v***
    = ***w***, we, therefore, also have *P*(***u***) + *P*(***v***) = *P*(***w***).
    This validates our first condition.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *P*(***u***) 和 *P*(***v***）相加，我们得到 (*u*[1] + *v*[1], *u*[2] + *v*[2])，这与 *P*(***w***)
    相同。对于任何三个三维向量 ***u*** + ***v*** = ***w***，因此我们也有 *P*(***u***) + *P*(***v***) =
    *P*(***w***)。这验证了我们的第一个条件。
- en: Proving projection preserves scalar multiples
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 证明投影保持标量乘积
- en: The second thing we need to show is that *P* preserves scalar multiples. Letting
    *s* stand for *any* real number and letting ***u*** = (*u*[1], *u*[2], *u*[3]),
    we want to demonstrate that *P*(*s* u) is the same as *sP*(*u*).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要证明的第二件事是 *P* 保持了标量乘积。让 *s* 代表 *任何* 实数，并让 ***u*** = (*u*[1], *u*[2], *u*[3])，我们想要证明
    *P*(*s* u) 与 *sP*(*u*) 相同。
- en: Deleting the third coordinate and doing the scalar multiplication give the same
    result regardless of which order these operations are carried out. The result
    of *s* *z* is (*su*[1], *su*[2], *su*[3]), so *P*(*s* u) = (*su*[1], *su*[2]).
    The result of *P*(***u***) is (***u***[1], ***u***[2]), so *sP*(*u*) = (*su*[1],
    *su*[2]). This validates the second condition and confirms that *P* satisfies
    the definition of linearity.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 删除第三个坐标并进行标量乘法，无论这些操作以何种顺序执行，都会得到相同的结果。*s* *z* 的结果是 (*su*[1], *su*[2], *su*[3])，所以
    *P*(*s* u) = (*su*[1], *su*[2])。*P*(***u***) 的结果是 (***u***[1], ***u***[2])，所以
    *sP*(*u*) = (*su*[1], *su*[2])。这验证了第二个条件，并确认 *P* 满足线性的定义。
- en: These kinds of proofs are usually easier to do than to follow, so I’ve given
    you another one as an exercise. In the exercise, you can check that a function
    from 2D to 3D, specified by a given matrix, is linear using the same approach.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这类证明通常比理解起来更容易，所以我给你们提供了一个练习题。在练习题中，你可以检查一下，一个从二维到三维的函数，由一个给定的矩阵指定，是否可以使用相同的方法来证明它是线性的。
- en: More illustrative than an algebraic proof is an example. What does it look like
    when we project a 3D vector sum down to 2D? We can see it in three steps. First,
    we can draw a vector sum of two vectors ***u*** and ***v*** in 3D as shown in
    figure 5.17.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 比代数证明更有说明性的是例子。当我们把一个三维向量的和投影到二维时，它看起来会是什么样子？我们可以分三步来看。首先，我们可以像图5.17所示的那样，在三维空间中画出两个向量
    ***u*** 和 ***v*** 的和。
- en: '![](../Images/CH05_F17_Orland.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F17_Orland.png)'
- en: Figure 5.17 A vector sum of two arbitrary vectors *z* and *v* in 3D
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17 两个任意向量 *z* 和 *v* 在三维空间中的向量和
- en: Then, we can trace a line from each vector to the *x*,*y* plane to show where
    these vectors end up after projection (figure 5.18).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从每个向量画一条线到 *x*，*y* 平面，以显示这些向量在投影后的位置（图5.18）。
- en: '![](../Images/CH05_F18_Orland.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F18_Orland.png)'
- en: Figure 5.18 Visualizing where *u*, *v*, and *z* + *v* end up after projection
    to the x,y plane
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18 展示了 *u*，*v* 和 *z* + *v* 在投影到 x,y 平面后的位置
- en: Finally, we can look at these new vectors and see that they *still* constitute
    a vector sum (figure 5.19).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以观察这些新向量，并看到它们 *仍然* 构成了一个向量和（图5.19）。
- en: '![](../Images/CH05_F19_Orland.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F19_Orland.png)'
- en: 'Figure 5.19 The projected vectors form a sum: P(*v*) + P(*v*) = P(*u + v*).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.19 投影后的向量形成一个和：P(*v*) + P(*v*) = P(*u + v*)。
- en: In other words, if three vectors ***u***, ***v***, and ***w*** form a vector
    sum ***u*** + ***v*** = ***w***, then their “shadows” in the *x*,*y* plane also
    form a vector sum. Now that you’ve got some insight into linear transformation
    from 3D to 2D and a matrix that represents it, let’s return to our discussion
    of linear maps in general.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果三个向量 ***u***，***v*** 和 ***w*** 构成了一个向量和 ***u*** + ***v*** = ***w***，那么它们在
    *x*，*y* 平面上的“影子”也形成一个向量和。现在你已经对从三维到二维的线性变换及其表示的矩阵有了些了解，让我们回到对线性映射的一般讨论。
- en: 5.2.5 Composing linear maps
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.5 线性映射的合成
- en: The beauty of matrices is that they store all of the data required to evaluate
    a linear function on a given vector. What’s more, the dimensions of a matrix tell
    us the dimensions of input vectors and output vectors for the underlying function.
    We captured that visually in figure 5.20 by drawing machines for matrices of varying
    dimensions, whose input and output slots have different shapes. Here are four
    examples we’ve seen, labeled with letters so we can refer back to them.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的美丽之处在于它们存储了评估给定向量上的线性函数所需的所有数据。更重要的是，矩阵的维度告诉我们底层函数的输入向量和输出向量的维度。我们在图 5.20
    中通过绘制不同维度的矩阵机器来直观地捕捉这一点，这些机器的输入和输出槽具有不同的形状。以下是四个我们看到的例子，用字母标记以便我们可以回过来引用。
- en: '![](../Images/CH05_F20_Orland.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F20_Orland.png)'
- en: Figure 5.20 Four linear functions represented as machines with input and output
    slots. The shape of a slot tells us what dimension of vector it accepts or produces.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20 以机器形式表示的四个线性函数，具有输入和输出槽。槽的形状告诉我们它接受或产生向量的维度。
- en: Drawn like this, it’s easy to pick out which pairs of linear function machines
    could be welded together to build a new one. For instance, the output slot of
    *M* has the same shape as the input slot of *P*, so we could make the composition
    *P*(*M*(***v***)) for a 3D vector ***v***. The output of *M* is a 3D vector that
    can be passed right along into the input slot of *P*(figure 5.21).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这样画出来，很容易找出哪些线性函数机器的配对可以焊接在一起来构建一个新的。例如，*M* 的输出槽与 *P* 的输入槽形状相同，因此我们可以为 3D 向量
    ***v*** 构造组合 *P*(*M*(***v***))。*M* 的输出是一个 3D 向量，可以直接传递到 *P* 的输入槽中（图 5.21）。
- en: '![](../Images/CH05_F21_Orland.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F21_Orland.png)'
- en: Figure 5.21 The composition of P and M. A vector is passed into the input slot
    of M, the output M(*v*) passes invisibly through the plumbing and into P, and
    the output P(M(*v*)) emerges from the other end.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21 P 和 M 的组合。一个向量被传递到 M 的输入槽中，M(*v*) 的输出无形中穿过管道进入 P，P(M(*v*)) 的输出从另一端出现。
- en: By contrast, figure 5.22 shows that we can’t compose *N* and *M* because *N*
    doesn’t have enough output slots to fill every input of *M*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，图 5.22 显示我们无法组合 *N* 和 *M*，因为 *N* 没有足够的输出槽来填充 *M* 的每个输入。
- en: '![](../Images/CH05_F22_Orland.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F22_Orland.png)'
- en: Figure 5.22 The composition of N and M is not possible because outputs of N
    are 2D vectors, while inputs to M are 3D vectors.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22 N 和 M 的组合是不可能的，因为 N 的输出是 2D 向量，而 M 的输入是 3D 向量。
- en: I’m making this idea visual now by talking about slots, but hidden underneath
    is the same reasoning we use to decide if two matrices can be multiplied together.
    The count of the columns of the first matrix has to match the count of rows of
    the second. When the dimensions match in this way, so do the slots, and we can
    compose the linear functions and multiply their matrices.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在通过谈论槽位来使这个想法可视化，但隐藏在下面的推理与决定两个矩阵是否可以相乘的推理是相同的。第一个矩阵的列数必须与第二个矩阵的行数相匹配。当维度以这种方式匹配时，槽位也匹配，我们可以组合线性函数并乘以它们的矩阵。
- en: Thinking of *P* and *M* as matrices, the composition of *P* and *M* is written
    *PM* as a matrix product. (Remember, if *PM* acts on a vector ***v*** as *PM*
    ***v***, *M* is applied first and then *P*.) When ***v*** = (1, 1, 1), the product
    *PM* ***v*** is a product of two matrices and a column vector, and it can be simplified
    into a single matrix times a column vector if we evaluate *PM (* figure 5.23).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *P* 和 *M* 视为矩阵，*P* 和 *M* 的组合写作 *PM* 作为矩阵乘积。（记住，如果 *PM* 对向量 ***v*** 作用为 *PM*
    ***v***，则先应用 *M*，然后是 *P*。）当 ***v*** = (1, 1, 1) 时，乘积 *PM* ***v*** 是两个矩阵和一个列向量的乘积，如果我们评估
    *PM*（图 5.23），它可以简化为一个矩阵乘以一个列向量。
- en: '![](../Images/CH05_F23_Orland.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F23_Orland.png)'
- en: Figure 5.23 Applying M and then P is equivalent to applying the composition
    PM. We consolidate the composition into a single matrix by doing the matrix multiplication.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23 应用 M 和 P 等同于应用组合 PM。我们通过矩阵乘法将组合合并为一个单一的矩阵。
- en: As a programmer, you’re used to thinking of functions in terms of the types
    of data they consume and produce. I’ve given you a lot of notation and terminology
    to digest thus far in this chapter, but as long as you grasp this core concept,
    you’ll get the hang of it eventually.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你习惯于从函数消耗和产生数据类型的角度来考虑函数。到目前为止，我在本章中已经给了你很多符号和术语来消化，但只要你掌握了这个核心概念，你最终会掌握它的。
- en: I strongly encourage you to work through the following exercises to make sure
    you understand the language of matrices. For the rest of this chapter and the
    next, there won’t be many big new concepts, only applications of what we’ve seen
    so far. These applications will give you even more practice with matrix and vector
    computations.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你完成以下练习，以确保你理解矩阵的语言。在本章的其余部分和下一章中，不会有太多新的重大概念，只有对我们之前所学的应用。这些应用将使你在矩阵和向量计算方面有更多的实践机会。
- en: 5.2.6 Exercises
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.6 练习
- en: '| **Exercise 5.13**: What are the dimensions of this matrix?![](../Images/CH05_F23_Orland_EQ38.png)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 5.13**: 这个矩阵的维度是什么？！[](../Images/CH05_F23_Orland_EQ38.png)'
- en: 5×3
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5×3
- en: 3×5
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3×5
- en: '**Solution**: This is a 3×5 matrix because it has three rows and five columns.
    |'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**：这是一个 3×5 矩阵，因为它有三行五列。|'
- en: '| **Exercise 5.14**: What are the dimensions of a 2D column vector considered
    as a matrix? What about a 2D row vector? A 3D column vector? A 3D row vector?**Solution**:
    A 2D column vector has two rows and one column, so it is a 2×1 matrix. A 2D row
    vector has one row with two columns, so it is a 1×2 matrix. Likewise, a 3D column
    and row vector have the dimensions 3×1 and 1×3 as matrices, respectively. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.14**: 将一个二维列向量视为矩阵时，它的维度是什么？二维行向量呢？三维列向量？三维行向量？**解答**：一个二维列向量有两行一列，因此它是一个
    2×1 矩阵。一个二维行向量有一行两列，因此它是一个 1×2 矩阵。同样，三维列向量和行向量作为矩阵的维度分别是 3×1 和 1×3。|'
- en: '| **Exercise 5.15-Mini Project**: Many of our vector and matrix operations
    make use of the Python `zip` function. When given input lists of different sizes,
    this function truncates the longer of the two rather than failing. This means
    that when we pass invalid inputs, we get meaningless results back. For instance,
    there is no such thing as a dot product between a 2D vector and a 3D vector, but
    our `dot` function returns something anyway:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 5.15-迷你项目**：我们的大多数向量和矩阵操作都使用了 Python 的 `zip` 函数。当给定不同大小的输入列表时，这个函数会截断较长的列表而不是失败。这意味着当我们传递无效输入时，我们会得到无意义的结果。例如，二维向量和三维向量之间没有点积，但我们的
    `dot` 函数仍然返回某些内容：'
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Add safeguards to all of the vector arithmetic functions so that they throw
    exceptions rather than returning values for vectors of invalid sizes. Once you’ve
    done that, show that `matrix_multiply` no longer accepts a product of a 3×2 and
    a 4×5 matrix. |
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有向量算术函数添加安全措施，以便它们对无效大小的向量抛出异常，而不是返回值。一旦你完成了这个，就证明 `matrix_multiply` 不再接受
    3×2 和 4×5 矩阵的乘积。|
- en: '| **Exercise 5.16**: Which of the following are valid matrix products? For
    those that are valid, what dimension is the product matrix?A.![](../Images/CH05_F23_Orland_EQ39.png)B.![](../Images/CH05_F23_Orland_EQ40.png)C.![](../Images/CH05_F23_Orland_EQ41.png)D.![](../Images/CH05_F23_Orland_EQ42.png)**Solution**:A.
    This product of a 2×2 matrix and a 4×4 matrix is not valid; the first matrix has
    two columns but the second matrix has four rows.B. This product of a 2×4 matrix
    and a 4×2 matrix *is* valid; the four columns of the first matrix match the four
    rows of the second matrix. The result is a 2×2 matrix.C. This product of a 3×1
    matrix and a 1×8 matrix *is* valid; the single column of the first matrix matches
    the single row of the second. The result is a 3×8 matrix.D. This product of a
    3×3 matrix and a 2×3 matrix is not valid; the three columns of the first matrix
    do not match the two rows of the second. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.16**: 以下哪些是有效的矩阵乘积？对于有效的乘积，乘积矩阵的维度是多少？A.![](../Images/CH05_F23_Orland_EQ39.png)B.![](../Images/CH05_F23_Orland_EQ40.png)C.![](../Images/CH05_F23_Orland_EQ41.png)D.![](../Images/CH05_F23_Orland_EQ42.png)**解答**：A.
    这个 2×2 矩阵和 4×4 矩阵的乘积是不有效的；第一个矩阵有两列，但第二个矩阵有四行。B. 这个 2×4 矩阵和 4×2 矩阵的乘积是有效的；第一个矩阵的四个列与第二个矩阵的四个行相匹配。结果是
    2×2 矩阵。C. 这个 3×1 矩阵和 1×8 矩阵的乘积是有效的；第一个矩阵的单列与第二个矩阵的单行相匹配。结果是 3×8 矩阵。D. 这个 3×3 矩阵和
    2×3 矩阵的乘积是不有效的；第一个矩阵的三列不匹配第二个矩阵的两行。|'
- en: '| **Exercise 5.17**: A matrix with 15 total entries is multiplied by a matrix
    with 6 total entries. What are the dimensions of the two matrices, and what is
    the dimension of the product matrix?**Solution**: Let’s call the dimensions of
    the matrices *m* -by- *n* and *n* -by- *k* because the number of columns of the
    first matrix has to match the number of rows of the second. Then *mn* = 15 and
    *nk* = 6\. There are actually two possibilities:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 5.17**：一个有 15 个总条目的矩阵乘以一个有 6 个总条目的矩阵。这两个矩阵的维度是什么，乘积矩阵的维度是什么？**解答**：让我们称矩阵的维度为
    *m* -by- *n* 和 *n* -by- *k*，因为第一个矩阵的列数必须与第二个矩阵的行数相匹配。那么 *mn* = 15 和 *nk* = 6。实际上有两种可能性：'
- en: The first possibility is that *m* = 5, *n* = 3, and *k* = 2\. Then this would
    be a 5×3 matrix multiplied by a 3×2 matrix resulting in a 5×2 matrix.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种可能性是 *m* = 5, *n* = 3, 和 *k* = 2。那么这将是一个 5×3 矩阵乘以一个 3×2 矩阵，结果是一个 5×2 矩阵。
- en: The second possibility is that *m* = 15, *n* = 1, and *k* = 6\. Then this would
    be a 15×1 matrix times a 1×6 matrix, resulting in a 15×6 matrix.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种可能性是 *m* = 15, *n* = 1, 和 *k* = 6。那么这将是一个 15×1 矩阵乘以一个 1×6 矩阵，结果是一个 15×6 矩阵。
- en: '|'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 5.18**: Write a function that turns a column vector into a row
    vector, or vice versa. Flipping a matrix on its side like this is called *transposition*
    and the resulting matrix is called the *transpose* of the original.**Solution**:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 5.18**：编写一个函数，将列向量转换为行向量，或反之亦然。像这样翻转矩阵称为**转置**，得到的矩阵称为原始矩阵的**转置**。**解答**：'
- en: '[PRE22]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The call to `zip(*matrix)` returns a list of columns of the matrix and then
    we tuple them. This has the effect of swapping rows and columns of any input matrix,
    specifically turning column vectors into row vectors and vice versa:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `zip(*matrix)` 返回矩阵的列的列表，然后我们将它们元组化。这会交换任何输入矩阵的行和列，具体来说，将列向量转换为行向量，反之亦然：
- en: '[PRE23]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 5.19**: Draw a picture that shows that a 10×8 and a 5×8 matrix
    *can’t* be multiplied in that order.**Solution**:![](../Images/w_gifs_326.gif)The
    rows of the first matrix have ten entries but the columns of the second have five,
    meaning we can’t evaluate this matrix product. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.19**：画一个图来展示一个 10×8 和一个 5×8 矩阵**不能**按那种顺序相乘。**解答**：![动画](../Images/w_gifs_326.gif)第一个矩阵的行有十个条目，但第二个矩阵的列有五个，这意味着我们无法评估这个矩阵乘积。
    |'
- en: '| **Exercise 5.20**: We want to multiply three matrices together: *a* is 5×7,
    *B* is 2×3, and *C* is 3×5\. What order can they be multiplied in and what is
    the size of the result?**Solution**: One valid product is *BC*, a 2x3 times a
    3×5 matrix yielding a 2×5 matrix. Another is *CA*, a 3×5 matrix times a 5×7 matrix
    yielding a 3×7 matrix. The product of three matrices, *BCA*, is valid regardless
    of the order you use. (*BC*) *a* is a 2×5 matrix times a 5×7 matrix, while *B*(*CA*)
    is a 2×3 matrix times a 3×7 matrix. Each yields the same 2×7 matrix as a result.![](../Images/CH05_F23_Orland_UN04.png)Multiplying
    three matrices in different orders |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.20**：我们想将三个矩阵相乘：*a* 是 5×7，*B* 是 2×3，*C* 是 3×5。它们可以按什么顺序相乘，结果的大小是多少？**解答**：一个有效乘积是
    *BC*，一个 2x3 乘以一个 3×5 矩阵得到一个 2×5 矩阵。另一个是 *CA*，一个 3×5 矩阵乘以一个 5×7 矩阵得到一个 3×7 矩阵。三个矩阵的乘积
    *BCA*，无论你使用什么顺序都是有效的。(*BC*) *a* 是一个 2×5 矩阵乘以一个 5×7 矩阵，而 *B*(*CA*) 是一个 2×3 矩阵乘以一个
    3×7 矩阵。每个都得到相同的 2×7 矩阵作为结果。![图片](../Images/CH05_F23_Orland_UN04.png)以不同的顺序乘以三个矩阵
    |'
- en: '| **Exercise 5.21**: Projection onto the *y*,*z* plane and onto the *x*,*z*
    plane are also linear maps from 3D to 2D. What are their matrices?**Solution**:
    Projection onto the *y*,*z* plane deletes the *x*-coordinate. The matrix for this
    operation is![](../Images/CH05_F23_Orland_UN04_EQ43.png)Likewise, projection onto
    the *x*,*z* plane deletes the *y*-coordinate:![](../Images/CH05_F23_Orland_UN04_EQ44.png)For
    example,![](../Images/CH05_F23_Orland_UN04_EQ45.png) |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.21**：将投影到 *y*，*z* 平面和 *x*，*z* 平面也是从 3D 到 2D 的线性映射。它们的矩阵是什么？**解答**：投影到
    *y*，*z* 平面删除了 *x* 坐标。这个操作的矩阵是![图片](../Images/CH05_F23_Orland_UN04_EQ43.png)。同样，投影到
    *x*，*z* 平面删除了 *y* 坐标：![图片](../Images/CH05_F23_Orland_UN04_EQ44.png)。例如，![图片](../Images/CH05_F23_Orland_UN04_EQ45.png)
    |'
- en: '| **Exercise 5.22**: Show by example that the `infer_matrix` function from
    a previous exercise can create matrices for linear functions whose inputs and
    outputs have different dimensions.**Solution**: One function we could test would
    be projection onto the *x*,*y* plane, which takes in 3D vectors and returns 2D
    vectors. We can implement this linear transformation as a Python function and
    then infer its 2×3 matrix:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 5.22**：通过示例说明之前练习中的`infer_matrix`函数可以创建具有不同维度输入和输出的线性函数的矩阵。**解答**：我们可以测试的一个函数是将投影到*x*，*y*平面的函数，它接受3D向量并返回2D向量。我们可以将这个线性变换实现为一个Python函数，然后推断其2×3矩阵：'
- en: '[PRE24]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that we had to supply the dimension of *input* vectors as an argument,
    so that we can build the correct standard basis vectors to test under the action
    of `project_xy`. Once `project_xy` is passed the 3D standard basis vectors, it
    automatically outputs 2D vectors to supply the columns of the matrix. |
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须将输入向量的维度作为参数提供，这样我们才能构建正确的标准基向量以在`project_xy`的作用下进行测试。一旦`project_xy`传递了3D标准基向量，它就会自动输出2D向量以提供矩阵的列。|
- en: '| **Exercise 5.23**: Write a 4×5 matrix that acts on a 5D vector by deleting
    the third of its five entries, thereby producing a 4D vector. For instance, multiplying
    it with the column vector form of (1, 2, 3, 4, 5) should return (1, 2, 4, 5).**Solution**:
    The matrix is![](../Images/CH05_F23_Orland_UN04_EQ46.png)You can see that the
    first, second, fourth, and fifth coordinates of an input vector form the four
    coordinates of the output vector:![](../Images/CH05_F23_Orland_UN05.png)The 1s
    in the matrix indicate where coordinates of the input vector end up in the output
    vector. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.23**：编写一个4×5矩阵，它通过删除其五个条目中的第三个来作用于一个5D向量，从而产生一个4D向量。例如，将其与列向量形式（1,
    2, 3, 4, 5）相乘应该返回（1, 2, 4, 5）。**解答**：这个矩阵是![](../Images/CH05_F23_Orland_UN04_EQ46.png)你可以看到输入向量的第一个、第二个、第四个和第五个坐标构成了输出向量的四个坐标！[](../Images/CH05_F23_Orland_UN05.png)矩阵中的1表示输入向量的坐标最终出现在输出向量中的位置。|'
- en: '| **Exercise 5.24−Mini Project**: Consider the vector of six variables (*l*,
    *e*, *m*, *o*, *n*, *s*). Find the matrix for the linear transformation that acts
    on this vector to produce the vector (*s*, *o*, *l*, *e*, *m*, *n*) as a result.**Hint**:
    The third coordinate of the output equals the first coordinate of the input, so
    the transformation must send the standard basis vector (1, 0, 0, 0, 0, 0) to (0,
    0, 1, 0, 0, 0).**Solution**:![](../Images/CH05_F23_Orland_UN05_EQ47.png)This matrix
    reorders the entries of a 6D vector in the specified way. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.24-迷你项目**：考虑六个变量（*l*，*e*，*m*，*o*，*n*，*s*）的向量。找到作用于该向量并产生向量（*s*，*o*，*l*，*e*，*m*，*n*）的线性变换的矩阵。**提示**：输出向量的第三个坐标等于输入向量的第一个坐标，因此变换必须将标准基向量（1,
    0, 0, 0, 0, 0）映射到（0, 0, 1, 0, 0, 0）。**解答**：![](../Images/CH05_F23_Orland_UN05_EQ47.png)这个矩阵以指定方式重新排列了6D向量的条目。|'
- en: '| **Exercise 5.25**: What valid products can be made from the matrices *M*,
    *N*, *P*, and *Q* from section 5.2.5? Include in your consideration the products
    of matrices with themselves. For those products that are valid, what are the dimensions
    of the matrix products?**Solution**: *M* is 3×3, *N* is 2×2, and *P* and *Q* are
    both 2×3\. The product of *M* with itself, *MM* = *M*² is valid and a 3×3 matrix,
    so is *NN* = *N*² which is a 2×2 matrix. Apart from that, *PM*, *QM*, *NP*, and
    *NQ* are all 3×2 matrices. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.25**：从5.2.5节中的矩阵 *M*，*N*，*P* 和 *Q* 中可以制作哪些有效的乘积？在考虑矩阵乘积时，包括矩阵与自身的乘积。对于有效的乘积，矩阵乘积的维度是什么？**解答**：*M*
    是 3×3，*N* 是 2×2，而 *P* 和 *Q* 都是 2×3。*M* 与自身的乘积 *MM* = *M*² 是有效的，是一个 3×3 矩阵，同样 *NN*
    = *N*² 也是一个 2×2 矩阵。除此之外，*PM*，*QM*，*NP* 和 *NQ* 都是 3×2 矩阵。|'
- en: 5.3 Translating vectors with matrices
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 使用矩阵转换向量
- en: One advantage of matrices is that computations look the same in any number of
    dimensions. We don’t need to worry about picturing the configurations of vectors
    in 2D or 3D; we can simply plug them into the formulas for matrix multiplication
    or use them as inputs to our Python `matrix_multiply`. This is especially useful
    when we want to do computations in more than three dimensions.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的一个优点是，在任意数量的维度中计算看起来都是一样的。我们不需要担心在2D或3D中想象向量的配置；我们只需将它们插入到矩阵乘法的公式中，或者将它们用作Python
    `matrix_multiply`的输入。当我们想要在超过三个维度中进行计算时，这特别有用。
- en: 'The human brain isn’t wired to picture vectors in four or five dimensions,
    let alone 100, but we already saw we can do computations with vectors in higher
    dimensions. In this section, we’ll cover a computation that *requires* doing computation
    in higher dimensions: translating vectors using a matrix.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 人类的大脑并没有被设计成想象四维或五维的向量，更不用说100维了，但我们已经看到我们可以在高维向量上进行计算。在本节中，我们将介绍一个*需要*在高维中进行计算的计算：使用矩阵进行向量的平移。
- en: 5.3.1 Making plane translations linear
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 使平面平移线性化
- en: In the last chapter, we showed that translations are not linear transformations.
    When we move every point in the plane by a given vector, the origin moves and
    vector sums are not preserved. How can we hope to execute a 2D transformation
    with a matrix if it is not a linear transformation?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们展示了平移不是线性变换。当我们将平面上的每个点移动一个给定的向量时，原点会移动，向量之和不会保持不变。如果它不是一个线性变换，我们怎么能希望用矩阵执行二维变换呢？
- en: 'The trick is that we can think of our 2D points to translate as living in 3D.
    Let’s return to our dinosaur from chapter 2\. The dinosaur was composed of 21
    points, and we could connect these in order to create the outline of the figure:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 小技巧在于我们可以将我们的二维点想象成生活在三维空间中。让我们回到第二章中的恐龙。这只恐龙由21个点组成，我们可以按顺序连接这些点来创建图形的轮廓：
- en: '[PRE25]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The result is the familiar 2D dinosaur (figure 5.24).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 结果就是熟悉的二维恐龙（图5.24）。
- en: '![](../Images/CH05_F24_Orland.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F24_Orland.png)'
- en: Figure 5.24 The familiar 2D dinosaur from chapter 2
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24 第二章中熟悉的二维恐龙
- en: If we want to translate the dinosaur to the right by 3 units and up by 1 unit,
    we could simply add the vector (3, 1) to each of the dinosaur’s vertices. But
    this isn’t a linear map, so we can’t produce a 2×2 matrix that does this translation.
    If we think of the dinosaur as an inhabitant of 3D space instead of the 2D plane,
    it turns out we *can* formulate the translation as a matrix.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将恐龙向右平移3个单位，向上平移1个单位，我们只需将向量（3, 1）加到恐龙的每个顶点上即可。但这不是一个线性映射，因此我们无法生成一个2×2的矩阵来完成这种平移。如果我们将恐龙想象成三维空间而不是二维平面的居民，那么我们发现*可以*将平移表示为一个矩阵。
- en: Bear with me for a moment while I show you the trick; I’ll explain how it works
    shortly. Let’s give every point of the dinosaur a z-coordinate of 1\. Then we
    can draw it in 3D by connecting each of the points with segments and see that
    the resulting polygon lies on the plane where *z* = 1 (figure 5.25). I’ve created
    a helper function called `polygon_segments_3d` to get the segments of the dinosaur
    polygon in 3D.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 请稍等，让我向你展示这个技巧；我很快就会解释它是如何工作的。让我们给恐龙的每个点赋予z坐标为1。然后我们可以通过连接每个点来在三维空间中绘制它，并看到结果的多边形位于*z*
    = 1的平面上（图5.25）。我创建了一个名为`polygon_segments_3d`的辅助函数，用于获取恐龙多边形在三维空间中的段。
- en: '[PRE26]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](../Images/CH05_F25_Orland.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F25_Orland.png)'
- en: Figure 5.25 The same dinosaur with each of its vertices given a z-coordinate
    of 1
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25 给恐龙的每个顶点赋予z坐标为1的相同恐龙
- en: Figure 5.26 shows a matrix that “skews” 3D space, so that the origin stays put,
    but the plane where *z* = 1 is translated as desired. Trust me for now! I’ve highlighted
    the numbers relating to the translation that you should pay attention to.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.26显示了一个“扭曲”三维空间的矩阵，使得原点保持不变，但*z* = 1的平面按所需平移。现在就相信我吧！我已经突出显示了与平移相关的数字，你应该注意这些。
- en: '![](../Images/CH05_F26_Orland.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F26_Orland.png)'
- en: Figure 5.26 A magic matrix that moves the plane z = 1 by +3 in the *x* direction
    and by +1 in the *y* direction
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.26 一个神奇的矩阵，将平面*z* = 1在*x*方向上移动+3，在*y*方向上移动+1
- en: We can apply this matrix to each vertex of the dinosaur and then voila! The
    dinosaur is translated by (3, 1) in its plane (figure 5.27).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个矩阵应用到恐龙的每个顶点上，然后 voila！恐龙在其平面内平移了（3, 1）（图5.27）。
- en: '![](../Images/CH05_F27_Orland.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F27_Orland.png)'
- en: Figure 5.27 Applying the matrix to every point keeps the dinosaur in the same
    plane, but translates it within the plane by (3, 1)..
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.27 将矩阵应用到每个点，使恐龙保持在同一平面内，但在平面内平移了（3, 1）。
- en: 'Here’s the code:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE27]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For clarity, we could then delete the z-coordinates again and show the translated
    dinosaur in the plane with the original one (figure 5.28).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们随后可以再次删除z坐标，并显示与原始恐龙在同一平面上的平移后的恐龙（图5.28）。
- en: '![](../Images/CH05_F28_Orland.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F28_Orland.png)'
- en: Figure 5.28 Dropping the translated dinosaur back into 2D
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.28 将平移后的恐龙放回二维空间
- en: You can reproduce the code and check the coordinates to see that the dinosaur
    was indeed translated by (3, 1) in the final picture. Now let me show you how
    the trick works.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以复制代码并检查坐标，以确认恐龙在最终图片中确实平移了 (3, 1)。现在让我向你展示这个技巧是如何工作的。
- en: 5.3.2 Finding a 3D matrix for a 2D translation
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 为 2D 平移找到一个 3D 矩阵
- en: The columns of our “magic” matrix, like the columns of any matrix, tell us where
    the standard basis vectors end up after being transformed. Calling this matrix
    *T*, the vectors ***e***[1], ***e***[2], and ***e***[3] would be transformed into
    the vectors *T* ***e***[1] = (1, 0, 0), *T* ***e***[2] = (0, 1, 0), and *T* ***e***[3]
    = (3, 1, 1). This means ***e***[1] and ***e***[2] are unaffected, and ***e***[3]
    changes only its *x* − and *y* -components (figure 5.29).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们“神奇”矩阵的列，就像任何矩阵的列一样，告诉我们标准基向量在变换后最终的位置。将这个矩阵称为 *T*，向量 ***e***[1]、***e***[2]
    和 ***e***[3] 将被变换为向量 *T* ***e***[1] = (1, 0, 0)，*T* ***e***[2] = (0, 1, 0)，和 *T*
    ***e***[3] = (3, 1, 1)。这意味着 ***e***[1] 和 ***e***[2] 没有受到影响，而 ***e***[3] 只改变了它的
    *x* 和 *y* 分量（图 5.29）。
- en: '![](../Images/CH05_F29_Orland.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F29_Orland.png)'
- en: Figure 5.29 This matrix doesn’t move e1 or e2, but it does move e3.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.29 这个矩阵不会移动 e1 或 e2，但它确实会移动 e3。
- en: 'Any point in 3D and, therefore, any point on our dinosaur is built as a linear
    combination of ***e***[1], ***e***[2], and ***e***[3]. For instance, the tip of
    the dinosaur’s tail is at (6, 4, 1), which is 6***e***[1] + 4***e***[2] + ***e***[3].
    Because *T* doesn’t move ***e***[1] or ***e***[2], only the effect on ***e***[3]
    moves the point, *T*(***e***[3]) = ***e***[3] + (3, 1, 0), so that the point is
    translated by +3 in the *x* direction and +1 in the *y* direction. You can also
    see this algebraically. Any vector (*x*, *y*, 1) is translated by (3, 1, 0) by
    this matrix:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 中的任何一点，因此，我们恐龙上的任何一点都是作为 ***e***[1]、***e***[2] 和 ***e***[3] 的线性组合构建的。例如，恐龙尾巴的尖端位于
    (6, 4, 1)，即 6***e***[1] + 4***e***[2] + ***e***[3]。因为 *T* 不会移动 ***e***[1] 或 ***e***[2]，只有对
    ***e***[3] 的影响会移动点，*T*(***e***[3]) = ***e***[3] + (3, 1, 0)，所以点在 *x* 方向上平移了 +3，在
    *y* 方向上平移了 +1。你也可以从代数上看到这一点。任何向量 (*x*, *y*, 1) 都可以通过这个矩阵平移 (3, 1, 0)：
- en: '![](../Images/CH05_F29_Orland_EQ48.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F29_Orland_EQ48.png)'
- en: 'If you want to translate a collection of 2D vectors by some vector (*a*, *b*),
    the general steps are as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想通过某个向量 (*a*, *b*) 平移一组 2D 向量，一般步骤如下：
- en: Move the 2D vectors into the plane in 3D space, where *z* = 1 and each has a
    z-coordinate of 1.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 2D 向量移动到 3D 空间中的平面，其中 *z* = 1，每个向量都有一个 z 坐标为 1。
- en: 'Multiply the vectors by the matrix with your given choices of *a* and *b* plugged
    in:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将向量乘以矩阵，并插入你给定的 *a* 和 *b* 选择：
- en: '![](../Images/CH05_F29_Orland_EQ49.png)'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/CH05_F29_Orland_EQ49.png)'
- en: Delete the z-coordinate of all of the vectors so you are left with 2D vectors
    as a result.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有向量的 z 坐标，这样你最终会得到 2D 向量。
- en: Now that we can do translations with matrices, we can creatively combine them
    with other linear transformations.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用矩阵进行平移，我们可以创造性地将它们与其他线性变换结合。
- en: 5.3.3 Combining translation with other linear transformations
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 将平移与其他线性变换结合
- en: In the previous matrix, the first two columns are exactly ***e***[1] and ***e***[2],
    meaning that only the change in ***e***[3] moves a figure. We don’t want *T*(***e***[1])
    or *T*(***e***[2]) to have any z-component because that would move the figure
    out of the plane *z* = 1\. But we can modify or interchange the other components
    (figure 5.30).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的矩阵中，前两列正好是 ***e***[1] 和 ***e***[2]，这意味着只有 ***e***[3] 的变化会移动图形。我们不希望 *T*(***e***[1])
    或 *T*(***e***[2]) 有任何 z 分量，因为这会将图形移出平面 *z* = 1。但我们可以修改或交换其他分量（图 5.30）。
- en: '![](../Images/CH05_F30_Orland.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F30_Orland.png)'
- en: Figure 5.30 Let’s see what happens when we move T(e1) and T(e2) in the x,y plane.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.30 让我们看看当我们移动 T(e1) 和 T(e2) 到 x,y 平面时会发生什么。
- en: It turns out you can put any 2×2 matrix in the top left (as shown by figure
    5.30) by doing the corresponding linear transformation *in addition* to the translation
    specified in the third column. For instance, this matrix
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，你可以通过在第三列指定的平移之外进行相应的线性变换，将任何 2×2 矩阵放入左上角（如图 5.30 所示）。例如，这个矩阵
- en: '![](../Images/CH05_F30_Orland_EQ50.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F30_Orland_EQ50.png)'
- en: produces a 90° counterclockwise rotation. Inserting it in the translation matrix,
    we get a new matrix that rotates the *x*,*y* plane by 90° and then translates
    it by (3, 1) as shown in figure 5.31.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 产生一个 90° 逆时针旋转。将其插入平移矩阵中，我们得到一个新的矩阵，它将 *x*，*y* 平面旋转 90°，然后按图 5.31 所示平移 (3, 1)。
- en: '![](../Images/CH05_F31_Orland.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F31_Orland.png)'
- en: Figure 5.31 A matrix that rotates e1 and e3 by 90° and translates e3 by (3,
    1). Any figure in the plane where z = 1 experiences both transformations.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.31 一个矩阵，将e1和e3旋转90°，并将e3平移到(3, 1)。任何在z = 1的平面上的图形都会经历这两种变换。
- en: 'To show this works, we can carry out this transformation on all of the 3D dinosaur
    vertices in Python. Figure 5.32 shows the output of the following code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这是可行的，我们可以在Python中对所有3D恐龙顶点执行这种转换。图5.32显示了以下代码的输出：
- en: '[PRE28]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![](../Images/CH05_F32b_Orland.png)![](../Images/CH05_F32a_Orland.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F32b_Orland.png)![](../Images/CH05_F32a_Orland.png)'
- en: Figure 5.32 The original dinosaur (left) and a second dinosaur (right) that
    is both rotated and translated by a single matrix
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.32 原始恐龙（左）和第二个恐龙（右），它们都通过一个单一的矩阵进行了旋转和平移
- en: Once you get the hang of doing 2D translations with a matrix, you can apply
    the same approach to doing a 3D translation. To do that, you’ll have to use a
    4×4 matrix and enter the mysterious world of 4D.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了使用矩阵进行2D平移的方法，你就可以将相同的方法应用于3D平移。要做到这一点，你将不得不使用4×4矩阵并进入神秘的4D世界。
- en: 5.3.4 Translating 3D objects in a 4D world
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.4 在四维世界中转换3D对象
- en: What is the fourth dimension? A 4D vector would be an arrow with some length,
    width, depth, and one other dimension. When we built 3D space from 2D space, we
    added a z-coordinate. That means that 3D vectors can live in the *x*,*y* plane,
    where *z* = 0, or they can live in any other parallel plane, where *z* takes a
    different value. Figure 5.33 shows some of these parallel planes.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 第四维度是什么？一个4D向量将是一个具有某些长度、宽度、深度和另一个维度的箭头。当我们从2D空间构建3D空间时，我们添加了一个z坐标。这意味着3D向量可以生活在*x*，*y*平面，其中*z*
    = 0，或者它们可以生活在任何其他平行平面中，其中*z*具有不同的值。图5.33显示了这些平行平面中的几个。
- en: '![](../Images/CH05_F33_Orland.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F33_Orland.png)'
- en: Figure 5.33 Building 3D space out of a stack of parallel planes, each looking
    like the x,y plane but at different z-coordinates
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.33 通过堆叠平行平面构建3D空间，每个平面看起来像x,y平面，但在不同的z坐标上
- en: 'We can think of four dimensions in analogy to this model: a collection of 3D
    spaces that are indexed by some fourth coordinate. One way to interpret the fourth
    coordinate is “time.” Each snapshot at a given time is a 3D space, but the collection
    of all of the snapshots is a fourth dimension called a *spacetime* . The origin
    of the spacetime is the origin of the space at the moment when time, *t*, is equal
    to 0 (figure 5.34).'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将四个维度类比为这个模型：一组由某个第四个坐标索引的3D空间。解释第四个坐标的一种方式是“时间”。在给定时间的一个快照是一个3D空间，但所有快照的集合是一个称为*时空*的第四维度。时空的起点是当时间*t*等于0时空间的原点（图5.34）。
- en: '![](../Images/CH05_F34_Orland.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F34_Orland.png)'
- en: Figure 5.34 An illustration of 4D spacetime, similar to how a slice of 3D space
    at a given z value is a 2D plane and a slice of 4D spacetime at a given t value
    is a 3D space
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.34 4D时空的示意图，类似于在给定的z值处3D空间的切片是一个二维平面，在给定的t值处4D时空的切片是一个三维空间
- en: This is the starting point for Einstein’s theory of relativity. (In fact, you
    are now qualified to go read about this theory because it is based on 4D spacetime
    and linear transformations given by 4×4 matrices.)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这是爱因斯坦相对论理论的起点。（事实上，你现在有资格去阅读有关这个理论的内容，因为它基于4D时空和由4×4矩阵给出的线性变换。）
- en: Vector math is indispensable in higher dimensions because we quickly run out
    of good analogies. For five, six, seven, or more dimensions, I have a hard time
    picturing them, but the coordinate math is no harder than in two or three dimensions.
    For our current purposes, it’s sufficient to think of a 4D vector as a four-tuple
    of numbers.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 向量数学在更高维度中是必不可少的，因为我们很快就会用尽好的类比。对于五维、六维、七维或更多维度，我很难想象它们，但坐标数学并不比二维或三维更难。对于我们当前的目的，我们可以将四维向量视为一个由四个数字组成的四元组。
- en: Let’s replicate the trick that worked for translating 2D vectors in 3D. If we
    start with a 3D vector like (*x*, *y*, *z*) and we want to translate it by a vector
    (*a*, *b*, *c*), we can attach a fourth coordinate of 1 to the target vector and
    use an analogous 4D matrix to do the translation. Doing the matrix multiplication
    confirms that we get the desired result (figure 5.35).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们复制适用于在3D中转换2D向量的技巧。如果我们从一个3D向量(*x*，*y*，*z*)开始，并且我们想要通过向量(*a*，*b*，*c*)进行平移，我们可以在目标向量上附加一个第四个坐标1，并使用类似的4D矩阵进行平移。进行矩阵乘法确认我们得到了期望的结果（图5.35）。
- en: '![](../Images/CH05_F35_Orland.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F35_Orland.png)'
- en: Figure 5.35 Giving the vector (*x*, *y*, *z*) a fourth coordinate of 1, we can
    translate the vector by (*a*, *b*, *c*) using this matrix.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.35 给向量 (*x*, *y*, *z*) 添加一个第四个坐标 1，我们可以使用这个矩阵通过 (*a*, *b*, *c*) 来平移向量。
- en: 'This matrix increases the *x*-coordinate by *a*, the *y*-coordinate by *b*,
    and the z-coordinate by *c*, so it does the transformation required to translate
    by the vector (*a*, *b*, *c*). We can package in a Python function the work of
    adding a fourth coordinate, applying this 4×4 matrix, and then deleting the fourth
    coordinate:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩阵将 *x* 坐标增加 *a*，*y* 坐标增加 *b*，*z* 坐标增加 *c*，因此它执行了通过向量 (*a*, *b*, *c*) 所需的变换。我们可以将添加第四个坐标、应用这个
    4×4 矩阵以及然后删除第四个坐标的工作封装在一个 Python 函数中：
- en: '[PRE29]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ The translate_3d function takes a translation vector and returns a new function
    that applies that translation to a 3D vector.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ translate_3d 函数接受一个平移向量，并返回一个新的函数，该函数将平移应用于 3D 向量。
- en: ❷ Builds the 4×4 matrix for the translation, and on the next line, turns (*x*,
    *y*, *z*) into a 4D vector with a fourth coordinate 1
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 构建平移的 4×4 矩阵，并在下一行，将 (*x*, *y*, *z*) 转换为具有第四个坐标 1 的 4D 向量
- en: ❸ Does the 4D matrix transformation
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 执行 4D 矩阵变换
- en: Finally, drawing the teapot as well as the teapot translated by (2, 2, −3),
    we can see that the teapot moves appropriately. You can confirm this by running
    matrix_translate _teapot.py. You should see the same image as in figure 5.36.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，绘制茶壶以及通过 (2, 2, −3) 平移的茶壶，我们可以看到茶壶适当地移动了。你可以通过运行 matrix_translate_teapot.py
    来确认这一点。你应该看到与图 5.36 中相同的图像。
- en: '![](../Images/CH05_F36b_Orland.png)![](../Images/CH05_F36a_Orland.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F36b_Orland.png)![](../Images/CH05_F36a_Orland.png)'
- en: Figure 5.36 The untranslated teapot (left) and a translated teapot (right).
    As expected, the translated teapot moves up and to the right, and away from our
    viewpoint.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.36 未翻译的茶壶（左）和已翻译的茶壶（右）。正如预期的那样，已翻译的茶壶向上和向右移动，并远离我们的视角。
- en: With translation packaged as a matrix operation, we can now combine that operation
    with other 3D linear transformations and do them in one step. It turns out you
    *can* interpret the artificial fourth-coordinate in this setup as time, *t*.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 将平移封装为矩阵运算后，我们现在可以将该操作与其他 3D 线性变换结合，并一次性完成。结果证明，你 *可以* 将这个设置中的虚拟第四个坐标解释为时间，*t*。
- en: The two images in figure 5.36 could be snapshots of a teapot at *t* = 0 and
    *t* = 1, which is moving in the direction (2, 2, −3) at a constant speed. If you’re
    looking for a fun challenge, you can replace the vector (*x*, *y*, *z*, 1) in
    this implementation with vectors of the form (*x*, *y*, *z*, *t*), where the coordinate
    *t* changes over time. With *t* = 0 and *t* = 1, the teapot should match the frames
    in figure 5.36, and at the time between the two, it should move smoothly between
    the two positions. If you can figure out how this works, you’ll catch up with
    Einstein!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.36 中的两个图像可能是 *t* = 0 和 *t* = 1 时茶壶的快照，它以恒定速度沿 (2, 2, −3) 方向移动。如果你在寻找一个有趣的挑战，你可以将此实现中的向量
    (*x*, *y*, *z*, 1) 替换为形式为 (*x*, *y*, *z*, *t*) 的向量，其中坐标 *t* 随时间变化。当 *t* = 0 和
    *t* = 1 时，茶壶应该与图 5.36 中的帧相匹配，而在两个时间之间，它应该在两个位置之间平滑移动。如果你能弄清楚这是如何工作的，你将赶上爱因斯坦！
- en: So far, we’ve focused exclusively on vectors as points in space that we can
    render to a computer screen. This is clearly an important use case, but it only
    scratches the surface of what we can do with vectors and matrices. The study of
    how vectors and linear transformations work together in general is called *linear
    algebra* , and I’ll give you a broader picture of this subject in the next chapter,
    along with some fresh examples that are relevant to programmers.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于将向量作为空间中的点渲染到计算机屏幕上。这显然是一个重要的用例，但它只是触及了我们可以用向量和矩阵做什么的表面。研究向量和线性变换如何在一般情况下一同工作的研究被称为
    *线性代数*，我将在下一章中给你一个更广泛的这个主题的图景，以及一些与程序员相关的全新示例。
- en: 5.3.5 Exercises
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.5 练习
- en: '| **Exercise 5.26**: Show that the 3D “magic” matrix transformation does not
    work if you move a 2D figure such as the dinosaur we have been using to the plane
    *z* = 2\. What happens instead?**Solution**: Using `[(x,y,2) for x,y in dino_vectors]`
    and applying the same 3×3 matrix, the dinosaur is translated twice as far by the
    vector (6, 2) instead of (3, 1). This is because the vector (0, 0, 1) is translated
    by (3, 1), and the transformation is linear.![](../Images/CH05_F36b_Orland_UN06.png)A
    dinosaur in the plane where z = 2 is translated twice as far by the same matrix.
    |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.26**：证明如果你将我们一直在使用的恐龙这样的 2D 图形移动到 *z* = 2 的平面上，3D 的“魔法”矩阵变换将不起作用。会发生什么？**解答**：使用
    `[(x,y,2) for x,y in dino_vectors]` 并应用相同的 3×3 矩阵，恐龙被向量 (6, 2) 平移了两次，而不是 (3, 1)。这是因为向量
    (0, 0, 1) 被平移了 (3, 1)，变换是线性的。![](../Images/CH05_F36b_Orland_UN06.png)在 z = 2 的平面上，恐龙被相同的矩阵平移了更远的距离。
    |'
- en: '| **Exercise 5.27**: Come up with a matrix to translate the dinosaur by −2
    units in the *x* direction and −2 units in the *y* direction. Execute the transformation
    and show the result.**Solution**: Replacing the values 3 and 1 in the original
    matrix with −2 and −2, we get![](../Images/CH05_F36b_Orland_UN06_EQ51b.png)The
    dinosaur, indeed, translates down and to the left by the vector (−2, −2).![](../Images/CH05_F36b_Orland_UN07.png)
    |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.27**：想出一个矩阵，将恐龙在 *x* 方向上平移 -2 个单位，在 *y* 方向上平移 -2 个单位。执行变换并展示结果。**解答**：将原始矩阵中的值
    3 和 1 替换为 -2 和 -2，我们得到！[](../Images/CH05_F36b_Orland_UN06_EQ51b.png)恐龙确实沿着向量 (−2,
    −2) 向下和向左平移了。![](../Images/CH05_F36b_Orland_UN07.png) |'
- en: '| **Exercise 5.28**: Show that any matrix of the form![](../Images/CH05_F36b_Orland_UN07_EQ52.png)doesn’t
    affect the z-coordinate of a 3D column vector it is multiplied by.**Solution**:
    If the initial z-coordinate of a 3D vector is a number *z*, this matrix leaves
    that coordinate unchanged:![](../Images/CH05_F36b_Orland_UN07_EQ53.png) |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.28**：证明任何形式为！[](../Images/CH05_F36b_Orland_UN07_EQ52.png)的矩阵都不会影响它乘以的
    3D 列向量的 z 坐标。**解答**：如果 3D 向量的初始 z 坐标是一个数字 *z*，这个矩阵不会改变该坐标：![](../Images/CH05_F36b_Orland_UN07_EQ53.png)
    |'
- en: '| **Exercise 5.29−Mini Project**: Find a 3×3 matrix that rotates a 2D figure
    in the plane *z* = 1 by 45°, decreases its size by a factor of 2, and translates
    it by the vector (2, 2). Demonstrate that it works by applying it to the vertices
    of the dinosaur.**Solution**: First, let’s find a 2×2 matrix for rotating a 2D
    vector by 45°:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 5.29-迷你项目**：找到一个 3×3 矩阵，它能在 *z* = 1 的平面上将 2D 图形旋转 45°，将其大小缩小到原来的 1/2，并通过向量
    (2, 2) 进行平移。通过将其应用于恐龙的顶点来证明它的工作原理。**解答**：首先，让我们找到一个用于将 2D 向量旋转 45° 的 2×2 矩阵：'
- en: '[PRE30]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '❶ Builds a function that executes rotate2d with an angle of 45° (or with 4
    radians) for an input 2D vectorThis matrix is approximately:![](../Images/CH05_F36b_Orland_UN07_EQ54.png)Similarly,
    we can find a matrix to scale by a factor of ½:![](../Images/CH05_F36b_Orland_UN07_EQ55.png)Multiplying
    these matrices together, we accomplish both transformations at once with this
    code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 编写一个函数，该函数使用 45°（或 4 弧度）的角度执行 rotate2d，对于输入的 2D 向量This matrix is approximately:![](../Images/CH05_F36b_Orland_UN07_EQ54.png)同样，我们可以找到一个缩放因子为
    ½ 的矩阵：![](../Images/CH05_F36b_Orland_UN07_EQ55.png)将这些矩阵相乘，我们一次使用这段代码就完成了两种变换：
- en: '[PRE31]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And this is a 3×3 matrix that translates the dinosaur by (2, 2) in the plane
    where *z* = 1:![](../Images/CH05_F36b_Orland_UN07_EQ56.png)We can plug our 2×2
    rotation and scaling matrix into the top left of this matrix, giving us the final
    matrix that we want:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 3×3 矩阵，它将恐龙在 *z* = 1 的平面上平移 (2, 2)：![](../Images/CH05_F36b_Orland_UN07_EQ56.png)我们可以将我们的
    2×2 旋转和缩放矩阵插入到这个矩阵的左上角，得到我们想要的最终矩阵：
- en: '[PRE32]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Moving the dinosaur to the plane *z* = 1, applying this matrix in 3D, and then
    projecting back to 2D gives us the rotated, scaled, and translated dinosaur, using
    only one matrix multiplication as shown here:![](../Images/CH05_F36b_Orland_UN08.png)
    |
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 将恐龙移动到平面 *z* = 1，应用这个矩阵进行 3D 变换，然后将其投影回 2D，我们得到了旋转、缩放和平移后的恐龙，这里只使用了一次矩阵乘法，如图所示：![](../Images/CH05_F36b_Orland_UN08.png)
    |
- en: '| **Exercise 5.30**: The matrix in the preceding exercise rotates the dinosaur
    by 45° and then translates it by (3, 1). Using matrix multiplication, build a
    matrix that does this in the opposite order.**Solution**: If the dinosaur is in
    the plane where *z* = 1, then the following matrix does a rotation by 90° with
    *no* translation:![](../Images/CH05_F36b_Orland_UN08_EQ57.png)We want to translate
    first and then rotate, so we multiply this rotation matrix by the translation
    matrix:![](../Images/CH05_F36b_Orland_UN08_EQ58.png)This is different from the
    other matrix, which rotates before the translation. In this case, we see that
    the translation vector (3, 1) is affected by the 90° rotation. The new effective
    translation is (−1, 3). |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| **练习 5.30**: 在前面的练习中，矩阵将恐龙旋转了 45°，然后通过 (3, 1) 进行平移。使用矩阵乘法，构建一个以相反顺序执行此操作的矩阵。**解答**：如果恐龙位于
    *z* = 1 的平面上，则以下矩阵执行 90° 旋转且没有平移：![](../Images/CH05_F36b_Orland_UN08_EQ57.png)我们想要先平移再旋转，因此我们将这个旋转矩阵与平移矩阵相乘：![](../Images/CH05_F36b_Orland_UN08_EQ58.png)这与另一个矩阵不同，它先旋转再平移。在这种情况下，我们看到平移向量
    (3, 1) 受到 90° 旋转的影响。新的有效平移是 (−1, 3)。|'
- en: '| **Exercise 5.31**: Write a function analogous to `translate_3d` called `translate_4d`
    that uses a 5×5 matrix to translate a 4D vector by another 4D vector. Run an example
    to show that the coordinates are translated.**Solution**: The setup is the same,
    except that we lift the 4D vector to 5D by giving it a fifth coordinate of 1:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 5.31**: 编写一个类似于 `translate_3d` 的函数，称为 `translate_4d`，它使用一个 5×5 矩阵通过另一个
    4D 向量来平移一个 4D 向量。运行一个示例以显示坐标已平移。**解答**：设置与之前相同，只是我们将 4D 向量提升到 5D，给它一个第五个坐标为 1：'
- en: '[PRE33]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can see that the translation works (the effect is the same as adding the
    two vectors):'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到平移是有效的（效果与添加两个向量相同）：
- en: '[PRE34]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'In the previous chapters, we used visual examples in 2D and 3D to motivate
    vector and matrix arithmetic. As we’ve gone along, we’ve put more emphasis on
    computation. At the end of this chapter, we calculated vector transformations
    in higher dimensions where we didn’t have any physical insight. This is one of
    the benefits of linear algebra: it gives you the tools to solve geometric problems
    that are too complicated to picture. We’ll survey the broad range of this application
    in the next chapter.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用 2D 和 3D 的视觉示例来激发向量和矩阵算术。随着我们的进行，我们更多地强调了计算。在本章的末尾，我们在没有物理洞察力的情况下计算了高维向量变换。这是线性代数的一个好处：它为你提供了解决过于复杂而无法想象的几何问题的工具。我们将在下一章中概述这一广泛的应用范围。
- en: Summary
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: A linear transformation is defined by what it does to standard basis vectors.
    When you apply a linear transformation to the standard basis, the resulting vectors
    contain all the data required to do the transformation. This means that only nine
    numbers are required to specify a 3D linear transformation of any kind (the three
    coordinates of each of these three resulting vectors). For a 2D linear transformation,
    four numbers are required.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性变换由其对标准基向量的作用来定义。当你将线性变换应用于标准基时，结果向量包含执行变换所需的所有数据。这意味着指定任何类型的 3D 线性变换只需要九个数字（这三个结果向量的三个坐标）。对于
    2D 线性变换，需要四个数字。
- en: In matrix notation, we represent a linear transformation by putting these numbers
    in a rectangular grid. By convention, you build a matrix by applying a transformation
    to the standard basis vectors and putting the resulting coordinate vectors side
    by side as columns.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在矩阵表示法中，我们通过将这些数字放入矩形网格中来表示线性变换。按照惯例，你通过将变换应用于标准基向量并将结果坐标向量并排放置作为列来构建矩阵。
- en: Using a matrix to evaluate the result of the linear transformation it represents
    on a given vector is called *multiplying the matrix by the vector*. When you do
    this multiplication, the vector is typically written as a column of its coordinates
    from top to bottom rather than as a tuple.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用矩阵来评估它对给定向量所表示的线性变换的结果称为 *矩阵乘以向量*。当你进行这种乘法时，向量通常按从上到下的顺序写成其坐标的列，而不是作为元组。
- en: Two square matrices can also be multiplied together. The resulting matrix represents
    the composition of the linear transformations of the original two matrices.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个方阵也可以相乘。结果矩阵表示原始两个矩阵的线性变换的合成。
- en: To calculate the product of two matrices, you take the dot products of the rows
    of the first with the columns of the second. For instance, the dot product of
    row *i* of the first matrix and column *j* of the second matrix gives you the
    value in row *i* and column *j* of the product.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要计算两个矩阵的乘积，你需要计算第一个矩阵的行与第二个矩阵的列的点积。例如，第一个矩阵的第 *i* 行与第二个矩阵的第 *j* 列的点积给出了乘积矩阵的第
    *i* 行和第 *j* 列的值。
- en: As square matrices represent linear transformations, non-square matrices represent
    linear functions from vectors of one dimension to vectors of another dimension.
    That is, these functions send vector sums to vector sums and scalar multiples
    to scalar multiples.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于方阵代表线性变换，非方阵代表从一维向量到另一维向量的线性函数。也就是说，这些函数将向量加和映射到向量加和，将标量乘积映射到标量乘积。
- en: The dimension of a matrix tells you what kind of vectors its corresponding linear
    function accepts and returns. A matrix with *m* rows and *n* columns is called
    an *m* -by- *n* matrix (sometimes written *m* × *n*). It defines a linear function
    from *n* -dimensional space to *m* -dimensional space.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的维度告诉你其对应的线性函数接受和返回什么类型的向量。一个有 *m* 行和 *n* 列的矩阵被称为 *m* -by- *n* 矩阵（有时写作 *m*
    × *n*）。它定义了一个从 *n* 维空间到 *m* 维空间的线性函数。
- en: Translation is *not* a linear function, but it can be made linear if you perform
    it in a higher dimension. This observation allows us to do translations (simultaneously
    with other linear transformations) by matrix multiplication.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 翻译**不是**一个线性函数，但如果在更高维度下进行，它可以被转化为线性。这个观察结果使我们能够通过矩阵乘法来进行翻译（同时与其他线性变换一起进行）。
