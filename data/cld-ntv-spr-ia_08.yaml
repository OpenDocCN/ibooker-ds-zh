- en: 6 Containerizing Spring Boot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 容器化 Spring Boot
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Working with container images on Docker
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Docker 上使用容器镜像
- en: Packaging Spring Boot applications as container images
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Spring Boot 应用程序打包为容器镜像
- en: Managing Spring Boot containers with Docker Compose
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 管理Spring Boot 容器
- en: Automating image build and push with GitHub Actions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 自动构建和推送镜像
- en: So far, we have developed a Catalog Service application that exposes a REST
    API and persists data through a PostgreSQL database running inside a container.
    We’re getting closer to deploying the first components of the Polar Bookshop system
    to a Kubernetes cluster. Before doing that, however, you need to learn how to
    package Spring Boot applications as container images and manage their life cycles.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经开发了一个 Catalog Service 应用程序，该应用程序公开 REST API 并通过运行在容器内的 PostgreSQL
    数据库持久化数据。我们正越来越接近将 Polar Bookshop 系统的第一个组件部署到 Kubernetes 集群。然而，在这样做之前，你需要学习如何将
    Spring Boot 应用程序打包为容器镜像并管理其生命周期。
- en: This chapter will teach you the essential characteristics of container images
    and how to build one. We’ll use Docker to work with containers, but you can do
    the same with any other container runtime compatible with the Open Container Initiative
    (OCI) standards ([https://opencontainers.org](https://opencontainers.org)). In
    the remainder of the book, whenever I refer to a *container image* or *Docker
    image*, I mean an image compatible with the OCI Image Specification.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你容器镜像的基本特性和如何构建一个。我们将使用 Docker 来处理容器，但你也可以使用任何其他与 Open Container Initiative
    (OCI) 标准兼容的容器运行时（[https://opencontainers.org](https://opencontainers.org)）。在本书的剩余部分，每当我提到
    *容器镜像* 或 *Docker 镜像* 时，我指的是与 OCI 镜像规范兼容的镜像。
- en: 'Along the way, I’ll share with you several considerations regarding building
    container images for production, such as security and performance. We’ll explore
    two possibilities: Dockerfiles and Cloud Native Buildpacks.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我会与你分享关于为生产构建容器镜像的几个考虑因素，例如安全和性能。我们将探讨两种可能性：Dockerfile 和云原生构建包。
- en: When we start working with more than one container, the Docker CLI is not very
    efficient. Instead, we’ll use Docker Compose to manage several containers and
    their life cycles.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始处理多个容器时，Docker CLI 并不高效。相反，我们将使用 Docker Compose 来管理多个容器及其生命周期。
- en: Finally, we’ll continue work on the deployment pipeline we started in chapter
    3\. I’ll show you how to add new steps to the commit stage for packaging and publishing
    container images automatically to GitHub Container Registry.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将继续在第 3 章中开始的工作，部署管道。我会向你展示如何为打包和自动发布容器镜像到 GitHub 容器注册库添加新的提交阶段步骤。
- en: Note The source code for the examples in this chapter is available in the Chapter06/06-begin
    and Chapter06/06-end folders, which contain the initial and final states of the
    project ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章示例的源代码可在 Chapter06/06-begin 和 Chapter06/06-end 文件夹中找到，这些文件夹包含项目的初始状态和最终状态（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)）。
- en: 6.1 Working with container images on Docker
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 在 Docker 上使用容器镜像
- en: In chapter 2, I introduced the main components of the Docker platform. The Docker
    Engine has a client/server architecture. The Docker CLI is the client you use
    to interact with the Docker server. The latter is responsible for managing all
    Docker resources (for example, images, containers, and networks) through the Docker
    daemon. The server can also interact with container registries to upload and download
    images. For your convenience, figure 6.1 shows the interaction flow among those
    components again.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章中，我介绍了 Docker 平台的主要组件。Docker 引擎具有客户端/服务器架构。Docker CLI 是你用来与 Docker 服务器交互的客户端。后者负责通过
    Docker 守护进程管理所有 Docker 资源（例如，镜像、容器和网络）。服务器还可以与容器注册库交互以上传和下载镜像。为了方便起见，图 6.1 再次显示了这些组件之间的交互流程。
- en: '![06-01](../Images/06-01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![06-01](../Images/06-01.png)'
- en: Figure 6.1 The Docker Engine has a client/server architecture and interacts
    with a container registry.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 Docker 引擎具有客户端/服务器架构，并与容器注册库进行交互。
- en: This section will continue from where we left off in chapter 2 and elaborate
    more on container images, which are lightweight executable packages that include
    everything needed to run the application that’s inside. You’ll learn the main
    characteristics of a container image, how to create one, and finally how to publish
    it to a container registry. Before moving on, make sure the Docker Engine on your
    computer is up and running by executing the docker version command from a Terminal
    window.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将从我们在第2章结束的地方继续，并进一步阐述容器镜像，这些镜像是有轻量级可执行包，包括运行内部应用程序所需的一切。您将学习容器镜像的主要特征，如何创建一个，以及最后如何将其发布到容器注册库。在继续之前，请确保通过在终端窗口中执行docker
    version命令来确认您计算机上的Docker引擎正在运行。
- en: 6.1.1 Understanding container images
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 理解容器镜像
- en: Container images are the product of executing an ordered sequence of instructions,
    each resulting in a *layer*. Each image is made up of several layers, and each
    layer represents a modification produced by the corresponding instruction. The
    final artifact, an image, can be run as a container.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像是通过执行一系列有序指令产生的，每个指令都产生一个*层*。每个镜像由多个层组成，每个层代表由相应指令产生的修改。最终的产物，即镜像，可以作为容器运行。
- en: 'Images can be created from scratch or starting from a base image. The latter
    is the most common approach. For example, you can start from an Ubuntu image and
    apply a series of modifications on top of it. The sequence of instructions would
    be as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像可以从头创建，或者从一个基础镜像开始。后者是最常见的方法。例如，您可以从Ubuntu镜像开始，并在其上应用一系列修改。指令的顺序如下：
- en: Use Ubuntu as the base image.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Ubuntu作为基础镜像。
- en: Install the Java Runtime Environment.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Java运行时环境。
- en: Run the java --version command.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行java --version命令。
- en: Each of these instructions will generate a layer, producing the final container
    image shown in figure 6.2.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令中的每一个都会生成一个层，产生图6.2中显示的最终容器镜像。
- en: '![06-02](../Images/06-02.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![06-02](../Images/06-02.png)'
- en: Figure 6.2 Container images are composed of an ordered sequence of read-only
    layers. The first one represents the base image; the others represent modifications
    applied on top of it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 容器镜像由一系列只读层组成。第一个代表基础镜像；其余的表示在其之上应用的修改。
- en: 'All layers in a container image are read-only. Once they are applied, you can’t
    modify them anymore. If you need to change something, you can do so by applying
    a new layer on top of it (by executing a new instruction). Changes applied to
    the upper layers will not affect the lower ones. This approach is called *copy-on-write*:
    a copy of the original item is created in the upper layer, and changes are applied
    to the copy rather than to the original item.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像中的所有层都是只读的。一旦它们被应用，您就不能再修改它们了。如果您需要更改某些内容，您可以通过在其上应用一个新的层来做到这一点（通过执行一个新的指令）。应用在上层的变化不会影响下层。这种方法被称为*写时复制*：在顶层创建原始项目的副本，并将更改应用于副本而不是原始项目。
- en: 'When an image is *run* as a container, one last layer is automatically applied
    on top of all the existing ones: the *container layer*. It is the only writable
    layer, and it’s used to store data created during the execution of the container
    itself. At runtime, this layer might be used to generate files required by the
    application to run or maybe to store temporary data. Even though it’s writable,
    remember that it’s volatile: once you delete your container, everything stored
    in that layer is gone. Figure 6.3 compares the layers in a running container and
    those in the corresponding image.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当镜像作为容器运行时，会在所有现有层之上自动应用一个最后的层：*容器层*。这是唯一的可写层，它用于存储容器自身执行过程中创建的数据。在运行时，此层可能用于生成应用程序运行所需的文件，或者用于存储临时数据。尽管它是可写的，但请记住它是易变的：一旦您删除容器，该层中存储的所有内容都将消失。图6.3比较了运行中的容器和相应镜像中的层。
- en: '![06-03](../Images/06-03.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![06-03](../Images/06-03.png)'
- en: Figure 6.3 Running containers have an extra layer on top of the image layers.
    That is the only writable layer, but remember that it’s volatile.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 运行的容器在其镜像层之上有一个额外的层。这是唯一的可写层，但请记住它是易变的。
- en: Note The fact that all the layers in a container image are read-only has some
    security implications. You should never store secrets or sensitive information
    in the lower layers because they will always be accessible, even if the upper
    layers delete them. For example, you shouldn’t package passwords or encryption
    keys within a container image.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 容器镜像中的所有层都是只读的，这有一些安全影响。你不应该在底层存储机密或敏感信息，因为它们始终是可访问的，即使上层删除了它们。例如，你不应该在容器镜像中打包密码或加密密钥。
- en: So far you have learned how container images are composed, but you haven’t yet
    seen how to create one. That’s coming up next.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了容器镜像是如何组成的，但你还没有看到如何创建一个。接下来就是了。
- en: 6.1.2 Creating images with Dockerfiles
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 使用 Dockerfile 创建镜像
- en: Following the OCI format, you can define a container image by listing the sequence
    of instructions in a particular file called a *Dockerfile*. It’s a script that
    acts as a recipe containing all the steps to *build* the desired image.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 OCI 格式，你可以通过在一个称为 *Dockerfile* 的特定文件中列出指令的顺序来定义容器镜像。它是一个脚本，充当包含构建所需镜像所有步骤的配方。
- en: 'In a Dockerfile, each instruction starts with a command from the Docker-specific
    syntax. Then you can pass familiar shell commands as arguments to the instructions,
    depending on which Linux distribution you’re using as your base image. The format
    is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Dockerfile 中，每条指令都以 Docker 特定语法中的命令开头。然后，你可以根据你使用的 Linux 发行版作为基础镜像，将熟悉的 shell
    命令作为参数传递给指令。格式如下：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note Docker supports Linux containers on machines with AMD64 and ARM64 architectures.
    It also supports working with Windows containers (runnable only on Windows systems),
    but we will exclusively use Linux containers in this book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Docker 支持在具有 AMD64 和 ARM64 架构的机器上运行 Linux 容器。它还支持与 Windows 容器（只能在 Windows
    系统上运行）一起工作，但在这本书中我们将仅使用 Linux 容器。
- en: 'Let’s put that into practice by defining a Dockerfile to build the container
    image mentioned in the previous section, composed of the following main instructions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过定义一个 Dockerfile 来构建上一节中提到的容器镜像，其中包含以下主要指令来实践一下：
- en: Use Ubuntu as the base image.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Ubuntu 作为基础镜像。
- en: Install the Java Runtime Environment.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Java 运行时环境。
- en: Run the java --version command.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 java --version 命令。
- en: Create a my-java-image folder and an empty file inside it named Dockerfile,
    with no extension (Chapter06/06-end/my-java-image). You might name it differently,
    but in this case let’s go with the default convention.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 my-java-image 的文件夹，并在其中创建一个名为 Dockerfile 的空文件，没有扩展名（Chapter06/06-end/my-java-image）。你可能会有不同的命名，但在这个例子中，让我们遵循默认约定。
- en: Listing 6.1 A Dockerfile with the instructions to build an OCI image
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 包含构建 OCI 镜像指令的 Dockerfile
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Bases the new image on the official image for Ubuntu, version 22.04
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 基于 Ubuntu 的官方镜像，版本 22.04
- en: ❷ Installs the JRE using familiar bash commands
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用熟悉的 bash 命令安装 JRE
- en: ❸ Defines the execution entry point for the running container
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义运行容器的执行入口点
- en: By default, Docker is configured to use Docker Hub to find and download images.
    That’s where the ubuntu:22.04 image comes from. Docker Hub is a registry that
    you can use for free (within specific rate limits), and it’s automatically configured
    when you install Docker.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker 配置为使用 Docker Hub 来查找和下载镜像。这就是 ubuntu:22.04 镜像的来源。Docker Hub 是一个你可以免费使用（在特定的速率限制内）的注册表，当你安装
    Docker 时它会自动配置。
- en: The java --version command is the *entry point* of the executing container.
    If you don’t specify any entry point, the container will not run as an executable.
    Unlike virtual machines, containers are meant to run tasks, not operating systems.
    Indeed, when running an Ubuntu container with docker run ubuntu, the container
    will exit right away because no task has been defined as the entry point, only
    the operating system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 'java --version 命令是执行容器的 *入口点*。如果你没有指定任何入口点，容器将不会作为可执行文件运行。与虚拟机不同，容器旨在运行任务，而不是操作系统。确实，当使用
    docker run ubuntu 运行 Ubuntu 容器时，容器会立即退出，因为没有定义任何任务作为入口点，只有操作系统。 '
- en: The most common instructions defined in a Dockerfile are listed in table 6.1.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Dockerfile 中定义的最常见指令列于表 6.1 中。
- en: Table 6.1 The most common instructions used in a Dockerfile for building container
    images
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 在 Dockerfile 中构建容器镜像时最常用的指令
- en: '| Instruction | Description | Example |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 | 示例 |'
- en: '| FROM | Defines the base image for the subsequent instructions. It must be
    the first instruction in a Dockerfile. | FROM ubuntu:22.04 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| FROM | 定义后续指令的基础镜像。它必须是 Dockerfile 中的第一条指令。 | FROM ubuntu:22.04 |'
- en: '| LABEL | Adds metadata to the image, following a key/value format. Multiple
    LABEL instructions can be defined. | LABEL version="1.2.1" |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| LABEL | 以键/值格式向镜像添加元数据。可以定义多个LABEL指令。 | LABEL version="1.2.1" |'
- en: '| ARG | Defines a variable that users can pass at build time. Multiple ARG
    instructions can be defined. | ARG JAR_FILE |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| ARG | 定义用户可以在构建时传递的变量。可以定义多个ARG指令。 | ARG JAR_FILE |'
- en: '| RUN | Executes the commands passed as arguments in a new layer on top of
    the existing ones. Multiple RUN instructions can be defined. | RUN apt-get update
    && apt-get install -y default-jre |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| RUN | 在现有层之上执行作为参数传递的命令。可以定义多个RUN指令。 | RUN apt-get update && apt-get install
    -y default-jre |'
- en: '| COPY | Copies files or directories from the host filesystem to the one inside
    the container. | COPY app-0.0.1-SNAPSHOT.jar app.jar |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| COPY | 从主机文件系统复制文件或目录到容器内部的文件系统。 | COPY app-0.0.1-SNAPSHOT.jar app.jar |'
- en: '| USER | Defines the user that will run all the subsequent instructions and
    the image itself (as a container). | USER sheldon |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| USER | 定义将运行所有后续指令和镜像本身（作为一个容器）的用户。 | USER sheldon |'
- en: '| ENTRYPOINT | Defines the program to execute when the image is run as a container.
    Only the last ENTRYPOINT instruction in a Dockerfile is considered. | ENTRYPOINT
    ["/bin/bash"] |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| ENTRYPOINT | 定义当镜像作为容器运行时要执行的程序。只有Dockerfile中的最后一个ENTRYPOINT指令被考虑。 | ENTRYPOINT
    ["/bin/bash"] |'
- en: '| CMD | Specifies defaults for an executing container. If the ENTRYPOINT instruction
    is defined, they are passed as arguments. If not, it should also contain an executable.
    Only the last CMD instruction in a Dockerfile is considered. | CMD ["sleep", "10"]
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| CMD | 指定正在运行的容器的默认值。如果定义了ENTRYPOINT指令，它们将作为参数传递。如果没有，它也应该包含一个可执行文件。只有Dockerfile中的最后一个CMD指令被考虑。
    | CMD ["sleep", "10"] |'
- en: Once you have the specifications for creating a container image declared in
    a Dockerfile, you can use the docker build command to run all the instructions
    one by one, producing a new layer for each of them. The whole process from Dockerfile
    to image to container is illustrated in figure 6.4\. Notice how the first instruction
    in a Dockerfile produces the lowest layer of the image.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在Dockerfile中声明了创建容器镜像的规范，你可以使用docker build命令逐条运行所有指令，为每个指令产生一个新的层。从Dockerfile到镜像再到容器的整个过程如图6.4所示。注意Dockerfile中的第一条指令产生了镜像的最低层。
- en: '![06-04](../Images/06-04.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![06-04](../Images/06-04.png)'
- en: Figure 6.4 Images are built starting from Dockerfiles. Each instruction in a
    Dockerfile results in an ordered sequence of layers in the image.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 图片是从Dockerfile构建的。Dockerfile中的每条指令都会在镜像中产生一个有序的层序列。
- en: Now open a Terminal window, navigate to the my-java-image folder where your
    Dockerfile is located, and run the following command (don’t forget the final dot).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开一个终端窗口，导航到包含你的Dockerfile的my-java-image文件夹，并运行以下命令（别忘了最后的点）。
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The command syntax is explained in figure 6.5.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 命令语法在图6.5中解释。
- en: '![06-05](../Images/06-05.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![06-05](../Images/06-05.png)'
- en: Figure 6.5 The Docker CLI command to build a new image with a given name and
    version
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 使用给定名称和版本的Docker CLI命令构建新镜像
- en: 'When it’s done, you can get some details about your newly created image using
    the docker images command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你可以使用docker images命令获取有关你新创建的镜像的一些详细信息：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The layered approach makes the image build very performant. Each image layer
    is a delta from the previous one, and Docker caches all of them. If you make changes
    to only one of them and build the image again, only that layer and the subsequent
    ones are recreated. If you run a container from a new version of an image stored
    in a registry, only the new layers will be downloaded, improving performance at
    runtime.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 分层方法使镜像构建非常高效。每个镜像层都是前一个层的增量，Docker缓存了所有这些层。如果你只更改其中之一并重新构建镜像，只有那个层和随后的层会被重新创建。如果你从一个存储在注册表中的镜像的新版本运行容器，只有新的层会被下载，从而提高了运行时的性能。
- en: For that reason, it’s recommended that you order layers based on their likelihood
    to change, optimizing the image build process. Place the instructions that change
    more often toward the end of the Dockerfile.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，建议你根据层可能发生变化的概率来排序层，优化镜像构建过程。将更频繁更改的指令放在Dockerfile的末尾。
- en: 'A container image can be run with the docker run command, which starts a container
    and executes the process described in the Dockerfile as the entry point:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像可以使用docker run命令运行，该命令启动一个容器并执行Dockerfile中描述的过程作为入口点：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After completing the execution, the container will stop. Since you used the
    --rm argument, the container will be removed automatically after the execution
    ends.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完成后，容器将停止。由于您使用了 --rm 参数，执行结束后容器将被自动删除。
- en: Note When you run the previous command, you’ll see that the default OpenJDK
    in Ubuntu 22.04 is Java 11 instead of the 17 version we are working with throughout
    the book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当您运行前面的命令时，您会看到 Ubuntu 22.04 的默认 OpenJDK 是 Java 11，而不是我们在整本书中使用的 17 版本。
- en: Let’s now see how to publish the image to a container registry.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何将镜像发布到容器注册表。
- en: 6.1.3 Publishing images on GitHub Container Registry
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 在 GitHub Container Registry 上发布镜像
- en: So far you have learned how to define, build, and run a container image. In
    this section, I’ll complete the picture by expanding on container registries.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学习了如何定义、构建和运行容器镜像。在本节中，我将通过扩展容器注册表来完善整个图景。
- en: A container registry is to images what a Maven repository is to Java libraries.
    Many cloud providers offer their own registry solutions with extra services, like
    image scanning for vulnerabilities and certified images. By default, a Docker
    installation is configured to use the container registry provided by the Docker
    company (Docker Hub), which hosts images for many popular open source projects,
    like PostgreSQL, RabbitMQ, and Redis. We’ll keep using it to pull images for third
    parties, as you did for Ubuntu in the previous section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 容器注册表对镜像的作用就像 Maven 仓库对 Java 库的作用。许多云提供商提供自己的注册表解决方案，并附带额外服务，如漏洞扫描和认证镜像。默认情况下，Docker
    安装配置为使用 Docker 公司提供的容器注册表（Docker Hub），该注册表托管了许多流行的开源项目的镜像，如 PostgreSQL、RabbitMQ
    和 Redis。我们将继续使用它来拉取第三方镜像，就像您在上一节中为 Ubuntu 所做的那样。
- en: 'How about publishing your own images? You can certainly use Docker Hub or one
    of the registries offered by cloud providers like Azure Container Registry. For
    the specific project we are working on throughout the book, I chose to rely on
    the GitHub Container Registry ([https://docs.github.com/en/packages](https://docs.github.com/en/packages))
    for a few reasons:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发布您自己的镜像怎么样？您当然可以使用 Docker Hub 或云提供商（如 Azure Container Registry）提供的注册表之一。对于我们在整本书中工作的特定项目，我选择依赖
    GitHub Container Registry ([https://docs.github.com/en/packages](https://docs.github.com/en/packages))，原因有以下几点：
- en: It is available for use with all personal GitHub accounts, and it’s free for
    public repositories. You can also use it with private repositories, but with some
    limitations.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对所有个人 GitHub 账户都可用，并且对公共存储库是免费的。您也可以用它来使用私有存储库，但有一些限制。
- en: It allows you to access public container images anonymously without rate limiting,
    even with a free account.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许您无需速率限制即可匿名访问公共容器镜像，即使使用免费账户。
- en: It is fully integrated into the GitHub ecosystem making it possible to navigate
    from images to related source code seamlessly.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它完全集成到 GitHub 生态系统，使得从镜像导航到相关源代码变得无缝。
- en: It lets you generate multiple tokens to access the registry even with a free
    account. It’s recommended that you issue a different access token for each use
    case, and GitHub lets you do that via the personal access token (PAT) feature
    without limitations on the number of tokens. Furthermore, if you access GitHub
    Container Registry from GitHub Actions, you don’t need to configure a PAT—you
    get a token auto-configured by GitHub out of the box, and it’s provided securely
    to the automated pipeline without further configuration.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许您即使使用免费账户也能生成多个令牌来访问注册表。建议您为每个用例发行不同的访问令牌，GitHub 通过个人访问令牌（PAT）功能让您这样做，且对令牌数量没有限制。此外，如果您从
    GitHub Actions 访问 GitHub Container Registry，您不需要配置 PAT——GitHub 会自动为您生成一个令牌，并且它会安全地提供给自动化管道，无需进一步配置。
- en: Publishing images to the GitHub Container Registry requires you to be authenticated,
    and for that you’ll need a personal access token (PAT). Go to your GitHub account,
    navigate to Settings > Developer Settings > Personal access tokens, and choose
    Generate New Token. Input a meaningful name, and assign it the write:packages
    scope to give the token permissions to publish images to the container registry
    (figure 6.6). Finally, generate the token and copy its value. GitHub will show
    you the token value only once. Make sure you save it, because you’ll need it soon.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将镜像发布到 GitHub 容器注册库需要你进行身份验证，为此你需要一个个人访问令牌（PAT）。前往你的 GitHub 账户，导航到设置 > 开发者设置
    > 个人访问令牌，并选择生成新令牌。输入一个有意义的名称，并分配 write:packages 范围以给令牌发布镜像到容器注册库的权限（图 6.6）。最后，生成令牌并复制其值。GitHub
    只会显示一次令牌值。请确保你保存它，因为你很快就会需要它。
- en: '![06-06](../Images/06-06.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![06-06](../Images/06-06.png)'
- en: Figure 6.6 A personal access token granting write access to the GitHub Container
    Registry
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 一个个人访问令牌，允许写入访问 GitHub 容器注册库
- en: 'Next, open a Terminal window and authenticate with GitHub Container Registry
    (make sure your Docker Engine is running). When asked, insert username (your GitHub
    username) and password (your GitHub PAT):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开一个终端窗口，并使用 GitHub 容器注册库进行身份验证（确保你的 Docker 引擎正在运行）。当被要求时，输入用户名（你的 GitHub
    用户名）和密码（你的 GitHub PAT）：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you followed along, you should have your custom my-java-image Docker image
    on your machine. If not, make sure you performed the operations described in the
    previous section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直跟着做，你应该在你的机器上有了自定义的 my-java-image Docker 镜像。如果没有，请确保你执行了上一节中描述的操作。
- en: 'Container images follow common naming conventions, which are adopted by OCI-compliant
    container registries: <container_registry>/<namespace>/<name>[:<tag>]:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像遵循常见的命名约定，这些约定被 OCI 兼容的容器注册库采用：<container_registry>/<namespace>/<name>[:<tag>]：
- en: '*Container registry*—The hostname for the container registry where the image
    is stored. When using Docker Hub, the hostname is docker.io and it’s usually omitted.
    The Docker Engine will implicitly prepend the image name with docker.io if you
    don’t specify a registry. When using GitHub Container Registry, the hostname is
    ghcr.io and must be explicit.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*容器注册库*—存储镜像的容器注册库的主机名。当使用 Docker Hub 时，主机名是 docker.io，通常省略。如果你没有指定注册库，Docker
    引擎会隐式地将 docker.io 前缀添加到镜像名称。当使用 GitHub 容器注册库时，主机名是 ghcr.io，并且必须是显式的。'
- en: '*Namespace*—When using Docker Hub or GitHub Container Registry, the namespace
    will be your Docker/GitHub username written all in lowercase. In other registries,
    it might be the path to the repository.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命名空间*—当使用 Docker Hub 或 GitHub 容器注册库时，命名空间将是你的 Docker/GitHub 用户名，全部小写。在其他注册库中，它可能是存储库的路径。'
- en: '*Name and tag*—The image name represents the repository (or *package*) that
    contains all the versions of your image. It’s optionally followed by a tag for
    selecting a specific version. If no tag is defined, the latest tag will be used
    by default.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*名称和标签*—镜像名称代表包含你镜像所有版本的存储库（或 *包*）。它可选地后面跟着一个标签以选择特定版本。如果没有定义标签，默认将使用最新标签。'
- en: Official images like ubuntu or postgresql can be downloaded by specifying the
    name only, which is implicitly converted to fully qualified names like docker.io/library/
    ubuntu or docker.io/library/postgres.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过指定名称来下载官方镜像，如 ubuntu 或 postgresql，该名称会被隐式转换为完全限定名称，如 docker.io/library/ubuntu
    或 docker.io/library/postgres。
- en: When uploading your images to GitHub Container Registry, you are required to
    use fully qualified names, according to the ghcr.io/<your_github_username>/ <image_name>
    format. For example, my GitHub username is ThomasVitale, and all my personal images
    are named ghcr.io/thomasvitale/<image_name> (notice how the username is converted
    to lowercase).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将镜像上传到 GitHub 容器注册库时，你必须使用完全限定名称，格式为 ghcr.io/<你的_github_username>/<image_name>。例如，我的
    GitHub 用户名是 ThomasVitale，我所有的个人镜像都命名为 ghcr.io/thomasvitale/<image_name>（注意用户名是如何转换为小写的）。
- en: 'Since you previously built an image with the name my-java-image:1.0.0, you
    have to assign it a fully qualified name before publishing it to a container registry
    (that is, you need to *tag* the image). You can do so with the docker tag command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你之前使用 my-java-image:1.0.0 的名称构建了一个镜像，在将其发布到容器注册库之前，你必须给它分配一个完全限定名称（即，你需要 *标记*
    镜像）。你可以使用 docker tag 命令这样做：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then you can finally *push* it to GitHub Container Registry:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你最终可以将其 *push* 到 GitHub 容器注册库：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Go to your GitHub account, navigate to your profile page, and enter the Packages
    section. You should see a new my-java-image entry. If you click on it, you’ll
    find the ghcr.io/<your_github_username>/my-java-image:1.0.0 image you just published
    (figure 6.7). By default, the repository hosting your new image will be private.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 访问您的 GitHub 账户，导航到您的个人资料页面，并进入“包”部分。您应该看到一个名为“my-java-image”的新条目。如果您点击它，您将找到您刚刚发布的
    ghcr.io/<your_github_username>/my-java-image:1.0.0 镜像（图 6.7）。默认情况下，托管您新镜像的仓库将是私有的。
- en: '![06-07](../Images/06-07.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![06-07](../Images/06-07.png)'
- en: Figure 6.7 GitHub Container Registry is a public registry that you can use to
    publish your container images. You can see your images in the Packages section
    of your GitHub profile.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 GitHub 容器注册库是一个公共注册库，您可以使用它来发布您的容器镜像。您可以在 GitHub 个人资料中的“包”部分查看您的镜像。
- en: Tip From the same Packages page, you can also delete the published image or
    the entire image repository (called a *package* in GitHub) by going to the Package
    Settings via the link in the sidebar.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：从相同的“包”页面，您也可以通过侧边栏中的链接进入“包设置”，删除已发布的镜像或整个镜像仓库（在 GitHub 中称为“包”）。'
- en: That concludes this section. Now that you know the main features of container
    images, how to create them, and how to publish them, let’s dive deeper into packaging
    Spring Boot applications as images.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容到此结束。现在您已经了解了容器镜像的主要功能、创建方法和发布方法，让我们更深入地探讨如何将 Spring Boot 应用程序打包成镜像。
- en: 6.2 Packaging Spring Boot applications as container images
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 将 Spring Boot 应用程序打包成容器镜像
- en: In the previous chapters, we built the Catalog Service application, featuring
    a REST API and database integration. In this section, as an intermediate step
    before deploying it to Kubernetes, we’ll build an image to run Catalog Service
    as a container on Docker.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们构建了具有 REST API 和数据库集成的目录服务应用程序。在本节中，作为将其部署到 Kubernetes 之前的中间步骤，我们将构建一个镜像，以便在
    Docker 上以容器形式运行目录服务。
- en: First I’ll review some aspects you should consider when packaging a Spring Boot
    application as a container image. Then I’ll show you how to do that with a Dockerfile
    and with Cloud Native Buildpacks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将回顾一些您在将 Spring Boot 应用程序打包成容器镜像时应考虑的方面。然后，我将向您展示如何使用 Dockerfile 和 Cloud
    Native Buildpacks 来实现这一点。
- en: 6.2.1 Preparing Spring Boot for containerization
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 为容器化准备 Spring Boot
- en: 'Packaging a Spring Boot application as a container image means that the application
    will run in an isolated context, including computational resources and network.
    Two main questions may arise from this isolation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Spring Boot 应用程序打包成容器镜像意味着该应用程序将在一个隔离的环境中运行，包括计算资源和网络。由此隔离可能引发两个主要问题：
- en: How can you reach the application through the network?
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您如何通过网络访问该应用程序？
- en: How can you make it interact with other containers?
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您如何使其与其他容器交互？
- en: We’ll look at those two issues next.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将接下来探讨这两个问题。
- en: Exposing application services through port forwarding
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过端口转发暴露应用程序服务
- en: In chapter 2, when you ran Catalog Service as a container, you mapped port 8080,
    on which the application exposed its services, to port 8080 on your local machine.
    After doing that, you could use the application by visiting http://localhost:8080\.
    What you did there is called *port forwarding* or *port mapping* or *port publishing*,
    and it’s used to make your containerized application accessible from the outside
    world.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章中，当您将目录服务作为容器运行时，您将应用程序暴露服务的端口 8080 映射到本地机器上的端口 8080。完成此操作后，您可以通过访问 http://localhost:8080
    来使用该应用程序。您在那里所做的被称为**端口转发**、**端口映射**或**端口发布**，它用于使您的容器化应用程序对外部世界可访问。
- en: 'By default, containers join an isolated network inside the Docker host. If
    you want to access any container from your local network, you must explicitly
    configure the port mapping. For example, when you ran the Catalog Service application,
    you specified the mapping as an argument to the docker run command: -p 8080:8080
    (where the first is the external port and the second is the container port). Figure
    6.8 illustrates how this works.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，容器加入 Docker 主机内部的隔离网络。如果您想从本地网络访问任何容器，您必须明确配置端口映射。例如，当您运行目录服务应用程序时，您将映射指定为
    docker run 命令的参数：-p 8080:8080（其中第一个是外部端口，第二个是容器端口）。图 6.8 说明了这是如何工作的。
- en: '![06-08](../Images/06-08.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![06-08](../Images/06-08.png)'
- en: Figure 6.8 Port mapping lets you access the services exposed by a containerized
    application by forwarding the traffic from the container network to the outside
    world.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 端口映射允许您通过将容器网络流量转发到外部世界来访问容器化应用程序暴露的服务。
- en: Using Docker’s built-in DNS server for service discovery
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 内置的 DNS 服务器进行服务发现
- en: Thanks to port forwarding, the Catalog Service application in the previous chapter
    could access the PostgreSQL database server through the URL jdbc:postgresql://localhost:5432,
    even if it was running inside a container. The interaction is shown in figure
    6.9\. When running Catalog Service as a container, however, you will not be able
    to do that anymore, since localhost would represent the inside of your container
    and not your local machine. How can you solve this problem?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了端口转发，上一章中的 Catalog Service 应用程序能够通过 URL jdbc:postgresql://localhost:5432
    访问 PostgreSQL 数据库服务器，即使它是在容器内运行的。这种交互在图 6.9 中展示。然而，当将 Catalog Service 作为容器运行时，您将无法再这样做，因为
    localhost 将代表您的容器内部而不是您的本地机器。您如何解决这个问题？
- en: '![06-09](../Images/06-09.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![06-09](../Images/06-09.png)'
- en: Figure 6.9 The Catalog Service application can interact with the PostgreSQL
    container thanks to the port mapping, making the database accessible from the
    outside world.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 通过端口映射，Catalog Service 应用程序可以与 PostgreSQL 容器交互，从而使数据库对外界可访问。
- en: Docker has a built-in DNS server that can enable containers in the same network
    to find each other using the container name rather than a hostname or an IP address.
    For example, Catalog Service will be able to call the PostgreSQL server through
    the URL jdbc:postgresql://polar-postgres:5432, where polar-postgres is the container
    name. Figure 6.10 shows how it works. Later in the chapter you’ll see how to achieve
    this result in code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 内置了一个 DNS 服务器，它可以使同一网络中的容器能够通过容器名称而不是主机名或 IP 地址找到彼此。例如，Catalog Service
    将能够通过 URL jdbc:postgresql://polar-postgres:5432 调用 PostgreSQL 服务器，其中 polar-postgres
    是容器名称。图 6.10 展示了它是如何工作的。在本章的后面部分，您将看到如何在代码中实现这一结果。
- en: '![06-10](../Images/06-10.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![06-10](../Images/06-10.png)'
- en: Figure 6.10 The Catalog Service container can directly interact with the PostgreSQL
    container because they are both on the same Docker network.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 由于 Catalog Service 容器和 PostgreSQL 容器都在同一个 Docker 网络上，因此 Catalog Service
    容器可以直接与 PostgreSQL 容器交互。
- en: 'So before moving on, let’s create a network inside which Catalog Service and
    PostgreSQL can talk to each other using the container name instead of an IP address
    or a hostname. You can run this command from any Terminal window:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在继续之前，让我们创建一个网络，在这个网络中，Catalog Service 和 PostgreSQL 可以通过容器名称而不是 IP 地址或主机名相互通信。您可以从任何终端窗口运行此命令：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, verify that the network has been successfully created:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，验证网络是否已成功创建：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can then start a PostgreSQL container, specifying that it should be part
    of the catalog-network you just created. Using the --net argument ensures the
    container will join the specified network and rely on the Docker built-in DNS
    server:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以启动一个 PostgreSQL 容器，指定它应该成为您刚刚创建的 catalog-network 的一部分。使用 --net 参数确保容器将加入指定的网络并依赖于
    Docker 内置的 DNS 服务器：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the command fails, you might have the PostgreSQL container from chapter 5
    still running. Remove it with docker rm -fv polar-postgres and run the previous
    command again.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令失败，您可能还有第 5 章中运行的 PostgreSQL 容器。使用 docker rm -fv polar-postgres 删除它，然后再次运行前面的命令。
- en: 6.2.2 Containerizing Spring Boot with Dockerfiles
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 使用 Dockerfile 容器化 Spring Boot
- en: Cloud native applications are self-contained. Spring Boot lets you package your
    applications as standalone JARs, including everything they need to run except
    the runtime environment. That makes the containerization very straightforward,
    since all you need in a container image besides the JAR artifact is an operating
    system and a JRE. This section will show you how to containerize the Catalog Service
    application using a Dockerfile.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用程序是自包含的。Spring Boot 允许您将应用程序打包为独立的 JAR 文件，包括它们运行所需的一切，除了运行时环境。这使得容器化变得非常简单，因为您在容器镜像中除了
    JAR 文件之外还需要的是操作系统和 JRE。本节将向您展示如何使用 Dockerfile 容器化 Catalog Service 应用程序。
- en: First, you need to identify which image you want to base yours on. You could
    choose an Ubuntu image, as we did before, and then explicitly install the JRE,
    or you could choose a base image that provides a JRE already, which is more convenient.
    All the major OpenJDK distributions have a related image available on Docker Hub.
    Feel free to choose the one you prefer. In this example I’ll be using Eclipse
    Temurin 17, which is the same OpenJDK distribution I’ve been using locally so
    far. Then you need to copy the JAR file of Catalog Service into the image itself.
    Finally, declare that the entry point for the container execution is the command
    to run the application on the JRE.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要确定您想要基于哪个镜像。您可以选择一个Ubuntu镜像，就像我们之前做的那样，然后明确安装JRE，或者您可以选择一个已经提供了JRE的基础镜像，这会更方便。所有主要的OpenJDK发行版都在Docker
    Hub上提供了相关的镜像。请随意选择您喜欢的。在这个例子中，我将使用Eclipse Temurin 17，这是我迄今为止在本地使用相同的OpenJDK发行版。然后您需要将目录服务JAR文件复制到镜像本身中。最后，声明容器执行的入口点是运行JRE上的应用程序的命令。
- en: Open your Catalog Service project (catalog-service), and create an empty file
    called Dockerfile (with no extension) in the root folder. That file will contain
    the recipe for containerizing your application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的目录服务项目（catalog-service），在根目录下创建一个名为Dockerfile（无扩展名）的空文件。该文件将包含容器化您的应用程序的配方。
- en: Listing 6.2 Dockerfile for describing the Catalog Service image
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2描述目录服务镜像的Dockerfile
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Ubuntu base image with the Eclipse Temurin distribution of the JRE pre-installed
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 预装Eclipse Temurin JRE的Ubuntu基础镜像
- en: ❷ Changes the current working directory to “workspace”
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将当前工作目录更改为“工作区”
- en: ❸ Builds argument specifying the location of the application JAR file in your
    project
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 构建指定应用程序JAR文件在项目中的位置的参数
- en: ❹ Copies the application JAR file from the local machine into the image
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将应用程序JAR文件从本地机器复制到镜像
- en: ❺ Sets the container entry point to run the application
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 设置容器入口点以运行应用程序
- en: This Dockerfile declares a JAR_FILE argument that can be specified when creating
    the image with the docker build command.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此Dockerfile声明了一个JAR_FILE参数，可以在使用docker build命令创建镜像时指定。
- en: 'Before moving on, you need to build the JAR artifact for the Catalog Service
    application. Open a Terminal window and navigate to the Catalog Service project’s
    root folder. First, build the JAR artifact:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您需要构建目录服务应用程序的JAR工件。打开一个终端窗口，导航到目录服务项目的根目录。首先，构建JAR工件：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By default, the Dockerfile script will copy the application’s JAR file from
    the location path used by Gradle: build/libs/. So if you’re using Gradle, you
    can build the container image by running this command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Dockerfile脚本将从Gradle使用的位置路径复制应用程序的JAR文件：build/libs/。所以如果您使用Gradle，您可以通过运行以下命令来构建容器镜像：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you’re using Maven, you can specify the location used by Maven as a build
    argument with the following command (don’t forget the final dot):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Maven，您可以使用以下命令指定Maven使用的位置作为构建参数（不要忘记最后的点）：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In either case, you’ll end up with your Catalog Service application packaged
    as a container image. Since we haven’t specified any version, the image will be
    tagged as latest automatically. Let’s verify that it works.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，您最终都会得到一个打包为容器镜像的目录服务应用程序。由于我们没有指定任何版本，该镜像将自动标记为最新。让我们验证它是否工作。
- en: 'Remember the two aspects I covered in the previous section: port forwarding
    and using the Docker built-in DNS server. You can handle them by adding two arguments
    to the docker run command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我在上一节中提到的两个方面：端口转发和使用Docker内置DNS服务器。您可以通过向docker run命令添加两个参数来处理它们：
- en: -p 9001:9001 will map port 9001 inside the container (where the Catalog Service
    is exposing its services) to port 9001 on your localhost.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -p 9001:9001 将容器内部的9001端口（目录服务暴露其服务的地方）映射到您的localhost上的9001端口。
- en: --net catalog-network will connect the Catalog Service container to the catalog-network
    you previously created so that it can contact the PostgreSQL container.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --net catalog-network 将目录服务容器连接到您之前创建的catalog-network，以便它可以联系PostgreSQL容器。
- en: 'That is still not enough. In the previous chapter, we set the spring.datasource.url
    property for Catalog Service to jdbc:postgresql://localhost:5432/polardb_catalog.
    Since it points to localhost, it will not work from within a container. You already
    know how to configure a Spring Boot application from the outside without having
    to recompile it, right? An environment variable will do. We need to overwrite
    the spring.datasource.url property and specify the same URL, replacing localhost
    with the PostgreSQL container name: polar-postgres. Using another environment
    variable, we can also enable the testdata Spring profile to trigger the creation
    of test data in the catalog:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不够。在上一章中，我们为目录服务设置了spring.datasource.url属性，值为jdbc:postgresql://localhost:5432/polardb_catalog。由于它指向localhost，因此在容器内部将无法工作。你已经知道如何在不重新编译的情况下从外部配置Spring
    Boot应用程序，对吧？一个环境变量就可以做到。我们需要覆盖spring.datasource.url属性并指定相同的URL，将localhost替换为PostgreSQL容器名称：polar-postgres。使用另一个环境变量，我们还可以启用testdata
    Spring配置文件以触发在目录中创建测试数据：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That’s quite a long command, isn’t it? You won’t use the Docker CLI for long,
    though, I promise. Later in the chapter I’ll introduce Docker Compose.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这条命令相当长，不是吗？不过，我保证你不会长时间使用Docker CLI。在本章的后面部分，我将介绍Docker Compose。
- en: 'Open a Terminal window, call the application, and verify that it works correctly,
    as it did in chapter 5:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，调用应用程序，并验证它是否正确工作，就像在第5章中做的那样：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When you’re done, remember to delete both containers:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，记得删除两个容器：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The approach you’ve just followed is perfectly fine for experimenting with Docker
    in your development environment and understanding how images work, but you’ll
    need to consider several aspects before achieving a production-grade image. That’s
    the topic of the next section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚采用的方法对于在开发环境中实验Docker和理解镜像的工作原理是完全可以的，但在实现生产级别的镜像之前，你需要考虑几个方面。这就是下一节的主题。
- en: 6.2.3 Building container images for production
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 为生产构建容器镜像
- en: Getting started with Dockerfiles might not be that difficult at the beginning,
    but building production-grade images can be challenging. In this section, you’ll
    see how to improve the image you built in the previous section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用Dockerfile可能并不那么困难，但构建生产级别的镜像可能具有挑战性。在本节中，你将看到如何改进上一节中构建的镜像。
- en: You’ll use the layered-JAR feature provided by Spring Boot to build more efficient
    images. Then you’ll consider essential security aspects related to container images.
    Finally, I’ll discuss some factors to consider when choosing between Dockerfiles
    and Cloud Native Buildpacks for containerizing applications.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用Spring Boot提供的分层-JAR功能来构建更高效的镜像。然后，你将考虑与容器镜像相关的关键安全方面。最后，我将讨论在选择将Dockerfile与云原生构建包用于应用程序容器化时需要考虑的一些因素。
- en: Performance
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 性能
- en: When building container images, you should consider performance at build time
    and at run time. The layered architecture characterizing OCI images enables the
    caching and reusing of unchanged layers when building an image. Container registries
    store images by layers, so that when you pull a new version, only the changed
    layers are downloaded. That is quite an advantage in a cloud environment, considering
    the time and bandwidth you’ll save for all your application instances.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建容器镜像时，你应该考虑构建时和运行时的性能。表征OCI镜像的分层架构使得在构建镜像时可以缓存和重用未更改的层。容器注册库按层存储镜像，因此当你拉取新版本时，只有更改过的层会被下载。考虑到你将节省所有应用程序实例的时间和带宽，这在云环境中是一个相当大的优势。
- en: In the previous section, you copied the Catalog Service standalone JAR file
    into a layer in the image. As a result, whenever you change something in your
    application, the whole layer must be rebuilt. Consider the scenario where you
    just add a new REST endpoint to your application. Even if all the Spring libraries
    and dependencies are unchanged, and the only difference is in your own code, you
    must rebuild the whole layer, since everything is together. We can do better.
    And Spring Boot can help us.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你将目录服务独立JAR文件复制到镜像的一个层中。结果，每次你更改应用程序中的内容时，整个层都必须重建。考虑这样一个场景：你只是向应用程序中添加了一个新的REST端点。即使所有的Spring库和依赖项都没有改变，唯一的区别在于你的代码，你也必须重建整个层，因为所有内容都是一起的。我们可以做得更好。Spring
    Boot可以帮助我们。
- en: 'Putting uber-JARs inside a container image has never been efficient. A JAR
    artifact is a compressed archive containing all the dependencies, classes, and
    resources used by the application. All those files are organized in folders and
    subfolders within the JAR. We could expand standard JAR artifacts and put each
    folder on a different container image level. Starting with version 2.3, Spring
    Boot made that even more efficient by introducing a new way of packaging applications
    as JAR artifacts: the layered-JAR mode. And since Spring Boot 2.4, that’s been
    the default mode, so you don’t need any extra configuration to use the new functionality.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将uber-JAR放入容器镜像中从未是高效的。JAR工件是一个包含应用程序使用的所有依赖项、类和资源的压缩归档。所有这些文件都组织在JAR内的文件夹和子文件夹中。我们可以扩展标准JAR工件，并将每个文件夹放在不同的容器镜像层上。从2.3版本开始，Spring
    Boot通过引入一种新的打包应用程序为JAR工件的方式：分层JAR模式，使其变得更加高效。自Spring Boot 2.4以来，这已成为默认模式，因此您无需任何额外配置即可使用新功能。
- en: Applications packaged using the *layered-JAR mode* are made up of layers, similar
    to how container images work. This new feature is excellent for building more
    efficient images. When using the new JAR packaging, we can expand the JAR artifact
    and then create a different image layer for each JAR layer. The goal is to have
    your own classes (which change more frequently) on a separate layer from the project
    dependencies (which change less frequently).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*分层JAR模式*打包的应用程序由层组成，类似于容器镜像的工作方式。这个新特性对于构建更高效的镜像非常出色。当使用新的JAR打包时，我们可以扩展JAR工件，然后为每个JAR层创建不同的镜像层。目标是让您的类（这些类更改得更频繁）与项目依赖项（这些依赖项更改得较少）在不同的层上。
- en: 'By default, Spring Boot applications are packaged as JAR artifacts made up
    of the following layers, starting from the lowest:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Boot应用程序被打包成由以下层组成的JAR工件，从最低层开始：
- en: dependencies—For all the main dependencies added to the project
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dependencies—对于添加到项目中的所有主要依赖项
- en: spring-boot-loader—For the classes used by the Spring Boot loader component
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spring-boot-loader—用于Spring Boot加载器组件使用的类
- en: snapshot-dependencies—For all the snapshot dependencies
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: snapshot-dependencies—对于所有快照依赖项
- en: application—For your application classes and resources
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: application—对于您的应用程序类和资源
- en: If you consider the previous scenario where you added a new REST endpoint to
    an existing application, only the application layer must be built when you containerize
    it. Moreover, when you upgrade the application in production, only that new layer
    must be downloaded to the nodes where the container is running, making the upgrade
    faster and cheaper (especially on cloud platforms, which bill for the bandwidth
    used).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您考虑之前的场景，其中您向现有应用程序添加了新的REST端点，那么在容器化时只需构建应用程序层。此外，当您在生产中升级应用程序时，只需将新层下载到容器正在运行的节点上，这使得升级更快、更便宜（尤其是在云平台上，云平台按使用的带宽计费）。
- en: 'Let’s update the previous Dockerfile to containerize Catalog Service more efficiently
    using the layered-JAR mode. Using this new strategy means doing some preparation
    work to copy the JAR file into the image and expand it into the four layers described
    previously. We don’t want to keep the original JAR file inside the image, or our
    optimization plan will not work. Docker provides a solution for that: *multi-stage
    builds*.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新之前的Dockerfile，使用分层JAR模式更有效地容器化目录服务。使用这种新策略意味着需要进行一些准备工作，将JAR文件复制到镜像中并扩展成之前描述的四个层。我们不希望在镜像中保留原始JAR文件，否则我们的优化计划将无法工作。Docker为此提供了一个解决方案：*多阶段构建*。
- en: We’ll divide the work into two stages. In the first stage we extract the layers
    from the JAR file. The second stage is where we place each JAR layer into a separate
    image layer. In the end, the result of the first stage is discarded (including
    the original JAR file), while the second stage will produce the final container
    image.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将工作分为两个阶段。在第一阶段，我们从JAR文件中提取层。第二阶段是将每个JAR层放置到单独的镜像层中。最终，第一阶段的结果将被丢弃（包括原始JAR文件），而第二阶段将生成最终的容器镜像。
- en: Listing 6.3 More efficient Dockerfile to build a Catalog Service image
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 更高效的Dockerfile构建目录服务镜像
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ OpenJDK base image for the first stage
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 第一阶段的OpenJDK基础镜像
- en: ❷ Builds argument specifying the location of the application JAR file in your
    project
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指定应用程序JAR文件在项目中的位置的构建参数
- en: ❸ Copies the application JAR file from the local machine into the image inside
    the “workspace” folder
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将应用程序JAR文件从本地机器复制到“工作区”文件夹内的镜像中
- en: ❹ Extracts the layers from the archive applying the layered-JAR mode
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从存档中提取层，应用分层-JAR 模式
- en: ❺ OpenJDK base image for the second stage
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 第二阶段的 OpenJDK 基础镜像
- en: ❻ Copies each JAR layer from the first stage to the second stage inside the
    “workspace” folder
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 从“工作区”文件夹中的第一个阶段复制每个 JAR 层到第二个阶段
- en: ❼ Uses the Spring Boot Launcher to start the application from the layers rather
    than an uber-JAR
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 使用 Spring Boot Launcher 从层而不是 uber-JAR 启动应用程序
- en: Note What if you want to change the configuration for the layers in the JAR
    file? As always, Spring Boot provides sensible defaults, but you can customize
    it and adapt it to your needs. Perhaps your project has internal shared dependencies
    you might want to place in a separate layer, since they change more often than
    third-party dependencies. You can do that through the Spring Boot Gradle or Maven
    plugin. For more information, refer to the Spring Boot documentation at [https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你想要更改 JAR 文件中层的配置怎么办？像往常一样，Spring Boot 提供了合理的默认值，但你也可以自定义它并适应你的需求。也许你的项目有内部共享依赖项，你可能希望将它们放在一个单独的层中，因为它们比第三方依赖项更改得更频繁。你可以通过
    Spring Boot Gradle 或 Maven 插件来实现这一点。有关更多信息，请参阅 Spring Boot 文档[https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)。
- en: The process for building and running the container is the same as before, but
    now the image is more efficient and is optimized at build and execution time.
    However, it’s still not ready for production. What about security? That’s the
    topic of the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行容器的过程与之前相同，但现在镜像更高效，在构建和执行时间上进行了优化。然而，它仍然不适合生产环境。那么安全性呢？这是下一节的主题。
- en: Security
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性
- en: Security is a critical aspect that is too often underestimated by people getting
    started with Docker and containerization. You should be aware that containers
    run using the root user by default, potentially letting them get root access to
    the Docker host. You can mitigate the risk by creating a non-privileged user and
    using it to run the entry-point process defined in the Dockerfile, following the
    principle of least privilege.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是一个经常被初学者低估的关键方面，尤其是在使用 Docker 和容器化技术时。你应该意识到，容器默认使用 root 用户运行，这可能会让它们获得对
    Docker 主机的 root 访问权限。你可以通过创建一个非特权用户并使用它来运行 Dockerfile 中定义的入口点进程，遵循最小权限原则来降低风险。
- en: Consider the Dockerfile you wrote for Catalog Service. You can improve it by
    adding new steps to create a new non-root user that will run the application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你为目录服务编写的 Dockerfile。你可以通过添加新步骤来创建一个新的非 root 用户来运行应用程序来改进它。
- en: Listing 6.4 More secure Dockerfile to build a Catalog Service image
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 更安全的 Dockerfile 以构建目录服务镜像
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Creates a “spring” user
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个“spring”用户
- en: ❷ Configures “spring” as the current user
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 配置“spring”为当前用户
- en: As previously noted, you should never store secrets like passwords or keys in
    a container image. Even if they are removed in an upper layer, they will remain
    intact in the original layer and be easily accessible.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你不应该在容器镜像中存储像密码或密钥这样的机密信息。即使它们在上层被移除，它们仍然会保留在原始层中，并且容易被访问。
- en: Finally, it’s also critical to use up-to-date base images and libraries in your
    Dockerfile. Scanning your container images for vulnerabilities is a best practice
    that should be embraced and automated in your deployment pipeline. In chapter
    3, you learned how to use grype to scan codebases for vulnerabilities. Now we’ll
    also use it to scan a container image.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用最新的基础镜像和库在 Dockerfile 中也是至关重要的。在部署管道中扫描容器镜像以查找漏洞是一种最佳实践，应该被采纳并自动化。在第 3
    章中，你学习了如何使用 grype 扫描代码库中的漏洞。现在我们将用它来扫描容器镜像。
- en: 'Using the updated Dockerfile, build a new container image for Catalog Service.
    Open a Terminal window, navigate to the Catalog Service root folder, and run this
    command (don’t forget the final dot):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更新的 Dockerfile，为目录服务构建一个新的容器镜像。打开一个终端窗口，导航到目录服务根文件夹，并运行此命令（别忘了最后的点）：
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, use grype to check if the newly created image contains any vulnerabilities:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 grype 检查新创建的镜像是否包含任何漏洞：
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Have you found any high-severity vulnerabilities? Discussing supply chain security
    and related risk management is out of scope for this book. I want to show you
    how to perform and automate vulnerability scanning for application artifacts,
    but I’ll leave it up to you to follow up on the scan results. I can’t stress enough
    how important it is to define a security strategy in your organization and automate,
    as much as possible, its compliance verification throughout the whole value stream.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否发现了任何严重漏洞？讨论供应链安全和相关风险管理超出了本书的范围。我想向你展示如何执行和自动化应用程序工件的安全扫描，但我会让你自己跟进扫描结果。我无法强调得更多，即定义组织的安全策略并尽可能在整个价值流中自动化其合规性验证是多么重要。
- en: In this section, I mentioned a few essential aspects you should consider when
    building production-grade container images, but there’s even more to cover. Is
    there another way to build production-grade container images? The following section
    introduces a different option.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我提到了在构建生产级容器镜像时应考虑的一些基本方面，但还有更多内容需要探讨。是否有另一种构建生产级容器镜像的方法？下一节将介绍另一种选择。
- en: Dockerfiles or Buildpacks
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfiles 或 Buildpacks
- en: Dockerfiles are very powerful, and they give you complete fine-grained control
    over the result. However, they require extra care and maintenance and can lead
    to several challenges in your value stream.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfiles非常强大，它们让你对结果有完全细粒度的控制。然而，它们需要额外的关注和维护，可能会在你的价值流中引起一些挑战。
- en: As a developer, you might not want to deal with all the performance and security
    concerns we’ve discussed. You might prefer to focus on the application code instead.
    After all, one reason to move to the cloud is to deliver value to customers faster.
    Adding the Dockerfile step and considering all those issues might not be for you.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你可能不想处理我们讨论的所有性能和安全问题。你可能更愿意专注于应用程序代码。毕竟，迁移到云的一个原因是为了更快地向客户交付价值。添加Dockerfile步骤并考虑所有这些问题可能不适合你。
- en: As an operator, it might be challenging to control and secure the supply chain
    within the organization when container images are built from a Dockerfile. It’s
    pretty common to invest some time in scripting the *perfect* Dockerfile and to
    copy that into multiple repositories for different applications. But it’s hard
    to keep all teams on the same page, verify adherence to the approved Dockerfile,
    synchronize any changes throughout the organization, and understand who is responsible
    for what.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作员，当容器镜像由Dockerfile构建时，可能很难在组织内部控制并保护供应链。在脚本编写*完美*的Dockerfile并复制到多个存储库以供不同应用程序使用是很常见的。但是，很难让所有团队保持一致，验证对批准的Dockerfile的遵守，在整个组织内同步任何更改，并了解谁负责什么。
- en: Cloud Native Buildpacks provide a different approach, focusing on consistency,
    security, performance, and governance. As a developer, you get a tool that automatically
    builds a production-ready OCI image from your application source code without
    having to write a Dockerfile. As an operator, you get a tool that defines, controls,
    and secures application artifacts within the entire organization.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Native Buildpacks提供了一种不同的方法，侧重于一致性、安全性、性能和治理。作为开发者，你将获得一个工具，该工具可以从你的应用程序源代码自动构建一个生产就绪的OCI镜像，而无需编写Dockerfile。作为操作员，你将获得一个工具，该工具定义、控制和保护整个组织中的应用程序工件。
- en: Ultimately, the decision to use a Dockerfile or a tool like Buildpacks depends
    on your organization and requirements. Both approaches are valid and are used
    in production. In general, my recommendation is to use Buildpacks unless it makes
    sense not to.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，使用Dockerfile或像Buildpacks这样的工具的决定取决于你的组织和需求。两种方法都是有效的，并且在生产中使用。一般来说，我的建议是使用Buildpacks，除非没有理由不这样做。
- en: Note Another option for packaging Java applications as container images without
    writing a Dockerfile is using Jib, a Gradle and Maven plugin developed by Google
    ([https://github.com/GoogleContainerTools/jib](https://github.com/GoogleContainerTools/jib)).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：另一种无需编写Dockerfile即可将Java应用程序打包为容器镜像的选项是使用Jib，这是由Google开发的一个Gradle和Maven插件（[https://github.com/GoogleContainerTools/jib](https://github.com/GoogleContainerTools/jib)）。
- en: In the next section and the rest of the book, we’ll use Cloud Native Buildpacks
    rather than Dockerfiles. It was important for me to show you how a Dockerfile
    works, because it makes understanding the container image features and layers
    easier. Furthermore, I wanted to show you how to write a basic Dockerfile for
    containerizing a Spring Boot application to highlight what’s needed and illustrate
    the execution of the application JAR from within the container. Finally, it will
    be easier for you to debug containers when something goes wrong, even if they’re
    automatically generated by Buildpacks, because you now know how to build images
    from scratch. If you’d like to learn more about Dockerfiles for Spring Boot applications,
    I recommend you look at the official documentation ([https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节和本书的其余部分，我们将使用 Cloud Native Buildpacks 而不是 Dockerfile。对我而言，向您展示 Dockerfile
    的工作原理非常重要，因为它使得理解容器镜像特性和层变得更容易。此外，我还想向您展示如何编写一个基本的 Dockerfile 来容器化 Spring Boot
    应用程序，以突出所需的内容并展示应用程序 JAR 在容器内的执行。最后，当出现问题时，您将更容易调试容器，即使它们是由 Buildpacks 自动生成的，因为您现在知道如何从头开始构建镜像。如果您想了解更多关于
    Spring Boot 应用程序的 Dockerfile，我建议您查看官方文档（[https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)）。
- en: 6.2.4 Containerizing Spring Boot with Cloud Native Buildpacks
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.4 使用 Cloud Native Buildpacks 容器化 Spring Boot
- en: Cloud Native Buildpacks ([https://buildpacks.io](https://buildpacks.io)) is
    a project hosted by the CNCF to “transform your application source code into images
    that can run on any cloud.” When introducing containers in chapter 1, I underlined
    how PaaS platforms like Heroku and Cloud Foundry are actually using containers
    behind the scenes, converting your application source code into containers before
    running them. Buildpacks is the tool they use to accomplish that.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Native Buildpacks ([https://buildpacks.io](https://buildpacks.io)) 是由
    CNCF 托管的项目，旨在“将您的应用程序源代码转换为可以在任何云上运行的镜像。”在第一章介绍容器时，我强调了 PaaS 平台如 Heroku 和 Cloud
    Foundry 实际上在幕后使用容器，在运行之前将您的应用程序源代码转换为容器。Buildpacks 是他们用来完成这个任务的工具。
- en: Cloud Native Buildpacks has been developed and advanced based on Heroku and
    Pivotal’s many years of experience running cloud native applications as containers
    on their PaaS platforms. It’s a mature project, and since Spring Boot 2.3, it
    has been integrated natively in the Spring Boot Plugin for both Gradle and Maven,
    so you’re not required to install the dedicated Buildpacks CLI (pack).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Native Buildpacks 是基于 Heroku 和 Pivotal 多年运行云原生应用程序（在他们的 PaaS 平台上作为容器）的经验开发和改进的。这是一个成熟的项目，自
    Spring Boot 2.3 以来，它已经集成到 Gradle 和 Maven 的 Spring Boot 插件中，因此您不需要安装专门的 Buildpacks
    CLI（pack）。
- en: 'These are some of its features:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是它的一些特性：
- en: It auto-detects the type of application and packages it without requiring a
    Dockerfile.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以自动检测应用程序的类型，并在不需要 Dockerfile 的情况下对其进行打包。
- en: It supports multiple languages and platforms.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持多种语言和平台。
- en: It’s highly performant through caching and layering.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过缓存和分层实现高性能。
- en: It guarantees reproducible builds.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它保证了可重复构建。
- en: It relies on best practices in terms of security.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在安全性方面遵循最佳实践。
- en: It produces production-grade images.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以生成生产级别的图像。
- en: It supports building native images using GraalVM.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持使用 GraalVM 构建原生镜像。
- en: Note If you’d like to know more about Cloud Native Buildpacks, I recommend watching
    “Cloud Native Buildpacks with Emily Casey” ([http://mng.bz/M0xB](http://mng.bz/M0xB)).
    Emily Casey is a member of the Buildpacks core team.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您想了解更多关于 Cloud Native Buildpacks 的信息，我建议您观看“Cloud Native Buildpacks with
    Emily Casey”（[http://mng.bz/M0xB](http://mng.bz/M0xB)）。Emily Casey 是 Buildpacks
    核心团队的一员。
- en: The container generation process is orchestrated by a *builder* image containing
    the complete information on how to containerize your application. Such information
    is provided as a sequence of *buildpacks*, each dedicated to a specific aspect
    of the application (such as the operating system, OpenJDK, and JVM configuration).
    The Spring Boot Plugin adopts the Paketo Buildpacks builder, an implementation
    of the Cloud Native Buildpacks specification that provides support for many types
    of applications, including Java and Spring Boot ones ([https://paketo.io](https://paketo.io)).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 容器生成过程由一个包含如何容器化您的应用程序的完整信息的 *builder* 镜像进行编排。这些信息以 *buildpacks* 的序列形式提供，每个
    *buildpacks* 都针对应用程序的特定方面（例如操作系统、OpenJDK 和 JVM 配置）。Spring Boot 插件采用了 Paketo Buildpacks
    builder，这是 Cloud Native Buildpacks 规范的实现，为包括 Java 和 Spring Boot 在内的许多类型的应用程序提供支持（[https://paketo.io](https://paketo.io)）。
- en: The Paketo builder component relies on a series of default buildpacks for the
    actual build operation. This structure is highly modular and customizable. You
    can add new buildpacks to the sequence (for example, to add a monitoring agent
    to the application), replace existing ones (for example, to replace the default
    Bellsoft Liberica OpenJDK with Microsoft OpenJDK), or even use a different builder
    image entirely.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Paketo 构建器组件依赖于一系列默认的构建包来进行实际的构建操作。这种结构高度模块化和可定制。您可以向序列中添加新的构建包（例如，向应用程序添加监控代理），替换现有的构建包（例如，用
    Microsoft OpenJDK 替换默认的 Bellsoft Liberica OpenJDK），或者甚至完全使用不同的构建器镜像。
- en: Note The Cloud Native Buildpacks project manages a registry where you can discover
    and analyze buildpacks you can use to containerize your applications, including
    all the buildpacks from the Paketo implementation ([https://registry.buildpacks.io](https://registry.buildpacks.io)).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Cloud Native Buildpacks 项目管理着一个注册表，您可以在其中发现和分析可用于容器化应用程序的构建包，包括 Paketo 实现中的所有构建包（[https://registry.buildpacks.io](https://registry.buildpacks.io)）。
- en: The Buildpacks integration provided by the Spring Boot Plugin can be configured
    in the build.gradle file located in your Catalog Service project. Let’s configure
    the image name and define which Java version to use through an environment variable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 插件提供的 Buildpacks 集成可以在位于您的 Catalog Service 项目中的 build.gradle 文件中进行配置。让我们配置镜像名称并通过环境变量定义要使用的
    Java 版本。
- en: Listing 6.5 Configuration for containerizing Catalog Service
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.5 容器化 Catalog 服务配置
- en: '[PRE22]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ The Spring Boot Plugin task to build an OCI image using Buildpacks
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 Buildpacks 构建OCI镜像的 Spring Boot 插件任务
- en: ❷ The name of the OCI image to build. The name is the same one defined in the
    Gradle configuration for the project. We rely on the implicit “latest” tag when
    working locally rather than a version number.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 要构建的 OCI 镜像的名称。该名称与项目 Gradle 配置中定义的名称相同。在本地工作时，我们依赖于隐式的“最新”标签，而不是版本号。
- en: ❸ The JVM version to be installed in the image. It uses the latest Java 17 version.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 需要在镜像中安装的 JVM 版本。它使用最新的 Java 17 版本。
- en: 'Go ahead and build the image by running the following command:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令继续构建镜像：
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Warning At the time of writing, the Paketo project is working on adding support
    for ARM64 images. You can follow the feature’s progress on the Paketo Buildpacks
    project on GitHub: [https://github.com/paketo-buildpacks/stacks/issues/51](https://github.com/paketo-buildpacks/stacks/issues/51).
    Until it’s complete, you can still use Buildpacks to build containers and run
    them via Docker Desktop on Apple Silicon computers. However, the build process
    and the application startup phase will be slower than usual. Until official support
    is added, you can alternatively use the following command, pointing to an experimental
    version of Paketo Buildpacks with ARM64 support: ./gradlew bootBuildImage --builder
    ghcr.io/thomasvitale/java-builder-arm64. Be aware that it’s experimental and not
    ready for production. For more information, you can refer to the documentation
    on GitHub: [https://github.com/ThomasVitale/paketo-arm64](https://github.com/ThomasVitale/paketo-arm64).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在撰写本文时，Paketo 项目正在努力添加对 ARM64 镜像的支持。您可以在 GitHub 上的 Paketo Buildpacks 项目中跟踪该功能的进展：[https://github.com/paketo-buildpacks/stacks/issues/51](https://github.com/paketo-buildpacks/stacks/issues/51)。在它完成之前，您仍然可以使用
    Buildpacks 构建容器并通过 Docker Desktop 在 Apple Silicon 计算机上运行它们。然而，构建过程和应用启动阶段将比通常慢。在官方支持添加之前，您还可以使用以下命令，指向具有
    ARM64 支持的实验性 Paketo Buildpacks 版本：./gradlew bootBuildImage --builder ghcr.io/thomasvitale/java-builder-arm64。请注意，这是实验性的，并不适合生产环境。有关更多信息，您可以参考
    GitHub 上的文档：[https://github.com/ThomasVitale/paketo-arm64](https://github.com/ThomasVitale/paketo-arm64)。
- en: The first time you run the task, it will take a minute to download the packages
    used by Buildpacks to create the container image. The second time, it will take
    only a few seconds. If you look closely at the output of the command, you can
    see all the steps performed by Buildpacks to generate the image. These steps include
    adding a JRE and using the layered JAR built by Spring Boot. The plugin accepts
    more properties to customize its behavior, such as providing your own builder
    component instead of Paketo’s. Check the official documentation for the complete
    list of configuration options ([https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行任务时，将花费一分钟下载 Buildpacks 创建容器镜像所使用的包。第二次，只需几秒钟。如果你仔细查看命令的输出，你可以看到 Buildpacks
    生成镜像所执行的所有步骤。这些步骤包括添加 JRE 和使用 Spring Boot 构建的分层 JAR。插件接受更多属性来自定义其行为，例如提供你自己的构建组件而不是
    Paketo 的。请查看官方文档以获取完整的配置选项列表（[https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot))。
- en: 'Let’s try running Catalog Service as a container once again, but this time
    we’ll use the image generated by Buildpacks. Remember to start the PostgreSQL
    container first, following the instructions in section 6.2.1:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试以容器形式运行 Catalog 服务，但这次我们将使用 Buildpacks 生成的镜像。请记住，首先按照 6.2.1 节中的说明启动 PostgreSQL
    容器：
- en: '[PRE24]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Warning If you’re running the container on an Apple Silicon computer, the previous
    command might return a message like “WARNING: The requested image’s platform (linux/amd64)
    does not match the detected host platform (linux/arm64/v8) and no specific platform
    was requested.” In that case, you’ll need to include this additional argument
    to the previous command (before the image name) until support for ARM64 is added
    to Paketo Buildpacks: --platform linux/amd64.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '警告：如果你在 Apple Silicon 计算机上运行容器，之前的命令可能会返回类似“WARNING: 请求的镜像的平台（linux/amd64）与检测到的宿主平台（linux/arm64/v8）不匹配，且未请求特定平台。”的消息。在这种情况下，你需要将此附加参数包含到之前的命令中（在镜像名称之前），直到
    Paketo Buildpacks 添加对 ARM64 的支持：--platform linux/amd64。'
- en: 'Open a browser window, call the application on http://localhost:9001/books,
    and verify that it works correctly. When you’re done, remember to delete both
    the PostgreSQL and Catalog Service containers:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个浏览器窗口，在 http://localhost:9001/books 上调用应用程序，并验证其是否正常工作。完成后，请记住删除 PostgreSQL
    和 Catalog 服务容器：
- en: '[PRE25]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, you can remove the network you used to make Catalog Service communicate
    with PostgreSQL. You won’t need it anymore, after I introduce Docker Compose in
    the next section:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以移除用于使 Catalog 服务与 PostgreSQL 通信的网络。在下一节介绍 Docker Compose 之后，你将不再需要它：
- en: '[PRE26]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since Spring Boot 2.4, you can also configure the Spring Boot plugin to publish
    the image directly to a container registry. To do so, you first need to add configuration
    for authenticating with the specific container registry in the build.gradle file.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Spring Boot 2.4 版本开始，你也可以配置 Spring Boot 插件直接将镜像发布到容器注册库。为此，你首先需要在 build.gradle
    文件中添加用于与特定容器注册库进行身份验证的配置。
- en: Listing 6.6 Configuration for containerizing Catalog Service
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 对 Catalog 服务进行容器化的配置
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Section to configure the connection with a container registry
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置与容器注册库连接的章节
- en: ❷ Section to configure authentication to the publishing container registry.
    The values are passed as Gradle properties.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 配置对发布容器注册库进行身份验证的章节。这些值作为 Gradle 属性传递。
- en: The details on how to authenticate with the container registry are externalized
    as Gradle properties both for flexibility (you can publish the image to different
    registries without changing the Gradle build) and for security (the token, in
    particular, should never be included in version control).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如何与容器注册库进行身份验证的详细信息被外部化为 Gradle 属性，这既是为了灵活性（你可以在不更改 Gradle 构建的情况下将镜像发布到不同的注册库）也是为了安全（特别是令牌，永远不应该包含在版本控制中）。
- en: 'Remember this golden rule of credentials: you should never give your password
    away. Never! If you need to delegate some service to access a resource on your
    behalf, you should rely on an access token. The Spring Boot plugin lets you use
    a password to authenticate with the registry, but you should use a token instead.
    In section 6.1.3, you generated a personal access token in GitHub to let you push
    images to the GitHub Container Registry from your local environment. If you don’t
    know its value anymore, feel free to generate a new one following the procedure
    I explained earlier in the chapter.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个关于凭证的黄金法则：你永远不应该泄露你的密码。永远不要！如果你需要代表你授权某些服务访问资源，你应该依赖访问令牌。Spring Boot 插件允许你使用密码与注册表进行身份验证，但你应该使用令牌。在第
    6.1.3 节中，你已经在 GitHub 上生成了一个个人访问令牌，以便你从本地环境将镜像推送到 GitHub 容器注册表。如果你不再知道它的值，可以自由地按照我在本章前面解释的步骤生成一个新的令牌。
- en: 'Finally, you can build and publish the image by running the bootBuildImage
    task. With the --imageName argument, you can define a fully qualified image name
    as container registries require. With the --publishImage argument, you can instruct
    the Spring Boot plugin to push the image to the container registry directly. Also,
    remember to pass values for the container registry via the Gradle properties:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过运行 bootBuildImage 任务来构建和发布镜像。使用 `--imageName` 参数，你可以定义一个完全限定的镜像名称，因为容器注册表需要。使用
    `--publishImage` 参数，你可以指示 Spring Boot 插件直接将镜像推送到容器注册表。此外，记得通过 Gradle 属性传递容器注册表的值：
- en: '[PRE28]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Tip If you’re working on ARM64 machines (such as Apple Silicon computers),
    you can add the --builder ghcr.io/thomasvitale/java-builder-arm64 argument to
    the previous command to use an experimental version of Paketo Buildpacks with
    ARM64 support. Be aware that it’s experimental and not ready for production. For
    more information, you can refer to the documentation on GitHub: [https://github.com/ThomasVitale/paketo-arm64](https://github.com/ThomasVitale/paketo-arm64).
    Without this workaround, until official support is added ([https://github.com/paketo-buildpacks/stacks/issues/51](https://github.com/paketo-buildpacks/stacks/issues/51)),
    you can still use Buildpacks to build containers and run them via Docker Desktop
    on Apple Silicon computers, but the build process and application startup phase
    will be slower than usual.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你在 ARM64 机器（例如苹果硅电脑）上工作，你可以在之前的命令中添加 `--builder ghcr.io/thomasvitale/java-builder-arm64`
    参数来使用带有 ARM64 支持的实验性 Paketo Buildpacks 版本。请注意，这是实验性的，并不适合生产环境。更多信息，你可以参考 GitHub
    上的文档：[https://github.com/ThomasVitale/paketo-arm64](https://github.com/ThomasVitale/paketo-arm64)。在没有官方支持添加之前（[https://github.com/paketo-buildpacks/stacks/issues/51](https://github.com/paketo-buildpacks/stacks/issues/51)），你仍然可以使用
    Buildpacks 来构建容器并通过 Docker Desktop 在苹果硅电脑上运行它们，但构建过程和应用启动阶段将比通常慢。
- en: Once the command completes successfully, go to your GitHub account, navigate
    to your profile page, and enter the Packages section. You should see a new catalog-service
    entry (by default, packages hosting container images are private), similar to
    what you saw with the my-java-image you published in section 6.1.3\. If you click
    on the catalog-service entry, you’ll find the ghcr.io/<your_github_username>/catalog-service:latest
    image you just published (figure 6.11).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令成功完成，请转到你的 GitHub 账户，导航到你的个人资料页面，并进入“包”部分。你应该会看到一个新目录服务条目（默认情况下，托管容器镜像的包是私有的），类似于你在第
    6.1.3 节中发布的 my-java-image 所见到的。如果你点击目录服务条目，你会找到你刚刚发布的 ghcr.io/<你的 GitHub 用户名>/catalog-service:latest
    镜像（图 6.11）。
- en: '![06-11](../Images/06-11.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![06-11](../Images/06-11.png)'
- en: Figure 6.11 Images published to the GitHub Container Registry are organized
    as “packages.”
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 发布到 GitHub 容器注册表的镜像组织为“包”。
- en: However, the catalog-service package is not linked to your catalog-service source
    code repository yet. Later, I’ll show you how to automate building and publishing
    your images with GitHub Actions, which makes it possible to publish images in
    the context of the source code repository from which they are built.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目录服务包尚未链接到你的目录服务源代码仓库。稍后，我会向你展示如何使用 GitHub Actions 自动化构建和发布你的镜像，这使得从构建它们的源代码仓库上下文中发布镜像成为可能。
- en: For now, let’s remove the catalog-service package that was created when you
    published the image so that it won’t cause any conflicts once you start using
    GitHub Actions to publish images. From the catalog-service package page (figure
    6.11), click Package Settings in the sidebar menu, scroll to the bottom of the
    settings page, and click Delete This Package (figure 6.12).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们删除在发布镜像时创建的 catalog-service 包，以避免您开始使用 GitHub Actions 发布镜像时产生任何冲突。从 catalog-service
    包页面（图 6.11），点击侧边菜单中的“Package Settings”，滚动到设置页面的底部，然后点击“Delete This Package”（图
    6.12）。
- en: '![06-12](../Images/06-12.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![06-12](../Images/06-12.png)'
- en: Figure 6.12 Delete the catalog-service package created manually.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 删除手动创建的 catalog-service 包。
- en: Note So far, we’ve been using the implicit latest tag for naming container images.
    That’s not recommended for production scenarios. In chapter 15, you’ll see how
    to handle versions when releasing your applications. Until then, we’ll rely on
    the implicit latest tag.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：到目前为止，我们一直在使用隐式的 latest 标签来命名容器镜像。在生产场景中，这并不推荐。在第 15 章中，您将了解在发布应用程序时如何处理版本。在此之前，我们将依赖隐式的
    latest 标签。
- en: 6.3 Managing Spring Boot containers with Docker Compose
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 使用 Docker Compose 管理 Spring Boot 容器
- en: Cloud Native Buildpacks lets you containerize Spring Boot applications quickly
    and efficiently without writing a Dockerfile yourself. But when it comes to running
    multiple containers, the Docker CLI can be a bit cumbersome. Writing commands
    in a Terminal window can be error-prone, hard to read, and challenging when it
    comes to applying version control.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Native Buildpacks 允许您快速高效地将 Spring Boot 应用程序容器化，而无需自己编写 Dockerfile。但是，当涉及到运行多个容器时，Docker
    CLI 可能会有些繁琐。在终端窗口中编写命令可能会出错，难以阅读，而且在应用版本控制时也会遇到挑战。
- en: Docker Compose provides a better experience than the Docker CLI. Instead of
    a command line, you work with YAML files that describe which containers you want
    to run and their characteristics. With Docker Compose, you can define all the
    applications and services composing your system in one place, and you can manage
    their life cycles together.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 提供了比 Docker CLI 更好的体验。您不是使用命令行，而是使用描述您想要运行哪些容器及其特性的 YAML 文件。使用
    Docker Compose，您可以在一个地方定义组成系统的所有应用程序和服务，并可以一起管理它们的生命周期。
- en: In this section, you’ll configure the execution of the Catalog Service and PostgreSQL
    containers using Docker Compose. Then you’ll learn how to debug a Spring Boot
    application running within a container.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将配置使用 Docker Compose 执行 Catalog Service 和 PostgreSQL 容器的执行。然后，您将学习如何调试在容器中运行的
    Spring Boot 应用程序。
- en: If you have installed Docker Desktop for Mac or Docker Desktop for Windows,
    you already have Docker Compose installed. If you’re on Linux, visit the Docker
    Compose installation page at [www.docker.com](http://www.docker.com) and follow
    the instructions for your distribution. In any case, you can verify that Docker
    Compose is correctly installed by running the command docker-compose --version.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已安装 Docker Desktop for Mac 或 Docker Desktop for Windows，您已经安装了 Docker Compose。如果您使用的是
    Linux，请访问 Docker Compose 安装页面 [www.docker.com](http://www.docker.com)，并按照您发行版的说明进行操作。在任何情况下，您都可以通过运行命令
    docker-compose --version 来验证 Docker Compose 是否正确安装。
- en: 6.3.1 Using Docker Compose to manage the container life cycle
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 使用 Docker Compose 管理容器生命周期
- en: The Docker Compose syntax is very intuitive and self-explanatory. Often, it
    can be mapped one-to-one to Docker CLI arguments. The two root sections of a docker-compose.yml
    file are version, where you specify which syntax of Docker Compose you want to
    use, and services, containing the specifications for all the containers you want
    to run. Other optional root-level sections you may add are volumes and networks.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 的语法非常直观且易于理解。通常，它可以与 Docker CLI 参数一一对应。docker-compose.yml 文件的两个根部分是
    version，其中您指定要使用 Docker Compose 的哪个语法，以及 services，包含您想要运行的所有容器的规范。您还可以添加其他可选的根级部分，如
    volumes 和 networks。
- en: Note If you don’t add any network configuration, Docker Compose will automatically
    create one for you and make all the containers in the file join it. That means
    they can interact with each other through their container names, relying on Docker’s
    built-in DNS server.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您不添加任何网络配置，Docker Compose 将自动为您创建一个，并将文件中的所有容器连接到它。这意味着它们可以通过容器名称相互交互，依赖于
    Docker 内置的 DNS 服务器。
- en: It’s good practice to gather all deployment-related scripts in a separate codebase
    and, possibly, in a separate repository. Go ahead and create a new polar-deployment
    repository on GitHub. It’ll contain all the Docker and Kubernetes scripts needed
    to run the applications composing the Polar Bookshop system. Inside the repository,
    create a “docker” folder to host the Docker Compose configuration for Polar Bookshop.
    In the source code accompanying the book, you can refer to Chapter06/06-end/ polar-deployment
    for the final result.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有与部署相关的脚本收集到一个单独的代码库中，并在可能的情况下，到一个单独的仓库中，这是一种良好的做法。继续在GitHub上创建一个新的polar-deployment仓库。它将包含运行Polar
    Bookshop系统所需的所有Docker和Kubernetes脚本。在仓库内部，创建一个“docker”文件夹来托管Polar Bookshop的Docker
    Compose配置。在本书的源代码中，你可以参考Chapter06/06-end/ polar-deployment以获取最终结果。
- en: In the polar-deployment/docker folder, create a docker-compose.yml file, and
    define the services to run as follows.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在polar-deployment/docker文件夹中，创建一个docker-compose.yml文件，并定义如下要运行的服务。
- en: Listing 6.7 Docker Compose file describing the catalog services
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.7描述目录服务的Docker Compose文件
- en: '[PRE29]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ The Docker Compose syntax version
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Docker Compose语法版本
- en: ❷ The section containing all the containers to run
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 包含所有要运行容器的部分
- en: ❸ The section describing the catalog-service container
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 描述目录服务容器的部分
- en: ❹ Catalog Service should start after the PostgreSQL database.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 目录服务应该在PostgreSQL数据库启动后启动。
- en: ❺ The image used to run the container
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 运行容器的镜像
- en: ❻ The name of the container
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 容器的名称
- en: ❼ The section listing the port mappings
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 列出端口映射的部分
- en: ❽ The section listing the environment variables
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 列出环境变量的部分
- en: ❾ A Paketo Buildpacks environment variable to configure the number of threads
    for memory calculation
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 一个Paketo Buildpacks环境变量，用于配置内存计算的线程数
- en: ❿ Enables the “testdata” Spring profile
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 启用“testdata”Spring配置文件
- en: ⓫ The section describing the polar-postgres container
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 描述polar-postgres容器的部分
- en: You might have noticed the presence of an additional environment variable for
    the Catalog Service container. In chapter 15, you’ll learn about the Java memory
    calculator provided by Paketo Buildpacks and how to configure CPU and memory for
    Spring Boot applications. For now, it’s enough to know that the BPL_JVM_THREAD_COUNT
    environment variable is used to configure the number of threads memory should
    be allocated for in the JVM stack. The default value for Servlet-based applications
    is 250\. In chapter 3, we used a low value for the Tomcat thread pool, and it’s
    good to do the same for the JVM memory configuration to keep the container’s memory
    usage low locally. You’re going to deploy many containers throughout the book
    (both applications and backing services), and such configuration helps make that
    possible without overloading your computer.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到目录服务容器存在一个额外的环境变量。在第15章，你将学习到Paketo Buildpacks提供的Java内存计算器以及如何为Spring
    Boot应用程序配置CPU和内存。现在，只需知道BPL_JVM_THREAD_COUNT环境变量用于配置在JVM堆栈中分配的线程数。基于Servlet的应用程序的默认值是250。在第3章，我们为Tomcat线程池使用了低值，对于JVM内存配置来说，这样做同样好，以保持本地容器内存使用量低。你将在本书中部署许多容器（包括应用程序和后端服务），这样的配置有助于在不超载你的计算机的情况下实现这一点。
- en: Docker Compose configures both containers on the same network by default, so
    you don’t need to specify one explicitly, as you did previously.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose默认将两个容器配置在同一个网络中，因此你不需要明确指定，就像之前做的那样。
- en: 'Let’s see now how to spin them up. Open a Terminal window, navigate to the
    folder containing the file, and run the following command to start the containers
    in detached mode:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何启动它们。打开一个终端窗口，导航到包含文件的文件夹，并运行以下命令以在分离模式下启动容器：
- en: '[PRE30]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When the command is done, try calling the Catalog Service application at http://
    localhost:9001/books and verify that it works correctly. Then keep your containers
    running and move on to the next section, where you’ll debug the Catalog Service
    application.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 命令完成后，尝试调用位于http://localhost:9001/books的目录服务应用，并验证其是否正确工作。然后保持容器运行，继续下一部分，在那里你将调试目录服务应用。
- en: 6.3.2 Debugging Spring Boot containers
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 调试Spring Boot容器
- en: When running a Spring Boot application as standard Java from your IDE, you can
    specify whether you want to run it in debug mode. If you do, the IDE will attach
    a debugger to the local Java process running your application. However, when you
    run it from within a container, your IDE can’t do that anymore because the process
    is not running on the local machine.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从您的IDE中以标准Java方式运行Spring Boot应用程序时，您可以指定是否希望以调试模式运行。如果您这样做，IDE将附加一个调试器到运行您应用程序的本地Java进程。然而，当您在容器内运行它时，您的IDE就不再能这样做，因为进程不是在本地机器上运行的。
- en: Fortunately, Spring Boot applications running in a container can be debugged
    almost as easily as when running locally. First you need to instruct the JVM inside
    the container to listen for debug connections on a specific port. The container
    image produced by Paketo Buildpacks supports dedicated environment variables for
    running the application in debug mode (BPL_DEBUG_ENABLED and BPL_DEBUG_PORT).
    Then you need to expose the debug port outside the container so that your IDE
    can reach it. Figure 6.13 illustrates how it works.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在容器中运行的Spring Boot应用程序可以像本地运行一样轻松地进行调试。首先，您需要指示容器内的JVM在特定端口上监听调试连接。由Paketo
    Buildpacks生成的容器镜像支持运行应用程序在调试模式下的专用环境变量（BPL_DEBUG_ENABLED和BPL_DEBUG_PORT）。然后，您需要将调试端口暴露在容器外部，以便您的IDE可以访问它。图6.13说明了它是如何工作的。
- en: '![06-13](../Images/06-13.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![06-13](../Images/06-13.png)'
- en: Figure 6.13 From a container, you can expose as many ports as you want. For
    Catalog Service, expose both the server port and the debug port.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 从容器中，您可以暴露您想要的任何数量的端口。对于Catalog Service，暴露服务器端口和调试端口。
- en: Next, update your docker-compose.yml file to configure the Catalog Service application
    for debugging.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新您的docker-compose.yml文件以配置Catalog Service应用程序进行调试。
- en: Listing 6.8 Configuring Catalog Service to run in debug mode
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8 配置Catalog Service以在调试模式下运行
- en: '[PRE31]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ The port where the JVM will listen for debug connections
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ JVM将监听调试连接的端口
- en: ❷ Activates the JVM configuration for accepting debug connections (provided
    by Buildpacks)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 激活JVM配置以接受调试连接（由Buildpacks提供）
- en: ❸ Debug connections are accepted via a socket on port 8001 (provided by Buildpacks).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过端口8001上的套接字（由Buildpacks提供）接受调试连接。
- en: 'From a Terminal window, navigate to the folder where the docker-compose.yml
    file is located, and rerun the following command:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端窗口导航到docker-compose.yml文件所在的文件夹，并重新运行以下命令：
- en: '[PRE32]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You’ll notice that Docker Compose is smart enough to know that the PostgreSQL
    container configuration is unchanged, and it will do nothing about it. Instead,
    it will reload the Catalog Service container with the new configuration.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到Docker Compose足够智能，能够知道PostgreSQL容器配置没有改变，因此它对此不会采取任何行动。相反，它将使用新的配置重新加载Catalog
    Service容器。
- en: Then, in your IDE of choice, you need to configure a remote debugger and point
    it to port 8001. Refer to your IDE’s documentation to find the instructions on
    how to do that. Figure 6.14 shows how to configure a remote debugger in IntelliJ
    IDEA.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您选择的IDE中，您需要配置一个远程调试器并将其指向端口8001。请参考您IDE的文档以找到如何操作的说明。图6.14展示了如何在IntelliJ
    IDEA中配置远程调试器。
- en: '![06-14](../Images/06-14.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![06-14](../Images/06-14.png)'
- en: Figure 6.14 Configuration to debug a containerized Java application from IntelliJ
    IDEA
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 从IntelliJ IDEA调试容器化Java应用程序的配置
- en: Once you run the Catalog Service, you can debug it as though it were running
    locally.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行了Catalog Service，您就可以像它本地运行一样对其进行调试。
- en: 'That’s it for this section. You can stop and remove both containers with the
    following command from the same folder where you keep your docker-compose.yml
    file:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 本节到此结束。您可以使用以下命令从保存docker-compose.yml文件的同一文件夹停止并删除两个容器：
- en: '[PRE33]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note In this book I’m only covering those Docker topics needed in your journey
    to successfully deploy Spring Boot applications in production with Kubernetes.
    If you’re interested in learning more about Docker images, networks, volumes,
    security, and architecture, refer to the official documentation on [https://docs.docker.com](https://docs.docker.com).
    Also, Manning has a few books in its catalog on the subject, such as *Learn Docker
    in a Month of Lunches* by Elton Stoneman (Manning, 2020) and *Docker in Practice*,
    second edition, by Ian Miell and Aidan Hobson Sayers (Manning, 2019).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这本书中，我只涵盖你在成功部署Spring Boot应用程序到生产环境中所需的Docker主题。如果你对学习更多关于Docker镜像、网络、卷、安全和架构感兴趣，请参阅[https://docs.docker.com](https://docs.docker.com)上的官方文档。此外，Manning在其目录中也有几本关于该主题的书籍，例如Elton
    Stoneman的《一个月午餐时间学习Docker》（Manning，2020年）和Ian Miell和Aidan Hobson Sayers的《实践Docker》（第二版，Manning，2019年）。
- en: When you make changes to an application, you don’t want to build and publish
    a new image manually. That’s a job for an automated workflow engine like GitHub
    Actions. The following section will show you how to complete the commit stage
    of the deployment pipeline we started in chapter 3\.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对应用程序进行更改时，你不想手动构建和发布新的镜像。这是一个自动化工作流引擎（如GitHub Actions）的工作。下一节将向您展示如何完成我们在第3章中开始的部署管道的提交阶段。
- en: '6.4 Deployment pipeline: Package and publish'
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 部署管道：打包和发布
- en: 'In chapter 3, we started implementing a deployment pipeline to support continuous
    delivery for the Polar Bookshop project. Continuous delivery is a holistic engineering
    approach for quickly, reliably, and safely delivering high-quality software. The
    deployment pipeline is the primary pattern for automating the entire journey from
    code commit to releasable software. We identified three main stages for the deployment
    pipeline: commit stage, acceptance stage, and production stage.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们开始实施一个部署管道来支持Polar Bookshop项目的持续交付。持续交付是一种全面的工程方法，旨在快速、可靠和安全地交付高质量的软件。部署管道是从代码提交到可发布软件的整个旅程自动化的主要模式。我们确定了部署管道的三个主要阶段：提交阶段、验收阶段和生产阶段。
- en: We’ll continue focusing on the commit stage. After a developer commits new code
    to the mainline, this stage goes through build, unit tests, integration tests,
    static code analysis, and packaging. At the end of this stage, an executable application
    artifact is published to an artifact repository. That is a *release candidate*.
    Chapter 3 covered all the main steps except for the final packaging and publishing
    of a release candidate. That’s what you’ll see in this section.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续关注提交阶段。在开发人员将新代码提交到主线后，这个阶段将经过构建、单元测试、集成测试、静态代码分析和打包。在这个阶段的最后，一个可执行的应用程序工件被发布到一个工件仓库。这是一个*发布候选者*。第3章涵盖了所有主要步骤，除了发布候选者的最终打包和发布。这就是你将在本节中看到的内容。
- en: 6.4.1 Building release candidates in the commit stage
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 在提交阶段构建发布候选
- en: After running static code analysis, compilation, unit tests, and integration
    tests, it’s time to package the application as an executable artifact and publish
    it. In our case, the executable artifact is a container image that we’ll publish
    to a container registry.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行静态代码分析、编译、单元测试和集成测试之后，是时候将应用程序打包成一个可执行工件并发布它了。在我们的案例中，可执行工件是一个容器镜像，我们将将其发布到一个容器注册库。
- en: An essential idea in continuous delivery, also present in the 15-Factor methodology,
    is that you should build artifacts only once. At the end of the commit stage,
    we’ll produce a container image that we can reuse in any following stage in the
    deployment pipeline up to production. If the pipeline proves something is wrong
    (a test fails) at any point, the release candidate is rejected. If the release
    candidate goes through all subsequent stages successfully, it’s proven to be ready
    for deployment in production.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付的一个基本理念，也存在于15个要素方法中，就是你应该只构建一次工件。在提交阶段结束时，我们将生成一个容器镜像，我们可以在部署管道的任何后续阶段（直到生产阶段）重复使用。如果管道在任何一点证明有错误（测试失败），则发布候选者将被拒绝。如果发布候选者成功通过所有后续阶段，则证明其已准备好在生产中部署。
- en: After we build an executable artifact, we can perform additional operations
    before publishing it. For example, we could scan it for vulnerabilities. That’s
    what we’re going to do with grype, much as we did for the codebase. A container
    image includes application libraries but also system libraries that were not included
    in the previous security analysis. That’s why we need to scan both the codebase
    and the artifact for vulnerabilities. Figure 6.15 illustrates the new steps we
    will add to the commit stage for building and publishing a release candidate.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建了一个可执行的工件之后，我们可以在发布之前执行额外的操作。例如，我们可以扫描它以查找漏洞。这正是我们将使用grype所做的事情，就像我们对代码库所做的那样。容器镜像包括应用程序库，但也包括之前安全分析中未包含的系统库。这就是为什么我们需要扫描代码库和工件以查找漏洞。图6.15说明了我们将添加到提交阶段以构建和发布候选版本的新步骤。
- en: '![06-15](../Images/06-15.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![06-15](../Images/06-15.png)'
- en: Figure 6.15 At the end of the commit stage, a release candidate is published
    to an artifact repository. In this case, a container image is published to a container
    registry.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 在提交阶段结束时，候选版本被发布到一个工件仓库中。在这种情况下，容器镜像被发布到一个容器注册库中。
- en: Once a release candidate is published, several parties can download it and use
    it, including the next stages in the deployment pipeline. How can we ensure that
    all interested parties use a legitimate container image from the Polar Bookshop
    project, and not one that has been compromised? We can achieve that by signing
    the image. After the publishing step, we could add a new step for signing the
    release candidate. For example, we could use Sigstore ([www.sigstore.dev](http://www.sigstore.dev)),
    a non-profit service that provides open source tools for signing, verifying, and
    protecting software integrity. If you’re interested in this subject, I recommend
    visiting the project’s website.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦候选版本发布，多个方可以下载并使用它，包括部署管道中的下一阶段。我们如何确保所有感兴趣的各方都使用来自Polar Bookshop项目的合法容器镜像，而不是一个已被破坏的镜像？我们可以通过签名镜像来实现这一点。在发布步骤之后，我们可以添加一个新的步骤来签名候选版本。例如，我们可以使用Sigstore
    ([www.sigstore.dev](http://www.sigstore.dev))，这是一个非营利性服务，它为签名、验证和保护软件完整性提供开源工具。如果您对这个主题感兴趣，我建议您访问该项目的网站。
- en: In the following section, I’ll show you how to implement the new steps in the
    commit stage of our deployment pipeline.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将向您展示如何在我们的部署管道的提交阶段实现新步骤。
- en: 6.4.2 Publishing container images with GitHub Actions
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 使用GitHub Actions发布容器镜像
- en: GitHub Actions is an engine that you can use to automate software workflows
    directly from your GitHub repositories. Workflow definitions are conventionally
    stored in a .github/workflows directory placed in the root of a repository on
    GitHub.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions是一个引擎，您可以直接从您的GitHub仓库自动化软件工作流程。工作流程定义通常存储在GitHub仓库根目录下的.github/workflows目录中。
- en: In chapter 3, we started developing a workflow to implement the commit stage
    of the deployment pipeline for Catalog Service. Let’s now continue the implementation
    by adding further steps to package and publish the application.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们开始开发一个工作流程以实现目录服务的部署管道的提交阶段。现在，让我们通过添加进一步步骤来打包和发布应用程序来继续实施。
- en: From your Catalog Service project (catalog-service), open the workflow definition
    for the commit stage (.github/workflows/commit-stage.yml) and define a few environment
    variables to store some essential facts you’ll need when building a container
    image for the application. By using environment variables, you can easily change
    which container registry you use or the version for the release artifact. Remember
    to add your GitHub username, all in lowercase, instead of the placeholder in the
    following listing. Chapter 15 will cover software release strategies, but until
    then we’re going to tag every image with latest instead of a version number.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的目录服务项目（catalog-service）中打开提交阶段的工作流程定义（.github/workflows/commit-stage.yml），并定义一些环境变量以存储在构建应用程序容器镜像时所需的某些基本事实。通过使用环境变量，您可以轻松地更改您使用的容器注册库或发布工件版本。请记住，在以下列表中，用您的GitHub用户名全部小写替换占位符。第15章将涵盖软件发布策略，但在此之前，我们将用最新标签而不是版本号来标记每个镜像。
- en: Listing 6.9 Configuring facts about the release candidate
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.9 配置候选版本的详细信息
- en: '[PRE34]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Uses the GitHub Container Registry
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用GitHub容器注册库
- en: ❷ The name of the image. Remember to add your GitHub username, all in lowercase.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 图像的名称。请记住，要将您的GitHub用户名全部小写添加进去。
- en: ❸ For the moment, any new image will be tagged as “latest”.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 目前，任何新的镜像都将被标记为“latest”。
- en: Next let’s add a new “Package and Publish” job to the workflow. If the “Build
    and Test” job completes successfully, and the workflow runs on the main branch,
    the new job will be executed. We’ll use the same strategy we used locally to package
    Catalog Service as a container image, relying on the Buildpacks integration provided
    by the Spring Boot Gradle plugin. Notice that we are not pushing the image directly.
    That’s because we first want to scan the image for vulnerabilities, which we’ll
    do in a moment. For now, update the commit-stage.yml file as follows.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们向工作流程中添加一个新的“打包和发布”作业。如果“构建和测试”作业成功完成，并且工作流程在主分支上运行，则新作业将被执行。我们将使用与本地相同的策略将
    Catalog Service 打包为容器镜像，依赖于 Spring Boot Gradle 插件提供的 Buildpacks 集成。请注意，我们不会直接推送镜像。这是因为我们首先想要扫描镜像中的漏洞，我们将在稍后进行。现在，按照以下方式更新
    commit-stage.yml 文件。
- en: Listing 6.10 Packaging the application as an OCI image using Buildpacks
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.10 使用 Buildpacks 将应用程序打包为 OCI 镜像
- en: '[PRE35]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ The job’s unique identifier
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 作业的唯一标识符
- en: ❷ Runs the job only on the main branch
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 仅在主分支上运行作业
- en: ❸ Runs the job only if the “build” job completes successfully
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 仅当“构建”作业成功完成时运行作业
- en: ❹ Runs the job on an Ubuntu 22.04 machine
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在 Ubuntu 22.04 机器上运行作业
- en: ❺ Permission to check out the current Git repository
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 允许检出当前的 Git 仓库
- en: ❻ Permission to upload images to GitHub Container Registry
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 允许上传镜像到 GitHub 容器注册表
- en: ❼ Permission to submit security events to GitHub
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 允许提交安全事件到 GitHub
- en: ❽ Checks out the current Git repository (catalog-service)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 检出当前的 Git 仓库（catalog-service）
- en: ❾ Installs and configures a Java runtime
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 安装和配置 Java 运行时
- en: ❿ Relies on the Buildpacks integration in Spring Boot to build a container image
    and defines the name for the release candidate
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 依赖于 Spring Boot 中的 Buildpacks 集成来构建容器镜像，并为发布候选版本定义名称
- en: After packaging the application as a container image, let’s update the commit-stage.yml
    file to use grype to scan the image for vulnerabilities and publish a report to
    GitHub, similar to what we did in chapter 3\. Finally, we can authenticate with
    the container registry and push the image representing our release candidate.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在将应用程序打包为容器镜像后，让我们更新 commit-stage.yml 文件以使用 grype 扫描镜像中的漏洞并将报告发布到 GitHub，类似于我们在第
    3 章中所做的。最后，我们可以使用容器注册表进行身份验证并推送代表我们的发布候选版本的镜像。
- en: Listing 6.11 Scanning the image for vulnerabilities and publishing it
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.11 扫描镜像中的漏洞并发布
- en: '[PRE36]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Scans the release candidate image for vulnerabilities using grype
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 grype 扫描发布候选镜像以查找漏洞
- en: ❷ The image to scan is the release candidate.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 扫描的镜像为发布候选版本
- en: ❸ It won’t fail the build if vulnerabilities are found in the image.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果镜像中发现漏洞，它不会使构建失败。
- en: ❹ Uploads the security vulnerability report to GitHub (SARIF format)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将安全漏洞报告上传到 GitHub（SARIF 格式）
- en: ❺ Authenticates with GitHub Container Registry
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用 GitHub 容器注册表进行身份验证
- en: ❻ The registry value as defined in the environment variable earlier
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在之前定义的环境变量中定义的注册表值
- en: ❼ The GitHub username of the current user, provided by GitHub Actions
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 当前用户的 GitHub 用户名，由 GitHub Actions 提供
- en: ❽ The token needed to authenticate with the registry, provided by GitHub Actions
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 用于与注册表进行身份验证的令牌，由 GitHub Actions 提供
- en: ❾ Pushes the release candidate to the registry
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 将发布候选版本推送到注册表
- en: In listing 6.11 we do not fail the workflow if serious vulnerabilities are discovered.
    However, you can find the scanning results in the Security section of your catalog-service
    GitHub repository. At the time of writing, no high or critical vulnerabilities
    are found in the Catalog Service project, but things might be different in the
    future. As already mentioned in chapter 3, in a real-world scenario, I recommend
    that you configure and tune grype carefully and according to your company’s policies
    regarding supply chain security, and make the workflow fail if the result is not
    compliant (setting the fail-build property to true). For more information, refer
    to the official grype documentation ([https://github.com/anchore/grype](https://github.com/anchore/grype)).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 6.11 中，如果发现严重漏洞，我们不会使工作流程失败。然而，您可以在 catalog-service GitHub 仓库的安全部分找到扫描结果。在撰写本文时，在
    Catalog Service 项目中没有发现高或关键漏洞，但未来可能会有所不同。正如第 3 章中提到的，在现实场景中，我建议您根据公司关于供应链安全的政策仔细配置和调整
    grype，并在结果不符合规范时使工作流程失败（将 fail-build 属性设置为 true）。有关更多信息，请参阅官方 grype 文档（[https://github.com/anchore/grype](https://github.com/anchore/grype)）。
- en: After completing the commit stage of the deployment pipeline, make sure your
    catalog-service GitHub repository is public. Then push your changes to the main
    branch of your remote repository, and see the workflow execution results in the
    Actions tab.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成部署管道的提交阶段后，确保你的 catalog-service GitHub 仓库是公开的。然后，将你的更改推送到远程仓库的主分支，并在“操作”选项卡中查看工作流程执行结果。
- en: Warning The action of uploading the vulnerability report requires the GitHub
    repository to be public. It works for private repositories only if you have an
    enterprise subscription. If you prefer to keep your repository private, you’ll
    need to skip the “Upload vulnerability report” step. Throughout the book, I’ll
    assume all the repositories you create on GitHub for the Polar Bookshop project
    are public.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：上传漏洞报告的操作需要 GitHub 仓库是公开的。如果你有企业订阅，它仅适用于私有仓库。如果你更喜欢保持你的仓库私有，你需要跳过“上传漏洞报告”步骤。在整个书中，我将假设你为
    Polar Bookshop 项目在 GitHub 上创建的所有仓库都是公开的。
- en: Images published from GitHub Actions and named after a repository are automatically
    associated. After the workflow completes its execution, you’ll find a Packages
    section in the sidebar of your GitHub catalog-service repository’s main page,
    with a “catalog-service” item (figure 6.16). Click on that item, and you’ll be
    directed to the container image repository for Catalog Service.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 GitHub Actions 并以存储库命名的图像将自动关联。工作流程执行完成后，你会在 GitHub catalog-service 仓库主页的侧边栏中找到一个“catalog-service”项目（图
    6.16）。点击该项目，你将被引导到 Catalog 服务的容器镜像仓库。
- en: '![06-16](../Images/06-16.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![06-16](../Images/06-16.png)'
- en: Figure 6.16 When using the GitHub Container Registry, you can store container
    images next to the source code.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 当使用 GitHub 容器注册库时，你可以将容器镜像存储在源代码旁边。
- en: Note Images published to GitHub Container Registry will have the same visibility
    as the related GitHub code repository. If no repository is associated with the
    image, it’s private by default. Throughout the book I’ll assume that all the images
    you build for Polar Bookshop are publicly accessible via the GitHub Container
    Registry. If that’s not the case, you can go to the package’s main page, select
    Package Settings from the sidebar menu, scroll to the bottom of the settings page,
    and make the package public by clicking the Change Visibility button.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：发布到 GitHub 容器注册库的图像将与相关的 GitHub 代码仓库具有相同的可见性。如果没有与图像关联的存储库，则默认为私有。在整个书中，我将假设你为
    Polar Bookshop 构建的图像都可以通过 GitHub 容器注册库公开访问。如果不是这样，你可以转到包的主页，从侧边栏菜单中选择“包设置”，滚动到设置页面的底部，通过点击“更改可见性”按钮使包公开。
- en: Great job! So far you’ve built a Spring Boot application that exposes a REST
    API and interacts with a relational database; you wrote unit and integration tests
    for the application; you handled the database schema with Flyway so it was production-ready;
    and you ran everything within containers and dealt with image generation, Docker,
    Cloud Native Buildpacks, and vulnerability scanning. The next chapter will complete
    the first part of this cloud native journey toward production by diving deep into
    Kubernetes. But before moving on, take a break, congratulate yourself on what
    you have achieved so far, and perhaps celebrate with a beverage of your choice.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！到目前为止，你已经构建了一个暴露 REST API 并与关系型数据库交互的 Spring Boot 应用程序；你为应用程序编写了单元和集成测试；你使用
    Flyway 处理数据库模式，使其准备好生产环境；你将所有内容都在容器中运行，并处理了镜像生成、Docker、Cloud Native Buildpacks
    和漏洞扫描。下一章将通过深入研究 Kubernetes 来完成这一云原生之旅的第一部分。但在继续之前，休息一下，为自己到目前为止所取得的成就表示祝贺，也许还可以喝上一杯你喜欢的饮料。
- en: Polar Labs
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Polar Labs
- en: Feel free to apply what you’ve learned in this chapter to Config Service.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 随意将本章学到的知识应用到 Config 服务上。
- en: Configure the Cloud Native Buildpacks integration and package the application
    as a container.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Cloud Native Buildpacks 集成并将应用程序打包为容器。
- en: Update your Docker Compose file to run Config Service as a container.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的 Docker Compose 文件以运行 Config 服务作为容器。
- en: Configure Catalog Service with the Config Service URL via the SPRING_CLOUD_CONFIG_URI
    environment variable, relying on the Docker built-in DNS.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 SPRING_CLOUD_CONFIG_URI 环境变量使用 Config 服务 URL 配置 Catalog 服务，依赖于 Docker 内置的
    DNS。
- en: Bootstrap a deployment pipeline for Config Service by implementing the workflow
    for the commit stage using GitHub Actions.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 GitHub Actions 实现提交阶段的流程，为 Config 服务启动部署管道。
- en: You can refer to the Chapter06/06-end folder in the code repository accompanying
    the book to see the final result ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考书中附带的代码仓库中的Chapter06/06-end文件夹，以查看最终结果（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)）。
- en: Summary
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Container images are lightweight executable packages that include everything
    needed to run the application inside.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像是一种轻量级的可执行包，包含运行应用程序所需的所有内容。
- en: Each image is made up of several layers, and each layer represents a modification
    produced by the corresponding instruction. The final artifact can be run as a
    container.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个镜像由多个层组成，每一层代表由相应指令产生的修改。最终工件可以作为容器运行。
- en: When you run a container, an additional writable layer is added on top of the
    image layers.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您运行容器时，会在镜像层之上添加一个额外的可写层。
- en: The standard way to define a container image is by listing the sequence of instructions
    in a particular file called a Dockerfile.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义容器镜像的标准方式是通过列出特定文件（称为Dockerfile）中的指令序列。
- en: A Dockerfile acts as a recipe containing all the steps to build the desired
    image.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile充当一个配方，包含构建所需镜像的所有步骤。
- en: Performance and security are important concerns when building container images.
    For example, you shouldn’t store secrets in any image layer, and never run the
    container with a root user.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能和安全是构建容器镜像时的重要关注点。例如，您不应该在任何镜像层中存储机密，并且永远不要以root用户运行容器。
- en: A container registry is to OCI images what a Maven repository is to Java libraries.
    Examples of container registries are Docker Hub and GitHub Container Registry.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器注册库对于OCI镜像来说，就像Maven仓库对于Java库来说一样。容器注册库的例子包括Docker Hub和GitHub Container Registry。
- en: You can package Spring Boot applications as container images in different ways.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以用不同的方式将Spring Boot应用程序打包为容器镜像。
- en: Dockerfiles give you maximum flexibility but make it your responsibility to
    configure everything you need.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile提供了最大的灵活性，但需要您负责配置所需的一切。
- en: Cloud Native Buildpacks (integrated with the Spring Boot Plugin) let you build
    OCI images directly from the source code, optimizing security, performance, and
    storage for you.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloud Native Buildpacks（与Spring Boot插件集成）让您可以直接从源代码构建OCI镜像，为您优化安全性、性能和存储。
- en: When you run Spring Boot applications as containers, you should consider which
    ports you want to make available to the outside world (such as 8080) and whether
    containers should communicate with each other. If yes, you can use the Docker
    DNS server to contact containers in the same network by container name instead
    of IP or hostname.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您以容器形式运行Spring Boot应用程序时，您应该考虑您想要向外界开放哪些端口（例如8080），以及容器是否应该相互通信。如果是的话，您可以使用Docker
    DNS服务器通过容器名称而不是IP或主机名来联系同一网络中的容器。
- en: If you want to debug an application running as a container, remember to expose
    the debug port.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想调试作为容器运行的应用程序，请记住要公开调试端口。
- en: Docker Compose is a client for interacting with the Docker server, and it provides
    a better user experience than Docker CLI. From a YAML file, you can manage all
    your containers.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose是用于与Docker服务器交互的客户端，它提供了比Docker CLI更好的用户体验。从YAML文件中，您可以管理所有容器。
- en: You can use GitHub Actions to automate the process of packaging an application
    as a container image, scanning it for vulnerabilities, and publishing it to a
    container registry. That’s part of the commit stage of a deployment pipeline.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用GitHub Actions来自动化将应用程序打包为容器镜像、扫描漏洞并将其发布到容器注册库的过程。这是部署管道的提交阶段的一部分。
- en: The outcome of the commit stage of a deployment pipeline is a release candidate.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署管道的提交阶段的输出是一个发布候选版本。
