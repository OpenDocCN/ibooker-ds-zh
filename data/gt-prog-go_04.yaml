- en: Unit 4\. Collections
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元 4\. 集合
- en: '*Collections* are just groups of things. You probably have a music collection.
    Each album has a collection of songs, and each song has a collection of musical
    notes. If you want to build a music player, you’ll be happy to know that programming
    languages have collections too.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合*只是事物的组合。你可能有一个音乐收藏。每张专辑有一组歌曲，每首歌曲有一组音符。如果你想要构建一个音乐播放器，你会很高兴地知道编程语言也有集合。'
- en: In Go, you can use the primitive types covered in [unit 2](kindle_split_015.html#part03)
    to compose more interesting *composite types*. These composite types allow you
    to group values together, providing new ways to collect and access data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，你可以使用 [单元 2](kindle_split_015.html#part03) 中介绍的原始类型来组合更有趣的 *复合类型*。这些复合类型允许你将值组合在一起，提供新的收集和访问数据的方式。
- en: Lesson 16\. Arrayed in splendor
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 16 课\. 星光熠熠
- en: After reading [lesson 16](#ch16), you’ll be able to
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读 [第 16 课](#ch16) 之后，你将能够
- en: Declare and initialize arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明和初始化数组
- en: Assign and access the elements of an array
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配和访问数组的元素
- en: Iterate through arrays
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历数组
- en: '*Arrays* are ordered collections of elements with a fixed length. This lesson
    uses arrays to store the names of planets and dwarf planets in our solar system,
    but you can collect anything you like.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组*是有序元素集合，具有固定长度。本课使用数组来存储我们太阳系中行星和矮行星的名称，但你也可以收集任何你喜欢的。'
- en: '|  |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Do you have a collection or did you in the past? Maybe stamps, coins, stickers,
    books, shoes, trophies, movies, or something else?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你有收藏品吗？或者你过去有吗？可能是邮票、硬币、贴纸、书籍、鞋子、奖杯、电影或其他东西？
- en: Arrays are for collecting many of the same type of thing. What collections could
    you represent with an array?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数组用于收集许多相同类型的事物。你可以用数组表示哪些集合？
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 16.1\. Declaring arrays and accessing their elements
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1\. 声明数组和访问它们的元素
- en: 'The following `planets` array contains exactly eight elements:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `planets` 数组恰好包含八个元素：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Every element of an array has the same type. In this case, `planets` is an array
    of strings.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的每个元素都具有相同的类型。在这种情况下，`planets` 是一个字符串数组。
- en: Individual elements of an array can be accessed by using square brackets `[]`
    with an index that begins at 0, as illustrated in [figure 16.1](#ch16fig01) and
    shown in [listing 16.1](#ch16ex01).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用方括号 `[]` 并以 0 开始的索引来访问数组的单个元素，如图 16.1 所示，并在列表 16.1 中展示。
- en: 'Listing 16.1\. Array of planets: array.go'
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.1\. 行星数组：array.go
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Assigns a planet at index 0**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 分配索引 0 处的行星**'
- en: '***2* Retrieves the planet at index 2**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取索引 2 处的行星**'
- en: '***3* Prints Earth**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印地球**'
- en: Figure 16.1\. Planets with indices 0 through 7
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 16.1\. 索引从 0 到 7 的行星
- en: '![](16fig01_alt.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](16fig01_alt.jpg)'
- en: 'Even though only three planets have been assigned, the `planets` array has
    eight elements. The length of an array can be determined with the built-in `len`
    function. The other elements contain the zero value for their type, an empty string:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管只有三个行星被分配，但 `planets` 数组有八个元素。数组的长度可以使用内置的 `len` 函数确定。其他元素包含它们类型的零值，即空字符串：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Prints 8**'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 8**'
- en: '***2* Prints true**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 true**'
- en: '|  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Go has a handful of built-in functions that don’t require an `import` statement.
    The `len` function can determine the length for a variety of types. In this case
    it returns the size of the array.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言有一些内置函数不需要 `import` 语句。`len` 函数可以确定多种类型的长度。在这种情况下，它返回数组的尺寸。
- en: '|  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 16.1**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 16.1**'
- en: '**[1](#ch16qa2q0a1)**'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch16qa2q0a1)**'
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How do you access the first element of the `planets` array?
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你如何访问 `planets` 数组的第一个元素？
- en: '**[2](#ch16qa2q0a2)**'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch16qa2q0a2)**'
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the default value for elements of a new array of integers?
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 新整数数组的元素默认值是什么？
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 16.1 answer**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 16.1 答案**'
- en: '**[1](#ch16qa1q1)**'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch16qa1q1)**'
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`planets[0]`'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`planets[0]`'
- en: '**[2](#ch16qa1q2)**'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch16qa1q2)**'
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Elements of an array are initially the zero value for the array’s type, which
    means `0` for integer arrays.
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数组的元素最初是数组类型的零值，这意味着整数数组是 `0`。
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 16.2\. Don’t go out of bounds
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2\. 不要越界
- en: 'An eight-element array has indices from 0 through 7\. The Go compiler will
    report an error when it detects access to an element outside of this range:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 八元素数组具有从 0 到 7 的索引。当 Go 编译器检测到访问此范围之外的元素时，将报告错误：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Invalid array index 8 (out of bounds for 8-element array)**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无效的数组索引 8（超出 8 元素数组的范围）**'
- en: 'If the Go compiler is unable to detect the error, your program may *panic*
    while it’s running:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Go 编译器无法检测到错误，程序在运行时可能会发生 *panic*：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Panic: runtime error: index out of range**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Panic: 运行时错误：索引越界**'
- en: A panic will crash your program, which is still better than modifying memory
    that doesn’t belong to the `planets` array, leading to unspecified behavior (as
    is the case with the C programming language).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果修改不属于 `planets` 数组的内存，程序将发生 *panic* 并崩溃，这仍然比导致未指定行为（如 C 编程语言中的情况）要好。
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 16.2**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 16.2**'
- en: '**[Q1:](#ch16qa4q0a1)**'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch16qa4q0a1)**'
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Will `planets[11]` cause an error at compile-time or a panic at runtime?
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`planets[11]` 会在编译时引起错误还是在运行时发生 *panic*？'
- en: '|  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 16.2 answer**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 16.2 答案**'
- en: '**[1:](#ch16qa3q1)**'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch16qa3q1)**'
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Go compiler will detect an invalid array index.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Go 编译器将检测无效的数组索引。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 16.3\. Initialize arrays with composite literals
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3\. 使用组合字面量初始化数组
- en: A *composite literal* is a concise syntax to initialize any composite type with
    the values you want. Rather than declare an array and assign elements one by one,
    Go’s composite literal syntax will declare and initialize an array in a single
    step, as shown in the following listing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*组合字面量* 是一种简洁的语法，可以初始化任何复合类型，使用你想要的值。而不是声明一个数组并逐个分配元素，Go 的组合字面量语法将声明和初始化一个数组，如下面的列表所示。'
- en: 'Listing 16.2\. Array of dwarf planets: dwarfs.go'
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.2\. 小行星数组：dwarfs.go
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The curly braces `{}` contain five comma-separated strings to populate elements
    of the new array.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号 `{}` 包含五个以逗号分隔的字符串，用于填充新数组的元素。
- en: With larger arrays, breaking the composite literal across multiple lines can
    be more readable. And as a convenience, you can ask the Go compiler to count the
    number of elements in the composite literal by specifying the ellipsis `...` instead
    of a number. The `planets` array in the following listing still has a fixed length.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较大的数组，将组合字面量拆分到多行可以提高可读性。并且作为便利，你可以要求 Go 编译器通过指定省略号 `...` 而不是数字来计算组合字面量中的元素数量。以下列表中的
    `planets` 数组仍然具有固定长度。
- en: 'Listing 16.3\. A full array of planets: composite.go'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.3\. 行星的全数组：composite.go
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* The Go compiler counts the elements.**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Go 编译器会计算元素数量。**'
- en: '***2* The trailing comma is required.**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 需要尾随逗号。**'
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 16.3**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 16.3**'
- en: '**[Q1:](#ch16qa6q0a1)**'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch16qa6q0a1)**'
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many planets are there in [listing 16.3](#ch16ex03)? Use the len built-in
    function to find out.
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[列表 16.3](#ch16ex03) 中有多少颗行星？使用内置的 len 函数来找出答案。'
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 16.3 answer**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 16.3 答案**'
- en: '**[1:](#ch16qa5q1)**'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch16qa5q1)**'
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `planets` array has eight elements (`8`).
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`planets` 数组有八个元素（`8`）。'
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 16.4\. Iterating through arrays
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4\. 遍历数组
- en: Iterating through each element of an array is similar to iterating over each
    character of a string in [lesson 9](kindle_split_019.html#ch09), as shown in the
    following listing.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历数组的每个元素类似于在 [第 9 课](kindle_split_019.html#ch09) 中遍历字符串的每个字符，如下面的列表所示。
- en: 'Listing 16.4\. Looping through an array: array-loop.go'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.4\. 遍历数组：array-loop.go
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `range` keyword provides an index and value for each element of an array
    with less code and less chance for mistakes, as shown in the next listing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 关键字通过更少的代码和更少的错误机会为数组的每个元素提供一个索引和值，如下面的列表所示。'
- en: 'Listing 16.5\. Iterating through an array with `range`: array-range.go'
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.5\. 使用 `range` 遍历数组：array-range.go
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Both [listings 16.4](#ch16ex04) and [16.5](#ch16ex05) produce the same output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 16.4](#ch16ex04) 和 [16.5](#ch16ex05) 产生相同的输出：'
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that you can use the blank identifier (underscore) if you don’t need
    the index variable provided by `range`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你不需要 `range` 提供的索引变量，可以使用空白标识符（下划线）。
- en: '|  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 16.4**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 16.4**'
- en: '**[1](#ch16qa8q0a1)**'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch16qa8q0a1)**'
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What mistakes can be avoided by using the `range` keyword to iterate over an
    array?
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `range` 关键字遍历数组可以避免哪些错误？
- en: '**[2](#ch16qa8q0a2)**'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch16qa8q0a2)**'
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When would it be appropriate to use a conventional `for` loop instead of `range`?
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在什么情况下使用传统的 `for` 循环而不是 `range` 更合适？
- en: '|  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 16.4 answer**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 16.4 答案**'
- en: '**[1](#ch16qa7q1)**'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch16qa7q1)**'
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With the `range` keyword, the loop is simpler and avoids mistakes like going
    out of bounds (for example, `i <= len(dwarfs)`).
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `range` 关键字，循环更简单，避免了越界等错误（例如，`i <= len(dwarfs)`）。
- en: '**[2](#ch16qa7q2)**'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch16qa7q2)**'
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you need something custom, like iterating in reverse or accessing every second
    element.
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你需要自定义操作，比如反向迭代或访问每个第二个元素。
- en: '|  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 16.5\. Arrays are copied
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.5. 数组是复制的
- en: Assigning an array to a new variable or passing it to a function makes a complete
    copy of its contents, as you can see in the following listing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组分配给新变量或将它传递给函数会完全复制其内容，如下面的列表所示。
- en: 'Listing 16.6\. Arrays are values: array-value.go'
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.6. 数组是值：array-value.go
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Copies planets array**'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 复制行星数组**'
- en: '***2* Makes way for an interstellar bypass**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为星际 bypass让路**'
- en: '***3* Prints [Mercury Venus whoops Mars Jupiter Saturn Uranus Neptune]**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印[水星 金星 哗啦 火星 木星 土星 天王星 海王星]**'
- en: '***4* Prints [Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune]**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印[水星 金星 地球 火星 木星 土星 天王星 海王星]**'
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: In the event that you escape the destruction of Earth, you will want Go installed
    on your own computer. See the instructions at [golang.org](http://golang.org).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你逃离地球的毁灭，你将需要在你的电脑上安装Go。请参阅[golang.org](http://golang.org)上的说明。
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Arrays are values, and functions pass by value, which means the `terraform`
    function in the following listing is completely ineffective.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是值，函数通过值传递，这意味着以下列表中的`terraform`函数完全无效。
- en: 'Listing 16.7\. Arrays pass by value: terraform.go'
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.7. 数组按值传递：terraform.go
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Prints [Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune]**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印[水星 金星 地球 火星 木星 土星 天王星 海王星]**'
- en: The `terraform` function is operating on a copy of the `planets` array, so the
    modifications don’t affect `planets` in the `main` function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform`函数正在操作`planets`数组的副本，因此修改不会影响`main`函数中的`planets`。'
- en: 'Also, it’s important to recognize that the length of an array is part of its
    type. The type `[8]string` and type `[5]string` are both collections of strings,
    but they’re two different types. The Go compiler will report an error when attempting
    to pass an array of a different length:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重要的是要认识到数组的长度是其类型的一部分。类型`[8]string`和类型`[5]string`都是字符串集合，但它们是两种不同的类型。当尝试传递不同长度的数组时，Go编译器将报告错误：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Can’t use dwarfs (type [5]string) as type [8]string in argument to terraform**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 不能将矮人（类型[5]string）用作terraform的参数类型[8]string**'
- en: For these reasons, arrays aren’t used as function parameters nearly as often
    as *slices*, covered in the next lesson.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，数组不像下一课中将要介绍的*slices*那样经常用作函数参数。
- en: '|  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 16.5**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查16.5**'
- en: '**[1](#ch16qa10q0a1)**'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch16qa10q0a1)**'
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How did Earth survive in `planetsMarkII` of [listing 16.6](#ch16ex06)?
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 地球如何在[列表16.6](#ch16ex06)的`planetsMarkII`中幸存？
- en: '**[2](#ch16qa10q0a2)**'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch16qa10q0a2)**'
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How could [listing 16.7](#ch16ex07) be modified so that the planets array in
    `main` is changed?
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如何修改[列表16.7](#ch16ex07)，以便在`main`中的行星数组发生变化？
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 16.5 answer**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 16.5 答案**'
- en: '**[1](#ch16qa9q1)**'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch16qa9q1)**'
- en: ''
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `planetsMarkII` variable received a copy of the `planets` array, so modifications
    to either array are independent of each other.
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`planetsMarkII`变量接收了`planets`数组的副本，因此对任一数组的修改都是相互独立的。'
- en: '**[2](#ch16qa9q2)**'
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch16qa9q2)**'
- en: ''
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `terraform` function could return the revised `[8]string` array, so that
    `main` could reassign planets to the new value. [Lesson 17](kindle_split_029.html#ch17)
    on slices and [lesson 26](kindle_split_040.html#ch26) on pointers present other
    alternatives.
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`terraform`函数可以返回修改后的`[8]string`数组，这样`main`就可以将行星重新分配给新值。[切片](kindle_split_029.html#ch17)和[指针](kindle_split_040.html#ch26)的[第17课](kindle_split_029.html#ch17)和[第26课](kindle_split_040.html#ch26)提供了其他替代方案。'
- en: '|  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 16.6\. Arrays of arrays
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.6. 数组数组
- en: You’ve seen arrays of strings, but you can also have arrays of integers, arrays
    of floating-point numbers, and even arrays of arrays. The 8 × 8 chessboard in
    the following listing is an array of arrays of strings.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经见过字符串数组，但你也可以有整数数组、浮点数数组和甚至数组数组。以下列表中的8×8棋盘是一个字符串数组数组。
- en: 'Listing 16.8\. Chessboard: chess.go'
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.8. 棋盘：chess.go
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* An array of eight arrays of eight strings**'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 八个八字符串数组的数组**'
- en: '***2* Places a rook at a [row][column] coordinate**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在[row][column]坐标放置一枚车**'
- en: '|  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 16.6**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查16.6**'
- en: '**[Q1:](#ch16qa12q0a1)**'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch16qa12q0a1)**'
- en: ''
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider the game of Sudoku. What would the declaration look like for a 9 ×
    9 grid of integers?
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑数独游戏。一个9×9整数网格的声明看起来会是什么样子？
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 16.6 answer**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 16.6 答案**'
- en: '**[1:](#ch16qa11q1)**'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch16qa11q1)**'
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Arrays are ordered collections of elements with a fixed length.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组是有序元素集合，具有固定长度。
- en: Composite literals provide a convenient means to initialize arrays.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合字面量提供了一种方便的方式来初始化数组。
- en: The `range` keyword can iterate over arrays.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range`关键字可以遍历数组。'
- en: When accessing elements of an array, you must stay inside its boundaries.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访问数组的元素时，你必须保持在它的边界内。
- en: Arrays are copied when assigned or passed to functions.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当分配或传递给函数时，数组会被复制。
- en: Let’s see if you got this...
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: 'Experiment: chess.go'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：chess.go
- en: Extend [listing 16.8](#ch16ex08) to display all the chess pieces at their starting
    positions using the characters `kqrbnp` for black pieces along the top and uppercase
    `KQRBNP` for white pieces on the bottom.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 [列表 16.8](#ch16ex08) 扩展到使用字符 `kqrbnp` 表示顶部的黑色棋子，以及使用大写 `KQRBNP` 表示底部的白色棋子，以显示所有棋子在起始位置。
- en: Write a function that nicely displays the board.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，以优雅的方式显示棋盘。
- en: Instead of strings, use `[8][8]rune` to represent the board. Recall that `rune`
    literals are surrounded with single quotes and can be printed with the `%c` format
    verb.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用 `[8][8]rune` 来表示棋盘，而不是字符串。回想一下，`rune` 文字用单引号包围，可以用 `%c` 格式说明符打印。
- en: 'Lesson 17\. Slices: windows into arrays'
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 17 课\. 切片：数组的窗口
- en: After reading [lesson 17](#ch17), you’ll be able to
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读 [第 17 课](#ch17) 之后，你将能够
- en: Use slices to view the solar system through a window
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用切片通过窗口查看太阳系
- en: Alphabetize slices with the standard library
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准库对切片进行排序。
- en: The planets in our solar system are classified as terrestrial, gas giants, and
    ice giants, as shown in [figure 17.1](#ch17fig01). You can focus on the terrestrial
    ones by slicing the first four elements of the `planets` array with `planets[0:4]`.
    *Slicing* doesn’t alter the `planets` array. It just creates a window or view
    into the array. This view is a type called a *slice*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们太阳系中的行星被分为地行星、气态巨行星和冰态巨行星，如图 17.1 所示。你可以通过用 `planets[0:4]` 切片 `planets` 数组的头四个元素来专注于地行星。*切片*不会改变
    `planets` 数组。它只是创建了一个窗口或视图。这个视图是一个名为 *切片* 的类型。
- en: Figure 17.1\. Slicing the solar system
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 17.1\. 切片太阳系
- en: '![](17fig01_alt.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](17fig01_alt.jpg)'
- en: '|  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: If you have a collection, is it organized in a certain way? The books on a library
    shelf may be ordered by the last name of the author, for example. This arrangement
    allows you to focus in on other books they wrote.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有收藏，它是按照某种方式组织的吗？例如，图书馆书架上的书可能是按照作者姓氏排序的。这种安排让你可以专注于他们写的其他书籍。
- en: You can use slices to zero in on part of a collection in the same way.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用切片以同样的方式聚焦于集合的一部分。
- en: '|  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 17.1\. Slicing an array
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1\. 切片数组
- en: Slicing is expressed with a *half-open range*. For example, in the following
    listing, `planets[0:4]` begins with the planet at index 0 and continues up to,
    but not including, the planet at index 4.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 切片用 *半开区间* 表示。例如，在下面的列表中，`planets[0:4]` 从索引 0 的行星开始，并继续到但不包括索引 4 的行星。
- en: 'Listing 17.1\. Slicing an array: slicing.go'
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.1\. 切片数组：slicing.go
- en: '[PRE15]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Prints [Mercury Venus Earth Mars] [Jupiter Saturn] [Uranus Neptune]**'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 [水星 金星 地球 火星] [木星 土星] [天王星 海王星]**'
- en: 'Though `terrestrial`, `gasGiants`, and `iceGiants` are slices, you can still
    index into slices like arrays:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `terrestrial`、`gasGiants` 和 `iceGiants` 都是切片，但你仍然可以像数组一样索引切片：
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Prints Jupiter**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印木星**'
- en: 'You can also slice an array, and then slice the resulting slice:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以先切片数组，然后再切片结果切片：
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Prints [Jupiter Saturn Uranus Neptune] [Jupiter Saturn] [Uranus Neptune]**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 [木星 土星 天王星 海王星] [木星 土星] [天王星 海王星]**'
- en: 'The `terrestrial`, `gasGiants`, `iceGiants`, `giants`, `gas`, and `ice` slices
    are all views of the same `planets` array. Assigning a new value to an element
    of a slice modifies the underlying `planets` array. The change will be visible
    through the other slices:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`terrestrial`、`gasGiants`、`iceGiants`、`giants`、`gas` 和 `ice` 切片都是同一 `planets`
    数组的视图。给切片的元素赋新值会修改底层 `planets` 数组。这种变化将通过其他切片可见：'
- en: '[PRE18]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Copies the iceGiants slice (a view of the planets array)**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 复制 iceGiants 切片（行星数组的视图）**'
- en: '***2* Prints [Mercury Venus Earth Mars Jupiter Saturn Uranus Poseidon]**'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 [水星 金星 地球 火星 木星 土星 天王星 波塞冬]**'
- en: '***3* Prints [Uranus Poseidon] [Uranus Poseidon] [Uranus Poseidon]**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印 [天王星 波塞冬] [天王星 波塞冬] [天王星 波塞冬]**'
- en: '|  |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 17.1**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 17.1**'
- en: '**[1](#ch17qa2q0a1)**'
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch17qa2q0a1)**'
- en: ''
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does slicing an array produce?
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 切片数组会产生什么？
- en: '**[2](#ch17qa2q0a2)**'
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch17qa2q0a2)**'
- en: ''
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When slicing with `planets[4:6]`, how many elements are in the result?
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当使用 `planets[4:6]` 切片时，结果中有多少个元素？
- en: '|  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 17.1 answer**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 17.1 答案**'
- en: '**[1](#ch17qa1q1)**'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch17qa1q1)**'
- en: ''
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A slice.
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个切片。
- en: '**[2](#ch17qa1q2)**'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch17qa1q2)**'
- en: ''
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Two.
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 二。
- en: '|  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 17.1.1\. Default indices for slicing
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.1.1\. 切片的默认索引
- en: When slicing an array, omitting the first index defaults to the beginning of
    the array. Omitting the last index defaults to the length of the array. This allows
    the slicing from [listing 17.1](#ch17ex01) to be written as shown in the following
    listing.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当切片数组时，省略第一个索引默认为数组的开始。省略最后一个索引默认为数组的长度。这使得 [列表 17.1](#ch17ex01) 中的切片可以写成以下列表所示。
- en: 'Listing 17.2\. Default indices: slicing-default.go'
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.2\. 默认索引：slicing-default.go
- en: '[PRE19]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Slice indices may not be negative.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 切片索引不能为负。
- en: '|  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can probably guess what omitting both indices does. The `allPlanets` variable
    is a slice containing all eight planets:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能可以猜到省略两个索引会发生什么。`allPlanets` 变量是一个包含八个行星的切片：
- en: '[PRE20]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Slicing strings**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**切片字符串**'
- en: 'The slicing syntax for arrays also works on strings:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的切片语法也适用于字符串：
- en: '[PRE21]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Prints tune**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印调音**'
- en: 'The result of slicing a string is another string. However, assigning a new
    value to `neptune` won’t change the value of `tune` or vice versa:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 切片字符串的结果是另一个字符串。然而，将新值赋给 `neptune` 不会改变 `tune` 的值，反之亦然：
- en: '[PRE22]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Prints tune**'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印调音**'
- en: 'Be aware that the indices indicate the number of bytes, not runes:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，索引表示字节数，而不是 runes：
- en: '[PRE23]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Prints ¿Cóm**'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 ¿Cóm**'
- en: '|  |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 17.2**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 17.2**'
- en: '**[Q1:](#ch17qa4q0a1)**'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch17qa4q0a1)**'
- en: ''
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If Earth and Mars were the only colonized planets, how could you derive the
    slice `colonized` from `terrestrial`?
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果地球和火星是唯一被殖民的行星，你将如何从 `terrestrial` 中推导出 `colonized` 切片？
- en: '|  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 17.2 answer**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 17.2 答案**'
- en: '**[1:](#ch17qa3q1)**'
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch17qa3q1)**'
- en: ''
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 17.2\. Composite literals for slices
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2\. 切片复合字面量
- en: 'Many functions in Go operate on slices rather than arrays. If you need a slice
    that reveals every element of the underlying array, one option is to declare an
    array and then slice it with `[:]`, like this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言中的许多函数操作的是切片而不是数组。如果你需要一个显示底层数组中每个元素的切片，一个选项是声明一个数组，然后使用 `[:]` 来切片，如下所示：
- en: '[PRE25]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Slicing an array is one way to create a slice, but you can also declare a slice
    directly. A slice of strings has the type `[]string`, with no value between the
    brackets. This differs from an array declaration, which always specifies a fixed
    length or ellipsis between the brackets.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 切片数组是创建切片的一种方法，但你也可以直接声明一个切片。字符串切片的类型是 `[]string`，括号中没有值。这与数组声明不同，数组声明总是指定括号中的固定长度或省略号。
- en: In the following listing, `dwarfs` is a slice initialized with the familiar
    composite literal syntax.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，`dwarfs` 是使用熟悉的复合字面量语法初始化的切片。
- en: 'Listing 17.3\. Start with a slice: dwarf-slice.go'
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.3\. 从切片开始：dwarf-slice.go
- en: '[PRE26]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There is still an underlying array. Behind the scenes, Go declares a five-element
    array and then makes a slice that views all of its elements.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一个底层数组。在幕后，Go 声明了一个五个元素的数组，然后创建了一个可以查看其所有元素的切片。
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 17.3**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 17.3**'
- en: '**[Q1:](#ch17qa6q0a1)**'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch17qa6q0a1)**'
- en: ''
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the `%T` format verb to compare the types of `dwarfArray` and the `dwarfs`
    slice.
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `%T` 格式说明符比较 `dwarfArray` 和 `dwarfs` 切片的类型。
- en: '|  |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 17.3 answer**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 17.3 答案**'
- en: '**[1:](#ch17qa5q1)**'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch17qa5q1)**'
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***1* Prints array [5]string**'
  id: totrans-293
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印数组 [5]string**'
- en: '***2* Prints slice []string**'
  id: totrans-294
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印切片 []string**'
- en: '|  |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 17.3\. The power of slices
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.3\. 切片的力量
- en: What if there were a way to fold the fabric of space-time, bringing worlds together
    for instantaneous travel? Using the Go standard library and some ingenuity, the
    `hyperspace` function in [listing 17.4](#ch17ex04) modifies a slice of `worlds`,
    removing the (white) space between them.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有办法折叠时空结构，将世界聚集在一起以实现瞬间旅行，会怎么样？使用 Go 标准库和一些巧妙的方法，[列表 17.4](#ch17ex04) 中的 `hyperspace`
    函数修改了一个 `worlds` 切片，移除了它们之间的（白色）空间。
- en: '![](f0135-01.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](f0135-01.jpg)'
- en: 'Listing 17.4\. Bringing worlds together: hyperspace.go'
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.4\. 将世界聚集在一起：hyperspace.go
- en: '[PRE28]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* This argument is a slice, not an array.**'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这个论点是切片，而不是数组。**'
- en: '***2* Planets surrounded by space**'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 空间包围的行星**'
- en: '***3* Prints VenusEarthMars**'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印金星、地球和火星**'
- en: Both `worlds` and `planets` are slices, and though `worlds` is a copy, they
    both point to the same underlying array.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`worlds` 和 `planets` 都是切片，尽管 `worlds` 是一个副本，但它们都指向同一个底层数组。'
- en: If `hyperspace` were to change where the `worlds` slice points, begins, or ends,
    those changes would have no impact on the `planets` slice. But `hyperspace` is
    able to reach into the underlying array that `worlds` points to and change its
    elements. Those changes are visible by other slices (views) of the array.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `hyperspace` 改变了 `worlds` 切片指向的位置、开始或结束，这些更改对 `planets` 切片没有影响。但是 `hyperspace`
    能够访问 `worlds` 指向的底层数组并更改其元素。这些更改对数组的其他（视图）切片是可见的。
- en: 'Slices are more versatile than arrays in other ways too. Slices have a length,
    but unlike arrays, the length isn’t part of the type. You can pass a slice of
    any size to the `hyperspace` function:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 切片在与其他语言的数组相比还有其他方面更灵活。切片有一个长度，但与数组不同，长度不是类型的一部分。你可以将任何大小的切片传递给 `hyperspace`
    函数：
- en: '[PRE29]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Arrays are rarely used directly. Gophers prefer slices for their versatility,
    especially when passing arguments to functions.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 数组很少直接使用。Gophers 更喜欢切片，因为它们具有多功能性，尤其是在向函数传递参数时。
- en: '|  |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 17.4**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 17.4**'
- en: '**[Q1:](#ch17qa8q0a1)**'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch17qa8q0a1)**'
- en: ''
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Look up `TrimSpace` and `Join` in the Go documentation at [golang.org/pkg](http://golang.org/pkg).
    What functionality do they provide?
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 [golang.org/pkg](http://golang.org/pkg) 的 Go 文档中查找 `TrimSpace` 和 `Join`。它们提供了哪些功能？
- en: '|  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 17.4 answer**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 17.4 答案**'
- en: '**[1:](#ch17qa7q1)**'
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch17qa7q1)**'
- en: ''
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**1a** `TrimSpace` returns a slice with leading and trailing white space removed.'
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1a** `TrimSpace` 返回一个移除了前导和尾随空白字符的切片。'
- en: ''
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**1b** `Join` concatenates a slice of elements with a separator placed between
    them.'
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1b** `Join` 使用分隔符连接元素切片。'
- en: '|  |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 17.4\. Slices with methods
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4. 带有方法的切片
- en: In Go you can define a type with an underlying slice or array. Once you have
    a type, you can attach methods to it. Go’s ability to declare methods on types
    proves more versatile than the classes of other languages.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，你可以定义一个具有底层切片或数组的类型。一旦你有了类型，你就可以向它附加方法。Go 声明类型方法的能力比其他语言中的类更灵活。
- en: 'The `sort` package in the standard library declares a `StringSlice` type:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的 `sort` 包声明了一个 `StringSlice` 类型：
- en: '[PRE30]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Attached to `StringSlice` is a `Sort` method:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 附属于 `StringSlice` 的是一个 `Sort` 方法：
- en: '[PRE31]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To alphabetize the planets, the following listing converts `planets` to the
    `sort.StringSlice` type and then calls the `Sort` method.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按字母顺序排列行星，以下列表将 `planets` 转换为 `sort.StringSlice` 类型，然后调用 `Sort` 方法。
- en: 'Listing 17.5\. Sorting a slice of strings: sort.go'
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 17.5. 排序字符串切片：sort.go
- en: '[PRE32]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Sorts planets alphabetically**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 按字母顺序排序行星**'
- en: '***2* Prints [Earth Jupiter Mars Mercury Neptune Saturn Uranus Venus]**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 [地球 木星 火星 水星 海王星 土星 天王星 金星]**'
- en: 'To make it even simpler, the `sort` package has a `Strings` helper function
    that performs the type conversion and calls the `Sort` method for you:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更加简单，`sort` 包有一个 `Strings` 辅助函数，它执行类型转换并为你调用 `Sort` 方法：
- en: '[PRE33]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|  |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 17.5**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 17.5**'
- en: '**[Q1:](#ch17qa10q0a1)**'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch17qa10q0a1)**'
- en: ''
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does `sort.StringSlice(planets)` do?
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`sort.StringSlice(planets)` 做了什么？'
- en: '|  |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 17.5 answer**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 17.5 答案**'
- en: '**[1:](#ch17qa9q1)**'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch17qa9q1)**'
- en: ''
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `planets` variable is converted from `[]string` to the `StringSlice` type,
    which is declared in the `sort` package.
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`planets` 变量从 `[]string` 类型转换为 `StringSlice` 类型，该类型在 `sort` 包中声明。'
- en: '|  |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Slices are windows or views into an array.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片是数组的窗口或视图。
- en: The `range` keyword can iterate over slices.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range` 关键字可以遍历切片。'
- en: Slices share the same underlying data when assigned or passed to functions.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当分配或传递给函数时，切片共享相同的基础数据。
- en: Composite literals provide a convenient means to initialize slices.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合字面量提供了一种方便的方式来初始化切片。
- en: You can attach methods to slices.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为切片附加方法。
- en: Let’s see if you got this...
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: 'Experiment: terraform.go'
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：terraform.go
- en: Write a program to terraform a slice of strings by prepending each planet with
    `"New "`. Use your program to terraform Mars, Uranus, and Neptune.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，通过在每个行星前添加 `"New "` 来改造字符串切片。使用你的程序来改造火星、天王星和海王星。
- en: Your first iteration can use a terraform function, but your final implementation
    should introduce a `Planets` type with a terraform method, similar to `sort.StringSlice`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一次迭代可以使用 terraform 函数，但你的最终实现应该引入一个 `Planets` 类型，并带有 terraform 方法，类似于 `sort.StringSlice`。
- en: Lesson 18\. A bigger slice
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第18课. 更大的切片
- en: After reading [lesson 18](#ch18), you’ll be able to
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完[第18课](#ch18)后，你将能够
- en: Append more elements to slices
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向切片中添加更多元素
- en: Investigate how length and capacity work
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查长度和容量是如何工作的
- en: Arrays have a fixed number of elements, and slices are just views into those
    fixed-length arrays. Programmers often need a variable-length array that grows
    as needed. By combining slices and a built-in function named `append`, Go provides
    the capabilities of variable-length arrays. This lesson delves into how it works.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 数组有固定数量的元素，切片只是这些固定长度数组的视图。程序员经常需要一个可变长度的数组，它可以按需增长。通过结合切片和名为 `append` 的内置函数，Go
    提供了可变长度数组的特性。本课深入探讨了它是如何工作的。
- en: '|  |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Have you ever had your books outgrow your shelves, or your family outgrow your
    home or vehicle?
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否有过书籍超出书架容量，或者家庭超出住所或车辆容量的情况？
- en: Like bookshelves, arrays have a certain capacity. A slice can focus on the portion
    of the array where the books are, and grow to reach the capacity of the shelf.
    If the shelf is full, you can replace the shelf with a larger one and move all
    the books over. Then point the slice at the books on the new shelf with a greater
    capacity.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 像书架一样，数组有一定的容量。切片可以关注数组中书籍的部分，并增长以达到书架的容量。如果书架满了，你可以用一个更大的书架替换它，并将所有书籍移过去。然后让切片指向新书架上的书籍，具有更大的容量。
- en: '|  |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 18.1\. The append function
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1\. `append` 函数
- en: The International Astronomical Union (IAU) recognizes five dwarf planets in
    our solar system, but there could be more. To add more elements to the `dwarfs`
    slice, use the built-in `append` function as shown in the following listing.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 国际天文学联合会（IAU）承认我们太阳系中有五个矮行星，但可能有更多。要向 `dwarfs` 切片添加更多元素，请使用以下列表中所示的内置 `append`
    函数。
- en: 'Listing 18.1\. More dwarf planets: append.go'
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.1\. 更多矮行星：append.go
- en: '[PRE34]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* Prints [Ceres Pluto Haumea Makemake Eris Orcus]**'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 [Ceres Pluto Haumea Makemake Eris Orcus]**'
- en: 'The `append` function is *variadic*, like `Println`, so you can pass multiple
    elements to append in one go:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`append` 函数是可变参数的，就像 `Println` 一样，所以你可以一次传递多个元素进行追加：'
- en: '[PRE35]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Prints [Ceres Pluto Haumea Makemake Eris Orcus Salacia Quaoar Sedna]**'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 [Ceres Pluto Haumea Makemake Eris Orcus Salacia Quaoar Sedna]**'
- en: The `dwarfs` slice began as a view into a five-element array, yet the preceding
    code appends four more elements. How is that possible? To investigate, you’ll
    first need to understand *capacity* and the built-in function `cap`.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`dwarfs` 切片最初是一个五元素数组的视图，但前面的代码又添加了四个更多元素。这是如何实现的？为了进行调查，你首先需要了解 *容量* 和内置函数
    `cap`。'
- en: '|  |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 18.1**'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 18.1**'
- en: '**[Q1:](#ch18qa2q0a1)**'
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch18qa2q0a1)**'
- en: ''
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many dwarf planets are in [listing 18.1](#ch18ex01)? What function can be
    used to determine this?
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[列表 18.1](#ch18ex01) 中有多少个矮行星？可以使用哪个函数来确定这个数量？'
- en: '|  |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 18.1 answer**'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 18.1 答案**'
- en: '**[1:](#ch18qa1q1)**'
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch18qa1q1)**'
- en: ''
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The slice contains nine dwarf planets, which can be determined with the `len`
    builtin function:'
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 该切片包含九个矮行星，可以使用 `len` 内置函数来确定：
- en: ''
  id: totrans-388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ''
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***1* Prints 9**'
  id: totrans-391
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 9**'
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 18.2\. Length and capacity
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2\. 长度和容量
- en: The number of elements that are visible through a slice determines its length.
    If a slice has an underlying array that is larger, the slice may still have *capacity*
    to grow.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 通过切片可见的元素数量决定了其长度。如果一个切片的底层数组更大，切片仍然可能具有增长的空间。
- en: The following listing declares a function to print out the length and capacity
    of a slice.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表声明了一个函数，用于打印切片的长度和容量。
- en: 'Listing 18.2\. `Len` and `cap`: slice-dump.go'
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 18.2\. `Len` 和 `cap`: slice-dump.go'
- en: '[PRE37]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Prints dwarfs: length 5, capacity 5 [Ceres Pluto Haumea Makemake Eris]**'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印矮行星：长度 5，容量 5 [Ceres Pluto Haumea Makemake Eris]**'
- en: '***2* Prints dwarfs[1:2]: length 1, capacity 4 [Pluto]**'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 dwarfs[1:2]：长度 1，容量 4 [Pluto]**'
- en: The slice created by `dwarfs[1:2]` has a length of 1, but the capacity to hold
    4 elements.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `dwarfs[1:2]` 创建的切片长度为 1，但可以容纳 4 个元素。
- en: '|  |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 18.2**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 18.2**'
- en: '**[Q1:](#ch18qa4q0a1)**'
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch18qa4q0a1)**'
- en: ''
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does the `dwarfs[1:2]` slice have a capacity of 4?
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么 `dwarfs[1:2]` 切片的容量为 4？
- en: '|  |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 18.2 answer**'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 18.2 答案**'
- en: '**[1:](#ch18qa3q1)**'
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch18qa3q1)**'
- en: ''
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Pluto Haumea Makemake Eris` provide a capacity of 4 even though the length
    is 1.'
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Pluto Haumea Makemake Eris` 即使长度为 1，也提供了 4 个元素的容量。'
- en: '|  |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 18.3\. Investigating the append function
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3\. 研究 `append` 函数
- en: Using the `dump` function from [listing 18.2](#ch18ex02), the next listing shows
    how `append` affects capacity.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [列表 18.2](#ch18ex02) 中的 `dump` 函数，下一个列表显示了 `append` 如何影响容量。
- en: 'Listing 18.3\. `append` to slice: slice-append.go'
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.3\. `append` 到切片：slice-append.go
- en: '[PRE38]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Length 5, capacity 5**'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 长度 5，容量 5**'
- en: '***2* Length 6, capacity 10**'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 长度 6，容量 10**'
- en: '***3* Length 9, capacity 10**'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 长度 9，容量 10**'
- en: The array backing `dwarfs1` doesn’t have enough room (capacity) to append Orcus,
    so `append` copies the contents of `dwarfs1` to a freshly allocated array with
    twice the capacity, as illustrated in [figure 18.1](#ch18fig01). The `dwarfs2`
    slice points at the newly allocated array. The additional capacity happens to
    provide enough room for the next `append`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 `dwarfs1` 的数组没有足够的空间（容量）来追加奥克鲁斯，因此 `append` 将 `dwarfs1` 的内容复制到具有两倍容量的新分配的数组中，如图
    18.1（#ch18fig01）所示。`dwarfs2` 切片指向新分配的数组。额外的容量恰好提供了足够的空间进行下一个 `append`。
- en: Figure 18.1\. `append` allocates a new array with increased capacity when necessary.
  id: totrans-421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 18.1\. 当需要时，`append` 分配具有增加容量的新数组。
- en: '![](18fig01_alt.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![](18fig01_alt.jpg)'
- en: To demonstrate that `dwarfs2` and `dwarfs3` refer to a different array than
    `dwarfs1`, simply modify an element and print out the three slices.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明 `dwarfs2` 和 `dwarfs3` 指向与 `dwarfs1` 不同的数组，只需修改一个元素并打印出三个切片。
- en: '|  |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 18.3**'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 18.3**'
- en: '**[Q1:](#ch18qa6q0a1)**'
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch18qa6q0a1)**'
- en: ''
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you modify an element of `dwarfs3` in [listing 18.3](#ch18ex03), will `dwarfs2`
    or `dwarfs1` change?
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你修改了 [列表 18.3](#ch18ex03) 中的 `dwarfs3` 的一个元素，`dwarfs2` 或 `dwarfs1` 会改变吗？
- en: ''
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|  |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 18.3 answer**'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 18.3 答案**'
- en: '**[1:](#ch18qa5q1)**'
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch18qa5q1)**'
- en: ''
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`dwarfs3` and `dwarfs2` are changed, but `dwarfs1` remains the same because
    it points to a different array.'
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`dwarfs3` 和 `dwarfs2` 发生了变化，但 `dwarfs1` 保持不变，因为它指向不同的数组。'
- en: '|  |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 18.4\. Three-index slicing
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.4\. 三个索引切片
- en: Go version 1.2 introduced *three-index slicing* to limit the capacity of the
    resulting slice. In the next listing, `terrestrial` has a length and capacity
    of 4\. Appending `Ceres` causes a new array to be allocated, leaving the `planets`
    array unaltered.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1.2 版本引入了 *三个索引切片* 来限制结果切片的容量。在下一个列表中，`terrestrial` 的长度和容量为 4。追加 `Ceres`
    会导致分配新的数组，而 `planets` 数组保持不变。
- en: 'Listing 18.4\. Capacity after slicing: three-index-slicing.go'
  id: totrans-440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.4\. 切片后的容量：three-index-slicing.go
- en: '[PRE40]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* Length 4, capacity 4**'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 长度 4，容量 4**'
- en: '***2* Prints [Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune]**'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 [水星 金星 地球 火星 木星 土星 天王星 海王星]**'
- en: 'If the third index isn’t specified, `terrestrial` will have a capacity of 8\.
    Appending `Ceres` doesn’t allocate a new array, but instead overwrites `Jupiter`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定第三个索引，`terrestrial` 将具有容量 8。追加 `Ceres` 不会分配新的数组，而是覆盖 `Jupiter`：
- en: '[PRE41]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* Length 4, capacity 8**'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 长度 4，容量 8**'
- en: '***2* Prints [Mercury Venus Earth Mars Ceres Saturn Uranus Neptune]**'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 [水星 金星 地球 火星 灶神星 土星 天王星 海王星]**'
- en: Unless you want to overwrite Jupiter, you should default to three-index slicing
    whenever you take a slice.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你想覆盖木星，否则在切片时应该默认使用三个索引切片。
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 18.4**'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 18.4**'
- en: '**[Q1:](#ch18qa8q0a1)**'
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch18qa8q0a1)**'
- en: ''
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When should three-index slicing be used?
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 何时应该使用三个索引切片？
- en: '|  |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 18.4 answer**'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 18.4 答案**'
- en: '**[1:](#ch18qa7q1)**'
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch18qa7q1)**'
- en: ''
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When shouldn’t three-index slicing be used? Unless you specifically want to
    overwrite the elements of the underlying array, it’s far safer to set the capacity
    with a three-index slice.
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 何时不应使用三个索引切片？除非你明确想要覆盖基本数组的元素，否则使用三个索引切片设置容量要安全得多。
- en: '|  |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 18.5\. Preallocate slices with make
  id: totrans-461
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.5\. 使用 make 预分配切片
- en: When there isn’t enough capacity for `append`, Go must allocate a new array
    and copy the contents of the old array. You can avoid extra allocations and copies
    by *preallocating* a slice with the built-in `make` function.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有足够的容量进行 `append` 时，Go 必须分配一个新的数组并复制旧数组的所有内容。你可以通过使用内置的 `make` 函数预先分配切片来避免额外的分配和复制。
- en: The `make` function in the next listing specifies both the length (0) and capacity
    (10) of the `dwarfs` slice. Up to 10 elements can be appended before `dwarfs`
    runs out of capacity, causing `append` to allocate a new array.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中的 `make` 函数指定了 `dwarfs` 切片的长度（0）和容量（10）。在 `dwarfs` 容量耗尽之前，最多可以追加 10 个元素，这会导致
    `append` 分配一个新的数组。
- en: 'Listing 18.5\. Make a slice: slice-make.go'
  id: totrans-464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.5\. 创建切片：slice-make.go
- en: '[PRE42]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The capacity argument is optional. To start with a length and capacity of 10,
    you can use `make([]string, 10)`. Each of the 10 elements will contain the zero
    value for their type, an empty string in this case. The `append` built-in function
    would add the 11th element.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 容量参数是可选的。要从一个长度和容量为 10 的切片开始，可以使用 `make([]string, 10)`。这 10 个元素将包含它们类型的零值，在这种情况下是一个空字符串。`append`
    内置函数将添加第 11 个元素。
- en: '|  |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 18.5**'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 18.5**'
- en: '**[Q1:](#ch18qa10q0a1)**'
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch18qa10q0a1)**'
- en: ''
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the benefit of making slices with `make`?
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `make` 创建切片有什么好处？
- en: '|  |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 18.5 answer**'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 18.5 答案**'
- en: '**[1:](#ch18qa9q1)**'
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch18qa9q1)**'
- en: ''
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Preallocating with `make` can set an initial capacity, thereby avoiding additional
    allocations and copies to enlarge the underlying array.
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `make` 预分配可以设置初始容量，从而避免在扩大底层数组时进行额外的分配和复制。
- en: '|  |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 18.6\. Declaring variadic functions
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.6. 声明可变参数函数
- en: '`Printf` and `append` are *variadic* functions because they accept a variable
    number of arguments. To declare a variadic function, use the ellipsis `...` with
    the last parameter, as shown in the following listing.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`Printf` 和 `append` 是 *可变参数* 函数，因为它们接受可变数量的参数。要声明一个可变参数函数，使用最后一个参数的省略号 `...`，如下所示。'
- en: 'Listing 18.6\. Variable arity functions: variadic.go'
  id: totrans-481
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.6. 可变参数函数：variadic.go
- en: '[PRE43]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Makes a new slice rather than modifying worlds directly**'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个新的切片而不是直接修改世界**'
- en: 'The `worlds` parameter is a slice of strings that contains zero or more arguments
    passed to `terraform`:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`worlds` 参数是一个包含零个或多个传递给 `terraform` 的参数的字符串切片：'
- en: '[PRE44]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* Prints [New Venus New Mars]**'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 [新金星 新火星]**'
- en: 'To pass a slice instead of multiple arguments, expand the slice with an ellipsis:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 要传递一个切片而不是多个参数，使用省略号展开切片：
- en: '[PRE45]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Prints [New Venus New Mars New Jupiter]**'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 [新金星 新火星 新木星]**'
- en: If `terraform` were to modify (or *mutate*) elements of the `worlds` parameter,
    the `planets` slice would also see those changes. By using `newWorlds`, the `terraform`
    function avoids modifying the passed arguments.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `terraform` 要修改（或 *修改*）`worlds` 参数的元素，`planets` 切片也会看到这些更改。通过使用 `newWorlds`，`terraform`
    函数避免了修改传递的参数。
- en: '|  |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 18.6**'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 18.6**'
- en: '**[Q1:](#ch18qa12q0a1)**'
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch18qa12q0a1)**'
- en: ''
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are three uses for the ellipsis `...`?
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 三个使用省略号 `...` 的用途是什么？
- en: '|  |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 18.6 answer**'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 18.6 答案**'
- en: '**[1:](#ch18qa11q1)**'
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch18qa11q1)**'
- en: ''
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Have the Go compiler count the number of elements in a composite literal for
    an array.
  id: totrans-501
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 Go 编译器计算复合字面量中数组元素的数量。
- en: Make the last parameter of a variadic function capture zero or more arguments
    as a slice.
  id: totrans-502
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使可变参数函数的最后一个参数捕获零个或多个参数作为一个切片。
- en: Expand the elements of a slice into arguments passed to a function.
  id: totrans-503
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将切片的元素展开为传递给函数的参数。
- en: '|  |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Slices have a length and a capacity.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片有一个长度和一个容量。
- en: When there isn’t enough capacity, the built-in `append` function will allocate
    a new underlying array.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当容量不足时，内置的 `append` 函数将分配一个新的底层数组。
- en: You can use the `make` function to preallocate a slice.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `make` 函数来预分配一个切片。
- en: Variadic functions accept multiple arguments, which are placed in a slice.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变参数函数接受多个参数，这些参数被放置在一个切片中。
- en: Let’s see if you got this...
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否明白了...
- en: 'Experiment: capacity.go'
  id: totrans-511
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：capacity.go
- en: Write a program that uses a loop to continuously append an element to a slice.
    Print out the capacity of the slice whenever it changes. Does `append` always
    double the capacity when the underlying array runs out of room?
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，使用循环不断向切片中追加一个元素。每当切片容量改变时，打印出切片的容量。`append` 在底层数组空间不足时总是加倍容量吗？
- en: Lesson 19\. The ever-versatile map
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第19课。永远多才多艺的映射
- en: After reading [lesson 19](#ch19), you’ll be able to
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读 [第19课](#ch19) 之后，你将能够
- en: Use maps as collections for unstructured data
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将映射用作非结构化数据的集合
- en: Declare, access, and iterate over maps
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明、访问和遍历映射
- en: Explore some uses of the versatile map type
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索一些多用途映射类型的用法
- en: Maps come in handy when you’re searching for something, and we’re not just talking
    about Google Maps ([www.google.com/mars/](http://www.google.com/mars/)). Go provides
    a map collection with keys that *map* to values. Whereas arrays and slices are
    indexed by sequential integers, *map keys* can be nearly any type.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在寻找某物时，映射很有用，我们不仅仅是在谈论谷歌地图 ([www.google.com/mars/](http://www.google.com/mars/))。Go
    提供了一个具有键映射到值的映射集合。而数组和切片是通过顺序整数索引的，*映射键* 可以是任何类型。
- en: '|  |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'This collection goes by several different names: dictionaries in Python, hashes
    in Ruby, and objects in JavaScript. Associative arrays in PHP and tables in Lua
    serve as both maps and conventional arrays.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集合有几个不同的名称：Python 中的字典、Ruby 中的散列和 JavaScript 中的对象。PHP 中的关联数组和 Lua 中的表既作为映射也作为常规数组。
- en: '|  |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Maps are especially useful for unstructured data where the keys are determined
    while a program is running. Programs written in scripting languages tend to use
    maps for *structured data* as well—data where the keys are known ahead of time.
    [Lesson 21](kindle_split_034.html#ch21) covers Go’s structure type, which is better
    suited for those cases.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 映射在键在程序运行时确定的无结构数据中特别有用。用脚本语言编写的程序倾向于使用映射来处理 *结构化数据*，即键在事先已知的数据。[第 21 课](kindle_split_034.html#ch21)介绍了
    Go 的结构类型，它更适合这些情况。
- en: '|  |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这个**'
- en: Maps associate a key with a value, which is handy for an index. If you know
    the title of a book, iterating through every book in an array could take some
    time, just like looking through every shelf of every aisle of a library or bookstore.
    A map keyed by book title is faster for that purpose.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 映射将键与值关联起来，这对于索引很有用。如果您知道一本书的标题，遍历数组中的每一本书可能需要一些时间，就像在图书馆或书店的每个通道的每个书架上查找一样。按书名键的映射在这一点上更快。
- en: What are some other situations in which a map from keys to values could be useful?
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪些其他情况下，从键到值的映射可能很有用？
- en: '|  |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 19.1\. Declaring a map
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1\. 声明映射
- en: The keys of maps can be nearly any type, unlike arrays and slices, which have
    sequential integers for keys. You must specify a type for the keys and values
    in Go. To declare a map with keys of type `string` and values of type `int`, the
    syntax is `map[string]int`, as shown in [figure 19.1](#ch19fig01).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组切片不同，数组的键是连续的整数，映射的键可以是任何类型。在 Go 中，您必须指定键和值的类型。要声明一个具有 `string` 类型键和 `int`
    类型值的映射，语法是 `map[string]int`，如图 19.1 所示。
- en: Figure 19.1\. A map with string keys and integer values
  id: totrans-531
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Figure 19.1\. 一个具有字符串键和整数值的地图
- en: '![](19fig01.jpg)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![](19fig01.jpg)'
- en: The `temperature` map declared in [listing 19.1](#ch19ex01) contains average
    temperatures from the Planetary Fact Sheet ([nssdc.gsfc.nasa.gov/planetary/factsheet/](http://nssdc.gsfc.nasa.gov/planetary/factsheet/)).
    You can declare and initialize maps with composite literals, much like other collection
    types. For each element, specify a key and value of the appropriate type. Use
    square brackets `[]` to look up values by key, to assign over existing values,
    or to add values to the map.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 19.1](#ch19ex01) 中声明的 `temperature` 映射包含来自行星事实表的平均温度 ([nssdc.gsfc.nasa.gov/planetary/factsheet/](http://nssdc.gsfc.nasa.gov/planetary/factsheet/))。您可以使用复合字面量声明和初始化映射，就像其他集合类型一样。对于每个元素，指定适当的键和值。使用方括号
    `[]` 通过键查找值，覆盖现有值或向映射中添加值。
- en: 'Listing 19.1\. Average temperature map: map.go'
  id: totrans-534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Listing 19.1\. 平均温度映射：map.go
- en: '[PRE46]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Composite literals are key-value pairs for maps.**'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 复合字面量是映射的键值对。**'
- en: '***2* Prints On average the Earth is 15° C.**'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 On average the Earth is 15° C.**'
- en: '***3* A little climate change**'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 一点气候变化**'
- en: '***4* Prints map[Venus:464 Earth:16 Mars:-65]**'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印地图[Venus:464 Earth:16 Mars:-65]**'
- en: 'If you access a key that doesn’t exist in the map, the result is the zero value
    for the type (`int`):'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问映射中不存在的键，结果将是该类型的零值 (`int`)：
- en: '[PRE47]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Prints 0**'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 0**'
- en: 'Go provides the *comma, ok* syntax, which you can use to distinguish between
    the `"Moon"` not existing in the map versus being present in the map with a temperature
    of 0° C:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了 *逗号，ok* 语法，您可以使用它来区分 `"Moon"` 在地图中不存在与存在于地图中且温度为 0° C 的情况：
- en: '[PRE48]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* The comma, ok syntax**'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 逗号，ok 语法**'
- en: '***2* Prints Where is the moon?**'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 Where is the moon?**'
- en: The `moon` variable will contain the value found at the `"Moon"` key or the
    zero value. The additional `ok` variable will be `true` if the key is present,
    or `false` otherwise.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '`moon` 变量将包含在 `"Moon"` 键中找到的值或零值。如果键存在，则额外的 `ok` 变量将为 `true`，否则为 `false`。'
- en: '|  |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-549
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'When using the comma, ok syntax you can use any variable names you like:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用逗号，ok 语法时，您可以使用您喜欢的任何变量名：
- en: '[PRE49]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|  |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 19.1**'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 19.1**'
- en: '**[1](#ch19qa2q0a1)**'
  id: totrans-555
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch19qa2q0a1)**'
- en: ''
  id: totrans-556
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What type would you use to declare a map with 64-bit floating-point keys and
    integer values?
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您会使用什么类型来声明一个具有 64 位浮点键和整数值的映射？
- en: '**[2](#ch19qa2q0a2)**'
  id: totrans-558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch19qa2q0a2)**'
- en: ''
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you modify [listing 19.1](#ch19ex01) so that the `"Moon"` key is present
    with a value of `0`, what’s the result of using the comma, ok syntax?
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您修改 [清单 19.1](#ch19ex01)，使得 `"Moon"` 键存在且值为 `0`，使用逗号，ok 语法的结果是什么？
- en: '|  |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 19.1 answer**'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 19.1 答案**'
- en: '**[1](#ch19qa1q1)**'
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch19qa1q1)**'
- en: ''
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The map type is `map[float64]int`.
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 映射类型是 `map[float64]int`。
- en: '**[2](#ch19qa1q2)**'
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch19qa1q2)**'
- en: ''
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The value of `ok` will be `true`:'
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ok` 的值将是 `true`：'
- en: ''
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ''
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***1* Prints On average the moon is 0° C.**'
  id: totrans-573
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 On average the moon is 0° C.**'
- en: '|  |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 19.2\. Maps aren’t copied
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2\. 地图不会被复制
- en: As you learned in [lesson 16](kindle_split_028.html#ch16), arrays are copied
    when assigned to new variables or when passed to functions or methods. The same
    is true for primitive types like `int` and `float64`.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第 16 课](kindle_split_028.html#ch16)中学到的，数组在分配给新变量或传递给函数或方法时会被复制。对于 `int`
    和 `float64` 这样的原始类型也是如此。
- en: Maps behave differently. In the next listing, both `planets` and `planetsMarkII`
    share the same underlying data. As you can see, changes to one impact the other.
    That’s a bit unfortunate given the circumstances.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 地图的行为不同。在下一个列表中，`planets` 和 `planetsMarkII` 共享相同的基本数据。正如你所看到的，对其中一个的更改会影响另一个。考虑到这种情况，这有点不幸。
- en: 'Listing 19.2\. Pointing at the same data: whoops.go'
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 19.2\. 指向相同的数据：whoops.go
- en: '[PRE51]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Prints map[Earth:whoops Mars:Sector ZZ9]**'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 map[Earth:whoops Mars:Sector ZZ9]**'
- en: '***2* Removes Earth from the map**'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从地图中移除地球**'
- en: '***3* Prints map[Mars:Sector ZZ9]**'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印 map[Mars:Sector ZZ9]**'
- en: When the `delete` built-in function removes an element from the map, both `planets`
    and `planetsMarkII` are impacted by the change. If you pass a map to a function
    or method, it may alter the contents of the map. This behavior is similar to multiple
    slices that point to the same underlying array.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 当内置的 `delete` 函数从一个地图中删除一个元素时，`planets` 和 `planetsMarkII` 都会受到这个变化的影响。如果你将一个地图传递给一个函数或方法，它可能会改变地图的内容。这种行为类似于多个切片指向同一个基本数组。
- en: '|  |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 19.2**'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 19.2**'
- en: '**[1](#ch19qa4q0a1)**'
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch19qa4q0a1)**'
- en: ''
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why are changes to `planets` also reflected in `planetsMarkII` in [listing 19.2](#ch19ex02)?
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么在[列表 19.2](#ch19ex02)中 `planets` 的更改也会反映在 `planetsMarkII` 中？
- en: '**[2](#ch19qa4q0a2)**'
  id: totrans-589
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch19qa4q0a2)**'
- en: ''
  id: totrans-590
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does the `delete` built-in function do?
  id: totrans-591
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 内置的 `delete` 函数做什么？
- en: '|  |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 19.2 answer**'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 19.2 答案**'
- en: '**[1](#ch19qa3q1)**'
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch19qa3q1)**'
- en: ''
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `planetsMarkII` variable points at the same underlying data as `planets`.
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`planetsMarkII` 变量指向与 `planets` 相同的基本数据。'
- en: '**[2](#ch19qa3q2)**'
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch19qa3q2)**'
- en: ''
  id: totrans-599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `delete` function removes an element from a map.
  id: totrans-600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`delete` 函数从一个地图中删除一个元素。'
- en: '|  |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 19.3\. Preallocating maps with make
  id: totrans-602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3\. 使用 `make` 预分配地图
- en: Maps are similar to slices in another way. Unless you initialize them with a
    composite literal, maps need to be allocated with the `make` built-in function.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 地图在另一个方面与切片相似。除非你使用复合字面量初始化它们，否则地图需要使用内置的 `make` 函数进行分配。
- en: 'For maps, `make` only accepts one or two parameters. The second one preallocates
    space for a number of keys, much like capacity for slices. A map’s initial length
    will always be zero when using `make`:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 对于地图，`make` 只接受一个或两个参数。第二个参数为键的数量预分配空间，就像切片的容量一样。使用 `make` 时，地图的初始长度始终为零：
- en: '[PRE52]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|  |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 19.3**'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 19.3**'
- en: '**[Q1:](#ch19qa6q0a1)**'
  id: totrans-608
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch19qa6q0a1)**'
- en: ''
  id: totrans-609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you suppose is the benefit of preallocating a map with `make`?
  id: totrans-610
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你认为使用 `make` 预分配地图有什么好处？
- en: '|  |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 19.3 answer**'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 19.3 答案**'
- en: '**[1:](#ch19qa5q1)**'
  id: totrans-614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch19qa5q1)**'
- en: ''
  id: totrans-615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As with slices, specifying an initial size for a map can save the computer some
    work later when the map gets bigger.
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 就像切片一样，为地图指定一个初始大小可以在地图变大时节省计算机一些工作。
- en: '|  |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 19.4\. Using maps to count things
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4\. 使用地图计数
- en: The code in [listing 19.3](#ch19ex03) determines the frequency of temperatures
    taken from the MAAS API ([github.com/ingenology/mars_weather_api](http://github.com/ingenology/mars_weather_api)).
    If `frequency` were a slice, the keys would need to be integers, and the underlying
    array would need to reserve space to count temperatures that never actually occur.
    A map is clearly a better choice in this case.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 19.3](#ch19ex03) 中的代码确定从 MAAS API ([github.com/ingenology/mars_weather_api](http://github.com/ingenology/mars_weather_api))
    读取的温度频率。如果 `frequency` 是一个切片，键需要是整数，并且基本数组需要预留空间来计数从未实际发生的温度。在这种情况下，地图显然是一个更好的选择。'
- en: '![](f0151-01.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![](f0151-01.jpg)'
- en: 'Listing 19.3\. Frequency of temperatures: frequency.go'
  id: totrans-621
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 19.3\. 温度频率：frequency.go
- en: '[PRE53]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* Iterates over a slice (index, value)**'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 遍历一个切片（索引，值）**'
- en: '***2* Iterates over a map (key, value)**'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 遍历一个地图（键，值）**'
- en: Iteration with the `range` keyword works similarly for slices, arrays, and maps.
    Rather than an index and value, maps provide the key and value for each iteration.
    Be aware that Go doesn’t guarantee the order of map keys, so the output may change
    from one run to another.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `range` 关键字进行迭代在切片、数组和地图中工作方式类似。对于每个迭代，地图提供键和值，而不是索引和值。请注意，Go 不保证地图键的顺序，所以输出可能在不同运行之间发生变化。
- en: '|  |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 19.4**'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 19.4**'
- en: '**[Q1:](#ch19qa8q0a1)**'
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch19qa8q0a1)**'
- en: ''
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When iterating over a map, what are the two variables populated with?
  id: totrans-630
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当遍历映射时，哪两个变量被填充？
- en: '|  |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 19.4 answer**'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 19.4 答案**'
- en: '**[1:](#ch19qa7q1)**'
  id: totrans-634
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch19qa7q1)**'
- en: ''
  id: totrans-635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The key and the value for each element in the map.
  id: totrans-636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 映射中每个元素的键和值。
- en: '|  |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 19.5\. Grouping data with maps and slices
  id: totrans-638
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.5. 使用映射和切片对数据进行分组
- en: Instead of determining the frequency of temperatures, let’s group temperatures
    together in divisions of 10° each. To do that, the following listing maps from
    a group to a slice of temperatures in that group.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再确定温度的频率，而是将温度按10°的间隔分组。为此，以下列表将映射从组映射到该组中的温度切片。
- en: 'Listing 19.4\. A map of slices: group.go'
  id: totrans-640
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 19.4. 切片映射：group.go
- en: '[PRE54]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* A map with float64 keys and []float64 values**'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 具有float64键和[]float64值的映射**'
- en: '***2* Rounds temperatures down to -20, -30, and so on**'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将温度四舍五入到-20、-30等**'
- en: 'The previous listing produces output like this:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的列表产生如下输出：
- en: '[PRE55]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '|  |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 19.5**'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 19.5**'
- en: '**[Q1:](#ch19qa10q0a1)**'
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch19qa10q0a1)**'
- en: ''
  id: totrans-649
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the type for the keys and values in the declaration `var groups map[string][]int`?
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 声明 `var groups map[string][]int` 中键和值的类型是什么？
- en: '|  |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 19.5 answer**'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 19.5 答案**'
- en: '**[1:](#ch19qa9q1)**'
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch19qa9q1)**'
- en: ''
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `groups` map has keys of type string and values that are a slice of integers.
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`groups` 映射的键是字符串类型，值是整数切片。'
- en: '|  |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 19.6\. Repurposing maps as sets
  id: totrans-658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.6. 将映射作为集合重用
- en: A *set* is a collection similar to an array, except that each element is guaranteed
    to occur only once. Go doesn’t provide a set collection, but you can always improvise
    by using a map, as shown in the following listing. The value isn’t important,
    but `true` is convenient for checking *set membership*. If a temperature is present
    in the map and it has a value of `true`, it’s a member of the set.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合* 是一个类似于数组的集合，除了每个元素都保证只发生一次。Go 不提供集合集合，但你可以通过使用映射来即兴创作，如下面的列表所示。值并不重要，但
    `true` 对于检查 *集合成员* 非常方便。如果一个温度在映射中，并且它的值为 `true`，那么它就是集合的成员。'
- en: 'Listing 19.5\. A makeshift set: set.go'
  id: totrans-660
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 19.5. 一个临时的集合：set.go
- en: '[PRE56]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* Makes a map with Boolean values**'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建具有布尔值的映射**'
- en: '***2* Prints set member**'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印集合成员**'
- en: '***3* Prints map[-31:true -29:true -23:true -33:true -28:true 32:true]**'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印 map[-31:true -29:true -23:true -33:true -28:true 32:true]**'
- en: 'You can see that the map only contains one key for each temperature, with any
    duplicates removed. But map keys have an arbitrary order in Go, so before they
    can be sorted, the temperatures must be converted back to a slice:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，映射只包含每个温度的一个键，任何重复都被删除。但是，Go 中映射键的顺序是任意的，因此在使用之前，必须将温度转换回切片：
- en: '[PRE57]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1* Prints [-33 -31 -29 -28 -23 32]**'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 [-33 -31 -29 -28 -23 32]**'
- en: '|  |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 19.6**'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 19.6**'
- en: '**[Q1:](#ch19qa12q0a1)**'
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch19qa12q0a1)**'
- en: ''
  id: totrans-671
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you check whether 32.0 is a member of `set`?
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你会如何检查32.0是否是`set`的成员？
- en: '|  |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 19.6 answer**'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 19.6 答案**'
- en: '**[1:](#ch19qa11q1)**'
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch19qa11q1)**'
- en: ''
  id: totrans-677
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-678
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '|  |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-680
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Maps are versatile collections for unstructured data.
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射是用于非结构化数据的灵活集合。
- en: Composite literals provide a convenient means to initialize maps.
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合字面量提供了一种方便的方式来初始化映射。
- en: The `range` keyword can iterate over maps.
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range` 关键字可以遍历映射。'
- en: Maps share the same underlying data when assigned or passed to functions.
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当映射被赋值或传递给函数时，映射共享相同的基本数据。
- en: Collections become more powerful when combined with each other.
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当集合相互结合时，集合变得更加强大。
- en: Let’s see if you got this...
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: 'Experiment: words.go'
  id: totrans-687
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：words.go
- en: Write a function to count the frequency of words in a string of text and return
    a map of words with their counts. The function should convert the text to lowercase,
    and punctuation should be trimmed from words. The `strings` package contains several
    helpful functions for this task, including `Fields`, `ToLower`, and `Trim`.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数来计算文本字符串中单词的频率，并返回一个包含单词及其计数的映射。该函数应将文本转换为小写，并从单词中去除标点符号。`strings` 包包含几个有助于此任务的函数，包括
    `Fields`、`ToLower` 和 `Trim`。
- en: Use your function to count the frequency of words in the following passage and
    then display the count for any word that occurs more than once.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的函数来计算以下段落中单词的频率，然后显示任何出现多次的单词的计数。
- en: As far as eye could reach he saw nothing but the stems of the great plants about
    him receding in the violet shade, and far overhead the multiple transparency of
    huge leaves filtering the sunshine to the solemn splendour of twilight in which
    he walked. Whenever he felt able he ran again; the ground continued soft and springy,
    covered with the same resilient weed which was the first thing his hands had touched
    in Malacandra. Once or twice a small red creature scuttled across his path, but
    otherwise there seemed to be no life stirring in the wood; nothing to fear—except
    the fact of wandering unprovisioned and alone in a forest of unknown vegetation
    thousands or millions of miles beyond the reach or knowledge of man.
  id: totrans-690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 就他的视线所能达到的地方，他看到的只有周围大植物的茎在紫色的阴影中后退，而在头顶上方，巨大的叶子多次透明地过滤阳光，形成了他行走的庄严辉煌的黄昏。每当他认为自己能够做到的时候，他就再次奔跑；地面继续柔软而有弹性，覆盖着同样的有弹性的杂草，这是他在马拉坎达第一次用手触摸的东西。一次或两次，一个小红动物从他面前逃窜，但除此之外，似乎树林中没有生命在动；没有什么可怕的事情——除了在远离人类触及或认知的数千里或数百万里的未知植被森林中无装备、独自漫游的事实。
- en: ''
  id: totrans-691
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*C.S. Lewis, *Out of the Silent Planet,* (see [mng.bz/V7nO](http://mng.bz/V7nO))*'
  id: totrans-692
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*C.S. Lewis, *Out of the Silent Planet,* (see [mng.bz/V7nO](http://mng.bz/V7nO))*'
- en: 'Lesson 20\. Capstone: A slice of life'
  id: totrans-693
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第20课. 顶峰：生命的一角
- en: '![](f0155-01_alt.jpg)'
  id: totrans-694
  prefs: []
  type: TYPE_IMG
  zh: '![](f0155-01_alt.jpg)'
- en: For this challenge, you will build a simulation of underpopulation, overpopulation,
    and reproduction called Conway’s Game of Life (see [mng.bz/xOyY](http://mng.bz/xOyY)).
    The simulation is played out on a two-dimensional grid of cells. As such, this
    challenge focuses on slices.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个挑战，你将构建一个模拟人口不足、过度人口和繁殖的康威生命游戏（见[mng.bz/xOyY](http://mng.bz/xOyY)）。这个模拟是在一个二维细胞网格上进行的。因此，这个挑战侧重于切片。
- en: Each cell has eight adjacent cells in the horizontal, vertical, and diagonal
    directions. In each generation, cells live or die based on the number of living
    neighbors.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 每个细胞在水平、垂直和对角方向上都有八个相邻细胞。在每一代中，细胞根据活着的邻居数量来决定是生存还是死亡。
- en: 20.1\. A new universe
  id: totrans-697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1\. 新宇宙
- en: 'For your first implementation of the Game of Life, limit the universe to a
    fixed size. Decide on the dimensions of the grid and define some constants:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你第一次实现生命游戏，将宇宙限制为固定大小。确定网格的尺寸并定义一些常量：
- en: '[PRE59]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, define a `Universe` type to hold a two-dimensional field of cells. With
    a Boolean type, each cell will be either dead (`false`) or alive (`true`):'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个`Universe`类型来存储二维细胞场。使用布尔类型，每个细胞要么是死的(`false`)，要么是活的(`true`)：
- en: '[PRE60]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Uses slices rather than arrays so that a universe can be shared with, and modified
    by, functions or methods.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切片而不是数组，这样就可以通过函数或方法共享并修改宇宙。
- en: '|  |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-704
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '[Lesson 26](kindle_split_040.html#ch26) introduces pointers, an alternative
    that allows you to directly share arrays with functions and methods.'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '[课程26](kindle_split_040.html#ch26)介绍了指针，这是一种允许你直接通过函数和方法共享数组的替代方案。'
- en: '|  |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Write a `NewUniverse` function that uses `make` to allocate and return a `Universe`
    with `height` rows and `width` columns per row:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`NewUniverse`函数，使用`make`分配并返回一个具有`height`行和每行`width`列的`Universe`：
- en: '[PRE61]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Freshly allocated slices will default to the zero value, which is `false`, so
    the universe begins empty.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 新分配的切片将默认为零值，即`false`，因此宇宙开始时是空的。
- en: 20.1.1\. Looking at the universe
  id: totrans-710
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.1.1\. 观察宇宙
- en: 'Write a method to print a universe to the screen using the `fmt` package. Represent
    live cells with an asterisk and dead cells with a space. Be sure to move to a
    new line after printing each row:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个方法，使用`fmt`包将宇宙打印到屏幕上。用星号表示活着的细胞，用空格表示死细胞。确保在打印每一行后换行：
- en: '[PRE62]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Write a `main` function to create a `NewUniverse` and `Show` it. Before continuing,
    be sure that you can run your program, even though the universe is empty.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`main`函数来创建`NewUniverse`并显示它。在继续之前，确保你可以运行你的程序，即使宇宙是空的。
- en: 20.1.2\. Seeding live cells
  id: totrans-714
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.1.2\. 种植活细胞
- en: 'Write a `Seed` method that randomly sets approximately 25% of the cells to
    alive (`true`):'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`Seed`方法，随机将大约25%的细胞设置为活着的(`true`)：
- en: '[PRE63]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Remember to import `math/rand` to use the `Intn` function. When you’re done,
    update `main` to populate the universe with `Seed` and display your handiwork
    with `Show`.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 记得导入`math/rand`以使用`Intn`函数。完成后，更新`main`以使用`Seed`填充宇宙，并用`Show`显示你的作品。
- en: 20.2\. Implementing the game rules
  id: totrans-718
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.2\. 实现游戏规则
- en: 'The rules of Conway’s Game of Life are as follows:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 康威生命游戏的规则如下：
- en: A live cell with less than two live neighbors dies.
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活着的细胞如果少于两个活着的邻居就会死亡。
- en: A live cell with two or three live neighbors lives on to the next generation.
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两个或三个活邻居的活细胞会活到下一代。
- en: A live cell with more than three live neighbors dies.
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有超过三个活邻居的活细胞会死亡。
- en: A dead cell with exactly three live neighbors becomes a live cell.
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恰好有三个活邻居的死亡细胞变成活细胞。
- en: 'To implement the rules, break them down into three steps, each of which can
    be a method:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现规则，将它们分解为三个步骤，每个步骤都可以是一个方法：
- en: A way to determine whether a cell is alive
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定一个细胞是否活着的方法
- en: The ability to count the number of live neighbors
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够计算活细胞邻居数量的能力
- en: The logic to determine whether a cell should be alive or dead in the next generation
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定细胞在下一代应该活着还是死亡的逻辑
- en: 20.2.1\. Dead or alive?
  id: totrans-728
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.2.1. 死或活？
- en: It should be easy to determine whether a cell is dead or alive. Just look up
    a cell in the `Universe` slice. If the Boolean is `true`, the cell is alive.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很容易确定一个细胞是死是活。只需在`Universe`切片中查找一个单元格。如果布尔值为`true`，则单元格是活着的。
- en: 'Write an `Alive` method on the `Universe` type with the following signature:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Universe`类型上编写一个具有以下签名的`Alive`方法：
- en: '[PRE64]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: A complication arises when the cell is outside of the universe. Is (–1,–1) dead
    or alive? On an 80 × 15 grid, is (80,15) dead or alive?
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 当细胞在宇宙之外时，会出现一个复杂的情况。(-1,-1)是死是活？在一个80 × 15的网格上，(80,15)是死是活？
- en: To address this, make the universe wrap around. The neighbor above (0,0) will
    be (0,14) instead of (0,–1), which can be calculated by adding `height` to `y`.
    If `y` exceeds the `height` of the grid, you can turn to the modulus operator
    (`%`) that we used for leap year calculations. Use `%` to divide `y` by `height`
    and keep the remainder. The same goes for `x` and `width`.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，使宇宙环绕。上面的邻居（0,0）将变成（0,14）而不是（0,–1），这可以通过将`height`加到`y`上来计算。如果`y`超过了网格的`height`，你可以转向我们用于闰年计算的模运算符（`%`）。使用`%`将`y`除以`height`并保留余数。对于`x`和`width`也是同样的道理。
- en: 20.2.2\. Counting neighbors
  id: totrans-734
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.2.2. 计算邻居数量
- en: 'Write a method to count the number of live neighbors for a given cell, from
    0 to 8\. Rather than access the universe data directly, use the `Alive` method
    so that the universe wraps around:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个方法来计算给定单元格的活细胞邻居数量，从0到8。而不是直接访问宇宙数据，使用`Alive`方法以便宇宙可以环绕：
- en: '[PRE65]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Be sure to only count adjacent neighbors and not the cell in question.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要只计算相邻的邻居，而不是计算中的单元格。
- en: 20.2.3\. The game logic
  id: totrans-738
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.2.3. 游戏逻辑
- en: 'Now that you can determine whether a cell has two, three, or more neighbors,
    you can implement the rules shown at the beginning of this section. Write a `Next`
    method to do this:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以确定一个单元格是否有两个、三个或更多邻居，你可以实现本节开头所示的规则。编写一个`Next`方法来完成这个操作：
- en: '[PRE66]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Don’t modify the universe directly. Instead, return whether the cell should
    be dead or alive in the next generation.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 不要直接修改宇宙。相反，返回单元格在下一代应该死亡还是活着。
- en: 20.3\. Parallel universe
  id: totrans-742
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.3. 并行宇宙
- en: To complete the simulation, you need to step through each cell in the universe
    and determine what its `Next` state should be.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成模拟，你需要遍历宇宙中的每个单元格并确定其`Next`状态应该是什么。
- en: There’s one catch. When counting neighbors, your count should be based on the
    previous state of the universe. If you modify the universe directly, those changes
    will influence the neighbor counts for the surrounding cells.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个陷阱。在计算邻居时，你的计数应该基于宇宙的先前状态。如果你直接修改宇宙，那些更改将影响周围单元格的邻居计数。
- en: 'A simple solution is to create two universes of the same size. Read through
    universe A while setting cells in universe B. Write a `Step` function to perform
    this operation:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方案是创建两个相同大小的宇宙。在读取宇宙A的同时设置宇宙B中的单元格。编写一个`Step`函数来执行此操作：
- en: '[PRE67]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Once universe B holds the next generation, you can swap universes and repeat:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦宇宙B包含下一代，你可以交换宇宙并重复：
- en: '[PRE68]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: To clear the screen before displaying a new generation, print `"\x0c"`, which
    is a special ANSI escape sequence. Then display the universe and use the `Sleep`
    function from the `time` package to slow down the animation.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示新一代之前清除屏幕，打印`"\x0c"`，这是一个特殊的ANSI转义序列。然后显示宇宙并使用`time`包中的`Sleep`函数来减慢动画。
- en: '|  |'
  id: totrans-750
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-751
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Outside of the Go Playground, you may need another mechanism to clear the screen,
    such as `"\033[H"` on macOS.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go Playground之外，你可能需要另一种机制来清除屏幕，例如在macOS上的`"\033[H"`。
- en: '|  |'
  id: totrans-753
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now you should have everything you need to write a complete Game of Life simulation
    and run it in the Go Playground.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该拥有编写完整的生命游戏模拟并在Go Playground中运行所需的一切。
- en: When you’re done, share a Playground link to your solution in the Manning forums
    at [forums.manning.com/forums/get-programming-with-go](http://forums.manning.com/forums/get-programming-with-go).
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，请将你的解决方案的Playground链接分享到Manning论坛的[forums.manning.com/forums/get-programming-with-go](http://forums.manning.com/forums/get-programming-with-go)。
