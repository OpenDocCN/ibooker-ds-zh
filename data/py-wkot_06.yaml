- en: 6 Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 函数
- en: Functions are one of the cornerstones of programming--but not because there’s
    a technical need for them. We could program without functions, if we really had
    to. But functions provide a number of great benefits.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是编程的基石之一——但这并不是因为技术上需要它们。如果我们真的需要，我们也可以不使用函数来编程。但函数提供了一系列巨大的好处。
- en: 'First, they allow us to avoid repetition in our code. Many programs have instructions
    that are repeated: asking a user to log in, reading data from a particular type
    of configuration file, or calculating the length of an MP3, for example. While
    the computer won’t mind (or even complain) if the same code appears in multiple
    places, we--and the people who have to maintain the code after we’re done with
    it--will suffer and likely complain. Such repetition is hard to remember and keep
    track of. Moreover, you’ll likely find that the code needs improvement and maintenance;
    if it occurs multiple times in your program, then you’ll need to find and fix
    it each of those times.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它们使我们能够避免代码中的重复。许多程序都有重复的指令：要求用户登录，从特定类型的配置文件中读取数据，或者计算MP3的长度，例如。虽然计算机不会介意（甚至不会抱怨）相同的代码出现在多个地方，但我们——以及在我们完成代码后需要维护代码的人——会感到痛苦，并可能抱怨。这种重复很难记住和跟踪。此外，你可能会发现代码需要改进和维护；如果它在程序中多次出现，那么你将需要每次都找到并修复它。
- en: As mentioned in chapter 2, the maxim “don’t repeat yourself” (DRY) is a good
    thing to keep in mind when programming. And writing functions is a great way to
    apply the phrase, “DRY up your code.”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如第2章所述，格言“不要重复自己”（DRY）是编程时应该牢记的好事情。编写函数是应用“DRY up your code”这个短语的一个很好的方式。
- en: A second benefit of functions is that they let us (as developers) think at a
    higher level of abstraction. Just as you can’t drive if you’re constantly thinking
    about what your car’s various parts are doing, you can’t program if you’re constantly
    thinking about all of the parts of your program and what they’re doing. It helps,
    semantically and cognitively, to wrap functionality into a named package, and
    then to use that name to refer to it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第二个好处是，它们让我们（作为开发者）能够在更高的抽象级别上进行思考。就像你不能在不断地思考你的汽车各个部件在做什么的情况下开车一样，你也不能在不断地思考程序的所有部分以及它们在做什么的情况下编程。将功能封装到命名的包中，然后使用该名称来引用它，这在语义和认知上都有帮助。
- en: In natural language, we create new verbs all of the time, such as *programming*
    and *texting*. We don’t have to do this; we could describe these actions using
    many more words, and with much more detail. But doing so becomes tedious and draws
    attention away from the point that we’re making. Functions are the verbs of programming;
    they let us define new actions based on old ones, and thus let us think in more
    sophisticated terms.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在自然语言中，我们经常创造新的动词，例如*编程*和*发短信*。我们不必这样做；我们可以用更多的词来描述这些动作，并且有更多的细节。但这样做会变得乏味，并使我们的注意力从我们正在做的要点上转移开。函数是编程的动词；它们让我们基于旧的动词定义新的动作，从而让我们能够以更复杂的方式思考。
- en: 'For all of these reasons, functions are a useful tool and are available in
    all programming languages. But Python’s functions add a twist to this: they’re
    objects, meaning that they can be treated as data. We can store functions in data
    structures and retrieve them from there as well. Using functions in this way seems
    odd to many newcomers to Python, but it provides a powerful technique that can
    reduce how much code we write and increase our flexibility.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些原因，函数是一个有用的工具，并且所有编程语言都提供了函数。但Python的函数给这个概念增加了一个转折：它们是对象，这意味着它们可以被当作数据来处理。我们可以将函数存储在数据结构中，并从那里检索它们。以这种方式使用函数对许多Python的新手来说似乎很奇怪，但它提供了一种强大的技术，可以减少我们编写的代码量，并增加我们的灵活性。
- en: Moreover, Python doesn’t allow for multiple definitions of the same function.
    In some languages, you can define a function multiple times, each time having
    a different signature. So you could, for example, define the function once as
    taking a single string argument, a second time as taking a list argument, a third
    time as taking a dict argument, and a fourth time as taking three float arguments.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python 不允许对同一函数进行多次定义。在某些语言中，你可以多次定义一个函数，每次定义有不同的签名。例如，你可以一次定义一个函数，接受一个字符串参数，第二次定义时接受一个列表参数，第三次定义时接受一个字典参数，第四次定义时接受三个浮点数参数。
- en: In Python, this functionality doesn’t exist; when you define a function, you’re
    assigning to a variable. And just as you can’t expect that `x` will simultaneously
    contain the values 5 and 7, you similarly can’t expect that a function will contain
    multiple implementations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，这种功能不存在；当你定义一个函数时，你是在对一个变量进行赋值。就像你不能期望`x`同时包含5和7的值一样，你同样不能期望一个函数包含多个实现。
- en: The way that we get around this problem in Python is with flexible parameters.
    Between default values, variable numbers of arguments (`*args`), and keyword arguments
    (`**kwargs`), we can write functions that handle a variety of situations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们通过灵活的参数来解决这个问题。在默认值、可变数量的参数（`*args`）和关键字参数（`**kwargs`）之间，我们可以编写处理各种情况的功能。
- en: You’ve already written a number of functions as you’ve progressed through this
    book, so the purpose of this chapter isn’t to teach you how to write functions.
    Rather, the goal is to show you how to use various function-related techniques.
    This will allow you not only to write code once and use it numerous times, but
    also to build up a hierarchy of new verbs, describing increasingly complex and
    higher level tasks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你在阅读这本书的过程中已经编写了许多函数，所以本章的目的不是教你如何编写函数。相反，目标是向你展示如何使用各种与函数相关的技术。这将不仅允许你编写一次代码并多次使用，而且还可以构建一个动词层次结构，描述越来越复杂和高级的任务。
- en: Table 6.1 What you need to know
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 你需要知道的内容
- en: '| Concept | What is it? | Example | To learn more |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 概念 | 它是什么？ | 示例 | 了解更多 |'
- en: '| `def` | Keyword for defining functions and methods | `def double(x): return
    x * 2` | [http://mng.bz/xW46](http://mng.bz/xW46) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `def` | 定义函数和方法的关键字 | `def double(x): return x * 2` | [http://mng.bz/xW46](http://mng.bz/xW46)
    |'
- en: '| `global` | In a function, indicates a variable must be global | `global x`
    | [http://mng.bz/mBNP](http://mng.bz/mBNP) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `global` | 在函数中，表示一个变量必须是全局的 | `global x` | [http://mng.bz/mBNP](http://mng.bz/mBNP)
    |'
- en: '| `nonlocal` | In a nested function, indicates a variable is local to the enclosing
    function | `nonlocal x` | [http://mng.bz/5apz](http://mng.bz/5apz) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `nonlocal` | 在嵌套函数中，表示一个变量是外部函数的局部变量 | `nonlocal x` | [http://mng.bz/5apz](http://mng.bz/5apz)
    |'
- en: '| `operator` module | Collection of methods that implement built-in operators
    | `operator.add(2,4)` | [http://mng.bz/6QAy](http://mng.bz/6QAy) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `operator`模块 | 实现内置运算符的方法集合 | `operator.add(2,4)` | [http://mng.bz/6QAy](http://mng.bz/6QAy)
    |'
- en: Default parameter values
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数值
- en: 'Let’s say that I can write a simple function that returns a friendly greeting:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我可以写一个简单的函数，它返回一个友好的问候语：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will work fine if I provide a value for `name`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我为`name`提供一个值，这将工作得很好：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But what if I don’t?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我没有提供呢？
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In other words, Python knows that the function takes a single argument. So if
    you call the function with one argument, you’re just fine. Call it with no arguments
    (or with two arguments, for that matter), and you’ll get an error message.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Python知道该函数接受一个参数。所以如果你用一个参数调用该函数，那就没问题。不传参数（或者传两个参数，按道理说）调用它，你会得到一个错误信息。
- en: 'How does Python know how many arguments the function should take? It knows
    because the function object, which we created when we defined the function with
    `def`, keeps track of that sort of thing. Instead of invoking the function, we
    can look inside the function object. The `__code__` attribute (see figure 6.1)
    contains the core of the function, including the bytecodes into which your function
    was compiled. Inside that object are a number of hints that Python keeps around,
    including this one:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python是如何知道函数应该接受多少个参数的？它是知道的，因为当我们在使用`def`定义函数时创建的函数对象，会跟踪这类事情。我们不必调用函数，我们可以查看函数对象内部。`__code__`属性（见图6.1）包含了函数的核心，包括将你的函数编译成的字节码。在这个对象中，Python保留了一些提示，包括这个：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](../Images/6-1.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-1.png)'
- en: Figure 6.1 A function object, along with its `__code__` section
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 函数对象及其`__code__`部分
- en: 'In other words, when we define our function with a parameter, the function
    object keeps track of that in `co_argcount`. And when we invoke the function,
    Python compares the number of arguments with `co_argcount`. If there’s a mismatch,
    then we get an error, as we saw a little earlier. However, there’s still a way
    that we can define the function such that an argument is optional--we can add
    a default value to the parameter:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当我们用参数定义我们的函数时，函数对象会在`co_argcount`中跟踪这一点。当我们调用函数时，Python会将参数的数量与`co_argcount`进行比较。如果它们不匹配，那么我们就会得到一个错误，就像我们之前看到的那样。然而，我们仍然可以定义函数，使得参数是可选的——我们可以在参数中添加一个默认值：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we run the function now, Python gives us more slack. If we pass an argument,
    then that value is assigned to the `name` parameter. But if we don’t pass an argument,
    then the
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行该函数时，Python 给我们更多的灵活性。如果我们传递一个参数，那么该值将被分配给 `name` 参数。但是如果我们没有传递参数，那么
- en: string `world` is assigned to `name`, as per our default (see table 6.2). In
    this way, we can call our function with either no arguments or one argument; however,
    two arguments aren’t allowed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，字符串 `world` 被分配给 `name`（参见表 6.2）。这样，我们可以用零个或一个参数调用我们的函数；然而，不允许有两个参数。
- en: Table 6.2 Calling hello
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2 调用 hello
- en: '| Call | Value of name | Return value |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 调用 | 名称的值 | 返回值 |'
- en: '| `hello()` | `world`, thanks to the default | `Hello, world!` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `hello()` | `world`，根据默认值 | `Hello, world!` |'
- en: '| `hello(''out there'')` | `out there` | `Hello, out there!` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `hello(''out there'')` | `out there` | `Hello, out there!` |'
- en: '| `hello(''a'', ''b'')` | Error: Too many arguments | No return value |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `hello(''a'', ''b'')` | 错误：参数过多 | 无返回值 |'
- en: '*Note* Parameters with defaults must come after those without defaults.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 带有默认值的参数必须放在没有默认值的参数之后。'
- en: '*Warning* Never use a mutable value, such as a list or dict, as a parameter’s
    default value. You shouldn’t do so because default values are stored and reused
    across calls to the function. This means that if you modify the default value
    in one call, that modification will be visible in the next call. Most code checkers
    and IDEs will warn you about this, but it’s important to keep in mind.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*警告* 永远不要使用可变值，例如列表或字典，作为参数的默认值。你不应该这样做，因为默认值在函数的多次调用中会被存储和重用。这意味着如果你在一个调用中修改了默认值，那么这个修改将在下一个调用中可见。大多数代码检查器和
    IDE 都会警告你这一点，但这一点很重要需要记住。'
- en: Exercise 25 ■ XML generator
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 25 ■ XML 生成器
- en: Python is often used not just to parse data, but to format it as well. In this
    exercise, you’ll write a function that uses a combination of different parameters
    and parameter types to produce a variety of outputs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python 经常不仅用于解析数据，还用于格式化数据。在这个练习中，你将编写一个函数，该函数使用不同参数和参数类型的组合来生成各种输出。
- en: Write a function, `myxml`, that allows you to create simple XML output. The
    output from the function will always be a string. The function can be invoked
    in a number of ways, as shown in table 6.3.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，`myxml`，允许你创建简单的 XML 输出。该函数的输出始终是一个字符串。该函数可以通过多种方式调用，如表 6.3 所示。
- en: Table 6.3 Calling `myxml`
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.3 调用 `myxml`
- en: '| Call | Return value |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 调用 | 返回值 |'
- en: '| `myxml(''foo'')` | `<foo></foo>` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `myxml(''foo'')` | `<foo></foo>` |'
- en: '| `myxml(''foo'', ''bar'')` | `<foo>bar</foo>` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `myxml(''foo'', ''bar'')` | `<foo>bar</foo>` |'
- en: '| `myxml(''foo'', ''bar'', a=1, b=2, c=3)` | `<foo a="1" b="2" c="3">bar</foo>`
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `myxml(''foo'', ''bar'', a=1, b=2, c=3)` | `<foo a="1" b="2" c="3">bar</foo>`
    |'
- en: Notice that in all cases, the first argument is the name of the tag. In the
    latter two cases, the second argument is the content (text) placed between the
    opening and closing tags. And in the third case, the name-value pairs will be
    turned into attributes inside of the opening tag.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在所有情况下，第一个参数是标签的名称。在后两种情况下，第二个参数是放置在开标签和闭标签之间的内容（文本）。在第三种情况下，名称-值对将被转换为开标签内的属性。
- en: Working it out
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: Let’s start by assuming that we only want our function to take a single argument,
    the name of the tag. That would be easy to write. We could say
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先假设我们只想让我们的函数接受单个参数，即标签的名称。这将很容易编写。我们可以这样说
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we decide we want to pass a second (optional) argument, this will fail. Some
    people thus assume that our function should take `*args`, meaning any number of
    arguments, all of which will be put in a tuple. But, as a general rule, `*args`
    is meant for situations in which you don’t know how many values you’ll be getting
    and you want to be able to accept any number.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定要传递第二个（可选）参数，这将失败。因此，有些人认为我们的函数应该接受 `*args`，这意味着接受任意数量的参数，所有这些参数都将被放入一个元组中。但是，作为一个通用规则，`*args`
    是用于你不知道将获得多少值并且希望能够接受任意数量值的情况。
- en: My general rule with `*args` is that it should be used when you’ll put its value
    into a `for` loop, and that if you’re grabbing elements from `*args` with numeric
    indexes, then you’re probably doing something wrong.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我对 `*args` 的通用规则是，当你会将其值放入 `for` 循环中时，应该使用它，如果你使用数字索引从 `*args` 中获取元素，那么你可能做错了。
- en: 'The other option, though, is to use a default. And that’s what I’ve gone with.
    The first parameter is mandatory, but the second is optional. If I make the second
    one (which I call `content` here) an empty string, then I know that either the
    user passes content or the content is empty. In either case, the function works.
    I can thus define it as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用默认值。这正是我所采取的。第一个参数是必需的，但第二个是可选的。如果我将第二个（我在这里称之为 `content`）设置为空字符串，那么我知道用户要么传递了内容，要么内容是空的。在两种情况下，函数都能正常工作。因此，我可以将其定义为以下内容：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But what about the key-value pairs that we can pass, and which are then placed
    as attributes in the opening tag?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们传递的键值对，然后放置在开标签中的属性是什么？
- en: When we define a function with `**kwargs`, we’re telling Python that we might
    pass **any** name-value pair in the style `name=value`. These arguments aren’t
    passed in the normal way but are treated separately, as *keyword arguments*. They’re
    used to create a dict, traditionally called `kwargs`, whose keys are the keyword
    names and whose values are the keyword values. Thus, we can say
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `**kwargs` 定义一个函数时，我们是在告诉 Python 我们可能会以 `name=value` 的风格传递任何名称-值对。这些参数不是以正常方式传递，而是作为单独的参数处理，称为
    *关键字参数*。它们用于创建一个字典，传统上称为 `kwargs`，其键是关键字名称，值是关键字值。因此，我们可以这样说
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, I’m not just taking the key-value pairs from `**kwargs` and
    putting them into a string. I first have to take that dict and turn it into name-value
    pairs in XML format. I do this with a list comprehension, running on the dict.
    For each key-value pair, I create a string, making sure that the first character
    in the string is a space, so we don’t bump up against the tagname in the opening
    tag.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我不仅从 `**kwargs` 中获取键值对并将它们放入字符串中。我首先必须将那个字典转换成 XML 格式的名称-值对。我通过在字典上运行列表推导来完成这个操作。对于每个键值对，我创建一个字符串，确保字符串的第一个字符是一个空格，这样我们就不至于在开标签中与标签名冲突。
- en: 'There’s a lot going on in this code, and it uses a few common Python paradigms.
    Understanding that, it’s probably useful to go through it, step by step, just
    to make things clearer:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有很多内容，它使用了几个常见的 Python 模式。理解这一点，逐步通过它可能是有用的，只是为了使事情更清晰：
- en: In the body of `myxml`, we know that `tagname` will be a string (the name of
    the tag), `content` will be a string (whatever content should go between the tags),
    and `kwargs` will be a dict (with the attribute name-value pairs).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `myxml` 的主体中，我们知道 `tagname` 将是一个字符串（标签的名称），`content` 将是一个字符串（应该在标签之间放置的内容），而
    `kwargs` 将是一个字典（包含属性名称-值对）。
- en: Both `content` and `kwargs` might be empty, if the user didn’t pass any values
    for those parameters.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户没有为这些参数传递任何值，`content` 和 `kwargs` 都可能为空。
- en: We use a list comprehension to iterate over `kwargs.items()`. This will provide
    us with one key-value pair in each iteration.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用列表推导来遍历 `kwargs.items()`。这将为我们提供每次迭代中的一个键值对。
- en: We use the key-value pair, assigned to the variables `key` and `value`, to create
    a string of the form `key="value"`. We get one such string for each of the attribute
    key-value pairs passed by the user.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用键值对，分配给变量 `key` 和 `value`，来创建形如 `key="value"` 的字符串。对于用户传递的每个属性键值对，我们都会得到这样一个字符串。
- en: The result of our list comprehension is a list of strings. We join these strings
    together with `str.join`, with an empty string between the elements.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们列表推导的结果是一个字符串列表。我们使用 `str.join` 将这些字符串连接起来，元素之间用一个空字符串分隔。
- en: Finally, we return the combination of the opening tag (with any attributes we
    might have gotten), the content, and the closing tag.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们返回由开标签（可能包含我们可能得到的任何属性）、内容和闭标签的组合。
- en: Solution
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ The function has one mandatory parameter, one with a default, and “**kwargs”.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数有一个必需的参数，一个具有默认值的参数，以及 “**kwargs”。
- en: ❷ Uses a list comprehension to create a string from kwargs
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用列表推导从 kwargs 创建字符串
- en: ❸ Returns the XML-formatted string
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回 XML 格式的字符串
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    OMoK](http://mng.bz/OMoK).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中查看这个代码的版本，[http://mng.bz/ OMoK](http://mng.bz/OMoK)。
- en: Screencast solution
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个解决方案的简短视频：[https://livebook.manning.com/ video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'Learning to work with functions, and the types of parameters that you can define,
    takes some time but is well worthwhile. Here are some exercises you can use to
    sharpen your thinking when it comes to function parameters:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何使用函数以及你可以定义的参数类型需要一些时间，但这是非常值得的。以下是一些你可以用来锻炼你对函数参数思考的练习：
- en: 'Write a `copyfile` function that takes one mandatory argument--the name of
    an input file--and any number of additional arguments: the names of files to which
    the input should be copied. Calling `copyfile(''myfile.txt'',` `''copy1 .txt'',`
    `''copy2.txt'',` `''copy3.txt'')` will create three copies of `myfile.txt`: one
    each in `copy1.txt`, `copy2.txt`, and `copy3.txt`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 `copyfile` 函数，它接受一个必选参数——输入文件的名称——以及任意数量的附加参数：应该复制到这些文件中的文件名。调用 `copyfile('myfile.txt',`
    `'copy1 .txt',` `'copy2.txt',` `'copy3.txt')` 将创建 `myfile.txt` 的三个副本：一个分别位于 `copy1.txt`、`copy2.txt`
    和 `copy3.txt` 中。
- en: Write a “factorial” function that takes any number of numeric arguments and
    returns the result of multiplying them all by one another.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个“阶乘”函数，该函数接受任意数量的数值参数，并返回将它们全部相乘的结果。
- en: Write an `anyjoin` function that works similarly to `str.join`, except that
    the first argument is a sequence of any types (not just of strings), and the second
    argument is the “glue” that we put between elements, defaulting to " " (a space).
    So `anyjoin([1,2,3])` will return `1` `2` `3`, and `anyjoin('abc',` `pass:'**')`
    will return `pass:a**b**c`.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 `anyjoin` 函数，它的工作方式与 `str.join` 类似，除了第一个参数是任何类型的序列（不仅仅是字符串），第二个参数是我们放在元素之间的“粘合剂”，默认为
    " "（一个空格）。所以 `anyjoin([1,2,3])` 将返回 `1` `2` `3`，而 `anyjoin('abc',` `pass:'**')`
    将返回 `pass:a**b**c`。
- en: Variable scoping in Python
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的变量作用域
- en: Variable scoping is one of those topics that many people prefer to ignore--first
    because it’s dry, and then because it’s obvious. The thing is, Python’s scoping
    is very different from what I’ve seen in other languages. Moreover, it explains
    a great deal about how the language works, and why certain decisions were made.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 变量作用域是许多人更喜欢忽略的话题之一——首先是因为它很枯燥，然后是因为它很明显。问题是，Python 的作用域与我在其他语言中看到的不同。此外，它解释了许多关于语言如何工作以及为什么做出某些决定的原因。
- en: The term *scoping* refers to the visibility of variables (and all names) from
    within the program. If I set a variable’s value within a function, have I affected
    it outside of the function as well? What if I set a variable’s value inside a
    `for` loop?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: “作用域”这个术语指的是变量（以及所有名称）在程序中的可见性。如果我在一个函数中设置了一个变量的值，它是否也会影响函数外部？如果我在 `for` 循环内部设置一个变量的值呢？
- en: 'Python has four levels of scoping:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有四个作用域级别：
- en: Local
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地
- en: Enclosing function
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封闭函数
- en: Global
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局
- en: Built-ins
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置
- en: These are known by the abbreviation LEGB. If you’re in a function, then all
    four are searched, in order. If you’re outside of a function, then only the final
    two (globals and built-ins) are searched. Once the identifier is found, Python
    stops searching.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以用缩写 LEGB 表示。如果你在一个函数中，那么会按顺序搜索这四个作用域。如果你不在函数中，那么只搜索最后两个（全局和内置）。一旦找到标识符，Python
    就会停止搜索。
- en: That’s an important consideration to keep in mind. If you haven’t defined a
    function, you’re operating at the global level. Indentation might be pervasive
    in Python, but it doesn’t affect variable scoping at all.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要记住的重要考虑因素。如果你没有定义函数，你就是在全局级别上操作。缩进在 Python 中可能很普遍，但它根本不影响变量作用域。
- en: But what if you run `int('s')`? Is `int` a global variable? No, it’s in the
    built-ins namespace. Python has very few reserved words; many of the most common
    types and functions we run are neither globals nor reserved keywords. Python searches
    the builtins namespace after the global one, before giving up on you and raising
    an exception.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你运行 `int('s')` 会怎样？`int` 是全局变量吗？不，它位于内置命名空间中。Python 有非常少的保留字；我们运行的大多数最常见类型和函数既不是全局变量也不是保留关键字。Python
    在放弃你并引发异常之前，会在全局命名空间之后搜索内置命名空间。
- en: What if you define a global name that’s identical to one in built-ins? Then
    you have effectively *shadowed* that value. I see this all the time in my courses,
    when people write something like
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义了一个与内置中相同的全局名称，会发生什么？那么你实际上已经“遮蔽”了那个值。我在我的课程中经常看到这种情况，当人们写出类似
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Why do we get this weird error? Because in addition to the `sum` function defined
    in built-ins, we have now defined a global variable named `sum`. And because globals
    come before built-ins in Python’s search path, Python discovers that `sum` is
    an integer and refuses to invoke it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们会得到这个奇怪的错误？因为我们除了在内置中定义的`sum`函数外，现在还定义了一个名为`sum`的全局变量。由于在Python的搜索路径中全局变量位于内置之前，Python发现`sum`是一个整数，并拒绝调用它。
- en: It’s a bit frustrating that the language doesn’t bother to check or warn you
    about redefining names in built-ins. However, there are tools (e.g., pylint) that
    will tell you if you’ve accidentally (or not) created a clashing name.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 语言不费心检查或警告你重新定义内置中的名称，这有点令人沮丧。然而，有一些工具（例如pylint）会告诉你你是否意外（或非意外）地创建了一个冲突的名称。
- en: Local variables
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量
- en: If I define a variable inside a function, then it’s considered to be a *local*
    variable. Local variables exist only as long as the function does; when the function
    goes away, so do the local variables it defined; for example
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在函数内部定义一个变量，那么它被认为是*局部*变量。局部变量只存在于函数执行期间；当函数结束时，它定义的局部变量也随之消失；例如
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code will print 100, 200, and then 100 again. In the code, we’ve defined
    two variables: `x` in the global scope is defined to be 100 and never changes,
    whereas `x` in the local scope, available only within the function `foo`, is 200
    and never changes (figure 6.2). The fact that both are called `x` doesn’t confuse
    Python, because from within the function, it’ll see the local `x` and ignore the
    global one entirely.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将打印100，200，然后再次打印100。在代码中，我们定义了两个变量：全局作用域中的`x`被定义为100且不会改变，而局部作用域中的`x`（仅在函数`foo`中可用）被定义为200且不会改变（图6.2）。尽管两者都被称为`x`，但Python不会混淆，因为在函数内部，它会看到局部`x`并完全忽略全局的`x`。
- en: '![](../Images/6-2.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-2.png)'
- en: Figure 6.2 Inner vs. outer `x`
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 内部与外部`x`的比较
- en: The global statement
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 全局语句
- en: What if, from within the function, I want to change the global variable? That
    requires the use of the `global` declaration, which tells Python that you’re not
    interested in creating a local variable in this function. Rather, any retrievals
    or assignments should affect the global variable; for example
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想在函数内部更改全局变量怎么办？这需要使用`global`声明，它告诉Python你在这个函数中不感兴趣创建一个局部变量。相反，任何检索或赋值都应该影响全局变量；例如
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code will print 100, 200, and then 200, because there’s only one `x`, thanks
    to the `global` declaration.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将打印100，200，然后再次打印200，因为只有一个`x`，这是由于`global`声明的存在。
- en: Now, changing global variables from within a function is almost always a bad
    idea. And yet, there are rare times when it’s necessary. For example, you might
    need to update a configuration parameter that’s set as a global variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从函数内部更改全局变量几乎总是个坏主意。然而，在罕见的情况下，这是必要的。例如，你可能需要更新设置为全局变量的配置参数。
- en: Enclosing
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 封装
- en: 'Finally, let’s consider inner functions via the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过以下代码来考虑内部函数：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Already, this code seems a bit weird. What are we doing defining `bar` inside
    of `foo`? This inner function, sometimes known as a *closure*, is a function that’s
    defined when `foo` is executed. Indeed, every time that we run `foo`, we get a
    new function named `bar` back. But of course, the name `bar` is a local variable
    inside of `foo`; we can call the returned function whatever we want.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来有点奇怪。我们在`foo`内部定义`bar`是做什么的呢？这个内部函数，有时被称为*闭包*，是在执行`foo`时定义的。确实，每次我们运行`foo`时，我们都会得到一个名为`bar`的新函数。但当然，`bar`的名字是`foo`内部的局部变量；我们可以将返回的函数命名为任何我们想要的。
- en: When we run the code, the result is 200\. It makes sense that when we invoke
    `f`, we’re executing `bar`, which was returned by `foo`. And we can understand
    how `bar` has access to `y`, since it’s a local variable. But what about `x`?
    How does the function `bar` have access to `x`, a local variable in `foo`?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，结果是200。当我们调用`f`时，我们执行的是`bar`，它是`foo`返回的。我们可以理解`bar`是如何访问`y`的，因为它是局部变量。但关于`x`呢？函数`bar`是如何访问`foo`中的局部变量`x`的？
- en: 'The answer, of course, is LEGB:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 答案当然是LEGB：
- en: First, Python looks for `x` locally, in the local function `bar`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，Python在局部函数`bar`中查找`x`。
- en: Next, Python looks for `x` in the enclosing function `foo`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，Python在封装函数`foo`中查找`x`。
- en: If `x` were not in `foo`, then Python would continue looking at the global level.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`x`不在`foo`中，那么Python会继续在全局级别查找。
- en: And if `x` were not a global variable, then Python would look in the built-ins
    namespace.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`x`不是一个全局变量，那么Python会在内置命名空间中查找。
- en: 'What if I want to change the value of `x`, a local variable in the enclosing
    function? It’s not global, so the `global` declaration won’t work. In Python 3,
    though, we have the `nonlocal` keyword. This keyword tells Python: “Any assignment
    we do to this variable should go to the outer function, not to a (new) local variable”;
    for example'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想改变 `x` 的值，它是封装函数中的局部变量？它不是全局的，所以 `global` 声明不起作用。然而，在 Python 3 中，我们有 `nonlocal`
    关键字。这个关键字告诉 Python：“我们对这个变量的任何赋值都应该传递到外部函数，而不是到一个（新的）局部变量”；例如
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Initializes call_counter as a local variable in foo
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 foo 中将 call_counter 初始化为局部变量
- en: ❷ Tells bar that assignments to call_counter should affect the enclosing variable
    in foo
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 告诉 bar，对 call_counter 的赋值应该影响 foo 中的封装变量
- en: ❸ Increments call_counter, whose value sticks around across runs of bar
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 增加 call_counter 的值，其值在 bar 的运行之间保持不变
- en: ❹ Iterates over the numbers 10, 20, 30, ... 90
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 遍历数字 10, 20, 30, ... 90
- en: ❺ Calls b with each of the numbers in that range
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对该范围内的每个数字调用 b
- en: The output from this code is
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出是
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So any time you see Python accessing or setting a variable--which is often!--consider
    the LEGB scoping rule and how it’s always, without exception, used to find all
    identifiers, including data, functions, classes, and modules.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所以每次当你看到 Python 访问或设置一个变量——这经常发生——考虑 LEGB 命名空间规则以及它总是无例外地用于查找所有标识符，包括数据、函数、类和模块。
- en: Exercise 26 ■ Prefix notation calculator
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 26 ■ 前缀表示法计算器
- en: In Python, as in real life, we normally write mathematics using *infix* notation,
    as in `2+3`. But there’s also something known as *prefix* notation, in which the
    operator precedes the arguments. Using prefix notation, we would write `+` `2`
    `3`. There’s also *postfix* notation, sometimes known as “reverse Polish notation”
    (or RPN), which is still in use on HP brand calculators. That would look like
    `2` `3` `+`. And yes, the numbers must then be separated by spaces.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，就像现实生活中一样，我们通常使用 *中缀* 表示法来写数学表达式，例如 `2+3`。但还有一种称为 *前缀* 表示法的东西，其中操作符位于参数之前。使用前缀表示法，我们将写
    `+` `2` `3`。还有 *后缀* 表示法，有时也称为“逆波兰表示法”（或 RPN），它仍在 HP 品牌计算器上使用。这看起来像 `2` `3` `+`。是的，数字之间必须用空格分隔。
- en: Prefix and postfix notation are both useful in that they allow us to do sophisticated
    operations without parentheses. For example, if you write `2` `3` `4` `+` `*`
    in RPN, you’re telling the system to first add `3+4` and then multiply `2*7`.
    This is why HP calculators have an Enter key but no “=” key, which confuses newcomers
    greatly. In the Lisp programming language, prefix notation allows you to apply
    an operator to many numbers (e.g., `(+` `1` `2` `3` `4` `5)`) rather than get
    caught up with lots of `+` signs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀和后缀表示法都很有用，因为它们允许我们进行复杂的操作而不需要括号。例如，如果你在 RPN 中写 `2` `3` `4` `+` `*`，你是在告诉系统先计算
    `3+4`，然后乘以 `2*7`。这就是为什么 HP 计算器有一个 Enter 键但没有 “=” 键，这常常让新手感到困惑。在 Lisp 编程语言中，前缀表示法允许你将操作符应用于多个数字（例如，`(+`
    `1` `2` `3` `4` `5)`），而不是陷入大量的 `+` 符号中。
- en: 'For this exercise, I want you to write a function (`calc`) that expects a single
    argument--a string containing a simple math expression in prefix notation--with
    an operator and two numbers. Your program will parse the input and produce the
    appropriate output. For our purposes, it’s enough to handle the six basic arithmetic
    operations in Python: addition, subtraction, multiplication, division (/), modulus
    (%), and exponentiation (**). The normal Python math rules should work, such that
    division always results in a floating-point number. We’ll assume, for our purposes,
    that the argument will only contain one of our six operators and two valid numbers.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我想让你编写一个函数（`calc`），它期望一个参数——一个包含简单数学表达式的字符串，该表达式以前缀表示法表示，包含一个操作符和两个数字。你的程序将解析输入并产生适当的输出。对于我们的目的，我们只需要处理
    Python 的六个基本算术运算：加法、减法、乘法、除法（/）、取模（%）、和指数运算（**）。正常的 Python 数学规则应该适用，即除法总是得到一个浮点数。我们将假设，对于我们的目的，参数将只包含我们的六个运算符之一和两个有效数字。
- en: 'But wait, there’s a catch--or a hint, if you prefer: you should implement each
    of the operations as a separate function, and you shouldn’t use an `if` statement
    to decide which function should be run. Another hint: look at the `operator` module,
    whose functions implement many of Python’s operators.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，这里有一个问题——或者如果你愿意，可以看作是一个提示：你应该将每个操作实现为一个单独的函数，并且不应该使用 `if` 语句来决定应该运行哪个函数。另一个提示：查看
    `operator` 模块，它的函数实现了 Python 的许多运算符。
- en: Working it out
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解题思路
- en: The solution uses a technique known as a *dispatch table*, along with the `operator`
    module that comes with Python. It’s my favorite solution to this problem, but
    it’s not the only one--and it’s likely not the one that you first thought of.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案使用了一种称为 *调度表* 的技术，以及 Python 中的 `operator` 模块。这是我最喜欢的解决方案，但并非唯一，而且可能也不是你首先想到的。
- en: Let’s start with the simplest solution and work our way up to the solution I
    wrote. We’ll need a function for each of the operators. But then we’ll somehow
    need to translate from the operator string (e.g., `+` or `**`) to the function
    we want to run. We could use `if` statements to make such a decision, but a more
    common way to do this in Python is with dicts. After all, it’s pretty standard
    to have keys that are strings, and since we can store anything in the value, that
    includes functions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的解决方案开始，逐步过渡到我所写的解决方案。我们需要为每个运算符编写一个函数。但随后我们还需要将运算符字符串（例如，`+` 或 `**`）转换为我们要运行的函数。我们可以使用
    `if` 语句来做出这样的决定，但在 Python 中更常见的方法是使用字典。毕竟，使用字符串作为键是相当标准的，而且由于我们可以存储任何东西作为值，这包括函数。
- en: '*Note* Many of my students ask me how to create a `switch`-`case` statement
    in Python. They’re surprised to hear that they already know the answer, namely
    that Python doesn’t have such a statement, and that we use `if` instead. This
    is part of Python’s philosophy of having one, and only one, way to do something.
    It reduces programmers’ choices but makes the code clearer and easier to maintain.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 许多学生问我如何在 Python 中创建 `switch`-`case` 语句。他们惊讶地发现他们已经知道答案，即 Python 没有这样的语句，我们使用
    `if` 代替。这是 Python 哲学的一部分，即只有一个、唯一的方式来做某事。这减少了程序员的选项，但使代码更清晰且易于维护。'
- en: 'We can then retrieve the function from the dict and invoke it with parentheses:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从字典中检索函数并通过括号调用它：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ The keys in the operations dict are the operator strings that a user might
    enter, while the values are our functions associated with those strings.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 操作字典中的键是用户可能输入的运算符字符串，而值是与这些字符串关联的我们的函数。
- en: ❷ Breaks the user’s input apart
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 分割用户的输入
- en: ❸ Turns each of the user’s inputs from strings into integers
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将用户的每个输入从字符串转换为整数
- en: ❹ Applies the user’s chosen operator as a key in operations, returning a function--which
    we then invoke, passing it “first” and “second” as arguments
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在 operations 中将用户选择的运算符作为键，返回一个函数——然后我们调用它，传递“first”和“second”作为参数
- en: Perhaps my favorite part of the code is the final line. We have a dict in which
    the functions are the values. We can thus retrieve the function we want with `operations
    [operator]`, where `operator` is the first part of the string that we broke apart
    with `str.split`. Once we have a function, we can call it with parentheses, passing
    it our two operands, `first` and `second`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我最喜欢的代码部分是最后一行。我们有一个字典，其中的值是函数。因此，我们可以使用 `operations [operator]` 来检索我们想要的函数，其中
    `operator` 是我们使用 `str.split` 分割的字符串的第一部分。一旦我们有了函数，我们就可以通过括号调用它，传递两个操作数 `first`
    和 `second`。
- en: But how do we get `first` and `second`? From the user’s input string, in which
    we assume that there are three elements. We use `str.split` to break them apart,
    and immediately use unpacking to assign them to three variables.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何得到 `first` 和 `second`？从用户的输入字符串中，我们假设有三个元素。我们使用 `str.split` 来分割它们，并立即使用解包将它们分配给三个变量。
- en: Hedging your bets with maxsplit
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 maxsplit 来分散风险
- en: If you’re uncomfortable with the idea of invoking `str.split` and simply assuming
    that we’ll get three results back, there’s an easy way to deal with that. When
    you invoke `str.split`, pass a value to its optional `maxsplit` parameter. This
    parameter indicates how many splits will actually be performed. Another way to
    think about it is that it’s the index of the final element in the returned list.
    For example, if I write
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢调用 `str.split` 并简单地假设我们会得到三个结果，有一个简单的方法来处理这个问题。当你调用 `str.split` 时，向其可选的
    `maxsplit` 参数传递一个值。此参数表示将执行多少次分割。另一种思考方式是，它是返回列表中最后一个元素的索引。例如，如果我写下
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: as you can see, I get (as always) a list of strings. Because I invoked `str.split`
    without any arguments, Python used any whitespace characters as separators.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我得到了（就像往常一样）一串字符串。因为我没有传递任何参数调用`str.split`，Python 使用任何空白字符作为分隔符。
- en: 'But if I pass a value of 3 to `maxsplit`, I get the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我将 3 传递给 `maxsplit`，我得到以下结果：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that the returned list now has four elements. The Python documentation
    says that `maxsplit` tells `str.split` how many cuts to make. I prefer to think
    of that value as the largest index in the returned list--that is, because the
    returned list contains four elements, the final element will have an index of
    3\. Either way, `maxsplit` ensures that when we use unpacking on the result from
    it, we’re not going to encounter an error.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，返回的列表现在有四个元素。Python文档说`maxsplit`告诉`str.split`要切割多少次。我更喜欢将这个值视为返回列表中的最大索引--也就是说，因为返回的列表包含四个元素，最后一个元素的索引将是3。无论如何，`maxsplit`确保当我们使用解包操作从它那里获取结果时，我们不会遇到错误。
- en: All of this is fine, but this code doesn’t seem very DRY. The fact that we have
    to define each of our functions, even when they’re so similar to one another and
    are reimplementing existing functionality, is a bit frustrating and out of character
    for Python.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都很好，但这段代码似乎并不符合DRY原则。我们不得不定义每个函数，即使它们彼此非常相似并且正在重新实现现有功能，这有点令人沮丧，也与Python的风格不符。
- en: 'Fortunately, the `operator` module, which comes with Python, can help us. By
    importing `operator`, we get precisely the functions we need: `add`, `sub`, `mul`,
    `truediv`/ `floordiv`, `mod`, and `pow`. We no longer need to define our own functions,
    because we can use the ones that the module provides. The `add` function in `operators`
    does what we would normally expect from the `+` operator: it looks to its left,
    determines the type of the first parameter, and uses that to know what to invoke.
    `operator.add`, as a function, doesn’t need to look to its left; it checks the
    type of its first argument and uses that to determine which version of `+` to
    run.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python附带了一个`operator`模块，它可以帮我们。通过导入`operator`，我们得到了我们需要的精确函数：`add`、`sub`、`mul`、`truediv`/
    `floordiv`、`mod`和`pow`。我们不再需要定义自己的函数，因为我们可以使用模块提供的函数。`operators`中的`add`函数执行我们通常从`+`运算符期望的操作：它查看其左侧，确定第一个参数的类型，并使用该类型来确定要调用哪个版本`+`。
- en: In this particular exercise, we restricted the user’s inputs to integers, so
    we didn’t do any type checking. But you can imagine a version of this exercise
    in which we could handle a variety of different types, not just integers. In such
    a case, the various `operator` functions would know what to do with whatever types
    we’d hand them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的练习中，我们限制了用户的输入为整数，因此我们没有进行任何类型检查。但你可以想象一个版本的练习，我们可以处理各种不同类型，而不仅仅是整数。在这种情况下，各种`operator`函数将知道如何处理我们给它们的任何类型。
- en: Solution
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ The operator module provides functions that implement all built-in operators.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `operator`模块提供了实现所有内置运算符的函数。
- en: ❷ Yes, functions can be the values in a dict!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 是的，函数可以是字典中的值！
- en: ❸ You can choose between truediv, which returns a float, as with the “/ ” operator,
    or floordiv, which returns an integer, as with the “// ” operator.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 你可以选择truediv，它返回一个浮点数，就像“/”运算符一样，或者floordiv，它返回一个整数，就像“//”运算符一样。
- en: ❹ Splits the line, assigning via unpacking
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 拆分行，通过解包赋值
- en: ❺ Calls the function retrieved via operator, passing “first” and “second” as
    arguments
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 通过operator获取的函数调用，传递“first”和“second”作为参数
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    YrGo](http://mng.bz/YrGo).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中运行此代码的版本，网址为 [http://mng.bz/ YrGo](http://mng.bz/YrGo)。
- en: Screencast solution
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频：[https://livebook.manning.com/ video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'Treating functions as data, and storing them in data structures, is odd for
    many newcomers to Python. But it enables techniques that, although possible, are
    far more complex in other languages. Here are three more exercises that extend
    this idea even further:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数视为数据，并将它们存储在数据结构中，对于许多Python的新手来说很奇怪。但这使得其他语言中虽然可能但远更复杂的技巧成为可能。这里有三个更进一步的练习，它们进一步扩展了这个想法：
- en: Expand the program you wrote, such that the user’s input can contain any number
    of numbers, not just two. The program will thus handle `+` `3` `5` `7` or `/`
    `100` `5` `5`, and will apply the operator from left to right--giving the answers
    `15` and `4`, respectively.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展你编写的程序，使得用户的输入可以包含任意数量的数字，而不仅仅是两个。因此，程序将处理`+` `3` `5` `7`或`/` `100` `5` `5`，并将运算符从左到右应用--分别给出`15`和`4`的答案。
- en: 'Write a function, `apply_to_each`, that takes two arguments: a function that
    takes a single argument, and an iterable. Return a list whose values are the result
    of applying the function to each element in the iterable. (If this sounds familiar,
    it might be--this is an implementation of the classic `map` function, still available
    in Python. You can find a description of `map` in chapter 7.)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，`apply_to_each`，它接受两个参数：一个接受单个参数的函数和一个可迭代对象。返回一个列表，其值是应用函数到可迭代对象中每个元素的结果。（如果这听起来很熟悉，可能是因为——这是一个经典`map`函数的实现，Python中仍然可用。你可以在第7章中找到`map`的描述。）
- en: 'Write a function, `transform_lines`, that takes three arguments: a function
    that takes a single argument, the name of an input file, and the name of an output
    file. Calling the function will run the function on each line of the input file,
    with the results written to the output file. (Hint: the previous exercise and
    this one are closely related.)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，`transform_lines`，它接受三个参数：一个接受单个参数的函数、输入文件的名称和输出文件的名称。调用该函数将在输入文件的每一行上运行该函数，并将结果写入输出文件。（提示：前一个练习和这个练习密切相关。）
- en: Exercise 27 ■ Password generator
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习27：密码生成器
- en: Even today, many people use the same password on many different computers. This
    means that if someone figures out your password on system A, then they can log
    into systems B, C, and D where you used the same password. For this reason, many
    people (including me) use software that creates (and then remembers) long, randomly
    generated passwords. If you use such a system, then even if system A is compromised,
    your logins on systems B, C, and D are all safe.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在今天，许多人还在许多不同的计算机上使用相同的密码。这意味着如果有人破解了系统A上的密码，那么他们就可以登录到使用相同密码的系统B、C和D。因此，许多人（包括我）使用创建（并记住）长随机密码的软件。如果你使用这样的系统，那么即使系统A被攻破，你在系统B、C和D上的登录都是安全的。
- en: In this exercise, we’re going to create a password-generation function. Actually,
    we’re going to create a factory for password-generation functions. That is, I
    might need to generate a large number of passwords, all of which use the same
    set of characters. (You know how it is. Some applications require a mix of capital
    letters, lowercase letters, numbers, and symbols; whereas others require that
    you only use letters; and still others allow both letters and digits.) You’ll
    thus call the function `create_password _generator` with a string. That string
    will return a function, which itself takes an integer argument. Calling this function
    will return a password of the specified length, using the string from which it
    was created; for example
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个密码生成函数。实际上，我们将创建一个密码生成函数的工厂。也就是说，我可能需要生成大量密码，它们都使用相同的字符集。（你知道是怎么回事。有些应用程序需要大写字母、小写字母、数字和符号的混合；而其他应用程序则要求你只使用字母；还有其他应用程序允许使用字母和数字。）因此，你需要用字符串调用`create_password_generator`函数。该字符串将返回一个函数，该函数本身接受一个整数参数。调用此函数将返回指定长度的密码，使用创建它的字符串；例如
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A useful function to know about in implementing this function is the `random`
    module ([http://mng.bz/Z2wj](http://mng.bz/Z2wj)), and more specifically the `random.choice`
    function in that module. That function returns one (randomly chosen) element from
    a sequence.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现此函数时，一个有用的函数是`random`模块（[http://mng.bz/Z2wj](http://mng.bz/Z2wj)），特别是该模块中的`random.choice`函数。该函数从一个序列中返回一个（随机选择的）元素。
- en: 'The point of this exercise is to understand how to work with inner functions:
    defining them, returning them, and using them to create numerous similar functions.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的目的是理解如何使用内部函数：定义它们、返回它们，并使用它们创建许多类似函数。
- en: Working it out
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: This is an example of where you might want to use an inner function, sometimes
    known as a *closure*. The idea is that we’re invoking a function (`create_password
    _generator`) that returns a function (`create_password`). The returned, inner
    function knows what we did on our initial invocation but also has some functionality
    of its own. As a result, it needs to be defined as an inner function so that it
    can access variables from the initial (outer) invocation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你可能想要使用内部函数的例子，有时也称为*闭包*。其思路是我们调用一个函数（`create_password_generator`），该函数返回另一个函数（`create_password`）。返回的内部函数知道我们在初始调用中做了什么，同时它也有一些自己的功能。因此，它需要被定义为内部函数，以便它可以访问初始（外部）调用中的变量。
- en: The inner function is defined not when Python first executes the program, but
    rather when the outer function (`create_password_generator`) is executed. Indeed,
    we create a new inner function once for each time that `create_password_generator`
    is invoked.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 内部函数的定义并非在Python首次执行程序时，而是在外部函数（`create_password_generator`）执行时。实际上，每当调用`create_password_generator`时，我们都会创建一个新的内部函数。
- en: 'That new inner function is then returned to the caller. From Python’s perspective,
    there’s nothing special here--we can return any Python object from a function:
    a list, dict, or even a function. What is special here, though, is that the returned
    function references a variable in the outer function, where it was originally
    defined.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 那个新的内部函数随后被返回给调用者。从Python的角度来看，这里并没有什么特别之处——我们可以从函数中返回任何Python对象：列表、字典，甚至是函数。但这里特别之处在于，返回的函数引用了在外部函数中最初定义的变量。
- en: After all, we want to end up with a function to which we can pass an integer,
    and from which we can get a randomly generated password. But the password must
    contain certain characters, and different programs have different restrictions
    on what characters can be used for those passwords. Thus, we might want five alphanumeric
    characters, or 10 numbers, or 15 characters that are either alphanumeric or punctuation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们希望得到一个函数，我们可以向其传递一个整数，并从中获取一个随机生成的密码。但密码必须包含某些字符，不同的程序对密码中可以使用哪些字符有不同的限制。因此，我们可能需要五个字母数字字符，或者十个数字，或者十五个既可以是字母数字也可以是标点的字符。
- en: We thus define our outer function such that it takes a single argument, a string
    containing the characters from which we want to create a new password. The result
    of invoking this function is, as was indicated, a function--the dynamically defined
    `create _password`. This inner function has access to the original `characters`
    variable in the outer function because of Python’s LEGB precedence rule for variable
    lookup. (See sidebar, “Variable scoping in Python.”) When, inside of `create_password`,
    we look for the variable `characters`, it’s found in the enclosing function’s
    scope.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义外部函数，使其接受一个参数，即包含我们想要用于创建新密码的字符的字符串。调用此函数的结果，如前所述，是一个函数——动态定义的`create_password`。这个内部函数由于Python的LEGB变量查找优先级规则，可以访问外部函数中的原始`characters`变量。（参见侧边栏，“Python中的变量作用域。”）当我们在`create_password`内部查找变量`characters`时，它会在封装函数的作用域中找到。
- en: '![](../Images/6-3.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/6-3.png)'
- en: Figure 6.3 Python Tutor’s depiction of two password-generating functions
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 Python Tutor对两个密码生成函数的描述
- en: If we invoke `create_password_generator` twice, as shown in the visualization
    via the Python Tutor (figure 6.3), each invocation will return a separate version
    of `create_password`, with a separate value of `characters`. Each invocation of
    the outer function returns a new function, with its own local variables. At the
    same time, each of the returned inner functions has access to the local variables
    from its enclosing function. When we invoke one of the inner functions, we thus
    get a new password based on the combination of the inner function’s local variables
    and the outer (enclosing) function’s local variables.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们两次调用`create_password_generator`，如Python Tutor的可视化所示（图6.3），每次调用都会返回一个不同的`create_password`版本，具有不同的`characters`值。外部函数的每次调用都会返回一个新的函数，具有它自己的局部变量。同时，每个返回的内部函数都可以访问其封装函数的局部变量。当我们调用其中一个内部函数时，因此会得到一个基于内部函数的局部变量和外部（封装）函数的局部变量组合的新密码。
- en: '*Note* Working with inner functions and closures can be quite surprising and
    confusing at first. That’s particularly true because our instinct is to believe
    that when a function returns, its local variables and state all go away. Indeed,
    that’s normally true--but remember that in Python, an object isn’t released and
    garbage-collected if there’s at least one reference to it. And if the inner function
    is still referring to the stack frame in which it was defined, then the outer
    function will stick around as long as the inner function exists.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 使用内部函数和闭包最初可能会相当令人惊讶和困惑。这尤其是因为我们的直觉是认为当函数返回时，其局部变量和状态都会消失。确实，通常情况下是这样的——但请记住，在Python中，如果一个对象至少有一个引用，它就不会被释放和垃圾回收。如果内部函数仍然引用其定义时的栈帧，那么外部函数将一直存在，直到内部函数存在为止。'
- en: Solution
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Defines the outer function
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义外部函数
- en: ❷ Defines the inner function, with def running each time we run the outer function
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义内部函数，每次运行外部函数时都会运行def
- en: ❸ How long do we want the password to be?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们希望密码有多长？
- en: ❹ Adds a new, random element from characters to output
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从字符中添加一个新的随机元素到输出
- en: ❺ Returns a string based on the elements of output
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 返回基于输出元素的字符串
- en: ❻ Returns the inner function to the caller
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 返回给调用者的内部函数
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    GVEM](http://mng.bz/GVEM).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中运行此代码的版本：[http://mng.bz/GVEM](http://mng.bz/GVEM)。
- en: Screencast solution
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 观看此简短视频教程：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'Thinking of functions as data lets you work at even higher levels of abstraction
    than usual functions, and thus solve even higher level problems without worrying
    about the low-level details. However, it can take some time to internalize and
    understand how to pass functions as arguments to other functions, or to return
    functions from inside other functions. Here are some additional exercises you
    can try to better understand and work with them:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数视为数据可以使你达到比通常函数更高的抽象层次，从而解决更高层次的问题，而不必担心低级细节。然而，要内化和理解如何将函数作为参数传递给其他函数，或者从其他函数中返回函数，可能需要一些时间。以下是一些额外的练习，你可以尝试以更好地理解和处理它们：
- en: 'Now that you’ve written a function to create passwords, write `create_password_checker`,
    which checks that a given password meets the IT staff’s acceptability criteria.
    In other words, create a function with four parameters: `min_ uppercase`, `min_lowercase`,
    `min_punctuation`, and `min_digits`. These represent the minimum number of uppercase
    letters, lowercase letters, punctuations, and digits for an acceptable password.
    The output from `create_password_ checker` is a function that takes a potential
    password (string) as its input and returns a Boolean value indicating whether
    the string is an acceptable password.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在你已经编写了一个创建密码的函数，请编写 `create_password_checker`，该函数检查给定的密码是否符合 IT 人员可接受的标准。换句话说，创建一个具有四个参数的函数：`min_uppercase`、`min_lowercase`、`min_punctuation`
    和 `min_digits`。这些代表可接受密码中所需的最小大写字母、小写字母、标点符号和数字的数量。`create_password_checker` 的输出是一个函数，它接受一个可能的密码（字符串）作为输入，并返回一个布尔值，指示该字符串是否为可接受密码。
- en: Write a function, `getitem`, that takes a single argument and returns a function
    `f`. The returned `f` can then be invoked on any data structure whose elements
    can be selected via square brackets, and then returns that item. So if I invoke
    `f` `=` `getitem('a')`, and if I have a dict `d` `=` `{'a':1,` `'b':2}`, then
    `f(d)` will return 1\. (This is very similar to `operator.itemgetter`, a very
    useful function in many circumstances.)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，名为 `getitem`，它接受一个参数并返回一个函数 `f`。返回的 `f` 函数可以在任何可以通过方括号选择元素的复杂数据结构上调用，并返回该元素。所以如果我将
    `f` 赋值为 `getitem('a')`，并且我有一个字典 `d` `=` `{'a':1,` `'b':2}`，那么 `f(d)` 将返回 1。这与
    `operator.itemgetter` 非常相似，这是一个在许多情况下非常有用的函数。
- en: Write a function, `doboth`, that takes two functions as arguments (`f1` and
    `f2`) and returns a single function, `g`. Invoking `g(x)` should return the same
    result as invoking `f2(f1(x))`.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，名为 `doboth`，它接受两个函数作为参数（`f1` 和 `f2`）并返回一个单一函数 `g`。调用 `g(x)` 应该返回与调用 `f2(f1(x))`
    相同的结果。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Writing simple Python functions isn’t hard. But where Python’s functions really
    shine is in their flexibility--especially when it comes to parameter interpretation--and
    in the fact that functions are data too. In this chapter, we explored all of these
    ideas, which should give you some thoughts about how to take advantage of functions
    in your own programs.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 编写简单的 Python 函数并不难。但 Python 函数真正闪耀的地方在于它们的灵活性——特别是在参数解释方面——以及函数本身也是数据的事实。在本章中，我们探讨了所有这些想法，这应该会给你一些关于如何在你的程序中利用函数的想法。
- en: If you ever find yourself writing similar code multiple times, you should seriously
    consider generalizing it into a function that you can call from those locations.
    Moreover, if you find yourself implementing something that you might want to use
    in the future, implement it as a function. Besides, it’s often easier to understand,
    maintain, and test code that has been broken into functions, so even if you aren’t
    worried about reuse or higher levels of abstraction, it might still be beneficial
    to write your code as functions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己多次编写类似的代码，你应该认真考虑将其概括成一个函数，以便从这些位置调用。此外，如果你发现自己正在实现可能未来会用到的东西，就将其实现为一个函数。而且，将代码分解成函数通常更容易理解、维护和测试，所以即使你并不担心重用或更高层次的抽象，将代码编写为函数也可能是有益的。
