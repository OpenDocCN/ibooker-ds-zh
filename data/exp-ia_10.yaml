- en: '11  Deployment: Assets & Heroku'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11  部署：资源与 Heroku
- en: It's time to put our applications into the real world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将我们的应用程序投入到现实世界中了。
- en: The first part of this chapter will discuss assets. If you're building any sort
    of website, it's very likely that you'll be serving some CSS and some JavaScript.
    It's common to concatenate and minify these assets for performance. It's also
    common to code in languages that compile to CSS (like SASS and LESS), just as
    it's common to code in laguages that transpile to JavaScript (like CoffeeScript
    or TypeScript) or to concatenate and minify JavaScript. Debates quickly turn into
    flame wars when talking about things like this; should you use LESS or SASS? Is
    CoffeeScript a good thing? Whichever you choose, I'll show you how to use a few
    of these tools to package up your assets for the web.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分将讨论资源。如果您正在构建任何类型的网站，您很可能需要提供一些 CSS 和 JavaScript。为了性能，通常会将这些资源连接并压缩。同样，使用编译到
    CSS 的语言（如 SASS 和 LESS）进行编码，就像使用编译到 JavaScript 的语言（如 CoffeeScript 或 TypeScript）或连接和压缩
    JavaScript 一样，是很常见的。当谈论这类事情时，辩论很快就会变成激烈的争论；您应该使用 LESS 还是 SASS？CoffeeScript 是好事吗？无论您选择哪个，我都会向您展示如何使用这些工具中的几个来打包您的资源以供网络使用。
- en: 'The rest of this chapter will show you how to build your Express applications
    and then put them online. There are lots of deployment options, but we''ll choose
    one that''s easy and free to try: Heroku. We''ll add a few small things to our
    app and deploy an Express app into the wild!'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余部分将向您展示如何构建您的 Express 应用程序，然后将它们上线。有众多部署选项，但我们将选择一个简单且免费的选项：Heroku。我们将在我们的应用程序中添加一些小功能，并将
    Express 应用程序部署到野外！
- en: 'After this chapter, you''ll:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，您将：
- en: ·  Develop CSS with more ease using the LESS preprocessor
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·  使用 LESS 预处理器更轻松地开发 CSS
- en: ·  Use Browserify to use `require` in the browser, just like in Node
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ·  使用 Browserify 在浏览器中使用 `require`，就像在 Node 中一样
- en: ·  Minify your assets to make the smallest files possible
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ·  压缩您的资源以生成尽可能小的文件
- en: ·  Use Grunt to run this compilation and much more
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ·  使用 Grunt 运行此编译以及其他更多操作
- en: ·  Use some Express middleware (connect-assets) as an alternative to this Grunt
    workflow
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ·  使用一些 Express 中间件（connect-assets）作为此 Grunt 工作流程的替代方案
- en: ·  Know how to deploy Express applications to the web with Heroku
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ·  了解如何使用 Heroku 将 Express 应用程序部署到网络
- en: 11.1  LESS, a more pleasant way to write CSS
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1  LESS，编写 CSS 的更愉快方式
- en: Harken back to Chapter 1, where we talked about the motivations for Express.
    In short, we said that Node.js is powerful but its syntax can be a little cumbersome
    and it can be a little limited. That's why Express was made—it doesn't fundamentally
    change Node; it just smooths it out a bit.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾第 1 章，我们讨论了 Express 的动机。简而言之，我们说 Node.js 功能强大，但其语法可能有点繁琐，而且功能有限。这就是 Express
    被创造出来的原因——它并没有从根本上改变 Node.js；它只是使它更加平滑。
- en: In that way, LESS and CSS are a lot like Express and Node. In short, CSS is
    a powerful layout tool but its syntax can be cumbersome and limited. That's why
    LESS was made—it doesn't fundamentally change CSS; it just smooths it out a bit.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，LESS 和 CSS 与 Express 和 Node.js 非常相似。简而言之，CSS 是一个强大的布局工具，但其语法可能有点繁琐，而且功能有限。这就是
    LESS 被创造出来的原因——它并没有从根本上改变 CSS；它只是使它更加平滑。
- en: CSS is a powerful tool for laying out webpages, but it's missing a number of
    features that people wanted. For example, developers want to reduce repetition
    in their code by with constant variables instead of hard-coded values; variables
    are present in LESS but not CSS.  LESS extends CSS and adds a number of powerful
    features.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 是布局网页的强大工具，但它缺少了人们想要的许多功能。例如，开发者希望通过使用常量变量而不是硬编码的值来减少代码中的重复；变量存在于 LESS 中，但不存在于
    CSS 中。LESS 扩展了 CSS 并添加了许多强大的功能。
- en: Unlike Express, LESS is actually its own language. That means that it has to
    be compiled down into CSS in order to be used by web browsers—browsers don't “speak”
    LESS, they speak CSS.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Express 不同，LESS 实际上是一种自己的语言。这意味着它必须被编译成 CSS 才能被网络浏览器使用——浏览器“说”的是 CSS，而不是 LESS。
- en: We'll see two different ways to compile LESS to CSS in Express applications.
    For now, while you're trying LESS, visit [http://less2css.org/](http://less2css.org/).
    On the left of the page, you'll be able to type LESS code, and compiled CSS will
    appear on the right.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Express 应用程序中看到两种不同的方法来编译 LESS 到 CSS。现在，当您尝试 LESS 时，请访问 [http://less2css.org/](http://less2css.org/)。在页面左侧，您将能够输入
    LESS 代码，编译后的 CSS 将会出现在右侧。
- en: '![](../Images/11_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_01.png)'
- en: Figure 11.1 less2css.org in action.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 less2css.org 在行动中。
- en: We'll go through a few examples in the following sections and you can try them
    out on that website. When it's time to integrate LESS into our Express apps, we'll
    move to a better, automated method.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将通过一些示例，你可以在那个网站上尝试它们。当是时候将 LESS 集成到我们的 Express 应用程序中时，我们将转向一个更好、自动化的方法。
- en: 'LESS is feature-filled, but it really has five major points:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: LESS 功能丰富，但它实际上有五个主要点：
- en: 1.  Variables, allowing you to define things like colors once and use them everywhere
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  变量，允许你定义一次像颜色这样的东西并在任何地方使用它们
- en: 2.  Functions, allowing you to manipulate variables (like darkening a color
    by 10%, for example)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  函数，允许你操作变量（例如，通过将颜色加深 10%）
- en: 3.  Nesting selectors, allowing you to structure your stylesheet more like your
    HTML and reduce repetition
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  嵌套选择器，允许你以更接近 HTML 的方式结构化你的样式表，并减少重复
- en: 4.  Mixins, allowing you to define reusable components and use them in various
    selectors
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  混入，允许你定义可重用的组件并在各种选择器中使用它们
- en: 5.  Includes, allowing you to split your stylesheets into multiple files (much
    like `require` in Node)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  包含，允许你将样式表拆分为多个文件（类似于 Node 中的 `require`）
- en: We'll do a very quick run-through of these major features. LESS is pretty complicated
    and we won't talk about every detail. If you're interested in the nitty-gritty
    features of LESS, take a look at its documentation at [http://lesscss.org/](http://lesscss.org/).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速浏览这些主要功能。LESS 非常复杂，我们不会讨论每个细节。如果你对 LESS 的细节功能感兴趣，请查看其文档在 [http://lesscss.org/](http://lesscss.org/)。
- en: 11.1.1   Variables
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1   变量
- en: CSS doesn't have variables. If your website's link color is `#29A1A4`, for example,
    and you decide you want to change it to `#454545`, you'd have to search for it
    everywhere in your CSS file and change it. If you want to experiment with a color
    that's used in many different places, you'll be doing find-replace, which can
    lead to various reliability issues. It's also unclear to other developers which
    color is which; where is that color used in various places?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 没有变量。例如，如果你的网站链接颜色是 `#29A1A4`，并且你决定想将其更改为 `#454545`，你将不得不在 CSS 文件中的每个地方搜索并更改它。如果你想试验在许多不同地方使用的颜色，你将进行查找替换，这可能会导致各种可靠性问题。对于其他开发者来说，哪个颜色是哪个也不清楚；那个颜色在各个地方是如何使用的？
- en: LESS added variables to CSS, allowing you to solve this kind of problem.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: LESS 为 CSS 添加了变量，允许你解决这类问题。
- en: 'For example, let''s say you want to define your site''s primary color as `#FF9900`.
    In LESS, you might do something like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想定义你网站的基色为 `#FF9900`。在 LESS 中，你可能做如下操作：
- en: Listing 11.1 Variables in LESS
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 LESS 中的变量
- en: '`@primary-color: #ff9900;  #A`   `.logo {` `  color: @primary-color;  #B` ` 
    font-weight: bold;` `}`   `a {` `  color: @primary-color;  #B``}`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`@primary-color: #ff9900;  #A`   `.logo {` `  color: @primary-color;  #B` ` 
    font-weight: bold;` `}`   `a {` `  color: @primary-color;  #B``}`'
- en: '#A Define the variable primary-color.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 定义变量 primary-color。'
- en: '#B Use that variable in several places.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 在几个地方使用该变量。'
- en: 'If you run the LESS code in Listing 11.1 through a LESS compiler (like the
    one at [http://less2css.org/](http://less2css.org/)), the following CSS will be
    produced:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将列表 11.1 中的 LESS 代码通过一个 LESS 编译器（如 [http://less2css.org/](http://less2css.org/)
    上的）运行，将生成以下 CSS：
- en: Listing 11.2 The compiled CSS from Listing 11.1
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 列表 11.1 编译的 CSS
- en: '`.logo {` `  color: #ff9900;  #A` `  font-weight: bold;` `}` `a {` `  color:
    #ff9900; #A``}`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`.logo {` `  color: #ff9900;  #A` `  font-weight: bold;` `}` `a {` `  color:
    #ff9900; #A``}`'
- en: '#A Notice that the variable is being inserted here.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 注意变量被插入在这里。'
- en: 'As you can see, the variable is being inserted into the resulting CSS. Now,
    if we want to change the primary color of our site, we only have to do it in one
    place: the variable at the top.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，变量被插入到生成的 CSS 中。现在，如果我们想更改我们网站的主色，我们只需在一个地方做这件事：顶部的变量。
- en: You might also notice that LESS looks an awful lot like CSS, and that's intentional—it's
    a strict superset of the language. That means that any valid CSS is valid LESS
    (but not the other way around). That means that you can easily import your existing
    CSS stylesheets into LESS and everything will work.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到 LESS 看起来非常像 CSS，这是故意的——它是语言的严格超集。这意味着任何有效的 CSS 都是有效的 LESS（反之则不然）。这意味着你可以轻松地将现有的
    CSS 样式表导入 LESS，并且一切都会正常工作。
- en: 11.1.2   Functions
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2   函数
- en: LESS also has functions, which allow you to manipulate variables and values
    just like you could in a programming language like JavaScript. Like a typical
    programming language, there are a number of built-in functions that can help you
    out. Unlike a typical programming language, however, these functions are all built
    into the language; you can't define your own; you'll have to use another feature
    called “mixins”, which we'll talk about in the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: LESS也有函数，允许你像在JavaScript这样的编程语言中一样操作变量和值。像典型的编程语言一样，有大量的内置函数可以帮助你。然而，与典型的编程语言不同的是，这些函数都是内置于语言中的；你不能定义自己的；你必须使用另一个称为“混入”的功能，我们将在下一节中讨论。
- en: LESS has a number of functions that you can use to manipulate colors. For example,
    imagine your links (your `<a>` tags) have a base color. When you hover over them,
    they should get lighter. When you click on them, they should get darker. In LESS,
    functions and variables make this easy.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: LESS有多个函数可以用来操作颜色。例如，想象一下你的链接（你的`<a>`标签）有一个基本颜色。当你悬停在它们上面时，它们应该变得更亮。当你点击它们时，它们应该变得更暗。在LESS中，函数和变量使得这一点变得简单。
- en: Listing 11.3 Using functions to lighten and darken colors
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.3 使用函数调整亮度和暗度
- en: '`@link-color: #0000ff;`   `a {` `  color: @link-color;  #A` `}` `a:hover {`
    `  color: lighten(@link-color, 25%);  #B` `}` `a:active {` `  color: darken(@link-color,
    20%);  #C``}`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`@link-color: #0000ff;`   `a {` `  color: @link-color;  #A` `}` `a:hover {`
    `  color: lighten(@link-color, 25%);  #B` `}` `a:active {` `  color: darken(@link-color,
    20%);  #C``}`'
- en: '#A Use the link-color variable that we''ve defined before; nothing new here.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 使用我们之前定义的链接颜色变量；这里没有新的内容。'
- en: '#B Lighten the link color by 25%.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 将链接颜色变亮25%。'
- en: '#C Darken the link color by 20%.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 将链接颜色加深20%。'
- en: 'After we compile this LESS into CSS, we''ll get something like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将LESS编译成CSS之后，我们会得到以下类似的内容：
- en: Listing 11.4 The compiled CSS from Listing 11.3
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.4 列表11.3编译后的CSS
- en: '`a {` `  color: #0000ff;` `}` `a:hover {` `  color: #8080ff; #A` `}` `a:active
    {` `  color: #000099; #A``}`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`a {` `  color: #0000ff;` `}` `a:hover {` `  color: #8080ff; #A` `}` `a:active
    {` `  color: #000099; #A``}`'
- en: '#A Notice that the colors are being manipulated to be lighter and darker.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 注意颜色正在被调整以变得更亮或更暗。'
- en: As you can see, LESS makes it easier to lighten and darken colors. Sure, you
    could have written that CSS yourself, but choosing finding the lightened and darkened
    colors would have been a bit of a hassle.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，LESS使得调整颜色的亮度和暗度变得更容易。当然，你自己也可以编写这样的CSS，但找到亮色和暗色可能会有些麻烦。
- en: There are a huge slew of other functions built into LESS. [http://lesscss.org/functions/](http://lesscss.org/functions/) lists
    them all.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: LESS内置了大量的其他函数。[http://lesscss.org/functions/](http://lesscss.org/functions/)列出了所有这些函数。
- en: 11.1.3   Mixins
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.3   混入（Mixins）
- en: Perhaps you're at this section wishing you could define your own functions;
    why does LESS get all of the power? Enter mixins, a way of defining reusable CSS
    declarations that you can use throughout your stylesheets.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你在这个部分希望可以定义你自己的函数；为什么LESS拥有如此强大的功能？进入混入（mixins），这是一种定义可重复使用的CSS声明的方法，你可以在整个样式表中使用它。
- en: 'Perhaps the most common example is with vendor prefixing. If you want to use
    the CSS `border-radius` property, you have to prefix it to make sure it works
    in Chrome, Firefox, Internet Explorer, Safari, and the like. You''ve probably
    seen something like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最常见的一个例子就是使用供应商前缀。如果你想使用CSS的`border-radius`属性，你必须给它加上前缀以确保它在Chrome、Firefox、Internet
    Explorer、Safari等浏览器上都能正常工作。你可能见过类似的东西：
- en: '`.my-element {` `  -webkit-border-radius: 5px;` `  -moz-border-radius: 5px;`
    `  -ms-border-radius: 5px;` `  border-radius: 5px;``}`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`.my-element {` `  -webkit-border-radius: 5px;` `  -moz-border-radius: 5px;`
    `  -ms-border-radius: 5px;` `  border-radius: 5px;``}`'
- en: In CSS, if you want to use border-radius and have it work on all browsers, you'll
    need the vendor prefixes. And if you want to put those prefixes, you'll have to
    write all of those every time you use border-radius. This can get tedious and
    is error-prone.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中，如果你想使用`border-radius`并且让它能在所有浏览器上工作，你需要供应商前缀。而且如果你想添加这些前缀，每次使用`border-radius`时你都必须写上它们。这可能会变得很繁琐，而且容易出错。
- en: In LESS, rather than define the border-radius and then make several vendor prefixed
    copies, you can define a mixin, or a reusable component that you can use in multiple
    declarations. They look an awful lot like functions in other programming languages.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在LESS中，你不需要定义`border-radius`然后创建多个供应商前缀的副本，你可以定义一个混入，或者一个可重复使用的组件，你可以在多个声明中使用它。它们在其他编程语言中的函数看起来非常相似。
- en: Listing 11.5 Mixins in LESS
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.5 LESS中的混入（Mixins）
- en: '`.border-radius(@radius) {          #A` `  -webkit-border-radius: @radius; 
    #A` `     -moz-border-radius: @radius;  #A` `      -ms-border-radius: @radius; 
    #A` `          border-radius: @radius;  #A` `}                                 
    #A`   `.my-element {` `  .border-radius(5px);  #B` `}` `.my-other-element {` ` 
    .border-radius(10px); #B``}`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`.border-radius(@radius) {          #A` `  -webkit-border-radius: @radius; 
    #A` `     -moz-border-radius: @radius;  #A` `      -ms-border-radius: @radius; 
    #A` `          border-radius: @radius;  #A` `}` `                                 
    #A` `.my-element {` `  .border-radius(5px);  #B` `}` `.my-other-element {` ` 
    .border-radius(10px); #B` `}`'
- en: '#A Define the border-radius mixin.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 定义border-radius mixin。'
- en: '#B Use our border-radius mixin in a couple of elements.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 在几个元素中使用我们的border-radius mixin。'
- en: 'Now, if you run that LESS through a compiler, it produces the following CSS:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您通过编译器运行那个LESS，它将生成以下CSS：
- en: Listing 11.6 The compiled CSS from Listing 11.5
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.6 列表11.5的编译CSS
- en: '`.my-element {` `  -webkit-border-radius: 5px;` `  -moz-border-radius: 5px;`
    `  -ms-border-radius: 5px;` `  border-radius: 5px;` `}` `.my-other-element {`
    `  -webkit-border-radius: 10px;` `  -moz-border-radius: 10px;` `  -ms-border-radius:
    10px;` `  border-radius: 10px;``}`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`.my-element {` `  -webkit-border-radius: 5px;` `  -moz-border-radius: 5px;`
    `  -ms-border-radius: 5px;` `  border-radius: 5px;` `}` `.my-other-element {`
    `  -webkit-border-radius: 10px;` `  -moz-border-radius: 10px;` `  -ms-border-radius:
    10px;` `  border-radius: 10px;` `}`'
- en: As you can see, the mixin is expanded into the tedious vendor-prefixed declarations
    so that you don't have to write them every time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，mixin被扩展为繁琐的供应商前缀声明，这样您就无需每次都编写它们。
- en: 11.1.4   Nesting
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.4   嵌套
- en: 'In HTML, your elements are nested. Everything goes inside the `<html>` tag,
    and then your content will go into the `<body>` tag. Inside the body, you might
    have a `<header>` with a `<nav>` for navigation. Your CSS doesn''t exactly mirror
    this; if you wanted to style your header and the navigation inside of your header,
    you might write some CSS like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中，您的元素是嵌套的。所有内容都位于`<html>`标签内，然后内容将进入`<body>`标签。在body内部，您可能有一个`<header>`，其中包含用于导航的`<nav>`。您的CSS并不完全反映这一点；如果您想为header及其内部的导航添加样式，您可能编写一些CSS如下：
- en: Listing 11.7 CSS example with no nesting
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.7 无嵌套的CSS示例
- en: '`header {` `  background-color: blue;` `}` `header nav {` `  color: yellow;``}`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`header {` `  background-color: blue;` `}` `header nav {` `  color: yellow;`
    `}`'
- en: 'In LESS, Listing 11.7 would be improved to this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在LESS中，列表11.7将改进为如下所示：
- en: Listing 11.8 A simple LESS nesting example
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.8 简单的LESS嵌套示例
- en: '`header {` `  background-color: blue;` `  nav {             #A` `    color:
    yellow;  #A` `  }                 #A``}`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`header {` `  background-color: blue;` `  nav {             #A` `    color:
    yellow;  #A` `  }                 #A` `}`'
- en: '#A Notice how the styling for the nav is inside of another selector.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 注意导航的样式是如何位于另一个选择器内部的。'
- en: LESS improves CSS to allow for nested rulesets. This means that your code will
    be shorter, more readable, and a better mirror of your HTML.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: LESS改进了CSS，允许嵌套规则集。这意味着您的代码将更短、更易读，并且更好地反映了您的HTML。
- en: NESTING THE PARENT SELECTORS
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套父选择器
- en: 'Nested rulesets can refer to their parent element. This is useful in lots of
    places, and a good example is links and their hover states. You might have a selector
    for `a`, `a:visited`, `a:hover`, and `a:active`. In CSS, you might do this with
    four separate selectors. In LESS, you''ll define an outer selector and then three
    inner selectors, one for each link state. It might look something like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套规则集可以引用其父元素。这在很多地方都很有用，一个很好的例子是链接及其悬停状态。您可能有一个针对`a`、`a:visited`、`a:hover`和`a:active`的选择器。在CSS中，您可能使用四个不同的选择器来做这件事。在LESS中，您将定义一个外部选择器，然后定义三个内部选择器，每个选择器对应一个链接状态。它可能看起来像这样：
- en: Listing 11.9 Referring to parent selectors in LESS
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.9 LESS中引用父选择器
- en: '`a {` `  color: #000099;` `  &:visited {  #A` `    color: #330099;` `  }` ` 
    &:hover {  #A` `    color: #0000ff;` `  }` `  &:active {  #A` `    color: #ff0099;`` 
    }``}`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`a {` `  color: #000099;` `  &:visited {  #A` `    color: #330099;` `  }` ` 
    &:hover {  #A` `    color: #0000ff;` `  }` `  &:active {  #A` `    color: #ff0099;`
    `  }` `}`'
- en: '#A In LESS, you use the & sign to refer to the parent selector.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 在LESS中，您使用&符号来引用父选择器。'
- en: LESS nesting can do simple things like nesting your selectors to match your
    HTML, but it can also nest selectors in relation to the parent selectors.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: LESS嵌套可以做一些简单的事情，比如嵌套选择器以匹配您的HTML，但它也可以根据父选择器嵌套选择器。
- en: 11.1.5   Includes
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.5   包含
- en: As your site gets bigger and bigger, you'll start to have more and more styles.
    In CSS, you can break your code up into multiple files, but this incurs the performance
    penalty of multiple HTTP requests.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的网站越来越大，您将开始拥有越来越多的样式。在CSS中，您可以拆分代码到多个文件中，但这会带来多个HTTP请求的性能惩罚。
- en: LESS allows you to split up your styles into multiple files, which are all concatenated
    into one CSS file at compilation time, saving performance. This means that developers
    can split their variables and mixins into separate files as needed, making for
    more modular code. You could also make one LESS file for the homepage, one for
    the user profiles page, and so on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: LESS 允许你在编译时将样式拆分成多个文件，这些文件最终合并成一个 CSS 文件，从而提高性能。这意味着开发者可以根据需要将变量和混入（mixins）拆分到单独的文件中，从而编写更模块化的代码。你也可以为首页创建一个
    LESS 文件，为用户资料页面创建另一个，依此类推。
- en: 'The syntax is quite simple:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 语法相当简单：
- en: Listing 11.10 Including another LESS file
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.10 包含另一个 LESS 文件
- en: '`@import "other-less-file";  #A`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`@import "other-less-file";  #A`'
- en: '#A Imports “other-less-file.less” in the same folder.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 在同一文件夹中导入“other-less-file.less”。'
- en: 11.1.6   Alternatives to LESS
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.6 LESS 的替代方案
- en: 'At this point in the book, it should come as no surprise: there''s more than
    one way to do CSS preprocessing. The elephant in the room is LESS''s biggest “rival”,
    Sass. Sass is very similar to LESS; both have variables, mixins, nested selectors,
    includes, and integration with Express. As far as the languages go, they''re pretty
    similar. Sass isn''t originally a Node project, but it is very popular and has
    done a solid job integrating itself into the Node world. You can check it out
    at[http://sass-lang.com/](http://sass-lang.com/).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的这一部分，这应该不会让人感到惊讶：CSS 预处理有多种方式。房间里的大象是 LESS 的最大“对手”，Sass。Sass 非常类似于 LESS；两者都有变量、混入、嵌套选择器、包含和与
    Express 的集成。就语言而言，它们非常相似。Sass 最初不是一个 Node 项目，但它非常受欢迎，并且很好地将自己整合到了 Node 世界中。你可以在[http://sass-lang.com/](http://sass-lang.com/)查看它。
- en: Most people reading this book will either want to use LESS or Sass. While we'll
    use LESS in this book, you can usually substitute the word “LESS” for the word
    “Sass” and it will be the same. LESS and Sass vary slightly in syntax, but they're
    largely the same conceptually and in how you integrate them with Express.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数阅读这本书的人要么想使用 LESS，要么想使用 Sass。虽然我们在这本书中会使用 LESS，但你通常可以将“LESS”这个词替换为“Sass”，它们的效果是一样的。LESS
    和 Sass 在语法上略有不同，但它们在概念上以及如何与 Express 集成方面大体相同。
- en: There are smaller-time CSS preprocessors that aim to fundamentally change CSS
    in one way or another. Stylus makes CSS's syntax a lot nicer and Roole adds a
    number of powerful features, and while they are both great, they aren't as popular
    as LESS or Sass.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些小型的 CSS 预处理器旨在以某种方式从根本上改变 CSS。Stylus 使 CSS 的语法变得更加优雅，Roole 添加了许多强大的功能，尽管它们都很出色，但它们不像
    LESS 或 Sass 那样受欢迎。
- en: Other CSS preprocessors like Myth and cssnext take a different angle. Rather
    than try to make a new language that compiles to CSS, they compile upcoming versions
    of CSS to current-day CSS. For example, the next version of CSS has variables,
    so these preprocessors compile this new syntax into current-day CSS.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 CSS 预处理器，如 Myth 和 cssnext，采取了不同的角度。它们不是试图创建一种编译成 CSS 的新语言，而是将 CSS 的未来版本编译成当前版本的
    CSS。例如，CSS 的下一个版本有变量，因此这些预处理器将这些新语法编译成当前版本的 CSS。
- en: 11.2  Using Browserify to require modules in the browser, just like in Node
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 使用 Browserify 在浏览器中引入模块，就像在 Node 中一样
- en: In short, Browserify is a tool for packaging JavaScript that allows you to use
    the `require`  function just like you do in Node. And I love Browserify. I just
    want to get that out of the way. Freakin' love this thing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Browserify 是一个打包 JavaScript 的工具，允许你使用 `require` 函数，就像你在 Node 中做的那样。而且我非常喜欢
    Browserify。我只是想先把这一点说出来。我真的很喜欢这个工具。
- en: 'I once heard someone describe browser-based programming as "hostile." I love
    making client-side projects, but I must admit that there are a lot of potholes
    in the road: browser inconsistencies, no reliable module system, an overwhelming
    number of varying-quality packages, no real choice of programming language...the
    list goes on. Sometimes it''s great, but sometimes it sucks! Browserify solves
    the module problem in a clever way: it lets you require modules exactly like you
    would in Node (in contrast to things like RequireJS, which are asynchronous and
    require an ugly callback). This is powerful for a few reasons.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经听到有人将基于浏览器的编程描述为“敌对的”。我喜欢制作客户端项目，但必须承认，路上有很多坑：浏览器的不一致性、没有可靠的模块系统、大量质量参差不齐的包、没有真正的编程语言选择……等等。有时候它很棒，但有时候很糟糕！Browserify
    以一种巧妙的方式解决了模块问题：它允许你以与 Node 中相同的方式引入模块（与像 RequireJS 这样的异步和需要丑陋回调的东西形成对比）。这有几个原因使其变得强大。
- en: First, this lets you easily define modules. If Browserify sees that `evan.js` requires `cake.js` and `burrito.js`,
    it'll package up `cake.js` and `burrito.js` and concatenate them into the compiled
    output file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这让你可以轻松地定义模块。如果Browserify看到`evan.js`需要`cake.js`和`burrito.js`，它就会将`cake.js`和`burrito.js`打包，并将它们连接到编译输出的文件中。
- en: Second, it's almost completely consistent with Node modules. This is huge—both
    Node-based and browser-based JavaScript can require Node modules, letting you
    share code between server and client with no extra work. You can even require
    most native Node modules in the browser, and many Node-isms like `__dirname` are
    resolved.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它与Node模块几乎完全一致。这是一个巨大的优势——基于Node和基于浏览器的JavaScript都可以使用Node模块，让你无需额外工作即可在服务器和客户端之间共享代码。你甚至可以在浏览器中要求大多数原生Node模块，许多Node特性如`__dirname`也会被解析。
- en: I could write sonnets about Browserify. This thing is truly great. Let me show
    it to you.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以写关于Browserify的十四行诗。这东西真的很棒。让我给你展示一下。
- en: 11.2.1   A simple Browserify example
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1   简单 Browserify 示例
- en: Let's say you want to write a webpage that generates a random color and sets
    the background to that color. Maybe you want to be inspired for the next great
    color scheme.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想编写一个网页，该网页生成一个随机颜色并将背景设置为该颜色。也许你想为下一个伟大的配色方案获得灵感。
- en: We're going to use an npm module called `random-color` (at [https://www.npmjs.com/package/random-color](https://www.npmjs.org/package/random-color)),
    which just generates a random RGB color string. If you check out the source code
    for this module, you'll see that it knows nothing about the browser—it's only
    designed to work with Node's module system.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`random-color`的npm模块（在[https://www.npmjs.com/package/random-color](https://www.npmjs.org/package/random-color)），它只是生成一个随机的RGB颜色字符串。如果你查看这个模块的源代码，你会看到它对浏览器一无所知——它只设计用于与Node的模块系统一起工作。
- en: 'Make a new folder to build this. We''ll make a `package.json` that looks something
    like this (your package versions may vary):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹来构建这个项目。我们将创建一个类似于以下的`package.json`（你的包版本可能不同）：
- en: Listing 11.11 package.json for our simple Browserify example
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.11 简单 Browserify 示例的 package.json
- en: '`{` `  "private": true,` `  "scripts": {` `    "build-my-js": "browserify main.js
    -o compiled.js"` `  },` `  "dependencies": {` `    "browserify": "^7.0.0",` `   
    "random-color": "^0.0.1"` `  }``}`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "private": true,` `  "scripts": {` `    "build-my-js": "browserify main.js
    -o compiled.js"` `  },` `  "dependencies": {` `    "browserify": "^7.0.0",` `   
    "random-color": "^0.0.1"` `  }``}`'
- en: 'Run `npm install` and then create a file called `main.js`. Put this inside:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm install`，然后创建一个名为`main.js`的文件。将以下内容放入其中：
- en: Listing 11.12 main.js for our simple Browserify example
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.12 简单 Browserify 示例的 main.js
- en: '`var randomColor = require("random-color");` `document.body.style.background
    = randomColor();`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`var randomColor = require("random-color");` `document.body.style.background
    = randomColor();`'
- en: Note that this file uses the `require` statement, but it's made for the browser,
    which doesn't have that natively. Get ready for your little mind to be blown!!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个文件使用了`require`语句，但它是为浏览器准备的，浏览器本身并没有这个功能。准备好你的小脑袋要被震撼了！！
- en: 'Finally, define a simple HTML file in the same directory with the following
    contents (it doesn''t matter what you call it, so long as it ends in `.html`):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在同一个目录中定义一个简单的HTML文件，内容如下（文件名不重要，只要以`.html`结尾即可）：
- en: Listing 11.13 HTML file for our simple Browserify example
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.13 简单 Browserify 示例的 HTML 文件
- en: '`<!DOCTYPE html>` `<html>` `<body>` `  <script src="compiled.js"></script>`
    `</body>``</html>`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`<!DOCTYPE html>` `<html>` `<body>` `  <script src="compiled.js"></script>`
    `</body>``</html>`'
- en: Now, if you save all that and run `npm run build-my-js`, Browserify will compile `main.js` into
    a new file, `compiled.js`. Open the HTML file you saved to see a webpage that
    generates random colors every time you refresh!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你保存所有这些并运行`npm run build-my-js`，Browserify会将`main.js`编译成一个新的文件，`compiled.js`。打开你保存的HTML文件，你会看到一个每次刷新都会生成随机颜色的网页！
- en: 'You can open `compiled.js` to see that your code is there, as is the `random-color` module.
    The code will be ugly, but here''s what it looks like:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以打开`compiled.js`来查看你的代码，以及`random-color`模块。代码可能看起来很丑，但它的样子如下：
- en: '`(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return
    a(o,!0);if(i) return i(o,!0);var f=new Error("Cannot find module ''"+o+` `"''");throw
    f.code="MODULE_NOT_FOUND",f}var l=n[o]={ exports:{}};t[o][0].call(l.exports,function(e){var
    n=t[o] [1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof
    require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]); return s})({1:[function(require,module,exports){
    var randomColor = require("random-color"); document.body.style.backgroundColor
    = randomColor();` `},{"random-color":2}],2:[function(require,module,exports){
    var random = require("rnd");` `module.exports = color;` `function color (max,
    min) {   max || (max = 255);   return ''rgb('' + random(max, min) + '', '' + random(max,
    min) + '', '' +   random(max, min) + '')''; }` `},{"rnd":3}],3:[function(require,module,exports){
    module.exports = random;` `function random (max, min) {   max || (max = 999999999999);  
    min || (min = 0);` `  return min + Math.floor(Math.random() * (max - min)); }`
    `},{}]},{},[1]);`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return
    a(o,!0);if(i) return i(o,!0);var f=new Error("Cannot find module ''"+o+` `"''");throw
    f.code="MODULE_NOT_FOUND",f}var l=n[o]={ exports:{}};t[o][0].call(l.exports,function(e){var
    n=t[o] [1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof
    require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]); return s})({1:[function(require,module,exports){
    var randomColor = require("random-color"); document.body.style.backgroundColor
    = randomColor();` `},{"random-color":2}],2:[function(require,module,exports){
    var random = require("rnd");` `module.exports = color;` `function color (max,
    min) {   max || (max = 255);   return ''rgb('' + random(max, min) + '', '' + random(max,
    min) + '', '' +   random(max, min) + '')''; }` `},{"rnd":3}],3:[function(require,module,exports){
    module.exports = random;` `function random (max, min) {   max || (max = 999999999999);  
    min || (min = 0);` `  return min + Math.floor(Math.random() * (max - min)); }`
    `},{}]},{},[1]);`'
- en: They're both wrapped in a bit of Browserify stuff to fake Node's module system,
    but they're there...and most importantly, they work! You can now require Node
    modules in the browser.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都包裹在一点 Browserify 东西中，以伪造 Node 的模块系统，但它们确实存在……最重要的是，它们可以工作！你现在可以在浏览器中引入 Node
    模块了。
- en: Browserify is so great. Love it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify 真的很棒。非常喜欢它。
- en: NOTE While you can require a number of utility libraries (even the built-in
    ones), there are some things you can't fake in the browser and therefore can't
    use in Browserify. For example, you can't run a web server in the browser, so
    some of the httpmodule is off-limits. But many things like `util` or modules you
    write are totally fair game!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：虽然你可以引入多个实用库（甚至内置的库），但在浏览器中有些事情是伪造不了的，因此不能在 Browserify 中使用。例如，你无法在浏览器中运行一个网络服务器，因此一些
    httpmodule 是不可用的。但许多像 `util` 或你编写的模块是完全合法的！
- en: As you write your code with Browserify, you'll want a nicer way to build this
    than having to run the build command every single time. Let's check out a tool
    that helps us use Browserify, LESS, and much much more.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Browserify 编写代码时，你可能会希望有一种比每次都运行构建命令更优雅的方式来构建它。让我们来看看一个可以帮助我们使用 Browserify、LESS
    以及更多工具的工具。
- en: 11.3  Using Grunt to compile, minify, and more
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 使用 Grunt 编译、压缩等
- en: We've taken a look at LESS and Browserify, but we haven't found an elegant way
    to wire them into our Express apps yet.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了 LESS 和 Browserify，但我们还没有找到一种优雅的方法将它们连接到我们的 Express 应用中。
- en: 'We''ll look at two ways to handle this, the first of which is with the use
    of a tool called Grunt. Grunt (at [http://gruntjs.com/](http://gruntjs.com/))
    calls itself "The JavaScript Task Runner", which is exactly what it sounds like:
    it runs tasks. If you''ve ever used Make or Rake, Grunt will seem familiar.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨两种处理方法，第一种是使用一个名为 Grunt 的工具。Grunt（在 [http://gruntjs.com/](http://gruntjs.com/)）自称是“JavaScript
    任务运行器”，这正是它的功能：运行任务。如果你曾经使用过 Make 或 Rake，Grunt 会让你感到熟悉。
- en: 'Grunt defines a framework onto which you define tasks. Like Express, Grunt
    is a minimal framework. It can''t do much alone; you''ll need to install and configure
    other tasks for Grunt to run. These tasks include compiling CoffeeScript or LESS
    or SASS, concatenating JavaScript and CSS, running tests, and plenty more. You
    can find a full list of tasks at [http://gruntjs.com/plugins](http://gruntjs.com/plugins),
    but we''ll be using four today: compiling and concatenating JavaScript with Browserify,
    compiling LESS into CSS, minifying JavaScript and CSS, and using "watch" to keep
    us from typing the same commands over and over again.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 在你定义的任务上定义了一个框架。就像 Express 一样，Grunt 是一个最小化的框架。它单独使用时功能有限；你需要安装和配置其他任务以便
    Grunt 运行。这些任务包括编译 CoffeeScript 或 LESS 或 SASS，连接 JavaScript 和 CSS，运行测试，等等。你可以在
    [http://gruntjs.com/plugins](http://gruntjs.com/plugins) 找到完整的任务列表，但今天我们将使用四个任务：使用
    Browserify 编译和连接 JavaScript，将 LESS 编译成 CSS，压缩 JavaScript 和 CSS，以及使用 "watch" 功能避免重复输入相同的命令。
- en: Let's start by installing Grunt.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装 Grunt 开始。
- en: 11.3.1   Installing Grunt
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1   安装 Grunt
- en: These instructions will deviate from the official Grunt instructions a bit.
    The documentation will tell you to install Grunt globally, but I believe that
    you should install everything locally if you can. This allows you to install multiple
    versions of Grunt on your system and doesn't pollute your globally installed packages.
    We'll talk more about these best practices in Chapter 12.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些说明将与官方 Grunt 指令略有不同。文档会告诉你全局安装 Grunt，但我认为如果你能的话，应该本地安装所有东西。这允许你在系统上安装多个版本的
    Grunt，并且不会污染全局安装的包。我们将在第 12 章中更多地讨论这些最佳实践。
- en: 'Every project has a `package.json`. If you want to add Grunt to a project,
    you''ll want to define a new script so that you can run the local Grunt:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都有一个 `package.json`。如果你想将 Grunt 添加到项目中，你需要定义一个新的脚本以便你可以运行本地的 Grunt：
- en: Listing 11.14 A script for running the local Grunt
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.14 运行本地 Grunt 的脚本
- en: '`...` `"scripts": {` `  "grunt": "grunt"``}, ...`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`...` `"scripts": {` `  "grunt": "grunt"` ``}, ...`'
- en: 'If you''d like to follow along with these examples, you can make a new project
    with a barebones package.json like this one:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要跟随这些示例，你可以创建一个新的项目，并使用如下类似的裸骨 package.json：
- en: Listing 11.15 A barebones package.json for these examples
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.15 为这些示例创建的裸骨 package.json
- en: '`{` `  "private": true,` `  "scripts": {` `    "grunt": "grunt"` `  }``}`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "private": true,` `  "scripts": {` `    "grunt": "grunt"` `  }``}`'
- en: Grunt isn't set up yet, but when it is, this allows us to say npm run grunt
    to run the local Grunt.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 尚未设置好，但一旦设置好，这将允许我们通过运行 `npm run grunt` 来运行本地的 Grunt。
- en: Next, you'll want to npm install grunt --save-dev and npm install grunt-cli
    --save-dev (or just npm install grunt grunt-cli --save-dev) to save Grunt and
    its command-line tool as local dependencies.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要运行 `npm install grunt --save-dev` 和 `npm install grunt-cli --save-dev`（或者直接运行
    `npm install grunt grunt-cli --save-dev`）来将 Grunt 和其命令行工具作为本地依赖项保存。
- en: Next, you'll want to create a something called a "Gruntfile", which Grunt examines
    to figure out what it should do. The Gruntfile lives at the root of your project
    (in the same folder as your package.json) and is called Gruntfile.js.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建一个名为 "Gruntfile" 的文件，Grunt 会检查这个文件来确定它应该做什么。Gruntfile 位于项目的根目录（与 package.json
    在同一个文件夹中）并且命名为 Gruntfile.js。
- en: Here's a "hello world" Gruntfile. When you run Grunt, it will look at this Gruntfile,
    find the appropriate task, and run the code inside.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 "hello world" 的 Gruntfile。当你运行 Grunt 时，它会查看这个 Gruntfile，找到适当的任务，并运行其中的代码。
- en: Listing 11.16 A skeleton Gruntfile
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.16 一个骨架 Gruntfile
- en: '`module.exports = function(grunt) {`   `  grunt.registerTask("default", "Say
    hello world.", function() {` `    grunt.log.write("Hello world!");` `  });`  `};`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.exports = function(grunt) {`   `  grunt.registerTask("default", "Say
    hello world.", function() {` `    grunt.log.write("Hello world!");` `  });`  `};`'
- en: 'To try this out, type `npm run grunt` into your terminal. You should see the
    following output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个，请在你的终端中输入 `npm run grunt`。你应该会看到以下输出：
- en: '`Running "default" task Hello world!` `Done, without errors.` `Grunt is now
    running the "hello world" task!`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Running "default" task Hello world!` `Done, without errors.` `Grunt is now
    running the "hello world" task!`'
- en: Unfortunately, "hello world" isn't of much use to us. Let's look at some more
    useful tasks we can define. If you'd like to follow along, you can take a look
    at this book's code samples at [https://github.com/EvanHahn/Express.js-in-Action-code/tree/master/Chapter_11/grunt-examples](https://github.com/EvanHahn/Express.js-in-Action-code/tree/master/Chapter_11/grunt-examples).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，"hello world" 对我们来说并没有什么用处。让我们看看一些更有用的任务，我们可以定义。如果你想要跟随，你可以查看这本书的代码示例在
    [https://github.com/EvanHahn/Express.js-in-Action-code/tree/master/Chapter_11/grunt-examples](https://github.com/EvanHahn/Express.js-in-Action-code/tree/master/Chapter_11/grunt-examples)。
- en: 11.3.2   Compiling LESS with Grunt
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2   使用 Grunt 编译 LESS
- en: When we learned about LESS above, I recommended a website that compiled your
    code live, in front of you. That's great for learning and it's useful to make
    sure your code is being compiled correctly, but it's hardly an automated solution.
    You don't want to have to put all of your code into a website, copy-paste the
    resulting CSS, and copy it into a CSS file! Let's make Grunt do it. (If you're
    not using LESS, there are other Grunt tasks for your favorite preprocessor. Just
    search the Grunt plugins page at [http://gruntjs.com/plugins](http://gruntjs.com/plugins).)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们上面学习 LESS 时，我推荐了一个可以实时编译你代码的网站。这对于学习来说很棒，并且确保你的代码被正确编译也是有用的，但这几乎不是一个自动化的解决方案。你不想把所有的代码都放到网站上，复制粘贴生成的
    CSS，然后再复制到 CSS 文件中！让我们让 Grunt 来做这件事。（如果你不使用 LESS，还有其他 Grunt 任务适用于你喜欢的预处理器。只需搜索
    Grunt 插件页面 [http://gruntjs.com/plugins](http://gruntjs.com/plugins) 即可。）
- en: Let's start by writing a very simple LESS file, which we'll compile to CSS with
    Grunt.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写一个非常简单的 LESS 文件，然后我们将使用 Grunt 编译成 CSS。
- en: Listing 11.17 A simple LESS file (in my_css/main.less)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.17 一个简单的 LESS 文件（在 my_css/main.less 中）
- en: '`article {` `  display: block;` `  h1 {` `    font-size: 16pt;` `    color:
    #900;` `  }` `  p {` `    line-height: 1.5em;` `  }``}`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`article {` `  display: block;` `  h1 {` `    font-size: 16pt;` `    color:
    #900;` `  }` `  p {` `    line-height: 1.5em;` `  }``}`'
- en: 'That should translate to the following CSS:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该转换成以下 CSS：
- en: Listing 11.18 Listing 11.17 compiled to CSS
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.18 列表 11.17 编译成 CSS
- en: '`article {` `  display: block;` `}` `article h1 {` `  font-size: 16pt;` ` 
    color: #900;` `}` `article p {` `  line-height: 1.5em;``}`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`article {` `  display: block;` `}` `article h1 {` `  font-size: 16pt;` ` 
    color: #900;` `}` `article p {` `  line-height: 1.5em;``}`'
- en: 'And if we minify that CSS, it should look like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们压缩这个 CSS，它应该看起来像这样：
- en: Listing 11.19 Listing 11.18, minified
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.19 列表 11.18，压缩后
- en: '`article{display: block}article h1{font-size:16pt; color:#900}article p{line-height:1.5em}`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`article{display: block}article h1{font-size:16pt; color:#900}article p{line-height:1.5em}`'
- en: 'We can use a third-party LESS task for Grunt to get us there! Start by installing
    this Grunt LESS task with `npm install grunt-contrib-less --save-dev`. Next, add
    the following to your Gruntfile:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用第三方 LESS 任务为 Grunt 获取所需内容！首先，使用 `npm install grunt-contrib-less --save-dev`
    安装此 Grunt LESS 任务。接下来，将以下内容添加到你的 Gruntfile 中：
- en: Listing 11.20 A Gruntfile with LESS
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.20 一个包含 LESS 的 Gruntfile
- en: '`module.exports = function(grunt) {`   `  grunt.initConfig({  #Z` `    less:
    {  #A` `      main: {                               #B` `        options: {                        
            #B` `          paths: ["my_css"]                        #B` `        },                                        
    #B` `        files: {                                   #B` `          "tmp/build/main.css":
    "my_css/main.less"  #B` `        }                                          #B`
    `      }` `    }` `  });`   `  grunt.loadNpmTasks("grunt-contrib-less");  #D`
      `  grunt.registerTask("default", ["less"]);  #E`  `};`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.exports = function(grunt) {` `  grunt.initConfig({  #Z` `    less:
    {  #A` `      main: {                               #B` `        options: {                          
    #B` `          paths: ["my_css"]                        #B` `        },                                  
    #B` `        files: {                                   #B` `          "tmp/build/main.css":
    "my_css/main.less"  #B` `        }                   #B` `      }` `    }` ` 
    });` `  grunt.loadNpmTasks("grunt-contrib-less");  #D` `  grunt.registerTask("default",
    ["less"]);  #E` `  };`'
- en: '#Z grunt.initConfig configures settings for  each of your Grunt tasks. In this
    case, we''re only configuring LESS right now.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '#Z grunt.initConfig 为每个 Grunt 任务配置设置。在这种情况下，我们目前只配置 LESS。'
- en: '#A We define the configuration for our LESS tasks. This is what the Grunt LESS
    task will look at.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 我们为 LESS 任务定义配置。这是 Grunt LESS 任务将查看的内容。'
- en: '#B Define the compilation configuration. This configuration tells the Grunt
    LESS plugin to compile my_css/main.less into tmp/build/main.css.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 定义编译配置。此配置告诉 Grunt LESS 插件将 my_css/main.less 编译成 tmp/build/main.css。'
- en: '#D This loads the Grunt LESS plugin. Without this, we won''t be able to compile
    anything!'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 这加载了 Grunt LESS 插件。没有这个，我们将无法编译任何内容！'
- en: '#E This tells Grunt to run the LESS compilation task when we run “grunt” at
    the command line.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '#E 这告诉 Grunt 在命令行运行 "grunt" 时执行 LESS 编译任务。'
- en: Now, when you run Grunt `npm run grunt`, your LESS will be compiled into `tmp/build/main.css`.
    After doing that, you'll need to make sure to serve that file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行 Grunt `npm run grunt` 时，LESS 将被编译成 `tmp/build/main.css`。完成这个步骤后，你需要确保提供该文件。
- en: SERVING THESE COMPILED ASSETS
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 提供这些编译后的资源
- en: 'Now that we''ve compiled something, we actually need to serve it to our visitors!
    We''ll use Express''s static middleware to do that. We''ll just add `tmp/build` as
    part of our middleware stack. For example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编译了一些内容，实际上我们需要将其提供给我们的访客！我们将使用 Express 的静态中间件来完成这个任务。我们只需将 `tmp/build`
    添加到我们的中间件堆栈中。例如：
- en: Listing 11.21 Static middleware with compiled files
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.21 带有编译文件的静态中间件
- en: '`var express = require("express");` `var path = require("path");`   `var app
    = express();`   `app.use(express.static(path.resolve(__dirname, "public"))); app.use(express.static(path.resolve(__dirname,
    "tmp/build")));`   `app.listen(3000, function() {` `  console.log("App started
    on port 3000.");``});`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var path = require("path");` `var app
    = express();` `app.use(express.static(path.resolve(__dirname, "public"))); app.use(express.static(path.resolve(__dirname,
    "tmp/build")));` `app.listen(3000, function() {` `  console.log("App started on
    port 3000.");``});`'
- en: Now, you can serve files from public and compiled files from `tmp/build`!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以从 public 目录和 `tmp/build` 目录提供文件！
- en: NOTE You likely don't want to commit compiled files into your repository, so
    you have to store them into a directory that you'll later ignore with version
    control. If you're using Git, add `tmp` to your `.gitignore` to make sure that
    your compiled assets aren't put into version control. Some people do like to commit
    these, so do what's right for you.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: NOTE 你可能不希望将编译后的文件提交到你的仓库中，所以你需要将它们存储在一个你稍后会忽略的版本控制目录中。如果你使用 Git，将 `tmp` 添加到你的
    `.gitignore` 中，以确保你的编译资源不会被纳入版本控制。有些人确实喜欢提交这些文件，所以请根据你的需要进行操作。
- en: 11.3.3   Using Browserify with Grunt
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3 使用 Grunt 与 Browserify
- en: Browserify, in its wisdom, has Grunt integration, so we can automate the process
    of compiling our client-side JavaScript. Browserify...what an amazing piece of
    technology.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify 智慧地集成了 Grunt，因此我们可以自动化编译客户端 JavaScript 的过程。Browserify...这是一项多么令人惊叹的技术。
- en: 'Start by installing `grunt-browserify`, a Grunt task for Browserify. Install
    it by running `npm install grunt-browserify --save-dev`, and then fill in Gruntfile.js
    with this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装 `grunt-browserify`，这是一个用于 Browserify 的 Grunt 任务。通过运行 `npm install grunt-browserify
    --save-dev` 来安装它，然后填写 Gruntfile.js，如下所示：
- en: Listing 11.22 A Gruntfile with Browserify
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.22 带有 Browserify 的 Gruntfile
- en: '`module.exports = function(grunt) {`   `  grunt.initConfig({` `    less: {
    /* ... */ }, #A` `    browserify: {        #B` `      client: {                           
    #C` `        src: ["my_javascripts/main.js"],   #C` `        dest: "tmp/build/main.js",         
    #C ` `      }` `    }  ` `  });`   `  grunt.loadNpmTasks("grunt-contrib-less");`
    `  grunt.loadNpmTasks("grunt-browserify");    #D`   `  grunt.registerTask("default",
    ["browserify", "less"]);  #E``};`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.exports = function(grunt) {` '
- en: '#A Note that we can keep our LESS configuration in here; typical Gruntfiles
    often have many bits of configuration.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 注意我们可以在其中保留我们的 LESS 配置；典型的 Gruntfile 经常包含许多配置项。'
- en: '#B Start configuring Browserify...'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 开始配置 Browserify...'
- en: '#C Compile main.js file from my_javascripts into tmp/build/main.js.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 将 my_javascripts 中的 main.js 文件编译到 tmp/build/main.js。'
- en: '#D Load the grunt-browserify task.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 加载 grunt-browserify 任务。'
- en: '#E When we run “grunt” at the command line, run both Browserify and LESS.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '#E 当我们在命令行中运行“grunt”时，同时运行 Browserify 和 LESS。'
- en: Now, when you run Grunt with `npm run grunt`, this will compile `main.js` in
    a folder called `my_javascripts` into `tmp/build/main.js`. If you've followed
    the steps from the LESS guide above, this should already be served!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行 Grunt 并使用 `npm run grunt` 时，这将把 `my_javascripts` 文件夹中的 `main.js` 编译成
    `tmp/build/main.js`。如果你已经按照上面的 LESS 指南进行了操作，这应该已经可以提供服务了！
- en: 11.3.4   Minifying the JavaScript with Grunt
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.4 使用 Grunt 压缩 JavaScript
- en: Unfortunately, Browserify doesn't minify your JavaScript for you; its only blemish.
    We'd like to do that to reduce file sizes and load times as best we can.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Browserify 并不会为你压缩 JavaScript；它的唯一瑕疵。我们希望这样做以尽可能减少文件大小和加载时间。
- en: UglifyJS is a popular JavaScript minifier that crushes your code down to tiny
    sizes. We'll be a Grunt task that takes advantage of UglifyJS to minify your already-Browserified
    code, called `grunt-contrib-uglify.` You can read more about it at [https://www.npmjs.com/package/grunt-contrib-uglify](https://www.npmjs.org/package/grunt-contrib-uglify).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: UglifyJS 是一个流行的 JavaScript 压缩工具，可以将你的代码压缩成极小的尺寸。我们将创建一个 Grunt 任务，利用 UglifyJS
    来压缩已经通过 Browserify 处理的代码，称为 `grunt-contrib-uglify`。你可以在 [https://www.npmjs.com/package/grunt-contrib-uglify](https://www.npmjs.org/package/grunt-contrib-uglify)
    上了解更多信息。
- en: 'First, install the Grunt task as usual with `npm install grunt-contrib-uglify
    --save-dev`. Next, let''s add this to our Gruntfile:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，像往常一样使用 `npm install grunt-contrib-uglify --save-dev` 安装 Grunt 任务。接下来，让我们将其添加到我们的
    Gruntfile 中：
- en: Listing 11.23 A Gruntfile with Browserify, LESS, and Uglify
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.23 带有 Browserify、LESS 和 Uglify 的 Gruntfile
- en: '`module.exports = function(grunt) {`   `  grunt.initConfig({` `    less: {
    /* ... */ },        #A` `    browserify: { /* ... */ },  #A` `    uglify: {                  
    #B` `      myApp: {                  #B` `        files: {                #B`
    `          "tmp/build/main.min.js": ["tmp/build/main.js"]  #B` `        }                      
    #B` `      }                         #B` `    }                           #B`
    `  });`   `  grunt.loadNpmTasks("grunt-browserify");` `  grunt.loadNpmTasks("grunt-contrib-less");`
    `  grunt.loadNpmTasks("grunt-contrib-uglify");`   `  grunt.registerTask("default",
    ["browserify", "less"]);  #C` `  grunt.registerTask("build", ["browserify", "less",
    "uglify"]);  #C`  `};`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.exports = function(grunt) {`   '
- en: '#A As before, we''ve left the existing LESS and Browserify tasks.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 如前所述，我们保留了现有的 LESS 和 Browserify 任务。'
- en: '#B This compiles your compiled JavaScript into a minified version. You can
    also overwrite the full JavaScript if you''d like: just set them both to "tmp/build/main.js".'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 这会将编译后的 JavaScript 编译成压缩版本。如果你愿意，也可以覆盖完整的 JavaScript：只需将它们都设置为 "tmp/build/main.js"。'
- en: '#C We''ve defined a new task called “build” in addition to our existing task.
    This will run when we type “npm run grunt build”.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 我们在现有的任务之外定义了一个名为“build”的新任务。当我们输入“npm run grunt build”时，它将会运行。'
- en: '`npm run grunt` won''t do anything different than it did before—it''ll run
    the default task, which in turns runs the Browserify and LESS tasks. But when
    you run `npm run grunt` `build`, you''ll run both the Browserify task and the
    Uglify task. Now your JavaScript will be minified!'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run grunt` 与之前没有区别——它会运行默认任务，该任务会运行 Browserify 和 LESS 任务。但当你运行 `npm run
    grunt build` 时，你会运行 Browserify 任务和 Uglify 任务。现在你的 JavaScript 将会被压缩！'
- en: 11.3.5   "grunt watch"
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.5   "grunt watch"
- en: While you're developing, you don't want to have to run `npm run grunt` every
    time you edit a file. There's a Grunt task that watches your files and re-runs
    any Grunt tasks when a change occurs. Enter `grunt-contrib-watch`. Let's use it
    to auto-compile any CSS and JavaScript whenever they change.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，你不想每次编辑文件时都要运行 `npm run grunt`。有一个 Grunt 任务可以监视你的文件，并在发生更改时重新运行任何 Grunt
    任务。输入 `grunt-contrib-watch`。让我们使用它来自动编译任何更改的 CSS 和 JavaScript。
- en: 'Start by installing the task with `npm install grunt-contrib-watch --save-dev`,
    then add some stuff to your Gruntfile like so:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用 `npm install grunt-contrib-watch --save-dev` 安装任务，然后在 Gruntfile 中添加一些内容，如下所示：
- en: Listing 11.24 A Gruntfile with watching added
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.24 添加了监视功能的 Gruntfile
- en: '`module.exports = function(grunt) {`   `  grunt.initConfig({` `    less: {
    /* ... */ },` `    browserify: { /* ... */ },` `    uglify: { /* ... */ },` `   
    watch: {` `      scripts: {               #A` `        files: ["**/*.js"],   
    #A` `        tasks: ["browserify"]  #A` `      },                       #A` `     
    styles: {                #B` `        files: ["**/*.less"],  #B` `        tasks:
    ["less"]        #B` `      }                        #B` `    }` `  });`   `  grunt.loadNpmTasks("grunt-browserify");`
    `  grunt.loadNpmTasks("grunt-contrib-less");` `  grunt.loadNpmTasks("grunt-contrib-uglify");`
    `  grunt.loadNpmTasks("grunt-contrib-watch");`   `  grunt.registerTask("default",
    ["browserify", "less"]);` `  grunt.registerTask("build", ["browserify", "less",
    "uglify"]);``};`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.exports = function(grunt) {`   '
- en: '#A Tell the Grunt watch task to run the Browserify task any time a .js file
    changes.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 告诉 Grunt 监视任务在 .js 文件更改时运行 Browserify 任务。'
- en: '#B Tell the Grunt watch task to run the LESS task any time a .less file changes.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 告诉 Grunt 监视任务在 .less 文件更改时运行 LESS 任务。'
- en: '#C Register the new watch task to execute when you run “grunt watch”.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 注册新的监视任务，以便在运行“grunt watch”时执行。'
- en: In the above example, we specify all files to watch and tasks to run when they
    change—it's that simple. Now, when you run `npm run grunt watch`, Grunt will watch
    your files and compile your CSS/JavaScript as needed. For example, if you change
    a file with the `.less` file extension, the LESS task will run (but no other tasks
    will); this is because we've configured `.less` files to trigger that task.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们指定了所有要监视的文件和更改时运行的任务——就这么简单。现在，当你运行 `npm run grunt watch` 时，Grunt
    将监视你的文件并根据需要编译 CSS/JavaScript。例如，如果你更改了扩展名为 `.less` 的文件，LESS 任务将运行（但不会运行其他任务）；这是因为我们已配置
    `.less` 文件来触发该任务。
- en: I find this super useful for development and strongly recommend it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得这非常实用，强烈推荐。
- en: 11.3.6   Other helpful Grunt tasks
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.6   其他有用的 Grunt 任务
- en: 'We''ve looked at a few Grunt tasks here, but there are loads more. You can
    find the full list on Grunt''s website at [http://gruntjs.com/plugins](http://gruntjs.com/plugins),
    but here are a few that might be helpful at some point:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里查看了一些 Grunt 任务，但还有很多。你可以在 Grunt 的网站上找到完整的列表 [http://gruntjs.com/plugins](http://gruntjs.com/plugins)，但这里有一些可能在某个时候有帮助：
- en: ·  grunt-contrib-sass is the Sass version of the LESS plugin we used. If you'd
    rather use Sass or SCSS, give this a look.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ·  grunt-contrib-sass 是我们使用的 LESS 插件的 Sass 版本。如果你更愿意使用 Sass 或 SCSS，可以看看这个。
- en: ·  grunt-contrib-requirejs uses the Require.js module system instead of Browserify.
    If that sounds better to you, you can use it instead.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ·  grunt-contrib-requirejs 使用 Require.js 模块系统而不是 Browserify。如果你觉得这样更好，你可以使用它。
- en: ·  grunt-contrib-concat simply concatenates files, which is a low-tech but popular
    solution for lots of problems.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ·  grunt-contrib-concat 简单地连接文件，这是一种低技术但流行的解决方案，用于解决许多问题。
- en: ·  grunt-contrib-imagemin minifies images (like JPEGs and PNGs). If you want
    to save bandwidth, this is a good tool.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ·  grunt-contrib-imagemin 压缩图像（如 JPEG 和 PNG）。如果你想节省带宽，这是一个好工具。
- en: ·  grunt-contrib-coffee lets you write CoffeeScript instead of JavaScript for
    your client-side code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ·  grunt-contrib-coffee 允许你用 CoffeeScript 而不是 JavaScript 编写客户端代码。
- en: 11.4  Using connect-assets to compile LESS and CoffeeScript and more
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4  使用 connect-assets 编译 LESS 和 CoffeeScript 等
- en: 'I don''t love Grunt, to be quite honest. I include it in the book because it''s
    incredibly popular and powerful, but I find the code verbose and a little confusing.
    There''s another solution for Express users: a piece of middleware called connect-assets
    (at [https://github.com/adunkman/connect-assets](https://github.com/adunkman/connect-assets)).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，我不太喜欢 Grunt。我把它包括在书中，因为它非常流行且功能强大，但我发现代码冗长且有些令人困惑。对于 Express 用户，还有一个解决方案：一个名为
    connect-assets 的中间件（在 [https://github.com/adunkman/connect-assets](https://github.com/adunkman/connect-assets)）。
- en: connect-assets can concatenate, compile to, and minify JavaScript and CSS. It
    supports CoffeeScript, Stylus, LESS, SASS, and even some EJS. It doesn't support
    Browserify and isn't as configurable as build tools like Grunt or Gulp, but it's
    very easy to use.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: connect-assets 可以连接、编译并压缩 JavaScript 和 CSS。它支持 CoffeeScript、Stylus、LESS、SASS，甚至一些
    EJS。它不支持 Browserify，并且不如 Grunt 或 Gulp 这样的构建工具可配置，但它非常容易使用。
- en: connect-assets is heavily inspired by the Sprockets asset pipeline from the
    Ruby on Rails world. If you've used that, this will be quite familiar, but if
    you haven't, don't worry!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: connect-assets 受到 Ruby on Rails 世界的 Sprockets 资产管道的极大启发。如果你使用过它，这将非常熟悉，但如果你没有，不用担心！
- en: A REMINDER ABOUT CONNECT Connect is another web framework for Node, and in short,
    Express middleware is compatible with Connect middleware. A lot of Express-compatible
    middleware has "connect" in the name like connect-assets.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 CONNECT 的提醒：Connect 是另一个 Node 的 Web 框架，简而言之，Express 中间件与 Connect 中间件兼容。许多与
    Express 兼容的中间件名称中都包含 "connect"，如 connect-assets。
- en: 11.4.1   Getting everything installed
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1   安装所有内容
- en: 'You''ll need to `npm install connect-assets --save` and any other compilers
    you''ll need:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要运行 `npm install connect-assets --save` 以及你需要的任何编译器：
- en: ·  coffee-script for CoffeeScript support
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ·  coffee-script 用于 CoffeeScript 支持
- en: ·  stylus for Stylus support
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ·  stylus 用于 Stylus 支持
- en: ·  less for LESS support
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ·  less 用于 LESS 支持
- en: ·  node-sass for SASS support
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ·  node-sass 用于 SASS 支持
- en: ·  ejs for some EJS support
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ·  ejs 用于一些 EJS 支持
- en: The last two won't be used by default in development mode, but will be in production.
    If you don't change the default options and forget to install those, your app
    will fail in production. Make sure to get those installed! For example, to install
    LESS, run `npm install less --save`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个在开发模式下默认不会使用，但在生产中会使用。如果你不更改默认选项并忘记安装这些，你的应用程序在生产中会失败。确保安装这些！例如，要安装 LESS，运行
    `npm install less --save`。
- en: You'll also need to pick a directory for your assets to live. By default, connect-assets
    will look for your CSS-related assets in `assets/css` and your JavaScript-related
    assets in `assets/js`, but this is configurable. I recommend using the defaults
    while you're getting started, so make a directory called `assets` and put the `css` and `js` directories
    inside.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要选择一个目录来存放你的资源。默认情况下，connect-assets会在`assets/css`目录中查找CSS相关资源，在`assets/js`目录中查找JavaScript相关资源，但这是可配置的。我建议你在开始时使用默认设置，因此创建一个名为`assets`的目录，并将`css`和`js`目录放入其中。
- en: 11.4.2   Setting up the middleware
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.2   设置中间件
- en: 'The middleware has some quick-start options that make it easy to get started,
    but I strongly recommend configuring things. For example, one of the configuration
    options can keep connect-assets from muddying the global namespace, which it does
    by default. Here''s what a simple application setup might look like:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件提供了一些快速入门选项，这使得开始使用变得容易，但我强烈建议进行配置。例如，配置选项之一可以防止connect-assets污染全局命名空间，这是它的默认行为。以下是一个简单的应用程序设置示例：
- en: Listing 11.25 Setting up the connect-assets middleware
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.25 设置connect-assets中间件
- en: '`var express = require("express");` `var assets = require("connect-assets");`
      `var app = express();` `app.use(assets({` `   helperContext: app.locals, #A`
    `   paths: ["assets/css", "assets/js"] #B` ` });`  `// ...`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var assets = require("connect-assets");`
    `var app = express();` `app.use(assets({` `   helperContext: app.locals, #A` `  
    paths: ["assets/css", "assets/js"] #B` ` });` `// ...`'
- en: '#A This attaches connect-assets''s view helpers to app.locals, rather than
    making them global variables.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这将connect-assets的视图助手附加到app.locals，而不是作为全局变量。'
- en: '#B Specify any asset paths you''re using. Order matters here—if main.js exists
    in multiple directories, for example, it''ll only compile the one listed first.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 指定你使用的任何资源路径。在这里，顺序很重要——例如，如果main.js存在于多个目录中，它只会编译第一个列出的。'
- en: This middleware has a number of sensible defaults. For example, it will enable
    minification and caching in production, but disable them in development. You can
    override this configuration if you truly want to; check the documentation for
    more detailed instructions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此中间件有一些合理的默认设置。例如，在生产环境中，它将启用压缩和缓存，但在开发环境中禁用它们。如果你确实想要覆盖此配置，请查看文档以获取更详细的说明。
- en: Now that we've set up the middleware, we'll need to link to those assets from
    views.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了中间件，我们需要从视图中链接到这些资源。
- en: 11.4.3   Linking to assets from views
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.3   从视图中链接到资源
- en: connect-assets provides two major helper functions to your views: `js` and `css`. `js("myfile")` will
    generate a `<script>` tag that corresponds to `myfile`. The `css` helper will
    do the same but for CSS, with a `<link>` tag. They return the HTML to include
    the most recent version of your assets, which means that they'll append a long
    hash to the name to make sure your browser doesn't use old cached assets.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: connect-assets为你的视图提供了两个主要的助手函数：`js`和`css`。`js("myfile")`将生成一个与`myfile`对应的`<script>`标签。`css`助手函数将执行相同的操作，但用于CSS，使用`<link>`标签。它们返回包含你资源最新版本的HTML，这意味着它们会在名称后附加一个长哈希值，以确保你的浏览器不会使用旧的缓存资源。
- en: 'If you''re using Jade to render your views, you''ll reference them from your
    views like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Jade来渲染你的视图，你可以像这样从你的视图中引用它们：
- en: Listing 11.26 Linking to connect-assets assets from Jade
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.26 从Jade链接到connect-assets资源
- en: '`!= css("my-css-file")` `!= js("my-javascript-file")`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`!= css("my-css-file")` `!= js("my-javascript-file")`'
- en: 'If you''re using EJS instead, it''s pretty similar. You reference connect-assets''s
    helpers from your views like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是EJS，这非常相似。你可以像这样从你的视图中引用connect-assets的助手函数：
- en: Listing 11.27 Linking to connect-assets assets from EJS
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.27 从EJS链接到connect-assets资源
- en: '`<%- css("my-css-file") %>` `<%- js("my-javascript-file") %>`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`<%- css("my-css-file") %>` `<%- js("my-javascript-file") %>`'
- en: If you're using another view engine, you'll need to make sure you aren't escaping
    HTML when you do this, because these helpers are spitting out raw HTML tags that
    shouldn't be escaped.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是其他视图引擎，你需要确保在执行此操作时不要转义HTML，因为这些助手函数会输出原始HTML标签，这些标签不应该被转义。
- en: 'In any case, these will spit out something like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这些操作将输出类似以下内容：
- en: Listing 11.28 HTML generated by connect-assets
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.28 connect-assets生成的HTML
- en: '`<link rel="stylesheet" href="/assets/my-css-file-{{SOME LONG HASH}}.css">`
    `<script src="/assets/my-javascript-file-{{SOME LONG HASH}}.js>`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`<link rel="stylesheet" href="/assets/my-css-file-{{SOME LONG HASH}}.css">`
    `<script src="/assets/my-javascript-file-{{SOME LONG HASH}}.js">`'
- en: And your assets will be loaded!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你的资源将被加载！
- en: 11.4.4   Concatenating scripts with directives
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.4   使用指令合并脚本
- en: You can't concatenate CSS files this way. Instead, you should use the `@import` syntax
    in your CSS preprocessor (like LESS or Sass). But connect-assets lets you concatenate
    JavaScript files using specially-formatted comments.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能这样连接 CSS 文件。相反，你应该在你的 CSS 预处理器（如 LESS 或 Sass）中使用 `@import` 语法。但 connect-assets
    允许你使用特殊格式的注释连接 JavaScript 文件。
- en: Let's say that your JavaScript file requires jQuery. All you have to do is define
    a comment that starts with `//= require` and then connect-assets will concatenate
    those files for you magically.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的 JavaScript 文件需要 jQuery。你只需要定义一个以 `//= require` 开头的注释，然后 connect-assets
    会为你神奇地连接这些文件。
- en: Listing 11.29 main.js, which requires jQuery
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.29 main.js，它需要 jQuery
- en: '`//= require jquery` `$(function() {``  // do what you need to do with jQuery`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`//= require jquery` `$(function() {``  // 使用 jQuery 做你需要做的事情`'
- en: And that's concatenation! It's that easy.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是连接！就这么简单。
- en: Now that we've looked at two ways to compile our assets, let's look at how to
    deploy our applications to the real web with Heroku!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了两种编译资源的方法，让我们看看如何使用 Heroku 将我们的应用程序部署到真正的网络中！
- en: 11.5  Deploying to Heroku
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5  部署到 Heroku
- en: Heroku's website has buzzwords like “cloud platform” and “built by developers
    for developers”. To us, it's a way to deploy our Node.js applications onto the
    real internet for free. No more `localhost:3000`! You'll be able to have your
    apps on the real life internet.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 的网站上有很多像“云平台”和“由开发者为开发者构建”这样的热门词汇。对我们来说，这是一种将我们的 Node.js 应用程序免费部署到真实互联网上的方式。不再有
    `localhost:3000`！你将能够在真实互联网上拥有你的应用程序。
- en: Essentially, when you deploy your site, you're sending your code to be run somewhere.
    In this case, when we deploy to Heroku, we'll be sending out code to Heroku's
    servers and they'll run your Express applications.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当你部署网站时，你是在将你的代码发送到某个地方运行。在这种情况下，当我们部署到 Heroku 时，我们将代码发送到 Heroku 的服务器上，它们将运行你的
    Express 应用程序。
- en: Like everything, there are a lot of ways to deploy your site. Heroku may not
    be the best option for you, and you should explore all of your options. We choose
    it here because it's relatively simple and it costs nothing.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有事情一样，部署你的网站有很多种方法。Heroku 可能不是最适合你的选项，你应该探索所有选项。我们在这里选择它是因为它相对简单且免费。
- en: 11.5.1   Getting Heroku set up
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.1   设置 Heroku
- en: First, you'll need to get a Heroku account. Visit Heroku.com and sign up (if
    you don't already have an account). The signup process should be fairly straightforward
    if you've ever signed up for any account online.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要获取一个 Heroku 账户。访问 Heroku.com 并注册（如果你还没有账户）。如果你曾经在线注册过任何账户，注册过程应该相当简单。
- en: '![](../Images/11_02.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_02.png)'
- en: Figure 11.2 Heroku's homepage.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 Heroku 的主页。
- en: 'Next, you''ll want to download and install the Heroku Toolbelt from [https://toolbelt.heroku.com/](https://toolbelt.heroku.com/).
    Follow the instructions for your specific operating system. Installing the Heroku
    Toolbelt on your computer will install three things:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要从 [https://toolbelt.heroku.com/](https://toolbelt.heroku.com/) 下载并安装
    Heroku Toolbelt。按照你特定操作系统的说明进行操作。在你的计算机上安装 Heroku Toolbelt 将安装以下三项：
- en: 1.  The Heroku client, a command-line tool for managing Heroku apps. We'll use
    it to create and manage our Express apps.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 1. Heroku 客户端，一个用于管理 Heroku 应用的命令行工具。我们将用它来创建和管理我们的 Express 应用程序。
- en: 2.  Foreman, another command-line tool. We'll use it to define how we want our
    applications to run.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 2. Foreman，另一个命令行工具。我们将用它来定义我们希望应用程序如何运行。
- en: 3.  Git, the version control system that you may already have installed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 3. Git，你可能已经安装的版本控制系统。
- en: 'Once you''ve installed it, there''s one last thing to do: authenticate your
    computer with Heroku. Open up a command line and type `heroku login`. This will
    ask you for your Heroku username and password.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，还有最后一件事要做：使用 Heroku 验证你的计算机。打开命令行并输入 `heroku login`。这将要求你输入 Heroku 用户名和密码。
- en: Once you've done all that, Heroku should be set up!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，Heroku 应该已经设置好了！
- en: 11.5.2   Making a Heroku-ready app
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.2   制作一个 Heroku 准备好的应用程序
- en: Let's make a simple hello world application and deploy it to Heroku, shall we?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的“Hello World”应用程序并将其部署到 Heroku，怎么样？
- en: 'To set your app up for Heroku, you don''t have to do too much different from
    what you normally would. While there are a few commands you''ll need to run in
    order to deploy, the only changes you''ll need to make are as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将你的应用程序设置好以供 Heroku 使用，你不需要做太多与平时不同的操作。虽然你需要运行一些命令来部署，但你唯一需要做的更改如下：
- en: 1.  Make sure to start the app on `process.env.PORT.`
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 确保在 `process.env.PORT` 上启动应用程序。
- en: 2.  Make sure your `package.json` lists a Node version.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 确保您的 `package.json` 列出了 Node 版本。
- en: 3.  Create a file that will be run when Heroku starts your app (called a Procfile).
    In our simple app, this file will only be one line.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 创建一个当 Heroku 启动您的应用时要运行的文件（称为 Procfile）。在我们的简单应用中，这个文件将只有一行。
- en: 4.  Add a file called `.gitignore` to your project.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 在您的项目中添加一个名为 `.gitignore` 的文件。
- en: Let's make a simple app and make sure we cross off these things.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的应用并确保我们完成了这些事项。
- en: The Express part of this “hello world” application should be pretty easy for
    you at this point in the book, and there's not much special we have to do in order
    to make sure that it works for Heroku; it's only a line or two.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的这一部分，Express 的“Hello World”应用应该对您来说很简单，而且为了确保它在 Heroku 上也能正常工作，我们不需要做太多特别的事情；这只需要一行或两行代码。
- en: 'First, define your `package.json`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义您的 `package.json`：
- en: Listing 11.30 package.json for our Heroku Express app
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.30 我们 Heroku Express 应用的 package.json 文件
- en: '`{` `  "private": true,` `  "scripts": {` `    "start": "node app"` `  },`
    `  "dependencies": {` `    "express": "^4.10.4"` `  },` `  "engines": {      
    #A` `    "node": "0.10.x" #A` `  }                  #A``}`'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "private": true,` `  "scripts": {` `    "start": "node app"` `  },`
    `  "dependencies": {` `    "express": "^4.10.4"` `  },` `  "engines": {      
    #A` `    "node": "0.10.x" #A` `  }                  #A``}`'
- en: '#A This tells Heroku (and anyone running your app) that your app requires Node
    0.10\. This helps Heroku disambiguate.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这告诉 Heroku（以及运行您的应用的人）您的应用需要 Node 0.10。这有助于 Heroku 区分。'
- en: 'Nothing too new there, but for the definition of which Node version to use.
    Next, define app.js, where our Hello World code resides:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么特别的新内容，但关于使用哪个 Node 版本的定义。接下来，定义 app.js，我们的 Hello World 代码就存放在这里：
- en: Listing 11.31 A Hello World Express app (app.js)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.31 一个简单的 Hello World Express 应用（app.js）
- en: '`var express = require("express");`   `var app = express();`   `app.set("port",
    process.env.PORT || 3000);`   `app.get("/", function(req, res) {` `  res.send("Hello
    world!");` `});`   `app.listen(app.get("port"), function() {` `  console.log("App
    started on port " + app.get("port"));``});`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var app = express();` `app.set("port",
    process.env.PORT || 3000);` `app.get("/", function(req, res) {` `  res.send("Hello
    world!");` `});` `app.listen(app.get("port"), function() {` `  console.log("App
    started on port " + app.get("port"));``});`'
- en: Once again, not much new here. The only Heroku-specific thing here is how the
    port is set. Heroku will set an environment variable for the port which we'll
    access through `process.env.PORT`. If we never deal with that variable, we won't
    be able to start our app on Heroku on the proper port.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这里没有太多新内容。这里唯一的 Heroku 特殊之处在于端口的设置。Heroku 将为端口设置一个环境变量，我们将通过 `process.env.PORT`
    来访问它。如果我们从不处理这个变量，我们就无法在 Heroku 上以正确的端口启动我们的应用。
- en: 'The next part is the most foreign thing we''ve seen so far: a `Procfile`. It
    might sound like a complicated new Heroku concept, but it''s really simple. When
    you run your app, you type `npm start` into your command line. The Procfile codifies
    that, and tells Heroku to run npm start when your app begins. Create a file in
    the root of your directory and call it `Procfile` (capital P, no file extension):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是我们迄今为止看到的最不熟悉的东西：一个 `Procfile`。它可能听起来像是一个复杂的新 Heroku 概念，但实际上非常简单。当您运行您的应用时，您会在命令行中输入
    `npm start`。Procfile 将这编码化，并告诉 Heroku 当您的应用开始时运行 npm start。在您的目录根目录下创建一个文件，并将其命名为
    `Procfile`（大写 P，无文件扩展名）：
- en: Listing 11.32 Our application's Procfile
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.32 我们应用的 Procfile
- en: '`web: npm start`'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`web: npm start`'
- en: That's not too bad, right? Heroku is pretty nice.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太糟糕，对吧？Heroku 非常友好。
- en: 'Finally, we need to add a file that tells Git to ignore certain files. We don''t
    need to push `node_modules` to our server, so let''s make sure we ignore that
    file:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加一个文件，告诉 Git 忽略某些文件。我们不需要将 `node_modules` 推送到我们的服务器，所以让我们确保我们忽略这个文件：
- en: Listing 11.33 Our application's .gitignore file
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.33 我们应用的 .gitignore 文件
- en: '`node_modules`'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`node_modules`'
- en: Now that we've got our application all ready to go, let's deploy it!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将应用全部准备就绪，让我们部署它！
- en: 11.5.3   Deploying our first app
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.3 部署我们的第一个应用
- en: The first thing we'll need to do, if you haven't done it already, is put your
    app under version control with Git. I'm going to assume you at least know the
    basics of Git, but if you don't, check out Try Git at [https://try.github.io](https://try.github.io/).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，我们首先需要做的是使用 Git 将您的应用置于版本控制之下。我将假设您至少了解 Git 的基础知识，但如果您不了解，请查看 Try
    Git 在 [https://try.github.io](https://try.github.io/)。
- en: 'To set up a Git project in this directory, type `git init`. Then use `git add
    .` to add all of your files and `git commit –m "Initial commit"` to commit those
    changes to your Git project. Once  that''s all ready to go, type the following
    command:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要在这个目录中设置 Git 项目，请输入 `git init`。然后使用 `git add .` 添加所有文件，并使用 `git commit –m "Initial
    commit"` 将这些更改提交到 Git 项目中。一旦一切准备就绪，请输入以下命令：
- en: '`heroku create`'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`heroku create`'
- en: This will set up a new URL for your Heroku app. The names it generates are always
    a bit wacky—I got mighty-ravine-4205.herokuapp.com—but that's the price you pay
    for free hosting! You can change the URL or associate a domain name you own with
    a Herkou address, but we won't go into that here.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为你的 Heroku 应用程序设置一个新的 URL。它生成的名称总是有点奇怪——我得到了 mighty-ravine-4205.herokuapp.com——但这就是免费托管所付出的代价！你可以更改
    URL 或将你拥有的域名与 Herkou 地址关联，但在这里我们不会深入讨论。
- en: 'Next, we''ll want to tell our newly-created Heroku app that it''s a production
    Node environment. We''ll do this by setting the `NODE_ENV` environment variable
    on Heroku''s servers. Set that variable by running this command:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望通知我们新创建的 Heroku 应用程序，它是一个生产环境中的 Node 环境。我们将通过在 Heroku 服务器上设置 `NODE_ENV`
    环境变量来实现这一点。通过运行以下命令来设置该变量：
- en: '`heroku config:set NODE_ENV=production`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`heroku config:set NODE_ENV=production`'
- en: 'When you ran `heroku create`, Heroku added a remote Git server. When you push
    your code to Heroku, Heroku will deploy your app (or redeploy it if you''ve already
    deployed). This is just one Git command:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 `heroku create` 时，Heroku 会添加一个远程 Git 服务器。当你将代码推送到 Heroku 时，Heroku 将部署你的应用程序（或者如果你已经部署过，将重新部署）。这只是一个
    Git 命令：
- en: '`git push heroku master`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`git push heroku master`'
- en: 'This will first push your code to Heroku''s servers, then set up their servers
    with all of your dependencies. You''ll run `git push heroku master` every time
    you want to re-deploy; that''s really the only command you''ll run more than once.
    There''s just one last thing to do: tell Heroku that it should run your app with
    one process so that it''ll actually run on a real computer:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这将首先将你的代码推送到 Heroku 的服务器，然后设置他们的服务器，包含你所有的依赖项。每次你想重新部署时，你将运行 `git push heroku
    master`；这实际上是你唯一会运行多次的命令。最后还有一件事要做：告诉 Heroku 它应该用一个进程来运行你的应用程序，这样它实际上才能在真实计算机上运行：
- en: '`heroku ps:scale web=1`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`heroku ps:scale web=1`'
- en: Suddenly, your app will be running on the real internet! You can type `heroku
    open` to open your app in your browser, and see it running! You can send this
    link to your friends. No more localhost, baby!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 突然之间，你的应用程序将在真实互联网上运行！你可以输入 `heroku open` 在浏览器中打开你的应用程序，并看到它在运行！你可以将此链接发送给你的朋友。不再需要
    localhost，宝贝！
- en: '![](../Images/11_03.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3](../Images/11_03.png)'
- en: Figure 11.3 Your “hello world” app running on Heroku!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 在 Heroku 上运行的“hello world”应用程序！
- en: 11.5.4   Running Grunt on Heroku
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.4   在 Heroku 上运行 Grunt
- en: If you're using connect-assets to compile your assets, then Heroku will work
    just fine (assuming you've installed all of the dependencies properly). But if
    you want to use Grunt (or another task runner like Gulp), you'll need to run Grunt
    to build your assets when you deploy your site.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 connect-assets 来编译你的资源，那么 Heroku 将运行得很好（假设你已经正确安装了所有依赖项）。但如果你想使用 Grunt（或像
    Gulp 这样的其他任务运行器），你需要在部署你的网站时运行 Grunt 来构建你的资源。
- en: 'There''s a little trick you can use to make this work, which leverages a nice
    little feature of npm: the post-install script. Heroku will run `npm install` when
    you deploy your app, and we can tell Heroku to run Grunt right after that in order
    to build all of our assets. This is a simple manner of adding another script to
    our `package.json`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个小技巧来使这生效，这利用了 npm 的一个很好的小功能：post-install 脚本。Heroku 会在你部署应用程序时运行 `npm
    install`，我们可以告诉 Heroku 在那之后运行 Grunt 来构建我们所有的资源。这是向我们的 `package.json` 中添加另一个脚本的一种简单方式：
- en: Listing 11.33 Running Grunt in a postinstall script
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.33 在 postinstall 脚本中运行 Grunt
- en: '`// …` `"scripts": {` `  // …` `  "postinstall": "grunt build"  #A` `},``//
    …`'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `"scripts": {` `  // …` `  "postinstall": "grunt build"  #A` `},``//
    …`'
- en: '#A I use “grunt build” as an example—you could run whatever Grunt command you''d
    like.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 我以“grunt build”为例——你可以运行你想要的任何 Grunt 命令。'
- en: Now, when anyone (including Heroku!) runs `npm install`, `grunt build` will
    run.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当任何人（包括 Heroku！）运行 `npm install` 时，`grunt build` 将会执行。
- en: 11.5.5   Making your server more crash-resistant
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.5   使你的服务器更具抗崩溃能力
- en: No offense, but your server might just crash.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 不想冒犯，但你的服务器可能随时会崩溃。
- en: It could be that you run out of memory, or that you have an uncaught exception,
    or that a user has found a way to break your server. If you've ever had this happen
    while you're developing, you've probably seen that an error sends your server
    process screeching to a halt. While you're developing, this is pretty helpful—you
    want to be aware that your app doesn't work! In production, however, it's much
    more likely that you want your app to work at all costs. If you have a crash,
    you'll want your app to be resilient and restart.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现内存不足的情况，或者出现未捕获的异常，或者用户找到了一种破坏您服务器的方法。如果您在开发过程中遇到过这种情况，您可能已经看到错误使您的服务器进程突然停止。在开发过程中，这很有帮助——您希望知道您的应用程序不起作用！然而，在生产环境中，您更有可能不惜一切代价让应用程序工作。如果您有崩溃，您希望应用程序具有弹性并重新启动。
- en: 'We''ve already seen Forever in our chapter about security, but a refresher:
    it is a tool to keep your server up and running, even in the face of crashes.
    Instead of typing `node app.js`, you''ll just type `forever app.js`. Then, if
    your app crashes, Forever will restart it.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在关于安全性的章节中看到了Forever，但作为一个复习：它是一个工具，即使在崩溃的情况下也能保持服务器运行。您不需要输入`node app.js`，只需输入`forever
    app.js`即可。然后，如果您的应用程序崩溃，Forever会重新启动它。
- en: First, run `npm install forever --save` to install Forever as a dependency.
    Now, we need to run `forever app.js` to start our server. We could add this to
    the Procfile or change our `npm start` script, but I like to add a new script
    to`package.json`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，运行`npm install forever --save`来安装Forever作为依赖项。现在，我们需要运行`forever app.js`来启动我们的服务器。我们可以将其添加到Procfile中或更改我们的`npm
    start`脚本，但我喜欢在`package.json`中添加一个新的脚本。
- en: 'Open up your scripts in `package.json` and add the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`package.json`中的脚本，并添加以下内容：
- en: Listing 11.34 Defining a script for running your server in production
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.34 定义用于在生产环境中运行服务器的脚本
- en: '`// …` `"scripts": {` `  // …` `  "production": "forever app.js"` `},``// …`'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `"scripts": {` `  // …` `  "production": "forever app.js"` `},``// …`'
- en: '#A When you run “npm run production”, your app will start running forever.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 当您运行“npm run production”时，您的应用程序将永久运行。'
- en: 'Now, when you run `npm run production`, your app will start with Forever. The
    next step is to get Heroku to run this script, and that''s just a simple matter
    of changing your Procfile:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您运行`npm run production`时，您的应用程序将使用Forever启动。下一步是让Heroku运行此脚本，这只是一个简单更改Procfile的问题：
- en: Listing 11.35 Updating your Procfile to use Forever
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.35 更新Procfile以使用Forever
- en: '`web: npm run production`'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`web: npm run production`'
- en: Now, when Heroku starts, it'll run your app with Forever and keep your app restarting
    after crashes!
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当Heroku启动时，它将使用Forever运行您的应用程序，并在崩溃后重新启动您的应用程序！
- en: As always with Heroku, commit these changes into Git. (You'll need to add your
    files with `git add .` and then commit them with `git commit –m "Your commit message
    here!"`.)Once that's done, you can deploy them to Heroku with`git push heroku
    master`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在Heroku上做的那样，将这些更改提交到Git中。（您需要使用`git add .`添加您的文件，然后使用`git commit –m "Your
    commit message here!"`提交它们。）完成这些后，您可以使用`git push heroku master`将它们部署到Heroku。
- en: You can use Forever in any kind of deployment, not just Heroku. While Heroku
    uses Procfiles and some of that will have to change depending on your server setup,
    you can use Forever wherever you choose to deploy.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任何类型的部署中使用Forever，而不仅仅是Heroku。虽然Heroku使用Procfiles，并且这取决于您的服务器设置，您可以在您选择的任何部署位置使用Forever。
- en: 11.6  Summary
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 摘要
- en: 'In this chapter, we''ve learned a ton of stuff about compiled files, from views
    to concatenated JavaScript. We''ve seen the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了大量关于编译文件的知识，从视图到连接的JavaScript。我们看到了以下内容：
- en: ·  LESS for improving our CSS with a number of features.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: · 使用LESS通过一系列功能来改进我们的CSS。
- en: ·  Browserify for packaging JavaScript, letting us share code between our client
    and our server.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: · 使用Browserify打包JavaScript，让我们可以在客户端和服务器之间共享代码。
- en: ·  The flexible Grunt task runner, and a few of its many tasks.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: · 灵活的Grunt任务运行器及其许多任务中的几个。
- en: ·  connect-assets as an alternative to Grunt for compiling and serving CSS and
    JavaScript.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: · 使用connect-assets作为Grunt的替代方案来编译和提供CSS和JavaScript。
- en: ·  Deploying our applications to Heroku for the real internet!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: · 将我们的应用程序部署到Heroku以进入真正的互联网！
