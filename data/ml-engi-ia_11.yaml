- en: 10 Standards of coding and creating maintainable ML code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 编码标准和创建可维护的机器学习代码
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Identifying ML code smells and how to correct them
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别机器学习代码中的问题及其纠正方法
- en: Reducing code complexity in ML projects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在机器学习项目中降低代码复杂性
- en: Currying for cleaner and more understandable code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了更清晰和易于理解的代码进行柯里化
- en: Applying proper exception handling in ML code bases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在机器学习代码库中应用适当的异常处理
- en: Understanding side effects and how they can create bugs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解副作用及其如何导致错误
- en: Simplifying nested logic to improve comprehension
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化嵌套逻辑以提高理解性
- en: In the preceding chapter, we covered the broad strokes of a code foundation.
    Focusing on breaking up complex structure by utilizing refactoring and basic software-engineering
    best practices was important to pave the way for further discussion of the more
    detailed aspects of software development for ML. Without laying the foundation
    of basic best-practices, the code architecture and design elements that follow
    simply don’t matter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了代码基础的大致轮廓。通过利用重构和基本的软件工程最佳实践来分解复杂结构，对于进一步讨论机器学习软件开发更详细方面是非常重要的。如果没有建立基本最佳实践的基础，接下来的代码架构和设计元素就无关紧要了。
- en: Early in anyone’s career in software development (ML or otherwise), the ability
    to identify potential issues with an implementation is effectively nonexistent.
    This is understandable, as the wisdom of knowing what works and what doesn’t comes
    directly from experience. Everyone who works in developing software eventually
    learns that just because you can do something doesn’t mean that you should do
    it in code. These lessons are typically gained by messing things up a great deal.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发（包括机器学习）的早期阶段，识别实现中潜在问题的能力实际上是不存在的。这是可以理解的，因为知道什么有效什么无效的智慧直接来自于经验。从事软件开发工作的每个人最终都会学到，仅仅因为你可以做某事，并不意味着你应该在代码中这样做。这些教训通常是通过犯很多错误而获得的。
- en: Projects that have too many of the aforementioned mistakes run the risk of being
    abandoned. After all, if no one can troubleshoot the code, let alone read it,
    the chance that the technical-debt-riddled solution will be permitted to run for
    very long in production is slim.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有太多上述错误的项目有被放弃的风险。毕竟，如果没有人能够调试代码，更不用说阅读它，那么充斥着技术债务的解决方案能够在生产环境中长时间运行的可能性很小。
- en: The goal of this chapter is to identify the most common issues that I see in
    ML code bases that directly affect the *stability of the solution *(and the general
    mental well-being of those required to maintain it).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是确定我在机器学习代码库中看到的最常见问题，这些问题直接影响到解决方案的*稳定性*（以及那些需要维护它的人的一般心理健康）。
- en: 10.1 ML code smells
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 机器学习代码中的问题
- en: Sometimes you look at a code base and just know something is not right. The
    mistakes you see in formatting, collection handling, lack of appropriate recursion,
    or quantity of dead code can give you a sense of the overall health of a code
    base. If they’re bad enough, even the most junior members of a team can identify
    them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你看看代码库，就能知道某些地方不对劲。你在格式、集合处理、缺乏适当的递归或死代码数量中看到的问题可以让你对代码库的整体健康状况有一个感觉。如果问题严重，即使是团队中最初级成员也能识别出来。
- en: More insidious problems might be much harder for a junior DS to identify but
    can be clear to more senior members of the team. These “smells” within the code
    (a term famously coined by Martin Fowler) are indicative of potentially crippling
    problems that may arise elsewhere, directly impacting production stability or
    making the code nigh-impossible to debug if a problem happens.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 更隐蔽的问题可能对初级数据科学家来说更难识别，但对团队中的资深成员来说可能很清楚。这些代码中的“问题”（由Martin Fowler著名提出）表明了可能出现的潜在严重问题，这些问题可能直接影响到生产稳定性，或者如果出现问题，使得代码几乎无法调试。
- en: Table 10.1 lists some of the more common code smells that I see in ML code bases.
    While the ones listed are not catastrophic, per se, they typically are the first
    sign that I have that “all is not well in Denmark.” Finding one of these code
    smells generally means that one of the more insidious issues that will likely
    affect production stability is contained somewhere in the code base. Learning
    to recognize these issues, setting plans to address the technical debt of them,
    and working to learn techniques to avoid these in ML projects can significantly
    reduce the refactoring and repair work that the ML team will have to do in the
    future.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1列出了我在机器学习代码库中看到的一些更常见的代码异味。虽然列出的这些异味本身并不是灾难性的，但它们通常是“丹麦一切都不好”的第一个迹象。发现这些代码异味通常意味着代码库中可能包含一些可能影响生产稳定性的隐蔽问题。学会识别这些问题，制定计划来解决这些问题的技术债务，并努力学习在机器学习项目中避免这些问题的技术，可以显著减少机器学习团队未来需要进行的重构和修复工作。
- en: Table 10.1 Common “nontoxic” code smells in ML code bases
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 机器学习代码库中常见的“非毒性”代码异味
- en: '| Code smell | Example | Why it stinks |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 代码异味 | 示例 | 为什么它令人厌恶 |'
- en: '| Wildcard imports | from scipy import * | It brings in all of the top-level
    functions in a package. It may create namespace collisions among other imported
    libraries or within the project’s code base. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 通配符导入 | from scipy import * | 它会导入包中的所有顶级函数。这可能会在其他导入的库或项目代码库中引起命名空间冲突。|'
- en: '| Multiple imports | import numpy as np | Confusing, mixed bag of usage throughout
    code. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 多重导入 | import numpy as np | 在代码中使用时，混乱且用途不一。|'
- en: '|  | from numpy import add | Makes the code harder to read. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|  | from numpy import add | 使代码难以阅读。|'
- en: '| Too many parameters | def my_method(df, name,source, fitting, metric,score,
    value, rename,outliers, train, valid) | Hard to read, hard to maintain, and confusing.
    Indicative of deeper issues in abstraction and encapsulation throughout the code
    base. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 参数过多 | def my_method(df, name,source, fitting, metric,score, value, rename,outliers,
    train, valid) | 难以阅读、难以维护且令人困惑。表明代码库中存在更深层次的抽象和封装问题。|'
- en: '| Copied boilerplate | Having feature-engineering code for training, test,
    and inference defined in three separate places | Aka *shotgun surgery*—changes
    need to be identically matched in all places, increasing the chances of making
    a mistake and having inconsistencies. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 复制样板代码 | 训练、测试和推理中的特征工程代码定义在三个不同的地方 | 也称为*散弹手术*——所有地方都需要相同地匹配更改，增加了出错和出现不一致的机会。|'
- en: '| Default | km = Kmeans() | The defaults are generally not ideal. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 默认 | km = Kmeans() | 默认值通常不是理想的。|'
- en: '| Hyperparameters | km.fit(train) | Seeing untuned models outside of rapid
    prototyping is dangerous. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 超参数 | km.fit(train) | 在快速原型设计之外看到未调优的模型是危险的。|'
- en: '| Variable reuse | pred = lr.predict(test)pred.to_parquet(''/<loc>'')pred =
    rf.predict(test)pred.to_parquet(''/<loc2>'') | Violates the single-responsibility
    principle. Makes the code hard to follow and debug. Can create stateful bugs that
    are hard to fix. Adding new functionality can create spaghetti code. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 变量重用 | pred = lr.predict(test)pred.to_parquet(''/<loc>'')pred = rf.predict(test)pred.to_parquet(''/<loc2>'')
    | 违反了单一职责原则。使代码难以跟踪和调试。可能创建难以修复的状态性错误。添加新功能可能会创建意大利面代码。|'
- en: '| Use of literals | profit = 0.72 * revenue | Literals are “magic numbers”
    that, when littered throughout code, can make updating them a nightmare. These
    should always be defined as named constants. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 文字常量使用 | profit = 0.72 * revenue | 文字常量是“魔法数字”，当它们散布在代码中时，可能会使更新它们变得噩梦般。这些应该始终定义为命名常量。|'
- en: '| In-line comments explaining how the code works | <some abhorrently complex
    chained code> | If you need to write comments to explain how code works, you are
    doing it wrong. Anytime the code becomes so complicated that you need a reminder
    of how it works, you should assume that no one else will be able to figure out
    what you wrote. Refactor it to reduce complexity. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 解释代码工作原理的行内注释 | <一些令人厌恶的复杂链式代码> | 如果你需要编写注释来解释代码的工作原理，那么你做错了。任何时候代码变得如此复杂，以至于你需要提醒它是如何工作的，你应该假设没有人能够理解你所写的内容。重构它以减少复杂性。|'
- en: '| SQL without common table expressions (CTEs) | <chained joins with no encapsulated
    interim table definitions> | CTEs help readability of SQL. Having hundreds (or
    thousands) of lines of SQL that have a single dependency chain means that any
    modification (adding or dropping a column) can take hours and is nearly impossible
    to debug. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| SQL 没有常用表表达式 (CTEs) | <无封装的临时表定义的链式连接> | CTEs 有助于提高 SQL 的可读性。拥有数百（或数千）行只有单一依赖链的
    SQL 代码意味着任何修改（添加或删除列）都可能需要数小时，并且几乎无法调试。|'
- en: '| SQL walls | <no upper casing to functions, no indentation or line-wrap SQL>
    | All three of these are impossible to read. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| SQL 墙 | <函数无大写，无缩进或换行 SQL> | 所有这三者都难以阅读。|'
- en: '| Constant recasting | age = int(age)height = float(height)seniority = int(retirement)
    \- int(age) | Typing doesn’t change. Cast it once. This is indicative of naïve
    programming (“It threw an exception once for not being an int, so I will make
    sure all integers are cast as int.”) It’s pointless. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 恒定类型转换 | age = int(age)height = float(height)seniority = int(retirement)
    - int(age) | 类型转换不会改变。转换一次即可。这表明了编程的幼稚性（“它曾经因为不是整数而抛出异常，所以我会确保所有整数都转换为整数。”）这是没有意义的。|'
- en: This chapter is focused on the five most frequent “deadly” errors. These are
    the crippling problems that create fundamentally broken ML code bases. Seeing
    these sorts of issues would likely mean a pager duty call at least once per week.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专注于五种最频繁的“致命”错误。这些问题是导致机器学习代码库根本性损坏的致命问题。看到这些问题可能会意味着每周至少一次的呼叫中心任务。
- en: If a project contains a small number of the issues described in this chapter,
    it’s not guaranteed to fail. The project may be onerous and confusing to continue
    developing, or incredibly unpleasant to maintain, but that doesn’t mean it won’t
    run and serve its intended purpose.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个项目包含本章中描述的少量问题，这并不保证项目会失败。项目可能难以继续开发，或者维护起来非常不愉快，但这并不意味着它不会运行并实现其预期目的。
- en: However, if the code base is riddled with multiple instances of each type of
    problem, the chances that you’re going to sleep well through your on-call week
    are pretty grim. Figure 10.1 shows the relationship between the severity of these
    issues and their potential effect on the outcome of the final project.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果代码库中充满了多种类型的问题的多个实例，那么在整个值班周都能睡得好的可能性相当渺茫。图 10.1 展示了这些问题严重性与最终项目结果潜在影响之间的关系。
- en: '![10-01](../Images/10-01.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![10-01](../Images/10-01.png)'
- en: Figure 10.1 The five most common issues in ML code and their relationships to
    project outcomes
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 机器学习代码中最常见的五个问题及其与项目结果的关系
- en: We’ll take a look at these five main bad practices throughout the rest of this
    chapter. We’ll focus on how to fix them and discuss why they can be so detrimental
    to ML project work.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的剩余部分探讨这五个主要的不良做法。我们将关注如何修复它们，并讨论为什么它们会对机器学习项目工作造成如此大的损害。
- en: 10.2 Naming, structure, and code architecture
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 命名、结构和代码架构
- en: Someone who is on on-call support experiences few more exhausting and panic-inducing
    scenarios than realizing that the job that just broke and requires investigation
    is “that one” This code is so overly confusing, complicated, and monkey-patched
    that when it breaks, the original author is usually called in to fix it. What
    makes it even worse is knowing that person left the company—two months ago. And
    now you have to fix their code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在值班支持中，有人会经历一些更加疲惫和令人恐慌的情况，比如意识到刚刚崩溃并需要调查的工作是“那个”工作。这段代码如此混乱、复杂和修补，以至于当它崩溃时，通常需要原始作者回来修复它。更糟糕的是，知道那个人两个月前就离开了公司。现在你必须修复他们的代码。
- en: 'Digging into it, all you see are obscure acronyms as variable names, massive
    walls of code within functions, classes with dozens of unrelated methods thrown
    in haphazardly, unhelpful inline comments, and thousands of lines of commented-out
    code. It’s basically the worst of both worlds: both a bowl of *spaghetti code*
    (control flow in the code organized as well as noodles in a bowl of spaghetti)
    and a *ball of mud* (effectively a morass of individual bowls of spaghetti with
    duplicated code, global references, dead code, and no seeming architectural design
    for maintainability).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 深入研究后，你看到的只是作为变量名的晦涩缩写，函数内部的庞大代码墙，随意添加的数十个无关的方法的类，无用的内联注释，以及数千行被注释掉的代码。这基本上是两种世界最糟糕的结合：既有
    *意大利面代码*（代码中的控制流组织得像意大利面碗中的面条一样）又有 *泥球*（实际上是一团意大利面的泥潭，有重复的代码、全局引用、死代码，并且没有明显的架构设计以供维护）。
- en: A lot of ML code tends to look like this, unfortunately, and it can be remarkably
    frustrating to diagnose and refactor. Let’s take a look at a few bad habits regarding
    naming, structure, and architecture, as well as better alternatives to those bad
    practices.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 很多的机器学习代码看起来都像这样，不幸的是，诊断和重构可能会非常令人沮丧。让我们看看一些关于命名、结构和架构的不良习惯，以及那些不良实践的更好替代方案。
- en: 10.2.1 Naming conventions and structure
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 命名约定和结构
- en: Naming variables can be a bit of a tricky exercise. Some schools of thought
    subscribe to the “less is more” philosophy, where the most succinct (shortest)
    code is best. Others, including myself, when writing non-ML code, tend to stick
    to more verbose naming conventions. As mentioned in chapter 9, the computer doesn’t
    care at all how you name things (provided that you’re not, as shown in listing
    10.1, using a reserved keyword for a structure as a variable name).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 命名变量可能是一项有点棘手的练习。一些思想流派遵循“少即是多”的哲学，认为最简洁（最短）的代码是最好的。其他人，包括我自己，在编写非机器学习代码时，倾向于坚持更详尽的命名约定。如第9章所述，计算机根本不在乎你如何命名事物（只要你不像列表10.1中所示，使用保留关键字作为结构变量名）。
- en: Let’s look at a dense representation of some naming issues. From lazy abbreviations
    (shorthand placeholder variable names) to unintelligible cipher-like names and
    a reserved function name, this listing has more than a few problems.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些命名问题的密集表示。从懒惰的缩写（简写占位符变量名）到难以理解的密码式名称，以及一个保留的函数名，这个列表有很多问题。
- en: Listing 10.1 Bad naming conventions
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 坏的命名约定
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Defines a tuple using the built-in language function tuple() that takes an
    iterable (here, a list). The variable definition sheds no light on what this is
    used for, though.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用内置语言函数tuple()定义一个元组，该函数接受一个可迭代对象（在这里，是一个列表）。变量定义并没有说明这个用途是什么。
- en: ❷ Generates a list of numbers. The variable name “abc” is just laziness.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 生成一个数字列表。变量名“abc”只是懒惰的表现。
- en: ❸ Creates a merged list of each of the other lists. Defining the list in this
    statement is hard to read and increases code complexity. The variable name is
    acronym soup and provides zero insight to anyone reading the code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个合并列表，包含其他每个列表。在这个语句中定义列表很难阅读，并增加了代码的复杂性。变量名像缩写汤，对阅读代码的人没有任何帮助。
- en: ❹ Calculates the squared error of the two lists of numbers. The variable name
    is dangerous because it’s a reserved function name that will now get overwritten
    for this context.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 计算两个数字列表的平方误差。变量名是危险的，因为它是一个保留的函数名，现在在这个上下文中将被覆盖。
- en: ❺ Calculates the root mean squared error (RMSE), but the variable defined is
    just a shortened name for a reserved language feature (“return”)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 计算均方根误差（RMSE），但定义的变量只是对保留语言特性（“返回”）的一个简写名称。
- en: ❻ Reports the value to stdout (for demonstration purposes only)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将值报告到标准输出（仅用于演示目的）
- en: ❼ The RMSE of the two series
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 两个序列的均方根误差（RMSE）
- en: ❽ Now calls the previously defined tuple gta to see what it generated when it
    was executed
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 现在调用之前定义的元组gta，看看它在执行时生成了什么
- en: ❾ The expected result of defining a tuple in the gta declaration
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 在gta声明中定义元组时的预期结果
- en: ❿ Now tries to generate another tuple
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 现在尝试生成另一个元组
- en: ⓫ Whoops! Why doesn’t it work? Well, we overrode the language function tuple
    with a list definition. Since nearly everything in Python is mutable, weakly typed,
    and object-based, we can even override the very nature of the language itself
    if we’re not careful.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 哎呀！为什么它不起作用？好吧，我们用列表定义覆盖了语言函数tuple。由于Python中几乎所有东西都是可变的、弱类型的和基于对象的，如果我们不小心，甚至可以覆盖语言本身的本质。
- en: This is clearly meant to be an exaggerated example of multiple bad practices
    condensed into a single block. You have little chance of seeing something like
    this “in the wild,” but each and every one of these issues has been in code bases
    that I’ve seen.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这明显是一个夸张的例子，将多个不良实践压缩到一个单独的块中。你很少有机会在“野外”看到这样的东西，但这些问题中的每一个都出现在我见过的代码库中。
- en: Of all of the issues presented here, the reserved name usage is perhaps the
    most insidious. Not only is it incredibly hard to detect in a large code base,
    but it can wreak havoc on future feature development. I can’t stress strongly
    enough how important it is to *avoid using nonspecific variable names*, particularly
    in a language like Python, because you can override core functionality with seemingly
    innocuous shortcut naming.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里提出的所有问题中，保留名称的使用可能是最隐蔽的。这不仅在大型的代码库中难以检测，而且可能会对未来的功能开发造成破坏。我无法强调避免使用不具体的变量名称的重要性，尤其是在像Python这样的语言中，因为你可以用看似无害的快捷命名覆盖核心功能。
- en: While this isn’t a problem in compiled languages directly (the compiler will
    not allow reassignment of a protected method to something that you define, after
    all), it can be introduced by unintentionally overriding methods that have dependencies.
    While JVM languages will detect and not permit mixing in of improperly overridden
    traits from a superclass, having poorly named methods during development can lead
    to wasting countless hours tracking down why a build fails.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在编译型语言中这并不是一个问题（毕竟编译器不会允许将受保护的方法重新赋值为你定义的内容），但它可以通过无意中覆盖具有依赖性的方法而引入。虽然JVM语言会检测并禁止从超类中混合不正确覆盖的特性，但在开发过程中方法命名不当可能会导致浪费无数小时追踪构建失败的原因。
- en: 10.2.2 Trying to be too clever
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 试图过于聪明
- en: There is no award, nor will there ever be, for developing software with the
    fewest keystrokes. Trying to be clever by seeing how compact and concise code
    can be written does nothing for the runtime efficiency of the code in an interpreted
    language. The only thing it achieves is raising the ire of others who have to
    read the code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 没有奖项，也永远不会有为使用最少的按键来开发软件而设立的奖项。试图通过看到代码可以多么紧凑和简洁来表现聪明，对解释型语言的代码运行效率没有任何帮助。它唯一达到的效果是激怒了不得不阅读代码的其他人。
- en: Note Code styling and comprehensible structure benefits humans. The computer
    doesn’t care how fancy your chained operations are, but other humans will. And
    they will hate you for this form of cleverness.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：代码风格和可理解的结构对人类有益。计算机不在乎你的链式操作有多花哨，但其他人会。他们会因为这种聪明而讨厌你。
- en: Listing 10.2 exemplifies an attempt at creating the most dense and efficient
    code achievable. While it is technically correct and will result in the calculation
    of a root mean squared error, it’s nearly impossible to read.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2展示了尝试创建最密集和高效代码的例子。虽然它在技术上正确，并且会导致计算均方根误差，但它几乎无法阅读。
- en: Writing code like this *does nothing for performance*. The author may feel smarter
    by writing what they see as efficient code, but nothing could be further from
    the truth. The code makes it hard for others to figure out what is going on, will
    be incredibly challenging to modify, and limits the ability to debug.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这样的代码对性能没有任何帮助。作者可能会觉得自己通过编写他们认为高效的代码而变得更聪明，但事实并非如此。这样的代码让其他人难以理解发生了什么，修改起来会非常困难，并且限制了调试的能力。
- en: Listing 10.2 Complex one-liner
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2 复杂的单行代码
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Borderline intentionally obfuscated functionality. Writing code like this
    does no one, including yourself, any favors. It’s dense, hard to read, and requires
    a lot of mental effort to figure out what it’s doing (even if it is named correctly).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 边界故意混淆的功能。编写这样的代码对你自己或任何人都没有好处。它很密集，难以阅读，需要大量的脑力才能弄清楚它在做什么（即使它被正确命名）。
- en: This style of efficient one-line coding requires paying far too much attention
    to each element in order to piece together all of the actions occurring. Thankfully,
    a simple set of logic is being performed in this example. I have seen one-liners
    span dozens of lines in an IDE before, and it does no one any favors by writing
    code like this.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种高效的单行编码风格需要非常关注每个元素，以便拼凑出所有发生的操作。幸运的是，这个例子中正在执行一个简单的逻辑集。我之前在IDE中见过单行代码长达数十行，这样的代码对任何人都没有好处。
- en: The following is a cleaner and more straightforward way to write this block
    of functionality. While still not ideal, it achieves a higher degree of legibility.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是以更干净、更直接的方式编写此功能块的方法。虽然仍然不是最佳选择，但它达到了更高的可读性。
- en: Listing 10.3 Properly named and structured version
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3 正确命名和结构化的版本
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Much clearer variable names that explain, in plain text, the values that the
    variable is pointing to
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 更清晰的变量名称，以纯文本形式解释变量指向的值
- en: ❷ By describing what is happening within the variable name, the code can be
    scanned much more easily. Instead of a confusing name that bears no meaning to
    the state of the operations at this point, stating what is being done makes reading
    the code much easier.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过在变量名中描述正在发生的事情，代码可以更容易地被扫描。而不是一个令人困惑的名字，这个名字在这个操作的状态下没有任何意义，说明正在做什么会使阅读代码变得容易得多。
- en: ❸ Naming the final action properly as a specific calculated value based on the
    defined logic makes this entire block much easier to figure out.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 正确命名最终操作，使其基于定义的逻辑成为一个特定的计算值，这使得整个块更容易理解。
- en: However, the proper way to write this code is shown in listing 10.4\. Not only
    are the variable names clear, but we’re not reimplementing functionality that
    already exists within standard packages. To keep code as simple and legible as
    possible, don’t try to reinvent the wheel.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编写此代码的正确方式在列表10.4中展示。不仅变量名清晰，我们没有重新实现标准包中已经存在的功能。为了使代码尽可能简单和易读，不要试图重新发明轮子。
- en: Listing 10.4 How it should be written
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.4 应该如何编写
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The RMSE equation is graciously provided and maintained for you by the scikit-learn
    contribution team. They certainly know what they’re doing, and you should trust
    that their modules work correctly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ RMSE方程由scikit-learn贡献团队慷慨提供并维护。他们当然知道自己在做什么，你应该相信他们的模块是正确工作的。
- en: ❷ Hardcoding values within functions or methods is an antipattern (except for
    in the mean_squared_error function, we’re forcing a particular functionality with
    the flag setting to False), so here we’re allowing the generator to calculate
    different values of generated sequences by passed-in configuration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在函数或方法中硬编码值是一个反模式（除了在mean_squared_error函数中，我们通过将标志设置为False来强制特定的功能），因此我们允许生成器通过传入的配置计算生成的序列的不同值。
- en: ❸ Sets the mean square error function’s (MSE) squared argument flag to False,
    and you have RMSE
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将均方误差函数（MSE）的平方参数标志设置为False，你就有了RMSE
- en: 10.2.3 Code architecture
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 代码架构
- en: Code architecture is a contentious subject. While many people tout that they
    have an ideal approach, the only valid answer to what makes a good layout of logic
    within a code base is the *one that the team can maintain*. I’ve lost count of
    the number of times that I’ve worked on or seen someone’s ideal repository structure
    that is so ridiculously overengineered that the team ends up struggling to merge
    code to it before the project is done.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 代码架构是一个有争议的话题。虽然许多人吹嘘他们有一个理想的方法，但关于什么使得代码库中的逻辑布局好的唯一有效答案是*团队可以维护的那个*。我已经数不清有多少次在项目完成前，我工作过或看到过某个人的理想仓库结构，它如此过度工程化，以至于团队在项目完成前都难以将其代码合并进去。
- en: The inevitable result of defining a well-intentioned but overly complex repository
    structure for a project is a breakdown in proper abstraction. As the process of
    development moves along in an ML project, and additional features are created
    to solve the needs of the solution, new functionality ends up getting shoehorned
    in places that it would not have otherwise been placed. By the time the development
    cycle is complete, the code base is impossible to navigate, as shown in figure
    10.2.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为项目定义一个良好意图但过于复杂的仓库结构的不幸结果是，适当的抽象发生了崩溃。随着机器学习项目的发展过程，为了解决解决方案的需求而创建额外的功能，新的功能最终被挤入原本不会放置的地方。到开发周期结束时，代码库变得无法导航，如图10.2所示。
- en: '![10-02](../Images/10-02.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![10-02](../Images/10-02.png)'
- en: Figure 10.2 A well-thought-out repository design and code architecture can slowly
    become a tangled and confusing mess.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 一个经过深思熟虑的仓库设计和代码架构可能会逐渐变得混乱和令人困惑。
- en: In this example, a series of three major feature updates need to be added to
    the code. Each contributor attempts to figure out where their feature branch code
    needs to be placed, based on the existing wireframe built at the start of the
    project. The first improvement that adds more features to the vector isn’t confusing.
    The repository structure has clearly defined modules dedicated to this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，需要向代码中添加一系列三个主要的功能更新。每个贡献者都试图弄清楚他们的功能分支代码应该放在哪里，这是基于项目开始时构建的现有线框图。向向量添加更多功能的第一个改进并不令人困惑。仓库结构已经明确定义了专门用于此的模块。
- en: The second change, modifications to the model family, involves replacing the
    model that had been used earlier. As long as the original model’s core code, which
    was in existence before the change, gets completely removed from the code base,
    and the dead code is removed and not just commented out, this form of refactoring
    is perfectly fine. However, as part of this model change, new functionality is
    required in the form of a validation check. Where should this go?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个更改，即对模型家族的修改，涉及替换之前使用的模型。只要原始模型的核心代码，在更改之前就已经存在，完全从代码库中移除，并且死代码被移除而不是仅仅注释掉，这种重构形式是完全可以接受的。然而，作为模型更改的一部分，需要一种验证检查的新功能。这个功能应该放在哪里？
- en: The contributor ends up slapping this new functionality into the feature-validation
    statistics class. This now creates a tight coupling of functionality between feature-related
    statistics and the new target-related statistics.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 贡献者最终将这个新功能强行加入到功能验证统计类中。这现在在功能相关统计和新目标相关统计之间创建了一个紧密的功能耦合。
- en: 'While it’s true that both operations are doing statistical validation of data,
    the algorithms, validations, and operations being performed have nothing to do
    with one another. Furthermore, in order to fit this functionality into the existing
    class, the signature needs to be changed to adapt to both use cases. This is a
    clear case of code spaghetti: completely unrelated code and modifications used
    to “monkey-patch” functionality together end up leaving the code more fragile,
    more confusing, and harder to modify in the future. Tests on this class will similarly
    become far more difficult to write as the new functionality has to be considered.
    It’s simply more work than it’s worth. What the contributor should have done with
    this new functionality is create a *new module* with a class (or classes) that
    support the target’s statistical validation needs.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个操作确实都在进行数据的统计验证，但所执行的算法、验证和操作之间没有任何关系。此外，为了将这个功能集成到现有的类中，签名需要更改以适应两种用例。这是一个明显的代码混乱案例：完全无关的代码和修改被用来“猴子补丁”功能，最终使代码更加脆弱、更加混乱，并且在未来更难修改。由于新功能必须被考虑，对这个类的测试也将变得更加困难。这纯粹是工作量大于其价值。贡献者应该用这个新功能创建一个*新模块*，其中包含一个（或多个）支持目标统计验证需求的类。
- en: The final change required, adding Hyperopt for auto-tuning of the model, forces
    the team members to perform a highly complex refactoring. They updated the model-training
    module to support this, which is reasonable. However, the search space configuration
    should have been externalized to a different module. Loading down the metrics,
    parameters, and monitoring module with unrelated functionality will only create
    a sloppy code base. It will make the peer review (PR) process more complicated,
    make future feature work more challenging, and force more-complex unit tests to
    be written to ensure proper code coverage.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做的最后一个更改，即添加Hyperopt以自动调整模型，迫使团队成员执行一个高度复杂的重构。他们更新了模型训练模块以支持这一点，这是合理的。然而，搜索空间配置应该被外部化到不同的模块。将无关的功能加载到指标、参数和监控模块中只会创建一个混乱的代码库。这将使同行评审（PR）过程更加复杂，使未来的功能工作更具挑战性，并迫使编写更复杂的单元测试以确保适当的代码覆盖率。
- en: To be crystal clear here, I’m not advocating rigid adherence to a particular
    code architecture, nor sticking with whatever design the repository was in at
    the conclusion of the MVP phase of a project. Code should always organically grow;
    the process of refactoring, improving, adding features, removing features, and
    maintaining a code base should be embraced by all who work in software development.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里要讲得非常清楚，我并不是在提倡对特定的代码架构进行僵化的遵循，也不是在MVP阶段项目结束时坚持任何设计。代码应该始终自然地增长；重构、改进、添加功能、移除功能以及维护代码库的过程应该被所有从事软件开发工作的人所接受。
- en: However, there are ways to add features that make a code base maintainable,
    and there are ways that make it a broken, complicated, and confusing mess. If
    you’re changing existing functionality or adding a new feature that is isolated
    to the encapsulation defined by a current class or module, you should be writing
    your feature within that module. However, if the change is extremely large (an
    entirely new functionality that can be abstracted away into its own module) or
    involves communication with many other classes and modules spread throughout your
    code base, do yourself and your team a favor and just create a new module.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些方法可以使代码库可维护，也有一些方法会使它变得破碎、复杂和混乱。如果你正在更改现有功能或添加一个仅限于当前类或模块封装的新功能，你应该在该模块内编写你的功能。然而，如果更改非常大（可以抽象成其自己的模块的全新功能）或涉及与代码库中分散的许多其他类和模块进行通信，请为自己和你的团队做点好事，只需创建一个新的模块。
- en: 10.3 Tuple unpacking and maintainable alternatives
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 元组解包及可维护的替代方案
- en: Let’s suppose for a moment that we’re working on a relatively complex ML code
    base that’s in production. We’ve created our feature branch and are ready to implement
    the improvement. The ticket we’re working on, adding a statistical test to a core
    module, requires adding another return value to a scoring method.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在处理一个相对复杂的处于生产状态的 ML 代码库。我们已经创建了功能分支，并准备实施改进。我们正在处理的工作单，向核心模块添加统计测试，需要向评分方法添加另一个返回值。
- en: Looking at the method that exists, we see that the return is a tuple of values,
    currently three of them. After adding in the additional logic and updating the
    return tuple with the additional variable, we move to the portion of the code
    that needs the new return value. After updating the return structure where our
    feature branch is targeting consumption of this method, we run a test on our feature
    branch.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 看看现有的方法，我们看到返回的是一个值的元组，目前有三个。在添加额外的逻辑并更新返回元组以包含额外的变量后，我们转向需要新返回值的代码部分。在更新我们的功能分支目标消费此方法的返回结构后，我们在我们的功能分支上运行测试。
- en: 'Everything breaks. The other places in the code base that didn’t specifically
    need the new variable, even though they don’t use it, still need to capture the
    added return value. Thankfully, there’s a solution to this issue of currying return
    values by position reference: tuple unpacking.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的东西都崩溃了。即使代码库中的其他地方不需要这个新变量，即使它们没有使用它，仍然需要捕获增加的返回值。幸运的是，有一个通过位置引用解决这种 curry
    返回值问题的解决方案：元组解包。
- en: 10.3.1 Tuple unpacking example
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 元组解包示例
- en: Let’s take a look at a simple data generator in listing 10.5\. In this code,
    we’re using the logistic map function to generate a series of data, visualizing
    it, and returning both the plot object and the series (so we can do some statistical
    analysis on it based on the configured values).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看列表 10.5 中的简单数据生成器。在这段代码中，我们使用逻辑映射函数生成一系列数据，可视化它，并返回图表对象和序列（这样我们就可以根据配置的值对其进行统计分析）。
- en: Listing 10.5 Logistic map data generator with tuple return
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.5 带元组返回的逻辑映射数据生成器
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The logistic map function for use in recursing over prior values
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于递归先前值的逻辑映射函数
- en: ❷ The tail-recursive function for generating the series by applying the logistic
    map equation over each previous value
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过对每个先前值应用逻辑映射方程生成序列的尾递归函数
- en: ❸ Function for generating the series and a plot to show what the particular
    recurrence value does to the series
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成序列的函数以及一个展示特定递归值对序列影响的图表
- en: ❹ The tuple return type. This is not a particularly egregious demonstration
    of complexity in passing a result out of a function, but it still requires knowledge
    of the function signature to use. It also requires positional reference for each
    place this function will be called (creating a tightly coupled structure between
    this function’s return type and each place that it is used in code).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 元组返回类型。这并不是一个特别严重的复杂性展示，即在函数中传递结果，但它仍然需要了解函数签名才能使用。它还要求对每个函数将被调用的位置进行位置引用（在函数的返回类型和它在代码中使用的每个地方之间创建了一个紧密耦合的结构）。
- en: ❺ Calls the function with tuple unpacking of the return values, assigning them
    to variables directly
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用元组解包返回值调用函数，直接将它们分配给变量
- en: NOTE For the results of these examples, see the Jupyter notebook for this chapter
    in the companion repository for this book at [https://github.com/BenWilson2/ML-Engineering](https://github.com/BenWilson2/ML-Engineering).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：关于这些示例的结果，请参阅本书配套仓库中该章节的Jupyter笔记本，仓库地址为[https://github.com/BenWilson2/ML-Engineering](https://github.com/BenWilson2/ML-Engineering)。
- en: With the two return values specified with the `generate_log_map_and_plot()`
    function, it’s not an overly complex burden from a usage and maintainability perspective
    to keep the correct references when using it. However, when the size and complexity
    of the return values grow, using the function becomes increasingly difficult.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`generate_log_map_and_plot()`函数指定的两个返回值，从使用和维护的角度来看，保持正确的引用并不是一个过于复杂的负担。然而，当返回值的大小和复杂性增加时，使用该函数变得越来越困难。
- en: As an example of a complex return type from a function, see listing 10.6\. This
    simple statistical analysis of a univariate series generates a complex output.
    While the intention of making it easier to use is there with the utilization of
    grouped tuples, it’s still too complex.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数复杂返回类型的示例，请参阅列表10.6。这个简单的单变量序列统计分析生成复杂的输出。虽然利用分组元组使其更容易使用的意图是存在的，但它仍然过于复杂。
- en: Listing 10.6 Statistical analysis function with a nightmarish tuple unpacking
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.6具有噩梦般元组解包的统计分析函数
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Function for collecting statistics on a series of data
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于收集数据序列统计信息的函数
- en: ❷ The complex grouped nested tuple return type that will force positional (or
    complex defined returns) on the caller side of this function
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 该函数调用方将强制使用位置（或复杂定义的返回）的复杂分组嵌套元组返回类型
- en: ❸ Uses an object to hold the entire return structure in a single variable
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用一个对象来在单个变量中持有整个返回结构
- en: ❹ Uses positional notation and nesting to return a particular element from the
    return structure. This is extremely fragile and difficult to use. Most of the
    time, when approach is utilized, if this function changes, these values are overlooked
    when refactoring, leading to confusing exceptions or incorrect calculations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用位置记法和嵌套来从返回结构中返回特定元素。这非常脆弱且难以使用。大多数时候，当使用这种方法时，如果这个函数发生变化，这些值在重构时会被忽略，导致令人困惑的异常或错误的计算。
- en: ❺ The alternative access pattern for expanding the tuples. This is just ugly
    code and difficult to maintain. When the underlying function changes, this tightly
    coupled signature will throw a ValueError Exception with unpacking counts being
    off from expected.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 扩展元组的替代访问模式。这只是丑陋的代码，难以维护。当底层函数发生变化时，这个紧密耦合的签名将抛出ValueError异常，解包计数与预期不符。
- en: Writing code in this way is problematic for reasons other than simply having
    to look at source code to use it, though. What happens when this function needs
    to change? What if, instead of needing to evaluate the 95th percentile of the
    series, we also need to calculate the 99th percentile? Where do we put that within
    the structure?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式编写代码存在其他问题，而不仅仅是需要查看源代码才能使用它。当这个函数需要更改时会发生什么？如果我们不仅需要评估序列的95百分位数，还需要计算99百分位数，我们把这个放在结构中的哪个位置呢？
- en: If we update the return signature, we then have to update every single place
    that this function is used. It’s simply not a usable form of currying data from
    the function for use elsewhere. It also increases the complicated levels of the
    code in a way that makes the entire code base more fragile, harder to maintain,
    and frustrating to troubleshoot and test.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更新返回签名，那么我们就必须更新使用此函数的每个地方。这根本不是一种从函数中提取数据以供其他地方使用的可用形式。它还以使整个代码库更加脆弱、更难以维护和调试测试的方式增加了代码的复杂程度。
- en: 10.3.2 A solid alternative to tuple unpacking
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 元组解包的可靠替代方案
- en: 'Listing 10.7 shows a solution to this problem, using a structure and approach
    that is similar to that used for another dominant ML language: Scala (through
    the use of case classes). In this listing, we’re using *named tuples* to handle
    the return type structure, allowing us to use named references to get to the underlying
    data within the structure.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.7展示了该问题的解决方案，使用了一种类似于用于另一种主导机器学习语言（Scala，通过使用案例类）的结构和方法。在这个列表中，我们使用*命名元组*来处理返回类型结构，使我们能够使用命名引用来访问结构内部的数据。
- en: This approach enables future-proofing since any modification of the return structure
    will not require defining consumption patterns at place of use. It’s also far
    easier to implement. Using these structures is like using dictionaries (using
    similar underlying structures), but they have a more syntax-sugar feel than dictionaries
    because of the positional named entity notation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使代码具有前瞻性，因为任何对返回结构的修改都不需要在使用位置定义消费模式。它也更容易实现。使用这些结构就像使用字典（使用类似的底层结构），但由于位置命名实体记号，它们比字典有更多的语法糖感。
- en: Listing 10.7 Refactoring the series and plot generator with named tuples
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.7 使用命名元组重构序列和绘图生成器
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Imports the standard collections library to have access to named tuples
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入标准集合库以访问命名元组
- en: ❷ Defines the named tuple we’ll be using for named access to the data within
    our tuple return type
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义我们将用于在元组返回类型内进行命名访问的命名元组
- en: ❸ Creates a new instance of our named tuple MapData and places the objects to
    be returned from the function within the named tuple defined structure
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个新的命名元组MapData实例，并将要从函数中返回的对象放置在定义的命名元组结构中
- en: ❹ The return signature is now a single element (keeping the code looking much
    cleaner when using the function), but it no longer requires positional notation
    to access the elements.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 返回签名现在是一个单一元素（当使用函数时，代码看起来更干净），但它不再需要位置记号来访问元素。
- en: ❺ The individual values contained within the return variable are accessed through
    the named elements that we defined as part of the named tuple collection definition.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 通过我们作为命名元组集合定义的一部分定义的命名元素访问返回变量中的单个值。
- en: Now that we have a simple example of the refactoring of the series generation
    and plotting from listing 10.5, let’s take a look at how a named tuple approach
    with defined structure can aid us with the far more complicated return type from
    listing 10.6, as shown in the next listing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个简单的示例，展示了如何从列表10.5中的序列生成和绘图重构，让我们看看如何使用具有定义结构的命名元组方法帮助我们处理列表10.6中的更复杂的返回类型，如以下列表所示。
- en: Listing 10.8 Refactoring the statistical attribute function with named tuples
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.8 使用命名元组重构统计属性函数
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Defines named tuples for each component of the analysis
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义用于分析每个组件的命名元组
- en: ❷ Named tuples can be nested to aggregate similar data return types together.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 命名元组可以嵌套以将类似的数据返回类型聚集在一起。
- en: ❸ Generates series data
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成序列数据
- en: ❹ Calls the function and passes in the name-referenced series data from the
    generator function return
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 调用函数并传入生成函数返回的命名引用序列数据
- en: ❺ Extracts a nested named tuple variable’s data
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 提取嵌套命名元组变量的数据
- en: By using named structures, you create less work for yourself and others when
    refactoring code, because you don’t have to change all calling instances of a
    function or a method. In addition, the code is far easier to read. Increasing
    legibility of the code may not reduce the complexity of what your code is doing,
    but it is guaranteed to make your code *far less complicated*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用命名结构，在重构代码时，你为自己和他人减少了工作量，因为你不必更改函数或方法的全部调用实例。此外，代码的阅读性也大大提高。提高代码的可读性可能不会减少代码执行的操作的复杂性，但它可以保证使你的代码*远没有那么复杂*。
- en: A great many ML APIs leverage tuple unpacking. Typically, the tuple is restricted
    to no more than three elements to reduce end-user confusion. Keeping track of
    three elements doesn’t seem very complex (for the most part). But using positional
    references to return elements from a function or a method becomes a nuisance,
    since the code has to reflect these positional returns *each place that the code
    is called*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 许多机器学习API利用元组解包。通常，元组限制为不超过三个元素以减少最终用户的困惑。跟踪三个元素似乎并不复杂（大部分情况下）。但是，使用位置引用从函数或方法返回元素变得麻烦，因为代码必须在这些代码被调用的每个地方反映这些位置返回。
- en: Tuple unpacking ends up increasing the level of confusion in people reading
    and maintaining the code and raises the overall level of complexity of the code
    base. By moving to encapsulated return types (named tuples in Python, case classes
    in Scala), we can minimize the number of lines of code that need to be changed
    in a feature branch and reduce the confusion in interpreting the code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 元组解包最终会增加阅读和维护代码的人的困惑程度，并提高代码库的整体复杂性。通过转向封装的返回类型（Python中的命名元组，Scala中的case类），我们可以最小化在功能分支中需要更改的代码行数，并减少对代码的解释困惑。
- en: '10.4 Blind to issues: Eating exceptions and other bad practices'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 对问题视而不见：吞噬异常和其他不良做法
- en: 'Let’s continue our scenario of walking into a code base that we’re unfamiliar
    with by focusing on running a full test of our first feature branch. As part of
    this branch, we have to use a data loader module that was written for interfacing
    with the object-storage data lake. Because of the poor documentation and difficult-to-read
    code of this module, we mistakenly pass the wrong authentication token. Stderr
    and stdout, upon executing our branch, merely have a single line printed out:
    `Oops.``Couldn''t``read``data.`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的场景，即进入一个我们不熟悉的代码库，通过关注运行我们的第一个功能分支的全面测试来集中精力。作为这个分支的一部分，我们必须使用一个为与对象存储数据湖接口而编写的数据加载模块。由于该模块的文档不佳和难以阅读的代码，我们错误地传递了错误的认证令牌。在执行我们的分支时，Stderr和stdout仅打印出一行：`Oops.``Couldn't``read``data.`。
- en: Not only is this incredibly annoying (cute error messages are not useful), but
    it doesn’t provide any guidance as to *why* the data couldn’t be read. Was the
    data not present? Did we pass in an invalid path? Do we have access to this data?
    Is something in the new feature branch’s usage of the method within the data loader
    class malformed?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅非常令人烦恼（可爱的错误消息没有用），而且它没有提供任何关于*为什么*数据无法读取的指导。数据是否存在？我们传递了无效的路径吗？我们是否有权访问这些数据？新功能分支中数据加载类的方法使用是否不规范？
- en: 'We simply won’t know without loading and parsing the logs on the system. We
    will have to trace, modify our code, insert debug statements, and spend hours
    digging into our code and the utility module code to figure out what’s going on.
    We’ve become an unwitting victim of *exception eating*: a misguided intention
    to “just make it work” by the inappropriate use of a try/catch block.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 没有加载和解析系统上的日志，我们根本无法知道。我们必须追踪、修改我们的代码，插入调试语句，并花费数小时深入挖掘我们的代码和实用模块代码，以找出发生了什么。我们不知不觉成为了*异常吞噬*的受害者：这是一种错误的意图，通过不恰当地使用try/catch块来“仅仅让它工作”。
- en: 10.4.1 Try/catch with the precision of a shotgun
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 使用猎枪精度的try/catch
- en: One of the more dangerous bad habits to get into when developing ML code is
    in exception handling. This area of software development is typically foreign
    to the way most DS practitioners write code when trying to solve a problem.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发机器学习代码时，养成的一个更危险的不良习惯是在异常处理方面。这个软件开发领域通常与大多数数据科学家在尝试解决问题时编写代码的方式不同。
- en: Generally, when an error happens while writing code, the issue is fixed for
    the problem at hand, and then work continues on solving the problem. However,
    in the realm of production code, many things can go wrong in a code base. Perhaps
    the data being passed in is malformed, the scale of the data changes to such a
    degree that calculations are no longer valid, or one of the other millions of
    things that can go wrong might go wrong.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当编写代码时发生错误，问题会得到解决，然后继续解决其他问题。然而，在生产代码领域，代码库中可能发生许多错误。可能传递的数据不规范，数据规模变化到一定程度，计算不再有效，或者可能发生数百万种可能出错的情况之一。
- en: I’ve seen many people slap a try/catch around where a seemingly innocuous fault
    occurs. Not fully understanding how to implement handling of a specific exception,
    however, could lead to using a *blind catch*, which can create a situation that
    makes the code base incredibly challenging to debug.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到许多人将看似无害的故障周围的try/catch快速贴上。然而，如果不完全理解如何实现特定异常的处理，可能会导致使用*盲目捕获*，这可能会使代码库难以调试。
- en: NOTE For step-by-step examples of how exception handling, when done incorrectly,
    can cause problems, see the companion repository to this book and follow along
    with the Jupyter notebook CH09_1.ipynb.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关异常处理不当可能导致问题的逐步示例，请参阅本书的配套仓库，并跟随Jupyter笔记本CH09_1.ipynb。
- en: 'Listing 10.9 illustrates this concept. In this simple example, we’re taking
    an integer and dividing it by a list of integers. What we want out of this function
    is a new collection that represents the quotient of the base number divided by
    each member of the passed-in collection. The results below the function show the
    inevitable result of executing the code: a `ZeroDivisionError`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.9说明了这个概念。在这个简单的例子中，我们正在取一个整数并除以一个整数列表。我们希望从这个函数中得到一个新的集合，表示基数除以传入集合的每个成员的商。函数下面的结果显示了执行代码的必然结果：一个`ZeroDivisionError`。
- en: Listing 10.9 A simple collection division function that will throw an exception
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.9 一个简单的集合除法函数，它将抛出异常
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Generates a list of numbers between 0 and 99, inclusive
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 生成一个介于0和99之间的数字列表，包括0和99
- en: ❷ Shuffles in place to provide random ordering of the generated list of integers
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在原地打乱以提供生成的整数列表的随机排序
- en: ❸ The function definition—the signature of base is the number for dividing the
    collection variable’s contents
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 函数定义——base的签名是用于除以集合变量内容的数字
- en: ❹ Loops through each element in the collection
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 遍历集合中的每个元素
- en: ❺ Appends the quotient of the base number and the iterator value of the list
    collection entity at position held in i
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将基数和列表集合实体的迭代器值在位置i的商追加到列表中
- en: ❻ Calls the function
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 调用函数
- en: ❼ The stdout result of the exception being thrown. The stack trace is shown
    below this header.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 异常抛出的stdout结果。堆栈跟踪显示在以下标题下方。
- en: ❽ Identified line of the code causing the issue
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 识别出问题的代码行
- en: ❾ The ZeroDivisionError Exception class name and message associated with the
    exception
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 与异常相关的ZeroDivisionError异常类名称和消息
- en: The *blind catch* (aka *eating* all of the exceptions) solution that many DSs
    I’ve seen use to address this problem might look something like the following
    listing. To be clear, this should *never* be done.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到许多数据科学家（DSs）用来解决这个问题的“盲目捕获”（也称为“吞噬”所有异常）的解决方案可能看起来像以下列表。为了清楚起见，这绝对不应该这样做。
- en: Listing 10.10 Unsafe exception-handling example
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.10 不安全的异常处理示例
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ The try block attempts to perform the encapsulated action, but if an exception
    is thrown (raised), it will move to the except blocks.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ try块尝试执行封装的操作，但如果抛出异常（引发），它将移动到except块。
- en: ❷ The except block(s) that contain handling code for specific exceptions. This
    implementation (blind catch) is dangerous, inadequate, and will cause stability
    and troubleshooting problems (this is effectively writing a bug directly into
    code).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 包含处理特定异常的代码的except块。这种实现（盲目捕获）是危险的、不充分的，并会导致稳定性和故障排除问题（这实际上是在代码中直接写入错误）。
- en: ❸ The dangerous “pass” (do nothing) command can be useful for stateless transaction
    systems (think web apps) but should never be used in ML code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 危险的“pass”（什么都不做）命令对于无状态事务系统（例如Web应用程序）可能是有用的，但不应该在ML代码中使用。
- en: When we execute this code against our list, we will get a return of a list filled
    with 99 numbers, minus the 0 value that threw an exception and was ignored because
    of the `pass` keyword. While this might seem like it solves the problem and lets
    the execution continue, this is a *truly terrible solution*. The following listing
    illustrates why.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码针对我们的列表时，我们将得到一个包含99个数字的列表的返回值，减去抛出异常并被忽略的0值，因为使用了`pass`关键字。虽然这看起来像解决了问题并允许执行继续，但这实际上是一个**真正糟糕的解决方案**。以下列表说明了原因。
- en: Listing 10.11 Example of why blind exception handling is bad
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.11 盲目异常处理的例子
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Passes in a string to be divided by. This obviously will not work (it will
    throw a TypeError).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 传入一个要除以的字符串。这显然不会工作（它将抛出TypeError）。
- en: ❷ Since we’re catching all exceptions and just moving on (the pass keyword),
    no exceptions are thrown to warn us that something didn’t work properly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 由于我们捕获了所有异常并且只是继续执行（使用pass关键字），没有异常被抛出以警告我们某些事情没有正常工作。
- en: ❸ The list is empty. That will likely break things downstream.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 列表为空。这可能会破坏下游的操作。
- en: When we pass something that is not a number into this function, we get no errors.
    Not a single exception is thrown to warn us that the return value is an empty
    list. What we can try to do is catch the exact exception instead so that situations
    like this won’t happen, making us effectively blind to issues.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将非数字传递给此函数时，我们不会得到任何错误。没有抛出任何异常来警告我们返回值是一个空列表。我们可以尝试捕获确切的异常，这样就不会发生类似的情况，使我们能够有效地忽略问题。
- en: Issues with catching all exceptions
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获所有异常的问题
- en: While the example in listing 10.11 is obvious, rather simple, and somewhat pointless
    in its functionality, real-world instances of this sort of pattern rear themselves
    in truly ugly ways.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然列表10.11中的例子很明显，相当简单，在功能上有些无意义，但这类模式在现实世界中的实例却以真正丑陋的方式出现。
- en: Suppose that you have a series of blind try/catch statements written around
    the vast majority of the code within an ML project. From reading in the source
    data, performing feature-engineering tasks, model tuning, validation, and logging,
    each major step is wrapped in a `try`, `except`, and then `pass` statement. What
    would happen if there was an issue with the data that failed in an encoding step?
    What about an expired authentication token to read the source data? What if the
    data was moved, and the location that you’re reading from is now empty? What if
    the model failed to converge?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在机器学习项目的绝大多数代码周围编写了一系列盲目的 try/catch 语句。从读取源数据，执行特征工程任务，模型调优，验证和日志记录，每个主要步骤都被包裹在一个
    `try`，`except`，然后 `pass` 语句中。如果数据在编码步骤中出现问题会发生什么？关于读取源数据的过期认证令牌呢？如果数据被移动，而你正在读取的位置现在是空的怎么办？如果模型未能收敛呢？
- en: The point I’m trying to make is that those scenarios, to the person investigating
    why the job didn’t produce any output, all look identical. The only indication
    that something went wrong is that the job didn’t do what it was supposed to do.
    Since all of the exceptions have been eaten, there is absolutely no indication
    of where to even begin looking to find the culprit.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图说明的是，对于调查为什么工作没有产生任何输出的人来说，这些场景看起来都是相同的。唯一的指示是工作没有完成它应该做的事情。由于所有异常都被吞噬了，根本没有任何迹象表明从哪里开始寻找问题的根源。
- en: It’s for this reason that blind catching of exceptions is so inherently dangerous.
    At some point in the future of any long-running project code base, problems will
    arise. The job will fail for one reason or another. If you’re handicapping your
    ability to figure out the issue, you’re going to have to step through the code
    manually or perform some sort of binary search to track down what’s going on.
    Figuring out problems in this way wastes effort and time.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，盲目捕获异常是如此危险。在任何长期运行的项目代码库中，未来某个时刻都会出现问题。工作可能会因为各种原因失败。如果你阻碍了自己找出问题的能力，你将不得不手动逐行代码或执行某种二分搜索来追踪发生了什么。以这种方式找出问题会浪费精力和时间。
- en: Even though it may seem like more work to write proper exception handling, it’s
    the right thing to do. When the code eventually blows up—and it will, trust me,
    because given enough time, all code bases do—you’ll be grateful to have spent
    an extra 30 minutes writing proper handling code when it gets you to the source
    of the issue in minutes rather than days.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 即使编写适当的异常处理可能看起来更费事，但这确实是正确的事情。当代码最终崩溃——相信我，它会的，因为给足够的时间，所有代码库都会崩溃——当你用额外的 30
    分钟编写适当的处理代码，让你在几分钟而不是几天内找到问题的根源时，你会感到非常感激。
- en: 10.4.2 Exception handling with laser precision
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 精确的异常处理
- en: The next listing shows the proper way to catch an exception by type.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了正确按类型捕获异常的方法。
- en: Listing 10.12 Catching and handling a single exception safely
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.12 安全地捕获和处理单个异常
- en: '[PRE11]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Catches the exact exception that we want (ZeroDivisionError) and gets a reference
    to the exception object (e)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 捕获了我们想要的精确异常（ZeroDivisionError）并获取了对异常对象的引用（e）
- en: ❷ A less-than-ideal handling of the exception (we’re still effectively ignoring
    it by printing it to stdout whenever it occurs, but at least we’re doing something
    with it). A proper handling would be to log the error to a logging service or
    to MLflow.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对异常的处理不够理想（我们仍然通过在发生时将其打印到标准输出而有效地忽略它，但至少我们对它做了些处理）。适当的做法是将错误记录到日志服务或 MLflow。
- en: ❸ Calling the function results in no thrown interruptible exceptions, but it
    does let us know what happened.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用该函数不会抛出可中断的异常，但它确实让我们知道发生了什么。
- en: ❹ It dropped one of the elements (the zero integer), but processed the remaining
    99 elements of the input list.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 它丢失了一个元素（零整数），但处理了输入列表中剩余的 99 个元素。
- en: This introduces a new problem, though. We have the warning message that was
    generated, but it’s printed to stdout. This doesn’t help us in a production system
    where we will need, in order to troubleshoot issues, a historical record of the
    conditions under which this problem happened.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这虽然引入了一个新问题。我们有了生成的警告信息，但它被打印到了标准输出。在需要历史记录来排查问题的生产系统中，这并不能帮助我们。
- en: We will instead need to have a centralized place to see the details of the *what*,
    the *where*, and the *when* for the times that these issues happen. We also need
    to ensure that, at a minimum, we have a parse-able standard format for our logs
    that can reduce the time spent searching through log files to track down an issue.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要有一个集中的地方来查看这些问题发生时的*什么*、*哪里*和*何时*的细节。我们还需要确保，至少我们有一个可解析的标准日志格式，这样可以减少搜索日志文件以跟踪问题所花费的时间。
- en: 10.4.3 Handling errors the right way
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3 正确处理错误
- en: The following listing shows the final implementation of this exception-handling
    scenario, replete with a custom exception, logging, and control handling for the
    zero-division error.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了此异常处理场景的最终实现，包括自定义异常、日志记录和对除以零错误的控制处理。
- en: Listing 10.13 Final implementation with proper exception handling and logging
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.13 带有适当异常处理和日志记录的最终实现
- en: '[PRE12]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ These three lines are required only for Jupyter Notebook functionality. In
    an .egg file, you would simply instantiate a new logging instance (Jupyter, however,
    starts one for you when you initialize a session).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这三条线仅适用于Jupyter Notebook功能。在一个.egg文件中，你只需实例化一个新的日志实例（然而，Jupyter在初始化会话时会为你启动一个）。
- en: ❷ Creates a custom exception class with the ability to inherit properties from
    the standard ValueError exception, as well as providing *args to allow another
    developer to extend or customize this exception class
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个自定义异常类，具有从标准ValueError异常继承属性的能力，并提供*args以允许其他开发人员扩展或自定义此异常类
- en: ❸ Retrieves the current function name for logging purposes (prevents having
    to hand-type the name in multiple places)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取当前函数名称以进行日志记录（防止在多个地方手动输入名称）
- en: ❹ Catches the divide-by-zero exception, logs it, and then provides a placeholder
    value
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 捕获除以零异常，记录它，并提供一个占位符值
- en: ❺ Catches the TypeError for mathematically invalid operations based on the data
    passed in
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 捕获基于传入数据的数学无效操作的TypeError
- en: ❻ Logs the TypeError exception before doing anything else (so we have visibility
    that it occurred)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在做任何事情之前记录TypeError异常（以便我们有可见性知道它发生了）
- en: ❼ After logging the exception, we want to raise it manually so the function
    will alert a developer who is interfacing with it that they really should be passing
    a numeric type to this function for the base variable.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 在记录异常后，我们希望手动抛出它，以便函数会提醒与它交互的开发者，他们确实应该向此函数传递数值类型的基变量。
- en: ❽ Gets the length of the input list “collection” and the post-for-loop length
    of the output list
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 获取输入列表“collection”的长度和循环后的输出列表长度
- en: ❾ If the list sizes don’t match, creates an object of our custom exception class
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 如果列表大小不匹配，创建我们的自定义异常类的对象
- en: ❿ Logs our custom exception’s details
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 记录我们自定义异常的详细信息
- en: ⓫ Raises the custom exception
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 抛出自定义异常
- en: ⓬ Since we’re replacing the failed zero-division error with 0.0 in the output
    list, our list lengths match (100).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 由于我们在输出列表中将失败的除以零错误替换为0.0，我们的列表长度匹配（100）。
- en: At this point, when we run the function with either a valid collection (containing
    zero or not), we will get a log report of each instance that is replaced. When
    we call the function with invalid values, we will get an exception logged and
    also thrown (desirable behavior). Finally, when the lists don’t match because
    of a future modification to this function (such as catching a new exception and
    not replacing a value or modifying the behavior of the logic), the person making
    those changes will be alerted in clear terms that their changes have introduced
    a bug.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，当我们用有效的集合（包含零或不包含零）运行函数时，我们将得到每个被替换实例的日志报告。当我们用无效的值调用函数时，我们将记录异常并抛出（期望的行为）。最后，当列表不匹配是因为对函数的将来修改（例如捕获新的异常而不替换值或修改逻辑行为）时，进行这些更改的人将以明确的方式被提醒他们的更改引入了错误。
- en: The next listing shows the log results of running this on the original configuration
    for variable submission, testing an invalid string parameter being supplied as
    the base argument, and simulating the lengths not matching.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了在原始配置下运行此代码的日志结果，测试作为基参数提供的无效字符串参数，并模拟长度不匹配的情况。
- en: Listing 10.14 Logging results of caught and handled exceptions
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.14 捕获和处理异常的日志结果
- en: '[PRE13]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Very simple function to read in the log file
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 非常简单的函数，用于读取日志文件
- en: ❷ We’re even handling the expected exception for the open() function so that
    if the log file hasn’t been generated (because no issues occur with the usage
    of the function), we won’t have a nasty exception thrown that isn’t clear to the
    end user of the function. Instead, a simple explanation prints out that lets us
    know that the log hasn’t been created yet.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们甚至处理了open()函数预期的异常，这样如果日志文件尚未生成（因为函数使用中没有出现任何问题），我们不会抛出一个对函数最终用户来说不清楚的讨厌异常。相反，会打印出一个简单的解释，让我们知道日志尚未创建。
- en: ❸ The exception that we’re expecting to get from passing in a collection list
    of integers containing the number 0
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们期望从传递包含数字0的整数集合列表中获得的异常
- en: ❹ The result of removing the “replace with 0.0” functionality in the catch block
    for handling the zero-division error
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在处理零除错误时，从捕获块中移除“替换为0.0”功能的结果
- en: ❺ The logged result of passing in an invalid value as the base argument to the
    function (which would also throw an exception at runtime, but after having logged
    the exception into the log)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将无效值作为函数的基数参数传递时的记录结果（这也会在运行时抛出异常，但已经在日志中记录了异常）
- en: Logging even innocuous errors that may not seem important during development
    can be an invaluable tool for addressing issues in production. Whether you want
    to fix the root cause of nuisance issues or check on the health of a code base,
    without having logs and the appropriate data being written to them, you could
    be completely unaware of potential problems in your solution’s code. When in doubt,
    log it out.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 记录即使是看似不重要的错误，在开发过程中也可能是一个非常有价值的工具，用于解决生产中的问题。无论您是想修复麻烦问题的根本原因还是检查代码库的健康状况，如果没有日志和适当的数据写入其中，您可能完全不知道解决方案代码中可能存在的潜在问题。当有疑问时，记录下来。
- en: 10.5 Use of global mutable objects
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 使用全局可变对象
- en: Continuing our exploration of our new team’s existing code base, we’re tackling
    another new feature to be added. This one adds completely new functionality. In
    the process of developing it, we realize that a large portion of the necessary
    logic for our branch already exists and we simply need to reuse a few methods
    and a function. What we fail to see is that the function uses a declaration of
    a globally scoped variable. When running our tests for our branch in isolation
    (through unit tests), everything works exactly as intended. However, the integration
    test of the entire code base produces a nonsensical result.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续探索我们新团队现有的代码库时，我们正在处理要添加的另一个新功能。这个功能添加了完全新的功能。在开发过程中，我们意识到我们分支所需的大部分逻辑已经存在，我们只需要重用几个方法和一个函数。我们没有看到的是，该函数使用了一个全局作用域变量的声明。当我们通过单元测试单独运行我们分支的测试时，一切工作正如预期。然而，整个代码库的集成测试产生了不合理的成果。
- en: After hours of searching through the code, walking through debugging traces,
    we find that the state of the function that we were using actually changed from
    its first usage, and the global variable that the function was using actually
    changed, rendering our second use of it completely incorrect. We were burned by
    mutation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 经过数小时在代码中搜索，跟踪调试跟踪后，我们发现我们使用的函数的状态实际上从第一次使用后发生了变化，该函数使用的全局变量实际上也发生了变化，这使得我们对它的第二次使用完全错误。我们被突变烧伤了。
- en: 10.5.1 How mutability can burn you
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.1 可变性如何烧伤你
- en: 'Recognizing how dangerous mutability is can be a bit tricky. Overuse of mutating
    values, shifting state, and overwriting of data can take many forms, but the end
    result is typically the same: an incredibly complicated series of bugs. These
    bugs can manifest themselves in different ways: *Heisenbugs* seemingly disappear
    when you’re trying to investigate them, and *Mandelbugs* are so complex and nondeterministic
    that they seem to be as complex as a fractal. Refactoring code bases that are
    riddled with mutation is nontrivial, and many times it’s simply easier to start
    over from scratch to fix the design flaws.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 认识到可变性有多危险可能有点棘手。过度使用可变值、状态转换和数据覆盖可以有多种形式，但最终结果通常是相同的：一系列极其复杂的错误。这些错误可以以不同的方式表现出来：*海森堡虫*似乎在你试图调查它们时消失了，而*曼德尔虫*如此复杂和非确定性，以至于它们似乎像分形一样复杂。重构充满变动的代码库是非平凡的，很多时候从头开始重新开始更容易来修复设计缺陷。
- en: Issues with mutation and side effects typically don’t rear their heads until
    long after the initial MVP of a project. Later, in the development process or
    after a production release, flawed code bases relying on mutability and side effects
    start to break apart at the seams. Figure 10.3 shows an example of the nuances
    between different languages and their execution environments and why mutability
    concerns might not be as apparent, depending on which languages you’re familiar
    with.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 可变性和副作用的问题通常在项目的初始MVP（最小可行产品）之后很久才会显现出来。后来，在开发过程中或生产发布之后，依赖于可变性和副作用的代码库开始出现裂缝。图
    10.3 展示了不同语言及其执行环境之间的细微差别，以及为什么可变性问题可能并不那么明显，这取决于你熟悉哪些语言。
- en: '![10-03](../Images/10-03.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![10-03](../Images/10-03.png)'
- en: Figure 10.3 Comparing mutability in Python and JVM-based languages
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 比较Python和基于JVM的语言的可变性
- en: For simplicity’s sake, let’s say that we’re trying to keep track of some fields
    to include in separate vectors used in an ensemble modeling problem. The following
    listing shows a simple function that contains a default value within the function
    signature’s parameters which, when used a single time, will provide the expected
    functionality.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，让我们假设我们正在尝试跟踪一些字段，以便在用于集成建模问题的单独向量中包含它们。以下列表显示了一个包含函数签名参数中默认值的简单函数，当单次使用时，将提供预期的功能。
- en: Listing 10.15 An example utility function for maintaining a list of elements
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.15 维护元素列表的示例实用函数
- en: '[PRE14]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Simple function for adding a list to a new list of elements (not a realistic
    example for vector creation, but it’s meant to be simple for purposes of explanation)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是一个简单的函数，用于将一个列表添加到新的元素列表中（这不是创建向量的真实示例，但为了解释的目的，它旨在简单）
- en: ❷ Iterates through the supplied list of elements and adds to a new collection
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历提供的元素列表，并将其添加到新的集合中
- en: ❸ Returns the new collection
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回新的集合
- en: The following is the output from a single use of this function. No real surprises
    here.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从该函数的单次使用中得到的输出。这里没有真正的惊喜。
- en: Listing 10.16 Usage of the simple listing function
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.16 简单列表函数的使用
- en: '[PRE15]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Adds three string elements into a new collection by passing it to our function
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过将它们传递给我们的函数，将三个字符串元素添加到新的集合中
- en: ❷ As expected, we have a list containing those elements that we passed in.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如预期的那样，我们有一个包含我们传入的元素的列表。
- en: However, what happens when we call it a second time for an additional operation?
    The next listing shows this additional usage, including what the values are, but
    also what happens to the original variable declaration.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们第二次调用它进行额外操作时会发生什么？下一个列表显示了这种额外使用，包括值是什么，以及原始变量声明发生了什么变化。
- en: Listing 10.17 Object state mutation by repeated calls to our function
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.17 通过重复调用我们的函数来修改对象状态
- en: '[PRE16]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Calls the function again with a new list of elements. We should expect the
    return to be ['d', 'e', 'f'], right?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 再次调用函数，传入新的元素列表。我们应该期望返回值是 ['d', 'e', 'f']，对吧？
- en: ❷ Uh, oh. The return still has values from when it was called previously. That’s
    weird.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 哎呀。返回值仍然包含之前调用时的值。这很奇怪。
- en: ❸ And it updates the variable list from the first call that we made. This seems
    broken.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 并且它更新了我们第一次调用的变量列表。这似乎是出错了。
- en: Now that’s a bit unexpected, right? What if we were intending to build one model
    with fields `a`, `b`, and `c`, and then build another model with fields `d`, `e`,
    and `f`? Both of these models would have input vectors of all six columns. Utilizing
    mutation to override variables in this manner wouldn’t break the project’s code.
    Both models would execute without throwing exceptions. However, unless we validated
    everything very carefully, we would overlook that we just built two identically
    configured models.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点出乎意料，对吧？如果我们打算构建一个具有字段 `a`、`b` 和 `c` 的模型，然后构建另一个具有字段 `d`、`e` 和 `f` 的模型呢？这两个模型都会有所有六个列的输入向量。以这种方式使用可变性覆盖变量不会破坏项目的代码。这两个模型都会执行而不会抛出异常。然而，除非我们非常仔细地验证一切，否则我们可能会忽略我们实际上构建了两个配置相同的模型。
- en: Bugs like this are crippling to productivity. The time spent debugging to figure
    out why something doesn’t work as intended can be large indeed; that’s time that
    should be spent on building something new, instead of figuring out why our code
    doesn’t work the way we intend.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的错误对生产力具有致命的影响。花费在调试以找出为什么某些事情没有按预期工作的时间确实可能很大；这些时间本应该花在构建新事物上，而不是找出我们的代码为什么没有按我们的意图工作。
- en: All of this happens because Python functions are objects themselves. They maintain
    state, and as such, the language does not include the concept that the variables
    and operations that happen within them are isolable. Care must be taken, particularly
    when adding to code bases, that the original implementations are crafted in such
    a way so as not to introduce unexpected behavior (avoiding unintentional mutation,
    in this example).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些发生的原因是因为Python函数本身也是对象。它们维护状态，因此，该语言不包含变量和操作在它们内部发生是可隔离的概念。在添加到代码库时，必须注意原始实现是以一种方式构建的，这样就不会引入意外的行为（在这个例子中是避免意外的修改）。
- en: The first and foremost goal when adding new functionality to a code base is
    to make sure that the code runs (exceptions aren’t thrown). Correctness issues
    can arise if the changes are not validated, creating hard-to-diagnose bugs due
    to the inadvertent use of shortcuts such as unsafe mutation. How should we have
    written this code?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当向代码库添加新功能时，首要目标是确保代码能够运行（不会抛出异常）。如果更改未经验证，可能会出现正确性问题，由于无意中使用诸如不安全的修改等捷径，这会导致难以诊断的错误。我们该如何编写这段代码？
- en: 10.5.2 Encapsulation to prevent mutable side effects
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.2 封装以防止可变副作用
- en: By knowing that the Python functions maintain state (and everything is mutable
    in this language), we could have anticipated this behavior. Instead of applying
    a default argument to maintain isolation and break the object-mutation state,
    we should have initialized this function with a state that could be checked against.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解Python函数维护状态（在这个语言中一切都是可变的），我们本可以预测这种行为。而不是应用默认参数以保持隔离并打破对象修改状态，我们应该用可以与之比较的状态初始化这个函数。
- en: By performing this simple state validation, we are letting the interpreter know
    that in order to satisfy the logic, a new object needs to be created to store
    the new list of values. The proper implementation for checking on instance state
    in Python for collection mutation is shown in the following listing.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行这种简单的状态验证，我们让解释器知道，为了满足逻辑，需要创建一个新的对象来存储新的值列表。Python中用于检查集合修改实例状态的正确实现如下所示。
- en: Listing 10.18 A fixed implementation for the utility function
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.18：固定实现实用函数
- en: '[PRE17]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Changes the signature to default the second argument to None instead of an
    empty list
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将签名更改为将第二个参数默认设置为None而不是空列表
- en: ❷ If nothing has been passed in to the feature_collection argument, creates
    a new empty list (this triggers Python to generate a new object in this case)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果没有传递任何内容给feature_collection参数，则创建一个新的空列表（这会触发Python在此情况下生成一个新对象）
- en: ❸ As expected, we get a new list with the elements that we passed in.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如预期的那样，我们得到了一个新的列表，其中包含我们传入的元素。
- en: ❹ Now we get a new list with the repeated call. This is the expected behavior.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 现在我们得到了一个新的列表，这是重复调用后的结果。这是预期的行为。
- en: ❺ The original variable has not been changed with the reuse of the function.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 重复使用函数时，原始变量没有改变。
- en: Seemingly small issues like this can create endless headaches for the person
    (or team) implementing a project. Typically, these sorts of problems are developed
    early on, showing no issues while the modules are being built out. Even simple
    unit tests that validate this functionality in isolation will appear to be functioning
    correctly.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的看似小的问题可能会给实施项目的人（或团队）带来无尽的麻烦。通常，这类问题在早期开发时就会显现出来，在构建模块时没有问题。即使简单的单元测试，在隔离的情况下验证这个功能，看起来也是正确的。
- en: It is typically toward the midpoint of an MVP that issues involving mutability
    begin to rear their ugly heads. As greater complexity is built out, functions
    and classes may be utilized multiple times (which is a desired pattern in development),
    and if not implemented properly, what was seeming to work just fine before now
    results in difficult-to-troubleshoot bugs.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在MVP（最小可行产品）的中期，与可变性相关的问题开始显现出来。随着复杂性的增加，函数和类可能会被多次使用（这在开发中是一个期望的模式），如果没有正确实现，之前看似正常的工作现在会导致难以调试的错误。
- en: Pro Tip It’s best to become familiar with the way your development language
    handles objects, primitives, and collections. Knowing these core nuances of the
    language will give you the tools necessary to guide your development in a way
    that won’t create more work and frustration for you throughout the process.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：最好熟悉你的开发语言如何处理对象、原始类型和集合。了解这些语言的核心细微差别将为你提供必要的工具，以指导你的开发过程，这样就不会在整个过程中给你带来更多的工作和挫败感。
- en: A note on encapsulation
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 关于封装的说明
- en: Throughout this book, you’ll see multiple references to me beating a dead horse
    about using functions in favor of declarative code. You’ll also notice references
    to favoring classes and methods to functions. This is all due to the overwhelming
    benefits that come with using encapsulation (and abstraction, but that’s another
    story discussed elsewhere in the text).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你会看到多次提到我反复强调使用函数而不是声明性代码。你也会注意到提到优先考虑类和方法而不是函数。这一切都是由于使用封装（以及抽象，但这又是另一个故事，将在文本的其他地方讨论）带来的压倒性好处。
- en: 'Encapsulating code has two primary benefits:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 封装代码有两个主要好处：
- en: Restricting end-user access to internal protected functionality, state, or data
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制最终用户访问内部受保护的功能、状态或数据
- en: Enforcing execution of logic on a bundle of the data being passed in and the
    logic contained within the method
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传入的数据包和包含在方法中的逻辑上执行逻辑的强制执行
- en: 'While the first reason is largely inconsequential to the vast majority of data
    scientists (unless you’re writing an open source project or utility libraries,
    or contributing to public-facing APIs), the second attribute of encapsulation
    can save ML practitioners no end of headaches. Through this bundling of data (the
    arguments of data being passed into a method) and the localized execution of logic
    upon that data, you can isolate behavior from other processes:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第一个原因对绝大多数数据科学家来说意义不大（除非你在编写开源项目或实用库，或者向公众提供的API做出贡献），但封装的第二个属性可以节省机器学习从业者无数的麻烦。通过这种数据捆绑（即将数据作为参数传递给方法的参数）和在该数据上局部执行逻辑，你可以将行为与其他过程隔离开来：
- en: A variable declared in a method is referenced only within that method.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法中声明的变量只在该方法内部引用。
- en: The only external-facing access that a method has to the outside world is in
    its return value.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法对外部世界的唯一外部访问途径就是它的返回值。
- en: The operations that are performed cannot be influenced by the state of anything
    other than the arguments passed into it.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行的操作不能受到除传入它的参数之外任何其他状态的影响。
- en: 'These attributes of encapsulation mean that you can ensure correctness of your
    code at any given time; for example, if you have a method whose sole purpose is
    to apply a sales tax offset to an item’s price, you can pass in the item cost
    and the tax rate, and ensure that no matter what the underlying state of the system
    is external to that method, it’s always just going to do one thing: apply a sales
    tax offset to the value passed in and return the adjusted value. These attributes
    also can help make your code more testable.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些封装属性意味着你可以在任何给定时间确保代码的正确性；例如，如果你有一个方法，它的唯一目的是对商品价格应用销售税抵扣，你可以传入商品成本和税率，并确保无论系统外部的基础状态如何，它始终只会做一件事：对传入的价值应用销售税抵扣并返回调整后的值。这些属性还可以帮助使你的代码更容易测试。
- en: Encapsulation has many other benefits (particularly for ML work) that we will
    cover in part 3 of this book. For now, remember that mutability issues and the
    headaches that state management can bring can be completely removed by the proper
    application of encapsulation of data and logic through the use of functions and
    methods.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 封装还有许多其他好处（尤其是对于机器学习工作），我们将在本书的第三部分中介绍。现在，请记住，通过使用函数和方法正确应用封装数据和方法，可以完全消除可变性问题以及状态管理可能带来的头痛。
- en: 10.6 Excessively nested logic
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 过度嵌套的逻辑
- en: 'Of all of the frequently coded parts of ML code bases, none bring more dread
    to those who must read and debug them than a large conditional logic tree. Most
    start relatively simply early in their utilization: a few `if` statements, a handful
    of `elif`, followed by a small number of catchall `else` statements. By the time
    the code has been in production for a few months, these monoliths of headache-inducing
    logic can span hundreds (if not thousands) of lines. These business logic rules
    generally evolve into a multilevel mess of complicated, confusing, and nearly
    impossible-to-maintain logic.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有常见的机器学习代码库编码部分中，没有一个比大型条件逻辑树更让那些必须阅读和调试它们的人感到恐惧。大多数逻辑树在早期使用时相对简单：几个`if`语句，一些`elif`，然后是一小部分通用的`else`语句。等到代码在生产环境中运行了几个月后，这些头痛的逻辑巨石可以扩展到数百行（如果不是数千行）。这些业务逻辑规则通常演变成多层混乱、复杂、几乎无法维护的逻辑。
- en: 'As an example, let’s look at a frequent use case in the ML world: ensembles.
    Let’s say that we have two models, and each is generating a probability per customer.
    Let’s start with generating that dataset to represent the outputs of these two
    models.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，让我们看看机器学习领域的一个常见用例：集成。假设我们有两个模型，每个模型为每个客户生成一个概率。让我们从生成表示这两个模型输出的数据集开始。
- en: Listing 10.19 Generating our synthetic probability data for the ensemble reconciliation
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.19 生成集成对齐的合成概率数据
- en: '[PRE18]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Encapsulating function for generating our data
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 封装函数用于生成我们的数据
- en: ❷ An encapsulated inner function that will have reference to the seed state
    of the random() function
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个封装的内部函数，它将引用random()函数的种子状态
- en: ❸ Generates a random number based on the seed state supplied to random, using
    the uniform distribution between 0.0 and 1.0
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 根据提供给random的种子状态生成随机数，使用0.0和1.0之间的均匀分布
- en: ❹ Generates a tuple with our two simulated probabilities and iterates over number
    times to create a list of tuples
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 生成包含我们两个模拟概率的元组，并迭代number次以创建一个元组列表
- en: ❺ The synthetic data
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 合成数据
- en: Now that we have some data generated, let’s pretend that the business wants
    five levels of classification based on these different probabilities, combining
    their bucketed values into a single representative score.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经生成了一些数据，让我们假设业务希望根据这些不同的概率进行五级分类，将这些分桶值合并成一个代表分数。
- en: Since Python doesn’t (currently, as of Python 3.9) have switch (case) statements
    available to it, the approach to create this evaluated consolidated score might
    look something like the following.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python（截至Python 3.9）没有提供switch（case）语句，创建这个评估合并分数的方法可能看起来像以下这样。
- en: Listing 10.20 Consolidation logic by way of if, elif, and else statements
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.20 通过if、elif和else语句实现合并逻辑
- en: '[PRE19]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Function for processing the pair combination of two probabilities and resolving
    them through nested conditional logic
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 处理两个概率的配对组合并通过嵌套条件逻辑解决它们的函数
- en: ❷ The nested logic structure (if first probability is less than 0.2, check conditions
    of second probability)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 嵌套逻辑结构（如果第一个概率小于0.2，检查第二个概率的条件）
- en: ❸ The caller function for evaluating the collection of paired tuples of probability
    values
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 评估概率值配对元组集合的调用函数
- en: ❹ Calls the evaluation function for resolving the probabilities to a single
    score
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 调用评估函数以将概率解决为单个分数
- en: ❺ Calls the function on the score data
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 调用函数处理分数数据
- en: ❻ First three elements of the resolved scores based on the conditional logic
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 根据条件逻辑解决的分数的前三个元素
- en: This hierarchical logic chain is written out as a series of `if`, `elif`, and
    `else` statements. It’s both difficult to read and would be a nightmare to maintain
    with additional real-world conditional logic embedded.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分层逻辑链被写成一系列的`if`、`elif`和`else`语句。它既难以阅读，又会在嵌入额外的现实条件逻辑时难以维护。
- en: What would the experience be like if this needed to be modified? The person
    working on that ticket would have to meticulously read through this wall of conditional
    logic and make sure that each place is updated correctly. For this example, it’s
    not overly onerous because of its simplicity, but in code bases that I’ve seen,
    the logic for business rules is rarely so simple and straightforward. Instead,
    nested conditional statements with `and` and `or` are typically within the conditional
    checks, further making this approach incredibly complicated.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要修改这个功能，处理这个工单的人将不得不仔细阅读这堵条件逻辑墙，并确保每个地方都正确更新。对于这个例子来说，由于它的简单性，这并不算过分繁重，但在我所看到的代码库中，业务规则的逻辑很少如此简单直接。相反，通常在条件检查中会有嵌套的`and`和`or`条件语句，这使这种方法变得极其复杂。
- en: 'If this approach were given to a traditional software developer, they would
    likely approach this problem in a completely different way: utilizing configuration
    structures to isolate the business logic from the processing of the consolidation
    of the scores. The next listing shows such a pattern.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将这种方法交给一个传统的软件开发者，他们可能会以完全不同的方式来处理这个问题：利用配置结构将业务逻辑与得分的合并处理隔离开。下面的列表显示了这样的模式。
- en: Listing 10.21 A dictionary-based configuration approach to handling business
    logic
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.21 基于字典配置处理业务逻辑的方法
- en: '[PRE20]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ A lookup dictionary for removing the mapping logic from the processing logic
    (in an actual code base, these dictionaries would be in a different module from
    the processing logic that follows)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于从处理逻辑中移除映射逻辑的查找字典（在实际代码库中，这些字典会位于后续处理逻辑的不同模块中）
- en: ❷ A resolver dictionary for converting the paired probability bucketed thresholds
    to a single score
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于将成对概率的桶化阈值转换为单个得分的解决字典
- en: ❸ Function for processing a single probability and mapping its value to a threshold
    bucket
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 函数用于处理单个概率并将其值映射到阈值桶
- en: ❹ Function for looking up and evaluating the tuple of paired probabilities against
    the matching dictionary
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 函数用于查找和评估成对概率的元组与匹配字典
- en: ❺ Function for iterating through each tuple in the total score set and applying
    the resolution logic
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 函数用于遍历总得分集中的每个元组并应用解决逻辑
- en: ❻ Calls the main function for resolving the probabilities to scores
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 调用主函数以解决概率到得分的转换
- en: ❼ First three elements of the data
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 数据的前三个元素
- en: While this approach is far easier to read than that of the earlier implementation
    from listing 10.20, it’s still far from ideal. Let’s suppose that, during the
    development of the project’s solution, a decision was made to increase the number
    of models generating probability scores from two to eight.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法比列表10.20中早期实现的阅读起来容易得多，但它仍然远非理想。让我们假设，在开发项目解决方案的过程中，做出了一个决定，将生成概率得分的模型数量从两个增加到八个。
- en: How would this affect either of these two structures? The next listing illustrates
    how many lines of code we would have to write for eight models to resolve to a
    single score for both of these implementation patterns.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这将对这两种结构中的哪一种产生影响？接下来的列表说明了为了八个模型解决这两种实现模式，我们需要编写多少行代码。
- en: Listing 10.22 A function to calculate just how many lines of code we’d have
    to write
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.22 一个用于计算我们需要编写多少行代码的函数
- en: '[PRE21]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ A fun little function to calculate how many lines of code we’d have to write
    for the if, elif, else pattern
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个有趣的小函数，用于计算我们需要为if、elif、else模式编写多少行代码
- en: ❷ A very scary number! This is just not realistic to attempt.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个非常可怕的数量！这根本不是现实的尝试。
- en: Clearly, this isn’t an option. Even if we were to attempt to use this method
    (the “dev way” with configuration dictionaries to handle the mappings), if we
    tried eight probabilities to merge into a single score, we’d have 32,768 conditions
    to create within the tuple-8 key for the dictionary. That’s just a truly ridiculous
    number of lines of configuration to write.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不是一个选择。即使我们尝试使用这种方法（使用配置字典处理映射的“开发方式”），如果我们尝试将八个概率合并为一个得分，我们将在字典的元组-8键中创建32,768个条件。这只是一个真正荒谬的配置行数。
- en: A note on sticking with a poor design pattern
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 关于坚持使用糟糕的设计模式的一则笔记
- en: While the example of the `if`/`elif`/`else` pattern may seem a bit ridiculous
    to some readers, I’ve found it to be the most common approach in ML code bases
    that I’ve seen in the wild. The dictionary approach may also seem a bit ridiculous
    when thinking of how many permutations for a configuration control structure might
    be created when we’re talking about eight different elements.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`if`/`elif`/`else`模式的例子可能对一些读者来说有点荒谬，但我发现这是我在野外看到的机器学习代码库中最常见的方法。当我们谈论八个不同的元素时，考虑到配置控制结构可能创建的排列组合数量，字典方法也可能显得有些荒谬。
- en: This example isn’t intended to be hyperbolic. I’ve seen similar configuration
    files, with dictionaries that are well in excess of 10,000 keys to handle logic
    like this. Most of these are not hand-typed (that would be ridiculous), but rather
    are a result of machine-generated code and some copying and pasting into an IDE.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子并不是夸张。我见过类似的配置文件，其中字典的键数远远超过10,000个，以处理这样的逻辑。其中大部分都不是手工输入的（那将是荒谬的），而是机器生成代码和一些复制粘贴到IDE的结果。
- en: The problem isn’t that there are tens of thousands of keys; Python hash tables
    can easily handle without too much hassle a unique key identifier count of 2^(26)
    before performance becomes a bottleneck in the lookup function (67,108,864 entries).
    Python can handle it. Your keyboard and your peers can’t.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 问题不在于有数万个键；Python散列表可以轻松处理，无需太多麻烦就能处理2^(26)个唯一的键标识符计数，在查找函数的性能成为瓶颈之前（67,108,864条记录）。Python可以处理它。你的键盘和你的同伴不能。
- en: The real problem exposed with approaching business logic or feature-engineering
    work in this way is that it’s even attempted in the first place. Approaching problems
    like this with the `if`/`elif`/`else` pattern or the dictionary pattern is akin
    to the old adage, “When all you have is a hammer, everything looks like a nail.”
    There are better ways of solving problems like this that break a complex logical
    pattern into smaller, more manageable pieces.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式处理业务逻辑或特征工程工作所暴露的真实问题是，它甚至被尝试了。用`if`/`elif`/`else`模式或字典模式来处理这类问题，就像古老的谚语，“当你只有一把锤子时，一切看起来都像钉子。”有更好的方法来解决这个问题，可以将复杂的逻辑模式分解成更小、更易于管理的部分。
- en: If you ever find yourself having to copy and paste large chunks of logic over
    and over again, it’s best to walk away from the keyboard, think about how to solve
    it more efficiently, and then return to test out some theories that can help not
    only save your code base from becoming an unmanageable mess, but also make it
    easier to modify and troubleshoot in the future.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己不得不反复复制粘贴大段逻辑，最好的做法是离开键盘，思考如何更高效地解决这个问题，然后回来测试一些可以帮助你不仅使代码库免于变得难以管理，而且在未来更容易修改和调试的理论。
- en: Listing 10.23 shows a much better approach to this problem. In this block of
    code, we’re going to adapt the data generator to support an arbitrary number of
    probabilities as part of the model return tuple, and then convert the lookup function
    from a dictionary to a direct mathematical representation of the scores. From
    this point, the code reduces the complexity to a much more manageable state, allowing
    easier resolution of the business rules by scaling, mapping to a new resolved
    score, and creating a code base that can be easily modified in the future.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.23展示了处理这个问题的更好方法。在这个代码块中，我们将适配数据生成器以支持作为模型返回元组一部分的任意数量的概率，然后将查找函数从字典转换为分数的直接数学表示。从这一点开始，代码将复杂性降低到一个更易于管理的状态，使得通过扩展、映射到新的解析分数以及创建一个未来可以轻松修改的代码库更容易解析业务规则。
- en: Listing 10.23 A better solution that effortlessly scales
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.23 一个轻松扩展的更好解决方案
- en: '[PRE22]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Function to generate an arbitrary number of elements within each tuple
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 生成每个元组内任意数量元素的函数
- en: ❷ Generates a tuple-8 collection of probabilities to resolve to a single score
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 生成一个元组-8概率集合以解析为单个分数
- en: ❸ Example of the first tuple-8 generated
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成第一个元组-8的示例
- en: ❹ Adapts the score-resolving function to mathematical bucketing. To return the
    space of this value to the range of the original 2-tuple ensemble design would
    be as trivial as creating a ceiling or floor function on the sum of the values,
    divided by half of the tuple length.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将分数解析函数适配到数学桶划分。将这个值的范围返回到原始2-元组集合设计的范围，就像创建一个上限或下限函数在值的总和上，除以元组长度的二分之一一样简单。
- en: ❺ Function that sums the resolved scores of the buckets for each element within
    the probability tuple
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对概率元组内每个元素的桶的已解析分数进行求和的函数
- en: ❻ The main function that iterates over the collection of all the tuple probabilities
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 遍历所有元组概率集合的主要函数
- en: ❼ Sample of a portion of the first two elements of the score resolver
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 分数解析器前两个元素的样本
- en: We’ve solved the scalability and complexity problem in a small number of code
    lines. We’ve reduced the complexity (getting rid of dictionaries, mappings, and
    chained logic) and made the code much simpler. The pursuit of simplicity when
    writing code should always be the goal of any developer, particularly one who
    has to deal with the breadth of DS work.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在少量代码行中解决了可扩展性和复杂性问题。我们减少了复杂性（去除字典、映射和链式逻辑），并使代码变得更加简单。在编写代码时追求简单性应该是任何开发者的目标，尤其是那些必须处理DS工作广度的人。
- en: Learning more, and the most frequent question I get asked
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 学习更多，以及我遇到的最频繁的问题
- en: By far, the most frequent question I get asked by junior DS people is, “How
    can I get better at learning all this software development stuff?” It’s a valid
    question. However, it’s typically a rather misguided one.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我收到初级数据科学家最频繁的问题之一是，“我如何提高学习所有这些软件开发知识的能力？”这是一个合理的问题。然而，它通常是一个相当错误的观点。
- en: Software development for ML is very, very different from pure software development.
    It’s a laser-focused microcosm of all the elements that a developer will need
    to know, focused more on creating maintainable and stable code that performs the
    functions required of DS work. Certainly, common ground with pure software development
    fundamentals exists. Knowing the basics of good software design, abstraction,
    encapsulation, comprehension, inheritance, and polymorphism are critical to being
    successful as an ML engineer and as a developer. However, the similarities begin
    to diverge after these fundamentals.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习的软件开发与纯软件开发非常不同。它是一个聚焦于所有开发者需要了解的元素的微观宇宙，更侧重于创建可维护和稳定的代码，以执行数据科学工作所需的功能。当然，与纯软件开发的基本原理存在共同点。了解良好的软件设计、抽象、封装、理解、继承和多态的基础知识对于成为一名成功的机器学习工程师和开发者至关重要。然而，在这些基础知识之后，相似之处开始出现分歧。
- en: What I try to tell junior data scientists when they ask this question is that
    they don’t need to become a seasoned DS as well as a seasoned developer. That’s
    simply untenable (akin to mastering two separate professions simultaneously) for
    the vast majority of people.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当年轻的数据科学家问我这个问题时，我试图告诉他们，他们不需要同时成为经验丰富的数据科学家和经验丰富的开发者。这对绝大多数人来说都是不可行的（就像同时掌握两个不同的职业一样）。
- en: The constructive answer that I give them is rather open-ended, though. It’s
    all about how much they want to know beyond the fundamentals and the specific
    skills needed to become a well-rounded ML engineer.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我给出的建设性回答相当开放。这完全取决于他们想要了解多少超出基础知识和成为全面机器学习工程师所需的具体技能。
- en: Software development skills aren’t something that you *just learn*. You won’t
    gain them from reading this book, or any other. You’re also not going to learn
    them by taking an expensive class or scanning through repositories on the internet.
    These skills are learned by deliberately taking time to focus on new ways of solving
    problems with code while referring to how others who are more skilled than you
    have solved them in the past. They’re learned by failing, rewriting, learning
    from your mistakes, testing, and working to creating code that breaks less frequently
    than the code you wrote last week. It is a *journey*—one that, in my opinion,
    is worthwhile.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发技能不是你“仅仅学习”就能掌握的。你不会通过阅读这本书或任何其他书籍来获得它们。你也不会通过参加昂贵的课程或浏览互联网上的代码库来学习它们。这些技能是通过故意花时间专注于用代码解决问题的新方法，同时参考那些比你更有技能的人过去是如何解决问题的来学习的。它们是通过失败、重写、从错误中学习、测试以及努力编写比上周编写的代码更少出错的代码来学习的。这是一段旅程——在我看来，这是一段值得的旅程。
- en: The issues covered in this chapter are merely things that I see a lot of data
    scientists do in their code that cause their code to be complicated and hard to
    troubleshoot. These topics are most certainly not an exhaustive list, but rather
    a group of examples to help you to think about why certain code that you write
    might be challenging for you or others to troubleshoot, maintain, or even explain.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的问题仅仅是我在看到很多数据科学家在他们的代码中做的事情，这些事情使得他们的代码变得复杂且难以调试。这些主题绝对不是详尽的列表，而是一组例子，帮助你思考为什么你写的某些代码可能对你或其他人来说调试、维护甚至解释都很有挑战性。
- en: There’s a reason that they call programming interfaces *languages.* As with
    any language that you learn, basic syntax rules, grammar, and structural components
    need to be understood and adhered to in order to make your thoughts and intentions
    understood by others. Some of the nuances of programming languages share those
    of spoken and written languages as well. There are well-crafted examples of perfect
    syntax, and there are also shorthand “slang” compositions that are unintelligible
    to all but a small inner circle of those in the know.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 他们之所以称编程接口为“语言”，是有原因的。就像学习任何语言一样，为了使你的思想和意图被他人理解，你需要理解和遵守基本的语法规则、语法和结构组件。编程语言的某些细微差别与口语和书面语言相似。有精心制作的语法完美的例子，也有只有少数知情者才能理解的简写“俚语”组合。
- en: It’s never a good idea to write code like you’re texting a friend with an inside
    joke, just as it’s not advisable to speak in that manner when at a job interview.
    Without the knowledge and standards of a language, though, even well-intentioned
    developers who are ignorant of such standards will produce code that is as unintelligible
    as a first-week student non-native speaker of a language, or, more damaging, as
    unrefined and amateurish as someone who delivers a speech in internet shorthand
    memetic idioms.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在面试时不宜用那种方式说话一样，编写像给朋友发带内部玩笑的短信一样的代码也不是一个好主意。然而，如果没有语言的知识和标准，即使是那些不了解这些标准的、有良好意图的开发者，也会编写出像语言初学者一样难以理解的代码，或者更糟糕的是，像使用网络简写和模因习语的人那样，编写出粗糙和业余的代码。
- en: Once moving past the point of learning those foundational concepts (and the
    first language is the hardest to learn, for what it’s worth), a vast gulf separates
    basic competency and artful mastery.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦超越了学习那些基础概念（而且第一门语言是最难学的，这一点值得注意），基本能力和艺术性的精通之间就存在着巨大的差距。
- en: I like to think of *mastery* of a language as a corollary to comparing different
    authors writing poetry and prose. At the beginning, after learning the basics,
    your code may be at, perhaps, a children’s book level. There are sentences, to
    be sure, and a plot, but a Pulitzer Prize is likely not in the cards. However,
    with time, practice, and fixing a lot of mistakes, eventually you’ll get to the
    point where you’re writing ML solutions that have all of the refinement and nuance
    of a David Foster Wallace novel.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢将语言的**精通**视为比较不同作者写诗和散文的类比。一开始，在学会基础知识之后，你的代码可能处于儿童书水平。当然，有句子，也有情节，但普利策奖可能不会是你的目标。然而，随着时间的推移，通过练习和改正很多错误，最终你会达到这样一个水平，你编写的机器学习解决方案将具有像大卫·福斯特·华莱士小说那样的精致和细微之处。
- en: The process of getting better with coding takes time. A lot of it. It is fraught
    with so many errors and frustrations that it may seem as though you’ll never get
    very good at it. However, like anything else that you’ve learned to be good at,
    you’ll eventually find that at some point, things become easier. The basic implementations
    that you struggled with in the past will become so commonplace and easy to do
    “perfectly” that you may not realize the gains that you’ve made. It all comes
    down to learning and practicing.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 提高编码能力的过程需要时间。很多时间。它充满了如此多的错误和挫折，以至于你可能觉得你永远不会在这方面变得很好。然而，就像你学会的其他任何一项技能一样，你最终会发现，在某个时刻，事情会变得更容易。你过去在基本实现中遇到的难题现在会变得如此普遍和容易做到“完美”，以至于你可能不会意识到你所取得的进步。这一切都归结于学习和实践。
- en: Summary
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Being able to identify common problematic implementation patterns (code smells)
    can help create a more legible, easier-to-debug, and extensible ML code base.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够识别常见的有问题的实现模式（代码异味）可以帮助创建更易于阅读、更容易调试和扩展的机器学习代码库。
- en: Simplifying implementations in order to enhance legibility and reduce the cognitive
    burden of understanding how a code base functions is time well spent.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过简化实现来提高可读性并减少理解代码库功能时的认知负担是值得花费时间的。
- en: Currying data with standard structures dramatically reduces the amount of refactoring
    needed to extend a code base, as well as reducing the complexity of troubleshooting
    failures.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准结构进行数据打包可以显著减少扩展代码库所需的重构量，同时减少故障排除的复杂性。
- en: Safe applications of try/catch (exception handling) will create a more production-stable
    code base. Ensuring that only specific exceptions are caught will aid in investigating
    issues in production.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全地使用 try/catch（异常处理）将创建一个更稳定的代码库。确保只捕获特定的异常将有助于在生产环境中调查问题。
- en: Side effects and improper use of global variables can create potential deterministic
    problems in a code base. Knowing when to use them effectively and never to use
    them outside of those few required times can enhance code resiliency.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副作用和全局变量的不当使用可能会在代码库中造成潜在的确定性问题。知道何时有效地使用它们，并且永远不要在那些少数必需的时间之外使用它们，可以增强代码的弹性。
- en: Even if the logical process to execute intended behavior could lend itself to
    nested and complex recursive behavior, trying to refactor this logic into something
    more understandable should be a priority in ML code bases.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使执行预期行为的逻辑过程可能适合嵌套和复杂的递归行为，但在机器学习代码库中将这种逻辑重构为更易于理解的形式应该是一个优先事项。
