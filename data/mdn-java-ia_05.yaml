- en: Part 6\. Functional programming and future Java evolution
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6部分\. 函数式编程与Java未来的演变
- en: In the final part of this book, we draw back a little with a tutorial introduction
    to writing effective functional-style programs in Java, along with a comparison
    of Java 8 features with those of Scala.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一部分，我们通过一个关于如何编写有效的Java函数式风格程序的教程介绍，以及Java 8特性与Scala特性的比较，稍微回顾了一下。
- en: '[Chapter 18](kindle_split_033.xhtml#ch18) gives a full tutorial on functional
    programming, introduces some of its terminology, and explains how to write functional-style
    programs in Java.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第18章](kindle_split_033.xhtml#ch18)提供了一个关于函数式编程的全面教程，介绍了其中的一些术语，并解释了如何在Java中编写函数式风格的程序。'
- en: '[Chapter 19](kindle_split_034.xhtml#ch19) covers more advanced functional programming
    techniques including higher-order functions, currying, persistent data structures,
    lazy lists, and pattern matching. You can view this chapter as a mix of practical
    techniques to apply in your codebase as well as academic information that will
    make you a more knowledgeable programmer.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第19章](kindle_split_034.xhtml#ch19)涵盖了更高级的函数式编程技术，包括高阶函数、柯里化、持久数据结构、惰性列表和模式匹配。你可以将这一章视为将实用技术应用于你的代码库以及使你成为更知识渊博的程序员的信息混合体。'
- en: '[Chapter 20](kindle_split_035.xhtml#ch20) follows by discussing how Java 8
    features compare to features in the Scala language—a language that, like Java,
    is implemented on top of the JVM and that has evolved quickly to threaten some
    aspects of Java’s niche in the programming language ecosystem.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第20章](kindle_split_035.xhtml#ch20)接着讨论了Java 8特性与Scala语言特性的比较——Scala是一种像Java一样在JVM之上实现的语言，并且它迅速发展，威胁到了Java在编程语言生态系统中的某些领域。'
- en: Finally, [chapter 21](kindle_split_036.xhtml#ch21) reviews the journey of learning
    about Java 8 and the gentle push toward functional-style programming. In addition,
    we speculate on what future enhancements and great new features may be in Java’s
    pipeline beyond Java 8 and Java 9.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[第21章](kindle_split_036.xhtml#ch21)回顾了学习Java 8的历程以及向函数式编程风格的温和推动。此外，我们还推测了Java
    8和Java 9之外，Java可能有哪些未来的增强功能和新的特性。
- en: Chapter 18\. Thinking functionally
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第18章\. 函数式思考
- en: '*This chapter covers*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Why functional programming?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择函数式编程？
- en: What defines functional programming?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: Declarative programming and referential transparency
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式编程和引用透明性
- en: Guidelines for writing functional-style Java
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写函数式风格Java的指南
- en: Iteration versus recursion
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代与递归的比较
- en: You’ve seen the term *functional* quite frequently throughout this book. By
    now, you may have some ideas about what being functional entails. Is it about
    lambdas and first-class functions or about restricting your right to mutate objects?
    What do you achieve from adopting a functional style?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这本书中经常看到“函数式”这个词。到现在，你可能对函数式意味着什么有一些想法。它是关于lambda表达式和一等函数，还是关于限制你修改对象的权利？采用函数式风格你能得到什么？
- en: In this chapter, we shed light on the answers to these questions. We explain
    what functional programming is and introduce some of its terminology. First, we
    examine the concepts behind functional programming—such as side effects, immutability,
    declarative programming, and referential transparency—and then we relate these
    concepts to Java 8\. In [chapter 19](kindle_split_034.xhtml#ch19), we look more
    closely at functional programming techniques such as higher-order functions, currying,
    persistent data structures, lazy lists, pattern matching, and combinators.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们揭示了这些问题的答案。我们解释了什么是函数式编程，并介绍了一些相关术语。首先，我们检查了函数式编程背后的概念——如副作用、不可变性、声明式编程和引用透明性——然后我们将这些概念与Java
    8联系起来。在第[19章](kindle_split_034.xhtml#ch19)中，我们更仔细地研究了函数式编程技术，如高阶函数、柯里化、持久数据结构、惰性列表、模式匹配和组合子。
- en: 18.1\. Implementing and maintaining systems
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1\. 实施和维护系统
- en: To start, imagine that you’ve been asked to manage an upgrade of a large software
    system that you haven’t seen. Should you accept the job of maintaining such a
    software system? A seasoned Java contractor’s only slightly tongue-in-cheek maxim
    for deciding is “Start by searching for the keyword `synchronized`; if you find
    it, just say no (reflecting the difficulty of fixing concurrency bugs). Otherwise,
    consider the structure of the system in more detail.” We provide more detail in
    the following paragraphs. First, however, we’ll note that as you’ve seen in previous
    chapters, Java 8’s addition of streams allows you to exploit parallelism without
    worrying about locking, provided that you embrace stateless behaviors. (That is,
    functions in your stream-processing pipeline don’t interact, with one function
    reading from or writing to a variable that’s written by another.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，想象一下，你被要求管理一个你从未见过的庞大软件系统的升级。你应该接受维护这样一个软件系统的任务吗？经验丰富的Java承包商在决定时只稍微带点玩笑地说：“首先搜索关键字`synchronized`；如果你找到了，就说不（反映修复并发错误的难度）。否则，更详细地考虑系统的结构。”我们将在接下来的段落中提供更多细节。然而，首先，我们将注意到，正如你在前面的章节中看到的，Java
    8添加的流允许你在不担心锁定的情况下利用并行性，前提是你接受无状态行为。（也就是说，你的流处理管道中的函数不交互，一个函数从另一个函数写入的变量中读取或写入。）
- en: What else might you want the program to look like so that it’s easy to work
    with? You’d want it to be well structured, with an understandable class hierarchy
    reflecting the structure of the system. You have ways to estimate such a structure
    by using the software engineering metrics *coupling* (how interdependent parts
    of the system are) and *cohesion* (how related the various parts of the system
    are).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你还希望程序看起来如何，以便更容易工作？你希望它结构良好，有一个可理解的类层次结构，反映了系统的结构。你可以通过使用软件工程度量*耦合*（系统的各个部分之间的相互依赖性）和*内聚性*（系统的各个部分之间的关系）来估计这样的结构。
- en: 'But for many programmers, the key day-to-day concern is debugging during maintenance:
    some code crashed because it observed an unexpected value. But which parts of
    the program were involved in creating and modifying this value? Think of how many
    of your maintenance concerns fall into this category!^([[1](#ch18fn01)]) It turns
    out that the concepts of *no side effects* and *immutability*, which functional
    programming promotes, can help. We examine these concepts in more detail in the
    following sections.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于许多程序员来说，关键的是维护期间的调试：一些代码崩溃是因为它观察到了一个意外的值。但是，程序中的哪些部分参与了创建和修改这个值？想想看，你有多少维护问题属于这个类别！^([[1](#ch18fn01)])
    事实证明，函数式编程提倡的*无副作用*和*不可变性*的概念可以帮助。我们将在以下章节中更详细地探讨这些概念。
- en: ¹
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We recommend reading *Working Effectively with Legacy Code*, by Michael Feathers
    (Prentice Hall, 2004), for further information on this topic.
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们建议阅读Michael Feathers所著的《有效地与遗留代码工作》（Prentice Hall，2004年），以获取更多关于这个主题的信息。
- en: 18.1.1\. Shared mutable data
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.1.1\. 共享的可变数据
- en: 'Ultimately, the reason for the unexpected-variable-value problem discussed
    in the preceding section is that shared mutable data structures are read and updated
    by more than one of the methods on which your maintenance centers. Suppose that
    several classes keep a reference to a list. As a maintainer, you need to establish
    answers to the following questions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，上一节讨论的意外变量值问题的原因在于共享的可变数据结构被你的维护中心中的多个方法读取和更新。假设有多个类保留了对一个列表的引用。作为维护者，你需要回答以下问题：
- en: Who owns this list?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁拥有这个列表？
- en: What happens if one class modifies the list?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类修改了这个列表会发生什么？
- en: Do other classes expect this change?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他类是否期望这个变化？
- en: How do those classes learn about this change?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些类是如何了解这个变化的？
- en: Do the classes need to be notified of this change to satisfy all assumptions
    in this list, or should they make defensive copies for themselves?
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了满足这个列表中的所有假设，类需要被通知这个变化，还是它们应该为自己制作防御性副本？
- en: In other words, shared mutable data structures make it harder to track changes
    in different parts of your program. [Figure 18.1](#ch18fig01) illustrates this
    idea.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，共享的可变数据结构使得跟踪程序不同部分的变化变得更加困难。[图18.1](#ch18fig01)说明了这个概念。
- en: Figure 18.1\. A mutable shared across multiple classes. It’s difficult to understand
    what owns the list.
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图18.1\. 在多个类之间共享的可变数据。很难理解谁拥有这个列表。
- en: '![](Images/18fig01_alt.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/18fig01_alt.jpg)'
- en: Consider a system that doesn’t mutate any data structures. This system would
    be a dream to maintain because you wouldn’t have any bad surprises about some
    object somewhere that unexpectedly modifies a data structure. A method that modifies
    neither the state of its enclosing class nor the state of any other objects and
    returns its entire results by using `return` is called *pure* or *side-effect-free*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个不修改任何数据结构的系统。这个系统将是一个梦寐以求的维护系统，因为你不会对某个对象意外修改数据结构有任何坏惊喜。一个既不修改其封装类的状态也不修改任何其他对象的状态，并且通过使用`return`返回其整个结果的方法被称为*纯*或*无副作用*。
- en: 'What constitutes a side effect? In a nutshell, a *side effect* is an action
    that’s not totally enclosed within the function itself. Here are some examples:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是副作用？简而言之，*副作用*是在函数本身内部不完全封闭的操作。以下是一些例子：
- en: Modifying a data structure in place, including assigning to any field, apart
    from initialization inside a constructor (such as setter methods)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构造函数内部（例如setter方法）之外，就地修改数据结构，包括对任何字段的赋值
- en: Throwing an exception
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常
- en: Performing I/O operations such as writing to a file
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行I/O操作，例如写入文件
- en: Another way to look at the idea of no side effects is to consider immutable
    objects. An *immutable object* is an object that can’t change its state after
    it’s instantiated, so it can’t be affected by the actions of a function. When
    immutable objects are instantiated, they can never go into an unexpected state.
    You can share them without having to copy them, and they’re thread-safe because
    they can’t be modified.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待无副作用概念的方法是考虑不可变对象。一个*不可变对象*是在实例化后不能改变其状态的对象，因此它不会受到函数操作的影响。当不可变对象被实例化时，它们永远不会进入意外状态。你可以共享它们而不需要复制，而且它们是线程安全的，因为它们不能被修改。
- en: The idea of no side effects may appear to be a severe restriction, and you may
    doubt whether real systems can be built this way. We hope to persuade you that
    they can be built by the end of the chapter. The good news is that components
    of systems that embrace this idea can use multicore parallelism without using
    locking, because the methods can no longer interfere with one another. In addition,
    this concept is great for immediately understanding which parts of the program
    are independent.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 无副作用的概念可能看起来是一种严重的限制，你可能怀疑是否真的可以以这种方式构建系统。我们希望在本章结束时说服你，它们确实可以这样做。好消息是，接受这一想法的系统组件可以在不使用锁的情况下使用多核并行处理，因为方法不再会相互干扰。此外，这个概念对于立即理解程序的哪些部分是独立的非常有用。
- en: These ideas come from functional programming, to which we turn in the next section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些想法来自函数式编程，我们将在下一节中介绍。
- en: 18.1.2\. Declarative programming
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.1.2. 声明式编程
- en: First, we explore the idea of declarative programming, on which functional programming
    is based.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们探讨声明式编程的概念，这是函数式编程的基础。
- en: There are two ways of thinking about implementing a system by writing a program.
    One way centers on how things are done. (First do this, then update that, and
    so on.) If you want to calculate the most expensive transaction in a list, for
    example, you typically execute a sequence of commands. (Take a transaction from
    the list and compare it with the provisional most expensive transaction; if it’s
    more expensive, it becomes the provisional most expensive; repeat with the next
    transaction in the list, and so on.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写程序来实现系统的两种思考方式。一种集中在如何做事上。（首先做这个，然后更新那个，等等。）例如，如果你想计算列表中最昂贵的交易，你通常会执行一系列命令。（从一个列表中取出一个交易并与暂定的最昂贵交易进行比较；如果它更贵，它就变成了暂定的最昂贵交易；然后与列表中的下一个交易重复此过程，等等。）
- en: 'This “how” style of programming is an excellent match for classic object-oriented
    programming (sometimes called *imperative programming*), because it has instructions
    that mimic the low-level vocabulary of a computer (such as assignment, conditional
    branching, and loops), as shown in this code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“如何”风格的编程非常适合经典面向对象编程（有时称为*命令式编程*），因为它有指令模仿计算机的低级词汇（如赋值、条件分支和循环），如以下代码所示：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The other way centers on what’s to be done. You saw in [chapters 4](kindle_split_015.xhtml#ch04)
    and [5](kindle_split_016.xhtml#ch05) that by using the Streams API, you could
    specify this query as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法集中在要做什么上。你在第[4章](kindle_split_015.xhtml#ch04)和第[5章](kindle_split_016.xhtml#ch05)中看到，通过使用Streams
    API，你可以这样指定这个查询：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The fine detail of how this query is implemented is left to the library. We
    refer to this idea as *internal iteration*. The great advantage is that your query
    reads like the problem statement, and for that reason, it’s immediately clear,
    compared with trying to understand what a sequence of commands does.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询如何实现的详细细节留给库来处理。我们将这个想法称为*内部迭代*。它的巨大优势是查询的阅读方式就像问题陈述一样，因此与试图理解一系列命令的作用相比，它立即变得清晰。
- en: This “what” style is often called *declarative programming*. You provide rules
    saying what you want, and you expect the system to decide how to achieve that
    goal. This type of programming is great because it reads closer to the problem
    statement.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“是什么”风格通常被称为*声明式编程*。你提供规则说明你想要什么，并期望系统决定如何实现这个目标。这种类型的编程很棒，因为它更接近于问题陈述。
- en: 18.1.3\. Why functional programming?
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.1.3. 为什么是函数式编程？
- en: Functional programming exemplifies this idea of declarative programming (say
    what you want using expressions that don’t interact, and for which the system
    can choose the implementation) and side-effect-free computation, explained earlier
    in this chapter. These two ideas can help you implement and maintain systems more
    easily.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程体现了这种声明式编程的思想（使用不交互的表达式来表达你想要的内容，系统可以选择实现方式），以及本章前面提到的无副作用计算。这两个想法可以帮助你更轻松地实现和维护系统。
- en: Note that certain language features, such as composing operations and passing
    behaviors (which we presented in [chapter 3](kindle_split_013.xhtml#ch03) by using
    lambda expressions), are required to read and write code in a natural way with
    a declarative style. Using streams, you can chain several operations to express
    a complicated query. These features characterize functional programming languages.
    We look at these features more carefully under the guise of combinators in [chapter
    19](kindle_split_034.xhtml#ch19).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，某些语言特性，如操作组合和传递行为（我们通过第3章中的lambda表达式来展示），是使用声明式风格自然地读写代码所必需的。使用流，你可以将多个操作链接起来以表达复杂的查询。这些特性是函数式编程语言的特征。我们在第19章（通过组合器的视角）更仔细地研究这些特性。
- en: To make the discussion tangible and connect it with the new features in Java
    8, in the next section we concretely define the idea of functional programming
    and its representation in Java. We’d like to impart the fact that by using functional-programming
    style, you can write serious programs without relying on side effects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使讨论具体化并将其与Java 8的新特性联系起来，在下一节中我们将具体定义函数式编程的概念及其在Java中的表示。我们想传达这样一个事实：通过使用函数式编程风格，你可以编写严肃的程序而不依赖于副作用。
- en: 18.2\. What’s functional programming?
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2. 什么是函数式编程？
- en: The oversimplistic answer to “What is functional programming?” is “Programming
    with functions.” What’s a function?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“什么是函数式编程？”这个问题的过于简化的回答是“用函数进行编程。”什么是函数？
- en: It’s easy to imagine a method taking an `int` and a `double` as arguments and
    producing a `double`—and also having the side effect of counting the number of
    times it has been called by updating a mutable variable, as illustrated in [figure
    18.2](#ch18fig02).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个方法接受一个`int`和一个`double`作为参数并产生一个`double`——并且还产生副作用，比如通过更新一个可变变量来计数它被调用的次数，如图18.2所示。
- en: Figure 18.2\. A function with side effects
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图18.2. 带有副作用的函数
- en: '![](Images/18fig02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图18.2](Images/18fig02.jpg)'
- en: 'In the context of functional programming, however, a *function* corresponds
    to a mathematical function: it takes zero or more arguments, returns one or more
    results, and has no side effects. You can see a function as being a black box
    that takes some inputs and produces some outputs, as illustrated in [figure 18.3](#ch18fig03).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在函数式编程的上下文中，一个*函数*对应于数学函数：它接受零个或多个参数，返回一个或多个结果，并且没有副作用。你可以将函数视为一个黑盒，它接受一些输入并产生一些输出，如图18.3所示。
- en: Figure 18.3\. A function with no side effects
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图18.3. 没有副作用的函数
- en: '![](Images/18fig03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图18.3](Images/18fig03.jpg)'
- en: The distinction between this sort of function and the methods you see in programming
    languages such as Java is central. (The idea that mathematical functions such
    as `log` or `sin` might have such side effects in unthinkable.) In particular,
    mathematical functions always return the same results when they’re called repeatedly
    with the same arguments. This characterization rules out methods such as `Random.nextInt`,
    and we further discuss this concept of referential transparency in [section 18.2.2](#ch18lev2sec5).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种函数与你在像Java这样的编程语言中看到的方法之间的区别是核心的。（数学函数如`log`或`sin`可能会有这样的副作用的想法是不可想象的。）特别是，数学函数在用相同的参数重复调用时总是返回相同的结果。这种特征排除了`Random.nextInt`这样的方法，我们将在[第18.2.2节](#ch18lev2sec5)进一步讨论这个概念，即引用透明性。
- en: 'When we say *functional*, we mean like mathematics, with no side effects. Now
    a programming subtlety appears. Do we mean either: Is every function built only
    with functions and mathematical ideas such as `if-then-else`? Or might a function
    do nonfunctional things internally as long as it doesn’t expose any of these side
    effects to the rest of the system? In other words, if programmers perform a side
    effect that can’t be observed by callers, does that side effect exist? The callers
    don’t need to know or care, because it can’t affect them.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说*函数式*时，我们指的是像数学一样，没有副作用。现在出现了一个编程的微妙之处。我们是说：每个函数是否只由函数和数学思想，如`if-then-else`构建？或者一个函数在内部做非函数式的事情，只要它不将这些副作用暴露给系统的其余部分？换句话说，如果程序员执行了一个调用者无法观察到的副作用，那么这个副作用存在吗？调用者不需要知道或关心，因为它无法影响他们。
- en: To emphasize the difference, we refer to the former as pure functional programming
    and the latter as functional-style programming.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调这种差异，我们将前者称为纯函数式编程，后者称为函数式风格编程。
- en: 18.2.1\. Functional-style Java
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.2.1. 函数式Java
- en: In practice, you can’t completely program in pure functional style in Java.
    Java’s I/O model consists of side-effecting methods, for example. (Calling `Scanner.nextLine`
    has the side effect of consuming a line from a file, so calling it twice typically
    produces different results.) Nonetheless, it’s possible to write core components
    of your system as though they were purely functional. In Java, you’re going to
    write functional-style programs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你无法在Java中完全以纯函数式风格编程。例如，Java的I/O模型由副作用方法组成。（调用`Scanner.nextLine`会产生副作用，即从文件中消耗一行，因此连续调用两次通常会产生不同的结果。）尽管如此，你仍然可以将系统的核心组件编写成好像它们是纯函数式的。在Java中，你将编写函数式风格的程序。
- en: First, there’s a further subtlety about no one seeing your side effects and,
    hence, in the meaning of *functional*. Suppose that a function or method has no
    side effects except for incrementing a field after entry and decrementing it before
    exit. From the point of view of a program that consists of a single thread, this
    method has no visible side effects and can be regarded as functional style. On
    the other hand, if another thread could inspect the field—or could call the method
    concurrently—the method wouldn’t be functional. You could hide this issue by wrapping
    the body of this method with a lock, which would enable you to argue that the
    method is functional. But in doing so, you’d lose the ability to execute two calls
    to the method in parallel by using two cores on your multicore processor. Your
    side effect may not be visible to a program, but it’s visible to the programmer
    in terms of slower execution.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个关于没有人看到你的副作用，因此，在*功能*意义上的进一步微妙之处。假设一个函数或方法除了在进入后增加一个字段，在退出前减少它之外，没有副作用。从由单个线程组成的程序的角度来看，这种方法没有可见的副作用，可以被视为函数式风格。另一方面，如果另一个线程可以检查该字段——或者可以并发调用该方法——则该方法不是函数式的。你可以通过将此方法的主体用锁包裹来隐藏这个问题，这样你就可以争论说这个方法是函数式的。但这样做，你将失去在多核处理器上使用两个核心并行执行该方法两次调用的能力。你的副作用可能对程序不可见，但从程序员的角度来看，它会导致执行速度变慢。
- en: Our guideline is that to be regarded as functional style, a function or method
    can mutate only local variables. In addition, the objects that it references should
    be immutable—that is, all fields are `final`, and all fields of reference type
    refer transitively to other immutable objects. Later, you may permit updates to
    fields of objects that are freshly created in the method, so they aren’t visible
    from elsewhere and aren’t saved to affect the result of a subsequent call.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的指导方针是，要被视为函数式风格，一个函数或方法只能修改局部变量。此外，它引用的对象应该是不可变的——也就是说，所有字段都是`final`的，所有引用类型的字段都递归地引用其他不可变对象。稍后，你可以允许更新在方法中新鲜创建的对象的字段，这样它们就不会从其他地方可见，也不会保存以影响后续调用的结果。
- en: Our guideline is incomplete, however. There’s an additional requirement to being
    functional, that a function or method *shouldn’t throw any exceptions*. A justification
    is that throwing an exception would mean that a result is being signaled other
    than via the function returning a value; see the black-box model of [figure 18.2](#ch18fig02).
    There’s scope for debate here, with some authors arguing that uncaught exceptions
    representing fatal errors are okay and that it’s the act of catching an exception
    that represents nonfunctional control flow. Such use of exceptions still breaks
    the simple “pass arguments, return result” metaphor pictured in the black-box
    model, however, leading to a third arrow representing an exception, as illustrated
    in [figure 18.4](#ch18fig04).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的指导方针并不完整。要成为函数式，还有一个额外的要求，即函数或方法**不应该抛出任何异常**。一个合理的解释是，抛出异常意味着除了通过函数返回值之外，还在通过其他方式传递结果；参见[图18.2](#ch18fig02)中的黑盒模型。在这里有争议的空间，一些作者认为未捕获的异常表示致命错误是可以接受的，而捕获异常的行为才代表非函数式控制流。然而，这种对异常的使用仍然打破了黑盒模型中简单的“传递参数，返回结果”隐喻，导致出现一个表示异常的第三个箭头，如[图18.4](#ch18fig04)所示。
- en: Figure 18.4\. A function throwing an exception
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图18.4\. 抛出异常的函数
- en: '![](Images/18fig04_alt.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/18fig04_alt.jpg)'
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Functions and partial functions**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数和部分函数**'
- en: In mathematics, a function is required to give exactly one result for each possible
    argument value. But many common mathematical operations are what should properly
    be called partial functions. That is, for some or most input values, they give
    exactly one result, but for other input values, they’re undefined and don’t give
    a result at all. An example is division when the second operand is zero or `sqrt`
    when its argument is negative. We often model these situations in Java by throwing
    an exception.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，一个函数必须对每个可能的参数值给出确切的一个结果。但许多常见的数学运算实际上应该被称为部分函数。也就是说，对于某些或大多数输入值，它们会给出确切的一个结果，但对于其他输入值，它们是未定义的，根本不会给出任何结果。例如，当第二个操作数是零时进行除法，或者当其参数为负数时进行平方根运算。我们通常在Java中通过抛出异常来模拟这些情况。
- en: '|  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: How might you express functions such as division without using exceptions? Use
    types like `Optional<T>`. Instead of having the signature “`double sqrt(double)`
    but may raise an exception,” `sqrt` would have the signature `Optional<Double>
    sqrt(double).` Either it returns a value that represents success, or it indicates
    in its return value that it couldn’t perform the requested operation. And yes,
    doing so does mean that the caller needs to check whether each method call may
    result in an empty `Optional`. This may sound like a huge deal, but pragmatically,
    given our guidance on functional-style programming versus pure functional programming,
    you may choose to use exceptions locally but not expose them via large-scale interfaces,
    thereby gaining the advantages of functional style without the risk of code bloat.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何在不使用异常的情况下表达像除法这样的函数？使用像`Optional<T>`这样的类型。而不是有“`double sqrt(double)`但可能抛出异常”这样的签名，`sqrt`将具有签名`Optional<Double>
    sqrt(double)`。它要么返回一个表示成功的值，要么在其返回值中表明它无法执行请求的操作。是的，这样做确实意味着调用者需要检查每个方法调用是否可能导致空的`Optional`。这可能听起来像是一个大问题，但根据我们对函数式编程与纯函数式编程的指导，你可以选择在本地使用异常，但不通过大规模接口暴露它们，从而在不增加代码膨胀风险的情况下获得函数式风格的优势。
- en: To be regarded as functional, your function or method should call only those
    side-effecting library functions for which you can hide nonfunctional behavior
    (that is, ensuring that any mutations they make in data structures are hidden
    from your caller, perhaps by copying first and by catching any exceptions). In
    [section 18.2.4](#ch18lev2sec7), you hide the use of a side-effecting library
    function `List.add` inside a method `insertAll` by copying the list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要被视为功能性的，你的函数或方法应该只调用那些你可以隐藏非功能行为的副作用库函数（即，确保它们对数据结构所做的任何修改都不会被调用者看到，可能通过先复制并捕获任何异常来实现）。在[第18.2.4节](#ch18lev2sec7)中，你通过复制列表的方式，在`insertAll`方法内部隐藏了副作用库函数`List.add`的使用。
- en: You can often mark these prescriptions by using comments or declaring a method
    with a marker annotation—and match the restrictions you placed on functions passed
    to parallel stream-processing operations such as `Stream.map` in [chapters 4](kindle_split_015.xhtml#ch04)–[7](kindle_split_018.xhtml#ch07).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常可以通过使用注释或声明带有标记注解的方法来标记这些规定，并且匹配你在[第4章](kindle_split_015.xhtml#ch04)到[第7章](kindle_split_018.xhtml#ch07)中为传递给并行流处理操作（如`Stream.map`）的函数所施加的限制。
- en: Finally, for pragmatic reasons, you may find it convenient for functional-style
    code to be able to output debugging information to some form of log file. This
    code can’t be strictly described as functional, but in practice, you retain most
    of the benefits of functional-style programming.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，出于实用主义的原因，你可能发现对于函数式风格的代码来说，能够将调试信息输出到某种形式的日志文件中是很方便的。这段代码不能严格地描述为函数式，但在实践中，你保留了函数式编程的大部分好处。
- en: 18.2.2\. Referential transparency
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.2.2\. 引用透明性
- en: The restrictions on no visible side effects (no mutating structure visible to
    callers, no I/O, no exceptions) encode the concept of referential transparency.
    A function is referentially transparent if it always returns the same result value
    when it’s called with the same argument value. The method `String.replace`, for
    example, is referentially transparent because `"raoul".replace('r', 'R')` always
    produces the same result (`replace` returns a new `String` with all lowercase
    `r`s replaced with uppercase `R`s) rather than updating its `this` object, so
    it can be considered to be a function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对无可见副作用（对调用者不可见的结构修改、无I/O、无异常）的限制编码了引用透明性的概念。一个函数是引用透明的，如果它在用相同的参数值调用时总是返回相同的值。例如，`String.replace`方法就是引用透明的，因为`"raoul".replace('r',
    'R')`总是产生相同的结果（`replace`返回一个新`String`，其中所有的`r`都被大写的`R`替换），而不是更新它的`this`对象，因此它可以被认为是一个函数。
- en: Put another way, a function consistently produces the same result given the
    same input, no matter where and when it’s invoked. It also explains why `Random.nextInt`
    isn’t regarded as being functional. In Java, using a `Scanner` object to get the
    input from a user’s keyboard violates referential transparency because calling
    the method `nextLine` may produce a different result at each call. But adding
    two `final int` variables always produces the same result because the content
    of the variables can never change.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，一个函数在相同的输入下始终产生相同的结果，无论它在何时何地被调用。这也解释了为什么`Random.nextInt`不被视为函数式。在Java中，使用`Scanner`对象从用户的键盘获取输入违反了引用透明性，因为调用`nextLine`方法可能每次调用都会产生不同的结果。但添加两个`final
    int`变量总是产生相同的结果，因为变量的内容永远不会改变。
- en: Referential transparency is a great property for program understanding. It also
    encompasses save-instead-of-recompute optimization for expensive or long-lived
    operations, a process that goes by the name *memoization* or *caching*. Although
    important, this topic is a slight tangent here, so we discuss it in [chapter 19](kindle_split_034.xhtml#ch19).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 引用透明性是程序理解的一个很好的属性。它还包括对昂贵或长期操作进行保存而不是重新计算优化的概念，这个过程被称为*记忆化*或*缓存*。尽管这个话题很重要，但在这里它是一个小的旁白，所以我们将在[第19章](kindle_split_034.xhtml#ch19)中讨论它。
- en: Java has one slight complication with regard referential transparency. Suppose
    that you make two calls to a method that returns a `List`. The two calls may return
    references to distinct lists in memory but containing the same elements. If these
    lists are to be seen as mutable object-oriented values (and therefore nonidentical),
    the method isn’t referentially transparent. If you plan to use these lists as
    pure (immutable) values, it makes sense to see the values as being equal, so the
    function is referentially transparent. In general, in functional-style code, you
    choose to regard such functions as being referentially transparent.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Java在引用透明性方面有一个轻微的复杂性。假设你调用一个返回`List`的方法两次。这两次调用可能返回内存中不同列表的引用，但包含相同的元素。如果这些列表被视为可变的面向对象值（因此非相同），则该方法不是引用透明的。如果你计划将这些列表用作纯（不可变）值，那么将这些值视为相等是有意义的，因此函数是引用透明的。一般来说，在函数式风格的代码中，你选择将这些函数视为引用透明的。
- en: In the next section, we explore whether to mutate from a wider perspective.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将从更广泛的视角探讨是否进行突变。
- en: 18.2.3\. Object-oriented vs. functional-style programming
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.2.3\. 面向对象与函数式编程风格
- en: We start by contrasting functional-style programming with (extreme) classical
    object-oriented programming before observing that Java 8 sees these styles as
    being mere extremes on the object-oriented spectrum. As a Java programmer, without
    consciously thinking about it, you almost certainly use some aspects of functional-style
    programming and some aspects of what we’ll call extreme object-oriented programming.
    As we remarked in [chapter 1](kindle_split_011.xhtml#ch01), changes in hardware
    (such as multicore) and programmer expectation (such as database-like queries
    to manipulate data) are pushing Java software-engineering styles more to the functional
    end of this spectrum, and one of the aims of this book is to help you adapt to
    the changing climate.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将函数式编程与（极端的）经典面向对象编程进行对比，然后观察到Java 8将这些风格视为面向对象光谱上的极端。作为一名Java程序员，即使没有有意识地思考，你也几乎肯定使用了函数式编程的一些方面和我们称之为极端面向对象编程的一些方面。正如我们在第1章（kindle_split_011.xhtml#ch01）中提到的，硬件（如多核）和程序员期望（如数据库查询来操作数据）的变化正在推动Java软件工程风格更多地转向函数式的一端，本书的一个目标就是帮助你适应这种变化的环境。
- en: 'At one end of the spectrum is the extreme object-oriented view: everything
    is an object, and programs operate by updating fields and calling methods that
    update their associated object. At the other end of the spectrum lies the referentially
    transparent functional-programming style of no (visible) mutation. In practice,
    Java programmers have always mixed these styles. You might traverse a data structure
    by using an `Iterator` containing mutable internal state but use it to calculate,
    say, the sum of values in the data structure in a functional-style manner. (In
    Java, as discussed earlier, this process can include mutating local variables.)
    One of the aims of this chapter and [chapter 19](kindle_split_034.xhtml#ch19)
    is to discuss programming techniques and introduce features from functional programming
    to enable you to write programs that are more modular and more suitable for multicore
    processors. Think of these ideas as being additional weapons in your programming
    armory.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在光谱的一端是极端的面向对象观点：一切皆对象，程序通过更新字段和调用更新相关对象的方法来操作。在光谱的另一端是引用透明的函数式编程风格，没有（可见的）突变。在实践中，Java程序员总是混合这些风格。你可能通过使用包含可变内部状态的`Iterator`遍历数据结构，但以函数式风格计算，例如，数据结构中值的总和。（在Java中，如前所述，此过程可能包括更新局部变量。）本章和第19章（kindle_split_034.xhtml#ch19）的一个目标就是讨论编程技术，并引入函数式编程的特性，以便你能够编写更模块化且更适合多核处理器的程序。将这些想法视为你编程武器库中的额外武器。
- en: 18.2.4\. Functional style in practice
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.2.4\. 实践中的函数式风格
- en: 'To start, solve a programming exercise given to beginning students that exemplifies
    functional style: given a `List<Integer>` value, such as {1, 4, 9}, construct
    a `List<List <Integer>>` value whose members are all the subsets of {1, 4, 9},
    in any order. The subsets of {1, 4, 9} are {1, 4, 9}, {1, 4}, {1, 9}, {4, 9},
    {1}, {4}, {9}, and {}.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，解决一个给初学者的编程练习，以体现函数式风格：给定一个`List<Integer>`值，例如{1, 4, 9}，构造一个`List<List<Integer>>`值，其成员是{1,
    4, 9}的所有子集，顺序不限。{1, 4, 9}的子集包括{1, 4, 9}，{1, 4}，{1, 9}，{4, 9}，{1}，{4}，{9}和{}。
- en: There are eight subsets, including the empty subset, written {}. Each subset
    is represented as type `List<Integer>`, which means that the answer is of type
    `List<List <Integer>>`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有八个子集，包括空子集，写作{}。每个子集都表示为`List<Integer>`类型，这意味着答案是`List<List<Integer>>`类型。
- en: 'Students often have problems thinking how to start and need prompting^([[2](#ch18fn02)])
    with the remark “The subsets of {1, 4, 9} either contain 1 or do not.” The ones
    that don’t are subsets of {4, 9}, and the ones that do can be obtained by taking
    the subsets of {4, 9} and inserting 1 into each of them. There’s one subtlety
    though: we must remember that the empty set has exactly one subset—itself. This
    understanding gives you an easy, natural, top-down, functional-programming-style
    encoding in Java as follows:^([[3](#ch18fn03)])'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 学生们经常在思考如何开始时遇到问题，需要通过提示^([[2](#ch18fn02)])来帮助他们，即“{1, 4, 9}的子集要么包含1，要么不包含。”那些不包含1的子集是{4,
    9}的子集，而包含1的子集可以通过取{4, 9}的子集并将1插入到每个子集中来获得。不过有一个细微之处：我们必须记住空集恰好只有一个子集——它自己。这种理解让你在Java中以简单、自然、自上而下的函数式编程风格进行编码，如下所示:^([[3](#ch18fn03)])
- en: ²
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Troublesome (bright!) students occasionally point out a neat coding trick involving
    binary representation of numbers. (The Java solution code corresponds to 000,001,010,011,100,101,110,111.)
    We tell such students to calculate instead the list of all permutations of a list;
    for the example {1, 4, 9}, there are six.
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时，麻烦（但聪明！）的学生会指出一个涉及数字二进制表示的巧妙编码技巧。（Java解决方案代码对应于000,001,010,011,100,101,110,111。）我们告诉这样的学生计算列表的所有排列；对于示例{1,
    4, 9}，有六个。
- en: ³
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For concreteness, the code we give here uses `List<Integer>`, but you can replace
    it in the method definitions with generic `List<T>`; then you could apply the
    updated `subsets` method to `List<String>` as well as `List<Integer>.`
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了具体化，我们在这里给出的代码使用`List<Integer>`，但你可以将其在方法定义中替换为泛型`List<T>`；然后你可以将更新的`subsets`方法应用于`List<String>`以及`List<Integer>`。
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* If the input list is empty, it has one subset: the empty list itself.**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果输入列表为空，它只有一个子集：空列表本身。**'
- en: '***2* Otherwise take out one element, fst, and find all subsets of the rest
    to give subAns; subAns forms half the answer.**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 否则取出一个元素，fst，并找到其余所有子集以给出subAns；subAns形成答案的一半。**'
- en: '***3* The other half of the answer, subAns2, consists of all the lists in subAns
    but adjusted by prefixing each of these element lists with fst.**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 答案的一半，subAns2，由subAns中的所有列表组成，但每个元素列表都通过在前面添加fst来调整。**'
- en: '***4* Then concatenate the two subanswers.**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 然后将两个子答案连接起来。**'
- en: The solution program produces {{}, {9}, {4}, {4, 9}, {1}, {1, 9}, {1, 4}, {1,
    4, 9}} when given {1, 4, 9} as input. Do try it when you’ve defined the two missing
    methods.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当以{1, 4, 9}作为输入时，解决方案程序产生{{}, {9}, {4}, {4, 9}, {1}, {1, 9}, {1, 4}, {1, 4,
    9}}。当你定义了这两个缺失的方法时，请尝试一下。
- en: To review, you’ve assumed that the missing methods `insertAll` and `concat`
    are themselves functional and deduced that your function `subsets` is also functional,
    because no operation in it mutates any existing structure. (If you’re familiar
    with mathematics, you’ll recognize this argument as being by induction.)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了复习，你假设缺失的方法`insertAll`和`concat`本身是函数式的，并推断出你的函数`subsets`也是函数式的，因为其中没有操作会改变任何现有结构。（如果你熟悉数学，你会认出这个论点是通过归纳得出的。）
- en: 'Now look at defining `insertAll`. Here’s the first danger point. Suppose that
    you defined `insertAll` so that it mutated its arguments, perhaps by updating
    all the elements of `subAns` to contain `fst`. Then the program would incorrectly
    cause `subAns` to be modified in the same way as `subAns2`, resulting in an answer
    that mysteriously contained eight copies of {1,4,9}. Instead, define `insertAll`
    functionally as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看定义`insertAll`。这里有一个危险点。假设你定义了`insertAll`使其改变其参数，可能通过更新`subAns`的所有元素以包含`fst`。那么程序将错误地导致`subAns`以与`subAns2`相同的方式被修改，从而导致一个神秘地包含八个{1,4,9}副本的答案。相反，将`insertAll`函数式地定义为以下内容：
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Copy the list so you can add to it. You wouldn’t copy the lower-level
    structure even if it were mutable. (Integers aren’t mutuable.)**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 复制列表以便可以添加到它。即使它是可变的，你也不会复制底层结构。（整数是不可变的。）**'
- en: 'Note that you’re creating a new `List` that contains all the elements of `subAns`.
    You take advantage of the fact that an `Integer` object is immutable; otherwise,
    you’d have to clone each element too. The focus caused by thinking of methods
    like `insertAll` as being functional gives you a natural place to put all this
    carefully copied code: inside `insertAll` rather in its callers.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你正在创建一个新的 `List`，它包含 `subAns` 的所有元素。你利用了 `Integer` 对象不可变的事实；否则，你将不得不克隆每个元素。将
    `insertAll` 等方法视为函数式的方法引起的关注，为你提供了一个自然的位置来放置所有这些精心复制的代码：在 `insertAll` 内部，而不是在其调用者中。
- en: 'Finally, you need to define the `concat` method. In this case, the solution
    is simple, but we beg you not to use it; we show it only so that you can compare
    the different styles:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要定义 `concat` 方法。在这种情况下，解决方案很简单，但我们恳求你不要使用它；我们只展示它，以便你可以比较不同的风格：
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead, we suggest that you write this code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们建议你编写以下代码：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Why? The second version of `concat` is a pure function. The function may be
    using mutation (adding elements to the list `r`) internally, but it returns a
    result based on its arguments and modifies neither of them. By contrast, the first
    version relies on the fact that after the call `concat(subAns, subAns2)`, no one
    refers to the value of `subAns` again. For our definition of `subsets`, this situation
    is the case, so surely using the cheaper version of `concat` is better. The answer
    depends on how you value your time. Compare the time you’d spend later searching
    for obscure bugs compared with the additional cost of making a copy.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？`concat` 的第二个版本是一个纯函数。函数可能在其内部使用变异（向列表 `r` 添加元素），但它基于其参数返回结果，并且不修改任何一个参数。相比之下，第一个版本依赖于在调用
    `concat(subAns, subAns2)` 之后，没有人再次引用 `subAns` 的值。对于我们的 `subsets` 定义，这种情况是成立的，因此当然使用更便宜的
    `concat` 版本更好。答案取决于你如何评估你的时间。比较你后来花费在搜索难以捉摸的错误上的时间与制作副本的额外成本。
- en: No matter how well you comment that the impure `concat` is “to be used only
    when the first argument can be arbitrarily overwritten, and intended to be used
    only in the `subsets` method, and any change to `subsets` must be reviewed in
    the light of this comment,” somebody sometime will find it useful in some piece
    of code where it apparently seems to work. Your future nightmare debugging problem
    has been born. We revisit this issue in [chapter 19](kindle_split_034.xhtml#ch19).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何注释不纯的 `concat` 只能“在第一个参数可以被任意覆盖时使用，并且仅在 `subsets` 方法中使用，并且对 `subsets` 的任何更改都必须根据此注释进行审查”，总有人会在某个代码片段中找到它有用，那里它似乎可以工作。你的未来噩梦调试问题已经诞生。我们将在第
    [19 章](kindle_split_034.xhtml#ch19) 中重新审视这个问题。
- en: 'Takeaway point: thinking of programming problems in terms of function-style
    methods that are characterized only by their input arguments and output results
    (what to do) is often more productive than thinking about how to do it and what
    to mutate too early in the design cycle.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 吸收要点：在设计周期早期，以函数式方法来思考编程问题，这些方法仅以它们的输入参数和输出结果（做什么）为特征，通常比思考如何做以及过早地考虑变异更有效。
- en: In the next section, we discuss recursion in detail.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细讨论递归。
- en: 18.3\. Recursion vs. iteration
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3. 递归与迭代
- en: '*Recursion* is a technique promoted in functional programming to let you think
    in terms of what-to-do style. Pure functional programming languages typically
    don’t include iterative constructs such as `while` and `for` loops. Such constructs
    are often hidden invitations to use mutation. The condition in a `while` loop
    needs to be updated, for example; otherwise, the loop would execute zero times
    or an infinite number of times. In many cases, however, loops are fine. We’ve
    argued that for functional style, you’re allowed mutation if no one can see you
    doing it, so it’s acceptable to mutate local variables. When you use the `for-each`
    loop in Java, `for(Apple apple : apples) { }`, it decodes into this `Iterator`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归* 是在函数式编程中推广的一种技术，让你能够以“做什么”的方式思考。纯函数式编程语言通常不包含迭代结构，如 `while` 和 `for` 循环。这些结构通常隐藏着使用变异的邀请。例如，`while`
    循环中的条件需要更新；否则，循环将执行零次或无限次。然而，在许多情况下，循环是可行的。我们曾主张，对于函数式风格，如果你没有人看到你在做，那么你可以进行变异，因此修改局部变量是可以接受的。当你使用
    Java 中的 `for-each` 循环 `for(Apple apple : apples) { }` 时，它解码为这个 `Iterator`：'
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This translation isn’t a problem because the mutations (changing the state
    of the `Iterator` with the `next` method and assigning to the `apple` variable
    inside the `while` body) aren’t visible to the caller of the method where the
    mutations happen. But when you use a `for-each` loop, such as a search algorithm,
    for example, what follows is problematic because the loop body is updating a data
    structure that’s shared with the caller:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种翻译没有问题，因为突变（使用 `next` 方法改变 `Iterator` 的状态，以及在 `while` 体内部将值赋给 `apple` 变量）对发生突变的方法的调用者不可见。但是，当你使用
    `for-each` 循环，例如搜索算法时，以下情况是有问题的，因为循环体正在更新与调用者共享的数据结构：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Indeed, the body of the loop has a side effect that can’t be dismissed as functional
    style: it mutates the state of the `stats` object, which is shared with other
    parts of the program.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，循环体有一个不能被忽视的副作用，即它不能作为函数式风格来忽略：它改变了与程序其他部分共享的 `stats` 对象的状态。
- en: For this reason, pure functional programming languages such as Haskell omit
    such side-effecting operations. How are you to write programs? The theoretical
    answer is that every program can be rewritten to prevent iteration by using recursion
    instead, which doesn’t require mutability. Using recursion lets you get rid of
    iteration variables that are updated step by step. A classic school problem is
    calculating the factorial function (for positive arguments) in an iterative way
    and in a recursive way (assume that the input is > 0), as shown in the following
    two listings.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，像 Haskell 这样的纯函数式编程语言省略了这样的副作用操作。你该如何编写程序呢？理论上的答案是，每个程序都可以通过使用递归而不是迭代来重写，这样就不需要可变性。使用递归可以让您摆脱逐步更新的迭代变量。一个经典的学校问题是计算阶乘函数（对于正数参数）的迭代方式和递归方式（假设输入大于0），如下面的两个列表所示。
- en: Listing 18.1\. Iterative factorial
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.1\. 迭代阶乘
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Listing 18.2\. Recursive factorial
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.2\. 递归阶乘
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first listing demonstrates a standard loop-based form: the variables `r`
    and `i` are updated at each iteration. The second listing shows a recursive definition
    (the function calls itself) in a more mathematically familiar form. In Java, recursive
    forms typically are less efficient, as we discuss immediately after the next example.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个列表演示了一种基于标准循环的形式：变量 `r` 和 `i` 在每次迭代中更新。第二个列表以更数学化的形式展示了递归定义（函数调用自身）。在 Java
    中，递归形式通常效率较低，正如我们在下一个示例之后立即讨论的那样。
- en: If you’ve read the earlier chapters of this book, however, you know that Java
    8 streams provide an even simpler declarative way of defining factorial, as shown
    in the following listing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您已经阅读了本书的前几章，您知道 Java 8 流提供了一种更简单的声明性方式来定义阶乘，如下面的列表所示。
- en: Listing 18.3\. Stream factorial
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.3\. 流阶乘
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we’ll turn to efficiency. As Java users, beware of functional-programming
    zealots who tell you that you should always use recursion instead of iteration.
    In general, making a recursive function call is much more expensive than issuing
    the single machine-level branch instruction needed to iterate. Every time the
    `factorialRecursive` function is called, a new stack frame is created on the call
    stack to hold the state of each function call (the multiplication it needs to
    do) until the recursion is done. Your recursive definition of factorial takes
    memory proportional to its input. For this reason, if you run `factorialRecursive`
    with a large input, you’re likely to receive a `StackOverflowError`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向效率问题。作为 Java 用户，当功能编程狂热者告诉你应该总是使用递归而不是迭代时，要小心。一般来说，进行递归函数调用比发出迭代所需的单个机器级分支指令要昂贵得多。每次调用
    `factorialRecursive` 函数时，都会在调用栈上创建一个新的栈帧来保存每个函数调用的状态（它需要进行的乘法）直到递归完成。您对阶乘的递归定义需要与输入成比例的内存。因此，如果您用大输入运行
    `factorialRecursive`，您很可能会收到 `StackOverflowError`：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Is recursion useless? Of course not! Functional languages provide an answer
    to this problem: *tail-call optimization*. The basic idea is that you can write
    a recursive definition of factorial in which the recursive call is the last thing
    that happens in the function (or the call is in a tail position). This different
    form of recursion style can be optimized to run fast. The next listing provides
    a tail-recursive definition of factorial.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 递归真的没有用吗？当然不是！函数式语言为这个问题提供了一个答案：*尾调用优化*。基本思想是，你可以编写一个阶乘的递归定义，其中递归调用是函数中最后发生的事情（或者调用在尾位置）。这种不同的递归风格可以被优化以快速运行。下一个列表提供了一个尾递归定义的阶乘。
- en: Listing 18.4\. Tail-recursive factorial
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 18.4\. 尾递归阶乘
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The function `factorialHelper` is tail-recursive because the recursive call
    is the last thing that happens in the function. By contrast, in the earlier definition
    of `factorialRecursive`, the last thing was a multiplication of `n` and the result
    of a recursive call.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `factorialHelper` 是尾递归的，因为递归调用是该函数中最后发生的事情。相比之下，在 `factorialRecursive` 的早期定义中，最后发生的事情是
    `n` 和递归调用结果的乘法。
- en: This form of recursion is useful because instead of storing each intermediate
    result of the recursion in separate stack frames, the compiler can decide to reuse
    a single stack frame. Indeed, in the definition of `factorialHelper`, the intermediate
    results (the partial results of the factorial) are passed directly as arguments
    to the function. There’s no need to keep track of the intermediate result of each
    recursive call on a separate stack frame; it’s accessible directly as the first
    argument of `factorialHelper`. [Figures 18.5](#ch18fig05) and [18.6](#ch18fig06)
    illustrate the difference between the recursive and tail-recursive definitions
    of factorial.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种递归形式很有用，因为它不需要在单独的栈帧中存储递归的每个中间结果，编译器可以决定重用单个栈帧。实际上，在 `factorialHelper` 的定义中，中间结果（阶乘的部分结果）直接作为参数传递给函数。不需要在单独的栈帧上跟踪每个递归调用的中间结果；它可以直接作为
    `factorialHelper` 的第一个参数访问。[图 18.5](#ch18fig05) 和 [18.6](#ch18fig06) 展示了阶乘递归和尾递归定义之间的差异。
- en: Figure 18.5\. Recursive definition of factorial, which requires several stack
    frames
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 18.5\. 阶乘的递归定义，需要几个栈帧
- en: '![](Images/18fig05_alt.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/18fig05_alt.jpg)'
- en: Figure 18.6\. Tail-recursive definition of factorial, which can reuse a single
    stack frame
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 18.6\. 阶乘的尾递归定义，可以重用单个栈帧
- en: '![](Images/18fig06_alt.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/18fig06_alt.jpg)'
- en: The bad news is that Java doesn’t support this kind of optimization. But adopting
    tail recursion may be a better practice than classic recursion because it opens
    the way to eventual compiler optimization. Many modern JVM languages such as Scala,
    Groovy, and Kotlin can optimize those uses of recursion, which are equivalent
    to iteration (and execute at the same speed). As a result, pure-functional adherents
    can have their purity cake and eat it efficiently too.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 坏消息是 Java 不支持这种优化。但采用尾递归可能比经典递归是一种更好的实践，因为它为最终编译器优化开辟了道路。许多现代 JVM 语言，如 Scala、Groovy
    和 Kotlin，可以优化这些递归的使用，这些递归与迭代等效（并且以相同的速度执行）。因此，纯函数式编程的拥护者也可以在保持纯度的同时高效地执行。
- en: The guidance in writing Java 8 is that you can often replace iteration with
    streams to avoid mutation. In addition, you can replace iteration with recursion
    when recursion allows you write an algorithm in a more concise, side-effect-free
    way. Indeed, recursion can make examples easier to read, write, and understand
    (as in the subsets example shown earlier in this chapter), and programmer efficiency
    is often more important than small differences in execution time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 编写指南中提到，你通常可以用流来替换迭代以避免突变。此外，当递归允许你以更简洁、无副作用的方式编写算法时，你可以用递归替换迭代。确实，递归可以使示例更容易阅读、编写和理解（如本章前面所示的部分示例），而程序员效率通常比执行时间的小差异更重要。
- en: In this section, we discussed functional-style programming with the idea of
    a method being functional; everything we said would have applied to the first
    version of Java. In [chapter 19](kindle_split_034.xhtml#ch19), we look at the
    amazing and powerful possibilities offered by the introduction of first-class
    functions in Java 8.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了具有方法功能性的函数式编程；我们所说的所有内容都适用于 Java 的第一个版本。在第 [19](kindle_split_034.xhtml#ch19)
    章中，我们将探讨 Java 8 中引入一等函数带来的惊人强大可能性。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Reducing shared mutable data structures can help you maintain and debug your
    programs in the long term.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少共享可变数据结构可以帮助你在长期内维护和调试你的程序。
- en: Functional-style programming promotes side-effect-free methods and declarative
    programming.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程风格提倡无副作用的方法和声明式编程。
- en: Function-style methods are characterized only by their input arguments and their
    output result.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式方法的特点仅在于它们的输入参数和输出结果。
- en: A function is referentially transparent if it always returns the same result
    value when called with the same argument value. Iterative constructs such as `while`
    loops can be replaced by recursion.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个函数在用相同的参数值调用时总是返回相同的值，则该函数是引用透明的。例如 `while` 循环这样的迭代结构可以用递归替换。
- en: Tail recursion may be a better practice than classic recursion in Java because
    it opens the way to potential compiler optimization.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾递归可能在Java中比经典递归是一种更好的实践，因为它为潜在的编译器优化打开了道路。
- en: Chapter 19\. Functional programming techniques
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第19章\. 函数式编程技术
- en: '*This chapter covers*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: First-class citizens, higher-order functions, currying, and partial application
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一等公民、高阶函数、柯里化和部分应用
- en: Persistent data structures
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久数据结构
- en: Lazy evaluation and lazy lists as generalizing Java streams
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性评估和惰性列表作为泛化Java流
- en: Pattern matching and how to simulate it in Java
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配及其在Java中的模拟
- en: Referential transparency and caching
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指称透明性和缓存
- en: In [chapter 18](kindle_split_033.xhtml#ch18), you saw how to think functionally;
    thinking in terms of side-effect-free methods can help you write more maintainable
    code. In this chapter, we introduce more advanced functional programming techniques.
    You can view this chapter as being a mix of practical techniques to apply in your
    code base, as well as academic information that will make you a more knowledgeable
    programmer. We discuss higher-order functions, currying, persistent data structures,
    lazy lists, pattern matching, caching with referential transparency, and combinators.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第18章](kindle_split_033.xhtml#ch18)中，你看到了如何以函数式的方式思考；以无副作用的方法来思考可以帮助你编写更易于维护的代码。在本章中，我们介绍了更高级的函数式编程技术。你可以将本章视为将实际可应用于代码库的技术与使你成为更有知识程序员的信息相结合。我们讨论了高阶函数、柯里化、持久数据结构、惰性列表、模式匹配、具有指称透明性的缓存和组合子。
- en: 19.1\. Functions everywhere
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1\. 到处都是函数
- en: 'In [chapter 18](kindle_split_033.xhtml#ch18) we used the phrase *functional-style
    programming* to mean that the behavior of functions and methods should be like
    that of mathematical-style functions, with no side effects. Functional-language
    programmers often use the phrase with more generality to mean that functions may
    be used like other values: passed as arguments, returned as results, and stored
    in data structures. Functions that may be used like other values are referred
    to as *first-class functions*. First-class functions are what Java 8 added over
    previous versions of Java: you may use any method as a function value, using the
    `::` operator to create a method reference, and lambda expressions (such as `(int
    x) -> x + 1`) to express function values directly. In Java 8 it’s perfectly valid^([[1](#ch19fn01)])
    to store the method `Integer.parseInt` in a variable by using a method reference
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第18章](kindle_split_033.xhtml#ch18)中，我们使用“函数式编程风格”这个短语来表示函数和方法的行为应该像数学风格的函数一样，没有副作用。函数式语言程序员经常更广泛地使用这个短语，表示函数可以被用作其他值：作为参数传递，作为结果返回，并存储在数据结构中。可以像其他值一样使用的函数被称为*一等函数*。一等函数是Java
    8相对于之前版本Java新增的特性：你可以将任何方法作为函数值使用，使用`::`操作符创建方法引用，并使用lambda表达式（如`(int x) -> x
    + 1`）直接表达函数值。在Java 8中，使用方法引用如下将`Integer.parseInt`方法存储在变量中是完全有效的^([[1](#ch19fn01)])：
- en: ¹
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `Integer::parseInt` is the only method you plan to store in variable `strToInt`,
    you might want to make `strToInt` have type `ToIntFunction<String>` to save boxing.
    You don’t do so here because using such Java primitive applications can get in
    the way of seeing what’s happening, even if those applications improve efficiency
    for primitive types.
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你计划将`Integer::parseInt`方法作为唯一要存储在变量`strToInt`中的方法，你可能想让`strToInt`具有`ToIntFunction<String>`类型以节省装箱。在这里你没有这样做，因为使用这样的Java原始应用可能会妨碍你看到正在发生的事情，即使这些应用提高了原始类型的效率。
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 19.1.1\. Higher-order functions
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 19.1.1\. 高阶函数
- en: 'So far, you’ve mainly used the fact that function values are first-class only
    to pass them to Java 8 stream-processing operations (as in [chapters 4](kindle_split_015.xhtml#ch04)–[7](kindle_split_018.xhtml#ch07))
    and to achieve the similar effect of behavior parameterization when you passed
    `Apple::isGreen-Apple` as a function value to `filterApples` in [chapters 1](kindle_split_011.xhtml#ch01)
    and [2](kindle_split_012.xhtml#ch02). Another interesting example was using the
    static method `Comparator.comparing`, which takes a function as a parameter and
    returns another function (a `Comparator`), as illustrated in the following code
    and [figure 19.1](#ch19fig01):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你主要使用函数值是一等公民的事实，将它们传递给Java 8流处理操作（如[第4章](kindle_split_015.xhtml#ch04)至[第7章](kindle_split_018.xhtml#ch07)），并在将
    `Apple::isGreen-Apple` 作为函数值传递给 `filterApples` 时实现类似的行为参数化效果（如[第1章](kindle_split_011.xhtml#ch01)和[第2章](kindle_split_012.xhtml#ch02)所示）。另一个有趣的例子是使用静态方法
    `Comparator.comparing`，它接受一个函数作为参数并返回另一个函数（一个 `Comparator`），如下面的代码和[图19.1](#ch19fig01)所示：
- en: Figure 19.1\. `comparing` takes a function as parameter and returns another
    function.
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图19.1\. `comparing` 接受一个函数作为参数并返回另一个函数。
- en: '![](Images/19fig01.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/19fig01.jpg)'
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You did something similar when you composed functions in [chapter 3](kindle_split_013.xhtml#ch03)
    to create a pipeline of operations:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在[第3章](kindle_split_013.xhtml#ch03)中组合函数以创建操作流水线时，你做了类似的事情：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Functions (such as `Comparator.comparing`) that can do at least one of the
    following are called *higher-order functions* within the functional programming
    community:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程社区中，能够至少执行以下操作之一的函数（如 `Comparator.comparing`）被称为 *高级函数*：
- en: Take one or more functions as a parameter
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个或多个函数作为参数
- en: Return a function as a result
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个函数作为结果
- en: This characterization directly relates to Java 8 functions because they can
    not only be passed as arguments, but also returned as results, assigned to local
    variables, or even inserted into structures. A pocket-calculator program might
    have a `Map<String, Function<Double, Double>>` that maps the `String "sin"` to
    `Function<Double, Double>` to hold the method reference `Math::sin`. You did something
    similar when you learned about the factory design pattern in [chapter 8](kindle_split_020.xhtml#ch08).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这种描述直接关联到Java 8函数，因为它们不仅可以作为参数传递，还可以作为结果返回，分配给局部变量，甚至可以插入到结构中。一个计算器程序可能有一个 `Map<String,
    Function<Double, Double>>`，将 `String "sin"` 映射到 `Function<Double, Double>` 以持有方法引用
    `Math::sin`。你在[第8章](kindle_split_020.xhtml#ch08)学习工厂设计模式时也做了类似的事情。
- en: Readers who liked the calculus example at the end of [chapter 3](kindle_split_013.xhtml#ch03)
    can regard the type of differentiation as being
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢在[第3章](kindle_split_013.xhtml#ch03)结尾处计算示例的读者可以将微分类型视为
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: because it takes a function as an argument (such as `(Double x) -> x * x`) and
    returns a function as a result (in this example, `(Double x) -> 2 * x`). We’ve
    written this code as a function type (the leftmost `Function`) to explicitly affirm
    the fact that you could pass this differentiating function to another function.
    But it’s good to recall that the type for differentiating and the signature
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它接受一个函数作为参数（例如 `(Double x) -> x * x`）并返回一个函数作为结果（在这个例子中，`(Double x) -> 2 *
    x`）。我们将此代码写成函数类型（最左边的 `Function`）以明确确认你可以将这个微分函数传递给另一个函数。但最好记住，微分函数的类型和签名
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: say the same thing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 说的是同一件事。
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Side effects and higher-order functions**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**副作用和高级函数**'
- en: We noted in [chapter 7](kindle_split_018.xhtml#ch07) that functions passed to
    stream operations generally are side-effect-free, and we noted the problems that
    arise otherwise (such as incorrect results and even unpredictable results due
    to race conditions you hadn’t thought of). This principle also applies in general
    when you use higher-order functions. When you’re writing a higher-order function
    or method, you don’t know in advance what arguments will be passed to it and,
    if the arguments have side effects, what these side effects might do. It becomes
    far too complicated to reason about what your code does if it uses functions passed
    as arguments that make unpredictable changes in the state of your program; such
    functions might even interfere with your code in some hard-to-debug way. It’s
    a good design principle to document what side effects you’re willing to accept
    from functions passed as parameters. None is best of all!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第7章](kindle_split_018.xhtml#ch07) 中提到，传递给流操作的函数通常是无副作用的，并指出了否则可能出现的问题（例如，由于你没有考虑到竞态条件而导致的不正确结果甚至不可预测的结果）。这个原则也适用于你使用高阶函数的一般情况。当你编写一个高阶函数或方法时，你事先不知道将传递给它什么参数，如果参数有副作用，这些副作用可能会做什么。如果你的代码使用了作为参数传递的函数，这些函数会在程序状态中引起不可预测的变化，那么推理你的代码做什么会变得非常复杂；这些函数甚至可能以难以调试的方式干扰你的代码。记录你愿意从作为参数传递的函数中接受的副作用是一个好的设计原则。没有副作用是最好的！
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'In the next section, we turn to currying: a technique that can help you modularize
    functions and reuse code.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将转向柯里化：一种可以帮助你模块化函数和重用代码的技术。
- en: 19.1.2\. Currying
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 19.1.2\. 柯里化
- en: Before we give you the theoretical definition of currying, we’ll present an
    example. Applications almost always need to be internationalized, so converting
    from one set of units to another set is a problem that comes up repeatedly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们给出柯里化的理论定义之前，我们将举一个例子。应用几乎总是需要国际化，因此从一个单位集转换到另一个单位集是一个反复出现的问题。
- en: 'Unit conversion always involves a conversion factor and, from time to time,
    a baseline adjustment factor. The formula to convert Celsius to Fahrenheit, for
    example, is `CtoF(x) = x*9/5 + 32`. The basic pattern of all unit conversion is
    as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 单位转换总是涉及一个转换系数，有时还涉及基线调整系数。例如，将摄氏度转换为华氏度的公式是 `CtoF(x) = x*9/5 + 32`。所有单位转换的基本模式如下：
- en: Multiply by the conversion factor.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 乘以转换系数。
- en: Adjust the baseline if relevant.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果相关，调整基线。
- en: 'You can express this pattern with the following general method:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用以下通用方法表达这个模式：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `x` is the quantity you want to convert, `f` is the conversion factor,
    and `b` is the baseline. But this method is a bit too general. Typically, you
    require a lot of conversions between the same pair of units, such as kilometers
    to miles. You could call the `converter` method with three arguments on each occasion,
    but supplying the factor and baseline each time would be tedious, and you might
    accidentally mistype them.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`x` 是你想要转换的量，`f` 是转换系数，而 `b` 是基线。但这种方法有点过于通用。通常，你需要进行大量相同单位对之间的转换，例如千米到英里。你可以在每次调用时用三个参数调用
    `converter` 方法，但每次都提供系数和基线会显得很繁琐，而且你可能会不小心打错字。
- en: You could write a new method for each application, but doing so would miss the
    reuse of the underlying logic.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为每个应用编写一个新的方法，但这样做会错过底层逻辑的重用。
- en: 'Here’s an easy way to benefit from the existing logic while tailoring the converter
    for particular applications. You can define a factory that manufactures one-argument
    conversion functions to exemplify the idea of currying:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个利用现有逻辑的同时为特定应用定制转换器的好方法。你可以定义一个工厂，制造单参数转换函数来举例说明柯里化的概念：
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now all you have to do is pass `curriedConverter` the conversion factor and
    baseline (`f` and `b`), and it obligingly returns a function (of `x`) to do what
    you asked for. Then you can use the factory to produce any converter you require,
    as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需要传递 `curriedConverter` 转换系数和基线（`f` 和 `b`），它会乐意地返回一个函数（`x` 的函数）来完成你所要求的事情。然后你可以使用工厂来生产你需要的任何转换器，如下所示：
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Because `DoubleUnaryOperator` defines a method `applyAsDouble`, you can use
    your converters as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `DoubleUnaryOperator` 定义了一个 `applyAsDouble` 方法，你可以这样使用你的转换器：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As a result, your code is more flexible, and it reuses the existing conversion
    logic!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你的代码更加灵活，并且它重用了现有的转换逻辑！
- en: Reflect on what you’re doing here. Instead of passing all the arguments `x`,
    `f`, and `b` all at once to the `converter` method, you ask only for the arguments
    `f` and `b` and return another function—which, when given an argument `x`, returns
    `x * f + b`. This two-stage process enables you to reuse the conversion logic
    and create different functions with different conversion factors.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 反思你在这里所做的事情。你并不是一次性将所有参数`x`、`f`和`b`传递给`converter`方法，而是只请求参数`f`和`b`，并返回另一个函数——当给定一个参数`x`时，它返回`x
    * f + b`。这个两阶段过程使你能够重用转换逻辑并创建具有不同转换因子的不同函数。
- en: '|  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Formal definition of currying**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**柯里化（Currying）的正式定义**'
- en: '*Currying^([[a](#ch19fnsb01)])* is a technique in which a function `f` of two
    arguments (such as `x` and `y`) is instead viewed as a function `g` of one argument
    that returns a function also of one argument. The value returned by the latter
    function is the same as the value of the original function—that is, `f(x,y) =
    (g(x))(y)`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*柯里化^([[a](#ch19fnsb01)])* 是一种技术，其中两个参数的函数 `f`（例如 `x` 和 `y`）被视为一个参数的函数 `g`，它返回另一个参数的函数。后者的函数值与原始函数的值相同——即
    `f(x,y) = (g(x))(y)`。'
- en: ^a
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The word *currying* is unconnected to Indian food; the term is named after the
    logician Haskell Brooks Curry, who popularized the technique. He attributed it
    to Moses Ilyich Schönfinkel, however. Should we refer to currying as *schönfinkeling*
    instead?
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “柯里化”这个词与印度食物无关；这个术语是以逻辑学家 Haskell Brooks Curry 命名的，他使这项技术流行起来。然而，他将其归功于 Moses
    Ilyich Schönfinkel。我们是否应该将柯里化称为 *schönfinkeling*？
- en: This definition generalizes, of course. You can curry a six-argument function
    to first take arguments numbered 2, 4, and 6, which returns a function taking
    argument 5, which returns a function taking the remaining arguments, 1 and 3.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这种定义是通用的。你可以将一个六参数函数 curry 成首先接受编号为2、4和6的参数，它返回一个接受参数5的函数，该函数返回一个接受剩余参数1和3的函数。
- en: When some arguments (but fewer than the full complement of arguments) have been
    passed, the function is *partially applied*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递了一些参数（但少于所有参数）时，函数是*部分应用*的。
- en: '|  |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'In the next section, we turn to another aspect of functional-style programming:
    data structures. Is it possible to program with data structures if you’re forbidden
    to modify them?'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将转向函数式编程风格的另一个方面：数据结构。如果禁止修改数据结构，是否还能用它们来编程？
- en: 19.2\. Persistent data structures
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2. 持久化数据结构
- en: Data structures used in functional-style programs have various names, such as
    functional data structures and immutable data structures, but perhaps the most
    common is persistent data structures. (Unfortunately, this terminology clashes
    with the notion of *persistent* in databases, meaning “outliving one run of the
    program.”)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程风格程序中使用的数据结构有各种名称，例如函数式数据结构和不可变数据结构，但最常见的是持久化数据结构。（不幸的是，这个术语与数据库中“持久化”的概念相冲突，意味着“超出一次程序运行的生命周期。”）
- en: The first thing to notice is that a functional-style method isn’t allowed to
    update any global data structure or any structure passed as a parameter. Why?
    Because calling it twice is likely to produce different answers, violating referential
    transparency and the ability to understand the method as a simple mapping from
    arguments to results.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要注意的是，函数式方法不允许更新任何全局数据结构或任何作为参数传递的结构。为什么？因为调用它两次很可能会产生不同的答案，违反了引用透明性和将方法理解为一个简单的从参数到结果的映射的能力。
- en: 19.2.1\. Destructive updates vs. functional
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 19.2.1. 摧毁性更新与函数式
- en: 'Consider the problems that can arise. Suppose that you represent train journeys
    from A to B as a mutable `TrainJourney` class (a simple implementation of a singly
    linked list), with an `int` field modeling some detail of the journey, such as
    the price of the current leg of the journey. Journeys that require changing trains
    have several linked `TrainJourney` objects via the `onward` field; a direct train
    or the final leg of a journey has `onward` being `null`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑可能出现的问题。假设你将A到B的火车旅程表示为一个可变的`TrainJourney`类（单链表的简单实现），其中`int`字段表示旅程的一些细节，例如旅程当前阶段的票价。需要换乘的旅程通过`onward`字段具有几个链接的`TrainJourney`对象；直达火车或旅程的最后一程，`onward`为`null`：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now suppose that you have separate `TrainJourney` objects representing a journey
    from X to Y and from Y to Z. You may want to create one journey that links the
    two `TrainJourney` objects (that is, X to Y to Z).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你有代表从X到Y和从Y到Z的旅程的单独的`TrainJourney`对象。你可能想创建一个连接这两个`TrainJourney`对象（即X到Y到Z）的旅程。
- en: 'Here is a simple traditional imperative method to `link` these train journeys:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的传统命令式方法来`链接`这些火车旅程：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method works by finding the last leg in the `TrainJourney` for `a` and
    replacing the `null` marking the end of `a`’s list with list `b`. (You need a
    special case if `a` has no elements.)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法通过找到`TrainJourney`中`a`的最后一部分，并用列表`b`替换`a`列表末尾的`null`标记来实现。如果`a`没有元素，则需要一个特殊情况。
- en: 'Here’s the problem: suppose that a variable `firstJourney` contains the route
    from X to Y and that a variable `secondJourney` contains the route from Y to Z.
    If you call `link(firstJourney, secondJourney)`, this code destructively updates
    `firstJourney` to also contain `secondJourney`, so in addition to the single user
    who requests a trip from X to Z seeing the combined journey as intended, the journey
    from X to Y has been updated destructively. Indeed, the `firstJourney` variable
    is no longer a route from X to Y, but one from X to Z, which breaks code that
    depends on `firstJourney`’s not being modified! Suppose that `firstJourney` represented
    the early-morning London-to-Brussels train, which all subsequent users trying
    to get to Brussels will be surprised to see requires an onward leg, perhaps to
    Cologne. We’ve all fought battles with such bugs concerning how visible a change
    in a data structure should be.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是：假设一个变量`firstJourney`包含从X到Y的路线，而另一个变量`secondJourney`包含从Y到Z的路线。如果您调用`link(firstJourney,
    secondJourney)`，此代码会破坏性地更新`firstJourney`以包含`secondJourney`，因此除了请求从X到Z的单一用户看到预期的合并旅程外，从X到Y的旅程也被破坏性地更新了。实际上，`firstJourney`变量不再是X到Y的路线，而是一条从X到Z的路线，这破坏了依赖于`firstJourney`未修改的代码！假设`firstJourney`代表早上的伦敦到布鲁塞尔的火车，所有试图前往布鲁塞尔的后续用户都会惊讶地看到需要一段后续旅程，可能到科隆。我们都与这类有关数据结构变化可见性的bug作过斗争。
- en: 'The functional-style approach to this problem is to ban such side-effecting
    methods. If you need a data structure to represent the result of a computation,
    you should make a new one, not mutate an existing data structure, as you’ve done
    previously. Doing so is often a best practice in standard object-oriented programming,
    too. A common objection to the functional approach is that it causes excess copying,
    and the programmer says, “I’ll remember” or “I’ll document” the side effects.
    But such optimism is a trap for maintenance programmers who have to deal with
    your code later. Thus, the functional-style solution is as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，函数式风格的解决方案是禁止这种有副作用的函数。如果您需要一个数据结构来表示计算的结果，您应该创建一个新的数据结构，而不是修改现有的数据结构，就像您之前所做的那样。这样做在标准面向对象编程中通常也是一个最佳实践。对函数式方法的一个常见反对意见是它会导致过多的复制，程序员会说，“我会记住”或“我会记录”副作用。但这种乐观是一种陷阱，对于后来必须处理您代码的维护程序员来说。因此，函数式风格的解决方案如下：
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code is clearly functional-style (uses no mutation, even locally) and doesn’t
    modify any existing data structures. Note, however, that the code doesn’t create
    a new `TrainJourney`. If `a` is a sequence of *n* elements and `b` is a sequence
    of *m* elements, the code returns a sequence of *n*+*m* elements, in which the
    first *n* elements are new nodes and the final *m* elements share with `TrainJourney
    b`. Note that users are required not to mutate the result of `append` because
    by doing so, they may corrupt the trains passed as sequence `b`. [Figures 19.2](#ch19fig02)
    and [19.3](#ch19fig03) illustrate the difference between the destructive `append`
    and the functional-style `append`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码明显是函数式风格的（不使用任何变异，即使是局部性的）并且不会修改任何现有的数据结构。然而，请注意，代码并没有创建一个新的`TrainJourney`。如果`a`是一个包含*n*个元素的序列，而`b`是一个包含*m*个元素的序列，则代码返回一个包含*n*+*m*个元素的序列，其中前*n*个元素是新的节点，最后的*m*个元素与`TrainJourney
    b`共享。请注意，用户需要确保不修改`append`的结果，因为这样做可能会破坏作为序列`b`传入的火车。![图19.2](#ch19fig02)和![19.3](#ch19fig03)说明了破坏性`append`和函数式`append`之间的区别。
- en: Figure 19.2\. The data structure is destructively updated.
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图19.2\. 数据结构被破坏性更新。
- en: '![](Images/19fig02_alt.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/19fig02_alt.jpg)'
- en: Figure 19.3\. Functional style with no modifications to the data structure
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图19.3\. 函数式风格，没有修改数据结构
- en: '![](Images/19fig03_alt.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/19fig03_alt.jpg)'
- en: 19.2.2\. Another example with Trees
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 19.2.2\. 树的另一个例子
- en: 'Before leaving this topic, consider another data structure: a binary search
    tree that might be used to implement a similar interface to a `HashMap`. The idea
    is that a `Tree` contains a `String` representing a key and an `int` representing
    its value, perhaps names and ages:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开这个主题之前，考虑另一种数据结构：一个二叉搜索树，可能用于实现类似于 `HashMap` 的接口。想法是 `Tree` 包含一个表示键的 `String`
    和一个表示其值的 `int`，可能是姓名和年龄：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You want to use the binary search tree to look up `String` values to produce
    an `int`. Now consider how you might update the value associated with a given
    key (assuming for simplicity that the key is already present in the tree):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您想使用二叉搜索树来查找 `String` 值以生成一个 `int`。现在考虑您如何更新与给定键关联的值（为了简单起见，假设键已经存在于树中）：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Adding a new node is trickier. The easiest way is to make the method `update`
    return the `Tree` that has been traversed (unchanged unless you had to add a node).
    Now this code is slightly clumsier because the user needs to remember that `update`
    tries to update the tree in place, returning the same tree as passed. But if the
    original tree were empty, a new node is returned as a result:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新节点比较复杂。最简单的方法是让方法 `update` 返回已遍历的 `Tree`（除非您需要添加节点，否则不会改变）。现在这段代码稍微有些笨拙，因为用户需要记住
    `update` 尝试原地更新树，并返回与传入相同的树。但如果原始树为空，则返回一个新节点：
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that both versions of `update` mutate the existing `Tree`, meaning that
    all users of the `map` stored in the tree see the mutation.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`update` 的两个版本都会修改现有的 `Tree`，这意味着所有使用存储在树中的 `map` 的用户都会看到这种修改。
- en: 19.2.3\. Using a functional approach
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 19.2.3. 使用函数式方法
- en: 'How might you program such tree updates functionally? You need to create a
    new node for the new key-value pair. You also need to create new nodes on the
    path from the root of the tree to the new node, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何以函数式方式编程这样的树更新？您需要为新的键值对创建一个新节点。您还需要在树的根节点到新节点路径上创建新节点，如下所示：
- en: '[PRE28]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In general, this code isn’t expensive. If the tree is of depth *d* and reasonably
    well balanced, it can have around 2*^d* entries, so you re-create a small fraction
    of it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这段代码并不昂贵。如果树深度为 *d* 且平衡得合理，它可以有大约 2^d 个条目，所以您只需重新创建其中的一小部分。
- en: We’ve written this code as a single conditional expression instead of using
    `if-then-else` to emphasize the idea that the body is a single expression with
    no side effects. But you may prefer to write an equivalent `if-then-else` chain,
    each containing a return.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这段代码写成单个条件表达式，而不是使用 `if-then-else`，以强调主体是一个没有副作用的单个表达式。但您可能更喜欢编写等效的 `if-then-else`
    链，每个都包含一个返回。
- en: What’s the difference between `update` and `fupdate`? We noted previously that
    the method `update` assumes that every user wants to share the data structure
    and see updates caused by any part of the program. Therefore, it’s vital (but
    often overlooked) in nonfunctional code that whenever you add some form of structured
    value to a tree, you copy it, because someone may assume later that he can update
    it. By contrast, `fupdate` is purely functional; it creates a new `Tree` as a
    result but shares as much as it can with its argument. [Figure 19.4](#ch19fig04)
    illustrates this idea. You have a tree consisting of nodes that store a name and
    an age of a person. Calling `fupdate` doesn’t modify the existing tree; it creates
    new nodes “living at the side of” the tree without harming the existing data structure.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 和 `fupdate` 之间的区别是什么？我们之前提到，`update` 方法假设每个用户都想要共享数据结构并看到程序任何部分引起的更新。因此，在非函数式代码中，每当您向树添加某种结构化值时，您必须复制它，因为有人可能后来会假设他可以更新它。相比之下，`fupdate`
    完全是函数式的；它创建一个新的 `Tree` 作为结果，但尽可能多地与它的参数共享。[图 19.4](#ch19fig04) 阐述了这一概念。您有一个由存储人的姓名和年龄的节点组成的树。调用
    `fupdate` 不会修改现有的树；它创建新的节点“位于树的一侧”，而不会损害现有的数据结构。'
- en: Figure 19.4\. No existing data structure was harmed during the making of this
    update to `Tree`.
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 19.4. 在制作此 `Tree` 更新过程中，没有现有的数据结构受到损害。
- en: '![](Images/19fig04_alt.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/19fig04_alt.jpg)'
- en: 'Such functional data structures are often called *persistent*—their values
    persist and are isolated from changes happening elsewhere—so as a programmer,
    you’re sure that `fupdate` won’t mutate the data structures passed as its arguments.
    There’s one proviso: the other side of the treaty requires all users of persistent
    data structures to follow the do-not-mutate requirement. If not, a programmer
    who disregards this proviso might mutate the result of `fupdate` (by changing
    Emily’s 20, for example). Then this mutation would be visible as an (almost certainly
    unwanted) unexpected and delayed change to the data structure passed as argument
    to `fupdate`!'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这种函数式数据结构通常被称为**持久性**的——它们的值持续存在，并且与其他地方发生的变化隔离——因此作为程序员，你可以确信`fupdate`不会修改作为其参数传递的数据结构。有一个前提条件：条约的另一方要求所有持久数据结构的用户都必须遵守不修改的要求。如果不这样做，忽视这个前提条件的程序员可能会修改`fupdate`的结果（例如，通过更改Emily的20）。然后这种修改就会作为（几乎肯定是不希望看到的）意外和延迟的变化出现在传递给`fupdate`作为参数的数据结构中！
- en: Viewed in these terms, `fupdate` can be more efficient. The “no mutation of
    existing structure” rule allows structures that differ only slightly (such as
    the `Tree` seen by user A and the modified version seen by user B) to share storage
    for common parts of their structure. You can get the compiler to help enforce
    this rule by declaring fields `key`, `val`, `left`, and `right` of class `Tree`
    to be `final`. But remember that `final` protects only a field, not the object
    pointed to, which may need its own fields to be `final` to protect it, and so
    on.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，`fupdate`可以更高效。不允许修改现有结构的规则允许结构只略有不同（例如，用户A看到的`Tree`和用户B看到的修改版本）在它们的结构的公共部分共享存储。你可以通过将类`Tree`的字段`key`、`val`、`left`和`right`声明为`final`来让编译器帮助强制执行此规则。但请记住，`final`只保护字段，而不是指向的对象，该对象可能需要其自己的字段是`final`以保护它，依此类推。
- en: 'You might say, “I *want* updates to the tree to be seen by some users (but
    admittedly not by some others).” You have two choices. One choice is the classical
    Java solution: be careful when updating something to check whether you need to
    copy it first. The other choice is the functional-style solution: you logically
    make a new data structure whenever you do an update (so that nothing is ever mutated)
    and arrange to pass the correct version of the data structure to users as appropriate.
    This idea could be enforced through an API. If certain clients of the data structure
    need to have updates visible, they should go through an API that returns the latest
    version. Clients who don’t want updates visible (such as for long-running statistical
    analysis) use whatever copy they retrieve, knowing that it can’t be mutated from
    under them.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说，“我希望树的结构更新能被某些用户看到（但诚实地讲，不是所有用户）。”你有两个选择。一个选择是经典的Java解决方案：在更新某些内容时要小心，检查是否需要先复制它。另一个选择是函数式风格的解决方案：你每次更新时逻辑上都会创建一个新的数据结构（这样就不会有任何东西被修改），并安排将适当的数据结构版本传递给用户。这个想法可以通过API来强制执行。如果某些数据结构的客户端需要看到更新，他们应该通过返回最新版本的API进行操作。不想看到更新的客户端（例如，用于长时间运行的统计分析）使用他们检索到的任何副本，知道它不能在他们不知情的情况下被修改。
- en: This technique is like updating a file on a CD-R, which allows a file to be
    written only once by burning with a laser. Multiple versions of the file are stored
    on the CD (smart CD-authoring software might even share common parts of multiple
    versions), and you pass the appropriate block address of the start of the file
    (or a filename encoding the version within its name) to select which version you
    want to use. In Java, things are rather better than on a CD, in that old versions
    of the data structure that can no longer be used are garbage-collected.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术就像在CD-R上更新文件一样，它允许通过激光烧录只写入一次文件。文件的多个版本存储在CD上（智能CD刻录软件甚至可能共享多个版本的公共部分），你通过传递文件起始位置的适当块地址（或包含版本信息的文件名编码）来选择你想要使用的版本。在Java中，情况比CD要好得多，因为旧的数据结构版本不再被使用时会被垃圾回收。
- en: 19.3\. Lazy evaluation with streams
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3. 使用流进行懒计算
- en: You saw in previous chapters that streams are great ways to process a collection
    of data. But for various reasons, including efficient implementation, the Java
    8 designers added streams to Java in a rather specific way. One limitation is
    that you can’t define a stream recursively because a stream can be consumed only
    once. In the following sections, we show you how this situation can be problematic.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你在前面的章节中看到，流是处理数据集合的绝佳方式。但是出于各种原因，包括高效的实现，Java 8的设计者以一种相当具体的方式将流添加到Java中。一个限制是，你不能递归地定义一个流，因为流只能被消费一次。在接下来的几节中，我们将向你展示这种情况可能存在的问题。
- en: 19.3.1\. Self-defining stream
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 19.3.1\. 自定义流
- en: 'Revisit the example from [chapter 6](kindle_split_017.xhtml#ch06) of generating
    prime numbers to understand this idea of a recursive stream. In that chapter,
    you saw that (perhaps as part of a `MyMath-Utils` class), you can compute a stream
    of prime numbers as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾第6章（kindle_split_017.xhtml#ch06）中生成素数的例子，以理解递归流的这个概念。在第6章中，你看到（可能作为`MyMath-Utils`类的一部分），你可以按照以下方式计算素数流：
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: But this solution is somewhat awkward. You have to iterate through every number
    every time to see whether it can be divided by a candidate number. (In fact, you
    need only test numbers that have been already classified as prime.)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个解决方案有些尴尬。你必须每次迭代通过每个数字，看看它是否可以被候选数字整除。（实际上，你只需要测试已经被分类为素数的数字。）
- en: 'Ideally, the stream should filter out numbers that are divisible by the prime
    that the stream is producing on the go. Here’s how this process might work:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，流应该过滤掉那些可以被流正在生成的素数整除的数字。这个过程可能如下所示：
- en: You need a stream of numbers from which you’ll select prime numbers.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要一个数字流，从该流中你可以选择素数。
- en: From that stream, take the first number (the head of the stream), which will
    be a prime number. (In the initial step, this number is 2.)
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那个流中取出第一个数字（流的头部），它将是一个素数。（在初始步骤中，这个数字是2。）
- en: Filter all the numbers that are divisible by that number from the tail of the
    stream.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从流的尾部过滤掉所有可以被那个数字整除的数字。
- en: The resulting tail is the new stream of numbers that you can use to find prime
    numbers. Essentially, you go back to step 1, so this algorithm is recursive.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果的尾部是新的数字流，你可以用它来找到素数。本质上，你回到了步骤1，因此这个算法是递归的。
- en: Note that this algorithm is poor for a few reasons,^([[2](#ch19fn02)]) but it’s
    simple to reason about algorithms for the purpose of working with streams. In
    the following sections, you try to write this algorithm by using the Streams API.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个算法有几个原因不好，^([[2](#ch19fn02)]) 但对于处理流的目的来说，算法是简单的，易于推理。在接下来的几节中，你将尝试使用Streams
    API编写这个算法。
- en: ²
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can find more information about why the algorithm is poor at [www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf](http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf).
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在[www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf](http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf)找到更多关于为什么该算法较差的信息。
- en: 'Step 1: Get a stream of numbers'
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第1步：获取一个数字流
- en: 'You can get an infinite stream of numbers starting from 2 by using the method
    `IntStream.iterate` (which we described in [chapter 5](kindle_split_016.xhtml#ch05))
    as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`IntStream.iterate`方法（我们在第5章中描述过）从2开始获取一个无限数字流，如下所示：
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Step 2: Take the head'
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第2步：取出头部
- en: 'An `IntStream` comes with the method `findFirst`, which you can use to return
    the first element:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntStream`提供了一个`findFirst`方法，你可以用它来返回第一个元素：'
- en: '[PRE31]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Step 3: Filter the tail'
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第3步：过滤尾部
- en: 'Define a method to get the tail of a stream:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个获取流尾部的函数：
- en: '[PRE32]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Given the head of the stream, you can filter the numbers as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 给定流的头部，你可以按照以下方式过滤数字：
- en: '[PRE33]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Step 4: Recursively create a stream of primes'
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第4步：递归创建素数流
- en: 'Here comes the tricky part. You may be tempted to try passing back the resulting
    filtered stream so that you can take its head and filter more numbers, like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是棘手的部分。你可能想尝试传递回过滤后的结果流，这样你就可以取出它的头部并过滤更多的数字，如下所示：
- en: '[PRE34]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Bad news
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 坏消息
- en: 'Unfortunately, if you run the code in step 4, you get the following error:
    `java.lang .IllegalStateException: stream has already been operated upon or closed`.
    Indeed, you’re using two terminal operations to split the stream into its head
    and tail: `findFirst` and `skip`. Remember from [chapter 4](kindle_split_015.xhtml#ch04)
    that after you call a terminal operation on a stream, it’s consumed forever!'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '不幸的是，如果你运行第4步中的代码，你会得到以下错误：`java.lang.IllegalStateException: stream has already
    been operated upon or closed`。确实，你使用了两个终端操作来将流分割成其头部和尾部：`findFirst`和`skip`。记得从[第4章](kindle_split_015.xhtml#ch04)中，在你对一个流调用终端操作后，它就会被永久消耗！'
- en: Lazy evaluation
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 惰性求值
- en: 'There’s an additional, more important problem`:` the static method `IntStream.concat`
    expects two instances of a stream, but its second argument is a direct recursive
    call to `primes`, resulting in an infinite recursion! For many Java purposes,
    restrictions on Java 8 streams such as no recursive definitions are unproblematic
    and give your database-like queries expressivity and the ability to parallelize.
    Thus, the Java 8 designers chose a sweet spot. Nonetheless, the more general features
    and models of streams from functional languages such as Scala and Haskell can
    be useful additions to your programming toolbox. What you need is a way to lazily
    evaluate the call to the method `primes` in the second argument of `concat`. (In
    a more technical programming vocabulary, we refer to this concept as *lazy evaluation,
    nonstrict evaluation* or even *call by name*.) Only when you need to process the
    prime numbers (such as with the `limit` method) should the stream be evaluated.
    Scala (which we explore in [chapter 20](kindle_split_035.xhtml#ch20)) provides
    support for this idea. In Scala, you can write the preceding algorithm as follows,
    where the operator `#::` does lazy concatenation (arguments being evaluated only
    when you need to consume the stream):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个额外且更重要的问题：静态方法`IntStream.concat`期望两个流实例，但它的第二个参数是对`primes`的直接递归调用，导致无限递归！对于许多Java用途，Java
    8流上的限制，如不允许递归定义，是无问题的，并且给你的数据库查询提供了表达性和并行化的能力。因此，Java 8的设计者选择了一个甜点。尽管如此，从Scala和Haskell等函数式语言中获得的更通用的流特性和模型可以作为你编程工具箱的有用补充。你需要的是一个方法，可以惰性地评估`concat`第二个参数中`primes`方法的调用。（在更技术性的编程术语中，我们称这个概念为*惰性求值，非严格求值*，甚至*按名调用*。）只有当你需要处理素数（例如使用`limit`方法）时，流才应该被评估。Scala（我们将在[第20章](kindle_split_035.xhtml#ch20)中探讨）提供了对这个想法的支持。在Scala中，你可以像下面这样编写前面的算法，其中操作符`#::`执行惰性连接（只有在需要消费流时才会评估参数）：
- en: '[PRE35]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Don’t worry about this code. Its only purpose is to show you an area of difference
    between Java and other functional programming languages. It’s good to reflect
    for a moment about how the arguments are evaluated. In Java, when you call a method,
    all its arguments are fully evaluated immediately. But when you use `#::` in Scala,
    the concatenation returns immediately, and the elements are evaluated only when
    needed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心这段代码。它的唯一目的是向你展示Java与其他函数式编程语言之间差异的一个领域。花一点时间思考一下参数是如何评估的。在Java中，当你调用一个方法时，所有参数都会立即完全评估。但是，当你使用Scala中的`#::`时，连接操作会立即返回，并且元素只有在需要时才会被评估。
- en: In the next section, we turn to implementing this idea of lazy lists directly
    in Java.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将转向直接在Java中实现这个惰性列表的想法。
- en: 19.3.2\. Your own lazy list
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 19.3.2. 你自己的惰性列表
- en: 'Java 8 streams are often described as being lazy. They’re lazy in one particular
    aspect: a stream behaves like a black box that can generate values on request.
    When you apply a sequence of operations to a stream, these operations are merely
    saved up. Only when you apply a terminal operation to a stream is anything computed.
    This delaying has a great advantage when you apply several operations (perhaps
    a `filter` and a `map` followed by a terminal operation `reduce`) to a stream:
    the stream has to be traversed only once instead of for each operation.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 流通常被描述为惰性的。它们在某个特定方面是惰性的：流的行为像一个可以按需生成值的黑盒。当你对一个流应用一系列操作时，这些操作仅仅是保存起来。只有当你对一个流应用一个终端操作时，才会进行任何计算。当你对一个流应用多个操作（可能是一个`filter`和一个`map`，然后是一个终端操作`reduce`）时，这种延迟具有很大的优势：流只需要遍历一次，而不是对每个操作都进行遍历。
- en: In this section, you consider the notion of lazy lists, which are forms of a
    more general stream. (Lazy lists form a concept similar to stream.) Lazy lists
    also provide an excellent way of thinking about higher-order functions. You place
    a function value in a data structure so that most of the time, it can sit there
    unused, but when it’s called (on demand), it can create more of the data structure.
    [Figure 19.5](#ch19fig05) illustrates this idea.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将考虑懒列表的概念，它是更一般流的形式。（懒列表形成了一个类似于流的概念。）懒列表还提供了一个思考高阶函数的绝佳方式。你将函数值放入数据结构中，这样大部分时间它都可以在那里闲置，但当你调用它（按需）时，它可以创建更多的数据结构。[图
    19.5](#ch19fig05) 说明了这个想法。
- en: Figure 19.5\. Elements of a `LinkedList` exist (are spread out) in memory. But
    elements of a `LazyList` are created on demand by a `Function`; you can see them
    as being spread out in time.
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 19.5\. `LinkedList` 的元素存在于（分散在）内存中。但 `LazyList` 的元素是由 `Function` 按需创建的；你可以将它们视为在时间上分散。
- en: '![](Images/19fig05_alt.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/19fig05_alt.jpg)'
- en: Next, you see how this concept works. You want to generate an infinite list
    of prime numbers by using the algorithm we described earlier.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将看到这个概念是如何工作的。你想要使用我们之前描述的算法生成一个无限素数列表。
- en: Creating a basic linked list
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建一个基本链表
- en: 'Recall that you can define a simple linked-list-style class called `MyLinkedList`
    in Java by writing it as follows (with a minimal `MyList` interface):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，你可以在 Java 中通过以下方式定义一个简单的链表样式类 `MyLinkedList`，如下所示（使用最小的 `MyList` 接口）：
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now you can construct a sample `MyLinkedList` value as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以按照以下方式构建一个示例 `MyLinkedList` 值：
- en: '[PRE37]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Creating a basic lazy list
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建一个基本懒列表
- en: 'An easy way to adapt this class to the concept of a lazy list is to cause the
    tail not to be present in memory all at once, but to have the `Supplier<T>` that
    you saw in [chapter 3](kindle_split_013.xhtml#ch03) (you can also see it as being
    a factory with a function descriptor `void -> T`) produce the next node of the
    list. This design leads to the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将此类适应懒列表概念的一个简单方法是不一次性将尾部存储在内存中，而是使用你在 [第 3 章](kindle_split_013.xhtml#ch03)
    中看到的 `Supplier<T>`（你也可以将其视为一个具有函数描述符 `void -> T` 的工厂）来生成列表的下一个节点。这种设计导致以下代码：
- en: '[PRE38]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Note that tail using a Supplier encodes laziness, compared with method
    head.**'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注意，与 head 方法相比，使用 Supplier 的 tail 编码了懒性。**'
- en: Calling the method `get` from the `Supplier` causes the creation of a node of
    the `Lazy-List` (as a factory would create a new object).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Supplier` 调用 `get` 方法会导致创建一个 `Lazy-List` 节点（就像工厂创建一个新对象一样）。
- en: 'Now you can create the infinite lazy list of numbers starting at *n* as follows.
    Pass a `Supplier` as the `tail` argument of the `LazyList` constructor, which
    creates the next element in the series of numbers:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以创建从 *n* 开始的无限懒列表，如下所示。将一个 `Supplier` 作为 `LazyList` 构造函数的 `tail` 参数传递，它将创建数字序列中的下一个元素：
- en: '[PRE39]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you try the following code, you see that it prints 2 3 4\. Indeed, the numbers
    are generated on demand. To check, insert `System.out.println` appropriately or
    note that `from(2)` would run forever if it tried to calculate all the numbers
    starting from 2:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试以下代码，你会看到它打印出 2 3 4。确实，数字是在需要时生成的。为了检查，适当地插入 `System.out.println` 或注意，如果
    `from(2)` 尝试从 2 开始计算所有数字，它将永远运行：
- en: '[PRE40]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Generating primes again
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 再次生成素数
- en: 'See whether you can use what you’ve done so far to generate a self-defining
    lazy list of prime numbers (something that you were unable to do with the Streams
    API). If you were to translate the code that was using the Streams API earlier,
    using the new `LazyList`, the code would look like something like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否可以使用你到目前为止所做的一切来生成一个自定义的懒列表素数（这是你无法使用 Streams API 做到的事情）。如果你要使用新的 `LazyList`
    来翻译之前使用 Streams API 的代码，代码看起来可能像这样：
- en: '[PRE41]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Implementing a lazy filter
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现一个懒过滤
- en: 'Unfortunately, a `LazyList` (more accurately, the `List` interface) doesn’t
    define a `filter` method, so the preceding code won’t compile! To fix this problem,
    declare a `filter` method, as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`LazyList`（更准确地说，`List` 接口）没有定义 `filter` 方法，所以前面的代码无法编译！为了解决这个问题，声明一个 `filter`
    方法，如下所示：
- en: '[PRE42]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1* You could return new Empty<>(), but using ’this’ is as good and empty.**'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你可以返回 new Empty<>()，但使用 ''this'' 一样好，也是空的。**'
- en: 'Your code compiles and is ready for use! You can calculate the first three
    prime numbers by chaining calls to `tail` and `head`, as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码编译并通过，可以使用了！你可以通过链式调用 `tail` 和 `head` 来计算前三个素数，如下所示：
- en: '[PRE43]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code prints 2 3 5, which are the first three prime numbers. Now you can
    have some fun. You could print all the prime numbers, for example. (The program
    will run infinitely by writing a `printAll` method, which iteratively prints the
    head and tail of a list.)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印出2 3 5，这是前三个素数。现在你可以玩一些有趣的事情了。例如，你可以打印出所有的素数。（通过编写一个`printAll`方法，程序会无限运行，该方法会迭代打印列表的头部和尾部。）
- en: '[PRE44]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This chapter being a functional programming chapter, we should explain that
    this code can be neatly written recursively:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章是关于函数式编程的，我们应该解释一下，这段代码可以简洁地递归编写：
- en: '[PRE45]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This program wouldn’t run infinitely, though. Sadly, it would eventually fail
    due to stack overflow because Java doesn’t support tail call elimination, as discussed
    in [chapter 18](kindle_split_033.xhtml#ch18).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个程序不会无限运行。遗憾的是，它最终会因为栈溢出而失败，因为Java不支持尾调用消除，如第18章所述（kindle_split_033.xhtml#ch18）。
- en: Review
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 回顾
- en: You’ve built a whole lot of technology with lazy lists and functions, using
    them only to define a data structure containing all the primes. What’s the practical
    use? Well, you’ve seen how to place functions inside data structures (because
    Java 8 allows you to), and you can use these functions to create parts of the
    data structure on demand instead of when the structure is created. This capability
    may be useful if you’re writing a game-playing program, perhaps for chess; you
    can have a data structure that notionally represents the whole tree of possible
    moves (far too big to calculate eagerly) but that can be created on demand. This
    data structure would be a lazy tree, as opposed to a lazy list. We’ve concentrated
    on lazy lists in this chapter because they provide a link to another Java 8 feature,
    streams, which enabled us to discuss the pros and cons of streams compared with
    lazy lists.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经用惰性列表和函数构建了大量技术，你只使用它们来定义一个包含所有素数的数据结构。这有什么实际用途呢？好吧，你已经看到了如何将函数放入数据结构中（因为Java
    8允许这样做），你可以使用这些函数在需要时创建数据结构的一部分，而不是在结构创建时。如果你正在编写一个游戏程序，比如国际象棋，这可能很有用；你可以有一个理论上代表所有可能移动的整个树的数据结构（太大而不能积极计算），但可以在需要时创建。这种数据结构将是一个惰性树，而不是惰性列表。我们之所以在本章中专注于惰性列表，是因为它们提供了与Java
    8的另一项功能——流的联系，这使得我们能够讨论流与惰性列表的优缺点。
- en: There remains the question of performance. It’s easy to assume that doing things
    lazily is better than doing things eagerly. Surely, it’s better to calculate only
    the values and data structures needed by a program on demand than to create all
    those values (and perhaps more), as done in traditional execution. Unfortunately,
    the real world isn’t so simple. The overhead of doing things lazily (such as the
    additional `Supplier`s between items in your `LazyList)` outweighs the notional
    benefit unless you explore, say, less than 10 % of the data structure. Finally,
    there’s a subtle way in which your `LazyList` values aren’t truly lazy. If you
    traverse a `LazyList` value such as `from(2)`, perhaps up to the 10th item, it
    also creates all the nodes twice, creating 20 nodes rather than 10\. This result
    is hardly lazy. The issue is that the `Supplier` in `tail` is repeatedly called
    on each on-demand exploration of the `LazyList`. You can fix this problem by arranging
    for the `Supplier` in `tail` to be called only on the first on-demand exploration,
    with the resulting value being cached, in effect solidifying the list at that
    point. To achieve this goal, add a `private Optional<LazyList<T>> alreadyComputed`
    field to your definition of `LazyList` and arrange for the `tail` method to consult
    and update it appropriately. The pure functional language Haskell arranges that
    all its data structures are properly lazy in the latter sense. Read one of the
    many articles on Haskell if you’re interested.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题仍然存在。人们很容易认为懒散地做事比积极地做事更好。当然，按需计算程序所需的价值和数据结构，而不是像传统执行那样创建所有这些值（也许更多），似乎是更好的选择。不幸的是，现实世界并不那么简单。懒散地做事的开销（比如在`LazyList`中的项目之间的额外`Supplier`）除非你探索的数据结构不到10%，否则会超过这种理论上的好处。最后，有一种微妙的方式，你的`LazyList`值并不是真正懒散的。如果你遍历一个`LazyList`值，比如`from(2)`，可能到第10项，它也会创建所有节点两次，创建20个节点而不是10个。这种结果几乎不懒散。问题是`tail`中的`Supplier`在每次按需探索`LazyList`时都会被反复调用。你可以通过安排`tail`中的`Supplier`只在第一次按需探索时调用，并将结果缓存起来，从而在这一点上固化列表来解决这个问题。为了实现这个目标，在你的`LazyList`定义中添加一个`private
    Optional<LazyList<T>> alreadyComputed`字段，并安排`tail`方法适当地咨询和更新它。纯函数式语言Haskell就是这样安排的，使其所有数据结构在后者意义上都是适当的懒散的。如果你对Haskell感兴趣，可以阅读许多关于Haskell的文章之一。
- en: Our guideline is to remember that lazy data structures can be useful weapons
    in your programming armory. Use these structures when they make an application
    easier to program; rewrite them in more traditional style if they cause unacceptable
    inefficiency.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的指导方针是记住，懒散的数据结构可以成为你编程武器库中的有用武器。当它们使应用程序更容易编程时使用这些结构；如果它们导致不可接受的低效，则以更传统的风格重写它们。
- en: 'The next section deals with another feature of almost all functional programming
    languages except Java: pattern matching.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分处理几乎所有函数式编程语言（除了Java）的另一个特性：模式匹配。
- en: 19.4\. Pattern matching
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4. 模式匹配
- en: 'There’s one other important aspect to what’s generally regarded as functional
    programming: (structural) *pattern matching*, which isn’t to be confused with
    pattern matching and regex. [Chapter 1](kindle_split_011.xhtml#ch01) ended by
    observing that mathematics can write definitions such as'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 被普遍认为的函数式编程还有一个其他重要的方面：（结构化）*模式匹配*，不要与模式匹配和正则表达式混淆。[第一章](kindle_split_011.xhtml#ch01)以观察数学可以写出如下定义结束：
- en: '[PRE46]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: whereas in Java, you have to write an `if-then-else` or a `switch` statement.
    As data types become more complex, the amount of code (and clutter) needed to
    process them increases. Using pattern matching can reduce this clutter.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 而在Java中，你必须编写一个`if-then-else`或`switch`语句。随着数据类型的变得更加复杂，处理它们所需的代码（和混乱）量也会增加。使用模式匹配可以减少这种混乱。
- en: 'To illustrate, take a tree structure that you’d like to traverse. Consider
    a simple arithmetic language consisting of numbers and binary operations:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，考虑一个你想遍历的树结构。考虑一个由数字和二元运算组成的简单算术语言：
- en: '[PRE47]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Suppose that you’re asked to write a method to simplify some expressions. 5
    + 0 can be simplified to 5, for example. Using our `Expr` class, `new BinOp("+",
    new Number(5), new Number(0))` could be simplified to `Number(5)`. You might traverse
    an `Expr` structure as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被要求编写一个简化某些表达式的函数。例如，5 + 0可以简化为5。使用我们的`Expr`类，`new BinOp("+", new Number(5),
    new Number(0))`可以简化为`Number(5)`。你可能像这样遍历一个`Expr`结构：
- en: '[PRE48]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can see that this code rapidly gets ugly!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这段代码很快就会变得丑陋！
- en: 19.4.1\. Visitor design pattern
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 19.4.1. 访问者设计模式
- en: Another way to unwrap the data type in Java is to use the visitor design pattern.
    In essence, you create a separate class that encapsulates an algorithm to visit
    a specific data type.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中展开数据类型的另一种方法是使用访问者设计模式。本质上，你创建一个单独的类，该类封装了一个访问特定数据类型的算法。
- en: 'The visitor class works by taking as input a specific instance of the data
    type; then it can access all its members. Here’s an example. First, add the method
    `accept` to `BinOp`, which takes `SimplifyExprVisitor` as argument and passes
    itself to it (and add a similar method for `Number`):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者类通过接受数据类型的特定实例作为输入来工作；然后它可以访问所有成员。以下是一个示例。首先，向 `BinOp` 添加方法 `accept`，该方法接受
    `SimplifyExprVisitor` 作为参数并将自身传递给它（并为 `Number` 添加类似的方法）：
- en: '[PRE49]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now the `SimplifyExprVisitor` can access a `BinOp` object and unwrap it:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `SimplifyExprVisitor` 可以访问 `BinOp` 对象并展开它：
- en: '[PRE50]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 19.4.2\. Pattern matching to the rescue
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 19.4.2\. 模式匹配救命
- en: A simpler solution uses a feature called pattern matching. That feature isn’t
    available in Java, so we’re going to use small examples from the Scala programming
    language to illustrate pattern matching. The examples give you an idea of what
    could be possible in Java if pattern matching were supported.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简单的解决方案是使用一个名为模式匹配的功能。该功能在 Java 中不可用，因此我们将使用 Scala 编程语言的小例子来说明模式匹配。这些例子给你一个想法，如果
    Java 支持模式匹配，可能会实现什么。
- en: 'Given data type `Expr` representing arithmetic expressions, in the Scala programming
    language (which we use because its syntax is closest to Java), you can write the
    following code to decompose an expression:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 给定表示算术表达式的数据类型 `Expr`，在 Scala 编程语言（我们之所以使用它是因为其语法与 Java 最接近）中，你可以编写以下代码来分解一个表达式：
- en: '[PRE51]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This use of pattern matching gives you an extremely concise and expressive way
    to manipulate many treelike data structures. Typically, this technique is useful
    for building compilers or engines for processing business rules. Note that the
    Scala syntax
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式匹配的使用提供了一种极其简洁且富有表现力的方式来操作许多树状数据结构。通常，这种技术对于构建编译器或处理业务规则的引擎非常有用。请注意，Scala
    语法
- en: '[PRE52]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: is similar to the Java syntax
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 语法相似
- en: '[PRE53]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'with Scala’s wildcard pattern _ making the final `case` _ play the role of
    `default`: in Java. The main visible syntactic difference is that Scala is expression-oriented,
    whereas Java is more statement-oriented. But for the programmer, the main expressiveness
    difference is the fact that Java patterns in `case` labels are restricted to a
    couple of primitive types, enumerations, a few special classes that wrap certain
    primitive types, and `String`s. One of the biggest practical advantages of using
    languages with pattern matching is that you can avoid using big chains of `switch`
    or `if-then-else` statements interleaved with field-selection operations.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Scala 的通配符模式 _ 使最终的 `case` 扮演 Java 中的 `default` 角色：。主要的可见语法差异是 Scala 以表达式为导向，而
    Java 则更以语句为导向。但对于程序员来说，主要的表达差异是 Java 中的 `case` 标签模式仅限于几种原始类型、枚举、一些封装特定原始类型的特殊类以及
    `String`。使用具有模式匹配功能的语言的最大实际优势之一是你可以避免使用大型的 `switch` 或 `if-then-else` 语句链，这些语句链与字段选择操作交织在一起。
- en: It’s clear that Scala’s pattern matching wins on ease of expressiveness over
    Java, and you can look forward to a future Java allowing more-expressive `switch`
    statements. (We make a concrete proposal for this feature in [chapter 21](kindle_split_036.xhtml#ch21).)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，Scala 的模式匹配在表达简洁性方面优于 Java，你可以期待未来 Java 允许更具有表现力的 `switch` 语句。（我们在第 21 章中提出了这个特性的具体建议。[chapter
    21](kindle_split_036.xhtml#ch21)。）
- en: In the meantime, we show you how Java 8 lambdas can provide an alternative way
    of achieving pattern-matching-like code in Java. We describe this technique purely
    to show you another interesting application of lambdas.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们向你展示 Java 8 lambdas 如何提供在 Java 中实现类似模式匹配代码的另一种方法。我们纯粹为了向你展示 lambdas 的另一个有趣应用来描述这项技术。
- en: Faking pattern matching in Java
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在 Java 中伪造模式匹配
- en: First, consider how rich Scala’s pattern-matching `match` expression form is.
    The case
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑 Scala 的模式匹配 `match` 表达式形式的丰富性。案例
- en: '[PRE54]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: means “Check that `expr` is a `BinOp`, extract its three components (`opname`,
    `left`, `right`), and then pattern-match these components—the first against the
    `String` +, the second against the variable `e` (which always matches), and the
    third against the pattern `Number(0)`.” In other words, pattern matching in Scala
    (and many other functional languages) is multilevel. Your simulation of pattern
    matching with Java 8’s lambdas produces only single-level pattern matching. In
    the preceding example, your simulation would express cases such as `BinOp(op,
    l, r)` or `Number(n)` but not `BinOp("+", e, Number(0))`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着“检查 `expr` 是否是 `BinOp`，提取其三个组件（`opname`，`left`，`right`），然后对这些组件进行模式匹配——第一个与
    `String` + 匹配，第二个与变量 `e`（它总是匹配）匹配，第三个与模式 `Number(0)` 匹配。”换句话说，Scala（以及许多其他函数式语言）中的模式匹配是多层的。你用
    Java 8 的 lambdas 模拟的模式匹配只产生单层模式匹配。在前面的例子中，你的模拟会表达 `BinOp(op, l, r)` 或 `Number(n)`
    这样的情况，但不会表达 `BinOp("+", e, Number(0))`。
- en: 'First, we make a slightly surprising observation: now that you have lambdas,
    you could in principle never use `if-then-else` in your code. You could replace
    code such as `condition ? e1 : e2` with a method call, as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们做一个稍微令人惊讶的观察：既然你有了 lambdas，原则上你可以在代码中永远不用 `if-then-else`。你可以用方法调用替换 `condition
    ? e1 : e2` 这样的代码，如下所示：'
- en: '[PRE55]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Somewhere, perhaps in a library, you’d have a definition (generic in type `T`):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个地方，可能是在图书馆里，你会找到一个定义（类型为 `T` 的泛型）：
- en: '[PRE56]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The type `T` plays the role of the result type of the conditional expression.
    In principle, you can perform similar tricks with other control-flow constructs
    such as `switch` and `while`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `T` 扮演了条件表达式的结果类型角色。原则上，你可以用其他控制流结构，如 `switch` 和 `while`，执行类似的技巧。
- en: In normal code, this encoding would make your code more obscure because `if-then-else`
    captures this idiom perfectly. But we’ve noted that Java’s `switch` and `if-then-else`
    don’t capture the idiom of pattern matching, and it turns out that lambdas can
    encode (single-level) pattern matching—rather more neatly than the chains of `if-then-else.`
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常代码中，这种编码会使你的代码更加晦涩，因为 `if-then-else` 完美地捕捉了这个习语。但我们已经注意到，Java 的 `switch`
    和 `if-then-else` 并没有捕捉到模式匹配的习语，而且结果证明 lambdas 可以编码（单层）模式匹配——比 `if-then-else` 链要整洁得多。
- en: 'Returning to pattern-matching values of class `Expr` (which has two subclasses,
    `BinOp` and `Number`), you can define a method `patternMatchExpr` (again generic
    in `T,` the result type of the pattern match):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `Expr` 类的模式匹配值（该类有两个子类，`BinOp` 和 `Number`），你可以定义一个 `patternMatchExpr` 方法（再次泛型
    `T`，模式匹配的结果类型）：
- en: '[PRE57]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The result is that the method call
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，方法调用
- en: '[PRE58]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: determines whether `e` is a `BinOp` (and if so, runs `binopcode`, which has
    access to the fields of the `BinOp` via identifiers `op, l, r`) or a `Number`
    (and if so, runs `numcode`, which has access to the value `n`). The method even
    makes provision for `defaultcode`, which would be executed if someone later created
    a tree node that was neither a `BinOp` nor a `Number`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 判断 `e` 是否是 `BinOp`（如果是，则运行 `binopcode`，它可以通过标识符 `op, l, r` 访问 `BinOp` 的字段）或
    `Number`（如果是，则运行 `numcode`，它可以通过值 `n` 访问），该方法甚至为 `defaultcode` 做了准备，如果有人后来创建了一个既不是
    `BinOp` 也不是 `Number` 的树节点，则会执行该代码。
- en: The following listing shows you how to start using `patternMatchExpr` by simplifying
    addition and multiplication expressions.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何通过简化加法和乘法表达式来开始使用 `patternMatchExpr`。
- en: Listing 19.1\. Implementing pattern matching to simplify an expression
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 19.1\. 实现模式匹配以简化表达式
- en: '[PRE59]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* Deals with a BinOp expression**'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 处理 BinOp 表达式**'
- en: '***2* Deals with the addition case**'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 处理加法情况**'
- en: '***3* Deals with the multiplication case**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 处理乘法情况**'
- en: '***4* Deals with a Number**'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 处理一个 Number**'
- en: '***5* A default case if the user provides an Expr that’s not recognized**'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果用户提供了一个未识别的 Expr，则有一个默认情况**'
- en: '***6* Applies pattern matching**'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 应用模式匹配**'
- en: 'Now you can call the `simplify` method as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以按照以下方式调用 `simplify` 方法：
- en: '[PRE60]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* Prints 5**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 5**'
- en: 'You’ve seen a lot of information so far: higher-order functions, currying,
    persistent data structures, lazy lists, and pattern matching. The next section
    looks at certain subtleties that we’ve deferred to the end to avoid overcomplicating
    the text.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了很多信息：高阶函数、柯里化、持久数据结构、惰性列表和模式匹配。下一节将探讨我们推迟到最后的某些细微差别，以避免使文本过于复杂。
- en: 19.5\. Miscellany
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.5\. 杂项
- en: 'In this section, we explore two subtleties of being functional and of having
    referential transparency: one about efficiency and the other about returning the
    same result. These issues are interesting, but we place them here because the
    subtleties concern side effects and aren’t conceptually central. We also explore
    the idea of *combinators*—methods or functions that take two or more functions
    and return another function. This idea has inspired many of the additions to the
    Java 8 API and more recently the Java 9 Flow API.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨函数式编程和引用透明性的两个细微之处：一个关于效率，另一个关于返回相同的结果。这些问题很有趣，但我们将其放在这里，因为这些问题涉及到副作用，并不是概念上的核心。我们还探讨了*组合子*的概念——即接受两个或更多函数并返回另一个函数的方法或函数。这个想法启发了Java
    8 API的许多新增功能，以及更近期的Java 9 Flow API。
- en: 19.5.1\. Caching or memoization
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 19.5.1. 缓存或记忆化
- en: Suppose that you have a side-effect-free method `computeNumberOfNodes(Range)`
    that calculates the number of nodes inside a given range in a network with a treelike
    topology. Assume that the network never changes (that is, the structure is immutable),
    but that calling the method `computeNumberOfNodes` is expensive to calculate because
    the structure needs to be traversed recursively. You may want to calculate the
    results over and over. If you have referential transparency, you have a clever
    way to avoid this additional overhead. One standard solution is *memoization*—adding
    a cache (such as a `HashMap`) to the method as a wrapper. First, the wrapper consults
    the cache to see whether the (argument, result) pair is already in the cache.
    If so, it can return the stored result immediately. Otherwise, you call `computeNumberOfNodes`,
    but before returning from the wrapper, you store the new (argument, result) pair
    in the cache. Strictly speaking, this solution isn’t purely functional because
    it mutates a data structure shared by multiple callers, but the wrapped version
    of the code is referentially transparent.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个无副作用的`computeNumberOfNodes(Range)`方法，它计算一个具有树形拓扑结构的网络中给定范围内的节点数。假设网络永远不会改变（即结构是不可变的），但调用`computeNumberOfNodes`方法计算成本很高，因为需要递归遍历结构。你可能需要反复计算结果。如果你有引用透明性，你有一个巧妙的方法来避免这种额外的开销。一个标准的解决方案是*记忆化*——在方法周围添加一个缓存（如`HashMap`）。首先，包装器会咨询缓存以查看（参数，结果）对是否已经在缓存中。如果是这样，它可以立即返回存储的结果。否则，你会调用`computeNumberOfNodes`，但在从包装器返回之前，你将新的（参数，结果）对存储在缓存中。严格来说，这个解决方案并不是纯函数式的，因为它会修改多个调用者共享的数据结构，但包装后的代码是引用透明的。
- en: 'In practice, this code works as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这段代码是这样工作的：
- en: '[PRE61]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '|  |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Java 8 enhances the `Map` interface (see [appendix B](kindle_split_038.xhtml#app02))
    with a `compute-If-Absent` method for such use cases. You could use `computeIfAbsent`
    to write clearer code:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8通过为这种用例添加`compute-If-Absent`方法来增强`Map`接口（见附录B[appendix B](kindle_split_038.xhtml#app02)）。你可以使用`computeIfAbsent`来编写更清晰的代码：
- en: '[PRE62]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '|  |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: It’s clear that the method `computeNumberOfNodesUsingCache` is referentially
    transparent (assuming that the method `computeNumberOfNodes` is also referentially
    transparent). But the fact that `numberOfNodes` has mutable shared state and that
    `HashMap` isn’t `synchronized`^([[3](#ch19fn03)]) means that this code isn’t thread-safe.
    Even using (lock-protected) `Hashtable` or (concurrent-without-locking) `ConcurrentHashMap`
    instead of `HashMap` may not produce the expected performance if parallel calls
    are made to `numberOfNodes` from multiple cores. There’s a race condition between
    your finding that `range` isn’t in the `map` and inserting the (argument, result)
    pair back into the `map`, which means that multiple processes might compute the
    same value to add to the `map`.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`computeNumberOfNodesUsingCache`方法具有引用透明性（假设`computeNumberOfNodes`方法也是引用透明的）。但`numberOfNodes`具有可变的共享状态，而`HashMap`不是`synchronized`^([[3](#ch19fn03)])，这意味着这段代码不是线程安全的。即使使用（锁保护的）`Hashtable`或（无锁的）`ConcurrentHashMap`代替`HashMap`，如果从多个核心对`numberOfNodes`进行并行调用，也可能不会产生预期的性能。在将（参数，结果）对放回`map`之前，你发现`range`不在`map`中，这之间有一个竞争条件，这意味着多个进程可能会计算相同的值添加到`map`中。
- en: ³
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This place is one where bugs breed. It’s so easy to use `HashMap` and to forget
    the fact that the Java manual notes that it’s not thread-safe (or not to care
    because *your* program is currently single-threaded).
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里是容易滋生错误的地方。使用`HashMap`如此容易，以至于很容易忘记Java手册指出它不是线程安全的（或者因为*你的*程序目前是单线程的而不在乎）。
- en: Perhaps the best thing to take away from this struggle is the fact that mixing
    mutable state with concurrency is trickier than you’d imagine. Functional-style
    programming avoids this practice except for low-level performance hacks such as
    caching. A second takeaway is that apart from implementing tricks such as caching,
    if you code in functional style, you never need to care whether another functional-style
    method that you call is synchronized, because you *know* that it has no shared
    mutable state.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 也许从这场斗争中我们能得到的最好的东西就是这样一个事实：将可变状态与并发混合比我们想象的要复杂。函数式编程除了用于低级性能黑客，如缓存之外，避免这种做法。第二个启示是，除了实现缓存等技巧之外，如果你以函数式风格编写代码，你永远不需要关心你调用的另一个函数式方法是否是同步的，因为你知道它没有共享的可变状态。
- en: 19.5.2\. What does “Return the same object” mean?
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 19.5.2\. “返回相同的对象”是什么意思？
- en: 'Consider again the binary tree example from [section 19.2.3](#ch19lev2sec5).
    In [figure 19.4](#ch19fig04), variable `t` points to an existing `Tree`, and the
    figure shows the effect of calling `fupdate("Will", 26, t)` to produce a new `Tree`,
    which presumably is assigned to variable `t2`. The figure makes clear that `t`
    and all the data structures reachable from it aren’t mutated. Now suppose that
    you perform a textually identical call in the additional assignment:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑[第19.2.3节](#ch19lev2sec5)中的二叉树示例。在[图19.4](#ch19fig04)中，变量`t`指向一个现有的`Tree`，图显示了调用`fupdate("Will",
    26, t)`以产生一个新的`Tree`的效果，这个新`Tree`可能被分配给变量`t2`。图清楚地表明`t`及其所有可到达的数据结构都没有被修改。现在假设你在附加赋值中执行一个文本上相同的调用：
- en: '[PRE63]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now `t3` points to three more newly created nodes containing the same data as
    those in `t2`. The question is whether `fupdate` is referentially transparent.
    *Referentially transparent* means “equal arguments (the case here) imply equal
    results.” The problem is that `t2` and `t3` are different references, and therefore
    `(t2 == t3)` is `false`, so it looks as though you’ll have to conclude that `fupdate`
    isn’t referentially transparent. But when you’re using persistent data structures
    that aren’t to be modified, no logical difference exists between `t2` and `t3`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`t3`指向三个包含与`t2`中相同数据的新的节点。问题是`fupdate`是否是引用透明的。*引用透明*意味着“相同的参数（这里的情况）意味着相同的结果。”问题是`t2`和`t3`是不同的引用，因此`(t2
    == t3)`是`false`，所以看起来你将不得不得出结论，`fupdate`不是引用透明的。但是当你使用不可修改的持久数据结构时，`t2`和`t3`之间不存在逻辑上的差异。
- en: We can debate this point at length, but the simplest adage is that functional-style
    programming generally uses `equals` to compare structured values rather than `==`
    (reference equality) because data isn’t modified, and under this model, `fupdate`
    *is* referentially transparent.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对此进行长时间的辩论，但最简单的格言是，函数式编程通常使用`equals`来比较结构化值，而不是`==`（引用相等），因为数据不会被修改，在这个模型下，`fupdate`是引用透明的。
- en: 19.5.3\. Combinators
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 19.5.3\. 组合子
- en: In functional programming, it’s common and natural to write a higher-order function
    (perhaps written as a method) that accepts, say, two functions and produces another
    function that somehow combines these functions. The term *combinator* generally
    is used for this idea. Much of the new Java 8 API is inspired by this idea, such
    as `thenCombine` in the `CompletableFuture` class. You can give this method two
    `CompletableFuture`s and a `BiFunction` to produce another `CompletableFuture`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，编写一个接受两个函数并产生另一个将这两个函数以某种方式组合的函数（可能被写成方法）是很常见且自然的。这个概念通常被称为*组合子*。Java
    8 API中的许多新功能都受到了这种想法的启发，例如`CompletableFuture`类中的`thenCombine`方法。你可以给这个方法提供两个`CompletableFuture`和一个`BiFunction`来产生另一个`CompletableFuture`。
- en: 'Although a detailed discussion of combinators in functional programming is
    beyond the scope of this book, it’s worth looking at a couple of special cases
    to give you the flavor of how operations that take and return functions are a
    common and natural functional programming construct. The following method encodes
    the idea of function composition:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对函数式编程中组合子的详细讨论超出了本书的范围，但看看几个特殊情况以给你一个关于操作函数的常见和自然函数式编程结构的味道是值得的。以下方法编码了函数组合的概念：
- en: '[PRE64]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This method takes functions `f` and `g` as arguments and returns a function
    whose effect is to do `f` first and then `g`. Then you can define an operation
    that captures internal iteration as a combinator. Suppose that you want to take
    data and apply function `f` to it repeatedly, *n* times, as in a loop. Your operation
    (call it `repeat`) takes a function, `f`, saying what happens in one iteration
    and returning a function that says what happens in *n* iterations. A call such
    as
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将函数 `f` 和 `g` 作为参数，并返回一个函数，其效果是先执行 `f`，然后执行 `g`。然后你可以定义一个操作，将内部迭代作为组合器。假设你想要对数据进行操作，并重复应用函数
    `f`，*n* 次，就像循环一样。你的操作（可以称为 `repeat`）接受一个函数 `f`，说明一次迭代发生的事情，并返回一个函数，说明 *n* 次迭代发生的事情。例如，调用
- en: '[PRE65]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: returns `x ->(2*(2*(2*x))` or equivalently `x -> 8*x`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `x ->(2*(2*(2*x))` 或等价于 `x -> 8*x`。
- en: You can test this code by writing
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编写以下代码来测试此代码：
- en: '[PRE66]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: which prints 80.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印 80。
- en: 'You can code the `repeat` method as follows (noting the special case of a zero-trip
    loop):'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样编写 `repeat` 方法（注意零次循环的特殊情况）：
- en: '[PRE67]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '***1* Return the do-nothing identity function if n is zero.**'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果 n 为零，则返回无操作的身份函数。**'
- en: '***2* Otherwise do f, repeated n-1 times, followed by doing it once more.**'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 否则，先执行 f，重复 n-1 次，然后再次执行。**'
- en: Variants of this idea can model richer notions of iteration, including having
    a functional model of mutable state passed between iterations. But it’s time to
    move on. This chapter’s role was to give you a summary of functional programming
    as the basis for Java 8\. Many excellent books explore functional programming
    in greater depth.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这种想法的变体可以模拟更丰富的迭代概念，包括在迭代之间传递可变状态的函数模型。但是，现在是时候继续前进了。本章的作用是为你提供一个关于函数式编程的总结，作为
    Java 8 的基础。许多优秀的书籍都深入探讨了函数式编程。
- en: Summary
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: First-class functions are functions that can be passed as arguments, returned
    as results, and stored in data structures.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一等函数是可以作为参数传递、作为结果返回，并且可以存储在数据结构中的函数。
- en: A higher-order function takes one or more functions as input or returns another
    function. Typical higher-order functions in Java include `comparing`, `andThen`,
    and `compose`.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数接受一个或多个函数作为输入或返回另一个函数。Java 中的典型高阶函数包括 `comparing`、`andThen` 和 `compose`。
- en: Currying is a technique that lets you modularize functions and reuse code.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化是一种让你模块化函数和重用代码的技术。
- en: A persistent data structure preserves the previous version of itself when it’s
    modified. As a result, it can prevent unnecessary defensive copying.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久数据结构在修改时保留其之前的版本。因此，它可以防止不必要的防御性复制。
- en: Streams in Java can’t be self-defined.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 中的流不能自定义。
- en: A lazy list is a more-expressive version of a Java stream. A lazy list lets
    you produce elements of the list on demand by using a supplier that can create
    more of the data structure.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性列表是 Java 流的更表达性版本。惰性列表允许你通过使用可以创建更多数据结构的供应商按需生成列表的元素。
- en: Pattern matching is a functional feature that lets you unwrap data types. You
    can view data matching as generalizing Java’s `switch` statement.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配是一种函数式特性，它允许你展开数据类型。你可以将数据匹配视为泛化 Java 的 `switch` 语句。
- en: Referential transparency allows computations to be cached.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用透明性允许计算被缓存。
- en: Combinators are functional ideas that combine two or more functions or other
    data structures.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合器是结合两个或更多函数或其他数据结构的函数式思想。
- en: 'Chapter 20\. Blending OOP and FP: Comparing Java and Scala'
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 20 章。混合 OOP 和 FP：比较 Java 和 Scala
- en: '*This chapter covers*'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: An introduction to Scala
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 简介
- en: How Java relates to Scala and vice versa
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 与 Scala 以及反之的关系
- en: How functions in Scala compare to Java
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 中的函数与 Java 中的函数比较
- en: Classes and traits
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和特质
- en: 'Scala is a programming language that mixes object-oriented and functional programming.
    It’s often seen as an alternative language to Java for programmers who want functional
    features in a statically typed programming language that runs on the JVM while
    keeping a Java feel. Scala introduces many more features than Java: a more-sophisticated
    type system, type inference, pattern matching (as presented in [chapter 19](kindle_split_034.xhtml#ch19)),
    constructs that define domain-specific languages simply, and so on. In addition,
    you can access all Java libraries within Scala code.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 是一种混合面向对象和函数式编程的编程语言。它通常被视为想要在 JVM 上运行且具有 Java 感觉的静态类型编程语言中具有函数式特性的程序员的
    Java 的替代语言。Scala 引入了许多比 Java 更多的特性：更复杂的类型系统、类型推断、模式匹配（如第 19 章所述）、定义特定领域语言的构造，等等。此外，你可以在
    Scala 代码中访问所有 Java 库。
- en: You may wonder why we have a chapter about Scala in a Java book. This book has
    largely centered on adopting functional-style programming in Java. Scala, like
    Java, supports the concepts of functional-style processing of collections (that
    is, streamlike operations), first-class functions, and default methods. But Scala
    pushes these ideas further, providing a larger set of features that support these
    ideas compared with Java. We believe that you may find it interesting to compare
    Scala with the approach taken by Java and see Java’s limitations. This chapter
    aims to shed light on this matter to appease your curiosity. We don’t necessarily
    encourage the adoption of Scala over Java. Other interesting new programming languages
    on the JVM, such as Kotlin, are also worth looking at. The purpose of this chapter
    is to open your horizons to what’s available beyond Java. We believe that it’s
    important for a well-rounded software engineer to be knowledgeable about the wider
    programming-languages ecosystem.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么在一本 Java 书中会有关于 Scala 的章节。这本书主要关注在 Java 中采用函数式编程风格。Scala，就像 Java 一样，支持集合的函数式处理概念（即类似流式操作）、一等函数和默认方法。但
    Scala 将这些想法进一步推进，提供了比 Java 更大的功能集来支持这些想法。我们相信，您可能会对将 Scala 与 Java 采用的方法进行比较，并看到
    Java 的局限性感到有趣。本章旨在阐明这一点，以满足您的求知欲。我们并不一定鼓励您采用 Scala 而不是 Java。JVM 上其他有趣的新的编程语言，如
    Kotlin，也值得一看。本章的目的是开阔您的视野，了解 Java 之外还有什么。我们相信，对于一位全面发展的软件工程师来说，了解更广泛的编程语言生态系统是很重要的。
- en: Also keep in mind that the purpose of this chapter isn’t to teach you how to
    write idiomatic Scala code or to tell you everything about Scala. Scala supports
    many features (such as pattern matching, for-comprehensions, and implicits) that
    aren’t available in Java, and we won’t discuss those features. Rather, we focus
    on comparing the Java and Scala features to give you an idea of the bigger picture.
    You’ll find that you can write more concise and readable code in Scala compared
    with Java, for example.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，本章的目的不是教您如何编写地道的 Scala 代码，也不是告诉您关于 Scala 的所有内容。Scala 支持许多在 Java 中不可用的特性（如模式匹配、for-comprehensions
    和 implicits），我们不会讨论这些特性。相反，我们专注于比较 Java 和 Scala 的特性，以给您一个更全面的了解。您会发现，与 Java 相比，您可以在
    Scala 中编写更简洁、更易读的代码，例如。
- en: 'This chapter starts with an introduction to Scala: writing simple programs
    and working with collections. Next, we discuss functions in Scala: first-class
    functions, closures, and currying. Finally, we look at classes in Scala and at
    a feature called traits, which is Scala’s take on interfaces and default methods.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从 Scala 的简介开始：编写简单的程序和操作集合。接下来，我们讨论 Scala 中的函数：一等函数、闭包和柯里化。最后，我们探讨 Scala 中的类以及一个称为
    traits 的特性，这是 Scala 对接口和默认方法的实现。
- en: 20.1\. Introduction to Scala
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1\. Scala 简介
- en: This section briefly introduces basic Scala features to give you a feel for
    simple Scala programs. We start with a slightly modified “Hello world” example
    written in an imperative style and a functional style. Then we look at some data
    structures that Scala supports—`List`, `Set`, `Map`, `Stream`, `Tuple`, and `Option`—and
    compare them with Java. Finally, we present *traits*, Scala’s replacement for
    Java’s interfaces, which also support inheritance of methods at object-instantiation
    time.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要介绍了 Scala 的基本特性，以便您对简单的 Scala 程序有一个感觉。我们从一个稍微修改过的“Hello world”示例开始，这个示例以命令式风格和函数式风格编写。然后我们查看
    Scala 支持的一些数据结构——`List`、`Set`、`Map`、`Stream`、`Tuple` 和 `Option`——并将它们与 Java 进行比较。最后，我们介绍
    *traits*，Scala 用它来替代 Java 的接口，它也支持在对象实例化时继承方法。
- en: 20.1.1\. Hello beer
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.1.1\. Hello beer
- en: 'To change a bit from the classic “Hello world” example, bring in some beer.
    You want to print the following output on the screen:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从经典的“Hello world”示例中有所改变，我们可以引入一些啤酒。你希望在屏幕上打印以下输出：
- en: '[PRE68]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Imperative-style Scala
  id: totrans-442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命令式风格的 Scala
- en: 'Here’s how the code to print this output looks in Scala when you use an imperative
    style:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用命令式风格在 Scala 中打印这个输出时，代码如下：
- en: '[PRE69]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1* String interpolation**'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 字符串插值**'
- en: 'You can find information about how to run this code on the official Scala website
    (see [https://docs.scala-lang.org/getting-started.html](https://docs.scala-lang.org/getting-started.html)).
    This program looks similar to what you’d write in Java, and its structure is similar
    to that of Java programs, consisting of one method called `main`, which takes
    an array of strings as argument. (Type annotations follow the syntax `s : String`
    instead of `Strings`, as in Java.) The `main` method doesn’t return a value, so
    it’s not necessary to declare a return type in Scala as you’d have to do in Java
    when you use `void`.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以在官方Scala网站上找到有关如何运行此代码的信息（见[https://docs.scala-lang.org/getting-started.html](https://docs.scala-lang.org/getting-started.html)）。这个程序看起来与你在Java中编写的程序相似，其结构也与Java程序相似，包含一个名为`main`的方法，该方法接受一个字符串数组作为参数。（类型注解遵循`s
    : String`语法，而不是Java中的`Strings`。）`main`方法不返回任何值，因此在Scala中不需要声明返回类型，就像在Java中使用`void`时必须做的那样。'
- en: '|  |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In general, nonrecursive method declarations in Scala don’t need an explicit
    return type, because Scala can infer the type for you.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，通常非递归方法声明不需要显式返回类型，因为Scala可以为你推断类型。
- en: '|  |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Before we look at the body of the `main` method, we need to discuss the `object`
    declaration. After all, in Java you have to declare the method `main` within a
    class. The declaration `object` introduces a singleton object, declaring a class
    `Beer` and instantiating it at the same time. Only one instance is created. This
    example is the first example of a classical design pattern (the singleton design
    pattern) implemented as a language feature, and it’s free to use out of the box.
    In addition, you can view methods within an `object` declaration as being declared
    as static, which is why the signature of the `main` method isn’t explicitly declared
    as `static`.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看`main`方法体之前，我们需要讨论`object`声明。毕竟，在Java中，你必须在类内部声明`main`方法。`object`声明引入了一个单例对象，同时声明了一个名为`Beer`的类并实例化它。只创建了一个实例。这个例子是第一个将经典设计模式（单例设计模式）作为语言特性实现的例子，并且可以直接使用。此外，你可以将`object`声明内的方法视为静态声明，这就是为什么`main`方法的签名没有明确声明为`static`。
- en: 'Now look at the body of `main`. This method also looks similar to a Java method,
    but statements don’t need to end with a semicolon (which is optional). The body
    consists of a `while` loop, which increments a mutable variable, `n`. For each
    new value of `n`, you print a string on the screen, using the predefined `println`
    method. The `println` line showcases another feature of Scala: *string interpolation*,
    which allows you to embed variables and expressions directly in string literals.
    In the preceding code, you can use the variable `n` directly in the string literal
    `s"Hello ${n} bottles of beer"`. Prepending the string with the interpolator `s`
    provides that magic. Normally in Java, you have to do an explicit concatenation
    such as `"Hello " + n + " bottles of beer"`.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看`main`方法的主体。这个方法看起来与Java方法相似，但语句不需要以分号结尾（这是可选的）。主体包含一个`while`循环，它递增一个可变变量`n`。对于`n`的每个新值，你都会在屏幕上打印一个字符串，使用预定义的`println`方法。`println`行展示了Scala的另一个特性：*字符串插值*，它允许你直接在字符串字面量中嵌入变量和表达式。在先前的代码中，你可以在字符串字面量`s"Hello
    ${n} bottles of beer"`中直接使用变量`n`。在字符串前加上插值器`s`提供了这种魔法。通常在Java中，你必须进行显式的连接，例如`"Hello
    " + n + " bottles of beer"`。
- en: Functional-style Scala
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数式风格的Scala
- en: 'But what can Scala offer after all our talk about functional-style programming
    throughout this book? The preceding code can be written in a more functional-style
    form in Java as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们整本书都在讨论函数式编程风格之后，Scala又能提供什么呢？前面的代码可以用更函数式的方式在Java中写成如下形式：
- en: '[PRE70]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here’s how that code looks in Scala:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这段代码在Scala中的样子：
- en: '[PRE71]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The Scala code is similar to the Java code but less verbose. First, you can
    create a range by using the expression `2 to 6`. Here’s something cool: `2` is
    an object of type `Int`. In Scala, *everything* is an object; there’s no concept
    of primitive types, as in Java, which makes Scala a complete object-oriented language.
    An `Int` object in Scala supports a method named `to`, which takes as an argument
    another `Int` and returns a range. You could have written `2.to(6)` instead. But
    methods that take one argument can be written in an infix form. Next, `foreach`
    (with a lowercase `e`) is similar to `forEach` in Java (with an uppercase `E`).
    This method is available on a range (you use the infix notation again), and it
    takes a lambda expression as an argument to apply on each element. The lambda-expression
    syntax is similar to that in Java, but the arrow is `=>` instead of `->`.^([[1](#ch20fn01)])
    The preceding code is functional; you’re not mutating a variable as you did in
    the earlier example using a `while` loop.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: Scala代码与Java代码类似，但更简洁。首先，你可以使用表达式`2 to 6`创建一个范围。这里有一个很酷的点：`2`是一个`Int`类型的对象。在Scala中，*一切都是对象*；没有像Java中那样的原始类型概念，这使得Scala成为一门完整的面向对象语言。Scala中的`Int`对象支持一个名为`to`的方法，它接受另一个`Int`作为参数并返回一个范围。你可以写成`2.to(6)`。但是只有一个参数的方法可以写成中缀形式。接下来，`foreach`（小写`e`）与Java中的`forEach`（大写`E`）类似。这个方法在范围上可用（你再次使用中缀表示法），它接受一个lambda表达式作为参数，用于对每个元素应用。lambda表达式的语法与Java中的类似，但箭头是`=>`而不是`->`。^([[1](#ch20fn01)])
    上述代码是函数式的；你并没有像在早期示例中使用`while`循环那样修改变量。
- en: ¹
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that the Scala terms *anonymous functions* and *closures* (interchangeable)
    refer to what Java calls lambda expressions.
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，Scala中的术语*匿名函数*和*closures*（可以互换使用）指的是Java中称为lambda表达式的概念。
- en: '20.1.2\. Basic data structures: List, Set, Map, Tuple, Stream, Option'
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.1.2\. 基本数据结构：List、Set、Map、Tuple、Stream、Option
- en: Are you feeling good after having a couple of beers to quench your thirst? Most
    real programs need to manipulate and store data, so in this section, you manipulate
    collections in Scala and see how that process compares with Java.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 喝了几杯啤酒解渴之后，你感觉好吗？大多数真实程序都需要操作和存储数据，所以在本节中，你将使用Scala操作集合，并查看这个过程与Java的比较。
- en: Creating collections
  id: totrans-464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建集合
- en: 'Creating collections in Scala is simple, thanks to Scala’s emphasis on conciseness.
    To exemplify, here’s how to create a `Map`:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中创建集合很简单，这得益于Scala对简洁性的重视。为了举例说明，以下是如何创建一个`Map`：
- en: '[PRE72]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Several things are new in this line of code. First, it’s awesome that you can
    create a `Map` and associate a key with a value directly, using the syntax `->`.
    There’s no need to add elements manually, as in Java:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有几个新特点。首先，你可以直接使用语法`->`创建一个`Map`并将键与值关联起来，这是很酷的。与Java中手动添加元素不同，你不需要手动添加元素：
- en: '[PRE73]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You learned in [chapter 8](kindle_split_020.xhtml#ch08), however, that Java
    9 has a couple of factory methods, inspired by Scala, that can help you tidy this
    type of code:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你已经在[第8章](kindle_split_020.xhtml#ch08)中了解到，Java 9有几个受Scala启发的工厂方法，可以帮助你整理这类代码：
- en: '[PRE74]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The second new thing is that you can choose not to annotate the type of the
    variable `authorsToAge`. You could have explicitly written `val authorsToAge :
    Map[String, Int]`, but Scala can infer the type of the variable for you. (Note
    that the code is still checked statically. All variables have a given type at
    compile time.) We come back to this feature in [chapter 21](kindle_split_036.xhtml#ch21).
    Third, you use the `val` keyword instead of `var`. What’s the difference? The
    keyword `val` means that the variable is read-only and can’t be reassigned to
    (like `final` in Java). The `var` keyword means that the variable is read-write.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '第二个新特点是，你可以选择不注释变量`authorsToAge`的类型。你可以明确写出`val authorsToAge : Map[String,
    Int]`，但Scala可以为你推断变量的类型。（注意，代码仍然是静态检查的。所有变量在编译时都有一个给定的类型。）我们将在[第21章](kindle_split_036.xhtml#ch21)中回到这个特性。第三，你使用`val`关键字而不是`var`。有什么区别？关键字`val`表示变量是只读的，不能重新赋值（就像Java中的`final`一样）。关键字`var`表示变量是可读写的。'
- en: 'What about other collections? You can create a `List` (a singly linked list)
    or a `Set` (no duplicates) easily, as follows:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 那其他集合呢？你可以轻松创建一个`List`（单链表）或一个`Set`（无重复），如下所示：
- en: '[PRE75]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `authors` variable has three elements, and the `numbers` variable has five
    elements.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`authors`变量有三个元素，而`numbers`变量有五个元素。'
- en: Immutable vs. mutable
  id: totrans-475
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不可变与可变
- en: One important fact to keep in mind is that the collections you created previously
    are immutable by default, which means that they can’t be changed after they’re
    created. Immutability is useful because you know that accessing the collection
    at any point in your program always yields a collection with the same elements.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个重要事实是，你之前创建的集合默认是不可变的，这意味着创建后不能更改。不可变性很有用，因为你知道在程序的任何时刻访问集合都会得到具有相同元素的集合。
- en: 'How can you update an immutable collection in Scala? To come back to the terminology
    used in [chapter 19](kindle_split_034.xhtml#ch19), such collections in Scala are
    said to be *persistent*. Updating a collection produces a new collection that
    shares as much as possible with the previous version, which persists without being
    affected by changes (as we show in [figures 19.3](kindle_split_034.xhtml#ch19fig03)
    and [19.4](kindle_split_034.xhtml#ch19fig04)). As a consequence of this property,
    your code has fewer implicit data dependencies: there’s less confusion about which
    location in your code updates a collection (or any other shared data structure)
    and at what point in time.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何在 Scala 中更新不可变集合？回到 [第 19 章](kindle_split_034.xhtml#ch19) 中使用的术语，Scala 中的此类集合被称为
    *持久性*。更新集合会产生一个新的集合，尽可能多地与上一个版本共享，而不会受到更改的影响（如图 19.3 和 19.4 所示）。由于这个属性，你的代码具有更少的隐式数据依赖：关于代码中哪个位置更新集合（或任何其他共享数据结构）以及何时更新的混淆更少。
- en: 'The following example demonstrates this idea. Add an element to a `Set`:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了这个概念。向 `Set` 添加一个元素：
- en: '[PRE76]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1* Here, + is a method that adds 8 to the Set, creating a new Set object
    as a result.**'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在这里，+ 是一种将 8 添加到集合的方法，从而创建一个新的集合对象。**'
- en: '***2* (2, 5, 3, 8)**'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* (2, 5, 3, 8)**'
- en: '***3* (2, 5, 3)**'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* (2, 5, 3)**'
- en: In this example, the set of numbers isn’t modified. Instead, a new `Set` is
    created with an additional element.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，数字集合没有被修改。相反，创建了一个新的 `Set`，并添加了一个额外的元素。
- en: Note that Scala doesn’t force you to use immutable collections—only makes it
    easy to adopt immutability in your code. Also, mutable versions are available
    in the package `scala.collection.mutable`.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Scala 不会强迫你使用不可变集合——只是使你在代码中采用不可变性变得容易。此外，在 `scala.collection.mutable` 包中提供了可变版本的集合。
- en: '|  |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Unmodifiable vs. immutable**'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变与不可变**'
- en: 'Java provides several ways to create unmodifiable collections. In the following
    code, the variable `newNumbers` is a read-only view of the set `numbers`:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了多种创建不可变集合的方法。在以下代码中，变量 `newNumbers` 是集合 `numbers` 的只读视图：
- en: '[PRE77]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This code means that you won’t be able to add new elements through the `newNumbers`
    variable. But an unmodifiable collection is a wrapper over a modifiable collection,
    so you could still add elements by accessing the `numbers` variable.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码意味着你将无法通过 `newNumbers` 变量添加新元素。但是，不可变集合是可变集合的包装器，因此你可以通过访问 `numbers` 变量来添加元素。
- en: By contrast, immutable collections guarantee that nothing can change the collection,
    regardless of how many variables are pointing to it.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，不可变集合保证没有任何东西可以更改集合，无论指向它的变量有多少。
- en: 'We explained in [chapter 19](kindle_split_034.xhtml#ch19) how you could create
    a persistent data structure: an immutable data structure that preserves the previous
    version of itself when modified. Any modifications always produce a new updated
    structure.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 19 章](kindle_split_034.xhtml#ch19) 中解释了如何创建持久数据结构：在修改时保留其先前版本的不可变数据结构。任何修改都会产生一个新的更新结构。
- en: '|  |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Working with collections
  id: totrans-493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用集合
- en: 'Now that you’ve seen how to create collections, you need to know what you can
    do with them. Collections in Scala support operations similar to those in the
    Java `Stream` API. You may recognize `filter` and `map` in the following example
    and as illustrated in [figure 20.1](#ch20fig01):'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何创建集合，你需要知道你可以用它们做什么。Scala 中的集合支持类似于 Java `Stream` API 中的操作。你可能会在以下示例中认出
    `filter` 和 `map`，如图 20.1 所示：
- en: '[PRE78]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Figure 20.1\. Streamlike operations with Scala’s `List`
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 20.1\. Scala 的 `List` 的流式操作
- en: '![](Images/20fig01_alt.jpg)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/20fig01_alt.jpg)'
- en: 'Don’t worry about the first line, which transforms a file into a list of strings
    consisting of the lines in the file (similar to what `Files.readAllLines` provides
    in Java). The second line creates a pipeline of two operations:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心第一行，它将文件转换为包含文件中行的字符串列表（类似于 Java 中的 `Files.readAllLines` 提供的功能）。第二行创建了一个包含两个操作的管道：
- en: A `filter` operation that selects only the lines that have a length greater
    than 10
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `filter` 操作，只选择长度大于 10 的行
- en: A `map` operation that transforms these long lines to uppercase
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将长行转换为大写的 `map` 操作
- en: 'This code can be also written as follows:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也可以写成以下形式：
- en: '[PRE79]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: You use the infix notation as well as the underscore (`_)` character, which
    is a placeholder that’s positionally matched with any arguments. In this case,
    you can read `_.length()` as `l => l.length()`. In the functions passed to `filter`
    and `map`, the underscore is bound to the line parameter that is to be processed.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用中缀表示法以及下划线字符（`_`），它是一个占位符，与任何参数位置匹配。在这种情况下，你可以将 `_.length()` 读取为 `l => l.length()`。在传递给
    `filter` 和 `map` 的函数中，下划线绑定要处理的行参数。
- en: Many more useful operations are available in Scala’s collection API. We recommend
    taking a look at the Scala documentation to get an idea ([https://docs.scala-lang.org/overviews/collections/introduction.html](https://docs.scala-lang.org/overviews/collections/introduction.html)).
    Note that this API is slightly richer than the Streams API (including support
    for zipping operations, which let you combine elements of two lists), so you’ll
    definitely gain a few programming idioms by checking it out. These idioms may
    also make it into the Streams API in future versions of Java.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 的集合 API 中还有许多其他有用的操作。我们建议查看 Scala 文档以获得一些想法（[https://docs.scala-lang.org/overviews/collections/introduction.html](https://docs.scala-lang.org/overviews/collections/introduction.html)）。请注意，此
    API 比流的 API（包括支持解包操作，这允许你组合两个列表的元素）略丰富，因此查看它绝对会带来一些编程习惯。这些习惯也可能在未来版本的 Java 的 Streams
    API 中出现。
- en: 'Finally, remember that in Java, you can ask for a pipeline to be executed in
    parallel by calling `parallel` on a `Stream`. Scala has a similar trick. You need
    only use the `par` method:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，记住在 Java 中，你可以通过在 `Stream` 上调用 `parallel` 来请求并行执行管道。Scala 也有类似的技巧。你只需要使用
    `par` 方法：
- en: '[PRE80]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Tuples
  id: totrans-507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 元组
- en: 'This section looks at another feature that’s often painfully verbose in Java:
    tuples. You may want to use tuples to group people by name and phone number (here,
    simple pairs) without declaring an ad hoc new class and instantiating an object
    for it: `("Raoul", "+44 7700 700042")`, `("Alan", "+44 7700 700314")`, and so
    on.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节探讨了在 Java 中通常非常冗长的另一个特性：元组。你可能想使用元组来按姓名和电话号码（在这里是简单的对）分组人员，而不需要声明一个专门的新类并为它实例化一个对象：`("Raoul",
    "+44 7700 700042")`、`("Alan", "+44 7700 700314")`，等等。
- en: 'Unfortunately, Java doesn’t provide support for tuples, so you have to create
    your own data structure. Here’s a simple `Pair` class:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Java 不提供对元组的支持，所以你必须创建自己的数据结构。以下是一个简单的 `Pair` 类：
- en: '[PRE81]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Also, of course you need to instantiate pairs explicitly:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还需要显式地实例化对：
- en: '[PRE82]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Okay, but how about triplets and arbitrary-size tuples? Defining a new class
    for every tuple size is tedious and ultimately affects the readability and maintainability
    of your programs.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，但是三元组和任意大小的元组怎么办？为每个元组大小定义一个新的类既繁琐又最终会影响你程序的易读性和可维护性。
- en: 'Scala provides *tuple literals*, which allow you to create tuples through simple
    syntactic sugar with the normal mathematical notation, as follows:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 提供了 *元组字面量*，允许你通过简单的语法糖和正常的数学符号创建元组，如下所示：
- en: '[PRE83]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Scala supports arbitrary-size^([[2](#ch20fn02)]) tuples, so the following are
    possible:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 支持任意大小的^([[2](#ch20fn02)])元组，所以以下都是可能的：
- en: ²
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tuples have a limit of 22 elements.
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 元组最多有 22 个元素。
- en: '[PRE84]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '***1* A tuple of type (Int, String, String)**'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个类型为 (Int, String, String) 的元组**'
- en: '***2* A tuple of type (Int, Int, Int, Int, Int)**'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一个类型为 (Int, Int, Int, Int, Int) 的元组**'
- en: 'You can access the elements of the tuples by their positions by using the accessors
    `_1`, `_2` (starting at 1), as in this example:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用访问器 `_1`、`_2`（从 1 开始）来通过位置访问元组的元素，就像这个例子一样：
- en: '[PRE85]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1* Prints 2018**'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 2018**'
- en: '***2* Prints 3**'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 3**'
- en: Isn’t that example much nicer than what you’d have to write in Java? The good
    news is that there are discussions about introducing tuple literals in future
    versions of Java. (See [chapter 21](kindle_split_036.xhtml#ch21) for more discussion
    of possible new features in Java.)
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 难道这个例子不像你在 Java 中需要写的那么好吗？好消息是，关于在 Java 的未来版本中引入元组字面量的讨论正在进行。（有关 Java 中可能的新功能的更多讨论，请参阅[第
    21 章](kindle_split_036.xhtml#ch21)）
- en: Stream
  id: totrans-528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 流
- en: The collections that we’ve described so far—`List`, `Set`, `Map`, and `Tuple`—are
    all evaluated eagerly (that is, immediately). By now, you know that streams in
    Java are evaluated on demand (that is, lazily). You saw in [chapter 5](kindle_split_016.xhtml#ch05)
    that because of this property, streams can represent an infinite sequence without
    overflowing memory.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止所描述的集合——`List`、`Set`、`Map` 和 `Tuple`——都是立即评估的（即立即）。到现在为止，你知道 Java 中的流是按需评估的（即惰性）。你在
    [第 5 章](kindle_split_016.xhtml#ch05) 中看到，由于这个特性，流可以表示一个无限序列而不会溢出内存。
- en: Scala also provides a corresponding lazily evaluated data structure called `Stream`.
    But `Stream`s in Scala provide more features than those in Java. `Stream`s in
    Scala remember values that were computed so that previous elements can be accessed.
    In addition, `Stream`s are indexed so that elements can be accessed by an index,
    like a list. Note that the trade-off for these additional properties is the fact
    that `Stream`s are less memory-efficient compared with Java’s `Stream`s, because
    being able to refer to previous elements means that the elements need to be remembered
    (cached).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 还提供了一个相应的惰性评估数据结构，称为 `Stream`。但 Scala 中的 `Stream` 提供的功能比 Java 中的更多。Scala
    中的 `Stream` 会记住计算过的值，以便可以访问前面的元素。此外，`Stream` 是索引的，因此可以通过索引访问元素，就像列表一样。请注意，这些额外属性的权衡是
    `Stream` 相比 Java 的 `Stream` 在内存效率上更低，因为能够引用前面的元素意味着元素需要被记住（缓存）。
- en: Option
  id: totrans-531
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Option
- en: Another data structure that you’ll be familiar with is `Option`—Scala’s version
    of Java’s `Optional`, which we discussed in [chapter 11](kindle_split_024.xhtml#ch11).
    We argued that you should use `Optional` when possible to design better APIs,
    in which by reading the signature of a method, users can tell whether they can
    expect an optional value. You should use this data structure instead of `null`
    whenever possible to prevent `null`-pointer exceptions.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会熟悉另一种数据结构 `Option`——Scala 对 Java 的 `Optional` 的实现，我们已在 [第 11 章](kindle_split_024.xhtml#ch11)
    中讨论过。我们曾论证，在可能的情况下，你应该使用 `Optional` 来设计更好的 API，这样用户通过阅读方法的签名就可以知道他们是否可以期待一个可选值。在可能的情况下，你应该使用这种数据结构而不是
    `null` 来防止 `null`-pointer 异常。
- en: 'You saw in [chapter 11](kindle_split_024.xhtml#ch11) that you can use `Optional`
    to return the name of a person’s insurance if the person’s age is greater than
    some minimum age, as follows:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 [第 11 章](kindle_split_024.xhtml#ch11) 中看到，你可以使用 `Optional` 来返回一个大于某个最小年龄的人的保险名称，如下所示：
- en: '[PRE86]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In Scala, you can use `Option` in a way similar to `Optional`:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，你可以像使用 `Optional` 一样使用 `Option`：
- en: '[PRE87]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: You can recognize the same structure and method names apart from `getOrElse`,
    which is the equivalent of `orElse` in Java. You see, throughout this book, you’ve
    learned new concepts that you can apply directly to other programming languages!
    Unfortunately, `null` also exists in Scala for Java compatibility reasons, but
    its use is highly discouraged.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以识别出相同的结构和除了 `getOrElse` 之外的方法名称，`getOrElse` 是 Java 中的 `orElse` 的等价物。你看，在这本书的整个过程中，你已经学习了可以直接应用于其他编程语言的新概念！不幸的是，由于与
    Java 的兼容性原因，Scala 中也存在 `null`，但其使用被高度不建议。
- en: 20.2\. Functions
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.2. 函数
- en: Scala functions can be viewed as being sequences of instructions that are grouped
    to perform a task. These functions are useful for abstracting behavior and are
    the cornerstone of functional programming.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 函数可以被视为执行任务的指令序列。这些函数对于抽象行为非常有用，并且是函数式编程的基石。
- en: 'In Java, you’re familiar with *methods*: functions associated with a class.
    You’ve also seen lambda expressions, which can be considered to be anonymous functions.
    Scala offers a richer set of features to support functions than Java does, and
    we look at those features in this section. Scala provides the following:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，你熟悉 *方法*：与类关联的函数。你也看到了 lambda 表达式，可以被认为是匿名函数。Scala 提供了比 Java 更丰富的功能来支持函数，我们将在本节中探讨这些功能。Scala
    提供以下功能：
- en: '*Function types*—syntactic sugar that represents the idea of Java function
    descriptors (that is, notations that represent the signature of the abstract method
    declared in a functional interface), which we described in [chapter 3](kindle_split_013.xhtml#ch03)'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数类型*——表示 Java 函数描述符（即表示在函数式接口中声明的抽象方法的签名）的语法糖，我们在 [第 3 章](kindle_split_013.xhtml#ch03)
    中描述过'
- en: Anonymous functions that don’t have the no-writing restriction on nonlocal variables
    that Java’s lambda expressions have
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有对非局部变量进行写入限制的匿名函数，这是 Java 的 lambda 表达式所不具备的
- en: Support for *currying*, which means breaking a function that takes multiple
    arguments into a series of functions, each of which takes some of the arguments
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 *柯里化*，这意味着将接受多个参数的函数分解为一系列函数，每个函数接受一些参数
- en: 20.2.1\. First-class functions in Scala
  id: totrans-544
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.2.1\. 首类函数在 Scala 中
- en: Functions in Scala are *first-class values*, which means that they can be passed
    around as parameters, returned as a result, and stored in variables, like values
    such as `Integer` and `String`. As we’ve shown you in earlier chapters, method
    references and lambda expressions in Java can also be seen as first-class functions.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 中的函数是 *首类值*，这意味着它们可以作为参数传递，作为结果返回，并存储在变量中，就像 `Integer` 和 `String` 这样的值一样。正如我们在前面的章节中向您展示的那样，Java
    中的方法引用和 lambda 表达式也可以看作是首类函数。
- en: 'Here’s an example of how first-class functions work in Scala. Suppose that
    you have a list of strings representing tweets you’ve received. You’d like to
    filter this list with different criteria, such as tweets that mention the word
    *Java* or tweets of a certain short length. You can represent these two criteria
    as *predicates* (functions that return a `Boolean`):'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 Scala 中首类函数如何工作的示例。假设你有一个表示你收到的推文的字符串列表。你想要根据不同的标准过滤这个列表，比如提到单词 *Java*
    的推文或特定短长度的推文。你可以将这些两个标准表示为 *谓词*（返回 `Boolean` 的函数）：
- en: '[PRE88]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In Scala, you can pass these methods directly to the built-in `filter` as follows
    (as you can pass them by using method references in Java):'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，你可以直接将这些方法传递给内置的 `filter`，如下所示（正如你可以在 Java 中使用方法引用传递它们一样）：
- en: '[PRE89]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now inspect the signature of the built-in method `filter`:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查内置方法 `filter` 的签名：
- en: '[PRE90]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: You may wonder what the type of the parameter `p` means (here, `(T) => Boolean`),
    because in Java, you’d expect a functional interface. This Scala syntax isn’t
    (yet) available in Java, but it describes a *function type*. Here, the type represents
    a function that takes an object of type `T` and returns a `Boolean`. In Java,
    this type is expressed as a `Predicate<T>` or `Function<T, Boolean>`, which has
    the same signature as the `isJavaMentioned` and `isShortTweet` methods, so you
    can pass them as arguments to `filter`. The designers of the Java language decided
    not to introduce similar syntax for function types to keep the language consistent
    with previous versions. (Introducing too much new syntax in a new version of the
    language is viewed as adding too much cognitive overhead.)
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道参数 `p` 的类型 `(T) => Boolean` 是什么意思，因为在 Java 中，你可能会期望一个函数式接口。这种 Scala 语法（目前）在
    Java 中不可用，但它描述了一种 *函数类型*。在这里，该类型表示一个接受类型 `T` 的对象并返回 `Boolean` 的函数。在 Java 中，这种类型可以表示为
    `Predicate<T>` 或 `Function<T, Boolean>`，它与 `isJavaMentioned` 和 `isShortTweet`
    方法的签名相同，因此你可以将它们作为 `filter` 的参数传递。Java 语言的开发者决定不引入类似语法来保持语言与先前版本的一致性。（在语言的新版本中引入过多的新语法被视为增加了过多的认知负担。）
- en: 20.2.2\. Anonymous functions and closures
  id: totrans-553
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.2.2\. 匿名函数和闭包
- en: 'Scala also supports anonymous functions, which have syntax similar to that
    of lambda expressions. In the following example, you can assign to a variable
    named `isLong-Tweet` an anonymous function that checks whether a given tweet is
    long:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 也支持匿名函数，其语法与 lambda 表达式类似。在下面的示例中，你可以将一个匿名函数赋值给名为 `isLong-Tweet` 的变量，该函数检查给定的推文是否很长：
- en: '[PRE91]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '***1* A variable of function type String to Boolean**'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个从 String 到 Boolean 的函数类型变量**'
- en: '***2* An anonymous function**'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一个匿名函数**'
- en: 'In Java, a lambda expression lets you create an instance of a functional interface.
    Scala has a similar mechanism. The preceding code is syntactic sugar for declaring
    an anonymous class of type `scala.Function1` (a function of one parameter), which
    provides the implementation of the method `apply`:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，lambda 表达式允许你创建一个函数式接口的实例。Scala 有一个类似的机制。前面的代码是声明一个类型为 `scala.Function1`
    的匿名类（一个单参数函数）的语法糖，它提供了 `apply` 方法的实现：
- en: '[PRE92]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Because the variable `isLongTweet` holds an object of type `Function1`, you
    can call the method `apply`, which can be seen as calling the function:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 因为变量 `isLongTweet` 存储了一个 `Function1` 类型的对象，所以你可以调用 `apply` 方法，这可以看作是调用函数：
- en: '[PRE93]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '***1* Returns false**'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回 false**'
- en: 'In Java, you could do the following:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，你可以这样做：
- en: '[PRE94]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'To allow you to use lambda expressions, Java provides several built-in functional
    interfaces such as `Predicate`, `Function`, and `Consumer`. Scala provides traits
    (you can think of traits as being interfaces for now) to achieve the same thing:
    `Function0` (a function with 0 parameters and a return result) up to `Function22`
    (a function with 22 parameters), all of which define the method `apply`.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你可以使用lambda表达式，Java提供了几个内置的函数式接口，如`Predicate`、`Function`和`Consumer`。Scala提供特质（你现在可以将其视为接口）来实现相同的功能：从`Function0`（具有0个参数和返回结果的函数）到`Function22`（具有22个参数的函数），所有这些都定义了`apply`方法。
- en: 'Another cool trick in Scala allows you to implicitly call the `apply` method
    by using syntactic sugar that looks more like a function call:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中另一个酷炫的技巧允许你通过类似于函数调用的语法糖隐式调用`apply`方法：
- en: '[PRE95]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '***1* Returns false**'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回false**'
- en: The compiler automatically converts a call `f(a)` to `f.apply(a)` and, more
    generally, a call `f(a1, ..., an)` to `f.apply(a1, ..., an)`, if `f` is an object
    that supports the `apply` method. (Note that `apply` can have any number of arguments.)
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器自动将调用`f(a)`转换为`f.apply(a)`，更一般地，将调用`f(a1, ..., an)`转换为`f.apply(a1, ..., an)`，如果`f`是一个支持`apply`方法的对象。（注意，`apply`可以有任意数量的参数。）
- en: Closures
  id: totrans-570
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 闭包
- en: 'In [chapter 3](kindle_split_013.xhtml#ch03), we commented on whether lambda
    expressions in Java constitute closures. A *closure* is an instance of a function
    that can reference nonlocal variables of that function with no restrictions. But
    lambda expressions in Java have a restriction: they can’t modify the content of
    local variables of a method in which the lambda is defined. Those variables have
    to be implicitly `final`. It helps to think that lambdas close over values, rather
    than variables.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](kindle_split_013.xhtml#ch03)中，我们讨论了Java中的lambda表达式是否构成闭包。**闭包**是函数的一个实例，它可以无限制地引用该函数的非局部变量。但是Java中的lambda表达式有一个限制：它们不能修改lambda定义的方法中局部变量的内容。这些变量必须隐式地声明为`final`。有助于思考的是，lambda表达式是封闭在值上，而不是变量上。
- en: 'By contrast, anonymous functions in Scala can capture variables themselves,
    not the *values* to which the variables currently refer. The following is possible
    in Scala:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Scala中的匿名函数可以捕获变量本身，而不是变量当前所引用的**值**。在Scala中以下情况是可能的：
- en: '[PRE96]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '***1* A closure capturing and incrementing count**'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 捕获并增加计数的闭包**'
- en: '***2* Prints 1**'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印1**'
- en: '***3* Prints 2**'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印2**'
- en: 'But in Java, the following results in a compiler error because `count` is implicitly
    forced to be `final`:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 但在Java中，以下结果会导致编译器错误，因为`count`被隐式地强制为`final`：
- en: '[PRE97]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '***1* Error: Count must be final or effectively final.**'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 错误：计数必须是final或实际上是final的。**'
- en: We argued in [chapters 7](kindle_split_018.xhtml#ch07), [18](kindle_split_033.xhtml#ch18),
    and [19](kindle_split_034.xhtml#ch19) that you should avoid mutation whenever
    possible to make your programs easier to maintain and parallelizable, so use this
    feature only when strictly necessary.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](kindle_split_018.xhtml#ch07)、[第18章](kindle_split_033.xhtml#ch18)和[第19章](kindle_split_034.xhtml#ch19)中争论说，你应该尽可能避免修改，以使你的程序更容易维护和并行化，因此仅在绝对必要时使用此功能。
- en: 20.2.3\. Currying
  id: totrans-581
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.2.3\. 柯里化
- en: In [chapter 19](kindle_split_034.xhtml#ch19), we described a technique called
    *currying*, in which a function `f` of two arguments (`x` and `y`, say) is seen
    instead as a function `g` of one argument, which returns a function also of one
    argument. This definition can be generalized to functions with multiple arguments,
    producing multiple functions of one argument. In other words, you can break down
    a function that takes multiple arguments into a series of functions, each of which
    takes a subset of the arguments. Scala provides a construct that makes it easy
    to curry an existing function.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第19章](kindle_split_034.xhtml#ch19)中，我们描述了一种称为**柯里化**的技术，其中两个参数（例如`x`和`y`）的函数`f`被视为一个参数的函数`g`，它返回一个也是参数为单个参数的函数。这个定义可以推广到具有多个参数的函数，产生多个参数为单个参数的函数。换句话说，你可以将接受多个参数的函数分解为一系列函数，每个函数接受参数的子集。Scala提供了一个构造，使得可以轻松地对现有函数进行柯里化。
- en: 'To understand what Scala brings to the table, first revisit an example in Java.
    You can define a simple method to multiply two integers:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Scala带来了什么，首先回顾一下Java中的一个示例。你可以定义一个简单的乘法方法来乘以两个整数：
- en: '[PRE98]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'But this definition requires all the arguments to be passed to it. You can
    break down the `multiply` method manually by making it return another function:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个定义要求将所有参数传递给它。你可以通过使其返回另一个函数来手动分解`multiply`方法：
- en: '[PRE99]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The function returned by `multiplyCurry` captures the value of `x` and multiplies
    it by its argument `y`, returning an `Integer`. As a result, you can use `multiplyCurry`
    as follows in a `map` to multiply each element by 2:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 由`multiplyCurry`返回的函数捕获`x`的值并将其与它的参数`y`相乘，返回一个`Integer`。因此，你可以在`map`中使用`multiplyCurry`来将每个元素乘以2：
- en: '[PRE100]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This code produces the result 2, 6, 10, 14\. This code works because `map` expects
    a `Function` as argument and `multiplyCurry` returns a `Function`.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生结果2，6，10，14。这段代码之所以能工作，是因为`map`期望一个`Function`作为参数，而`multiplyCurry`返回一个`Function`。
- en: 'It’s a bit tedious in Java to split up a function manually to create a curried
    form, especially if the function has multiple arguments. Scala has a special syntax
    that performs this automatically. You can define the normal `multiply` method
    as follows:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中手动拆分函数以创建curried形式有点繁琐，尤其是当函数有多个参数时。Scala有一种特殊的语法可以自动执行这个操作。你可以定义一个普通的`multiply`方法如下：
- en: '[PRE101]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'And here is the curried form:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是curried形式的例子：
- en: '[PRE102]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '***1* Defining a curried function**'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义curried函数**'
- en: '***2* Invoking a curried function**'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用curried函数**'
- en: 'When you use the `(x: Int)(y: Int)` syntax, the `multiplyCurry` method takes
    *two* argument lists of one `Int` parameter. By contrast, `multiply` takes *one
    list* of two `Int` parameters. What happens when you call `multiplyCurry`? The
    first invocation of `multiplyCurry` with a single `Int` (the parameter `x`), `multiplyCurry(2)`,
    returns another function that takes a parameter `y` and multiplies it by the captured
    value of `x` (here, the value 2). We say that this function is *partially applied*
    as explained in [chapter 19](kindle_split_034.xhtml#ch19), because not all arguments
    are provided. The second invocation multiplies `x` and `y`. You can store the
    first invocation to `multiplyCurry` inside a variable and reuse it, as follows:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '当你使用`(x: Int)(y: Int)`语法时，`multiplyCurry`方法接受两个参数列表，每个列表有一个`Int`参数。相比之下，`multiply`接受一个包含两个`Int`参数的参数列表。当你调用`multiplyCurry`时会发生什么？`multiplyCurry`的第一个调用使用单个`Int`（参数`x`），即`multiplyCurry(2)`，返回另一个函数，该函数接受一个参数`y`并将其与捕获的`x`的值（在这里是值2）相乘。我们说这个函数是*部分应用*的，如第19章中解释的那样，因为不是所有参数都提供了。第二次调用将`x`和`y`相乘。你可以将第一次调用`multiplyCurry`存储在一个变量中并重用它，如下所示：'
- en: '[PRE103]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '***1* 20**'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 20**'
- en: By comparison with Java, in Scala you don’t need to provide the curried form
    of a function manually, as in the preceding example. Scala provides a convenient
    function-definition syntax to indicate that a function has multiple curried argument
    lists.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java相比，在Scala中，你不需要像上一个例子那样手动提供函数的curried形式。Scala提供了一个方便的函数定义语法，用来表示一个函数有多个curried参数列表。
- en: 20.3\. Classes and traits
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.3\. 类和特质
- en: In this section, we look at how classes and interfaces in Java compare with
    those in Scala. These two constructs are paramount to design applications. You’ll
    see that Scala’s classes and interfaces can provide more flexibility than those
    in Java.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们来看Java中的类和接口与Scala中的类和接口如何比较。这两个构造是设计应用程序的关键。你会发现Scala的类和接口可以提供比Java更多的灵活性。
- en: 20.3.1\. Less verbosity with Scala classes
  id: totrans-602
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.3.1\. Scala类减少冗余
- en: 'Because Scala is a full object-oriented language, you can create classes and
    instantiate them to produce objects. In its most basic form, the syntax to declare
    and instantiate classes is similar to that of Java. Here’s how to declare a `Hello`
    class:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Scala是一种完全面向对象的语言，所以你可以创建类并实例化它们来生成对象。在其最基本的形式中，声明和实例化类的语法与Java相似。下面是如何声明一个`Hello`类的示例：
- en: '[PRE104]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Getters and setters
  id: totrans-605
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Getter和setter
- en: 'Scala becomes more interesting when you have a class with fields. Have you
    ever come across a Java class that purely defines a list of fields and had to
    declare a long list of getters, setters, and an appropriate constructor? What
    a pain! In addition, you often see tests for the implementation of each method.
    A large amount of code typically is devoted to such classes in Enterprise Java
    applications. Consider this simple `Student` class:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个带有字段的类时，Scala变得更加有趣。你是否遇到过只定义了一组字段而没有声明长列表的getter、setter和适当构造函数的Java类？多么痛苦！此外，你经常看到对每个方法实现的测试。在企业Java应用程序中，通常会有大量代码用于此类。考虑这个简单的`Student`类：
- en: '[PRE105]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: You have to manually define the constructor that initializes all fields, two
    getters, and two setters. A simple class now has more than 20 lines of code. Several
    IDEs (integrated development environments) and tools can help you generate this
    code, but your code base still has to deal with a large amount of additional code
    that’s not too useful compared with real business logic.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须手动定义一个构造函数来初始化所有字段，两个getter和两个setter。一个简单的类现在有超过20行代码。几个IDE（集成开发环境）和工具可以帮助你生成此代码，但你的代码库仍然必须处理与实际业务逻辑相比不太有用的大量额外代码。
- en: 'In Scala, constructors, getters, and setters can be generated implicitly, which
    results in code with less verbosity:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，构造函数、getter和setter可以隐式生成，这导致代码更加简洁：
- en: '[PRE106]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '***1* Initialize a Student object.**'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 初始化一个Student对象。**'
- en: '***2* Get the name and print Raoul.**'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取名称并打印Raoul。**'
- en: '***3* Set the id.**'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 设置id。**'
- en: '***4* Print 1337.**'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印1337。**'
- en: In Java, you could get similar behavior by defining public fields, but you’d
    still have to define the constructor explicitly. Scala classes save you boilerplate
    code.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，你可以通过定义公共字段来获得类似的行为，但你仍然需要显式地定义构造函数。Scala类可以为你节省样板代码。
- en: 20.3.2\. Scala traits vs. Java interfaces
  id: totrans-616
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 20.3.2\. Scala特质与Java接口
- en: Scala has another useful feature for abstraction, called traits, which are Scala’s
    replacement for Java’s interfaces. A trait can define both abstract methods and
    methods with a default implementation. Traits can also be multiply inherited like
    interfaces in Java, so you can see them as being similar to Java interfaces that
    support default methods. Traits can also contain fields such as abstract classes,
    which Java interfaces don’t support. Are traits like abstract classes? No, because
    unlike abstract classes, traits can be multiply inherited. Java has always had
    multiple inheritance of types because a class can implement multiple interfaces.
    Java 8, through default methods, introduced multiple inheritance of behaviors
    but still doesn’t allow multiple inheritance of state—something permitted by Scala
    traits.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: Scala还有一个用于抽象的有用特性，称为特质，它是Scala对Java接口的替代。特质可以定义抽象方法和具有默认实现的方法。特质也可以像Java中的接口一样多重继承，因此你可以将它们视为类似于支持默认方法的Java接口。特质还可以包含字段，如抽象类，这是Java接口不支持的功能。特质像抽象类吗？不，因为与抽象类不同，特质可以多重继承。Java始终具有类型的多重继承，因为一个类可以实现多个接口。Java
    8通过默认方法引入了行为的多重继承，但仍然不允许状态的多重继承——这是Scala特质允许的。
- en: 'To see what a trait looks like in Scala, define a trait called `Sized` that
    contains one mutable field called `size` and one method called `isEmpty` with
    a default implementation:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Scala中看到特质的样子，定义一个名为`Sized`的特质，其中包含一个名为`size`的可变字段和一个名为`isEmpty`的方法，具有默认实现：
- en: '[PRE107]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '***1* A field called size**'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个名为“大小”的字段**'
- en: '***2* A method called isEmpty with a default implementation**'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一个具有默认实现的方法isEmpty**'
- en: 'You can compose this code at declaration time with a class, such as an `Empty`
    class that always has size 0:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在声明时与一个类组合此代码，例如一个始终具有大小0的`Empty`类：
- en: '[PRE108]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '***1* A class inheriting from the trait Sized**'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从特质Sized继承的类**'
- en: '***2* Prints true**'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印true**'
- en: 'Interestingly, compared with Java interfaces, traits can be composed at object
    instantiation time (but this operation is still a compile-time operation). You
    can create a `Box` class and decide that one specific instance should support
    the operations defined by the trait `Sized`, as follows:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，与Java接口相比，特质可以在对象实例化时进行组合（但这个操作仍然是一个编译时操作）。你可以创建一个`Box`类，并决定一个特定的实例应该支持由特质`Sized`定义的操作，如下所示：
- en: '[PRE109]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '***1* Composing the trait at object instantiation time**'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在对象实例化时组合特质**'
- en: '***2* Prints true**'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印true**'
- en: '***3* Compile error: The Box class declaration doesn’t inherit from Sized.**'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 编译错误：Box类声明没有从Sized继承。**'
- en: What happens if multiple traits are inherited, declaring methods with the same
    signatures or fields with the same names? Scala provides restriction rules similar
    to those that apply to default methods ([chapter 13](kindle_split_026.xhtml#ch13)).
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 如果继承了多个特质，声明具有相同签名的方法或具有相同名称的字段会发生什么？Scala提供了类似于应用于默认方法的限制规则（[第13章](kindle_split_026.xhtml#ch13)）。
- en: Summary
  id: totrans-632
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Java and Scala combine object-oriented and functional-programming features into
    one programming language; both run on the JVM and to a large extent can interoperate.
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java和Scala将面向对象和函数式编程特性结合到一个编程语言中；两者都运行在JVM上，并且在很大程度上可以互操作。
- en: Scala supports collection abstractions similar to those in Java—`List`, `Set`,
    `Map`, `Stream`, `Option`—but also supports tuples.
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 支持类似于 Java 中的集合抽象，如 `List`、`Set`、`Map`、`Stream`、`Option`，但也支持元组。
- en: Scala provides richer features that support more functions than Java does. These
    features include function types, closures that have no restrictions on accessing
    local variables, and built-in currying forms.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 提供了比 Java 更丰富的功能，支持比 Java 更多的函数。这些功能包括函数类型、无限制访问局部变量的闭包，以及内置的柯里化形式。
- en: Classes in Scala can provide implicit constructors, getters, and setters.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 中的类可以提供隐式构造函数、获取器和设置器。
- en: Scala supports traits, which are interfaces that can include fields and default
    methods.
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 支持特质，这些特质是包含字段和默认方法的接口。
- en: Chapter 21\. Conclusions and where next for Java
  id: totrans-638
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 21 章。结论和 Java 的未来方向
- en: '*This chapter covers*'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: The new Java 8 features and their evolutionary effect on programming style
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 Java 8 特性及其对编程风格的影响
- en: The new Java 9 module system
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 Java 9 模块系统
- en: The new six-monthly Java incremental-release life cycle
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的每六个月一次的 Java 增量发布生命周期
- en: The first incremental release forming Java 10
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构成 Java 10 的第一个增量发布
- en: A few ideas that you’ll likely see implemented in some future version of Java
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些你可能会在 Java 的未来版本中看到的实现想法
- en: We’ve covered a lot of material in this book, and we hope that you feel that
    you’re ready to start using the new Java 8 and 9 features in your own code, perhaps
    building on our examples and quizzes. In this chapter, we review the journey of
    learning about Java 8 and the gentle push toward functional-style programming,
    as well as the advantages of the new modularization capability and other minor
    improvements introduced with Java 9\. You also learn about what is included in
    Java 10\. In addition, we speculate on what future enhancements and great new
    features may be in Java’s pipeline beyond Java 9, 10, 11, and 12.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们涵盖了大量的内容，我们希望你觉得你已经准备好开始在自己的代码中使用新的 Java 8 和 9 特性，也许是在我们的示例和测验的基础上。在本章中，我们回顾了学习
    Java 8 的旅程，以及向函数式编程风格的温和推动，以及 Java 9 引入的新模块化能力和其他一些改进的优势。你还了解了 Java 10 中包含的内容。此外，我们还推测了在
    Java 9、10、11 和 12 之后的未来增强和新特性可能是什么。
- en: 21.1\. Review of Java 8 features
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.1. Java 8 特性回顾
- en: 'A good way to help you understand Java 8 as a practical, useful language is
    to revisit the features in turn. Instead of simply listing them, we’d like to
    present them as being interlinked to help you understand them not only as a set
    of features, but also as a high-level overview of the coherent language design
    that is Java 8\. Our other aim in this review chapter is to emphasize how most
    of the new features in Java 8 are facilitating functional-style programming in
    Java. Remember, supporting function programming wasn’t a capricious design choice
    but a conscious design strategy centered on two trends, which we regard as climate
    change in the model from [chapter 1](kindle_split_011.xhtml#ch01):'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 要帮助你理解 Java 8 作为一种实用、有用的语言的好方法，就是依次回顾其特性。我们不想只是简单地列出它们，而是希望将它们呈现为相互关联，以便你不仅能够理解它们作为一组特性，还能理解它们是
    Java 8 高级语言设计的整体概述。在本章的另一个目标中，我们强调大多数 Java 8 的新特性是如何促进 Java 中函数式编程的。记住，支持函数式编程并不是一个任性的设计选择，而是一种以两个趋势为中心的有意识的设计策略，我们将它们视为模型中的气候变化，这两个趋势在[第
    1 章](kindle_split_011.xhtml#ch01)中有所描述：
- en: The increasing need to exploit the power of multicore processors now that, for
    silicon technology reasons, the additional transistors annually provided by Moore’s
    law no longer translate into higher clock speeds of individual CPU cores. Put
    simply, making your code run faster requires parallel code.
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于硅技术的原因，摩尔定律每年提供的额外晶体管不再转化为单个 CPU 核心的更高时钟速度，现在需要利用多核处理器的强大功能。简单来说，让你的代码运行得更快需要并行代码。
- en: The increasing tendency to concisely manipulate collections of data with a declarative
    style for processing data, such as taking some data source, extracting all data
    that matches a given criterion, and applying some operation to the result (summarizing
    it or making a collection of the result for further processing later). This style
    is associated with the use of immutable objects and collections, which are then
    processed to produce further immutable values.
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 越来越倾向于使用声明性风格简洁地处理数据集合，例如，从某些数据源中提取所有符合给定标准的数据，并对结果应用某些操作（总结它或创建一个结果集合以供后续处理）。这种风格与使用不可变对象和集合相关联，然后对这些对象和集合进行处理，以产生进一步的不变值。
- en: Neither motivation is effectively supported by the traditional, object-oriented,
    imperative approach, which centers on mutating fields and applying iterators.
    Mutating data on one core and reading it from another is surprisingly expensive,
    not to mention that it introduces the need for error-prone locking. Similarly,
    when you’re focused on iterating over and mutating existing objects, the stream-like
    programming idiom can feel alien. But these two trends are supported by ideas
    from functional programming, which explains why the Java 8 center of gravity has
    moved a bit from what you’ve come to expect from Java.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是哪种动机，传统的面向对象、命令式方法都无法有效支持。这种方法以修改字段和应用迭代器为中心。在一个核心上修改数据，然后在另一个核心上读取它，其成本出奇地高，更不用说它还引入了易出错的锁定需求。同样，当你专注于迭代和修改现有对象时，流式编程习惯可能会感觉陌生。但这两个趋势得到了函数式编程思想的支撑，这也解释了为什么Java
    8的中心力从你从Java中期待的方向有所偏移。
- en: This chapter reviews, in a big-picture unifying view, what you’ve learned from
    this book and shows you how everything fits together in the new climate.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从宏观统一的角度回顾了你在本书中学到的内容，并展示了在新环境下一切是如何相互融合的。
- en: 21.1.1\. Behavior parameterization (lambdas and method references)
  id: totrans-652
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 21.1.1\. 行为参数化（lambda和方法引用）
- en: To write a reusable method such as `filter`, you need to specify as its argument
    a description of the filtering criterion. Although Java experts could achieve
    this task in earlier versions of Java by wrapping the filtering criterion as a
    method inside a class and passing an instance of that class, this solution was
    unsuitable for general use because it was too cumbersome to write and maintain.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个可重用的方法，如`filter`，你需要指定其参数为过滤标准的描述。尽管Java专家可以在Java的早期版本中通过将过滤标准包装为类内的方法并传递该类的实例来完成这项任务，但这种解决方案不适合通用使用，因为它编写和维护起来过于繁琐。
- en: 'As you discovered in [chapters 2](kindle_split_012.xhtml#ch02) and [3](kindle_split_013.xhtml#ch03),
    Java 8 provides a way, borrowed from functional programming, to pass a piece of
    code to a method. Java conveniently provides two variants:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第2章和第3章中发现的那样，Java 8提供了一种从函数式编程中借用来的方法，可以将一段代码传递给方法。Java方便地提供了两种变体：
- en: Passing a lambda (a one-off piece of code) such as
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个lambda（一段一次性代码），例如
- en: '[PRE110]'
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Passing a *method reference* to an existing method, such as `Apple::isHeavy`
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个*方法引用*到现有方法，例如`Apple::isHeavy`
- en: These values have types such as `Function<T, R>`, `Predicate<T>`, and `BiFunction<T,
    U, R>`, and the recipient can execute them by using the methods `apply`, `test`,
    and so on. These types are called functional interfaces and have a single abstract
    method, as you learned in [chapter 3](kindle_split_013.xhtml#ch03). Of themselves,
    lambdas can seem to be rather a niche concept, but the way that Java 8 uses them
    in much of the new Streams API propels them to the center of Java.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值具有`Function<T, R>`、`Predicate<T>`和`BiFunction<T, U, R>`等类型，接收者可以通过使用`apply`、`test`等方法来执行它们。这些类型被称为函数式接口，并且有一个抽象方法，正如你在第3章中学到的。lambda本身可能看起来是一个相当狭窄的概念，但Java
    8在许多新的Streams API中使用它们的方式，使它们成为了Java的中心。
- en: 21.1.2\. Streams
  id: totrans-659
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 21.1.2\. 流
- en: The collection classes in Java, along with iterators and the `for-each` construct,
    have served programmers honorably for a long time. It would have been easy for
    the Java 8 designers to add methods such as `filter` and `map` to collections,
    exploiting lambdas to express database-like queries. Instead, the designers they
    added a new Streams API, which is the subject of [chapters 4](kindle_split_015.xhtml#ch04)–[7](kindle_split_018.xhtml#ch07),
    and it’s worth pausing to consider why.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的集合类，连同迭代器和`for-each`构造，长期以来一直为程序员提供了荣誉服务。Java 8的设计师们本可以轻松地将`filter`和`map`等方法添加到集合中，利用lambda表达式来表示类似数据库的查询。然而，他们添加了一个新的Streams
    API，这是第4章到第7章的主题，值得我们停下来思考一下原因。
- en: 'What’s wrong with `Collection`s that requires them to be replaced or augmented
    by a similar notion of `Stream`s? We’ll summarize this way: if you have a large
    collection and apply three operations to it (perhaps mapping the objects in the
    collection to sum two of their fields, filtering the sums that satisfy some criterion,
    and sorting the result), you make three separate traversals of the collection.
    Instead, the Streams API lazily forms these operations into a pipeline and does
    a single stream traversal performing all the operations together. This process
    is much more efficient for large datasets, and for reasons such as memory caches,
    the larger the dataset, the more important it is to minimize the number of traversals.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection`s有什么问题需要它们被类似`Stream`s的概念所取代或增强？我们可以这样总结：如果你有一个大集合，并且对其应用三个操作（可能将集合中的对象映射到求两个字段的和，过滤满足某些标准的和，然后对结果进行排序），你将对集合进行三次单独的遍历。相反，Streams
    API会懒惰地将这些操作组合成一个管道，并执行一次流遍历，完成所有操作。这个过程对于大数据集来说效率更高，并且由于内存缓存等原因，数据集越大，最小化遍历次数就越重要。'
- en: The other, no less important, reason concerns processing elements in parallel,
    which is vital to the efficient exploitation of multicore CPUs. Streams, and in
    particular the `parallel` method, allow a stream to be marked as suitable for
    parallel processing. Recall that parallelism and mutable state fit badly together,
    so core functional concepts (side-effect-free operations and methods parameterized
    with lambdas and method references that permit internal iteration instead of external
    iteration, as discussed in [chapter 4](kindle_split_015.xhtml#ch04)) are central
    to exploiting streams in parallel by using `map`, `filter`, and the like.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个同样重要的原因是并行处理元素，这对于高效利用多核CPU至关重要。Streams，特别是`parallel`方法，允许将流标记为适合并行处理。回想一下，并行性和可变状态不太搭配，所以核心函数式概念（无副作用的操作和用lambda表达式和方法引用参数化的方法，允许内部迭代而不是外部迭代，如第4章所述）是利用`map`、`filter`等来并行利用流的关键。
- en: In the following section, we look at how these ideas, which we introduced in
    terms of streams, have a direct analog in the design of `CompletableFuture`.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨这些想法，即我们以流的形式引入的，在`CompletableFuture`的设计中有一个直接的对应物。
- en: 21.1.3\. CompletableFuture
  id: totrans-664
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 21.1.3\. CompletableFuture
- en: Java has provided the `Future` interface since Java 5\. `Future`s are useful
    for exploiting multicore because they allow a task to be spawned onto another
    thread or core and allow the spawning task to continue executing along with the
    spawned task. When the spawning task needs the result, it can use the `get` method
    to wait for the `Future` to complete (produce its value).
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: Java自Java 5以来就提供了`Future`接口。`Future`s对于利用多核很有用，因为它们允许将任务在另一个线程或核心上生成，并允许生成任务继续执行。当生成任务需要结果时，它可以使用`get`方法等待`Future`完成（产生其值）。
- en: '[Chapter 16](kindle_split_030.xhtml#ch16) explains the Java 8 `CompletableFuture`
    implementation of `Future`, which again exploits lambdas. A useful, if slightly
    imprecise, motto is “`CompletableFuture` is to `Future` as `Stream` is to `Collection`.”
    To compare:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '[第16章](kindle_split_030.xhtml#ch16)解释了Java 8的`CompletableFuture`对`Future`的实现，这再次利用了lambda表达式。一个有用但稍微不够精确的格言是“`CompletableFuture`是`Future`的，就像`Stream`是`Collection`的。”为了比较：'
- en: '`Stream` lets you pipeline operations and provides behavior parameterization
    with `map`, `filter`, and the like, eliminating the boilerplate code that you
    typically have to write when you use iterators.'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream`允许你将操作管道化，并通过`map`、`filter`等提供行为参数化，消除了在使用迭代器时通常必须编写的样板代码。'
- en: '`CompletableFuture` provides operations such as `thenCompose`, `thenCombine`,
    and `allOf`, which provide functional-programming-style concise encodings of common
    design patterns involving `Future`s and let you avoid similar imperative-style
    boilerplate code.'
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture`提供了`thenCompose`、`thenCombine`和`allOf`等操作，这些操作以函数式编程风格的简洁编码提供了涉及`Future`s的常见设计模式，并让你避免类似的命令式样板代码。'
- en: This style of operations, albeit in a simpler scenario, also applies to the
    Java 8 operations on `Optional`, which we revisit in the next section.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作风格，尽管是在一个更简单的场景中，也适用于Java 8对`Optional`的操作，我们将在下一节重新探讨这一点。
- en: 21.1.4\. Optional
  id: totrans-670
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 21.1.4\. Optional
- en: The Java 8 library provides the class `Optional<T>`, which allows your code
    to specify that a value is a proper value of type `T` or a missing value returned
    by the static method `Optional.empty`. This feature is great for program comprehension
    and documentation. It provides a data type with an explicit missing value instead
    of the previous error-prone use of the `null` pointer to indicate missing values,
    which programmers could never be sure was a planned missing value or an accidental
    `null` resulting from an earlier erroneous computation.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 库提供了 `Optional<T>` 类，允许你的代码指定一个值是类型 `T` 的有效值或由静态方法 `Optional.empty` 返回的缺失值。这个特性对于程序理解和文档来说非常棒。它提供了一个具有显式缺失值的数据类型，而不是之前使用
    `null` 指针来指示缺失值，程序员永远无法确定这是一个计划中的缺失值还是由于早期错误计算导致的意外 `null`。
- en: As discussed in [chapter 11](kindle_split_024.xhtml#ch11), if `Optional<T>`
    is used consistently, programs should never produce `NullPointerException`s. Again,
    you could see this situation as a one-off, unrelated to the rest of Java 8, and
    ask, “How does changing from one form of missing value to another help me write
    programs?” Closer inspection shows that the `Optional<T>` class provides `map`,
    `filter`, and `ifPresent`. These methods have behavior similar to that of corresponding
    methods in the `Streams` class and can be used to chain computations, again in
    functional style, with the tests for missing value done by the library instead
    of user code. The choice of internal versus external testing in `Optional<T>`
    is directly analogous to how the Streams library does internal versus external
    iteration in user code. Java 9 added various new methods to the `Optional` API,
    including `stream()`, `or()`, and `ifPresentOrElse()`.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 11 章所述 [chapter 11](kindle_split_024.xhtml#ch11)，如果一致地使用 `Optional<T>`，程序就不应该产生
    `NullPointerException`s。再次强调，你可以将这种情况视为一个孤立的例子，与 Java 8 的其他部分无关，并问自己，“从一种缺失值形式转换为另一种形式如何帮助我编写程序？”仔细检查后发现，`Optional<T>`
    类提供了 `map`、`filter` 和 `ifPresent` 方法。这些方法的行为与 `Streams` 类中相应的方法类似，可以用来链式计算，再次以函数式风格进行，由库而不是用户代码来完成缺失值的测试。`Optional<T>`
    中内部测试与外部测试的选择与 Streams 库在用户代码中如何进行内部迭代与外部迭代直接相关。Java 9 为 `Optional` API 添加了各种新方法，包括
    `stream()`、`or()` 和 `ifPresentOrElse()`。
- en: 21.1.5\. Flow API
  id: totrans-673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 21.1.5\. 流 API
- en: 'Java 9 standardized reactive streams and the reactive-pull-based backpressure
    protocol, a mechanism designed to prevent a slow consumer from being overwhelmed
    by one or more faster producers. The Flow API includes four core interfaces that
    library implementations can support to provide wider compatibility: `Publisher`,
    `Subscriber`, `Subscription`, and `Processor`.'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 标准化了反应式流和基于反应式拉取的背压协议，这是一种旨在防止慢速消费者被一个或多个较快的生产者压倒的机制。Flow API 包含四个核心接口，库实现可以支持这些接口以提供更广泛的兼容性：`Publisher`、`Subscriber`、`Subscription`
    和 `Processor`。
- en: Our final topic in this section concerns not functional-style programming, but
    Java 8 support for upward-compatible library extensions driven by software-engineering
    desires.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最后一个主题不是关于函数式编程风格，而是关于 Java 8 对向上兼容的库扩展的支持，这种支持是由软件工程的需求驱动的。
- en: 21.1.6\. Default methods
  id: totrans-676
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 21.1.6\. 默认方法
- en: Java 8 has other additions, none of which particularly affects the expressiveness
    of any program. But one thing that’s helpful to library designers allows default
    methods to be added to an interface. Before Java 8, interfaces defined method
    signatures; now they can also provide default implementations for methods that
    the interface designer suspects not all clients will want to provide explicitly.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 有其他添加的功能，但它们都没有特别影响任何程序的表达能力。但有一个对库设计者有帮助的功能，允许向接口添加默认方法。在 Java 8 之前，接口定义了方法签名；现在它们还可以为接口设计者怀疑不是所有客户端都希望明确提供的那些方法提供默认实现。
- en: This tool is a great new tool for library designers because it gives them the
    ability to augment an interface with a new operation without having to require
    all clients (classes implementing this interface) to add code to define this method.
    Therefore, default methods are also relevant to users of libraries because they
    shield the users from future interface changes (see [chapter 13](kindle_split_026.xhtml#ch13)).
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具是库设计者的一个伟大新工具，因为它使他们能够通过不需要要求所有客户端（实现此接口的类）添加代码来定义此方法，从而增强接口的新操作。因此，默认方法也与库的用户相关，因为它们保护用户免受未来接口更改的影响（参见第
    13 章 [chapter 13](kindle_split_026.xhtml#ch13)）。
- en: 21.2\. The Java 9 module system
  id: totrans-679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.2\. Java 9 模块系统
- en: Java 8 added a lot, both in terms of new features (lambdas and default methods
    on interfaces, for example) and new useful classes in the native API, such as
    `Stream` and `CompletableFuture`. Java 9 didn’t introduce any new language features
    but mostly polished the work started in Java 8, completing the classes introduced
    there with some useful methods such as `takeWhile` and `dropWhile` on a `Stream`
    and `completeOn-Timeout` on a `CompletableFuture`. In fact, the main focus of
    Java 9 was the introduction of the new module system. This new system doesn’t
    affect the language except for the new `module-info.java` file, but nevertheless
    improves the way in which you design and write applications from an architectural
    point of view, clearly marking the boundaries of subparts and defining how they
    interact.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 增加了大量的新特性（例如接口上的 lambdas 和默认方法）以及原生 API 中的新有用类，如 `Stream` 和 `CompletableFuture`。Java
    9 没有引入任何新的语言特性，但主要是在 Java 8 中开始的工作进行了打磨，通过在 `Stream` 上添加 `takeWhile` 和 `dropWhile`
    以及在 `CompletableFuture` 上添加 `completeOn-Timeout` 等一些有用的方法来完善那里引入的类。实际上，Java 9
    的主要重点是引入新的模块系统。这个新系统除了新的 `module-info.java` 文件外，不会影响语言，但仍然从架构的角度改善了设计和编写应用程序的方式，明确标记了子部分的边界，并定义了它们如何交互。
- en: 'Java 9, unfortunately, harmed the backward compatibility of Java more than
    any other release (try compiling a large Java 8 code base with Java 9). But this
    cost is worth paying for the benefits of proper modularization. One reason is
    to ensure better and stronger encapsulation across packages. In fact, Java visibility
    modifiers are designed to define encapsulation among methods and classes, but
    across packages, only one visibility is possible: `public`. This lack makes it
    hard to modularize a system properly, in particular to specify which parts of
    a module are designed for public use and which parts are implementation details
    that should be hidden from other modules and applications.'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Java 9 对 Java 的向后兼容性造成了比任何其他版本更大的损害（尝试用 Java 9 编译一个大的 Java 8 代码库）。但这个代价是值得的，因为适当的模块化带来的好处。一个原因是确保跨包之间有更好的和更强的封装。实际上，Java
    可见性修饰符被设计用来定义方法和类之间的封装，但在包之间，只有一种可见性是可能的：`public`。这种缺乏使得正确地模块化一个系统变得困难，特别是指定模块中哪些部分是为公共使用设计的，哪些部分是应该隐藏给其他模块和应用的实现细节。
- en: The second reason, which is an immediate consequence of the weak encapsulation
    across packages, is that without a proper module system, it’s impossible to avoid
    exposing functionalities that are relevant for security of all the code running
    in the same environment. Malicious code may access critical parts of your module,
    thus bypassing all security measures encoded in them.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因，它是跨包封装弱化的直接后果，即没有适当的模块系统，无法避免暴露与同一环境中所有代码运行的安全相关的功能。恶意代码可能访问模块的关键部分，从而绕过其中编码的所有安全措施。
- en: Finally, the new Java module system enables the Java runtime to be split into
    smaller parts, so you can use only the parts that are necessary for your application.
    It would be surprising if CORBA was a requirement for your new Java project, for
    example, but it’s likely to be included in all your Java applications. Although
    this act may be of limited relevance for traditional-size computing devices, it’s
    important for embedded appliances and for the increasingly frequent situation
    in which your Java applications run in a containerized environment. In other words,
    the Java module system is an enabler that allows the use of the Java runtime in
    Internet of Things (IoT) applications and in the cloud.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，新的 Java 模块系统使得 Java 运行时可以被分割成更小的部分，因此你可以只使用你应用所必需的部分。如果你的新 Java 项目需要 CORBA，这可能会令人惊讶，但它很可能会包含在你所有的
    Java 应用中。尽管这一举措对于传统尺寸的计算设备可能影响有限，但对于嵌入式设备以及你的 Java 应用越来越多地在容器化环境中运行的情况来说，它非常重要。换句话说，Java
    模块系统是一个使能器，它允许在物联网（IoT）应用和云中使用 Java 运行时。
- en: 'As discussed in [chapter 14](kindle_split_027.xhtml#ch14), the Java module
    system solves these problems by introducing a language-level mechanism to modularize
    your large systems and the Java runtime itself. The advantages of the Java module
    system include the following:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第 14 章[讨论](kindle_split_027.xhtml#ch14)中所述，Java 模块系统通过引入一种语言级机制来模块化你的大型系统和
    Java 运行时本身，从而解决了这些问题。Java 模块系统的优势包括以下方面：
- en: '***Reliable configuration*—** Explicitly declaring module requirements allows
    early detection of errors at build time rather than at runtime in the case of
    missing, conflicting, or circular dependencies.'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可靠的配置*—** 明确声明模块需求可以在构建时而不是在运行时（在缺少、冲突或循环依赖的情况下）早期检测到错误。'
- en: '***Strong encapsulation*—** The Java Module System enables modules to export
    only specific packages and then separate the public and accessible boundaries
    of each module with internal implementation.'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***强封装*—** Java模块系统使模块能够仅导出特定包，然后通过内部实现将每个模块的公共和可访问边界分开。'
- en: '***Improved security*—** Not allowing users to invoke specific parts of your
    module makes it much harder for an attacker to evade the security controls implemented
    in them.'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***提高安全性*—** 不允许用户调用模块的特定部分，这使得攻击者更难规避其中实现的安全控制。'
- en: '***Better performance*—** Many optimization techniques can be more effective
    when a class can refer to few components rather than to any other classes loaded
    by the runtime.'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***更好的性能*—** 当一个类可以引用少量组件而不是由运行时加载的任何其他类时，许多优化技术可以更有效地发挥作用。'
- en: '***Scalability*—** The Java module system allows the Java SE platform to be
    decomposed into smaller parts containing only the features required by the running
    application.'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可伸缩性*—** Java模块系统允许将Java SE平台分解为只包含运行应用程序所需特性的更小部分。'
- en: In general, modularization is a hard topic, and it’s unlikely to be a driver
    for quick adoption of Java 9 as lambdas were for Java 8\. We believe, however,
    that in the long run, the effort you invest in modularizing your application will
    be repaid in terms of easier maintainability.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，模块化是一个难题，它不太可能像Java 8中的lambda表达式那样成为Java 9快速采用的驱动因素。然而，我们认为，从长远来看，你在模块化应用程序上投入的努力将因易于维护而得到回报。
- en: So far, we’ve summarized the concepts of Java 8 and 9 covered in this book.
    In the next section, we turn to the thornier subject of future enhancements and
    great features that may be in Java’s pipeline beyond Java 9.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经总结了本书中涵盖的Java 8和9的概念。在下一节中，我们将转向更棘手的话题，即Java 9之外可能存在于Java管道中的未来增强功能和重大特性。
- en: 21.3\. Java 10 local variable type inference
  id: totrans-692
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.3. Java 10局部变量类型推断
- en: Originally in Java, whenever you introduced a variable or method, you gave its
    type at the same time. The example
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，每次你引入一个变量或方法时，你都会同时给出它的类型。例如，这个例子
- en: '[PRE111]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: contains three types, which give the result the type of `convertUSDToGBP`, the
    type of its argument `money`, and the type of its local variable `e`. Over time,
    this requirement has been relaxed in two ways. First, you may omit type parameters
    of generics in an expression when the context determines them. This example
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 包含三种类型，这些类型给出了`convertUSDToGBP`的结果类型、其参数`money`的类型以及其局部变量`e`的类型。随着时间的推移，这一要求已经以两种方式放宽。首先，当上下文确定类型参数时，你可以在表达式中省略泛型的类型参数。这个例子
- en: '[PRE112]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'can be abbreviated to the following since Java 7:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从Java 7开始简写为以下形式：
- en: '[PRE113]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Second, to use the same idea of propagating the type determined by context into
    an expression, a lambda expression such as
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，为了将上下文确定的类型传播到表达式中相同的思想，一个lambda表达式如下
- en: '[PRE114]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: can be shortened to
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 可以缩短为
- en: '[PRE115]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: by omitting types. In both cases, the compiler infers the omitted types.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 通过省略类型。在两种情况下，编译器都会推断省略的类型。
- en: 'Type inference has a few advantages when a type consists of a single identifier,
    the main one being reduced editing work when replacing one type with another.
    But as types grow in size, generics parameterized by further generic types, type
    inference can aid readability.^([[1](#ch21fn01)]) The Scala and C# languages permit
    a type in a local-variable-initialized declaration to be replaced by the (restricted)
    keyword `var`; the compiler fills in the appropriate type from the right side.
    The declaration of `myMap` shown earlier in Java syntax could be rendered like
    this:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型由单个标识符组成时，类型推断有几个优点，主要优点是在用一种类型替换另一种类型时减少了编辑工作量。但随着类型大小的增加，由更进一步的泛型类型参数化的泛型，类型推断有助于提高可读性.^([[1](#ch21fn01)])
    Scala和C#语言允许在局部变量初始化声明中将类型替换为（受限的）关键字`var`；编译器会从右侧填充适当类型。前面用Java语法展示的`myMap`声明可以表示如下：
- en: ¹
  id: totrans-705
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-706
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s important that type inference be done sensibly, of course. Type inference
    works best when you have only one way, or one easily documentable way, to re-create
    the type that the user omitted. Problems occur if the system infers a different
    type from the one that the user was thinking of. So a good design of type inference
    produces a fault when two incomparable types could be inferred; heuristics can
    give the appearance of picking the wrong one seemingly at random.
  id: totrans-707
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当然，类型推断必须合理。类型推断在只有一个方式，或者一个容易记录的方式，来重新创建用户省略的类型时效果最好。如果系统推断出的类型与用户所想的类型不同，就会出现问题。因此，良好的类型推断设计会在可以推断出两个不可比较的类型时产生错误；启发式方法可能会给人一种随机选择错误类型的印象。
- en: '[PRE116]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This idea is called *local variable type inference* and is included in Java
    10.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法被称为*局部变量类型推断*，并包含在Java 10中。
- en: There’s some small cause for concern, however. Given a class `Car` that subclasses
    a class `Vehicle`, does the declaration
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些小的担忧。给定一个继承自`Vehicle`类的`Car`类，声明
- en: '[PRE117]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: implicitly declare `x` to have type `Car` or `Vehicle` (or even `Object`)? In
    this case, a simple explanation that the missing type is the type of the initializer
    (here, `Car`) is perfectly clear. Java 10 formalizes this fact, also stating that
    `var` can’t be used when there’s no initializer.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式声明`x`的类型为`Car`或`Vehicle`（甚至`Object`）？在这种情况下，一个简单的解释，即缺失的类型是初始化器的类型（在这里，是`Car`）是完全可以理解的。Java
    10正式化了这一事实，同时也指出`var`不能在没有初始化器的情况下使用。
- en: 21.4\. What’s ahead for Java?
  id: totrans-713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.4\. Java的未来是什么？
- en: Some of the points we cover in this section are discussed in more detail on
    the JDK Enhancement Proposal website at [http://openjdk.java.net/jeps/0](http://openjdk.java.net/jeps/0).
    Here, we take care to explain why seemingly sensible ideas have subtle difficulties
    or interactions with existing features that inhibit their direct incorporation
    into Java.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中讨论的一些点在JDK增强提案网站上讨论得更为详细[http://openjdk.java.net/jeps/0](http://openjdk.java.net/jeps/0)。在这里，我们仔细解释了为什么看似合理的想法有细微的困难或与现有特征的交互，这阻碍了它们直接被纳入Java。
- en: 21.4.1\. Declaration-site variance
  id: totrans-715
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 21.4.1\. 声明位置方差
- en: 'Java supports wildcards as flexible mechanisms that allow subtyping for generics
    (generally referred to as *use-site variance*). This support makes the following
    assignment valid:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: Java支持通配符作为灵活的机制，允许泛型（通常称为*使用位置方差*）进行子类型化。这种支持使得以下赋值有效：
- en: '[PRE118]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'But the following assignment, omitting the `"? extends"`, produces a compile-time
    error:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 但以下省略`"? extends"`的赋值会产生编译时错误：
- en: '[PRE119]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '***1* Incompatible types**'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 不兼容的类型**'
- en: Many programming languages, such as C# and Scala, support a different variance
    mechanism called *declaration-site variance*. These languages allow programmers
    to specify variance when defining a generic class. This feature is useful for
    classes that are inherently variant. `Iterator`, for example, is inherently covariant,
    and `Comparator` is inherently contravariant, and you shouldn’t need to think
    in terms of `? extends` or `? super` when you use them. Adding declaration-site
    variance to Java would be useful, because these specifications appear instead
    at the declaration of classes. As a result, this addition would reduce some cognitive
    overhead for programmers. Note that at the writing (2018), a JDK enhancement proposal
    would allow default declaration-site variance in upcoming versions of Java ([http://openjdk.java.net/jeps/300](http://openjdk.java.net/jeps/300)).
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言，如C#和Scala，支持一种称为*声明位置方差机制*的不同方差机制。这些语言允许程序员在定义泛型类时指定方差。这个特性对于本质上可变的类很有用。例如，`Iterator`本质上是一致的，而`Comparator`本质上是对抗的，当你使用它们时，你不需要考虑`?
    extends`或`? super`。将声明位置方差添加到Java中会有用，因为这些规范出现在类的声明处。因此，这个添加将减少程序员的认知负担。注意，在撰写时（2018年），一个JDK增强提案将允许在Java的后续版本中默认启用声明位置方差（[http://openjdk.java.net/jeps/300](http://openjdk.java.net/jeps/300)）。
- en: 21.4.2\. Pattern matching
  id: totrans-722
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 21.4.2\. 模式匹配
- en: 'As we discussed in [chapter 19](kindle_split_034.xhtml#ch19), functional-style
    languages typically provide some form of pattern matching—an enhanced form of
    `switch`—in which you can ask, “Is this value an instance of a given class?” and
    (optionally) recursively ask whether its fields have certain values. In Java a
    simple case test looks like this:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第19章](kindle_split_034.xhtml#ch19)中讨论的，函数式语言通常提供某种形式的模式匹配——一种增强的`switch`形式——你可以问，“这个值是否是给定类的实例？”（可选地）递归地询问其字段是否具有某些值。在Java中，简单的case测试看起来像这样：
- en: '[PRE120]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Note that you have to repeat the type `BinOp` within the cast expression, even
    though it’s clear that the object referenced by `op` is of that type.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使在 `op` 引用的对象显然属于该类型的情况下，你仍然需要在类型转换表达式中重复 `BinOp` 类型。
- en: You may have a complicated hierarchy of expressions to process, of course, and
    the approach of chaining multiple `if` conditions will make your code more verbose.
    It’s worth reminding you that traditional object-oriented design discourages the
    use of `switch` and encourages patterns such as the visitor pattern, in which
    data-type-dependent control flow is done by method dispatch instead of by `switch`.
    At the other end of the programming language spectrum, in functional-style programming,
    pattern matching over values of data types is often the most convenient way to
    design a program.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能有一个复杂的表达式层次结构需要处理，使用多个 `if` 条件链的方法会使你的代码更加冗长。值得提醒的是，传统的面向对象设计不鼓励使用 `switch`，并鼓励使用如访问者模式之类的模式，其中数据类型相关的控制流是通过方法调度而不是通过
    `switch` 来实现的。在编程语言的另一端，在函数式编程风格中，对数据类型值的模式匹配通常是设计程序最方便的方式。
- en: 'Adding Scala-style pattern matching in full generality to Java seems to be
    a big job, but following the recent generalization to `switch` to allow `String`s,
    you can imagine a more modest syntax extension that allows `switch` to operate
    on objects by using the `instanceof` syntax. In fact, a JDK enhanced proposal
    explores pattern matching as a language feature for Java ([http://openjdk.java.net/jeps/305](http://openjdk.java.net/jeps/305)).
    The following example revisits our example from [chapter 19](kindle_split_034.xhtml#ch19)
    and assumes a class `Expr`, which is subclassed into `BinOp` and `Number`:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Scala 风格的模式匹配完全泛化到 Java 似乎是一项大工程，但鉴于最近对 `switch` 的泛化，允许 `String` 使用，你可以想象一个更温和的语法扩展，允许
    `switch` 通过使用 `instanceof` 语法来操作对象。实际上，一个 JDK 增强提案探索了将模式匹配作为 Java 的语言特性([http://openjdk.java.net/jeps/305](http://openjdk.java.net/jeps/305))。以下示例回顾了第
    19 章中的例子，并假设有一个类 `Expr`，它被继承为 `BinOp` 和 `Number`：
- en: '[PRE121]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Notice a couple of things. First, this code steals from pattern matching the
    idea that in `case (op instanceof BinOp`):, `op` is a new local variable (of type
    `BinOp`), which becomes bound to the same value as `someExpr`. Similarly, in the
    `Number` case, `n` becomes a variable of type `Number`. In the default case, no
    variable is bound. This proposal eliminates much boilerplate code compared with
    using chains of `if-then-else` and casting to subtype. A traditional object-oriented
    designer probably would argue that such data-type dispatch code would better be
    expressed with visitor-style methods overridden in subtypes, but to functional-programming
    eyes, this solution results in related code being scattered over several class
    definitions. This classical design dichotomy is discussed in the literature as
    the expression problem.^([[2](#ch21fn02)])
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '注意以下几点。首先，这段代码从模式匹配中借鉴了这样的想法：在 `case (op instanceof BinOp`): 中，`op` 是一个新的局部变量（类型为
    `BinOp`），它绑定到与 `someExpr` 相同的值。同样，在 `Number` 情况下，`n` 成为一个 `Number` 类型的变量。在默认情况下，没有变量被绑定。与使用一系列
    `if-then-else` 语句和子类型转换相比，这个提议消除了大量的样板代码。一个传统的面向对象设计师可能会争辩说，这样的数据类型分发代码最好用子类型中重写的访问者风格方法来表示，但从函数式编程的角度来看，这种解决方案导致相关代码分散在几个类定义中。这种经典的设计二分法在文献中被讨论为表达式问题.^([[2](#ch21fn02)])'
- en: ²
  id: totrans-730
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-731
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For a more complete explanation, see [http://en.wikipedia.org/wiki/Expression_problem](http://en.wikipedia.org/wiki/Expression_problem).
  id: totrans-732
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于更完整的解释，请参阅 [http://en.wikipedia.org/wiki/Expression_problem](http://en.wikipedia.org/wiki/Expression_problem)。
- en: 21.4.3\. Richer forms of generics
  id: totrans-733
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 21.4.3. 泛型的更丰富形式
- en: This section discusses two limitations of Java generics and looks at a possible
    evolution to mitigate them.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了 Java 泛型的两个限制，并探讨了一种可能的演变来减轻它们。
- en: Reified generics
  id: totrans-735
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实体化泛型
- en: When generics were introduced in Java 5, they had to be backward-compatible
    with the existing JVM. To this end, the runtime representations of `ArrayList<String>`
    and `ArrayList<Integer>` are identical. This model is called the *erasure model
    of generic polymorphism*. Certain small runtime costs are associated with this
    choice, but the most significant effect for programmers is that parameters of
    generic types can be only objects and not primitive types. Suppose that Java allowed,
    say, `ArrayList<int>`. Then you could allocate an `ArrayList` object on the heap
    containing a primitive value such as `int 42`, but the `ArrayList` container wouldn’t
    contain any indicator of whether it contained an `Object` value such as a `String`
    or a primitive `int` value such as 42.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java 5引入泛型时，它们必须与现有的JVM向后兼容。为此，`ArrayList<String>`和`ArrayList<Integer>`的运行时表示是相同的。这种模型被称为*泛型多态的擦除模型*。这个选择与某些小的运行时成本相关联，但对于程序员来说，最显著的影响是泛型类型的参数只能是对象，而不能是原始类型。假设Java允许，比如说，`ArrayList<int>`。那么你可以在堆上分配一个`ArrayList`对象，包含一个原始值，如`int
    42`，但是`ArrayList`容器不会包含任何指示它是否包含一个`Object`值，如`String`，或者一个原始`int`值，如42。
- en: At some level, this situation seems to be harmless. If you get a primitive 42
    from an `ArrayList<int>` and a `String` object `"abc"` from an `ArrayList<String>`,
    why should you worry that the `ArrayList` containers are indistinguishable? Unfortunately,
    the answer is garbage collection, because the absence of runtime type information
    about the contents of the `ArrayList` would leave the JVM unable to determine
    whether element 13 of your `ArrayList` was a `String` reference (to be followed
    and marked as in use by garbage collection) or an `int` primitive value (most
    definitely not to be followed).
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，这种状况似乎是无害的。如果你从一个`ArrayList<int>`中获取一个原始的42，并从一个`ArrayList<String>`中获取一个`String`对象`"abc"`，你为什么还会担心`ArrayList`容器是不可区分的呢？不幸的是，答案是垃圾回收，因为`ArrayList`内容缺少运行时类型信息，会导致JVM无法确定你的`ArrayList`的第13个元素是一个`String`引用（将被跟踪并标记为垃圾回收使用）还是一个`int`原始值（绝对不是要跟踪的）。
- en: In the C# language, the runtime representations of `ArrayList<String>`, `ArrayList<Integer>`,
    and `ArrayList<int>` are in principle different. But even if these representations
    were the same, sufficient type information is kept at runtime to allow, for example,
    garbage collection to determine whether a field is a reference or a primitive.
    This model is called the *reified model of generic polymorphism* or, more simply,
    *reified generics*. The word *reification* means “making explicit something that
    otherwise would be implicit.”
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#语言中，`ArrayList<String>`、`ArrayList<Integer>`和`ArrayList<int>`的运行时表示在原则上不同。即使这些表示相同，运行时也会保留足够类型信息，以便例如垃圾回收确定一个字段是引用还是原始值。这种模型被称为*泛型多态的实体化模型*，或者更简单地说，*实体化泛型*。单词*实体化*意味着“使原本隐含的东西变得明确”。
- en: Reified generics are clearly desirable because they enable a more full unification
    of primitive types and their corresponding object types—something that you’ll
    see as problematic in the following sections. The main difficulty for Java is
    backward compatibility, both in the JVM and in existing programs that use reflection
    and expect generics to be erased.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 实体化泛型显然是可取的，因为它们能够实现原始类型及其对应对象类型的更全面统一——你将在以下章节中看到这可能会成为问题。对于Java来说，主要困难是向后兼容性，无论是在JVM中还是在使用反射并期望泛型被擦除的现有程序中。
- en: Additional syntactic flexibility in generics for function types
  id: totrans-740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 泛型在函数类型上的额外语法灵活性
- en: 'Generics proved to be a wonderful feature when they were added to Java 5\.
    They’re also fine for expressing the type of many Java 8 lambdas and method references.
    You can express a one-argument function this way:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 当泛型在Java 5中添加时，它们证明是一个非常好的特性。它们也适用于表达许多Java 8 lambda表达式和方法引用的类型。你可以这样表达一个单参数函数：
- en: '[PRE122]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: If you have a two-argument function, you use the type `BiFunction<T, U, R>`,
    where `T` is the type of the first parameter, `U` the second, and `R` the result.
    But there’s no `TriFunction` unless you declare it yourself.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个双参数函数，你使用类型`BiFunction<T, U, R>`，其中`T`是第一个参数的类型，`U`是第二个参数，`R`是结果。但是除非你自己声明，否则没有`TriFunction`。
- en: Similarly, you can’t use `Function<T, R>` for references to methods that take
    zero arguments and return result type `R`; you have to use `Supplier<R>` instead.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你不能使用`Function<T, R>`来引用接受零个参数并返回结果类型`R`的方法；你必须使用`Supplier<R>`代替。
- en: In essence, Java 8 lambdas have enriched what you can write, but the type system
    hasn’t kept up with the flexibility of the code. In many functional languages,
    you can write, for example, the type `(Integer, Double) => String`, to represent
    what Java 8 calls `BiFunction<Integer, Double, String>`, along with `Integer =>
    String` to represent `Function<Integer, String>`, and even `() => String` to represent
    `Supplier<String>`. You can understand `=>` as an infix version of `Function`,
    `BiFunction`, `Supplier`, and the like. A simple extension to Java syntax for
    types to allow infix `=>` would result in more readable types analogous to what
    Scala provides, as discussed in [chapter 20](kindle_split_035.xhtml#ch20).
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，Java 8 的 lambda 表达式丰富了你可以编写的代码，但类型系统并没有跟上代码的灵活性。在许多函数式语言中，你可以编写，例如，类型
    `(Integer, Double) => String` 来表示 Java 8 中的 `BiFunction<Integer, Double, String>`，以及
    `Integer => String` 来表示 `Function<Integer, String>`，甚至 `() => String` 来表示 `Supplier<String>`。你可以将
    `=>` 理解为 `Function`、`BiFunction`、`Supplier` 等的 infix 版本。Java 语法类型的一个简单扩展，允许 infix
    `=>`，将导致更易读的类型，类似于在第 20 章中讨论的 Scala 提供的类型，如 [chapter 20](kindle_split_035.xhtml#ch20)
    所述。
- en: Primitive specializations and generics
  id: totrans-746
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原始类型特化和泛型
- en: In Java, all primitive types (`int`, for example) have a corresponding object
    type (here, `java.lang.Integer`). Often, programmers refer to these types as unboxed
    and boxed. Although this distinction has the laudable aim of increasing runtime
    efficiency, the types can become confusing. Why, for example, do you write `Predicate<Apple>`
    instead of `Function<Apple, Boolean>` in Java 8? An object of type `Predicate<Apple>`,
    when called by the `test` method, returns a primitive `boolean`.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，所有原始类型（例如 `int`）都有一个相应的对象类型（这里，`java.lang.Integer`）。通常，程序员将这些类型称为未装箱和已装箱。尽管这种区别有提高运行时效率的值得称赞的目标，但类型可能会变得令人困惑。例如，为什么在
    Java 8 中你写 `Predicate<Apple>` 而不是 `Function<Apple, Boolean>`？当 `Predicate<Apple>`
    类型的对象通过 `test` 方法被调用时，返回的是一个原始的 `boolean`。
- en: By contrast, like all Java generics, a `Function` can be parameterized only
    by object types. In the case of `Function<Apple, Boolean>`, this is the object
    type `Boolean`, not the primitive type `boolean`. `Predicate<Apple>` is more efficient
    because it avoids boxing the `boolean` to make a `Boolean`. This issue has led
    to the creation of multiple similar interfaces such as `LongToIntFunction` and
    `BooleanSupplier`, which add further conceptual overload.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有 Java 泛型一样，`Function` 只能通过对象类型进行参数化。在 `Function<Apple, Boolean>` 的情况下，这是对象类型
    `Boolean`，而不是原始类型 `boolean`。`Predicate<Apple>` 更高效，因为它避免了将 `boolean` 封装成 `Boolean`。这个问题导致了多个类似接口的创建，例如
    `LongToIntFunction` 和 `BooleanSupplier`，这进一步增加了概念上的负担。
- en: Another example concerns the differences between `void`, which can qualify only
    method return types and has no values, and the object type `Void`, which has `null`
    as its only value (a question that regularly appears in forums). The special cases
    of `Function` such as `Supplier<T>`, which could be written `() => T` in the new
    notation proposed in the previous section, further attest to the ramifications
    caused by the distinction between primitive and object types. We discussed earlier
    how reified generics could address many of these issues.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子涉及 `void` 和对象类型 `Void` 之间的区别，`void` 只能修饰方法返回类型且没有值，而 `Void` 的唯一值是 `null`（这是一个在论坛中经常出现的问题）。`Function`
    的特殊情况，如 `Supplier<T>`，在上一节提出的新语法中可以写成 `() => T`，进一步证明了原始类型和对象类型之间的区别所引起的后果。我们之前讨论了如何通过具体化的泛型来解决这些问题。
- en: 21.4.4\. Deeper support for immutability
  id: totrans-750
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 21.4.4. 对不可变性的更深入支持
- en: 'Some expert readers may have been a little upset when we said that Java 8 has
    three forms of values:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 一些专家读者可能对我们说 Java 8 有三种值形式感到有些不满：
- en: Primitive values
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始值
- en: (References to) objects
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （对）对象
- en: (References to) functions
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （对）函数
- en: At one level, we’re going to stick to our guns and say, “But these are the values
    that a method may now take as arguments and return as results.” But we also want
    to concede that this explanation is a little problematic. To what extent do you
    return a (mathematical) value when you return a reference to a mutable array?
    A `String` or an immutable array clearly is a value, but the case is far less
    clear-cut for a mutable object or array. Your method may return an array with
    its elements in ascending order, but some other code may change one of its elements
    later.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个层面上，我们将坚持我们的观点，说：“但是，这些是方法现在可以将其作为参数传递并作为结果返回的值。”但我们也想承认这种解释有点问题。当你返回一个可变数组的引用时，你返回了多少（数学）值？`String`
    或不可变数组显然是值，但对于可变对象或数组来说，情况远没有那么明确。你的方法可能返回一个元素按升序排列的数组，但其他代码可能在以后改变其元素之一。
- en: 'If you’re interested in functional-style programming in Java, you need linguistic
    support for saying “immutable value.” As noted in [chapter 18](kindle_split_033.xhtml#ch18),
    the keyword `final` doesn’t achieve this purpose; it only stops the field that
    it qualifies from being updated. Consider this example:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 Java 中的函数式编程风格感兴趣，你需要语言支持来表达“不可变值”。正如在第 18 章中提到的（kindle_split_033.xhtml#ch18），关键字
    `final` 达不到这个目的；它只能阻止它修饰的字段被更新。考虑以下示例：
- en: '[PRE123]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The first line forbids another assignment `arr = ...` but doesn’t forbid `arr[1]
    = 2`; the second line forbids assignments to `list` but doesn’t forbid other methods
    from changing the number of elements in `list`. The keyword `final` works well
    for primitive values, but for references to objects, it often produces a false
    sense of security.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行禁止另一个赋值 `arr = ...`，但不禁止 `arr[1] = 2`；第二行禁止对 `list` 进行赋值，但不禁止其他方法改变 `list`
    中的元素数量。关键字 `final` 对于原始值来说效果很好，但对于对象引用来说，它往往会产生一种错误的安全感。
- en: 'What we’re leading up to is this: given that functional-style programming puts
    strong emphasis on not mutating existing structure, a strong argument exists for
    a keyword such as `transitively_final`, which can qualify fields of reference
    type and ensure that no modification can take place in the field or any object
    directly or indirectly accessible via that field.'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要引导的是这个观点：鉴于函数式编程风格强调不要修改现有结构，存在一个强有力的论据支持一个如 `transitively_final` 这样的关键字，它可以修饰引用类型的字段，并确保该字段或通过该字段直接或间接访问的任何对象都不能进行修改。
- en: 'Such types represent one intuition about values: values are immutable, and
    only variables (which contain values) may be mutated to contain a different immutable
    value. As we remarked at the beginning of this section, Java authors (including
    us) sometimes inconsistently talk about the possibility of a Java value’s being
    a mutable array. In the next section, we return to proper intuition and discuss
    the idea of value types, which can contain only immutable values even if variables
    of value types can still be updated unless they’re qualified with `final`.'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的类型代表了对值的某种直觉：值是不可变的，只有变量（包含值的容器）可以被修改以包含不同的不可变值。正如我们在本节开头所提到的，Java 作者（包括我们）有时会不一致地讨论
    Java 值是否可能是可变数组的可能性。在下一节中，我们将回到正确的直觉，并讨论值类型的概念，即使值类型的变量仍然可以被更新（除非它们被 `final` 修饰），值类型也只能包含不可变值。
- en: 21.4.5\. Value types
  id: totrans-761
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 21.4.5. 值类型
- en: In this section, we discuss the difference between primitive types and object
    types, following up on the discussion of the desire for value types, which help
    you write programs functionally, as object types are necessary for object-oriented
    programming. Many of the issues we discuss are related, so there’s no easy way
    to explain one problem in isolation. Instead, we identify the problem by its various
    facets.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论原始类型和对象类型之间的区别，这是在讨论对值类型的渴望之后进行的，值类型有助于你以函数式的方式编写程序，因为对象类型对于面向对象编程是必要的。我们讨论的许多问题都是相关的，因此没有简单的方法可以单独解释一个问题。相反，我们通过其各种方面来识别问题。
- en: Can’t the compiler treat Integer and int identically?
  id: totrans-763
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编译器难道不能将 Integer 和 int 视为相同类型处理吗？
- en: Given all the implicit boxing and unboxing that Java has slowly acquired since
    Java 1.1, you might ask whether it’s time for Java to treat, for example, `Integer`
    and `int` identically and to rely on the Java compiler to optimize into the best
    form for the JVM.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Java 自 1.1 版本以来逐渐获得的隐式装箱和拆箱，你可能会问是否是时候让 Java 将 `Integer` 和 `int` 视为相同类型，并依赖
    Java 编译器优化到 JVM 的最佳形式了。
- en: 'This idea is wonderful in principle, but consider the problems surrounding
    adding the type `Complex` to Java to see why boxing is problematic. The type `Complex`,
    which models so-called complex numbers with real and imaginary parts, is naturally
    introduced as follows:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法在原则上很棒，但考虑一下在Java中添加`Complex`类型所带来的问题，以了解为什么装箱有问题。`Complex`类型，它用实部和虚部来模拟所谓的复数，自然地以以下方式引入：
- en: '[PRE124]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: But values of type `Complex` are reference types, and every operation on `Complex`
    needs to do an object allocation, dwarfing the cost of the two additions in `add`.
    Programmers need a primitive-type analog of `Complex`, perhaps called `complex`.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 但`Complex`类型的值是引用类型，对`Complex`的每个操作都需要进行对象分配，这使`add`中的两个添加的成本相形见绌。程序员需要一个`Complex`的原始类型类似物，可能称为`complex`。
- en: 'The issue is that programmers want an unboxed object, for which neither Java
    nor the JVM offers any real support. You can return to the lament “Oh, but surely
    the compiler can optimize this.” Sadly, this process is much harder than it appears;
    although a compiler optimization based on so-called escape analysis can sometimes
    determine that unboxing is okay, its applicability is limited by Java’s assumptions
    of `Object`s, which have been present since Java 1.1\. Consider the following
    puzzler:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于程序员想要一个无包装的对象，而Java和JVM都没有提供真正的支持。你可以回到那个哀叹：“哦，但编译器肯定可以优化这个。”遗憾的是，这个过程比看起来要困难得多；尽管基于所谓的逃逸分析进行的编译器优化有时可以确定无包装是可行的，但其适用性受到Java对`Object`的假设的限制，这些假设自Java
    1.1以来就存在了。考虑以下难题：
- en: '[PRE125]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The result is “yes”, “no”, “yes.” An expert Java programmer probably would say,
    “What silly code. Everyone knows you should use `equals` on the last two lines
    instead of `==`.” But we’ll persist. Even though all these primitives and objects
    contain the immutable value 3.14 and should be indistinguishable, the definitions
    of `o1` and `o2` create new objects, and the `==` operator (identity comparison)
    can tell them apart. Note that on primitives, the identity comparison does bitwise
    comparison, but on objects, it does reference equality. Often, you accidentally
    create a new distinct `Double` object, which the compiler needs to respect because
    the semantics of `Object`, from which `Double` inherits, require this. You’ve
    seen this discussion before, both in the discussion of value types in this chapter
    and in [chapter 19](kindle_split_034.xhtml#ch19), where we discussed referential
    transparency of methods that functionally update persistent data structures.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是“是”、“否”、“是”。一个经验丰富的Java程序员可能会说，“什么愚蠢的代码。每个人都知道你应该在最后两行使用`equals`而不是`==`。”但我们会坚持下去。尽管所有这些原始类型和对象都包含不可变的值3.14并且应该是不可区分的，但`o1`和`o2`的定义创建了新的对象，而`==`运算符（身份比较）可以区分它们。请注意，在原始类型上，身份比较进行位比较，而在对象上，它进行引用相等性比较。通常，你会意外地创建一个新的不同的`Double`对象，编译器需要尊重它，因为`Object`的语义，`Double`从中继承，要求这样做。你之前已经见过这个讨论，无论是在本章关于值类型的讨论中，还是在[第19章](kindle_split_034.xhtml#ch19)中，我们讨论了函数式更新持久数据结构的方法的引用透明性。
- en: 'Value types: Not everything is a primitive or an object'
  id: totrans-771
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 值类型：并非所有内容都是原始类型或对象
- en: We suggest that the resolution of this problem is to rework the Java assumptions
    that (1) everything that isn’t a primitive is an object and hence inherits `Object`
    and (2) all references are references to objects.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议解决这个问题的方法是重新工作Java的假设，即（1）所有不是原始类型的东西都是对象，因此继承`Object`，以及（2）所有引用都是对对象的引用。
- en: 'The development starts this way. Values take two forms:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 开发以这种方式开始。值有两种形式：
- en: '`Object` types that have mutable fields unless forbidden with `final` and that
    also have identity, which may be tested with `==`.'
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有可变字段的对象类型，除非用`final`禁止，并且具有身份，该身份可以用`==`测试。
- en: Value types, which are immutable and don’t have reference identity. Primitive
    types are a subset of this wider notion.
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型，它们是不可变的并且没有引用身份。原始类型是这个更广泛概念的一个子集。
- en: You could allow user-defined value types (perhaps starting with a lowercase
    letter to emphasize their similarity to primitive types such as `int` and `boolean`).
    On value types, `==` would, by default, perform an element-by-element comparison
    in the same way that hardware comparison on `int` performs a bit-by-bit comparison.
    We need to be careful for floating-point members as comparison is a somewhat more
    sophisticated operation. The type `Complex` would be a perfect example of a nonprimitive
    value type; such types resemble C# structs.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以允许用户定义值类型（可能从小写字母开始，以强调它们与诸如`int`和`boolean`这样的原始类型相似）。在值类型上，默认情况下，`==`会执行元素级的比较，就像硬件在`int`上执行位级比较一样。我们需要小心处理浮点成员，因为比较是一个相对复杂的操作。`Complex`类型将是一个非原始值类型的完美例子；这些类型类似于C#中的结构体。
- en: In addition, value types can reduce storage requirements because they don’t
    have reference identity. [Figure 21.1](#ch21fig01) illustrates an array of size
    three, whose elements 0, 1, and 2 are light gray, white, and dark gray, respectively.
    The left diagram shows a typical storage requirement when `Pair` and `Complex`
    are `Object`s, and the right diagram shows the better layout when `Pair` and `Complex`
    are value types. Note that we call them `pair` and `complex` in lowercase in the
    diagram to emphasize their similarity to primitive types. Note also that value
    types are likely to produce better performance, not only for data access (multiple
    levels of pointer indirection replaced by a single indexed-addressing instruction),
    but also for hardware cache use (due to data contiguity).
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，值类型可以减少存储需求，因为它们没有引用标识。[图21.1](#ch21fig01)展示了大小为三的数组，其元素0、1和2分别是浅灰色、白色和深灰色。左图显示了当`Pair`和`Complex`是`Object`时的典型存储需求，右图显示了当`Pair`和`Complex`是值类型时的更好布局。注意，我们在图中用小写字母称呼它们，以强调它们与原始类型的相似性。还要注意，值类型可能会产生更好的性能，不仅对于数据访问（多级指针间接替换为单个索引寻址指令），而且对于硬件缓存的使用（由于数据连续性）。
- en: Figure 21.1\. Objects versus value types
  id: totrans-778
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图21.1\. 对象与值类型
- en: '![](Images/21fig01_alt.jpg)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/21fig01_alt.jpg)'
- en: 'Note that because value types don’t have reference identity, the compiler can
    box and unbox them at its choice. If you pass a `complex` as argument from one
    function to another, the compiler can naturally pass it as two separate doubles.
    (Returning it without boxing is trickier in the JVM, of course, because the JVM
    provides only method-return instructions for passing values representable in a
    64-bit machine register.) But if you pass a larger value type as an argument (perhaps
    a large immutable array), the compiler can instead, transparently to the user,
    pass it as a reference when it has been boxed. Similar technology already exists
    in C#. Microsoft says ([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types)):'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于值类型没有引用标识，编译器可以自由地进行装箱和拆箱。如果你从一个函数将一个`complex`类型作为参数传递到另一个函数，编译器可以自然地将它作为两个单独的双精度浮点数传递。（在JVM中，不进行装箱直接返回它会更复杂，因为JVM只为可以在64位机器寄存器中表示的值提供了方法返回指令。）但是，如果你传递一个更大的值类型作为参数（可能是一个大的不可变数组），编译器可以透明地将它作为引用传递，当它被装箱时。这种技术已经在C#中存在。微软表示（[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types)）：
- en: '*Variables that are based on value types directly contain values. Assigning
    one value type variable to another copies the contained value. This differs from
    the assignment of reference type variables, which copies a reference to the object
    but not the object itself.*'
  id: totrans-781
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*基于值类型的变量直接包含值。将一个值类型变量赋值给另一个变量时，会复制包含的值。这与引用类型变量的赋值不同，引用类型变量的赋值会复制对象的引用，但不会复制对象本身。*'
- en: At the time of writing (2018), a JDK enhancement proposal is pending for value
    types in Java ([http://openjdk.java.net/jeps/169](http://openjdk.java.net/jeps/169)).
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时（2018年），Java中关于值类型的JDK增强提案正在等待审批（[http://openjdk.java.net/jeps/169](http://openjdk.java.net/jeps/169)）。
- en: 'Boxing, generics, value types: the interdependency problem'
  id: totrans-783
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 装箱、泛型、值类型：相互依赖问题
- en: We’d like to have value types in Java because functional-style programs deal
    with immutable values that don’t have identity. We’d like to see primitive types
    as a special case of value types, but the erasure model of generics, which Java
    currently has, means that value types can’t be used with generics without boxing.
    Object (boxed) versions (such as `Integer`) of primitive types (such as `int`)
    continue to be vital for collections and Java generics because of their erasure
    model, but now their inheriting `Object` (and, hence, reference equality) is seen
    as a drawback. Addressing any of these problems means addressing them all.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在Java中有值类型，因为函数式风格的程序处理的是没有身份的不变值。我们希望将原始类型视为值类型的特例，但Java目前具有的泛型擦除模型意味着值类型不能与泛型一起使用而不进行装箱。由于擦除模型，原始类型的对象（装箱）版本（如`Integer`）对于集合和Java泛型来说仍然至关重要，但现在它们继承`Object`（因此，引用相等）被视为一个缺点。解决任何这些问题意味着解决所有这些问题。
- en: 21.5\. Moving Java forward faster
  id: totrans-785
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.5. 加速Java的发展
- en: There have been ten major releases of Java in 22 years—an average of more than
    two years between releases. In some cases, the wait was five years. The Java architects
    realized that this situation is no longer sustainable because it doesn’t evolve
    the language fast enough and is the main reason why emerging languages on the
    JVM (such as Scala and Kotlin) are creating a huge feature gap for Java. Such
    a long release cycle is arguably reasonable for huge and revolutionary features
    such as lambdas and the Java Module System, but it also implies that minor improvements
    have to wait, for no valid reason, for the complete implementation of one of those
    big changes before being incorporated into the language. The collection factory
    methods discussed in [chapter 8](kindle_split_020.xhtml#ch08), for example, were
    ready to ship long before the Java 9 module system was finalized.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 在22年内，Java已经发布了十个主要版本——平均每个版本之间相隔两年多。在某些情况下，等待时间长达五年。Java架构师意识到，这种情况已经不再可持续，因为它不能足够快地推动语言的发展，这也是为什么在JVM上新兴的语言（如Scala和Kotlin）为Java创造了一个巨大的功能差距的主要原因。对于像lambda和Java模块系统这样巨大且革命性的功能，这样的长发布周期可以说是合理的，但它也意味着，在将这些大变化之一完全实现之前，任何小的改进都必须无理由地等待，然后才能被纳入语言中。例如，[第8章](kindle_split_020.xhtml#ch08)中讨论的集合工厂方法，在Java
    9模块系统最终确定之前就已经准备好发货了。
- en: For these reasons, it has been decided that from now on, Java will have a six-month
    development cycle. In other words, a new major version of Java and the JVM will
    appear every six months, with Java 10 released in March 2018 and Java 11 due in
    September 2018\. The Java architects also realized that although this faster development
    cycle is beneficial for the language itself, and also for agile companies and
    developers who are used to constantly experimenting with new technologies, it
    could be problematic for more conservative organizations, which generally update
    their software at a slower pace. For that reason, the Java architects also decided
    that every three years, there’ll be a long-term support (LTS) release that will
    be supported for the subsequent three years. Java 9 isn’t an LTS release, so it’s
    considered to be at the end of its life now Java 10 is out. The same thing will
    happen with Java 10\. Java 11, by contrast, will be an LTS version, with release
    planned for September 2018 and supported until September 2021\. [Figure 21.2](#ch21fig02)
    shows the life cycle of the Java versions that are planned for released in the
    next few years.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，已经决定从现在开始，Java将拥有六个月的开发周期。换句话说，Java和JVM的新主要版本将每六个月出现一次，Java 10于2018年3月发布，Java
    11预计于2018年9月发布。Java架构师也意识到，尽管这种更快的开发周期对语言本身以及习惯于不断尝试新技术的敏捷公司和开发者来说是有益的，但它可能对更保守的组织造成问题，这些组织通常以较慢的速度更新其软件。因此，Java架构师还决定，每三年将有一个长期支持（LTS）版本，将在随后的三年内得到支持。Java
    9不是一个LTS版本，因此现在被认为已经走到了生命的尽头，因为Java 10已经发布。同样的事情也会发生在Java 10上。相比之下，Java 11将是一个LTS版本，计划于2018年9月发布，并支持到2021年9月。[图21.2](#ch21fig02)显示了计划在未来几年发布的Java版本的生命周期。
- en: Figure 21.2\. The life cycle of future Java releases
  id: totrans-788
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图21.2. 未来Java版本的生命周期
- en: '![](Images/21fig02_alt.jpg)'
  id: totrans-789
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/21fig02_alt.jpg)'
- en: We strongly empathize with the decision to give Java a shorter development cycle,
    especially nowadays, when all software systems and languages are meant to improve
    as quickly as possible. A shorter development cycle enables Java to evolve at
    the right speed and allows the language to remain relevant and appropriate in
    the coming years.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈认同缩短Java开发周期的决定，尤其是在现在，当所有软件系统和语言都旨在尽可能快速地改进的时候。较短的开发周期使Java能够以适当的速度进化，并使语言在未来几年保持相关性和适用性。
- en: 21.6\. The final word
  id: totrans-791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.6. 最后的话
- en: This book explored the main new features added by Java 8 and 9\. Java 8 represents
    perhaps the biggest evolution step ever taken by Java. The only comparably large
    evolution step was the introduction, a decade previously (in 2005), of generics
    in Java 5\. The most characteristic feature of Java 9 is the introduction of the
    long-awaited module system, which is likely to be more interesting for software
    architects than to developers. Java 9 also embraced reactive streams by standardizing
    its protocol through the Flow API. Java 10 introduces local-variable type inference,
    which is a popular feature in other programming languages to help productivity.
    Java 11 allows the `var` syntax of local-variable type inference to be used in
    the list of parameters of an implicitly typed lambda expression. Perhaps more
    importantly, Java 11 embraces the concurrency and reactive programming ideas discussed
    in this book and brings a new asynchronous HTTP client library that fully adopts
    `CompletableFutures`. Finally, at the time of writing, Java 12 was announced to
    support an enhanced switch construct that can be used as an expression instead
    of just a statement—a key feature of functional programming languages. In fact,
    switch expressions pave the way for the introduction of pattern matching in Java,
    which we discussed in [section 21.4.2](#ch21lev2sec8). All these language updates
    show that functional programming ideas and influence will continue to make their
    way into Java in the future!
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书探讨了Java 8和9添加的主要新特性。Java 8可能代表了Java历史上迈出的最大一步。与之相比，上一个十年前（2005年）Java 5中泛型的引入，也是一个相当大的进化步骤。Java
    9最显著的特征是引入了期待已久的模块系统，这对软件架构师可能比开发者更有趣。Java 9还通过Flow API标准化了其协议，从而拥抱了响应式流。Java
    10引入了局部变量类型推断，这是在其他编程语言中流行的功能，有助于提高生产力。Java 11允许将局部变量类型推断的`var`语法用于隐式类型lambda表达式的参数列表。也许更重要的是，Java
    11接受了本书讨论的并发和响应式编程思想，并带来一个新的异步HTTP客户端库，该库完全采用`CompletableFutures`。最后，在撰写本文时，Java
    12宣布支持一个增强的switch结构，它可以作为一个表达式而不是仅仅作为一个语句使用——这是函数式编程语言的一个关键特性。实际上，switch表达式为Java中模式匹配的引入铺平了道路，我们在[第21.4.2节](#ch21lev2sec8)中讨论了这一点。所有这些语言更新都表明，函数式编程思想和影响将继续在未来进入Java！
- en: 'In this chapter, we looked at pressures for further Java evolution. In conclusion,
    we propose the following statement:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了进一步Java进化的压力。总之，我们提出以下声明：
- en: '*Java 8, 9, 10, and 11 are excellent places to pause but not to stop!*'
  id: totrans-794
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Java 8、9、10和11是暂停但不要停止的地方！*'
- en: We hope that you’ve enjoyed this learning adventure with us and that we’ve sparked
    your interest in exploring the further evolution of Java.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您已经享受了与我们一起的学习之旅，并且我们已经激发了您探索Java进一步演化的兴趣。
