- en: Part 3\. The SPA server
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三部分。SPA服务器
- en: When a user navigates through a traditional website, the server burns lots of
    processing power to generate and send page after page of content to the browser.
    The SPA server is quite different. Most of the business logic—and all of the HTML
    templating and presentation logic—is moved to the client. The server remains important,
    but it becomes leaner and more focused on services like persistent data storage,
    data validation, user authentication, and data synchronization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在传统网站上导航时，服务器会消耗大量的处理能力来生成并发送一页又一页的内容到浏览器。SPA服务器则截然不同。大部分的业务逻辑——以及所有的HTML模板和展示逻辑——都被移到了客户端。服务器仍然很重要，但它变得更加精简，更专注于像持久数据存储、数据验证、用户认证和数据同步等服务。
- en: 'Historically, web developers had to spend a good deal of time developing logic
    to transform one data format to another, much like shoveling dirt from one giant,
    musty dirt pile to another—and just about as productive. Web developers have also
    had to master many different languages and toolkits. A traditional website stack
    might require detailed knowledge of SQL, Apache2, mod_rewrite, mod_perl2, Perl,
    DBI, HTML, CSS, and JavaScript. Learning all these languages and switching between
    them is expensive and annoying. Even worse, if we need to move some logic from
    one part of the application to the other, we get to rewrite it in a completely
    different language. In [part 3](#part03) we learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，网络开发者不得不花费大量时间开发逻辑来转换一种数据格式到另一种，就像把泥土从一个大而潮湿的土堆铲到另一个土堆一样——而且几乎一样低效。网络开发者还必须掌握许多不同的语言和工具包。一个传统的网站堆栈可能需要详细了解SQL、Apache2、mod_rewrite、mod_perl2、Perl、DBI、HTML、CSS和JavaScript。学习所有这些语言并在它们之间切换是昂贵且令人烦恼的。更糟糕的是，如果我们需要将一些逻辑从一个应用程序的部分移动到另一个部分，我们就必须用完全不同的语言重写它。在[第三部分](#part03)中我们学到：
- en: The fundamentals of Node.js and MongoDB
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js和MongoDB的基础知识
- en: How to stop wasting server cycles on data transformations and instead use the
    JSON data format throughout the SPA stack
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何停止在数据转换上浪费服务器周期，转而在整个SPA堆栈中使用JSON数据格式
- en: How to build an HTTP server application and interact with the database using
    only one language—JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何仅使用一种语言——JavaScript构建HTTP服务器应用程序并与之交互
- en: The challenges of SPA deployment and how we can resolve them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPA部署的挑战以及我们如何解决它们
- en: We use JSON and JavaScript end-to-end in our stack. This *eliminates* the overhead
    of data transformations. And it *significantly reduces* the number of languages
    and development environments we need to master. The result is a better product
    that’s significantly less expensive to develop, deliver, and maintain.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的堆栈中端到端使用JSON和JavaScript。这*消除了*数据转换的开销。并且它*显著减少了*我们需要掌握的语言和开发环境数量。结果是更好的产品，其开发、交付和维护的成本显著降低。
- en: Chapter 7\. The web server
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第七章. 网络服务器
- en: '|  |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: The role of the web server when supporting an SPA
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在支持SPA时，网络服务器的作用
- en: Using JavaScript as the web server language with Node.js
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js作为网络服务器语言
- en: Using Connect middleware
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Connect中间件
- en: Using the Express framework
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express框架
- en: Configuring Express to support an SPA architecture
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Express以支持SPA架构
- en: Routing and CRUD
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由和CRUD
- en: Messaging using Socket.IO and why we care
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Socket.IO进行消息传递以及我们为什么关心
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This chapter discusses the logic and code a server needs to support an SPA.
    It also provides a good introduction to Node.js. If after reading this chapter
    you’re really excited and want to build out a fully production-ready application
    using Node.js, we suggest checking out the book *Node.js in Action* (Manning 2013).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了服务器支持SPA所需的逻辑和代码。它还提供了Node.js的良好入门介绍。如果在阅读本章后你真的非常兴奋，并想使用Node.js构建一个完全可投入生产的应用程序，我们建议查看书籍《Node.js实战》（Manning
    2013）。
- en: 7.1\. The role of the server
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1. 服务器的作用
- en: An SPA moves much of the business logic found on the server in a traditional
    website to the browser. But we still need some server Ying to match the browser
    client Yang. There are areas where the web server must be involved to achieve
    a desired effect—for example, security—or where the server is better suited to
    the task than the client. The most common responsibilities of an SPA web server
    include *authentication and authorization*, *data validation*, and *data storage
    and synchronization*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用（SPA）将传统网站服务器上发现的大部分业务逻辑移动到了浏览器。但我们需要一些服务器端的“阴”来匹配客户端的“阳”。有些领域需要网络服务器参与以实现预期效果——例如，安全性——或者服务器比客户端更适合执行任务。SPA网络服务器最常见的职责包括*身份验证和授权*、*数据验证*以及*数据存储和同步*。
- en: 7.1.1\. Authentication and authorization
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1\. 身份验证和授权
- en: '*Authentication* is the process of making sure that someone is who they say
    they are. The server is needed because we should never rely solely on data provided
    from the client. If authentication was handled solely on the client side, a malicious
    hacker could reverse-engineer the authentication mechanism and create the necessary
    credentials to impersonate a user and steal their account. Authentication is often
    initiated by the user entering a user name and password.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*身份验证*是确保某人就是他们所说的那个人的过程。服务器是必需的，因为我们绝不应该仅依赖于客户端提供的数据。如果身份验证仅由客户端处理，恶意黑客可能会逆向工程身份验证机制并创建必要的凭证来冒充用户并窃取他们的账户。身份验证通常是通过用户输入用户名和密码来启动的。'
- en: Increasingly, developers are turning to third-party authentication services,
    such as those provided by Facebook or Yahoo. When authenticating with a third
    party, the user is required to provide credentials—typically a username and password—*for*
    the third-party service. If, for example, we use Facebook authentication, the
    user will be expected to provide the username and password for their Facebook
    account to the Facebook server. The third-party server then communicates with
    our server to authenticate the user. The advantage to users is they can reuse
    a username and password they’ve already memorized. The advantage to developers
    is they get to outsource most of the tedious details of implementation and get
    access to the third party’s user population.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的开发者转向第三方身份验证服务，例如由Facebook或Yahoo提供的服务。当与第三方进行身份验证时，用户需要提供第三方服务的凭证——通常是用户名和密码。例如，如果我们使用Facebook身份验证，用户将被期望向Facebook服务器提供他们的Facebook账户的用户名和密码。然后第三方服务器与我们的服务器通信以验证用户。对用户的好处是他们可以重用他们已经记住的用户名和密码。对开发者的好处是他们可以将实现的大部分繁琐细节外包出去，并获得访问第三方用户群体的权限。
- en: '*Authorization* is the processes of ensuring that only people and systems that
    are supposed to have access to data are able to receive it. This can be accomplished
    by tying permissions to a user, so that when the user signs in there’s a record
    of what they’re permitted to see. It’s important that authorization be handled
    on the server so that no unauthorized data is ever sent to the client. Otherwise,
    our malicious hacker could again reverse-engineer our application and access sensitive
    information they’re not supposed to see. A side benefit of authorization is that
    because it only sends data that a user is authorized to see, it minimizes the
    amount of data sent to the client, potentially making the transaction much quicker.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*授权*是确保只有那些应该有权访问数据的人或系统能够接收数据的流程。这可以通过将权限绑定到用户来实现，这样当用户登录时，会有一个记录表明他们被允许看到什么。确保授权在服务器上处理非常重要，这样就不会向客户端发送未经授权的数据。否则，我们的恶意黑客可能会再次逆向工程我们的应用程序并访问他们不应该看到的敏感信息。授权的一个附带好处是，因为它只发送用户有权看到的数据，所以它最小化了发送到客户端的数据量，可能使交易变得更快。'
- en: 7.1.2\. Validation
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2\. 验证
- en: Validation is a quality control process, ensuring that only accurate and reasonable
    data can be saved. Validation helps prevent errors from being saved and propagated
    to other users or systems. For example, an airline might validate that when a
    user selects a flight date for purchasing a ticket, they’re selecting a date in
    the future that has available seats. Without this validation, the airline could
    overbook flights, book seats on flights that don’t exist, or book seats on flights
    that have already departed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 验证是一个质量控制过程，确保只能保存准确和合理的数据。验证有助于防止错误被保存并传播到其他用户或系统。例如，航空公司可能会验证当用户选择购买机票的航班日期时，他们选择的是有可用座位的未来日期。如果没有这种验证，航空公司可能会超额预订航班，预订不存在航班的座位，或者预订已经起飞航班的座位。
- en: 'It’s important that validation occur on both the client side and the server:
    it should be implemented on the client for a speedy response, and it should be
    validated on the server because it should never trust code from the client to
    be valid. All sorts of issues could result in the server receiving invalid data:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 验证在客户端和服务器端都发生很重要：它应该在客户端实现以获得快速响应，并且应该在服务器上验证，因为它永远不应该信任客户端的代码是有效的。服务器接收无效数据可能会导致各种问题：
- en: A programming error could damage or omit client validation from the SPA.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程错误可能会损坏或省略SPA中的客户端验证。
- en: A different client may lack validation—web server applications often have multiple
    clients accessing the same server.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的客户端可能缺乏验证——Web服务器应用程序通常有多个客户端访问同一个服务器。
- en: A once-valid option could become invalid by the time the data is submitted (say,
    the seat was booked by someone else just after the user clicked Submit).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个曾经有效的选项可能在数据提交时变得无效（比如说，用户点击提交后，有人刚刚预订了座位）。
- en: Our malicious hacker might again appear and attempt to hijack or break the site
    by stuffing our data store with corrupt data.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的恶意黑客可能会再次出现，并试图通过用损坏的数据填充我们的数据存储来劫持或破坏网站。
- en: The classic example of improper server validation is the SQL-injection attacks
    which have embarrassed many notable organizations that really should have known
    better. We don’t want to join that club, do we?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不当的服务器验证的经典例子是SQL注入攻击，这些攻击让许多本应知道更好的知名组织感到尴尬。我们不想加入那个行列，对吧？
- en: 7.1.3\. Preservation and synchronization of data
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.3. 数据的保留和同步
- en: Although an SPA can save data in the client, that data is transitory and is
    easily modified or deleted outside of control of the SPA. In most cases, the client
    should be used only for temporary storage, with the server being responsible for
    long-term storage.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单页应用（SPA）可以在客户端保存数据，但这些数据是临时的，并且很容易在SPA的控制之外被修改或删除。在大多数情况下，客户端应仅用于临时存储，服务器负责长期存储。
- en: 'Data may also need to be synchronized between multiple clients, like when a
    person’s online status needs to be shared with everyone who’s viewing their home
    page. The simplest way to accomplish this is to have the client send the status
    to the server, have the server save it, and then broadcast the status to all authenticated
    clients. Synchronizing may also be used with transient data; for example, when
    we use a chat server to dispatch messages to an authenticated client: though the
    server doesn’t store the data, it has the critical task of routing the messages
    to the correct authenticated clients.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可能还需要在多个客户端之间同步，比如当一个人的在线状态需要与查看他们主页的每个人共享时。实现这一点的最简单方法是让客户端将状态发送到服务器，让服务器保存它，然后将状态广播给所有经过身份验证的客户端。同步也可以用于临时数据；例如，当我们使用聊天服务器向经过身份验证的客户端发送消息时：尽管服务器不存储数据，但它有将消息路由到正确的经过身份验证的客户端的关键任务。
- en: 7.2\. Node.js
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2. Node.js
- en: '*Node.js* is a platform that uses JavaScript as its control language. When
    we use it as an HTTP server, it’s philosophically similar to Twisted, Tornado,
    or mod_perl. Many other popular web server platforms, in contrast, are split into
    two components: the HTTP server and the application process container. Examples
    include Apache/PHP, Passenger/Ruby, or Tomcat/Java.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*Node.js* 是一个使用JavaScript作为其控制语言的平台。当我们将其用作HTTP服务器时，它在哲学上与Twisted、Tornado或mod_perl相似。相比之下，许多其他流行的Web服务器平台被分为两个组件：HTTP服务器和应用进程容器。例如，包括Apache/PHP、Passenger/Ruby或Tomcat/Java。'
- en: Writing the HTTP server and application together enables us to easily complete
    some tasks that are difficult on platforms with separate HTTP and application
    components. If, for example, we want to write our logs to an in-memory database,
    we can do so without having to worry about where the HTTP server stops and the
    application server begins.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将HTTP服务器和应用程序一起编写使我们能够轻松完成在具有独立HTTP和应用程序组件的平台上的某些任务。例如，如果我们想将日志写入内存数据库，我们可以这样做，而无需担心HTTP服务器在哪里结束，应用程序服务器在哪里开始。
- en: 7.2.1\. Why Node.js?
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. 为什么选择Node.js？
- en: 'We’ve selected Node.js as our server platform because it has capabilities that
    make it a great choice for a modern SPA:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择Node.js作为我们的服务器平台，因为它具备使它成为现代SPA（单页应用）优秀选择的特性：
- en: The server is the application. The result is not having to worry about setting
    up and interfacing with a separate application server. Everything is controlled
    in one place, by one process.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器就是应用程序。结果是无需担心设置和与单独的应用程序服务器接口。所有控制都在一个地方，由一个进程完成。
- en: The server application language is JavaScript, meaning we can eliminate the
    cognitive load of writing the server application in one language and the SPA in
    another. It also means we can share code between the client and server, which
    has many advantages. For example, we might use the same data validation libraries
    on both the SPA and the server.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器应用程序的语言是JavaScript，这意味着我们可以消除在一种语言中编写服务器应用程序而在另一种语言中编写SPA的认知负担。这也意味着我们可以在客户端和服务器之间共享代码，这有许多优点。例如，我们可能在SPA和服务器上使用相同的数据验证库。
- en: Node.js is non-blocking and event-driven. In a nutshell, this means a single
    Node.js instance on modest hardware can handle tens or hundreds of thousands of
    concurrent open connections, such as those used in real-time messaging, which
    is often a highly desired feature of modern SPAs.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js是非阻塞和事件驱动的。简而言之，这意味着在适度硬件上，单个Node.js实例可以处理成千上万的并发打开连接，如实时消息中使用的连接，这通常是现代SPA高度期望的特性。
- en: Node.js is fast, well supported, and has a rapidly growing body of modules and
    developers.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js速度快，支持良好，并且拥有快速增长的模块和开发者群体。
- en: Node.js handles network requests differently than most other server platforms.
    Most HTTP servers maintain a pool of processes or threads that are kept ready
    to service incoming requests. Node.js, in contrast, only has one event queue that
    processes each incoming request as it happens, and even splits up the processing
    of parts of an incoming request into separate events in the main event queue.
    What this means in practice is that Node.js doesn’t tend to wait around for a
    long event to finish before processing other events. If a particular database
    query is taking a long time, Node.js goes right on processing other events. When
    the database query does finish, an event is placed in the queue so that the controlling
    routine may use the results.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js处理网络请求的方式与大多数其他服务器平台不同。大多数HTTP服务器维护一个进程或线程池，以准备服务传入的请求。相比之下，Node.js只有一个事件队列，它会处理每个传入的请求，并且甚至将传入请求的部分处理拆分为主事件队列中的单独事件。在实践中，这意味着Node.js不会在处理其他事件之前等待长时间的事件完成。如果某个数据库查询耗时较长，Node.js会继续处理其他事件。当数据库查询完成时，一个事件会被放入队列，以便控制例程可以使用结果。
- en: Without further ado, let’s get into Node.js and see how to create a web server
    application with it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们深入了解Node.js，看看如何用它创建一个网络服务器应用程序。
- en: 7.2.2\. Create ‘Hello World’ using Node.js
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2\. 使用Node.js创建“Hello World”
- en: Let’s go to the Node.js site ([http://nodejs.org/#download](http://nodejs.org/#download))
    and download and install Node.js. There are many ways to download and install
    it; the simplest, if you’re not familiar with the command line, is probably to
    use the installer for your operating system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去Node.js网站([http://nodejs.org/#download](http://nodejs.org/#download))下载并安装Node.js。有许多下载和安装它的方法；如果你不熟悉命令行，最简单的方法可能是使用操作系统的安装程序。
- en: 'The Node Package Manager, `npm`, is installed along with Node.js. It is similar
    to Perl’s `CPAN`, Ruby’s `gem`, or Python’s `pip`. On our command, it downloads
    and installs packages, resolving dependencies along the way. It’s much easier
    than manually doing this ourselves. Now that we have Node.js and `npm` installed,
    let’s create our first server. The Node.js website ([http://nodejs.org](http://nodejs.org))
    has an example of a simple Node web server, so we’ll use that. Let’s create a
    directory called webapp and make it our working directory. Then we can create
    a file in it called app.js with the code in [listing 7.1](#ch07list01):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Node包管理器`npm`与Node.js一起安装。它类似于Perl的`CPAN`、Ruby的`gem`或Python的`pip`。根据我们的命令，它下载并安装包，同时解决依赖关系。这比我们手动做要容易得多。现在我们已经安装了Node.js和`npm`，让我们创建我们的第一个服务器。Node.js网站([http://nodejs.org](http://nodejs.org))有一个简单的Node网络服务器的示例，所以我们将使用它。让我们创建一个名为webapp的目录并将其作为工作目录。然后我们可以在其中创建一个名为app.js的文件，并包含[列表7.1](#ch07list01)中的代码：
- en: Listing 7.1\. Create a simple node server application—`webapp/app.js`
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.1\. 创建一个简单的Node服务器应用程序—`webapp/app.js`
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open a terminal, navigate to the directory where we saved our app.js file,
    and start the server with the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端，导航到我们保存app.js文件的目录，并使用以下命令启动服务器：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should see `Listening on port 3000`. When we open a web browser (on the
    same computer) and go to `http://localhost:3000`, we should see `Hello World`
    appear in the browser. Wow, that was simple! A server in only seven lines of code.
    I don’t know how you feel right about now, but I was delighted to have a web server
    application written and running in minutes. Now let’s walk through what the code
    means.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到`Listening on port 3000`。当我们打开一个网络浏览器（在同一台计算机上）并访问`http://localhost:3000`时，我们应该在浏览器中看到`Hello
    World`出现。哇，这很简单！只用七行代码就创建了一个服务器。我不知道你现在感觉如何，但我很高兴能在几分钟内编写并运行一个网络服务器应用程序。现在让我们来分析一下代码的含义。
- en: 'Our first section is our standard heading with JSLint settings. It allows us
    to validate our server JavaScript just like we do with our client:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一部分是带有JSLint设置的常规标题。它允许我们验证我们的服务器JavaScript，就像我们验证客户端JavaScript一样：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next line declares the module-scope variable we will be using:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个行声明我们将使用的模块作用域变量：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next line tells Node.js to include the `http` module for use in this server
    application. It’s similar to using HTML `script` tags to include JavaScript files
    for use by the browser. The `http` module is a core Node.js module used to create
    an HTTP server, and we store the module in the variable `http`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个行告诉Node.js包含`http`模块以供此服务器应用程序使用。这类似于使用HTML `script`标签包含JavaScript文件以供浏览器使用。`http`模块是一个Node.js核心模块，用于创建HTTP服务器，我们将模块存储在变量`http`中：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next we use the `http.createServer` method to create an HTTP server. We provide
    it an anonymous function that will be called whenever the Node.js server receives
    a request event. The function receives a `request` object and a `response` object
    as arguments. The `request` object is the HTTP request sent by the client:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们使用`http.createServer`方法创建一个HTTP服务器。我们提供一个匿名函数，每当Node.js服务器接收到请求事件时都会调用该函数。该函数接收一个`request`对象和一个`response`对象作为参数。`request`对象是客户端发送的HTTP请求：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside our anonymous function, we begin defining the response to the HTTP request.
    The next line creates the HTTP headers using the `response` argument. We provide
    a `200` HTTP response code to indicate success, and we provide an anonymous object
    with the property `Content-Type` and the value `text/plain`. This tells the browser
    what sort of content to expect in the message:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的匿名函数内部，我们开始定义对HTTP请求的响应。下一行使用`response`参数创建HTTP头。我们提供一个`200`的HTTP响应代码来指示成功，并提供一个具有`Content-Type`属性和`text/plain`值的匿名对象。这告诉浏览器在消息中期望什么类型的内容：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next line uses the `response.end` method to send the string `‘Hello World''`
    to the client and let Node.js know that we’re done with this response:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个行使用`response.end`方法向客户端发送字符串`‘Hello World'`，并让Node.js知道我们已经完成了这个响应：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then close the anonymous function and the call to the `createServer` method.
    The code then chains a call to the `listen` method on the `http` object. The `listen`
    method instructs the `http` object to listen on port 3000:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后关闭匿名函数和对`createServer`方法的调用。代码随后在`http`对象上链式调用`listen`方法。`listen`方法指示`http`对象监听3000端口：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our last line prints to the console when this server application is started.
    We are able to use an attribute from the `server` object we created earlier to
    report the port that is being used:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一行代码在启动此服务器应用程序时打印到控制台。我们能够使用我们之前创建的`server`对象的一个属性来报告正在使用的端口号：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’ve used Node.js to create a very basic server. It’s worth spending some
    time playing around with the `request` and `response` arguments passed to the
    anonymous function in the `http.createServer` method. Let’s start by logging the
    `request` argument in [listing 7.2](#ch07list02). The new line is shown in **bold**:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 Node.js 创建了一个非常基本的服务器。花些时间在`http.createServer`方法中传递给匿名函数的`request`和`response`参数上玩耍是值得的。让我们从在[列表
    7.2](#ch07list02)中记录`request`参数开始。新行以**粗体**显示：
- en: Listing 7.2\. Add simple logging to a node server application—`webapp/app.js`
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. 向节点服务器应用程序添加简单的日志记录—`webapp/app.js`
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When we restart the web application, we’ll see the object logged, shown in [listing
    7.3](#ch07list03), in the terminal where the Node.js application is running. Don’t
    worry too much about the structure of the object right now; we’ll go over the
    parts we need to know later.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新启动网络应用程序时，我们将在运行 Node.js 应用程序的终端中看到对象被记录，如[列表 7.3](#ch07list03)所示。现在不必太在意对象的架构；我们稍后会讲解我们需要了解的部分。
- en: Listing 7.3\. The request object
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. 请求对象
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Some notable properties of the `request` object include:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`request`对象的一些显著属性包括：'
- en: '`ondata`—A method that gets called when the server starts receiving data from
    the client, for example when `POST` variables are set. This is a substantially
    different method of getting arguments from the client than most frameworks. We’ll
    abstract this away so that the full list of parameters is available in a variable.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ondata`——当服务器开始从客户端接收数据时会被调用的一个方法，例如当设置`POST`变量时。这与大多数框架从客户端获取参数的方法有显著不同。我们将抽象化这部分，以便在变量中提供完整的参数列表。'
- en: '`headers`—All of the headers from the request.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`——请求中的所有头部信息。'
- en: '`url`—The page that was requested without the host. For example, [http://www.singlepagewebapp.com/test](http://www.singlepagewebapp.com/test)
    will have a `url` of `/test`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`——请求的页面，不包含主机。例如，[http://www.singlepagewebapp.com/test](http://www.singlepagewebapp.com/test)
    的 `url` 将是 `/test`。'
- en: '`method`—The method used to make the request: `GET` or `POST`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`——用于发送请求的方法：`GET`或`POST`。'
- en: 'Armed with the knowledge of these attributes, we can start to write a rudimentary
    router in [listing 7.4](#ch07list04). Changes are shown in **bold**:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 带着对这些属性的知识的武装，我们可以开始编写一个基本的路由器，如[列表 7.4](#ch07list04)所示。变化以**粗体**显示：
- en: Listing 7.4\. Add simple routing to a node server application—`webapp/app.js`
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4\. 向节点服务器应用程序添加简单的路由—`webapp/app.js`
- en: '![](235fig01_alt.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](235fig01_alt.jpg)'
- en: We could continue to write our own router, and for simple applications that
    is a reasonable choice. We have larger aspirations for our server application,
    however, and we’d like to use a framework that the Node.js community has developed
    and tested. The first framework we will consider is Connect.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续编写我们自己的路由器，对于简单的应用程序来说，这是一个合理的选择。然而，我们对我们的服务器应用程序有更大的抱负，我们希望使用 Node.js
    社区开发和测试过的框架。我们将考虑的第一个框架是 Connect。
- en: 7.2.3\. Install and use Connect
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3\. 安装和使用 Connect
- en: Connect is an extensible *middleware* framework that adds capabilities like
    basic authentication, session management, static file serving, and form handling
    to a Node.js web server. It’s not the only framework available, but it’s simple
    and relatively standard. Connect allows us to inject *middleware* functions between
    the receipt of a request and the final response. Generally, a middleware function
    takes an incoming request, performs some actions on it, and then hands the request
    to the next middleware function or ends the response using the `response.end`
    method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Connect 是一个可扩展的 *中间件* 框架，它为 Node.js 网络服务器添加了基本认证、会话管理、静态文件服务和表单处理等功能。它不是唯一的框架，但它是简单且相对标准的。Connect
    允许我们在请求接收和最终响应之间注入 *中间件* 函数。通常，中间件函数接收一个传入的请求，对其进行一些操作，然后将请求传递给下一个中间件函数或使用`response.end`方法结束响应。
- en: 'The best way to become familiar with Connect and the middleware pattern is
    to use it. Let’s ensure webapp is our working directory, and install connect.
    Type the following at the command line:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉 Connect 和中间件模式最好的方式是使用它。让我们确保 webapp 是我们的工作目录，并安装 connect。在命令行中输入以下内容：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will create a folder called node_modules and install the Connect framework
    inside of it. The node_modules directory is the folder that all of the modules
    for your Node.js application go in. `npm` will install modules in this directory,
    and when we write our own modules, this is where they’ll go. We can modify our
    server application as shown in [listing 7.5](#ch07list05). Changes are shown in
    **bold**:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 node_modules 的文件夹，并在其中安装 Connect 框架。node_modules 目录是所有 Node.js 应用程序模块的文件夹。`npm`
    将在此目录中安装模块，当我们编写自己的模块时，它们将放在这里。我们可以按照 [列表 7.5](#ch07list05) 中的说明修改我们的服务器应用程序。变更以**粗体**显示：
- en: Listing 7.5\. Modify the node server application to use Connect—`webapp/app.js`
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5\. 修改节点服务器应用程序以使用 Connect—`webapp/app.js`
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This Connect server behaves very much like our first node server in the previous
    section. We define our first middleware function, `connectHello`, and then tell
    the Connect object, `app`, to use this method as its one and only middleware function.
    Since the `connectHello` function invokes the `response.end` method, it concludes
    the server response. Let’s build on this by adding more middleware.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Connect 服务器的行为与上一节中的第一个节点服务器非常相似。我们定义了第一个中间件函数 `connectHello`，然后告诉 Connect
    对象 `app` 使用这个方法作为其唯一的中间件函数。由于 `connectHello` 函数调用了 `response.end` 方法，它结束了服务器响应。让我们在此基础上添加更多的中间件。
- en: 7.2.4\. Add Connect middleware
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.4\. 添加 Connect 中间件
- en: 'Let’s say that we want to log every time someone accesses a page. We do that
    using a built-in middleware function that Connect provides. [Listing 7.6](#ch07list06)
    shows the addition of the `connect.logger()` middleware function. Changes are
    shown in **bold**:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要记录每次有人访问页面时的情况。我们可以使用 Connect 提供的内置中间件函数来实现。[列表 7.6](#ch07list06) 展示了添加
    `connect.logger()` 中间件函数。变更以**粗体**显示：
- en: Listing 7.6\. Add logging to a node server application using Connect—`webapp/app.js`
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.6\. 使用 Connect 向节点服务器应用程序添加日志—`webapp/app.js`
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All we did was add `connect.logger()` as middleware before our `connectHello`
    middleware. Now every time a client issues an HTTP request to the server application,
    the first middleware function that gets invoked is `connect.logger()`, which prints
    out log information to the console. The *next* middleware function that gets called
    is the one we defined, `connectHello`, which, as before, sends `Hello Connect`
    to the client and ends the response. When we point our browser to http://localhost:3000,
    we should see something like the following in the Node.js console log:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的只是在我们定义的 `connectHello` 中间件之前添加了 `connect.logger()` 作为中间件。现在每次客户端向服务器应用程序发出
    HTTP 请求时，首先被调用的中间件函数是 `connect.logger()`，它将日志信息打印到控制台。随后被调用的下一个中间件函数是我们定义的 `connectHello`，它像之前一样向客户端发送
    `Hello Connect` 并结束响应。当我们将浏览器指向 http://localhost:3000 时，我们应该在 Node.js 控制台日志中看到以下内容：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Even though Connect is a higher-level abstraction than Node.js, we would like
    even more capability. It’s time to upgrade to Express.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Connect 比 Node.js 是一个更高级的抽象，但我们希望有更多的功能。是时候升级到 Express 了。
- en: 7.2.5\. Install and use Express
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.5\. 安装和使用 Express
- en: Express is a lightweight web framework designed after Sinatra, a lightweight
    Ruby web framework. In an SPA we don’t need to take full advantage of every feature
    that Express offers, but it does provide a richer feature set than Connect—in
    fact, it is built on top of Connect.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Express 是一个轻量级 Web 框架，其设计灵感来自 Sinatra，一个轻量级的 Ruby Web 框架。在 SPA 中，我们不需要充分利用 Express
    提供的每个功能，但它确实提供了比 Connect 更丰富的功能集——实际上，它是建立在 Connect 之上的。
- en: 'Let’s ensure webapp is our working directory and install Express. Instead of
    using the command line like we did with Connect, we’ll use a manifest file called
    pack-age.json to tell `npm` what modules and versions our application needs to
    run correctly. This comes in handy when installing the application on a remote
    server or when someone downloads and installs our application on their machine.
    Let’s create pack-age.json to install Express as shown in [listing 7.7](#ch07list07):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 webapp 是我们的工作目录，并安装 Express。与之前使用 Connect 时的命令行不同，我们将使用名为 package.json 的清单文件来告诉
    `npm` 我们的应用程序需要哪些模块和版本才能正确运行。这在将应用程序安装到远程服务器或有人在我们机器上下载并安装我们的应用程序时非常有用。让我们创建 package.json
    以安装 Express，如 [列表 7.7](#ch07list07) 所示：
- en: Listing 7.7\. Create a manifest for `npm install`—webapp/package.json
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.7\. 为 `npm install` 创建清单—`webapp/package.json`
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `name` attribute is the name of our application; it can be whatever we
    want it to be. The `version` attribute is the version of your application, and
    it should use a major, minor, and patch version scheme (`<major>.<minor>.<patch>`).
    Setting the `private` attribute to `true` tells `npm` not to publish your application.
    Finally, the `dependencies` attribute describes the modules and versions we want
    `npm` to install. In this case we only have one module, `express`. Let’s first
    remove the existing webapp/ node_modules directory and then use `npm` to install
    Express:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 属性是应用程序的名称；它可以是我们想要的任何名称。`version` 属性是应用程序的版本，它应该使用主要、次要和补丁版本方案（`<major>.<minor>.<patch>`）。将
    `private` 属性设置为 `true` 告诉 `npm` 不要发布您的应用程序。最后，`dependencies` 属性描述了我们想要 `npm` 安装的模块和版本。在这种情况下，我们只有一个模块，即
    `express`。让我们首先删除现有的 webapp/ node_modules 目录，然后使用 `npm` 安装 Express：'
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When adding new modules with the `npm` command, we can use the `--save` option
    to automatically update package.json to contain the new module. This is handy
    during development. Notice also how we specified the version we wanted for Express
    as `"3.2.x"` which means we want Express version 3.2, with the latest patch. This
    is a recommended version declaration, as patches rarely break APIs but instead
    fix bugs or help ensure backward capability.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `npm` 命令添加新模块时，我们可以使用 `--save` 选项来自动更新 package.json 以包含新模块。这在开发过程中非常有用。注意我们如何指定我们想要的
    Express 版本为 `"3.2.x"`，这意味着我们想要 Express 版本 3.2，带有最新的补丁。这是一个推荐的版本声明，因为补丁很少破坏 API，而是修复错误或帮助确保向后兼容性。
- en: 'Now let’s edit app.js to use Express. We’ll be a little stricter in this implementation
    by using the `''use strict''` pragma and putting in a few section delimiters,
    as shown in [listing 7.8](#ch07list08). Changes are shown in **bold**:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编辑 app.js 以使用 Express。我们将在这个实现中使用 `'use strict'` 预言和几个部分分隔符，如 [列表 7.8](#ch07list08)
    所示。变化以 **粗体** 显示：
- en: Listing 7.8\. Create a node server application using Express—`webapp/app.js`
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.8\. 使用 Express 创建一个 node 服务器应用程序—`webapp/app.js`
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When looking at this small example, it might not be immediately apparent why
    Express is simpler to use, so let’s walk through the lines and see. First, we
    load the `express` and `http` modules (shown in **bold**):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这个小型示例时，可能不会立即明显地看出为什么 Express 更容易使用，所以让我们逐行分析并查看。首先，我们加载 `express` 和 `http`
    模块（如 **粗体** 所示）：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then create an `app` object using `express`. This object has methods for
    setting the routes and other properties of the application. We also create the
    HTTP `server` object, which we will use later (shown in **bold**):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `express` 创建一个 `app` 对象。该对象具有设置应用程序路由和其他属性的函数。我们还创建了 HTTP `server` 对象，我们将在以后使用它（如
    **粗体** 所示）：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next we define the routing for our application by using the `app.get` method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用 `app.get` 方法来定义我们应用程序的路由：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Express makes routing in Node.js simple thanks to a rich set of methods like
    `get`. The first argument to `app.get` is a pattern to compare with the request
    URL. For example, if a browser on our development box makes a request to http://localhost:3000
    or http://localhost:3000/, the `GET` request string will be ‘/’ which matches
    the pattern.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Express 提供了丰富的 `get` 等方法，Node.js 中的路由变得简单。`app.get` 的第一个参数是一个与请求 URL 进行比较的模式。例如，如果我们的开发机器上的浏览器向
    http://localhost:3000 或 http://localhost:3000/ 发送请求，则 `GET` 请求字符串将是 ‘/’，这与模式匹配。
- en: The second argument is a callback function that’s executed when a match occurs.
    The `request` and `response` objects are arguments provided to the callback function.
    Query string parameters can be found in `request.params`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个当匹配发生时执行的回调函数。`request` 和 `response` 对象是提供给回调函数的参数。查询字符串参数可以在 `request.params`
    中找到。
- en: 'Our third and final section starts the server and logs to the console:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三和最后一部分开始启动服务器并将日志记录到控制台：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that we have a working Express application, let’s add some middleware.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作的 Express 应用程序，让我们添加一些中间件。
- en: 7.2.6\. Add Express middleware
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.6\. 添加 Express 中间件
- en: Since Express is built on top of Connect, we can also call and pass along middleware
    using similar syntax. Let’s add the logging middleware for our app, as shown in
    7.9\. The changes are shown in **bold**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Express 是建立在 Connect 之上的，我们也可以使用类似的语法调用并传递中间件。让我们为我们的应用程序添加日志中间件，如 7.9 所示。变化以
    **粗体** 显示。
- en: Listing 7.9\. Add Express logging middleware to our application—`webapp/app.js`
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.9\. 将 Express 日志中间件添加到我们的应用程序中—`webapp/app.js`
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Express provides all of the Connect middleware methods so that we don’t have
    to require Connect in the page. Running the preceding code will result in the
    app logging requests to the console, just like `connect.logger` did in the last
    section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Express提供了所有的Connect中间件方法，这样我们就不需要在页面中引入Connect。运行前面的代码会导致应用程序将请求记录到控制台，就像上一节中的`connect.logger`所做的那样。
- en: We can organize our middleware using the Express `app.configure` method, as
    in [listing 7.10](#ch07list10). Changes are shown in **bold**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Express的`app.configure`方法来组织我们的中间件，就像[列表7.10](#ch07list10)中所示。变更以**粗体**显示。
- en: Listing 7.10\. Use configure to organize our Express middleware—`webapp/app.js`
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.10\. 使用configure组织我们的Express中间件—`webapp/app.js`
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This configuration adds two new middleware methods: `bodyParser` and `methodOver-ride`.
    `bodyParser` decodes forms and will be used extensively later. `methodOverride`
    is used for creating RESTful services. The `configure` method also lets us change
    our configuration depending on the Node.js environment in which the application
    is running.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置添加了两个新的中间件方法：`bodyParser`和`methodOver-ride`。`bodyParser`解码表单，将在以后广泛使用。`methodOverride`用于创建RESTful服务。`configure`方法还允许我们根据应用程序运行的Node.js环境更改配置。
- en: 7.2.7\. Use environments with Express
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.7\. 使用Express的环境
- en: 'Express supports the concept of switching configurations based on an environment
    setting. Example environments include `development`, `testing`, `staging`, and
    `production`. Express can determine which environment is being used by reading
    the `NODE_ENV` environment variable and will then respond by setting its configuration
    accordingly. If you’re using Windows, you would start the server application like
    this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Express支持根据环境设置切换配置的概念。示例环境包括`development`、`testing`、`staging`和`production`。Express可以通过读取`NODE_ENV`环境变量来确定正在使用哪个环境，然后相应地设置其配置。如果你使用Windows，你可以这样启动服务器应用程序：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using a Mac or Linux, set it like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Mac或Linux，设置如下：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you’re using something else, we have every confidence that you can figure
    it out.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是其他东西，我们非常有信心你能弄明白。
- en: We can use any string for an environment name when we run an Express server
    application. If no `NODE_ENV` variable is set, it uses `development` by default.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行Express服务器应用程序时，我们可以使用任何字符串作为环境名称。如果没有设置`NODE_ENV`变量，它将默认使用`development`。
- en: 'Let’s adjust our application to adjust itself to the environment being provided.
    We want to use the `bodyParser` and `methodOverride` middleware in every environment.
    In the `development` environment we would like the application to log HTTP requests
    and detailed errors. In the `production` environment we only want to log error
    summaries, as shown in [listing 7.11](#ch07list11). Changes are shown in **bold**:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整我们的应用程序以适应提供的环境。我们希望在每一个环境中都使用`bodyParser`和`methodOverride`中间件。在`开发`环境中，我们希望应用程序记录HTTP请求和详细错误。在`生产`环境中，我们只想记录错误摘要，如[列表7.11](#ch07list11)所示。变更以**粗体**显示：
- en: Listing 7.11\. Support different environments with Express—`webapp/app.js`
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.11\. 使用Express支持不同的环境—`webapp/app.js`
- en: '![](241fig01_alt.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](241fig01_alt.jpg)'
- en: We can test these configurations by running the application in development mode
    (`node app.js`) and loading the page in a browser. You should see the log output
    in the Node.js console. Next, we can stop the server and run it in production
    mode (`NODE_ENV=production node app.js`). When we reload the page in the browser,
    there should be no entry in the log.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在开发模式下运行应用程序（`node app.js`）并在浏览器中加载页面来测试这些配置。你应该在Node.js控制台中看到日志输出。接下来，我们可以停止服务器，并以生产模式运行它（`NODE_ENV=production
    node app.js`）。当我们重新加载浏览器中的页面时，日志中应该没有条目。
- en: Now that we have a good understanding of some of the fundamentals of Node.js,
    Connect, and Express, let’s move on to more advanced routing methods.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对Node.js、Connect和Express的一些基本原理有了很好的理解，让我们继续学习更高级的路由方法。
- en: 7.2.8\. Serving static files with Express
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.8\. 使用Express提供静态文件服务
- en: As you might expect, serving static files with Express requires adding a bit
    of middleware and a little redirection. Let’s copy the contents of the spa directory
    from [chapter 6](kindle_split_017.html#ch06) into a public directory as shown
    in [listing 7.12](#ch07list12).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，使用Express提供静态文件需要添加一些中间件和一点重定向。让我们将[第6章](kindle_split_017.html#ch06)中的spa目录的内容复制到公共目录中，如[列表7.12](#ch07list12)所示。
- en: Listing 7.12\. Add the public directory for static files
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.12\. 添加静态文件目录
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now we can adjust the application to serve the static files, as shown in [listing
    7.13](#ch07list13). Changes are shown in **bold**.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调整应用程序以提供静态文件，如[列表 7.13](#ch07list13)所示。变更以粗体显示。
- en: Listing 7.13\. Serve static files with Express—`webapp/app.js`
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.13\. 使用 Express 提供静态文件—`webapp/app.js`
- en: '![](243fig01_alt.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](243fig01_alt.jpg)'
- en: Now when we run the application (`node app.js`) and point our browser to http://localhost:3000,
    we should see our SPA as we left it in [chapter 6](kindle_split_017.html#ch06).
    We can’t sign in yet, though, as the backend isn’t ready for that yet.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行应用程序（`node app.js`）并将浏览器指向 http://localhost:3000，我们应该看到我们离开[第 6 章](kindle_split_017.html#ch06)时的
    SPA。尽管如此，我们目前还不能登录，因为后端还没有准备好。
- en: Now that we have a good feel for Express middleware, let’s look at advanced
    routing, which we will need for web data services.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Express 中间件有了很好的了解，让我们看看高级路由，这对于 Web 数据服务是必需的。
- en: 7.3\. Advanced routing
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 高级路由
- en: 'Until now, all our application has done is provide a route for the root of
    the web application and returned some text to the browser. In this section we’ll:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序所做的一切只是为 Web 应用程序的根提供路由，并向浏览器返回一些文本。在本节中，我们将：
- en: Use the Express framework to provide CRUD routes for managing `user` objects.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Express 框架为管理 `user` 对象提供 CRUD 路由。
- en: Set response properties, such as content type, for all routes used for CRUD.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有用于 CRUD 的路由设置响应属性，例如内容类型。
- en: Make the code generic so that it works for all CRUD routes.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使代码通用，以便它适用于所有 CRUD 路由。
- en: Place the routing logic into a separate module.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将路由逻辑放入一个单独的模块中。
- en: 7.3.1\. User CRUD routes
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1\. 用户 CRUD 路由
- en: '*CRUD* operations *(Create, Read, Update, Delete)* are the major operations
    often required for persistent storage of data. Wikipedia has a great in-depth
    discussion if you need a refresher or are hearing about CRUD for the first time.
    One common design pattern in web applications used to implement CRUD is known
    as *REST*, or *Representational State Transfer*. REST uses strict and well-defined
    semantics to define what the verbs `GET`, `POST`, `PUT`, `PATCH`, and `DELETE`
    do. If you know and love REST, by all means feel free to implement it; it’s a
    perfectly valid method of exchanging data between distributed systems, and Node.js
    even has many modules intended to help out with that.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*CRUD* 操作（创建、读取、更新、删除）是数据持久存储通常需要的重大操作。如果您需要复习或第一次听说 CRUD，维基百科有一个深入的讨论。在 Web
    应用程序中用于实现 CRUD 的常见设计模式被称为 *REST*，或 *表征状态转移*。REST 使用严格和定义良好的语义来定义动词 `GET`、`POST`、`PUT`、`PATCH`
    和 `DELETE` 的作用。如果您了解并喜爱 REST，请随意实现它；它是在分布式系统之间交换数据的完全有效的方法，Node.js 甚至有许多模块旨在帮助实现这一点。'
- en: We’ve implement basic CRUD routes for our user object and have opted not to
    implement REST in this example for a few reasons. One challenge is that many browsers
    have yet to implement native REST verbs, so `PUT`, `PATCH`, and `DELETE` are often
    implemented by passing extra form parameters or a header in a `POST`. This means
    a developer can’t easily tell what verb is being used in a request, but instead
    must hunt through the headers of the data being sent. REST is also not a perfect
    mapping to CRUD, even though the REST verbs look similar to the CRUD operations.
    Finally, the web browser can get in the way when processing status codes. For
    example, instead of passing a 302 status code to the client SPA, the browser may
    intercept the code and try to do “the right thing” and redirect to a different
    resource. This may not always be the behavior we want.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为用户对象实现了基本的 CRUD 路由，并且出于几个原因没有在这个示例中实现 REST。一个挑战是许多浏览器尚未实现本地的 REST 动词，因此
    `PUT`、`PATCH` 和 `DELETE` 通常通过传递额外的表单参数或 `POST` 中的头信息来实现。这意味着开发者无法轻易地知道正在使用哪个动词，而必须通过发送数据的头信息进行搜索。尽管
    REST 动词看起来与 CRUD 操作相似，但 REST 并不是 CRUD 的完美映射。最后，当处理状态码时，Web 浏览器可能会造成障碍。例如，我们本应将
    302 状态码传递给客户端 SPA，但浏览器可能会拦截该代码并尝试“做正确的事”，将重定向到不同的资源。这可能不是我们总希望的行为。
- en: We can get started by listing all of our users.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过列出所有用户开始。
- en: Make a Route to Get a User List
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建获取用户列表的路由
- en: 'We can make a simple route to provide a list of users. Notice that we set the
    `contentType` of the response object to `json`. This sets the HTTP headers to
    let the browser know the response is in the JSON format, as shown in [listing
    7.14](#ch07list14). Changes are shown in **bold**:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个简单的路由来提供用户列表。请注意，我们将响应对象的 `contentType` 设置为 `json`。这会将 HTTP 头信息设置为让浏览器知道响应是
    JSON 格式，如[列表 7.14](#ch07list14)所示。变更以粗体显示：
- en: Listing 7.14\. Make a route to get a user list—`webapp/app.js`
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.14\. 创建一个获取用户列表的路由—`webapp/app.js`
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The user-list route expects an HTTP `GET` request. This is just fine if we are
    retrieving data. In our next route, we will use a `POST` so that we can send copious
    amounts of data to the server.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 用户列表路由期望一个 HTTP `GET` 请求。如果我们正在检索数据，这完全没问题。在我们的下一个路由中，我们将使用 `POST` 以便我们可以向服务器发送大量数据。
- en: Make a Route to Create a User Object
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建一个创建用户对象的路由
- en: 'When we make a route to create a user object, we need to process `POST` data
    from the client. Express provides a shortcut method, `app.post`, which handles
    `POST` requests that match a provided pattern. We can add the following to our
    server application, as shown in [listing 7.15](#ch07list15). Changes are shown
    in **bold**:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个创建用户对象的路由时，我们需要处理来自客户端的 `POST` 数据。Express 提供了一个快捷方法 `app.post`，它处理与提供的模式匹配的
    `POST` 请求。我们可以在我们的服务器应用程序中添加以下内容，如 [列表 7.15](#ch07list15) 所示。变化以粗体显示：
- en: Listing 7.15\. Make a route to create a user object—`webapp/app.js`
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.15\. 创建一个创建用户对象的路由—`webapp/app.js`
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We haven’t done anything with the posted data yet; we’ll cover that in the
    next chapter. If we navigate to http://localhost:3000/user/create with our browser,
    we’ll see a 404 error and the message `Cannot GET /user/create`. This is because
    the browser is sending a `GET` request and this route only handles `POST`s. Instead
    we can use the command line to create a user:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有对提交的数据做任何处理；我们将在下一章中介绍。如果我们用浏览器导航到 http://localhost:3000/user/create，我们会看到一个
    404 错误和消息 `Cannot GET /user/create`。这是因为浏览器正在发送一个 `GET` 请求，而这个路由只处理 `POST` 请求。相反，我们可以使用命令行来创建一个用户：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'and the server should respond with:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应该响应：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**CURLing and WGETing**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**CURL 和 WGET**'
- en: 'If you’re using a Mac or Linux box, you can use `curl` to test out your API
    and skip the browser. We can test the URL we just created by doing a `POST` to
    user/create:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Mac 或 Linux 机器，你可以使用 `curl` 来测试你的 API 并跳过浏览器。我们可以通过向 user/create 发送
    `POST` 来测试我们刚刚创建的 URL：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `-d` is used to send data and the empty object literal sends no data over.
    Instead of opening a browser to test a route, using `curl` can dramatically speed
    up your development time. To discover more about `curl`’s capabilities, type `curl
    -h` at the command prompt.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d` 用于发送数据，而空对象字面量不会发送任何数据。与其打开浏览器来测试一个路由，使用 `curl` 可以显著加快你的开发时间。要了解更多关于 `curl`
    的功能，请在命令提示符下输入 `curl -h`。'
- en: 'One can get similar results with `wget`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `wget` 也可以得到类似的结果：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To discover more about `wget`’s capabilities, type `wget -h` at the command
    prompt.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `wget` 的功能，请在命令提示符下输入 `wget -h`。
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that we have a route to create a user object, we want to create a route
    to read a user object.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个创建用户对象的路由，我们想要创建一个读取用户对象的路由。
- en: Make a Route to Read a User Object
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建一个读取用户对象的路由
- en: 'The route to read a user object is similar to the create route, but uses the
    `GET` method and has an additional argument passed in through the URL: the ID
    of the user. This route is created by using a colon to define a parameter in the
    route path, as shown in [listing 7.16](#ch07list16). Changes are shown in **bold**:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 读取用户对象的路由与创建路由类似，但使用 `GET` 方法，并通过 URL 传递一个额外的参数：用户的 ID。此路由是通过在路由路径中使用冒号来定义参数创建的，如
    [列表 7.16](#ch07list16) 所示。变化以粗体显示：
- en: Listing 7.16\. Make a route to read a user object—`webapp/app.js`
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.16\. 创建一个读取用户对象的路由—`webapp/app.js`
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The user `:id` parameter at the end of the route is accessible through the `request.params`
    object. The route of `/user/read/:id` makes the user ID accessible at `request.params[‘id']`
    or `request.params.id`. If the requested URL was http://localhost:3000/user/read/12
    then the value of `request.params.id` would be 12\. Give it a try, and also notice
    that this route works no matter what the value of `id` is—it accepts just about
    anything as long as there’s a valid value. There are more examples in [table 7.1](#ch07table01).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 路由末尾的用户 `:id` 参数可以通过 `request.params` 对象访问。`/user/read/:id` 路由使得用户 ID 可在 `request.params[‘id’]`
    或 `request.params.id` 处访问。如果请求的 URL 是 http://localhost:3000/user/read/12，那么 `request.params.id`
    的值将是 12。试一试，并注意这个路由无论 `id` 的值是什么都有效——只要有一个有效的值就可以接受。更多示例见 [表 7.1](#ch07table01)。
- en: Table 7.1\. Routes and their results
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 7.1\. 路由及其结果
- en: '| Try these in the browser | Output in Node.js terminal |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 在浏览器中尝试这些 | Node.js 终端中的输出 |'
- en: '| --- | --- |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| /user/read/19 | {“title”:“User with id 19 found”} |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| /user/read/19 | {“title”:“User with id 19 found”} |'
- en: '| /user/read/spa | {“title”:“User with id spa found”} |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| /user/read/spa | {“title”:“User with id spa found”} |'
- en: '| /user/read/ | Cannot GET /user/read/ |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| /user/read/ | 无法获取 /user/read/ |'
- en: '| /user/read/? | Cannot GET /user/read/? |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| /user/read/? | 无法获取 /user/read/? |'
- en: 'It’s good that the routes with anything are caught, but what if our ID will
    always be a number? We don’t want the router to intercept a path that doesn’t
    have a number as the ID. Express provides the capability to only accept routes
    that contain numbers by adding a regular expression pattern, `[(0-9)]+`, into
    the route definition, as shown in [listing 7.17](#ch07list17). Changes are shown
    in **bold**:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然捕获任何路由都很好，但如果我们的ID始终是数字呢？我们不希望路由器拦截ID不是数字的路径。Express通过在路由定义中添加正则表达式模式`[(0-9)]+`，提供了仅接受包含数字的路由的能力，如[列表7.17](#ch07list17)所示。变化以**粗体**显示：
- en: Listing 7.17\. Constrain the route to only numeric IDs—`webapp/app.js`
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.17\. 将路由限制为仅接受数字ID—`webapp/app.js`
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[Table 7.2](#ch07table02) shows that the route will now only accept numbered
    IDs.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[表7.2](#ch07table02)显示，路由现在将仅接受数字ID。'
- en: Table 7.2\. Routes and their results
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表7.2\. 路由及其结果
- en: '| Try these in the browser | Result |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 在浏览器中尝试这些操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| /user/read/19 | {“title”:“User with id 19 found”} |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| /user/read/19 | {“title”:“找到ID为19的用户”} |'
- en: '| /user/read/spa | Cannot GET /user/read/spa |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| /user/read/spa | 无法获取 /user/read/spa |'
- en: Make Routes to Update or Delete a User
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建更新或删除用户的路由
- en: 'The routes for updating and deleting a user are much the same as those for
    reading a user at this point, though in the next chapter the actions they take
    on the user object will be much different. We add the routes for updating and
    deleting a user in [listing 5.18](kindle_split_016.html#ch05list18). Changes are
    shown in **bold**:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 目前更新和删除用户的路由与读取用户的路由几乎相同，尽管在下一章中它们对用户对象执行的操作将大不相同。我们在[列表5.18](kindle_split_016.html#ch05list18)中添加了更新和删除用户的路由。变化以**粗体**显示：
- en: Listing 7.18\. Define routes for CRUD—`webapp/app.js`
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.18\. 定义CRUD路由—`webapp/app.js`
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Creating these basic routes was easy, but you may have noticed that we’re having
    to set the `contentType` for every response. That’s error-prone and inefficient—a
    better way would be if we could set the `contentType` for all responses to these
    user CRUD operations. Ideally, we’d like to create a route that intercepts all
    incoming user routes and sets the response `contentType` to `json`. Two complications
    stand in our way:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些基本路由很简单，但你可能已经注意到，我们必须为每个响应设置`contentType`。这很容易出错且效率低下——更好的方法是我们能够为所有这些用户CRUD操作的响应设置`contentType`。理想情况下，我们希望创建一个拦截所有传入用户路由并设置响应`contentType`为`json`的路由。有两个问题阻碍了我们：
- en: Some of the requests are using the `GET` method, and others are using `POST`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些请求使用`GET`方法，而另一些使用`POST`。
- en: After setting the response’s `contentType`, we want the router to work as before.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置响应的`contentType`之后，我们希望路由器像以前一样工作。
- en: 'Fortunately, Express again delivers. In addition to the `app.get` and `app.post`
    methods, there’s an `app.all` method that will intercept routes regardless of
    their method type. Express also lets us pass control back to the router to see
    if any other routes match the request by setting and calling a third argument
    in the router callback method. The third argument is called `next` by convention,
    and immediately passes control to the next middleware or route. We add the `app.all`
    method in [listing 7.19](#ch07list19). Changes are shown in **bold**:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Express再次发挥了作用。除了`app.get`和`app.post`方法外，还有一个`app.all`方法可以拦截任何类型的路由。Express还允许我们通过在路由回调方法中设置和调用第三个参数来将控制权交回给路由器，以查看是否有其他路由与请求匹配。按照惯例，第三个参数被称为`next`，它立即将控制权传递给下一个中间件或路由。我们在[列表7.19](#ch07list19)中添加了`app.all`方法。变化以**粗体**显示：
- en: Listing 7.19\. Using `app.all()` to set common attributes—`webapp/app.js`
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.19\. 使用`app.all()`设置常用属性—`webapp/app.js`
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the route pattern, `/user/*?`, the `*` will match anything and the `?` makes
    it optional. `/user/*?` will match any of the following routes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由模式`/user/*?`中，`*`将匹配任何内容，而`?`使其成为可选的。`/user/*?`将匹配以下任何路由：
- en: '`/user`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user`'
- en: '`/user/`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/`'
- en: '`/user/12`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/12`'
- en: '`/user/spa`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/spa`'
- en: '`/user/create`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/create`'
- en: '`/user/delete/12`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/delete/12`'
- en: Now that our user routing is in place, it’s easy to imagine the number of routes
    exploding as we add object types. Do we really need to define five new routes
    for every type of object? Fortunately, no. We can make these routes generic and
    place them in their own module.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了用户路由，很容易想象随着我们添加对象类型，路由的数量会激增。我们真的需要为每种对象类型定义五个新路由吗？幸运的是，不需要。我们可以使这些路由通用，并将它们放在自己的模块中。
- en: 7.3.2\. Generic CRUD routing
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2\. 通用CRUD路由
- en: 'We already know that we can use route parameters to accept arguments from the
    client, but we can also use them to make our routes generic. We just need to tell
    Express to use a portion of the URI as a parameter. This will do the trick:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们可以使用路由参数来接受来自客户端的参数，但我们也可以使用它们来使我们的路由通用。我们只需要告诉 Express 使用 URI 的一部分作为参数。这将解决问题：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now when we request `/horse/read/12` we will get the object type (`horse`)
    in the request parameter, `request.params.obj_type`, and the response JSON will
    be `{ title: "horse with id 12 found" }`. Applying that logic to the rest of our
    methods, we end up with the code in [listing 7.20](#ch07list20). All changes are
    shown in **bold**.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们请求 `/horse/read/12` 时，将在请求参数 `request.params.obj_type` 中获取对象类型（`horse`），响应
    JSON 将是 `{ title: "horse with id 12 found" }`。将此逻辑应用于我们的其他方法，我们最终得到 [列表 7.20](#ch07list20)
    中的代码。所有更改都以 **粗体** 显示。'
- en: Listing 7.20\. Complete generic CRUD routes—`webapp/app.js`
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.20\. 完整的通用 CRUD 路由—`webapp/app.js`
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now when we start up the application (`node app.js`) and point our browser
    to http://localhost:3000, we will see our familiar SPA, as shown in [figure 7.1](#ch07fig01):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们启动应用程序（`node app.js`）并将浏览器指向 http://localhost:3000，我们将看到我们熟悉的 SPA，如图 [图
    7.1](#ch07fig01) 所示：
- en: Figure 7.1\. Our SPA in the browser—http://localhost:3000
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.1\. 浏览器中的我们的 SPA——http://localhost:3000
- en: '![](07fig01_alt.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig01_alt.jpg)'
- en: 'This shows that our static file configuration allowed the browser to read all
    the HTML, JavaScript, and CSS files. But we still also have access to our CRUD
    API. If we point our browser to http://localhost:3000/user/read/12, we should
    see something like:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们的静态文件配置允许浏览器读取所有的 HTML、JavaScript 和 CSS 文件。但我们仍然可以访问我们的 CRUD API。如果我们将浏览器指向
    http://localhost:3000/user/read/12，我们应该看到类似的内容：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'What if we were to have a file at <root_directory>/user/read/12 (don’t laugh,
    you *know* this stuff happens)? In our case, the file would be returned instead
    of a CRUD response. This is because the `express.static` middleware is added before
    the router, as shown next:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `<root_directory>/user/read/12` 有一个文件（别笑，你知道这种情况会发生），我们的情况下，将返回文件而不是 CRUD
    响应。这是因为 `express.static` 中间件被添加到路由器之前，如下所示：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If, however, we reversed the order and put the router first, the CRUD response
    would be returned instead of the static file. The benefit of this arrangement
    might be faster response to a CRUD request; the downside is slower and more complicated
    file access. The *smart* thing to do is to place all the CRUD requests under a
    single root name like /api/1.0.0/ so that dynamic and static content are neatly
    separated.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们反转了顺序，将路由器放在前面，将返回 CRUD 响应而不是静态文件。这种安排的好处可能是对 CRUD 请求的更快响应；缺点是文件访问更慢且更复杂。*聪明的*做法是将所有
    CRUD 请求放在单个根名称下，例如 /api/1.0.0/，这样动态内容和静态内容就可以整洁地分离。
- en: Now we have the basics of a clean, generic router to manage any object type.
    Obviously, this doesn’t take into account authorization issues, but we’ll get
    to that logic a little later. First, let’s first move all the routing logic into
    a separate module.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了管理任何对象类型的干净、通用的路由器的基础。显然，这并没有考虑到授权问题，但我们会稍后讨论这个逻辑。首先，让我们先将所有路由逻辑移动到一个单独的模块中。
- en: 7.3.3\. Place routing in a separate Node.js module
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.3\. 将路由放置在单独的 Node.js 模块中
- en: Keeping all of your routes defined in the main app.js file is rather like writing
    client-side JavaScript in the HTML page—it clutters up your app and doesn’t maintain
    a clean separation of responsibilities. Let’s start by looking a little closer
    at the Node.js module system, which is Node.js’s way of including modular code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有路由定义在主 `app.js` 文件中，就像在 HTML 页面中编写客户端 JavaScript 一样——它会弄乱您的应用程序，并且没有保持职责的清晰分离。让我们首先更仔细地看看
    Node.js 模块系统，这是 Node.js 包括模块化代码的方式。
- en: Node Modules
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Node 模块
- en: Node modules are loaded with the function `require`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Node 模块是通过 `require` 函数加载的。
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The string passed in to `require` specifies the path to the file to be loaded.
    There are a few different syntax rules to be memorized, so have patience. For
    your convenience, these are described in [table 7.3](#ch07table03).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `require` 的字符串指定要加载的文件的路径。需要记住一些不同的语法规则，所以请耐心。为了您的方便，这些内容在 [表 7.3](#ch07table03)
    中描述。
- en: Table 7.3\. Node search path logic for *require*
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 7.3\. Node 对 *require* 的搜索路径逻辑
- en: '| Syntax | Search paths, in order of precedence |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 语法 | 搜索路径，按优先级顺序 |'
- en: '| --- | --- |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|   | This syntax is also used to refer to core node.js modules, such as the
    http module. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '|   | 此语法也用于引用核心 node.js 模块，例如 http 模块。'
- en: 'Inside of a node module, variables scoped with `var` are constrained to the
    module and don’t need a self-executing anonymous function to keep the variable
    out of the global scope like the client side requires. Instead, there’s the `module`
    object. The value assigned to the `module.exports` attribute is provided as the
    return value of the `require` method. Let’s create the routes module, as shown
    in [listing 7.21](#ch07list21):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 node 模块内部，使用 `var` 声明的变量被限制在模块内部，不需要一个自执行的匿名函数来保持变量不在全局作用域中，就像客户端所需要的那样。相反，有一个
    `module` 对象。分配给 `module.exports` 属性的值作为 `require` 方法的返回值。让我们创建一个路由模块，如 [列表 7.21](#ch07list21)
    所示：
- en: Listing 7.21\. Create the routes module—`webapp/routes.js`
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.21\. 创建路由模块—`webapp/routes.js`
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `module.exports` value can be any data type such as a function, object,
    array, string, number, or boolean. In this case, routes.js sets the value of `module.exports`
    to an anonymous function. Let’s `require` routes.js in app.js and store the return
    value in the `routes` variable. We can then invoke the returned function as shown
    in [listing 7.22](#ch07list22). Changes are shown in **bold**:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.exports` 的值可以是任何数据类型，如函数、对象、数组、字符串、数字或布尔值。在这种情况下，routes.js 将 `module.exports`
    的值设置为匿名函数。让我们在 app.js 中 `require` routes.js 并将返回值存储在 `routes` 变量中。然后我们可以像 [列表
    7.22](#ch07list22) 所示那样调用返回的函数。更改以粗体显示：'
- en: Listing 7.22\. Include a module and use the return value—`webapp/app.js`
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.22\. 包含一个模块并使用返回值—`webapp/app.js`
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When we type `node app.js` at the command prompt, we should see the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在命令提示符中键入 `node app.js` 时，我们应该看到以下内容：
- en: '[PRE47]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now that we have added our routes module, let’s move our router configuration
    to it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了我们的路由模块，让我们将我们的路由器配置移动到它那里。
- en: Move Routing to a Module
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将路由移动到模块中
- en: When we create a non-trivial application we like to define our routing in a
    single file in the main application folder. In a larger application with lots
    of routes, we can define them in a routes folder with as many files as we need.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个非平凡的应用程序时，我们喜欢在主应用程序文件夹中定义我们的路由到一个单独的文件。在一个具有大量路由的大应用中，我们可以在一个路由文件夹中定义它们，文件夹中有我们需要的文件数量。
- en: Since our next app will be non-trivial, let’s create a file in the root spa
    directory called routes.js and copy the existing routes into the `module.exports`
    function. It should look like [listing 7.23](#ch07list23).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的下一个应用程序将不是平凡的，让我们在根 spa 目录中创建一个名为 routes.js 的文件，并将现有的路由复制到 `module.exports`
    函数中。它应该看起来像 [列表 7.23](#ch07list23)。
- en: Listing 7.23\. Place routes in a separate module—`webapp/routes.js`
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.23\. 将路由放置在单独的模块中—`webapp/routes.js`
- en: '![](ch07list23-0.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![ch07list23-0.jpg]'
- en: '![](ch07list23-1.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![ch07list23-1.jpg]'
- en: Now we can adjust `webapp/app.js` to use the routing module, as shown in [listing
    7.24](#ch07list24). Changes are shown in **bold**.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调整 `webapp/app.js` 以使用路由模块，如 [列表 7.24](#ch07list24) 所示。更改以粗体显示。
- en: Listing 7.24\. Update server application to use external routes—`webapp/app.js`
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.24\. 更新服务器应用程序以使用外部路由—`webapp/app.js`
- en: '![](ch07list24-0.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![ch07list24-0.jpg]'
- en: '![](ch07list24-1.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![ch07list24-1.jpg]'
- en: 'This leaves us with a pretty clean app.js: it loads the needed library modules,
    creates our Express application, configures our middleware, adds our routes, and
    starts the server. What it doesn’t do is persist your data to a database by actually
    performing any of the requested actions. We’ll hook that up in the next chapter
    after setting up MongoDB and connecting it to our Node.js application. Before
    doing that, let’s take a look at some other things we might need first.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的 app.js 变得相当干净：它加载所需的库模块，创建我们的 Express 应用程序，配置我们的中间件，添加我们的路由，并启动服务器。它没有做的是通过执行任何请求的操作将数据持久化到数据库中。我们将在设置
    MongoDB 并将其连接到我们的 Node.js 应用程序之后，在下一章中设置它。在此之前，让我们先看看我们可能需要的一些其他事情。
- en: 7.4\. Adding authentication and authorization
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4\. 添加认证和授权
- en: Now that we’ve created the routes for performing CRUD actions on our objects,
    we should add authentication. We can do this the hard way and code it ourselves,
    or do it the easy way and take advantage of another Express middleware. Hmm. Think...
    think, which to choose?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为在对象上执行 CRUD 操作创建了路由，我们应该添加认证。我们可以通过艰难的方式自己编写代码，或者通过简单的方式利用另一个 Express
    中间件。嗯。想想...想想，选择哪一个？
- en: 7.4.1\. Basic Authentication
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.1\. 基本认证
- en: 'Basic Authentication is an HTTP/1.0 and 1.1 standard for how a client provides
    a username and password when making a request; it’s commonly referred to as *basic
    auth*. Remember that middleware is called in the order it’s added to the application,
    so if you want the application to authorize access to the routes, the middleware
    needs to be added before the router middleware. That’s easy enough to do as shown
    in [listing 7.25](#ch07list25). Changes are shown in **bold**:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证是 HTTP/1.0 和 1.1 标准中客户端在请求时提供用户名和密码的方式；通常被称为 *基本认证*。记住，中间件是按照添加到应用程序的顺序调用的，所以如果你想使应用程序授权访问路由，中间件需要在路由中间件之前添加。这就像
    [列表 7.25](#ch07list25) 中所示的那样容易完成。更改以 **粗体** 表示：
- en: Listing 7.25\. Add basic auth to our server application—`webapp/app.js`
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.25. 将基本认证添加到我们的服务器应用程序——`webapp/app.js`
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this case, we’ve hard-coded the app to expect the user to be `user` and the
    password to be `spa`. `basicAuth` also accepts a function as the third parameter,
    which can be used to provide more advanced mechanisms, like looking up user details
    in a database. That function should return `true` if the user is valid, and `false`
    when the user is not. When we restart the server and reload the browser, it should
    open an alert dialog that looks like [figure 7.2](#ch07fig02), requiring a valid
    User Name and Password before allowing access.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们硬编码了应用程序，使其期望用户为 `user`，密码为 `spa`。`basicAuth` 也接受一个函数作为第三个参数，该函数可以用来提供更高级的机制，例如在数据库中查找用户详细信息。该函数应该返回
    `true` 如果用户有效，当用户无效时返回 `false`。当我们重新启动服务器并重新加载浏览器时，它应该打开一个类似于 [图 7.2](#ch07fig02)
    的警告对话框，在允许访问之前要求有效的用户名和密码。
- en: Figure 7.2\. Chrome’s authentication dialog
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.2. Chrome 的身份验证对话框
- en: '![](07fig02.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig02.jpg)'
- en: If we enter the wrong password, it’ll keep prompting until we get it right.
    Pressing the Cancel button will bring us to a page that says `Unauthorized.`
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入错误的密码，它会持续提示，直到我们输入正确。按下取消按钮将带我们到一个显示“未经授权”的页面。
- en: Basic authentication is *not* recommended for use in a production app. It sends
    the credentials for every request in plain text—security experts call this a *large
    attack vector*. And even if we use SSL (HTTPS) to encrypt the transmission, we
    only have one layer of security between the client and server.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证不建议在生产应用程序中使用。它以纯文本形式发送每个请求的凭据——安全专家称这为 *大攻击向量*。即使我们使用 SSL（HTTPS）加密传输，我们也只有一层安全在客户端和服务器之间。
- en: Rolling your own authentication mechanism is getting passé these days. Many
    startups and even larger more established companies are using third-party authentication
    from the likes of Facebook or Google. There are many online tutorials showing
    how to integrate with these services; the Node.js middleware Passport can get
    you started.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 自己构建身份验证机制现在正变得过时。许多初创公司甚至更大、更成熟的公司都在使用来自 Facebook 或 Google 等第三方身份验证服务。有许多在线教程展示了如何集成这些服务；Node.js
    中间件 Passport 可以帮助你入门。
- en: 7.5\. Web sockets and Socket.IO
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5. Web sockets 和 Socket.IO
- en: '*Web sockets* are an exciting technology that’s gaining widespread browser
    support. Web sockets allow the client and server to maintain a persistent, lightweight,
    and bidirectional communication channel over a single TCP connection. This lets
    the client or server push messages in real-time without the overhead and latency
    of an HTTP request-response cycle. Prior to web sockets, developers had employed
    alternate—but less efficient—techniques to provide similar capabilities. These
    techniques included using Flash sockets; long-polling, where the browser opens
    a request to a server and then reinitializes the request when there’s a response
    or when the request times out; and server polling at close intervals (say, once
    per second).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*Web sockets* 是一种令人兴奋的技术，它正在获得广泛的浏览器支持。Web sockets 允许客户端和服务器通过单个 TCP 连接保持持久、轻量级和双向的通信通道。这使得客户端或服务器能够在没有
    HTTP 请求-响应周期开销和延迟的情况下实时推送消息。在 Web sockets 之前，开发者采用了替代但效率较低的技巧来提供类似的功能。这些技术包括使用
    Flash sockets；长轮询，其中浏览器向服务器打开一个请求，并在有响应或请求超时时重新初始化请求；以及服务器在很短的间隔内轮询（例如，每秒一次）。'
- en: The trouble with web sockets is that the specifications haven’t yet been finalized
    and older browsers will never support it. Socket.IO is a Node.js module that gracefully
    resolves the latter concern, as it provides browser-to-server messaging over web
    sockets if available, but will degrade to use other techniques if sockets aren’t
    available.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务器的问题在于规范尚未最终确定，旧浏览器永远不会支持它。Socket.IO 是一个 Node.js 模块，它优雅地解决了后一个问题，因为它在可用的情况下提供浏览器到服务器的
    WebSocket 消息传递，但如果 WebSocket 不可用，它将降级使用其他技术。
- en: 7.5.1\. Simple Socket.IO
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.1\. 简单 Socket.IO
- en: 'Let’s create a simple Socket.IO application that updates a counter on the server
    every second and pushes the current count to connected clients. We can install
    Socket.IO by updating our package.json as shown in [listing 7.26](#ch07list26).
    Changes are shown in **bold**:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的 Socket.IO 应用程序，该应用程序每秒更新服务器上的计数并将当前计数推送到已连接的客户端。我们可以通过更新我们的 package.json
    来安装 Socket.IO，如 [列表 7.26](#ch07list26) 所示。更改以粗体显示：
- en: Listing 7.26\. Installing Socket.IO—webapp/package.json
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.26\. 安装 Socket.IO—webapp/package.json
- en: '[PRE49]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now we can run `npm install` to ensure both Express and Socket.IO are installed.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行 `npm install` 来确保 Express 和 Socket.IO 都已安装。
- en: 'Let’s add two files, a server application named webapp/socket.js and browser
    document named [webapp/socket.html](http://webapp/socket.html). Let’s start by
    building a server application that can serve static files and that has a timer
    that increments once per second. Since we know we are going to use Socket.IO,
    we will include that library too. [Listing 7.27](#ch07list27) shows our new socket.js
    server application:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加两个文件，一个名为 webapp/socket.js 的服务器应用程序和一个名为 [webapp/socket.html](http://webapp/socket.html)
    的浏览器文档。让我们首先构建一个可以提供静态文件并且有一个每秒递增一次的计时器的服务器应用程序。既然我们知道我们将使用 Socket.IO，我们将包括该库。[列表
    7.27](#ch07list27) 显示了我们的新 socket.js 服务器应用程序：
- en: Listing 7.27\. Begin the server application—webapp/socket.js
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.27\. 开始服务器应用程序—webapp/socket.js
- en: '![](ch07list27-0.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch07list27-0.jpg)'
- en: '![](ch07list27-1.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch07list27-1.jpg)'
- en: 'When we start the server—`node socket.js`—we see it logging a constantly incrementing
    number in the terminal. Now, let’s create the `[webapp/socket.html](http://webapp/socket.html)`
    shown in [listing 7.28](#ch07list28) to display this number. We’ll include jQuery
    because it makes grabbing the body tag simple:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动服务器—`node socket.js`—我们在终端看到它正在记录一个不断递增的数字。现在，让我们创建 [webapp/socket.html](http://webapp/socket.html)
    中所示的 `[webapp/socket.html](http://webapp/socket.html)` 来显示这个数字。我们将包括 jQuery，因为它使获取
    body 标签变得简单：
- en: Listing 7.28\. Create the browser document—webapp/socket.html
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.28\. 创建浏览器文档—webapp/socket.html
- en: '[PRE50]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We should now be able to load `http://localhost:3000` and see the nearly blank
    page. Getting Socket.IO to send this information to the client takes just two
    additional lines in our server application, as shown in [listing 7.29](#ch07list29).
    Changes are shown in **bold**:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够加载 `http://localhost:3000` 并看到几乎空白的页面。让 Socket.IO 向客户端发送此信息只需要在我们的服务器应用程序中添加两行，如
    [列表 7.29](#ch07list29) 所示。更改以粗体显示：
- en: Listing 7.29\. Add web sockets to the server application—webapp/socket.js
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.29\. 将 WebSocket 添加到服务器应用程序—webapp/socket.js
- en: '![](259fig01_alt.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](259fig01_alt.jpg)'
- en: 'The browser document requires just an additional six lines to enable Socket.IO,
    as shown in [listing 7.30](#ch07list30). Changes are shown in **bold**:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器文档只需要额外的六行来启用 Socket.IO，如 [列表 7.30](#ch07list30) 所示。更改以粗体显示：
- en: Listing 7.30\. Add web sockets to the browser document—webapp/socket.html
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.30\. 将 WebSocket 添加到浏览器文档—webapp/socket.html
- en: '[PRE51]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The JavaScript file `/socket.io/socket.io.js` is provided by the Socket.IO installation
    so there’s no need to create one; it’s also a “magical” file that doesn’t actually
    exist on the server, so don’t go looking for it. `io.connect()` returns a Socket.IO
    connection and the `on` method is similar to the `bind` method in jQuery, in that
    it tells it to watch for a certain kind of Socket.IO event. In this case, the
    event we’re looking for is any message coming over the connection. Then we use
    jQuery to update the body with the new count. You went looking for the socket.io.js
    file on the server, didn’t you?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 文件 `/socket.io/socket.io.js` 由 Socket.IO 安装提供，因此无需创建一个；它也是一个“神奇”的文件，实际上并不存在于服务器上，所以不要去寻找它。`io.connect()`
    返回一个 Socket.IO 连接，而 `on` 方法与 jQuery 中的 `bind` 方法类似，它告诉它监视某种 Socket.IO 事件。在这种情况下，我们正在寻找的事件是通过连接发送的任何消息。然后我们使用
    jQuery 更新 body 以新的计数。你是在服务器上寻找 socket.io.js 文件，对吧？
- en: If we open `http://localhost:3000/` in a browser we should see the counter incrementing.
    When we open another tab to the same location we should see another counter incrementing
    at the same number and rate because `countIdx` is a module-scope variable in the
    server application.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中打开 `http://localhost:3000/`，我们应该看到计数器在增加。当我们打开另一个标签到同一位置时，我们应该看到另一个计数器以相同的数量和速率增加，因为
    `countIdx` 是服务器应用程序的模块作用域变量。
- en: 7.5.2\. Socket.IO and messaging servers
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.2\. Socket.IO 和信息服务器
- en: When we use Socket.IO to route messages between clients and servers, we’re creating
    a messaging server. An example of another messaging server is *Openfire*, which
    serves messages using XMPP, the protocol used by Google Chat and Jabber. A messaging
    server must maintain connections to all clients so they can receive and respond
    to messages quickly. They should also minimize the size of the message by avoiding
    unnecessary data.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Socket.IO 在客户端和服务器之间路由消息时，我们正在创建一个信息服务器。另一个信息服务器的例子是 *Openfire*，它使用 XMPP
    协议来提供消息，这是 Google Chat 和 Jabber 所使用的协议。信息服务器必须维护与所有客户端的连接，以便它们可以快速接收和响应消息。它们还应该通过避免不必要的数据来最小化消息的大小。
- en: Traditional web servers such as Apache2 are poor messaging servers because they
    create and assign a process (or thread) for every connection, *and each process
    must live for as long as its connection persists*. As you might guess, after a
    few hundred or thousand connections, a web server will have all its resources
    consumed by all the processes used to service the connections. Apache2 was never
    designed for this; it was written as a content server, where the idea is to push
    data out as fast as possible in response to a request and then close the connection
    as fast as possible. For these types of uses, Apache2 is a great choice—just ask
    YouTube.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的网络服务器，如 Apache2，是糟糕的信息服务器，因为它们为每个连接创建和分配一个进程（或线程），**并且每个进程必须在其连接持续期间存在**。正如你可能猜到的，在几百或几千个连接之后，网络服务器将耗尽所有用于服务连接的进程所使用的资源。Apache2
    从未为此而设计；它被编写为一个内容服务器，其理念是尽可能快地响应请求推送数据，然后尽可能快地关闭连接。对于这些类型的用途，Apache2 是一个很好的选择——只需问问
    YouTube。
- en: Node.js, by comparison, is an excellent messaging server. Thanks to its event
    model, it *doesn’t* create a process for every connection. Instead it does some
    bookkeeping when a connection is opened or closed, and some maintenance in between.
    Therefore it can handle tens or hundreds of thousands of concurrent connections
    on modest hardware. Node.js doesn’t do any significant work until a messaging
    event—like a request or a response—occurs on one or more of its open connections.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相比，Node.js 是一个优秀的信息服务器。多亏了其事件模型，它**不会**为每个连接创建一个进程。相反，它在连接打开或关闭时做一些记账，并在之间进行一些维护。因此，它可以在普通的硬件上处理成千上万的并发连接。Node.js
    不会在其打开的连接之一或多个上发生信息事件——如请求或响应——之前做任何显著的工作。
- en: The number of messaging clients Node.js can handle depends on the actual workload
    the server encounters. If the clients are relatively quiet and the server tasks
    are lightweight, the server can handle *lots* of clients. If the clients are chatty
    and the server tasks are heavier, the server can handle *a lot less*. It’s conceivable
    in a high-volume environment that a load balancer would route traffic between
    a cluster of Node.js servers that provides messaging, another cluster of Node.js
    servers that provides dynamic web content, and a cluster of Apache2 servers that
    provides static content.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 可以处理的消息客户端数量取决于服务器遇到的实际工作量。如果客户端相对安静且服务器任务轻量，服务器可以处理**很多**客户端。如果客户端很健谈且服务器任务更重，服务器可以处理的客户端就**少得多**。在一个高流量环境中，负载均衡器可能会在提供消息的
    Node.js 服务器集群、提供动态网页内容的另一个 Node.js 服务器集群以及提供静态内容的 Apache2 服务器集群之间路由流量。
- en: 'There are many benefits of using Node.js over other messaging protocols such
    as XMPP. Here are just a few:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Node.js 而不是 XMPP 等其他消息协议的好处有很多。这里只列举几个：
- en: 'Socket.IO makes cross-browser messaging in a web app almost trivial. We’ve
    used XMPP before for a production application. Trust us: it’s a *lot* more work
    just for the software.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Socket.IO 使得在 Web 应用中进行跨浏览器消息传递几乎变得微不足道。我们之前曾为生产应用程序使用过 XMPP。相信我们：仅为了软件，它就**要复杂得多**。
- en: We can avoid maintaining a separate server and configuration. Again, another
    big win.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以避免维护一个单独的服务器和配置。这又是一个巨大的优势。
- en: We can work with native JSON protocol instead of a different language. XMPP
    is XML and requires sophisticated software to encode and decode.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用原生的 JSON 协议而不是不同的语言。XMPP 是 XML，需要复杂的软件来编码和解码。
- en: We don’t have to worry (at least initially) about the dreaded “same domain”
    policy that plagues other messaging platforms. This browser policy prevents content
    from loading into browsers if it doesn’t come from the same server as the JavaScript
    that’s using it.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不必担心（至少最初）那些困扰其他消息平台的“同源”策略。这个浏览器策略阻止内容加载到浏览器中，如果它不是来自使用它的JavaScript相同的服务器。
- en: 'Now let’s look at a use of Socket.IO that’s sure to impress: dynamically updating
    our SPA.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个一定会给人留下深刻印象的Socket.IO用法：动态更新我们的SPA。
- en: 7.5.3\. Updating JavaScript with Socket.IO
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.3\. 使用Socket.IO更新JavaScript
- en: One challenge with an SPA is ensuring the client software matches the server
    application. Imagine if Bobbie loaded our SPA into her browser, and five minutes
    later we update our server application. Now Bobbie has a problem, because our
    updated server communicates in a new data format, yet Bobbie’s SPA still expects
    the old. One way to resolve this situation is to force Bobbie to reload the entire
    SPA when it recognizes it’s out of date—say after we sent it a message announcing
    the server update. But we can get even fancier—we can selectively update only
    the JavaScript that has changed in the SPA without forcing the entire application
    to reload.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单页应用程序（SPA）的一个挑战是确保客户端软件与服务器应用程序匹配。想象一下，如果鲍比在我们的浏览器中加载了我们的SPA，五分钟后我们更新了我们的服务器应用程序。现在鲍比遇到了问题，因为我们的更新后的服务器使用了一种新的数据格式，而鲍比的SPA仍然期望使用旧的数据格式。解决这种情况的一种方法是在我们发送消息宣布服务器更新后，强制鲍比重新加载整个SPA——比如说，我们发送了消息后。但我们还可以做得更复杂——我们可以在SPA中仅更新已更改的JavaScript，而不必强制整个应用程序重新加载。
- en: 'So how do we do this magical update? There are three parts to consider:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何进行这种神奇的更新？需要考虑三个部分：
- en: Watching the JavaScript files to detect when they’re modified.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监视JavaScript文件以检测它们何时被修改。
- en: Notifying the client the file has been updated.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通知客户端文件已更新。
- en: Updating the client side JavaScript when it’s notified of the change.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当通知客户端更改时更新客户端侧的JavaScript。
- en: 'The first part, detecting when the file is modified, can be accomplished using
    the native node file system module `fs`. The second is a matter of sending a Socket.IO
    notification to the browser as described in the previous section, and updating
    the client can be accomplished through injecting a new script tag when receiving
    a notification. We can update our server application from the last example as
    shown in [listing 7.31](#ch07list31). Changes are shown in **bold**:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分，检测文件何时被修改，可以使用本机node文件系统模块`fs`完成。第二部分是向浏览器发送Socket.IO通知，如前所述，通过接收通知时注入新的script标签来更新客户端。我们可以从上一个示例中更新我们的服务器应用程序，如[列表
    7.31](#ch07list31)所示。更改以粗体显示：
- en: Listing 7.31\. Update the server application to watch files—`webapp/socket.js`
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.31\. 更新服务器应用程序以监视文件—`webapp/socket.js`
- en: '![](ch07list31-0.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.31-0](ch07list31-0.jpg)'
- en: '![](ch07list31-1.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.31-1](ch07list31-1.jpg)'
- en: 'Now that we’ve prepared the server application, let’s look at the client, starting
    with the JavaScript file we’ll be updating and then the index page. Our data file,
    webapp/js/ data.js, consists of one line assigning some text to a variable, as
    shown in [listing 7.32](#ch07list32):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了服务器应用程序，让我们看看客户端，从我们将要更新的JavaScript文件开始，然后是索引页面。我们的数据文件，`webapp/js/data.js`，包含一行将一些文本赋值给变量的代码，如[列表
    7.32](#ch07list32)所示：
- en: Listing 7.32\. Create a data file—`webapp/js/data.js`
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.32\. 创建数据文件—`webapp/js/data.js`
- en: '[PRE52]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Changes to our browser document need to be a little more substantial, as shown
    in [listing 7.33](#ch07list33). Changes are shown in **bold**:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器文档的更改需要更实质一些，如[列表 7.33](#ch07list33)所示。更改以粗体显示：
- en: Listing 7.33\. Update the browser document—`webapp/socket.html`
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.33\. 更新浏览器文档—`webapp/socket.html`
- en: '![](263fig01_alt.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图 263](263fig01_alt.jpg)'
- en: Now we can make the magic happen. First, let’s start our server application
    (type `node socket.js` on the command line). Next, let’s open our browser document
    ([webapp/socket.html](http://webapp/socket.html)). We should see `SPA` in our
    browser body. Let’s then edit the webapp/js/ data.js file and change the value
    of `SPA` to `the meaning of life is a rutabaga` or some other equally pithy comment.
    When we return to the browser, we should see the display change (without reloading
    the browser) from `SPA` to the aforementioned pithy comment. There may be a delay
    of a few seconds because the `watchFile` command can take that long to notice
    a file change.^([[1](#ch07fn01)])
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以让魔法发生。首先，让我们启动我们的服务器应用程序（在命令行中输入`node socket.js`）。接下来，让我们打开我们的浏览器文档（[webapp/socket.html](http://webapp/socket.html)）。我们应该在我们的浏览器主体中看到`SPA`。然后，让我们编辑webapp/js/
    data.js文件，将`SPA`的值更改为`生活的意义是一个芜菁`或一些其他同样简洁的评论。当我们返回浏览器时，我们应该看到显示从`SPA`更改为上述简洁评论的变化（无需重新加载浏览器）。可能会有几秒钟的延迟，因为`watchFile`命令可能需要这么长时间才能注意到文件变化.^([[1](#ch07fn01)])
- en: ¹ In a production setting we generally want to keep file polling (`fstat`s)
    to a minimum, as it can be a real drag on performance. The `fileWatch` method
    can have options set so that files are polled less frequently. For example, we
    might poll once every 30,000 milliseconds (30 seconds) instead of the default
    of 0 (which we can only assume means “check really, really often”).
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 在生产环境中，我们通常希望将文件轮询（`fstat`s）保持在最低限度，因为它可能会严重影响性能。`fileWatch`方法可以设置选项，以便更频繁地轮询文件。例如，我们可能每30,000毫秒（30秒）轮询一次，而不是默认的0（我们只能假设这意味着“检查非常、非常频繁”）。
- en: 7.6\. Summary
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6. 概述
- en: In this chapter, we’ve seen that although much of the logic of an SPA has been
    moved to the client, the server is still responsible for authentication, data
    validation, and data storage. We’ve set up a Node.js server and used the Connect
    and Express middleware to make routing, logging, and authentication easier.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了尽管SPA的大部分逻辑已经转移到客户端，但服务器仍然负责身份验证、数据验证和数据存储。我们已经设置了一个Node.js服务器，并使用Connect和Express中间件使路由、日志和身份验证变得更容易。
- en: Separating the routing and configuration logic into different files makes it
    easier to comprehend, and Express gives us the capability to define different
    configurations for different environments. Express provided us the tools to easily
    create CRUD routes that work for all our object types.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 将路由和配置逻辑分离到不同的文件中使其更容易理解，Express为我们提供了定义不同环境的不同配置的能力。Express为我们提供了创建适用于所有对象类型的CRUD路由的工具。
- en: We haven’t yet tackled how to validate and store data—that comes in the next
    chapter, when we bring the application and the data together.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有解决如何验证和存储数据的问题——这将在下一章中解决，当我们将应用程序和数据结合在一起时。
- en: Chapter 8\. The server database
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章. 服务器数据库
- en: '|  |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: The role of the database in an SPA
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SPA中数据库的作用
- en: Using JavaScript as the database language with MongoDB
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript作为MongoDB的数据库语言
- en: Understanding the Node.js MongoDB driver
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Node.js MongoDB驱动程序
- en: Implementing CRUD operations
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现CRUD操作
- en: Using JSV for data validation
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSV进行数据验证
- en: Pushing data changes to the client with Socket.IO
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Socket.IO推送数据更改到客户端
- en: '|  |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This chapter builds on code we’ve written in [chapter 7](kindle_split_019.html#ch07).
    We recommend copying the entire directory structure for that chapter into a new
    “chapter_8” directory and updating the files there.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于我们在[第7章](kindle_split_019.html#ch07)中编写的代码。我们建议将那个章节的整个目录结构复制到一个新的“chapter_8”目录中，并更新那里的文件。
- en: In this chapter, we add the database to our SPA for persistent data storage.
    This completes our vision of using JavaScript end-to-end—on the database, the
    server, and the browser. When we’re finished, we’ll be able to start our Node.js
    server application and invite our friends to sign in to the SPA with their computer
    or touch device. They can then chat with each other or make changes to avatars
    that everyone can see in near-real time. Let’s get started by looking more closely
    at the role of the database.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将数据库添加到我们的SPA中，以实现持久数据存储。这完成了我们使用JavaScript端到端——在数据库、服务器和浏览器上的愿景。当我们完成时，我们将能够启动我们的Node.js服务器应用程序，并邀请我们的朋友使用他们的电脑或触摸设备登录SPA。他们可以互相聊天或更改每个人都可以在近实时看到的人物形象。让我们通过更仔细地研究数据库的作用来开始。
- en: 8.1\. The role of the database
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1. 数据库的作用
- en: We use the database server to provide reliable, persistent storage of data.
    We rely on the server for this role because data stored on the client is transitory
    and prone to application errors, user error, and user tampering. Client-side data
    is also difficult to share peer-to-peer and is available only when the client
    is online.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用数据库服务器来提供数据的可靠、持久存储。我们依赖服务器来扮演这个角色，因为客户端存储的数据是短暂的，容易受到应用程序错误、用户错误和用户篡改的影响。客户端数据也难以进行点对点共享，并且仅在客户端在线时可用。
- en: 8.1.1\. Select the data store
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. 选择数据存储
- en: 'We have many options to consider when selecting a server storage solution:
    relational databases, key/value stores, and NoSQL databases to name a few. But
    what’s the best option? Like many questions in life, the answer is “it depends.”
    We’ve worked with web applications where many of these solutions were used concurrently
    for different purposes. Many people have written volumes on the merits of various
    data stores such as relational databases (like *MySQL*), key-value stores (like
    *memcached*), graph databases (like *Neo4J*), or document databases (like *Cassandra*
    or *MongoDB*). Discussion of the relative merits of these solutions is outside
    of the scope of this book, though the authors tend to be agnostic and think that
    each of these has its place.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择服务器存储解决方案时，我们有许多选项需要考虑：关系数据库、键值存储和NoSQL数据库等。但最佳选择是什么？就像生活中的许多问题一样，答案是“这取决于。”我们曾与使用这些解决方案中的许多用于不同目的的Web应用程序合作过。许多人已经撰写了大量关于各种数据存储优点的内容，例如关系数据库（如
    *MySQL*）、键值存储（如 *memcached*）、图数据库（如 *Neo4J*）或文档数据库（如 *Cassandra* 或 *MongoDB*）。尽管作者们倾向于保持中立，认为这些都有其位置，但这些解决方案相对优缺点的讨论超出了本书的范围。
- en: Let’s envision that we’ve created an SPA that’s a word processor. We might use
    a round-robin file system data store for the bulk files, but index them using
    a MySQL database. In addition, we may store authentication objects in MongoDB.
    In any case, the user will almost certainly expect to save their documents to
    the server for long-term storage. Sometimes the user may want to read from or
    save to a file on their local disk, and we almost certainly should provide that
    option. But the use case for local storage continues to diminish as the value
    and reliability of networks, remote storage, and accessibility continue to improve.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设想我们已经创建了一个作为文字处理器的SPA。我们可能会使用循环冗余文件系统数据存储来存储大量文件，但使用MySQL数据库进行索引。此外，我们可能将身份验证对象存储在MongoDB中。在任何情况下，用户几乎肯定会期望将他们的文档保存到服务器上进行长期存储。有时用户可能希望从本地磁盘上的文件读取或保存，我们几乎肯定应该提供这个选项。但随着网络、远程存储的价值和可靠性以及可访问性的持续提高，本地存储的使用案例正在不断减少。
- en: 'We’ve selected MongoDB as our data store for a number of reasons: it has proven
    reliable, it’s scalable, it has good performance, and—unlike some other NoSQL
    options—it’s positioned to be a general purpose database. We find it well-suited
    for SPAs because it enables us to use JavaScript and JSON from one end of the
    SPA to the other. Its command-line interface uses JavaScript as its query language,
    so we can easily test JavaScript constructs while exploring a database, or manipulate
    data using the exact same expressions as we do in our server or browser environment.
    It uses JSON as its storage format and its data management tools are purpose-built
    for JSON.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择MongoDB作为我们的数据存储，原因有很多：它已被证明是可靠的，它具有可扩展性，性能良好，并且——与一些其他NoSQL选项不同——它定位为通用数据库。我们发现它非常适合SPA，因为它使我们能够从SPA的一端到另一端使用JavaScript和JSON。它的命令行界面使用JavaScript作为其查询语言，因此我们可以在探索数据库的同时轻松测试JavaScript结构，或者使用与我们服务器或浏览器环境完全相同的表达式来操作数据。它使用JSON作为其存储格式，其数据管理工具是为JSON量身定制的。
- en: 8.1.2\. Eliminate data transformations
  id: totrans-362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2\. 消除数据转换
- en: 'Consider the traditional web application written in MySQL/Ruby on Rails (or
    mod_perl, PHP, ASP, Java, or Python) and JavaScript: the developer must write
    code to convert from SQL -> Active Record -> JSON on the way to the client, and
    then JSON -> Active Record -> SQL on the way back (see [figure 8.1](#ch08fig01)).
    That’s three languages (SQL, Ruby, JavaScript), three data formats (SQL, Active
    Record, JSON), and four data transformations. At best, this wastes a great deal
    of server power that could be better used elsewhere. At worst, each transformation
    provides an opportunity to introduce bugs, and it can require a great deal of
    effort to implement *and* maintain.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下用MySQL/Ruby on Rails（或mod_perl、PHP、ASP、Java或Python）和JavaScript编写的传统网络应用程序：开发者必须编写代码将SQL
    -> Active Record -> JSON在客户端的路径上转换，然后在返回的路径上将JSON -> Active Record -> SQL转换（见[图8.1](#ch08fig01)）。这涉及到三种语言（SQL、Ruby、JavaScript）、三种数据格式（SQL、Active
    Record、JSON）和四种数据转换。在最坏的情况下，这会浪费大量的服务器资源，这些资源本可以用于其他更好的用途。在最坏的情况下，每个转换都提供了引入错误的机会，并且可能需要大量的努力来实现和维护。
- en: Figure 8.1\. Data transformations in a web application
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1\. 网络应用程序中的数据转换
- en: '![](08fig01_alt.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig01_alt.jpg)'
- en: 'We use MongoDB, Node.js, and a native JavaScript SPA, so our data mapping looks
    like this: JSON -> JSON -> JSON on the way to the client, and then JSON -> JSON
    -> JSON on the way back (see [figure 8.2](#ch08fig02)). We work with one language
    (JavaScript), one data format (JSON), and no data transformations. This brings
    powerful simplicity to a once complex system.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用MongoDB、Node.js和原生JavaScript SPA，因此我们的数据映射如下：在客户端的路径上JSON -> JSON -> JSON，然后在返回的路径上JSON
    -> JSON -> JSON（见[图8.2](#ch08fig02)）。我们使用一种语言（JavaScript）、一种数据格式（JSON）和没有数据转换。这给曾经复杂系统带来了强大的简单性。
- en: Figure 8.2\. With MongoDB, Node.js, and an SPA there’s no data transformation
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2\. 使用MongoDB、Node.js和SPA，无需数据转换
- en: '![](08fig02_alt.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig02_alt.jpg)'
- en: The simplicity of this setup also enables us to be flexible when deciding where
    to place our application logic.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置的简单性也使我们能够在决定放置应用程序逻辑的位置时更加灵活。
- en: 8.1.3\. Move the logic where you need it
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3\. 将逻辑移动到需要的位置
- en: In our traditional web application example, consider how we choose where to
    place some application logic. Perhaps we should place it in a stored SQL procedure?
    Or perhaps we should embed the logic in the server application? Maybe we should
    put the logic on the client? If we need to move from one layer to another, it
    usually requires a great deal of effort because the layers use different languages
    and data formats. In other words, it was often enormously expensive to be wrong
    (imagine rewriting logic from Java to JavaScript, for example). That leads to
    compromised “safe” choices that limit the capability of the application.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的传统网络应用程序示例中，考虑一下我们如何选择放置某些应用程序逻辑的位置。也许我们应该将其放在存储的SQL存储过程中？或者也许我们应该将逻辑嵌入到服务器应用程序中？也许我们应该将逻辑放在客户端？如果我们需要从一个层移动到另一个层，通常需要付出大量的努力，因为层使用不同的语言和数据格式。换句话说，犯错误通常代价高昂（例如，想象一下将逻辑从Java重写到JavaScript）。这导致了妥协的“安全”选择，限制了应用程序的能力。
- en: The use of a single language and data format greatly reduces the expense of
    changing our minds. This allows us to be much more inventive during development
    because *the cost of being wrong is minimal*. If we need to move some logic from
    the server to the client, we can use the same JavaScript with little or no or
    alteration.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单一语言和数据格式大大减少了改变主意的成本。这使我们能够在开发过程中更加富有创新性，因为*犯错误的成本极低*。如果我们需要将一些逻辑从服务器移动到客户端，我们可以使用相同的JavaScript，几乎不需要或不需要修改。
- en: Now let’s take a deeper look at our database of choice, MongoDB.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地了解我们选择的数据库，MongoDB。
- en: 8.2\. An introduction to MongoDB
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. MongoDB简介
- en: 'According to the MongoDB website, MongoDB is “a scalable, high-performance,
    open source NoSQL database” using document-oriented storage with dynamic schemas
    that offer “simplicity and power.” Let’s step through what that means:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 根据MongoDB网站，MongoDB是“一个可扩展、高性能的开源NoSQL数据库”，使用基于文档的存储和动态模式，提供“简单和强大”。让我们一步步了解这意味着什么：
- en: '*Scalable, high performance*—MongoDB is designed to scale horizontally, using
    less-expensive servers. With relational databases, the only easy way to scale
    your database is to buy better hardware.^([[1](#ch08fn01)]) With MongoDB you can
    easily add another server to provide more capacity or performance.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可扩展，高性能*—MongoDB被设计为水平扩展，使用成本较低的服务器。在使用关系型数据库的情况下，唯一容易扩展数据库的方法就是购买更好的硬件。[1](#ch08fn01)
    使用MongoDB，您可以轻松地添加另一台服务器以提供更多容量或性能。'
- en: ¹ Yes, you can create relational database clusters and replicas, but they typically
    require a good deal of expertise to configure and maintain. Buying a faster server
    is a lot easier.
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 是的，你可以创建关系型数据库集群和副本，但它们通常需要相当多的专业知识来配置和维护。购买更快的服务器要容易得多。
- en: '*Document-oriented storage*—MongoDB stores data in the JSON document format
    instead of in tables with columns and rows. Documents, which are roughly equivalent
    to SQL rows, are stored in collections, which are similar to SQL tables.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文档型存储*—MongoDB以JSON文档格式存储数据，而不是以列和行组成的表。文档，大致相当于SQL行，存储在集合中，集合类似于SQL表。'
- en: '*Dynamic schemas*—Whereas relational databases require a schema to define what
    data can be stored in what tables, MongoDB doesn’t. You can store any JSON document
    in a collection. Individual documents within the same collection can have completely
    different structures, and a document structure may be completely changed during
    a document update.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态模式*—与关系型数据库需要模式来定义可以在哪些表中存储哪些数据不同，MongoDB不需要。你可以在集合中存储任何JSON文档。同一集合中的单个文档可以具有完全不同的结构，文档结构在文档更新期间也可能完全改变。'
- en: The first point about performance will appeal to everyone, especially operations
    managers. The second two points are of particular interest to SPA developers and
    are worth exploring in detail. If you are already familiar with MongoDB, feel
    free to skip to section 8.3, where we hook it up to our Node.js application.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 关于性能的第一个要点将吸引每个人，尤其是运营经理。接下来的两个要点对SPA开发者特别有趣，值得详细探讨。如果你已经熟悉MongoDB，可以直接跳到第8.3节，在那里我们将它与我们的Node.js应用程序连接起来。
- en: 8.2.1\. Document-oriented storage
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1. 文档型存储
- en: MongoDB stores data in JSON documents, which makes it a great match for most
    SPAs. JSON documents from our SPA can be stored and retrieved without transformation.^([[2](#ch08fn02)])
    This is compelling because we don’t have to spend development or processing time
    transforming data back and forth from our native format. When we find a problem
    in the data on the client side, it’s simple to check whether it’s found in the
    database because the formats are identical.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB以JSON文档的形式存储数据，这使得它非常适合大多数SPA。我们的SPA中的JSON文档可以存储和检索，无需转换.^([[2](#ch08fn02)])
    这很有吸引力，因为我们不必花费开发或处理时间在原生格式之间转换数据。当我们发现客户端数据中的问题时，检查它是否在数据库中找到非常简单，因为格式是相同的。
- en: ² Compare this with a relational database, where we first have to convert to
    SQL to store the documents, and then convert it back to JSON on retrieval.
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 将此与关系型数据库进行比较，在关系型数据库中，我们首先必须将其转换为SQL以存储文档，然后在检索时将其转换回JSON。
- en: Not only does this result in a simpler development and a simpler application,
    but it also provides performance benefits. Instead of the server having to manipulate
    data from format to format, it passes it along. This has an impact on the cost
    of hosting and scaling the application as well, as the servers have to perform
    less work. In this case, the work isn’t offloaded onto the client; it’s just *gone*
    because of the single data format. This doesn’t necessarily mean that Node.js
    + MongoDB is faster than Java + PostgreSQL—many other factors impact overall speed
    of the application—but it does mean that everything else being equal, a single
    data format should provide better performance.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅使开发和应用程序更简单，还提供了性能优势。服务器不必在格式之间转换数据，而是直接传递。这对托管和扩展应用程序的成本也有影响，因为服务器需要执行的工作更少。在这种情况下，工作并没有转移到客户端；它只是因为单一的数据格式而“消失”。这并不一定意味着Node.js
    + MongoDB比Java + PostgreSQL更快——许多其他因素会影响应用程序的整体速度，但它在其他条件相同的情况下，单一数据格式应该提供更好的性能。
- en: 8.2.2\. Dynamic document structure
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2. 动态文档结构
- en: 'MongoDB doesn’t constrain the structure of documents. Instead of defining a
    structure, we can just start adding documents to collections. We don’t even have
    to `create` a collection first—inserting data into a non-existent collection creates
    it. Compare this to a relational database, where you must define tables and schemas
    explicitly, and any change in data structure requires a change in schema. Having
    a database that doesn’t require a schema has some interesting benefits:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB不限制文档的结构。我们不需要定义结构，只需开始向集合中添加文档即可。我们甚至不需要先`创建`一个集合——向不存在的集合中插入数据会创建它。将此与关系型数据库进行比较，在关系型数据库中，你必须明确定义表和模式，任何数据结构的变化都需要对模式进行更改。拥有一个不需要模式的数据库有一些有趣的好处：
- en: '*Document structure is flexible.* MongoDB will store the documents regardless
    of structure. If the document structure changes frequently or is unstructured,
    MongoDB will store them without need for adjustment.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文档结构灵活。* MongoDB 将存储文档，无论其结构如何。如果文档结构频繁更改或无结构，MongoDB 将无需调整即可存储它们。'
- en: '*Application changes often don’t require database changes.* When we update
    a document to have new or different attributes, we can deploy the application
    and it’ll start storing the new document structure immediately. On the other hand,
    we may need to adjust the code to account for document attributes that don’t exist
    in previously saved documents.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用程序更改通常不需要数据库更改。* 当我们更新文档以包含新的或不同的属性时，我们可以部署应用程序，它将立即开始存储新的文档结构。另一方面，我们可能需要调整代码以处理之前保存的文档中不存在的文档属性。'
- en: '*No schema changes to cause downtime and delays.* We don’t have to lock parts
    of the database to accommodate a document structure change. But as before, we
    may need to adjust our application.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*没有模式更改会导致停机和服务延迟。* 我们不必锁定数据库的部分来适应文档结构更改。但就像之前一样，我们可能需要调整我们的应用程序。'
- en: '*Specialized knowledge of schema design isn’t needed.* Being schema-less means
    there’s an entire sphere of knowledge that doesn’t need to be mastered to build
    an application. That means the applications are easier for generalists to build
    and may require less planning to get up and running.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不需要对模式设计有专业知识。* 无模式意味着有一个完整的知识领域，不需要掌握这些知识就可以构建应用程序。这意味着应用程序对通才来说更容易构建，并且可能需要更少的规划才能启动。'
- en: 'But there are downsides to not having a schema:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 但没有模式也有一些缺点：
- en: '*No document structure enforcement.* Document structure isn’t enforced at the
    database level, and any changes to their structure aren’t automatically propagated
    to existing documents. This can be especially painful when multiple applications
    are using the same collection.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*没有文档结构强制。* 数据库级别不强制执行文档结构，对它们结构的任何更改都不会自动传播到现有文档。当多个应用程序使用相同的集合时，这可能会特别痛苦。'
- en: '*No document structure definition.* There’s no place in the database for a
    database engineer or the application to determine what structure the data *should*
    have. It’s more difficult to determine the purpose of a collection by inspecting
    the documents because there’s no guarantee the structure is the same from document
    to document.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*没有文档结构定义。* 数据库中没有地方让数据库工程师或应用程序确定数据*应该*具有的结构。通过检查文档来确定集合的目的更困难，因为没有保证结构在文档之间是相同的。'
- en: '*Not well-defined.* Document databases aren’t well-defined mathematically.
    When storing data in a relational database, there are often mathematically proven
    best practices to follow to make the data access as flexible and fast as possible.
    Optimizations aren’t nearly as well-defined for MongoDB, although some traditional
    methods, such as creating indexes, are supported.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定义不明确。* 文档数据库在数学上没有明确定义。在关系数据库中存储数据时，通常有一些经过数学证明的最佳实践，以使数据访问尽可能灵活和快速。对于 MongoDB，优化并没有那么明确，尽管一些传统方法，如创建索引，是支持的。'
- en: Now that we have a feel for how MongoDB stores data, let’s start using it.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 MongoDB 存储数据的方式有了感觉，让我们开始使用它。
- en: 8.2.3\. Get started with MongoDB
  id: totrans-396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3\. 从 MongoDB 开始
- en: 'A good way to start with MongoDB is to install it and then interact with collections
    and documents using the MongoDB shell. First, let’s install MongoDB from the MongoDB
    website, [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads),
    and then start the server `mongodb` process. The startup procedure varies by OS,
    so please consult the documentation for details ([http://docs.mongodb.org/manual/tutorial/manage-mongodb-processes/](http://docs.mongodb.org/manual/tutorial/manage-mongodb-processes/)).
    Once we’ve started the database, let’s open a terminal and start the shell by
    typing `mongo` (`mongo.exe` on Windows). You should see something like this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 一种开始使用 MongoDB 的好方法是安装它，然后使用 MongoDB shell 与集合和文档交互。首先，让我们从 MongoDB 网站[http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)安装
    MongoDB，然后启动 `mongodb` 进程。启动程序因操作系统而异，请参阅文档以获取详细信息([http://docs.mongodb.org/manual/tutorial/manage-mongodb-processes/](http://docs.mongodb.org/manual/tutorial/manage-mongodb-processes/))。一旦我们启动了数据库，让我们打开一个终端，通过输入
    `mongo` (`mongo.exe` 在 Windows 上) 来启动 shell。你应该会看到类似以下内容：
- en: '[PRE53]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'One important concept to take into account when interacting with MongoDB is
    that you don’t manually create databases or collections: they’re created when
    they’re needed. In order to “create” a new database, issue the command to use
    that database. In order to “create” a collection, insert a document into the collection.
    If you reference a collection that doesn’t exist in a query, the query won’t fail;
    it’ll act like the collection exists but won’t actually create it until you insert
    a document. Table 8.11 shows some common operations. We recommend you try them
    out in order using “spa” as the *database_name*.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在与MongoDB交互时，一个重要的概念是您不需要手动创建数据库或集合：它们在需要时自动创建。为了“创建”一个新的数据库，发出使用该数据库的命令。为了“创建”一个集合，向该集合中插入一个文档。如果您在查询中引用了一个不存在的集合，查询不会失败；它将表现得像该集合存在一样，但实际上只有在您插入文档时才会创建它。表
    8.11 展示了一些常见操作。我们建议您使用“spa”作为 *database_name* 依次尝试它们。
- en: Table 8.1\. Basic MongoDB shell commands
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 8.1\. 基本MongoDB shell命令
- en: '| Command | Description |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| show dbs | Show a list of all the databases in this MongoDB instance. |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| show dbs | 显示此MongoDB实例中所有数据库的列表。 |'
- en: '| use database_name | Switch the current database to the *database_name*. If
    the database doesn’t exist yet, it’ll create it the first time a document is inserted
    into a collection on that database. |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| use database_name | 将当前数据库切换到 *database_name*。如果数据库尚不存在，则在第一次向该数据库的集合中插入文档时创建它。
    |'
- en: '| db | Current database. |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| db | 当前数据库。 |'
- en: '| help | Get general help. db.help() will provide help on db methods. |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| help | 获取一般帮助。db.help() 将提供关于 db 方法的帮助。 |'
- en: '| db.getCollectionNames() | Get a list of all collections available in the
    current database. |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| db.getCollectionNames() | 获取当前数据库中所有集合的列表。 |'
- en: '| db.collection_name | A collection in the current database. |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| db.collection_name | 当前数据库中的一个集合。 |'
- en: '| db.collection_name.insert({ ‘name'': ‘Josh Powell'' }) | Insert a document
    with the field *name* with a value of “Josh Powell” into the *collection_name*
    collection. |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| db.collection_name.insert({ ‘name'': ‘Josh Powell'' }) | 将字段 *name* 值为“Josh
    Powell”的文档插入到 *collection_name* 集合中。 |'
- en: '| db.collection_name.find() | Return all documents in the *collection_name*
    collection. |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| db.collection_name.find() | 返回 *collection_name* 集合中的所有文档。 |'
- en: '| db.collection_name.find({ ‘name'': ‘Josh Powell'' }) | Return all documents
    in the *collection_name* collection that have the field *name* with a value of
    “Josh Powell.” |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| db.collection_name.find({ ‘name'': ‘Josh Powell'' }) | 返回所有字段 *name* 值为“Josh
    Powell”的 *collection_name* 集合中的文档。 |'
- en: '| db.collection_name.update({ ‘name'': ‘Josh Powell'' }, {''name'':'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '| db.collection_name.update({ ‘name'': ‘Josh Powell'' }, {''name'':'
- en: '‘Mr. Joshua C. Powell''}) | Find all documents with a *name* of “Josh Powell”
    and *replace* them with {’name’: ‘Mr. Joshua C. Powell’ }. |'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '‘Mr. Joshua C. Powell''}) | 查找所有名为“Josh Powell”的文档，并将它们替换为 {’name’: ‘Mr. Joshua
    C. Powell’ }。 |'
- en: '| db.collection_name.update({ ‘name'': ‘Mr. Joshua C. Powell'' }, {$set: {‘job'':
    ‘Author''} }) | Find all documents with a *name* of “Mr. Joshua C. Powell” and
    *add or modify* the attributes provided by the $set attribute. |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| db.collection_name.update({ ‘name'': ‘Mr. Joshua C. Powell'' }, {$set: {‘job'':
    ‘Author''} }) | 查找所有名为“Mr. Joshua C. Powell”的文档，并使用 $set 属性添加或修改提供的属性。 |'
- en: '| db.collection_name.remove({ {‘name'': ‘Mr. Joshua C. Powell''}. | Remove
    all documents with the field *name* with a value of “Mr. Joshua C. Powell” from
    the *collection_name* collection. |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| db.collection_name.remove({ {‘name'': ‘Mr. Joshua C. Powell''}. | 从 *collection_name*
    集合中删除所有字段 *name* 值为“Mr. Joshua C. Powell”的文档。 |'
- en: '| exit | Exit the MongoDB shell. |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| exit | 退出MongoDB shell。 |'
- en: Of course, MongoDB has many more capabilities than presented in the table. For
    example, there are methods to sort, return a subset of the existing fields, upsert
    documents, increment or otherwise modify an attribute, manipulate arrays, add
    an index, and much, much more. For a more in-depth examination of all that MongoDB
    offers, check out *MongoDB in Action* (Manning 2011), the online MongoDB manual
    ([http://docs.mongodb.org/manual/](http://docs.mongodb.org/manual/)), or the *Little
    MongoDB Book* ([http://openmymind.net/mongodb.pdf](http://openmymind.net/mongodb.pdf)).
    We’ve now run through some basic MongoDB commands, so let’s hook our application
    up to MongoDB. First, we’ll need to prepare the project files.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，MongoDB的功能远不止表格中展示的那么多。例如，有方法可以对数据进行排序、返回现有字段的子集、更新文档、增加或修改属性、操作数组、添加索引等等。要深入了解MongoDB提供的一切，请参阅*MongoDB
    in Action*（Manning 2011）、在线MongoDB手册([http://docs.mongodb.org/manual/](http://docs.mongodb.org/manual/))或*Little
    MongoDB Book*([http://openmymind.net/mongodb.pdf](http://openmymind.net/mongodb.pdf))。我们已经运行了一些基本的MongoDB命令，现在让我们将应用程序连接到MongoDB。首先，我们需要准备项目文件。
- en: 8.3\. Use the MongoDB driver
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. 使用MongoDB驱动程序
- en: An application in a given language requires a database driver to efficiently
    interface with MongoDB. Without a driver, the only way to interact with MongoDB
    would be through the shell. A number of MongoDB drivers have been written in various
    languages, including one for JavaScript in Node.js. A good driver handles many
    low-level tasks around interacting with a database without troubling the developer.
    Some examples include reconnecting to the database in case of a lost connection,
    managing the connections to replica sets, buffer pooling, and cursor support.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定语言中的应用程序需要一个数据库驱动程序来高效地与MongoDB交互。没有驱动程序，与MongoDB交互的唯一方式是通过shell。已经为各种语言编写了多个MongoDB驱动程序，包括Node.js中的JavaScript驱动程序。一个好的驱动程序可以处理与数据库交互的许多底层任务，而不会打扰开发者。一些例子包括在连接丢失的情况下重新连接到数据库、管理副本集的连接、缓冲区池和游标支持。
- en: 8.3.1\. Prepare the project files
  id: totrans-420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1\. 准备项目文件
- en: 'In this chapter, we build on the work we completed in [chapter 7](kindle_split_019.html#ch07).
    We’ll copy our entire file structure from [chapter 7](kindle_split_019.html#ch07)
    into a new “chapter_8” directory where we’ll continue our work. [Listing 8.1](#ch08list01)
    shows our file structure after we have completed the copy. Files and directories
    we will be removing are shown in **bold**:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在[第7章](kindle_split_019.html#ch07)中完成的工作基础上继续。我们将把第7章的整个文件结构复制到一个新的“chapter_8”目录中，在那里我们将继续我们的工作。[列表8.1](#ch08list01)展示了我们完成复制后的文件结构。我们将要删除的文件和目录以**粗体**显示：
- en: Listing 8.1\. Copy files from Chapter 7
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1\. 从第7章复制文件
- en: '[PRE54]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let’s remove the js directory, the [socket.html](http://socket.html) file,
    and the socket.js file. We should also remove the node_modules directory, as that
    will be regenerated during module installation. Our updated structure should then
    look like [listing 8.2](#ch08list02):'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除js目录、[socket.html](http://socket.html)文件和socket.js文件。我们还应该删除node_modules目录，因为在模块安装过程中将重新生成该目录。我们的更新结构应该看起来像[列表8.2](#ch08list02)：
- en: Listing 8.2\. Remove some files and directories we no longer need
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2\. 删除我们不再需要的某些文件和目录
- en: '[PRE55]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now with our directory copied and tidied up, we’re ready to attach MongoDB to
    our application. Our first step is to install the MongoDB driver.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经复制并整理了目录，我们准备将MongoDB附加到我们的应用程序上。我们的第一步是安装MongoDB驱动器。
- en: 8.3.2\. Install and connect to MongoDB
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2\. 安装并连接到MongoDB
- en: 'We find that the MongoDB driver is a good solution for many applications. It’s
    simple, fast, and easy to understand. If we need more capability we might consider
    using an *Object Document Mapper (ODM)*. An ODM is analogous to an *Object Relational
    Mapper (ORM)* frequently used for relational databases. There are a few options
    available: *Mongoskin*, *Mongoose*, and *Mongolia* to name a few.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现MongoDB驱动器是许多应用的优秀解决方案。它简单、快速且易于理解。如果我们需要更多功能，我们可能会考虑使用*对象文档映射器（ODM）*。ODM类似于常用于关系数据库的*对象关系映射器（ORM）*。有几个选项可供选择：*Mongoskin*、*Mongoose*和*Mongolia*等。
- en: We’ll be using the basic MongoDB driver for our application because most of
    our associations and higher-level data modelling are handled on the client. We
    don’t want any ODM validation features, as we’ll be validating our document structure
    using a general purpose JSON schema validator. We’ve made that choice because
    the JSON schema validator is standards-compliant and works on both the client
    and the server, whereas the ODM validations only work on the server at this time.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用基本的MongoDB驱动程序来构建我们的应用程序，因为我们的大部分关联和高级数据建模都是在客户端处理的。我们不希望有任何ODM验证功能，因为我们将通过通用的JSON模式验证器来验证我们的文档结构。我们做出这个选择是因为JSON模式验证器是符合标准的，并且可以在客户端和服务器上运行，而ODM验证目前只能在服务器上运行。
- en: 'We can use our `package.json` to install the MongoDB driver. As before, we’ll
    specify the major and minor versions of the module, but request the latest patch
    version, as shown in [listing 8.3](#ch08list03). Changes are shown in **bold**:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的`package.json`来安装MongoDB驱动程序。和之前一样，我们将指定模块的主版本和次版本，但请求最新的补丁版本，如[列表8.3](#ch08list03)所示。更改以**粗体**显示：
- en: Listing 8.3\. Update the manifest for `npm install`—webapp/package.json
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3\. 更新`npm install`的清单—webapp/package.json
- en: '[PRE56]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can run `npm install` to install all the modules in the manifest, including
    the MongoDB driver. Let’s edit the routes.js file to include `mongodb` and start
    a connection, as shown in [listing 8.4](#ch08list04). Changes are shown in **bold**:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行`npm install`来安装清单中的所有模块，包括MongoDB驱动程序。让我们编辑`routes.js`文件以包含`mongodb`并建立连接，如[列表8.4](#ch08list04)所示。更改以**粗体**显示：
- en: Listing 8.4\. Open a MongoDB connection—webapp/routes.js
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.4\. 打开MongoDB连接—webapp/routes.js
- en: '![](273fig01_alt.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](273fig01_alt.jpg)'
- en: We can also remove basic auth from our server application, as shown in [listing
    8.5](#ch08list05).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从我们的服务器应用程序中移除基本认证，如[列表8.5](#ch08list05)所示。
- en: Listing 8.5\. Remove basic auth from our server application—webapp/app.js
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.5\. 从我们的服务器应用程序中移除基本认证—webapp/app.js
- en: '![](273fig02_alt.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![](273fig02_alt.jpg)'
- en: 'Now we can start our server application (`node app.js` at the command prompt)
    and see the following output:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以启动我们的服务器应用程序（在命令提示符中输入`node app.js`）并查看以下输出：
- en: '[PRE57]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now that we’ve connected our server application to MongoDB, let’s explore basic
    Create-Read-Update-Delete (CRUD) operations.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将我们的服务器应用程序连接到MongoDB，让我们探索基本的创建-读取-更新-删除（CRUD）操作。
- en: 8.3.3\. Use MongoDB CRUD methods
  id: totrans-443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3\. 使用MongoDB CRUD方法
- en: 'Before we update our server application further, we’d like to get comfortable
    with MongoDB CRUD methods. Let’s open a terminal and start the MongoDB shell by
    typing `mongo`. We can then *create* some documents in a collection (using the
    `insert` method) as shown in [listing 8.6](#ch08list06). Our input is shown in
    **bold**:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步更新服务器应用程序之前，我们希望熟悉MongoDB的CRUD方法。让我们打开一个终端并输入`mongo`来启动MongoDB shell。然后我们可以在集合中*创建*一些文档（使用`insert`方法），如[列表8.6](#ch08list06)所示。我们的输入以**粗体**显示：
- en: Listing 8.6\. Create some documents in MongoDB
  id: totrans-445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.6\. 在MongoDB中创建一些文档
- en: '[PRE58]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can *read* these document to ensure they have been added correctly (using
    the `find` method) as shown in [listing 8.7](#ch08list07). Our input is shown
    in **bold**:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过*读取*这些文档来确保它们已经被正确添加（使用`find`方法），如[列表8.7](#ch08list07)所示。我们的输入以**粗体**显示：
- en: Listing 8.7\. Read documents from MongoDB
  id: totrans-448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.7\. 从MongoDB读取文档
- en: '[PRE59]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Note that MongoDB automatically adds a unique ID field, named `_id`, to any
    document that’s `insert`ed. Hmm, though the `name` field for one of our authors
    is obviously correct (although perhaps an understatement), it seems too formal.
    Let’s remove the stuffiness and *update* the document (using the `update` method)
    as shown in [listing 8.8](#ch08list08). Our input is shown in **bold**:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，MongoDB会自动为任何`insert`的文档添加一个唯一的ID字段，名为`_id`。嗯，尽管我们作者之一的`name`字段显然是正确的（尽管可能有点过于保守），但它似乎过于正式。让我们去除这种拘谨，并使用`update`方法来*更新*文档，如[列表8.8](#ch08list08)所示。我们的输入以**粗体**显示：
- en: Listing 8.8\. Update a document in MongoDB
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.8\. 在MongoDB中更新文档
- en: '[PRE60]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We couldn’t help but notice that a *hapless interloper* has entered our database.
    Like a red-shirted crew member in a *Star Trek* landing party, a hapless interloper
    shouldn’t make it past the end of a scene. We’d hate to break with tradition,
    so let’s dispatch this interloper forthwith and *delete* the document (using the
    `remove` method) as shown in [listing 8.9](#ch08list09). Our input is shown in
    **bold**:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不禁注意到一个 *不幸的闯入者* 已经进入了我们的数据库。就像一部 *星际迷航* 登陆小组成员中的红衫队员一样，一个不幸的闯入者不应该在场景结束时还活着。我们不愿意打破传统，所以让我们立即派遣这个闯入者，并
    *删除* 文档（使用 `remove` 方法），如 [列表 8.9](#ch08list09) 所示。我们的输入以 **粗体** 显示：
- en: Listing 8.9\. Delete a document from MongoDB
  id: totrans-454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.9\. 从 MongoDB 删除文档
- en: '[PRE61]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We’ve now completed the Create-Read-Update-Delete operations using the MongoDB
    console. Now let’s update our server application to support these operations.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用 MongoDB 控制台完成了创建-读取-更新-删除操作。现在让我们更新我们的服务器应用程序以支持这些操作。
- en: 8.3.4\. Add CRUD to the server application
  id: totrans-457
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.4\. 将 CRUD 添加到服务器应用程序
- en: 'Because we’re using Node.js, the interaction with MongoDB is going to be different
    than most other languages because JavaScript is event-based. Now that we have
    some documents in the database to play around with, let’s update our router to
    use MongoDB to fetch a list of user objects, as shown in [listing 8.10](#ch08list10).
    Changes are shown in **bold**:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 Node.js，与 MongoDB 的交互将不同于大多数其他语言，因为 JavaScript 是基于事件的。现在我们在数据库中已经有了一些文档可以操作，让我们更新我们的路由器以使用
    MongoDB 获取用户对象列表，如 [列表 8.10](#ch08list10) 所示。更改以 **粗体** 显示：
- en: Listing 8.10\. Update our router to retrieve a user list—`webapp/routes.js`
  id: totrans-459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10\. 更新我们的路由器以检索用户列表—`webapp/routes.js`
- en: '![](277fig01_alt.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![](277fig01_alt.jpg)'
- en: Before looking at the results in your browser, you may want to get a browser
    extension or add-on that makes the JSON more human-readable. We use *JSONView
    0.0.32* on Chrome and *JSONovich 1.9.5* on Firefox. Both of these are available
    through the respective vendor add-on sites.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看结果之前，你可能想要安装一个浏览器扩展或插件，使 JSON 更易于阅读。我们在 Chrome 上使用 *JSONView 0.0.32*，在
    Firefox 上使用 *JSONovich 1.9.5*。这两个插件都可以在各自的供应商插件网站上找到。
- en: 'We can start our application by typing `node app.js` in the terminal. When
    we point our browser to http://localhost:3000/user/list, we should see a JSON
    document presentation similar to [figure 8.3](#ch08fig03):'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在终端中输入 `node app.js` 来启动我们的应用程序。当我们将浏览器指向 http://localhost:3000/user/list
    时，我们应该看到一个类似于 [图 8.3](#ch08fig03) 的 JSON 文档展示。
- en: Figure 8.3\. Response from MongoDB through Node.js to client
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.3\. 通过 Node.js 从 MongoDB 到客户端的响应
- en: '![](08fig03_alt.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig03_alt.jpg)'
- en: 'We can now add the remaining CRUD operations as shown in [listing 8.11](#ch08list11).
    Changes are shown in **bold**:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加剩余的 CRUD 操作，如 [列表 8.11](#ch08list11) 所示。更改以 **粗体** 显示：
- en: Listing 8.11\. Add the MongoDB driver and CRUD to our router—routes.js
  id: totrans-466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11\. 将 MongoDB 驱动和 CRUD 添加到我们的路由器—routes.js
- en: '![](ch08list11-0.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list11-0.jpg)'
- en: '![](ch08list11-1.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list11-1.jpg)'
- en: We now have user CRUD operations working from the client through the Node.js
    server and into MongoDB and back again. Now we would like the application to validate
    data received from the client.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从客户端通过 Node.js 服务器到 MongoDB，然后再返回，用户 CRUD 操作正在工作。现在我们希望应用程序验证从客户端接收到的数据。
- en: 8.4\. Validate client data
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. 验证客户端数据
- en: 'MongoDB doesn’t have a mechanism to define what can and can’t be added to a
    collection. We’ll need to validate client data ourselves before saving it. We
    want our data transfer to work as shown in [figure 8.5](#ch08fig05):'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 没有定义可以添加到集合中的内容的机制。在保存之前，我们需要自己验证客户端数据。我们希望数据传输如图 8.5 所示：
- en: Figure 8.4\. Validate client data—the path through the code
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.4\. 验证客户端数据——代码路径
- en: '![](08fig04_alt.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig04_alt.jpg)'
- en: Figure 8.5\. Validation of object type
  id: totrans-474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.5\. 对象类型验证
- en: '![](08fig05_alt.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig05_alt.jpg)'
- en: Our first step is to define what types of objects are valid.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是定义哪些类型的对象是有效的。
- en: 8.4.1\. Validate the object type
  id: totrans-477
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1\. 验证对象类型
- en: 'As it is now, we’re accepting any route and passing objects to MongoDB without
    even verifying if it’s an allowable type. For example, a POST to create a horse
    will work. The following is an example using `wget`. Our input is shown in **bold**:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 如现在所示，我们接受任何路由并将对象传递给 MongoDB，甚至没有验证它是否是允许的类型。例如，一个用于创建马的 POST 请求将工作。以下是一个使用
    `wget` 的示例。我们的输入以 **粗体** 显示：
- en: '[PRE62]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This is even worse than it may appear. MongoDB will not only store the document,
    but it’ll *create a completely new collection* (as it did in our example), which
    consumes a fair amount of resources. We couldn’t go to production like this, as
    a simple script kiddie could easily overwhelm the server(s) in minutes by running
    a script that creates thousands of new MongoDB collections.^([[3](#ch08fn03)])
    We should allow access only to approved object types, as shown in [figure 8.5](#ch08fig05).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至比看起来更糟糕。MongoDB不仅会存储文档，它还会*创建一个全新的集合*（就像我们在示例中所做的那样），这会消耗相当多的资源。我们不能这样上线，因为一个简单的脚本小子可以在几分钟内通过运行一个创建数千个新MongoDB集合的脚本而轻易地压垮服务器（s）。我们应该只允许访问经过批准的对象类型，如图8.5所示。
- en: ³ On my 64-bit developer box, each *nearly empty* collection grabs around 64MB
    of disk space.
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³在我的64位开发机器上，每个*几乎为空*的集合大约占用64MB的磁盘空间。
- en: 'This is easy enough to implement. We can create a map of allowable object types
    and then check against it in the router. Let’s modify the routes.js file to do
    this, as shown in [listing 8.12](#ch08list12). Changes are shown in **bold**:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易实现。我们可以创建一个允许的对象类型的映射，然后在路由器中检查它。让我们修改routes.js文件来实现这一点，如图8.12所示。变化以**粗体**显示：
- en: Listing 8.12\. Validate the incoming routes—`routes.js`
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.12。验证传入的路由—`routes.js`
- en: '![](ch08list12-0.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08list12-0.jpg)'
- en: '![](ch08list12-1.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08list12-1.jpg)'
- en: We don’t want to stop with just ensuring the object type is allowed. We also
    want to ensure the client data is structured as we expect. Let’s do that next.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望仅仅确保对象类型被允许。我们还想确保客户端数据结构如我们所期望的那样。让我们接下来这么做。
- en: 8.4.2\. Validate the object
  id: totrans-487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.2。验证对象
- en: The browser client sends a JSON document to the server to represent an object.
    As many readers are surely aware, JSON has displaced XML for many web APIs because
    it’s more compact and often easier to process.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器客户端发送一个JSON文档到服务器以表示一个对象。正如许多读者可能已经知道的那样，JSON已经取代了XML在许多Web API中的应用，因为它更紧凑，通常更容易处理。
- en: One stellar feature that XML provides is the ability to define a *Document Type
    Definition (DTD)* that describes allowable content. JSON has a similar, although
    less mature, standard that can ensure document content similar to a DTD. It’s
    called a *JSON schema*.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: XML提供的一个非常出色的功能是能够定义一个*文档类型定义（DTD）*，它描述了允许的内容。JSON有一个类似但不够成熟的类似标准，可以确保文档内容类似于DTD。它被称为*JSON
    schema*。
- en: '*JSV* is a validator that uses a JSON schema. It can be used in the browser
    and the server, so we don’t have to write or maintain two separate (and always
    subtly conflicting) validation libraries. Here are the steps we need to validate
    our objects:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '*JSV*是一个使用JSON schema的验证器。它可以在浏览器和服务器上使用，所以我们不需要编写或维护两个不同的（并且总是微妙地冲突的）验证库。以下是我们需要验证我们的对象的步骤：'
- en: Install the JSV node module
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装JSV节点模块
- en: Create a JSON schema
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个JSON schema
- en: Load JSON schemas
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载JSON schemas
- en: Create a validation function
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个验证函数
- en: Validate incoming data
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证传入数据
- en: Our first step is to install JSV.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是安装JSV。
- en: Install the Jsv Node Module
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安装Jsv Node模块
- en: 'Update the package.json file to include JSV 4.0.2\. It should now look like
    [listing 8.13](#ch08list13):'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 将package.json文件更新为包含JSV 4.0.2。现在它应该看起来像[列表8.13](#ch08list13)：
- en: Listing 8.13\. Update the manifest to include JSV—`webapp/package.json`
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.13。更新清单以包含JSV—`webapp/package.json`
- en: '[PRE63]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: When we run `npm install`, `npm` should pick up the changes and install JSV.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`npm install`时，`npm`应该能够检测到更改并安装JSV。
- en: Create a Json Schema
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建一个Json Schema
- en: Before we can validate a user object, we must decide what properties are allowed
    and what values they might take. The JSON schema provides us a nice, standard
    mechanism to describe these constraints, as shown in [listing 8.14](#ch08list14).
    Be sure to pay careful attention to the annotations, as they explain the constraints.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够验证用户对象之前，我们必须决定允许哪些属性以及它们可能取哪些值。JSON schema为我们提供了一个很好的、标准的机制来描述这些约束，如图8.14所示。务必仔细注意注释，因为它们解释了约束。
- en: Listing 8.14\. Create the user schema—webapp/user.json
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.14。创建用户schema—webapp/user.json
- en: '![](ch08list14-0.jpg)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08list14-0.jpg)'
- en: '![](ch08list14-1.jpg)'
  id: totrans-506
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08list14-1.jpg)'
- en: You may have noticed that we have defined a schema that constrains an object
    and constrains an object *within* that object. This illustrates how a JSON schema
    can be infinitely recursive. JSON schemas may extend other schemas too, much like
    XML. If you want to learn more about JSON schemas, check out the official website
    at [jsonschema.org](http://jsonschema.org). Now we can load our schema and ensure
    any user object we receive contains only the data we allow.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们定义了一个约束对象的模式，并在该对象内约束对象。这说明了 JSON 模式可以无限递归。JSON 模式也可以扩展其他模式，就像 XML
    一样。如果你想了解更多关于 JSON 模式的信息，请查看官方网站 [jsonschema.org](http://jsonschema.org)。现在我们可以加载我们的模式并确保我们收到的任何用户对象只包含我们允许的数据。
- en: Load Json Schemas
  id: totrans-508
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 加载 Json 模式
- en: Let’s load our schema documents into memory when the server is started. This
    will avoid expensive file seeks while our server application is running. We can
    load one schema document per object type defined in the object type map (`objTypeMap`)
    as shown in [listing 8.15](#ch08list15). Changes are shown in **bold**:^([[4](#ch08fn04)])
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器启动时，让我们将我们的模式文档加载到内存中。这将避免在服务器应用程序运行时进行昂贵的文件查找。我们可以按对象类型映射（`objTypeMap`）中定义的对象类型加载每个模式文档（如图
    [列表 8.15](#ch08list15) 所示）。变化以**粗体**显示：^([[4](#ch08fn04)])
- en: ⁴ Windows users will need to replace forward slashes (`/`) with double back
    slashes (`\\`) for file system paths.
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ Windows 用户需要将文件系统路径中的正斜杠（`/`）替换为双反斜杠（`\\`）。
- en: Listing 8.15\. Load schemas in our router—`webapp/routes.js`
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.15\. 在我们的路由器中加载模式—`webapp/routes.js`
- en: '![](ch08list15-0.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list15-0.jpg)'
- en: '![](ch08list15-1.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list15-1.jpg)'
- en: Now that we have our schemas loaded, we can create a validation function.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了我们的模式，我们可以创建一个验证函数。
- en: Create a Validation Function
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建一个验证函数
- en: 'Now that we have the `user` JSON schema loaded, we want to compare incoming
    client data against the schema. [Listing 8.16](#ch08list16) shows a simple function
    to do just that. Changes are shown in **bold**:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了 `user` JSON 模式，我们想要将传入的客户端数据与模式进行比较。[列表 8.16](#ch08list16) 展示了一个简单的函数来完成这项工作。变化以**粗体**显示：
- en: Listing 8.16\. Add a function to validate documents—`webapp/routes.js`
  id: totrans-517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.16\. 添加一个验证文档的功能—`webapp/routes.js`
- en: '![](ch08list16-0.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list16-0.jpg)'
- en: '![](ch08list16-1.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list16-1.jpg)'
- en: Now that we have a JSON schema loading and a validation function, we can validate
    incoming client data.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 JSON 模式加载和验证函数，我们可以验证传入的客户端数据。
- en: Validate Incoming Client Data
  id: totrans-521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 验证传入的客户端数据
- en: 'Now we can complete validation. We just need to adjust the routes that accept
    client data—create and update—to use the validator. In each case, we want to perform
    the requested action if the list of errors is empty. Otherwise we want to return
    an error report, as shown in [listing 8.17](#ch08list17). Changes are shown in
    **bold**:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以完成验证。我们只需要调整接受客户端数据的路由（创建和更新）以使用验证器。在每种情况下，如果错误列表为空，我们想要执行请求的操作。否则，我们想要返回一个错误报告，如图
    [列表 8.17](#ch08list17) 所示。变化以**粗体**显示：
- en: Listing 8.17\. Create and update routes with validation—webapp/`routes.js`
  id: totrans-523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.17\. 创建和更新带有验证的路由—`webapp/`routes.js`
- en: '![](ch08list17-0.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list17-0.jpg)'
- en: '![](ch08list17-1.jpg)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list17-1.jpg)'
- en: 'Now that we have completed validation, let’s see how we’ve done. First we should
    make sure all our modules pass JSLint (`jslint user.json app.js routes.js`), and
    then start the application (`node app.js`). Then we can use our deft `wget` skills
    to `POST` bad and good data, as shown in [listing 8.18](#ch08list18). Our input
    is shown in **bold**:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了验证，让我们看看我们做得怎么样。首先，我们应该确保所有我们的模块都通过 JSLint (`jslint user.json app.js
    routes.js`)，然后启动应用程序（`node app.js`）。然后我们可以使用我们熟练的 `wget` 技巧来 `POST` 好的和坏的数据，如图
    [列表 8.18](#ch08list18) 所示。我们的输入以**粗体**显示：
- en: Listing 8.18\. POST bad and good data using deft `wget` skills
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.18\. 使用熟练的 `wget` 技巧 `POST` 好的和坏的数据
- en: '[PRE64]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Updating a user with `wget` is left as an exercise for the reader.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `wget` 更新用户留作读者练习。
- en: In the next section we’ll move the CRUD capability into a separate module. This
    will result in cleaner, easier to understand, and more maintainable code.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将 CRUD 功能移动到一个单独的模块中。这将导致代码更干净、更容易理解，并且更易于维护。
- en: 8.5\. Create a separate CRUD module
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5\. 创建一个单独的 CRUD 模块
- en: At this point, the logic for CRUD operations and routing is contained in the
    routes.js file as shown in [figure 8.6](#ch08fig06).
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，CRUD 操作和路由的逻辑包含在如图 [图 8.6](#ch08fig06) 所示的 routes.js 文件中。
- en: Figure 8.6\. Path through code
  id: totrans-533
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.6\. 代码中的路径
- en: '![](08fig06_alt.jpg)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig06_alt.jpg)'
- en: We have the server accepting calls from the client, validating the data, and
    saving it to the database. The only way to validate and save the data is through
    calling the routes with an HTTP call. If this were all we needed for the application,
    then it’d probably makes sense to stop here with no further abstraction. But our
    SPA will need to create and modify objects through web socket connections as well.
    Therefore, we’ll create a CRUD module that has all of the logic for validating
    and managing our documents in the database. The router will then use the CRUD
    module for any required CRUD operations.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器正在接受来自客户端的调用，验证数据，并将其保存到数据库中。验证和保存数据的唯一方式是通过调用路由进行 HTTP 调用。如果这就是我们应用所需的所有内容，那么可能就没有必要进一步抽象化，在这里停止。但我们的单页应用还需要通过
    WebSocket 连接创建和修改对象。因此，我们将创建一个 CRUD 模块，其中包含验证和管理数据库中文档的所有逻辑。然后，路由器将使用 CRUD 模块进行任何所需的
    CRUD 操作。
- en: Before we create the CRUD module, we want to emphasize why we waited until now
    to create it. We like to keep our code as direct and simple as possible, but not
    simpler. If we have to do an operation only once in the code, we prefer to usually
    have it inline or at least as a local function. But when we find that we need
    to perform an operation two or more times, we want to abstract it. Though this
    may not save initial coding time, it almost always saves maintenance time, as
    we centralize the logic into a single routine and avoid subtle errors that can
    result in variances in implementation. Of course, it takes good judgment to determine
    how far to take this philosophy. For example, we feel abstracting all `for` loops
    is generally not a good idea even though it’s thoroughly possible with JavaScript.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建 CRUD 模块之前，我们想强调为什么我们等到现在才创建它。我们喜欢保持我们的代码尽可能直接和简单，但不要过于简单。如果我们必须在代码中只执行一次操作，我们通常更喜欢将其内联或至少作为一个局部函数。但当我们发现我们需要执行两次或更多次操作时，我们希望进行抽象化。尽管这可能不会节省初始编码时间，但它几乎总是节省维护时间，因为我们把逻辑集中到一个单独的例程中，并避免了可能导致实现差异的微妙错误。当然，需要良好的判断力来确定这一哲学的适用范围。例如，我们认为抽象化所有的
    `for` 循环通常不是一个好主意，尽管用 JavaScript 完全可能做到。
- en: 'After we move the MongoDB connection and validations over to a separate CRUD
    module, our router will no longer be concerned with the implementation of data
    storage and will act more like a controller: it dispatches requests to other modules
    instead of performing actions itself, as shown in [figure 8.7](#ch08fig07).'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将 MongoDB 连接和验证移动到一个单独的 CRUD 模块之后，我们的路由器将不再关心数据存储的实现，而更像是一个控制器：它将请求调度到其他模块，而不是自己执行操作，如图
    8.7 所示。
- en: Figure 8.7\. Code path on the server
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.7\. 服务器上的代码路径
- en: '![](08fig07_alt.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![08fig07_alt.jpg](08fig07_alt.jpg)'
- en: Our first step in creating the CRUD module will be to prepare the file structure.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 CRUD 模块的第一步是准备文件结构。
- en: 8.5.1\. Prepare the file structure
  id: totrans-541
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.1\. 准备文件结构
- en: 'Our file structure has remained consistent since the beginning of this chapter.
    Now that we need to add an additional module, we need to rethink it a bit. Our
    current structure is shown in [listing 8.19](#ch08list19):'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 自本章开始以来，我们的文件结构一直保持一致。现在我们需要添加一个额外的模块，我们需要对其进行一些思考。我们当前的结构如图 8.19 所示：
- en: Listing 8.19\. Our current file structure
  id: totrans-543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.19\. 我们当前的文件结构
- en: '[PRE65]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We’d rather keep our modules in a separate directory called lib. This will
    tidy up the webapp directory and keep our modules out of the node_modules directory.
    The node_modules directory should only contain external modules added through
    `npm install` so that it can be deleted and recreated without interfering with
    our modules. [Listing 8.20](#ch08list20) shows how we want to structure our files.
    Changes are shown in **bold**:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更愿意将我们的模块保存在一个名为 lib 的单独目录中。这将整理 webapp 目录，并将我们的模块与 node_modules 目录分开。node_modules
    目录应仅包含通过 `npm install` 添加的外部模块，以便它可以被删除和重新创建，而不会干扰我们的模块。[列表 8.20](#ch08list20)
    展示了我们希望如何组织我们的文件。变更以粗体显示：
- en: Listing 8.20\. A new and enlightened file structure
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.20\. 一个新的启迪性文件结构
- en: '[PRE66]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Our first step toward file enlightenment is to move our routes file into webapp/lib.
    Once we’ve done that, we need to update our server application to point to the
    new path, as shown in [listing 8.21](#ch08list21). Changes are shown in **bold**:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迈向文件启迪的第一步是将我们的路由文件移动到 webapp/lib。一旦我们这样做，我们需要更新我们的服务器应用程序以指向新的路径，如图 8.21
    所示。变更以粗体显示：
- en: Listing 8.21\. Revise app.js to require moved routes.js—`webapp/app.js`
  id: totrans-549
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.21\. 修改 app.js 以引入移动后的 routes.js—`webapp/app.js`
- en: '[PRE67]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Our next step is to include the CRUD module in our routes module, as shown
    in [listing 8.22](#ch08list22). Changes are shown in **bold**:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的步骤是将 CRUD 模块包含到我们的路由模块中，如[列表 8.22](#ch08list22)所示。变更以**粗体**显示：
- en: Listing 8.22\. Adjust the routes module to require CRUD—`webapp/lib/routes.js`
  id: totrans-552
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.22\. 调整路由模块以要求 CRUD—`webapp/lib/routes.js`
- en: '[PRE68]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We can create our CRUD module and sketch its API. We’ll use `module.exports`
    to share the CRUD methods, as shown in [listing 8.23](#ch08list23).
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建我们的 CRUD 模块并草拟其 API。我们将使用 `module.exports` 来共享 CRUD 方法，如[列表 8.23](#ch08list23)所示。
- en: Listing 8.23\. Create the CRUD module—`webapp/lib/crud.js`
  id: totrans-555
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.23\. 创建 CRUD 模块—`webapp/lib/crud.js`
- en: '![](ch08list23-0.jpg)'
  id: totrans-556
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list23-0.jpg)'
- en: '![](ch08list23-1.jpg)'
  id: totrans-557
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list23-1.jpg)'
- en: 'When we start the server with `node app.js` it should run without any errors:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `node app.js` 启动服务器时，它应该在没有错误的情况下运行：
- en: '[PRE69]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note that we’ve added two public methods beyond basic CRUD operations. The first
    is `makeMongoId`, which provides the capability to make a MongoDB ID object. The
    second is `checkType`, which we intend to use to check allowable object types.
    Now that we have our files in place, we can move our CRUD logic into the proper
    module.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们添加了两个超出基本 CRUD 操作的公共方法。第一个是 `makeMongoId`，它提供了创建 MongoDB ID 对象的能力。第二个是
    `checkType`，我们打算用它来检查允许的对象类型。现在我们的文件已经就绪，我们可以将 CRUD 逻辑移动到适当的模块。
- en: 8.5.2\. Move CRUD into its own module
  id: totrans-561
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.2\. 将 CRUD 移动到自己的模块
- en: 'We can complete the CRUD module by copying our methods from the routes module
    and then replacing the HTTP-specific parameters with general ones. We won’t go
    into the minutia as we feel the conversion is obvious. The completed module is
    shown in [listing 8.24](#ch08list24). Please pay attention to the annotations
    as they provide some additional insight:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过复制路由模块中的方法来完成 CRUD 模块，然后将特定的 HTTP 参数替换为通用的参数。我们不会深入细节，因为我们认为转换是显而易见的。完成的模块在[列表
    8.24](#ch08list24)中显示。请注意注释，因为它们提供了一些额外的见解：
- en: Listing 8.24\. Move logic to our CRUD module—`webapp/lib/crud.js`
  id: totrans-563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.24\. 将逻辑移动到我们的 CRUD 模块—`webapp/lib/crud.js`
- en: '![](ch08list24-0.jpg)'
  id: totrans-564
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list24-0.jpg)'
- en: '![](ch08list24-1.jpg)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list24-1.jpg)'
- en: 'The routes module now becomes much simpler, as most logic and many dependencies
    have been moved to the CRUD module. A revised routes file should look like [listing
    8.25](#ch08list25). Changes are shown in **bold**:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 路由模块现在变得简单多了，因为大部分逻辑和许多依赖都已经被移动到了 CRUD 模块。一个修订后的路由文件应看起来像[列表 8.25](#ch08list25)。变更以**粗体**显示：
- en: Listing 8.25\. Our modified routes module—`webapp/lib/routes.js`
  id: totrans-567
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.25\. 我们修改后的路由模块—`webapp/lib/routes.js`
- en: '![](ch08list25-0.jpg)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list25-0.jpg)'
- en: '![](ch08list25-1.jpg)'
  id: totrans-569
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list25-1.jpg)'
- en: Now our routes module is much smaller and uses the CRUD module to service routes.
    And, perhaps more importantly, our CRUD module is ready to be used by the chat
    module we’ll build in the next section.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的路由模块变得更小，并使用 CRUD 模块来服务路由。也许更重要的是，我们的 CRUD 模块已经准备好在下一节中我们将构建的聊天模块中使用。
- en: 8.6\. Build the Chat module
  id: totrans-571
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6\. 构建聊天模块
- en: We want our server application to provide chat capabilities to our SPA. Until
    now, we’ve been building out the client, UI, and supporting framework on the server.
    See [figure 8.8](#ch08fig08) to see how our application should look once chat
    is implemented.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的服务器应用程序能够为我们的单页应用（SPA）提供聊天功能。到目前为止，我们一直在服务器上构建客户端、UI 和支持框架。参见[图 8.8](#ch08fig08)以了解聊天实现后我们的应用程序应如何看起来。
- en: Figure 8.8\. Finished Chat application
  id: totrans-573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.8\. 完成的聊天应用程序
- en: '![](08fig08_alt.jpg)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig08_alt.jpg)'
- en: We’ll have a working chat server by the end of this section. We’ll start by
    creating a chat module.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节结束时拥有一个可工作的聊天服务器。我们将首先创建一个聊天模块。
- en: 8.6.1\. Start the chat module
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.6.1\. 启动聊天模块
- en: 'Socket.IO should be installed in our webapp directory already. Please ensure
    your webapp/package.json manifest has the correct modules listed:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO 应已安装在我们的 webapp 目录中。请确保您的 webapp/package.json 清单中列出了正确的模块：
- en: '[PRE70]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Once our manifest matches the example, we can run `npm install`, and `npm` will
    ensure `socket.io` and all other required modules are installed.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的清单与示例匹配，我们就可以运行 `npm install`，`npm` 将确保安装 `socket.io` 和所有其他所需的模块。
- en: 'Now we can build our chat messaging module. We want to include the CRUD module
    because we’re certain we’ll need it for our messages. We’ll construct a `chatObj`
    object and export it using `module.exports`. At first this object will have a
    single method called `connect` that will take the `http.Server` instance (`server`)
    as an argument and will begin listening for socket connections. Our first pass
    is shown in [listing 8.26](#ch08list26):'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建我们的聊天消息模块。我们想包括 CRUD 模块，因为我们确信我们将在消息中使用它。我们将构建一个 `chatObj` 对象，并使用 `module.exports`
    导出它。最初，这个对象将只有一个名为 `connect` 的方法，它将接受 `http.Server` 实例（`server`）作为参数，并开始监听套接字连接。我们的第一次尝试如下所示
    [清单 8.26](#ch08list26)：
- en: Listing 8.26\. Our first pass at the chat messaging module—`webapp/lib/chat.js`
  id: totrans-581
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 8.26\. 我们对聊天消息模块的第一次尝试—`webapp/lib/chat.js`
- en: '[PRE71]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You may recall from [chapter 6](kindle_split_017.html#ch06) that the client
    will be sending messages to the server—`adduser`, `updatechat`, `leavechat`, `disconnect`,
    and `updateavatar`—using the `/chat` namespace. Let’s set up our chat client to
    handle these messages as shown in [listing 8.27](#ch08list27). Changes are shown
    in **bold**:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得 [第 6 章](kindle_split_017.html#ch06)，客户端将使用 `/chat` 命名空间向服务器发送消息—`adduser`、`updatechat`、`leavechat`、`disconnect`
    和 `updateavatar`。让我们设置我们的聊天客户端来处理这些消息，如下所示 [清单 8.27](#ch08list27)。更改以粗体显示：
- en: Listing 8.27\. Set up our app and outline message handlers—`webapp/lib/chat.js`
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 8.27\. 设置我们的应用程序并概述消息处理器—`webapp/lib/chat.js`
- en: '![](301fig01_alt.jpg)'
  id: totrans-585
  prefs: []
  type: TYPE_IMG
  zh: '![301fig01_alt.jpg](301fig01_alt.jpg)'
- en: 'Let’s return to the routes module, where we’ll include the chat module and
    then use the `chat.connect` method to initialize the Socket.IO connection. We
    provide the `http.Server` instance (`server`) as the argument, as shown in [listing
    8.28](#ch08list28). Changes are shown in **bold**:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到路由模块，我们将包括聊天模块，然后使用 `chat.connect` 方法初始化 Socket.IO 连接。我们提供 `http.Server`
    实例（`server`）作为参数，如 [清单 8.28](#ch08list28) 所示。更改以粗体显示：
- en: Listing 8.28\. Update the routes module to initialize chat—`webapp/lib/routes.js`
  id: totrans-587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 8.28\. 更新路由模块以初始化聊天—`webapp/lib/routes.js`
- en: '[PRE72]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: When we start the server with `node app.js` we should see `info - socket.io
    started` in the Node.js server log. We can also access http://localhost:3000 as
    before to manage user objects or view our application in the browser.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `node app.js` 启动服务器时，我们应该在 Node.js 服务器日志中看到 `info - socket.io started`。我们也可以像以前一样访问
    http://localhost:3000 来管理用户对象或在浏览器中查看我们的应用程序。
- en: We’ve declared all our message handlers, but now we need to make them respond.
    Let’s start with the `adduser` message handler.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明了所有的消息处理器，但现在我们需要让它们做出响应。让我们从 `adduser` 消息处理器开始。
- en: '|  |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Why web sockets?**'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么选择 WebSocket？**'
- en: 'Web sockets have some distinct advantages over other near-real-time communication
    techniques used in the browser:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 相比于浏览器中使用的其他近实时通信技术具有一些明显的优势：
- en: A web socket data frame requires only two bytes to maintain a data connection,
    whereas an AJAX HTTP call (used in long-polling) often transfers kilobytes of
    information per frame (the actual amount varies according to the number and size
    of cookies).
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 WebSocket 数据帧只需要两个字节来维护数据连接，而 AJAX HTTP 调用（在长轮询中使用）通常每个数据帧传输千字节的信息（实际数量根据
    Cookie 的数量和大小而变化）。
- en: Web sockets compare favorably to long-polling. They typically use about 1-2%
    of the network bandwidth and have one-third the latency. Web sockets also tend
    to be more firewall-friendly.
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket 与长轮询相比具有优势。它们通常使用大约 1-2% 的网络带宽，并且延迟减少到三分之一。WebSocket 还往往更受防火墙欢迎。
- en: Web sockets are full-duplex, whereas most other solutions are not and require
    the equivalent of two connections.
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket 是全双工的，而大多数其他解决方案不是，并且需要相当于两个连接。
- en: Unlike Flash sockets, web sockets work on any modern browser on nearly any platform—including
    mobile devices like smart phones and tablets.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Flash 套接字不同，WebSocket 在几乎所有平台上的任何现代浏览器上都能工作，包括智能手机和平板电脑等移动设备。
- en: Though Socket.IO favors web sockets, it’s comforting to know that it’ll negotiate
    the best connection possible if web sockets aren’t available.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Socket.IO 倾向于使用 WebSocket，但知道如果 WebSocket 不可用，它将协商最佳连接，这让人感到安慰。
- en: '|  |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.6.2\. Create the adduser message handler
  id: totrans-600
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.6.2\. 创建 adduser 消息处理器
- en: 'When a user attempts to sign in, the client sends an `adduser` message with
    user data to our server application. Our `adduser` message handler should:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户尝试登录时，客户端会向我们的服务器应用程序发送包含用户数据的 `adduser` 消息。我们的 `adduser` 消息处理器应该：
- en: Try to find the user object with the provided username in MongoDB using the
    CRUD module.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用 CRUD 模块在 MongoDB 中查找提供的用户名对应的用户对象。
- en: If an object with the requested username is found, use the found object.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到了请求的用户对象，使用找到的对象。
- en: If an object with the requested username *is not* found, create a new user object
    with the provided username and insert it into the database. Use this newly created
    object.
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有找到请求的用户对象**不是**，则使用提供的用户名创建一个新的用户对象并将其插入数据库。使用这个新创建的对象。
- en: 'Update the user object in MongoDB to indicate the user is online (`is_online:
    true`).'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '更新MongoDB中的用户对象以指示用户在线（`is_online: true`）。'
- en: Update the `chatterMap` to store the user ID and a socket connection as key-value
    pairs.
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`chatterMap`以存储用户ID和socket连接作为键值对。
- en: 'Let’s implement this logic as shown in [listing 8.29](#ch08list29). Changes
    are shown in **bold**:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照[列表8.29](#ch08list29)中所示实现这个逻辑。更改以**粗体**显示：
- en: Listing 8.29\. Create the adduser message handler—`webapp/lib/chat.js`
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.29. 创建adduser消息处理器—`webapp/lib/chat.js`
- en: '![](ch08list29-0.jpg)'
  id: totrans-609
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list29-0.jpg)'
- en: '![](ch08list29-1.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list29-1.jpg)'
- en: 'It can take a while to adjust to the callback method of thinking, but typically
    when we call a method, and when that method finishes, the callback we provided
    gets executed. In essence it turns procedural code like so:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 调整到回调方法的思考可能需要一段时间，但通常当我们调用一个方法，并且该方法完成时，我们提供的回调将被执行。本质上它将过程代码转换为这样：
- en: '[PRE73]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Into event-driven code like this:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 进入类似这样的事件驱动代码：
- en: '[PRE74]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We use callbacks because many function calls in Node.js are asynchronous. In
    the preceding example, when we invoke `user.create`, the JavaScript engine will
    keep on executing the subsequent code without waiting for the invocation to complete.
    One guaranteed way to use the results immediately after they’re ready is to use
    a callback.^([[5](#ch08fn05)]) If you’re familiar with the jQuery AJAX call, it
    uses the callback mechanism:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用回调，因为Node.js中的许多函数调用都是异步的。在前面的例子中，当我们调用`user.create`时，JavaScript引擎将继续执行后续代码，而不会等待调用完成。在结果准备好后立即使用结果的保证方法之一是使用回调.^([[5](#ch08fn05)])
    如果你熟悉jQuery AJAX调用，它使用回调机制：
- en: ⁵ Another mechanism is called *promises*, and is generally more flexible than
    vanilla callbacks. Promise libraries include Q (`npm install q`) and Promised-IO
    (`npm install promised-io`). jQuery for Node.js also provides a rich and familiar
    set of promise methods. [Appendix B](kindle_split_023.html#app02) shows the use
    of jQuery with Node.js.
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 另一种机制称为*承诺*，通常比普通的回调更灵活。承诺库包括Q (`npm install q`) 和 Promised-IO (`npm install
    promised-io`)。jQuery for Node.js 也提供了一套丰富且熟悉的承诺方法。[附录B](kindle_split_023.html#app02)展示了jQuery与Node.js的使用。
- en: '[PRE75]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We can now point our browser to localhost:3000 and sign in. We encourage those
    playing along at home to give it a try. Now let’s get people chatting.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将浏览器指向localhost:3000并登录。我们鼓励在家练习的人尝试一下。现在让我们开始聊天。
- en: 8.6.3\. Create the updatechat message handler
  id: totrans-619
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.6.3. 创建updatechat消息处理器
- en: A fair amount of code was required to implement sign-in. Our application now
    keeps track of users in MongoDB, managing their state, and broadcasts a list of
    online people to all connected clients. Handling chat messaging is comparatively
    simple, especially now that we have the sign-in logic complete.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 实现登录功能需要相当多的代码。我们的应用程序现在在MongoDB中跟踪用户，管理他们的状态，并向所有连接的客户端广播在线人员列表。处理聊天消息相对简单，尤其是在我们完成登录逻辑之后。
- en: 'When the client sends an `updatechat` message to our server application, it’s
    requesting delivery of a message to someone. Our `updatechat` message handler
    should:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向我们的服务器应用程序发送`updatechat`消息时，它是在请求将消息发送给某人。我们的`updatechat`消息处理器应该：
- en: Inspect the chat data and retrieve the recipient.
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查聊天数据并检索收件人。
- en: Determine if the intended recipient is online.
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定目标收件人是否在线。
- en: If the recipient is online, send the chat data to the recipient on their socket.
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果收件人在线，通过他们的socket将聊天数据发送给收件人。
- en: If the recipient is *not online*, send new chat data to the sender on their
    socket. The new chat data should notify the sender that the intended recipient
    is not online.
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果收件人**不在线**，将新的聊天数据发送给发送者在其socket上。新的聊天数据应通知发送者目标收件人不在线。
- en: 'Let’s implement this logic as shown in [listing 8.30](#ch08list30). Changes
    are shown in **bold**:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照[列表8.30](#ch08list30)中所示实现这个逻辑。更改以**粗体**显示：
- en: Listing 8.30\. Add the updatechat message handler—`webapp/lib/chat.js`
  id: totrans-627
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.30. 添加updatechat消息处理器—`webapp/lib/chat.js`
- en: '![](ch08list30-0.jpg)'
  id: totrans-628
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list30-0.jpg)'
- en: '![](ch08list30-1.jpg)'
  id: totrans-629
  prefs: []
  type: TYPE_IMG
  zh: '![](ch08list30-1.jpg)'
- en: We can now point our browser to localhost:3000 and sign in. If we sign in to
    another browser window as a different user, we can pass messages back and forth.
    As always, we encourage those playing along at home to give it a try. The only
    capabilities that don’t yet work are disconnect and avatars. Let’s take care of
    disconnect next.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的浏览器指向localhost:3000并登录。如果我们以不同的用户身份登录到另一个浏览器窗口，我们可以互相传递消息。一如既往，我们鼓励在家中的玩家尝试一下。目前唯一不起作用的功能是断开连接和头像。让我们先处理断开连接的问题。
- en: 8.6.4\. Create disconnect message handlers
  id: totrans-631
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.6.4. 创建断开连接消息处理程序
- en: A client can close the session one of two ways. First, the user may click on
    their username in the top-right corner of the browser window to sign out. This
    sends a `leavechat` message to the server. Second, the user may close the browser
    window. This results in a `disconnect` message to the server. In either case,
    Socket.IO does a good job of cleaning up the socket connection.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以通过两种方式之一关闭会话。首先，用户可以点击浏览器窗口右上角的用户名来注销。这会向服务器发送一个`leavechat`消息。其次，用户可以关闭浏览器窗口。这会导致服务器收到一个`disconnect`消息。在两种情况下，Socket.IO都很好地清理了套接字连接。
- en: 'When our server application receives a `leavechat` or a `disconnect` message,
    it should take the same two actions. First, it should mark the person associated
    with the client as offline (`is_online : false`). Second, it needs to broadcast
    the updated list of online people to all connected clients. This logic is shown
    in [listing 8.31](#ch08list31). Changes are shown in **bold**:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们的服务器应用程序收到`leavechat`或`disconnect`消息时，它应该采取相同的两个行动。首先，它应该将关联客户端的人标记为离线（`is_online
    : false`）。其次，它需要向所有已连接客户端广播更新的在线人员列表。这个逻辑在[列表8.31](#ch08list31)中显示。变化以**粗体**显示：'
- en: Listing 8.31\. Add disconnect methods—`webapp/lib/chat.js`
  id: totrans-634
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.31. 添加断开连接方法—`webapp/lib/chat.js`
- en: '![](ch08list31-0.jpg)'
  id: totrans-635
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08list31-0.jpg)'
- en: '![](ch08list31-1.jpg)'
  id: totrans-636
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08list31-1.jpg)'
- en: 'Now we can open up multiple browser windows, point them to http://localhost:3000,
    and sign in as different users by clicking at the top-right corner of each window.
    We can then send message between users. We did intentionally leave one flaw as
    an exercise for our readers: the server application will allow the same user to
    log in on multiple clients. This shouldn’t be possible. You should be able to
    fix this by inspecting the `chatterMap` in the `adduser` message handler.'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以打开多个浏览器窗口，将它们指向 http://localhost:3000，并通过点击每个窗口右上角来以不同的用户身份登录。然后我们可以在用户之间发送消息。我们故意留下了一个缺陷作为读者的练习：服务器应用程序将允许同一用户在多个客户端登录。这是不应该发生的。你应该可以通过检查`adduser`消息处理程序中的`chatterMap`来修复这个问题。
- en: 'We have one feature yet to implement: synchronizing avatars.'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个尚未实现的功能：同步头像。
- en: 8.6.5\. Create the updateavatar message handler
  id: totrans-639
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.6.5. 创建更新头像消息处理程序
- en: Web socket messaging can be used for all kinds of server-client communication.
    When we need near-real-time communication with the browser, it’s often the best
    choice. To demonstrate another use of Socket.IO, we’ve built avatars into our
    chat that users can move around the screen and change color. When anyone changes
    an avatar, Socket.IO immediately pushes those updates to other users. Let’s walk
    through what that looks like in [figures 8.9](#ch08fig09), [8.10](#ch08fig10),
    and [8.11](#ch08fig11).
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket消息可用于所有类型的服务器-客户端通信。当我们需要与浏览器进行近乎实时通信时，它通常是最佳选择。为了展示Socket.IO的另一种用途，我们在聊天中加入了用户可以移动和改变颜色的头像。当任何人更改头像时，Socket.IO会立即将这些更新推送给其他用户。让我们通过[图8.9](#ch08fig09)、[8.10](#ch08fig10)和[8.11](#ch08fig11)来了解一下这看起来是什么样子。
- en: Figure 8.9\. Avatar when signing in
  id: totrans-641
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.9. 登录时的头像
- en: '![](08fig09.jpg)'
  id: totrans-642
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig09.jpg)'
- en: Figure 8.10\. Moving an avatar
  id: totrans-643
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.10. 移动头像
- en: '![](08fig10.jpg)'
  id: totrans-644
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig10.jpg)'
- en: Figure 8.11\. Avatars when others are signed in
  id: totrans-645
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.11. 其他用户登录时的头像
- en: '![](08fig11.jpg)'
  id: totrans-646
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig11.jpg)'
- en: 'The client-side code for this has been demonstrated in [chapter 6](kindle_split_017.html#ch06),
    and we’ve arrived at the moment where we put it all together. The server-side
    code to enable this is dramatically small now that we’ve set up the Node.js server,
    MongoDB, and Socket.IO. We just add a message handler adjacent to the others in
    lib/chat.js as shown in [listing 8.32](#ch08list32):'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 这个客户端代码已经在[第6章](kindle_split_017.html#ch06)中演示过，我们现在已经到了将所有这些放在一起的时刻。现在我们已经设置了Node.js服务器、MongoDB和Socket.IO，使服务器端代码变得非常小。我们只需在lib/chat.js中添加一个与其它消息处理程序相邻的消息处理程序，就像[列表8.32](#ch08list32)中所示：
- en: Listing 8.32\. Behold the avatars—`webapp/lib/chat.js`
  id: totrans-648
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.32. 看看这些头像—`webapp/lib/chat.js`
- en: '[PRE76]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Let’s start the server with `node app.js`, point our browser to http://localhost:3000/,
    and sign in. Let’s also open a second browser window and sign in with a different
    user name. At this point we may only see one avatar because the two may overlap.
    We can move an avatar by using a long-press-drag motion. We can change its color
    by clicking or tapping on it. This works on desktops and touch devices. In any
    case, our server application synchronizes the avatars in near-real time.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`node app.js`启动服务器，将我们的浏览器指向http://localhost:3000/，并登录。我们还要打开第二个浏览器窗口，并用不同的用户名登录。在这个时候，我们可能只能看到一个头像，因为两个可能重叠。我们可以通过长按拖动来移动头像。我们可以通过点击或轻触来改变它的颜色。这在桌面和触摸设备上都有效。无论如何，我们的服务器应用程序在近乎实时地同步头像。
- en: Messaging is the key to near-real-time collaboration. With web sockets, we can
    create applications where distant people can work together to solve a puzzle,
    design an engine, or draw a picture—the possibilities are endless. This is the
    promise of the real-time web, and we’re seeing more of it every day.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递是实现近乎实时协作的关键。通过Web sockets，我们可以创建应用程序，让遥远的人们可以一起解决谜题、设计引擎或绘制图片——可能性是无限的。这是实时网络的承诺，我们每天都在看到更多这样的应用。
- en: 8.7\. Summary
  id: totrans-652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7. 概述
- en: In this chapter we set up MongoDB, connected it to Node.js, and performed some
    basic CRUD operations. We introduced MongoDB and discussed its many benefits and
    pitfalls. We’ve also demonstrated how to validate data before inserting it into
    the database using the same code that the client uses. This reuse saves us the
    familiar pain of writing a validator for the server in one language and rewriting
    it in JavaScript for the browser.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设置了MongoDB，将其连接到Node.js，并执行了一些基本的CRUD操作。我们介绍了MongoDB，并讨论了它的许多优点和缺点。我们还展示了如何使用客户端相同的代码在将数据插入数据库之前对其进行验证。这种重用避免了在服务器端用一种语言编写验证器，然后在浏览器端用JavaScript重写它的熟悉痛苦。
- en: We introduced Socket.IO and showed how to use it to provide chat messaging.
    We moved our CRUD capabilities into a separate module so it could easily service
    both the HTTP API and Socket.IO. And we used messaging to provide near-real-time
    synchronization of avatars across many clients.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了Socket.IO，并展示了如何使用它来提供聊天消息。我们将CRUD功能移动到一个单独的模块中，以便它可以轻松地为HTTP API和Socket.IO提供服务。我们还使用消息在许多客户端之间提供近乎实时的头像同步。
- en: In the next chapter we’ll take a look at how we make our SPA ready for production.
    We’ll review some of the problems we have encountered when hosting SPAs, and discuss
    how we can solve them.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使我们的单页应用（SPA）为生产做好准备。我们将回顾我们在托管SPA时遇到的一些问题，并讨论如何解决这些问题。
- en: Chapter 9\. Readying our SPA for production
  id: totrans-656
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章。为生产准备我们的SPA
- en: '|  |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容涵盖**'
- en: Optimizing SPAs for search engines
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化SPA以适应搜索引擎
- en: Using Google Analytics
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google Analytics
- en: Placing static content on a content delivery network (CDN)
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内容分发网络（CDN）上放置静态内容
- en: Logging client errors
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录客户端错误
- en: Caching and cache busting
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存和缓存清除
- en: '|  |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This chapter builds on code we’ve written in [chapter 8](kindle_split_020.html#ch08).
    We recommend copying the entire directory structure of that chapter into a new
    “chapter_9” directory and updating the files there.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于我们在[第8章](kindle_split_020.html#ch08)中编写的代码。我们建议将那一章的整个目录结构复制到一个新的“chapter_9”目录中，并更新那里的文件。
- en: We’ve finished writing a responsive SPA using a well-tested architecture, but
    some challenges remain that are less about programming and more about operations.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了一个响应式SPA的编写，使用了经过良好测试的架构，但仍然存在一些挑战，这些挑战更多是关于操作而不是编程。
- en: We need to adjust our SPA so that users can use Google and other search engines
    to find what they need. Our web server needs to interact with the *crawler* robots
    that index our content differently because the crawlers don’t execute the JavaScript
    our SPA uses to generate the content. We also want to use analytics tools. On
    a traditional website, analytics data is typically collected through a JavaScript
    snippet added to every HTML page. Because all of the HTML in an SPA is generated
    by JavaScript, we need a different approach.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调整我们的SPA，以便用户可以使用Google和其他搜索引擎找到他们需要的内容。我们的Web服务器需要与索引我们内容的*爬虫*机器人进行交互，因为这些爬虫不会执行我们的SPA用来生成内容的JavaScript。我们还想使用分析工具。在传统的网站上，分析数据通常是通过添加到每个HTML页面的JavaScript片段来收集的。由于SPA中的所有HTML都是由JavaScript生成的，我们需要采取不同的方法。
- en: We also want to want to adjust our SPA to provide detailed logging on traffic,
    user behavior, and errors. Server logging provides much of this insight on traditional
    websites. SPAs move most of the user interaction logic to the client, so a different
    approach is required. We want our SPA to be very responsive. One method to improve
    response time is to use a content delivery network (CDN) to serve static files
    and data. Another method is to use HTTP and server caching.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望调整我们的SPA以提供关于流量、用户行为和错误的详细日志记录。服务器日志为传统网站提供了许多这样的洞察。SPA将大多数用户交互逻辑移动到客户端，因此需要不同的方法。我们希望我们的SPA非常响应。提高响应时间的一种方法是通过使用内容分发网络（CDN）来提供静态文件和数据。另一种方法是使用HTTP和服务器缓存。
- en: Let’s get started by making our SPA content searchable.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使我们的SPA内容可搜索开始。
- en: 9.1\. Optimize our SPA for search engines
  id: totrans-670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. 优化我们的SPA以适应搜索引擎
- en: When Google and other search engines index websites, they don’t execute JavaScript.
    This seems to put SPAs at a tremendous disadvantage compared to a traditional
    website. Not being on Google could easily mean the death of a business, and this
    daunting pitfall could tempt the uninformed to abandon SPAs.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 当谷歌和其他搜索引擎索引网站时，它们不会执行JavaScript。这似乎让SPA与传统的网站相比处于巨大的劣势。不在谷歌上可能意味着一个企业的死亡，这个令人畏惧的陷阱可能会诱使不知情的人放弃SPA。
- en: SPAs actually have an advantage over traditional websites in search engine optimization
    (SEO) because Google and others have recognized the challenge. They have created
    a mechanism for SPAs to not only have their dynamic pages indexed, but also optimize
    their pages specifically for crawlers. This section focuses on the biggest search
    engine, Google, but other large search engines such as Yahoo and Bing support
    the same mechanism.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: SPAs（单页应用程序）实际上在搜索引擎优化（SEO）方面比传统网站有优势，因为谷歌和其他搜索引擎已经认识到了这个挑战。他们已经为SPAs创建了一种机制，不仅可以让它们的动态页面被索引，还可以针对爬虫优化它们的页面。本节重点介绍最大的搜索引擎谷歌，但其他大型搜索引擎如雅虎和必应也支持相同的机制。
- en: 9.1.1\. How Google crawls an SPA
  id: totrans-673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1. 谷歌如何爬取SPA
- en: When Google indexes a traditional website, its web crawler (called a *Googlebot*)
    first scans and indexes the content of the top-level URI (for example, [www.myhome.com](http://www.myhome.com)).
    Once this is complete, it then it follows all of the links on that page and indexes
    those pages as well. It then follows the links on the subsequent pages, and so
    on. Eventually it indexes all the content on the site and associated domains.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 当谷歌索引一个传统网站时，它的网络爬虫（称为*Googlebot*）首先扫描和索引顶级URI（例如，[www.myhome.com](http://www.myhome.com)）的内容。一旦完成，它就会跟随该页面上所有的链接，并索引这些页面。然后它跟随后续页面上的链接，依此类推。最终，它会索引网站上所有相关域的内容。
- en: When the Googlebot tries to index an SPA, all it sees in the HTML is a single
    empty container (usually an empty `div` or `body` tag), so there’s nothing to
    index and no links to crawl, and it indexes the site accordingly (in the round
    circular “folder” on the floor next to its desk).
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 当Googlebot尝试索引一个SPA时，它在HTML中看到的是一个空的容器（通常是一个空的`div`或`body`标签），因此没有可以索引的内容和可以爬取的链接，它相应地索引了该网站（在其桌旁的圆形“文件夹”中）。
- en: If that were the end of the story, it would be the end of SPAs for many web
    applications and sites. Fortunately, Google and other search engines have recognised
    the importance of SPAs and provided tools to allow developers to provide search
    information to the crawler that can be better than traditional websites.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这就是故事的结局，那么许多Web应用程序和网站的SPA时代也就结束了。幸运的是，谷歌和其他搜索引擎已经认识到了SPA的重要性，并提供了工具，允许开发者向爬虫提供比传统网站更好的搜索信息。
- en: The first key to making our SPA crawlable is to realize that our server can
    tell if a request is being made by a crawler or by a person using a web browser
    and respond accordingly. When our visitor is a person using a web browser, respond
    as normal, but for a crawler, return a page optimized to show the crawler exactly
    what we want to in a format the crawler can easily read.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的SPA可爬取的第一个关键是要意识到我们的服务器可以判断一个请求是由爬虫还是由使用网络浏览器的人发起，并相应地做出反应。当我们的访客是使用网络浏览器的人时，正常响应，但对于爬虫，返回一个针对爬虫优化的页面，以显示爬虫可以轻松读取的格式中我们想要展示的内容。
- en: For the home page of our site, what does a crawler-optimized page look like?
    It’s probably our logo or other primary image we’d like appearing in search results,
    some SEO-optimized text explaining what the application does, and a list of HTML
    links to only those pages we want Google to index. What the page doesn’t have
    is any CSS styling or complex HTML structure applied to it. Nor does it have any
    JavaScript, or links to areas of the site we don’t want Google to index (like
    legal disclaimer pages or other pages we don’t want people to enter through a
    Google search). [Figure 9.1](#ch09fig01) shows how a page might be presented to
    a browser and to the crawler.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们网站的首页，一个针对爬虫优化的页面看起来是什么样子？它可能是我们希望在搜索结果中出现的标志或其他主要图像，一些 SEO 优化的文本解释应用程序的功能，以及一个仅指向我们希望
    Google 索引的页面的 HTML 链接列表。页面没有 CSS 样式或应用于它的复杂 HTML 结构。也没有 JavaScript 或链接到我们不希望 Google
    索引的区域（如法律免责声明页面或其他我们不希望人们通过 Google 搜索进入的页面）。[图 9.1](#ch09fig01) 展示了页面可能如何呈现给浏览器和爬虫。
- en: Figure 9.1\. Client and crawler views of a home page
  id: totrans-679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.1\. 主页的客户和爬虫视图
- en: '![](09fig01.jpg)'
  id: totrans-680
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2](09fig01.jpg)'
- en: The links on the page aren’t followed by the crawler the same way a person follows
    links because we apply the special characters `#!` (pronounced *hash bang*) in
    our URI anchor component. For instance, if in our SPA a link to the user page
    looks like `/index.htm#!page=user:id,123`, the crawler would see the `#!` and
    know to look for a web page with the URI `/index.htm?_escaped_fragment_=page=user:id,123`.
    Knowing that the crawler will follow the pattern and look for this URI, we can
    program the server to respond to that request with an HTML snapshot of the page
    that would normally be rendered by JavaScript in the browser. That snapshot will
    be indexed by Google, but anyone clicking on our listing in Google search results
    will be taken to `/index.htm#!page=user:id,123`. The SPA JavaScript will take
    over from there and render the page as expected.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上的链接不会被爬虫以人类跟随链接的方式跟随，因为我们应用了特殊的字符 `#!`（发音为 *hash bang*）在我们的 URI 锚组件中。例如，如果在我们单页应用（SPA）中，用户页面链接看起来像
    `/index.htm#!page=user:id,123`，爬虫会看到 `#!` 并知道要查找具有 URI `/index.htm?_escaped_fragment_=page=user:id,123`
    的网页。知道爬虫会遵循这个模式并查找这个 URI，我们可以编程服务器响应这个请求，返回一个通常由浏览器中的 JavaScript 渲染的网页的 HTML 快照。这个快照将被
    Google 索引，但任何点击我们 Google 搜索结果中列表的人都会被带到 `/index.htm#!page=user:id,123`。SPA JavaScript
    将从那里接管并按预期渲染页面。
- en: This provides SPA developers with the opportunity to tailor their site specifically
    for Google and specifically for users. Instead of having to write text that’s
    both legible and attractive to a person and understandable by a crawler, pages
    can be optimized for each without worrying about the other. The crawler’s path
    through our site can be controlled, allowing us to direct people from Google search
    results to a specific set of entrance pages. This will require more work on the
    part of the engineer to develop, but it can have big pay-offs in terms of search
    result position and customer retention.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 这为单页应用（SPA）开发者提供了针对 Google 和用户特别定制网站的机会。不必编写既对人类可读又吸引人，同时又能被爬虫理解的文本，页面可以针对每个进行优化，而不必担心另一个。我们可以控制爬虫在我们网站上的路径，从而将人们从
    Google 搜索结果引导到一组特定的入口页面。这需要工程师进行更多的工作来开发，但它在搜索结果位置和客户保留方面可以带来巨大的回报。
- en: 'At the time of this writing, the Googlebot announces itself as a crawler to
    the server by making requests with a user-agent string of `Googlebot/2.1 (+[http://www.googlebot.com/bot.html](http://www.googlebot.com/bot.html))`.
    Our Node.js application can check for this user agent string in the middleware
    and send back the crawler-optimized home page if the user agent string matches.
    Otherwise, we can handle the request normally. Alternatively, we could hook it
    into our routing middleware as shown in [listing 9.1](#ch09list01):'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Googlebot 通过带有用户代理字符串 `Googlebot/2.1 (+[http://www.googlebot.com/bot.html](http://www.googlebot.com/bot.html))`
    的请求向服务器宣布自己是一个爬虫。我们的 Node.js 应用程序可以在中间件中检查这个用户代理字符串，如果匹配，则发送回针对爬虫优化的主页。否则，我们可以正常处理请求。或者，我们可以将其钩入我们的路由中间件，如
    [列表 9.1](#ch09list01) 所示：
- en: Listing 9.1\. Detect a Googlebot and serve alternative content in the `routes.js`
    file
  id: totrans-684
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. 在 `routes.js` 文件中检测 Googlebot 并提供替代内容
- en: '![](316fig01_alt.jpg)'
  id: totrans-685
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1](316fig01_alt.jpg)'
- en: 'This arrangment seems like it would be complicated to test, since we don’t
    own a Googlebot. Google offers a service to do this for publicly available production
    websites as part of its Webmaster Tools ([http://support.google.com/webmasters/bin/answer.py?hl=en&answer=158587](http://support.google.com/webmasters/bin/answer.py?hl=en&answer=158587)),
    but an easier way to test is to spoof our user-agent string. This used to require
    some command-line hackery, but Chrome Developer Tools makes this as easy as clicking
    a button and checking a box:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安排看起来测试起来可能很复杂，因为我们没有谷歌爬虫。谷歌提供了一项服务，作为其网站管理工具的一部分，用于测试公开可用的生产网站（[http://support.google.com/webmasters/bin/answer.py?hl=en&answer=158587](http://support.google.com/webmasters/bin/answer.py?hl=en&answer=158587)），但一个更简单的方法是伪造我们的用户代理字符串。这曾经需要一些命令行技巧，但Chrome开发者工具使得这个过程变得非常简单，只需点击一个按钮并勾选一个复选框即可：
- en: Open the Chrome Developer Tools by clicking the button with three horizontal
    lines to the right of the Google Toolbar, and then selecting Tools from the menu
    and clicking on Developer Tools.
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击位于谷歌工具栏右侧带有三个水平线的按钮，然后从菜单中选择工具并点击开发者工具，可以打开Chrome开发者工具。
- en: 'In the lower-right corner of the screen is a gears icon: click on that and
    see some advanced developer options such as disabling cache and turning on logging
    of `XmlHttpRequest`s.'
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 屏幕左下角有一个齿轮图标：点击该图标，可以看到一些高级开发者选项，例如禁用缓存和开启`XmlHttpRequest`s的日志记录。
- en: In the second tab, labelled Overrides, click the check box next to the User
    Agent label and select any number of user agents from the drop-down from Chrome,
    to Firefox, to IE, iPads, and more. The Googlebot agent isn’t a default option.
    In order to use it, select Other and copy and paste the user-agent string into
    the provided input.
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个标签页，标记为“覆盖”的旁边，点击用户代理标签旁边的复选框，并从下拉菜单中选择任何数量的用户代理，从Chrome到Firefox，再到IE、iPad等。谷歌爬虫代理不是默认选项。为了使用它，选择“其他”，并将用户代理字符串复制并粘贴到提供的输入框中。
- en: Now that tab is spoofing itself as a Googlebot, and when we open any URI on
    our site, we should see the crawler page.
  id: totrans-690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在这个标签页正在伪造自己为谷歌爬虫，当我们打开我们网站上的任何URI时，我们应该能看到爬虫页面。
- en: Obviously, different applications will have different needs with regard to what
    to do with web crawlers, but always having one page returned to the Googlebot
    is probably not enough. We’ll also need to decide what pages we want to expose
    and provide ways for our application to map the `_escaped_fragment_=key=value`
    URI to the content we want to show them. Whatever the case, this book should provide
    you with the tools to decide how to best abstract the crawler content for your
    application. You may want to get fancy and tie the server response in to the front
    end framework, but we usually take the simpler approach here and create custom
    pages for the crawler and put them in a separate router file for crawlers.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，不同的应用程序在处理网络爬虫方面会有不同的需求，但始终只返回一个页面给谷歌爬虫可能是不够的。我们还需要决定我们想要公开哪些页面，并为我们的应用程序提供将`_escaped_fragment_=key=value`
    URI映射到我们想要显示的内容的方法。无论情况如何，这本书都应该为你提供决定如何最好地抽象化爬虫内容以适应你应用程序的工具。你可能想要做得更复杂，将服务器响应与前端框架结合起来，但通常我们采取更简单的方法，为爬虫创建自定义页面，并将它们放在一个单独的路由文件中。
- en: There are also a lot more legitimate crawlers out there, so once we’ve adjusted
    our server for the Google crawler we can expand to include them as well.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有许多合法的爬虫，因此一旦我们调整了服务器以适应谷歌爬虫，我们就可以将它们也包括在内。
- en: 9.2\. The cloud and third-party services
  id: totrans-693
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. 云服务和第三方服务
- en: Many companies have services that help build and manage applications, which
    can save a great deal of development and maintenance. If we’re a smaller operation,
    we may want to take advantage of some of these services. Three important services—site
    analytics, client logging, and CDNs—are particularly important for SPA development.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公司提供帮助构建和管理应用程序的服务，这些服务可以大大节省开发和维护成本。如果我们是一家小公司，我们可能想利用其中的一些服务。三个重要的服务——网站分析、客户端日志和CDN——对于SPA开发尤为重要。
- en: 9.2.1\. Site analytics
  id: totrans-695
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1. 网站分析
- en: An important tool in the web developer’s toolbelt is the ability to acquire
    analytics about the site they’re working on. With traditional websites, developers
    have come to depend on tools like Google Analytics and New Relic to provide detailed
    analysis of how people are using the sites and to find any bottlenecks in application
    or business performance (how effectively the site is generating sales). A slightly
    different approach using the same tools will make them every bit as effective
    on an SPA.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 网络开发者工具包中的一个重要工具是获取他们正在工作的网站的分析能力。在传统网站上，开发者已经依赖于像谷歌分析和新 relic 这样的工具来提供关于人们如何使用网站以及找到应用程序或业务性能瓶颈（网站如何有效地产生销售额）的详细分析。使用相同的工具采取略有不同的方法将使它们在
    SPA 上同样有效。
- en: 'Google Analytics provides a simple way to get statistics about how popular
    our SPA and its various states are, as well as how traffic is coming to our site.
    We can use Google Analytics in a traditional website by pasting a snippet of JavaScript
    code onto every HTML page on the site and making a few small modifications to
    categorize pages. We could use this approach with our SPA, but then we’d only
    get analytics on the initial page load. There are two paths we can use to enable
    our SPA to take full advantage of Google Analytics:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌分析提供了一个简单的方法来获取关于我们的 SPA 及其各种状态的流行度统计，以及流量如何进入我们的网站。我们可以在传统网站上使用谷歌分析，通过将一小段
    JavaScript 代码粘贴到网站上每个 HTML 页面上，并对页面进行一些小的修改来分类页面。我们也可以用这种方法来处理我们的 SPA，但那样我们只能得到初始页面加载的统计分析。我们可以使用两条路径来启用我们的
    SPA 充分利用谷歌分析：
- en: Use Google Events to track hashtag changes
  id: totrans-698
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用谷歌事件跟踪标签变化
- en: Use Node.js to record server-side
  id: totrans-699
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Node.js 记录服务器端
- en: We’ll begin by looking at Google Events.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看谷歌事件开始。
- en: Google Events
  id: totrans-701
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 谷歌事件
- en: 'Google has long recognized the need to record and classify events on pages—SPA
    development may be fairly new, but Ajax has been around a long time (in web years,
    a really long time... since 1999!). Tracking events is easy, though it’s more
    manual work then tracking page views. In a traditional website, the snippet of
    JavaScript code makes a call to `_trackPageView` on the `_gaq` object. It allows
    us to pass in custom variables to set information about the page the snippet is
    on. That call sends the information to Google by requesting an image and passing
    along parameters on the end of the request. Those parameters are used by Google’s
    servers to process information about that page view. Using Google Events makes
    a different call on the `_gaq` object: it calls `_trackEvent` and takes some parameters.
    `_trackEvent` then loads an image with some parameters on the end of it that Google
    uses to process the information about that event.'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌长期以来一直认识到记录和分类页面事件的需求——SPA 开发可能相对较新，但 Ajax 技术已经存在很长时间（在网页年代，这真的是很长……自 1999
    年以来！）跟踪事件很容易，尽管它比跟踪页面浏览量需要更多手动工作。在传统网站上，JavaScript 代码片段会调用 `_gaq` 对象上的 `_trackPageView`
    方法。这允许我们传递自定义变量来设置代码片段所在页面的信息。该调用通过请求一个图像并在请求末尾传递参数将信息发送到谷歌。这些参数被谷歌服务器用来处理关于该页面浏览的信息。使用谷歌事件在
    `_gaq` 对象上执行不同的调用：它调用 `_trackEvent` 并传递一些参数。然后 `_trackEvent` 会加载一个带有一些参数的图像，谷歌使用这些参数来处理关于该事件的信
- en: 'The steps to set up and use event tracking are fairly straightforward:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和使用事件跟踪的步骤相当直接：
- en: Set up tracking for our site on the Google Analytics site.
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在谷歌分析网站上设置我们网站的跟踪。
- en: Call the `_trackEvent` method.
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `_trackEvent` 方法。
- en: View the reports.
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看报告。
- en: 'The `_trackEvent` method takes two required parameters and three optional ones:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '`_trackEvent` 方法需要两个必需参数和三个可选参数：'
- en: '[PRE77]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The parameter details are:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 参数细节如下：
- en: '`category` is required and is used to name the group of events this belongs
    to. It will show up in our reporting to categorize events.'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`category` 是必需的，用于命名属于该组的事件。它将在我们的报告中显示，用于分类事件。'
- en: '`action` is required and defines the specific action we’re tracking with each
    event.'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action` 是必需的，用于定义我们通过每个事件跟踪的具体操作。'
- en: '`opt_label` is an optional parameter used to add additional data about the
    event.'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opt_label` 是一个可选参数，用于添加关于事件的额外数据。'
- en: '`opt_value` is an optional parameter used to provide numerical data about the
    event.'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opt_value` 是一个可选参数，用于提供关于事件的数值数据。'
- en: '`opt_noninteraction` is an optional parameter used to tell Google not to use
    this event in bounce rate calculations.'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opt_noninteraction` 是一个可选参数，用于告诉谷歌不要将此事件用于跳出率计算。'
- en: 'For example, if in our SPA we want to track when a user opens a chat window,
    we might make the following `_trackEvent` call:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果在我们SPA中想要跟踪用户打开聊天窗口的时刻，我们可能会进行以下`_trackEvent`调用：
- en: '[PRE78]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This call would then show up in reports letting us know that a chat event occurred,
    the user opened the chat window, and the user did this on the home page. Another
    call might be:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用将出现在报告中，让我们知道发生了聊天事件，用户打开了聊天窗口，并且用户是在主页上完成的。另一个调用可能是：
- en: '[PRE79]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This would record that a chat event occurred, the user sent a message, and did
    it on the game page. Like the traditional website approach, it’s up to the developer
    to decide how to organize and track different events. As a shortcut, instead of
    coding each event into the client-side models, we can insert the `_trackEvent`
    calls into the client-side router (the code that watches the hashtag for changes)
    and then parse those changes into categories, actions, and labels and call the
    `_trackEvent` method using those changes as parameters.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录一个聊天事件发生，用户发送了消息，并且是在游戏页面上完成的。像传统网站的方法一样，如何组织和跟踪不同的事件取决于开发者决定。作为一个捷径，我们可以在不将每个事件编码到客户端模型中的情况下，将`_trackEvent`调用插入到客户端路由器（监视哈希标签变化的代码）中，然后解析这些变化为类别、操作和标签，并使用这些变化作为参数调用`_trackEvent`方法。
- en: Server-Side Google Analytics
  id: totrans-720
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 服务器端Google Analytics
- en: Tracking on the server side is useful if we want to get information about what
    data is being requested from the server, but it can’t be used to track client
    interactions that don’t make requests to the server side, which there’s quite
    a bit of in SPAs. It may seem less useful because it can’t track client-side actions,
    but it’s useful to be able to track requests that are making it past the client
    cache. It can help us track down server requests that are running too slow and
    other behaviors. Though this is still able to provide helpful insights, if we
    have to choose one, we go with the client.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要获取有关从服务器请求的数据的信息，服务器端跟踪是有用的，但它不能用来跟踪不向服务器端发出请求的客户端交互，这在SPA中相当多。它可能看起来不那么有用，因为它不能跟踪客户端操作，但能够跟踪通过客户端缓存的请求是有用的。它可以帮助我们追踪运行过慢的服务器请求和其他行为。尽管这仍然能够提供有价值的见解，但如果我们必须选择一个，我们会选择客户端。
- en: Since JavaScript is used on the server, it seems likely that we could modify
    the Google Analytics code to be used from the server. It’s not only possible,
    but like many things that seem like a good idea, it has probably already been
    implemented by the community. A quick search turns up *node-googleanalytics* and
    *nodealytics* as community-developed projects.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript在服务器上使用，我们似乎可以修改Google Analytics代码以便从服务器端使用。这不仅可能，而且像许多看似好主意的事情一样，社区可能已经实现了它。快速搜索结果显示了*node-googleanalytics*和*nodealytics*作为社区开发的项目。
- en: 9.2.2\. Logging client-side errors
  id: totrans-723
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2. 记录客户端错误
- en: In a traditional website, when there’s an error on the server, it’s written
    to a log file. In an SPA, when a client hits a similar error, there’s nothing
    in place to record it. We’ll have to either manually write code to track errors
    ourselves or look to a third-party service for help. Handling it ourselves gives
    us the flexibility to do whatever we want to with the error, but using a third-party
    service gives us the opportunity to spend our time and resources on something
    else. Besides, they’ve likely implemented far more than we’d have time to. It’s
    also not all or nothing—we can use a third-party service and then if there are
    errors we want tracked or escalated in a way that the service doesn’t provide,
    we can implement the desired capability ourselves.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统网站上，当服务器发生错误时，错误会被写入日志文件。在SPA中，当客户端遇到类似错误时，没有现成的记录机制。我们不得不手动编写代码来跟踪错误，或者寻求第三方服务的帮助。自行处理提供了灵活性，可以做我们想要做的任何关于错误的事情，但使用第三方服务则给我们提供了将时间和资源用于其他事情的机会。此外，他们可能已经实现了比我们能够实现得多的功能。而且，这并不是全有或全无——我们可以在使用第三方服务的同时，如果需要跟踪或升级服务不提供的方式的错误，我们可以自行实现所需的功能。
- en: Third-Party Client Logging
  id: totrans-725
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第三方客户端日志
- en: 'There are several third-party services that collect and aggregate errors and
    metrics data generated by our application:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个第三方服务收集和汇总我们应用程序生成的错误和指标数据：
- en: '*Airbrake* specializes in Ruby on Rails applications, but has experimental
    JavaScript support.'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Airbrake*专注于Ruby on Rails应用程序，但提供了实验性的JavaScript支持。'
- en: '*Bugsense* specializes in mobile application solutions. Their product works
    with JavaScript SPAs and native mobile applications. If we have a mobile-focused
    application, they may be a good choice.'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Bugsense*专注于移动应用程序解决方案。他们的产品与JavaScript SPAs和原生移动应用程序兼容。如果我们有一个以移动为重点的应用程序，他们可能是一个不错的选择。'
- en: '*Errorception* is dedicated to logging JavaScript errors and is therefore a
    good choice for an SPA client. They’re not as established as Airbrake or Bugsense
    but we like their moxy. *Errorception* keeps a developer blog ([http://blog.errorception.com/](http://blog.errorception.com/)),
    where we can gain insight on JavaScript error logging.'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Errorception*专注于记录JavaScript错误，因此是SPA客户端的一个好选择。它们不如Airbrake或Bugsense那样成熟，但我们喜欢它们的活力。*Errorception*维护一个开发者博客([http://blog.errorception.com/](http://blog.errorception.com/))，在那里我们可以获得JavaScript错误记录的见解。'
- en: '*New Relic* is fast becoming an industry standard for web application performance
    monitoring. Its performance monitoring includes error logging and performance
    metrics for each step of the request/response cycle, from how long the query took
    in the database to how long the browser took to render the CSS styles. The service
    provides an impressive amount of insight into performance on both the client and
    the server.'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*New Relic*正迅速成为网络应用程序性能监控的行业标准。其性能监控包括请求/响应周期中每个步骤的错误日志和性能指标，从数据库查询耗时到浏览器渲染CSS样式耗时。该服务为客户端和服务器上的性能提供了令人印象深刻的洞察力。'
- en: At the time of writing, we tend to prefer New Relic or Errorception. Whereas
    New Relic provides more data, we’ve found Errorception superior when dealing with
    JavaScript errors, as well as easy to set up.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，我们倾向于更喜欢New Relic或Errorception。虽然New Relic提供了更多数据，但我们发现Errorception在处理JavaScript错误时更胜一筹，并且易于设置。
- en: Logging Client-Side Errors Manually
  id: totrans-732
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 手动记录客户端错误
- en: 'When it comes down to it, all these services use one of these two methods to
    send JavaScript errors:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 当具体到这些服务时，它们都使用这两种方法之一来发送JavaScript错误：
- en: Catching errors with the `window.onerror` event handler.
  id: totrans-734
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`window.onerror`事件处理器捕获错误。
- en: Surrounding code with a `try/catch` block and sending back what it catches.
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码包裹在`try/catch`块中，并发送它捕获的内容。
- en: The `window.onerror` event is the basis of most of the third-party applications.
    `onerror` fires for runtime errors, but not for compilation errors. `onerror`
    is somewhat controversial because of uneven browser support and potential security
    holes, but it’s a major weapon in our arsenal for logging client-side JavaScript
    errors.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.onerror`事件是大多数第三方应用的基础。`onerror`会在运行时错误发生时触发，但不会在编译错误时触发。由于浏览器支持的差异和潜在的安全漏洞，`onerror`有些争议，但它是我们日志记录客户端JavaScript错误的重大武器。'
- en: '![](320fig01.jpg)'
  id: totrans-737
  prefs: []
  type: TYPE_IMG
  zh: '![图片](320fig01.jpg)'
- en: The `try/catch` method requires wrapping a `try/catch` block around the main
    call in our SPA. This will catch any synchronous errors generated by our application;
    unfortunately it’ll also prevent them from bubbling up to `window.onerror` or
    being displayed in the error console. It won’t catch any errors in asynchronous
    calls like those made in event handlers or in `setTimeout` or `setInterval` functions.
    That means having to wrap all of the code in our asynchronous function with a
    `try/catch` block.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '`try/catch`方法需要在我们的SPA中的主要调用周围包裹`try/catch`块。这将捕获我们应用程序生成的任何同步错误；不幸的是，它也会阻止它们冒泡到`window.onerror`或显示在错误控制台中。它不会捕获异步调用中的任何错误，如事件处理器中或`setTimeout`或`setInterval`函数中做出的调用。这意味着必须将所有代码包裹在我们的异步函数中的`try/catch`块中。'
- en: '[PRE80]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Having to do that for all of our asynchronous calls would get tedious, and prevent
    reporting of the errors to the console. Wrapping code in a `try/catch` block also
    prevents the code in that block from being compiled in advance, causing it to
    run slower. A good compromise approach for an SPA is to wrap our `init` call in
    a `try/catch` block, log the error to the console inside the catch, and send it
    off via Ajax, then use `window.onerror` to catch all of our asynchronous errors
    and send them off via Ajax. No need to log the asynchronous errors to the console
    manually because they’ll still appear there on their own.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们所有的异步调用都必须这样做会变得乏味，并阻止错误报告到控制台。将代码包裹在`try/catch`块中也会阻止该块中的代码预先编译，导致其运行速度变慢。对于SPA的一个良好折衷方法是，将我们的`init`调用包裹在`try/catch`块中，在`catch`内部将错误记录到控制台，并通过Ajax发送，然后使用`window.onerror`来捕获所有我们的异步错误并通过Ajax发送。无需手动将异步错误记录到控制台，因为它们仍然会自动出现在那里。
- en: '[PRE81]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Now that we understand which errors are happening on the client, we can focus
    on how to deliver content to site visitors more quickly.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了客户端发生的错误，我们可以专注于如何更快地向网站访客提供内容。
- en: 9.2.3\. Content delivery networks
  id: totrans-743
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.3. 内容分发网络
- en: A *content delivery network (CDN)* is a network set up to deliver static files
    as quickly as possible. It could be as simple as a single Apache server sitting
    next to our application server, or a worldwide infrastructure with dozens of data
    centers. In any case, it makes sense to have a separate server set up to deliver
    our static files, so as to not burden our application server with that task. Node.js
    is particularly ill-suited to delivering large static content files (images, CSS,
    JavaScript), because this usage can’t take advantage of the asynchronous nature
    of Node.js. Apache, with its pre-fork, is much better suited.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '*内容分发网络（CDN）*是一个建立起来以尽可能快地交付静态文件的网络。它可能只是一个位于我们应用程序服务器旁边的单个Apache服务器，或者是一个拥有数十个数据中心的全局基础设施。无论如何，设置一个单独的服务器来交付我们的静态文件是有意义的，这样就不会给我们的应用程序服务器带来负担。Node.js特别不适合交付大型静态内容文件（图像、CSS、JavaScript），因为这种使用无法利用Node.js的异步特性。具有预分叉的Apache则更适合。'
- en: 'Because we’re well-versed in Apache, we *could* throw together our own “one-server
    CDN” until we get ready to scale the site; otherwise there are many third-party
    CDNs we can use. Three big ones are Amazon, Akamai, and Edgecast. Amazon has the
    Cloudfront product, and Akamai and Edgecast resell through other companies like
    Rackspace, Distribution Cloud, and others. In fact, there are so many CDN companies
    out there that there’s a website dedicated to selecting the right provider: [www.cdnplanet.com](http://www.cdnplanet.com).'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们精通Apache，我们**可以**自己搭建一个“单服务器CDN”，直到我们准备好扩展网站；否则，我们还可以使用许多第三方CDN。其中三个大的是亚马逊、Akamai和Edgecast。亚马逊有Cloudfront产品，而Akamai和Edgecast则通过其他公司如Rackspace、Distribution
    Cloud等进行转售。实际上，市场上有很多CDN公司，甚至有一个网站专门用于选择合适的提供商：[www.cdnplanet.com](http://www.cdnplanet.com)。
- en: Another benefit of using a globally distributed CDN is that our content is served
    from the closest server, making the time it takes to serve up those files much
    shorter. When we consider the performance benefits, using a CDN is often an easy
    choice.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全球分布式的CDN的另一个好处是，我们的内容是从最近的服务器提供的，这使得提供这些文件所需的时间大大缩短。当我们考虑性能优势时，使用CDN通常是一个容易做出的选择。
- en: 9.3\. Caching and cache busting
  id: totrans-747
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3. 缓存和缓存失效
- en: 'Caching is incredibly important to making our application run fast. There’s
    no faster form of data retrieval than client-side caching, and server caching
    is often far superior to having to request and calculate the same information
    over again. There are many places in our SPA that have the potential to cache
    data and thus speed up that part of our application. We’ll go through them all:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存对于使我们的应用程序运行快速至关重要。没有比客户端缓存更快的检索数据方式，而服务器缓存通常比再次请求和计算相同信息要好得多。在我们的SPA中有许多地方有缓存数据的潜力，从而加快应用程序的这一部分。我们将逐一介绍：
- en: Web storage
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web存储
- en: HTTP caching
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP缓存
- en: Server caching
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器缓存
- en: Database caching
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库缓存
- en: It’s crucial to think about data freshness when caching. We don’t want to be
    serving stale data to our applications users, but at the same time we want to
    be responding to requests as quickly as possible.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓存时考虑数据新鲜度至关重要。我们不希望向应用程序用户提供过时的数据，但与此同时，我们希望尽可能快速地响应用户请求。
- en: 9.3.1\. Caching opportunities
  id: totrans-754
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1. 缓存机会
- en: Each of these caches has different responsibilities and interacts with the client
    to speed up the application in different ways.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些缓存都有不同的职责，并以不同的方式与客户端交互，以加快应用程序。
- en: '*Web storage* stores strings in the client and is accessible to the application.
    Use these to store finished HTML from data already retrieved from the server and
    processed.'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Web存储*在客户端存储字符串，并且对应用程序是可访问的。使用这些存储从服务器检索并处理的数据的完成HTML。'
- en: '*HTTP caching* is client-side caching that stores responses from the server.
    There’s a lot of detail to learn in order to properly control this style of caching,
    but after learning and implementing it, we’ll get a lot of caching almost for
    free.'
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HTTP缓存*是客户端缓存，它存储来自服务器的响应。为了正确控制这种缓存方式，需要学习很多细节，但一旦学习和实施，我们几乎可以免费获得大量的缓存。'
- en: '*Server caching* with Memcached and Redis are often used to cache processed
    server responses. This is the first form of caching that can store data for different
    users so that if one user requests some information, it’s already cached the next
    time someone else requests it, saving a trip to the database.'
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务器缓存*使用Memcached和Redis，通常用于缓存处理过的服务器响应。这是第一种可以存储不同用户数据的缓存形式，这样如果某个用户请求某些信息，下次其他人请求时，它已经缓存了这些信息，从而节省了数据库的访问。'
- en: '*Database caching*, or query caching, is used by databases to cache the results
    of a query so that if it’s turned on, subsequent identical queries return the
    cache instead of gathering the data again.'
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据库缓存*或查询缓存，是数据库用来缓存查询结果，以便如果开启，后续相同的查询将返回缓存而不是再次收集数据。'
- en: '[Figure 9.2](#ch09fig02) shows a typical request/response cycle with all of
    the caching opportunities. We can see how each level of caching can speed up the
    response by shortcutting the cycle at various stages. HTTP caching and database
    caching are the simplest to implement, usually only requiring the setting of some
    configurations, whereas web storage and server caching are more involved, requiring
    more effort on the part of the developer.'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.2](#ch09fig02)显示了具有所有缓存机会的典型请求/响应周期。我们可以看到每个缓存级别如何通过在各个阶段缩短周期来加速响应。HTTP缓存和数据库缓存实现起来最简单，通常只需要设置一些配置，而Web存储和服务器缓存则更复杂，需要开发者付出更多努力。'
- en: Figure 9.2\. Shortcutting the request/response cycle with caching
  id: totrans-761
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2\. 使用缓存缩短请求/响应周期
- en: '![](09fig02_alt.jpg)'
  id: totrans-762
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig02_alt.jpg)'
- en: 9.3.2\. Web storage
  id: totrans-763
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. Web存储
- en: 'Web storage, also known as *DOM storage*, comes in two types: local and session
    storage. They’re supported by all modern browsers, including IE8+. They’re simple
    key/value stores where both the key and the value must be a string. Session storage
    only stores the data for the current tab session—closing the tab will close the
    session and clear the data. Local storage will keep the storage cached with no
    expiration date. In either case, the data is only available to the web page that
    stored it. For the SPA, this means that the entire site has access to the storage.
    One excellent way to use web storage is to store processed HTML strings, enabling
    a request to bypass the entire request/response cycle and proceed directly to
    displaying the result. [Figure 9.3](#ch09fig03) shows the details.'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: Web存储，也称为*DOM存储*，分为两种类型：本地存储和会话存储。它们被所有现代浏览器支持，包括IE8+。它们是简单的键/值存储，其中键和值都必须是字符串。会话存储只存储当前标签页会话中的数据——关闭标签页将关闭会话并清除数据。本地存储将存储缓存，没有过期日期。在任何情况下，数据只对存储它的网页可用。对于SPA来说，这意味着整个网站都可以访问存储。使用Web存储的一个极好方法是存储处理过的HTML字符串，这样就可以绕过整个请求/响应周期，直接显示结果。[图9.3](#ch09fig03)显示了详细信息。
- en: Figure 9.3\. Web storage
  id: totrans-765
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3\. Web存储
- en: '![](09fig03_alt.jpg)'
  id: totrans-766
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig03_alt.jpg)'
- en: We use local storage to store non-sensitive information that we want to persist
    beyond the current browser session. We use session storage to store data that
    won’t persist beyond the current session.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用本地存储来存储我们希望在当前浏览器会话之外持久化的非敏感信息。我们使用会话存储来存储不会在当前会话中持久化的数据。
- en: Since web storage can only save string values, typically JSON or HTML is saved.
    Saving JSON is redundant with using an HTTP cache in an SPA, which we’ll discuss
    in the next section, and still requires some processing to be used. Often it’s
    better practice to store an HTML string so we can save the client the processing
    required to create it in the first place. This kind of storage can be abstracted
    into a JavaScript object, which handles the particulars for us.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Web存储只能保存字符串值，通常保存JSON或HTML。在SPA中使用HTTP缓存保存JSON是多余的，我们将在下一节讨论，并且仍然需要一些处理才能使用。通常，存储HTML字符串更好，这样我们就可以节省客户端创建它的处理工作。这种存储可以抽象为一个JavaScript对象，它为我们处理细节。
- en: 'Session storage only stores data for the current session, so we can sometimes
    get away with not thinking too much about the stale data problem—but not always.
    When we do need to worry about stale data, one method used to force a data refresh
    is to encode the time into the cache key. If we want data to expire every day,
    we can include the day’s date in the key. If we want the data to expire every
    hour, we can encode the hour in there as well. This won’t handle every scenario,
    but is probably the simplest in terms of execution, as shown in [listing 9.2](#ch09list02):'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 会话存储只存储当前会话的数据，因此我们有时可以不必过多考虑过时数据的问题——但并非总是如此。当我们确实需要担心过时数据时，一种强制数据刷新的方法是将时间编码到缓存键中。如果我们希望数据每天过期，我们可以在键中包含当天的日期。如果我们希望数据每小时过期，我们也可以将小时编码到其中。这不会处理每个场景，但在执行方面可能是最简单的，如[列表9.2](#ch09list02)所示：
- en: Listing 9.2\. Encoding the time in the cache key
  id: totrans-770
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.2. 在缓存键中编码时间
- en: '![](324fig01_alt.jpg)'
  id: totrans-771
  prefs: []
  type: TYPE_IMG
  zh: '![图片](324fig01_alt.jpg)'
- en: 9.3.3\. HTTP caching
  id: totrans-772
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.3. HTTP缓存
- en: HTTP caching occurs when the browser caches data sent to it from the server,
    according to some attributes the server set in the header or according to an industry
    standard set of default caching guidelines. Though it can be slower than web storage
    because the results still need to be processed, it’s often much simpler and still
    faster than server-side caching. [Figure 9.4](#ch09fig04) shows where HTTP caching
    sits in the request/ response cycle.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP缓存发生在浏览器根据服务器在头部设置的某些属性或根据行业标准的默认缓存指南缓存从服务器发送的数据时。尽管它可能比Web存储慢，因为结果仍然需要处理，但它通常更简单，并且仍然比服务器端缓存快。[图9.4](#ch09fig04)显示了HTTP缓存在请求/响应周期中的位置。
- en: Figure 9.4\. HTTP caching
  id: totrans-774
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4. HTTP缓存
- en: '![](09fig04_alt.jpg)'
  id: totrans-775
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig04_alt.jpg)'
- en: 'HTTP caching is used to store server responses in the client, to keep from
    doing another round trip. There are two patterns that it can follow:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP缓存用于在客户端存储服务器响应，以避免再次进行往返。它可以遵循两种模式：
- en: Serve directly from cache without checking the server for freshness.
  id: totrans-777
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接从缓存中提供服务，不检查服务器的新鲜度。
- en: Check the server for freshness and serve from cache if fresh, and from server
    response if stale.
  id: totrans-778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查服务器的新鲜度，如果新鲜则从缓存中提供服务，如果过时则从服务器响应中提供服务。
- en: Serving directly from cache without checking for freshness of data is the quickest,
    because we forgo a round trip to the server. This is safer to do for images, CSS,
    and JavaScript files, but we can also set our application up so that it’ll cache
    data for a length of time as well. For example, if we have an application that
    only updates some kinds of data once a day at midnight, then we could direct clients
    to cache data until just after midnight.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从缓存中提供服务而不检查数据的新鲜度是最快的，因为我们避免了往返服务器的过程。对于图像、CSS和JavaScript文件来说，这样做更安全，但我们也可以设置我们的应用程序，使其能够缓存数据一段时间。例如，如果我们有一个每天午夜只更新某些类型数据的应用程序，那么我们可以指示客户端缓存数据直到午夜过后。
- en: Sometimes that doesn’t provide up-to-date enough information. In those cases
    the browser can be instructed to check back with the server to see if the data
    is still fresh.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这并不提供足够最新的信息。在这种情况下，浏览器可以被指示再次与服务器联系，以查看数据是否仍然新鲜。
- en: 'Let’s get down to the nitty-gritty and see how this caching works. HTTP caching
    works by having the client look at the headers of the response sent from the server.
    There are three primary attributes that the client looks for: `max-age`, `no-cache`,
    and `last-modified`. Each of these contributes toward telling the client how long
    to cache the data.'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨，看看这种缓存是如何工作的。HTTP缓存通过让客户端查看从服务器发送的响应头来实现。客户端寻找三个主要属性：`max-age`、`no-cache`和`last-modified`。每个属性都向客户端传达了数据缓存多长时间。
- en: Max-Age
  id: totrans-782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Max-Age
- en: In order for the client to use data from its cache without attempting to contact
    the server, the header of the initial response must have the `max-age` set in
    the `Cache-Control` header. This value tells the client how long to cache the
    data before making another request. The `max-age` value is in seconds. This is
    both a powerful capability and a potentially dangerous one. It’s powerful because
    it’s the quickest possible way to access data; apps running with data cached in
    this way will be very fast once the data has been loaded. It’s dangerous because
    the client no longer checks with the server for changes, so we’ll have to be deliberate
    with them.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让客户端能够使用其缓存中的数据而不需要尝试联系服务器，初始响应的头部必须在 `Cache-Control` 头部中设置 `max-age`。这个值告诉客户端在再次请求之前应该缓存数据多长时间。`max-age`
    的值以秒为单位。这既是一个强大的功能，也是一个潜在的危险功能。它之所以强大，是因为这是访问数据的最快方式；一旦数据被加载，使用这种方式缓存数据的程序将会非常快。它之所以危险，是因为客户端不再检查服务器是否有变化，因此我们必须对此格外小心。
- en: When using Express, we can set the `Cache-Control` header with the `max-age`
    attribute.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Express 时，我们可以使用 `max-age` 属性设置 `Cache-Control` 头部。
- en: '[PRE82]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Once the cache is set in this way, the only way to bust the cache and force
    the client to make a new request is to change the name of the file.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦以这种方式设置缓存，唯一打破缓存并强制客户端发出新请求的方法是更改文件名。
- en: Obviously, changing the names of files every time we push to production isn’t
    desirable. Fortunately, changing parameters passed in to the file will bust the
    cache. This is typically done by appending a version number or some integer that
    our build system increments with every deployment. There are many ways to accomplish
    this, but the one we prefer is to have a separate file that has our incrementing
    value in it and append that number onto the end of our filename. Because the index
    page is static, we can set up our deployment tool to generate the finished HTML
    file and include the version number on the end of our includes. Let’s take a look
    at [listing 9.3](#ch09list03) for an example of what the cache buster would look
    like in the finished HTML.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，每次将文件推送到生产环境时都更改文件名是不理想的。幸运的是，更改传递给文件的参数将打破缓存。这通常是通过附加一个版本号或一些整数来完成的，我们的构建系统会随着每次部署递增这个整数。有许多实现这种方法的方式，但我们更喜欢有一个单独的文件，其中包含我们的递增值，并将该数字附加到文件名末尾。因为索引页面是静态的，我们可以设置我们的部署工具生成最终的
    HTML 文件，并在我们的包含文件末尾包含版本号。让我们看看 [列表 9.3](#ch09list03) 的例子，看看缓存破坏者在最终的 HTML 中会是什么样子。
- en: Listing 9.3\. Bust the `max-age` cache
  id: totrans-788
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. 打破 `max-age` 缓存
- en: '![](326fig01_alt.jpg)'
  id: totrans-789
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](326fig01_alt.jpg)'
- en: Another use of `max-age` is to set it to 0, which tells the client that the
    content should always be revalidated. When this is set, the client will always
    check with the server to make sure that the content is still valid, but the server
    is still free to reply with a 302 response, informing the client that the data
    isn’t stale and should be served from cache. A side effect of setting `max-age=0`
    is that intermediate servers—those servers sitting between the client and the
    end server—can still respond with a stale cache as long as they also set a warning
    flag on the response.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '`max-age` 的另一个用途是将它设置为 0，这告诉客户端内容应该始终重新验证。当设置为这种情况时，客户端将始终检查服务器以确保内容仍然有效，但服务器仍然可以回复一个
    302 响应，通知客户端数据不是过时的，应该从缓存中提供。设置 `max-age=0` 的副作用是，中间服务器——那些位于客户端和最终服务器之间的服务器——只要它们也在响应中设置了一个警告标志，仍然可以响应一个过时的缓存。'
- en: Now, if we wish to prevent the intermediate servers from ever using its cache,
    then we’ll want to look into the `no-cache` attribute.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们希望防止中间服务器永远使用其缓存，那么我们就需要查看 `no-cache` 属性。
- en: No-Cache
  id: totrans-792
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无缓存
- en: The `no-cache` attribute, according to the spec, works in a manner similar enough
    to setting `max-age=0` to be confusing. It tells the client to revalidate with
    the server before using the data in cache, but it also tells intermediate servers
    that they can’t serve up stale content, even with a warning message. An interesting
    situation has come up in the last few years, because IE and Firefox have started
    to interpret this setting to mean they shouldn’t cache this data under any circumstances.
    That means the client won’t even ask the server if the data it last received is
    fresh before reserving it; the client won’t ever store the data in its cache.
    That can make resources loaded with the `no-cache` header to be unnecessarily
    slow. If the desired behavior is to prevent clients from caching the resource,
    then the `no-store` attribute should be used instead.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规范，`no-cache`属性的工作方式与设置`max-age=0`非常相似，以至于容易造成混淆。它告诉客户端在使用缓存中的数据之前，需要先与服务器进行重新验证，但它也告诉中间服务器，即使有警告信息，它们也不能提供过时的内容。在过去的几年中，出现了一个有趣的情况，因为IE和Firefox开始将此设置解释为在任何情况下都不应该缓存此数据。这意味着客户端在保留数据之前甚至不会询问服务器它最后接收的数据是否新鲜；客户端永远不会将其缓存中的数据存储。这可能导致带有`no-cache`头部的资源加载变得不必要地缓慢。如果期望的行为是防止客户端缓存资源，那么应该使用`no-store`属性。
- en: No-Store
  id: totrans-794
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: No-Store
- en: The `no-store` attribute informs clients and intermediate servers to never store
    any information about this request/response in their cache. Though this helps
    improve the privacy of such transmissions, it’s by no means a perfect form of
    security. In properly implemented systems, any trace of the data will be gone;
    there’s a chance that the data could pass through improperly or maliciously coded
    systems and is vulnerable to eavesdropping.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '`no-store`属性通知客户端和中间服务器，永远不要在它们的缓存中存储有关此请求/响应的任何信息。尽管这有助于提高此类传输的隐私性，但它绝不是一种完美的安全形式。在正确实现的系统中，任何数据痕迹都将消失；有可能数据会通过不当或恶意编码的系统，从而容易受到窃听。'
- en: Last-Modified
  id: totrans-796
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Last-Modified
- en: If no `Cache-Control` is set, then the client depends on an algorithm based
    on the `last-modified` date to determine how long to cache the data. Typically
    this is one-third of the time since the `last-modified` date. So, if an image
    file was last modified three days ago, when it’s requested, the client will default
    to serving it from cache for one day before checking with the server again. This
    results in a largely random amount of time a resource will be served from cache,
    dependent on how long it has been since the file was last pushed to production.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有设置`Cache-Control`，则客户端将依赖于基于`last-modified`日期的算法来确定缓存数据的时间长度。通常这相当于自`last-modified`日期以来的三分之一时间。因此，如果图像文件是三天前最后修改的，当它被请求时，客户端将默认从缓存中提供它一天，然后再与服务器再次检查。这导致资源从缓存中提供的时间量在很大程度上是随机的，取决于文件上次推送到生产环境的时间长度。
- en: There are many other attributes dealing with caches, but mastering these basic
    attributes will significantly speed up application load time. HTTP caching enables
    clients of our application to serve up resources it has seen before without needing
    to request the information again, or with a minimum of overhead in asking the
    server if the resource is still fresh. This speeds up our application on subsequent
    requests, but what about identical requests made by other clients? HTTP caching
    doesn’t help there; instead the data will need to be cached on the server.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他与缓存相关的属性，但掌握这些基本属性将显著加快应用程序的加载时间。HTTP缓存允许我们的应用程序的客户在无需再次请求信息或以最小的开销询问服务器资源是否仍然新鲜的情况下，提供之前看到的资源。这加快了后续请求中的应用程序，但对于其他客户端发出的相同请求呢？HTTP缓存对此没有帮助；相反，数据需要在服务器上进行缓存。
- en: 9.3.4\. Server caching
  id: totrans-799
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.4\. 服务器缓存
- en: The fastest way for a server to respond to a client-side request with dynamic
    data is to serve it from a cache. This removes the processing time it takes to
    query the database and marshal the query response into a JSON string. [Figure
    9.5](#ch09fig05) shows where server caching fits into the request/response cycle.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应客户端动态数据请求最快的方式是从缓存中提供服务。这样做可以减少查询数据库并将查询响应序列化为JSON字符串所需的时间。[图9.5](#ch09fig05)展示了服务器缓存在请求/响应周期中的位置。
- en: Figure 9.5\. Server caching
  id: totrans-801
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5\. 服务器缓存
- en: '![](09fig05_alt.jpg)'
  id: totrans-802
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig05_alt.jpg)'
- en: Two popular methods of caching data on the server are Memcached and Redis. According
    to [memcached.org](http://memcached.org), “Memcached is an in-memory key-value
    store for small chunks of arbitrary data.” It’s purpose-built as a temporary cache
    of data retrieved from a database, API call, or processed HTML. When the server
    runs out of memory, it’ll automatically start dropping data based on a least recently
    used (LRU) algorithm. Redis is an *advanced key-value store* and can be used to
    store more complex data structures, such as strings, hashes, lists, sets, and
    sorted sets.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上缓存数据的两种流行方法是Memcached和Redis。根据[memcached.org](http://memcached.org)，“Memcached是一个用于小块任意数据的内存键值存储。”它专门设计为从数据库、API调用或处理HTML中检索数据的临时缓存。当服务器内存不足时，它将自动根据最近最少使用（LRU）算法开始丢弃数据。Redis是一个*高级键值存储*，可以用于存储更复杂的数据结构，如字符串、散列、列表、集合和有序集合。
- en: The overall idea for the cache is to reduce server load and speed response time.
    When a request for data is received, the application first checks whether the
    response for this query has been stored in cache. If the application finds the
    data, it serves it to the client. If the data isn’t cached, it instead makes a
    comparatively expensive database query and transforms the data into JSON. It then
    stores the data in the cache and replies to the client with the results.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的整体思路是减少服务器负载并加快响应时间。当接收到数据请求时，应用程序首先检查该查询的响应是否已存储在缓存中。如果应用程序找到数据，它就会将其提供给客户端。如果没有缓存数据，它就会进行相对昂贵的数据库查询，并将数据转换为JSON。然后，它在缓存中存储数据，并使用结果回复客户端。
- en: 'When we use a cache, we must consider when the cache needs to be “busted.”
    If only our application writes to the cache, then it can either clear or regenerate
    the cache when the data changes. If other applications also write to the cache,
    then we need them to update the cache as well. There are a few methods to work
    around this:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用缓存时，必须考虑何时需要“清除”缓存。如果只有我们的应用程序向缓存写入数据，那么当数据发生变化时，它可以清除或重新生成缓存。如果有其他应用程序也向缓存写入数据，那么我们需要它们也更新缓存。有几种方法可以解决这个问题：
- en: We can invalidate caches after a set length of time and force a refresh of the
    data. If we do this once an hour then there will be up to 24 times throughout
    the day with a cache-free response. Obviously, this won’t work for all applications.
  id: totrans-806
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在一定时间后使缓存失效并强制刷新数据。如果我们每小时这样做一次，那么一天中将有高达24次没有缓存的响应。显然，这并不适用于所有应用程序。
- en: We can check the last updated time of the data, and if it’s the same or earlier
    than the cache timestamp. This will take longer to process than the first option,
    but it may not take as long as a complex request takes, and we’ll be assured that
    the data is fresh.
  id: totrans-807
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查数据的最后更新时间，如果它与缓存的最后更新时间相同或更早。这比第一个选项处理时间更长，但它可能不会像复杂请求那样耗时，并且我们可以确保数据是新鲜的。
- en: Which option we choose is dependent on the needs of our application.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择哪种选项取决于我们应用程序的需求。
- en: Server caching is overkill for our SPA. MongoDB offers excellent performance
    for our sample data set. And we don’t process the MongoDB response—we just pass
    it along to the client.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器缓存对于我们的SPA来说过于冗余。MongoDB为我们示例数据集提供了出色的性能。我们并不处理MongoDB的响应——我们只是将其传递给客户端。
- en: So when should we consider adding server caching to our web application? When
    we find our database or web server is becoming a bottleneck. Usually it’ll reduce
    the load on both the server and the database, and improve response time. It’s
    certainly worth trying before purchasing an expensive new server. But remember
    that server caching requires another service (like Memcached or Redis) that will
    need to be monitored and maintained, and it also adds complexity to our application.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该在何时考虑将服务器缓存添加到我们的Web应用程序中？当我们发现我们的数据库或Web服务器成为瓶颈时。通常，它将减少服务器和数据库的负载，并提高响应时间。在购买昂贵的全新服务器之前尝试它肯定值得。但请记住，服务器缓存需要另一个服务（如Memcached或Redis）来监控和维护，并且它也增加了我们应用程序的复杂性。
- en: Node.js has drivers for both Memcached and Redis. Let’s add Redis to our application
    and use it to cache data about our users. We can visit [http://redis.io](http://redis.io)
    and follow the instructions to install Redis on our system. Once installed and
    running, we can confirm it’s available by starting the Redis shell with the command
    `redis-cli`.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js为Memcached和Redis都提供了驱动程序。让我们将Redis添加到我们的应用程序中，并使用它来缓存有关我们用户的数据。我们可以访问[http://redis.io](http://redis.io)并遵循说明在我们的系统上安装Redis。一旦安装并运行，我们可以通过使用命令`redis-cli`启动Redis外壳来确认它可用。
- en: 'Let’s update the `npm` manifest to install the Redis driver as shown in [listing
    9.4](#ch09list04). Changes are shown in **bold**:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `npm` 清单以安装 Redis 驱动程序，如 [列表 9.4](#ch09list04) 所示。变更以粗体显示：
- en: Listing 9.4\. Update the npm manifest to include redis—`webapp/package.json`
  id: totrans-813
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.4\. 更新 npm 清单以包含 redis—`webapp/package.json`
- en: '[PRE83]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Before we get started, let’s think about what we’ll need to be able to do with
    a cache. Two things that come to mind are *setting* a cache key-value pair and
    *getting* the cache value by key. We also will probably want to be able to *delete*
    a cache key. With that, let’s set up the node module by creating a cache.js file
    in the lib directory and filling it in with the node module pattern and methods
    to get, set, and delete from the cache. See [listing 9.5](#ch09list05) for how
    to connect Node.js to Redis and set up the skeleton of the cache file.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们考虑一下我们需要能够用缓存做什么。两个想到的事情是 *设置* 缓存键值对和 *通过键获取* 缓存值。我们还可能希望能够 *删除*
    缓存键。有了这些，让我们通过在 lib 目录中创建一个 cache.js 文件并填充它以 node 模块模式和获取、设置和从缓存中删除的方法来设置节点模块。参见
    [列表 9.5](#ch09list05) 了解如何将 Node.js 连接到 Redis 并设置缓存文件的框架。
- en: Listing 9.5\. Start the redis cache—`webapp/cache.js`
  id: totrans-816
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. 启动 redis 缓存—`webapp/cache.js`
- en: '[PRE84]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now, let’s start filling in these methods; the finished methods are in [listing
    9.6](#ch09list06). We’ll start with `setValue` because that one is the simplest.
    Redis has a lot of different data types that, depending on the type of data we’re
    caching, could be useful. For this example, we’ll stick with the basic string
    key-value pair. Using the Redis driver to set a value is as simple as calling
    `redis.set( key, value );`. There’s no callback, because we’re going to assume
    this method works and let the call work asynchronously and discard failures. We
    could do something fancier and increment a value in Redis to keep track of failures
    if we wanted to. We encourage interested readers to explore this approach.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始填充这些方法；完成的方法在 [列表 9.6](#ch09list06) 中。我们将从 `setValue` 开始，因为它是最简单的。Redis
    有很多不同的数据类型，根据我们缓存的数据类型，这些类型可能很有用。在这个例子中，我们将坚持使用基本的字符串键值对。使用 Redis 驱动程序设置值就像调用
    `redis.set( key, value );` 一样简单。因为没有回调，我们将假设这个方法有效，并让调用异步执行并忽略失败。如果我们想的话，我们可以做些更复杂的事情，比如在
    Redis 中增加一个值来跟踪失败。我们鼓励感兴趣的读者探索这种方法。
- en: 'The `getValue` method takes three arguments: the `key` to search for, a callback
    for a cache hit (`hit_callback`), and a callback for a cache miss (`miss_callback`).
    When this method is invoked, it requests that Redis return the value associated
    with the key. If there’s a hit (the value is not `null`), it invokes the `hit_callback`
    with the value as its argument. If there’s a miss (the value is `null`), it invokes
    the `miss_callback`. Any logic for querying a database is left to the caller,
    as we want this code focused on caching.'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '`getValue` 方法接受三个参数：要搜索的 `key`、缓存命中的回调（`hit_callback`）和缓存未命中的回调（`miss_callback`）。当这个方法被调用时，它请求
    Redis 返回与键关联的值。如果命中（值不是 `null`），它将使用值作为参数调用 `hit_callback`。如果未命中（值是 `null`），它将调用
    `miss_callback`。查询数据库的任何逻辑都留给调用者，因为我们希望这段代码专注于缓存。'
- en: The `deleteKey` method calls `redis.del` and passes in the Redis key. We don’t
    use a callback because we’ll be doing this asynchronously and assume it works.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteKey` 方法调用 `redis.del` 并传入 Redis 键。我们不使用回调，因为我们将会异步执行并假设它有效。'
- en: The `makeString` utility is used to convert keys and values before we present
    them to Redis. We need this, because otherwise the Redis Node driver would use
    the `toString()` method on keys and values. This results in strings that look
    something like `[Object object]`, which isn’t what we want.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeString` 工具用于在我们将键和值呈现给 Redis 之前将它们转换。我们需要这样做，因为否则 Redis Node 驱动程序会在键和值上使用
    `toString()` 方法。这会导致看起来像 `[Object object]` 的字符串，这不是我们想要的。'
- en: 'Our updated cache module is shown in [listing 9.6](#ch09list06). Changes are
    shown in **bold**:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新的缓存模块在 [列表 9.6](#ch09list06) 中展示。变更以粗体显示：
- en: Listing 9.6\. Final Redis cache file—`webapp/lib/cache.js`
  id: totrans-823
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.6\. 最终 Redis 缓存文件—`webapp/lib/cache.js`
- en: '![](ch09list06-0.jpg)'
  id: totrans-824
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09list06-0.jpg)'
- en: '![](ch09list06-1.jpg)'
  id: totrans-825
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09list06-1.jpg)'
- en: 'Now that we have the cache file set, we can take advantage of it in the crud.js
    file by adding five lines of code, as seen in [listing 9.7](#ch09list07). Changes
    are shown in **bold**:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了缓存文件，我们可以在 crud.js 文件中利用它，通过添加五行代码，如 [列表 9.7](#ch09list07) 所见。变更以粗体显示：
- en: Listing 9.7\. Reading from the cache—`webapp/lib/crud.js`
  id: totrans-827
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.7\. 从缓存中读取—`webapp/lib/crud.js`
- en: '![](ch09list07-0.jpg)'
  id: totrans-828
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09list07-0.jpg)'
- en: '![](ch09list07-1.jpg)'
  id: totrans-829
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09list07-1.jpg)'
- en: We ensure that the key is removed from the Redis database when an object is
    deleted. But this is far from ideal. It doesn’t ensure that all instances of cached
    data are deleted; it only ensures that the cached data associated with the *key
    used to delete the item* is removed. We could, for example, delete an employee
    *by ID* who was just fired, but the user might still log in and cause havoc in
    the system because the information might be cached using a *username-and-password*
    key. The same issue can happen when updating an object.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保当对象被删除时，键从Redis数据库中移除。但这远非理想。它不能确保所有缓存的实例数据都被删除；它只能确保与用于删除项目的*键*关联的缓存数据被移除。例如，我们可以删除刚刚被解雇的员工*通过ID*，但用户可能仍然登录并导致系统混乱，因为信息可能使用*用户名和密码*键进行缓存。在更新对象时也可能出现同样的问题。
- en: This isn’t an easy problem to resolve and is one reason why server caching is
    often put off until it’s necessary to invest the time in it to scale the system.
    Some possible solutions include expiring cached records after a length of time
    (minimizes the cache mismatch window), clearing the entire user cache when deleting
    or updating a user (safer, but results in more cache misses), or manually keeping
    track of cached objects (more error-prone for developers).
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '这不是一个容易解决的问题，这也是为什么服务器缓存通常被推迟到系统需要扩展时才投入时间解决的原因。一些可能的解决方案包括在一段时间后过期缓存记录（最小化缓存不匹配窗口），在删除或更新用户时清除整个用户缓存（更安全，但会导致更多的缓存未命中），或者手动跟踪缓存对象（对开发者来说更容易出错）。 '
- en: 'There are many more opportunities and challenges in server caching—enough to
    fill a book on its own—but hopefully this is enough to get you started. Now let’s
    take a look at the final caching method: caching data in the database.'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器缓存中有许多更多的机会和挑战——足够写一本书，但希望这足以让你开始。现在让我们看看最终的缓存方法：在数据库中缓存数据。
- en: 9.3.5\. Database query caching
  id: totrans-833
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.5. 数据库查询缓存
- en: '*Query caching* happens when the database caches the results to particular
    queries. In relational databases, this is particularly important because of the
    need to translate the results into a form that the application can read. The query
    cache stores this translated result. Take a look at [figure 9.6](#ch09fig06) to
    see where query caching resides in the request/response cycle.'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询缓存*发生在数据库缓存特定查询的结果时。在关系型数据库中，这尤为重要，因为需要将结果转换为应用程序可以读取的形式。查询缓存存储这个转换后的结果。请查看[图9.6](#ch09fig06)以了解查询缓存在请求/响应周期中的位置。'
- en: Figure 9.6\. Query caching
  id: totrans-835
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.6. 查询缓存
- en: '![](09fig06_alt.jpg)'
  id: totrans-836
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig06_alt.jpg)'
- en: With MongoDB, this is handled automatically for us using the file system of
    the OS. Instead of caching the results to a particular query, MongoDB tries to
    hold the entire index in memory, resulting in extremely quick queries when the
    entire dataset can be held in memory. MongoDB, or rather the operating system’s
    subsystem memory, will dynamically allocate memory based on the needs of the server.
    That means MongoDB will have the entire supply of free RAM available to it without
    having to guess how much to allocate, and will automatically free up memory for
    other processes when it’s needed. Caching behavior such as Least Recently Used
    algorithms work according to the behavior of the operating system.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MongoDB，这由操作系统文件系统自动处理。MongoDB不是缓存特定查询的结果，而是试图将整个索引保持在内存中，当整个数据集可以保持在内存中时，这会导致查询非常快。MongoDB，或者更确切地说，操作系统的子系统内存，将根据服务器的需求动态分配内存。这意味着MongoDB将拥有所有可用的空闲RAM，而无需猜测要分配多少，并且当需要时将自动释放内存给其他进程。像最近最少使用算法这样的缓存行为是根据操作系统的行为工作的。
- en: 9.4\. Summary
  id: totrans-838
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4. 总结
- en: In this chapter, we answered some common questions that occur when hosting an
    SPA website. We showed how we can adjust our SPA so it can be indexed by a search
    engine, how to use analytics tools (like Google Analytics), and how to log application
    errors to a server. Finally, we discussed how to cache at every layer of the application,
    what practical benefit each layer of caching provides, and how to take advantage
    of it.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回答了在托管SPA网站时出现的一些常见问题。我们展示了如何调整我们的SPA以便它可以被搜索引擎索引，如何使用分析工具（如Google Analytics），以及如何将应用程序错误记录到服务器上。最后，我们讨论了如何在应用程序的每一层进行缓存，每一层缓存提供的实际好处，以及如何利用它。
- en: Our advice on how to build a robust, testable, and scalable SPA is nearly complete.
    We strongly encourage you to read appendices A and B, as both cover important
    topics that are covered in significant depth. [Appendix A](kindle_split_022.html#app01)
    shows the code standards we used throughout most of the book; [appendix B](kindle_split_023.html#app02)
    shows how to use test modes and automation to easily identify, isolate, and fix
    software defects.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于如何构建健壮、可测试和可扩展的 SPA 的建议几乎已经完成。我们强烈建议您阅读附录 A 和 B，因为它们都涵盖了重要主题，并且进行了深入探讨。[附录
    A](kindle_split_022.html#app01) 展示了我们在本书的大部分内容中使用的代码标准；[附录 B](kindle_split_023.html#app02)
    展示了如何使用测试模式和自动化来轻松识别、隔离和修复软件缺陷。
- en: In [part 1](kindle_split_010.html#part01) of this book, we built our first SPA
    and discussed why SPAs are an excellent choice for many websites. In particular,
    SPAs can provide an incredibly responsive and interactive user experience that
    a traditional website can’t touch. Next we reviewed some JavaScript programming
    concepts that need to be understood to successfully implement a large-scale SPA.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的[第1部分](kindle_split_010.html#part01)中，我们构建了我们的第一个单页应用（SPA）并讨论了为什么 SPA 对于许多网站来说是一个极佳的选择。特别是，SPA
    可以提供传统网站无法比拟的极响应和交互式的用户体验。接下来，我们回顾了一些需要理解以成功实施大型 SPA 的 JavaScript 编程概念。
- en: In [part 2](kindle_split_013.html#part02), we proceeded to design and implement
    an SPA using a well-tested architecture. We didn’t use a “framework” library because
    we wanted to illustrate the inner workings of an SPA. You should be able to use
    this architecture to develop your own SPA, or tackle the challenge of learning
    one of the many framework libraries with the experience necessary to judge if
    it provides the tools you need.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2部分](kindle_split_013.html#part02)中，我们继续使用经过良好测试的架构设计和实现了 SPA。我们没有使用“框架”库，因为我们想展示
    SPA 的内部工作原理。您应该能够使用这个架构来开发自己的 SPA，或者利用必要的经验来学习许多框架库之一，以判断它是否提供了您需要的工具。
- en: In [part 3](kindle_split_018.html#part03), we set up a Node.js and MongoDB server
    to provide a CRUD backend for our SPA. We used Socket.IO to provide responsive
    and lightweight full-duplex communication between client and server. We also eliminated
    the marshalling of data between data formats that we often see in traditional
    websites.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3部分](kindle_split_018.html#part03)中，我们设置了一个 Node.js 和 MongoDB 服务器，为我们的 SPA
    提供了 CRUD 后端。我们使用了 Socket.IO 来提供客户端和服务器之间响应式和轻量级的全双工通信。我们还消除了在传统网站中经常看到的数据格式之间的数据打包过程。
- en: In the end, we find ourselves with an entire stack that uses JavaScript as its
    language and JSON as its data format. This elegant simplicity provides benefits
    that are compounded at each step of the development process. For example, the
    use of a single language provides the opportunity to move and share code between
    the client and server, which can signicantly reduce the size and complexity of
    our code. It also saves us time and avoids confusion, as there is little context
    switching between languages or data formats. And the benefits extend into testing,
    as not only can we have significantly less code to test, but we can also use the
    same test framework for almost all the code without the overhead and expense of
    a browser test suite.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们发现整个堆栈都使用 JavaScript 作为其语言，JSON 作为其数据格式。这种优雅的简洁性在开发过程的每一步都提供了累积的好处。例如，使用单一语言提供了在客户端和服务器之间移动和共享代码的机会，这可以显著减少我们代码的大小和复杂性。它还节省了我们的时间，避免了混淆，因为语言或数据格式之间的上下文切换很少。而且好处还扩展到测试阶段，因为我们不仅可以有显著更少的代码需要测试，而且我们还可以几乎为所有代码使用相同的测试框架，而不需要浏览器测试套件的额外开销和费用。
- en: We hope that you’ve enjoyed the book and learned as much as we did writing it.
    The best way to continue learning about single page web applications is to continue
    developing them. We’ve tried hard to provide you with all the tools you need to
    do it using JavaScript end-to-end.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您喜欢这本书，并且像我们撰写它一样学到很多。继续学习单页网页应用的最佳方式是继续开发它们。我们努力为您提供了使用 JavaScript 端到端完成所需的所有工具。
