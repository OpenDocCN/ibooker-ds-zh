- en: 3 NATO output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 北约输出
- en: Count yourself blessed if you’ve never had to spell your name over the phone.
    Or perhaps you’re named Mary Smith, but you live on a street or in a city you
    must constantly spell aloud. If so, you resort to your own spelling alphabet,
    something like, “N, as in Nancy” or “K, as in knife.” As a programmer, you can
    ease this frustration by reading this chapter, where you
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未在电话中拼过你的名字，那你就很幸运了。或者也许你的名字叫玛丽·史密斯，但你住在必须不断大声拼读的街道或城市。如果是这样，你就求助于你自己的拼写字母表，比如，“N，就像Nancy”或“K，就像刀子。”作为一个程序员，你可以通过阅读本章来减轻这种挫败感，其中你
- en: Understand the NATO phonetic alphabet and why they even bother.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解北约音标字母表以及他们为什么要这样做。
- en: Translate words into the spelling alphabet.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单词翻译成拼写字母表。
- en: Read a file to translate words into the phonetic alphabet.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件将单词翻译成音标字母表。
- en: Go backward and translate the NATO alphabet into words.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向后翻译北约字母表成单词。
- en: Read a file to translate the NATO alphabet.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件以翻译北约字母表。
- en: Learn that natto in Japanese is a delicious, fermented soybean paste.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习到在日语中纳豆是一种美味的发酵大豆酱。
- en: The last bullet point isn’t covered in this chapter. I just enjoy eating natto,
    and now I can write it off as a business expense.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要点在本章中没有涉及。我只是喜欢吃纳豆，现在我可以把它作为业务费用报销。
- en: Anyway.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 总之。
- en: The glorious conclusion to all this mayhem is to not only learn some new programming
    tricks but also proudly spell words aloud by saying “November” instead of “Nancy.”
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些混乱的辉煌结论是不仅学习一些新的编程技巧，而且可以自豪地大声拼读单词，用“November”而不是“Nancy”。
- en: 3.1 The NATO alphabet
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 北约字母表
- en: Beyond being a handy nickname for anyone named Nathaniel, NATO stands for the
    North Atlantic Treaty Organization. It’s a group of countries who are members
    of a mutual defense pact.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅是任何名叫纳撒尼尔的人的好听的昵称，北约还代表北大西洋公约组织。它是一群国家组成的相互防御联盟。
- en: Established after World War II, blah-blah-blah. I could wax on, but the point
    is that NATO requires some commonality between its member states. You know, so
    that when Hans is short on ammo, Pierre can offer him bullets and they fit into
    the gun. Stuff like that.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在二战后建立，等等。我可以继续说，但重点是北约要求其成员国之间有一些共同点。你知道，这样当汉斯弹药不足时，皮埃尔可以给他子弹，而且子弹可以装进枪里。诸如此类的东西。
- en: One common item shared between NATO countries is a way to spell things out loud.
    That way, Hans doesn’t need to say, “Bullets! That’s B, as in bratwurst; U, as
    in über; L, as in lederhosen. . . .” And so on. Instead, Hans says, “Bravo, Uniform,
    Lima, Lima, Echo, Tango.” This way, Pierre can understand Hans, even over all
    the surrounding gunfire.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 北约国家之间共享的一个共同点是有一个大声拼读单词的方法。这样，汉斯就不需要说，“子弹！B，就像香肠；U，就像超级；L，就像皮短裤……”。以此类推。相反，汉斯会说，“Bravo，Uniform，Lima，Lima，Echo，Tango。”这样，皮埃尔就能理解汉斯，即使是在周围的枪声中。
- en: Table 3.1 lists the NATO phonetic alphabet, describing each letter with its
    corresponding word. The words are chosen to be unique and not easily misunderstood.
    Two of the words (Alfa and Juliett) are misspelled on purpose to avoid being confusing—and
    to be confusing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1列出了北约音标字母表，描述了每个字母对应的单词。这些单词被选择为独特且不易误解。其中有两个单词（Alfa和Juliett）故意拼写错误，以避免混淆——并且为了混淆。
- en: Table 3.1 The NATO phonetic alphabet.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 北约音标字母表。
- en: '| Letter | NATO | Letter | NATO |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 信件 | 北约 | 信件 | 北约 |'
- en: '| A | Alfa | N | November |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| A | 阿尔法 | N | 诺瓦 |'
- en: '| B | Bravo | O | Oscar |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| B | 布拉沃 | O | 奥斯卡 |'
- en: '| C | Charlie | P | Papa |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| C | 查理 | P | 爸爸 |'
- en: '| D | Delta | Q | Quebec |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| D | 德尔塔 | Q | 魁北克 |'
- en: '| E | Echo | R | Romeo |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| E | 雷声 | R | 罗密欧 |'
- en: '| F | Foxtrot | S | Sierra |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| F | 狐狸 | S | 西班牙 |'
- en: '| G | Golf | T | Tango |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| G | 高尔夫 | T | 塔戈 |'
- en: '| H | Hotel | U | Uniform |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| H | 酒店 | U | 制服 |'
- en: '| I | India | V | Victor |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| I | 印度 | V | 维克托 |'
- en: '| J | Juliett | W | Whiskey |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| J | 朱丽叶 | W | 威士忌 |'
- en: '| K | Kilo | X | Xray |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| K | 基洛 | X | X射线 |'
- en: '| L | Lima | Y | Yankee |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| L | 利马 | Y | 美国佬 |'
- en: '| M | Mike | Z | Zulu |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| M | 米克 | Z | 朱鲁 |'
- en: NATO isn’t the only phonetic alphabet, but it’s perhaps the most common. The
    point is consistency. As programmer, you don’t need to memorize any of these words,
    though as a nerd, you probably will. Still, it’s the program that can output NATO
    code—or translate it back into words, depending on how you write your C code.
    Oscar Kilo.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 北约不是唯一的音标字母表，但它可能是最常用的。关键是统一性。作为程序员，你不需要记住这些单词，尽管作为一个极客，你可能会的。不过，程序可以输出北约代码——或者根据你如何编写C代码将其翻译回单词。奥斯卡基洛。
- en: 3.2 The NATO translator program
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 北约翻译程序
- en: 'Any NATO translator program you write must have a string array, like the one
    shown here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的任何北约翻译程序都必须有一个字符串数组，就像下面展示的那样：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The array’s notation, *nato[], implies an array of pointers, which is how the
    compiler builds this construction in memory. The array’s data type is *char*,
    so the pointers reference character arrays—strings—stored in memory. It’s classified
    as a constant because it’s unwise to create an array of strings as pointers and
    then risk modifying them later. The nato[] array is filled with the memory locations
    of the strings, as illustrated in figure 3.1.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的表示法*nato[]*意味着一个指针数组，这是编译器如何在内存中构建这种结构的方式。数组的数据类型是*char*，因此指针引用存储在内存中的字符数组——字符串。它被归类为常量，因为创建一个字符串指针数组并随后修改它们是不明智的。nato[]数组填充了字符串的内存位置，如图3.1所示。
- en: '![03-01](Images/03-01.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![03-01](Images/03-01.png)'
- en: Figure 3.1 How an array of pointers references strings as they sit in memory
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 如何通过数组指针引用内存中的字符串
- en: 'For example, in the figure, the string *Alfa* (terminated with a null character,
    \0) is stored at address 0x404020\. This memory location is stored in the nato[]
    array, not the string itself. Yes, the string appears in the array’s declaration,
    but it’s stored elsewhere in memory at runtime. The same structure holds true
    for all elements in the array: each one corresponds to a string’s memory location,
    from Alfa to Zulu.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在图中，字符串*Alfa*（以空字符终止，\0）存储在地址0x404020。这个内存位置存储在nato[]数组中，而不是字符串本身。是的，字符串出现在数组的声明中，但在运行时它存储在内存的另一个地方。对于数组中的所有元素，这种结构都是相同的：每个元素对应一个字符串的内存位置，从Alfa到Zulu。
- en: The beauty of the nato[] array is that the contents are sequential, matching
    up to ASCII values 'A' through 'Z' when you subtract the value of 'A'. (See chapter
    4 for more details on how this operation works.) This coincidence makes extracting
    the character corresponding to the NATO word embarrassingly easy.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: NATO数组的美妙之处在于其内容是顺序排列的，当你从'A'的值中减去时，它们与ASCII值'A'到'Z'相匹配。（有关此操作的更多详细信息，请参阅第4章。）这种巧合使得提取对应NATO单词的字符变得非常容易。
- en: 3.2.1 Writing the NATO translator
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 编写NATO翻译器
- en: A simple NATO translator is shown in listing 3.1\. It prompts for input, using
    the *fgets()* function to gather a word from standard input. A *while* loop churns
    through the word letter by letter. Along the way, any alphabetic characters are
    detected by the *isalpha()* function. If found, the letter is used as a reference
    into the nato[] array. The result is the NATO phonetic alphabet term output.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的NATO翻译器在列表3.1中展示。它使用*fgets()*函数从标准输入中收集一个单词。一个*while*循环逐个字符地遍历单词。在这个过程中，任何字母字符都会被*isalpha()*函数检测到。如果找到，该字母就被用作nato[]数组的参考。结果是输出NATO音标字母术语。
- en: Listing 3.1 Source code for nato01.c
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 nato01.c的源代码
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Stores into location phrase 63 characters (plus the null character) from stdin,
    standard input
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将从stdin，标准输入存储到位置phrase的63个字符（加上空字符）
- en: ❷ Loops until the null character is found in the string
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 循环直到在字符串中找到空字符
- en: ❸ Converts ch to uppercase
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将字符ch转换为大写
- en: ❹ True when character ch is alphabetic
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当字符ch是字母时为真
- en: ❺ ch-'A' transforms the letters to values 0 through 25, matching the corresponding
    array element.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ ch-'A'将字母转换为0到25的值，与相应的数组元素匹配。
- en: ❻ A long string may not have a null character, so bail when the buffer size
    is reached.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果长字符串没有空字符，那么当达到缓冲区大小时就退出。
- en: 'When built and run, the program prompts for input. Whatever text is typed (up
    to 63 characters) is translated and output in the phonetic alphabet. For example,
    “Howdy” becomes:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行程序后，程序会提示输入。无论输入什么文本（最多63个字符），都会将其翻译并输出为音标字母。例如，“Howdy”会变成：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Typing a longer phrase such as “Hello, World!” yields:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个较长的短语，例如“Hello, World!”，会得到：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because nonalpha characters are ignored in the code, no output for them is generated.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因为代码中忽略了非字母字符，所以不会为它们生成输出。
- en: 'Translation into another phonetic alphabet is easy with this code. All you
    do is replace the nato[] array with your own phonetic alphabet. For example, here
    is the array you can use for the law enforcement phonetic alphabet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码将翻译成另一个音标字母非常容易。你所要做的就是用你自己的音标字母替换nato[]数组。例如，以下是你可以用于执法音标字母的数组：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 3.2.2 Reading and converting a file
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 读取和转换文件
- en: I’m unsure of the need to translate all the text from a file into the NATO phonetic
    alphabet. It’s a C project you can undertake, primarily for practice, but practically
    speaking, it makes little sense. I mean, it would be tedious to hear three hours
    of *Antony and Cleopatra* done entirely in the NATO alphabet, though if you’re
    a theater/IT dual major, give it a shot. Still, this is a book and I’m a nerd,
    so the topic will be explored for your betterment.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定将文件中的所有文本翻译成北约语音字母表的需要。这是一个你可以承担的 C 项目，主要是为了练习，但从实际的角度来看，这几乎没有意义。我的意思是，听到三个小时的全是北约字母表的
    *安东尼与克莉奥帕特拉* 会很无聊，尽管如果你是戏剧/IT 双专业，可以试一试。不过，这是一本书，而我是一个书呆子，所以这个话题将为了你们的提高而被探讨。
- en: Listing 3.2 presents code that devours a file and translates each character
    into its NATO phonetic alphabet counterpart. The filename is supplied at the command
    prompt. If not, the program bails with an appropriate error message. Otherwise,
    similar to the code in nato01.c, the code churns though the file one character
    at a time, spewing out the matching NATO words.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 展示了消耗文件并将每个字符转换为北约语音字母表对应项的代码。文件名在命令提示符中提供。如果没有提供，程序将显示适当的错误消息并退出。否则，与
    nato01.c 中的代码类似，该代码逐个字符地处理文件，输出匹配的北约单词。
- en: Listing 3.2 Source code for nato02.c
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 nato02.c 的源代码
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ If fewer than two arguments are present, the filename option is missing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果参数少于两个，则缺少文件名选项。
- en: ❷ Opens the filename supplied at the command prompt, referenced as argv[1]
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打开在命令提示符中提供的文件名，引用为 argv[1]
- en: ❸ Reads one character at a time from the file, storing it in variable ch. The
    EOF marks the end of the file
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 逐个字符从文件中读取，将其存储在变量 ch 中。EOF 标记文件末尾
- en: ❹ Processes only text characters
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 仅处理文本字符
- en: ❺ Uses the uppercase version of the character, minus the value of 'A' to index
    the nato[] array
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用字符的大写版本，减去 'A' 的值来索引 nato[] 数组
- en: Remember to use integer variables when processing text from a file. The EOF
    flag that marks the end of a file is an *int* value, not a *char* value. The *while*
    statement in the code is careful to extract a character from the file as well
    as evaluate the character to determine when the operation is over.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 记住处理来自文件的文本时使用整数变量。标记文件末尾的 EOF 标志是一个 *int* 值，而不是 *char* 值。代码中的 *while* 语句小心地从文件中提取一个字符，并评估该字符以确定何时结束操作。
- en: To run the program, type a filename argument after the program name. Text files
    are preferred. The output appears as a single line of text reflecting the phonetic
    alphabet words for every dang doodle character in the file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序，请在程序名称后输入文件名参数。文本文件是首选。输出显示为单行文本，反映了文件中每个字符的语音字母表单词。
- en: 'For extra fun on the Macintosh, pipe the program’s output through the say command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Macintosh 上，为了增加乐趣，可以将程序的输出通过 say 命令进行管道传输：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This way, the phonetic alphabet contents of the file given are read aloud by
    the Mac, from start to end. Sit back and enjoy.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，文件提供的语音字母表内容就会被 Mac 从头到尾朗读出来。坐下来享受吧。
- en: 3.3 From NATO to English
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 从北约到英语
- en: 'Phonetic alphabet translation is supposed to happen in your head. Someone spells
    their hometown: India, Sierra, Sierra, Alfa, Quebec, Uniform, Alfa, Hotel. And
    the listener knows how to write down the word, spelling it properly. The word
    is *Issaquah*, which is a city where I once lived. I had to spell the name frequently.
    The beauty of this operation is that even a person who doesn’t know the NATO alphabet
    can understand what’s being spelled, thanks to the initial letter.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 语音字母表的翻译应该在您的脑海中完成。有人拼写他们的家乡：印度，西拉，西拉，阿尔法，魁北克，尤尼弗莫，阿尔法，酒店。听众知道如何写下这个单词，正确地拼写它。这个单词是
    *Issaquah*，这是我曾经居住过的一个城市。我不得不经常拼写这个名字。这个操作的美丽之处在于，即使不知道北约字母表的人也能理解正在拼写的内容，多亏了首字母。
- en: More difficult, however, is to write code that scans for phonetic alphabet words
    and translates them into the proper single characters. This process involves parsing
    input and examining it word by word to see whether one of the words matches a
    term found in the lexicon.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编写代码以扫描语音字母表单词并将它们翻译成正确的单个字符则更困难。这个过程涉及解析输入并逐词检查是否有单词与词典中找到的术语匹配。
- en: 3.3.1 Converting NATO input to character output
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 将北约输入转换为字符输出
- en: To determine whether a phonetic alphabet term appears in a chunk of text, you
    must parse the text. The string is separated into word chunks. Only after you
    pull out the words can you compare them with the phonetic alphabet terms.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定音标字母术语是否出现在文本块中，你必须解析文本。字符串被分隔成单词块。只有在你提取出单词后，你才能将它们与音标字母术语进行比较。
- en: To do the heavy lifting, use the *strtok()* function to parse words in a stream
    of text. I assume the function name translates as “string tokenizer” or “string
    to kilograms,” which makes no sense.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行繁重的工作，使用 *strtok()* 函数解析文本流中的单词。我假设函数名翻译为“字符串标记器”或“字符串到千克”，这毫无意义。
- en: 'The *strtok()* function parses a string into chunks based on one or more separator
    characters. Defined in the string.h header file, the man page format is:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*strtok()* 函数根据一个或多个分隔符字符将字符串解析成块。定义在 string.h 头文件中，手册页的格式是：'
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first argument, str, is the string to scan. The second argument, delim,
    is a string containing the individual characters that can separate, or *delimit*,
    the character chunks you want to parse. The value returned is a *char* pointer
    referencing the character chunk found. For example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，str，是要扫描的字符串。第二个参数，delim，是包含可以分隔或*限定*你想要解析的字符块的单独字符的字符串。返回值是一个 *char*
    指针，它引用找到的字符块。例如：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This statement scans characters held in buffer string, stopping when the space
    character is encountered. Yes, the second argument is a full string, even when
    only a single character is required. The *char* pointer match holds the address
    of the word (or text chunk) found, terminated with a null character where the
    space or another delimiter would otherwise be. The NULL constant is returned when
    nothing is found.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句扫描缓冲字符串中持有的字符，直到遇到空格字符停止。是的，第二个参数是一个完整的字符串，即使只需要单个字符。*char* 指针匹配持有找到的单词（或文本块）的地址，在空格或另一个分隔符本应出现的地方终止。当没有找到任何内容时，返回
    NULL 常量。
- en: 'To continue scanning the same string, the first argument is replaced with the
    NULL constant:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续扫描相同的字符串，第一个参数被替换为 NULL 常量：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The NULL argument informs the function to use the string passed earlier and
    continue the tokenizing operation. The code shown in the next listing illustrates
    how to put the *strtok()* function to work.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: NULL 参数通知函数使用之前传递的字符串并继续标记化操作。下一列表中的代码展示了如何使用 *strtok()* 函数。
- en: Listing 3.3 Source code for word_parse01.c
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 word_parse01.c 的源代码
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ The initial call to *strtok()*, with the string to search.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始调用 *strtok()*, 传入要搜索的字符串。
- en: ❷ Loops as long as the return value isn’t NULL.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当返回值不是 NULL 时循环。
- en: ❸ In the second call to *strtok()*, NULL is used to keep searching the same
    string.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在第二次调用 *strtok()* 时，使用 NULL 以继续搜索相同的字符串。
- en: 'In this code, the user is prompted for a string. The *strtok()* function extracts
    words from the string, using a single space as the separator. Here’s a sample
    run:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，用户被提示输入一个字符串。*strtok()* 函数使用单个空格作为分隔符从字符串中提取单词。以下是一个示例运行：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When separators other than the space appear in the string, they’re included
    in the character chunk match:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符串中出现除空格之外的分隔符时，它们会被包含在字符块匹配中：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To avoid capturing the punctuation characters, you can set this delimiter string:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要避免捕获标点符号字符，你可以设置此分隔符字符串：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, the second argument lists common punctuation characters, including the
    double quote character, which must be escaped (\"). The result is that the delimited
    words are truncated, as in:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第二个参数列出了常见的标点符号字符，包括双引号字符，它必须被转义（\"). 结果是分隔的单词被截断，如下所示：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You may find some trailing blank lines in the program’s output. These extra
    newline characters are fine for matching text, because the blank lines won’t match
    anything anyhow.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在程序的输出中找到一些尾随的空白行。这些额外的换行符对于匹配文本是好的，因为空白行无论如何都不会匹配任何内容。
- en: To create a phonetic alphabet input translator, you modify this code to perform
    string comparisons with an array of NATO phonetic alphabet terms. The *strcmp()*
    function handles this task, but you must consider two factors.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个音标字母输入转换器，你需要修改此代码以执行与北约音标字母术语数组的字符串比较。*strcmp()* 函数处理这个任务，但你必须考虑两个因素。
- en: First, *strcmp()* is case-sensitive. Some C libraries feature a *strcasecmp()*
    function that performs case-insensitive comparisons, though this function isn’t
    part of the C standard. Second, the string length may vary. For example, if you
    choose not to count the punctuation characters (" ,.!?:;\"'") in the *strtok()*
    function—or when an unanticipated punctuation character appears—the comparison
    fails.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*strcmp()* 是大小写敏感的。一些 C 库具有一个 *strcasecmp()* 函数，它执行不区分大小写的比较，尽管这个函数不是 C 标准的一部分。其次，字符串长度可能不同。例如，如果您选择不在
    *strtok()* 函数中计算标点符号字符（" ,.!?:;\"'”）——或者当出现未预期的标点符号字符时——比较将失败。
- en: Given these two situations, I figure it’s best to concoct a unique string comparison
    function, one designed specifically to check parsed words for a match with a phonetic
    alphabet term. This function, *isterm()*, is shown next.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我认为最好创建一个独特的字符串比较函数，一个专门设计用来检查解析的单词是否与音标字母表术语匹配的函数。这个函数，*isterm()*，将在下面展示。
- en: Listing 3.4 The *isterm()* function
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 *isterm()* 函数
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Sets pointer n to the current NATO word
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将指针 n 设置为当前北约单词
- en: ❷ Pointer t references the term passed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指针 t 指向传递的术语。
- en: ❸ Loops until the NATO term ends
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 循环直到北约术语结束
- en: ❹ Logically converts each letter to uppercase and compares; refer to chapter
    5 for more info on this and other ASCII tricks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 逻辑地将每个字母转换为大写并比较；有关此和其他 ASCII 技巧的更多信息，请参阅第 5 章。
- en: ❺ For no match, the loop breaks and the next term in nato[] is compared.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对于没有匹配的情况，循环中断，并比较 nato[] 中的下一个术语。
- en: ❻ Increments through each letter
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 遍历每个字母
- en: ❼ When pointer n is the null character, the terms have matched.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 当指针 n 是空字符时，术语已匹配。
- en: ❽ Returns the first letter of the NATO term
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 返回北约术语的第一个字母
- en: The *isterm()* function accepts a word as its argument. The return value is
    a single character if the word matches a NATO phonetic alphabet term; otherwise,
    the null character is returned.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*isterm()* 函数接受一个单词作为其参数。如果单词与北约音标字母表术语匹配，则返回值是单个字符；否则，返回空字符。'
- en: To create a new NATO translation program, add the *isterm()* function to your
    source code file, below any existing code. You must include both the stdio.h and
    string.h header files. Then add the following main() function to build a new program,
    nato03.c, as shown here.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的北约翻译程序，将 *isterm()* 函数添加到您的源代码文件中，在现有代码的下方。您必须包含 stdio.h 和 string.h 头文件。然后添加以下
    main() 函数来构建一个新的程序，nato03.c，如下所示。
- en: Listing 3.5 The *main()* function from nato03.c
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.5 nato03.c 中的 *main()* 函数
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The code scans the line input for any matching phonetic alphabet terms. The
    *isterm()* function handles the job. The matching character is returned and output.
    Here’s a sample run:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 代码扫描输入行中的任何匹配的音标字母表术语。*isterm()* 函数处理这项工作。匹配的字符被返回并输出。以下是一个示例运行：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'An input sentence with no matching characters outputs a blank line. Mixed characters
    are output like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配的字符，输入的句子将输出一个空行。混合字符的输出如下：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you want to add in code to translate special characters, such as punctuation
    characters, you can do so on your own. Keep in mind that the NATO phonetic alphabet
    lacks terms with punctuation, though if you’re creating your own text-translation
    program, checking for special characters might be required.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在代码中添加翻译特殊字符的功能，您可以自行完成。请注意，北约音标字母表缺少带有标点的术语，尽管如果您正在创建自己的文本翻译程序，检查特殊字符可能是有必要的。
- en: 3.3.2 Reading NATO input from a file
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 从文件中读取北约输入
- en: 'Reading input to detect and translate an alphabetic language is silly but a
    good exercise. Reading an entire file to detect an alphabetic language is even
    sillier. I try not to think of it as a necessity but rather as programming practice:
    can you scan a file for specific words and then report on their presence? Adopt
    this notion to justify completing such a program.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 读取输入以检测和翻译字母语言是愚蠢的，但这是一个很好的练习。读取整个文件以检测字母语言甚至更愚蠢。我尽量不把它看作是必需的，而更看作是编程实践：你能扫描文件以查找特定单词，然后报告它们的存在吗？采用这个概念来证明完成这样一个程序是合理的。
- en: As with reading a line of text, to process text in a file for signs of NATO
    alphabet words, you need the isterm() function. The file reads a line at a time,
    and the contents of each line are examined similarly to the code presented in
    nato03.c. Mixing in the file commands from nato02.c, I’ve created a child program,
    nato04.c. It’s found in this book’s GitHub repository. Assembling such a program
    in a kind of Frankenstein way appeals to me. It’s the philosophy upon which Stack
    Overflow is successful.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与读取一行文本一样，为了在文件中处理文本以寻找北约字母表单词，你需要 isterm() 函数。文件逐行读取，并且每行的内容都类似于在 nato03.c
    中展示的代码。将 nato02.c 中的文件命令混合在一起，我创建了一个子程序，nato04.c。它位于本书的 GitHub 仓库中。以类似弗兰肯斯坦的方式组装这样的程序对我来说很有吸引力。这是
    Stack Overflow 成功的哲学。
- en: The guts of nato04.c process an open file by using two while loops, illustrated
    in the next listing. If you’ve been following along with the NATO series of programs
    in this chapter, many of the statements are familiar to you.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: nato04.c 的核心通过使用两个 while 循环处理打开的文件，如下一列表所示。如果你一直跟随本章中北约程序系列，许多语句对你来说都很熟悉。
- en: Listing 3.6 Processing words in a file with nested loops
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 使用嵌套循环处理文件中的单词
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Loops until the end of open file handle n
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 循环直到打开的文件处理器 n 的末尾
- en: ❷ Grabs a line of text up to 63 characters
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 读取最多63个字符的文本行
- en: ❸ Filters out a lot of characters
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 过滤掉很多字符
- en: ❹ Loops until all the words in the line are read
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 循环直到读取行中的所有单词
- en: ❺ Sends the matching word off to the *isterm()* function
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将匹配的单词发送到 *isterm()* 函数
- en: 'The result of all this cobbled code is to pluck out any matching NATO phonetic
    alphabet terms stored in a file and pop out the corresponding letter for each.
    As you may guess, few files have a NATO term smuggled inside, so the output is
    often empty. Still, I ran the code using the nato04.c source code file as input:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些拼凑的代码的结果是，从文件中提取任何匹配的北约音标字母表术语，并为每个术语弹出相应的字母。正如你可能猜到的，很少有文件中隐藏着北约术语，所以输出通常是空的。尽管如此，我还是使用了
    nato04.c 源代码文件作为输入来运行代码：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Much to its delight, the program found the nato[] array’s text and gobbled up
    all the alphabetic terms, in order, to spew out the alphabet itself. Wonderful.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让程序很高兴的是，它找到了 nato[] 数组的文本，并按顺序吞噬了所有字母表术语，然后吐出了字母表本身。太棒了。
- en: One problem with the code in nato04.c is that the *fgets()* function reads in
    only a slice of characters per line. In the source code, if a line of text in
    the file is shorter than the given number of characters (63 plus one for the null
    character), the line of text is read up to and including the newline character.
    If the line of text in a file is longer than the quantity specified by the *fgets()*
    function, it’s truncated. Truncating text when you’re looking for a word is bad,
    though not as bad as truncating an elephant.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: nato04.c 中的代码有一个问题，那就是 *fgets()* 函数每次只读取每行的字符片段。在源代码中，如果文件中的一行文本短于指定的字符数（63个字符加上一个空字符），则文本行将读取到并包括换行符。如果文件中的一行文本长于
    *fgets()* 函数指定的数量，则文本将被截断。当你寻找单词时截断文本是件坏事，尽管这比截断一头大象要好一些。
- en: To better process the file, and ensure that words aren’t split by an unforgiving
    *fgets()* function, I’ve recajiggered the code to read the file one character
    at a time. In this approach, the code works more like a program filter. (Filters
    are covered in chapter 4.) The words in the file are assembled as each character
    is digested.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地处理文件，并确保单词不会被苛刻的 *fgets()* 函数分割，我已经重新调整了代码，使其逐个字符读取文件。在这种方法中，代码更像是一个程序过滤器。（过滤器在第4章中有介绍。）随着每个字符的消化，文件中的单词被组装起来。
- en: Listing 3.7 shows a *while* loop that processes an open file, represented by
    *FILE* handle n. Characters are stored in int variable ch, read one at a time
    by using the *fgetc()* function. The integer variable offset tracks the characters
    read as they’re stored in a word[] buffer. This buffer is 64 characters long.
    If a buffer overflow occurs, the program terminates. I mean, show me a word longer
    than 64 characters. And if you can legitimately find one, increase the buffer
    size.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7展示了处理打开文件（由 *FILE* 处理器 n 表示）的 *while* 循环。字符存储在 int 变量 ch 中，通过使用 *fgetc()*
    函数逐个读取。整数变量 offset 跟踪存储在 word[] 缓冲区中的读取字符。这个缓冲区长64个字符。如果发生缓冲区溢出，程序将终止。我的意思是，给我一个超过64个字符的单词。如果你能合法地找到一个，请增加缓冲区大小。
- en: Listing 3.7 Processing words in a file one at a time
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 逐个处理文件中的单词
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Loops as long as the file has bytes to read
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 循环直到文件有可读字节
- en: ❷ Words start with a letter of the alphabet.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 单词以字母表中的一个字母开头。
- en: ❸ Stores the character to build the word
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 存储字符以构建单词
- en: ❹ Checks for overflow; bails if so
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查溢出；如果发生溢出则退出
- en: ❺ A nonalphabetic character is found, meaning the end of a word.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 找到非字母字符，意味着单词的结束。
- en: ❻ Confirms that the word[] buffer has some text in it
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 确认word[]缓冲区中有些文本
- en: ❼ Cap your strings!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 限制字符串长度！
- en: ❽ Processes the word, returning a valid character or the null character (doesn’t
    print)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 处理单词，返回有效字符或空字符（不打印）
- en: ❾ Resets the offset to store the next word
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 重置偏移量以存储下一个单词
- en: The code shown in listing 3.7 is part of the nato05.c source code file, available
    in this book’s GitHub repository. The program works similarly to nato04.c, though
    a long line of text read from the file isn’t split—which could split a valid word.
    By processing the file’s text one character at a time, such a split can’t happen
    (unless the word is ridiculously long).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7中显示的代码是nato05.c源代码文件的一部分，可在本书的GitHub仓库中找到。该程序的工作方式与nato04.c类似，尽管从文件中读取的长行文本没有被分割——这可能会分割一个有效的单词。通过逐字符处理文件的文本，这种分割就不会发生（除非单词非常长）。
- en: 'The program’s output is identical to that of nato04.c in the case of processing
    the source code file’s text:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出与处理源代码文件文本时的nato04.c完全相同：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Like any program, the code for nato05.c can be improved upon. As it’s written,
    the code relies upon a nonalphabetic character to terminate a word: the *isalpha()*
    function returns TRUE when the character (*int* value) examined is in the range
    ''A'' to ''Z'' or ''a'' to ''z''. This rule eliminates contractions (*don’t*,
    *o’clock*), though it’s rare such contractions would be included in a phonetic
    alphabet.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 任何程序，nato05.c的代码都可以进行改进。按照目前的编写方式，代码依赖于非字母字符来终止一个单词：当检查的字符（*int*值）在'A'到'Z'或'a'到'z'的范围内时，*isalpha()*函数返回TRUE。这个规则消除了缩写（*don’t*，*o’clock*），尽管这种缩写很少会包含在音标字母表中。
- en: Beyond peeking into a file for NATO phonetic alphabetic terms, the code provides
    a practical example of how to scan any file for specific words. Consider it inspiration
    for other programs you may create. Or just enjoy your newfound knowledge of the
    NATO phonetic alphabet, so you can beam with pride when asked to spell your city
    name over the phone.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查看文件中的北约音标字母表术语外，该代码还提供了一个如何扫描任何文件以查找特定单词的实际示例。将其视为您可能创建的其他程序的灵感来源。或者，只需享受您对北约音标字母表的新知识，这样当别人打电话要求您拼写城市名称时，您就可以自豪地展示出来。
