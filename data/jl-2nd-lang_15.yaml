- en: 12 Understanding Julia collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 理解Julia集合
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding how collections are categorized according to the type of operations
    they support
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解根据它们支持的运算类型对集合进行分类的方法
- en: Turning staged rockets into an iterable collection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分阶段火箭转换为可迭代集合
- en: Using common operations supported by various collection types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用各种集合类型支持的操作
- en: You have already looked at collections such as arrays and dictionaries, but
    there are many other types of collections, including sets, linked lists, heaps,
    stacks, and binary trees. In this chapter, I will cover the commonalities between
    different types of collections. Every collection organizes and stores multiple
    elements, and each collection type offers unique ways of accessing these elements.
    For example, with a dictionary, you can access elements by providing a key, while
    an array requires an index.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经查看过数组、字典等集合，但还有许多其他类型的集合，包括集合、链表、堆、栈和二叉树。在本章中，我将介绍不同类型集合之间的共性。每个集合都组织和存储多个元素，每种集合类型都提供访问这些元素的独特方式。例如，使用字典，你可以通过提供键来访问元素，而数组则需要索引。
- en: However, collections also have core functionality that all collections must
    support, such as being *iterable*. If something is iterable, you can access the
    individual elements in a for loop or use a higher-order function, such as map
    or filter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，集合也有所有集合都必须支持的核心功能，例如*可迭代性*。如果某物是可迭代的，你可以在for循环中访问其单个元素或使用高阶函数，如map或filter。
- en: What exactly makes something a collection? What are the differences and similarities
    between different collection types? And how can you make your own? You will explore
    these questions by expanding on the multistage rocket example from chapter 8\.
    Because the rocket is made up of many different parts, it is possible to turn
    it into something Julia will recognize as a collection.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 什么使某物成为集合？不同集合类型之间的差异和相似之处是什么？你如何创建自己的集合？你将通过扩展第8章中的多级火箭示例来探索这些问题。因为火箭由许多不同的部分组成，所以它可以被转换成Julia能识别为集合的东西。
- en: In this chapter you will add code to the Tank abstract type to show how interfaces
    are defined. You will modify the engine Cluster type to support iterating over
    engines. In the final example you will modify the StagedRocket type to support
    iteration over a multistage rocket.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将为Tank抽象类型添加代码，以展示接口是如何定义的。你将修改engine Cluster类型以支持遍历引擎。在最后的示例中，你将修改StagedRocket类型以支持多级火箭的遍历。
- en: 12.1 Defining interfaces
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 定义接口
- en: What exactly is an interface? It helps to contrast interfaces with implementations.
    When you interact with a computer, you use a mouse and a keyboard; that is the
    interface to your computer—you don’t need to know how the particular computer
    you use is built (figure 12.1). You can use the same mouse and keyboard with many
    different computers built in very different ways. Regardless of how much memory
    or what microprocessor your computer has, you can interact with it by clicking
    the same icons and moving around the same windows. In other words, there is a
    shared interface between many computer models, which insulates you from the specific
    hardware implementation of each computer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接口究竟是什么？它有助于将接口与实现进行对比。当你与计算机交互时，你使用鼠标和键盘；这就是你的计算机接口——你不需要知道你使用的特定计算机是如何构建的（图12.1）。你可以使用相同的鼠标和键盘与许多不同方式构建的计算机一起使用。无论你的计算机有多少内存或什么微处理器，你都可以通过点击相同的图标和移动相同的窗口与之交互。换句话说，许多计算机模型之间存在一个共享的接口，这使你免受每个计算机特定硬件实现的干扰。
- en: '![12-01](../Images/12-01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![12-01](../Images/12-01.png)'
- en: Figure 12.1 A computer does not need to know how an input device works.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 计算机不需要知道输入设备的工作原理。
- en: Separating components with clearly defined interfaces allows you to build large,
    complex structures. The various parts making up your system do not need to know
    details about implementation as long as each part uses a well-defined interface.
    Let’s relate this to programming with Julia. Arrays and ranges are both subtypes
    of AbstractArray, as shown in figure 12.2.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过清晰定义的接口分离组件，允许你构建大型、复杂的结构。组成你系统的各个部分不需要了解实现细节，只要每个部分使用一个定义良好的接口即可。让我们将这一点与使用Julia进行编程联系起来。数组和范围都是AbstractArray的子类型，如图12.2所示。
- en: '![12-02](../Images/12-02.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![12-02](../Images/12-02.png)'
- en: Figure 12.2 Type hierarchy for arrays and ranges
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 数组和范围的类型层次结构
- en: Thus if you have defined a function operating on an AbstractArray, you don’t
    have to deal with the difference between an array and a range. You can make a
    function addup (see listing 12.1), which works whether you pass an array or a
    range as an argument.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你已经定义了一个在抽象数组上操作的功能，你就不必处理数组和范围之间的区别。你可以创建一个名为addup（见列表12.1）的功能，它无论你传递的是数组还是范围作为参数都能正常工作。
- en: Listing 12.1 Function for adding up elements in an abstract array
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.1 在抽象数组中累加元素的功能
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Store the total.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 存储总和。
- en: ❷ Return the total.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回总和。
- en: Let’s call this function with different arguments. Notice it is very similar
    in function to the sum function, except it does not allow you to add up a tuple
    of values. Why is that?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用不同的参数调用这个函数。注意它在功能上与sum函数非常相似，只是它不允许你添加值元组。为什么是这样呢？
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Adding a range of values
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加一系列值
- en: ❷ Adding an array of values
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加一个值数组
- en: ❸ Attempting to add a tuple of values
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 尝试添加一个值元组
- en: 'The Tuple type is nowhere to be found in the AbstractArray type hierarchy,
    and thus values of type Tuple are not valid arguments to addup. Another example
    of a common interface can be seen in accessing elements by index both for ranges
    and arrays. Keep in mind that the first element of Julia arrays is at index 1:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Tuple类型在AbstractArray类型层次结构中无处可寻，因此Tuple类型的值不是addup的有效参数。另一个常见接口的例子是，对于范围和数组，都可以通过索引访问元素。请记住，Julia数组的第一个元素位于索引1：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Define a similar-looking range and array.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个看起来相似的范围和数组。
- en: ❷ Accessing the second element looks the same.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 访问第二个元素看起来是一样的。
- en: ❸ Summing a range and an array works the same.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对范围和数组求和的效果相同。
- en: A range doesn’t have elements; elements exist implicitly. However, you can abstract
    away that difference by giving range and array a similar-looking interface. That
    allows us to define functions such as sum to work for both types, without creating
    two different methods.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 范围没有元素；元素是隐式存在的。然而，你可以通过给范围和数组一个相似的接口来抽象出这种差异。这允许我们定义像sum这样的函数，使其对这两种类型都有效，而不需要创建两个不同的方法。
- en: In an object-oriented language, such as Java, C++, or C#, interfaces for an
    AbstractArray are defined explicitly. The type definition in these languages includes
    a list of methods that subtypes must implement. Failing to do so produces a compiler
    error.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的语言中，例如Java、C++或C#，AbstractArray的接口是明确定义的。这些语言中的类型定义包括子类型必须实现的方法列表。未能这样做会产生编译器错误。
- en: However, in Julia, interfaces are *informally* defined. Therefore there is no
    compiler telling you that you implemented an interface incorrectly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Julia中，接口是*非正式*定义的。因此，没有编译器会告诉你你错误地实现了接口。
- en: 12.2 Propellant tank interface example
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 推进剂罐接口示例
- en: To clarify how to define and work with interfaces in Julia, we will take a look
    at the propellant tank example from chapter 8 (see listing 12.2). Say you are
    supplying a propellant tank interface other developers can use, and you want to
    enable them to create their own Tank subtypes they can use when assembling rockets.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐明如何在Julia中定义和使用接口，我们将查看第8章中的推进剂罐示例（见列表12.2）。假设你正在提供一个推进剂罐接口，其他开发人员可以使用它，并且你希望他们能够创建自己的Tank子类型，以便在组装火箭时使用。
- en: Listing 12.2 Defining an abstract propellant tank
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.2 定义一个抽象推进剂罐
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Filling a propellant tank to the max
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将推进剂罐装满至最大
- en: Now imagine that another developer tries to create a concrete Tank subtype to
    use in the rocket simulation. The developer writes the following code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象另一个开发人员试图创建一个具体的Tank子类型，用于火箭模拟。开发人员编写了以下代码。
- en: Listing 12.3 Defining a propellant tank subtype
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.3 定义推进剂罐子类型
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The developer wants to try out their new tank and writes the following code
    in the Julia REPL:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员想要尝试他们的新罐子，并在Julia REPL中编写以下代码：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Julia has no idea what totalmass is.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Julia不知道totalmass是什么。
- en: This error message makes it difficult for somebody trying to implement the Tank
    interface to know what they are supposed to do. The Julia convention to solve
    this problem is defining the functions in the interface and documenting them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误信息使得试图实现Tank接口的人难以知道他们应该做什么。Julia解决这个问题的惯例是在接口中定义函数并对其进行文档化。
- en: 'When looking at the code in listing 12.4, you may ask the following questions:
    Why is this focusing on documenting the code? Where is the interface defined?
    And what is the syntax for defining an interface? The answer is that there is
    none. That is why I say interfaces in Julia are *informally* defined. Hence documentation
    *is* a key part of defining a Julia interface.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看列表 12.4 中的代码时，你可能会有以下疑问：为什么这个例子专注于文档化代码？接口在哪里定义？定义接口的语法是什么？答案是，没有。这就是为什么我说
    Julia 中的接口是*非正式*定义的。因此，文档*是*定义 Julia 接口的关键部分。
- en: Remember from chapter 7 that in Julia, methods are attached to functions, not
    types. You cannot associate functions with any particular type. The only reason
    totalmass, drymass, and propellant belong to the Tank interface is that we said
    so in the documentation. It is all make believe.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 记住第 7 章中提到的，在 Julia 中，方法附加到函数上，而不是类型上。你不能将函数与任何特定类型关联。totalmass、drymass 和 propellant
    属于 Tank 接口的原因仅仅是因为我们在文档中这样说了。这完全是虚构的。
- en: Listing 12.4 Defining a well-documented interface to propellant tanks
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.4 定义一个良好文档化的推进剂罐接口
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Julia documentation system works by prefixing a function or type definition
    with a regular Julia text string. Inside this text string you document your function
    or type using markdown^([1](#pgfId-1013449)) syntax. In markdown you indent lines
    you want formatted as source code. To highlight individual words as code you use
    backticks `.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的文档系统通过在函数或类型定义前加上一个常规的 Julia 文本字符串来工作。在这个文本字符串内部，你使用 markdown^([1](#pgfId-1013449))
    语法来文档化你的函数或类型。在 markdown 中，你缩进你想格式化为源代码的行。为了突出显示单个单词作为代码，你使用反引号 `。
- en: Tip Sometimes you want to write function definitions right in the Julia REPL.
    However, when you press Enter after the end of the documentation string, it gets
    evaluated before you can write your function definition. How do you fix this?
    If you hold down the Alt or Option key when you press Enter, Julia will allow
    you to continue writing code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：有时你希望在 Julia REPL 中直接编写函数定义。然而，当你按下 Enter 键结束文档字符串后，它在你能够编写函数定义之前就会被评估。如何解决这个问题？如果你在按下
    Enter 键时按住 Alt 或 Option 键，Julia 将允许你继续编写代码。
- en: 'To add documentation to your functions, you can use double-quoted or triple-quoted
    strings (" or """). Please keep in mind that this is different from adding a comment
    with the hash # symbol. Comments don’t get stored in the Julia help system.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '要给你的函数添加文档，你可以使用双引号或三引号字符串 (" 或 """)。请记住，这与使用井号 # 符号添加注释是不同的。注释不会存储在 Julia
    帮助系统中。'
- en: 'Triple quotation and double quotation work slightly different. For instance
    if you want to use double quotes inside double-quoted text you need to *escape*
    the quotes by using a backslash. That is not necessary for triple quotation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 三引号和双引号的工作方式略有不同。例如，如果你想在使用双引号的双引号文本中使用双引号，你需要使用反斜杠*转义*引号。对于三引号来说这不是必要的：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Your documentation does not need to match Julia syntax. For instance, you have
    used an arrow in the documentation to inform readers what sort of object the functions
    return:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你的文档不需要匹配 Julia 语法。例如，你已经在文档中使用箭头来告知读者函数返回的对象类型：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Put this new definition of Tank in a file together with FlexiTank, and reload
    your Julia REPL with it. You can organize this almost whatever way you like. I
    use a file called tank-interface.jl, which looks like the following (I’ve removed
    documentation strings for compactness):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个新的 Tank 定义与 FlexiTank 一起放入文件中，并用它重新加载你的 Julia REPL。你可以以几乎任何你喜欢的组织方式来做这件事。我使用一个名为
    tank-interface.jl 的文件，如下所示（为了简洁，我已删除文档字符串）：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s explore what error messages appear this time while attempting to refill
    the flexi tank:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索在尝试重新填充柔性罐时出现的错误信息：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this case, you get a better error message. Julia lets us know that totalmass
    is indeed a function, but it lacks a method for the FlexiTank type. By checking
    which methods exist, you can deduce that a method dealing with the FlexiTank type
    is necessary:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你会得到一个更好的错误信息。Julia 通知我们，totalmass 确实是一个函数，但它缺少 FlexiTank 类型的方法。通过检查存在哪些方法，你可以推断出需要一个处理
    FlexiTank 类型的方法：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To enter the Julia help system, hit the ? key, as discussed in chapter 2:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入 Julia 帮助系统，按 ? 键，如第 2 章所述：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Usually, you would provide a guide to your library to explain how developers
    should use it. This guide explains what interfaces exist and how to implement
    these interfaces.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会提供一个库指南来解释开发者应该如何使用它。这个指南解释了存在哪些接口以及如何实现这些接口。
- en: 'In a statically typed language, such as Java, the compiler and a sophisticated
    IDE^([2](#pgfId-1013929)) can inform developers about the required methods to
    implement and their arguments. Since Julia is a dynamically typed language, you
    don’t have this luxury. You must adequately document your functions, so other
    developers know what arguments are expected and what the functions should return.
    As the following example shows, you can press the Tab key before you have finished
    writing a function call to get a list of methods and their arguments that match
    what you have written:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态类型语言，例如Java中，编译器和复杂的IDE^([2](#pgfId-1013929))可以通知开发者需要实现的方法及其参数。由于Julia是动态类型语言，您没有这样的便利。您必须充分记录您的函数，以便其他开发者知道预期的参数以及函数应该返回什么。以下示例显示，在完成函数调用之前，您可以按Tab键以获取与您所写内容匹配的方法及其参数列表：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Press tab, and available methods pop up.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 按Tab键，可用的方法会弹出。
- en: However, this strategy is useless for totalmass and drymass, as these functions
    don’t have any attached methods. That is why it is essential to document required
    arguments for these functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种策略对totalmass和drymass没有用，因为这些函数没有任何附加的方法。这就是为什么记录这些函数的必需参数至关重要。
- en: 12.3 Interfaces by convention
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 习惯用法接口
- en: Not all interfaces in Julia are connected to a specific abstract type, as demonstrated
    in the previous example. For instance, there is an *iteration* interface. If you
    implement this interface, you will be able to iterate over your collection using
    a for loop. This will also make it possible to use it with functions, such as
    map, reduce, and filter, which operate on iterable collections.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中的接口并不都与特定的抽象类型相关联，如前例所示。例如，有一个*迭代*接口。如果您实现此接口，您将能够使用for循环遍历您的集合。这将使您能够使用map、reduce和filter等函数，这些函数在可迭代集合上操作。
- en: 'The iteration interface is not represented by any particular abstract type
    you need to implement. Rather it is informally described. You are, at a minimum,
    expected to extend the iterate function for your collection type with the following
    methods:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代接口不是由任何特定的抽象类型表示，而是非正式地描述的。您至少需要扩展您的集合类型的iterate函数，以下方法：
- en: '| Required methods | Purpose |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 必需方法 | 目的 |'
- en: '| iterate(iter) | First item and initial state |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| iterate(iter) | 第一个项和初始状态 |'
- en: '| iterate(iter, state) | Current item and next state |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| iterate(iter, state) | 当前项和下一个状态 |'
- en: 'There are several of these methods, which are documented thoroughly in the
    official Julia documentation. The following are the most useful ones:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种这样的方法，这些方法在官方Julia文档中得到了详细记录。以下是最有用的几个：
- en: '| Optional methods | Purpose |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 可选方法 | 目的 |'
- en: '| IteratorSize(IterType) | Indicate whether a collection has a known length
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| IteratorSize(IterType) | 指示集合是否有已知长度 |'
- en: '| eltype(IterType) | The type of each element |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| eltype(IterType) | 每个元素的类型 |'
- en: '| length(iter) | The number of items in a collection |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| length(iter) | 集合中的项目数量 |'
- en: I will cover two different rocket-related examples in which you will implement
    some of these methods. In the first example, you will iterate over the engines
    a cluster. In the second, you will iterate over the stages of a multistage rocket.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我将涵盖两个不同的与火箭相关的示例，在这些示例中，您将实现其中的一些方法。在第一个示例中，您将遍历集群中的发动机。在第二个示例中，您将遍历多级火箭的阶段。
- en: 12.4 Implementing engine cluster iteration
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 实现发动机集群迭代
- en: In chapter 8, we defined a cluster of engines like the following.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，我们定义了一个类似以下的发动机集群。
- en: Listing 12.5 Old definition of rocket engine cluster
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.5 火箭发动机集群的旧定义
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With this definition all the engines in the cluster have to be of the same
    type. But what if you want a mix of different types of engines? Some rockets actually
    do have a mix of engines, and you cannot model such rockets with the given Cluster
    type definition. To solve this, you will turn Cluster into an abstract type instead.
    This abstract type will have two concrete subtypes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，集群中的所有发动机都必须是同一类型。但如果你想要不同类型发动机的混合呢？一些火箭实际上确实有发动机的混合，而您不能使用给定的Cluster类型定义来模拟这样的火箭。为了解决这个问题，您将Cluster转换为抽象类型。这个抽象类型将有两个具体的子类型：
- en: A UniformCluster, representing identical engines
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个UniformCluster，表示相同的发动机
- en: A MixedCluster, representing a mix of different engines
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个MixedCluster，表示不同发动机的混合
- en: But why introduce a second level of abstraction? Why can’t UniformCluster and
    MixedCluster be direct subtypes of Engine? As you develop your code the benefits
    of this layer of abstraction will become clear. Open the source code for your
    Cluster type from chapter 8, and modify it with the following code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么引入第二层抽象？为什么UniformCluster和MixedCluster不能直接成为Engine的子类型？随着您代码的发展，这一层抽象的好处将变得明显。打开第8章中Cluster类型的源代码，并使用以下代码进行修改。
- en: Listing 12.6 Redesigned cluster type hierarchy
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.6 重新设计的集群类型层次结构
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ A vector of elements that are subtypes of Engine
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个元素为Engine子类型的向量
- en: ❷ Define function checking if engine e is the same as the first engine.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义一个检查引擎e是否与第一个引擎相同的函数。
- en: ❸ Check if all engines are of the same type.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查所有引擎是否为同一类型。
- en: ❹ Return a UniformCluster if all engines are of the same type.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果所有引擎类型相同，则返回UniformCluster。
- en: ❺ Return a MixedCluster if engines are of different types.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果引擎类型不同，则返回MixedCluster。
- en: You add Cluster methods, which look at the types of engines passed as arguments
    to determine whether a uniform or mixed cluster should be created. You use a couple
    of new tricks here.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您添加了Cluster方法，这些方法会查看传递给参数的引擎类型，以确定是否创建均匀或混合集群。您在这里使用了一些新技巧。
- en: The sametype function is defined inside the Cluster constructor. This means
    it has access to the engine argument, without having to pass it as an argument.
    This is beneficial because all is a higher-order function expecting a function
    taking a single argument and returning true or false. The following are some examples
    to give you an idea.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: sametype函数是在Cluster构造函数内部定义的。这意味着它有权访问引擎参数，而无需将其作为参数传递。这很有益，因为all是一个接受单个参数并返回true或false的高阶函数。以下是一些示例，以给您一个想法。
- en: Listing 12.7 Demonstrating usage of the all function
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.7 all函数的使用演示
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Every number is even in this case.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在这种情况下，每个数字都是偶数。
- en: ❷ The number 3 is not even.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 数字3不是偶数。
- en: 'By hiding the type used to represent a cluster, you can create the illusion
    that there is only one Cluster type. That you use two different types internally
    becomes an implementation detail. Let’s demonstrate how this works in the Julia
    REPL:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过隐藏表示集群使用的类型，您可以产生只有一种Cluster类型的错觉。您内部使用两种不同的类型成为实现细节。让我们通过Julia REPL演示它是如何工作的：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Since all arguments are of the same type you get a UniformCluster.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由于所有参数都是同一类型，因此您得到一个UniformCluster。
- en: ❷ You need a mixed cluster to hold a Merlin and Rutherford engine.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 您需要一个混合集群来容纳Merlin和Rutherford引擎。
- en: You will need to redefine your Isp, mass, and thrust methods with these changes.
    Remember that in chapter 8 these functions were defined as
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要根据这些更改重新定义您的Isp、质量和推力方法。请记住，在第8章中，这些函数被定义为
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Implement an *iterable* interface on these cluster types to allow you to write
    only one implementation of mass and thrust, which works for both cluster types.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些集群类型上实现一个*可迭代*接口，以便您只需编写一个质量推力和实现，它适用于两种集群类型。
- en: 12.4.1 Making clusters iterable
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.1 使集群可迭代
- en: 'You can try to iterate over a cluster, as it is currently defined but will
    not work:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试迭代一个集群，如目前定义的那样，但不会工作：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The Julia JIT compiler will convert this for loop into a lower-level while loop,
    which looks like the code in the following listing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Julia JIT编译器会将这个for循环转换为更低级的while循环，其代码如下所示。
- en: Listing 12.8 For loop implementation in Julia
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.8 Julia中的for循环实现
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Begin iteration.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 开始迭代。
- en: ❷ Check if you reached the end of the iteration.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查是否到达迭代的末尾。
- en: ❸ Extract values in the next tuple.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从下一个元组中提取值。
- en: ❹ Advance to the next element in collection.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在集合中推进到下一个元素。
- en: So your for loop does not work because you have not yet implemented the required
    iterate methods. The following listing shows how to add these methods to allow
    iteration over the engines making up a mixed cluster.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您的for循环不起作用，因为您尚未实现所需的iterate方法。以下列表显示了如何添加这些方法，以便可以对混合集群的引擎进行迭代。
- en: Listing 12.9 Implementing the iteration interface for MixedCluster
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.9 为MixedCluster实现迭代接口
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Add methods to the iterate function defined in the Base module.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 向Base模块中定义的iterate函数添加方法。
- en: ❷ Used to start the iteration
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于启动迭代
- en: ❸ Advance to the next element in the collection.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将集合中的下一个元素向前推进。
- en: ❹ Return nothing to indicate you reached the end.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 返回nothing以指示您已到达末尾。
- en: ❺ The current element and index of the next element
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当前元素和下一个元素的索引
- en: 'Importing the iterate function from Base is important, since the for loop is
    made to use iterate from Base and not an iterate function of the same name defined
    in another module. When you start iteration you need to return the very first
    element and the index of the next element. Thus when you start iteration you must
    return the index of the second element. That is why you return cluster.engines[1],
    2. You can call iterate manually to get a sense of how it works:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从Base导入iterate函数很重要，因为for循环是为了使用Base中的iterate而设计的，而不是在其他模块中定义的同名iterate函数。当你开始迭代时，你需要返回第一个元素和下一个元素的索引。因此，当你开始迭代时，你必须返回第二个元素的索引。这就是为什么你返回cluster.engines[1],
    2。你可以手动调用iterate来了解它是如何工作的：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Get the initial state.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取初始状态。
- en: ❷ Extract the engine and next index from the next tuple.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从下一个元组中提取发动机和下一个索引。
- en: ❸ Fetch the next engine.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取下一个发动机。
- en: ❹ It has reached the end, so next equals nothing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 已经到达末尾，所以next等于nothing。
- en: Now the implementation of iteration for UniformCluster in the following listing
    should make more sense.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在以下列表中关于UniformCluster迭代的实现应该更加清晰。
- en: Listing 12.10 Implementing iteration for UniformCluster
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.10 实现UniformCluster的迭代
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can see that this implementation is simpler because you are always returning
    the same engine. The i index is only used to keep track of whether you have reached
    the end of the iteration. Because both Cluster types now support iteration, you
    can implement mass and thrust in terms of iteration, as in the following listing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这种实现更简单，因为你总是返回相同的发动机。i索引仅用于跟踪你是否已经到达迭代的末尾。因为现在Cluster类型都支持迭代，你可以通过迭代来实现质量和推力，如下面的列表所示。
- en: Listing 12.11 Defining mass and thrust for clusters
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.11 为集群定义质量和推力
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How does this work? The sum function iterates over the collection supplied as
    the second argument. sum will apply the function provided as the first argument
    to each element it iterates over. sum(thrust, cluster) is equivalent to writing
    sum(map(thrust, cluster)). Neither call will work until you implement length for
    clusters (listing 12.12); otherwise Julia cannot figure out how large the result
    vector should be before starting iteration.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？sum函数遍历作为第二个参数提供的集合。sum将提供的第一个参数函数应用于它遍历的每个元素。sum(thrust, cluster)等价于编写sum(map(thrust,
    cluster))。这两个调用在实现列表12.12（为集群实现长度）之前都不会工作；否则，Julia无法在开始迭代之前确定结果向量的长度。
- en: Listing 12.12 Giving Julia a way to figure out how many engines are in a cluster
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.12 为Julia提供一种确定集群中发动机数量的方法
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Extend the length function to support cluster types.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将长度函数扩展以支持集群类型。
- en: Remember, there are sum methods that take both one and two arguments. For Isp
    you cannot sum values; rather you would have to find an average, as follows.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，有一些求和函数可以接受一个或两个参数。对于比冲（Isp），你不能直接求和值；相反，你需要找到一个平均值，如下所示。
- en: Listing 12.13 Calculating the specific impulse of a cluster of engines
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.13 计算发动机集群的比冲
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code also lets the collection support length, which is sensible for most
    collections to support. Naturally, developers want to be able to check how many
    elements are contained within a collection.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码还让集合支持长度，这对于大多数集合来说是有意义的。自然地，开发者希望能够检查集合中包含了多少个元素。
- en: With these changes, it should be more apparent why you made Cluster an abstract
    type. It allowed you to share your implementation of mass, Isp, and thrust across
    multiple cluster types. The usage of abstract types is a good way of achieving
    code reuse.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，应该更明显地看出你为什么将Cluster定义为抽象类型。它允许你在多个集群类型之间共享质量、比冲和推力的实现。使用抽象类型是实现代码重用的一种好方法。
- en: Next you will explore iterating across rocket stages. This will be a bit different,
    since you cannot access rocket stages by index.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将探索遍历火箭阶段。这会有点不同，因为你不能通过索引访问火箭阶段。
- en: 12.5 Implementing rocket stage iteration
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 实现火箭阶段迭代
- en: The following listing shows the definition of a rocket stage used in chapter
    8.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了第8章中使用的火箭阶段的定义。
- en: Listing 12.14 Definition of a rocket stage
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.14 火箭阶段的定义
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that you don’t have a vector from which you can pull individual stages.
    Thus, the element in the tuple you return from iterate will not be an integer
    index.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你没有可以从其中提取单个阶段的向量。因此，从iterate返回的元组中的元素不会是整数索引。
- en: Listing 12.15 Initiate iteration of a staged rocket
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.15 启动分阶段火箭的迭代
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The code in listing 12.15 handles two different cases:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.15中的代码处理了两种不同的情况：
- en: A staged rocket that actually has a payload
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实际有有效载荷的分级火箭
- en: All other rockets that are not staged and thus have no next element
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他未分级且因此没有下一个元素的火箭
- en: This means you don’t have to add iterate for every possible subtype of Rocket.
    Instead, you make Rocket types default to not supporting iteration. You also need
    to support advancing through the collection of stages, which is what the iteration
    methods in the following listing will do.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不必为Rocket的每个可能的子类型添加iterate。相反，你使Rocket类型默认不支持迭代。你还需要支持通过阶段集合的推进，这正是以下列表中的迭代方法将要做的。
- en: Listing 12.16 Advance to the next stage of the rocket
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.16 前进到火箭的下一阶段
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Called when next stage is also a staged rocket
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当下一阶段也是分级火箭时被调用
- en: ❷ Default handling of iterating to next stage
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 默认处理迭代到下一阶段
- en: You have defined these new methods such that you default to ending the iteration.
    That is accomplished by specifying the type of current as Rocket. Then you make
    an exception for when current is of type StagedRocket. In this case you know there
    is a nextstage field, which you can access to advance to the next element in the
    collection.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经定义了这些新方法，以便默认结束迭代。这是通过指定current的类型为Rocket来实现的。然后你对current是StagedRocket类型的情况进行例外处理。在这种情况下，你知道有一个nextstage字段，你可以访问它来前进到集合中的下一个元素。
- en: Thus, while the first example with the Cluster type makes it look as if current
    is an integer index, that is not really true. The second argument to iterate does
    not need to be an integer. It can be any data that helps you remember your current
    position in a collection you are iterating over. You can test iteration with a
    small program by putting the code in the following listing in the REPL or a file
    you load into the REPL.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然Cluster类型的第一个例子使current看起来像是一个整数索引，但这并不完全正确。iterate的第二个参数不需要是整数。它可以是你迭代集合中当前位置的任何数据。你可以通过将以下列表中的代码放入REPL或加载到REPL中的文件中来测试迭代。
- en: Listing 12.17 Iterating over rocket stages
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.17 遍历火箭阶段
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Make sure you have loaded your rocket code into your REPL first. When you run
    this program you should get the following output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你首先将你的火箭代码加载到你的REPL中。当你运行这个程序时，你应该得到以下输出：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This shows that iteration within a for loop works. However you cannot use it
    with functions such as sum, map, and collect. The following REPL session shows
    a failed attempt at using the map and collect functions on the booster stage.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明在for循环中迭代是可行的。然而，你不能与sum、map和collect等函数一起使用。以下REPL会话显示了在助推阶段使用map和collect函数的失败尝试。
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Making this work will be the next step.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使其工作将是下一步。
- en: 12.5.1 Adding support for map and collect
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5.1 添加对map和collect的支持
- en: map and collect fail because you lack implementation for a length method for
    the Rocket type. To develop an understanding of this problem, I will first show
    a naive solution, as follows.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: map和collect失败是因为你缺少Rocket类型的length方法的实现。为了理解这个问题，我将首先展示一个原始解决方案，如下所示。
- en: Listing 12.18 Calculating a number of stages in a staged rocket
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.18 计算分级火箭的阶段数量
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: While this works, it has poor performance characteristics. The time it takes
    to calculate the length of a stage rocket is proportional to its length. Such
    algorithms are referred to as *linear* or O(n) in big-O notation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可行，但其性能特性较差。计算分级火箭长度的所需时间与其长度成正比。这类算法在*大O表示法*中被称为*线性*或O(n)。
- en: Big-O notation
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 大O表示法
- en: In computer science, we often talk about memory requirements and processing
    power of data structures and algorithms in what is called *big-O notation*. If
    the time it takes to find an item with an algorithm is linear (e.g., it depends
    on the number of elements in a collection), then we write that as O(n). The n
    refers to n elements in your whole collection. Thus, if n doubles, then an O(n)
    algorithm will take twice the amount of time to finish. An algorithm that uses
    a for loop to look at every element is referred to as a O(n) algorithm, and an
    algorithm with constant time is written as O(1).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，我们经常讨论数据结构和算法的内存需求和处理能力，这被称为*大O表示法*。如果一个算法查找一个项目所需的时间是线性的（例如，它依赖于集合中的元素数量），那么我们将其写为O(n)。这里的n指的是你整个集合中的n个元素。因此，如果n加倍，那么O(n)算法完成所需的时间也将加倍。使用for循环查看每个元素的算法被称为O(n)算法，而具有恒定时间的算法则写为O(1)。
- en: Julia gives us a way of telling its iteration machinery that there is no effective
    method for determining the length of the collection you iterate over. You do that
    by implementing an IteratorSize method, as follows.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 给我们一种方法来告诉它的迭代机制，没有有效的方法来确定你迭代的集合的长度。你可以通过实现一个 IteratorSize 方法来实现这一点，如下所示。
- en: Listing 12.19 Add the SizeUnknown trait to the Rocket subtypes
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.19 将 SizeUnknown 特性添加到 Rocket 子类型
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This concept is not easy to grasp at first glance. It is what we call the *holy
    traits pattern*. Patterns in programming refer to particular ways of solving problems
    that get reused in many different contexts. In Julia you use the holy traits pattern
    to add traits to types. A *trait* is like an ability or characteristic (figure
    12.3). For instance, an archer might have the CanShoot trait; a knight could have
    the CanRide trait; and a horse archer, such as a Mongol warrior, could have both
    the CanShoot and CanRide traits.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念一开始并不容易理解。我们称之为“神圣特性模式”。编程中的模式指的是在许多不同情境中重复使用的问题解决特定方式。在 Julia 中，你使用神圣特性模式向类型添加特性。一个“特性”就像是一种能力或特征（图
    12.3）。例如，一个弓箭手可能有 CanShoot 特性；一个骑士可能有 CanRide 特性；而像蒙古战士这样的弓箭手，则可能同时拥有 CanShoot
    和 CanRide 特性。
- en: '![12-03](../Images/12-03.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![12-03](../Images/12-03.png)'
- en: Figure 12.3 The IteratorSize trait and its subtypes
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 IteratorSize 特性和其子类型
- en: Iterable Julia collections can have different traits, with one of these traits
    being IteratorSize. How exactly does this work? When you call collect(rocket),
    this gets translated to the following code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代的 Julia 集合可以有不同的特性，其中之一就是 IteratorSize。这究竟是如何工作的呢？当你调用 collect(rocket) 时，这会被转换成以下代码。
- en: Listing 12.20 Implementation of the collect function
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.20 collect 函数的实现
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Attached to the _collect function are several different methods for dealing
    with collections with different traits. You can see here that the behavior of
    collect depends on two different traits: IteratorEltype and IteratorSize. You
    don’t always have to register traits for your collections because the defaults
    are fine. The following listing shows how the default for IteratorSize is defined.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: _collect 函数附带了处理具有不同特性的集合的几种不同方法。你可以看到，collect 的行为取决于两个不同的特性：IteratorEltype
    和 IteratorSize。你不必总是为你的集合注册特性，因为默认值就很好。以下列表显示了 IteratorSize 的默认值是如何定义的。
- en: Listing 12.21 Default IteratorSize for Julia collections
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.21 Julia 集合的默认 IteratorSize
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When the IteratorSize trait is defined as HasLength, Julia will call length
    to determine the size of the result array produced from collect. When you define
    this trait as SizeUnknown, Julia will instead use an empty array for output that
    grows as needed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当 IteratorSize 特性被定义为 HasLength 时，Julia 将调用 length 来确定从 collect 生成的结果数组的长度。当你将此特性定义为
    SizeUnknown 时，Julia 将使用一个空数组作为输出，该数组根据需要增长。
- en: 'In Julia, traits are defined as abstract types. The values a trait can have
    are determined by a concrete subtype. HasLength and SizeUnknown are both subtypes
    of IteratorSize. You may recognize a similar pattern from chapter 9: both the
    convert and promote_rule functions take types as arguments; however in this case
    you add the little twist of describing the argument type as Type{<:Rocket}.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，特性被定义为抽象类型。特性可以具有的值由具体子类型确定。HasLength 和 SizeUnknown 都是 IteratorSize
    的子类型。你可能从第 9 章中认出了类似的模式：convert 和 promote_rule 函数都接受类型作为参数；然而在这种情况下，你添加了一个小的变化，即描述参数类型为
    Type{<:Rocket}。
- en: 'The subtype operator <: is used to indicate that *all* subtypes of Rocket have
    the value SizeUnknown for the IteratorSize trait. I know this is a mouthful, but
    fortunately, it is something you can usually look up when needed. It is more important
    to be aware of traits than to remember exactly how they work. Having defined the
    IteratorSize trait for Rocket, you can now use map, sum, and other higher-order
    functions operating on collections:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型运算符 `<:` 用于表示所有 Rocket 的子类型都具有 IteratorSize 特性的 SizeUnknown 值。我知道这听起来可能有些复杂，但幸运的是，当你需要时通常可以查阅。了解特性比记住它们是如何工作的更重要。为
    Rocket 定义了 IteratorSize 特性后，你现在可以使用 map、sum 和其他在集合上操作的高阶函数：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Remember to define the second and third state if you haven’t already.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果还没有定义，请记住定义第二和第三状态。
- en: ❷ Get the mass of every stage.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取每个阶段的重量。
- en: ❸ Add up the thrust of all engines on the multistage rocket.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将多级火箭上所有引擎的推力相加。
- en: The most basic operation a collection needs to be able to support is iteration.
    You have looked at how that is achieved on two different types of collections.
    The rocket clusters behave mostly like arrays; however, your staged rocket behaves
    more like a data structure called a *linked list*. In the next section, you will
    compare linked lists and arrays to better understand how different collection
    types have different tradeoffs.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 集合需要支持的最基本操作是迭代。你已经看到了如何在两种不同的集合类型上实现这一点。火箭集群的行为大多像数组；然而，你的分阶段火箭更像是一种称为 *链表*
    的数据结构。在下一节中，你将比较链表和数组，以更好地理解不同的集合类型有不同的权衡。
- en: 12.6 Comparison of linked lists and arrays
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6 链表和数组的比较
- en: 'The way you link stages to each other through nextstage, is the same as how
    a *linked list* works: they are often contrasted with arrays. With an array, you
    can quickly determine the length or look up an arbitrary element, given an index.
    You will add support for index-based lookup to your Cluster subtypes and later
    contrast it with the linked list of rocket stages.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过 nextstage 将阶段相互链接的方式与 *链表* 的工作方式相同：它们通常与数组进行对比。使用数组时，你可以快速确定长度或根据索引查找任意元素。你将为
    Cluster 子类型添加基于索引的查找支持，并在稍后将其与火箭阶段的链表进行比较。
- en: Recalling that for loops actually get turned into while loops, there is actually
    a similar case when accessing and replacing elements in an array. Say you have
    created a cluster in which you access elements.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，for 循环实际上会被转换为 while 循环，在访问和替换数组中的元素时也存在类似的情况。假设你创建了一个集群，在其中访问元素。
- en: Listing 12.22 Index-based access
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.22 基于索引的访问
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Read the first element.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 读取第一个元素。
- en: ❷ Change the second element.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更改第二个元素。
- en: The code in listing 12.22 will be translated by the Julia compiler through several
    stages. One of these stages, called *lowering*, turns this code into the following.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.22 中的代码将通过 Julia 编译器经过几个阶段进行翻译。其中一个阶段，称为 *lowering*，将此代码转换为以下形式。
- en: Listing 12.23 Index-based access under the hood
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.23 基于索引的访问内部机制
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Thus to make your Cluster subtypes support accessing elements by index, you
    need to add methods to the getindex and setindex! functions found in the Base
    module. These are the functions used for implementing element access with square
    brackets: [].'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使你的 Cluster 子类型支持通过索引访问元素，你需要向 Base 模块中找到的 getindex 和 setindex! 函数添加方法。这些是用于实现方括号中元素访问的函数：[]。
- en: Listing 12.24 Adding index-based access to rocket clusters
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.24 向火箭集群添加基于索引的访问
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Get the ith element in the cluster.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取集群中的第 i 个元素。
- en: ❷ Set the ith element in cluster to egn.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将集群中的第 i 个元素设置为 egn。
- en: ❸ You don’t care about the index for a UniformCluster.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对于 UniformCluster，你不需要关心索引。
- en: You can see some differences between MixedCluster and UniformCluster, and you
    can easily support getting elements from a UniformCluster because every element
    is the same. However, you cannot support setting an element because it would no
    longer be uniform. Hence, you have not added a method for setindex! dealing with
    the UniformCluster. While you could define index-based access for a linked list,
    it isn’t very efficient, as shown in the following listing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 MixedCluster 和 UniformCluster 之间的一些差异，你可以轻松地支持从 UniformCluster 中获取元素，因为每个元素都是相同的。然而，你不能支持设置元素，因为这将不再保持均匀。因此，你没有为
    UniformCluster 添加处理 setindex! 的方法。虽然你可以为链表定义基于索引的访问，但如以下列表所示，这并不高效。
- en: Listing 12.25 Accessing rocket stage by index
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.25 通过索引访问火箭阶段
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ _ is used when you don’t care about the name of a variable.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当你不在乎变量的名称时使用 `_`。
- en: Such a lookup is an O(n) operation (linear). The more stages you have, the more
    times the for loop has to be repeated. A lookup in an array, in contrast, is a
    O(1) operation. That is another way of saying it is a *constant operation*. The
    time to look up an element in an array with three elements is exactly the same
    as in an array with millions of elements.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的查找是一个 O(n) 操作（线性）。阶段越多，for 循环需要重复的次数就越多。相比之下，在数组中的查找是一个 O(1) 操作。这就是说它是一个
    *常数操作*。在包含三个元素的数组中查找元素的时间与在包含数百万元素的数组中查找元素的时间完全相同。
- en: However, you can add support for other types of operations that work faster.
    Let’s look at some of the most common operations supported in Julia for adding
    elements to collections.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以添加对其他类型操作的支持，这些操作运行得更快。让我们看看 Julia 中支持的一些最常见的操作，用于向集合中添加元素。
- en: 12.6.1 Adding and removing elements
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6.1 添加和删除元素
- en: Arrays allow you to add elements to the front and back of the array as well
    as remove elements from both ends. Notice in the examples how push! and pushfirst!
    allow you to add more than one element in a single function call.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 数组允许您向数组的末尾添加元素，也可以从两端删除元素。注意在示例中，push! 和 pushfirst! 如何允许您在单个函数调用中添加多个元素。
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Create array xs with one element 7.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建包含一个元素 7 的数组 xs。
- en: ❷ Add 9 and 11 to the back of the array.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 9 和 11 添加到数组的末尾。
- en: ❸ Add 3 and 5 to the front of the array.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 3 和 5 添加到数组的开头。
- en: ❹ Remove the last element.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 移除最后一个元素。
- en: ❺ Remove the first element.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 移除第一个元素。
- en: Figure 12.4 may help clarify how these operations work.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 可能有助于阐明这些操作的工作原理。
- en: '![12-04](../Images/12-04.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![12-04](../Images/12-04.png)'
- en: Figure 12.4 Adding and removing elements from an array
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 从数组中添加和删除元素
- en: For linked lists, removing and adding elements to the front is effective (figure
    12.5). Thus, you can support operations like pushfirst! and popfirst!. However,
    you need to make some adjustments and preparations to make it more convenient
    to implement these functions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于链表，从前面添加和删除元素是有效的（见图 12.5）。因此，您可以支持 pushfirst! 和 popfirst! 等操作。然而，您需要做一些调整和准备工作，以便更方便地实现这些函数。
- en: '![12-05](../Images/12-05.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![12-05](../Images/12-05.png)'
- en: Figure 12.5 Terminated linked list of staged rockets
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 终止的火箭级链表
- en: When dealing with linked lists, it is useful to have something obvious to terminate
    a chain of objects. Often this will be a nothing object, but with the multistage
    rocket, an emptypayload would be a natural fit.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理链表时，有一个明显的终止对象链是很有用的。通常这将是 nothing 对象，但在多级火箭中，一个 emptypayload 将是一个自然的选择。
- en: Listing 12.26 An empty payload object to terminate a list of rocket stages
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.26 一个空的载荷对象，用于终止火箭级列表
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ No fields
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 没有字段
- en: ❷ Every instance has the same objects as with nothing.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每个实例都有与没有任何东西时相同的对象。
- en: ❸ Implement the rocket interface.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 实现火箭接口。
- en: Having a representation of an empty payload provides a number of advantages,
    such as having a sensible default constructor for a single-stage rocket, as shown
    in listing 12.26\. The example, however, is not quite done. A new type is needed
    and an existing one needs to be modified. StagedRocket was initially made immutable,
    which will hinder, for example, popfirst! from working, as you need to modify
    the nextstage field. You cannot modify fields on immutable objects (objects which
    cannot be changed).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 具有空载荷的表示提供了一些优势，例如为单级火箭提供一个合理的默认构造函数，如列表 12.26 所示。然而，示例尚未完成。需要一个新类型，并且需要修改现有类型。StagedRocket
    最初被设置为不可变的，这将阻碍例如 popfirst! 的操作，因为您需要修改 nextstage 字段。您不能修改不可变对象的字段（无法更改的对象）。
- en: Important Whenever you change a type definition, such as by making a struct
    mutable, you need to restart the Julia REPL. This is because Julia types are fixed;
    they cannot be modified at runtime like many other dynamic languages.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：每次更改类型定义，例如通过使结构可变，您都需要重新启动 Julia REPL。这是因为 Julia 类型是固定的；它们不能像许多其他动态语言那样在运行时修改。
- en: Next I will introduce the SpaceVehicle type (listing 12.27). Figure 12.6 shows
    how it is conceptually related to other rocket parts.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将介绍 SpaceVehicle 类型（列表 12.27）。图 12.6 显示了它在概念上与其他火箭部件的关系。
- en: '![12-06](../Images/12-06.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![12-06](../Images/12-06.png)'
- en: Figure 12.6 Rocket terminology overview
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 火箭术语概述
- en: The SpaceVehicle is the whole thing with all the rocket stages. This abstraction
    is useful to wrap around the stages, so you can keep track of where the first
    rocket stage starts. This is useful when implementing pushfirst! and popfirst!
    because it allows you to add and remove stages relative to something else.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: SpaceVehicle 是包含所有火箭级的整体。这种抽象有助于围绕级进行包装，以便您可以跟踪第一个火箭级开始的位置。这在实现 pushfirst! 和
    popfirst! 时很有用，因为它允许您相对于其他东西添加和删除级。
- en: Listing 12.27 New and modified type definitions
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.27 新的和修改的类型定义
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Change StagedRocket to mutable.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 StagedRocket 更改为可变的。
- en: ❷ You want nextstage to be changeable.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 您希望 nextstage 可以更改。
- en: ❸ Wrapper around rocket stages
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 火箭级的包装器
- en: ❹ Stage with the engines currently firing
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当前引擎正在燃烧的级
- en: 'With these type definitions in place, you have the foundation for implementing
    your popfirst! and pushfirst! methods (listing 12.28). Because they are standard
    functions for Julia collections, you import them from Base to extend them with
    methods dealing with your specific collection: SpaceVehicle.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些类型定义到位后，你就有了实现popfirst!和pushfirst!方法的基础（列表12.28）。因为它们是Julia集合的标准函数，所以你从Base导入它们，并通过处理你的特定集合SpaceVehicle的方法来扩展它们。
- en: Listing 12.28 Removing stages from the bottom
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.28 从底部移除阶段
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Check if more stages are left.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查是否还有剩余的阶段。
- en: ❷ Not allowed to pop stages from an empty space vehicle
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 不允许从空航天器中弹出阶段
- en: ❸ Discard the bottom stage.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 丢弃底部阶段。
- en: ❹ Unchain the discarded stage.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 解链被丢弃的阶段。
- en: ❺ The next stage becomes the active stage.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 下一个阶段变为活动阶段。
- en: ❻ Show what stage was discarded in REPL.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在REPL中显示被丢弃的阶段。
- en: 'The tail function requires some explanation. You add two methods: one for handling
    a StagedRocket and another for subtypes of Rocket. This is a simple way to check
    whether there are any stages left on the SpaceVehicle. Since the activestage field
    of SpaceVehicle is of type Rocket, you cannot be guaranteed that a nextstage exists.
    Why not make it a StagedRocket then? Because you want to allow stages to be detached
    until you have only a payload representing a satellite or crew capsule left.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尾部功能需要一些解释。你添加了两种方法：一种用于处理StagedRocket，另一种用于Rocket的子类型。这是一种简单的方式来检查SpaceVehicle上是否还有剩余的阶段。由于SpaceVehicle的activestage字段是Rocket类型，你不能保证存在下一个阶段。为什么不将其改为StagedRocket呢？因为你希望允许阶段在只剩下代表卫星或乘员舱的有效载荷之前被分离。
- en: Listing 12.29 Adding a stage to the bottom
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.29 在底部添加阶段
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ The current stage becomes the next stage.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当前阶段变为下一个阶段。
- en: ❷ The new stage becomes the current stage.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 新阶段变为当前阶段。
- en: 'With pushfirst! you put a new stage r in front of the existing active stage
    (listing 12.29). The old active stage changes its role to become the next stage
    of the new active stage. You can make all these edits and modifications and spin
    up a new REPL to get a feel for how these new functions work. To help make it
    more visually distinct, I will present an example of a rocket with stages named
    a, b, and c. Each stage has bigger tanks and a bigger engine than the previous
    one:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pushfirst!，你将新阶段r放在现有活动阶段之前（列表12.29）。旧的活动阶段改变其角色，成为新活动阶段的下一个阶段。你可以进行所有这些编辑和修改，并启动一个新的REPL来感受这些新函数的工作方式。为了使其更直观，我将展示一个名为a、b和c的火箭阶段示例。每个阶段都比前一个阶段有更大的油箱和更大的引擎：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The example begins by creating a space vehicle with a small 40-kg payload:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 示例开始于创建一个带有小型40公斤有效载荷的航天器：
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, pushfirst! is used to add stages to this space vehicle:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用pushfirst!向这艘航天器添加阶段：
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: I have edited the REPL output by adding whitespace and indentation to more clearly
    show the structure being created while adding more stages. You can see how the
    smallest stage is at the deepest indentation level. That is because it is nested
    deepest. The booster stage with the large engine and tank is at the bottom.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过添加空白和缩进来编辑REPL输出，以更清楚地显示在添加更多阶段时创建的结构。你可以看到最小的阶段位于最深的缩进级别。这是因为它是嵌套最深的。带有大型引擎和油箱的助推阶段位于底部。
- en: 'You can knock off all these stages again using the popfirst! function:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用popfirst!函数再次移除所有这些阶段：
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: On each pop, the stage that was discarded is returned. Notice how the largest
    stage with the Merlin engine comes off first. The next stage involves the medium-sized
    tank. The top stage with the small tank comes last. Finally, the space vehicle
    only containing the initial 40-kg payload remains.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次pop操作中，被丢弃的阶段会被返回。注意，带有Merlin引擎的最大阶段首先脱落。下一个阶段涉及中等大小的油箱。带有小油箱的顶部阶段最后脱落。最后，只剩下包含初始40公斤有效载荷的航天器。
- en: 12.7 Utility of custom types
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.7 自定义类型的实用性
- en: A linked list isn’t used often in actual code, as arrays are more versatile
    and have better performance most of the time. However, linked lists are useful
    to understand, as the principles applied here apply to more complex data structures.
    Tree structures and graphs also link elements together.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际代码中，链表并不常用，因为数组更灵活，并且在大多数情况下性能更好。然而，理解链表是有用的，因为这里应用的原则也适用于更复杂的数据结构。树结构和图也链接元素。
- en: While you are unlikely to spend much time writing completely generic data structures,
    such as arrays, linked lists, and dictionaries, you will find it helpful to turn
    custom data structures (rocket stages) into collections. Once a data structure
    implements the interface of a well-established category of types, such as a collection,
    you make a host of functions applicable to them. For example, by making a staged
    rocket iterable, you can suddenly use map, reduce, filter, sum, collect, and other
    functions with it for free.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能不会花太多时间编写完全通用的数据结构，例如数组、链表和字典，但将自定义数据结构（火箭阶段）转换为集合会很有帮助。一旦数据结构实现了已建立类型类别（如集合）的接口，你就可以使大量函数适用于它们。例如，通过使分阶段火箭可迭代，你就可以突然免费使用map、reduce、filter、sum、collect和其他函数。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: For loops and index access with square brackets both translate to Julia function
    calls such as iterate, getindex, and setindex!.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方括号进行循环和索引访问都转换为Julia函数调用，例如iterate、getindex和setindex!。
- en: Collections must, at a minimum, support iterations. That is done by implementing
    two iterate methods for your collection type—one to start the iteration and another
    to get the next element.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合至少必须支持迭代。这是通过为你的集合类型实现两个iterate方法来完成的——一个用于开始迭代，另一个用于获取下一个元素。
- en: Julia types can be configured with different capabilities using the holy traits
    pattern. Julia collections can be configured with different traits, such as IteratorSize
    and IteratorEltype.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia类型可以使用神圣的特质模式配置不同的能力。Julia集合可以使用不同的特质配置，例如IteratorSize和IteratorEltype。
- en: Collections for which calculating the number of elements is slow should configure
    IteratorSize to SizeUnknown.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于计算元素数量较慢的集合，应将IteratorSize配置为SizeUnknown。
- en: Arrays offer fast access of elements at any index but don’t allow quick insertion
    of elements except at the end of the array.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组可以快速访问任何索引处的元素，但除了在数组末尾外，不允许快速插入元素。
- en: Linked lists have slow access of elements by index but fast insertion and removal
    of elements at the front.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表通过索引访问元素较慢，但在前端的元素插入和删除较快。
- en: Implementing well established Julia interfaces can make your own data types
    more versatile. For example, by turning your data structure into a Julia collection,
    you can leverage many of the prebuilt Julia-collection-related functions.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现已建立的Julia接口可以使你的数据类型更加灵活。例如，通过将你的数据结构转换为Julia集合，你可以利用许多预构建的与Julia集合相关的函数。
- en: '* * *'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)Markdown is a lightweight markup language for creating formatted text using
    a plain-text editor.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: (1.)Markdown是一种轻量级标记语言，用于使用纯文本编辑器创建格式化文本。
- en: ^(2.)IDE is short for *integrated development environment*. Visual Studio and
    IntelliJ IDEA are some examples of IDEs.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: (2.)IDE是集成开发环境的缩写。Visual Studio和IntelliJ IDEA是IDE的一些例子。
