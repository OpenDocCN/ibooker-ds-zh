- en: 9  Testing Express Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9  测试 Express 应用程序
- en: Writing reliable code can be difficult. Even small software can have be too
    complex for one person, which can create bugs. Developers have come up with a
    number of tricks to try to squash these errors. Compilers and syntax checkers
    automatically scan your code for potential bugs; peer code reviews let other people
    look at what's written to see if they can spot errors; style guides can keep teams
    of developers on the same page. These are all helpful tricks we play that keep
    our code more reliable and bug-free.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写可靠的代码可能很困难。即使是小型软件也可能过于复杂，以至于一个人难以处理，这可能导致错误。开发者们已经想出了一些技巧来尝试消除这些错误。编译器和语法检查器会自动扫描你的代码以查找潜在的错误；同行代码审查让其他人查看所写内容，看看他们是否能发现错误；风格指南可以帮助开发团队保持一致。这些都是我们用来使代码更可靠、更无错误的帮助性技巧。
- en: Another powerful way to tackle bugs is with automated testing. Automated testing
    lets us codify (literally!) how we want our software to behave, and lets us say
    “My code works!” with much more confidence. It lets us refactor code without worrying
    if we broke something, and gives us easy feedback about where our code fails.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决错误的有力方法是自动化测试。自动化测试让我们能够将我们希望软件如何行为编码化（字面上！）并且让我们更有信心地说“我的代码是正确的！”它让我们在重构代码时不用担心是否破坏了某些东西，并且给我们提供了关于代码失败位置的简单反馈。
- en: 'We want these benefits for our Express applications! By the end of this chapter,
    you''ll:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的 Express 应用程序也能获得这些好处！在本章结束时，你将：
- en: ·  Understand the motivation for testing at a high level
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·  了解在高级别进行测试的动机
- en: ·  Understand the different types of testing
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·  了解不同类型的测试
- en: ·  Be able to do test-driven development, understanding and using the red-green-refactor
    model of development
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ·  能够进行测试驱动开发，理解和使用开发的红-绿-重构模型
- en: ·  Write, run, and organize tests for general Node.js code to make sure your
    functions and models work as intended (using tools called Mocha and Chai)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ·  编写、运行和组织测试以确保你的函数和模型按预期工作（使用称为 Mocha 和 Chai 的工具）
- en: ·  Test your Express applications to make sure your servers are behaving as
    they should (with a module called Supertest)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ·  使用 Supertest 模块测试你的 Express 应用程序以确保你的服务器表现如预期
- en: ·  Test HTML responses to make sure your views are generating the correct HTML
    (using a jQuery-like module called Cheerio)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ·  测试 HTML 响应以确保你的视图生成了正确的 HTML（使用一个类似 jQuery 的模块 Cheerio）
- en: Let's get started putting these components together.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始将这些组件组合起来。
- en: 9.1     What is testing and why is it important?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1     什么是测试以及为什么它很重要？
- en: It should come as no surprise that there is often a disconnect between how you
    envision your code behaving and how it actually behaves. No programmer has ever
    written bug-free code 100% of the time; this is part of our profession.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，你想象中的代码行为和实际行为之间往往存在脱节。没有程序员能够100%地写出没有错误的代码；这是我们职业的一部分。
- en: If we were writing a simple calculator, for example, we know in our heads that
    we want it to do addition, subtraction, multiplication, and division. We can test
    these by hand every time we make a change—dafter making this change, does 1 plus
    1 still equal 2? Does 12 divided by 3 still equal 4?—but this can be tedious and
    error-prone.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在编写一个简单的计算器，我们知道我们想要它执行加法、减法、乘法和除法。我们可以每次更改时手动测试这些功能——在做出这个更改后，1 加 1
    仍然等于 2 吗？12 除以 3 仍然等于 4 吗？——但这可能很繁琐且容易出错。
- en: We can write automated tests, which effectively puts these desires into code.
    We write code that says "make sure, with our calculator, that 1 + 1 = 2, and that
    12 ÷ 3 = 4". This is effectively a specification for your program, but it's not
    written in English—it's written in code for the computer, which means that you
    can automatically verify it. "Testing" is usually short for "automated testing",
    and it's simply when test code is run that verifies your "real" code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写自动化测试，这实际上是将这些愿望转化为代码。我们编写的代码是“确保，用我们的计算器，1 + 1 等于 2，以及 12 除以 3 等于 4”。这实际上是对你程序的规范，但它不是用英语写的——它是用计算机代码写的，这意味着你可以自动验证它。“测试”通常简称为“自动化测试”，它只是当运行测试代码来验证你的“真实”代码时。
- en: This automatic verification has a number of advantages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动验证有许多优点。
- en: Most importantly, you can be much more confident about your code's reliability.
    If you've written a rigorous specification that a computer can automatically run
    against your program, you can be much more confident about its correctness once
    you've written it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，你可以对自己的代码可靠性更有信心。如果你已经编写了一个计算机可以自动运行以验证你的程序的严格规范，那么一旦你编写了它，你就可以对其正确性更有信心。
- en: It's also really helpful when you want to change your code. A common problem
    is that you have a functioning program, but you want some part of it to be rewritten
    (perhaps to be optimized or cleaned up). Without tests, you'll have to manually
    verify that your old code behaves like the new code. With automated tests, you
    can be confident that this refactoring doesn't break anything.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想更改代码时，这也非常有帮助。一个常见的问题是，你有一个正在运行的程序，但你希望程序的一部分被重写（可能是为了优化或清理）。没有测试，你必须手动验证旧代码的行为是否与新代码一致。有了自动化测试，你可以确信这种重构不会破坏任何东西。
- en: Automated testing is also a lot less tedious. Imagine if, every time you wanted
    to test your calculator, you had to make sure that 1 + 1 = 2, 1 – 1 = 0, 1 – 3
    = -2...et cetera. It'd get old pretty fast! Computers are fantastic at handling
    tedium like this.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自动测试也少了很多繁琐。想象一下，每次你想测试你的计算器时，你都必须确保 1 + 1 = 2，1 – 1 = 0，1 – 3 = -2……等等。这会很快变得无聊！计算机在处理这种繁琐的事情上非常出色。
- en: 'In short: we write tests so we can automatically verify that our code (probably)
    works.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之：我们编写测试是为了能够自动验证我们的代码（可能）是正确的。
- en: 9.1.1  Test-driven development
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 测试驱动开发
- en: Imagine you're writing a little JavaScript that resizes images to proper dimensions,
    a common task in web applications. When passed an image and dimensions, your function
    will return the image resized to those dimensions. Perhaps your boss has assigned
    this task, or perhaps it's your own impetus, but in any case, the specifications
    are pretty clear.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在编写一个小型的JavaScript代码，用于将图像调整到适当的尺寸，这是网络应用中常见的任务。当传递一个图像和尺寸时，你的函数将返回调整到这些尺寸的图像。也许你的老板分配了这个任务，或者也许是你的个人动力，但无论如何，规范都很明确。
- en: Let's say that I've convinced you to write automated tests for this; the paragraphs
    above have moved you. When do you write the tests? You could write the image resizer
    and then write the tests, but you could also switch things up and write the tests first.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我已经说服你为这个项目编写自动化测试；上面的段落已经打动了你。你什么时候编写测试？你可以在编写图像缩放器之后编写测试，但你也可以改变顺序，先编写测试。
- en: Writing tests first has a number of advantages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先编写测试具有许多优点。
- en: 'When you write tests first, you''re literally codifying your specification.
    When you''re finished writing your tests, you''ve told the computer how to ask
    the question: is my code finished yet? If you have any failing tests, then your
    code isn''t conforming to the specification. If all of your tests pass, then you
    know that your code works as you specified. Writing the code first might mislead
    you and you''ll write incomplete tests.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首先编写测试时，你实际上是在将你的规范编码化。当你完成测试编写后，你就告诉了计算机如何提问：我的代码完成了吗？如果你有任何失败的测试，那么你的代码没有符合规范。如果你的所有测试都通过了，那么你知道你的代码按照你的指定工作。先编写代码可能会误导你，并且你会编写不完整的测试。
- en: You've probably used an API that's really pleasant to work with. The code is
    simple and intuitive. When you write tests first, you're forced to think about
    how your code should work before you've even written it. This can help you design
    what some people call "dream code"; the easiest interface to your code. TDD can
    help you see the big picture about how your code should work and make for a more
    elegant design.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能使用过一个非常易于使用的API。代码简单直观。当你首先编写测试时，你被迫在编写代码之前思考代码应该如何工作。这可以帮助你设计出一些人称之为“梦想代码”的东西；最容易使用的代码接口。TDD可以帮助你看到代码应该如何工作的整体图景，并使设计更加优雅。
- en: This "write tests first" philosophy is called Test-Driven Development, shortened
    to TDD. It's so named because your tests dictate how your code forms.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“先编写测试”的哲学被称为测试驱动开发，简称TDD。之所以这样命名，是因为你的测试决定了你的代码如何形成。
- en: TDD can really help you, but there are a few times where it can slow you down.
    If your specifications are unclear, you could spend a bunch of time writing tests,
    only to realize that you don't actually want to implement what you set out to!
    Now you have all of these useless tests and some wasted time. TDD can limit your
    flexibility, especially if your specifications are a little foggy.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: TDD确实可以帮助你，但有时它可能会让你慢下来。如果你的规范不明确，你可能会花很多时间写测试，结果却发现你实际上并不想实现你设定的目标！现在你有了所有这些无用的测试和一些浪费的时间。TDD可能会限制你的灵活性，特别是如果你的规范有些模糊不清。
- en: And if you're not writing tests at all, then TDD is contrary to your very philosophy
    and you won’t write tests at all!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你根本不写测试，那么TDD就与你非常哲学相悖，你根本不会写测试！
- en: Some folks are TDD for all their development—test first or go home. Others are
    hugely against it. It's not a silver bullet nor is it a deadly poison; decide
    whether TDD is right for you and your code. We'll be using some TDD in this chapter,
    but don't take that as an unconditional endorsement. It's good for some situations
    and not so good for others.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人在他们的所有开发中都采用TDD——先测试再回家。其他人则强烈反对它。它既不是银弹，也不是致命的毒药；决定TDD是否适合你和你写的代码。在本章中，我们将使用一些TDD，但不要把它当作无条件的支持。它在某些情况下很好，但在其他情况下则不是那么好。
- en: 'HOW TDD WORKS: RED, GREEN, REFACTOR'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是如何工作的：红、绿、重构
- en: The TDD cycle usually works in three repeating steps, called red, green, refactor,
    as shown in Figure 9.1.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TDD周期通常在三个重复的步骤中工作，称为红、绿、重构，如图9.1所示。
- en: '![](../Images/09_01.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09_01.png)'
- en: Figure  9.1  The repeating red-green-refactor cycle of TDD.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 TDD的重复红-绿-重构周期。
- en: 1.  Step 1 is the “red” step. Because it’s TDD, you write your tests first.
    When you write these tests before you write any of the real code, none of your
    tests will pass—how could they when no real code has been written? During the
    red step, you write all of your tests and run them to watch them all fail. This
    step is so named for the red color that you usually see when you have a failing
    test.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 步骤1是“红”步骤。因为它是TDD，你先写测试。在你写任何真正的代码之前写这些测试，你的所有测试都不会通过——当没有写任何真正的代码时，它们怎么可能通过呢？在红色步骤中，你写所有的测试并运行它们，以观察它们全部失败。这个步骤之所以被称为红色步骤，是因为你通常会在失败的测试中看到红色。
- en: 2.  Step 2 is the “green” step. Now that you’ve written all of your tests, you
    begin to “fill in” the real code to satisfy all the tests. As you make progress,
    your tests will slowly go from red (failing) to green (passing). Like the previous
    step, it’s called the “green” step because you typically see green for a passing
    test. Once you’re all green (all of your tests pass), you’re ready for the final
    step.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 步骤2是“绿”步骤。现在你已经写完了所有的测试，你开始“填充”真正的代码以满足所有测试。随着你的进展，你的测试将慢慢从红色（失败）变为绿色（通过）。就像上一个步骤一样，它被称为“绿”步骤，因为你通常会在通过测试时看到绿色。一旦你全部都是绿色（所有测试都通过），你就准备好进行最后一步了。
- en: 3.  Step 3 is the “refactor” step. If all of your tests are green, that means
    all of your code works, but it might not be perfect. Perhaps one of your functions
    is slow or you’ve chosen bad variable names. Like a writer cleaning up a draft
    of a book, you go back and clean up the code. Because you have all of your tests,
    you can refactor without worrying that you’re breaking some unforeseen part of
    your code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 步骤3是“重构”步骤。如果你的所有测试都是绿色，这意味着你的所有代码都工作，但它可能并不完美。也许你的某个函数运行缓慢，或者你选择了不好的变量名。就像作家清理书籍草稿一样，你回去清理代码。因为你有了所有的测试，你可以重构而不必担心你会破坏代码中未预见的某个部分。
- en: 4.  Step 4 is to repeat the process. You probably haven’t written all of your
    code for the project, so go back to step 1 and write some tests for the next part.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 步骤4是重复这个过程。你可能还没有为项目写完所有的代码，所以回到步骤1，为下一部分写一些测试。
- en: 'Here’s how we might use red-green-refactor for our image resizer:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何可能使用红-绿-重构来处理我们的图像调整大小：
- en: '·  First, the “red” step. We’d write some of our tests. For example: if we
    pass it a JPEG image, our function should return a JPEG image; if we pass it a
    PNG image, our function should return a PNG image. These tests aren’t complete,
    but it’s a good starting point.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: · 首先，“红”步骤。我们会写一些测试。例如：如果我们传递一个JPEG图像，我们的函数应该返回一个JPEG图像；如果我们传递一个PNG图像，我们的函数应该返回一个PNG图像。 这些测试并不完整，但这是一个好的起点。
- en: ·  Next, the “green” step. Now that we have some of our tests, we’ll fill in
    the code to make our tests pass. Note that we haven’t written any tests that say
    that we should resize the image, only that we should return the same file type.
    So we don’t write the image resizing yet! We simply return the image and all of
    our tests can pass.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ·  接下来是“绿色”步骤。现在我们已经有了一些测试，我们将填充代码以使测试通过。请注意，我们还没有编写任何测试来说明我们应该调整图像大小，只是说我们应该返回相同的文件类型。所以我们还没有编写图像调整大小的代码！我们只是返回图像，这样所有的测试都可以通过。
- en: ·  Now for the refactor step.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ·  现在轮到重构步骤了。
- en: '9.1.2  Cardinal rule: when in doubt, test'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2  基本规则：当有疑问时，进行测试
- en: In short, you can almost never have too many tests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你几乎永远不能有太多的测试。
- en: As you can likely imagine, successful tests don't necessarily mean that you
    code works. For example, if you were testing a function, you could test that the
    function is a function. That's a very valid thing to test, but if it's your only
    test, then you might be misled into thinking that your code works when all of
    your tests succeed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所能想象，成功的测试并不一定意味着你的代码是正确的。例如，如果你正在测试一个函数，你可以测试该函数是否是一个函数。这是一个非常有效的测试，但如果这是你唯一的测试，那么当所有测试都成功时，你可能会被误导，认为你的代码是正确的。
- en: Because of that, you want to test as much of your code as you can. You want
    to poke at every (reasonable) nook and cranny of your software to make sure it
    performs as you expect. The more passing tests you have, the more you approach
    certainty that your code works as you expect. You can never be 100% sure—something
    might break somewhere along the line that you didn't think of—but if you've thrown
    everything you can possibly think of at your code, it's probably working.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，你希望尽可能多地测试你的代码。你希望检查你软件的每一个（合理的）角落和缝隙，以确保它按预期工作。你通过的测试越多，你越接近确信你的代码按预期工作。你永远不能100%确定——可能在你没有考虑到的地方某处会出问题——但如果你已经把你能想到的所有东西都应用到代码上，它很可能是在正常工作的。
- en: Code Coverage
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Testing can make you more confident about your code, but it’s just one method.
    As we discussed at the beginning of the chapter, there are plenty of methods like
    peer reviews and code linters. An extension of testing to further boost your confidence
    is the idea of code coverage.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以使你对你的代码更有信心，但这只是众多方法中的一种。正如我们在本章开头所讨论的，还有许多其他方法，比如同行评审和代码检查器。测试的扩展，以进一步增强你的信心，就是代码覆盖率的概念。
- en: Code coverage tools see how much of your code is “covered” by your tests. You
    could imagine writing 10 passing tests for your code but completely ignoring one
    of your functions which is totally broken! Code coverage tools tell you what parts
    of your code are untouched by tests and therefore untested. In the Node.js world,
    the prevailing code coverage tool seems to be Istanbul. We won’t cover it here,
    but if you’re looking for even more confidence, take a look at Istanbul.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率工具会查看你的代码有多少是被测试“覆盖”的。你可以想象为你的代码编写10个通过测试，但完全忽略了一个完全损坏的函数！代码覆盖率工具会告诉你哪些代码部分没有被测试，因此未经测试。在Node.js的世界里，最流行的代码覆盖率工具似乎是Istanbul。我们在这里不会介绍它，但如果你在寻找更多的信心，可以看看Istanbul。
- en: Lost time is the only reason not to write tests. This is both lost time for
    the computer—some tests can be computationally expensive—and lost time for you
    as a human being—it takes time to type the tests!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 失去的时间是唯一不编写测试的理由。这不仅是对计算机的失去时间——一些测试可能计算成本很高——也是对你这个人的失去时间——编写测试需要时间！
- en: 9.2     Introduction to the Mocha testing framework
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2     Mocha测试框架简介
- en: Just like it's possible to write web servers with only Node.js, it's possible
    to write tests with only Node.js. We could create a file that checked a bunch
    of conditions to make sure everything was working as normal, and then we could
    output the results with `console.log`. Like Express, we might find this “raw”
    method to be verbose and we might find ourselves having to write a lot of boilerplate
    code just to write tests.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 就像只用Node.js就能编写Web服务器一样，只用Node.js也能编写测试。我们可以创建一个文件，检查一系列条件以确保一切按正常工作，然后我们可以使用`console.log`输出结果。就像Express一样，我们可能会发现这种方法“原始”且冗长，我们可能需要编写大量的样板代码才能编写测试。
- en: Mocha is a testing framework that helps to reduce some of this headache. (It's
    written by the original creator of Express, by the way.) It gives you a nice syntax
    for organizing your tests, and has a several other features like asynchronous
    test support and easy-to-read output. It's not specifically tied to Express, so
    you can use it to test Express applications, JavaScript functions, database models,
    and anything else that runs inside the Node runtime.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha是一个测试框架，有助于减少一些头痛问题。（顺便说一下，它是Express的原始创建者编写的。）它为你提供了一个组织测试的好语法，并具有异步测试支持和易于阅读的输出等几个其他功能。它并不特定于Express，因此你可以用它来测试Express应用程序、JavaScript函数、数据库模型以及Node运行时内部运行的任何其他内容。
- en: Before we start testing  Express applications, let's start by testing a simple
    function to see how it's done.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始测试Express应用程序之前，让我们先测试一个简单的函数，看看它是如何完成的。
- en: Imagine we want to write a function called `capitalize` that capitalizes the
    first character of a string and makes the rest of the string lowercase. For example, `"hello
    WORLD"` would become `"Hello world"`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写一个名为`capitalize`的函数，该函数将字符串的第一个字符转换为大写，并将字符串的其余部分转换为小写。例如，`"hello WORLD"`将变成`"Hello
    world"`。
- en: 9.2.1  How does Node.js testing work?
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1  Node.js测试是如何工作的？
- en: 'Testing in Node.js applications has three major parts: the “real” code (written
    by you), the testing code (written by you), and the test runner (usually a third-party
    module, probably not written by you).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js应用程序中进行测试有三个主要部分：“真实”代码（由你编写），测试代码（由你编写），以及测试运行器（通常是第三方模块，可能不是由你编写）。
- en: 1.  The “real” code is whatever you want to test. This might be a function,
    or a database model, or an Express server. In a Node.js context, this is anything
    that assigns anything to `module.exports`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  “真实”代码是你想要测试的任何内容。这可能是一个函数、数据库模型或Express服务器。在Node.js环境中，这是任何将内容分配给`module.exports`的东西。
- en: 2.  The test code tests your “real” code. These will `require` whatever you
    want to test and then start asking questions about it. Does the function return
    what it should return? Do your objects behave as they should behave?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  测试代码测试你的“真实”代码。这些将`require`你想要测试的内容，然后开始对其提问。函数返回了它应该返回的内容吗？你的对象表现如预期吗？
- en: 3.  The test runner is an executable that runs on your computer. This is an
    executable that looks as your test code and runs it. Test runners will commonly
    print out things like “these tests succeeded, these tests failed and here's how”
    and “the tests took 100 milliseconds to run” and things like that. We'll be using
    Mocha in this chapter, but you might've used Jasmine or Qunit in your JavaScript
    career. You might've used Rspec or Junit in another life.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  测试运行器是一个在你的计算机上运行的可执行文件。这是一个检查你的测试代码并运行它的可执行文件。测试运行器通常会打印出诸如“这些测试通过了，这些测试失败了，以及失败的原因”和“测试运行了100毫秒”等信息。在本章中，我们将使用Mocha，但你在JavaScript职业生涯中可能使用过Jasmine或Qunit。你可能在前世中使用过Rspec或Junit。
- en: Both the real code and your test code live in the same repository. We'll also
    define Mocha (our test runner) as a dependency, and we'll install it locally to
    our repository.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 真实代码和你的测试代码都位于同一个仓库中。我们还将Mocha（我们的测试运行器）定义为依赖项，并将其本地安装到我们的仓库中。
- en: 9.2.2  Setting up Mocha and the Chai assertion library
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2  设置Mocha和Chai断言库
- en: 'Let''s take a stab at writing a first version of this. Create a new directory
    and create one file inside: `capitalize.js`, then put the following inside:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试编写这个的第一个版本。创建一个新的目录并在其中创建一个文件：`capitalize.js`，然后放入以下内容：
- en: Listing 9.1 A first version of the capitalize function (in capitalize.js)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1：capitalize函数的第一个版本（在capitalize.js中）
- en: '`function capitalize(str) {` `  var firstLetter = str[0].toUpperCase();` `  var
    rest = str.slice(1).toLowerCase();` `  return firstLetter + rest;` `}`  `module.exports
    = capitalize;`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`function capitalize(str) {` `  var firstLetter = str[0].toUpperCase();` `  var
    rest = str.slice(1).toLowerCase();` `  return firstLetter + rest;` `}`  `module.exports
    = capitalize;`'
- en: If we just eyeball the code, it looks like it should work, but let's write some
    tests to become more confident about that.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是粗略地查看代码，它看起来应该可以工作，但让我们编写一些测试来增加我们对它的信心。
- en: 'Create a `package.json` file in the same directory, which should contain the
    following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录中创建一个`package.json`文件，它应包含以下内容：
- en: Listing 9.2 The package.json for the capitalize function
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.2：capitalize函数的package.json文件
- en: '`{` `  "private": true,` `  "devDependencies": {` `    "chai": "^1.9.2", #A`
    `    "mocha": "^2.0.1" #A` `  },` `  "scripts": {` `    "test": "mocha"  #B` ` 
    }``}`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "private": true,` `  "devDependencies": {` `    "chai": "^1.9.2", #A`
    `    "mocha": "^2.0.1" #A` `  },` `  "scripts": {` `    "test": "mocha"  #B` ` 
    }``}`'
- en: '#A As always, your version numbers may vary.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 如同往常，你的版本号可能会有所不同。'
- en: '#B When you type “npm test”, this will run Mocha to run your tests.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 当你输入“npm test”时，这将运行 Mocha 来运行你的测试。'
- en: 'We''re using two modules here: Mocha and Chai.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用两个模块：Mocha 和 Chai。
- en: Mocha is a testing framework. If you've ever used other JavaScript testing frameworks
    like Jasmine, this should be familiar. At the end of the day, it's the thing that
    actually runs your tests. It's the syntax you use to say "here's what I'm testing,
    let me set it up, here's where I test thing A, here's where I test thing B”, et
    cetera.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 是一个测试框架。如果你曾经使用过其他 JavaScript 测试框架，如 Jasmine，这应该很熟悉。最终，它是运行你的测试的东西。它是你用来表达“这里是我要测试的内容，让我设置一下，这里是我测试
    A 项，这里是我测试 B 项”，等等的语法。
- en: Chai is an assertion library. While Mocha lays out the tests, Chai (almost literally)
    says "I expect the `helloWorld` function to return `'hello world'`". The actual
    syntax is `expect(helloWorld()).to.equal("hello world")`, which reads a lot like
    the previous English. If `helloWorld` works and returns “hello world”, your tests
    will pass. If it doesn't return “hello world”, an error will appear, telling you
    that things aren't as you expect.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 是一个断言库。当 Mocha 布置测试时，Chai（几乎可以说是字面意义上）会说“我期望 `helloWorld` 函数返回 `'hello
    world'`”。实际的语法是 `expect(helloWorld()).to.equal("hello world")`，这读起来很像之前的英文。如果
    `helloWorld` 正常工作并返回 “hello world”，你的测试将会通过。如果它没有返回 “hello world”，将会出现一个错误，告诉你事情并不像你预期的那样。
- en: There are a number of assertion libraries (including one built into Node), but
    at the end of the day, Mocha waits for an assertion library to throw an error.
    If no error is thrown, the test passes. If an error is thrown, the test fails.
    That’s why we use Chai—it’s a nice way to throw errors when our tests fail.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多断言库（包括 Node 内置的一个），但最终，Mocha 等待断言库抛出错误。如果没有抛出错误，测试通过。如果抛出错误，测试失败。这就是我们使用
    Chai 的原因——它是在测试失败时抛出错误的好方法。
- en: The distinction between Mocha and Chai is important. Mocha is the test runner,
    so there’s an actual executable that runs (you don’t ever type `node my_tests.js` nor
    do you ever `require` it). Mocha injects some global variables into your code—as
    we’ll see, these globals exist to structure each of your tests. Inside of each
    of these tests, you use Chai to actually test your code. When we test our capitalization
    library, we’ll use Mocha to break up our tests into pieces like “the capitalization
    library capitalizes single words” and “the capitalization library doesn’t break
    if you pass it the empty string”. At the Chai level, we’ll actually call our capitalization
    library and make sure that our module’s output matches what we expect.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 和 Chai 之间的区别很重要。Mocha 是测试运行器，所以有一个实际的可执行文件会运行（你永远不会输入 `node my_tests.js`，也永远不会
    `require` 它）。Mocha 将一些全局变量注入到你的代码中——正如我们将看到的，这些全局变量存在是为了结构化你的每个测试。在每个这样的测试中，你使用
    Chai 实际测试你的代码。当我们测试我们的大写库时，我们将使用 Mocha 将我们的测试分解成“大写库将单个单词大写”和“大写库在传入空字符串时不会出错”这样的部分。在
    Chai 层面上，我们将实际调用我们的大写库并确保我们的模块输出符合我们的预期。
- en: 9.2.3  What happens when we run our tests
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 当我们运行我们的测试时会发生什么
- en: As you might expect, we’ll actually want to run these tests written with Mocha
    and Chai in order to make sure that our code works. How do we do this?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，我们实际上会想要运行用 Mocha 和 Chai 编写的这些测试，以确保我们的代码工作。我们该如何做呢？
- en: First, as you can see above, we’ve defined the test script in our `package.json`.
    This allows us to type `npm test` into the command line. This runs Mocha which
    in turn runs our tests, as you can see in Figure 9.2.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如上图所示，我们已经在我们的 `package.json` 中定义了测试脚本。这允许我们在命令行中输入 `npm test`。这会运行 Mocha，然后运行我们的测试，如图
    9.2 所示。
- en: '![](../Images/09_02.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09_02.png)'
- en: Figure 9.2 What happens when we type “npm test” into our command line.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 当我们在命令行中输入“npm test”时会发生什么。
- en: Now we've set everything up. It's time to start writing some tests.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一切。是时候开始编写一些测试了。
- en: 9.2.4  Writing your first test with Mocha and Chai
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.4 使用 Mocha 和 Chai 编写你的第一个测试
- en: Now that we've written a first version of our capitalization function, let's
    write a test to see if it works!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了我们的大写函数的第一个版本，让我们编写一个测试来看看它是否工作！
- en: 'Create a folder called `test` in the root of your project; this is where your
    test code will live. Inside that directory, create a file for testing our capitalization;
    I simply called mine `capitalize.js`. Put the following inside:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目的根目录下创建一个名为 `test` 的文件夹；这是你的测试代码将存放的地方。在那个目录内，为测试我们的大写函数创建一个文件；我简单地将其命名为
    `capitalize.js`。将以下内容放入其中：
- en: Listing 9.3 Our first test for capitalize (in test/capitalize.js)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 对 capitalize 的第一个测试（在 test/capitalize.js 中）
- en: '`var capitalize = require("../capitalize");  #A`   `var chai = require("chai"); 
    #B` `var expect = chai.expect;    #B`   `describe("capitalize", function() { 
    #C`   `  it("capitalizes single words", function() {  #D` `    expect(capitalize("express")).to.equal("Express"); 
    #E` `    expect(capitalize("cats")).to.equal("Cats");        #E` `  });`  `});`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`var capitalize = require("../capitalize");  #A`   `var chai = require("chai"); 
    #B` `var expect = chai.expect;    #B`   `describe("capitalize", function() { 
    #C`   `  it("capitalizes single words", function() {  #D` `    expect(capitalize("express")).to.equal("Express"); 
    #E` `    expect(capitalize("cats")).to.equal("Cats");        #E` `  });`  `});`'
- en: '#A First, require our function that we''re going to test.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 首先，引入我们要测试的函数。'
- en: '#B Require Chai and then use the “expect” property, which we''ll use to make
    assertions in our tests.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 需要先引入 Chai 库，然后使用其“expect”属性，我们将用它来在测试中做出断言。'
- en: '#C This is called a “suite”, and describes a series of specifications in the
    same topic. This is at the Mocha level.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 这被称为“测试套件”，它描述了同一主题的一系列规范。这是在 Mocha 框架级别。'
- en: '#D This is a specification, and it has a title and some code to run. This is
    at the Mocha level.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 这是一个规范，它有一个标题和一些要运行的代码。这是在 Mocha 框架级别。'
- en: '#E Do the actual assertions; make sure our code actually does what we expect!
    This is at the Chai level.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '#E 进行实际的断言；确保我们的代码实际上做了我们期望的事情！这是在 Chai 框架级别。'
- en: So what's going on here?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？
- en: First, we're requiring our module so that we can test it. Next, we're requiring
    Chai and using its `expect` property so that we can use it to make assertions
    later on. (Chai has two other assertion styles, but we'll stick to this one for
    now.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们引入我们的模块以便测试它。接下来，我们引入 Chai 并使用其`expect`属性，这样我们就可以用它来做出断言。 （Chai 有两种其他的断言风格，但现在我们将坚持使用这一种。）
- en: Next, we `describe` a “suite” of tests. This is basically a component of your
    application; this could be a class or just a slew of functions. This suite is
    called "capitalize"; it's English, not code. In this case, this suite describes
    the capitalization function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们`describe`一个“测试套件”。这基本上是应用程序的一个组件；这可能是一个类或者一系列函数。这个测试套件被称为“capitalize”；它是英文，不是代码。在这种情况下，这个测试套件描述了大写化函数。
- en: Inside of this suite, we define a test (we'll add more in a moment). It's a
    JavaScript function that says what some piece of your program should do. It says
    it in plain English ("it capitalizes single words") and in code. For each suite,
    you can have a number of tests for any number of tests you want to do.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试套件中，我们定义了一个测试（我们稍后会添加更多）。它是一个 JavaScript 函数，说明了程序中某个部分应该做什么。它用普通的英语（“它将单词首字母大写”）和代码来说明。对于每个测试套件，你可以根据需要添加任意数量的测试。
- en: Finally, inside of the test, we `expect` the result of `capitalize("express")` to
    equal `"Express"`, and the same capitalization should happen for `"cats"`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在测试内部，我们`expect``capitalize("express")`的结果应该等于`"Express"`，并且对于`"cats"`也应该进行相同的大写化处理。
- en: 'With respect to our code, running `npm test`  goes through a flow like in Figure
    3:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的代码，运行`npm test`会经过类似于图 3 的流程：
- en: '![](../Images/09_03.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09_03.png)'
- en: Figure 9.3 Typing npm test will go through this flow and ultimately end up running
    the code inside test/capitalize.js.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 输入 npm test 会经过这个流程，最终运行 test/capitalize.js 中的代码。
- en: 'If you go to the root of your project and type `npm test`, you''ll see something
    like the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入项目的根目录并输入`npm test`，你会看到如下输出：
- en: '`capitalize` `  ✓ capitalizes single words`  `1 passing (9ms)`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`capitalize` `  ✓ 将单词首字母大写`  `1 passing (9ms)`'
- en: That means we've run one test, and it passes! Congratulations—you've written
    your first test. We don't know that everything works 100%, but we know that it
    properly capitalizes the first letter of two different words.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们已经运行了一个测试，并且它通过了！恭喜你——你已经编写了你的第一个测试。我们不知道一切是否都工作得100%，但我们知道它正确地大写了两个不同单词的首字母。
- en: We're not out of the woods yet; there are more tests to write to become more
    confident that our code works.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有走出困境；我们还需要编写更多测试来更有信心我们的代码是正确的。
- en: 9.2.5  Adding more tests
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.5 添加更多测试
- en: We've written a single test so far, and it's showed us that our code isn't totally
    broken. But we don't know if it works on more complex inputs. What would happen
    if you passed it a string with no letters? What about an empty string? We can
    see that we're capitalizing the first letter, but are we lowercasing the rest
    of the string? Let's add some more tests to test the “unhappy paths”.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了一个测试，它表明我们的代码并没有完全出错。但我们不知道它是否适用于更复杂的输入。如果你传递一个没有字母的字符串会发生什么？关于空字符串呢？我们可以看到我们在大写第一个字母，但我们是否将字符串的其余部分转换为小写？让我们添加一些更多的测试来测试“不愉快的情况”。
- en: 'Let''s start by adding another relatively simple test: does it make the rest
    of the string lowercase? We''ll leave everything from before and we''ll add a
    new test to `test/capitalize.js`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加另一个相对简单的测试：它是否将字符串的其余部分转换为小写？我们将保留之前的内容，并在 `test/capitalize.js` 中添加一个新的测试：
- en: Listing 9.4 Another test for capitalize (in test/capitalize.js)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.4 对 capitalize 的另一个测试（在 test/capitalize.js 中）
- en: '`// …`   `describe("capitalize", function() {`   `  it("capitalizes single
    words", function() { /* … * / });`   `  it("makes the rest of the string lowercase",
    function() {  #A` `    expect(capitalize("javaScript")).to.equal("Javascript");
    #B` `  });`  `});`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …`   `describe("capitalize", function() {`   `  it("capitalizes single
    words", function() { /* … * / });`   `  it("makes the rest of the string lowercase",
    function() {  #A` `    expect(capitalize("javaScript")).to.equal("Javascript");
    #B` `  });`  `});`'
- en: '#A Our new tests will make sure it “makes the rest of the string lowercase”.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 我们的新测试将确保它“将字符串的其余部分转换为小写”。'
- en: '#B We expect the capitalization of “javaScript” to equal “Javascript”.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 我们期望将“javaScript”转换为大写后等于“Javascript”。'
- en: 'You can run your tests with `npm test` (or just `npm t` for short), and you
    should see something like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `npm test` 运行测试（或简写为 `npm t`），您应该会看到类似以下内容：
- en: '`capitalize` `  ✓ capitalizes single words` `  ✓ makes the rest of the string
    lowercase`  `2 passing (10ms)`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`capitalize` `  ✓ 将单个单词转换为大写` `  ✓ 将字符串的其余部分转换为小写`  `2 passing (10ms)`'
- en: Cool! Now we're more confident that we're capitalizing the first letter and
    lowercasing the rest of the string. But we're not out of the woods yet.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！现在我们更有信心我们在大写第一个字母并将字符串的其余部分转换为小写。但我们还没有走出困境。
- en: What about adding a test for the empty string? Capitalizing the empty string
    should just return the empty string, right? Let's write a test to see if that
    happens.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于添加空字符串的测试呢？将空字符串转换为大写应该只返回空字符串，对吧？让我们编写一个测试来看看是否会发生这种情况。
- en: Listing 9.5 Testing capitalization of the empty string (in test/capitalize.js)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 测试空字符串的资本化（在 test/capitalize.js 中）
- en: '`// …`   `describe("capitalize", function() {`   `  // …`   `  it("leaves empty
    strings alone", function() {` `    expect(capitalize("")).to.equal("");` `  });`
     `});`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …`   `describe("capitalize", function() {`   `  // …`   `  it("leaves empty
    strings alone", function() {` `    expect(capitalize("")).to.equal("");` `  });`
     `});`'
- en: 'Run `npm test` again to run this new test (and all the others). You should
    see something like the following output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 `npm test` 来运行这个新测试（以及所有其他测试）。您应该会看到类似以下输出：
- en: '`capitalize` `  ✓ capitalizes single words` `  ✓ makes the rest of the string
    lowercase` ``   `1) leaves empty strings alone` ``   `2 passing (10ms)` `` `1
    failing` ``   `1) capitalize leaves empty strings alone:` ``    `TypeError: Cannot
    call method ''toUpperCase'' of undefined` `` `    at capitalize (/path/to/capitalizeproject/capitalize.js:2:28)``   
    …`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`capitalize` `  ✓ 将单个单词转换为大写` `  ✓ 将字符串的其余部分转换为小写` ``   `1) 留空字符串不变` ``   `2
    passing (10ms)` `` `1 failing` ``   `1) capitalize 留空字符串不变:` ``    `TypeError:
    Cannot call method ''toUpperCase'' of undefined` `` `    at capitalize (/path/to/capitalizeproject/capitalize.js:2:28)``   
    …`'
- en: Uh oh! Looks like we have a red/failing test. Let's look at it to see what's
    wrong.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！看起来我们有一个红色/失败的测试。让我们看看出了什么问题。
- en: 'First, we can see that the error occurs when we run the “leaves empty strings
    alone” test. The error is a `TypeError`, and it''s telling us that we can''t call `toUpperCase` on `undefined`.
    We can also see a stack trace, which starts on line 2 of`capitalize.js`. Here''s
    the line that''s causing the error:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以看到错误发生在运行“留空字符串不变”测试时。错误是一个 `TypeError`，它告诉我们不能在 `undefined` 上调用 `toUpperCase`
    方法。我们还可以看到堆栈跟踪，它从 `capitalize.js` 的第 2 行开始。以下是导致错误的行：
- en: '`var firstLetter = str[0].toUpperCase();`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`var firstLetter = str[0].toUpperCase();`'
- en: 'Looks like `str[0]` is undefined when we pass the empty string, so we''ll need
    to make sure it''s defined. Let''s replace the use of square brackets with the `charAt` method.
    Our new-and-improved function should look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来当我们传递空字符串时，`str[0]` 是未定义的，所以我们需要确保它是已定义的。让我们将使用方括号的使用替换为 `charAt` 方法。我们新的改进函数应该看起来像这样：
- en: Listing 9.6 The new capitalize.js
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.6 新的 capitalize.js
- en: '`function capitalize(str) {` `  var firstLetter = str.charAt(0).toUpperCase(); 
    #A` `  var rest = str.slice(1).toLowerCase();` `  return firstLetter + rest;`
    `}`  `module.exports = capitalize;`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '```javascript'
- en: '#A Check out this new-and-improved line!'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 查看这条新改进的行！'
- en: Re-run our tests with `npm test` and you should see everything green!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行我们的测试 `npm test`，你应该会看到一切正常绿色！
- en: '`capitalize` `  ✓ leaves empty strings alone` `  ✓ capitalizes single words`
    `  ✓ makes the rest of the string lowercase`  `3 passing (11ms)`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`capitalize`'
- en: We can add a few more tests to make sure our code is robust. We'll add a test
    that doesn't try to capitalize any letters. We'll also make sure it properly capitalizes
    multi-word strings. We should also make sure it leaves a string alone if it's
    already properly capitalized. These new tests should pass with the code we already
    have.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一些更多的测试来确保我们的代码是健壮的。我们将添加一个不尝试大写任何字母的测试。我们还将确保它正确地大写多词字符串。我们还应该确保如果字符串已经正确大写，它不会改变字符串。这些新测试应该会通过我们已有的代码。
- en: Listing 9.7 Some new tests for capitalization (in test/capitalize.js)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 一些新的大写测试（在 test/capitalize.js 中）
- en: '`// …`   `it("leaves strings with no words alone", function() {` `  expect(capitalize(" 
    ")).to.equal("  ");` `  expect(capitalize("123")).to.equal("123");` `});`   `it("capitalizes
    multiple-word strings", function() {` `  expect(capitalize("what is Express?")).to.equal("What
    is express?");` `  expect(capitalize("i love lamp")).to.equal("I love lamp");`
    `});`   `it("leaves already-capitalized words alone", function() {` `  expect(capitalize("Express")).to.equal("Express");`
    `  expect(capitalize("Evan")).to.equal("Evan");` `  expect(capitalize("Catman")).to.equal("Catman");`
    `});`  `// …`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …`'
- en: Run `npm test` and you should see our tests pass.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm test`，你应该会看到我们的测试通过。
- en: 'Finally, we''ll try to throw one more curveball at our function: the `String` object.
    Every JavaScript style guide will warn you against using the `String` object—it''s
    bad news that can cause unexpected behavior, like they say about `==` or `eval`.
    It''s possible that you don''t even know about this feature of JavaScript, which
    is for the best, because you should never use it.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在我们的函数上再抛出一个曲线球：String 对象。每个 JavaScript 风格指南都会警告你避免使用 String 对象——这是一个可能导致意外行为的不良消息，就像他们所说的
    `==` 或 `eval`。可能你甚至都不知道 JavaScript 的这个特性，这是最好的，因为你永远不应该使用它。
- en: Unfortunately, there are inexperienced programmers out there (and others are,
    sadly, fools). Some of them might be using your code. You could argue that bugs
    are their fault, but you could also argue that your code shouldn't be the problem.
    That's why we should test our function with the `String` object, just in case.
    Let's write one last test that uses the `String` object.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有些程序员（以及其他一些人，遗憾的是，是傻瓜）缺乏经验。他们中的一些人可能会使用你的代码。你可以认为错误是他们的责任，但你也可以认为你的代码不应该是问题。这就是为什么我们应该用
    String 对象测试我们的函数，以防万一。让我们写最后一个使用 String 对象的测试。
- en: Listing 9.8 Testing with the String object
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8 使用 String 对象进行测试
- en: '`// …`   `it("capitalizes String objects without changing their values",` `[CA]function()
    {` `  var str = new String("who is JavaScript?");` `  expect(capitalize(str)).to.equal("Who
    is javascript?");` `  expect(str.valueOf()).to.equal("who is JavaScript?");  #A`
    `});`  `// …`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …`'
- en: '#A str.valueOf() converts the String object to a “normal” string.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '#A `str.valueOf()` 将 String 对象转换为“普通”字符串。'
- en: We've got seven tests for our little capitalization function; run `npm test` one
    last time to make sure they all pass!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的小大写函数有了七个测试；最后一次运行 `npm test` 确保它们都通过！
- en: '`capitalize` `  ✓ leaves empty strings alone` `  ✓ leaves strings with no words
    alone` `  ✓ capitalizes single words` `  ✓ makes the rest of the string lowercase`
    `  ✓ capitalizes multiple-word strings` `  ✓ leaves already-capitalized words
    alone` `  ✓ capitalizes String objects without changing their values`  `7 passing
    (13ms)`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`capitalize` `  ✓ 保留空字符串不变` `  ✓ 保留没有单词的字符串不变` `  ✓ 大写单个单词` `  ✓ 将字符串的其余部分转换为小写`
    `  ✓ 保留已经大写的单词不变` `  ✓ 大写字符串对象而不改变其值` `  7 passing (13ms)`'
- en: Look at us! We're now pretty sure our capitalization function works, even when
    passed a variety of odd strings.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们！我们现在相当确信我们的大写函数即使在传入各种奇怪的字符串时也能正常工作。
- en: 9.2.6  More features of Mocha and Chai
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.6 Mocha 和 Chai 的更多功能
- en: So far, we've only seen how we can use Mocha and Chai to test equality. Effectively,
    we've used a glorified equality operator. But these two modules can do much more
    than that. We won't go through all of the options here, but we'll look at a couple
    of examples.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了如何使用 Mocha 和 Chai 来测试相等性。实际上，我们使用了一个华丽的相等运算符。但这两个模块能做的远不止这些。我们不会在这里介绍所有选项，但我们会看看几个例子。
- en: RUNNING CODE BEFORE EACH TEST
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试之前运行代码
- en: It's common to run setup code before you actually run your assertions. Perhaps
    you're defining a variable to be manipulated or spooling up your server.  If you're
    doing this setup  across many tests, Mocha has the `beforeEach` function to help
    reduce the amount of repeated code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际运行断言之前运行设置代码是很常见的。也许你正在定义一个要操作的变量或启动你的服务器。如果你在许多测试中执行此设置，Mocha 的 `beforeEach`
    函数可以帮助减少重复代码的数量。
- en: 'For example, let''s say we''ve made a User model and we want to test it. In
    every single test, we''re creating a User object and we want to test it. Here''s
    how we might do that:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们创建了一个用户模型，并想对其进行测试。在每次测试中，我们都会创建一个用户对象并想对其进行测试。以下是我们可以这样做的方式：
- en: Listing 9.9 Using Mocha's beforeEach feature
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.9 使用 Mocha 的 beforeEach 功能
- en: '`describe("User", function() {`   `  var user;` `  beforeEach(function() {            
    #A` `    user = new User({                 #A` `      firstName: "Douglas",          
    #A` `      lastName: "Reynholm",           #A` `      birthday: new Date(1975,
    3, 20) #A` `    });                               #A` `  });                                
    #A`   `  it("can extract its name", function() {` `    expect(user.getName()).to.equal("Douglas
    Reynholm");` `  });`   `  it("can get its age in milliseconds", function() {`
    `    var now = new Date();` `    expect(user.getAge()).to.equal(now - user.birthday);`
    `  });`  `});`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe("User", function() {` `  var user;` `  beforeEach(function() {            
    #A` `    user = new User({                 #A` `      firstName: "Douglas",          
    #A` `      lastName: "Reynholm",           #A` `      birthday: new Date(1975,
    3, 20) #A` `    });                               #A` `  });                                
    #A` `  it("可以提取其名称", function() {` `    expect(user.getName()).to.equal("Douglas
    Reynholm");` `  });` `  it("可以获取其年龄（以毫秒为单位）", function() {` `    var now = new
    Date();` `    expect(user.getAge()).to.equal(now - user.birthday);` `  });` `});`'
- en: '#A This code is run before every single test, so that the user is defined inside
    of every test.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这段代码在每次测试之前都会运行，因此用户定义在每次测试中。'
- en: The code above tests some of the functionality of an imaginary User object,
    but it doesn't have code to redefine an example User object inside of every test
    (inside of every `it` block); it defines them in a `beforeEach` block, which redefines
    the user before running each test.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码测试了一个虚构的用户对象的某些功能，但它没有在每个测试（每个 `it` 块）中重新定义示例用户对象的代码；它是在 `beforeEach` 块中定义的，在每个测试运行之前重新定义用户。
- en: TESTING FOR ERRORS
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 测试错误
- en: If we pass a string to our capitalization function, everything should work normally.
    But if we pass a non-string, like a number or `undefined`, we want our function
    to throw some kind of error. We can use Chai to test this.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向我们的大写函数传递一个字符串，一切应该正常工作。但如果我们传递一个非字符串，比如一个数字或 `undefined`，我们希望我们的函数抛出某种错误。我们可以使用
    Chai 来测试这一点。
- en: Listing 9.10 Using Chai to test for errors
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 使用 Chai 测试错误
- en: '`// …`   `it("throws an error if passed a number", function() {` `  expect(function()
    { capitalize(123); }).to.throw(Error);` `});`  `// …`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `it("如果传入数字则抛出错误", function() {` `  expect(function() { capitalize(123);
    }).to.throw(Error);` `});` `// …`'
- en: This will test that calling `capitalize` with `123` throws an error. The only
    tricky bit is that we have to wrap it in a function. This is because we don't
    want our test code to create an error—we want that error to be caught by Chai.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将测试调用 `capitalize` 函数并传入 `123` 会抛出错误。唯一棘手的地方是我们必须将其包裹在一个函数中。这是因为我们不希望我们的测试代码创建错误——我们希望这个错误被
    Chai 捕获。
- en: REVERSING TESTS
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 反转测试
- en: We might want to test that a value equals another value or that a function throws
    an error, but we might also want to test that a value doesn't equal another value
    or that a function doesn't throw an error. In the spirit of Chai's almost-readable-as-English
    syntax, we can use `.not` to reverse our test.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要测试一个值是否等于另一个值，或者一个函数是否抛出错误，但我们也可能想要测试一个值不等于另一个值，或者一个函数不抛出错误。在 Chai 几乎可以像英语一样阅读的语法精神下，我们可以使用
    `.not` 来反转我们的测试。
- en: Let's say that we want to make sure that capitalizing “foo” doesn't equal “foo”.
    This is a bit of a contrived example, but we might want to make sure that our
    capitalization function does something.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要确保将“foo”大写后不等于“foo”。这是一个有点牵强的例子，但我们可能想要确保我们的大写函数确实做了些什么。
- en: Listing 9.11 Negating tests
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.11 否定测试
- en: '`// ...`   `it("changes the value", function() {` `  expect(capitalize("foo")).not.to.equal("foo"); 
    #A` `});`  `// …`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`// ...` `it("改变值", function() {` `  expect(capitalize("foo")).not.to.equal("foo"); 
    #A` `});` `// …`'
- en: '#A Notice the .not in there; that''s reversing our condition.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '# 注意到其中的 `.not`；这是反转我们的条件。'
- en: We've only begun to scratch the surface of what Chai can do. For more of its
    features, check out the documentation at [http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是刚刚触及 Chai 能做什么的表面。有关更多功能，请查看 [http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/)
    的文档。
- en: 9.3     Testing Express servers with Supertest
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 使用 Supertest 测试 Express 服务器
- en: The techniques above are useful for testing “business logic” like model behavior
    or utility functions. These are often called "unit tests"; they test discrete
    units of your app. But you might also want to test the routes or middleware of
    your Express applications. You might want to make sure that your API endpoints
    are returning the values they should, or that you're serving static files, or
    a number of other things. These are often called "integration tests" because they
    test the integrated system as a whole, rather than individual pieces in isolation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上述技术对于测试“业务逻辑”如模型行为或实用函数很有用。这些通常被称为“单元测试”；它们测试应用程序的离散单元。但你也可能想要测试 Express 应用程序的路线或中间件。你可能想要确保你的
    API 端点返回了它们应该返回的值，或者你正在提供静态文件，或者许多其他事情。这些通常被称为“集成测试”，因为它们测试的是整个集成系统，而不是孤立的各个部分。
- en: We'll use Supertest to accomplish this. Supertest spools up our Express server
    and sends requests to it. Once the requests come back, we can make assertions
    about the response. For example, we might want to make sure that we get an HTTP
    200 status code when we send a GET request to the homepage. Supertest will send
    that GET request to the homepage and then, when we get the response, make sure
    it had 200 as its HTTP status code. We can use this to test and middleware or
    route that we define in our application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Supertest 来完成这个任务。Supertest 启动我们的 Express 服务器并向其发送请求。一旦请求返回，我们就可以对响应进行断言。例如，我们可能想要确保当我们向主页发送
    GET 请求时，我们得到 HTTP 200 状态码。Supertest 将发送 GET 请求到主页，然后在我们收到响应时，确保其 HTTP 状态码为 200。我们可以使用这种方法来测试我们在应用程序中定义的中间件或路由。
- en: 'Most browsers send a header called `User-Agent` that identifies the type of
    browser to the server. This is often how websites serve mobile versions of sites
    to you if you''re on your phone: a server can see that you''re on a mobile device
    and send you a different version of the page.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数浏览器都会向服务器发送一个名为 `User-Agent` 的头信息，以标识浏览器的类型。当你用手机浏览网站时，网站通常会根据这个信息为你提供移动版网站：服务器可以看到你正在使用移动设备，并为你发送不同的页面版本。
- en: Let's build “What's My User Agent?”, a simple application for getting the User
    Agent string of your users. It will support a “classic” HTML view when you visit
    it in a browser. You'll also be able to get the user's User Agent as plain text.
    There will be just one route for these two responses. If a visitor comes to the
    root of your site (at `/`) and doesn't request HTML (as most web browsers would),
    they'll be shown their User Agent as plain text. If they visit the same URL but
    their`Accepts` header mentions HTML (like web browsers do), they'll be given their
    User Agent as an HTML page.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建“我的用户代理是什么？”，这是一个简单的应用程序，用于获取用户的用户代理字符串。当你用浏览器访问它时，它将支持“经典”HTML 视图。你还可以以纯文本形式获取用户的用户代理。这两个响应将只有一个路由。如果一个访客来到你网站的根目录（在
    `/`），并且没有请求 HTML（大多数网络浏览器都会这样做），他们将看到他们的用户代理作为纯文本。如果他们访问相同的 URL，但他们的 `Accepts`
    头信息提到了 HTML（就像网络浏览器一样），他们将得到他们的用户代理作为 HTML 页面。
- en: 'Create a new directory for this project, and create a package file in the folder:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为此项目创建一个新的目录，并在文件夹中创建一个包文件：
- en: Listing 9.12 package.json for “What's my User Agent?”
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.12 “我的用户代理是什么？”的package.json
- en: '`{` `  "name": "whats-my-user-agent",` `  "private": true,` `  "scripts": {`
    `    "start": "node app",` `    "test": "mocha"` `  },` `  "dependencies": {`
    `    "ejs": "^1.0.0",       #A` `    "express": "^4.10.1"` `  },` `  "devDependencies":
    {` `    "mocha": "^2.0.1",` `    "cheerio": "^0.17.0",  #B` `    "supertest":
    "^0.14.0" #C` `  }``}`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`{`   `  "name": "whats-my-user-agent",`   `  "private": true,`   `  "scripts":
    {`   `    "start": "node app",`   `    "test": "mocha"`   `  },`   `  "dependencies":
    {`   `    "ejs": "^1.0.0",       #A`   `    "express": "^4.10.1"`   `  },`   ` 
    "devDependencies": {`   `    "mocha": "^2.0.1",`   `    "cheerio": "^0.17.0", 
    #B`   `    "supertest": "^0.14.0" #C`   `  }``}`'
- en: '#A We''ll use EJS to render the HTML page, as we''ve used before.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 我们将使用EJS来渲染HTML页面，就像我们之前使用的那样。'
- en: '#B Cheerio lets us parse the rendered HTML for testing. We''ll use this to
    make sure the User Agent string is properly inserted into our HTML.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '#B Cheerio让我们能够解析渲染的HTML进行测试。我们将使用它来确保用户代理字符串被正确地插入到我们的HTML中。'
- en: '#C Supertest lets us spool up Express servers and test them. We''ll use Supertest
    to test both of our application''s routes.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '#C Supertest允许我们启动Express服务器并对其进行测试。我们将使用Supertest测试我们应用程序的两个路由。'
- en: In the previous examples, we wrote our code and then wrote the tests. In this
    example, we'll flip it around and do test-driven development. We know what we
    want our application to do, so we can write the tests right now without worry
    about how we implement it. Our tests will fail at first, because we won't have
    written any “real” code! After our tests are written, we'll go back and “fill
    in” the application to make our tests pass.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们先编写了代码，然后编写了测试。在这个例子中，我们将颠倒顺序，进行测试驱动开发。我们知道我们想要应用程序做什么，所以我们可以立即编写测试，而不必担心如何实现它。我们的测试一开始会失败，因为我们还没有编写任何“真正的”代码！在编写完测试后，我们将返回并“填充”应用程序，以使测试通过。
- en: The TDD approach isn't always the best; sometimes you aren't quite sure what
    your code should look like, so it'd be a bit of a waste to write tests. There
    are huge flame wars online about the pros and cons of TDD; I won't reiterate them
    here, but we'll try TDD for this example.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: TDD方法并不总是最好的；有时你并不完全清楚你的代码应该是什么样子，所以编写测试会有些浪费。网上有很多关于TDD优缺点的激烈争论；我不会在这里重复它们，但我们将尝试在这个例子中使用TDD。
- en: 'We will write tests for the two major parts of this application:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个应用程序的两个主要部分编写测试：
- en: 1.  The plain text API
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 纯文本API
- en: 2.  The HTML view
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 2. HTML视图
- en: Let's start by testing the plain text API.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试纯文本API开始。
- en: 9.3.1  Testing a simple API
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 测试简单的API
- en: Because it's the simplest, we'll start by testing the plain text API.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是最简单的，我们将从测试纯文本API开始。
- en: In plain English, this test will need to send a request to our server at the `/` route,
    so the server knows that we want plain text in the first place. We'll want to
    assert that (1) the response is the right User Agent string (2) the responses
    come back as plain text. Let's codify this English into Mocha tests.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的话说，这个测试需要向我们的服务器发送一个对`/`路由的请求，这样服务器就知道我们首先想要纯文本。我们想要断言（1）响应是正确的用户代理字符串（2）响应以纯文本形式返回。让我们将这个英语转化为Mocha测试。
- en: 'Create a folder called `test` for all your tests, and create a file for testing
    the plain text API; I called mine `txt.js`. Inside, put the following skeleton:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有测试创建一个名为`test`的文件夹，并为测试纯文本API创建一个文件；我命名为`txt.js`。在里面，放置以下框架：
- en: Listing 9.13 Skeleton of plain text tests (in test/txt.js)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.13 纯文本测试框架（在test/txt.js中）
- en: '`var app = require("../app");  #A`   `describe("plain text response", function()
    {`   `  it("returns a plain text response", function(done) {  #B` `    // ...`
    `  });`   `  it("returns your User Agent", function(done) {  #B` `    // ...`
    `  });`  `});`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`var app = require("../app");  #A`   `describe("plain text response", function()
    {`   `  it("returns a plain text response", function(done) {  #B` `    // ...`   ` 
    });`   `  it("returns your User Agent", function(done) {  #B`   `    // ...`   ` 
    });`   `});`'
- en: '#A We''ll require our app, because that''s what will be testing. We''ll put
    it inside app.js in the root of our project (but because this is TDD, we haven''t
    actually done this yet).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 我们将引入我们的应用程序，因为这是我们将要测试的。我们将将其放在项目根目录下的app.js中（但由于这是TDD，我们实际上还没有这样做）。'
- en: '#B There will be two tests. One makes sure we get a plain text response, and
    another makes sure we get the correct User Agent string.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 将有两个测试。一个确保我们得到一个纯文本响应，另一个确保我们得到正确的用户代理字符串。'
- en: So far, this is just a skeleton, but it's not too different from what we had
    before when we were testing our capitalization module. We're requiring our app
    (which we haven't written yet!), describing a suite of tests (plain text mode,
    in this case), and then defining two tests.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这只是一个骨架，但它与我们之前测试大写模块时的情况并没有太大不同。我们正在`require`我们的应用（我们还没有编写！），描述一系列测试（在这种情况下是纯文本模式），然后定义两个测试。
- en: 'Let''s fill in the first test, to make sure that our application returns a
    plain text response. Remember: what we''re testing doesn''t exist yet. We''re
    going to write the tests, watch them fail, and then “fill in” the real code to
    make our tests pass.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们填写第一个测试，以确保我们的应用程序返回纯文本响应。记住：我们正在测试的内容还不存在。我们将编写测试，观察它们失败，然后“填写”真正的代码以使测试通过。
- en: Our first test will need to make a request to the server, making sure to set
    the `Accept` header to `text/plain`, and once it gets a response from the server,
    our test should ensure that it comes back as `text/plain`. The Supertest module
    will help us with this, so `require` it at the top of your file. Then we’ll use
    Supertest to make requests to our server and see if it gives us the response we
    want.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一次测试需要向服务器发送请求，确保将`Accept`头设置为`text/plain`，一旦从服务器收到响应，我们的测试应该确保它以`text/plain`返回。Supertest模块将帮助我们完成这项工作，所以请在文件顶部`require`它。然后我们将使用Supertest向我们的服务器发送请求，看看它是否给出了我们想要的响应。
- en: Listing 9.14 Using Supertest to check the response (in test/txt.js)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.14 使用Supertest检查响应（在test/txt.js中）
- en: '`var supertest = require("supertest");`   `// …`   `it("returns a plain text
    response", function(done) {  #A` `  supertest(app)  #B` `    .get("/")     #B`
    `    .set("User-Agent", "my cool browser")  #B` `    .set("Accept", "text/plain") 
    #B` `    .expect("Content-Type", /text\/plain/)  #C` `    .expect(200)  #C` `   
    .end(done);   #A` `});`  `// …`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`var supertest = require("supertest");`   `// …`   `it("返回纯文本响应", function(done)
    {   #A   supertest(app)   #B   .get("/")   #B   .set("User-Agent", "我的酷浏览器")   #B   .set("Accept",
    "text/plain")   #B   .expect("Content-Type", /text\/plain/)   #C   .expect(200)   #C   .end(done);   #A   });`   `//
    …`'
- en: '#A When running asynchronous tests like these, our function is passed a callback.
    We call that callback when we''re all done running our code.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 当运行像这样的异步测试时，我们的函数会接收到一个回调。我们在代码全部运行完成后调用那个回调。'
- en: '#B Supertest builds up the request. We''re testing our app, visiting the “/”
    URL, and setting two HTTP headers: one for the User Agent and one for the types
    of content we accept.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '#B Supertest构建请求。我们正在测试我们的应用，访问“/”URL，并设置两个HTTP头：一个用于用户代理，一个用于我们接受的内容类型。'
- en: '#C Supertest then checks the response, making sure the Content-Type matches
    “text/plain” and that we get a status code of 200.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '#C Supertest随后检查响应，确保Content-Type匹配“text/plain”并且我们得到状态码200。'
- en: 'Notice how we use Supertest to test our application. It''s not quite like Chai
    in that it reads like English, but it should be pretty straightforward. Here''s
    what we''re doing with Supertest, line by line:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何使用Supertest来测试我们的应用的。它并不完全像Chai，因为它读起来像英语，但它应该相当直接。以下是我们在Supertest中逐行所做的事情：
- en: 1.  We wrap our app up by calling `supertest` with `app` as an argument. This
    returns a Supertest object.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  我们通过将`app`作为参数调用`supertest`来包装我们的应用。这返回一个Supertest对象。
- en: 2.  Next, we call `get` on that Supertest object with the route we want to request;
    in this case, we want the application's root (at “/”).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  接下来，我们在那个Supertest对象上调用`get`，使用我们想要请求的路由；在这种情况下，我们想要应用程序的根（在“/”上）。
- en: 3.  Next, we set some options on this request; in this case, we're setting the
    HTTP `Accept` header to `text/plain` and the User-Agent header to "my cool browser".
    We call `set` multiple times because we want to set multiple headers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  接下来，我们在这次请求上设置一些选项；在这种情况下，我们正在设置HTTP `Accept`头为`text/plain`和User-Agent头为"我的酷浏览器"。我们多次调用`set`，因为我们想设置多个头。
- en: 4.  In the first call to `expect`, we say “I want the Content-Type to match
    'text/plain'”. Notice that this is a regular expression, not a string. We want
    to be a little flexible here; the Content-Type could be “text/plain”, or it could
    be “text/plain; charset=utf-8” or something like that. We care to test for the
    plain text content type, but not for the specific character set because it's just
    ASCII in this case, which is the same in most character encodings.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  在第一次调用`expect`时，我们说“我希望Content-Type匹配'text/plain'”。请注意，这是一个正则表达式，而不是一个字符串。我们在这里想有点灵活性；Content-Type可以是“text/plain”，也可以是“text/plain;
    charset=utf-8”或类似的东西。我们关心测试纯文本内容类型，但不关心特定的字符集，因为在这种情况下，它只是ASCII，在大多数字符编码中都是一样的。
- en: 5.  In the second call to `expect`, we're making sure we get the HTTP status
    code of 200, meaning “OK”.  You could imagine writing a test for a nonexistent
    resource, where you'd expect the status code to be 404, or any of the other many
    HTTP status codes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 在第二次调用 `expect` 中，我们确保我们得到 HTTP 状态码 200，表示“OK”。你可以想象编写一个测试来测试一个不存在的资源，你期望状态码为
    404，或者任何其他许多 HTTP 状态码。
- en: 6.  Finally, we call `end` with `done`. `done` is a callback function passed
    to us by Mocha which we use to signal that asynchronous tests (like this one)
    are all done.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 最后，我们调用 `end` 并传递 `done`。`done` 是 Mocha 传递给我们的回调函数，我们用它来表示异步测试（如这个测试）全部完成。
- en: 'Next, let''s fill in our second test to make sure that our application is returning
    the right User Agent. It''ll look pretty similar to the above, but we''ll actually
    test the response body. Let''s fill in our second test:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们填写我们的第二个测试，以确保我们的应用程序返回正确的 User Agent。它看起来将与上面的类似，但我们实际上会测试响应体。让我们填写我们的第二个测试：
- en: Listing 9.15 Testing that our app returns the right User Agent string (in test/txt.js)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.15 测试我们的应用程序返回正确的 User Agent 字符串（在 test/txt.js）
- en: '`// …`   `it("returns your User Agent", function(done) {` `  supertest(app) 
    #A` `    .get("/")     #A` `    .set("User-Agent", "my cool browser")  #A` `   
    .set("Accept", "text/plain")  #A` `    .expect(function(res) {   #B` `      if
    (res.text !== "my cool browser") {  #B` `        throw new Error("Response does
    not contain User Agent");  #B` `      }  #B` `    })   #B` `    .end(done); #C`
    `});`  `// …`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `it("返回你的 User Agent", function(done) {` `  supertest(app)  #A` `   
    .get("/")     #A` `    .set("User-Agent", "my cool browser")  #A` `    .set("Accept",
    "text/plain")  #A` `    .expect(function(res) {   #B` `      if (res.text !==
    "my cool browser") {  #B` `        throw new Error("响应不包含 User Agent");  #B` `     
    }  #B` `    })   #B` `    .end(done); #C` `});` `// …`'
- en: '#A This request setup is the same as before.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这个请求设置与之前相同。'
- en: '#B We call expect with a function that throws an error if we don''t get the
    right User Agent string.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 我们调用 `expect` 并传递一个函数，如果得不到正确的 User Agent 字符串，该函数会抛出错误。'
- en: '#C Once again, we call “done” when we''re done.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 再次，我们在完成后调用“done”。'
- en: The first three lines of this test and the last line should look similar to
    before; we set up Supertest to test our app, and when we're done testing things,
    we call `done`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本测试的前三行和最后一行应与之前相似；我们设置了 Supertest 来测试我们的应用程序，测试完成后，我们调用 `done`。
- en: The middle part calls `expect` with a function this time. This function throws
    an error if `res.text` (the text that our application returns) isn't equal to
    the `User-Agent` header we passed in. If it is equal, then the function simply
    finishes with no fuss.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 中间部分调用 `expect` 并传递一个函数。如果 `res.text`（应用程序返回的文本）不等于我们传递的 `User-Agent` 头信息，则该函数会抛出错误。如果它们相等，则函数简单地结束，没有任何麻烦。
- en: 'One last thing: we''ve got some duplicate code here. In this test, we''re always
    making the same request to our server: the same application, the same route, and
    the same headers. What if we didn''t have to repeat ourselves? Enter Mocha''s`beforeEach` feature:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事：这里有一些重复的代码。在这个测试中，我们总是向我们的服务器发送相同的请求：相同的应用程序、相同的路由和相同的头信息。如果我们不必重复这些操作会怎样？进入
    Mocha 的 `beforeEach` 功能：
- en: Listing 9.16 Reducing repetition in our code with beforeEach (in test/txt.js)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.16 使用 beforeEach 在我们的代码中减少重复（在 test/txt.js）
- en: '`// …`   `describe("plain text response", function() {`   `  var request;`
    `  beforeEach(function() {  #A` `    request = supertest(app)  #A` `      .get("/") 
    #A` `      .set("User-Agent", "my cool browser")  #A` `      .set("Accept", "text/plain"); 
    #A` `  });  #A`   `  it("returns a plain text response", function(done) {` `   
    request  #B` `      .expect("Content-Type", /text\/plain/)` `      .expect(200)`
    `      .end(done);` `  });`   `  it("returns your User Agent", function(done)
    {` `    request  #B` `      .expect(function(res) {` `        if (res.text !==
    "my cool browser") {` `          throw new Error("Response does not contain User
    Agent");` `        }` `      })` `      .end(done);` `  });`  `});`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `describe("纯文本响应", function() {` `  var request;` `  beforeEach(function()
    {  #A` `    request = supertest(app)  #A` `      .get("/")  #A` `      .set("User-Agent",
    "my cool browser")  #A` `      .set("Accept", "text/plain");  #A` `  });  #A`
    `  it("返回纯文本响应", function(done) {` `    request  #B` `      .expect("Content-Type",
    /text\/plain/)` `      .expect(200)` `      .end(done);` `  });` `  it("返回你的 User
    Agent", function(done) {` `    request  #B` `      .expect(function(res) {` `       
    if (res.text !== "my cool browser") {` `          throw new Error("响应不包含 User
    Agent");` `        }` `      })` `      .end(done);` `  });` `});`'
- en: '#A We can use beforeEach to run the same code before every test in this describe
    block. In this case, we''re reassigning the request variable to a new Supertest
    object.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 我们可以使用 `beforeEach` 在这个 `describe` 块中的每个测试之前运行相同的代码。在这种情况下，我们将请求变量重新赋值为一个新的
    Supertest 对象。'
- en: '#B We can use the variable in tests without repeating ourselves.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 我们可以在测试中使用变量而不需要重复。'
- en: As you can see, we're using `beforeEach` to remove repeated code. The benefits
    of this really start to show as you have many tests with the same setup every
    time.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们正在使用`beforeEach`来移除重复的代码。当你有很多测试每次都需要相同的设置时，这种做法的好处才能真正显现出来。
- en: 'Now that we''ve written our two tests, let''s run them with `npm test` as a
    sanity check. Because we haven''t even made the file where our app will live,
    you should get an error that contains something like “Cannot find module ''../app''”.
    This is exactly what we expect at this point: we''ve written the tests but no
    real code, so how in the world could our tests pass? This is the “red” step in
    the red-green-refactor cycle.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了两个测试，让我们用`npm test`来做一个理智的检查。因为我们还没有创建应用程序将要存放的文件，你应该会得到一个包含类似“无法找到模块
    '../app'"的错误。这正是我们目前所期望的：我们已经编写了测试，但没有真正的代码，那么我们的测试怎么可能通过呢？这是红-绿-重构周期中的“红色”步骤。
- en: 'You can make the errors a little better by creating `app.js` in the root of
    your project and putting a skeleton Express app inside, like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在项目的根目录中创建`app.js`并在其中放入一个骨架Express应用程序来使错误变得更好：
- en: Listing 9.17 Skeleton of app.js
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.17 app.js的骨架
- en: '`var express = require("express");`   `var app = express();`  `module.exports
    = app;`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var app = express();` `module.exports
    = app;`'
- en: 'Your tests will still fail when running `npm test`. Your errors might look
    something like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`npm test`时，你的测试仍然会失败。你的错误可能看起来像这样：
- en: '`  html response` `    1) returns an HTML response` `    2) returns your User
    Agent`   `  plain text response` `    3) returns a plain text response` `    4)
    returns your User Agent`   `  0 passing (68ms)` `  4 failing`   `  1) html response
    returns an HTML response:` `     Error: expected 200 "OK", got 404 "Not Found"`
    `       ...`   `  2) html response returns your User Agent:` `     TypeError:
    Cannot read property ''trim'' of null` `       ...`   `  3) plain text response
    returns a plain text response:` `     Error: expected "Content-Type" matching
    /text\/plain/, got "text/html; charset=utf-8"` `       ...`   `  4) plain text
    response returns your User Agent:` `     Error: Response does not contain User
    Agent``       ...`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`  html响应` `    1) 返回一个HTML响应` `    2) 返回你的用户代理` `  纯文本响应` `    3) 返回一个纯文本响应`
    `    4) 返回你的用户代理` `  0个通过（68ms）` `  4个失败` `  1) html响应返回一个HTML响应:` `     错误：期望200
    "OK"，但得到404 "未找到"` `       ...` `  2) html响应返回你的用户代理:` `     类型错误：无法读取null的''trim''属性`
    `       ...` `  3) 纯文本响应返回一个纯文本响应:` `     错误：期望"Content-Type"匹配/text/plain/，但得到"text/html;
    charset=utf-8"` `       ...` `  4) 纯文本响应返回你的用户代理:` `     错误：响应不包含用户代理` `      
    ...`'
- en: No doubt, these are errors. But these errors are already leagues better than
    "cannot find module". We can see that real things are being tested here.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，这些都是错误。但这些错误已经远远优于“无法找到模块”。我们可以看到，这里正在进行真正的测试。
- en: Let's write our application to make these tests go from red (failing) to green
    (passing).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写应用程序，让这些测试从红色（失败）变为绿色（通过）。
- en: 9.3.2  Filling in the code for our first tests
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2  为我们的第一个测试填充代码
- en: 'Now that it''s time to write some “real” code, put the following inside `app.js` in
    the root of your project:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写一些“真实”的代码了，将以下内容放入项目的根目录下的`app.js`中：
- en: Listing 9.18 First draft of app.js
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.18 app.js的第一个草稿
- en: '`var express = require("express");`   `var app = express();`   `app.set("port",
    process.env.PORT || 3000);`   `app.get("/", function(req, res) { #A` `  res.send(req.headers["user-agent"]);
    #A` `}); #A`   `app.listen(app.get("port"), function() {` `  console.log("App
    started on port " + app.get("port"));` `});`  `module.exports = app; #B`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var app = express();` `app.set("port",
    process.env.PORT || 3000);` `app.get("/", function(req, res) { #A ` `  res.send(req.headers["user-agent"]);
    #A ` `}); #A ` `app.listen(app.get("port"), function() {` `  console.log("App
    started on port " + app.get("port"));` `});` `module.exports = app; #B`'
- en: '#A We write some code to return the User-Agent header.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 我们编写一些代码来返回用户代理头。'
- en: '#B Export the app for testing.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 导出app以供测试。'
- en: 'The last line is the only thing that might seem new: we export the app. Normally,
    when you''re just running a file (like `node app.js`), you don''t need to export
    the app because you don''t think of it as a module. But when you''re testing the
    application, you''ll need to export it so that the outside world can poke at it
    and test it.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这一行可能看起来有些新：我们导出了app。通常，当你只是运行一个文件（如`node app.js`）时，你不需要导出app，因为你不会把它当作一个模块。但当你测试应用程序时，你需要导出它，这样外部世界就可以对其进行探索和测试。
- en: 'If you run `npm test` now, you''ll see something like the following output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行 `npm test`，你会看到以下类似输出：
- en: '`plain text response` `  1) returns a plain text response` `  ✓returns your
    User Agent`   `1 passing (29ms)` `1 failing`   `1) plain text response returns
    a plain text response:` `   Error: expected "Content-Type" matching /text\/plain/,
    got "text/html; charset=utf-8"` `    at Test.assert …``    …`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`纯文本响应` `  1) 返回纯文本响应` `  ✓返回你的用户代理` `  1 通过 (29ms)` `  1 失败` `  1) 纯文本响应返回纯文本响应:`
    `   错误：期望 "Content-Type" 匹配 /text/plain/，但得到 "text/html; charset=utf-8"` `   
    在 Test.assert …``    …`'
- en: 'This is good! We''re not all the way done because only half of our tests pass,
    but it looks like we''re returning the right User Agent. Add just one more line
    to make all of our tests pass:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好！我们还没有完全完成，因为只有一半的测试通过，但看起来我们正在返回正确的用户代理。只需添加一行代码就可以让所有测试通过：
- en: Listing 9.19 Making app.js return plain text
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.19 使 app.js 返回纯文本
- en: '`// …`   `app.get("/", function(req, res) {` `  res.type("text");  #A` `  res.send(req.headers["user-agent"]);`
    `});`  `// …`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `app.get("/", function(req, res) {` `  res.type("text");  #A` `  res.send(req.headers["user-agent"]);`
    `});` `// …`'
- en: '#A The new line: make sure the Content-Type is some variant of plain text.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 确保内容类型是纯文本的某种变体。'
- en: Now, when you run `npm test`, you'll see all of your tests pass!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行 `npm test` 时，你会看到所有的测试都通过了！
- en: '`plain text response` `  ✓ returns a plain text response` `  ✓ returns your
    User Agent`  `2 passing (38ms)`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`纯文本响应` `  ✓ 返回纯文本响应` `  ✓ 返回你的用户代理` `  2 通过 (38ms)`'
- en: 'This is great; we''re now returning the plain text responses we desire. Now
    we’re done with the “green” step in the red-green-refactor cycle. In this case
    the final refactor step is simple: we don’t have to do anything. Our code is so
    short and sweet that it doesn’t really need much of a clean up yet.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了；我们现在正在返回我们想要的纯文本响应。现在我们已经完成了红-绿-重构循环中的“绿色”步骤。在这种情况下，最终的重构步骤很简单：我们不需要做任何事情。我们的代码如此简短且优美，以至于目前还不需要太多清理。
- en: But wait, didn't we also want to return HTML responses, too? Our tests shouldn't
    be passing yet, should they? You're right, wise reader. Let's write some more
    tests and go back to the “red” step.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，我们不是也想返回 HTML 响应吗？我们的测试不应该通过，对吧？你是对的，明智的读者。让我们编写更多的测试，并回到“红色”步骤。
- en: 9.3.3  Testing HTML responses
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3 测试 HTML 响应
- en: As we've seen, if the user requests plain text, then they'll get plain text.
    But if they want HTML, they should get HTML, but they're just getting plain text
    right now. To fix this “the TDD way”, we'll write some tests to make sure the
    HTML stuff works, we'll watch those tests fail, and then we'll fill in the rest
    of the code.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，如果用户请求纯文本，那么他们会得到纯文本。但如果他们想要 HTML，他们应该得到 HTML，但现在他们只是得到了纯文本。为了“测试驱动开发”的方式解决这个问题，我们将编写一些测试来确保
    HTML 功能正常，我们会观察这些测试失败，然后填写其余的代码。
- en: 'Create `test/html.js` which will hold the tests for the HTML part of our server.
    The skeleton for this file will look pretty similar to what we''ve seen in the
    plain text part of our tests, but the “innards” of one of them will look pretty
    different. Here''s the skeleton of the HTML tests:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `test/html.js`，它将包含我们服务器 HTML 部分的测试。这个文件的骨架将看起来与我们在纯文本测试部分看到的非常相似，但其中之一的内容将看起来相当不同。以下是
    HTML 测试的骨架：
- en: Listing 9.20 Testing our HTML responses (in test/html.js)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.20 测试我们的 HTML 响应（在 test/html.js 中）
- en: '`var app = require("../app");`   `var supertest = require("supertest");`  
    `describe("html response", function() {`   `  var request;` `  beforeEach(function()
    {` `    request = supertest(app)  #A` `      .get("/")  #A` `      .set("User-Agent",
    "a cool browser")  #A` `      .set("Accept", "text/html");  #A` `  });`   `  it("returns
    an HTML response", function(done) {` `    // …` `  });`   `  it("returns your
    User Agent", function(done) {` `    // …` `  });`  `});`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`var app = require("../app");` `var supertest = require("supertest");` `describe("HTML
    响应", function() {` `  var request;` `  beforeEach(function() {` `    request =
    supertest(app)  #A` `      .get("/")  #A` `      .set("User-Agent", "一个酷炫的浏览器") 
    #A` `      .set("Accept", "text/html");  #A` `  });` `  it("返回 HTML 响应", function(done)
    {` `    // …` `  });` `  it("返回你的用户代理", function(done) {` `    // …` `  });` `});`'
- en: '#A This beforeEach is very similar to before, but we''re requesting text/html
    instead of text/plain.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这个 beforeEach 与之前非常相似，但我们请求的是 text/html 而不是 text/plain。'
- en: So far, this should look a lot like the code we had from our plain text tests.
    We're requiring the app and Supertest; we're doing some test setup in a `beforeEach` block;
    we're making sure we're getting HTML back and also the right User Agent.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这应该看起来与我们的纯文本测试中的代码非常相似。我们正在引入 app 和 Supertest；我们在 `beforeEach` 块中进行一些测试设置；我们确保我们得到的是
    HTML 响应，并且还有正确的用户代理。
- en: 'The first test in this file also looks pretty darn similar to the first one
    we wrote in the other file. Let''s fill it in now:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的第一个测试与我们在另一个文件中编写的第一个测试非常相似。现在让我们来填充它：
- en: Listing 9.21 Testing for an HTML response (in test/html.js)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.21 测试HTML响应（在test/html.js中）
- en: '`// …`   `it("returns an HTML response", function(done) {` `  request` `   
    .expect("Content-Type", /html/)` `    .expect(200)` `    .end(done);` `});`  `//
    …`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …`   `it("返回HTML响应", function(done) {` `  request` `    .expect("Content-Type",
    /html/)` `    .expect(200)` `    .end(done);` `});`  `// …`'
- en: This is very similar to before. We're testing for a response that contains “html”
    and we want the HTTP status code to be 200.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前非常相似。我们正在测试一个包含“html”的响应，并希望HTTP状态码为200。
- en: The next test is where things get pretty different.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试将展示一些相当不同的内容。
- en: 'First, let''s write the code to get the HTML response from the server. This
    should look pretty similar to what we''ve seen before:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写从服务器获取HTML响应的代码。这应该与之前看到的大致相同：
- en: Listing 9.22 Getting the HTML response (in test/html.js)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.22 获取HTML响应（在test/html.js中）
- en: '`// …`   `it("returns your User Agent", function(done) {` `  request` `   
    .expect(function(res) {` `      var htmlResponse = res.text;` `      // …` `   
    })` `    .end(done);` `});`  `// …`'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …`   `it("返回您的用户代理", function(done) {` `  request` `    .expect(function(res)
    {` `      var htmlResponse = res.text;` `      // …` `    })` `    .end(done);`
    `});`  `// …`'
- en: 'But now it''s time to do something with that HTML. We don''t just want the
    User Agent string to show up somewhere in the HTML. We want it to show up inside
    a specific HTML tag. Our response will look something like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在是我们对HTML做些事情的时候了。我们不仅希望用户代理字符串出现在HTML的某个地方，我们希望它出现在一个特定的HTML标签内。我们的响应将类似于以下这样：
- en: Listing 9.23 What we might be looking for in our HTML responses
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.23 我们可能在HTML响应中寻找的内容
- en: '`<!DOCTYPE html>` `<html>` `<head>` `  <meta charset="utf-8">` `</head>` `<body>`
    `  <h1>Your User Agent is:</h1>` ``   `<p class="user-agent">Mozilla/5.0 (Windows
    NT 6.1; WOW64; rv:28.0) Gecko/20100101 Firefox/36.0</p>` `` `</body>``</html>`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`<!DOCTYPE html>` `<html>` `<head>` `  <meta charset="utf-8">` `</head>` `<body>`
    `  <h1>您的用户代理是：</h1>` ``   `<p class="user-agent">Mozilla/5.0 (Windows NT 6.1;
    WOW64; rv:28.0) Gecko/20100101 Firefox/36.0</p>` `` `</body>``</html>`'
- en: We don't care too much about most of this HTML; the thing we care to test is
    inside something with the class `user-agent`. How do we get it out?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对大多数HTML并不太关心；我们真正关心测试的是具有`user-agent`类的元素中的内容。我们如何获取它？
- en: Enter Cheerio, the final dependency from our list of devDependencies. In short,
    Cheerio is jQuery for Node. That might sound silly—why would you need to deal
    with the DOM in an environment that doesn't have a DOM?—but it's exactly what
    we need here. We need to be able to look through the HTML and find the User Agent
    inside. If we were in the browser, we could use jQuery to do this. Because we're
    in Node, we'll use Cheerio, which will be very familiar to anyone who knows jQuery.
    We'll use Cheerio to parse the HTML, find where the User Agent should be, and
    make sure that it's valid.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 进入Cheerio，这是我们devDependencies列表中的最后一个依赖项。简而言之，Cheerio是Node.js版本的jQuery。这听起来可能有些荒谬——为什么需要在没有DOM的环境中处理DOM呢？——但这正是我们在这里需要的。我们需要能够遍历HTML并找到其中的用户代理。如果我们处于浏览器中，我们可以使用jQuery来完成这个任务。因为我们处于Node.js环境中，我们将使用Cheerio，这对于任何了解jQuery的人来说都非常熟悉。我们将使用Cheerio来解析HTML，找到用户代理应该出现的位置，并确保它是有效的。
- en: Start by requiring Cheerio at the top of your test file, and then we'll use
    Cheerio to parse the HTML we get from our server.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在测试文件的顶部引入Cheerio，然后我们将使用Cheerio来解析我们从服务器获取的HTML。
- en: Listing 9.24 Parsing HTML with Cheerio (in test/html.js)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.24 使用Cheerio解析HTML（在test/html.js中）
- en: '`// …`   `var cheerio = require("cheerio");`   `// …`   `it("returns your User
    Agent", function(done) {` `  request` `    .expect(function(res) {` `      var
    htmlResponse = res.text;` `      var $ = cheerio.load(htmlResponse);  #A` `     
    var userAgent = $(".user-agent").html().trim();  #B` `      if (userAgent !==
    "a cool browser") {  #C` `        throw new Error("User Agent not found");  #C`
    `      }  #C` `    })` `    .end(done);` `});`  `// …`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …`   `var cheerio = require("cheerio");`   `// …`   `it("返回您的用户代理", function(done)
    {` `  request` `    .expect(function(res) {` `      var htmlResponse = res.text;`
    `      var $ = cheerio.load(htmlResponse);  #A` `      var userAgent = $(".user-agent").html().trim(); 
    #B` `      if (userAgent !== "一个酷炫的浏览器") {  #C` `        throw new Error("用户代理未找到"); 
    #C` `      }  #C` `    })` `    .end(done);` `});`  `// …`'
- en: '#A Initialize a Cheerio object from our HTML.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 从我们的HTML中初始化一个Cheerio对象。'
- en: '#B Get the User Agent from the HTML. This should look a lot like jQuery.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 从HTML中获取用户代理。这应该与jQuery非常相似。'
- en: '#C Test for an User Agent just like before.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 测试用户代理，就像之前一样。'
- en: Here, we use Cheerio to parse our HTML and make sense of it like we do with
    jQuery. Once we've parsed the HTML and gotten the value we want, we run our tests
    just like before! Cheerio makes parsing HTML easy, and you can use it to test
    HTML responses.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Cheerio解析我们的HTML，就像我们使用jQuery一样。一旦我们解析了HTML并获取了我们想要的值，我们就像以前一样运行我们的测试！Cheerio使解析HTML变得容易，你可以用它来测试HTML响应。
- en: Now that we've written our two tests, we can run `npm test`. We should see our
    plain text tests pass as before, but our new HTML tests will fail because we haven't
    written the code yet—this is the “red” step. Let's make those tests pass.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了两个测试，我们可以运行 `npm test`。我们应该看到我们的纯文本测试像以前一样通过，但我们的新HTML测试会失败，因为我们还没有编写代码——这就是“红色”步骤。让我们让这些测试通过。
- en: If you've been following along so far, the code for this shouldn't be too crazy.
    We'll make some changes to our request handler, and render an EJS view which will
    contain the User Agent as our test expects.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直跟着做，这段代码不应该太疯狂。我们将对我们的请求处理器做一些修改，并渲染一个包含用户代理的EJS视图，正如我们的测试所期望的那样。
- en: First, let's make some modifications to `app.js`. We'll set up EJS as our view
    engine and then render the HTML view when the client wants HTML.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们对 `app.js` 进行一些修改。我们将设置EJS作为我们的视图引擎，然后在客户端需要HTML时渲染HTML视图。
- en: Listing 9.25 Filling in app.js to support HTML responses
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.25 填充app.js以支持HTML响应
- en: '`var express = require("express");` `var path = require("path");`   `var app
    = express();`   `app.set("port", process.env.PORT || 3000);`   `var viewsPath
    = path.join(__dirname, "views"); #A` `app.set("view engine", "ejs");                
    #A` `app.set("views", viewsPath);                   #A`   `app.get("/", function(req,
    res) {` `  var userAgent = req.headers["user-agent"] || "none";`   `  if (req.accepts("html"))
    {              #B` `    res.render("index", { userAgent: userAgent });  #B` ` 
    } else {` `    res.type("text");  #C` `    res.send(userAgent);  #C` `  }` `});`
     `// …`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var path = require("path");`   `var app
    = express();`   `app.set("port", process.env.PORT || 3000);`   `var viewsPath
    = path.join(__dirname, "views"); #A` `app.set("view engine", "ejs");                
    #A` `app.set("views", viewsPath);                   #A`   `app.get("/", function(req,
    res) {` `  var userAgent = req.headers["user-agent"] || "none";`   `  if (req.accepts("html"))
    {              #B` `    res.render("index", { userAgent: userAgent });  #B` ` 
    } else {` `    res.type("text");  #C` `    res.send(userAgent);  #C` `  }` `});`
     `// …`'
- en: '#A Set up our views with EJS and make sure we''re using the “views” directory.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 设置我们的视图使用EJS并确保我们使用“views”目录。'
- en: '#B If the request accepts HTML, render the “index” template (which we''ll define
    in a moment).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 如果请求接受HTML，渲染“index”模板（我们将在稍后定义）。'
- en: '#C Otherwise, send the User Agent string as plain text as we''ve done before.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 否则，像我们以前做的那样，将用户代理字符串作为纯文本发送。'
- en: This code shouldn't be too wild if you've seen views before. We're setting up
    EJS as our view engine, assigning a path to it, and then rendering a view if the
    user requests it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前见过视图，这段代码不应该太疯狂。我们正在设置EJS作为我们的视图引擎，为其分配一个路径，然后在用户请求时渲染一个视图。
- en: 'The last thing we''ll need to do is define the EJS view. Create `views/index.ejs` and
    put the following code inside:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是定义EJS视图。创建 `views/index.ejs` 并将以下代码放入其中：
- en: Listing 9.26 views/index.ejs
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.26 views/index.ejs
- en: '`<!DOCTYPE html>` `<html>` `<head>` `  <meta charset="utf-8">` `  <style>`
    `  html {` `    font-family: sans-serif;` `    text-align: center;` `  }` `  </style>`
    `</head>` `<body>` `  <h2>Your User Agent is:</h2>` `  <h1 class="user-agent">`
    `    <%= userAgent %>` `  </h1>` `</body>``</html>`'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`<!DOCTYPE html>` `<html>` `<head>` `  <meta charset="utf-8">` `  <style>`
    `  html {` `    font-family: sans-serif;` `    text-align: center;` `  }` `  </style>`
    `</head>` `<body>` `  <h2>Your User Agent is:</h2>` `  <h1 class="user-agent">`
    `    <%= userAgent %>` `  </h1>` `</body>``</html>`'
- en: 'It''s time for the big moment. Run all of your tests with `npm test`, and you
    should see a sea of positivity:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是关键时刻。使用 `npm test` 运行所有测试，你应该看到一片积极：
- en: '`html response` `  ✓ returns an HTML response` `  ✓ returns your User Agent`
      `plain text response` `  ✓ returns a plain text response` `  ✓ returns your
    User Agent`  `4 passing (95ms)`'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`html response` `  ✓ 返回HTML响应` `  ✓ 返回你的用户代理` `plain text response` `  ✓ 返回纯文本响应`
    `  ✓ 返回你的用户代理` `  4 passing (95ms)`'
- en: All of your tests pass! It’s all green! Happy days! Now you know how to test
    an application with Mocha, Chai, Supertest, and Cheerio.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 所有你的测试都通过了！一切都很绿色！好日子！现在你知道如何使用Mocha、Chai、Supertest和Cheerio测试应用程序了。
- en: 'The biggest takeaway from this chapter isn''t a series of tools: it''s the
    fact that through testing, you can be much more confident about your application''s
    behavior. When we write code, we want our code to work as we intend. That is often
    hard to do, but with testing, we can be a little surer that things work as we
    intend.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最大收获并不是一系列工具：而是通过测试，你可以对自己的应用程序行为更加自信。当我们编写代码时，我们希望我们的代码能按我们的意图工作。这通常很难做到，但有了测试，我们可以更有信心地认为事情会按我们的意图进行。
- en: 9.4     Summary
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4     总结
- en: 'In this chapter, we''ve learned:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了：
- en: ·  What testing is and how it helps us to be more confident about our code's
    behavior
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ·  测试是什么以及它如何帮助我们对自己的代码行为更有信心
- en: ·  Different ways to test and common practices, like test-driven development
    and “test as much as possible”
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ·  不同的测试方法和常见实践，如测试驱动开发和“尽可能多地测试”
- en: ·  How to run tests in Node.js with Mocha and Chai
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何使用 Mocha 和 Chai 在 Node.js 中运行测试
- en: ·  How to use Mocha and Supertest to test “real”  Express servers
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何使用 Mocha 和 Supertest 测试“真实”的 Express 服务器
- en: ·  How to test HTML responses with Cheerio
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何使用 Cheerio 测试 HTML 响应
