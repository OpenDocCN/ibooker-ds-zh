- en: Lesson 14\. Making more-complicated decisions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第14课\. 做更复杂的决策
- en: After reading [lesson 14](#ch14), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完[第14课](#ch14)后，你将能够
- en: Combine many decisions in one conditional statement
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个条件语句中组合许多决定
- en: Make a choice when presented with various options
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在面对各种选项时做出选择
- en: Write code that gets the computer to decide between a few choices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写代码让计算机在几个选择之间做出决定
- en: 'It’s limiting and time-consuming if every decision you make is the result of
    asking only one question at a time. Say you want to buy a new phone. There are
    only three phones that you’re considering, but you’re not sure how much money
    you have in your bank account. Additionally, one other criteria is that the phone
    is available in green. Using yes or no questions, you could ask the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你每次只问一个问题来做决定，这会限制你的选择并耗费时间。比如说，你想买一部新手机。你只考虑了三部手机，但你不确定银行账户里有多少钱。另外，还有一个条件是手机必须是绿色的。使用是或否的问题，你可以问以下问题：
- en: Do I have between $400 and $600?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的银行账户里是否有400到600美元？
- en: Do I have between $200 and $400?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的银行账户里是否有200到400美元？
- en: Do I have between $0 and $100?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的银行账户里是否有0到100美元？
- en: Does Phone 1 come in green?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手机1有绿色款吗？
- en: Does Phone 2 come in green?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手机2有绿色款吗？
- en: Does Phone 3 come in green?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手机3有绿色款吗？
- en: Because you have more than one condition you want to check, you can combine
    two (or more) together. For example, you could ask, “Do I have between $400 and
    $600, and does Phone 1 come in green?”
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你需要检查多个条件，你可以将两个（或更多）条件组合在一起。例如，你可以问，“我的银行账户里是否有400到600美元，并且手机1有绿色款吗？”
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: You’re seven years old and are trying to choose your best friend based on the
    sports that you both play. The order of importance of sports is soccer, basketball,
    and baseball. You want to have as many sports as possible in common. If that isn’t
    possible, you want your friend to play as many sports as possible from that preferred
    order. List all the possible combinations of sports in order. Tommy plays soccer
    and baseball. How many choices down in the list is he?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你7岁，正在尝试根据你们共同参加的体育项目来选择你的最好朋友。体育项目的优先顺序是足球、篮球和棒球。你希望尽可能多地拥有共同的体育项目。如果不可能，你希望你的朋友尽可能多地从你喜欢的顺序中玩体育项目。按顺序列出所有可能的体育项目组合。汤米踢足球和打棒球。他在列表中的哪个位置有选择？
- en: 'Answer:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：
- en: '| soccer and basketball and baseball |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 足球和篮球和棒球 |'
- en: '| soccer and basketball |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 足球和篮球 |'
- en: '| soccer and baseball | <----- Three choices down |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 足球和棒球 | <----- 三个选择以下 |'
- en: '| basketball and baseball |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 篮球和棒球 |'
- en: '| soccer |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 足球 |'
- en: '| basketball |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 篮球 |'
- en: '| baseball |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 棒球 |'
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.1\. Combining multiple conditions
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1\. 组合多个条件
- en: You know how to write code that depends on whether one condition is true. This
    means deciding “this or not this.” Sometimes, the decision you want to make might
    be “this or that or that or some other thing.”
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道如何编写依赖于一个条件是否为真的代码。这意味着决定“这个或不是这个”。有时，你想要做的决定可能是“这个或那个或那个或其它什么”。
- en: For example, if “It is raining” is true and “I am hungry” is false, then “It
    is raining and I am hungry” is false. [Table 14.1](#ch14table01) shows the truth
    values of statements made up of two statements.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果“正在下雨”是真的，而“我饿了”是假的，那么“正在下雨并且我饿了”是假的。[表14.1](#ch14table01)显示了由两个陈述组成的语句的真值。
- en: Table 14.1\. Truth values for combinations of two statements with “and” and
    “or”
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.1\. “和”和“或”组合的两个陈述的真值
- en: '| Statement 1 (example: “It is raining”) | Word to combine the statements (<and>,
    <or>, <not>) | Statement 2 (example: “I am hungry”) | Result (example: “It is
    raining <*_*> I am hungry”) |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 陈述1（例如：“正在下雨”） | 结合语句的词（<和>，<或>，<非>） | 陈述2（例如：“我饿了”） | 结果（例如：“正在下雨 <*_*>
    我饿了”） |'
- en: '| --- | --- | --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| True | <and> | True | True |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 真 | <和> | 真 | 真 |'
- en: '| True | <and> | False | False |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 真 | <和> | 假 | 假 |'
- en: '| False | <and> | True | False |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 假 | <和> | 真 | 假 |'
- en: '| False | <and> | False | False |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 假 | <和> | 假 | 假 |'
- en: '| True | <or> | True | True |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 真 | <或> | 真 | 真 |'
- en: '| True | <or> | False | True |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 真 | <或> | 假 | 真 |'
- en: '| False | <or> | True | True |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 假 | <或> | 真 | 真 |'
- en: '| False | <or> | False | False |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 假 | <或> | 假 | 假 |'
- en: '| N/A | <not> | True | False |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| N/A | <非> | 真 | 假 |'
- en: '| N/A | <not> | False | True |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| N/A | <非> | 假 | 真 |'
- en: Suppose you’re making a simple pasta dinner. How do you think about making it?
    You ask yourself whether you have pasta and pasta sauce. If you have both, you
    can make your pasta dinner. Notice that a couple of ideas arise from this simple
    question.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在准备一顿简单的意大利面晚餐。你是怎么考虑做的？你问问自己是否有意大利面和意大利面酱。如果你两者都有，你就可以做你的意大利面晚餐。注意，从这个简单的问题中产生了几个想法。
- en: 'One idea is that you combined two questions in one: *Do you have pasta and
    pasta sauce?* These questions could be asked in a different way, in a nested fashion,
    which would end up giving you the same final answer: *Do you have pasta? If yes,
    do you have pasta sauce?* But combining the two questions in one is easier to
    understand.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个想法是你将两个问题合并为一个：*你有意大利面和意大利面酱吗？* 这些问题可以用不同的方式提出，以嵌套的方式，最终会得到相同的最终答案：*你有意大利面吗？如果是，你有意大利面酱吗？*
    但是将两个问题合并在一起更容易理解。
- en: The other idea is that you used an important word, *and*, to link two questions
    that have yes/no answers. The word *and* and the word *or* are both Boolean operators,
    which are used to link two questions that have yes/no answers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个想法是你使用了一个重要的词，*and*，来连接两个有是/否答案的问题。词 *and* 和词 *or* 都是布尔运算符，它们用于连接有是/否答案的问题。
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 14.1**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 14.1**'
- en: 'Combine the following questions by using the Boolean operators `and`/`or`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔运算符 `and`/`or` 结合以下问题：
- en: '**[1](kindle_split_056.html#app01qa59q0a1)**'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa59q0a1)**'
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you need milk? If yes, do you have a car? If yes, drive to the store and
    buy milk.
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你需要牛奶吗？如果是，你有车吗？如果是，开车去商店买牛奶。
- en: '**[2](kindle_split_056.html#app01qa59q0a2)**'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa59q0a2)**'
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is variable `a` zero? If yes, is variable `b` zero? If yes, is variable `c`
    zero? If yes, then all variables are zero.
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 变量 `a` 是零吗？如果是，变量 `b` 是零吗？如果是，变量 `c` 是零吗？如果是，那么所有变量都是零。
- en: '**[3](kindle_split_056.html#app01qa59q0a3)**'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa59q0a3)**'
- en: ''
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you have a jacket? Do you have a sweater? Take one of these; it’s cold outside.
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你有夹克吗？你有毛衣吗？拿一件；外面很冷。
- en: '|  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The code examples so far have only one expression that evaluates to `true` or
    `false` inside the conditional statement. In reality, you can make decisions based
    on more than one condition. In programming, you can combine multiple conditional
    expressions in one `if` statement. This way, you don’t have to write separate
    `if` statements for every separate conditional. This leads to cleaner code that’s
    easier to read and understand.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的代码示例中，在条件语句内只有一个表达式会评估为 `true` 或 `false`。实际上，你可以根据多个条件做出决定。在编程中，你可以在一个
    `if` 语句中组合多个条件表达式。这样，你不必为每个单独的条件编写单独的 `if` 语句。这导致代码更干净，更容易阅读和理解。
- en: 14.1.1\. Conditionals are made up of true/false expressions
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.1\. 条件由真/假表达式组成
- en: You’ve seen conditionals in which only one expression evaluates to `true`/`false`;
    for example, `num_a < 0`. An `if` statement can check multiple conditionals and
    act accordingly, depending on whether the entire expression, made up of multiple
    conditionals, is `true`/`false`. This is where the truth table you saw in [table
    14.1](#ch14table01) is useful. You use it to combine more than one expression
    by using the Boolean operators `and` and `or`. In Python, the words `and` and
    `or` are keywords.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了只有单个表达式评估为 `true`/`false` 的条件语句；例如，`num_a < 0`。一个 `if` 语句可以检查多个条件，并根据整个表达式（由多个条件组成）是
    `true`/`false` 而相应地行动。这就是你之前在 [表 14.1](#ch14table01) 中看到的真值表有用的地方。你使用它通过布尔运算符
    `and` 和 `or` 来组合多个表达式。在 Python 中，`and` 和 `or` 是关键字。
- en: You can have an `if` statement made up of more than one expression, as shown
    in the following listing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有一个由多个表达式组成的 `if` 语句，如下所示。
- en: Listing 14.1\. Multiple conditional expressions in one `if` statement
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.1\. 一个 `if` 语句中的多个条件表达式
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, two decisions must be made before entering inside the code block of the
    `if` statement: one decision is if `num_a < 0`, and the other decision is if `num_b
    < 0`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入 `if` 语句的代码块之前，这里必须做出两个决定：一个决定是 `num_a < 0`，另一个决定是 `num_b < 0`。
- en: 14.1.2\. Operator precedence rules
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.2\. 运算符优先级规则
- en: Recall that expressions are evaluated to a value that’s a Python object—for
    example, an integer value. After you start to combine multiple expressions, you
    need to be careful about the order in which expressions and parts of each expression
    are evaluated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，表达式会被评估为一个值，这个值是 Python 对象——例如，一个整数值。在你开始组合多个表达式之后，你需要注意表达式及其各部分的评估顺序。
- en: In math, you learned about the operator precedence of addition, subtraction,
    multiplication, and division. In programming, the same precedence exists as in
    math, but additional operations must be taken into account—things like comparison
    operators and logical operators to combine Boolean expressions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，你学习了加法、减法、乘法和除法的运算符优先级。在编程中，与数学中的优先级相同，但必须考虑额外的操作——比如比较运算符和逻辑运算符来组合布尔表达式。
- en: '[Table 14.2](#ch14table02) shows a complete set of operator precedence rules,
    which tells you which operations are done before others in Python. These precedence
    rules are used, among other things, for evaluating the result of a larger conditional
    made up of smaller conditional expressions.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[表14.2](#ch14table02)显示了完整的运算符优先级规则集，它告诉你Python中哪些操作先于其他操作执行。这些优先级规则用于评估由较小的条件表达式组成的大条件的结果。'
- en: Table 14.2\. Order of operations, with those at the top being executed first.
    Operations at the same precedence level within one cell are left-associative;
    they’re executed left to right as encountered in an expression.
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.2。运算顺序，其中顶部的是首先执行的。同一单元格内具有相同优先级的操作是左结合的；它们按照在表达式中遇到的顺序从左到右执行。
- en: '| Operator | Meaning |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 含义 |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| () | Parentheses |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| () | 括号 |'
- en: '| ** | Exponent |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| ** | 指数 |'
- en: '| * / // % | Multiplication Division Floor division Modulus |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| * / // % | 乘法 除法 整除 模数 |'
- en: '| + - | Addition Subtraction |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| + - | 加法 减法 |'
- en: '| == != > >= < <= is is not in not in | Is equal to Is not equal to Greater
    than Greater than or equal to Less than Less than or equal to Identity (object
    is another object) Identity (object is not another object) Membership (object
    is in another object) Membership (object isn’t in another object) |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| == != > >= < <= is is not in not in | 等于 不等于 大于 大于等于 小于 小于等于 身份（对象是另一个对象）
    身份（对象不是另一个对象） 成员（对象在另一个对象中） 成员（对象不在另一个对象中） |'
- en: '| not | Logical NOT |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| not | 逻辑非 |'
- en: '| and | Logical AND |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| and | 逻辑与 |'
- en: '| or | Logical OR |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| or | 逻辑或 |'
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 14.2**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查14.2**'
- en: 'Evaluate the following expressions by using the operator precedence in [table
    14.2](#ch14table02):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[表14.2](#ch14table02)中的运算符优先级评估以下表达式：
- en: '**[1](kindle_split_056.html#app01qa60q0a1)**'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa60q0a1)**'
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`3 < 2 ** 3 and 3 == 3`'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`3 < 2 ** 3 and 3 == 3`'
- en: '**[2](kindle_split_056.html#app01qa60q0a2)**'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa60q0a2)**'
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`0 != 4 or (3/3 == 1 and (5 + 1) / 3 == 2)`'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 != 4 or (3/3 == 1 and (5 + 1) / 3 == 2)`'
- en: '**[3](kindle_split_056.html#app01qa60q0a3)**'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa60q0a3)**'
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`"a" in "code" or "b" in "Python" and len("program") == 7`'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`"a" in "code" or "b" in "Python" and len("program") == 7`'
- en: '|  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Take a look at the following (incorrect) code. It’s similar to the code in [listing
    14.1](#ch14ex01), except that the line `num_a < 0 and num_b < 0` is written as
    `num_a and num_b < 0`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的（错误）代码。它与14.1中的代码类似，除了将`num_a < 0 and num_b < 0`行写成`num_a and num_b < 0`。
- en: Listing 14.2\. Code that doesn’t do what you think it does
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.2。不按你想象的方式工作的代码
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you run the code with the following different values for `num_a` and `num_b`,
    you’ll get the output in [table 14.3](#ch14table03). An empty entry means no output.
    Notice that one of the pairs of values gives a misleading printout.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用以下不同的`num_a`和`num_b`值运行代码，你将在表14.3中看到输出。空条目表示没有输出。注意，有一对值给出了误导性的打印输出。
- en: Table 14.3\. Result in the console output after running the code in [listing
    14.2](#ch14ex02) with different values for `num_a` and `num_b`
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.3。在[列表14.2](#ch14ex02)中用不同的`num_a`和`num_b`值运行代码后的控制台输出结果
- en: '| num_a | num_b | Console output |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| num_a | num_b | 控制台输出 |'
- en: '| --- | --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| -1 | -1 | both negative |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| -1 | -1 | 两个都是负数 |'
- en: '| -1 | 1 |   |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| -1 | 1 |   |'
- en: '| 0 | -1 |   |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 0 | -1 |   |'
- en: '| 0 | 1 |   |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 |   |'
- en: '| 1 | -1 | both negative |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 1 | -1 | 两个都是负数 |'
- en: '| 1 | 1 |   |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |   |'
- en: When `num_a = 1` and `num_b = -1`, the output printed to the console is `both
    negative`, which is incorrect. Use the precedence rules to see what’s going on.
    Add parentheses to denote expressions that are evaluated first in [listing 14.2](#ch14ex02).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当`num_a = 1`和`num_b = -1`时，打印到控制台的是`两个都是负数`，这是不正确的。使用优先级规则来查看发生了什么。在[列表14.2](#ch14ex02)中添加括号来表示首先评估的表达式。
- en: By the precedence rules in [table 14.2](#ch14table02), the `and` logical operator
    has lower precedence than the “less than” comparison. The expression `num_a and
    num_b < 0` can be rewritten as `(num_a and (num_b < 0))`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 根据表14.2中的优先级规则，逻辑运算符“and”的优先级低于比较运算符“小于”。表达式`num_a and num_b < 0`可以重写为`(num_a
    and (num_b < 0))`。
- en: In Python, all integer values except 0 are considered `True`, and the integer
    value 0 is considered `False`. `if -1` evaluates to `if True`, and `if 0` evaluates
    to `if False`. Because of the precedence rules, whenever `num_a` is anything except
    0, the expression evaluates to `True`. When `num_a = 1` and `num_b = -1`, the
    code incorrectly prints `both negative` because `(num_a and (num_b < 0))` evaluates
    to `(1 and (-1 < 0))`, which evaluates to `(True and True)`, which is `True`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，除了0以外的所有整数值都被认为是`True`，整数值0被认为是`False`。`if -1`评估为`if True`，而`if 0`评估为`if
    False`。由于优先级规则，当`num_a`不是0时，表达式评估为`True`。当`num_a = 1`且`num_b = -1`时，代码错误地打印`both
    negative`，因为`(num_a and (num_b < 0))`评估为`(1 and (-1 < 0))`，这评估为`(True and True)`，即`True`。
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 14.3**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查14.3**'
- en: '**[Q1:](kindle_split_056.html#app01qa61q0a1)**'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_056.html#app01qa61q0a1)**'
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Go back to the code in [listing 14.1](#ch14ex01). The conditional there can
    be rewritten, using the precedence rules and parentheses, as `((num_a < 0) and
    (num_b < 0))`. Draw a table for a few combinations of `num_a` and `num_b` to convince
    yourself that all possible pairs of values give the expected printout.
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 回到[列表14.1](#ch14ex01)中的代码。那里的条件可以使用优先级规则和括号重写为`((num_a < 0) and (num_b < 0))`。为`num_a`和`num_b`的几个组合绘制一个表格，以说服自己所有可能的值对都会给出预期的打印输出。
- en: '|  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.2\. Choosing which lines to execute
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2\. 选择要执行的行
- en: Now you understand the purpose of a conditional statement and how to write one
    in Python. Conditionals don’t have to be used as only single “detours” in code.
    They can also be used to make a decision as to which blocks of code to execute.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了条件语句的用途以及如何在Python中编写一个条件语句。条件语句不一定要作为代码中的唯一“分支”使用。它们也可以用来决定要执行哪些代码块。
- en: 14.2.1\. Do this or that
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.1\. 做这个或那个
- en: Sometimes you want to perform one task but not another. For example, you might
    say something like “If it is sunny, then I will walk to work; otherwise, if it
    is cloudy, then I will take an umbrella and walk to work; but otherwise, I will
    drive.” For this, the `elif` and `else` keywords will be used in combination with
    an `if` statement.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你想执行一个任务而不是另一个。例如，你可能会说：“如果天气晴朗，我就步行去上班；否则，如果天气多云，我就拿伞步行去上班；否则，我就开车去。”为此，将使用`elif`和`else`关键字与`if`语句结合使用。
- en: '[Listing 14.3](#ch14ex03) shows a simple `if-elif-else` conditional statement
    in code. You get an input number from the user. If the number is greater than
    0, you print `positive`. Otherwise, if the number is less than zero, you print
    `negative`. Otherwise, you print that the number is zero. Only one of the messages
    will be printed.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表14.3](#ch14ex03)展示了代码中的简单`if-elif-else`条件语句。你从用户那里获取一个输入数字。如果数字大于0，你打印`positive`。否则，如果数字小于零，你打印`negative`。否则，你打印该数字为零。只有一条消息会被打印。'
- en: Listing 14.3\. Example of a simple `if-elif-else` conditional statement
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.3\. 简单的`if-elif-else`条件语句示例
- en: '[PRE2]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* User input**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用户输入**'
- en: '***2* Condition checks that the number is greater than 0**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 检查数字是否大于0**'
- en: '***3* Prints a message**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印一条消息**'
- en: '***4* When if num > 0 is False, do this condition to check that the number
    is less than 0.**'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 当if num > 0为False时，执行此条件以检查数字是否小于0。**'
- en: '***5* Prints a message**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 打印一条消息**'
- en: '***6* When elif num < 0 is False, the else is a catchall.**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 当elif num < 0为False时，else是一个通配符。**'
- en: '***7* Prints a message**'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 打印一条消息**'
- en: Here, you start a conditional with the `if` statement. Any `elif` or `else`
    statements that come after it are associated with that `if` statement. This kind
    of structure means that you’ll execute the code block that belongs to the first
    decision that’s true.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用`if`语句开始一个条件。任何随后的`elif`或`else`语句都与该`if`语句相关联。这种结构意味着你将执行属于第一个为真的决策的代码块。
- en: '|  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 14.4**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查14.4**'
- en: '**[Q1:](kindle_split_056.html#app01qa62q0a1)**'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_056.html#app01qa62q0a1)**'
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What’s printed when you run [listing 14.3](#ch14ex03) with the following values
    for `num`: -3, 0, 2, 1?'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你使用以下`num`值运行[列表14.3](#ch14ex03)时，会打印什么？-3, 0, 2, 1？
- en: '|  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Figure 14.1](#ch14fig01) shows how to visualize multiple decisions. Each decision
    is a conditional statement; a group of decisions are part of an `if-elif-else`
    code block. Follow any path in [figure 14.1](#ch14fig01) by tracing the paths
    denoted by arrows. The main program decisions are shown by the diamonds. The first
    decision starts with an `if` statement and indicates the start of a decision block.
    If you trace any path from the `if` statement to the box labeled `<rest of program>,`
    you’ll notice that you can deviate from the main path of the program at most only
    once. The path you’ll deviate to is the first path whose condition evaluates to
    `True`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14.1](#ch14fig01) 展示了如何可视化多个决策。每个决策都是一个条件语句；一组决策是 `if-elif-else` 代码块的一部分。通过追踪
    [图 14.1](#ch14fig01) 中由箭头表示的路径，遵循任何路径。主程序决策由菱形表示。第一个决策从 `if` 语句开始，表示决策块的开始。如果你从
    `if` 语句追踪到标有 `<rest of program>` 的框，你会注意到你最多只能偏离程序的主路径一次。你将偏离的路径是第一个条件评估为 `True`
    的路径。'
- en: Figure 14.1\. Visualizing a generic `if-elif-else` code block. You can deviate
    from the main program flow by doing `<do something>` at most once. You can have
    zero or more `elif` blocks, and the `else` block is optional.
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.1\. 可视化一个通用的 `if-elif-else` 代码块。你最多只能通过执行 `<do something>` 一次来偏离主程序流程。你可以有零个或多个
    `elif` 块，而 `else` 块是可选的。
- en: '![](images/14fig01.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](images/14fig01.jpg)'
- en: 'The `if-elif-else` code block in [figure 14.1](#ch14fig01) is a generic block.
    You can have the following variations:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 中的 `if-elif-else` 代码块是一个通用块。你可以有以下变体：
- en: Only one `if` statement (you saw this in the previous lesson)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个 `if` 语句（你已经在上一课中看到了）
- en: One `if` statement and one `elif` statement
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `if` 语句和一个 `elif` 语句
- en: One `if` statement and many `elif` statements
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `if` 语句和多个 `elif` 语句
- en: One `if` statement and one `else` statement
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `if` 语句和一个 `else` 语句
- en: One `if` statement, one or more `elif` statements, and one `else` statement
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `if` 语句，一个或多个 `elif` 语句，以及一个 `else` 语句
- en: For all of these variations, the detour executed is the first one whose condition
    evaluates to `True`. If none evaluate to `True`, the `else` detour is executed.
    If the preceding variations don’t include an `else` statement, it’s possible that
    none of the detours to `<do something>` are executed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些变体，执行的是第一个条件评估为 `True` 的绕行。如果没有评估为 `True`，则执行 `else` 绕行。如果前面的变体不包括 `else`
    语句，则可能没有执行到 `<do something>` 的任何绕行。
- en: '|  |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 14.5**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 14.5**'
- en: '**[Q1:](kindle_split_056.html#app01qa63q0a1)**'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_056.html#app01qa63q0a1)**'
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw a flowchart for [listing 14.3](#ch14ex03).
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为 [列表 14.3](#ch14ex03) 绘制流程图。
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The following listing shows the generic way of writing code that does one thing
    or another, depending on whether certain conditions hold, as shown in [figure
    14.1](#ch14fig01).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了根据某些条件是否成立，执行一个动作或另一个动作的代码的通用编写方式，如图 14.1 所示。
- en: Listing 14.4\. A General way to write a simple `if-elif-else` conditional
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.4\. 简单 `if-elif-else` 条件的通用编写方式
- en: '[PRE3]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* The keyword “if” starts the conditional block.**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 关键词“if”开启条件块。**'
- en: '***2* The keyword “elif” starts the “else if” conditional block.**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 关键词“elif”开启“else if”条件块。**'
- en: '***3* The keyword “else” starts the catchall other conditional cases.**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 关键词“else”开启所有其他条件情况的捕获。**'
- en: The keyword `if` starts the conditional block, as before, followed by a conditional
    expression and then the colon character. When the `if` statement conditional is
    `True`, the code block for that `if` statement is executed, and then all remaining
    code blocks that are part of the `if-elif-else` group are skipped. When the `if`
    statement conditional is `False`, you check the conditional in the `elif` statement.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `if` 开启条件块，就像之前一样，后面跟着一个条件表达式，然后是冒号字符。当 `if` 语句的条件为 `True` 时，执行该 `if` 语句的代码块，然后跳过
    `if-elif-else` 组中所有剩余的代码块。当 `if` 语句的条件为 `False` 时，你将检查 `elif` 语句中的条件。
- en: If the conditional in the `elif` statement is `True`, the code block for that
    `elif` statement is executed, and all remaining code blocks that are part of the
    `if-elif-else` group are skipped. You can have as many `elif` statements as you
    want (zero or more). Python looks at conditionals one after another and will execute
    the first code block that evaluates to `True`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `elif` 语句中的条件为 `True`，则执行该 `elif` 语句的代码块，并跳过 `if-elif-else` 组中所有剩余的代码块。你可以有任意多的
    `elif` 语句（零个或更多）。Python 会逐个检查条件，并执行第一个评估为 `True` 的代码块。
- en: When none of the conditionals from the `if` or any of the `elif` statements
    are `True`, the code block inside the `else` is executed. You can think of the
    `else` as a catchall conditional for when nothing else is `True`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `if` 或任何 `elif` 语句中的条件都不为 `True` 时，`else` 语句内的代码块将被执行。您可以将 `else` 视为一个用于当其他条件都不为
    `True` 时的通用条件。
- en: When there’s no `else` statement, and none of the conditionals evaluate to `True`,
    the conditional block won’t do anything.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有 `else` 语句，并且没有任何条件评估为 `True` 时，条件块不会执行任何操作。
- en: '|  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 14.6**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 14.6**'
- en: '**[Q1:](kindle_split_056.html#app01qa64q0a1)**'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_056.html#app01qa64q0a1)**'
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Take a look at these code snippets:'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看以下代码片段：
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will the user see on the screen if `num` has the following values?
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 `num` 有以下值，用户会在屏幕上看到什么？
- en: ''
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.2.2\. Putting it all together
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.2\. 整合所有内容
- en: 'At this point, you can see that the structure of the programs is changing yet
    again:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可以看到程序的结构再次发生了变化：
- en: You can decide to do one of many things by checking different conditions.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过检查不同的条件来决定做许多事情之一。
- en: The `if-elif` structure is used to enter the first code block that’s `True`.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if-elif` 结构用于进入第一个为 `True` 的代码块。'
- en: The `else` is used to do something when nothing else is `True`.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else` 用于在没有任何其他条件为 `True` 时执行某些操作。'
- en: '[Listing 14.5](#ch14ex05) shows a simple program that checks the user input.
    When the user enters a noninteger value for either input, the program prints a
    message to the user and then moves on to the next group, at the same indentation
    level, of `if-elif-else` statements. It doesn’t enter the `else` code block associated
    with the first `if` statement because it already executed the block within the
    `if`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14.5](#ch14ex05) 展示了一个简单的程序，该程序检查用户输入。当用户为任一输入输入非整数值时，程序会向用户打印一条消息，然后继续执行下一个组，即同一缩进级别的
    `if-elif-else` 语句。它不会进入与第一个 `if` 语句关联的 `else` 代码块，因为它已经执行了 `if` 语句内的代码块。'
- en: When the user enters two valid integers, you enter the `else` code block and
    print a message depending on the sign of the numbers inputted. Only the message
    associated with the first time a condition evaluates to `True` within the nested
    `if-elif-else` statement will be printed. After that code block finishes, you
    move on to check the next `if-elif-else` group, seeing whether the user guessed
    the lucky number.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入两个有效的整数时，您将进入 `else` 代码块，并根据输入数字的符号打印一条消息。只有当嵌套的 `if-elif-else` 语句中第一次条件评估为
    `True` 时关联的消息会被打印。在该代码块执行完毕后，您将进入下一个 `if-elif-else` 组，检查用户是否猜对了幸运数字。
- en: Listing 14.5\. Example of how to use `if-elif-else` statements
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.5\. 使用 `if-elif-else` 语句的示例
- en: '[PRE6]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* One group of if-else with a nested if-elif-else group**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 嵌套的 if-else 组**'
- en: '***2* Nested group of if-elif-else**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 嵌套的 if-elif-else 组**'
- en: '***3* Another group of if-else**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 另一个 if-else 组**'
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Thinking like a programmer**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**像程序员一样思考**'
- en: Programmers write readable code, both for others to be able to read and for
    themselves to look back on later. It’s a good idea to create variables to store
    complex computations and give them descriptive names rather than including them
    in conditionals directly. For example, don’t do `if (x ** 2 - x + 1 == 0) or (x
    + y ** 3 + x ** 2 == 0)`. Instead, create variables `x_eq = x ** 2 - x + 1` and
    `xy_eq = x + y ** 3 + x ** 2` and then check `if x_eq == 0 or xy_eq == 0`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员编写的代码易于阅读，既是为了让其他人能够阅读，也是为了自己以后回顾。创建变量来存储复杂的计算并给它们起有描述性的名字是一个好主意，而不是直接将它们包含在条件语句中。例如，不要这样做
    `if (x ** 2 - x + 1 == 0) or (x + y ** 3 + x ** 2 == 0)`。相反，创建变量 `x_eq = x **
    2 - x + 1` 和 `xy_eq = x + y ** 3 + x ** 2`，然后检查 `if x_eq == 0 or xy_eq == 0`。
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Python makes it easy to visualize which lines should be executed because the
    code blocks are indented. You can take [listing 14.5](#ch14ex05) and visualize
    the code in terms of blocks. In [figure 14.2](#ch14fig02), you see that the conditionals
    have a cascading look.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通过缩进代码块使得可视化哪些行应该被执行变得容易。您可以查看[列表 14.5](#ch14ex05)并从块的角度来可视化代码。在[图 14.2](#ch14fig02)中，您可以看到条件语句呈现出级联的外观。
- en: Figure 14.2\. Visualization of [listing 14.5](#ch14ex05), showing the conditional
    code blocks
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.2\. [列表 14.5](#ch14ex05) 的可视化，显示条件代码块
- en: '![](images/14fig02_alt.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](images/14fig02_alt.jpg)'
- en: Within the conditional group, you’ll execute only the first branch that evaluates
    to `True`. Whenever you have another `if` statement at the same level as another
    `if` statement, you’re starting another conditional group.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件组内，你将只执行评估结果为`True`的第一个分支。每当你在同一级别有另一个`if`语句时，你就是在开始另一个条件组。
- en: 'You can see in [figure 14.2](#ch14fig02) that two major conditional blocks
    are at the main level: the one that checks the user input and the one that checks
    for the lucky number. Using this visualization, you can even propose a rewrite
    of the code in [listing 14.5](#ch14ex05) to eliminate the `else` statement for
    the first code block that checks the user input, and convert that to an `elif`
    statement. The code rewrite is in the next listing.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图14.2](#ch14fig02)中看到，两个主要的条件块位于主级别：一个用于检查用户输入，另一个用于检查幸运数字。使用这种可视化，你甚至可以提出对[列表14.5](#ch14ex05)中代码的重新编写，以消除第一个检查用户输入的代码块的`else`语句，并将其转换为`elif`语句。代码重写将在下一个列表中展示。
- en: Listing 14.6\. Rewrite of [listing 14.5](#ch14ex05) to convert an `else` to
    a series of `elifs`
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.6\. 将[列表14.5](#ch14ex05)中的else转换为一系列elif的重写
- en: '[PRE7]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* The else block from [listing 14.5](#ch14ex05) converted to a series of
    elif blocks**'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将[列表14.5](#ch14ex05)中的else块转换为一系列elif块**'
- en: As an exercise, you can check all combinations of inputs and compare the outputs
    of the code in [listing 14.5](#ch14ex05) and in [listing 14.6](#ch14ex06) to make
    sure it’s the same.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以检查所有输入组合，并将[列表14.5](#ch14ex05)和[列表14.6](#ch14ex06)中代码的输出进行比较，以确保它们相同。
- en: 14.2.3\. Thinking in terms of code blocks
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.3\. 从代码块的角度思考
- en: It’s important to realize that when you decide which branch to execute, you
    look at only the particular `if-elif-else` conditional group, as shown in [listing
    14.7](#ch14ex07). The `if` statement has one check, to see whether the input from
    the user is one of the strings in the tuple `greet_en` or `greet_sp`. The other
    two `elif`s each have a nested `if-elif` code block.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，当你决定执行哪个分支时，你只查看特定的`if-elif-else`条件组，如[列表14.7](#ch14ex07)所示。`if`语句有一个检查，查看用户输入是否是元组`greet_en`或`greet_sp`中的字符串之一。其他两个`elif`每个都有一个嵌套的`if-elif`代码块。
- en: Listing 14.7\. Example with multiple `if-elif-else` code blocks
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.7\. 多个`if-elif-else`代码块的示例
- en: '[PRE8]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* One code block made up of if-elif statements**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 由if-elif语句组成的代码块**'
- en: '***2* A nested block containing an if-elif block**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包含if-elif块的嵌套块**'
- en: '***3* A nested block containing another if-elif block**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 包含另一个if-elif块的嵌套块**'
- en: 'The program will enter only one path through the `if-elif-elif`, through one
    of the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将通过`if-elif-elif`进入以下路径之一：
- en: The `if` when the user enters a greeting that isn’t in `greet_en` and not in
    `greet_sp`
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户输入的问候语不在`greet_en`和`greet_sp`中时
- en: Through the `elif` when `greeting in greet_en`
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`elif`在`greeting in greet_en`时
- en: Through the `elif` when `greeting in greet_sp`
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`elif`在`greeting in greet_sp`时
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this lesson, my objective was to teach you how to make decisions by using
    the `if-elif-else` conditional statements, and to teach you how various combinations
    of their parts affect the program flow. The decisions you can make are now even
    more complex, because you can choose which code to execute. These are the major
    takeaways:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我的目标是教你如何使用`if-elif-else`条件语句来做出决策，并教你如何各种组合的各部分影响程序流程。你现在可以做出的决策现在更加复杂，因为你可以选择执行哪个代码。以下是主要收获：
- en: Operator precedence is important when evaluating many expressions inside one
    conditional.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个条件中评估多个表达式时，运算符优先级很重要。
- en: The `if` statement indicates whether to take a detour. The `if-elif-else` statements
    indicate which detour to take.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`语句表示是否要走一条捷径。`if-elif-else`语句表示要走哪条捷径。'
- en: Visualize more-complicated programs, which include conditional statements, by
    using flowcharts.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用流程图来可视化更复杂的程序，这些程序包括条件语句。
- en: As you’re starting to write programs that involve a few concepts, it’s important
    to actively engage in solving them. Take out a pen and paper and draw out your
    solution or write out your thought process. Then open your preferred IDE, type
    your code, and then run, test, and debug your program. Don’t forget to comment
    your code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编写涉及几个概念的程序时，积极参与解决问题很重要。拿出笔和纸，画出你的解决方案或写下你的思考过程。然后打开你喜欢的IDE，输入你的代码，然后运行、测试和调试你的程序。别忘了给你的代码添加注释。
- en: Let’s see if you got this...
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否明白了...
- en: '**[Q14.1](kindle_split_056.html#app01qa65q0a1)**'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q14.1](kindle_split_056.html#app01qa65q0a1)**'
- en: ''
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write a program that reads in two numbers from the user. The program should
    print the relation between the two numbers, which will be one of the following:
    `numbers are equal`, `first number is less than the second number`, `first number
    is greater than the second number`.'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个程序，从用户那里读取两个数字。程序应该打印出这两个数字之间的关系，这将是以下之一：`数字相等`，`第一个数字小于第二个数字`，`第一个数字大于第二个数字`。
- en: '**[Q14.2](kindle_split_056.html#app01qa65q0a2)**'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q14.2](kindle_split_056.html#app01qa65q0a2)**'
- en: ''
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a program that reads in a string from the user. If the string contains
    at least one of every vowel (a, e, i, o, u), print `You have all the vowels!`
    Additionally, if the string starts with the letter *a* and ends with the letter
    *z*, print `And it's sort of alphabetical!`
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个程序，从用户那里读取一个字符串。如果该字符串至少包含每个元音字母（a, e, i, o, u）中的一个，打印`您已经拥有了所有元音字母！`另外，如果字符串以字母*a*开头并以字母*z*结尾，打印`而且它有点字母顺序！`
