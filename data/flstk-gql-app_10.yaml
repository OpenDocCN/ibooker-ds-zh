- en: 7 Adding authorization and authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 添加授权和认证
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Adding authentication and authorization to our application, including both the
    GraphQL API and our frontend React application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将身份验证和授权添加到我们的应用程序中，包括 GraphQL API 和我们的前端 React 应用程序
- en: Using JSON Web Tokens (JWTs) to encode user identity and permissions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON Web 令牌 (JWT) 来编码用户身份和权限
- en: Expressing and enforcing authorization rules in our GraphQL schema using the
    @auth GraphQL schema directive
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 @auth GraphQL 模式指令在我们的 GraphQL 模式中表达和强制执行授权规则
- en: Using Auth0 as a JWT provider and the Auth0 React SDK to add Auth0 support to
    our application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Auth0 作为 JWT 提供者以及 Auth0 React SDK 来为我们的应用程序添加 Auth0 支持
- en: '*Authentication* (verifying a user’s identity) and *authorization* (verifying
    resources users can access) are needed to secure any application—ensuring users
    have the permissions that they should and protecting data and actions of the application,
    both on the frontend and backend. So far, both our frontend React application
    and GraphQL API are open for anyone to access all features and functionality,
    including modifying, creating, and deleting data.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*身份验证*（验证用户的身份）和 *授权*（验证用户可以访问的资源）对于任何应用程序的安全性都是必要的——确保用户拥有他们应有的权限，并保护应用程序的数据和操作，包括前端和后端。到目前为止，我们的前端
    React 应用程序和 GraphQL API 对任何人开放，任何人都可以访问所有功能和功能，包括修改、创建和删除数据。'
- en: GraphQL itself is not opinionated about authorization, leaving it up to the
    developer to choose the most appropriate approach to implement in their application.
    In this chapter, we show how to implement authorization and authentication features
    in our application, using JWTs, GraphQL schema directives, and Auth0\. First,
    we’ll take a look at a *naive* approach to adding authorization to our GraphQL
    API by adding an authorization check in our resolvers. Then, we explore how to
    use the @auth GraphQL schema directive with the Neo4j GraphQL library to protect
    our GraphQL API, adding authorization rules in the schema. We then add support
    for the Auth0 authorization service and see how we can make use of JSON Web Tokens
    to encode user identity and permissions in our application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 本身对授权没有意见，将其留给开发者选择在他们的应用程序中实施的最合适的方法。在本章中，我们展示了如何使用 JWT、GraphQL 模式指令和
    Auth0 在我们的应用程序中实现授权和认证功能。首先，我们将看看在解析器中添加授权检查的简单方法来添加授权到我们的 GraphQL API。然后，我们将探讨如何使用
    @auth GraphQL 模式指令与 Neo4j GraphQL 库一起保护我们的 GraphQL API，在模式中添加授权规则。然后，我们添加对 Auth0
    授权服务的支持，并看看我们如何可以在我们的应用程序中使用 JSON Web 令牌来编码用户身份和权限。
- en: '7.1 Authorization in GraphQL: A naive approach'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 GraphQL 中的授权：一个简单的方法
- en: Let’s first take a look at a naive approach to adding authorization to a GraphQL
    API in listing 7.1 as a starting point, using just a single static authorization
    token. When receiving a request by the GraphQL server, we’ll check for a token
    contained in the authorization header of the request. We’ll pass this token through
    to the GraphQL resolver, where we’ll check for a certain value of the token to
    determine whether the request is properly authenticated and send back the appropriate
    response only if the token is valid. Note that this example is meant to convey
    concepts and does not represent best practices!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看在列表 7.1 中添加授权到 GraphQL API 的一个简单方法，作为起点，仅使用单个静态授权令牌。当 GraphQL 服务器接收到请求时，我们将检查请求授权头中包含的令牌。我们将此令牌传递到
    GraphQL 解析器，在那里我们将检查令牌的特定值以确定请求是否正确认证，并且只有在令牌有效时才发送适当的响应。请注意，此示例旨在传达概念，并不代表最佳实践！
- en: 'Listing 7.1 api/naive.js: A naive GraphQL authorization implementation'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 api/naive.js：一个简单的 GraphQL 授权实现
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Checking for a specific auth token value
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查特定的认证令牌值
- en: ❷ Adding the HTTP request headers to the GraphQL context object
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 HTTP 请求头添加到 GraphQL 上下文对象中
- en: Our GraphQL server has a single resolver, Query.people, which includes the logic
    for checking the value of an authorization token, passed through the context object.
    This token comes from the request header and is passed into the context object
    at query time (see figure 7.1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 GraphQL 服务器有一个单一的解析器，Query.people，它包括检查授权令牌值的逻辑，该令牌通过上下文对象传递。此令牌来自请求头，并在查询时传递到上下文对象中（见图
    7.1）。
- en: '![CH07_F01_Lyon](../../OEBPS/Images/CH07_F01_Lyon.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F01_Lyon](../../OEBPS/Images/CH07_F01_Lyon.png)'
- en: Figure 7.1 The authorization flow for our naive GraphQL authorization implementation
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 我们简单 GraphQL 授权实现的授权流程
- en: 'Let’s give it a try. We can now start the GraphQL server:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。现在我们可以启动 GraphQL 服务器：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In Apollo Studio, let’s issue a GraphQL query to find all Person objects and
    return the name field of each:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Apollo Studio 中，让我们发出一个 GraphQL 查询以查找所有 Person 对象并返回每个对象的名字字段：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our request is rejected since we haven’t included the appropriate authorization
    token, and our result is an error message: *You are not authorized.* Let’s add
    the appropriate authorization header to the GraphQL request with our authorization
    token. We can do this in Apollo Studio by clicking *Headers* in the lower-left
    corner and selecting *New header* with the key *Authorization* and value *Bearer
    authorized123*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有包括适当的授权令牌，我们的请求被拒绝，并且我们的结果是错误消息：*您未授权.* 让我们在 GraphQL 请求中添加适当的授权头和我们的授权令牌。我们可以在
    Apollo Studio 中通过点击左下角的 *Headers* 并选择 *New header*（键为 *Authorization*，值为 *Bearer
    authorized123*）来完成此操作：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, when we execute the same GraphQL operation—this time with the authorization
    token attached as a header in the request—we see the results we’re expecting:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们执行相同的 GraphQL 操作——这次将授权令牌附加为请求中的头信息——我们看到我们预期的结果：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This naive approach shows a few important concepts, such as how to take the
    authorization header from a request and pass it through to the context object
    of the GraphQL resolver, as well as how to add an authorization header in Apollo
    Studio. However, there are a few problems with this approach that we wouldn’t
    want to implement in a real-world application:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种天真方法展示了几个重要概念，例如如何从请求中获取授权头并将其传递到 GraphQL 解析器的上下文对象，以及如何在 Apollo Studio 中添加授权头。然而，这种方法有几个问题，我们不会在现实世界的应用程序中实现：
- en: '*We don’t validate the token.* How do we know the user making the request is
    who they say they are and if they actually have the permissions they state in
    the token? We’re just taking their word for it!'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*我们不验证令牌。* 我们如何知道发起请求的用户是他们所说的那个人，以及他们是否真的拥有令牌中声明的权限？我们只是在相信他们的话！'
- en: '*Our authorization rules are mixed with data-fetching logic in the GraphQL
    resolver.* This might seem like something that works for a simple example, but
    imagine what will happen as we add more types and authorization rules—it will
    be difficult to track and maintain.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*我们的授权规则与 GraphQL 解析器中的数据获取逻辑混合在一起。* 这可能看起来像是一个简单的例子可以工作，但想象一下当我们添加更多类型和授权规则时会发生什么——这将很难跟踪和维护。'
- en: We’ll address the first issue by using cryptographically-signed JWTs to encode
    and validate the users’ identity and permissions expressed in the authorization
    header. We’ll address the second issue by using the @auth GraphQL schema directive
    with the Neo4j GraphQL library; by adding declarative authorization rules to our
    schema, we have a single source of truth for our authorization rules.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用加密签名的 JWT 来编码和验证授权头中表达的用户身份和权限来解决第一个问题。我们将通过使用 Neo4j GraphQL 库中的 @auth
    GraphQL 模式指令来解决第二个问题；通过在我们的模式中添加声明性授权规则，我们有一个单一的真相来源，用于我们的授权规则。
- en: 7.2 JSON Web Tokens
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 JSON Web Tokens
- en: JSON Web Token, commonly referred to as JWT, is an open standard for cryptographically
    signing a JSON object that can be used for trusted communication between parties.
    A compact token is generated and signed using public/private key pairs to verify
    that the token was generated by a party holding the private key, and therefore,
    the integrity of the information contained in the token can be cryptographically
    verified by decoding it, using the public key counterpart of the private key used
    to sign it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Token，通常简称为 JWT，是一种用于对 JSON 对象进行加密签名的开放标准，可用于各方之间进行可信通信。通过使用公钥/私钥对生成并签名一个紧凑的令牌，以验证该令牌是由持有私钥的一方生成的，因此，可以通过解码它并使用用于签名的私钥的公钥对应物来对令牌中包含的信息的完整性进行加密验证。
- en: The information encoded in a JWT (the payload) is a series of *claims* about
    an entity, typically a user. Standard claims in a JWT include
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: JWT（负载）中编码的信息是一系列关于实体的 *声明*，通常是用户。JWT 中的标准声明包括
- en: iss—The issuer of the token
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iss—令牌的发行者
- en: exp—The expiration date of the token
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: exp—令牌的过期日期
- en: sub—The subject, usually some sort of ID referencing the user to which these
    claims apply
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sub—主题，通常是一些 ID，引用了这些声明适用的用户
- en: aud—The audience, often used when authenticating against an API
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aud—受众，通常在验证 API 时使用
- en: We can also add additional claims to a JWT to express information about the
    user, such as what roles they have in the application (i.e., Is the user an admin
    or editor?) or more fine-grained permissions they should be granted, such as the
    permission to read, create, update, or delete certain types of data in the application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向JWT添加额外的声明来表示有关用户的信息，例如他们在应用程序中的角色（例如，用户是管理员还是编辑？）或更细粒度的权限，例如读取、创建、更新或删除应用程序中某些类型数据的权限。
- en: Many identity and access management services support the JWT standard. They
    can even be used self-contained, if you choose to provide your own authorization
    service. In this chapter, we will make use of the Auth0 service.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 许多身份和访问管理服务支持JWT标准。如果您选择提供自己的授权服务，它们甚至可以独立使用。在本章中，我们将使用Auth0服务。
- en: First, let’s create a JWT to encode some claims about a user, and then we’ll
    modify the previous naive GraphQL API to verify the token and ensure the user
    should be given access to the GraphQL API. To do this, we’ll use the online JWT
    debugger at [https://jwt.io](https://jwt.io).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个JWT来编码关于用户的一些声明，然后我们将修改之前的简单GraphQL API以验证令牌并确保用户应该被允许访问GraphQL API。为此，我们将使用在线JWT调试器[https://jwt.io](https://jwt.io)。
- en: 'We’ll need a random string to use as the signing key. Later, we’ll use this
    in our GraphQL server to verify the incoming JWTs:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个随机字符串作为签名密钥。稍后，我们将在我们的GraphQL服务器中使用这个密钥来验证传入的JWT：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Enter this value in the *VERIFY SIGNATURE* section of the JWT Debugger. Next,
    we need to add some claims to the payload of our token (see figure 7.2):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在JWT调试器的“验证签名”部分输入此值。接下来，我们需要在我们的令牌的有效载荷中添加一些声明（见图7.2）：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![CH07_F02_Lyon](../../OEBPS/Images/CH07_F02_Lyon.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F02_Lyon](../../OEBPS/Images/CH07_F02_Lyon.png)'
- en: Figure 7.2 Creating a signed JWT using jwt.io
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 使用jwt.io创建已签名的JWT
- en: 'After creating our JWT, let’s return to the naive GraphQL server and add support
    for verifying the token. First, we’ll install the jsonwebtoken package:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的JWT后，让我们回到简单的GraphQL服务器并添加验证令牌的支持。首先，我们将安装jsonwebtoken包：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, we’ll update the resolver logic to decode the JWT using our random client
    secret, as shown in the next listing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新解析器逻辑，使用我们的随机客户端密钥解码JWT，如下所示。
- en: 'Listing 7.2 api/naive.js: Verifying a JWT in the GraphQL server'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 api/naive.js：在GraphQL服务器中验证JWT
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Verifying the token using our random client secret
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用我们的随机客户端密钥验证令牌
- en: If the token can be verified, meaning it was signed by the appropriate key,
    then we continue fetching data in the resolver. If the token is not valid, then
    the resolver throws an error, and no data is fetched (see figure 7.3).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果令牌可以验证，即它是由适当的密钥签名的，那么我们将继续在解析器中获取数据。如果令牌无效，则解析器抛出错误，并且不会获取任何数据（见图7.3）。
- en: '![CH07_F03_Lyon](../../OEBPS/Images/CH07_F03_Lyon.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F03_Lyon](../../OEBPS/Images/CH07_F03_Lyon.png)'
- en: Figure 7.3 Introducing JWT into our authorization flow
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 将JWT引入我们的授权流程
- en: This example uses the HS256 algorithm, which means the client and server share
    the same key. Later, when we switch to Auth0 as the provider for our tokens, we’ll
    make use of the more secure RS256 algorithm in which a public/private key pair
    is used instead.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用HS256算法，这意味着客户端和服务器共享相同的密钥。稍后，当我们切换到Auth0作为令牌提供者时，我们将使用更安全的RS256算法，其中使用公钥/私钥对代替。
- en: 'After restarting the GraphQL server to pick up our changes, we’ll open Apollo
    Studio and add the JWT token to the authorization header. If we try to make the
    request without a token or using an invalid token, we receive this error: *You
    are not authorized*. This ensures the GraphQL server only executes valid requests—those
    containing a JWT signed using the private key corresponding to the public key
    (see figure 7.4).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在重启GraphQL服务器以应用我们的更改后，我们将打开Apollo Studio并将JWT令牌添加到授权头中。如果我们尝试不使用令牌或使用无效令牌进行请求，我们会收到以下错误：“您未授权”。这确保了GraphQL服务器只执行有效的请求——即包含使用对应公钥的私钥签名的JWT（见图7.4）。
- en: '![CH07_F04_Lyon](../../OEBPS/Images/CH07_F04_Lyon.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F04_Lyon](../../OEBPS/Images/CH07_F04_Lyon.png)'
- en: Figure 7.4 Adding a JWT as an Authorization header in Apollo Studio
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 在Apollo Studio中添加JWT作为授权头
- en: Earlier, we mentioned two issues with our naive approach to authorization. The
    first was that we didn’t have a way to validate the authorization token. We’ve
    solved that problem by using and validating a JWT, so now, it’s time to address
    our commingled authorization rules. We’ll use directives to declare our authorization
    rules in our GraphQL schema and ensure they are enforced using the Neo4j GraphQL
    library.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到了我们原始授权方法中的两个问题。第一个问题是我们没有一种方式来验证授权令牌。我们通过使用和验证JWT解决了这个问题，所以现在，是时候解决我们的混合授权规则了。我们将在GraphQL模式中使用指令来声明我们的授权规则，并确保使用Neo4j
    GraphQL库强制执行这些规则。
- en: 7.3 The @auth GraphQL schema directive
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 The @auth GraphQL模式指令
- en: Let’s leave behind the simple, naive GraphQL server example and return to our
    business reviews application to explore how to add authorization rules to our
    GraphQL schema. As we saw previously with the @cypher schema directive, GraphQL
    schema directives allow us to indicate that some custom server-side logic should
    be applied when resolving the GraphQL request.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们放下简单的、原始的GraphQL服务器示例，回到我们的业务审查应用中，探索如何将授权规则添加到我们的GraphQL模式中。正如我们之前通过@cypher模式指令所看到的，GraphQL模式指令允许我们在解析GraphQL请求时应用一些自定义的服务端逻辑。
- en: 'The Neo4j GraphQL library includes the @auth GraphQL schema directive, which
    allows for defining authorization rules to protect fields or types in the GraphQL
    schema. Before we can use the @auth schema directive, we’ll need to specify the
    method used to verify the JWT as well as the secret that should be used to verify
    the token. Let’s set an environment variable with the value of our JWT secret:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j GraphQL库包括@auth GraphQL模式指令，允许定义授权规则以保护GraphQL模式中的字段或类型。在我们能够使用@auth模式指令之前，我们需要指定用于验证JWT的方法以及用于验证令牌的密钥。让我们设置一个环境变量，其值为我们的JWT密钥：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we’ll need to update the configuration for the Neo4j GraphQL Library to
    specify that this token should be used when verifying authorization tokens, as
    shown in listing 7.3\. To do this, we will read the JWT_SECRET environment variable
    we just set and pass this in a plugins object alongside our type definitions and
    resolvers. We’ll also need to install the graphql-plugin-auth package to enable
    the usage of authorization plugins with the Neo4j GraphQL Library:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新Neo4j GraphQL库的配置，指定在验证授权令牌时应使用此令牌，如列表7.3所示。为此，我们将读取我们刚刚设置的JWT_SECRET环境变量，并将其与我们的类型定义和解析器一起传递到插件对象中。我们还需要安装graphql-plugin-auth包以启用与Neo4j
    GraphQL库一起使用授权插件：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 7.3 api/index.js: Configuring authorization for the Neo4j GraphQL library'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3 api/index.js：配置Neo4j GraphQL库的授权
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Validate JWTs using a secret.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用密钥验证JWT。
- en: We can also configure JWT decoding and verification using a JSON Web Key Set
    (JWKS) URL, a more secure approach than using a shared secret. We will use this
    method to configure JWT verification with the Neo4j GraphQL library when we use
    Auth0, but for now, configuring using the shared secret is fine, as shown in the
    next listing. In addition, we also need to pass through the HTTP request object
    that includes the authorization header and the user’s auth token.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用JSON Web Key Set (JWKS) URL配置JWT解码和验证，这是一种比使用共享密钥更安全的方法。当我们使用Auth0时，我们将使用此方法配置Neo4j
    GraphQL库中的JWT验证，但就目前而言，使用共享密钥配置是可行的，如下一个列表所示。此外，我们还需要传递包含授权头和用户认证令牌的HTTP请求对象。
- en: 'Listing 7.4 api/index.js: Pass through the request object with the auth token'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4 api/index.js：传递带有认证令牌的请求对象
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Pass the HTTP request object to the context function so the JWT can be decoded
    in the resolvers generated by the Neo4j GraphQL library.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将HTTP请求对象传递给上下文函数，以便Neo4j GraphQL库生成的解析器可以解码JWT。
- en: 7.3.1 Rules and operations
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 规则和操作
- en: 'When using the @auth GraphQL schema directive, there are two aspects we need
    to consider: rules and operations. Both of these are specified as arguments to
    the @auth directive. There are several types of authorization rules that can be
    defined, depending on how, exactly, we want to protect fields and types. Perhaps
    we only want certain fields to be accessible to users who have signed in. Or perhaps
    we want only administrators in our application to be able to edit certain types.
    Or perhaps only authors of a review should be able to update it. These are all
    authorization rules that can be specified using the @auth directive. The following
    rule types are available with the @auth schema directive:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用@auth GraphQL模式指令时，我们需要考虑两个方面的内容：规则和操作。这两个都作为@auth指令的参数指定。可以定义几种授权规则，具体取决于我们如何精确地保护字段和类型。也许我们只想让已登录的用户访问某些字段。或者，也许我们只想让我们的应用中的管理员能够编辑某些类型。或者，也许只有评论的作者才能更新它。这些都是可以使用@auth指令指定的授权规则。以下是与@auth模式指令一起可用的规则类型：
- en: isAuthenticated is the most basic rule we can use. A GraphQL request accessing
    the protected type or field must have a valid JWT.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: isAuthenticated是我们能使用的最基本规则。访问受保护类型或字段的GraphQL请求必须包含有效的JWT。
- en: The roles rule specifies one or more roles, which must be contained in the JWT
    payload.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: roles规则指定一个或多个角色，这些角色必须包含在JWT负载中。
- en: The allow rule will compare values from the JWT payload to values in the database,
    ensuring they are equal for a valid request.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: allow规则将比较JWT负载中的值与数据库中的值，确保它们在有效请求中相等。
- en: The bind rule is used to ensure equality between a value in the JWT payload
    and in a GraphQL mutation operation before committing to the database.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bind规则用于确保在提交到数据库之前，JWT负载中的值与GraphQL突变操作中的值相等。
- en: The where rule is similar to allow, in that a value from the JWT payload is
    used; however, instead of checking for equality, a predicate is added to the generated
    database query to filter for data matching the rule.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Where规则与allow规则类似，都使用JWT负载中的值；然而，它不是检查相等性，而是在生成的数据库查询中添加了一个谓词来过滤符合规则的数据。
- en: 'When adding rules using the @auth directive, one or more operations can be
    optionally specified, indicating which operations the rule should be applied to.
    If no operations are specified, then the rule will be applied to all operations.
    The following operations can be used:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用@auth指令添加规则时，可以可选地指定一个或多个操作，指示规则应用于哪些操作。如果没有指定操作，则规则将应用于所有操作。以下操作可以使用：
- en: CREATE
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建
- en: READ
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取
- en: UPDATE
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新
- en: DELETE
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: CONNECT
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接
- en: DISCONNECT
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断开连接
- en: Let’s see the @auth directive in action to help us understand how these rules
    and operations should be used in our business reviews application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看@auth指令的实际应用，以帮助我们理解这些规则和操作如何在我们的业务审查应用中使用。
- en: 7.3.2 The isAuthenticated authorization rule
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 isAuthenticated授权规则
- en: The isAuthenticated rule can be used on either GraphQL types or fields and indicates
    that to access that type or field, the GraphQL request must have a valid JWT attached.
    The validity of the JWT is determined by whether or not it can be verified using
    the JWT secret value as the key—indicating that the token was signed by the private
    key and created by the appropriate authority. The isAuthenticated logic is used
    to gate some area of the application that requires the user to authenticate to
    the application but does not require any specific permissions—the user only needs
    to be an authenticated user.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: isAuthenticated规则可以在GraphQL类型或字段上使用，表示要访问该类型或字段，GraphQL请求必须附加有效的JWT。JWT的有效性由是否可以使用JWT密钥值作为密钥进行验证来决定——这表明令牌是由私钥签署并由适当的权威机构创建的。isAuthenticated逻辑用于控制应用中需要用户认证但不需要任何特定权限的区域——用户只需要是一个认证用户。
- en: For the purposes of our business reviews application, let’s say we want to allow
    any user to search for businesses but only show the averageStars field to authenticated
    users, encouraging users to sign up with our application. Let’s update our GraphQL
    type definitions to include this authorization rule.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的业务审查应用，假设我们希望允许任何用户搜索企业，但只向认证用户显示averageStars字段，以鼓励用户使用我们的应用进行注册。让我们更新我们的GraphQL类型定义以包含此授权规则。
- en: 'Listing 7.5 api/index.js: Updating the Business type'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5 api/index.js：更新Business类型
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ We add the @auth schema directive to protect the averageStars field, using
    an isAuthenticated rule.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们使用@auth模式指令添加isAuthenticated规则来保护averageStars字段。
- en: We’ve now protected the averageStars field, which means we’ll need to include
    a valid JWT in the header of any GraphQL request with that field, as shown in
    the next listing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经保护了averageStars字段，这意味着我们需要在包含该字段的任何GraphQL请求的头部包含一个有效的JWT，如下一个列表所示。
- en: Listing 7.6 Requesting the protected averageStars field in a GraphQL query
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 在GraphQL查询中请求受保护的averageStars字段
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we don’t include the averageStars field in the selection set, our request
    returns the expected fields. Experiment with sending an invalid token and requests
    with and without the averageStars field. Here we include a valid token in the
    request’s authorization header to allow us to view the averageStars field:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不将averageStars字段包含在选择集中，我们的请求将返回预期的字段。尝试发送无效令牌和包含或不包含averageStars字段的请求。在这里，我们在请求的授权头中包含一个有效令牌，以便我们可以查看averageStars字段：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 7.3.3 The roles authorization rule
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 角色授权规则
- en: The roles rule allows us to add requirements for the type of permissions required
    for one or more operations. Rather than just having a valid signed token, to access
    a field or type protected by a roles rule, the token must include one of the specified
    roles in the role claim encoded in the token. Let’s take a look at an example
    in the next listing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 角色规则允许我们为一种或多种操作添加所需权限类型的必要条件。除了拥有一个有效的签名令牌外，要访问受角色规则保护的字段或类型，令牌必须包含在令牌中编码的角色声明中指定的一个角色。让我们在下一个列表中查看一个示例。
- en: 'Listing 7.7 api/index.js: Protecting the user type with a roles authorization
    rule'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 api/index.js：使用角色授权规则保护用户类型
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we use the extend GraphQL keyword in our type definitions to add additional
    directives or fields to a type already defined in our type definitions. Using
    this syntax is equivalent to including the directive when first defining the type,
    but using type extensions allows us to separate our type definitions into multiple
    files if we desire (see figure 7.5).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用extend GraphQL关键字在我们的类型定义中添加额外的指令或字段到已经定义在我们的类型定义中的类型。使用此语法等同于在首次定义类型时包含指令，但使用类型扩展允许我们将我们的类型定义分成多个文件，如果需要的话（见图7.5）。
- en: '![CH07_F05_Lyon](../../OEBPS/Images/CH07_F05_Lyon.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F05_Lyon](../../OEBPS/Images/CH07_F05_Lyon.png)'
- en: Figure 7.5 Authorization flow, using the @auth GraphQL schema directive
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 使用@auth GraphQL架构指令的授权流程
- en: Now, any GraphQL operation that accesses the User type must have the admin role,
    including any that traverse to a user, as the next listing shows.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何访问用户类型的GraphQL操作都必须具有管理员角色，包括任何遍历到用户的操作，如下一个列表所示。
- en: Listing 7.8 GraphQL query accessing user information
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 查询用户信息的GraphQL
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Executing the previous query will result in the following error message, since
    our token does not include the admin role:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的查询将导致以下错误消息，因为我们的令牌不包括管理员角色：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We’ll need to include the roles in the claims in the token. Return to the online
    JWT builder at [https://jwt.io](https://jwt.io), and add the roles array to the
    claims:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在令牌中的声明中包含角色。返回到在线JWT构建器[https://jwt.io](https://jwt.io)，并将角色数组添加到声明中：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, if we update the token used in the authorization header in Apollo Studio
    using this new JWT and run the GraphQL query again, we will be able to access
    user information.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用这个新的JWT更新Apollo Studio中用于授权头的令牌，并再次运行GraphQL查询，我们将能够访问用户信息。
- en: Remember that if we don’t specify specific operations (e.g., create, read, and
    update) when adding our authorization rules, then the rule applies to all operations
    that include the type or field in question. If we want to limit the authorization
    rule to only being applied to certain operations, we must explicitly specify them
    when defining the rules, using the @auth schema directive.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果我们没有在添加授权规则时指定特定操作（例如，创建、读取和更新），那么该规则将适用于包含所讨论类型或字段的任何操作。如果我们想限制授权规则只应用于某些操作，我们必须在定义规则时明确指定它们，使用@auth架构指令。
- en: The first two @auth rules we examined (isAuthenticated and roles) used only
    values from the JWT payload (or, simply, the presence of a valid token, in the
    case of isAuthenticated). The next three rules we will explore will use values
    from the database (our application data) to enforce authorization rules.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前检查的前两个@auth规则（isAuthenticated和roles）仅使用了JWT有效载荷中的值（或者，在isAuthenticated的情况下，简单地，有效令牌的存在）。接下来我们将探索的三个规则将使用数据库中的值（我们的应用程序数据）来执行授权规则。
- en: 7.3.4 The allow authorization rule
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.4 允许授权规则
- en: Previously, we created a rule that protected the user type by requiring the
    admin role for the authenticated user. Let’s add an additional authorization rule
    to allow users to read their own user information.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们创建了一个规则，通过要求认证用户具有管理员角色来保护用户类型。让我们添加一个额外的授权规则，允许用户读取他们自己的用户信息。
- en: 'Listing 7.9 api/index.js: Allowing users to access their own user information'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 api/index.js：允许用户访问他们自己的用户信息
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that we have combined our new allow rule with the existing roles rule.
    Since the rules argument takes an array of rules, these act as or logic. To access
    the user type, the claims in the request’s JWT must conform to at least one of
    the authorization rules defined in the rules array. In this case, the authenticated
    user must be either an admin or match the userId of the user being requested.
    To test our new rule, let’s create a new JWT for the user Jenny with the following
    payload:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将我们的新允许规则与现有的角色规则结合起来。由于规则参数接受一个规则数组，这些规则充当或逻辑。要访问用户类型，请求的 JWT 中的声明必须至少符合规则数组中定义的授权规则之一。在这种情况下，认证用户必须是管理员或与请求用户的
    userId 匹配。为了测试我们的新规则，让我们为用户 Jenny 创建一个新的 JWT，其有效载荷如下：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can create this using the web interface at [jwt.io](https://jwt.io/); just
    be sure to use the same JWT secret when signing the token:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 web 界面在 [jwt.io](https://jwt.io/) 中创建此 JWT；只需确保在签名令牌时使用相同的 JWT 密钥：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, using this JWT to execute a GraphQL request as the user Jenny, we can query
    for this user’s details in the following listing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用此 JWT 以用户 Jenny 的身份执行 GraphQL 请求，我们可以在以下列表中查询此用户的详细信息。
- en: Listing 7.10 Query for a single user’s details
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.10 查询单个用户的详细信息
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since the sub claim in our JWT matches the userId of the user we are requesting,
    we see the result data:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 JWT 中的 sub 声明与请求用户的 userId 匹配，我们看到了结果数据：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, our GraphQL query is filtering for the user, using the where argument
    to ensure we are only querying for the data that we have access to. What happens
    if we ask for user data that we don’t have access to? For example, what if we
    asked for all user information?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的 GraphQL 查询正在使用 where 参数过滤用户，以确保我们只查询我们有权访问的数据。如果我们请求我们没有访问权限的用户数据会发生什么？例如，如果我们请求所有用户信息会怎样？
- en: Listing 7.11 Query for all user details
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.11 查询所有用户详细信息
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since our user is not an admin and we are requesting user objects for which
    the userId will not match the sub claim in our JWT, we will see a Forbidden error.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的用户不是管理员，并且我们请求的用户对象中 userId 将不会与我们的 JWT 中的 sub 声明匹配，我们将看到禁止错误。
- en: Let’s see how we can avoid these types of errors by automatically filtering
    the query results for only the data the authenticated user has access to. To accomplish
    this, we will use a where authorization rule. This means the client doesn’t need
    to worry about adding a filter to avoid asking for data the authenticated user
    doesn’t have access to.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过自动过滤查询结果，只为认证用户有权访问的数据，来避免这些类型的错误。为了实现这一点，我们将使用一个 where 授权规则。这意味着客户端不必担心添加过滤器以避免请求认证用户无权访问的数据。
- en: 7.3.5 The where authorization rule
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.5 Where 授权规则
- en: In the previous section, we used an allow authorization rule to ensure that
    users are only able to access their own data. However, this approach was problematic
    in that it put the burden on the client to add the appropriate filters to ensure
    the GraphQL request was not asking for data the user was not authorized to see.
    Let’s instead use a where rule in the next listing, so we don’t need to worry
    about requesting data that the authenticated user is not authorized to see.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了一个允许授权规则来确保用户只能访问他们自己的数据。然而，这种方法存在问题，因为它将负担放在了客户端，需要客户端添加适当的过滤器以确保
    GraphQL 请求没有请求用户无权查看的数据。让我们在下一个列表中使用一个 where 规则，这样我们就不必担心请求认证用户无权查看的数据。
- en: 'Listing 7.12 api/index.js: Using a where authorization rule'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.12 api/index.js：使用 where 授权规则
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We still need to ensure that only admin users are able to create, update, or
    delete users, so we add those operations to the roles rule, as shown in listing
    7.13\. Now, whenever a read request for the user type is executed, a predicate
    in the generated database query is added to filter for only the currently authenticated
    user, matching the sub claim of the JWT to the userId node property value in the
    database.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要确保只有管理员用户能够创建、更新或删除用户，因此我们将这些操作添加到角色规则中，如列表7.13所示。现在，每当执行对用户类型的读取请求时，生成的数据库查询中都会添加一个谓词，以过滤出当前认证的用户，将JWT的sub声明与数据库中userId节点属性值相匹配。
- en: Listing 7.13 GraphQL query requesting user information
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.13 GraphQL查询请求用户信息
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we examine the generated Cypher query sent to the database we can see the
    predicate that is appended, ensuring the node’s userId property value in the database
    matches the JWT sub value, as shown in the following listing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查发送到数据库的生成的Cypher查询，我们可以看到附加的谓词，确保数据库中节点的userId属性值与JWT的sub值相匹配，如下列所示。
- en: Listing 7.14 Generated Cypher query
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.14 生成的Cypher查询
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 7.3.6 The bind authorization rule
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.6 绑定授权规则
- en: The bind rule is used to enforce authorization rules when creating or updating
    data and can also be used across relationships. In listing 7.15, let’s use a bind
    rule to ensure that when reviews are created or updated, they are connected to
    the currently authenticated user. We don’t want to allow users to falsely create
    reviews written by other users!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定规则用于在创建或更新数据时强制执行授权规则，也可以用于跨关系。在列表7.15中，让我们使用绑定规则来确保在创建或更新审查时，它们与当前认证的用户相关联。我们不希望允许用户伪造其他用户的审查！
- en: 'Listing 7.15 api/index.js: Using a bind authorization rule'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.15 api/index.js：使用绑定授权规则
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let’s write a GraphQL mutation to create a new business review in the next listing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一个列表中编写一个GraphQL突变来创建一个新的商业审查。
- en: Listing 7.16 Creating a new review
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.16 创建新的审查
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This executes with no problem, adding the review node to the database and the
    appropriate relationships:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有问题执行，将审查节点添加到数据库中并建立适当的关系：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, if instead of connecting the review to the currently authenticated
    user (in this case, the user with userId u3), the mutation tries to connect to
    user u1 or to no user at all, then the mutation operation will fail, and a Forbidden
    error will be returned.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果连接审查与当前认证用户（在这种情况下，userId为u3的用户）的操作失败，尝试连接到用户u1或没有任何用户，那么突变操作将失败，并返回一个禁止错误。
- en: 'Be sure to refer to the documentation for more examples of how to use the @auth
    GraphQL schema directive to add complex authorization rules to your GraphQL API:
    [neo4j.com/docs/graphql-manual/current/auth](https://neo4j.com/docs/graphql-manual/3.0/auth/).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必参考文档以获取更多关于如何使用@auth GraphQL模式指令将复杂授权规则添加到您的GraphQL API的示例：[neo4j.com/docs/graphql-manual/current/auth](https://neo4j.com/docs/graphql-manual/3.0/auth/)。
- en: So far, we’ve been using the JWT Builder website to create our JWTs; this is
    fine for development and testing, but we need something more for production.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用JWT Builder网站创建我们的JWT；这对于开发和测试来说是不错的，但我们还需要为生产环境准备更多。
- en: '7.4 Auth0: JWT as a service'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 Auth0：JWT as a service
- en: Auth0 is an authentication and authorization service that can authenticate users
    with several methods, such as social sign-in or email and password. It also includes
    functionality to maintain a database of users, and we can use it to define rules
    and permissions for our users. I like to think of Auth0 as a JWT-as-a-service
    provider. Even though Auth0 has lots of functionality and services, at the end
    of the day, I’m often just interested in getting a user’s auth token (as a JWT)
    and using that to authorize the user in my APIs and applications.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Auth0是一个认证和授权服务，可以使用多种方法认证用户，例如社交登录或电子邮件和密码。它还包括维护用户数据库的功能，我们可以用它来定义用户的规则和权限。我喜欢将Auth0视为JWT-as-a-service提供商。尽管Auth0有很多功能和服务，但最终，我通常只对获取用户的认证令牌（作为JWT）并使用它来授权我的API和应用程序感兴趣。
- en: Auth0 is also a good service for learning and development because it offers
    a free tier with no credit card required to sign up. In this section, we will
    configure Auth0 to protect our API and then use the Auth0 React SDK to add Auth0
    support to our application. You can create an Auth0 account for free at [https://auth0.com](https://auth0.com).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Auth0也是一个很好的学习和发展的服务，因为它提供免费层，无需信用卡即可注册。在本节中，我们将配置Auth0以保护我们的API，然后使用Auth0 React
    SDK将Auth0支持添加到我们的应用程序中。您可以在[https://auth0.com](https://auth0.com)免费创建Auth0账户。
- en: 7.4.1 Configuring Auth0
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 配置 Auth0
- en: Once we’ve signed in to Auth0, we’ll need to create an API and an Application
    in our Auth0 tenant (see figure 7.6). First, create the API and give it a name.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们登录到 Auth0，我们将在我们的 Auth0 租户中创建一个 API 和一个应用程序（见图 7.6）。首先，创建 API 并为其命名。
- en: '![CH07_F06_Lyon](../../OEBPS/Images/CH07_F06_Lyon.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F06_Lyon](../../OEBPS/Images/CH07_F06_Lyon.png)'
- en: Figure 7.6 Creating an API in Auth0
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 在 Auth0 中创建 API
- en: We won’t make use of this feature in our application, but we can, optionally,
    enable role-based access control (RBAC) for our API (see figure 7.7). This will
    allow us to add fine-grained permissions to the JWTs generated by Auth0 that can
    be used by the roles @auth schema directive rule for role-based access control.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在我们的应用程序中使用此功能，但我们可以选择性地为我们的 API 启用基于角色的访问控制（RBAC）（见图 7.7）。这将允许我们向 Auth0
    生成的 JWT 添加细粒度的权限，这些权限可以用于基于角色的访问控制（@auth）模式指令规则。
- en: '![CH07_F07_Lyon](../../OEBPS/Images/CH07_F07_Lyon.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F07_Lyon](../../OEBPS/Images/CH07_F07_Lyon.png)'
- en: Figure 7.7 Enabling RBAC for our API in Auth0
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 在 Auth0 中为我们的 API 启用 RBAC
- en: If we do enable RBAC, we’ll also need to define all possible permissions that
    can be used in our API. I’ve added the necessary permissions for creating, reading,
    updating, and deleting businesses in our API (see figure 7.8).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启用 RBAC，我们还需要定义我们 API 中可以使用的所有可能的权限。我已经为我们的 API 中创建、读取、更新和删除业务添加了必要的权限（见图
    7.8）。
- en: '![CH07_F08_Lyon](../../OEBPS/Images/CH07_F08_Lyon.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F08_Lyon](../../OEBPS/Images/CH07_F08_Lyon.png)'
- en: Figure 7.8 Adding permissions to the API in Auth0
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 在 Auth0 中的 API 中添加权限
- en: 'You can read more about using the roles authorization rule to enable RBAC in
    the Neo4j GraphQL Library documentation here: [http://mng.bz/5Q5z](http://mng.bz/5Q5z).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Neo4j GraphQL 库文档中了解更多关于使用角色授权规则启用 RBAC 的信息：[http://mng.bz/5Q5z](http://mng.bz/5Q5z)。
- en: Now, we need to create our Application in the Auth0 dashboard. Select *Create
    Application*. We’ll need to choose a name for our application—I used *Business
    Reviews*. We’re also asked to choose the type of application. Since we’re building
    a React application, choose *Single Page Web Application*, and click the *Create*
    button.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在 Auth0 控制台中创建我们的应用程序。选择 *创建应用程序*。我们需要为我们的应用程序选择一个名称——我使用了 *Business
    Reviews*。我们还被要求选择应用程序类型。由于我们正在构建一个 React 应用程序，请选择 *单页 Web 应用程序*，然后点击 *创建* 按钮。
- en: We’ll keep most default settings, but we must update the entries for *Allowed
    Callback URLs* and *Allowed Logout URLs*. Add http://localhost:3000 to each of
    these text boxes under the *Settings* tab for our new application, and then select
    *Save Changes*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留大多数默认设置，但我们必须更新 *允许回调 URL* 和 *允许注销 URL* 的条目。在我们的新应用程序的 *设置* 选项卡下，将 http://localhost:3000
    添加到每个文本框中，然后选择 *保存更改*。
- en: Next, we’ll need to update the configuration in our GraphQL API, specifying
    the method used to verify the JWTs generated by Auth0, as shown in listing 7.17\.
    Up to now, we’ve been using a simple secret stored in an environment variable
    (JWT_SECRET) to verify the JWT. This is fine for local development and testing,
    but we’ll want to use a more secure method now that we’re using Auth0 and preparing
    to deploy our application to the web.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的 GraphQL API 中的配置，指定用于验证 Auth0 生成的 JWT 的方法，如图 7.17 列表所示。到目前为止，我们一直在使用存储在环境变量（JWT_SECRET）中的简单密钥来验证
    JWT。这对于本地开发和测试来说是不错的，但现在我们使用 Auth0 并准备将我们的应用程序部署到网络上，我们希望使用更安全的方法。
- en: Navigate to *Advanced Settings* and then *Endpoints*. Look for the JWKS URL,
    and copy this value. Then, in the code for our GraphQL API, change the method
    used for validating the JWT to jwksEndpoint using the URL for your Auth0 application.
    This will allow our GraphQL API to fetch the public key from Auth0 to validate
    the token, which is a much more secure method than using a shared secret.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到 *高级设置* 然后选择 *端点*。查找 JWKS URL，并复制此值。然后，在我们的 GraphQL API 代码中，将用于验证 JWT 的方法更改为使用
    Auth0 应用程序的 URL 的 jwksEndpoint。这将允许我们的 GraphQL API 从 Auth0 获取公钥以验证令牌，这是一种比使用共享密钥更安全的验证方法。
- en: 'Listing 7.17 api/index.js: Using the Auth0 JSON Web Key Set (JWKS) endpoint'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.17 api/index.js：使用 Auth0 JSON Web Key Set (JWKS) 端点
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Now we use the Neo4jGraphQLAuthJWKSPlugin class.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 现在我们使用 Neo4jGraphQLAuthJWKSPlugin 类。
- en: ❷ Be sure to use your endpoint, as found in Auth0’s Advanced Settings.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 请确保使用在 Auth0 高级设置中找到的端点。
- en: We’re now ready to start integrating Auth0 into our React application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好开始将 Auth0 集成到我们的 React 应用程序中。
- en: 7.4.2 Auth0 React
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 Auth0 React
- en: First, let’s install the Auth0 SDK for React. This package includes React-specific
    integrations for adding Auth0 support to any React applications.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装Auth0 SDK for React。这个包包括为添加Auth0支持到任何React应用程序而设计的特定于React的集成。
- en: 'We’ll install the auth0-react library using npm. First, be sure you’re in the
    web-react directory:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用npm安装auth0-react库。首先，确保你处于web-react目录中：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, let’s add the initial Auth0 setup to our React application in the next
    listing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一个列表中将初始Auth0设置添加到我们的React应用程序中。
- en: 'Listing 7.18 web-react/src/index.js: Adding the Auth0 provider component'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.18 web-react/src/index.js：添加Auth0提供者组件
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Import the Auth0 Provider component.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入Auth0 Provider组件。
- en: ❷ Wrap our App component with the Auth0Provider component.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将我们的App组件包裹在Auth0Provider组件中。
- en: We add the Auth0Provider component, injecting it into the component hierarchy
    by wrapping our ApolloProvider and App components. We also include the domain,
    client ID, and audience information for our Auth0 tenant, application, and API
    that we just created. This information can be found in the Auth0 dashboard for
    your Auth0 application.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加Auth0Provider组件，通过包裹我们的ApolloProvider和App组件将其注入到组件层次结构中。我们还包含了我们的Auth0租户、应用程序和API的域、客户端ID和受众信息，这些信息可以在Auth0仪表板中找到。
- en: In the next listing, we’ll add login and logout buttons to our application using
    Auth0\. Clicking the login button will walk the user through Auth0’s authentication
    flow.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的列表中，我们将使用Auth0将登录和注销按钮添加到我们的应用程序中。点击登录按钮将引导用户通过Auth0的认证流程。
- en: 'Listing 7.19 web-react/src/App.js: Adding login and logout buttons'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.19 web-react/src/App.js：添加登录和注销按钮
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Import the useAuth0 React hook.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入useAuth0 React钩子。
- en: ❷ Access functions to work with authentication flow and user data.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 访问函数以处理认证流程和用户数据。
- en: ❸ Add the login and logout buttons.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 添加登录和注销按钮。
- en: The Auth0 React package includes a useAuth0 hook, which gives us access to functions
    that can trigger the authentication flow, determine whether the user is currently
    authenticated, and access user information. Now, we have a button with the option
    to log in, or if we’re already logged in, then we have the option to log out.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Auth0 React包包括一个useAuth0钩子，它为我们提供了可以触发认证流程、确定用户是否当前已认证以及访问用户信息的函数。现在，我们有一个带有登录选项的按钮，或者如果我们已经登录，我们就有注销的选项。
- en: Clicking *Log In*, we’re presented with a number of options for sign-in, including
    GitHub, Google, Twitter, or email and password authentication (see figure 7.9).
    One benefit of using an authentication service is that we don’t really need to
    concern ourselves with the specifics of the auth flow, since this is handled by
    Auth0.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“登录”，我们会看到一系列登录选项，包括GitHub、Google、Twitter或电子邮件和密码认证（见图7.9）。使用认证服务的优点之一是我们实际上不需要关心认证流程的具体细节，因为这是由Auth0处理的。
- en: '![CH07_F09_Lyon](../../OEBPS/Images/CH07_F09_Lyon.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F09_Lyon](../../OEBPS/Images/CH07_F09_Lyon.png)'
- en: Figure 7.9 Sign-in options via Auth0
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 通过Auth0的登录选项
- en: Notice the use of the isAuthenticated variable provided by the useAuth0 hook.
    Once they log in, we can also access user information. Let’s now add a profile
    component to show the user’s name and avatar image once they’ve logged in. Create
    a new file, Profile .js, in the web-react/src directory, as shown in the next
    listing.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用了由useAuth0钩子提供的isAuthenticated变量。一旦他们登录，我们也可以访问用户信息。现在，让我们添加一个配置文件组件，在用户登录后显示他们的姓名和头像图片。在web-react/src目录中创建一个新文件Profile.js，如下所示。
- en: 'Listing 7.20 web-react/src/Profile.js: Adding a user profile component'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.20 web-react/src/Profile.js：添加用户配置文件组件
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, let’s include this profile component in our main App component to display
    the profile when the user is logged in.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个配置文件组件包含到我们的主App组件中，以便在用户登录时显示配置文件。
- en: 'Listing 7.21 web-react/src/App.js: Adding profile component'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.21 web-react/src/App.js：添加配置文件组件
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Adding the Profile component
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加配置文件组件
- en: OK, we’re able to have users sign in to our application and show their profile
    information, as shown in figure 7.10, but how do we make authenticated requests
    to our GraphQL API? We saw when using Apollo Studio that we need to attach the
    authorization token as a header in the GraphQL request.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在可以让用户登录到我们的应用程序并显示他们的配置文件信息，如图7.10所示，但我们如何向我们的GraphQL API发送认证请求呢？当我们使用Apollo
    Studio时，我们看到了需要在GraphQL请求中附加授权令牌作为头部。
- en: '![CH07_F10_Lyon](../../OEBPS/Images/CH07_F10_Lyon.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F10_Lyon](../../OEBPS/Images/CH07_F10_Lyon.png)'
- en: Figure 7.10 The authenticated view of our React application
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 我们React应用程序的认证视图
- en: To access the token, we will use the getAccessTokenSilently function from the
    auth0-react library. Then, we will attach this token to the Apollo Client instance,
    as shown in the next listing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问令牌，我们将使用 auth0-react 库中的 getAccessTokenSilently 函数。然后，我们将把这个令牌附加到 Apollo
    Client 实例中，如下一列表所示。
- en: 'Listing 7.22 web-react/src/index.js: Adding the access token in our GraphQL
    request'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.22 web-react/src/index.js：在我们的 GraphQL 请求中添加访问令牌
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Create a wrapper component that will be responsible for adding the authorization
    token.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个包装组件，该组件将负责添加授权令牌。
- en: ❷ Use Apollo Client’s setContext function to add the JWT to the GraphQL request.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 Apollo Client 的 setContext 函数将 JWT 添加到 GraphQL 请求中。
- en: ❸ Inject the AppWithApollo component into the React component hierarchy.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 AppWithApollo 组件注入到 React 组件层次结构中。
- en: Now, each request to the GraphQL API will include the authorization token in
    the header if the user is authenticated. We can verify this by opening the browser
    developer tools and inspecting the GraphQL network request (see figure 7.11).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果用户经过身份验证，每次对 GraphQL API 的请求都会在头部包含授权令牌。我们可以通过打开浏览器开发者工具并检查 GraphQL 网络请求（见图
    7.11）来验证这一点。
- en: '![CH07_F11_Lyon](../../OEBPS/Images/CH07_F11_Lyon.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F11_Lyon](../../OEBPS/Images/CH07_F11_Lyon.png)'
- en: Figure 7.11 Viewing the authorization header attached to the GraphQL request
    in the browser dev tools window
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 在浏览器开发者工具窗口中查看附加到 GraphQL 请求的授权头部
- en: 'We can copy this token and decode its payload using jwt.io. Here’s what my
    decoded token looks like:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以复制这个令牌并使用 jwt.io 来解码其有效载荷。以下是我的解码令牌的样子：
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Of course, our application doesn’t look any different, since we aren’t requesting
    any protected fields in our GraphQL query. Let’s add the averageStars field, which
    is protected by the isAuthenticated rule, to the GraphQL query when the user is
    logged in.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的应用程序看起来没有任何不同，因为我们没有在我们的 GraphQL 查询中请求任何受保护的字段。让我们在用户登录时，将受 isAuthenticated
    规则保护的 averageStars 字段添加到 GraphQL 查询中。
- en: 'Listing 7.23 web-react/src/App.js: Including the averageStars field in the
    selection set'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.23 web-react/src/App.js：在选择集中包含 averageStars 字段
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Add the averageStars field when the user is authenticated.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当用户经过身份验证时添加 averageStars 字段。
- en: And now we will update the BusinessResults component to include averageStars
    when the use is authenticated.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新 BusinessResults 组件，以便在用户经过身份验证时包含 averageStars。
- en: 'Listing 7.24 web-react/src/BusinessResults.js: Display the averageStars field'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.24 web-react/src/BusinessResults.js：显示 averageStars 字段
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Add the Average Stars header only when the user is authenticated.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅当用户经过身份验证时，才添加“平均星级”标题。
- en: ❷ Show the Average Stars value when authenticated.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当用户经过身份验证时显示平均星级值。
- en: Now, we’ll see the average stars for each business only when the user is authenticated.
    We’ve added authentication and authorization to our application and added support
    for Auth0\. Now that we’re confident our application is secure, we’ll take a look
    at deploying our application and database in the next chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只有在用户经过身份验证时才会看到每个企业的平均星级。我们已经将身份验证和授权添加到我们的应用程序中，并添加了对 Auth0 的支持。现在，我们相信我们的应用程序是安全的，我们将在下一章中查看如何部署我们的应用程序和数据库。
- en: 7.5 Exercises
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 练习
- en: Create a new query field called qualityBusinesses that uses a @cypher schema
    directive to return businesses that have at least two reviews each with four or
    more stars. Protect this field, using a roles rule and the @auth schema directive
    to require a role of analyst. Create a JWT that includes this role in the claims,
    and use Apollo Studio to query this new qualityBusinesses field.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的查询字段 qualityBusinesses，它使用 @cypher 架构指令来返回每个企业至少有两个评论，每个评论至少有四个星级的业务。使用角色规则和
    @auth 架构指令来保护此字段，要求分析师角色。创建一个包含此角色的声明的 JWT，并使用 Apollo Studio 来查询这个新的 qualityBusinesses
    字段。
- en: In this chapter, we used a GraphQL mutation to create a new business review.
    Update the React application to include a form to allow the currently authenticated
    user to create new business reviews.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 GraphQL 变更来创建新的企业评论。更新 React 应用程序以包括一个表单，允许当前经过身份验证的用户创建新的企业评论。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Authorization rules can be expressed declaratively in the GraphQL schema using
    the @auth GraphQL schema directive.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 @auth GraphQL 架构指令在 GraphQL 模式中以声明方式表达授权规则。
- en: JWT is a standard for encoding and transmitting JSON objects and is commonly
    used for authorization tokens in web applications, such as GraphQL APIs.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JWT 是一种用于编码和传输 JSON 对象的标准，通常用于 Web 应用程序中的授权令牌，如 GraphQL API。
- en: Auth0 is an identity and access management service that can be used to handle
    JWT generation and user authentication. Auth0 can be integrated into a React application,
    using the Auth0 React SDK.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Auth0 是一种身份和访问管理服务，可用于处理 JWT 生成和用户认证。Auth0 可以集成到 React 应用程序中，使用 Auth0 React
    SDK。
