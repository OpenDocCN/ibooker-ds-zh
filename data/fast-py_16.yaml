- en: Appendix B. Using Numba to generate efficient low-level code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 B. 使用 Numba 生成高效的底层代码
- en: Numba is a framework to auto-magically convert Python code to native code—CPU
    or GPU. It is, on the CPU side, an alternative to Cython. The reason we have an
    entire chapter on Cython and not Numba is because in this book we are interested
    in understanding how things work and not only in making them work. Numba, which
    is great otherwise, is not great from a pedagogical approach—due to being “magical.”
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 是一个将 Python 代码自动转换为原生代码（CPU 或 GPU）的框架。在 CPU 方面，它是 Cython 的替代品。我们为什么有一个关于
    Cython 而不是 Numba 的整个章节，是因为在这本书中，我们感兴趣的是了解事物是如何工作的，而不仅仅是让它们工作。Numba 虽然在其他方面很出色，但从教学角度来看并不出色——因为它具有“魔法性”。
- en: To solve real-world problems, Numba is as good as, if not better than, Cython
    as it requires less work on your part and produces similar results. From a usability
    perspective, I recommend you consider Numba as an alternative to Cython. Actually,
    it’s probably more pragmatic to consider Numba first.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决实际问题，Numba 与 Cython 相当，如果不是更好，因为它需要您更少的工作，并且产生类似的结果。从可用性的角度来看，我建议您将 Numba
    作为 Cython 的替代品考虑。实际上，首先考虑 Numba 可能更实用。
- en: Numba takes a Python function and dynamically converts it into optimized machine
    code when you try to run that function. In other words, it is a just-in-time (JIT)
    compiler.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试运行函数时，Numba 会将 Python 函数动态转换为优化的机器代码。换句话说，它是一个即时（JIT）编译器。
- en: In this appendix, we will develop an example for the CPU. You can use this content
    as an introduction to Numba that you need for the GPU chapter, or you can just
    take it as self-standing to learn Numba for the CPU.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们将为 CPU 开发一个示例。您可以将此内容作为 GPU 章节所需 Numba 介绍的入门，或者您可以将其作为独立的内容来学习 Numba
    用于 CPU。
- en: To run this code, you will need to install Numba. If you use conda, you can
    do `conda install numba`. If you use Docker, the image is `tiagoantao/python-
    performance-numba`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此代码，您需要安装 Numba。如果您使用 conda，可以执行 `conda install numba`。如果您使用 Docker，镜像为 `tiagoantao/python-performance-numba`。
- en: '![](../Images/APPB_F01_Antao.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPB_F01_Antao.png)'
- en: Figure B.1 A grayscale rendering of the Mandelbrot set
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.1 曼德布罗特集的灰度渲染
- en: 'Our example will be computing the Mandelbrot set, and we will be running both
    a native Python version and a Numba version to compare speeds. You have probably
    seen the iconic image—a variation is shown in figure B.1\. The Mandelbrot set
    is computed on the complex space—we will be using complex numbers—and studies
    what happens to the behavior of iterating the equation `z = z² + c`, where `c`
    is a point in space and `z` starts at `(0, 0)`. This computation is simpler than
    it seems. Let’s look at the code to understand the details:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子将是计算曼德布罗特集，我们将运行一个原生 Python 版本和一个 Numba 版本来比较速度。你可能已经见过这个标志性的图像——一个变体在图
    B.1 中显示。曼德布罗特集是在复数空间中计算的——我们将使用复数，并研究方程 `z = z² + c` 的迭代行为，其中 `c` 是空间中的一个点，而 `z`
    从 `(0, 0)` 开始。这个计算比看起来要简单。让我们看看代码来了解细节：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① We need to specify the maximum number of iterations, as this can be infinite.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们需要指定最大迭代次数，因为这可能是无限的。
- en: ② Python has native support for complex numbers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ② Python 本身支持复数。
- en: ③ The Mandelbrot equation z = z² + c
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 曼德布罗特方程 z = z² + c
- en: Our input is a point in space, `c`. We are interested in the number of iterations
    until the absolute value of the equation `z = z² + c` with `z` starting at (0,
    0) is above 2\. The number of iterations determines the color of the pixel for
    position `c`. We impose a maximum number of iterations as points close to 0 but
    may never get above 2, and the number of iterations would thus be infinite.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输入是空间中的一个点，`c`。我们感兴趣的是方程 `z = z² + c`（`z` 从 `(0, 0)` 开始）的绝对值超过 2 的迭代次数。迭代次数决定了位置
    `c` 的像素颜色。我们设定一个最大迭代次数，因为接近 0 的点可能永远不会超过 2，因此迭代次数将是无限的。
- en: So, we stop the iteration when the distance to the origin of `z` is larger than
    2\. Points very far away from the origin stop at the first iteration, and points
    close to the origin iterate forever. To avoid an infinite number of computations,
    we define a maximum number of iterations with `max_iter`. Around the border, the
    number of iterations changes in a chaotic way (the gray tones in figure B.1).
    The image shows the conversion of the number of iterations to a gray tone with
    a maximum number of iterations of 255 in the complex space between 1.5 – 1.3i
    and 0.5 + 1.3i.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当 `z` 到原点的距离大于2时，我们停止迭代。远离原点的点在第一次迭代时停止，而接近原点的点将无限迭代。为了避免无限次的计算，我们使用 `max_iter`
    定义最大迭代次数。在边界附近，迭代次数以混沌的方式变化（图B.1中的灰度色调）。图像显示了在复平面1.5 – 1.3i和0.5 + 1.3i之间的255次最大迭代次数下，迭代次数到灰度色调的转换。
- en: The main function to compute the Mandelbrot set is thus quite simple. The version
    here is actually slightly more complex than the standard version, as we rescale
    the output to between 0 and 255, irrespective of the number of iterations. Rescaling
    will make drawing a grayscale 8-bit image simpler. (I use a grayscale image due
    to the limitations of using color in the printed book.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 计算曼德布罗集的主要函数因此相当简单。这里的版本实际上比标准版本稍微复杂一些，因为我们把输出重缩放到0到255之间，不管迭代次数多少。重缩放将使绘制灰度8位图像变得简单。（我使用灰度图像是因为在打印的书中使用颜色的限制。）
- en: B.1 Generating optimized code with Numba
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.1 使用 Numba 生成优化代码
- en: 'We are now going to create a Numba version of the function by using the `@jit`
    decorator:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 `@jit` 装饰器来创建函数的 Numba 版本：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Don’t be fazed by the decorator: decorators are nothing more than syntactic
    sugar. Because in our case we want both versions—native and Numba—to compare performance,
    using a decorator is more convenient, as the `@` syntax would only expose the
    Numba version.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被装饰器吓到：装饰器不过是一种语法糖。因为在这种情况下，我们想要比较原生和 Numba 版本的性能，使用装饰器更方便，因为 `@` 语法只会暴露 Numba
    版本。
- en: 'As Numba is a JIT, the first call of the function will compile it to an LLVM
    representation; this is a one-time operation. We will do a dummy call so that
    later the performance analysis isn’t biased by this one-time step:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Numba 是一个 JIT（即时编译器），函数的第一次调用将把它编译成 LLVM 表示形式；这是一个一次性操作。我们将进行一个虚拟调用，这样后续的性能分析就不会因为这个一次性步骤而受到偏差：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You have to be careful with functions that might have side effects: make sure
    the dummy call doesn’t have undesired consequences. In most production scenarios
    where you aren’t performing benchmarking, you can simply ignore this step.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须小心那些可能有副作用的功能：确保虚拟调用没有不希望的结果。在大多数生产场景中，如果你没有进行基准测试，你可以简单地忽略这一步。
- en: 'Now we have two versions: the native (`compute_point`) and the Numba-optimized
    (`compute_point_numba`). We will need to call these functions for every point
    we want to draw. We will have a start and end corner and our resolution: we will
    have the same resolution on the X and Y coordinates:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个版本：原生版本（`compute_point`）和 Numba 优化版本（`compute_point_numba`）。我们需要为每个要绘制的点调用这些函数。我们将有一个起始角和结束角以及我们的分辨率：X和Y坐标上我们将有相同的分辨率：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This simple function goes through all the points. If you are thinking that it
    is amenable to a vectorization approach, you are correct; we will get to that
    later. `size` is the number of pixels in each dimension, `start` and `end` are
    the positions on the complex space, `img_array` is the output array, and `compute_fun`
    is the function that we will use to compute the value at each position.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的函数遍历所有点。如果你认为它可以接受向量化的方法，你是正确的；我们稍后会讨论这一点。"size" 是每个维度的像素数，"start" 和 "end"
    是复空间中的位置，"img_array" 是输出数组，"compute_fun" 是我们将用于计算每个位置值的函数。
- en: 'There is just a small nuance regarding how we compute the `x` and `y` coordinates.
    We could, in theory, add a delta to the current position like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何计算 `x` 和 `y` 坐标，这里有一个小的细节。理论上，我们可以像这样向当前位置添加一个增量：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The problem with this approach, which would be slightly faster, is that precision
    errors would accumulate from iteration to iteration, to the point that we may
    get erroneous results. So, we will stick with the more expensive `x = (endx -
    startx)*(xp/size) + startx`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点，虽然会稍微快一些，是精度误差会从一次迭代累积到下一次迭代，到我们可能得到错误的结果。因此，我们将坚持使用更昂贵的 `x = (endx
    - startx)*(xp/size) + startx`。
- en: 'To generate the image, the parameters are:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 生成图像的参数是：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We also need to initialize the array that will serve as the output.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要初始化作为输出的数组。
- en: 'Let’s now compare the time to run the native and Numba versions. With IPython,
    we could do:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们比较一下原生和Numba版本的运行时间。使用IPython，我们可以这样做：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: On my computer, I get a ten-fold increase in performance.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的电脑上，我得到了性能的十倍提升。
- en: 'As we can see from this example, Numba is quite good at optimizing Python code
    automatically, but it can also experience a problem that we saw earlier in Cython:
    if it cannot get rid of the CPython object machinery, performance suffers. Let’s
    create a somewhat artificial example to demonstrate this problem. While in our
    earlier example Numba performed an admirable job at automatic conversion, we can
    force Numba to generate CPython-bound code to see how it affects performance:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中我们可以看出，Numba在自动优化Python代码方面做得相当好，但它也可能遇到我们在Cython中看到的问题：如果它无法摆脱CPython对象机制，性能会受到影响。让我们创建一个稍微有些人为的例子来展示这个问题。在我们之前的例子中，Numba在自动转换方面做得令人钦佩，但我们可以强制Numba生成与CPython绑定的代码，看看它如何影响性能：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The run time is:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时间是：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, we have 1 min, 46 s. Note that this example is a worst-case scenario. Sometimes
    Numba can optimize parts of the code, even if it fails to optimize all of it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有1分46秒。请注意，这个例子是一个最坏的情况。有时Numba可以优化代码的一部分，即使它无法优化所有部分。
- en: 'To force Python compilation, add `nopython=True` to the decorator. If Numba
    fails to compile the function, be sure to check Numba’s documentation at [https://numba.readthedocs.io/en/stable/user/5minguide.html](https://numba.readthedocs.io/en/stable/user/5minguide.html)
    to see which Python functionalities are supported: we will not go through those
    here as they change over time.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制Python编译，请在装饰器中添加`nopython=True`。如果Numba无法编译函数，请务必查看Numba的文档[https://numba.readthedocs.io/en/stable/user/5minguide.html](https://numba.readthedocs.io/en/stable/user/5minguide.html)，以查看哪些Python功能受支持：我们不会在这里详细介绍，因为它们会随时间变化。
- en: B.2 Writing explicitly parallel functions in Numba
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.2 在Numba中显式编写并行函数
- en: 'Numba also allows you to write parallel threaded code, as sometimes you can
    release the GIL:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Numba还允许你编写并行线程代码，因为有时你可以释放GIL：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① We specify parallel=True, and we release the GIL with nogil=True.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们指定`parallel=True`，并通过`nogil=True`释放GIL。
- en: ② We use the prange function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用`prange`函数。
- en: 'When we use `prange`, we are asking Numba to parallelize that loop. Because
    the code is GIL-free (i.e., no interactions with CPython are required), parallelization
    is possible. As such, the result is:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`prange`时，我们是在要求Numba并行化该循环。因为代码是无GIL的（即不需要与CPython交互），所以可以并行化。因此，结果是：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The performance is a bit over three times the serial version on my machine.
    This result is obviously better, but not linear with the eight cores that I have
    available. Numba functions can, in some cases (i.e., when Numba can sidestep the
    Python interpreter completely), generate code that is truly parallel.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，性能是串行版本的3倍多。这个结果显然更好，但并不与我的可用八核线性相关。在某些情况下（即当Numba可以完全绕过Python解释器时），Numba函数可以生成真正的并行代码。
- en: B.3 Writing NumPy-aware code in Numba
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.3 在Numba中编写NumPy感知代码
- en: 'Now that we converted pure Python code with Numba, let’s consider a version
    using a NumPy universal function, as integrating in NumPy is fundamental for data
    science applications. Numba functions can be turned into NumPy universal functions,
    which is a common use case in data science. The process is quite simple:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用Numba将纯Python代码转换过来，让我们考虑一个使用NumPy通用函数的版本，因为将代码集成到NumPy对于数据科学应用是基本的。Numba函数可以被转换为NumPy通用函数，这是数据科学中常见的用例。这个过程相当简单：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We use the `vectorize` function to wrap `compute_point`. We specify that the
    function can be run and is parallel. We also have to supply a list of types of
    function signatures. Optional arguments, like `max_iter`, become mandatory in
    practice.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`vectorize`函数来包装`compute_point`。我们指定该函数可以运行且是并行的。我们还必须提供一个函数签名类型的列表。例如`max_iter`这样的可选参数在实践中变得强制。
- en: 'The way we use this code is different: we need to pass a matrix of positions
    for which we want the result:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此代码的方式不同：我们需要传递一个包含我们想要结果的位矩阵：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`prepare_pos_array` simply prepares the input array with all the coordinate
    positions to be computed. The downside to this approach is that we need memory
    to store both the position and results array.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`prepare_pos_array`只是准备输入数组，其中包含所有要计算的坐标位置。这种方法的不利之处在于我们需要内存来存储位置和结果数组。'
- en: 'Let’s time the run:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计时运行：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output on my machine is:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上的输出是：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This result is almost three times faster than the non-NumPy parallel version,
    all without a lot of work.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果比非 NumPy 并行版本快近三倍，而且无需做很多工作。
- en: This appendix should allow you to get started with Numba. If you are interested
    in generating GPU code using Numba, check out chapter 9\.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录应能帮助您开始使用 Numba。如果您对使用 Numba 生成 GPU 代码感兴趣，请查看第 9 章。
