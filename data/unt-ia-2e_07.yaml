- en: 5 Building a Memory game using Unity’s 2D functionality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 使用Unity的2D功能构建记忆游戏
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Displaying 2D graphics in Unity
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中显示2D图形
- en: Making objects clickable
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使对象可点击
- en: Loading new images programmatically
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以编程方式加载新图像
- en: Maintaining and displaying state by using UI text
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UI文本维护和显示状态
- en: Loading levels and restarting the game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载关卡和重新开始游戏
- en: 'Up to now, we’ve been working with 3D graphics, but you can also work with
    2D graphics in Unity. So in this chapter, you’ll build a 2D game. You’re going
    to develop the classic children’s game Memory: you’ll display a grid of card backs,
    reveal the card front when it’s clicked, and score matches. These mechanics cover
    the basics you need to know to develop 2D games in Unity.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理3D图形，但你也可以在Unity中使用2D图形。因此，在本章中，你将构建一个2D游戏。你将开发经典的儿童游戏记忆：你将显示一组卡片背面，当点击时显示卡片正面，并计分。这些机制涵盖了你在Unity中开发2D游戏所需了解的基本知识。
- en: Although Unity originated as a tool for 3D games, it’s used often for 2D games
    as well. Unity has had built-in 2D graphics support since version 4.3 in 2013,
    but even before then 2D games were already being developed in Unity (especially
    mobile games that took advantage of Unity’s cross-platform nature). In prior versions
    of Unity, game developers required a third-party framework to emulate 2D graphics
    within Unity’s 3D scenes. Eventually, the core editor and game engine were modified
    to incorporate 2D graphics, and this chapter will teach you about that functionality.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Unity最初是作为3D游戏的工具而诞生的，但它也常用于2D游戏。自2013年4.3版本以来，Unity已经内置了2D图形支持，但在此之前，2D游戏已经在Unity中开发（特别是利用Unity跨平台特性的移动游戏）。在Unity的早期版本中，游戏开发者需要第三方框架在Unity的3D场景中模拟2D图形。最终，核心编辑器和游戏引擎被修改以包含2D图形，本章将介绍这一功能。
- en: 'The 2D workflow in Unity is more or less the same as the workflow to develop
    a 3D game: import art assets, drag them into a scene, and write scripts to attach
    to the objects. The primary kind of art asset in 2D graphics is called a *sprite*.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的2D工作流程与开发3D游戏的工作流程大致相同：导入艺术资产，将它们拖入场景，并编写脚本将其附加到对象上。2D图形中的主要艺术资产称为*精灵*。
- en: DEFINITION *Sprites* are 2D images displayed directly on the screen, as opposed
    to images displayed on the surface of 3D models (that is, *textures*).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*精灵*是直接显示在屏幕上的2D图像，与显示在3D模型表面上的图像（即*纹理*）相对。
- en: You can import 2D images into Unity as sprites in much the same way you can
    import images as textures (see chapter 4). Technically, these sprites will be
    objects in 3D space, but they’ll be flat surfaces all oriented perpendicular to
    the z-axis. Because they’ll all face the same direction, you can point the camera
    straight at the sprites, and players will be able to discern their movements only
    along the x- and y-axes (in two dimensions).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将2D图像导入Unity作为精灵，就像你可以将图像导入为纹理一样（参见第四章）。技术上，这些精灵将是3D空间中的对象，但它们将是所有面向垂直于z轴的平面。因为它们都将朝向同一方向，你可以将相机直接对准精灵，玩家将能够仅沿x轴和y轴（在二维中）辨别它们的移动。
- en: 'In chapter 2, we discussed the coordinate axes: having three dimensions adds
    a z-axis perpendicular to the x- and y-axes you were already familiar with. Two
    dimensions are just those x- and y-axes (that’s what your teacher was talking
    about in math class!).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们讨论了坐标轴：有三个维度增加了垂直于你已熟悉的x轴和y轴的z轴。二维只是那些x轴和y轴（这就是你在数学课上老师所谈论的！）。
- en: 5.1 Setting up everything for 2D graphics
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 为2D图形设置一切
- en: You’re going to create the classic game of Memory. For those unfamiliar with
    this game, a series of cards are dealt out facedown. Every card has a matching
    card located somewhere else, but the player sees only the reverse side of the
    card. The player can turn over two cards at a time, attempting to find matching
    cards; if the two cards chosen aren’t a match, they’ll flip back, and then the
    player can guess again.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建经典的记忆游戏。对于那些不熟悉这个游戏的人来说，一系列卡片被倒扣分发。每张卡片都有一个位于其他地方的匹配卡片，但玩家只能看到卡片的背面。玩家可以一次翻两张卡片，试图找到匹配的卡片；如果选中的两张卡片不匹配，它们将翻转回来，然后玩家可以再次猜测。
- en: Figure 5.1 shows a mock-up of the game we’re going to build; compare this to
    the road map diagram from chapter 2\. The mock-up this time depicts exactly what
    the player will see (whereas the mock-up for our 3D scene depicted the space around
    the player and then where the camera went for the player to see through). Now
    that you know what you’ll be building, it’s time to get to work!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 展示了我们将要构建的游戏的草图；将其与第 2 章中的路线图图进行比较。这次的草图精确地描述了玩家将看到的内容（而我们的 3D 场景草图描述了玩家周围的空间以及摄像机移动的位置，以便玩家可以看到）。现在您知道了您将要构建的内容，是时候开始工作了！
- en: '![CH05_F01_Hocking3](../Images/CH05_F01_Hocking3.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F01_Hocking3](../Images/CH05_F01_Hocking3.png)'
- en: Figure 5.1 Mock-up of what the Memory game will look like
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 记忆游戏外观的草图
- en: 5.1.1 Preparing the project
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 准备项目
- en: The first step is to gather up and display graphics for our game. In much the
    same way as building the 3D demo previously, you want to start the new game by
    putting together the minimum set of graphics for the game to operate, and after
    that’s in place, you can start programming the functionality.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是收集并显示游戏所需的图形。与之前构建 3D 示例的方式类似，您想要通过组合游戏运行所需的最小图形集来开始新游戏，然后在该部分就绪后，您可以开始编程功能。
- en: 'That means you’ll need to create everything depicted in figure 5.1: card backs
    for hidden cards, a series of card fronts for when they turn over, a score display
    in one corner, and a reset button in the opposite corner. We also need a background
    for the screen, so all together, our art requirements sum up to figure 5.2.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您需要创建图 5.1 中所示的所有内容：隐藏卡的背面、翻面时的卡片正面系列、一个角上的得分显示和一个对角上的重置按钮。我们还需要屏幕的背景，所以总的来说，我们的艺术需求汇总为图
    5.2。
- en: '![CH05_F02_Hocking3](../Images/CH05_F02_Hocking3.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F02_Hocking3](../Images/CH05_F02_Hocking3.png)'
- en: Figure 5.2 Art assets required for the Memory game
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 记忆游戏所需的艺术资产
- en: TIP As always, a finished version of the project, including all necessary art
    assets, can be downloaded from [http://mng.bz/VBY5](http://mng.bz/VBY5), this
    book’s website. You can copy the images from there to use in your own project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：与以往一样，包括所有必要的艺术资产在内的项目完整版本可以从 [http://mng.bz/VBY5](http://mng.bz/VBY5)，本书的网站上下载。您可以从那里复制图片用于您自己的项目。
- en: Gather the required images and then create a new project in Unity. In the New
    Project window that comes up, you’ll notice project templates (shown in figure
    5.3) that let you switch between 2D and 3D mode. In previous chapters, we’ve worked
    with 3D graphics, and because that’s the default value, we haven’t been concerned
    with this setting. In this chapter, though, you’ll want to select the 2D template
    when creating a new project.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 收集所需的图像，然后在 Unity 中创建一个新项目。在出现的“新建项目”窗口中，您会注意到项目模板（如图 5.3 所示），它允许您在 2D 和 3D
    模式之间切换。在前几章中，我们处理了 3D 图形，因为那是默认值，所以我们没有关注这个设置。然而，在本章中，您在创建新项目时将想要选择 2D 模板。
- en: '![CH05_F03_Hocking3](../Images/CH05_F03_Hocking3.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F03_Hocking3](../Images/CH05_F03_Hocking3.png)'
- en: Figure 5.3 Create new projects in either 2D or 3D mode with these buttons.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 使用这些按钮以 2D 或 3D 模式创建新项目。
- en: With the new project for this chapter created and set for 2D, we can start putting
    our images into the scene.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在为本章创建的新项目并设置为 2D 后，我们可以开始将我们的图像放入场景中。
- en: 2D Editor mode and 2D Scene view
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 2D 编辑模式与 2D 场景视图
- en: The 2D/3D setting for new projects adjusts two settings within Unity’s editor,
    both of which you can adjust manually later if you wish. Those two settings are
    the 2D Editor mode and the 2D Scene view. The 2D Scene view controls how the scene
    is displayed within Unity; toggle the 2D button along the top of the Scene view.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 新项目的 2D/3D 设置调整了 Unity 编辑器内的两个设置，如果您愿意，以后可以手动调整这两个设置。这两个设置是 2D 编辑模式和 2D 场景视图。2D
    场景视图控制场景在 Unity 中的显示方式；切换场景视图顶部的 2D 按钮。
- en: '![CH05_UN01_Hocking3](../Images/CH05_UN01_Hocking3.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_UN01_Hocking3](../Images/CH05_UN01_Hocking3.png)'
- en: 2D Scene view toggle
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 2D 场景视图切换
- en: You set 2D Editor mode by opening the Edit menu and selecting Editor from the
    Project Settings drop-down list. Within those settings, you’ll see the Default
    Behavior Mode setting with selections for either 3D or 2D.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打开编辑菜单并从项目设置下拉列表中选择编辑来设置 2D 编辑模式。在这些设置中，您将看到默认行为模式设置，可以选择 3D 或 2D。
- en: '![CH05_UN02_Hocking3](../Images/CH05_UN02_Hocking3.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_UN02_Hocking3](../Images/CH05_UN02_Hocking3.png)'
- en: Default Behavior Mode setting within Edit > Project Settings > Editor
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 > 项目设置 > 编辑中的默认行为模式设置
- en: Setting the editor to 2D mode causes imported images to be set to Sprite. As
    you saw in chapter 4, images normally import as textures, but that’s easy to switch
    in the Inspector. Just select the asset to see its settings, and remember to click
    Apply after making any changes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将编辑器设置为2D模式会导致导入的图像被设置为精灵。正如你在第4章中看到的，图像通常导入为纹理，但在检查器中很容易切换。只需选择资产以查看其设置，并在做出任何更改后记得点击应用。
- en: 2D Editor mode also causes new scenes to lack the default 3D lighting setup;
    this lighting doesn’t harm 2D scenes, but it’s unnecessary. If you ever need to
    remove it manually, delete the directional light that comes with new scenes and
    turn off the skybox in the lighting window (click the tiny circle icon for a file
    picker and choose None from the list).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 2D编辑器模式还会导致新场景缺少默认的3D照明设置；这种照明对2D场景没有害处，但不是必需的。如果你需要手动删除它，请删除新场景附带的方向光，并在照明窗口中关闭天空盒（点击小圆圈图标用于文件选择器，并从列表中选择无）。
- en: 5.1.2 Displaying 2D images (aka sprites)
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 显示2D图像（又称精灵）
- en: Drag all the image files into the Project view to import them, ensuring that
    the images are imported as sprites and not textures. (This is automatic if the
    editor is set to 2D. Select an asset to see its import settings in the Inspector.)
    Now drag the table_top sprite (our background image) up from the Project view
    into the empty scene. As with mesh objects, in the Inspector there’s a Transform
    component for the sprite; type 0, 0, 5 to position the background image.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有图像文件拖入项目视图以导入它们，确保图像被导入为精灵而不是纹理。（如果编辑器设置为2D，这是自动的。选择一个资产以在检查器中查看其导入设置。）现在将table_top精灵（我们的背景图像）从项目视图拖到空场景中。与网格对象一样，在检查器中有一个用于精灵的变换组件；输入0,
    0, 5以定位背景图像。
- en: TIP Another import setting to take note of is Pixels Per Unit. Because Unity
    was previously a 3D engine that had 2D graphics grafted in, one unit in Unity
    isn’t necessarily one pixel in the image. You could set the Pixels Per Unit setting
    to 1:1, but I recommend leaving it at the default of 100:1 (because the physics
    engine doesn’t work properly at 1:1, and the default is better for compatibility
    with others’ code).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：另一个需要注意的导入设置是每单位像素。因为Unity之前是一个3D引擎，后来添加了2D图形，所以Unity中的一个单位不一定等于图像中的一个像素。你可以将每单位像素设置设置为1:1，但我建议将其保留为默认的100:1（因为1:1时物理引擎无法正常工作，默认设置更适合与其他代码的兼容性）。
- en: Creating packed sprite atlases
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 创建打包的精灵图集
- en: Although we’re going to use separate images in this project, you can have multiple
    sprites laid out in a single image. The image is usually called a *sprite sheet*
    when numerous frames of an animation are combined into one image, but the more
    general term for multiple images combined into one is an *atlas*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个项目中我们将使用单独的图像，但你可以在单个图像中排列多个精灵。当动画的多个帧组合成一个图像时，这个图像通常被称为*精灵表*，但将多个图像组合成一个的更通用术语是*图集*。
- en: Animated sprites are common in 2D games, and we’ll implement those in the next
    chapter. Multiple frames can be imported as multiple images, but games usually
    have all the frames of animation laid out in a sprite sheet. Basically, all the
    separate frames appear as a grid on one large image.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 动画精灵在2D游戏中很常见，我们将在下一章实现它们。多个帧可以作为多个图像导入，但游戏通常将所有动画帧排列在精灵表中。基本上，所有单独的帧都显示在一个大图像上的网格中。
- en: 'In addition to keeping frames of animation together, sprite atlases are also
    often used for still images. That’s because atlases can optimize the performance
    of sprites in two ways: by reducing the amount of wasted space in images by packing
    them tightly, and by reducing the draw calls of the video card (every new image
    that’s loaded causes a bit more work for the video card).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将动画帧保持在一起，精灵图集也常用于静态图像。这是因为图集可以通过两种方式优化精灵的性能：通过紧密打包以减少图像中的浪费空间，以及通过减少视频卡的绘制调用（每次加载新图像都会让视频卡做更多的工作）。
- en: Sprite atlases can be created using external tools like TexturePacker (see appendix
    B), and that approach will certainly work. But Unity includes sprite-packing functionality,
    which packs together multiple sprites automatically. To use this feature, enable
    Sprite Packer in Editor settings (choose Edit > Project Settings and switch the
    Mode to Always Enabled). Now you can create Sprite Atlas assets that contain individual
    sprites. For more information, look at Unity’s documentation at [http://mng.bz/ZxOZ.](http://mng.bz/ZxOZ)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用外部工具如TexturePacker（见附录B）创建精灵图集，这种方法肯定可行。但Unity包括精灵打包功能，可以自动打包多个精灵。要使用此功能，请在编辑器设置中启用Sprite
    Packer（选择编辑 > 项目设置并将模式切换到始终启用）。现在你可以创建包含单个精灵的Sprite Atlas资源。有关更多信息，请参阅Unity的文档[http://mng.bz/ZxOZ](http://mng.bz/ZxOZ)。
- en: The 0s for the X and Y positions are straightforward (this sprite will fill
    the entire screen, so you want it at the center), but that 5 for the Z position
    might seem odd. For 2D graphics, shouldn’t only X and Y matter? Well, X and Y
    are the only values that matter for positioning the object on the 2D screen, but
    the Z value still matters for stacking objects.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: X和Y位置上的0是直接的（这个精灵将填充整个屏幕，所以你希望它在中心），但Z位置上的5可能看起来有些奇怪。对于2D图形，难道不是只有X和Y才重要吗？嗯，X和Y是唯一影响对象在2D屏幕上定位的值，但Z值对于堆叠对象仍然很重要。
- en: Lower Z values are closer to the camera, so sprites with lower Z values are
    displayed on top of other sprites (refer to figure 5.4). Accordingly, the background
    sprite should have the highest Z value. You’ll set your background to a positive
    Z position, and then give everything else a 0 or negative Z position.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Z值较低的位置更靠近相机，因此Z值较低的精灵会显示在其他精灵的上方（参见图5.4）。因此，背景精灵应该具有最高的Z值。你将背景设置为正Z位置，然后给其他所有东西一个0或负Z位置。
- en: '![CH05_F04_Hocking3](../Images/CH05_F04_Hocking3.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F04_Hocking3](../Images/CH05_F04_Hocking3.png)'
- en: Figure 5.4 How sprites stack along the z-axis
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 精灵沿z轴堆叠
- en: Other sprites will be positioned with values with up to two decimal places because
    of the Pixels Per Unit setting mentioned earlier. A ratio of 100:1 means that
    100 pixels in the image are 1 unit in Unity; put another way, 1 pixel is 0.01
    units. But before you put any more sprites into the scene, let’s set up the camera
    for this game.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面提到的每单位像素设置，其他精灵将以最多两位小数的值定位。100:1的比率意味着图像中的100像素是Unity中的1个单位；换句话说，1像素是0.01个单位。但在你将更多精灵放入场景之前，让我们为这个游戏设置相机。
- en: 5.1.3 Switching the camera to 2D mode
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 将相机切换到2D模式
- en: Now let’s adjust settings on the main camera in the scene. You might think that
    because the Scene view is set to 2D, what you see in Unity is what you’ll see
    in the game. Somewhat unintuitively, though, that isn’t the case.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来调整场景中主相机的设置。你可能认为由于场景视图设置为2D，你在Unity中看到的内容就是你将在游戏中看到的内容。然而，有些不太直观的是，情况并非如此。
- en: WARNING Whether or not the Scene view is set to 2D has nothing to do with the
    camera view in the running game.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：场景视图是否设置为2D与运行游戏中的相机视图无关。
- en: It turns out that, regardless of whether the Scene view is set to 2D mode, the
    camera in the game is set independently. This can be handy in many situations
    so that you can toggle the Scene view back to 3D to work on certain effects within
    the scene. This disconnect does mean that what you see in Unity isn’t necessarily
    what you see in the game, and it can be easy for beginners to forget this.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，无论场景视图是否设置为2D模式，游戏中的相机都是独立设置的。这在许多情况下都很有用，这样你就可以切换场景视图回3D模式来在场景中处理某些效果。这种脱节确实意味着你在Unity中看到的内容不一定是你将在游戏中看到的内容，而且对于初学者来说很容易忘记这一点。
- en: The most important camera setting to adjust is Projection. The camera projection
    is probably already correct because you created the new project in 2D mode, but
    this is still important to know about and worth double-checking. Select the camera
    in Hierarchy to show its settings in the Inspector, and then look for the Projection
    setting (see figure 5.5). For 3D graphics, the setting should be Perspective,
    but for 2D graphics, the camera projection should be Orthographic.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 需要调整的最重要相机设置是投影。由于你是在2D模式下创建的新项目，所以相机投影可能已经是正确的，但了解这一点并再次检查仍然很重要。在层次结构中选择相机以在检查器中显示其设置，然后查找投影设置（见图5.5）。对于3D图形，设置应该是透视，但对于2D图形，相机投影应该是正交的。
- en: '![CH05_F05_Hocking3](../Images/CH05_F05_Hocking3.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F05_Hocking3](../Images/CH05_F05_Hocking3.png)'
- en: Figure 5.5 Camera settings to adjust for 2D graphics
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 调整2D图形的相机设置
- en: DEFINITION *Orthographic* is the term for a flat camera view that has no apparent
    perspective. This is the opposite of a Perspective camera view, in which closer
    objects appear larger and lines recede into the distance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：**正交投影**是指没有明显透视的平面摄像机视图。这与透视摄像机视图相反，在透视摄像机视图中，较近的物体看起来更大，线条会退入远方。
- en: Although the Projection mode is the most important camera setting for 2D graphics,
    we have a few other settings to adjust as well. Next, we’ll look at Size, which
    is under Projection. The camera’s orthographic size determines the size of the
    camera view from the center of the screen up to the top of the screen. In other
    words, set Size to half the pixel dimensions of the screen you want. If you later
    set the resolution of the deployed game to the same pixel dimensions, you’ll get
    pixel-perfect graphics.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然投影模式是2D图形最重要的摄像机设置，但我们还有其他一些设置需要调整。接下来，我们将查看位于投影下的尺寸。摄像机的正交尺寸决定了从屏幕中心到屏幕顶部的摄像机视图大小。换句话说，将尺寸设置为所需屏幕像素尺寸的一半。如果你后来将部署游戏的分辨率设置为相同的像素尺寸，你将获得像素完美的图形。
- en: DEFINITION *Pixel-perfect* means one pixel on the screen corresponds to one
    pixel in the image (otherwise, the video card will make the images subtly blurry
    while scaling up to fit the screen).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：**像素完美**意味着屏幕上的一个像素对应图像中的一个像素（否则，显卡在放大以适应屏幕时会使图像略微模糊）。
- en: Let’s say you want a pixel-perfect 1024 × 768 screen. That means the camera
    height should be 384 pixels. Divide that by 100 (because of the pixels-to-units
    scale) and you get 3.84 for the camera size. Again, that math is SCREEN_SIZE /
    2 / 100f (f as in float, rather than an int value). Given that the background
    image is 1024 × 768 (select the asset to check its dimensions), then clearly this
    value of 3.84 is what we want for our camera.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一个像素完美的1024 × 768屏幕。这意味着摄像机的高度应该是384像素。除以100（因为像素到单位的缩放比例），你得到3.84作为摄像机大小。同样，这个数学是SCREEN_SIZE
    / 2 / 100f（f代表浮点数，而不是整数值）。鉴于背景图像是1024 × 768（选择资产以检查其尺寸），那么显然这个3.84的值就是我们想要的摄像机值。
- en: The remaining adjustments to make in the Inspector are the camera’s background
    color and Z position. As mentioned previously for sprites, higher Z positions
    are further away into the scene. As such, the camera should have a pretty low
    Z position; set the position of the camera to 0, 0, -100. Next make sure the camera’s
    Clear Flag is set to Solid Color instead of Skybox; this setting determines the
    camera background. The camera’s background color should probably be black; the
    default color is blue, and that’ll look odd displayed along the sides if the screen
    is wider than the background image (which is likely). Click the color swatch next
    to Background and set the color picker to black.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器中需要进行的剩余调整是摄像机的背景颜色和Z位置。如前所述，对于精灵来说，较高的Z位置意味着更远离场景。因此，摄像机应该有一个相当低的Z位置；将摄像机的位置设置为0,
    0, -100。接下来，确保摄像机的清除标志设置为实色而不是天空盒；此设置确定摄像机背景。摄像机的背景颜色可能是黑色；默认颜色是蓝色，如果屏幕宽度大于背景图像（这很可能是情况），那么这种颜色看起来会很奇怪。点击背景旁边的颜色块，并将颜色选择器设置为黑色。
- en: Now save the scene as Scene and click Play. You’ll see the Game view filled
    with our tabletop sprite. As you saw, getting to this point wasn’t completely
    straightforward (again, that’s because Unity was a 3D game engine that has recently
    had 2D graphics grafted in). But the tabletop is completely bare, so our next
    step is to put a card on the table.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将场景保存为“场景”并点击播放。你会看到游戏视图充满了我们的桌面精灵。正如你所看到的，到达这个点并不完全直接（再次强调，这是因为Unity是一个最近才添加了2D图形的3D游戏引擎）。但是桌面是完全空的，所以我们的下一步是在桌子上放一张卡片。
- en: 5.2 Building a card object and making it react to clicks
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 构建卡片对象并使其对点击做出反应
- en: Now that the images are all imported and ready to use, let’s build the card
    objects that form the core of this game. In Memory, all the cards are initially
    face down, and they’re face up only temporarily, when you choose a pair of cards
    to turn over. To implement this functionality, you’re going to create objects
    that consist of multiple sprites stacked on top of one another. Then, you’ll write
    code that makes the cards reveal themselves when clicked with the mouse.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有图像都已导入并准备好使用，让我们构建构成游戏核心的卡片对象。在《记忆》游戏中，所有卡片最初都是面朝下的，只有在选择一对卡片翻转时才会临时面朝上。为了实现这一功能，你需要创建由多个堆叠在一起的精灵组成的对象。然后，你将编写代码，使得卡片在鼠标点击时显示出来。
- en: 5.2.1 Building the object out of sprites
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 使用精灵构建对象
- en: Drag one of the card images into the scene. Use one of the card fronts, because
    you’ll add a card back on top to hide the image. Technically, the position right
    now doesn’t matter, but eventually it will, so you may as well position the card
    at -3, 1, 0. Now drag the card_back sprite into the scene. Make this new sprite
    a child of the previous card sprite (remember, in the Hierarchy, drag the child
    object onto the parent object) and then set its position to 0, 0, -0.1 (Keep in
    mind that this position is relative to the parent, so this means, “Put it at the
    same X and Y but move it closer on Z.”)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将一张卡片图片拖入场景。使用一张卡片正面，因为你会在上边添加一张卡片背面来隐藏图片。技术上，现在的位置并不重要，但最终会很重要，所以你可以将卡片定位在-3,
    1, 0。现在将卡片背面精灵拖入场景。将这个新的精灵设置为之前卡片精灵的子对象（记住，在层次结构中，将子对象拖到父对象上），然后将其位置设置为0, 0, -0.1（请注意，这个位置是相对于父对象的，这意味着“在X和Y上保持相同，但在Z上更靠近。”）
- en: NOTE In this setup, the back of the card and the front of the card are separate
    objects. That makes the graphics simpler to set up, and revealing the “front”
    is as simple as turning off the “back.” However, since Unity is always 3D even
    when the scene looks 2D, you could make a 3D card that flips over. That would
    be more complex to set up but may have advantages for certain graphical effects.
    There’s no one right way to implement things, just different pros and cons to
    balance.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这个设置中，卡片背面和正面是单独的对象。这使得图形设置更简单，显示“正面”就像关闭“背面”一样简单。然而，由于Unity即使在看起来是2D的场景中也总是3D的，你可以制作一个可以翻转的3D卡片。这会使得设置更复杂，但可能对某些图形效果有优势。没有一种正确的方法来实现这些事情，只是不同的利弊需要权衡。
- en: TIP Instead of the Move, Rotate, and Scale tools that we used in 3D, in 2D mode
    we use a single manipulation tool called the *Rect tool*. In 2D mode, this tool
    is selected automatically, or you can click the fifth control button in the top-left
    corner of Unity. With this tool active, click and drag objects to do all three
    operations (move/rotate/scale) in two dimensions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：与我们在3D中使用的移动、旋转和缩放工具不同，在2D模式下，我们使用一个称为*矩形工具*的单个操作工具。在2D模式下，此工具会自动选择，或者你可以点击Unity左上角的控制按钮中的第五个按钮。使用此工具时，点击并拖动对象可以在二维空间内执行所有三个操作（移动/旋转/缩放）。
- en: With the card back in place, as depicted in figure 5.6, the graphics are ready
    for a reactive card that can be revealed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如图5.6所示，卡片背面就位后，图形就准备好了一个可以揭示的响应式卡片。
- en: '![CH05_F06_Hocking3](../Images/CH05_F06_Hocking3.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F06_Hocking3](../Images/CH05_F06_Hocking3.png)'
- en: Figure 5.6 Hierarchy linking and position for the card back sprite
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 卡片背面精灵的层次链接和位置
- en: 5.2.2 Mouse input code
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 鼠标输入代码
- en: In order to respond when the player clicks them, the card sprites need to have
    a collider component. New sprites don’t have a collider by default, so they can’t
    be clicked. You’re going to attach a collider to the root card object, but not
    to the card back, so that only the card front and not the card back will receive
    mouse clicks.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应玩家点击，卡片精灵需要有一个碰撞器组件。新的精灵默认没有碰撞器，所以不能被点击。你将把一个碰撞器附加到根卡片对象上，而不是卡片背面，这样只有卡片正面而不是卡片背面会接收到鼠标点击。
- en: To do this, select the root card object in Hierarchy (don’t click the card in
    the scene, because the card back is on top and you’ll select that part instead).
    Then click the Add Component button in the Inspector. Select Physics 2D (not Physics,
    because that system is for 3D physics and this is a 2D game) and then choose a
    box collider.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请在层次结构中选择根卡片对象（不要在场景中点击卡片，因为卡片背面在最上面，你会选择那个部分）。然后点击检查器中的添加组件按钮。选择物理2D（不是物理，因为该系统是用于3D物理的，这是一个2D游戏），然后选择一个盒子碰撞器。
- en: Besides a collider, the card needs a script in order to be reactive to the player
    clicking it, so let’s write some code. Create a new script called MemoryCard and
    attach it to the root card object (again, not the card back). This listing shows
    the code that makes the card emit debug messages when clicked.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了碰撞器之外，卡片还需要一个脚本来对玩家的点击做出反应，所以让我们编写一些代码。创建一个新的脚本名为MemoryCard，并将其附加到根卡片对象上（再次，不是卡片背面）。下面的列表显示了当点击时使卡片发出调试消息的代码。
- en: Listing 5.1 Emitting debug messages when clicked
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 点击时发出调试消息
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ The function is called when the object is clicked.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当对象被点击时，会调用该函数。
- en: ❷ Just emit a test message to the console for now.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 目前只需向控制台发出一个测试消息。
- en: 'TIP If you’re not in this habit yet, organizing your assets into separate folders
    is probably a good idea. Create folders for scripts and drag files within the
    Project view. Be careful to avoid the special folder names Unity responds to:
    Resources, Plugins, Editor, and Gizmos. Later in the book, we’ll go over what
    some of these special folders do, but for now avoid naming any folders with those
    words.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你还没有这个习惯，将你的资产组织到单独的文件夹中可能是个好主意。为脚本创建文件夹，并在项目视图中拖动文件。请小心避免Unity响应的特殊文件夹名称：Resources、Plugins、Editor和Gizmos。在本书的后面部分，我们将介绍这些特殊文件夹的一些功能，但现在避免使用这些单词命名任何文件夹。
- en: Nice—we can click the card now! Just like Update(), OnMouseDown() is another
    function provided by MonoBehaviour, this time responding when the object is clicked.
    Play the game and watch messages appear in the console. But this only prints to
    the console for testing; we want the card to be *revealed*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 很好——现在我们可以点击卡片了！就像Update()一样，OnMouseDown()是MonoBehaviour提供的另一个函数，这次是在对象被点击时响应。玩玩游戏，并观察控制台中的消息。但这只是为了测试而打印到控制台；我们希望卡片被*揭示*。
- en: 5.2.3 Revealing the card on a click
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 点击时揭示卡片
- en: Rewrite the code to match this listing (the code won’t run quite yet, but don’t
    worry).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写代码以匹配此列表（代码现在还不能运行，但不用担心）。
- en: Listing 5.2 Script that hides the back when the card is clicked
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 当点击卡片时隐藏背面的脚本
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Variable that appears in the Inspector
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在检查器中出现的变量
- en: ❷ Run deactivate code only if the object is currently active/visible.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 仅当对象当前处于活动/可见状态时运行禁用代码。
- en: ❸ Set the object to inactive/invisible.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将对象设置为非活动/不可见。
- en: 'We’ve made two key additions to the script: a reference to an object in the
    scene, and the SetActive() method that deactivates that object. The first part,
    the reference to an object in the scene, is similar to what we’ve done in previous
    chapters: mark the variable as serialized and then drag the object from Hierarchy
    over to the variable in the Inspector. With the object reference set, the code
    will now affect the object in the scene.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在脚本中添加了两个关键功能：对场景中对象的引用，以及SetActive()方法，该方法可以禁用该对象。第一部分，对场景中对象的引用，与我们之前章节中做的是类似的：将变量标记为序列化，然后将对象从层次结构拖动到检查器中的变量上。设置好对象引用后，代码现在将影响场景中的对象。
- en: The second key addition to the code is the SetActive command. This command will
    deactivate any GameObject, making that object invisible. If we now drag card_back
    in the scene to this script’s variable in the Inspector, the card back disappears
    when you click the card during a game. Hiding the card back will reveal the card
    front; we’ve accomplished yet another important task for the Memory game! But
    this is still only one card, so now let’s create a bunch of cards.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的第二个关键添加是SetActive命令。此命令将使任何GameObject失效，使其不可见。如果我们现在将场景中的card_back拖动到检查器中此脚本的变量，那么在游戏中点击卡片时，卡片背面将消失；隐藏卡片背面将揭示卡片正面；我们为记忆游戏完成了另一个重要的任务！但仍然只有一张卡片，所以现在让我们创建一堆卡片。
- en: TIP Forgetting to drag over the object when a script has a serialized variable
    is a fairly common mistake, so it’s useful to recognize that error message in
    the Console tab. Code that uses a serialized variable that hasn’t been set will
    throw a null reference error. Actually, a null reference error gets thrown *any*
    time the code attempts to use a variable not set yet, whether or not it’s a serialized
    variable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：当脚本有一个序列化变量时忘记拖动对象，这是一个相当常见的错误，因此识别控制台标签中的错误信息是有用的。使用尚未设置的序列化变量的代码将抛出空引用错误。实际上，每当代码尝试使用尚未设置的变量时，无论是否为序列化变量，都会抛出空引用错误。
- en: 5.3 Displaying the various card images
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 显示各种卡片图像
- en: We’ve programmed a card object that initially shows the card back but reveals
    itself when clicked. That was a single card, but the game needs a whole grid of
    cards, with different images on most cards. We’ll implement the grid of cards
    by using a couple of concepts seen in previous chapters, along with some concepts
    you haven’t seen before. Chapter 3 introduced the concepts of using an invisible
    SceneController component and instantiating clones of an object. The SceneController
    will apply different images to different cards this time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了一个卡片对象，它最初显示卡片背面，但在点击时揭示自己。那是一张单独的卡片，但游戏需要一个完整的卡片网格，大多数卡片上有不同的图像。我们将通过使用之前章节中看到的一些概念以及一些你之前没有见过的概念来实现卡片网格。第三章介绍了使用不可见的SceneController组件和实例化对象副本的概念。这次SceneController将为不同的卡片应用不同的图像。
- en: 5.3.1 Loading images programmatically
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 以编程方式加载图像
- en: The game we’re creating has four card images. All eight cards on the table (two
    for each symbol) will be created by cloning the same original, so all cards will
    initially have the same symbol. We’ll have to change the image on the card in
    the script, loading different images programmatically.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建的游戏有四张卡牌图像。桌上的所有八张卡牌（每种符号两张）将通过克隆相同的原始图像来创建，所以所有卡牌最初都将有相同的符号。我们将在脚本中更改卡牌上的图像，通过程序加载不同的图像。
- en: To examine how images can be assigned programmatically, let’s write simple test
    code (which will be replaced later) to demonstrate the technique. First, add this
    code to the MemoryCard script.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查图像如何被程序化分配，让我们编写简单的测试代码（稍后将被替换）来演示这个技术。首先，将此代码添加到MemoryCard脚本中。
- en: Listing 5.3 Test code to demonstrate changing the sprite image
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 用于演示更改精灵图像的测试代码
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Reference to the Sprite asset that will be loaded
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 引用将要加载的精灵资源
- en: ❷ Set the sprite for this SpriteRenderer component.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置这个SpriteRenderer组件的精灵。
- en: After you save this script, the new image variable will appear in the Inspector
    because it has been set as serialized. Drag a sprite up from the Project view
    (pick one of the card images, and not the same as the image already in the scene)
    and drop it on the Image slot. Now run the scene and you’ll see the new image
    on the card.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此脚本后，新的图像变量将出现在检查器中，因为它已被设置为序列化。从项目视图中拖动一个精灵（选择一张卡牌图像，而不是场景中已有的图像）到图像槽中。现在运行场景，你将看到卡牌上的新图像。
- en: 'The key to understanding this code is to know about the SpriteRenderer component.
    You’ll notice in figure 5.7 that the card back object has just two components:
    the standard Transform component on all objects in the scene, and a new component
    called SpriteRenderer. This component makes the GameObject into a sprite object
    and determines which sprite asset will be displayed. Note that the first property
    in the component is called sprite and links to one of the sprites in the Project
    view; the property can be manipulated in code, and that’s precisely what this
    script does.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这段代码的关键是了解SpriteRenderer组件。你会在图5.7中注意到，卡牌背面对象只有两个组件：场景中所有对象的标准Transform组件和一个新组件，称为SpriteRenderer。这个组件使GameObject成为一个精灵对象，并确定将显示哪个精灵资源。注意，组件中的第一个属性被称为sprite，并链接到项目视图中的一个精灵；该属性可以在代码中操作，这正是这个脚本所做的。
- en: '![CH05_F07_Hocking3](../Images/CH05_F07_Hocking3.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F07_Hocking3](../Images/CH05_F07_Hocking3.png)'
- en: Figure 5.7 A sprite object in the scene has the SpriteRenderer component attached
    to it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 场景中的一个精灵对象附带了SpriteRenderer组件。
- en: As it did with CharacterController and custom scripts in previous chapters,
    the GetComponent() method returns other components on the same object, so we use
    it to reference the SpriteRenderer object. The sprite property of SpriteRenderer
    can be set to any sprite asset, so this code sets that property to the Sprite
    variable declared at the top (which we filled with a sprite asset in the editor).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在前面章节中处理CharacterController和自定义脚本一样，GetComponent()方法返回同一对象上的其他组件，因此我们用它来引用SpriteRenderer对象。SpriteRenderer的精灵属性可以被设置为任何精灵资源，所以这段代码将这个属性设置为顶部声明的Sprite变量（我们在编辑器中用精灵资源填充了它）。
- en: Well, that wasn’t too hard! But it’s only a single image. We have four images
    to use, so now delete the new code from listing 5.3 (it was only a demonstration
    of how the technique works) to prepare for the next section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这并不太难！但这只是一个单独的图像。我们有四张图像要使用，所以现在删除列表5.3中的新代码（它只是演示了技术的工作原理），为下一部分做准备。
- en: 5.3.2 Setting the image from an invisible SceneController
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 从不可见的SceneController设置图像
- en: Recall that, in chapter 3, we created an invisible object in the scene to control
    spawning objects. We’re going to take that approach here as well, using an invisible
    object to control more abstract features that aren’t tied to any specific object
    in the scene.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在第三章中，我们在场景中创建了一个不可见对象来控制对象的生成。在这里，我们也将采取同样的方法，使用一个不可见对象来控制与场景中任何特定对象无关的更抽象的特征。
- en: First, create an empty GameObject (remember, choose GameObject > Create Empty).
    Then create a new script, SceneController, in the Project view, and drag this
    script asset onto the controller GameObject. Before writing code in the new script,
    add the contents of the next listing to the MemoryCard script instead of what
    you saw in listing 5.3.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个空的游戏对象（记住，选择GameObject > 创建空）。然后在项目视图中创建一个新的脚本，命名为SceneController，并将此脚本资产拖到控制器游戏对象上。在编写新脚本中的代码之前，将下一列表的内容添加到MemoryCard脚本中，而不是列表5.3中看到的内容。
- en: Listing 5.4 New public methods in MemoryCard
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4 MemoryCard中的新公共方法
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Added getter function (an idiom common in languages like C# and Java)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加了获取函数（在C#和Java等语言中常见的习语）
- en: ❷ Public method that other scripts can use to pass new sprites to this object
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 其他脚本可以使用以向此对象传递新精灵的公共方法
- en: ❸ SpriteRenderer code line just as in the deleted code demonstration
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 与删除的代码演示中相同的SpriteRenderer代码行
- en: The primary change from previous listings is that we’re now setting the sprite
    image in SetCard() instead of Start(). Because that’s a public method that takes
    a sprite as a parameter, you can call this function from other scripts and set
    the image on this object. Note that SetCard() also takes an ID number as a parameter,
    and the code stores that number. Although we don’t need the ID quite yet, soon
    we’ll write code that compares cards for matches, and that comparison will rely
    on the IDs of the cards.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的列表相比，主要的变化是我们现在在SetCard()中设置精灵图像，而不是在Start()中设置。因为这是一个接受精灵作为参数的公共方法，你可以从其他脚本中调用此函数并设置此对象上的图像。请注意，SetCard()还接受一个ID号作为参数，并且代码会存储该数字。尽管我们目前不需要ID，但很快我们将编写比较卡片以进行匹配的代码，而这个比较将依赖于卡片的ID。
- en: NOTE Depending on what programming languages you’ve used in the past, you may
    not be familiar with the concept of *getters* and *setters*. Long story short,
    they are functions that run when you attempt to access the property associated
    with them (for example, retrieving the value of card.Id). There are multiple reasons
    to use getters and setters, but in this case the Id property is read-only because
    we have a function to only get the value and not set it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：根据你过去使用的编程语言，你可能不熟悉*获取器*和*设置器*的概念。简而言之，它们是在你尝试访问与它们关联的属性时运行的函数（例如，检索card.Id的值）。使用获取器和设置器有多种原因，但在此情况下，Id属性是只读的，因为我们有一个只获取值而不设置的函数。
- en: Finally, note that the code has a variable for the controller. Even as SceneController
    starts cloning card objects to fill the scene, the card objects also need a reference
    to the controller to call its public methods. As usual, when the code references
    objects in the scene, drag the controller object in Unity’s editor to the serialized
    variable slot in the Inspector. Do this once for this single card, and all of
    the copies to come later will have the reference as well. With that additional
    code now in MemoryCard, write this code in SceneController.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意代码中有一个用于控制器的变量。即使当SceneController开始克隆卡片对象以填充场景时，卡片对象也需要一个指向控制器的引用来调用其公共方法。通常情况下，当代码在场景中引用对象时，请将Unity编辑器中的控制器对象拖动到检查器中的序列化变量槽中。对于这个单独的卡片，只需这样做一次，之后的所有副本都将具有该引用。现在，在MemoryCard中添加了额外的代码，请在SceneController中编写此代码。
- en: Listing 5.5 First pass at SceneController for the Memory game
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5 Memory游戏的SceneController第一次尝试
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Reference for the card in the scene
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 场景中卡片的引用
- en: ❷ An array for references to the sprite assets
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于引用精灵资源的数组
- en: ❸ Call the public method we added to MemoryCard.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用我们添加到MemoryCard中的公共方法。
- en: For now, this is a short snippet to demonstrate the concept of manipulating
    cards from SceneController. Most of this should already be familiar to you (for
    example, in Unity’s editor, drag the card object to the serialized variable slot
    in the Inspector), but the array of images is new. As shown in figure 5.8, in
    the Inspector you can set the number of elements. Type in 4 for the array length
    and then drag the sprites for card images onto the array slots. Now these sprites
    can be accessed in the array, like any other object reference.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这是一个简短的代码片段，用于演示从SceneController操作卡片的原理。其中大部分应该你已经很熟悉（例如，在Unity的编辑器中，将卡片对象拖动到检查器中的序列化变量槽中），但图像数组是新的。如图5.8所示，在检查器中你可以设置元素的数量。将数组长度输入为4，然后将卡片图像的精灵拖放到数组槽中。现在这些精灵可以像任何其他对象引用一样在数组中访问。
- en: '![CH05_F08_Hocking3](../Images/CH05_F08_Hocking3.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F08_Hocking3](../Images/CH05_F08_Hocking3.png)'
- en: Figure 5.8 The filled-in array of sprites
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 填充好的精灵数组
- en: Incidentally, we used the Random.Range() method in chapter 3, so hopefully you
    recall that. The exact boundary values didn’t matter there, but this time it’s
    important to note that the minimum value is inclusive and may be returned, whereas
    the return value is always below the maximum.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，我们在第3章中使用了Random.Range()方法，所以希望你能回忆起来。那里确切的边界值并不重要，但这次需要注意的是，最小值是包含的，可能被返回，而返回值总是低于最大值。
- en: Click Play to run this new code. You’ll see different images being applied to
    the revealed card each time you run the scene. The next step is to create a whole
    grid of cards instead of only one.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放以运行此新代码。每次运行场景时，你都会看到不同的图像被应用到露出的卡片上。下一步是创建一个完整的卡片网格，而不仅仅是单张卡片。
- en: 5.3.3 Instantiating a grid of cards
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 实例化卡片网格
- en: SceneController already has a reference to the card object, so now you’ll use
    the Instantiate() method (see the next listing) to clone the object numerous times,
    as we did when spawning objects in chapter 3.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: SceneController已经引用了卡片对象，因此现在你将使用Instantiate()方法（参见下一列表）多次克隆对象，就像我们在第3章中生成对象时做的那样。
- en: Listing 5.6 Cloning the card eight times and positioning in a grid
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.6 克隆卡片八次并在网格中定位
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Values for how many grid spaces to make and how far apart to place them
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 确定网格空间数量和放置距离的值
- en: ❷ Position of the first card; all other cards will be offset from here.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第一张卡片的定位；所有其他卡片都将从这个位置偏移。
- en: ❸ Nested loops to define both columns and rows of the grid
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用嵌套循环定义网格的列和行
- en: ❹ Container reference for either the original card or the copies
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 原始卡片或副本的容器引用
- en: ❺ For 2D graphics, you need to offset only X and Y; keep Z the same.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对于2D图形，只需要偏移X和Y；保持Z不变。
- en: Although this script is much longer than the previous listing, there’s not a
    lot to explain because most of the additions are straightforward variable declarations
    and math. The oddest bit of this code is probably the if/else statement that begins
    if (i == 0 && j == 0). That conditional either uses the original card object for
    the first grid slot or clones the card object for all other grid slots. Because
    the original card already exists in the scene, if you copied the card at every
    iteration of the loop, you’d end up with one too many cards in the scene. The
    cards are then positioned by offsetting them according to the number of iterations
    through the loop.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个脚本比之前的列表长得多，但解释起来并不多，因为大部分新增的都是直接的变量声明和数学运算。这段代码中最奇怪的部分可能是以if (i == 0 &&
    j == 0)开始的if/else语句。这个条件要么使用原始卡片对象作为第一个网格槽，要么克隆卡片对象用于所有其他网格槽。因为原始卡片已经在场景中存在，如果你在循环的每次迭代中都复制卡片，你会在场景中多出一张卡片。然后，根据循环的迭代次数，通过偏移来定位卡片。
- en: TIP Just as when moving 3D objects, 2D objects could have transform.position
    incremented repeatedly in Update() to achieve smooth movement over time. But as
    you saw when moving the first-person player, collision detection isn’t applied
    when adjusting transform.position directly. For that reason, the next chapter’s
    code will move sprites by adjusting rigidbody2D.velocity.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：就像移动3D对象一样，2D对象可以通过在Update()中重复增加transform.position来实现平滑的移动。但是，正如你在移动第一人称玩家时看到的，当直接调整transform.position时，不会应用碰撞检测。因此，下一章的代码将通过调整rigidbody2D.velocity来移动精灵。
- en: Run the code now, and a grid of eight cards will be created (as depicted in
    figure 5.9). The last step in preparing the grid of cards is to organize them
    into pairs instead of keeping them random.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行代码，将创建一个包含八张卡片的网格（如图5.9所示）。准备卡片网格的最后一个步骤是将它们组织成对，而不是保持随机。
- en: '![CH05_F09_Hocking3](../Images/CH05_F09_Hocking3.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F09_Hocking3](../Images/CH05_F09_Hocking3.png)'
- en: Figure 5.9 The grid of eight cards, which are revealed when you click them
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 当你点击它们时显示的八张卡片网格
- en: 5.3.4 Shuffling the cards
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.4 洗牌卡片
- en: Instead of making every card random, we’ll define an array of all the card IDs
    (numbers 0 through 3 twice, for a pair of each card) and then shuffle that array.
    We’ll then use this array of card IDs when setting cards, rather than making each
    one random.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会让每一张卡片都是随机的，而是定义一个包含所有卡片ID（数字0到3各两次，每张卡片一对）的数组，然后对这个数组进行洗牌。在设置卡片时，我们将使用这个卡片ID数组，而不是让每个卡片都是随机的。
- en: Listing 5.7 Placing cards from a shuffled list
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.7 从洗牌列表放置卡片
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Much of this listing is context to show where the additions go.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这部分列表主要是为了显示新增内容的位置。
- en: ❷ Declare an integer array with a pair of IDs for all four card sprites.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 声明一个整数数组，包含所有四个卡片精灵的ID对。
- en: ❸ Call a function that will shuffle the elements of the array.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用一个函数来洗牌数组的元素。
- en: ❹ Retrieve IDs from the shuffled list instead of random numbers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从洗牌后的列表中检索ID，而不是随机数。
- en: ❺ An implementation of the Knuth shuffle algorithm
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ Knuth洗牌算法的实现
- en: Now, when you click Play, the grid of cards will be a shuffled assortment that
    reveals exactly two of each card image. The array of cards was run through the
    *Knuth* (also known as *Fisher-Yates*) shuffle algorithm, a simple yet effective
    way of shuffling the elements of an array. This algorithm loops through the array
    and swaps every element of the array with another randomly chosen array position.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你点击“播放”时，卡片网格将是一个随机排列的混合，恰好揭示每种卡片的图像各两张。卡片数组通过 *Knuth*（也称为 *Fisher-Yates*）洗牌算法进行处理，这是一种简单而有效的洗牌数组元素的方法。此算法遍历数组，并将数组的每个元素与另一个随机选择的数组位置交换。
- en: You can click all the cards to reveal them, but the game of Memory is supposed
    to proceed in pairs. We need a bit more code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击所有牌来揭示它们，但记忆游戏应该是成对进行的。我们需要更多的代码。
- en: 5.4 Making and scoring matches
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 制作和计分匹配
- en: The last step in making a fully functional Memory game is checking for matches.
    Although we now have a grid of cards that are revealed when clicked, the various
    cards don’t affect each other in any way. In the game of Memory, every time a
    pair of cards is revealed, we should check to see if the revealed cards match.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一个完全功能的记忆游戏的最后一步是检查匹配。尽管我们现在有一个在点击时揭示的卡片网格，但各种卡片在没有任何方式影响彼此。在记忆游戏中，每次揭示一对牌时，我们都应该检查揭示的牌是否匹配。
- en: This abstract logic—checking for matches and responding appropriately—requires
    that cards notify SceneController when they’ve been clicked. That requires the
    additions to SceneController shown in the next listing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象逻辑——检查匹配并相应地做出反应——要求牌在点击时通知 SceneController。这需要 SceneController 中显示的添加。
- en: Listing 5.8 SceneController, which must keep track of revealed cards
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 SceneController，必须跟踪已揭示的牌
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Getter function that returns false if a second card is already revealed
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回 false 的 getter 函数，如果已揭示第二张牌
- en: The CardRevealed() method will be filled in momentarily; we need the empty scaffolding
    for now to refer to in MemoryCard without any compiler errors. Note that we have
    a read-only getter again, this time used to determine whether another card can
    be revealed. The player can reveal another card only when two cards aren’t already
    revealed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: The CardRevealed() 方法将稍后填充；我们现在需要空的框架，以便在 MemoryCard 中引用而不会出现编译错误。注意，我们再次有一个只读的
    getter，这次用于确定是否可以揭示另一张牌。玩家只有在两张牌尚未揭示的情况下才能揭示另一张牌。
- en: We also need to modify MemoryCard to call the (currently empty) method in order
    to inform SceneController when a card is clicked. Modify the code in MemoryCard
    according to this listing.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改 MemoryCard 以调用（目前为空的）方法，以便在点击牌时通知 SceneController。根据此列表修改 MemoryCard
    中的代码。
- en: Listing 5.9 MemoryCard modifications for revealing cards
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 揭示牌的 MemoryCard 修改
- en: '[PRE8]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Check the controller’s canReveal property to make sure only two cards are
    revealed at a time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查控制器的 canReveal 属性，以确保一次只揭示两张牌。
- en: ❷ Notify the controller when this card is revealed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当这张牌被揭示时通知控制器。
- en: ❸ A public method so that SceneController can hide the card again (by turning
    card_back back on)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个公共方法，以便 SceneController 可以再次隐藏卡片（通过将 card_back 重新打开）
- en: If you were to put a debug statement inside CardRevealed() to test the communication
    between objects, you’d see the test message appear whenever you click a card.
    Let’s first handle one revealed pair.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 CardRevealed() 中放入一个调试语句来测试对象之间的通信，你会在点击卡片时看到测试消息出现。让我们首先处理一个已揭示的对。
- en: 5.4.1 Storing and comparing revealed cards
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 存储和比较已揭示的牌
- en: The card object was passed into CardRevealed(), so let’s start keeping track
    of the revealed cards.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片对象被传递到 CardRevealed() 中，所以让我们开始跟踪已揭示的卡片。
- en: Listing 5.10 Keeping track of revealed cards in SceneController
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.10 在 SceneController 中跟踪已揭示的牌
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Store card objects in one of the two card variables, depending on whether
    the first variable is already occupied.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 根据第一个变量是否已被占用，将牌对象存储在两个牌变量之一中。
- en: ❷ Compare the IDs of the two revealed cards.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 比较两张已揭示的牌的 ID。
- en: The listing stores the revealed cards in one of the two card variables, depending
    on whether the first variable is already occupied. If the first variable is empty,
    fill it; if it’s already occupied, fill the second variable and check the card
    IDs for a match. The Debug statement prints either true or false in the console.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表将揭示的牌存储在两个牌变量之一中，具体取决于第一个变量是否已被占用。如果第一个变量为空，则填充它；如果它已被占用，则填充第二个变量并检查牌 ID 是否匹配。调试语句在控制台打印出
    true 或 false。
- en: At the moment, the code doesn’t respond to matches—it only checks for them.
    Now let’s program the response.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，代码不会对匹配做出响应——它只会检查它们。现在让我们编写响应程序。
- en: 5.4.2 Hiding mismatched cards
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 隐藏不匹配的牌
- en: We’ll use coroutines again because the reaction to mismatched cards should pause
    to allow the player to see the cards. Refer to chapter 3 for a full explanation
    of coroutines; long story short, using a coroutine will allow us to pause before
    checking for a match. This listing shows more code for you to add to SceneController.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用协程，因为对不匹配牌的反应应该暂停，以便玩家可以看到牌。请参阅第3章以获取协程的完整解释；简而言之，使用协程将允许我们在检查匹配之前暂停。此列表显示了更多要添加到SceneController中的代码。
- en: Listing 5.11 SceneController scores a match or hides missed matches
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.11 SceneController得分或隐藏未匹配的匹配
- en: '[PRE10]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Add to the list near the top of SceneController
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在SceneController顶部附近添加到列表中
- en: ❷ The only changed line in this function, which calls the coroutine when both
    cards are revealed
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在此函数中，唯一更改的行是当两张牌都显示时调用协程
- en: ❸ Increment the score if the revealed cards have matching IDs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果显示的牌具有匹配的ID，则增加分数。
- en: ❹ Construct the message by using string interpolation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用字符串插值构造消息。
- en: ❺ Unreveal the cards if they do not match.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果牌不匹配，则不显示牌。
- en: ❻ Clear out the variables whether or not a match was made.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 无论是否匹配，都要清除变量。
- en: First, add a score value to track. Then, launch a coroutine to CheckMatch()
    when a second card is revealed. That coroutine has two code paths, depending on
    whether the cards match. If they match, the coroutine doesn’t pause; the yield
    command gets skipped over. If the cards don’t match, the coroutine pauses for
    half a second before calling Unreveal() on both cards, hiding them again. Finally,
    whether or not a match was made, the variables for storing cards are both nulled
    out, paving the way for revealing more cards.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加一个分数值来跟踪。然后，当第二张牌显示时，启动一个协程来检查匹配。这个协程有两个代码路径，取决于牌是否匹配。如果匹配，协程不会暂停；跳过yield命令。如果不匹配，协程会在调用Unreveal()并再次隐藏两张牌之前暂停半秒钟。最后，无论是否匹配，存储牌的变量都会被置为null，为揭示更多牌铺平道路。
- en: When you play the game, mismatched cards will display briefly before hiding
    again. Debug messages appear when you score matches, but we want the score displayed
    as a label on the screen.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当你玩游戏时，不匹配的牌会在隐藏之前短暂显示。当你得分匹配时，会显示调试信息，但我们希望分数以屏幕上的标签形式显示。
- en: 5.4.3 Text display for the score
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.3 分数文本显示
- en: Displaying information to the player is half of the reason for a UI in a game
    (the other half is receiving input from the player. UI buttons are discussed in
    the next section).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，向玩家展示信息是UI（用户界面）存在的一半原因（另一半是接收玩家的输入。UI按钮将在下一节讨论）。
- en: DEFINITION *UI* stands for *user interface*. Another closely related term is
    *GUI*, or *graphical user interface*, which refers to the visual part of the interface,
    such as text and buttons, and which is what a lot of people mean when they say
    UI.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *UI* 代表 *用户界面*。另一个与之密切相关的术语是 *GUI*，或 *图形用户界面*，它指的是界面的视觉部分，如文本和按钮，这也是很多人在说UI时所指的。
- en: Unity has multiple ways to create text displays, but using the TextMeshPro package
    is the best approach. This advanced text system was developed externally and later
    acquired by Unity.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Unity有多种创建文本显示的方法，但使用TextMeshPro包是最佳方法。这个高级文本系统是由外部开发的，后来被Unity收购。
- en: TextMeshPro may already be installed (when creating a new project, Unity installs
    several commonly used packages), but if not, then you must install it in Package
    Manager. From the menu, choose Window > Package Manager to open that window and
    scroll down to TextMeshPro in the list on the left, as shown in figure 5.10\.
    Select that package and then click the Install button.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: TextMeshPro可能已经安装（在创建新项目时，Unity会安装几个常用包），如果没有，则必须在包管理器中安装它。从菜单中选择Window > Package
    Manager打开该窗口，然后滚动到左侧列表中的TextMeshPro，如图5.10所示。选择该包，然后点击安装按钮。
- en: '![CH05_F10_Hocking3](../Images/CH05_F10_Hocking3.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F10_Hocking3](../Images/CH05_F10_Hocking3.png)'
- en: Figure 5.10 Installing TextMeshPro via Package Manager
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 通过包管理器安装TextMeshPro
- en: With that package installed, you can create a TextMeshPro object in the scene
    by going to the GameObject menu and choosing 3D Object > Text - TextMeshPro. Since
    this will be the first time TextMeshPro is used in this project, the TMP Importer
    window will automatically appear. Click the Import TMP Essentials button, and
    after the required resources finish downloading, the text object will appear in
    the scene.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了该包后，您可以通过访问 GameObject 菜单并选择 3D Object > Text - TextMeshPro 在场景中创建一个 TextMeshPro
    对象。由于这是 TextMeshPro 在本项目中首次使用，TMP Importer 窗口将自动出现。点击导入 TMP Essentials 按钮，在所需资源下载完成后，文本对象将出现在场景中。
- en: NOTE 3D text might sound incompatible with a 2D game, but don’t forget that
    this is technically a 3D scene that looks flat because it’s being seen through
    an orthographic camera. That means we can put 3D objects into the 2D game if we
    want—they’re displayed in a flat perspective.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 3D 文本可能听起来与 2D 游戏不兼容，但别忘了，这实际上是一个看起来平面的 3D 场景，因为它是通过正交相机看到的。这意味着如果我们想的话，我们可以将
    3D 对象放入 2D 游戏中——它们将以平面视角显示。
- en: WARNING TextMeshPro is also listed under GameObject > UI. Later chapters cover
    Unity’s UI system, and you’ll use that other GameObject instead in those chapters.
    Don’t get the two versions confused; while both are TextMeshPro objects, we are
    not using Unity’s advanced UI system in this chapter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 TextMeshPro 也列在 GameObject > UI 下。后面的章节将介绍 Unity 的 UI 系统，您将在那些章节中使用那个其他 GameObject。不要混淆这两个版本；虽然两者都是
    TextMeshPro 对象，但我们在这个章节中并没有使用 Unity 的高级 UI 系统。
- en: Select the new text object to see its settings in the Inspector. Position this
    object at -2.3, 3.1, -10; that’s 230 pixels to the left and 310 pixels up, putting
    it in the top-left corner and nearer to the camera so that it’ll appear on top
    of other game objects. Also decrease Width to 5 and Height to 1 since the new
    text starts out huge.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 选择新的文本对象以查看其设置在检查器中。将此对象定位在 -2.3, 3.1, -10；即向左 230 像素和向上 310 像素，将其放置在左上角并靠近相机，以便它能够覆盖其他游戏对象。此外，由于新文本一开始很大，因此将宽度减小到
    5 和高度减小到 1。
- en: Scroll down to the TextMeshPro settings. We could customize the text in tons
    of ways but are going to leave most of the defaults for now. Figure 5.11 shows
    the settings we’ll change, and you can learn about them all in the Unity documentation
    ([http://mng.bz/RqQP](https://shortener.manning.com/RqQP)).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到 TextMeshPro 设置。我们可以以无数种方式自定义文本，但现在我们将保留大多数默认设置。图 5.11 显示我们将更改的设置，您可以在 Unity
    文档中了解它们的所有信息（[http://mng.bz/RqQP](https://shortener.manning.com/RqQP)）。
- en: '![CH05_F11_Hocking3](../Images/CH05_F11_Hocking3.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F11_Hocking3](../Images/CH05_F11_Hocking3.png)'
- en: Figure 5.11 Inspector settings for this text object
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 此文本对象的检查器设置
- en: 'Enter Score: in the big Text Input box and decrease Font Size to 8. Manipulating
    this text object during the game requires just a few adjustments in the scoring
    code.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '在大文本输入框中输入 Score: 并将字体大小减小到 8。在游戏中操作这个文本对象只需要在得分代码中进行少量调整。'
- en: Listing 5.12 Displaying the score on a text object
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12 在文本对象上显示得分
- en: '[PRE11]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Include TextMeshPro code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含 TextMeshPro 代码。
- en: As you can see, text is a property of the object that you can set to a new string.
    Put the score variable into the string to display that value.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，文本是对象的属性，您可以将其设置为新的字符串。将得分变量放入字符串中，以显示该值。
- en: Drag the text object in the scene to the scoreLabel variable you added to SceneController
    and then click Play. Now you should see the score displayed while you play the
    game and make matches. Huzzah—the game works!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将场景中的文本对象拖到 SceneController 中您添加的 scoreLabel 变量上，然后点击播放。现在，当您玩游戏并制作匹配时，应该会看到得分显示。太棒了——游戏工作啦！
- en: 5.5 Restart button
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 重启按钮
- en: At this point, the Memory game is fully functional. You can play the game, and
    all the essential features are in place. But this playable core is still lacking
    the overarching functionality that players expect or need in a finished game.
    For example, right now you can play the game only once; you need to quit and restart
    to play again. Let’s add a control to the screen so that players can start the
    game over without having to quit.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，记忆游戏已经完全可用。您可以玩游戏，所有基本功能都已就绪。但这个可玩的核心仍然缺少玩家在完成的游戏中期望或需要的整体功能。例如，目前您只能玩一次游戏；您需要退出并重新启动才能再次玩游戏。让我们在屏幕上添加一个控制按钮，以便玩家可以在不退出的情况下重新开始游戏。
- en: 'This functionality divides into two tasks: create a UI button and reset the
    game when that button is clicked. Figure 5.12 shows what the game will look like
    with the Start button.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能可以分为两个任务：创建一个 UI 按钮，并在点击该按钮时重置游戏。图 5.12 显示了带有开始按钮的游戏外观。
- en: '![CH05_F12_Hocking3](../Images/CH05_F12_Hocking3.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F12_Hocking3](../Images/CH05_F12_Hocking3.png)'
- en: Figure 5.12 Complete Memory game screen, including the Start button
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 完整的记忆游戏屏幕，包括开始按钮
- en: Neither task is specific to 2D games, by the way. All games need UI buttons,
    and all games need the ability to reset. We’ll go over both topics to round out
    this chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这两个任务并不特定于 2D 游戏。所有游戏都需要 UI 按钮，所有游戏都需要重置的能力。我们将讨论这两个主题，以完善本章内容。
- en: 5.5.1 Programming a UIButton component by using SendMessage
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 通过 SendMessage 编程 UIButton 组件
- en: First, place the button sprite in the scene by dragging it up from the Project
    view. Give it a position like 4.5, 3.25, -10; that will place the button in the
    top-right corner (that’s 450 pixels to the right and 325 pixels up) and move it
    nearer to the camera so that it’ll appear on top of other game objects. Because
    we want to be able to click this object, give it a collider (just as with the
    card object, choose Add Component > Physics 2D > Box Collider 2D).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过从项目视图拖动按钮精灵到场景中。给它一个位置如 4.5, 3.25, -10；这样会将按钮放置在右上角（即向右450像素，向上325像素）并使其靠近相机，以便它能够显示在其他游戏对象之上。因为我们希望能够点击这个对象，所以给它一个碰撞器（就像卡片对象一样，选择添加组件
    > 物理引擎 2D > 矩形碰撞器 2D）。
- en: NOTE As alluded to in the previous section, Unity provides multiple ways to
    create UI displays, including an advanced UI system introduced in later versions
    of Unity. For now, we’ll build the single button out of standard display objects.
    A future chapter will teach you about the advanced UI functionality; the UI for
    both 2D and 3D games is ideally built with that system.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：正如前节所述，Unity 提供了多种创建 UI 显示的方式，包括在 Unity 后续版本中引入的高级 UI 系统。现在，我们将使用标准显示对象构建单个按钮。未来的章节将教你关于高级
    UI 功能；2D 和 3D 游戏的 UI 理想上应该使用该系统构建。
- en: Now create a new script called UIButton and assign it to the button object.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个新的脚本名为 UIButton 并将其分配给按钮对象。
- en: Listing 5.13 Code to make a generic and reusable UI button
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.13 创建通用和可重用 UI 按钮的代码
- en: '[PRE12]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Reference a target object to inform about clicks.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 引用目标对象以通知点击事件。
- en: ❷ Tint the button when the mouse hovers over it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当鼠标悬停在按钮上时，为按钮着色。
- en: ❸ The button’s size pops a bit when it’s clicked.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当按钮被点击时，按钮的大小会略微弹出。
- en: ❹ Send a message to the target object when the button is clicked.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当按钮被点击时，向目标对象发送消息。
- en: 'The majority of this code happens inside a series of OnMouseSomething functions.
    Like Start() and Update(), these are a series of functions automatically available
    to all script components in Unity. MouseDown was already mentioned in section
    5.2.2, but these other functions also respond to mouse interactions if the object
    has a collider. MouseEnter and MouseExit are a pair of events used for hovering
    the mouse cursor over an object: MouseEnter triggers when the mouse cursor first
    moves over an object, and MouseExit triggers when the mouse cursor moves away.
    Similarly, MouseDown and MouseUp are a pair of events for clicking the mouse.
    MouseDown triggers when the mouse button is physically pressed, and MouseUp triggers
    when the mouse button is released.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的大部分内容都发生在一系列的 OnMouseSomething 函数中。就像 Start() 和 Update() 一样，这些是一系列自动对所有脚本组件在
    Unity 中可用的函数。MouseDown 在第 5.2.2 节中已经提到，但其他这些函数也会在对象有碰撞器的情况下响应鼠标交互。MouseEnter 和
    MouseExit 是一对事件，用于在鼠标光标悬停在对象上：当鼠标光标第一次移动到对象上时，MouseEnter 触发，而当鼠标光标移开时，MouseExit
    触发。同样，MouseDown 和 MouseUp 是一对用于点击鼠标的事件。当鼠标按钮被物理按下时，MouseDown 触发，而当鼠标按钮释放时，MouseUp
    触发。
- en: You can see that this code tints the sprite when the mouse hovers over it and
    scales the sprite when it’s clicked. In both cases, you can see that the change
    (in color or scale) happens when the mouse interaction begins, and then the property
    returns to the default (either white or scale 1) when the mouse interaction ends.
    For scaling, the code uses the standard transform component that all GameObjects
    have. For tint, though, the code uses the SpriteRenderer component that sprite
    objects have; the sprite is set to a color that’s defined in Unity’s editor through
    a public variable.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当鼠标悬停在精灵上时，代码会着色精灵，当点击时，会缩放精灵。在这两种情况下，你可以看到变化（颜色或缩放）发生在鼠标交互开始时，当鼠标交互结束时，属性会返回默认值（白色或缩放
    1）。对于缩放，代码使用所有 GameObject 都有的标准变换组件。然而，对于着色，代码使用精灵对象具有的 SpriteRenderer 组件；精灵被设置为在
    Unity 编辑器中通过公共变量定义的颜色。
- en: In addition to returning the scale to 1, SendMessage() is called when the mouse
    is released. SendMessage() calls the function of the given name in all components
    of that GameObject. Here, the target object for the message, as well as the message
    to send, are both defined by serialized variables. This way, the same UIButton
    component can be used for all sorts of buttons, with the target of different buttons
    set to different objects in the Inspector.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将比例恢复到1之外，当鼠标释放时还会调用SendMessage()。SendMessage()会调用该GameObject所有组件中给定名称的函数。在这里，消息的目标对象以及要发送的消息都由序列化变量定义。这样，同一个UIButton组件可以用于所有类型的按钮，不同按钮的目标对象在检查器中设置为不同的对象。
- en: Normally, when doing OOP in a strongly typed language like C#, you need to know
    the type of a target object in order to communicate with that object (for example,
    to call a public method of the object, like calling targetObject.SendMessage()
    itself). But scripts for UI elements may have lots of types of targets, so Unity
    provides the SendMessage() method to communicate specific messages with a target
    object even if you don’t know exactly what type of object it is.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在强类型语言如C#中进行面向对象编程时，你需要知道目标对象类型才能与该对象通信（例如，调用对象的公共方法，如调用targetObject.SendMessage()）。但UI元素的脚本可能有多种目标类型，因此Unity提供了SendMessage()方法，即使你不知道目标对象的确切类型，也可以与目标对象通信特定的消息。
- en: WARNING Using SendMessage() is less efficient for the CPU than calling public
    methods on known types (that is, using object.SendMessage("Method") versus component.Method()),
    so use SendMessage() only when it’s a big win in terms of making the code simpler
    to understand and work with. As a general rule, that will be the case only if
    lots of different types of objects could be receiving the message. In situations
    like that, the inflexibility of inheritance or even interfaces will hinder the
    game development process and discourage experimentation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：使用SendMessage()比调用已知类型的公共方法对CPU效率更低（即使用object.SendMessage("Method")与component.Method()相比），因此只有在使代码更易于理解和操作的情况下才使用SendMessage()。一般来说，只有在许多不同类型的对象可能接收消息的情况下才会如此。在这种情况下，继承或接口的不灵活性将阻碍游戏开发过程并抑制实验。
- en: With this code written, wire up the public variables in the button’s Inspector.
    The highlight color can be set to whatever you’d like (although the default cyan
    looks pretty good on a blue button). Meanwhile, put the SceneController object
    in the target object slot, and then type Restart as the message.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 编写完此代码后，将按钮检查器中的公共变量连接起来。高亮颜色可以设置为任何你喜欢的颜色（尽管默认的青色在蓝色按钮上看起来相当不错）。同时，将SceneController对象放入目标对象槽中，然后输入Restart作为消息。
- en: If you play the game now, the Reset button in the top-right corner changes color
    in response to the mouse and makes a slight visual pop when clicked. But an error
    message will be emitted when you click the button; in the console, you’ll see
    an error about there not being a receiver for the Restart message. That’s because
    we haven’t written a Restart() method in SceneController, so let’s add that.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在玩游戏，右上角的复位按钮会根据鼠标颜色变化，并在点击时产生轻微的视觉弹出效果。但是，当你点击按钮时，会发出错误消息；在控制台中，你会看到一个关于没有接收器用于重启消息的错误。那是因为我们还没有在SceneController中编写Restart()方法，所以让我们添加它。
- en: 5.5.2 Calling LoadScene from SceneController
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2 从SceneController调用LoadScene
- en: The SendMessage() method from the button attempts to call Restart() in the SceneController,
    so let’s add that now.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮中的SendMessage()方法试图在SceneController中调用Restart()，所以现在让我们添加它。
- en: Listing 5.14 SceneController code that reloads the level
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.14重新加载级别的SceneController代码
- en: '[PRE13]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Include SceneManagement code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含SceneManagement代码。
- en: ❷ If your scene has a different name, change the name in this string.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果你的场景有不同的名称，请更改此字符串中的名称。
- en: You can see the one thing Restart() does is call LoadScene(). That method loads
    a saved scene asset (the file created when you click Save Scene in Unity). Pass
    the name of the scene you want to load into the method. In my case, the scene
    was saved with the name Scene, but if you used a different name, pass that to
    the method instead.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到Restart()所做的唯一一件事就是调用LoadScene()方法。该方法加载一个已保存的场景资产（当你点击Unity中的保存场景时创建的文件）。将你想加载的场景名称传递给该方法。在我的情况下，场景以Scene名称保存，但如果你使用了不同的名称，请将那个名称传递给该方法。
- en: Click Play to see what happens. Reveal a few cards and make a few matches. If
    you then click the Reset button, the game starts over, with all cards hidden and
    a score of 0\. Great, just what we wanted!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放按钮查看会发生什么。翻开几张牌并完成一些匹配。如果你然后点击重置按钮，游戏将重新开始，所有牌都隐藏起来，得分为0。太好了，这正是我们想要的！
- en: As the name LoadScene() indicates, this method can load different scenes. But
    what exactly happens when a scene loads, and why does this reset the game? What
    happens is that everything from the current level (all objects in the scene, and
    thus all scripts attached to those objects) is flushed from memory, and then everything
    from the new scene is loaded. Because the new scene is the saved asset of the
    current scene (in this case), everything is flushed from memory and then reloaded
    from scratch.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如名称LoadScene()所示，这个方法可以加载不同的场景。但场景加载时究竟会发生什么，为什么这会重置游戏？发生的情况是，当前级别（场景中的所有对象，以及因此附加到这些对象的所有脚本）的内容都会从内存中清除，然后加载新场景的所有内容。因为新场景是当前场景（在这种情况下）的保存资产，所以所有内容都会从内存中清除，然后从头开始重新加载。
- en: TIP You can mark specific objects to exclude from the default memory flush when
    a level is loaded. Unity provides the DontDestroyOnLoad() method to keep an object
    around in multiple scenes. You’ll use this method on parts of the code architecture
    in later chapters.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：你可以在加载关卡时标记特定的对象，以排除默认内存清除。Unity提供了DontDestroyOnLoad()方法来在多个场景中保持对象的存在。你将在后面的章节中使用这个方法在代码架构的部分。
- en: Another game successfully completed! Well, *completed* is a relative term; you
    could always implement more features, but everything from the initial plan is
    done. Many of the concepts from this 2D game apply to 3D games as well, especially
    the checking of game state and loading levels. It’s time to switch gears yet again
    and move away from this Memory game and on to new projects.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个游戏成功完成！嗯，*完成*这个词是相对的；你总是可以添加更多功能，但所有初始计划中的内容都已经完成。这个二维游戏中的许多概念也适用于三维游戏，特别是检查游戏状态和加载关卡。是时候再次转换方向，离开这个记忆游戏，转向新的项目。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Displaying 2D graphics in Unity uses an orthographic camera.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中使用正交相机显示二维图形。
- en: For pixel-perfect graphics, the camera size should be half the screen height.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了像素级的图形，相机的尺寸应该是屏幕高度的一半。
- en: Clicking sprites requires that you first assign 2D colliders to them.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击精灵之前，你需要首先为它们分配二维碰撞器。
- en: New images for sprites can be loaded programmatically.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过编程方式加载精灵的新图像。
- en: UI text can be made using 3D text objects.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用3D文本对象创建UI文本。
- en: Loading levels resets the scene.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载关卡会重置场景。
