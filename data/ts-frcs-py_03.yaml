- en: 2 A naive prediction of the future
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 对未来的简单预测
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Defining a baseline model
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义基线模型
- en: Setting a baseline using the mean
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平均值设置基线
- en: Building a baseline using the mean of the previous window of time
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用前一个时间窗口的平均值创建基线
- en: Creating a baseline using the previous timestep
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用前一时间步创建基线
- en: Implementing the naive seasonal forecast
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现简单的季节性预测
- en: In chapter 1 we covered what time series are and how forecasting a time series
    is different from a traditional regression task. You also learned the necessary
    steps in building a successful forecasting project, from defining a goal to building
    a model, deploying it, and updating it as new data is collected. Now you are ready
    to start forecasting a time series.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章中，我们介绍了时间序列是什么，以及预测时间序列与传统的回归任务有何不同。你还学习了构建成功预测项目所需的必要步骤，从定义目标到构建模型，部署它，以及随着新数据的收集而更新它。现在你准备好开始预测时间序列了。
- en: You will first learn how to make a naive prediction of the future, which will
    serve as a baseline. The baseline model is a trivial solution that uses heuristics,
    or simple statistics, to compute a forecast. Developing a baseline model is not
    always an exact science. It will often require some intuition that we’ll gain
    by visualizing the data and detecting patterns that can be used to make predictions.
    In any modeling project, it is important to have a baseline, as you can use it
    to compare the performance of the more complex models you’ll build down the road.
    The only way to know that a model is good, or performant, is to compare it to
    a baseline.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先学习如何进行未来的简单预测，这将成为基线。基线模型是一个简单的解决方案，它使用启发式方法或简单的统计方法来计算预测。开发基线模型并不总是精确的科学。它通常需要通过可视化数据和检测可用于预测的模式来获得一些直觉。在任何建模项目中，拥有一个基线都很重要，因为你可以用它来比较你将来构建的更复杂模型的性能。唯一知道模型是好是坏的方法是将它与基线进行比较。
- en: In this chapter, let’s imagine that we wish to predict the quarterly earnings
    per share (EPS) of Johnson & Johnson. We can look at the dataset in figure 2.1,
    which is identical to what you saw in chapter 1\. Specifically, we will use the
    data from 1960 to the end of 1979 in order to predict the EPS for the four quarters
    of 1980\. The forecasting period is illustrated by the gray zone in figure 2.1.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，让我们假设我们希望预测强生公司的季度每股收益（EPS）。我们可以查看图2.1中的数据集，这与你在第1章中看到的是相同的。具体来说，我们将使用1960年到1979年底的数据来预测1980年四个季度的EPS。预测期如图2.1中的灰色区域所示。
- en: '![](../../OEBPS/Images/02-01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/02-01.png)'
- en: Figure 2.1 Quarterly earnings per share of Johnson & Johnson in US dollars (USD)
    between 1960 and 1980\. We will use the data from 1960 to the last quarter of
    1979 to build a baseline model that will forecast the earnings per share for the
    quarters of 1980 (as illustrated by the gray area).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 1960年至1980年间强生公司每股收益（美元，USD）。我们将使用1960年到1979年最后一个季度的数据来构建一个基线模型，该模型将预测1980年各季度的每股收益（如图中灰色区域所示）。
- en: You can see in figure 2.1 that our data has a trend, since it is increasing
    over time. Also, we have a seasonal pattern, since over the course of a year,
    or four quarters, we can observe peaks and troughs repeatedly. This means that
    we have seasonality.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图2.1中看到，我们的数据具有趋势，因为它随时间增加。此外，我们有一个季节性模式，因为在一年或四个季度中，我们可以反复观察到峰值和谷值。这意味着我们存在季节性。
- en: Recall that we identified each of these components when we decomposed our time
    series in chapter 1\. The components are shown in figure 2.2\. We will study some
    of these components in detail later in the chapter, as they will help us gain
    some intuition about the behavior of the data, which in turn will help us develop
    a good baseline model.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们在第1章中分解时间序列时识别了这些组件。组件如图2.2所示。我们将在本章的后面部分详细研究这些组件，因为它们将帮助我们获得关于数据行为的直觉，这反过来又帮助我们开发一个好的基线模型。
- en: '![](../../OEBPS/Images/02-02.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/02-02.png)'
- en: Figure 2.2 Decomposition of quarterly earnings of Johnson & Johnson from 1960
    to 1980
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 1960年至1980年强生公司季度收益分解
- en: We will first define what a baseline model is, and then we will develop four
    different baselines to forecast the quarterly EPS of Johnson & Johnson. This is
    the time when we’ll finally get our hands dirty with Python and time series forecasting.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将定义什么是基线模型，然后我们将开发四个不同的基线来预测强生公司的季度每股收益。这是我们将最终开始使用Python和时间序列预测“动手”的时候。
- en: 2.1 Defining a baseline model
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 定义基准模型
- en: A *baseline model* is a trivial solution to our problem. It often uses heuristics,
    or simple statistics, to generate predictions. The baseline model is the simplest
    solution you can think of—it should not require any training, and the cost of
    implementation should be very low.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*基准模型*是解决我们问题的简单解决方案。它通常使用启发式方法或简单的统计来生成预测。基准模型是你能想到的最简单解决方案——它不应该需要任何训练，并且实施成本应该非常低。
- en: Can you think of a baseline for our project?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你能为我们项目想出一个基准吗？
- en: Knowing that we want to forecast the EPS for Johnson & Johnson, what is the
    most basic, most naive, forecast you can make?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 知道我们想要预测强生公司的每股收益（EPS），你能做出最基本、最天真的预测是什么？
- en: In the context of time series, one simple statistic we can use to build a baseline
    is the arithmetic mean. We can simply compute the mean of the values over a certain
    period and assume that future values will be equal to that mean. In the context
    of predicting the EPS for Johnson & Johnson, this is like saying
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列的背景下，我们可以用来构建基准的一个简单统计量是算术平均值。我们可以简单地计算一定时期内的平均值，并假设未来的值将等于这个平均值。在预测强生公司EPS的背景下，这就像说
- en: The average EPS between 1960 and 1979 was $4.31\. Therefore, I expect the EPS
    over the next four quarters of 1980 to be equal to $4.31 per quarter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 1960年至1979年间的平均EPS为$4.31。因此，我预计1980年接下来的四个季度的EPS将等于每季度$4.31。
- en: Another possible baseline is to naively forecast the last recorded data point.
    In our context, this would be like saying
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的基准是天真地预测最后一个记录的数据点。在我们的背景下，这就像说
- en: If the EPS is $0.71 for this quarter, then the EPS will also be $0.71 for next
    quarter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个季度的EPS是$0.71，那么下一个季度的EPS也将是$0.71。
- en: Or, if we see a cyclical pattern in our data, we can simply repeat that pattern
    into the future. Staying in the context of Johnson & Johnson, this is like saying
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们看到数据中的周期性模式，我们可以简单地重复这个模式到未来。在强生公司的背景下，这就像说
- en: If the EPS is $14.04 for the first quarter of 1979, then the EPS for the first
    quarter of 1980 will also be $14.04.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果1979年第一季度的EPS是$14.04，那么1980年第一季度的EPS也将是$14.04。
- en: You can see these three possible baselines rely on simple statistics, heuristics,
    and patterns observed in our dataset.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这三个可能的基准依赖于我们数据集中的简单统计、启发式方法和观察到的模式。
- en: Baseline model
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 基准模型
- en: A baseline model is a trivial solution to your forecasting problem. It relies
    on heuristics or simple statistics and is usually the simplest solution. It does
    not require model fitting, and it is easy to implement.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 基准模型是解决你的预测问题的简单解决方案。它依赖于启发式方法或简单的统计，通常是解决方案中最简单的。它不需要模型拟合，并且易于实现。
- en: You might wonder if those baseline models are any good. How well can those simple
    methods forecast the future? We can answer this question by forecasting for the
    year of 1980 and testing our forecasts against the observed data in 1980\. This
    is called *out-of-sample* forecasting because we are making predictions for a
    period that was not taken into account when the model was developed. That way
    we can measure the performance of our models and see how they would perform when
    we forecast beyond the data we have, which in this case is 1981 and later.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道那些基准模型是否有效。这些简单的方法能有多好地预测未来？我们可以通过预测1980年并测试我们的预测与1980年观察到的数据来回答这个问题。这被称为*样本外*预测，因为我们正在为一个在模型开发时未考虑的时期进行预测。这样我们可以衡量我们模型的性能，并看到当我们预测超出我们拥有的数据时，它们会如何表现，在这种情况下是1981年和之后。
- en: In the next sections, you will learn how to develop the different baselines
    mentioned here to predict the quarterly EPS of Johnson & Johnson.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将学习如何开发这里提到的不同基准来预测强生公司的季度EPS。
- en: 2.2 Forecasting the historical mean
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 预测历史平均值
- en: 'As mentioned at the beginning of the chapter, we are going to work with the
    quarterly EPS in US dollars (USD) of Johnson & Johnson from 1960 to 1980\. Our
    goal is to use the data from 1960 to the end of 1979 to predict the four quarters
    of 1980\. The first baseline we’ll discuss uses the historical mean, which is
    the arithmetic mean of past values. Its implementation is straightforward: calculate
    the mean of the training set, and it will be our prediction for the four quarters
    of 1980\. First, though, we need to do some preliminary work that we’ll use in
    all of our baseline implementations.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，我们将使用1960年至1980年Johnson & Johnson的季度每股收益（EPS）美元（USD）。我们的目标是使用1960年到1979年底的数据来预测1980年的四个季度。我们将讨论的第一个基线使用的是历史平均值，即过去值的算术平均值。其实现方法是直接的：计算训练集的平均值，它将成为我们对1980年四个季度的预测。不过，首先我们需要做一些初步工作，这些工作将用于我们所有的基线实现。
- en: 2.2.1 Setup for baseline implementations
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 基线实现设置
- en: 'Our first step is to load the dataset. To do so, we will use the `pandas` library
    and load the dataset into a `DataFrame` using the `read_csv` method. You can either
    download the file on your local machine and pass the file’s path to the `read_csv`
    method, or simply type in the URL where the CSV file is hosted on GitHub. In this
    case, we will work with the file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是加载数据集。为此，我们将使用`pandas`库，并通过`read_csv`方法将数据集加载到`DataFrame`中。您可以在本地机器上下载文件，并将文件的路径传递给`read_csv`方法，或者简单地输入CSV文件在GitHub上托管的位置。在这种情况下，我们将使用以下文件：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note The entire code for this chapter is available on GitHub: [https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH02](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH02).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章的完整代码可在GitHub上找到：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH02](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH02)。
- en: A `DataFrame` is the most-used data structure in `pandas`. It is a 2-dimensional
    labeled data structure with columns that can hold different types of data, such
    as strings, integers, floats, or dates.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame`是`pandas`中最常用的数据结构。它是一个二维带标签的数据结构，具有可以存储不同类型数据的列，例如字符串、整数、浮点数或日期。'
- en: Our second step is to split the data into a train set for training and a test
    set for testing. Given that our horizon is 1 year, our train set will start in
    1960 and go all the way to the end of 1979\. We will save the data collected in
    1980 for our test set. You can think of a `DataFrame` as a table or a spreadsheet
    with column names and row indices.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二步是将数据分为训练集和测试集。鉴于我们的预测范围是1年，我们的训练集将从1960年开始，一直持续到1979年底。我们将把1980年收集的数据保存为测试集。您可以将`DataFrame`想象成一个带有列名和行索引的表格或电子表格。
- en: With our dataset in a `DataFrame`, we can display the first five entries by
    running
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据集以`DataFrame`形式存在的情况下，我们可以通过运行以下命令来显示前五条记录
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will give us the output shown in figure 2.3.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出如图2.3所示的输出。
- en: '![](../../OEBPS/Images/02-03.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/02-03.png)'
- en: 'Figure 2.3 The first five entries of quarterly earnings per share for the Johnson
    & Johnson dataset. Notice how our `DataFrame` has two columns: date and data.
    It also has row indices starting at 0.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：Johnson & Johnson数据集的季度每股收益的前五条记录。注意我们的`DataFrame`有两个列：日期和数据。它还有从0开始的行索引。
- en: Figure 2.3 will help you better understand what type of data our `DataFrame`
    is holding. We have the date column, which specifies the end of each quarter,
    when the EPS is calculated. The data column holds the value of the EPS in US dollars
    (USD).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3将帮助您更好地理解我们的`DataFrame`所持有的数据类型。我们有一个日期列，它指定了EPS计算的每个季度的结束。数据列持有每股收益的美元（USD）值。
- en: 'We can optionally display the last five entries of our dataset and obtain the
    output in figure 2.4:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择显示数据集的最后五条记录，并得到如图2.4所示的输出：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](../../OEBPS/Images/02-04.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/02-04.png)'
- en: Figure 2.4 The last five entries of our dataset. Here we can see the four quarters
    of 1980 that we will try to predict using different baseline models. We will compare
    our forecasts to the observed data in 1980 to evaluate the performance of each
    baseline.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：数据集的最后五条记录。在这里，我们可以看到1980年的四个季度，我们将尝试使用不同的基线模型来预测。我们将比较我们的预测与1980年的观测数据，以评估每个基线的性能。
- en: In figure 2.4 we see the four quarters of 1980, which is what we will be trying
    to forecast using our baseline models. We will evaluate the performance of our
    baselines by comparing our forecasts to the values in the data column for the
    four quarters of 1980\. The closer our forecasts are to the observed values, the
    better.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在图2.4中，我们看到1980年的四个季度，这是我们试图使用基线模型预测的内容。我们将通过将我们的预测与1980年四个季度的数据列中的值进行比较来评估基线的性能。我们的预测越接近观察值，性能就越好。
- en: The final step before developing our baseline models is to split the dataset
    into the train and test sets. As mentioned earlier, the train set will consist
    of the data from 1960 to the end of 1979, and the test set will consist of the
    four quarters of 1980\. The train set will be the only information we use to develop
    our models. Once a model is built, we will forecast the next four timesteps, which
    will correspond to the four quarters of 1980 in our test set. That way, we can
    compare our forecasts to the observed data and evaluate the performance of our
    baselines.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发我们的基线模型之前的最后一步是将数据集分为训练集和测试集。如前所述，训练集将包括从1960年到1979年底的数据，测试集将包括1980年的四个季度。训练集将是我们在开发模型时使用的唯一信息。一旦构建了一个模型，我们将预测下一个四个时间步长，这将在我们的测试集中对应于1980年的四个季度。这样，我们可以将我们的预测与观察数据进行比较，并评估基线的性能。
- en: 'To make the split, we’ll specify that our train set will contain all the data
    held in `df` except the last four entries. The test set will be composed of only
    the last four entries. This is what the next code block does:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行分割，我们将指定我们的训练集将包含`df`中保存的所有数据，除了最后四个条目。测试集将仅由最后四个条目组成。这就是下一个代码块所做的工作：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 2.2.2 Implementing the historical mean baseline
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 实现历史平均值基线
- en: 'Now we are ready to implement our baseline. We will first use the arithmetic
    mean of the entire train set. To compute the mean, we’ll use the `numpy` library,
    as it is a very fast package for scientific computing in Python that plays really
    well with `DataFrames`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备实现我们的基线。我们首先将使用整个训练集的算术平均值。为了计算平均值，我们将使用`numpy`库，因为它是一个在Python中进行科学计算非常快速的包，并且与`DataFrames`配合得很好：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Compute the arithmetic mean of the data column in the train set.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算训练集中数据列的算术平均值。
- en: In the preceding code block, we first import the `numpy` library and then compute
    the average of the EPS over the entire train set and print it out on the screen.
    This gives a value of 4.31 USD. This means that from 1960 to the end of 1979,
    the quarterly EPS of Johnson & Johnson is on average 4.31 USD.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们首先导入`numpy`库，然后计算整个训练集EPS的平均值，并在屏幕上打印出来。这个值是4.31美元。这意味着从1960年到1979年底，强生公司的季度EPS平均为4.31美元。
- en: 'Now we will naively forecast this value for each quarter of 1980\. To do so,
    we’ll simply create a new column, pred_mean, that holds the historical mean of
    the training set as a forecast:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将天真地预测1980年每个季度的这个值。为此，我们将简单地创建一个新的列，名为pred_mean，它包含训练集的历史平均值作为预测值：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Set the historical mean as a forecast.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将历史平均值设为预测值。
- en: Next, we need to define and calculate an error metric in order to evaluate the
    performance of our forecasts on the test set. In this case, we will use the *mean
    absolute percentage error* (MAPE). It is a measure of prediction accuracy for
    forecasting methods that is easy to interpret and independent of the scale of
    our data. This means that whether we are working with two-digit values or six-digit
    values, the MAPE will always be expressed as a percentage. Thus, the MAPE returns
    the percentage of how much the forecast values deviate from the observed or actual
    values on average, whether the prediction was higher or lower than the observed
    values. The MAPE is defined in equation 2.1.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义并计算一个误差指标，以便评估我们的预测在测试集上的性能。在这种情况下，我们将使用*平均绝对百分比误差*（MAPE）。它是一种易于解释且与我们的数据规模无关的预测准确度度量。这意味着无论我们处理的是两位数还是六位数，MAPE都将始终以百分比的形式表示。因此，MAPE返回预测值与观察值或实际值平均偏差的百分比，无论预测值是高于还是低于观察值。MAPE在方程2.1中定义。
- en: '![](../../OEBPS/Images/02-04_Equation-2-1.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/02-04_Equation-2-1.png)'
- en: Equation 2.1
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 方程2.1
- en: In equation 2.1, *A*[i] is the actual value at point *i* in time, and *F*[i]
    is the forecast value at point *i* in time; *n* is simply the number of forecasts.
    In our case, because we are forecasting the four quarters of 1980, *n* = 4\. Inside
    the summation, the forecast value is subtracted from the actual value, and that
    result is divided by the actual value, which gives us the percentage error. Then
    we take the absolute value of the percentage error. This operation is repeated
    for each of the *n* points in time, and the results are added together. Finally,
    we divide the sum by *n*, the number of points in time, which effectively gives
    us the mean absolute percentage error.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在公式 2.1 中，*A*[i] 是时间点 *i* 的实际值，而 *F*[i] 是时间点 *i* 的预测值；*n* 简单地是预测的数量。在我们的情况下，因为我们正在预测
    1980 年的四个季度，*n* = 4。在求和内部，预测值从实际值中减去，然后除以实际值，这给出了百分比误差。然后我们取百分比误差的绝对值。这个操作对时间点
    *n* 的每个点重复进行，然后将结果相加。最后，我们将总和除以 *n*，即时间点的数量，这实际上给出了平均绝对百分比误差。
- en: 'Let’s implement this function in Python. We’ll define a `mape` function that
    takes in two vectors: `y_true` for the actual values observed in the test set
    and `y_pred` for the forecast values. In this case, because `numpy` allows us
    to work with arrays, we will not need a loop to sum all the values. We can simply
    subtract the `y_pred` array from the `y_true` array and divide by `y_true` to
    get the percentage error. Then we can take the absolute value. After that, we
    take the mean of the result, which will take care of summing up each value in
    the vector and dividing by the number of predictions. Finally, we’ll multiply
    the result by 100 so the output is expressed as a percentage instead of a decimal
    number:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Python 中实现这个函数。我们将定义一个 `mape` 函数，它接受两个向量：`y_true` 用于测试集中观察到的实际值，`y_pred`
    用于预测值。在这种情况下，因为 `numpy` 允许我们处理数组，我们不需要循环来求和所有值。我们可以简单地从 `y_true` 数组中减去 `y_pred`
    数组，然后除以 `y_true` 来得到百分比误差。然后我们可以取绝对值。之后，我们取结果的平均值，这将负责将向量中的每个值相加并除以预测的数量。最后，我们将结果乘以
    100，这样输出就是以百分比而不是小数形式表示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can calculate the MAPE of our baseline. Our actual values are in the
    data column of `test`, so it will be the first parameter passed to the `mape`
    function. Our forecasts are in the pred_mean column of `test`, so it will be our
    second parameter for the function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以计算基线的 MAPE。我们的实际值在 `test` 数据的 `data` 列中，所以它将是传递给 `mape` 函数的第一个参数。我们的预测值在
    `test` 的 `pred_mean` 列中，所以它将是函数的第二个参数：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Running the function gives a MAPE of 70.00%. This means that our baseline deviates
    by 70% on average from the observed quarterly EPS of Johnson & Johnson in 1980.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该函数得到 MAPE 为 70.00%。这意味着我们的基线平均偏离了 1980 年 Johnson & Johnson 观察到的季度 EPS 70%。
- en: Let’s visualize our forecasts to better understand our MAPE of 70%.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们可视化我们的预测，以更好地理解我们的 70% MAPE。
- en: Listing 2.1 Visualizing our forecasts
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 可视化我们的预测
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In listing 2.1, we use the `matplotlib` library, which is the most popular library
    for generating visualizations in Python, to generate a graph showing the training
    data, the forecast horizon, the observed values of the test set, and the predictions
    for each quarter of 1980.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 2.1 中，我们使用了 `matplotlib` 库，这是 Python 中生成可视化的最流行库，用来生成一个显示训练数据、预测范围、测试集的观察值以及
    1980 年每个季度的预测的图表。
- en: First, we initialize a `figure` and an `ax` object. A figure can contain many
    `ax` objects, which allows us to create a figure with two, three, or more plots.
    In this case, we are creating a figure with a single plot, so we only need one
    `ax`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化一个 `figure` 和一个 `ax` 对象。一个图可以包含多个 `ax` 对象，这允许我们创建包含两个、三个或更多图表的图。在这种情况下，我们正在创建一个包含单个图表的图，所以我们只需要一个
    `ax`。
- en: Second, we plot our data on the `ax` object. We plot the train data using a
    green dashed and dotted line and give this curve a label of “Train.” The label
    will later be useful for generating a legend for the graph. We then plot the test
    data and use a blue continuous line with a label of “Test.” Finally, we plot our
    predictions using a red dashed line with a label of “Predicted.”
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们在 `ax` 对象上绘制我们的数据。我们使用绿色虚线和点线绘制训练数据，并给这条曲线一个“训练”的标签。标签将后来用于生成图表的图例。然后我们绘制测试数据，并使用带有“测试”标签的蓝色连续线。最后，我们使用带有“预测”标签的红色虚线绘制我们的预测。
- en: Third, we label our *x-*axis and *y*-axis and draw a rectangular area to illustrate
    the forecast horizon. Since our forecast horizon is the four quarters of 1980,
    the area should start at index 80 and end at index 83, spanning the entire year
    of 1980\. Remember that we obtained the indices of the last quarter of 1980 by
    running `df.tail()`, which resulted in figure 2.5.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们标注了*x-*轴和*y-*轴，并绘制一个矩形区域来表示预测范围。由于我们的预测范围是1980年的四个季度，该区域应从索引80开始，到索引83结束，覆盖整个1980年。记住，我们通过运行`df.tail()`获得了1980年最后一个季度的索引，这导致了图2.5。
- en: '![](../../OEBPS/Images/02-05.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/02-05.png)'
- en: Figure 2.5 The last five entries of our dataset
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 我们数据集的最后五条记录
- en: We give this area a gray color and specify the opacity using the `alpha` parameter.
    When `alpha` is 1, the shape is completely opaque; when `alpha` is 0, it is completely
    transparent. In our case, we’ll use an opacity of 20%, or 0.2.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个区域涂成灰色，并使用`alpha`参数指定不透明度。当`alpha`为1时，形状是完全不透明的；当`alpha`为0时，它是完全透明的。在我们的情况下，我们将使用20%的不透明度，或0.2。
- en: 'Then we specify the labels for the ticks on the *x*-axis. By default, the labels
    would show the data for each quarter of the dataset, which would create a crowded
    *x*-axis with unreadable labels. Instead, we’ll display the year every 2 years.
    To do so, we’ll generate an array specifying the index at which the label must
    appear. That’s what `np.arange(0, 81, 8)` does: it generates an array starting
    at 0, finishing at 80, because the end index (81) is not included, with steps
    of 8, because there are 8 quarters in 2 years. This will effectively generate
    the following array: [0,8,16,...72,80]. Then we specify an array containing the
    labels at each index, so it must start with 1960 and end with 1980, just like
    our dataset.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们指定*x*轴上刻度的标签。默认情况下，标签将显示数据集中的每个季度的数据，这将创建一个拥挤的*x*轴，标签难以阅读。相反，我们将每两年显示一次年份。为此，我们将生成一个指定标签必须出现位置的索引数组。这就是`np.arange(0,
    81, 8)`所做的事情：它生成一个从0开始，到80结束的数组，因为结束索引（81）不包括在内，步长为8，因为两年中有8个季度。这将有效地生成以下数组：[0,8,16,...72,80]。然后我们指定一个包含每个索引标签的数组，因此它必须从1960年开始，以1980年结束，就像我们的数据集一样。
- en: Finally, we use `fig.automft_xdate()` to automatically format the tick labels
    on the *x*-axis. It will slightly rotate them and make sure that they are legible.
    The final touch-up is using `plt.tight_layout()` to remove any excess white space
    around the figure.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`fig.automft_xdate()`来自动格式化*x*轴上的刻度标签。它将略微旋转它们，并确保它们可读。最终的调整是使用`plt.tight_layout()`来移除图周围的任何多余空白。
- en: The end result is figure 2.6\. Clearly, this baseline did not yield accurate
    predictions, since the Predicted line is very far from the Test line. Now we know
    that our forecasts are, on average, 70% below the actual EPS for each quarter
    in 1980\. Whereas the EPS in 1980 was consistently above $10, we predicted only
    $4.31 for each quarter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是图2.6。很明显，这个基线并没有产生准确的预测，因为预测线与测试线相距甚远。现在我们知道，我们的预测平均比1980年每个季度的实际EPS低70%。而1980年的EPS始终高于10，我们只预测了每个季度的4.31美元。
- en: '![](../../OEBPS/Images/02-06.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/02-06.png)'
- en: Figure 2.6 Predicting the historical mean as a baseline. You can see that the
    prediction is far from the actual values in the test set. This baseline gives
    a MAPE of 70%.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 预测历史平均值作为基线。你可以看到预测值与测试集中的实际值相差甚远。这个基线给出了70%的MAPE。
- en: Still, what can we learn from it? Looking at our training set, we can see a
    positive trend, as the EPS is increasing over time. This is further supported
    by the trend component coming from the decomposition of our dataset, shown in
    figure 2.7.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们能从中学习到什么？查看我们的训练集，我们可以看到一个正向趋势，因为EPS随时间增加。这一点还得到了我们数据集分解的趋势成分的支持，如图2.7所示。
- en: '![](../../OEBPS/Images/02-07.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/02-07.png)'
- en: Figure 2.7 Trend component of our time series. You can see that we have a positive
    trend in our data, as it increases over time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 我们时间序列的趋势成分。你可以看到我们的数据中有一个正向趋势，因为它随时间增加。
- en: As you we can see, not only do we have a trend, but the trend is not constant
    between 1960 and 1980—it is getting steeper. Therefore, it might be that the EPS
    observed in 1960 is not predictive of the EPS in 1980, because we have a positive
    trend, and EPS values are increasing with time and are doing so at a faster rate.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，不仅存在一个趋势，而且在1960年至1980年之间，这个趋势并不是恒定的——它正在变得更加陡峭。因此，1960年观察到的EPS可能并不能预测1980年的EPS，因为我们有一个正向趋势，EPS值随时间增加，并且增长速度越来越快。
- en: Can you improve our baseline?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你能改进我们的基线吗？
- en: Before moving on to the next section, can you think of a way to improve our
    baseline while still using the mean? Do you think that taking the mean of a shorter
    and more recent period of time would help (from 1970 to 1979, for example)?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一节之前，你能想到一种方法来改进我们的基线，同时仍然使用平均值吗？你认为取较短且较近时期（例如1970年至1979年）的平均值会有帮助吗？
- en: 2.3 Forecasting last year’s mean
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 预测上一年的平均值
- en: The lesson learned from the previous baseline is that earlier values do not
    seem to be predictive of future values in the long term because of the positive
    trend component in our dataset. Earlier values seem to be too small to be representative
    of the new level the EPS reaches toward the end of 1979 and onwards into 1980.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的基线中学到的教训是，由于数据集中的正向趋势成分，早期值似乎在长期内并不能预测未来的值。早期值似乎太小，不能代表1979年末和1980年达到的新EPS水平。
- en: What if we use the mean of the last year in our training set to forecast the
    following year? This means that we would compute the average EPS in 1979 and forecast
    it for each quarter of 1980—the more recent values that have increased over time
    should potentially be closer to what will be observed in 1980\. For now, this
    is simply a hypothesis, so let’s implement this baseline and test it to see how
    it performs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在训练集中使用上一年的平均值来预测下一年，这意味着我们将计算1979年的平均每股收益（EPS），并预测1980年每个季度的EPS。随着时间的推移而增加的更近期的值可能更接近1980年观察到的值。目前，这仅仅是一个假设，所以让我们实现这个基线并测试其性能。
- en: 'Our data is already split into test and train sets (done in section 2.2.1),
    so we can go ahead and calculate the mean of the last year in the train set, which
    corresponds to the last four data points in 1979:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据已经分为测试集和训练集（在2.2.1节中完成），因此我们可以继续计算训练集中上一年的平均值，这对应于1979年的最后四个数据点：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Compute the average EPS for the four quarters of 1979, which are the last
    four data points of the train set.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算训练集最后四个数据点（1979年四个季度）的平均每股收益。
- en: 'This gives us an average EPS of $12.96\. Therefore, we will predict that Johnson
    & Johnson will have an EPS of $12.96 for the four quarters of 1980\. Using the
    same procedure that we used for the previous baseline, we’ll create a new pred_last_yr_mean
    column to hold the mean of last year as our predictions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了平均每股收益为$12.96。因此，我们将预测强生公司1980年四个季度的每股收益为$12.96。使用与之前基线相同的程序，我们将创建一个新的pred_last_yr_mean列来保存去年的平均值作为我们的预测：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, using the `mape` function that we defined earlier, we can evaluate the
    performance of our new baseline. Remember that the first parameter is the observed
    values, which are held in the test set. Then we pass in the predicted values,
    which are in the pred_last_yr_mean column:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用我们之前定义的`mape`函数，我们可以评估新基线的性能。记住，第一个参数是观察值，它们存储在测试集中。然后我们传入预测值，它们在pred_last_yr_mean列中：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This gives us a MAPE of 15.60%. We can visualize our forecasts in figure 2.8.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了15.60%的MAPE。我们可以在图2.8中可视化我们的预测。
- en: '![](../../OEBPS/Images/02-08.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/02-08.png)'
- en: Figure 2.8 Predicting the mean of the last year in the training set (1979) as
    a baseline model. You can see that the prediction is closer to the actual values
    of the test set when compared to the previous baseline that we built in figure
    2.6.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 预测训练集中上一年的平均值（1979年）作为基线模型。你可以看到，与我们在图2.6中构建的先前基线相比，预测值更接近测试集的实际值。
- en: Can you recreate figure 2.8?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你能重新创建图2.8吗？
- en: As an exercise, try to recreate figure 2.8 to visualize the forecasts using
    the mean of the quarters of 1979\. The code should be identical to listing 2.1,
    only this time the predictions are in a different column.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试重新创建图2.8，使用1979年季度的平均值来可视化预测。代码应该与列表2.1相同，只是这次预测值在不同的列中。
- en: This new baseline is a clear improvement over the previous one, even though
    its implementation is just as simple, as we decreased the MAPE from 70% to 15.6%.
    This means that our forecasts deviate from the observed values by 15.6% on average.
    Using the last year’s mean is a good step in the right direction. We want to get
    a MAPE as close to 0% as possible, since that would translate into predictions
    that are closer to the actual values in our forecast horizon.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的基线与先前的基线相比有明显的改进，尽管其实现同样简单，因为我们已经将MAPE从70%降低到15.6%。这意味着我们的预测值平均偏离观察值15.6%。使用上一年的平均值是朝着正确方向迈出的好一步。我们希望将MAPE尽可能接近0%，因为那将意味着我们的预测值更接近我们预测范围内的实际值。
- en: We can learn from this baseline that future values likely depend on past values
    that are not too far back in history. This is a sign of *autocorrelation*, and
    we will dive deep into this subject in chapter 5\. For now, let’s look at another
    baseline that we could develop for this situation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个基线我们可以了解到，未来的值很可能依赖于历史中不太久远的数据。这是一个**自相关**的迹象，我们将在第5章深入探讨这个主题。现在，让我们看看另一种我们可以为这种情况开发的基线。
- en: 2.4 Predicting using the last known value
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 使用最后一个已知值进行预测
- en: Previously we used the mean over different periods to develop a baseline model.
    So far, the best baseline has been the mean of the last recorded year in our training
    set, since it yielded the lowest MAPE. We learned from that baseline that future
    values depend on past values, but not those too far back in time. Indeed, predicting
    the mean EPS from 1960 to 1979 yielded worse forecasts than predicting the mean
    EPS over 1979.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们使用不同时期的平均值来开发基线模型。到目前为止，最好的基线是我们训练集中最后记录的年份的平均值，因为它产生了最低的MAPE。我们从那个基线了解到，未来的值依赖于过去的数据，但不是那些很久远的数据。实际上，从1960年到1979年预测平均EPS的预测比预测1979年的平均EPS要差。
- en: Therefore, we could suppose that using the last known value of the training
    set as a baseline model will give us even better forecasts, which would translate
    to a MAPE closer to 0%. Let’s test that hypothesis.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以假设使用训练集的最后一个已知值作为基线模型将给我们带来更好的预测，这将转化为更接近0%的MAPE。让我们测试这个假设。
- en: 'The first step is to extract the last known value of our train set, which corresponds
    to the EPS recorded for the last quarter of 1979:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是提取我们训练集的最后一个已知值，这对应于1979年最后一个季度的EPS记录：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we retrieve the EPS recorded for the last quarter of 1979, we get a value
    of $9.99\. We will thus predict that Johnson & Johnson will have an EPS of $9.99
    for the four quarters of 1980.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检索1979年最后一个季度的EPS记录时，我们得到一个值为$9.99。因此，我们将预测强生公司1980年四个季度的EPS将为$9.99。
- en: Again, we’ll append a new column called pred_last to hold the predictions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将添加一个名为pred_last的新列来保存预测。
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, using the same MAPE function that we defined earlier, we can evaluate
    the performance of this new baseline model. Again, we pass to the function the
    actual values from the test set and our prediction from the pred_last column of
    `test`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用我们之前定义的相同的MAPE函数，我们可以评估这个新基线模型的表现。再次，我们将测试集中的实际值和`test`的`pred_last`列中的预测传递给函数：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This gives us a MAPE of 30.45%. We can visualize the forecasts in figure 2.9.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个MAPE为30.45%。我们可以在图2.9中可视化预测结果。
- en: '![](../../OEBPS/Images/02-09.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/02-09.png)'
- en: Figure 2.9 Predicting the last known value of the train set as a baseline model.
    We can see that this baseline, with a MAPE of 30.45%, is better than our first
    baseline, but less performant than our second one.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 预测训练集最后一个已知值作为基线模型。我们可以看到，这个基线，MAPE为30.45%，比我们的第一个基线好，但不如第二个基线表现好。
- en: Can you recreate figure 2.9?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你能重新创建图2.9吗？
- en: Try to produce figure 2.9 on your own! As data scientists, it is important for
    us to convey our results in a way that is accessible to people who do not work
    in our domain. Thus, producing plots showing our forecasts is an important skill
    to develop.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己制作图2.9！作为数据科学家，我们传达结果的方式对那些不在我们领域工作的人来说是重要的。因此，制作显示我们预测的图表是一项重要的技能。
- en: It seems that our new hypothesis did not improve upon the last baseline that
    we built, since we have a MAPE of 30.45%, whereas we achieved a MAPE of 15.60%
    using the mean EPS over 1979\. Therefore, these new forecasts are farther from
    the observed values in 1980.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的新假设并没有改进我们构建的最后一个基线，因为我们有一个MAPE为30.45%，而使用1979年的平均EPS我们实现了15.60%的MAPE。因此，这些新的预测比1980年的观察值更远。
- en: This can be explained by the fact that the EPS displays a cyclical behavior,
    where it is high during the first three quarters and then falls at the last quarter.
    Using the last known value does not take the seasonality into account, so we need
    to use another naive forecasting technique to see if we can produce a better baseline.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过EPS显示的周期性行为来解释，它在第一季度和第二季度较高，然后在最后一个季度下降。使用最后一个已知值没有考虑到季节性，因此我们需要使用另一种简单的预测技术来查看我们是否可以产生更好的基线。
- en: 2.5 Implementing the naive seasonal forecast
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 实现简单的季节性预测
- en: 'We considered the trend component for the first two baselines in this chapter,
    but we have not studied another important component from our dataset, which is
    the seasonal component shown in figure 2.10\. There are clear cyclical patterns
    in our data, and that is a piece of information that we could use to construct
    one last baseline: the naive seasonal forecast.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的前两个基线中考虑了趋势成分，但我们还没有研究数据集中另一个重要的成分，即图2.10中显示的季节成分。我们的数据中存在明显的周期性模式，这是我们构建最后一个基线可以使用的信息：朴素季节性预测。
- en: '![](../../OEBPS/Images/02-10.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/02-10.png)'
- en: Figure 2.10 Seasonal component of our time series. We can see periodic fluctuations
    here, which indicate the presence of seasonality.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 时间序列的季节成分。我们可以看到这里存在周期性波动，这表明存在季节性。
- en: The naive seasonal forecast takes the last observed cycle and repeats it into
    the future. In our case, a full cycle occurs in four quarters, so we will take
    the EPS from the first quarter of 1979 and predict that value for the first quarter
    of 1980\. Then we’ll take the EPS from the second quarter of 1979 and predict
    that value for the second quarter of 1980\. This process will be repeated for
    the third and fourth quarters.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 朴素季节性预测将最后一个观察到的周期重复到未来。在我们的例子中，一个完整的周期发生在四个季度中，所以我们将从1979年的第一季度取EPS并预测1980年第一季度的值。然后我们将从1979年的第二季度取EPS并预测1980年第二季度的值。这个过程将重复进行第三和第四季度。
- en: 'In Python, we can implement this baseline by simply taking the last four values
    of the train set, which correspond to the four quarters of 1979, and assigning
    them to the corresponding quarters in 1980\. The following code appends the pred_last_season
    column to hold our predictions from the naive seasonal forecast method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以通过简单地取训练集的最后四个值来实现这个基线，这对应于1979年的四个季度，并将它们分配给1980年的相应季度。以下代码将pred_last_season列附加到我们的预测中，以使用朴素季节性预测方法：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Our predictions are the last four values of our train set, which correspond
    to the quarters of 1979.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的预测是训练集的最后四个值，对应于1979年的各个季度。
- en: 'Then we calculate the MAPE the same way we did in the previous sections:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们以与前面章节相同的方式计算MAPE：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This gives us a MAPE of 11.56%, which is the lowest MAPE from all the baselines
    in this chapter. Figure 2.11 illustrates our forecast compared to the observed
    data in the test set. As an exercise, I strongly suggest that you try to recreate
    it on your own.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了11.56%的MAPE，这是本章所有基线中最低的MAPE。图2.11展示了我们的预测与测试集中观察到的数据相比。作为一个练习，我强烈建议你尝试自己重现它。
- en: As you can see, our naive seasonal forecast resulted in the lowest MAPE of all
    the baselines we built in this chapter. This means that seasonality has a significant
    impact on future values, since repeating the last season into the future yields
    fairly accurate forecasts. Intuitively, this makes sense, because we can clearly
    observe a cyclical pattern being repeated every year in figure 2.11\. Seasonal
    effects will have to be considered when we develop a more complex forecasting
    model for this problem. I will explain in detail how to account for them in chapter
    8.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的朴素季节性预测在本章构建的所有基线中产生了最低的MAPE。这意味着季节性对未来值有显著影响，因为将最后一个季节重复到未来会产生相当准确的预测。直观上，这是有道理的，因为我们可以在图2.11中清楚地观察到每年重复的周期性模式。在开发这个问题的更复杂预测模型时，我们必须考虑季节性影响。我将在第8章详细解释如何考虑它们。
- en: '![](../../OEBPS/Images/02-11.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/02-11.png)'
- en: Figure 2.11 Result of the naive seasonal forecast on the test set. This forecast
    is more similar to the data observed in the test set, and it resulted in the lowest
    MAPE. Clearly, the seasonality of this dataset has an impact on future values,
    and it must be considered when forecasting.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 在测试集上朴素季节性预测的结果。这个预测与测试集中观察到的数据更相似，并且导致了最低的MAPE。显然，这个数据集的季节性对未来值有影响，预测时必须考虑这一点。
- en: 2.6 Next steps
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 下一步
- en: In this chapter, we developed four different baselines for our forecasting project.
    We used the arithmetic mean of the entire training set, the mean of the last year
    in the train set, the last known value of the train set, and a naive seasonal
    forecast. Each baseline was then evaluated on a test set using the MAPE metric.
    Figure 2.12 summarizes the MAPE of each baseline we developed in this chapter.
    As you can see, the baseline using the naive seasonal forecast has the lowest
    MAPE, and therefore the best performance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为我们的预测项目开发了四个不同的基线。我们使用了整个训练集的算术平均值、训练集中最后一年份的平均值、训练集的最后一个已知值，以及一个简单的季节性预测。然后，每个基线都使用MAPE指标在测试集上进行了评估。图2.12总结了本章中我们开发的每个基线的MAPE。如图所示，使用简单季节性预测的基线具有最低的MAPE，因此性能最佳。
- en: '![](../../OEBPS/Images/02-12.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/02-12.png)'
- en: Figure 2.12 The MAPE of the four baselines developed in this chapter. The lower
    the MAPE, the better the baseline; therefore, we’ll choose the naive seasonal
    baseline as our benchmark and compare it to our more complex models.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 本章开发的四个基线的MAPE。MAPE越低，基线越好；因此，我们将选择简单的季节性基线作为我们的基准，并将其与我们的更复杂模型进行比较。
- en: Keep in mind that a baseline model serves as a basis for comparison. We will
    develop more complex models by applying statistical learning or deep learning
    techniques, and when we evaluate our more complex solutions against the test set
    and record our error metrics, we can compare them to those of the baseline. In
    our case, we’ll compare the MAPE from a complex model against the MAPE of our
    naive seasonal forecast. If the MAPE of a complex model is lower than 11.56%,
    then we’ll know that we have a better-performing model.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，基线模型作为比较的基础。我们将通过应用统计学习或深度学习技术来开发更复杂的模型，当我们对测试集进行评估并记录我们的误差指标时，我们可以将它们与基线进行比较。在我们的案例中，我们将比较复杂模型的MAPE与我们的简单季节性预测的MAPE。如果复杂模型的MAPE低于11.56%，那么我们就知道我们有一个性能更好的模型。
- en: There will be special situations in which a time series can only be forecast
    using naive methods. These are special cases where the process moves at random
    and cannot be predicted using statistical learning methods. This means that we
    are in the presence of a random walk—we’ll examine this in the next chapter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些特殊情况下，时间序列只能使用简单方法进行预测。这些是过程随机移动且无法使用统计学习方法预测的特殊情况。这意味着我们处于随机游走的状态——我们将在下一章中探讨这一点。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Time series forecasting starts with a baseline model that serves as a benchmark
    for comparison with more complex models.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列预测从作为更复杂模型比较基准的基线模型开始。
- en: A baseline model is a trivial solution to our forecasting problem because it
    only uses heuristics, or simple statistics, such as the mean.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基线模型是我们预测问题的简单解决方案，因为它只使用了启发式方法或简单的统计，如平均值。
- en: MAPE stands for *mean absolute percentage error*, and it is an intuitive measure
    of how much a predicted value deviates from the actual value.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MAPE代表“平均绝对百分比误差”，它是预测值与实际值偏差的直观度量。
- en: There are many ways to develop a baseline. In this chapter, you saw how to use
    the mean, the last known value, or the last season.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发基线有许多方法。在本章中，你看到了如何使用平均值、最后一个已知值或最后一个季节。
