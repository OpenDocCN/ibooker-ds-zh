- en: Appendix A. React Router 4 basics
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录A. React Router 4基础知识
- en: '*This appendix covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本附录涵盖*'
- en: Using declarative routing in your components
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的组件中使用声明式路由
- en: Using configurable routing to create a single source of truth
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可配置的路由创建单一事实来源
- en: Moving code from React Router 3 lifecycle events into a higher-order component
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将React Router 3的生命周期事件中的代码移动到高阶组件中
- en: Prefetching data in the browser by using a higher-order component
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用高阶组件在浏览器中预取数据
- en: React Router 4 represents a big change in thinking from React Router 3\. It
    moves from a standard static router implementation in which you define your routes
    in a single file to a dynamic implementation in which routes are created within
    React components. This also allows you to move most lifecycle logic out of React
    Router lifecycle methods and into React’s lifecycle. Let’s start by reviewing
    how you switch your components over to use React Router’s decentralized routing
    pattern. The code examples in this appendix assume you’ve reviewed the React Router
    3 version and want to see the differences. Each listing assumes that code presented
    in the related chapter is familiar to you. I’ve listed new code in bold.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 4代表了从React Router 3到的一种重大思维转变。它从在单个文件中定义路由的标准静态路由实现，转变为在React组件内部创建路由的动态实现。这也允许您将大多数生命周期逻辑从React
    Router的生命周期方法中移出，并放入React的生命周期中。让我们首先回顾一下如何将您的组件切换到使用React Router的去中心化路由模式。本附录中的代码示例假设您已审查了React
    Router 3版本，并想查看差异。每个列表都假设您熟悉相关章节中展示的代码。我已将新代码以粗体列出。
- en: A.1\. Browser-only routing with React Router 4
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1\. 使用React Router 4进行仅浏览器路由
- en: In this section, I’ll walk you through making routes work in a single-page application
    (SPA) architecture so you understand the basics of React Router 4\. The code for
    the examples in this section can be found in the repo for the complete isomorphic
    example at [http://mng.bz/zRGa](http://mng.bz/zRGa). The code can also be found
    in the branch chapter-4-react-router-basic-routes (`git checkout chapter-4-react-router-basic-routes`).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示如何在单页应用程序（SPA）架构中使路由工作，以便您理解React Router 4的基本原理。本节中示例的代码可以在[http://mng.bz/zRGa](http://mng.bz/zRGa)的完整同构示例仓库中找到。代码也可以在分支chapter-4-react-router-basic-routes中找到（`git
    checkout chapter-4-react-router-basic-routes`）。
- en: 'First, you need to install the React Router 4 packages to have the correct
    code for this section. React Router now follows the React convention of separating
    DOM-related code into its own package. Make sure to upgrade react-router and install
    react-router-dom:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装React Router 4包，以便为本节提供正确的代码。React Router现在遵循React的约定，将DOM相关的代码分离到其自己的包中。请确保升级react-router并安装react-router-dom：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After you’ve done this, you need to set up React Router in main.jsx.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成此操作后，您需要在main.jsx中设置React Router。
- en: A.1.1\. Creating the app
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.1.1\. 创建应用程序
- en: The way you instantiate the main Router is slightly different in React Router
    4 than in it was in version 3\. Instead of taking the router and passing in routes
    and history, you pick the router that’s appropriate to the use case. In this case,
    you want to use `BrowserRouter` so you can take advantage of the browser history
    API in your app. The following listing shows how to change the code in main.jsx
    to work with React Router 4.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Router 4中实例化主路由的方式与版本3略有不同。不是将路由和历史传递给路由器，而是选择适合用例的路由器。在这种情况下，您想使用`BrowserRouter`以便在您的应用程序中利用浏览器历史API。以下列表显示了如何更改main.jsx中的代码以与React
    Router 4一起工作。
- en: Listing A.1\. Set up the router—main.jsx
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.1\. 设置路由器—main.jsx
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Uses the BrowserRouter component as the root component**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用BrowserRouter组件作为根组件**'
- en: '***2* App should be the child of BrowserRouter. You’ll put the routes into
    the App component.**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* App应该是BrowserRouter的子组件。您将把路由放入App组件中。**'
- en: Even though you’ve instantiated the router, you still need to update your components
    to handle the routes. The next section walks you through how to do this.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您已实例化了路由器，但您仍需要更新您的组件以处理路由。下一节将向您展示如何做到这一点。
- en: A.1.2\. Routing in components
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.1.2\. 组件中的路由
- en: The basics of React Router 4 are similar to those of React Router 3\. You declare
    your routes using a Route component. You give it a path and a component to render.
    The big change is in where you declare your routes. In version 3, you have a single,
    centralized routes file. In version 4, you declare your routes inside the appropriate
    component. The following listing shows how you’d take the routes from the sharedRoutes.jsx
    file and put them in app.jsx instead.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 4 的基础知识与 React Router 3 类似。你使用 Route 组件来声明你的路由。你给它一个路径和一个要渲染的组件。最大的变化在于你声明路由的位置。在版本
    3 中，你有一个单一的、集中的路由文件。在版本 4 中，你在适当的组件内部声明你的路由。以下列表显示了如何将 sharedRoutes.jsx 文件中的路由放入
    app.jsx 中。
- en: Listing A.2\. Declare the routes—components/app.jsx
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.2\. 声明路由—components/app.jsx
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Imports the Route component and the withRouter higher-order component**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 Route 组件和 withRouter 高阶组件**'
- en: '***2* Imports the various app components used in the routes**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入在路由中使用的各种应用组件**'
- en: '***3* For paths that would result in multiple matches, make sure to use the
    exact option.**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 对于会导致多个匹配的路径，请确保使用精确选项。**'
- en: '***4* Each Route takes a path and a component.**'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 每个 Route 都需要一个路径和一个组件。**'
- en: '***5* Wraps App in the HOC withRouter. This ensures your components have access
    to the history and location props.**'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用 HOC withRouter 包装 App。这确保你的组件可以访问历史和位置属性。**'
- en: Now that you’ve moved the routes to the correct place, your app works! Note
    that the Link component works the same way in both versions. You declare a link
    by providing the Link component a `to` prop.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将路由移动到正确的位置，你的应用就可以工作了！注意，Link 组件在两个版本中工作方式相同。你通过为 Link 组件提供一个 `to` 属性来声明一个链接。
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'In React Router 3, you could define a parent route with `/` and then define
    the child routes without the leading slash (for example, `products`). This is
    no longer supported. Instead, on a parent route, you need to use the `exact` option.
    For your root route `/`, you’ll want to set `exact: true`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '在 React Router 3 中，你可以使用 `/` 定义一个父路由，然后定义子路由时不需要前面的斜杠（例如，`products`）。这不再被支持。相反，在父路由上，你需要使用
    `exact` 选项。对于你的根路由 `/`，你希望设置 `exact: true`。'
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Next, you’ll learn how to create routes in a way that works well for an isomorphic
    app.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何以适合同构应用的方式创建路由。
- en: A.2\. Creating a single source of truth
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2\. 创建单一的真实来源
- en: Now that you have React Router 4 working in the app, let’s apply the same principles
    that you applied in React Router 3; the goal is to have a single source of truth
    for your routes. All the code in this section can be found in the branch chapter-4-react-router-v4
    (`git checkout chapter-4-react-router-v4`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在应用中使用了 React Router 4，让我们应用你在 React Router 3 中应用过的相同原则；目标是让你的路由有一个单一的真实来源。本节中所有的代码都可以在分支
    chapter-4-react-router-v4 中找到（`git checkout chapter-4-react-router-v4`）。
- en: 'You need a way to define your routes in a single object that can be used right
    now in the browser and again later on the server. The good news is that the React
    Router creators have created a beta library for addressing this problem: React
    Router Config ([http://mng.bz/33Vu](http://mng.bz/33Vu)). This is a utility library
    that provides two functions for you to use to make server rendering and matching
    easier:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一种方法来定义你的路由，这个路由可以在浏览器中立即使用，也可以在服务器端稍后使用。好消息是 React Router 的创建者已经创建了一个用于解决这个问题的测试版库：React
    Router Config ([http://mng.bz/33Vu](http://mng.bz/33Vu))。这是一个提供两个函数的实用库，你可以使用这些函数来简化服务器渲染和匹配：
- en: '**`matchRoutes(routes, pathname)`—** Determines whether the current route matches
    one of the routes in the provided configuration.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`matchRoutes(routes, pathname)`—** 确定当前路由是否与提供的配置中的某个路由匹配。'
- en: '**`renderRoutes(routes, extraProps)`—** Renders the provided routes into the
    component where the function is called. This method must be used instead of the
    Route component to ensure that the browser render matches the server-side render.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`renderRoutes(routes, extraProps)`—** 将提供的路由渲染到函数被调用的组件中。此方法必须用于替代 Route
    组件，以确保浏览器渲染与服务器端渲染匹配。'
- en: 'Install this library so you can import it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这个库，以便你可以导入它：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, you’ll set up your routes with a configuration object instead of declaring
    them in the App component directly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用配置对象设置你的路由，而不是直接在 App 组件中声明它们。
- en: A.2.1\. Routes as config
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.2.1\. 路由作为配置
- en: Rather than declare the routes in the App component as subcomponents, you’ll
    now create a JavaScript object that represents the routes. As with React Router
    3, you’ll do this in a sharedRoutes file. So that you can differentiate and compare,
    I’ve called this file sharedRoutesv4.jsx.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与在 App 组件中将路由声明为子组件不同，你现在将创建一个代表路由的 JavaScript 对象。与 React Router 3 一样，你将在 sharedRoutes
    文件中这样做。为了区分和比较，我称此文件为 sharedRoutesv4.jsx。
- en: The following listing shows the code that makes up this module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了构成此模块的代码。
- en: Listing A.3\. Route configuration—shared/sharedRoutesv4.es6
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.3\. 路由配置—shared/sharedRoutesv4.es6
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Imports the components used in the routes**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入在路由中使用的组件**'
- en: '***2* Declares your root component**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明你的根组件**'
- en: '***3* Declares the subroutes in the routes array for the App component**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在 App 组件的路由数组中声明子路由**'
- en: '***4* You can still declare the exact option by adding this property.**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 你仍然可以通过添加此属性来声明精确选项。**'
- en: '***5* Every route has a path and a component.**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 每个路由都有一个路径和一个组件。**'
- en: '***6* Every route has a path and a component.**'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 每个路由都有一个路径和一个组件。**'
- en: Now that you’ve declared your routes, you need to use this route configuration
    instead of the Route components from the previous section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经声明了你的路由，你需要使用这个路由配置而不是上一节中的 Route 组件。
- en: A.2.2\. Configuring the routes in the components
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.2.2\. 在组件中配置路由
- en: Using the React Router Config library, you can easily set up your app to use
    the routes from the previous section. To get everything working properly, you
    need to call the `renderRoutes` function from this library in main.jsx and in
    your top-level App component. The following listing shows how to declare this
    function in main.jsx.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 React Router Config 库，你可以轻松地将你的应用程序配置为使用上一节中的路由。为了使一切正常工作，你需要在 main.jsx 和你的顶级
    App 组件中调用此库中的 `renderRoutes` 函数。以下列表显示了如何在 main.jsx 中声明此函数。
- en: Listing A.4\. Use the configured routes—main.jsx
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.4\. 使用配置的路由—main.jsx
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Imports renderRoutes**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 renderRoutes**'
- en: '***2* Imports the route configuration object**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入路由配置对象**'
- en: '***3* Calls renderRoutes and passes in the routes configuration. This replaces
    the App component declaration.**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 调用 renderRoutes 并传入路由配置。这替换了 App 组件的声明。**'
- en: Next you need to also declare these routes inside the App component—you need
    to declare routes anytime you have a component that has subroutes. This replaces
    the Route component declarations you made previously. The following listing shows
    how to update the code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你还需要在 App 组件内部声明这些路由——每次你有具有子路由的组件时，你都需要声明路由。这替换了之前你做的 Route 组件声明。以下列表显示了如何更新代码。
- en: Listing A.5\. Use the configured routes—components/app.jsx
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.5\. 使用配置的路由—components/app.jsx
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Imports renderRoutes**'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 renderRoutes**'
- en: '***2* Calls renderRoutes. Passes in the routes object provided via props because
    you declared them in main.jsx.**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用 renderRoutes。通过属性传入提供的路由对象，因为你在 main.jsx 中声明了它们。**'
- en: '***3* Passes the history object in as a prop so child components have access
    as needed.**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将历史对象作为属性传递，以便子组件在需要时可以访问。**'
- en: At this point, your routes should work as expected. Next we’ll review the changes
    to the React lifecycle.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的路由应该按预期工作。接下来，我们将回顾 React 生命周期的更改。
- en: A.3\. Handling lifecycle events
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3\. 处理生命周期事件
- en: Another major change between React Router 3 and 4 is the way lifecycle events
    are handled. In React Router 3, the Router had its own independent lifecycle.
    You had to manage React’s lifecycle and React Router’s lifecycle, which often
    became complex. You added code in the sharedRoutes file that handled code that
    happens at specific points in the lifecycle. Now you need to do that in a different
    way.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 3 和 4 之间的另一个主要变化是处理生命周期事件的方式。在 React Router 3 中，Router 有它自己的独立生命周期。你必须管理
    React 的生命周期和 React Router 的生命周期，这通常变得很复杂。你在 sharedRoutes 文件中添加了代码来处理生命周期中的特定点的代码。现在你需要以不同的方式来做这件事。
- en: In React Router 4, you use React’s lifecycle to do updates based on the route
    changing. A good way to facilitate this is to create a higher-order component
    (HOC).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Router 4 中，你使用 React 的生命周期根据路由变化来进行更新。一种促进这种更新方式的好方法是创建一个高阶组件（HOC）。
- en: A.3.1\. Using higher-order components to manage route changes
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.3.1\. 使用高阶组件来管理路由更改
- en: To create your own higher-order component, you create a function that returns
    a React component. Then you can hook into the React lifecycle and do updates based
    on the route changing. The following listing shows how to do this. It includes
    the example from [chapter 4](kindle_split_015_split_000.xhtml#ch04), where you
    add page tracking on every update.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自己的高阶组件，你创建一个返回 React 组件的函数。然后你可以挂钩到 React 生命周期并根据路由更改进行更新。以下列表展示了如何做这件事。它包括第
    4 章的示例，其中在每次更新时添加页面跟踪。
- en: Listing A.6\. `onRouteChange` higher-order component—components/onRouteChange.jsx
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.6\. `onRouteChange` 高阶组件—components/onRouteChange.jsx
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Creates a function that takes in a component**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个接受组件的函数**'
- en: '***2* This function represents tracking a page view.**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这个函数代表跟踪页面视图。**'
- en: '***3* Calls the trackPageView function from componentDidMount. This replaces
    the onEnter call in the old sharedRoutes file.**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在 componentDidMount 中调用 trackPageView 函数。这替换了旧 sharedRoutes 文件中的 onEnter
    调用。**'
- en: '***4* Checks whether the route has changed**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 检查路由是否已更改**'
- en: '***5* Calls trackPageView if the route has changed. Calling it in componentWillReceiveProps
    replaces the onChange call in the old sharedRoutes file.**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果路由已更改，则调用 trackPageView。在 componentWillReceiveProps 中调用它替换了旧 sharedRoutes
    文件中的 onChange 调用。**'
- en: After you’ve created this HOC, you need to use it in your root component, App.
    The following listing shows how to import and apply it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了这个高阶组件（HOC）之后，你需要在根组件 App 中使用它。以下列表展示了如何导入和应用它。
- en: Listing A.7\. Use the configured routes—components/app.jsx
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.7\. 使用配置的路由—components/app.jsx
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Imports onRouteChange**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 onRouteChange**'
- en: '***2* To have the onRouteChange HOC manage your routes, you need to wrap your
    root component with it.**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为了让 onRouteChange HOC 管理你的路由，你需要用它在根组件周围包裹。**'
- en: Now that you’ve wrapped the root component in `onRouteChange`, you can easily
    add the code to prefetch data when navigating around the app.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你在 `onRouteChange` 中包裹了根组件，你可以轻松地添加代码来在应用程序中导航时预取数据。
- en: A.3.2\. Prefetching the data for the view
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.3.2\. 预取视图数据
- en: '[Chapter 8](kindle_split_020_split_000.xhtml#ch08) teaches you how to prefetch
    the data when navigating around the site in the browser. With the removal of React
    Router lifecycle events in version 4, you need to take a different approach. This
    is handled the same way you handle page-tracking events in the previous section.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 8 章](kindle_split_020_split_000.xhtml#ch08) 介绍了如何在浏览器中导航网站时预取数据。随着 React
    Router 4 版本中生命周期事件的移除，你需要采取不同的方法。这和之前章节中处理页面跟踪事件的方式相同。'
- en: The code for this example can be found on GitHub (`git checkout chapter-8-complete-react-router-4`).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的代码可以在 GitHub 上找到（`git checkout chapter-8-complete-react-router-4`）。
- en: The following listing shows how to prefetch data in the browser when navigating
    between routes. It uses the `onRouteChange` HOC you created in the previous section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何在导航不同路由之间时在浏览器中预取数据。它使用了之前章节中创建的 `onRouteChange` HOC。
- en: Listing A.8\. Prefetch the data—components/onRouteChange.jsx
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.8\. 预取数据—components/onRouteChange.jsx
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Imports matchRoutes so you can pull out all the components used in the
    current route. Gets the routes from the configured routes in sharedRoutesv4.**'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 matchRoutes 以提取当前路由中使用的所有组件。从 sharedRoutesv4 中配置的路由获取路由。**'
- en: '***2* Calls matchRoutes with the routes and location from props**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 props 中的路由和位置调用 matchRoutes**'
- en: '***3* Iterates over each item in the matches array. This represents each component
    being rendered on this route—anything you declared in sharedRoutesv4.**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 遍历 matches 数组中的每个项目。这代表在这个路由上渲染的每个组件——在 sharedRoutesv4 中声明的任何内容。**'
- en: '***4* This block is almost identical to the one in [chapter 7](kindle_split_019_split_000.xhtml#ch07).
    You look for the base component and call prefetchActions if the function exists.**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 这个块几乎与 [第 7 章](kindle_split_019_split_000.xhtml#ch07) 中的相同。你寻找基本组件，如果函数存在，则调用
    prefetchActions。**'
- en: '***5* The major difference is you have to handle the case where you wrapped
    App in two HOCs.**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 主要区别是你必须处理将 App 包裹在两个 HOC 中的情况。**'
- en: '***6* Flattens the results of getting the actions into a single array**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将获取动作的结果扁平化成一个单一数组**'
- en: '***7* Gets ready to execute the actions by passing them into the dispatch function
    from Redux**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 通过将它们传递到 Redux 的 dispatch 函数中，准备执行动作**'
- en: '***8* Call of the actions**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 调用动作**'
- en: '***9* You call the fetchData function from componentWillReceiveProps, so it
    will run every time except the initial load.**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 你在componentWillReceiveProps中调用fetchData函数，所以除了初始加载外，它将每次运行。**'
- en: Because you’re using `dispatch` in the preceding code, you need to wrap your
    App component with the connect HOC. The following listing shows how to do this.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你在前面的代码中使用了`dispatch`，所以你需要将App组件包裹在connect高阶组件（HOC）中。下面的列表显示了如何做到这一点。
- en: Listing A.9\. Use the configured routes—components/app.jsx
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.9\. 使用配置的路由—组件/app.jsx
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Imports connect**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入connect**'
- en: '***2* To have access to the dispatch function in onRouteChange, you must first
    wrap it in the connect HOC.**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 要在onRouteChange中访问dispatch函数，你必须首先将其包裹在connect高阶组件（HOC）中。**'
- en: Now the app will run! It prefetches the data when needed. Try navigating from
    /products to /cart to see this in action.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用将运行！它会在需要时预取数据。尝试从/products导航到/cart来查看这一功能的效果。
