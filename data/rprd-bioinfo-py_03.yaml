- en: 'Chapter 2\. Transcribing DNA into mRNA: Mutating Strings, Reading and Writing
    Files'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。将DNA转录为mRNA：突变字符串，读写文件
- en: 'To express the proteins necessary to sustain life, regions of DNA must be transcribed
    into a form of RNA called *messenger RNA* (mRNA). While there are many fascinating
    biochemical differences between DNA and RNA, for our purposes the only difference
    is that all the characters *T* representing the base thymine in a sequence of
    DNA need to be changed to the letter *U*, for uracil. As described on [the Rosalind
    RNA page](https://oreil.ly/9Dddm), the program I’ll show you how to write will
    accept a string of DNA like `ACGT` and print the transcribed mRNA `ACGU`. I can
    use Python’s `str.replace()` function to accomplish this in one line:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表达维持生命所必需的蛋白质，DNA区域必须被转录成一种称为*messenger RNA*（mRNA）的RNA形式。虽然DNA和RNA之间有许多迷人的生化差异，但就我们的目的而言，唯一的区别是DNA序列中代表嘧啶碱基的所有*T*字符需要更改为尿嘧啶字母*U*。正如在[Rosalind
    RNA页面](https://oreil.ly/9Dddm)上所描述的那样，我将向您展示如何编写一个接受像`ACGT`这样的DNA字符串并打印转录mRNA
    `ACGU`的程序。我可以使用Python的`str.replace()`函数在一行中完成这个任务：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You already saw in [Chapter 1](ch01.html#ch01) how to write a program to accept
    a DNA sequence from the command line or a file and print a result, so you won’t
    be learning much if you do that again. I’ll make this program more interesting
    by tackling a very common pattern found in bioinformatics. Namely, I’ll show how
    to process one or more input files and place the results in an output directory.
    For instance, it’s pretty common to get the results of a sequencing run back as
    a directory of files that need to be quality checked and filtered, with the cleaned
    sequences going into some new directory for your analysis. Here the input files
    contain DNA sequences, one per line, and I’ll write the mRNA sequences into like-named
    files in an output directory.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在[第1章](ch01.html#ch01)中看到如何编写一个从命令行或文件接受DNA序列并打印结果的程序，因此如果再次这样做，您不会学到太多新东西。我将通过解决生物信息学中常见的模式来使这个程序更有趣。具体来说，我将展示如何处理一个或多个输入文件，并将结果放置在输出目录中。例如，将测序运行的结果作为包含需要进行质量检查和过滤的文件目录返回，将清理后的序列放入新的目录进行分析。这里的输入文件包含DNA序列，每行一个，我将mRNA序列写入到同名文件中。
- en: 'In this chapter, you will learn:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: How to write a program to require one or more file inputs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写一个需要一个或多个文件输入的程序
- en: How to create directories
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建目录
- en: How to read and write files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何读写文件
- en: How to modify strings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何修改字符串
- en: Getting Started
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'It might help to try running one of the solutions first to see how your program
    should work. Start by changing into the *02_rna* directory and copying the first
    solution to the program `rna.py`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有所帮助，先尝试运行其中一个解决方案，看看程序应该如何工作。首先切换到*02_rna*目录，并将第一个解决方案复制到程序`rna.py`：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Request the usage for the program using the `-h` flag:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-h`标志请求程序的用法：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO1-1)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO1-1)'
- en: The arguments surrounded by square brackets (`[]`) are optional. The `[FILE
    ...]` syntax means that this argument can be repeated.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 用方括号（`[]`）括起来的参数是可选的。`[FILE ...]`语法表示可以重复使用该参数。
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO1-2)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO1-2)'
- en: The input `FILE` argument(s) will be positional.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`FILE`参数将是位置参数。
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO1-3)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO1-3)'
- en: The optional output directory has the default value of `out`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的输出目录默认为*out*。
- en: 'The goal of the program is to process one or more files, each containing sequences
    of DNA. Here is the first test input file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的目标是处理一个或多个包含DNA序列的文件。以下是第一个测试输入文件：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the `rna.py` program with this input file, and note the output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`rna.py`程序，使用此输入文件，并注意输出：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now there should be an *out* directory containing a file called *input1.txt*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该有一个名为*out*的目录，其中包含一个名为*input1.txt*的文件：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The contents of that file should match the input DNA sequence but with all
    the *T*s changed to *U*s:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的内容应与输入的DNA序列匹配，但所有的*T*都应更改为*U*：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should run the program with multiple inputs and verify that you get multiple
    files in the output directory. Here I will use all the test input files with an
    output directory called *rna*. Notice how the summary text uses the correct singular/plurals
    for *sequence(s)* and *file(s)*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该使用多个输入运行程序，并验证您在输出目录中获取多个文件。在这里，我将使用所有测试输入文件，输出目录称为*rna*。请注意摘要文本如何使用*序列*和*文件*的正确单数/复数形式：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'I can use the `wc` (word count) program with the `-l` option to count the *lines*
    in the output file and verify that five sequences were written to three files
    in the *rna* directory:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用带有`-l`选项的`wc`（单词计数）程序来计算输出文件中的*行*数，并验证*rna*目录中是否写入了五个序列到三个文件：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Defining the Program’s Parameters
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义程序的参数
- en: 'As you can see from the preceding usage, your program should accept the following
    parameters:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的使用情况所见，您的程序应接受以下参数：
- en: One or more positional arguments, which must be readable text files each containing
    strings of DNA to transcribe.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个位置参数，必须是每个包含要转录的DNA字符串的可读文本文件。
- en: An optional `-o` or `--out_dir` argument that names an output directory to write
    the sequences of RNA into. The default should be `out`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`-o`或`--out_dir`参数，用于命名一个输出目录以将RNA序列写入其中。默认值应为`out`。
- en: 'You are free to write and structure your programs however you like (so long
    as they pass the tests), but I will always start a program using **`new.py`**
    and the structure I showed in the first chapter. The `--force` flag indicates
    that the existing `rna.py` should be overwritten:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自由编写和结构化您的程序（只要它们通过测试），但我总是会使用**`new.py`**和我在第一章展示的结构来启动程序。`--force`标志表示应覆盖现有的`rna.py`：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Defining an Optional Parameter
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个可选参数
- en: 'Modify the `get_args()` function to accept the parameters described in the
    previous section. To start, define the `out_dir` parameter. I suggest you change
    the `-a|--arg` option generated by `new.py` to this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`get_args()`函数以接受前面部分描述的参数。首先定义`out_dir`参数。我建议您将由`new.py`生成的`-a|--arg`选项更改为以下内容：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-1)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-1)'
- en: This is the short flag name. Short flags start with a single dash and are followed
    by a single character.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是短标志名称。短标志以单个破折号开头，后跟单个字符。
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-2)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-2)'
- en: This is the long flag name. Long flags start with two dashes and are followed
    by a more memorable string than the short flag. This will also be the name `argparse`
    will use to access the value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是长标志名称。长标志以两个破折号开头，后跟比短标志更易记的字符串。这也将是`argparse`用来访问值的名称。
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-3)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-3)'
- en: This will be incorporated into the usage statement to describe the argument.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包含在使用说明中，以描述该参数。
- en: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-4)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-4)'
- en: The `metavar` is a short description also shown in the usage.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`metavar`也是在使用中显示的简短描述。'
- en: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-5)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-5)'
- en: The default type of all arguments is `str` (string), so this is technically
    superfluous but still not a bad idea to document.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参数的默认类型都是`str`（字符串），因此这在技术上是多余的，但仍然是记录文档的一个好主意。
- en: '[![6](assets/6.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-6)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-6)'
- en: The default value will be the string `out`. If you do not specify a `default`
    attribute when defining an option, the default value will be `None`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在定义选项时未指定`default`属性，则默认值将为`None`。
- en: Defining One or More Required Positional Parameters
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个或多个必需的位置参数
- en: 'For the `FILE` value(s), I can modify the default `-f|--file` parameter to
    look like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`FILE`值，我可以修改默认的`-f|--file`参数如下：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO3-1)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO3-1)'
- en: Remove the `-f` short flag and the two dashes from `--file` so that this becomes
    a *positional* argument called `file`. Optional parameters start with dashes,
    and positional ones do not.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 移除`-f`短标记和`--file`中的两个破折号，使其成为一个*位置*参数称为`file`。可选参数以破折号开头，位置参数不会。
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO3-2)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO3-2)'
- en: The `help` string indicates the argument should be one or more files containing
    DNA sequences.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`help`字符串指示参数应为一个或多个包含DNA序列的文件。'
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO3-3)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO3-3)'
- en: This string is printed in the short usage to indicate the argument is a file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此字符串在简短的使用说明中打印，表示该参数是一个文件。
- en: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO3-4)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO3-4)'
- en: This indicates the number of arguments. The `+` indicates that one or more values
    are required.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明参数的数量。`+`表示需要一个或多个值。
- en: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO3-5)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO3-5)'
- en: This is the actual type that `argparse` will enforce. I am requiring any value
    to be a readable text (`rt`) file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`argparse`将强制执行的实际类型。我要求任何值都必须是可读的文本（`rt`）文件。
- en: Using nargs to Define the Number of Arguments
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用nargs定义参数的数量
- en: I use `nargs` to describe the *number of arguments* to the program. In addition
    to using an integer value to describe exactly how many values are allowed, I can
    use the three symbols shown in [Table 2-1](#table_2.1).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`nargs`来描述程序接受的*参数数量*。除了使用整数值来准确描述允许的数目外，还可以使用[Table 2-1](#table_2.1)中显示的三个符号。
- en: Table 2-1\. Possible values for `nargs`
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. `nargs`的可能值
- en: '| Symbol | Meaning |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 意义 |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `?` | Zero or one |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 零个或一个 |'
- en: '| `*` | Zero or more |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 零个或多个 |'
- en: '| `+` | One or more |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 一个或多个 |'
- en: When you use `+` with `nargs`, `argparse` will provide the arguments as a list.
    Even if there is just one argument, you will get a list containing one element.
    You will never have an empty list because at least one argument is required.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在`nargs`中使用`+`时，`argparse`将提供参数作为一个列表。即使只有一个参数，也会得到包含一个元素的列表。您永远不会得到空列表，因为至少需要一个参数。
- en: Using argparse.FileType() to Validate File Arguments
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用argparse.FileType()验证文件参数
- en: 'The `argparse.FileType()` function is incredibly powerful, and using it can
    save you loads of time in validating file inputs. When you define a parameter
    with this type, `argparse` will print an error message and halt the execution
    of the program if any of the arguments is not a file. For instance, I would assume
    there is no file in your *02_dna* directory called *blargh*. Notice the result
    when I pass that value:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparse.FileType()`函数非常强大，使用它可以节省大量验证文件输入的时间。当您使用此类型定义参数时，如果任何参数不是文件，`argparse`将打印错误消息并停止程序的执行。例如，我会假设在您的*02_dna*目录中没有名为*blargh*的文件。请注意当我传递该值时的结果：'
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It’s not obvious here, but the program never made it out of the `get_args()`
    function because `argparse` did the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里并不明显，但程序从未跳出`get_args()`函数，因为`argparse`执行了以下操作：
- en: Detected that *blargh* is not a valid file
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测到*blargh*不是一个有效的文件
- en: Printed the short usage statement
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印了简短的使用说明
- en: Printed a useful error message
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印了一个有用的错误消息
- en: Exited the program with a nonzero value
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用非零值退出程序
- en: This is how a well-written program ought to work, detecting and rejecting bad
    arguments as soon as possible and notifying the user of the problems. All this
    happened without my writing anything more than a good description of the kind
    of argument I wanted. Again, the best code is code you never write (or as Elon
    Musk puts it, “The best part is no part, the best process is no process.”)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一个良好编写的程序应该如何工作，尽快检测和拒绝不良参数，并通知用户出现的问题。所有这些都是在我仅仅描述所需参数类型的情况下发生的。再次强调，最好的代码是您根本不需要编写的代码（或者像埃隆·马斯克说的那样，“最好的零件是没有零件，最好的流程是没有流程。”）
- en: Because I am using the file *type*, the elements of the list will not be strings
    representing the filenames but will instead be open filehandles. A *filehandle*
    is a mechanism to read and write the contents of a file. I used a filehandle in
    the last chapter when the DNA argument was a filename.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我使用了文件*类型*，列表的元素不会是表示文件名的字符串，而是打开的文件句柄。文件句柄是读写文件内容的机制。在上一章节中，当DNA参数是文件名时，我使用了文件句柄。
- en: The order in which you define these parameters in your source code does not
    matter in this instance. You can define options before or after positional parameters.
    The order only matters when you have multiple positional arguments—the first parameter
    will be for the first positional argument, the second parameter for the second
    positional argument, and so forth.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码中定义这些参数的顺序在此情况下并不重要。您可以在位置参数之前或之后定义选项。只有当您有多个位置参数时，顺序才重要——第一个参数将用于第一个位置参数，第二个参数用于第二个位置参数，依此类推。
- en: Defining the Args Class
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义`Args`类
- en: 'Finally, I need a way to define the `Args` class that will represent the arguments:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我需要一种方法来定义`Args`类，以表示参数：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO4-1)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO4-1)'
- en: I’ll need two new imports from the `typing` module, `List` to describe a list,
    and `TextIO` for an open filehandle.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我将需要从`typing`模块导入两个新项，`List`用于描述列表，`TextIO`用于打开文件句柄。
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO4-2)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO4-2)'
- en: The `files` attribute will be a list of open filehandles.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`files`属性将是一个打开的文件句柄列表。'
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO4-3)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO4-3)'
- en: The `out_dir` attribute will be a string.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`out_dir`属性将是一个字符串。'
- en: 'I can use this class to create the return value from `get_args()`. The following
    syntax uses positional notation such that the `file` is the first field and the
    `out_dir` is the second. When there are one or two fields, I will tend to use
    the positional notation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用这个类来创建从`get_args()`返回的值。以下语法使用位置表示法，使得`file`是第一个字段，`out_dir`是第二个字段。当有一个或两个字段时，我倾向于使用位置表示法：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Explicitly using the field names is safer and arguably easier to read, and
    it will become vital when I have more fields:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 明确地使用字段名称更安全，而且在我有更多字段时，可能更容易阅读，也会变得至关重要：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now I have all the code to define, document, and validate the inputs. Next,
    I’ll show how the rest of the program should work.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经具备了定义、记录和验证输入的所有代码。接下来，我将展示程序的其余部分应该如何工作。
- en: Outlining the Program Using Pseudocode
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用伪代码概述程序：
- en: 'I’ll sketch out the basics of the program’s logic in the `main()` function
    using a mix of code and pseudocode to generally describe how to handle the input
    and output files. Whenever you get stuck writing a new program, this approach
    can help you see *what* needs to be done. Then you can figure out *how* to do
    it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在`main()`函数中勾画程序逻辑的基础，使用代码和伪代码混合来概述如何处理输入和输出文件。每当你在编写新程序时遇到困难时，这种方法都可以帮助你看到*需要*做什么。然后你可以找出*如何*做到这一点：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-1)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-1)'
- en: The `os.path.isdir()` function will report if the output directory exists.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path.isdir()`函数将报告输出目录是否存在。'
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-2)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-2)'
- en: The `os.makedirs()` function will create a directory path.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.makedirs()`函数将创建目录路径。'
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-3)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-3)'
- en: Initialize variables for the number of files and sequences written to use in
    the feedback you provide when the program exits.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化变量以记录写入的文件数和序列数，以在程序退出时提供反馈。
- en: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-4)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-4)'
- en: Use a `for` loop to iterate the list of filehandles in `args.files`. The iterator
    variable `fh` helps remind me of the type.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`循环迭代`args.files`列表中的文件句柄。迭代变量`fh`有助于我记住其类型。
- en: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-5)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-5)'
- en: This is pseudocode describing the steps you need to do with each filehandle.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是描述你需要对每个文件处理的伪代码步骤。
- en: '[![6](assets/6.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-6)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-6)'
- en: Print a summary for the user to let them know what happened.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为用户打印一个摘要，让他们知道发生了什么。
- en: The `os.makedirs()` function will create a directory and all the parent directories,
    while the `os.mkdir()` function will fail if the parent directories do not exist.
    I only ever use the first function in my code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.makedirs()` 函数将创建一个目录及其所有父目录，而 `os.mkdir()` 函数将在父目录不存在时失败。我在我的代码中只使用第一个函数。'
- en: If you think you know how to finish the program, feel free to proceed. Be sure
    to run **`pytest`** (or **`make test`**) to ensure your code is correct. Stick
    with me if you need a little more guidance on how to read and write files. I’ll
    tackle the pseudocode in the following sections.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为你知道如何完成程序，请随意继续。确保运行 **`pytest`**（或 **`make test`**）来确保你的代码是正确的。如果你需要关于如何读写文件的更多指导，请跟着我走。接下来我将处理伪代码部分。
- en: Iterating the Input Files
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代输入文件
- en: 'Remember that `args.files` is a `List[TextIO]`, meaning that it is a list of
    filehandles. I can use a `for` loop to visit each element in any iterable in such
    a list:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`args.files` 是一个 `List[TextIO]`，意味着它是一个文件句柄的列表。我可以使用 `for` 循环访问列表中任何可迭代元素：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I’d like to stress here that I chose an iterator variable called `fh` because
    each value is a filehandle. I sometimes see people who always use an iterator
    variable name like `i` or `x` with a `for` loop, but those are not descriptive
    variable names.^([1](ch02.html#idm45963631969784)) I’ll concede that it’s very
    common to use variable names like `n` (for *number*) or `i` (for *integer*) when
    iterating numbers like so:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里强调，我选择了一个迭代器变量称为 `fh`，因为每个值都是文件句柄。我有时看到一些人总是在 `for` 循环中使用像 `i` 或 `x` 这样的迭代器变量名，但这些都不是描述性的变量名。[^1]
    我会承认，在迭代数字时使用像 `n`（代表 *number*）或 `i`（代表 *integer*）这样的变量名是非常常见的，比如：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And I will sometimes use `x` and `xs` (pronounced *exes*) to stand for *one*
    and *many* of some generic value:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我会使用 `x` 和 `xs`（读作 *exes*）来代表某个通用值的 *one* 和 *many*：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Otherwise, it’s very important to use variable names that accurately describe
    the thing they represent.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，非常重要的是使用准确描述它们代表的内容的变量名。
- en: Creating the Output Filenames
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建输出文件名
- en: Per the pseudocode, the first goal is to open an output file. For that, I need
    a filename that combines the name of the output directory with the *basename*
    of the input file. That is, if the input file is *dna/input1.txt* and the output
    directory is *rna*, then the output file path should be *rna/input1.txt*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 根据伪代码，第一个目标是打开一个输出文件。为此，我需要一个文件名，该文件名将输入文件的基本名称与输出目录的名称结合起来。也就是说，如果输入文件是 *dna/input1.txt*，输出目录是
    *rna*，那么输出文件路径应该是 *rna/input1.txt*。
- en: 'The `os` module is used to interact with the operating system (like Windows,
    macOS, or Linux), and the `os.path` module has many handy functions I can use,
    like the `os.path.dirname()` function to get the name of the directory from a
    file path and `os.path.basename()` to get the file’s name (see [Figure 2-1](#fig_2.1)):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`os` 模块用于与操作系统（如Windows、macOS或Linux）交互，而 `os.path` 模块有许多方便的函数可以使用，比如 `os.path.dirname()`
    函数用于从文件路径中获取目录名称和 `os.path.basename()` 函数用于获取文件名称（见 [Figure 2-1](#fig_2.1)）：'
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![mpfb 0201](assets/mpfb_0201.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0201](assets/mpfb_0201.png)'
- en: Figure 2-1\. The `os.path` module contains useful functions like `dirname()`
    and `basename()` to extract parts from a file’s path
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. `os.path` 模块包含诸如 `dirname()` 和 `basename()` 这样的有用函数，用于从文件路径中提取部分
- en: The new sequences will be written to an output file in `args.out_dir`. I suggest
    you use the `os.path.join()` function with the basename of the input file to create
    the output filename, as shown in [Figure 2-2](#fig_2.2). This will ensure that
    the output filename works both on Unix and Windows, which use different path dividers—the
    slash (`/`) and backslash (`\`), respectively. You may also want to investigate
    the `pathlib` module for similar functionality.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 新序列将被写入到 `args.out_dir` 中的输出文件中。我建议您使用 `os.path.join()` 函数与输入文件的基本名称创建输出文件名，如
    [Figure 2-2](#fig_2.2) 所示。这将确保输出文件名在Unix和Windows上都有效，因为它们使用不同的路径分隔符—斜杠 (`/`) 和反斜杠
    (`\`)。您可能还想要研究类似功能的 `pathlib` 模块。
- en: '![mpfb 0202](assets/mpfb_0202.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0202](assets/mpfb_0202.png)'
- en: Figure 2-2\. The `os.path.join()` will create the output path by combining the
    output directory with the basename of the input file
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. `os.path.join()` 将通过将输出目录与输入文件的基本名称组合来创建输出路径
- en: 'You can get the file’s path from the `fh.name` attribute of the filehandle:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从文件句柄的 `fh.name` 属性获取文件路径：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run your program to verify that it looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的程序以验证它是否如下所示：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I’m taking baby steps toward what the program is supposed to do. It’s very important
    to write just one or two lines of code and then run your program to see if it’s
    correct. I often see students try to write many lines of code—whole programs,
    even—before they attempt to run them. That never works out well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我在慢慢向程序应该做什么迈进。写入一两行代码然后运行你的程序来检查它是否正确是非常重要的。我经常看到学生尝试在运行之前写很多行代码 —— 整个程序甚至
    —— 这从来不会有好结果。
- en: Opening the Output Files
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开输出文件
- en: 'Using this output filename, you need to `open()` the filehandle. I used this
    function in the first chapter to read DNA from an input file. By default, `open()`
    will only allow me to read a file, but I need to write a file. I can indicate
    that I want to open the file for writing by passing an optional second argument:
    the string `w` for *write*.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个输出文件名，你需要使用 `open()` 函数。我在第一章中使用了这个函数来从输入文件中读取 DNA。默认情况下，`open()` 只允许我读取文件，但我需要写入文件。我可以通过传递一个可选的第二个参数来指示我想要以写入方式打开文件：字符串
    `w` 代表*写入*。
- en: When you open an existing file with a mode of `w`, the file will be *overwritten*,
    meaning its previous contents will be immediately and permanently lost. If needed,
    you can use the `os.path.isfile()` function to check if you’re opening an existing
    file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用 `w` 模式打开现有文件时，文件将会*被覆盖*，这意味着其先前的内容会立即且永久丢失。如果需要，你可以使用 `os.path.isfile()`
    函数来检查你是否打开了一个已存在的文件。
- en: As shown in [Table 2-2](#table_2.2), you can also use the values `r` for *read*
    (the default) and `a` to *append*, which allows you to open for writing more content
    at the end of an existing file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [表 2-2](#table_2.2) 所示，你还可以使用值 `r` 代表*读取*（默认值），使用 `a` 来*追加*，这样可以在现有文件末尾写入更多内容。
- en: Table 2-2\. File writing modes
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2\. 文件写入模式
- en: '| Mode | Meaning |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 含义 |'
- en: '| --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `w` | Write |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `w` | 写入 |'
- en: '| `r` | Read |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `r` | 读取 |'
- en: '| `a` | Append |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 追加 |'
- en: '[Table 2-3](#table_2.3) shows that you can also read and write either text
    or raw bytes using the modes `t` and `b`, respectively.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-3](#table_2.3) 显示你也可以使用 `t` 和 `b` 模式来读取和写入文本或原始字节。'
- en: Table 2-3\. File content modes
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-3\. 文件内容模式
- en: '| Mode | Meaning |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 含义 |'
- en: '| --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `t` | Text |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `t` | 文本 |'
- en: '| `b` | Bytes |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `b` | 字节 |'
- en: 'You can combine these, for example using `rb` to *read bytes* and `wt` to *write
    text*, which is what I want here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以结合使用这些，例如使用 `rb` *读取字节* 和 `wt` *写入文本*，这正是我在这里想要的：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO6-1)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO6-1)'
- en: Note that I named my variable `out_fh` to remind me this is the output filehandle.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我将变量命名为 `out_fh` 是为了提醒自己这是输出文件句柄。
- en: Writing the Output Sequences
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入输出序列
- en: 'Looking at the pseudocode again, I have two levels of iterating—one for each
    filehandle of input, and then one for each line of DNA in the filehandles. To
    read each line from an open filehandle, I can use another `for` loop:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看伪代码，我有两层循环迭代 —— 一个用于每个输入文件句柄，然后一个用于文件句柄中的每行 DNA。要从打开的文件句柄中读取每行，我可以使用另一个
    `for` 循环：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The *input2.txt* file has two sequences, each ending with a newline:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*input2.txt* 文件包含两个序列，每个序列以换行符结尾：'
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To start, I’ll show you how to print each sequence to the console, then I’ll
    demonstrate how to use `print()` to write content to a filehandle. [Chapter 1](ch01.html#ch01)
    mentions that the `print()` function will automatically append a newline (`\n`
    on Unix platforms and `\r\n` on Windows) unless I tell it not to. To avoid having
    two newlines from the following code, one from the sequence and one from `print()`,
    I can either use the `str.rstrip()` function to remove the newline from the sequence
    like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将展示如何将每个序列打印到控制台，然后演示如何使用 `print()` 将内容写入文件句柄。[第 1 章](ch01.html#ch01) 提到
    `print()` 函数将自动追加换行符（在 Unix 平台上是 `\n`，在 Windows 上是 `\r\n`），除非我告诉它不要这样做。为了避免以下代码产生两个换行符，一个来自序列，一个来自
    `print()`，我可以使用 `str.rstrip()` 函数删除序列中的换行符，如下所示：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO7-1)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO7-1)'
- en: Use `dna.rstrip()` to remove the trailing newline.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dna.rstrip()` 去除末尾的换行符。
- en: 'or use the `end` option to `print()`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用 `print()` 的 `end` 选项：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO8-1)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO8-1)'
- en: Use the empty string at the end instead of a newline.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在结尾使用空字符串而不是换行符。
- en: 'The goal is to transcribe each DNA sequence to RNA and write the result to
    `out_fh`. In the introduction to this chapter, I suggested you could use the `str.replace()`
    function. If you read `help(str.replace)` in the REPL, you’ll see that it will
    “Return a copy with all occurrences of substring old replaced by new”:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是将每个DNA序列转录为RNA并将结果写入 `out_fh`。在本章的介绍中，我建议您可以使用 `str.replace()` 函数。如果您在 REPL
    中阅读 `help(str.replace)`，您将看到它将“返回一个将所有出现的旧子字符串替换为新子字符串的副本”：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are other ways to change the *T*s to *U*s that I will explore later.
    First, I’d like to point out that strings in Python are immutable, meaning they
    cannot be changed in place. That is, I could check to see if the letter *T* is
    in the DNA string and then use the `str.index()` function to find the location
    and try to overwrite it with the letter *U*, but this will raise an exception:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法可以将 *T* 更改为 *U*，我稍后会探讨。首先，我想指出，在Python中，字符串是不可变的，这意味着它们不能在原地修改。也就是说，我可以检查DNA字符串中是否有字母
    *T*，然后使用 `str.index()` 函数找到位置并尝试用字母 *U* 覆盖它，但这会引发异常：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Instead, I’ll use `str.replace()` to create a new string:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我将使用 `str.replace()` 创建一个新的字符串：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'I need to write this new string into the `out_fh` output filehandle. I have
    two options. First, I can use the `print()` function’s `file` option to describe
    *where* to print the string. Consult the `help(print)` documentation in the REPL:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要将这个新字符串写入 `out_fh` 输出文件句柄。我有两个选项。首先，我可以使用 `print()` 函数的 `file` 选项来描述 *在哪里*
    打印字符串。在 REPL 中请参阅 `help(print)` 文档：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO9-1)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO9-1)'
- en: This is the option I need to print the string to the open filehandle.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我需要将字符串打印到打开的文件句柄的选项。
- en: I need to use the `out_fh` filehandle as the `file` argument. I want to point
    out that the default `file` value is `sys.stdout`. On the command line, `STDOUT`
    (pronounced *standard out*) is the standard place for program output to appear,
    which is usually the console.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要将 `out_fh` 文件句柄用作 `file` 参数。我想指出，默认的 `file` 值是 `sys.stdout`。在命令行上，“STDOUT”（读作
    *standard out*）是程序输出的标准位置，通常是控制台。
- en: Another option is to use the `out_fh.write()` method of the filehandle itself,
    but note that this function *does not* append a newline. It’s up to you to decide
    when to add newlines. In the case of reading these sequences that are terminated
    with newlines, they are not needed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是直接使用文件句柄 `out_fh.write()` 方法本身，但请注意，此函数 *不会* 添加换行符。你需要自己决定何时添加换行符。在读取以换行符结尾的这些序列的情况下，它们是不需要的。
- en: Printing the Status Report
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印状态报告
- en: I almost always like to print something when my programs have finished running
    so I at least know they got to the end. It may be something as simple as “Done!”
    Here, though, I’d like to know how many sequences in how many files were processed.
    I also want to know where I can find the output, something that’s especially helpful
    if I forget the name of the default output directory.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我的程序运行完成时，我几乎总是喜欢打印一些东西，这样我至少知道它们已经完成了。可能只是简单的“完成了！”然而，在这里，我想知道处理了多少个序列在多少个文件中。我还想知道在哪里找到输出，如果我忘记了默认输出目录的名称，这尤其有帮助。
- en: 'The tests expect that you will use proper grammar^([2](ch02.html#idm45963631818520))
    to describe the numbers—for example, *1 sequence* and *1 file*:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 测试期望您使用正确的语法^([2](ch02.html#idm45963631818520))来描述数字，例如 *1 sequence* 和 *1 file*：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'or *3 sequences* and *2 files*:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 或者 *3 sequences* 和 *2 files*：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO10-1)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO10-1)'
- en: The syntax `input[12].txt` is a way to say either 1 or 2 can occur, so *input1.txt*
    and *input2.txt* will both match.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 语法 `input[12].txt` 是一种说法，表示 1 或 2 可能出现，因此 *input1.txt* 和 *input2.txt* 都会匹配。
- en: Using the Test Suite
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用测试套件
- en: 'You can run **`pytest -xv`** to run *tests/rna_test.py*. A passing test suite
    looks like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行**`pytest -xv`**来运行*tests/rna_test.py*。通过的测试套件看起来像这样：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO11-1)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO11-1)'
- en: The `rna.py` program exists.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`rna.py` 程序存在。'
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO11-2)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO11-2)'
- en: The program prints a usage statement when requested.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求时，程序打印用法说明。
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO11-3)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO11-3)'
- en: The program exits with an error when given no arguments.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当未提供参数时，程序以错误退出。
- en: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO11-4)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO11-4)'
- en: The program prints an error message when given a bad file argument.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供错误文件参数时，程序打印错误消息。
- en: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO11-5)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO11-5)'
- en: The next tests all verify that the program works properly given good inputs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的测试都验证程序在给出良好输入时是否正常工作。
- en: Generally speaking, I first write tests that try to break a program before giving
    it good input. For instance, I want the program to fail when given no files or
    when given nonexistent files. Just as the best detectives can think like criminals,
    I try to imagine all the ways to break my programs and test that they behave predictably
    under those circumstances.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我首先编写尝试破坏程序的测试，然后再给出良好输入。例如，我希望程序在没有文件或给出不存在的文件时失败。正如最好的侦探可以像罪犯一样思考，我尝试想象所有可能破坏我的程序的方法，并测试它们在这些情况下的可预测行为。
- en: 'The first three tests are exactly as from [Chapter 1](ch01.html#ch01). For
    the fourth test, I pass a nonexistent file and expect a nonzero exit value along
    with the usage and the error message. Note that the error specifically mentions
    the offending value, here the bad filename. You should strive to create feedback
    that lets the user know exactly what the problem is and how to fix it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个测试与[第1章](ch01.html#ch01)完全相同。对于第四个测试，我传递一个不存在的文件，并期望非零退出值以及用法和错误消息。请注意，错误明确提到了有问题的值，即坏文件名。您应努力创建反馈，让用户准确地知道问题所在以及如何修复：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO12-1)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO12-1)'
- en: This is a function I wrote to generate a string of random characters.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我编写的一个函数，用于生成一串随机字符。
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO12-2)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO12-2)'
- en: Run the program with this nonexistent file.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个不存在的文件运行程序。
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO12-3)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO12-3)'
- en: Make sure the exit value is not `0`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 确保退出值不是`0`。
- en: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO12-4)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO12-4)'
- en: Use a regular expression (*regex*) to look for the usage in the output.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式（*regex*）查找输出中的用法。
- en: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO12-5)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO12-5)'
- en: Use another regex to look for the error message describing the bad input filename.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用另一个正则表达式来查找描述坏输入文件名的错误消息。
- en: 'I haven’t introduced regular expressions yet, but they will become central
    to solutions I write later. To see why they are useful, look at the output from
    the program when run with a bad file input:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有介绍正则表达式，但它们将成为我后来编写的解决方案的核心。要了解它们为何有用，请查看以坏文件输入运行程序时的输出：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using the `re.match()` function, I am looking for a pattern of text starting
    at the beginning of the `out` text. Using the `re.search()` function, I am looking
    for another pattern that occurs somewhere inside the `out` text. I’ll have much
    more to say about regexes later. For now, it’s enough to point out that they are
    very useful.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`re.match()`函数，我正在寻找以`out`文本开头的文本模式。使用`re.search()`函数，我正在寻找出现在`out`文本中的另一个模式。稍后我会详细介绍正则表达式，现在仅需指出它们非常有用。
- en: 'I’ll show one last test that verifies the program runs correctly when provided
    good input. There are many ways to write such a test, so don’t get the impression
    this is canon:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示最后一个测试，验证在提供良好输入时程序是否正确运行。有许多编写此类测试的方法，所以不要认为这是唯一的正确方法：
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-1)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-1)'
- en: This is the default output directory name.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认的输出目录名称。
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-2)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-2)'
- en: The `try`/`finally` blocks help to ensure cleanup when tests fail.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`/`finally`块有助于确保在测试失败时进行清理。'
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-3)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-3)'
- en: See if the output directory has been left over from a previous run.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 查看输出目录是否留有上次运行的残留物。
- en: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-4)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-4)'
- en: Use the `shutil.rmtree()` function to remove the directory and its contents.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`shutil.rmtree()`函数删除目录及其内容。
- en: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-5)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-5)'
- en: Run the program with a known good input file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 用已知的良好输入文件运行程序。
- en: '[![6](assets/6.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-6)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-6)'
- en: Make sure the expected output directory was created.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 确保已创建预期的输出目录。
- en: '[![7](assets/7.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-7)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-7)'
- en: Make sure the expected output file was created.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 确保已创建预期的输出文件。
- en: '[![8](assets/8.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-8)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-8)'
- en: Make sure the contents of the output file are correct.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 确保输出文件的内容是正确的。
- en: '[![9](assets/9.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-9)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-9)'
- en: Even if something fails in the `try` block, this `finally` block will be run.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`try`块中出现失败，也会执行此`finally`块。
- en: '[![10](assets/10.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-10)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-10)'
- en: Clean up the testing environment.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 清理测试环境。
- en: I want to stress how important it is to check every aspect of what your program
    is supposed to do. Here, the program should process some number of input files,
    create an output directory, and then place the processed data into files in the
    output directory. I’m testing every one of those requirements using known input
    to verify that the expected output is created.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调检查程序应该执行的每个方面是多么重要。在这里，程序应处理一些输入文件，创建一个输出目录，然后将处理后的数据放入输出目录中的文件中。我正在使用已知的输入来测试每一个这些要求，以验证是否创建了预期的输出。
- en: There are a couple of other tests I won’t cover here as they are similar to
    what I’ve already shown, but I would encourage you to read the entire *tests/rna_test.py*
    program. The first input file has one sequence. The second input file has two
    sequences, and I use that to test that two sequences are written to the output
    file. The third input file has two very long sequences. By using these inputs
    individually and together, I try to test every aspect of my program that I can
    imagine.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另外几个测试我不会在这里详细介绍，因为它们与我已经展示的类似，但我鼓励你阅读整个*tests/rna_test.py*程序。第一个输入文件有一个序列。第二个输入文件有两个序列，我用它来测试是否将两个序列写入输出文件。第三个输入文件有两个非常长的序列。通过单独和结合使用这些输入，我试图测试我能想象到的程序的每个方面。
- en: Although you can run the tests in *tests/rna_test.py* using `pytest`, I also
    urge you to use `pylint`, `flake8`, and `mypy` to check your program. The `make
    test` shortcut can do this for you as it will execute `pytest` with the additional
    arguments to run those tools. Your goal should be a completely clean test suite.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以使用 `pytest` 运行 *tests/rna_test.py* 中的测试，我也建议你使用 `pylint`、`flake8` 和 `mypy`
    来检查你的程序。`make test` 快捷方式可以为您执行此操作，因为它将使用额外的参数执行 `pytest` 来运行这些工具。您的目标应该是一个完全干净的测试套件。
- en: You may find that `pylint` will complain about variable names like `fh` being
    too short or not being *snake_case*, where lowercase words are joined with underscores.
    I have included a *pylintrc* configuration file in the top level of the GitHub
    repository. Copy this to the file *.pylintrc* in your home directory to silence
    these errors.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现 `pylint` 会抱怨像 `fh` 这样的变量名太短，或者不是 *snake_case*，即小写单词用下划线连接。我在GitHub仓库的顶层包含了一个
    *pylintrc* 配置文件。将其复制到家目录下的文件 *.pylintrc* 中，以消除这些错误。
- en: You should have enough information and tests now to help you finish this program.
    You’ll get the most benefit from this book if you try to write working programs
    on your own before you look at my solutions. Once you have one working version,
    try to find other ways to solve it. If you know about regular expressions, that’s
    a great solution. If you don’t, I will demonstrate a version that uses them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该有足够的信息和测试来帮助你完成这个程序。在你查看我的解决方案之前，如果你尝试自己编写工作程序，你将从这本书中获得最大的收益。一旦你有一个工作版本，尝试找到其他解决方法。如果你了解正则表达式，那是一个很好的解决方案。如果不了解，我将演示一个使用它们的版本。
- en: Solutions
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: The following two solutions differ only in how I substitute the *T*s for *U*s.
    The first uses the `str.replace()` method, and the second introduces regular expressions
    and uses the Python `re.sub()` function.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个解决方案仅在如何用 *T* 替换 *U* 方面有所不同。第一个使用 `str.replace()` 方法，第二个引入了正则表达式并使用了Python的
    `re.sub()` 函数。
- en: 'Solution 1: Using str.replace()'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 1：使用 str.replace()
- en: 'Here is the entirety of one solution that uses the `str.replace()` method I
    discussed in the introduction to this chapter:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个完全使用我在本章介绍的 `str.replace()` 方法的解决方案的全部内容：
- en: '[PRE38]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-1)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-1)'
- en: Initialize the counters for files and sequences.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化文件和序列的计数器。
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-2)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-2)'
- en: Iterate the filehandles.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代文件句柄。
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-3)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-3)'
- en: Increment the counter for files.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 递增文件计数器。
- en: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-4)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-4)'
- en: Open the output file for this input file.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 打开用于此输入文件的输出文件。
- en: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-5)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-5)'
- en: Iterate the sequences in the input file.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代输入文件中的序列。
- en: '[![6](assets/6.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-6)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-6)'
- en: Increment the counter for sequences.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 递增序列的计数器。
- en: '[![7](assets/7.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-7)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-7)'
- en: Write the transcribed sequence to the output file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 将转录的序列写入输出文件。
- en: '[![8](assets/8.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-8)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-8)'
- en: Close the output filehandle.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭输出文件句柄。
- en: '[![9](assets/9.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-9)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-9)'
- en: Print the status. Note that I’m relying on Python’s implicit concatenation of
    adjacent strings to create one output string.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 打印状态。请注意，我依赖于Python隐式连接相邻字符串来创建一个输出字符串。
- en: 'Solution 2: Using re.sub()'
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 2：使用 re.sub()
- en: I suggested earlier that you might explore how to use regular expressions to
    solve this. Regexes are a language for describing patterns of text. They have
    been around for decades, long before Python was even invented. Though they may
    seem somewhat daunting at first, regexes are well worth the effort to learn.^([3](ch02.html#idm45963631621240))
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前建议过，你可以探索如何使用正则表达式来解决这个问题。正则表达式是一种描述文本模式的语言。它们存在已久，甚至在Python诞生之前就有了。虽然一开始它们可能看起来有些令人畏惧，但是学习正则表达式绝对是值得的。^([3](ch02.html#idm45963631621240))
- en: 'To use regular expressions in Python, I must import the `re` module:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中使用正则表达式，我必须导入`re`模块：
- en: '[PRE39]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Previously, I used the `re.search()` function to look for a pattern of text
    inside another string. For this program, the pattern I am looking for is the letter
    *T*, which I can write as a literal string:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我使用了`re.search()`函数在另一个字符串中查找文本模式。对于这个程序，我要找的模式是字母*T*，我可以直接写成一个字符串：
- en: '[PRE40]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO15-1)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO15-1)'
- en: Search for the pattern `T` inside the string `ACGT`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串`ACGT`中搜索模式`T`。
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO15-2)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO15-2)'
- en: Because `T` was found, the return value is a `Re.Match` object showing the location
    of the found pattern. A failed search would return `None`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 因为找到了`T`，返回值是一个`Re.Match`对象，显示找到模式的位置。如果搜索失败，则返回`None`。
- en: 'The `span=(3, 4)` reports the start and stop indexes where the pattern `T`
    is found. I can use these positions to extract the substring using a slice:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`span=(3, 4)`报告了找到模式`T`的起始和停止索引位置。我可以使用这些位置来通过切片提取子字符串：'
- en: '[PRE41]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: But instead of just finding the *T*, I want to replace the string `T` with `U`.
    As shown in [Figure 2-3](#fig_2.3), the `re.sub()` (for *substitute*) function
    will do this.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 但不只是找到*T*，我想用字符串`T`替换为`U`。如[图2-3](#fig_2.3)所示，`re.sub()`（*substitute*）函数可以实现这一点。
- en: '![mpfb 0203](assets/mpfb_0203.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0203](assets/mpfb_0203.png)'
- en: Figure 2-3\. The `re.sub()` function will return a new string where all instances
    of a pattern have been replaced with a new string
  id: totrans-285
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-3\. `re.sub()`函数将返回一个新字符串，其中所有模式的实例都被替换为新字符串
- en: 'The result is a new string where the *T*s have all been replaced with *U*s:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个新字符串，其中所有*T*都已替换为*U*：
- en: '[PRE42]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO16-1)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO16-1)'
- en: Replace every `T` with `U` in the string `ACGT`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串`ACGT`中用`U`替换每个`T`。
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO16-2)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO16-2)'
- en: The result is a new string with the substitutions.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个新字符串，其中进行了替换。
- en: 'To use this version, I can modify the inner `for` loop, as shown. Note that
    I have chosen to use the `str.strip()` method to remove the newline terminating
    the input DNA string because `print()` will add a newline:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个版本，我可以修改内部的`for`循环，如所示。请注意，我选择使用`str.strip()`方法来删除输入DNA字符串末尾的换行符，因为`print()`会添加一个换行符：
- en: '[PRE43]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO17-1)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO17-1)'
- en: Remove the newline from `dna`, substitute all the `T`s with `U`s, and print
    the resulting string to the output filehandle.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 从`dna`中删除换行符，用`U`替换所有的`T`，并将结果打印到输出文件句柄。
- en: Benchmarking
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Benchmarking
- en: 'You might be curious to know which solution is faster. Comparing the relative
    runtimes of programs is called *benchmarking*, and I’ll show you a simple way
    to compare these two solutions using some basic `bash` commands. I’ll use the
    *./tests/inputs/input3.txt* file, as it is the largest test file. I can write
    a `for` loop in `bash` with almost the same syntax as Python. Note that I am using
    newlines in this command to make it more readable, and `bash` notes the line continuation
    with `>`. You can substitute semicolons (`;`) to write this on one line:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇哪个解决方案更快。比较程序的相对运行时间称为*基准测试*，我将展示一种简单的方法，使用一些基本的`bash`命令比较这两个解决方案。我将使用*./tests/inputs/input3.txt*文件，因为它是最大的测试文件。我可以在`bash`中编写一个`for`循环，几乎与Python的语法相同。请注意，我在这个命令中使用换行符以提高可读性，并用`>`表示行继续。你可以用分号(`;`)来将其写成一行：
- en: '[PRE44]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'It would appear the second solution using regular expressions is faster, but
    I don’t have enough data to be sure. I need a more substantial input file. In
    the *02_rna* directory, you’ll find a program called `genseq.py` I wrote that
    will generate 1,000 sequences of 1,000,000 bases in a file called *seq.txt*. You
    can, of course, modify the parameters:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来第二种使用正则表达式的解决方案更快，但我没有足够的数据来确定。我需要一个更实质性的输入文件。在 *02_rna* 目录下，您会找到一个名为 `genseq.py`
    的程序，我写了这个程序将在一个名为 *seq.txt* 的文件中生成 1,000,000 个碱基的 1,000 个序列。当然，您可以修改参数：
- en: '[PRE45]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The file *seq.txt* that is generated using the defaults is about 95 MB. Here’s
    how the programs do with a more realistic input file:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认设置生成的文件 *seq.txt* 大约为 95 MB。以下是程序在更现实的输入文件上的表现：
- en: '[PRE46]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It now appears that the first solution is faster. For what it’s worth, I came
    up with several other solutions, all of which fared much worse than these two.
    I thought I was creating more and more clever solutions that would ultimately
    lead to the best performance. My pride was sorely wounded when what I thought
    was my best program turned out to be orders of magnitude slower than these two.
    When you have assumptions, you should, as the saying goes, “Trust, but verify.”
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种解决方案似乎更快。说实话，我想出了几种其他解决方案，但所有这些解决方案都比这两种糟糕得多。我以为我正在创造越来越聪明的解决方案，最终会导致最佳性能。当我认为我最好的程序竟然比这两个慢了几个数量级时，我的自尊受到了严重打击。当你有假设时，应该像俗话说的那样，“信任，但验证”。
- en: Going Further
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探讨
- en: Modify your program to print the lengths of the sequences to the output file
    rather than the transcribed RNA. Have the final status report the maximum, minimum,
    and average sequence lengths.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 修改您的程序以打印序列的长度到输出文件，而不是转录的 RNA。最终状态报告最大、最小和平均序列长度。
- en: Review
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾
- en: 'Key points from this chapter:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要点：
- en: The `argparse.FileType` option will validate file arguments.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argparse.FileType` 选项将验证文件参数。'
- en: The `nargs` option to `argparse` allows you to define the number of valid arguments
    for a parameter.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argparse` 的 `nargs` 选项允许您为参数定义有效参数的数量。'
- en: The `os.path.isdir()` function can detect if a directory exists.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.path.isdir()` 函数可以检测目录是否存在。'
- en: The `os.makedirs()` function will create a directory structure.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.makedirs()` 函数将创建一个目录结构。'
- en: The `open()` function by default allows only reading files. The `w` option must
    be used to write to the filehandle, and the `a` option is for appending values
    to an existing file.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，`open()` 函数仅允许读取文件。必须使用 `w` 选项来写入文件句柄，`a` 选项用于将值附加到现有文件。
- en: File handles can be opened with the `t` option for *text* (the default) or `b`
    for *bytes*, such as when reading image files.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件句柄可以使用 `t` 选项打开*文本*（默认）或 `b` 选项打开*字节*，例如在读取图像文件时。
- en: Strings are immutable, and there are many methods to alter strings into new
    strings, including `str.replace()` and `re.sub()`.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串是不可变的，有许多方法可以将字符串更改为新字符串，包括 `str.replace()` 和 `re.sub()`。
- en: '^([1](ch02.html#idm45963631969784-marker)) As Phil Karlton says, “There are
    only two hard things in Computer Science: cache invalidation and naming things.”'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#idm45963631969784-marker)) 正如 Phil Karlton 所说，“计算机科学中只有两件难事：缓存失效和命名事物。”
- en: ^([2](ch02.html#idm45963631818520-marker)) Sorry, but I can’t stop being an
    English major.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.html#idm45963631818520-marker)) 抱歉，但我无法停止做英语专业的人。
- en: ^([3](ch02.html#idm45963631621240-marker)) [*Mastering Regular Expressions*](https://oreil.ly/R7O1r)
    by Jeffrey Friedl (O’Reilly, 2006) is one of the best books I’ve found.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.html#idm45963631621240-marker)) [*精通正则表达式*](https://oreil.ly/R7O1r)
    由 Jeffrey Friedl（O’Reilly，2006）是我找到的最佳书籍之一。
