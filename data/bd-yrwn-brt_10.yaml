- en: 10 Robotic QR code finder
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 机器人二维码查找器
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Generating QR codes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成二维码
- en: Detecting and decoding data in QR codes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测和解码二维码中的数据
- en: Streaming live video using Motion JPEG
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Motion JPEG流式传输实时视频
- en: Creating a robot that can search for specific QR codes in its environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可以在其环境中搜索特定二维码的机器人
- en: We start this chapter by exploring the QR code standard and learning how to
    generate our own QR codes. Then, we use the OpenCV computer vision library to
    detect QR codes in images, as well as to read the data encoded in the QR code
    itself. We will then learn how to save the video stream data from the camera to
    the filesystem so that multiple applications can simultaneously read live video
    data. This will allow us to check the video stream for QR codes we are interested
    in, as well as stream the video to desktop and web applications at the same time.
    We will use the Tornado web framework to create a Motion JPEG video server that
    can be accessed from any mobile device or computer on the network to get a live
    view of the robot’s camera video stream. Finally, we end the chapter by creating
    a robot that can move around in search of matching QR codes in its environment.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '我们从探索二维码标准和学习如何生成我们自己的二维码开始本章。然后，我们使用OpenCV计算机视觉库在图像中检测二维码，以及读取二维码本身编码的数据。然后，我们将学习如何将来自相机的视频流数据保存到文件系统中，以便多个应用程序可以同时读取实时视频数据。这将允许我们检查我们感兴趣的二维码视频流，同时将视频流传输到桌面和Web应用程序。我们将使用Tornado
    Web框架创建一个Motion JPEG视频服务器，可以从网络上的任何移动设备或计算机访问，以获取机器人相机视频流的实时视图。最后，我们通过创建一个可以在其环境中寻找匹配二维码的机器人来结束本章。 '
- en: Bringing all these technologies together helps us solve the problem of having
    robots use computer vision to investigate their environment and move around to
    different desired locations by looking for matching QR codes. This is a core functionality
    for many robots that must perform autonomous navigation in warehouses or factories.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些技术结合起来，帮助我们解决机器人使用计算机视觉来调查其环境并在寻找匹配的二维码时移动到不同期望位置的问题。这对于许多必须在仓库或工厂中执行自主导航的机器人来说是一个核心功能。
- en: 10.1 Hardware stack
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 硬件栈
- en: Figure 10.1 shows the hardware stack, with the specific components used in this
    chapter highlighted. The robot will use the DC motors to move back and forth along
    a set track. The camera is mounted on the side of the robot and can capture objects
    next to the robot as the robot drives past them. The robot will be checking the
    images from the live video feed, looking for a matching QR code. Once the code
    is found, the robot can stop the motors, as it has reached its desired destination.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1显示了硬件栈，本章中使用的特定组件被突出显示。机器人将使用直流电机在一条设定的轨道上来回移动。相机安装在机器人的侧面，可以在机器人经过时捕捉到机器人旁边的物体。机器人将检查来自实时视频流的图像，寻找匹配的二维码。一旦找到代码，机器人就可以停止电机，因为它已经到达了期望的目的地。
- en: '![](../Images/CH10_F01_Alsabbagh.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F01_Alsabbagh.png)'
- en: 'Figure 10.1 Hardware stack: the camera will be used to capture live images
    for QR code detection.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 硬件栈：相机将被用来捕捉用于二维码检测的实时图像。
- en: For further details on the robot assembly, check the robot assembly guide in
    appendix C. It shows how to assemble the robot used in this chapter. It also gives
    tips on how to create a track for the robot so that it can travel back and forth
    on a controlled path.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于机器人组装的更多细节，请查看附录C中的机器人组装指南。它展示了如何组装本章中使用的机器人。它还提供了如何为机器人创建轨道的技巧，以便它可以在一个受控路径上往返移动。
- en: 10.2 Software stack
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 软件栈
- en: Details of the specific software used in this chapter are described in figure
    10.2\. We start the chapter by creating the `detect_qr` application that will
    perform QR code detection and decoding using the OpenCV library on a single image.
    Then, we will use the `stream_save` script to capture the video stream to the
    filesystem. The `watcher` library uses the `sys` module to read command line arguments
    and watch for changes on the streaming image file. We then create streaming applications
    for both web and graphical applications. We end the chapter by using the camera
    and DC motors hardware in the `goto_qr` application to move the robot to a specific
    target location marked by a QR code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的特定软件的详细信息在图10.2中描述。我们首先创建了一个名为`detect_qr`的应用程序，该应用程序将使用OpenCV库在单个图像上执行二维码检测和解码。然后，我们将使用`stream_save`脚本来捕获视频流到文件系统。`watcher`库使用`sys`模块来读取命令行参数并监视流图像文件的变化。然后，我们为Web和图形应用程序创建流应用程序。我们通过在`goto_qr`应用程序中使用摄像头和直流电机硬件来移动机器人到由二维码标记的特定目标位置来结束本章。
- en: '![](../Images/CH10_F02_Alsabbagh.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F02_Alsabbagh.png)'
- en: 'Figure 10.2 Software stack: the OpenCV library will be used to perform QR code
    detection.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 软件栈：将使用OpenCV库来执行二维码检测。
- en: 10.3 Detecting QR codes in an image
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 在图像中检测二维码
- en: 'The first step is to perform QR code detection and decoding on a single image.
    We need to create a Python application that meets the following requirements:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在单个图像上执行二维码检测和解码。我们需要创建一个满足以下要求的Python应用程序：
- en: The application should use the OpenCV computer vision library to detect the
    location of a QR code in an image.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应使用OpenCV计算机视觉库来检测图像中二维码的位置。
- en: A rectangle should be drawn in the image around the detected QR code.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应在图像中检测到的二维码周围绘制一个矩形。
- en: The application should decode and return the data stored in the QR code.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应解码并返回存储在二维码中的数据。
- en: The last requirement of decoding data stored in the QR code will be very helpful
    later in the chapter, as we will use it to decide whether we have reached our
    desired QR code or whether the robot should keep moving down the track.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 解码存储在二维码中的数据的最后要求将在本章的后面非常有帮助，因为我们将使用它来决定我们是否到达了期望的二维码，或者机器人是否应该继续沿着轨道移动。
- en: 10.3.1 Exploring QR codes
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 探索二维码
- en: 'The first step in our QR code adventure is to install the `qrcode` Python package.
    This module will let us generate QR codes. Run the following command to install
    the package:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们二维码冒险的第一步是安装`qrcode`Python包。此模块将使我们能够生成二维码。运行以下命令来安装包：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This package can be imported in Python code or executed directly in the command
    line. Let’s start by generating some QR codes in the terminal. When we run the
    next command, a QR code encoded with the text `hello` will be generated and outputted
    to our terminal:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此软件包可以在Python代码中导入或在命令行中直接执行。让我们首先在终端中生成一些二维码。当我们运行下一个命令时，将生成一个包含文本`hello`的二维码，并将其输出到我们的终端：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can test the QR code by scanning it using a smartphone. Once you scan the
    QR code, the text `hello` should appear on your device. When we run the next command,
    it will save the generated QR code to an image instead of outputting it to the
    terminal:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用智能手机扫描二维码来测试它。一旦扫描二维码，文本`hello`应出现在您的设备上。当我们运行下一个命令时，它将保存生成的二维码到图像而不是输出到终端：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can open the `hello.png` image and test it again. This is a useful way for
    generating QR codes, as we can print the image and stick it to the objects we
    want to tag with QR codes. Figure 10.3 shows the QR code generated using this
    command.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以打开`hello.png`图像并再次测试它。这是一种生成二维码的有用方法，因为我们可以将图像打印出来并将其粘贴到我们想要用二维码标记的对象上。图10.3显示了使用此命令生成的二维码。
- en: '![](../Images/CH10_F03_Alsabbagh.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F03_Alsabbagh.png)'
- en: 'Figure 10.3 Generated QR code: the example QR code has the text `hello` encoded
    in it.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 生成的二维码：示例二维码中编码了文本`hello`。
- en: 'Next, we will pop into a read–evaluate–print loop (REPL) session to explore
    using the package from a Python application. The first step is to import the `qrcode`
    library:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进入一个读取-评估-打印循环（REPL）会话，以探索从Python应用程序中使用该软件包。第一步是导入`qrcode`库：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next line will create a QR code with the text `hi again` and save it into
    an image called `hi_again.png`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个步骤将创建一个包含文本`hi again`的二维码并将其保存到名为`hi_again.png`的图像中：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For more advanced applications, we use a `QRCode` object. Through this object,
    we can set different options relating to the error correction, box size, and border
    of the QR code. In the example that follows, we create a `QRCode` object and use
    the `add_data` method to set the content of the QR code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的应用，我们使用一个`QRCode`对象。通过这个对象，我们可以设置与二维码的错误纠正、框大小和边框相关的不同选项。在下面的示例中，我们创建一个`QRCode`对象，并使用`add_data`方法设置二维码的内容：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we call the `make` method to generate the QR code. Once generated, we
    can obtain details about the generated QR code, such as the symbol version that
    was used. In this example, the `version` attribute reports the QR code is using
    symbol version `1`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`make`方法来生成二维码。一旦生成，我们可以获取有关生成的二维码的详细信息，例如使用的符号版本。在这个例子中，`version`属性报告二维码正在使用符号版本`1`：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The official website for the QR code standard ([https://www.qrcode.com](https://www.qrcode.com))
    gives exact details on each symbol version and how much data it can store. Essentially,
    the more data you put in a QR code, the larger the symbol version, which in turn
    generates a denser QR code. It is useful to be able to check this value when we
    generate QR code images, as the lower-version numbers are less dense and will
    be easier to read even with low-resolution images. The next line in our REPL will
    save the QR code to an image called `python.png`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 二维码标准的官方网站([https://www.qrcode.com](https://www.qrcode.com))提供了每个符号版本的确切细节以及它可以存储多少数据。本质上，你放入二维码中的数据越多，符号版本就越大，这反过来又生成一个更密集的二维码。在我们生成二维码图像时能够检查这个值是有用的，因为低版本号更稀疏，即使是在低分辨率图像中也会更容易阅读。我们REPL中的下一行将二维码保存到名为`python.png`的图像中：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On most smartphones, if you read this QR code, it will be detected from the
    text as a URL, and you will be directed to the Python website ([https://www.python.org](https://www.python.org)).
    Now that we have generated some QR codes, let’s move on to detecting and decoding
    them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数智能手机上，如果你读取这个二维码，它将从文本中被检测为一个URL，并将你导向Python网站([https://www.python.org](https://www.python.org))。现在我们已经生成了一些二维码，让我们继续检测和解码它们。
- en: 10.3.2 Marking detected QR codes
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 标记检测到的二维码
- en: We will create a script to perform QR code detection and decoding on an image
    and then to draw a rectangle around the matching QR code. We will also display
    the decoded data as text on the image. The image will then be displayed in our
    graphical application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本来在图像上执行二维码检测和解码，然后围绕匹配的二维码绘制一个矩形。我们还将以文本形式在图像上显示解码的数据。然后，该图像将在我们的图形应用程序中显示。
- en: Take the image generated in the previous section that has the text `hello` encoded
    in it, and print it out. Then, take a photo of it using the Pi camera, and save
    the image in a file called `hello.jpg`. You can use the `snapshot.py` application
    from chapter 8 to take the image. Alternatively, a `hello.jpg` image is also provided
    in the folder for this chapter in the book’s GitHub repository.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 取上节生成的包含文本`hello`编码的图像，并将其打印出来。然后，使用Pi相机拍照，并将图像保存到名为`hello.jpg`的文件中。你可以使用第8章中的`snapshot.py`应用程序来拍照。或者，`hello.jpg`图像也包含在本书GitHub仓库的该章节文件夹中。
- en: 'The first step will be to import the `cv2` library:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步将是导入`cv2`库：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The value for the color blue is saved in the variable `BLUE`, and the font
    for displaying text in the application is saved in `FONT`. We then instantiate
    a `QRCodeDetector` object and save it in `decoder`. Methods on this object will
    be called to perform the QR code detection and decoding:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色的值保存在变量`BLUE`中，应用程序中显示文本的字体保存在`FONT`中。然后，我们实例化一个`QRCodeDetector`对象，并将其保存在`decoder`中。将调用此对象上的方法来执行二维码检测和解码：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `draw_box` function will draw a box around the detected QR code in the
    image. The image is provided in the `frame` argument, and the four points of the
    detected quadrangle are provided in `points`. The color and thickness of the box
    are set using the `color` and `thickness` arguments. The point values are first
    converted to integers, as this is what is expected by the `cv2.line` function.
    We then save each of the four points of the quadrangle into its own variable.
    Next, we draw four lines to connect these four points:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw_box`函数将在图像中绘制一个围绕检测到的二维码的矩形。图像由`frame`参数提供，检测到的四边形的四个点由`points`提供。使用`color`和`thickness`参数设置框的颜色和粗细。首先将点值转换为整数，因为这是`cv2.line`函数所期望的。然后，我们将四边形的四个点分别保存到自己的变量中。接下来，我们绘制四条线来连接这四个点：'
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will then define `decode_qrcode`, which calls the `detectAndDecode` method
    to detect and decode QR codes in the `frame` image. Decoded data is stored in
    the variable `data`, and a list of matching points is stored in `matches`. If
    we find decoded data, we display it as text using `putText` and draw a box around
    the matched area by calling the `draw_ box` function. We finally end the function
    by returning the decoded data:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将定义`decode_qrcode`，它调用`detectAndDecode`方法来检测和解码`frame`图像中的QR码。解码的数据存储在变量`data`中，匹配点的列表存储在`matches`中。如果我们找到解码数据，我们使用`putText`将其显示为文本，并通过调用`draw_box`函数在匹配区域周围绘制一个框。我们最终通过返回解码数据来结束函数：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `main` function loads our photo of a QR code into a variable called `frame`.
    Then `decode_qrcode` is called to perform the QR code detection and decoding.
    The decoded data is stored in a variable called `decoded_data` and printed out.
    The image is then shown using `imshow`. The `waitKey` function is called to display
    the image until a key is pressed in the application:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数将我们的QR码照片加载到名为`frame`的变量中。然后调用`decode_qrcode`来执行QR码的检测和解码。解码的数据存储在名为`decoded_data`的变量中并打印出来。然后使用`imshow`显示图像。调用`waitKey`函数来显示图像，直到在应用程序中按下键：'
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The full script can be saved as `detect_qr.py` on the Pi and then executed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为`detect_qr.py`在Pi上，然后执行。
- en: 'Listing 10.1 `detect_qr.py`: Detecting and decoding QR codes in an image'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 `detect_qr.py`：在图像中检测和解码QR码
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When this script is run, it will perform the QR code detection on the `hello.jpg`
    image and draw a box around the matching quadrangle. The decoded data is also
    displayed in the top-left corner of the image. Figure 10.4 shows what the application
    will look like once it has completed detection and decoding of the QR code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此脚本时，它将在`hello.jpg`图像上执行QR码检测，并在匹配的四边形周围绘制一个框。解码的数据也显示在图像的左上角。图10.4显示了应用程序完成QR码的检测和解码后的样子。
- en: '![](../Images/CH10_F04_Alsabbagh.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F04_Alsabbagh.png)'
- en: 'Figure 10.4 Detected QR code: the application draws a box around the detected
    QR code.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 检测到的QR码：应用程序在检测到的QR码周围绘制一个框。
- en: We now have a solid foundation in QR code detection and decoding. We will have
    multiple applications, all wanting to access the live video stream. Thus, the
    next step will be to design a system to capture and distribute images from the
    live video stream to multiple applications.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在QR码检测和解码方面有了坚实的基础。我们将有多个应用程序，它们都需要访问实时视频流。因此，下一步将是设计一个系统来捕获和分发来自实时视频流的图像到多个应用程序。
- en: 10.4 Streaming live video to multiple applications
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 将实时视频流传输到多个应用程序
- en: 'We will approach this problem by saving the images from the live video stream
    to the filesystem. Then, multiple applications can simultaneously read these images
    from the filesystem and use them to stream to desktop or web applications. We
    can use the same mechanism to detect QR codes in the live stream and control the
    robot’s movements. We need to create a Python application that meets the following
    requirements:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将来自实时视频流的图像保存到文件系统来解决这个问题。然后，多个应用程序可以同时从文件系统中读取这些图像，并将它们用于流式传输到桌面或Web应用程序。我们可以使用相同的机制来检测实时流中的QR码并控制机器人的运动。我们需要创建一个满足以下要求的Python应用程序：
- en: The latest frame from the camera video stream should be captured and saved to
    the filesystem.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该捕获并保存来自相机视频流的最新帧到文件系统。
- en: The frame should be saved to a ramdisk in order to not create any additional
    disk workload.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应将帧保存到ramdisk中，以避免创建任何额外的磁盘工作负载。
- en: The image data should be saved as an atomic operation to ensure data consistency.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应将图像数据保存为原子操作，以确保数据一致性。
- en: The first step is to create an application to save the frames from the video
    stream to the filesystem. We can then create applications to stream the video
    stream to desktop and web applications. By using a ramdisk, we will get better
    I/O performance for video streaming and won’t create a slowdown for other applications
    that are trying to read and write from the disk.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个应用程序，将视频流中的帧保存到文件系统。然后我们可以创建应用程序将视频流流式传输到桌面和Web应用程序。通过使用ramdisk，我们将获得更好的I/O性能进行视频流传输，并且不会给试图从磁盘读取和写入的其他应用程序造成减速。
- en: 10.4.1 Saving the video stream to a ramdisk
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 将视频流保存到ramdisk
- en: One thing to keep in mind is that the camera on the robot is positioned upside
    down so that there can be enough space for the camera connector to be connected
    to the Raspberry Pi. This will make our captured images appear upside down. This
    problem can be solved by correcting the image orientation in software and flipping
    the image after we capture it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，机器人上的摄像头是倒置的，这样可以为摄像头连接器连接到树莓派腾出足够的空间。这将使得我们捕获的图像看起来是颠倒的。这个问题可以通过在软件中纠正图像方向并在捕获图像后翻转图像来解决。
- en: 'The `cv2` library is imported to capture frames from the video stream. The
    `os` module is imported so that we can access environment variables:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 `cv2` 库以从视频流中捕获帧。导入 `os` 模块以便我们可以访问环境变量：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A ramdisk is created by default on Linux systems, and we can access its location
    by reading the value of the `XDG_RUNTIME_DIR` environment variable. The files
    in the ramdisk are stored in memory and not on physical disks. In this way, we
    can work with them as we would with any other file on the filesystem but get the
    added benefit of not putting any additional load on the physical disks. We will
    place our image in this directory and use the `IMG_PATH` variable to keep track
    of its path. We also need to save the image data to a temporary file located in
    `TMP_PATH` before saving it to its final location:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统上默认创建了一个 ramdisk，我们可以通过读取 `XDG_RUNTIME_DIR` 环境变量的值来访问其位置。ramdisk 中的文件存储在内存中，而不是物理磁盘上。这样，我们可以像处理文件系统上的任何其他文件一样处理它们，但同时又不会对物理磁盘造成额外的负载。我们将图像放置在这个目录中，并使用
    `IMG_PATH` 变量来跟踪其路径。在将其保存到最终位置之前，我们还需要将图像数据保存到位于 `TMP_PATH` 的临时文件中：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will set the sizes of the images we capture to be half the size of the default
    resolution. This will make the size of data saved and streamed smaller and more
    efficient. The image will still be large enough to get a good view of what the
    robot sees as well as accurately perform QR code detection and decoding. We save
    these values in the variables `FRAME_WIDTH` and `FRAME_HEIGHT`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将捕获的图像尺寸设置为默认分辨率的二分之一。这将使得保存和流式传输的数据大小更小、更高效。图像仍然足够大，可以清楚地看到机器人看到的景象，以及准确地执行二维码检测和解码。我们将这些值保存到变量
    `FRAME_WIDTH` 和 `FRAME_HEIGHT` 中：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `init_camera` function is used to create the video capture object and set
    the video capture dimensions to `FRAME_WIDTH` and `FRAME_HEIGHT`. The video capture
    object is then returned:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`init_camera` 函数用于创建视频捕获对象，并将视频捕获的尺寸设置为 `FRAME_WIDTH` 和 `FRAME_HEIGHT`。然后返回视频捕获对象：'
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `save_frames` function enters into an infinite loop and captures a frame
    from the video stream in each loop. The variable `counter` keeps track of the
    number of frames captured so far. We save the captured image in `frame` and then
    flip the image by calling `cv2.flip`. We use `imwrite` to save the image to our
    temporary file. Then, we call `os.replace` to place our temporary file in its
    final destination. This call is guaranteed to be an atomic operation on Unix operating
    systems such as Linux, which our Pi is running on. Then, we print out how many
    frames we have captured so far. We use the carriage return as the end character
    when printing the output so that the same line in the terminal gets updated with
    our frame counter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`save_frames` 函数进入一个无限循环，并在每个循环中从视频流中捕获一个帧。变量 `counter` 跟踪到目前为止捕获的帧数。我们将捕获的图像保存在
    `frame` 中，然后通过调用 `cv2.flip` 翻转图像。我们使用 `imwrite` 将图像保存到我们的临时文件中。然后，我们调用 `os.replace`
    将我们的临时文件放置在其最终目的地。这个调用在 Unix 操作系统（如 Linux）上保证是一个原子操作，我们的 Pi 正在运行这样的操作系统。然后，我们打印出到目前为止捕获的帧数。在打印输出时，我们使用回车符作为结束字符，以便在终端中更新同一行的帧计数器：'
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we end with our `main` function that first initializes the video capture
    device and then calls the `save_frames` function to save frames from the video
    stream. We use `finally` to ensure that we release the video capture device upon
    exiting the application:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们以 `main` 函数结束，该函数首先初始化视频捕获设备，然后调用 `save_frames` 函数来保存视频流中的帧。我们使用 `finally`
    确保在退出应用程序时释放视频捕获设备：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The full script can be saved as `stream_save.py` on the Pi and then executed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 `stream_save.py` 并在 Pi 上执行。
- en: 'Listing 10.2 `stream_save.py`: Saving captured video frames to the filesystem'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2 `stream_save.py`：将捕获的视频帧保存到文件系统中
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will continuously capture and save frames from the video stream to the
    ramdisk. We can execute the following command to list the location of our stream
    image:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将连续捕获并保存视频流中的帧到ramdisk。我们可以执行以下命令来列出我们的流图像的位置：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can see from the output that the image size is 23K, and the file location
    is `/run/user/1000/robo_stream.jpg`. Each time we open this file in an image viewer,
    it will show the latest image being captured by the camera.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从输出中看到图像大小为23K，文件位置为`/run/user/1000/robo_stream.jpg`。每次我们在图像查看器中打开此文件时，它都会显示相机捕获的最新图像。
- en: 'Going deeper: Atomic operations'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解：原子操作
- en: Atomic operations are a very powerful and useful feature found in software such
    as operating systems and databases. They are particularly useful when you have
    multiple processes accessing the same data at the same time and you want to be
    sure that you won’t face data corruption when reading and writing data. In our
    case, we want to avoid having one of the streaming applications reading image
    data that hasn’t fully been written to disk. Reading such half-written image data
    into our applications would cause them to fail. The OSDev website has an excellent
    page on Atomic operations ([https://wiki.osdev.org/Atomic_operation](https://wiki.osdev.org/Atomic_operation))
    from an operating system perspective. It is a good resource for further details
    on the topic.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作是操作系统和数据库等软件中非常强大且有用的功能。当您有多个进程同时访问相同的数据时，它们尤其有用，并且您想确保在读写数据时不会遇到数据损坏。在我们的情况下，我们希望避免有流媒体应用程序读取尚未完全写入磁盘的图像数据。将这种半写入的图像数据读入我们的应用程序会导致它们失败。OSDev网站有一个关于原子操作的优秀页面（[https://wiki.osdev.org/Atomic_operation](https://wiki.osdev.org/Atomic_operation)），从操作系统的角度来看。它是关于该主题的详细信息的好资源。
- en: The Python `os` module documentation ([https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html))
    covers the `os.replace` function that we use in this section to write the image
    data to disk as an atomic operation. It mentions that replacing a file on systems
    such as Linux that follow the Portable Operating System Interface (POSIX) standard
    will be an atomic operation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`os`模块文档（[https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)）涵盖了我们在本节中使用的`os.replace`函数，该函数将图像数据作为原子操作写入磁盘。它提到，在遵循便携式操作系统接口（POSIX）标准的系统（如Linux）上替换文件将是一个原子操作。
- en: The strategy employed in this chapter of writing to a temporary file and then
    renaming the file to its final destination is a very common approach used by many
    applications, such as word processors and web browsers, to ensure data consistency
    in the final output file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中采用的将数据写入临时文件然后重命名文件到最终目标的方法是许多应用程序（如文字处理器和网页浏览器）常用的非常常见的方法，以确保最终输出文件中的数据一致性。
- en: 10.4.2 Watching the filesystem for changes
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 监视文件系统更改
- en: Now that we have our video stream saved to the filesystem, we can read these
    live video images and display them in different applications. However, to do this,
    we would need some mechanism where, by polling the filesystem, we could check
    on a regular basis whether a new image has been made available. One simple and
    efficient way to do this is to check the modification time of the image file.
    Whenever it has changed, we know there is a new image available for us. To help
    the different applications perform this task, we will put the functionality into
    a library that they can all import and use.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将视频流保存到文件系统中，我们可以读取这些实时视频图像并在不同的应用程序中显示它们。然而，为了做到这一点，我们需要一种机制，通过轮询文件系统，我们可以定期检查是否有新的图像可用。实现这一点的简单而有效的方法是检查图像文件的修改时间。每当它发生变化时，我们就知道有新的图像可供我们使用。为了帮助不同的应用程序执行此任务，我们将功能放入一个库中，它们都可以导入和使用。
- en: 'The `sys` module will be used to read command line arguments, and the `time`
    module will be used to pause between checks for file changes. The `getmtime` function
    will give us the modification time of the image file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys`模块将被用来读取命令行参数，而`time`模块将被用来在检查文件更改之间暂停。`getmtime`函数将给我们提供图像文件的修改时间：'
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `FileWatcher` class receives the `path` to watch and initialize the `last_mtime`
    attribute to `None` when a new instance is created. Each time the `has_changed`
    method is called, it gets the current modification time of the file being watched
    and returns whether this value has changed since it was last checked:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileWatcher` 类在创建新实例时接收要监视的 `path`，并将 `last_mtime` 属性初始化为 `None`。每次调用 `has_changed`
    方法时，它都会获取正在监视的文件的当前修改时间，并返回自上次检查以来此值是否已更改：'
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The library has a `main` function that can be used to test the `FileWatcher`
    class. It saves the first command line argument in the `path` variable. Then,
    it creates a `FileWatcher` instance to watch the specified path. Next, it loops
    10 times and checks the file for changes at a rate of 60 frames per second. In
    each loop, it prints out whether a change was detected:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该库有一个 `main` 函数，可以用来测试 `FileWatcher` 类。它将第一个命令行参数保存到 `path` 变量中。然后，它创建一个 `FileWatcher`
    实例来监视指定的路径。接下来，它以每秒 60 帧的速度循环 10 次，并检查文件是否有变化。在每次循环中，它都会打印出是否检测到变化：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The full script can be saved as `watcher.py` on the Pi and then executed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 完整脚本可以保存为 `watcher.py` 在 Pi 上，然后执行。
- en: 'Listing 10.3 `watcher.py`: Watching a file for changes'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.3 `watcher.py`：监视文件变化
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In one terminal, keep our previous `stream_save.py` running so that it keeps
    saving the latest frames to the `robo_stream.jpg` file. Then, execute the `watcher.py`
    script in another terminal and provide it with the stream image to watch. The
    following session shows the script being executed and the output generated:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个终端中，保持我们之前的 `stream_save.py` 运行，以便它持续将最新帧保存到 `robo_stream.jpg` 文件中。然后，在另一个终端中执行
    `watcher.py` 脚本，并为其提供要监视的流图像。以下会话显示了脚本的执行和生成的输出：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The camera is capturing images at a rate of 30 frames per second, and we are
    polling the image file for changes at a rate of 60 frames per second. This creates
    the expected pattern of the file alternating between changed and not changed to
    exactly match the rate of images being captured from the video stream.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像机以每秒 30 帧的速度捕获图像，而我们以每秒 60 帧的速度轮询图像文件的变化。这会创建一个预期的模式，文件在已更改和未更改之间交替，以精确匹配从视频流中捕获的图像速率。
- en: 10.4.3 Streaming to a graphical application
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3 将流式传输发送到图形应用程序
- en: 'With the `watcher` library in place, we can move on and create a graphical
    application that uses it to watch for changes in the streaming image and display
    the updated image whenever it changes. The `os` module is imported so that we
    can access environment variables. The `cv2` module will be used to display images
    in the application, and the `FileWatcher` will detect changes to the streaming
    image file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `watcher` 库就绪后，我们可以继续创建一个使用它来监视流式图像变化并显示更新图像的图形应用程序。导入 `os` 模块以便我们可以访问环境变量。在应用程序中，将使用
    `cv2` 模块显示图像，`FileWatcher` 将检测流式图像文件的变化：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `IMG_PATH` variable points to the streaming image file path. `ESC_KEY`
    has the value for the key code of the Esc key:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMG_PATH` 变量指向流式图像文件路径。`ESC_KEY` 包含 Esc 键的键码值：'
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `main` function creates a `FileWatcher` object in the variable `watcher`
    and then enters into an event loop. The event loop will keep looping until the
    Esc key or Q key is pressed. In each loop cycle, the image file is checked for
    a change by calling the `has_changed` method. If a change is detected, the `imread`
    function is called to read the new image, and then `imshow` is called to display
    the image:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数在变量 `watcher` 中创建一个 `FileWatcher` 对象，然后进入事件循环。事件循环将一直循环，直到按下 Esc 键或
    Q 键。在每次循环周期中，通过调用 `has_changed` 方法检查图像文件是否有变化。如果检测到变化，则调用 `imread` 函数读取新的图像，然后调用
    `imshow` 显示图像：'
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The full script can be saved as `stream_view.py` on the Pi and then executed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 完整脚本可以保存为 `stream_view.py` 在 Pi 上，然后执行。
- en: 'Listing 10.4 `stream_view.py`: Showing video streaming in a graphical application'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 `stream_view.py`：在图形应用程序中显示视频流
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Make sure to have `stream_save.py` running in another terminal. Now, when you
    run `stream_view.py`, you can see a live view of the video streaming coming from
    the camera. Unlike the camera applications in previous chapters, you can start
    the application multiple times, and each one will stream the video images simultaneously.
    If you try to do this with the `snapshot.py` application from chapter 8, it will
    fail because you cannot have more than one application directly capturing frames
    from the video stream at the same time. With this filesystem-based mechanism of
    sharing video stream images, we can safely have as many applications as we like
    accessing and working with live video images. Figure 10.5 shows multiple graphical
    applications running at the same time and being able to stream the same video
    stream simultaneously.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在另一个终端中运行`stream_save.py`。现在，当你运行`stream_view.py`时，你可以看到来自摄像头的实时视频流。与前面章节中的摄像头应用不同，你可以多次启动应用，每个应用将同时传输视频图像。如果你尝试使用第8章中的`snapshot.py`应用来做这件事，它会失败，因为你不能同时有多个应用直接从视频流中捕获帧。通过这种基于文件系统的视频流图像共享机制，我们可以安全地有任意多的应用访问并处理实时视频图像。图10.5显示了同时运行多个图形应用，并且能够同时传输相同的视频流。
- en: '![](../Images/CH10_F05_Alsabbagh.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F05_Alsabbagh.png)'
- en: 'Figure 10.5 Graphical application video streaming: multiple windows can read
    the video stream.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 图形应用视频流：多个窗口可以读取视频流。
- en: Since we’ve got our videos streaming in graphical applications, we can now try
    and add QR code detection functionality to our video streaming applications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在我们的图形应用中实现了视频流，我们现在可以尝试将二维码检测功能添加到我们的视频流应用中。
- en: 10.4.4 Detecting QR codes in a video stream
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.4 在视频流中检测二维码
- en: 'This next application will let us do QR code detection on the live video stream.
    Any detected QR codes will be marked on the image, and the decoded text will be
    displayed in the application. This application essentially combines the code and
    logic from the scripts `detect_qr.py` and `stream_view.py`. We import and use
    the same three modules from the `stream_view.py` script:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个应用将允许我们在实时视频流中进行二维码检测。任何检测到的二维码都将标记在图像上，解码后的文本将在应用中显示。此应用本质上结合了`detect_qr.py`和`stream_view.py`脚本中的代码和逻辑。我们从`stream_view.py`脚本中导入并使用了相同的三个模块：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `IMG_PATH` and `ESC_KEY` variables are taken from `stream_view.py` and
    serve the same purpose. The `BLUE` and `FONT` variables will be used to set the
    color and font for drawing in the application. The `decoder` object will perform
    our QR code decoding:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMG_PATH`和`ESC_KEY`变量来自`stream_view.py`，并具有相同的作用。`BLUE`和`FONT`变量将用于设置应用中绘图的颜色和字体。`decoder`对象将执行我们的二维码解码：'
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first four lines of the `main` function are identical to the ones in `stream_view.py`
    and will take care of detecting new images and handling the event loop. Once a
    new image is detected, the `decode_qrcode` function is called to decode the QR
    code and draw a box around any detected codes. The `decode_qrcode` and `draw_box`
    functions are identical to the ones defined in `detect_qr.py`. The last part of
    the function displays the image by calling `cv2.imshow`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数的前四行与`stream_view.py`中的相同，将负责检测新图像和处理事件循环。一旦检测到新图像，就会调用`decode_qrcode`函数来解码二维码并在任何检测到的代码周围绘制一个框。`decode_qrcode`和`draw_box`函数与在`detect_qr.py`中定义的相同。函数的最后部分通过调用`cv2.imshow`来显示图像：'
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The full script can be saved as `stream_qr.py` on the Pi and then executed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 完整脚本可以保存为Pi上的`stream_qr.py`并执行。
- en: 'Listing 10.5 `stream_qr.py`: Detecting QR codes in a streaming video'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.5 `stream_qr.py`：在流媒体视频中检测二维码
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Make sure to have `stream_save.py` running in another terminal. Now, when you
    run `stream_qr.py`, you can see a live view of the video streaming coming from
    the camera. Any QR codes detected in the image from the video stream will be marked.
    Figure 10.6 shows the QR code for the QR code used to mark the starting position
    of the track being detected.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在另一个终端中运行`stream_save.py`。现在，当你运行`stream_qr.py`时，你可以看到来自摄像头的实时视频流。视频流图像中检测到的任何二维码都将被标记。图10.6显示了用于标记正在检测的轨迹起始位置的二维码。
- en: '![](../Images/CH10_F06_Alsabbagh.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F06_Alsabbagh.png)'
- en: 'Figure 10.6 Detecting QR codes in live video: detected QR codes are marked
    on live video.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 在实时视频中检测二维码：检测到的二维码在实时视频中标记。
- en: This script can come very much in handy to test the QR code detection for the
    printed-out labels. When printing the labels, it is important to not print them
    out too small, or the camera will not be able to easily detect them. A width and
    height of 6 cm for the QR codes have been tested and work well. Figure 10.7 shows
    how the exact dimensions of a QR code label can be set in LibreOffice Writer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本对于测试打印标签的 QR 码检测非常有用。在打印标签时，重要的是不要将它们打印得太小，否则相机将无法轻松检测到它们。已经测试了 6 厘米的宽度和高度，对于
    QR 码来说效果良好。图 10.7 展示了如何在 LibreOffice Writer 中设置 QR 码标签的确切尺寸。
- en: '![](../Images/CH10_F07_Alsabbagh.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F07_Alsabbagh.png)'
- en: 'Figure 10.7 QR code label size: it is important to correctly set the size of
    printed QR codes.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 QR 码标签尺寸：正确设置打印 QR 码的大小非常重要。
- en: We can now move on to the next challenge of getting the images from the camera
    to stream into web browsers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续下一个挑战，即将图像从相机传输到流式传输到网络浏览器。
- en: 10.4.5 Streaming to a web browser
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.5 流式传输到网络浏览器
- en: Streaming the camera video to a format that web browsers can understand opens
    new and powerful functionality for our robotic web applications, namely, the ability
    for a web application to get a live video feed and see exactly what the robot
    sees at that point in time. This will be a new functionality that wasn’t available
    in our previous robot web applications.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将相机视频流式传输到网络浏览器可以理解的格式，为我们的机器人网络应用程序打开了新的强大功能，即网络应用程序能够获取实时视频流并看到机器人当时所看到的场景。这将是一个我们之前机器人网络应用程序中不可用的新功能。
- en: The Motion JPEG video format will be used in this application to transmit a
    continuous stream of video images to the connected web browser. This format is
    widely used for video streaming and sends a series of JPEG images to the web browser,
    which are then played back in the web browser like any other video content.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在此应用程序中，将使用 Motion JPEG 视频格式来传输连续的视频图像流到连接的网络浏览器。此格式广泛用于视频流，并向网络浏览器发送一系列 JPEG
    图像，然后在网络浏览器中回放，就像其他任何视频内容一样。
- en: 'The `os` module will be used to read environment variables, and `FileWatcher`
    will watch for changes in the image file. The Tornado web framework will be used
    to create the web application. The `asyncio` is part of the Python standard library
    and will be used to run the `tornado` main event loop:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用 `os` 模块读取环境变量，`FileWatcher` 将监视图像文件的变化。将使用 Tornado 网络框架创建网络应用程序。`asyncio`
    是 Python 标准库的一部分，将用于运行 `tornado` 主事件循环：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `IMG_PATH` variable points to our image file that we will use to check
    for new images and read them as they are detected. The frequency of polling for
    changes is defined in `POLL_DELAY` and is set at 60 times per second. It is twice
    the speed of the camera frame rate, so it should be more than sufficient to detect
    any new video frames:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMG_PATH` 变量指向我们将用于检查新图像并读取它们的图像文件。更改的轮询频率在 `POLL_DELAY` 中定义，设置为每秒 60 次。这是相机帧速率的两倍，因此应该足以检测到任何新的视频帧：'
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `CONTENT_TYPE` variable stores the HTTP content type for Motion JPEG content.
    It also defines the boundary value that will be used to mark new images. `BOUNDARY`
    contains the boundary value and the bytes that need to be sent between images.
    The `JPEG_ HEADER` has the content type for each JPEG image that will be sent
    in the video stream:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`CONTENT_TYPE` 变量存储了 Motion JPEG 内容的 HTTP 内容类型。它还定义了将用于标记新图像的边界值。`BOUNDARY`
    包含边界值和需要在图像之间发送的字节。`JPEG_HEADER` 包含将发送到视频流中的每个 JPEG 图像的内容类型：'
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `MainHandler` class implements the `get` method, which is called when an
    incoming HTTP GET request comes to the server and will respond by streaming video
    content to the browser. It first sets the `Content-Type` of the response to Motion
    JPEG and then creates a `FileWatcher` object to watch for changes to the stream
    image file. Next, it enters an infinite loop where, whenever a new image is detected,
    it is read and sent to the browser with the associated boundary and JPEG HTTP
    headers. We then call `self.flush` to send the content to the browser. `asyncio.sleep`
    is called to sleep for the specified polling duration:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainHandler` 类实现了 `get` 方法，该方法在接收到服务器上的 HTTP GET 请求时被调用，并通过向浏览器流式传输视频内容进行响应。它首先将响应的
    `Content-Type` 设置为 Motion JPEG，然后创建一个 `FileWatcher` 对象来监视流图像文件的变化。接下来，它进入一个无限循环，每当检测到新图像时，它就会读取并发送带有相关边界和
    JPEG HTTP 标头的图像到浏览器。然后我们调用 `self.flush` 将内容发送到浏览器。使用 `asyncio.sleep` 暂停指定的轮询持续时间：'
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `main` function first defines a `tornado.web.Application` object that maps
    the top-level path to the `MainHandler` class. It then listens on port `9000`
    for incoming HTTP requests and then calls `shutdown_event.wait()` to wait for
    a shutdown event:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数首先定义了一个`tornado.web.Application`对象，它将顶级路径映射到`MainHandler`类。然后它在端口`9000`上监听传入的HTTP请求，然后调用`shutdown_event.wait()`等待关闭事件：'
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The full script can be saved as `stream_web.py` on the Pi and then executed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 完整脚本可以保存为`stream_web.py`在Pi上，然后执行。
- en: 'Listing 10.6 `stream_web.py`: Streaming video to web applications'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.6 `stream_web.py`：将视频流传输到Web应用程序
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In one terminal, keep our previous `stream_save.py` running so that it keeps
    saving the latest frames to the `robo_stream.jpg` file. Then execute the `stream_web.py`
    script in another terminal. You can access the web application by visiting the
    address `http:// robopi:9000` from a computer on your network. You can also access
    the web app by replacing RoboPi in the URL with the IP address of your robot.
    When accessing the web app from a mobile device, using the IP address will be
    an easier option. Figure 10.8 shows what the video stream looks like when accessed
    on a mobile device. In this example, the live video stream was viewed on an Android
    mobile device over a Wi-Fi network.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个终端中，保持之前的`stream_save.py`运行，以便它持续将最新帧保存到`robo_stream.jpg`文件中。然后在另一个终端中执行`stream_web.py`脚本。您可以通过访问网络上的计算机上的地址`http://robopi:9000`来访问Web应用程序。您也可以通过将URL中的RoboPi替换为机器人的IP地址来访问Web应用程序。当从移动设备访问Web应用程序时，使用IP地址将是一个更方便的选择。图10.8显示了在移动设备上访问时的视频流外观。在这个例子中，实时视频流是通过Wi-Fi网络在Android移动设备上查看的。
- en: '![](../Images/CH10_F08_Alsabbagh.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F08_Alsabbagh.png)'
- en: 'Figure 10.8 Web application video streaming: the image shows streaming over
    the web to a mobile device.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 Web应用程序视频流：图像显示了通过Web传输到移动设备。
- en: Compared to the graphical application, the web-based approach offers greater
    flexibility, as any modern web browsers on any mobile or desktop computer can
    be used to access the video stream. Once again, there is the added benefit that
    many computers and devices can access and view the video stream simultaneously
    without any problems.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与图形应用程序相比，基于Web的方法提供了更大的灵活性，因为任何现代的移动或桌面计算机上的Web浏览器都可以用来访问视频流。再次强调，这是一个额外的优点，即许多计算机和设备可以同时无问题地访问和查看视频流。
- en: 10.5 Moving the robot to a target QR code
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 将机器人移动到目标QR码
- en: 'We can now take on the final challenge in this chapter of driving the robot
    along the track until it finds a specific QR code. We need to create a Python
    application that meets the following requirements:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以接受本章的最终挑战，即沿着轨道驾驶机器人直到找到特定的QR码。我们需要创建一个满足以下要求的Python应用程序：
- en: The name of the target QR code should be provided as the first command line
    argument.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标QR码的名称应作为第一个命令行参数提供。
- en: The robot should be driven in the forward direction while continually scanning
    for QR codes.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人应在不断扫描QR码的同时向前行驶。
- en: The robot should stop when the target QR code is first detected.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人应在首次检测到目标QR码时停止。
- en: We can place many objects with QR codes on them along the robot track and use
    this technique to ask the robot to go to one of these specific locations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在机器人轨道上放置许多带有QR码的物体，并使用这种技术让机器人前往这些特定位置之一。
- en: 10.5.1 Find the QR code
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.1 查找QR码
- en: As the robot moves along the track, it will keep checking the video stream for
    any detected QR codes. If it finds a QR code, it will compare its value to the
    target that we are looking for. If it finds a match, we stop the robot. For safety,
    we will also provide a maximum number of moves the robot can make so that it doesn’t
    crash into the end of the track. Figure 10.9 shows the camera mounted on the side
    of the robot right above the wheel so that it can capture QR codes of the objects
    it drives by.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当机器人沿着轨道移动时，它将不断检查视频流中是否有检测到的QR码。如果它找到一个QR码，它将比较其值与我们正在寻找的目标。如果找到匹配项，我们停止机器人。为了安全起见，我们还将提供一个机器人可以移动的最大次数，以防止它撞到轨道的末端。图10.9显示了安装在机器人侧面的摄像头，正好位于轮子上方，以便它可以捕获它经过的物体的QR码。
- en: '![](../Images/CH10_F09_Alsabbagh.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F09_Alsabbagh.png)'
- en: 'Figure 10.9 Side camera: the camera is mounted on the side of the robot above
    the wheel.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 侧摄像头：摄像头安装在机器人侧面的轮子上方。
- en: 'The `os` module will be used to read environment variables, and `sys` will
    get command line arguments. We will use `cv2` to do the QR detection and `motor`
    to move the robot motors:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用 `os` 模块读取环境变量，`sys` 将获取命令行参数。我们将使用 `cv2` 进行 QR 码检测，并使用 `motor` 控制机器人电机：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `MAX_MOVES` variable sets a limit of 20 moves before the robot gives up
    on finding its target. `IMG_PATH` points to the video stream image, and `decoder`
    will be used to decode the QR codes:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAX_MOVES` 变量设置了一个限制，在机器人放弃寻找目标之前，最多移动 20 次。`IMG_PATH` 指向视频流图像，而 `decoder`
    将用于解码 QR 码：'
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `decode_qr` function reads the latest image from the video stream and attempts
    to decode any QR codes found in the image. The decoded data is then returned:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`decode_qr` 函数从视频流中读取最新图像，并尝试解码图像中发现的任何 QR 码。解码后的数据随后返回：'
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `goto` function loops the number of times specified in `MAX_MOVES`. In
    each loop, it moves the robot forward at the lowest speed for 0.1 seconds. It
    then decodes QR code data from the latest video image and prints out its progress
    so far, as well as whatever data it has just decoded. If the decoded data matches
    the value of `target`, we return the `True` value to indicate a successful search.
    If we have exceeded `MAX_MOVES`. then we return `False` to indicate the search
    for `target` was unsuccessful:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto` 函数循环执行 `MAX_MOVES` 中指定的次数。在每次循环中，它以最低速度将机器人向前移动 0.1 秒。然后，它从最新视频图像中解码
    QR 码数据，并打印出迄今为止的进度以及它刚刚解码的数据。如果解码的数据与 `target` 的值匹配，我们返回 `True` 值以指示成功搜索。如果我们超过了
    `MAX_MOVES`，则返回 `False` 以指示搜索 `target` 未成功：'
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `main` function gets the value of `target` from the first command line
    argument. It prints out the value and then calls `goto` with `target`. Finally,
    the result of the search is saved and printed out:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数从第一个命令行参数获取 `target` 的值。它打印出该值，然后调用 `goto` 并传入 `target`。最后，搜索的结果被保存并打印出来：'
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The full script can be saved as `goto_qr.py` on the Pi and then executed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 完整脚本可以保存为 `goto_qr.py` 并在 Pi 上执行。
- en: 'Listing 10.7 `goto_qr.py`: Searching and going to the target QR code'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 `goto_qr.py`：搜索并前往目标 QR 码
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Make sure to keep `stream_save.py` running in another terminal so that it keeps
    saving the latest frames to the filesystem. Then, execute the `goto_qr.py` script
    in another terminal. You can also watch what the robot is seeing by using either
    `stream_view.py` or `stream_web.py`. The following session shows the script being
    executed and the output it generated:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在另一个终端中运行 `stream_save.py`，以便它持续将最新帧保存到文件系统中。然后，在另一个终端中执行 `goto_qr.py` 脚本。您还可以通过使用
    `stream_view.py` 或 `stream_web.py` 来观看机器人所看到的。以下会话显示了脚本的执行和它生成的输出：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We asked the robot to search for a target called `start`. The robot made four
    movements before successfully going to the marker with the `start` QR code. The
    search then ended and was reported as a success. Let’s see what happens when we
    search for a target further down the track:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让机器人搜索一个名为 `start` 的目标。机器人移动了四次，然后成功到达了带有 `start` QR 码的标记。搜索随后结束，并报告为成功。让我们看看当我们搜索轨道更远处的目标时会发生什么：
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can see that the robot encountered the `start` marker again during movement
    number `4`. As it kept searching, it finally got to the target `end` at movement
    number `12`. Like before, it then returned with a return value indicating a successful
    search. Let’s try asking the robot to find a target that doesn’t exist and see
    what happens:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在移动次数 `4` 时，机器人再次遇到了 `start` 标记。在持续搜索后，它最终在移动次数 `12` 时到达了目标 `end`。像之前一样，它随后返回，并返回一个表示成功搜索的返回值。让我们尝试让机器人寻找一个不存在的目标，看看会发生什么：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The robot has exceeded the maximum number of permitted movements without finding
    its target. It returned with a `False` value to indicate the search was unsuccessful.
    This covers the scenario of searching for an object that does not exist.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人超过了允许的最大移动次数，但没有找到其目标。它返回了一个 `False` 值以指示搜索未成功。这涵盖了搜索不存在物体的场景。
- en: 'Robots in the real world: Warehouse robots'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的机器人：仓库机器人
- en: Robots have been increasingly used in warehouses to retrieve items that are
    to be shipped to customers. The Smart Warehouse ([http://mng.bz/ored](http://mng.bz/ored))
    article by Supply Chain Today shows different types of automation that Amazon
    uses in its warehouse.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人越来越多地被用于仓库中检索即将运送给客户的物品。Supply Chain Today 的 Smart Warehouse ([http://mng.bz/ored](http://mng.bz/ored))
    文章展示了亚马逊在其仓库中使用的不同类型的自动化。
- en: The mobile robots used in the warehouse to move items around different locations
    employ an interesting navigation mechanism. They have cameras on the bottom that
    read QR codes on the floor. The warehouse floor is filled with QR codes in a grid
    pattern that the robots can read to find out exactly where they are in the warehouse.
    This approach is very similar to how the robot in this chapter reads QR codes
    in its environment to navigate to a specific location.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库中使用的移动机器人，用于在不同位置移动物品，采用了一种有趣的导航机制。它们在底部有摄像头，可以读取地面的二维码。仓库地板上布满了以网格图案排列的二维码，机器人可以读取这些二维码以确定它们在仓库中的确切位置。这种方法与本章中机器人读取其环境中二维码以导航到特定位置的方式非常相似。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The OpenCV computer vision library is used to detect QR codes in images, as
    well as to read the data encoded in the QR code itself.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenCV计算机视觉库在图像中检测二维码，以及读取二维码中编码的数据。
- en: The robot will use the DC motors to move back and forth along a set track.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人将使用直流电机在一条设定的轨道上来回移动。
- en: The more data you put in a QR code, the larger the symbol version becomes, which
    in turn generates a denser QR code.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在二维码中放入的数据越多，符号版本就越大，这反过来又生成一个更密集的二维码。
- en: Detected QR codes have four points relating to the four corners of a quadrangle.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测到的二维码有四个点，分别对应于四边形的四个角。
- en: A ramdisk is used to stream video images, as this will not create additional
    disk workload.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ramdisk来流式传输视频图像，因为这不会创建额外的磁盘工作负载。
- en: Changes to the streaming image are checked by polling the filesystem on a regular
    basis.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定期轮询文件系统来检查流媒体图像的变化。
- en: The Motion JPEG video format is used in web video streaming applications to
    transmit a continuous stream of video images to web browsers.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络视频流应用中使用Motion JPEG视频格式，以向网络浏览器传输连续的视频图像流。
