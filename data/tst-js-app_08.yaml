- en: 6 Testing frontend applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 测试前端应用程序
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Replicating a browser’s JavaScript environment in your tests
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试中复制浏览器的 JavaScript 环境
- en: Asserting on DOM elements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 DOM 元素进行断言
- en: Handling and testing events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理和测试事件
- en: Writing tests involving browser APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写涉及浏览器 API 的测试
- en: Handling HTTP requests and WebSocket connections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 HTTP 请求和 WebSocket 连接
- en: Trying to write a client-side application without using JavaScript is as difficult
    as baking a dessert without carbohydrates. JavaScript was born to conquer the
    web, and in browsers, it has shone.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写一个不使用 JavaScript 的客户端应用程序，就像在没有碳水化合物的情况下烘焙甜点一样困难。JavaScript 是为了征服网络而生的，在浏览器中，它闪耀着光芒。
- en: In this chapter, we’ll cover the fundamentals of testing frontend applications.
    Together, we’ll build a small web client for the backend we wrote in chapter 4
    and learn how to test it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍测试前端应用程序的基础知识。我们将一起构建一个用于第 4 章中编写后端的小型网络客户端，并学习如何测试它。
- en: During the process of building and testing this application, I’ll explain the
    peculiarities of running JavaScript within a browser, and, because Jest *can’t*
    run in a browser, I’ll teach you how to simulate that environment within Node.js.
    Without being able to emulate a browser’s environment in Jest, you wouldn’t be
    able to use it to test your frontend applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和测试此应用程序的过程中，我将解释在浏览器中运行 JavaScript 的特殊性，由于 Jest*不能*在浏览器中运行，我将教您如何在 Node.js
    中模拟该环境。如果不能在 Jest 中模拟浏览器环境，您就无法使用它来测试您的前端应用程序。
- en: When testing frontend applications, assertions can become more challenging,
    because now you’re dealing not *only* with a function’s return value but also
    with its interaction with the DOM. Therefore, you will learn how to find elements
    within your tests and perform assertions on their contents.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试前端应用程序时，断言可能会变得更加困难，因为现在您不仅要处理函数的返回值，还要处理它与 DOM 的交互。因此，您将学习如何在测试中找到元素并对它们的内
    容进行断言。
- en: The way users interact with frontend applications is also significantly different
    from how they interact with backend applications. Whereas servers receive input
    through, for example, HTTP, CoAP, or MQTT, web clients have to deal with users
    scrolling, clicking, typing, and dragging, which are harder to simulate accurately.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 用户与前端应用程序的交互方式也与他们与后端应用程序的交互方式显著不同。服务器通过例如 HTTP、CoAP 或 MQTT 接收输入，而网络客户端必须处理用户的滚动、点击、输入和拖动，这些更难准确模拟。
- en: To learn how you can handle those elaborate interactions, I’ll explain how events
    work and how you can trigger them as a browser would. Learning how to simulate
    user behavior appropriately is critical to making your tests closely resemble
    what happens at run time. This resemblance will enable you to extract from your
    tests as much value as you can, increasing the number of bugs you can catch before
    reaching production.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解您如何处理这些复杂的交互，我将解释事件是如何工作的，以及您如何像浏览器一样触发它们。适当地模拟用户行为对于使您的测试尽可能接近运行时发生的情况至关重要。这种相似性将使您能够从测试中获得尽可能多的价值，增加在达到生产之前可以捕获的错误数量。
- en: Let’s say, for example, that you have an input field whose content is validated
    every time a user enters a character. If in your tests you change the input’s
    content all at once, you will *not* trigger the multiple validations that would
    have happened at run time. Because your tests would simulate a situation different
    from what happens in production, your tests would be unreliable. For example,
    you wouldn’t catch bugs that happen only as users type.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，你有一个输入字段，其内容在用户输入每个字符时都会被验证。如果在你的测试中你一次性更改输入的内容，你将*不会*触发在运行时发生的多次验证。因为你的测试会模拟一个与生产环境中发生的情况不同的场景，所以你的测试将不可靠。例如，你不会捕获到仅在用户输入时发生的错误。
- en: Besides being able to handle complex interactions, browsers also provide many
    exciting APIs that you can use to store data or manipulate the navigation history,
    for example. Even though you don’t need to test these APIs themselves, it’s crucial
    to validate whether your code interfaces adequately with them. Otherwise, your
    application may not work as it should.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够处理复杂的交互外，浏览器还提供了许多您可以使用来存储数据或操作导航历史记录等功能的令人兴奋的 API。即使您不需要测试这些 API 本身，验证您的代码是否充分与它们接口也是至关重要的。否则，您的应用程序可能无法按预期工作。
- en: By using the History and the Web Storage API, you’ll understand how to approach
    testing features that involve browser APIs. You’ll learn what you should test,
    what you should *not* test, and, most importantly, how to test it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用历史和Web存储API，你将了解如何测试涉及浏览器API的功能。你将学习你应该测试什么，不应该测试什么，最重要的是，如何进行测试。
- en: Finally, at the end of this chapter, you’ll see how to handle interactions with
    third parties through HTTP requests or WebSocket connections, two of the most
    common ways of gathering data on the web. Just like you’ve done when testing backend
    applications, you’ll learn how to handle these interactions reliably and without
    creating maintenance overhead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在本章的结尾，你将了解到如何通过HTTP请求或WebSocket连接与第三方进行交互，这两种方式是网络上收集数据最常见的方法之一。就像你在测试后端应用程序时所做的那样，你将学习如何可靠地处理这些交互，同时不产生维护开销。
- en: The main goal of this chapter is to teach you the **fundamentals** required
    to test *any* frontend applications. Because you will learn the role of each tool,
    and how they work behind the scenes, these concepts will be useful no matter whether
    you’re testing an application written in Vue.js or React.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是教你测试**任何**前端应用程序所需的**基础**。因为你将学习每个工具的作用以及它们在幕后是如何工作的，所以无论你是在测试用Vue.js编写的应用程序还是React编写的应用程序，这些概念都将是有用的。
- en: A solid understanding of how to test “raw” frontend applications makes it easier
    to test any other libraries or frameworks you may use in the future.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对如何测试“原始”前端应用程序有扎实的理解，将使你更容易测试你未来可能使用的任何其他库或框架。
- en: You’ll learn these concepts by building a frontend application for Louis’s staff
    to manage their stock. At first, you’ll only allow users to add cheesecakes to
    the inventory and learn how to run your application’s code within Node.js so that
    you can test it using Jest.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过为路易斯的员工构建一个前端应用程序来管理他们的库存来学习这些概念。一开始，你只允许用户将奶酪蛋糕添加到库存中，并学习如何在Node.js中运行你的应用程序代码，以便你可以使用Jest进行测试。
- en: As you progress through these sections, you’ll add new functionality and learn
    how to test it and which tools to use. You will, for example, allow Louis’s staff
    to add any quantity of any desserts they want and validate their inputs to prevent
    them from making mistakes. Then, if they do make a mistake, you’ll enable them
    to revert it with an `undo` button, which interacts with the browser’s History
    API.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对这些章节的深入，你将添加新的功能，并学习如何测试它们以及使用哪些工具。例如，你将允许路易斯的员工添加他们想要的任何数量的任何甜点，并验证他们的输入以防止他们犯错。然后，如果他们确实犯了错误，你将使他们能够通过一个`撤销`按钮来恢复，这个按钮与浏览器的历史API进行交互。
- en: Finally, in this chapter’s final section, you’ll make the application update
    itself without requiring users to refresh the page. As operators add items, any
    members of the staff will be able to see, in real time, which ingredients the
    chefs are consuming and which desserts customers are buying.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在本章的最后部分，你将使应用程序能够自动更新，而无需用户刷新页面。当操作员添加项目时，任何员工都将能够实时看到厨师正在消耗哪些原料，以及顾客正在购买哪些甜点。
- en: By testing these features, which cover different aspects involved in writing
    a frontend application, you’ll be able to test any functionality that Louis might
    ask you to implement in the future.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测试这些功能，这些功能涵盖了编写前端应用程序所涉及的不同方面，你将能够测试路易斯未来可能要求你实现的所有功能。
- en: Hopefully, the staff will be as delighted by how well your software works as
    customers are delighted by how good the bakery’s cheesecakes taste.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 希望员工们对你的软件工作得有多好，就像顾客对糕点店的奶酪蛋糕味道有多满意一样。
- en: 6.1 Introducing JSDOM
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 介绍JSDOM
- en: Baking in a professional kitchen is quite different from baking at home. At
    home, you won’t always have all the unique ingredients you would find in a chef’s
    shelves. You probably won’t have the same fancy appliances or the same impeccable
    kitchen. Nevertheless, that doesn’t mean you can’t bake excellent desserts. You
    just have to adapt.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业厨房烘焙与在家烘焙大不相同。在家烘焙时，你不会总是拥有厨师架子上所有独特的原料。你可能不会有同样复杂的设备或同样完美的厨房。尽管如此，这并不意味着你不能烘焙出美味的甜点。你只需要适应。
- en: Similarly, running JavaScript in a browser is significantly different from running
    JavaScript in Node.js. Depending on the occasion, the JavaScript code running
    in a browser can’t run in Node.js at all and vice versa. Therefore, for you to
    test your frontend application, you’ll have to go through a few extra hoops, but
    it doesn’t mean you can’t do it. With a few adaptations, you can use Node.js to
    run JavaScript that’s been written for the browser in the same way that Louis
    can bake mouth-watering cheesecakes at home without the fancy French cookware
    he has at the bakery.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在浏览器中运行JavaScript与在Node.js中运行JavaScript有显著不同。根据情况，在浏览器中运行的JavaScript代码根本不能在Node.js中运行，反之亦然。因此，为了测试你的前端应用程序，你可能需要走一些额外的步骤，但这并不意味着你不能做到。通过一些调整，你可以使用Node.js以与路易在面包店使用他拥有的花哨的法式厨具在家烘焙令人垂涎的奶酪蛋糕相同的方式运行为浏览器编写的JavaScript。
- en: In this section, you’ll learn how to use Node.js and Jest to test code written
    to run in a browser.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用Node.js和Jest来测试为在浏览器中运行而编写的代码。
- en: Within a browser, JavaScript has access to different APIs and thus has different
    capabilities.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，JavaScript可以访问不同的API，因此具有不同的功能。
- en: In browsers, JavaScript has access to a global variable called `window`. Through
    the `window` object, you can change a page’s content, trigger actions in a user’s
    browser, and react to events, like clicks and keypresses.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，JavaScript可以访问一个名为`window`的全局变量。通过`window`对象，你可以更改页面的内容，在用户的浏览器中触发操作，并对事件做出反应，如点击和按键。
- en: Through `window`, you can, for example, attach a listener to a button so that
    each time a user clicks it, your application updates the quantity of an item in
    the bakery’s inventory.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`window`，例如，你可以将监听器附加到按钮上，以便每次用户点击它时，你的应用程序都会更新面包店库存中商品的数量。
- en: Try creating an application that does exactly that. Write an HTML file that
    contains a button and a count and that loads a script called `main.js`, as shown
    next.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建一个执行此操作的应用程序。编写一个包含按钮和计数的HTML文件，并加载一个名为`main.js`的脚本，如下所示。
- en: Listing 6.1 index.html
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 index.html
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ The script with which we’ll make the page interactive
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们将用来使页面交互的脚本
- en: In `main.js`, find the button by its ID, and attach a listener to it. Whenever
    users click this button, the listener will be triggered, and the application will
    increment the cheesecake count.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.js`中，通过其ID找到按钮，并将其监听器附加到它上。每次用户点击此按钮时，监听器都会被触发，应用程序将增加奶酪蛋糕的数量。
- en: Listing 6.2 main.js
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2 main.js
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ The function that updates the application’s state
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 更新应用程序状态的函数
- en: ❷ Attaching an event listener that will cause incrementCount to be called whenever
    the button is clicked
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当按钮被点击时，将调用incrementCount的事件监听器
- en: To see this page in action, execute `npx http-server ./` in the same folder
    as your `index.html`, and then access `localhost:8080`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此页面的实际效果，请在与你的`index.html`相同的文件夹中执行`npx http-server ./`，然后访问`localhost:8080`。
- en: Because this script runs in a browser, it has access to `window`, and thus it
    can manipulate the browser and the elements in the page, as shown in figure 6.1.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个脚本在浏览器中运行，所以它能够访问`window`，因此它可以操作浏览器和页面中的元素，如图6.1所示。
- en: Unlike the browser, Node.js can’t run that script. If you try executing it with
    `node main.js`, Node.js will immediately tell you that it has found a `ReferenceError`
    because "`window is not defined`".
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与浏览器不同，Node.js不能运行该脚本。如果你尝试使用`node main.js`执行它，Node.js会立即告诉你它发现了一个`ReferenceError`，因为"`window
    is not defined`"。
- en: '![](../Images/CH06_F01_DaCosta.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F01_DaCosta.png)'
- en: Figure 6.1 The JavaScript environment within a browser
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 浏览器中的JavaScript环境
- en: That error happens because Node.js doesn’t have a `window`. Instead, because
    it was designed to run different kinds of applications, it gives you access to
    APIs such as `process`, which contains information about the current Node.js process,
    and `require`, which allows you to import different JavaScript files.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那个错误发生是因为Node.js没有`window`。相反，因为它被设计为运行不同类型的应用程序，所以它为你提供了访问`process`等API的权限，其中包含有关当前Node.js进程的信息，以及`require`，它允许你导入不同的JavaScript文件。
- en: For now, if you were to write tests for the `incrementCount` function, you’d
    have to run them in the browser. Because your script depends on DOM APIs, you
    wouldn’t be able to run these tests in Node.js. If you tried to do it, you’d run
    into the same `ReferenceError` you saw when you executed `node main.js`. Given
    that Jest depends on Node.js-specific APIs and therefore run *only* in Node.js,
    you also *can’t* use Jest.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果你要为`incrementCount`函数编写测试，你必须运行它们在浏览器中。因为你的脚本依赖于DOM API，你无法在Node.js中运行这些测试。如果你尝试这样做，你会遇到你在执行`node
    main.js`时看到的相同的`ReferenceError`。鉴于Jest依赖于Node.js特定的API，因此它只能在Node.js中运行，你也不能使用Jest。
- en: To be able to run your tests in Jest, **instead of running your tests within
    the browser, you can bring browser APIs to Node.js by using JSDOM**. You can think
    of JSDOM as an implementation of the browser environment that can run within Node.js.
    It implements web standards using pure JavaScript. For example, with JSDOM, you
    can emulate manipulating the DOM and attaching event listeners to elements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够在Jest中运行你的测试，**而不是在浏览器中运行测试，你可以通过使用JSDOM将浏览器API带到Node.js中**。你可以将JSDOM视为一个可以在Node.js中运行的浏览器环境实现。它使用纯JavaScript实现网络标准。例如，使用JSDOM，你可以模拟操作DOM并为元素附加事件监听器。
- en: JSDOM JSDOM is an implementation of web standards written purely in JavaScript
    that you can use in Node.js.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JSDOM JSDOM是纯JavaScript编写的网络标准实现，你可以在Node.js中使用。
- en: To understand how JSDOM works, let’s use it to create an object that represents
    `index.html` and that we can use in Node.js.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解JSDOM是如何工作的，让我们使用它来创建一个表示`index.html`的对象，我们可以在Node.js中使用它。
- en: First, create a `package.json` file with `npm init -y`, and then install JSDOM
    with `npm install --save jsdom`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`npm init -y`创建一个`package.json`文件，然后使用`npm install --save jsdom`安装JSDOM。
- en: By using `fs`, you will read the `index.html` file and pass its contents to
    JSDOM, so that it can create a representation of that page.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`fs`，你可以读取`index.html`文件并将其内容传递给JSDOM，以便它能够创建该页面的表示。
- en: Listing 6.3 page.js
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 page.js
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `page` representation contains properties that you’d find in a browser,
    such as `window`. Because you’re now dealing with pure JavaScript, you can use
    `page` in Node.js.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`page`表示包含你在浏览器中会找到的属性，例如`window`。因为你现在正在处理纯JavaScript，你可以在Node.js中使用`page`。'
- en: Try importing `page` in a script and interacting with it as you’d do in a browser.
    For example, you can try attaching a new paragraph to the `page`, as shown here.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在脚本中导入`page`并像在浏览器中一样与之交互。例如，你可以尝试将一个新段落附加到`page`上，如下所示。
- en: Listing 6.4 example.js
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.4 example.js
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Imports the JSDOM representation of the page
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入页面的JSDOM表示
- en: ❷ Creates a paragraph element
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个段落元素
- en: ❸ Updates the paragraph’s content
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 更新段落的文本内容
- en: ❹ Attaches the paragraph to the page
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将段落附加到页面上
- en: To execute the previous script in Node.js, run `node example.js`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Node.js中执行前面的脚本，请运行`node example.js`。
- en: With JSDOM, you can do almost everything you can do in a browser, including
    updating DOM elements, like `count`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSDOM，你可以做几乎在浏览器中能做的任何事情，包括更新DOM元素，如`count`。
- en: Listing 6.5 example.js
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5 example.js
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Updates the contents of the count element
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 更新计数元素的文本内容
- en: Thanks to JSDOM, you can run your tests in Jest, which, as I have mentioned,
    can run only in Node.js.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了JSDOM，你可以在Jest中运行你的测试，正如我之前提到的，Jest只能在Node.js中运行。
- en: By passing the value `"jsdom"` to Jest’s `testEnvironment` option, you can make
    it set up a global instance of JSDOM, which you can use when running your tests.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将值`"jsdom"`传递给Jest的`testEnvironment`选项，你可以让它设置一个全局的JSDOM实例，你可以在运行测试时使用它。
- en: To set up a JSDOM environment within Jest, as shown in figure 6.2, start by
    creating a new Jest configuration file called `jest.config.js`. In this file,
    export an object whose `testEnvironment` property’s value is `"jsdom"`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Jest中设置JSDOM环境，如图6.2所示，首先创建一个名为`jest.config.js`的新Jest配置文件。在这个文件中，导出一个对象，其`testEnvironment`属性的值是`"jsdom"`。
- en: '![](../Images/CH06_F02_DaCosta.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F02_DaCosta.png)'
- en: Figure 6.2 The JavaScript environment within Node.js
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 Node.js中的JavaScript环境
- en: Listing 6.6 jest.config.js
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.6 jest.config.js
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: NOTE At the time of this writing, Jest’s current version is 26.6\. In this version,
    `jsdom` is the default value for the Jest’s `testEnvironment`, so you don’t necessarily
    need to specify it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在撰写本文时，Jest的当前版本是26.6。在这个版本中，`jsdom`是Jest的`testEnvironment`的默认值，因此你不必指定它。
- en: If you don’t want to create a `jest.config.js` file manually, you can use `./node_modules/.bin/jest
    --init` to automate this process. Jest’s automatic initialization will then prompt
    you to choose a test environment and present you with a `jsdom` option.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想手动创建 `jest.config.js` 文件，可以使用 `./node_modules/.bin/jest --init`来自动化此过程。Jest
    的自动初始化将提示您选择测试环境，并为您提供 `jsdom` 选项。
- en: Now try to create a `main.test.js` file and import `main.js` to see what happens.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试创建一个 `main.test.js` 文件并将 `main.js` 导入以查看会发生什么。
- en: Listing 6.7 main.test.js
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 main.test.js
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you try to run this test with Jest, you will still get an error.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试使用 Jest 运行此测试，您仍然会得到一个错误。
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Even though `window` now exists, thanks to Jest setting up `JSDOM`, its DOM
    is not built from `index.html`. Instead, it’s built from an empty HTML document,
    and thus, no `increment-button` exists. Because the button does not exist, you
    can’t call its `addEventListener` method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `window` 现在存在，多亏了 Jest 设置的 `JSDOM`，其 DOM 并不是从 `index.html` 构建的。相反，它是由一个空的
    HTML 文档构建的，因此没有 `increment-button`。因为按钮不存在，所以您不能调用它的 `addEventListener` 方法。
- en: To use `index.html` as the page that the JSDOM instance will use, you need to
    read `index.html` and assign its content to `window.document.body.innerHTML` before
    importing `main.js`, as shown next.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `index.html` 作为 JSDOM 实例将使用的页面，您需要读取 `index.html` 并将其内容分配给 `window.document.body.innerHTML`，然后再导入
    `main.js`，如下所示。
- en: Listing 6.8 main.test.js
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.8 main.test.js
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Assigns the contents of the index.html file to the page’s body
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 分配 index.html 文件的内容到页面的主体
- en: Because you have now configured the global `window` to use the contents of `index.html`,
    Jest will be able to execute `main.test.js` successfully.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您现在已经配置了全局 `window` 使用 `index.html` 的内容，Jest 将能够成功执行 `main.test.js`。
- en: The last step you need to take to be able to write a test for `incrementCount`
    is to expose it. Because `main.js` does not expose `incrementCount` or `data`,
    you can’t exercise the function or check its result. Solve this problem by using
    `module.exports` to export `data` and the `incrementCount` function as follows.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够为 `incrementCount` 编写测试，您需要采取的最后一步是暴露它。因为 `main.js` 没有暴露 `incrementCount`
    或 `data`，所以您不能执行该函数或检查其结果。通过以下方式使用 `module.exports` 来导出 `data` 和 `incrementCount`
    函数来解决这个问题。
- en: Listing 6.9 main.js
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.9 main.js
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, you can go ahead and create a `main.test.js` file that sets an initial
    count, exercises `incrementCount`, and checks the new `count` within `data`. Again,
    it’s the three As pattern—arrange, act, assert—just like we’ve done before.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以继续创建一个 `main.test.js` 文件，该文件设置初始计数，执行 `incrementCount` 并在 `data` 中检查新的
    `count`。这仍然是三个 A 模式——安排、行动、断言——就像我们之前做的那样。
- en: Listing 6.10 main.test.js
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.10 main.test.js
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '❶ Arrange: sets the initial quantity of cheesecakes'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安排：设置芝士蛋糕的初始数量
- en: '❷ Act: exercises the incrementCount function, which is the unit under test'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 行动：执行待测试的 incrementCount 函数
- en: '❸ Assert: checks whether data.cheesecakes contains the correct amount of cheesecakes'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言：检查 data.cheesecakes 是否包含正确的芝士蛋糕数量
- en: NOTE For now, we won’t worry about checking the page’s contents. In the next
    sections, you’ll learn how to assert on the DOM and deal with events triggered
    by user interactions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：目前我们不会担心检查页面内容。在下一节中，您将学习如何断言 DOM 并处理由用户交互触发的事件。
- en: Once you’ve celebrated seeing this test pass, it’s time to solve one last problem.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您庆祝看到这个测试通过，就是时候解决最后一个问题。
- en: 'Because you’ve used `module.exports` to expose `incrementCount` and `data`,
    `main.js` will now throw an error when running in the browser. To see the error,
    try serving your application again with `npx` `http-server ./`, and accessing
    `localhost: 8080` with your browser’s dev tools open.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '因为您已经使用 `module.exports` 来暴露 `incrementCount` 和 `data`，所以 `main.js` 在浏览器中运行时会抛出错误。要查看错误，请尝试再次使用
    `npx http-server ./` 提供您的应用程序，并使用浏览器开发者工具打开 `localhost: 8080`。'
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Your browser throws this error because it doesn’t have `module` globally available.
    Again, you have run into a problem related to the differences between browsers
    and Node.js.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您的浏览器抛出此错误是因为它没有全局提供 `module`。再次，您遇到了与浏览器和 Node.js 之间差异相关的问题。
- en: A common strategy to run in browsers’ files that use Node.js’s module system
    is to use a tool that bundles dependencies into a single file that the browser
    can execute. One of the main goals of tools like Webpack and Browserify is to
    do this kind of bundling.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行使用 Node.js 模块系统的文件的一种常见策略是使用一个工具，该工具将依赖项捆绑到一个浏览器可以执行的单一文件中。像 Webpack
    和 Browserify 这样的工具的主要目标之一就是进行这种捆绑。
- en: Install `browserify` as a dev dependency, and run `./node_modules/.bin/browserify
    main.js -o bundle.js` to transform your `main.js` file into a browser-friendly
    `bundle.js`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `browserify` 安装为开发依赖项，并运行 `./node_modules/.bin/browserify main.js -o bundle.js`
    以将您的 `main.js` 文件转换为浏览器友好的 `bundle.js`。
- en: NOTE You can find Browserify’s complete documentation at [browserify.org](https://www.browserify.org).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: NOTE 您可以在 [browserify.org](https://www.browserify.org) 找到 Browserify 的完整文档。
- en: Once you have run Browserify, update `index.html` to use `bundle.js` instead
    of `main.js`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行了 Browserify，更新 `index.html` 以使用 `bundle.js` 而不是 `main.js`。
- en: Listing 6.11 index.html
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.11 index.html
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ The bundle.js will be generated from main.js. It’s a single file that contains
    all of main.js’s direct and indirect dependencies.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ bundle.js 将由 main.js 生成。它是一个包含 main.js 的所有直接和间接依赖项的单个文件。
- en: TIP You will need to rebuild `bundle.js` whenever there’s a change to `main.js`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 每当 `main.js` 发生变化时，您都需要重新构建 `bundle.js`。
- en: Because you have to run it frequently, it would be wise to create an NPM script
    that runs Browserify with the correct arguments.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您需要频繁运行它，创建一个运行 Browserify 的 NPM 脚本会是一个明智的选择。
- en: To create an NPM script that runs Browserify, update your `package.json` so
    that it includes the next lines.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个运行 Browserify 的 NPM 脚本，更新您的 `package.json` 以包括以下行。
- en: Listing 6.12 package.json
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.12 package.json
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Goes through the main.js file’s dependency tree and bundles all of the dependencies
    into a single bundle.js file
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 遍历 main.js 文件的依赖树，并将所有依赖项打包成一个单一的 bundle.js 文件
- en: By using tools like Browserify or Webpack, you can transform the testable code
    you’ve written to run in Node.js so that it can run in a browser.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用像 Browserify 或 Webpack 这样的工具，您可以将您编写的可测试代码转换为在 Node.js 中运行，以便它可以在浏览器中运行。
- en: Using bundlers enables you to test your modules separately and makes it easier
    to manage them within browsers. When you bundle your application into a single
    file, you don’t need to manage multiple `script` tags in your HTML page.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用打包器使您能够单独测试您的模块，并使它们在浏览器中管理起来更加容易。当您将应用程序打包成一个单一文件时，您不需要在您的 HTML 页面中管理多个 `script`
    标签。
- en: In this section, you’ve learned how to use Node.js and Jest to test JavaScript
    designed to run in a browser. You’ve seen the differences between these two platforms
    and learned how to bring browser APIs to Node.js with JSDOM.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何使用 Node.js 和 Jest 来测试设计在浏览器中运行的 JavaScript。您看到了这两个平台之间的区别，并学习了如何使用
    JSDOM 将浏览器 API 带到 Node.js。
- en: You’ve also seen how Browserify can help you test your application by enabling
    you to divide it into separate modules, which you can test in Node.js and then
    bundle to run in a browser.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您还看到了 Browserify 如何通过允许您将应用程序分割成单独的模块来帮助您测试应用程序，这些模块可以在 Node.js 中测试，然后打包在浏览器中运行。
- en: By using these tools, you were able to test your browser application in Node.js,
    using Jest.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些工具，您能够使用 Jest 在 Node.js 中测试您的浏览器应用程序。
- en: 6.2 Asserting on the DOM
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 在 DOM 上断言
- en: The best chefs know that a dessert should not only *taste* right; it must also
    *look* good.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的厨师知道，甜点不仅应该 *味道* 正确；它还必须 *看起来* 很好。
- en: In the previous section, you learned how to set up Jest so that you can test
    your scripts, but you haven’t yet checked whether the page displays the correct
    output to your users. In this section, you will understand how your scripts interact
    with a page’s markup and learn how to assert on the DOM.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您学习了如何设置 Jest 以测试您的脚本，但您还没有检查页面是否向用户显示了正确的输出。在本节中，您将了解您的脚本如何与页面的标记交互，并学习如何断言
    DOM。
- en: Before we get to writing tests, refactor the previous section’s application
    so that it can manage multiple inventory items, not just cheesecakes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写测试之前，重构上一节的应用程序，使其能够管理多个库存项目，而不仅仅是芝士蛋糕。
- en: Because you’re using Browserify to bundle your application, you can create a
    separate `inventoryController.js` file that will manage the items in the inventory,
    which you’ll store in memory.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您正在使用 Browserify 打包您的应用程序，所以您可以创建一个单独的 `inventoryController.js` 文件来管理库存中的项目，这些项目您将存储在内存中。
- en: NOTE For now, we’ll store all the data in memory and focus on testing our web
    client. In this chapter’s final section, you will learn how to connect your frontend
    application to the server from chapter 4 and test its backend integration.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: NOTE 目前，我们将所有数据存储在内存中，并专注于测试我们的网络客户端。在本章的最后部分，您将学习如何将前端应用程序连接到第 4 章中的服务器，并测试其后端集成。
- en: Listing 6.13 inventoryController.js
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.13 inventoryController.js
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we’ve done in the previous section, you can add a test for this function
    by importing `inventoryController.js`, assigning an empty object to the `inventory`
    property, exercising the `addItem` function, and checking the inventory’s contents—the
    usual three As pattern.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中所做的那样，你可以通过导入 `inventoryController.js`，将一个空对象分配给 `inventory` 属性，执行
    `addItem` 函数，并检查库存的内容——这是通常的三个 A 模式。
- en: Listing 6.14 inventoryController.test.js
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.14 inventoryController.test.js
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '❶ Arrange: assigns an empty object to the inventory, representing its initial
    state'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安排：将一个空对象分配给库存，代表其初始状态
- en: '❷ Act: exercises the addItem function, adding five cheesecakes to the inventory'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 行动：执行 `addItem` 函数，向库存中添加五个芝士蛋糕
- en: '❸ Assert: checks whether the inventory contains the correct amount of cheesecakes'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言：检查库存中是否包含正确数量的芝士蛋糕
- en: Running Jest should indicate that your test is passing, but even though `addItem`
    works, it doesn’t update the page with the inventory’s contents. To update the
    page with a list of items in stock, update your `index.html` file so that it includes
    an unordered list to which we’ll append items, as shown next.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Jest 应该表明你的测试通过了，但即使 `addItem` 正常工作，它也没有更新页面以显示库存的内容。要更新页面以显示库存项目列表，更新你的
    `index.html` 文件，使其包括一个无序列表，我们将向其中追加项目，如下所示。
- en: Listing 6.15 index.html
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.15 index.html
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After creating this unordered list, create a file called `domController.js`,
    and write an `updateItemList` function. This function should receive the `inventory`
    and update `item-list` accordingly.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个无序列表后，创建一个名为 `domController.js` 的文件，并编写一个 `updateItemList` 函数。这个函数应该接收 `inventory`
    并相应地更新 `item-list`。
- en: Listing 6.16 domController.js
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.16 domController.js
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Clears the list
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 清除列表
- en: ❷ For each item in the inventory, creates a li element, sets its contents to
    include the item’s name and quantity, and appends it to the list of items
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于库存中的每一项，创建一个 li 元素，将其内容设置为包括项目的名称和数量，并将其追加到项目列表中
- en: Finally, you can put all of this together into your `main.js` file. Go ahead
    and try adding a few items to the inventory by using `addItem` and calling `updateItemList`,
    passing it the new inventory.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以将这些内容全部放入你的 `main.js` 文件中。尝试使用 `addItem` 并调用 `updateItemList` 来添加一些项目到库存中，将新的库存传递给它。
- en: Listing 6.17 main.js
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.17 main.js
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: NOTE Because you should’ve completely rewritten `main.js`, its tests at `main.test.js`
    do not apply anymore and, therefore, can be deleted.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：因为你应该已经完全重写了 `main.js`，所以 `main.test.js` 中的测试不再适用，因此可以删除。
- en: Don’t forget that, because we’re using Node.js’s module system to enable testing,
    we must run `main.js` through Browserify so that it can generate a `bundle.js`
    file capable of running in the browser. Instead of relying on APIs like `require`
    and `module`, `bundle .js` includes the code for both `inventoryController.js`
    and `domController.js`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，因为我们使用 Node.js 的模块系统来启用测试，我们必须通过 Browserify 运行 `main.js`，以便它能够生成一个能够在浏览器中运行的
    `bundle.js` 文件。`bundle.js` 包括 `inventoryController.js` 和 `domController.js` 的代码，而不是依赖于
    `require` 和 `module` 这样的 API。
- en: Once you have built `bundle.js` with `./node_modules/.bin/browserify main.js
    -o bundle.js`, you can serve your application with `npx http-server ./` and access
    `localhost:8080` to see a list of inventory items.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用 `./node_modules/.bin/browserify main.js -o bundle.js` 建立了 `bundle.js`，你就可以使用
    `npx http-server ./` 来提供你的应用程序，并通过访问 `localhost:8080` 来查看库存项目列表。
- en: So far, you have tested only whether `addItem` adequately updates the application’s
    state, but you haven’t checked `updateItemList` at all. Even though the unit test
    for `addItem` passes, there’s no guarantee that `updateItemList` can update the
    page when you give it the current `inventory`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只测试了 `addItem` 是否充分更新了应用程序的状态，但你根本就没有检查 `updateItemList`。尽管 `addItem`
    的单元测试通过了，但这并不能保证当给 `updateItemList` 提供当前 `inventory` 时，它能够更新页面。
- en: Because `updateItemList` depends on the page’s markup, you must set the `innerHTML`
    of the document used by Jest’s JSDOM, just like we did in the previous section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `updateItemList` 依赖于页面的标记，你必须设置 Jest 的 JSDOM 所使用的文档的 `innerHTML`，就像我们在上一节中所做的那样。
- en: Listing 6.18 domController.test.js
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.18 domController.test.js
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: TIP Besides `window`, `document` is also global within your tests. You can save
    yourself a few keystrokes by accessing `document` instead of `window.document`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：除了 `window` 之外，`document` 在你的测试中也是全局的。你可以通过访问 `document` 而不是 `window.document`
    来节省一些按键。
- en: 'After setting up the JSDOM instance with the contents of your `index.html`
    page, test `updateItemList` using the three As pattern again: set up a scenario
    by creating an inventory with a few items, pass it to `updateItemList`, and check
    whether it updates the DOM appropriately.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用你的 `index.html` 页面的内容设置 JSDOM 实例后，再次使用三个 A 模式测试 `updateItemList`：通过创建包含几个项目的库存来设置场景，将其传递给
    `updateItemList`，并检查它是否适当地更新了 DOM。
- en: Given that, thanks to Jest and JSDOM, the global `document` works just like
    it would in a browser, and you can use browser APIs to find DOM nodes and assert
    on them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Jest 和 JSDOM 的存在，全局 `document` 在浏览器中工作得就像它应该那样，你可以使用浏览器 API 来查找 DOM 节点并对它们进行断言。
- en: Try, for example, using `querySelector` to find an unordered list that is an
    immediate child of `body` and assert on the number of `childNodes` it contains.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试使用 `querySelector` 找到一个 `body` 的直接子元素的未有序表，并断言它包含的 `childNodes` 的数量。
- en: Listing 6.19 domController.test.js
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.19 domController.test.js
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Because you’re assigning the index.html file’s content to the body’s innerHTML,
    the page will be in its initial state when the test runs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 因为你在将 index.html 文件的内容分配给 body 的 innerHTML，所以当测试运行时，页面将处于其初始状态。
- en: ❷ Creates an inventory representation containing a few different items
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建包含几个不同项目的库存表示
- en: '❸ Act: exercises the updateItemList function'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 行动：练习 updateItemList 函数
- en: ❹ Finds the list by its placement in the DOM
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通过其在 DOM 中的位置找到列表
- en: '❺ Assert: checks whether the list contains the correct quantity of child nodes'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 断言：检查列表是否包含正确的子节点数量
- en: DOM elements in JSDOM contain the same properties as in a browser, so you can
    go ahead and make your test more rigorous by asserting on the `innerHTML` of each
    item in the list.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: JSDOM 中的 DOM 元素包含与浏览器中相同的属性，因此你可以通过断言列表中每个项目的 `innerHTML` 来使你的测试更加严格。
- en: Listing 6.20 domController.test.js
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.20 domController.test.js
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Extract the innerHTML from each node in the itemList, creating an array of
    strings.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 itemList 中的每个节点提取 innerHTML，创建一个字符串数组。
- en: Because you will be directly invoking `updateItemList` but checking the `DOM`
    to assert on whether the function produced the correct output, I’d classify this
    test for `updateItemList` as an integration test. It specifically tests whether
    `updateItemList` updates the page’s markup correctly.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你会直接调用 `updateItemList` 但检查 `DOM` 来断言函数是否产生了正确的输出，所以我将这个 `updateItemList`
    的测试归类为集成测试。它专门测试 `updateItemList` 是否正确更新了页面的标记。
- en: You can see how this test interfaces with other modules in figure 6.3.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图 6.3 中看到这个测试如何与其他模块交互。
- en: '![](../Images/CH06_F03_DaCosta.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F03_DaCosta.png)'
- en: Figure 6.3 How the tests and the unit under test interact with the document
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 测试和被测试单元与文档的交互方式
- en: Notice how the testing pyramid permeates all of your tests. The same principles
    you’ve used to test backend applications apply to frontend applications.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意测试金字塔如何渗透到你的所有测试中。你用来测试后端应用程序的原则同样适用于前端应用程序。
- en: The problem with the previous test is that it’s tightly coupled to the page’s
    markup. It relies on the DOM’s structure to find nodes. If your page’s markup
    changes in such a way that the nodes are not in the exact same place, the tests
    will fail, even if the application, from a user’s point of view, is still flawless.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 之前测试的问题在于它与页面的标记紧密耦合。它依赖于 DOM 的结构来查找节点。如果你的页面标记以这种方式改变，以至于节点不在完全相同的位置，测试将失败，即使从用户的角度来看，应用程序仍然完美无瑕。
- en: Let’s say, for example, that you wanted to wrap your unordered list in a `div`
    for stylistic purposes, as shown next.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，你想要为了样式目的将你的无序列表包裹在一个 `div` 中，如下所示。
- en: Listing 6.21 index.html
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.21 index.html
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This change will make your test in `domController` fail because it won’t find
    the unordered list anymore. Because the test relies on the list being a direct
    descendant of `body`, it will fail as soon as you wrap `item-list` in any other
    elements.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改将使你的 `domController` 中的测试失败，因为它将找不到无序列表。因为测试依赖于列表是 `body` 的直接后代，所以一旦你将 `item-list`
    包裹在任何其他元素中，它就会失败。
- en: In this case, you’re not worried about whether the list is a direct descendant
    of `body`. Instead, what you need to guarantee is that it exists and that it contains
    the correct items. This query would be adequate only if your goal were to ensure
    that the `ul` directly descended from `body`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你不必担心列表是否是 `body` 的直接后代。相反，你需要保证它存在并且包含正确的项目。这个查询只有在你的目标是确保 `ul` 是 `body`
    的直接后代时才足够。
- en: You should think of the queries in your tests as built-in assertions. If, for
    example, you want to assert that an element is a direct descendant of another,
    you should write a query that relies on its DOM position.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将测试中的查询视为内置断言。例如，如果你想断言一个元素是另一个元素的直接后代，你应该编写一个依赖于其 DOM 位置的查询。
- en: NOTE We have previously discussed how to turn assertions into preconditions
    in the final section of chapter 5\. Queries that depend on specific characteristics
    of an element operate on the same principles.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们已经在第 5 章的最后部分讨论了如何将断言转换为先决条件。依赖于元素特定特征的查询遵循相同的原理。
- en: As you write frontends, you will soon notice that the DOM structure will frequently
    change without affecting the overall functioning of the application. Therefore,
    in the vast majority of situations, you should avoid coupling your tests to the
    DOM structure. Otherwise, you will generate extra costs by having to update tests
    too frequently, even if the application still works.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写前端时，你很快就会注意到 DOM 结构会频繁变化，而不会影响应用程序的整体功能。因此，在绝大多数情况下，你应该避免将测试耦合到 DOM 结构。否则，即使应用程序仍然工作，你也必须频繁更新测试，这将产生额外的成本。
- en: To avoid depending on the DOM’s structure, update your test in `domController`
    so that it finds the list by its `id`, as shown in the next code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免依赖于 DOM 的结构，更新你的 `domController` 中的测试，使其通过 `id` 找到列表，如下一代码所示。
- en: Listing 6.22 domController.test.js
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.22 domController.test.js
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Finds the list by its id
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过 ID 查找列表
- en: By finding the list by its `id`, you are free to move it around in the DOM and
    to wrap it in as many elements you want. As long as it has the same `id`, your
    tests will pass.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过通过 `id` 查找列表，你可以自由地在 DOM 中移动它，并包裹你想要的任何元素。只要它有相同的 `id`，你的测试就会通过。
- en: TIP The elements on which you want to assert will not always already have an
    `id` attribute. It could be the case that your application doesn’t use `id` attributes
    to find elements, for example.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你想要断言的元素不一定已经有了 `id` 属性。可能你的应用程序不使用 `id` 属性来查找元素，例如。
- en: In that case, attaching to your elements an attribute with such strong semantics
    as `id` is *not* the best option. Instead, you can add a unique `data-testid`
    attribute and use it to find your element with `document.querySelector ('[data-testid="your-element-testid"]')`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，将具有如此强语义的属性 `id` 附着到你的元素上并不是最佳选择。相反，你可以添加一个唯一的 `data-testid` 属性，并使用它通过
    `document.querySelector ('[data-testid="your-element-testid"]')` 来查找你的元素。
- en: Now, to indicate which actions happened since the page was first loaded, update
    your `updateItemList` function so that it attaches a new paragraph to the document’s
    body whenever it runs.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了指示自页面首次加载以来发生了哪些操作，更新你的 `updateItemList` 函数，使其在每次运行时都向文档的主体附加一个新的段落。
- en: Listing 6.23 domController.js
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.23 domController.js
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Creates a paragraph element
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个段落元素
- en: ❷ Sets the paragraph’s content
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置段落的文本内容
- en: ❸ Appends the paragraph to the document’s body
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将段落附加到文档的主体
- en: Once you’ve updated `updateItemList`, use Browserify to rebuild `bundle.js`
    by running `browserify main.js -o bundle.js`, and serve the application with `npx
    http-server ./`. When accessing `localhost:8080`, you should see a paragraph at
    the bottom of the page indicating what the last update was.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你更新了 `updateItemList`，使用 Browserify 通过运行 `browserify main.js -o bundle.js`
    来重建 `bundle.js`，然后使用 `npx http-server ./` 来提供应用程序。当访问 `localhost:8080` 时，你应该在页面底部看到一个段落，指示最后一次更新是什么。
- en: Now it’s time to add a test covering this functionality. Because the paragraph
    appended to the body doesn’t have an `id` or a `data-testid`, you must either
    add one of these attributes or discover another way of finding this element.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候添加一个测试来覆盖这个功能了。因为附加到主体的段落没有 `id` 或 `data-testid`，你必须添加这些属性之一，或者发现另一种找到这个元素的方法。
- en: In this case, adding an identifier attribute to the paragraph seems like a bad
    idea. To make sure that these identifiers are unique, you’d have to make `domController`
    stateful so that it can generate a new ID every time. By doing this, you’d be
    adding a significant amount of code just to make this functionality testable.
    Besides adding more code, which would require more maintenance, you’d also be
    tightly coupling your implementation to your tests.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，给段落添加一个标识符属性似乎是个坏主意。为了确保这些标识符是唯一的，你必须使 `domController` 状态化，以便每次都能生成一个新的
    ID。通过这样做，你将添加大量的代码来仅使这个功能可测试。除了添加更多的代码，这需要更多的维护外，你还会将你的实现与测试紧密耦合。
- en: 'To avoid this overhead, instead of finding paragraphs by unique identifiers,
    find paragraphs by the characteristic on which you want to assert: their content.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种开销，而不是通过唯一标识符查找段落，而是通过您想要断言的特征来查找段落：其内容。
- en: Add to `domController.test.js` a new test that finds all paragraphs in a page
    and filters them by their contents.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `domController.test.js` 中添加一个新的测试，用于查找页面中的所有段落并根据其内容进行过滤。
- en: Warning You now have multiple tests running on the same `document`, so you must
    reset its contents between each test. Don’t forget to encapsulate the assignment
    to `document.body.innerHTML` in a `beforeEach` hook.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：现在您在同一 `document` 上运行多个测试，因此您必须在每个测试之间重置其内容。不要忘记在 `beforeEach` 钩子中封装对 `document.body.innerHTML`
    的赋值。
- en: Listing 6.24 domController.test.js
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.24 domController.test.js
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Before each test, you’ll reset the document’s body to its initial state by
    reassigning to it the contents of index.html.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试之前，您将通过重新分配 index.html 的内容来将文档的 body 重置为其初始状态。
- en: ❷ Exercises the updateItemList function
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 练习 updateItemList 函数
- en: ❸ Finds all the paragraphs in the page
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查找页面中的所有段落
- en: ❹ Filters all of the page’s paragraphs by their text to find the one containing
    the desired text
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通过文本过滤页面的所有段落以找到包含所需文本的段落
- en: ❺ Checks that there’s only one paragraph with the expected text
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查是否存在一个包含预期文本的段落
- en: ❻ Checks the paragraph’s entire content
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 检查段落的全部内容
- en: Finding an element by its content is better than relying on the DOM’s structure
    or unique `ids`. Even though all of these techniques are valid and apply to different
    scenarios, finding an element through its content is the best way to avoid coupling
    between your application and your tests. Alternatively, you can find an element
    through other attributes that not only uniquely identify it but also constitute
    an integral part of what the element should be. You can, for example, find an
    element by its `role` attribute and, therefore, build accessibility checks into
    your selectors.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过内容查找元素比依赖于 DOM 的结构或唯一的 `ids` 更好。尽管所有这些技术都是有效的，并且适用于不同的场景，但通过内容查找元素是避免应用程序和测试之间耦合的最佳方式。或者，您可以通过其他属性来查找元素，这些属性不仅能够唯一标识它，而且也是元素应该具有的固有部分。例如，您可以通过
    `role` 属性来查找元素，因此可以将无障碍性检查集成到选择器中。
- en: When testing your frontend applications, remember to assert not only whether
    your functions work but also whether your pages display the right elements, with
    the correct content. To do that, find elements in the DOM, and make sure to write
    assertions to validate them. When writing these assertions, be careful with *how*
    you find those elements. Try to always assert on the characteristics that are
    an integral part of what the element should be. By asserting on these characteristics,
    you’ll make your tests robust and won’t create extra maintenance overhead when
    you refactor your application but everything is still working.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试您的前端应用程序时，请记住不仅要断言您的函数是否工作，还要断言您的页面是否显示了正确的内容。为此，请在 DOM 中查找元素，并确保编写断言来验证它们。在编写这些断言时，请注意您是如何查找这些元素的。尽量始终断言元素应该具有的固有特征。通过断言这些特征，您将使您的测试更加健壮，并在重构应用程序时不会创建额外的维护开销，即使一切仍然正常工作。
- en: 6.2.1 Making it easier to find elements
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 使查找元素更加容易
- en: Louis would have given up baking a long time ago if it took him an hour to find
    the right pan every time he wanted to bake a cake. To prevent you from giving
    up writing valuable tests every time you add a new feature, it’s a good idea to
    make finding elements as effortless as it is for Louis to find his pans.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路易斯每次想要烤蛋糕时都要花一个小时来找到正确的烤盘，他早就放弃烘焙了。为了避免您每次添加新功能时都放弃编写有价值的测试，使查找元素变得像路易斯找到他的烤盘一样轻松是一个好主意。
- en: So far, we’ve been using native APIs to find elements. Sometimes, this can get
    quite cumbersome.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用原生 API 来查找元素。有时，这可能会变得相当繁琐。
- en: If you’re finding elements by their `test-id`, for example, you have to rewrite
    many similar selectors. In the previous test, to find a paragraph by its text,
    we not only had to use a selector but also had to write a significant amount of
    code to filter the page’s `p` elements. Similar tricky situations could happen
    if you were trying to find, for example, an `input` by its `value` or `label`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过 `test-id` 来查找元素，例如，您必须重写许多类似的选择器。在之前的测试中，为了通过文本查找一个段落，我们不仅必须使用选择器，还必须编写大量的代码来过滤页面的
    `p` 元素。如果您尝试通过 `value` 或 `label` 来查找 `input`，类似的情况也可能发生。
- en: To make finding elements more straightforward, you can use a library like `dom-testing-library`,
    which ships with functions that make it easy for you to find DOM nodes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使查找元素更加直接，你可以使用像 `dom-testing-library` 这样的库，它提供了使你能够轻松找到 DOM 节点的函数。
- en: Now that you understand how to assert on the DOM, you’ll install `dom-testing-library`
    as a `dev-dependency` by running `npm` `install` `--save-dev` `@testing-library/dom`
    and refactor your tests so that they use this library’s queries.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何对 DOM 进行断言，你将通过运行 `npm install --save-dev @testing-library/dom` 将
    `dom-testing-library` 安装为 `dev-dependency`，并重构你的测试，以便它们使用这个库的查询。
- en: Start with the test that checks the page’s list of items. In that test, you’ll
    use the `getByText` function exported by `dom-testing-library`. With `getByText`,
    you won’t need to create an array with each item’s `innerHTML` and check whether
    the array includes the text you want. Instead, you’ll tell `getByText` to find
    the desired piece of text within the list. The `getByText` function takes as arguments
    the `HTMLElement` within which you want to search and the text to find.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从检查页面项目列表的测试开始。在那个测试中，你将使用由 `dom-testing-library` 导出的 `getByText` 函数。使用 `getByText`，你不需要创建一个包含每个项目
    `innerHTML` 的数组并检查该数组是否包含你想要的文本。相反，你将告诉 `getByText` 在列表中查找所需的文本。`getByText` 函数接受两个参数：你想要在其中搜索的
    `HTMLElement` 和要查找的文本。
- en: Because `getByText` will return a `falsy` result if it doesn’t find an element,
    you can use `toBeTruthy` to assert that it did find a matching node. For now,
    `toBeTruthy` will be enough, but in the next subsection, you will learn how to
    write more precise assertions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因为如果 `getByText` 没有找到元素，它将返回一个 `falsy` 结果，所以你可以使用 `toBeTruthy` 来断言它确实找到了匹配的节点。目前，`toBeTruthy`
    足够了，但在下一个子节中，你将学习如何编写更精确的断言。
- en: Listing 6.25 domController.test.js
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.25 domController.test.js
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ In these assertions, you’re using getByText to find desired elements more
    easily.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在这些断言中，你使用 `getByText` 来更容易地找到所需的元素。
- en: Now, instead of having to write the logic for finding elements by their text,
    you delegate that task to `dom-testing-library`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你不再需要编写根据文本查找元素的逻辑，你可以将这项任务委托给 `dom-testing-library`。
- en: To make your selection even more thorough, you could also pass a third argument
    to `getByText` telling it to consider only nodes that are `li` elements. Try passing
    `{ selector:` `"li"` `}` as the third argument for `getByText`, and you’ll see
    that the test still passes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '为了使选择更加彻底，你也可以向 `getByText` 传递第三个参数，告诉它只考虑 `li` 元素。尝试将 `{ selector: `"li"`
    }` 作为第三个参数传递给 `getByText`，你会发现测试仍然通过。'
- en: Go ahead and do the same for the other test in `domController.test.js`. This
    time, instead of having to pass an element within which `getByText` should search,
    you can use the `getByText` method from the `screen` namespace that `dom-testing-library`
    exports. Unlike the directly exported `getByText`, `screen.getByText` finds items
    within the global `document` by default.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对 `domController.test.js` 中的另一个测试也做同样的操作。这次，你不需要传递一个 `getByText` 应该在其中搜索的元素，你可以使用
    `dom-testing-library` 导出的 `screen` 命名空间中的 `getByText` 方法。与直接导出的 `getByText` 不同，`screen.getByText`
    默认在全局 `document` 中查找项目。
- en: Listing 6.26 domController.test.js
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.26 domController.test.js
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Instead of using getByText, use screen.getByText to search for elements within
    the global document and thus avoid having to find the itemList beforehand.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 代替使用 `getByText`，使用 `screen.getByText` 在全局文档中搜索元素，从而避免在之前必须找到 `itemList`。
- en: The `dom-testing-library` package also includes many other useful queries, such
    as `getByAltText`, `getByRole`, and `getByLabelText`. As an exercise, try adding
    new elements to the page, such as an image in your `input` field, and use these
    queries to find them in the tests you will write.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`dom-testing-library` 包还包含许多其他有用的查询，例如 `getByAltText`、`getByRole` 和 `getByLabelText`。作为一个练习，尝试向页面添加新元素，例如在
    `input` 字段中的图像，并使用这些查询在你要编写的测试中找到它们。'
- en: NOTE You can find the complete documentation for `dom-testing-library` queries
    at [https://testing-library.com/docs/dom-testing-library/api-queries](https://testing-library.com/docs/dom-testing-library/api-queries).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在 [https://testing-library.com/docs/dom-testing-library/api-queries](https://testing-library.com/docs/dom-testing-library/api-queries)
    找到 `dom-testing-library` 查询的完整文档。
- en: Your selectors, just like your assertions, should be based on what constitutes
    an integral part of what an element should be. An `id`, for example, is arbitrary,
    and, therefore, finding elements by their `ids` will tightly couple your tests
    to your markup. Instead of finding elements by arbitrary properties, you should
    find elements by what matters to your users, like their text or their role. By
    using robust and easy-to-write selectors, your tests will be much quicker to write
    and much more resilient to changes that do not affect whether your application
    works as it should.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你的选择器，就像你的断言一样，应该基于构成元素本质的部分。例如，`id` 是任意的，因此通过 `ids` 找到元素将使你的测试与标记紧密耦合。你应该通过对用户有意义的内容来查找元素，比如它们的文本或角色。通过使用强大且易于编写的选择器，你的测试将更快编写，并且对不影响应用程序正常工作的更改更具弹性。
- en: 6.2.2 Writing better assertions
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 编写更好的断言
- en: In the previous section, you used `toBeTruthy` to assert that `dom-testing-library`
    was able to find the elements you wanted. Even though it worked well enough for
    those examples, assertions like `toBeTruthy` are too loose and can make tests
    more difficult to understand.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你使用了 `toBeTruthy` 来断言 `dom-testing-library` 能够找到你想要的元素。尽管对于这些示例来说效果足够好，但像
    `toBeTruthy` 这样的断言太宽松，可能会使测试更难理解。
- en: Just like we used the `jest-extended` library to extend Jest with new matchers
    in chapter 3, we can use `jest-dom` to extend it with new matchers specifically
    for testing the DOM. These matchers can help you reduce the amount of code you
    need to write in your tests and make them more readable.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在第 3 章中使用 `jest-extended` 库扩展 Jest 以添加新的匹配器一样，我们也可以使用 `jest-dom` 来扩展它，添加专门用于测试
    DOM 的新匹配器。这些匹配器可以帮助你减少测试中需要编写的代码量，并使测试更易读。
- en: To use `jest-dom`, first, install it as a dev dependency by running `npm` `install`
    `--save-dev` `@testing-library/jest-dom`. Once you’ve installed it, add a `jest.
    config.js` file to your application’s directory, and configure Jest to run a setup
    file called `setupJestDom.js`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `jest-dom`，首先，通过运行 `npm install --save-dev @testing-library/jest-dom` 将其作为开发依赖项安装。安装后，在你的应用程序目录中添加一个
    `jest.config.js` 文件，并配置 Jest 以运行一个名为 `setupJestDom.js` 的设置文件。
- en: Listing 6.27 jest.config.js
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.27 jest.config.js
- en: '[PRE28]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Within `setupJestDom.js`, call `expect.extend` and pass it `jest-dom`’s main
    export.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setupJestDom.js` 中，调用 `expect.extend` 并传递 `jest-dom` 的主要导出。
- en: Listing 6.28 setupJestDom.js
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.28 setupJestDom.js
- en: '[PRE29]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Adding `setupJestDom.js` to your `setupFilesAfterEnv` config will cause it to
    run after Jest has been initialized and add the matchers from `jest-dom` to `expect`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `setupJestDom.js` 添加到 `setupFilesAfterEnv` 配置中，将在 Jest 初始化后运行，并将 `jest-dom`
    的匹配器添加到 `expect` 中。
- en: After updating your Jest configuration, you can replace `toBeTruthy` with the
    `toBeInTheDocument` assertion from `jest-dom`. This change will make your tests
    more readable and precise. In case the element found by `dom-testing-library`
    is not attached to the document anymore, for example, `toBeInTheDocument` will
    fail, whereas `toBeTruthy` would pass.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 Jest 配置后，你可以用 `jest-dom` 的 `toBeInTheDocument` 断言替换 `toBeTruthy`。这个更改会使你的测试更易读且更精确。如果
    `dom-testing-library` 找到的元素不再附加到文档上，例如，`toBeInTheDocument` 将会失败，而 `toBeTruthy`
    则会通过。
- en: Listing 6.29 domController.test.js
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.29 domController.test.js
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To try a different assertion, update your application so that it highlights
    in `red` the name of items whose `quantity` is less than five.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试不同的断言，更新你的应用程序，使其高亮显示 `红色` 的名称，这些名称的 `quantity` 小于五。
- en: Listing 6.30 domController.js
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.30 domController.js
- en: '[PRE31]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Iterates through each entry in the inventory
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 遍历库存中的每个条目
- en: ❷ If an item’s quantity is less than five, sets its color to red
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果一个项目的数量少于五，将其颜色设置为红色
- en: To assert on an element’s style, instead of manually accessing its `style` property
    and checking the value of `color`, you can use `toHaveStyle`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要断言一个元素的样式，而不是手动访问其 `style` 属性并检查 `color` 的值，你可以使用 `toHaveStyle`。
- en: Go ahead and add a new test to check if your application highlights in red the
    elements whose `quantity` is less than five, as shown next.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 继续添加一个新的测试，检查你的应用程序是否高亮显示红色，以突出显示 `quantity` 小于五的元素，如下所示。
- en: Listing 6.31 domController.test.js
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.31 domController.test.js
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With `toHaveStyle`, you can also assert on styles that are applied through a
    stylesheet. For example, try adding to your `index.html` a `style` tag that includes
    an `almost-soldout` class that sets an element’s color to red.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `toHaveStyle`，你也可以断言通过样式表应用的风格。例如，尝试向你的 `index.html` 添加一个包含 `almost-soldout`
    类的 `style` 标签，该类将元素的色彩设置为红色。
- en: Listing 6.32 index.html
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.32 index.html
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Then, instead of manually setting the item’s `style.color` property when its
    quantity is less than five, set its `className` property to `almost-soldout`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当物品的数量少于五时，不要手动设置其`style.color`属性，而是将其`className`属性设置为`almost-soldout`。
- en: Listing 6.33 domController.js
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.33 domController.js
- en: '[PRE34]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Instead of setting an element’s color directly, sets its class to almost-soldout,
    which causes an element’s color to become red
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不要直接设置元素的色彩，而是将其类设置为almost-soldout，这将导致元素的色彩变为红色
- en: Even though the styles are not applied by your scripts, your tests should still
    pass. For you to achieve the same goal without `jest-dom`, you’d need to write
    way more code in your tests.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 即使样式不是由你的脚本应用的，你的测试仍然应该通过。为了在不使用`jest-dom`的情况下达到相同的目标，你需要在测试中编写更多的代码。
- en: As an exercise, try adding new features to the application, such as setting
    the `visibility` of soldout items to `hidden` or adding a `button` that empties
    the inventory and remains disabled if the inventory is already empty. Then, use
    assertions like `toBeVisible`, `toBeEnabled`, and `toBeDisabled` to test these
    new features.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试向应用程序添加新功能，例如将售罄物品的`visibility`设置为`hidden`或添加一个当库存已空时保持禁用的`button`。然后，使用`toBeVisible`、`toBeEnabled`和`toBeDisabled`等断言来测试这些新功能。
- en: NOTE You can find the entire documentation for `jest-dom`, including a complete
    list of available matchers, at [https://github.com/testing-library/jest-dom](https://github.com/testing-library/jest-dom).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以在[https://github.com/testing-library/jest-dom](https://github.com/testing-library/jest-dom)找到`jest-dom`的完整文档，包括可用匹配器的完整列表。
- en: In this section, you should’ve learned how to find DOM elements within your
    tests, be it with native browser APIs or with utilities from `dom-testing-library`,
    which make your tests more readable. By now, you should also understand which
    techniques you should use to avoid maintenance overhead. You should know, for
    example, that finding an element based on its hierarchical chain is not a good
    idea, and that it’s better to find elements by their labels so that you can build
    verifications into your selectors. Additionally, you should be able to write precise
    and readable assertions for your tests with the assistance of `jest-dom`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你应该已经学会了如何在测试中找到DOM元素，无论是使用原生的浏览器API还是使用`dom-testing-library`提供的工具，这些工具使你的测试更具可读性。到如今，你也应该了解应该使用哪些技术来避免维护开销。例如，你应该知道基于其层次链查找元素不是一个好主意，而且最好通过它们的标签来查找元素，这样你就可以将验证集成到选择器中。此外，你应该能够借助`jest-dom`编写精确且易于阅读的断言来为你的测试服务。
- en: 6.3 Handling events
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 处理事件
- en: To make something people want, you must listen to what your customers have to
    say. The customer may not always be right, but, in Louis’s bakery, every employee
    knows that they must always listen to their customers—or, at least, make the customers
    feel listened to.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作人们想要的产品，你必须倾听你的客户有什么要说的。客户可能并不总是对的，但在路易斯的面包店，每个员工都知道他们必须始终倾听客户的声音——至少，要让客户感到被倾听。
- en: From a business perspective, a customer’s input drives product decisions. For
    example, it helps the bakery to produce more of what their customers want and
    less of what they don’t. From a software perspective, user inputs cause the application
    to react, changing its state and displaying new results.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 从商业角度来看，客户的反馈驱动着产品决策。例如，这有助于面包店生产更多客户想要的产品，而减少他们不想要的产品。从软件角度来看，用户输入导致应用程序做出反应，改变其状态并显示新的结果。
- en: Applications that run in the browser don’t directly receive input like numbers
    or strings. Instead, they deal with events. As users click, type, and scroll,
    they trigger **events**. These events include details about users’ interactions,
    like what was the content of the form they submitted or which button they clicked.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行的应用程序不会直接接收像数字或字符串这样的输入。相反，它们处理事件。当用户点击、键入和滚动时，它们会触发**事件**。这些事件包括有关用户交互的详细信息，例如他们提交的表单内容或他们点击了哪个按钮。
- en: In this section, you will learn how to handle events within your tests and accurately
    simulate the way users interact with your application. By precisely representing
    user’s inputs, you will have more reliable tests, because they will more closely
    resemble what happens in run time.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何在测试中处理事件，并准确模拟用户与你的应用程序的交互方式。通过精确地表示用户的输入，你将拥有更可靠的测试，因为它们将更接近运行时发生的情况。
- en: To see how events work and learn how to test them, you’ll add to your application
    a new `form` that allows users to add items to the inventory. Then you will make
    your application validate the form as users interact with it and write a few more
    tests for these interactions.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解事件是如何工作的以及如何测试它们，你将在你的应用程序中添加一个新的 `form`，允许用户向库存中添加项目。然后你将使你的应用程序在用户与之交互时验证表单，并为这些交互编写一些额外的测试。
- en: 'First, add to `index.html` a `form` that contains two fields: one for an item’s
    name and another for its quantity.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `index.html` 中添加一个包含两个字段的 `form`：一个用于项目名称，另一个用于数量。
- en: Listing 6.34 index.html
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.34 index.html
- en: '[PRE35]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Causes the form to be submitted, triggering a submit event
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导致表单提交，触发提交事件
- en: In your `domController.js` file, create a function named `handleAddItem`. This
    function will receive an `event` as its first argument, retrieve the submitted
    values, call `addItem` to update the inventory, and then `updateItemList` to update
    the DOM.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `domController.js` 文件中，创建一个名为 `handleAddItem` 的函数。这个函数将接收一个 `event` 作为其第一个参数，检索提交的值，调用
    `addItem` 来更新库存，然后调用 `updateItemList` 来更新 DOM。
- en: Listing 6.35 domController.js
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.35 domController.js
- en: '[PRE36]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Prevents the page from reloading as it would by default
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 阻止页面默认重新加载
- en: ❷ Because the quantity field value is a string, we need to use parseInt to convert
    it to a number.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 因为数量字段值是一个字符串，我们需要使用 `parseInt` 来将其转换为数字。
- en: NOTE By default, browsers will reload the page when users submit a form. Calling
    the event’s `preventDefault` method will cancel the default behavior, causing
    the browser to *not* reload the page.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：默认情况下，当用户提交表单时，浏览器会重新加载页面。调用事件的 `preventDefault` 方法将取消默认行为，导致浏览器不重新加载页面。
- en: Finally, for `handleAddItem` to be called whenever users submit new items, you
    need to attach to the form an event listener for `submit` events.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使 `handleAddItem` 在用户提交新项目时被调用，你需要将一个 `submit` 事件监听器附加到表单上。
- en: Now that you have a form to submit items, you don’t need to manually call `addItem`
    and `updateItemList` in your `main.js` file anymore. Instead, you can replace
    the entire content of this file, and make it attach *only* an event listener to
    the form.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了提交项目的表单，你不再需要在 `main.js` 文件中手动调用 `addItem` 和 `updateItemList`。相反，你可以替换这个文件的整个内容，并使其仅附加一个事件监听器到表单上。
- en: Listing 6.36 main.js
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.36 main.js
- en: '[PRE37]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Invokes handleAddItem whenever users submit the form
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当用户提交表单时调用 `handleAddItem`
- en: After these changes, you should have an application that is capable of dynamically
    adding items to the inventory. To see it running, execute `npm` `run build` to
    regenerate `bundle.js`, `npx` `http-server` `./` to serve `index.html`, and access
    `localhost:8080`, as you’ve done before.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，你应该有一个能够动态添加项目到库存中的应用程序。要看到它运行，执行 `npm run build` 来重新生成 `bundle.js`，然后执行
    `npx http-server ./` 来提供 `index.html`，并访问 `localhost:8080`，就像你之前做的那样。
- en: Now, think about what you’d do to test the code you’ve just added.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑你会如何测试你刚刚添加的代码。
- en: One possibility would be to add a test for the `handleAddItem` function itself.
    This test would create an eventlike object and pass it as an argument to `handleAddItem`,
    as shown next.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能性是为 `handleAddItem` 函数本身添加一个测试。这个测试将创建一个类似事件的对象，并将其作为参数传递给 `handleAddItem`，如下所示。
- en: Listing 6.37 domController.test.js
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.37 domController.test.js
- en: '[PRE38]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Creates an object that replicates an event’s interface
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个对象，它复制了事件接口
- en: ❷ Exercises the handleAddItem function
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 练习 `handleAddItem` 函数
- en: ❸ Checks if the form’s default reload has been prevented
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查表单的默认重新加载是否已被阻止
- en: ❹ Checks whether the itemList contains a node with the expected text
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查 itemList 是否包含具有预期文本的节点
- en: For the previous test to pass, you’ve had to reverse-engineer the properties
    of `event`, building it from scratch.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使之前的测试通过，你必须逆向工程 `event` 的属性，从头开始构建它。
- en: One of the problems with this technique is that it doesn’t take into account
    any of the actual `input` elements in the page. Because you’ve built `event` yourself,
    you were able to include arbitrary values for `name` and `quantity`. If you try,
    for example, removing the `input` elements from your `index.html`, this test will
    still pass, even though your application can’t possibly work.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的缺点是它没有考虑到页面中的任何实际 `input` 元素。因为你自己构建了 `event`，所以你能够为 `name` 和 `quantity`
    包含任意值。例如，如果你尝试从 `index.html` 中移除 `input` 元素，这个测试仍然会通过，尽管你的应用程序可能无法工作。
- en: Because this test directly invokes `handleAddItem`, as shown in figure 6.4,
    it doesn’t care about whether it’s attached to the `form` as a listener for the
    `submit` event. For example, if you try removing from `main.js` the call to `addEventListener`,
    this test will continue to pass. Again, you’ve found another case in which your
    application won’t work but in which your tests will pass.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个测试直接调用了 `handleAddItem`，如图 6.4 所示，它不关心它是否作为 `submit` 事件的监听器附加到 `form` 上。例如，如果您尝试从
    `main.js` 中移除 `addEventListener` 的调用，这个测试将继续通过。再次，您又发现了一个应用程序不会工作但测试会通过的情况。
- en: '![](../Images/CH06_F04_DaCosta.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F04_DaCosta.png)'
- en: Figure 6.4 The test for `handleAddItem` invokes it directly, causing it to update
    the document.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 `handleAddItem` 的测试直接调用它，导致文档更新。
- en: Constructing events manually, as you’ve just done, can be useful to iterate
    quickly and test your listeners in isolation as you build them. But, when it comes
    to creating reliable guarantees, this technique is inadequate. This unit test
    covers *only* the `handleAddItem` function itself and, therefore, can’t guarantee
    that the application will work when users trigger real events.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如您刚刚所做的那样手动构造事件，可以快速迭代并测试您构建时的监听器。但是，当涉及到创建可靠的保证时，这种技术是不够的。这个单元测试仅涵盖 `handleAddItem`
    函数本身，因此不能保证当用户触发真实事件时应用程序将正常工作。
- en: To create more reliable guarantees, it’s better to create a real event instance
    and dispatch it through a DOM node by using the node’s `dispatchEvent` method.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建更可靠的保证，最好创建一个真实的事件实例，并通过使用节点的 `dispatchEvent` 方法通过 DOM 节点派发它。
- en: The first step to accurately reproduce what happens in run time is to update
    the document’s body so that it contains the markup from `index.html`, as we’ve
    done previously. Then, it would be best if you executed `main.js` by using `require("./main")`
    so that it can attach the `eventListener` to the `form`. If you don’t run `main.js`
    after updating the document’s body with `initialHTML` again, its form will *not*
    have an event listener attached to it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 准确重现运行时发生情况的第一步是更新文档的 `body`，使其包含我们之前所做的 `index.html` 的标记。然后，最好使用 `require("./main")`
    执行 `main.js`，以便它可以将 `eventListener` 附加到 `form` 上。如果您在用 `initialHTML` 再次更新文档的 `body`
    后不运行 `main.js`，它的表单将不会附加事件监听器。
- en: Additionally, you must call `jest.resetModules` before requiring `main.js`.
    Otherwise, Jest will get `./main.js` from its cache, preventing it from being
    executed again.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您必须在引入 `main.js` 之前调用 `jest.resetModules`。否则，Jest 将从其缓存中获取 `./main.js`，从而阻止它再次执行。
- en: Listing 6.38 main.test.js
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.38 main.test.js
- en: '[PRE39]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Here you must use jest.resetModules because, otherwise, Jest will have cached
    main.js and it will not run again.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在这里您必须使用 jest.resetModules，否则 Jest 将缓存 main.js，它将不会再次运行。
- en: ❷ You must execute main.js again so that it can attach the event listener to
    the form every time the body changes.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 您必须再次执行 main.js，以便每次文档内容发生变化时，它都能将事件监听器附加到表单上。
- en: Now that your document has the contents from `index.html` and `main.js` has
    attached a listener to the `form`, you can write the test itself. This test will
    fill the page’s inputs, create an `Event` with type `submit`, find the `form`,
    and call its `dispatchEvent` method. After dispatching the event, it will check
    whether the list contains an entry for the item it just added.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的文档已经包含了 `index.html` 的内容，并且 `main.js` 已经将监听器附加到了 `form` 上，您就可以编写测试了。这个测试将填充页面的输入框，创建一个类型为
    `submit` 的 `Event` 对象，找到 `form`，并调用其 `dispatchEvent` 方法。在派发事件后，它将检查列表是否包含刚刚添加的项目条目。
- en: Listing 6.39 main.test.js
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.39 main.test.js
- en: '[PRE40]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Creates a “native” instance of Event with type submit
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个类型为 submit 的“原生”Event 实例
- en: ❷ Dispatches the event through the page’s form
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过页面的表单派发事件
- en: ❸ Checks whether the dispatched event caused the page to include an element
    with the expected text
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查派发的事件是否导致页面包含具有预期文本的元素
- en: This test (also shown in figure 6.5) represents what happens at run time much
    more accurately. Because its scope is broader than the previous test’s, this test
    goes higher in the testing pyramid, and, therefore, its guarantees are more reliable.
    For example, if you try removing the `input` elements from `index.html` or the
    call to `addEventListener` from `main.js`, this test will fail, unlike the previous
    one.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试（如图 6.5 所示）更准确地代表了运行时发生的情况。因为它的范围比之前的测试更广，所以这个测试在测试金字塔中位置更高，因此它的保证更可靠。例如，如果您尝试从
    `index.html` 中移除 `input` 元素或从 `main.js` 中移除 `addEventListener` 的调用，这个测试将失败，而之前的测试不会。
- en: '![](../Images/CH06_F05_DaCosta.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F05_DaCosta.png)'
- en: Figure 6.5 By dispatching events through the form, the application triggers
    the event listener attached by `main.js`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 通过通过表单派发事件，应用程序触发`main.js`中附加的事件监听器。
- en: Next, you’ll make your application validate the item name field as users type.
    Every time a user types into the item name input, you’ll confirm that its value
    is valid by checking if it exists in a predefined list of ingredients.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使你的应用程序在用户输入时验证项目名称字段。每次用户在项目名称输入框中输入时，你将确认其值是否有效，通过检查它是否存在于预定义的配料列表中。
- en: Start implementing this feature by adding a new function to `domController`.
    This function will take an event and check whether the event’s target is in the
    ingredient list. If the item exists, it will display a success message. Otherwise,
    it will show an error.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向`domController`添加一个新函数来开始实现这个功能。这个函数将接受一个事件并检查事件的目标是否在配料列表中。如果项目存在，它将显示一个成功消息。否则，它将显示一个错误。
- en: Listing 6.40 domController.js
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.40 domController.js
- en: '[PRE41]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, for `handleItemName` to be able to display its messages, add to `index.html`
    a new `p` tag whose `id` is `error-msg`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了让`handleItemName`能够显示其消息，向`index.html`添加一个新的`p`标签，其`id`为`error-msg`。
- en: Listing 6.41 index.html
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.41 index.html
- en: '[PRE42]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ The element that will display feedback to the users depending on whether an
    item’s name is valid
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 根据项目名称是否有效，向用户显示反馈的元素
- en: If you want to test the `handleItemName` function in isolation, you can, as
    an exercise, try to write a unit test for it, just like we have previously done
    for the `handleAddItem` function. You can find a complete example of how to write
    this test in the `chapter6/3_handling_events/1_handling_raw_events` folder in
    this book’s GitHub repository, at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要单独测试`handleItemName`函数，你可以作为一个练习，尝试为它编写一个单元测试，就像我们之前为`handleAddItem`函数所做的那样。你可以在本书GitHub仓库的`chapter6/3_handling_events/1_handling_raw_events`文件夹中找到一个如何编写此测试的完整示例，网址为[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: NOTE As previously mentioned, unit testing these functions can be useful as
    you iterate, but tests that dispatch actual events are much more reliable. Given
    that both kinds of tests have a high degree of overlap and require similar amounts
    of code, if you have to choose one, I’d recommend you to stick with tests that
    use an element’s `dispatchEvent`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如前所述，在迭代过程中对函数进行单元测试可能很有用，但派发实际事件的测试要可靠得多。鉴于这两种测试具有高度的重叠和需要相似数量的代码，如果你必须选择一种，我建议你坚持使用使用元素的`dispatchEvent`的测试。
- en: If you are comfortable writing your handler functions without testing them in
    isolation throughout the process, it’s probably better to write tests that use
    *only* `dispatchEvent`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于在整个过程中不单独测试你的处理函数，那么可能更好的是编写只使用`dispatchEvent`的测试。
- en: The final step for the validation to work is to attach an event listener that
    handles `input` events that happen in the `input` for the item name. Update your
    `main.js`, and add the following code.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 验证功能正常工作的最后一步是附加一个处理`input`事件的监听器，这些事件发生在项目名称的`input`中。更新你的`main.js`，并添加以下代码。
- en: Listing 6.42 main.js
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.42 main.js
- en: '[PRE43]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Uses handleItemName to handle input events from itemInput
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用handleItemName处理来自itemInput的输入事件
- en: TIP To see this new feature, don’t forget to rebuild `bundle.js` by running
    `npm run build` before serving it with `npx http-server ./`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：为了看到这个新功能，在通过`npx http-server ./`提供服务之前，不要忘记通过运行`npm run build`来重建`bundle.js`。
- en: Now that you have the validation feature working, write a test for it. This
    test must set the input’s value and dispatch an `input` event through the `input`
    node. After dispatching the event, it should check whether the document contains
    a success message.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经实现了验证功能，为它编写一个测试。这个测试必须设置输入的值并通过`input`节点派发一个`input`事件。在派发事件后，它应该检查文档是否包含成功消息。
- en: Listing 6.43 main.test.js
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.43 main.test.js
- en: '[PRE44]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Creates a “native” instance of Event with type input
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个类型为input的“原生”Event实例
- en: ❷ Dispatches the event through the field for an item’s name
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过字段名称派发事件
- en: ❸ Checks whether the page contains the expected feedback message
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查页面是否包含预期的反馈消息
- en: As an exercise, try writing a test for the unhappy path. This test should enter
    an invalid item name, dispatch an event through the item name field, and check
    if the document contains an error message.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试编写一个测试来测试不愉快的路径。这个测试应该输入一个无效的项目名称，通过项目名称字段派发一个事件，并检查文档是否包含错误消息。
- en: Back to our application requirements—showing an error message when an item’s
    name is invalid is excellent, but, if we don’t disable the users from submitting
    the form, they’ll still be able to add invalid items to the inventory. We also
    don’t have any validation to prevent users from submitting the form without specifying
    a quantity, causing `NaN` to be displayed.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的应用程序需求——当项目的名称无效时显示错误消息是很好的，但如果我们不禁用用户提交表单，他们仍然可以向库存中添加无效的项目。我们也没有任何验证来防止用户在未指定数量时提交表单，这会导致显示
    `NaN`。
- en: To prevent these invalid actions from happening, you’ll need to refactor your
    handlers. Instead of listening only to `input` events that happen on the item
    name field, you’ll listen to all `input` events that happen on the form’s children.
    Then, the form will check its children’s values and decide whether it should disable
    the submit button.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这些无效操作发生，你需要重构你的处理程序。而不是只监听在项目名称字段上发生的 `input` 事件，你将监听在表单子元素上发生的所有 `input`
    事件。然后，表单将检查其子元素的值，并决定是否应该禁用提交按钮。
- en: Start by renaming `handleItemName` to `checkFormValues` and making it validate
    the values in both of the form’s fields.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `handleItemName` 重命名为 `checkFormValues`，并使其验证表单的两个字段中的值。
- en: Listing 6.44 domController.js
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.44 domController.js
- en: '[PRE45]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Disables or enables the form’s submit input, depending on whether the values
    in the form’s fields are valid
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 根据表单字段中的值是否有效，禁用或启用表单的提交输入
- en: Now update `main.js` so that instead of attaching `handleItemName` to the name
    input, it attaches the new `checkFormValues` to your form. This new listener will
    respond to any `input` events that bubble up from the form’s children.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更新 `main.js`，使其不再将 `handleItemName` 绑定到名称输入，而是将新的 `checkFormValues` 绑定到你的表单上。这个新的监听器将响应来自表单子元素的任何
    `input` 事件。
- en: Listing 6.45 main.js
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.45 main.js
- en: '[PRE46]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ The checkFormValues function will now handle any input events triggered in
    the form, including input events that will bubble up from the form’s children.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `checkFormValues` 函数现在将处理表单中触发的任何输入事件，包括从表单子元素冒泡上来的输入事件。
- en: NOTE To see the application working, rebuild it with `npm` `run build` before
    serving it, as we have done multiple times throughout this chapter.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了看到应用程序的工作情况，在提供之前，使用 `npm run build` 重新构建它，就像我们在本章中多次做的那样。
- en: Given that you have preserved the error message that appears when users enter
    invalid item names, the previous tests for the item name validation should continue
    to pass. But, if you try rerunning them, you will see that they fail.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你保留了当用户输入无效项目名称时出现的错误消息，之前的针对项目名称验证的测试应该继续通过。但是，如果你尝试重新运行它们，你会看到它们失败了。
- en: TIP To run *only* the tests in `main.test.js`, you can pass `main.test.js` as
    the first argument to the `jest` command.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：要仅运行 `main.test.js` 中的测试，可以将 `main.test.js` 作为 `jest` 命令的第一个参数传递。
- en: If you are running `jest` from your `node_modules` folder, your command should
    look like `./node_modules/.bin/jest main.test.js`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从 `node_modules` 文件夹运行 `jest`，你的命令应该看起来像 `./node_modules/.bin/jest main.test.js`。
- en: If you have added an NPM script to run Jest called, for example, `test`, you
    should run `npm run test -- main.test.js`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经添加了一个名为 `test` 的 NPM 脚本来运行 Jest，你应该运行 `npm run test -- main.test.js`。
- en: These tests fail because the events you have dispatched will *not* bubble up.
    When dispatching an `input` event through the item name field, for example, it
    will *not* trigger any of the listeners attached to its parents, including the
    one attached to the `form`. Because the `form` listener is not executed, it won’t
    add any error messages to the page, causing your tests to fail.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试失败是因为你发出的事件将**不会**冒泡。例如，通过项目名称字段发出 `input` 事件时，它将**不会**触发其父元素（包括 `form`）上的任何监听器。因为
    `form` 监听器没有执行，它不会向页面添加任何错误消息，导致你的测试失败。
- en: To fix your tests by making events bubble up, you must pass an extra argument
    when instantiating events. This additional argument should contain a property
    named `bubbles`, whose value is `true`. Events created with this option *will*
    bubble up and trigger listeners attached to an element’s parents.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过使事件冒泡来修复你的测试，你必须在使用事件时传递一个额外的参数。这个额外的参数应该包含一个名为 `bubbles` 的属性，其值为 `true`。使用此选项创建的事件**会**冒泡并触发元素父元素上的监听器。
- en: Listing 6.46 main.test.js
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.46 main.test.js
- en: '[PRE47]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Creates a “native” instance of Event with type input, which can bubble up
    to the parents of the element through which it’s dispatched
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个具有输入类型的“原生”事件实例，该实例可以通过发出它的元素的父母冒泡到元素的父母。
- en: ❷ Dispatches the event through the field for an item’s name. Because the event’s
    bubble property is set to true, it will bubble up to the form, triggering its
    listeners.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过项目的名称字段分发事件。因为事件的冒泡属性被设置为true，它将冒泡到表单，触发其监听器。
- en: To avoid having to instantiate and dispatch events manually, `dom-testing-library`
    includes a utility called `fireEvent`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免手动实例化和分发事件，`dom-testing-library`包含了一个名为`fireEvent`的实用工具。
- en: With `fireEvent`, you can accurately simulate many different kinds of events,
    including submitting forms, pressing keys, and updating fields. Because `fireEvent`
    handles all that you need to do when firing an event on a particular component,
    it helps you write less code and not have to worry about everything that happens
    when an event is triggered.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fireEvent`，你可以精确地模拟许多不同类型的事件，包括提交表单、按键和更新字段。因为`fireEvent`处理在特定组件上触发事件时你需要做的所有事情，它帮助你编写更少的代码，并且不必担心事件触发时发生的所有事情。
- en: By using `fireEvent` instead of manually creating an `input` event, you can,
    for example, avoid having to set the `value` property of the field for an item’s
    name. The `fireEvent` function knows that an `input` event changes the value of
    the component through which it’s dispatched. Therefore it will handle changing
    the `value` for you.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`fireEvent`而不是手动创建`input`事件，例如，你可以避免设置项目名称字段的`value`属性。`fireEvent`函数知道`input`事件通过它分发的方式改变了组件的值。因此，它会为你处理更改`value`。
- en: Update your tests for the form validation so that they use the `fireEvent` utility
    from `dom-testing-library`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的表单验证测试，以便使用来自`dom-testing-library`的`fireEvent`实用工具。
- en: Listing 6.47 main.test.js
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.47 main.test.js
- en: '[PRE48]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ Instead of creating an event and then dispatching it, use fireEvent.input
    to trigger an input event on the field for an item’s name.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不要创建事件然后分发它，而是使用`fireEvent.input`在项目的名称字段上触发输入事件。
- en: TIP In case you need to simulate user events more accurately, such as users
    typing at a certain speed, you can use the `user-event` library, which is also
    made by the `testing-library` organization.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：如果你需要更准确地模拟用户事件，例如以特定速度输入，你可以使用由`testing-library`组织制作的`user-event`库。
- en: 'This library can be especially useful when, for example, you have fields that
    use debounced validations: validations that are triggered only at a certain time
    after users stop typing.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当例如你有使用防抖验证的字段时，这个库特别有用：验证只在用户停止输入一段时间后才会触发。
- en: You can see the complete documentation for `@testing-library/user-event` at
    [https://github.com/testing-library/user-event](https://github.com/testing-library/user-event).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/testing-library/user-event](https://github.com/testing-library/user-event)查看`@testing-library/user-event`的完整文档。
- en: As an exercise, try updating all the other tests so that they use `fireEvent`.
    I’d also recommend handling different kinds of interactions with the inventory
    manager and testing them. You can try, for example, removing items when users
    double-click their names on the item list.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试更新所有其他测试，使它们使用`fireEvent`。我还建议处理与库存管理器的不同类型的交互并对其进行测试。例如，你可以尝试在用户双击项目列表中的名称时移除项目。
- en: After this section, you should be able to write tests that validate interactions
    that users will have with your page. Even though it’s okay to manually construct
    events so that you can get quick feedback while you iterate, that’s not the kind
    of test that creates the most reliable quality guarantees. Instead, to simulate
    your user’s behavior much more accurately—and, therefore, create more reliable
    guarantees—you can either dispatch native events using `dispatchEvent` or use
    third-party libraries to make this process more convenient. When it comes to catching
    errors, this resemblance will make your tests much more valuable, and because
    you’re not trying to manually reproduce an event’s interface, they’ll cause much
    less maintenance overhead.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节之后，你应该能够编写测试来验证用户与你的页面交互的交互。尽管在迭代过程中手动构建事件以获得快速反馈是可以的，但这种测试并不能提供最可靠的质量保证。相反，为了更准确地模拟用户的行为——因此，创建更可靠的质量保证——你可以使用`dispatchEvent`来分发原生事件，或者使用第三方库来使这个过程更加方便。当涉及到捕获错误时，这种相似性将使你的测试更有价值，而且因为你不是试图手动重现事件的接口，所以它们将导致更少的维护开销。
- en: 6.4 Testing and browser APIs
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 测试和浏览器API
- en: A well-equipped kitchen doesn’t necessarily imply well-baked desserts. When
    it comes to its role in baking amazing cakes, a kitchen is only as good as the
    pastry chef in it. Similarly, in the less tasty but equally fun world of web development,
    the fantastic APIs that browsers provide you are helpful only if your application
    interfaces with them correctly.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设备齐全的厨房并不一定意味着能做出美味的甜点。当谈到其在烘焙美味蛋糕中的作用时，厨房的好坏仅取决于里面的糕点师。同样，在不太美味但同样有趣的网页开发世界中，浏览器提供的出色
    API 只有在您的应用程序正确与之接口时才有帮助。
- en: As I’ve previously mentioned in this chapter, thanks to the methods that browsers
    make available to your code, you can build feature-rich applications. You can,
    for example, obtain a user’s location, send notifications, navigate through the
    application’s history, or store data in the browser that will persist between
    sections. Modern browsers even allow you to interact with Bluetooth devices and
    do speech recognition.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章前面提到的，由于浏览器提供给您的代码的方法，您可以构建功能丰富的应用程序。例如，您可以获取用户的位置，发送通知，浏览应用程序的历史记录，或者在浏览器中存储将在各个部分之间持久化的数据。现代浏览器甚至允许您与蓝牙设备交互并进行语音识别。
- en: In this chapter, you will learn how to test features that involve these APIs.
    You’ll understand from where they come, how to check them, and how to write adequate
    test doubles to help you deal with event handlers without interfering with your
    application code.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何测试涉及这些 API 的功能。您将了解它们的来源，如何检查它们，以及如何编写适当的测试替身来帮助您处理事件处理器，而不会干扰您的应用程序代码。
- en: 'You’ll learn how to test these DOM APIs by integrating two of them with your
    frontend application: `localStorage` and `history`. By using `localStorage`, you’ll
    make your application persist its data within the browser and restore it when
    the page loads. Then, with the History API, you’ll allow users to undo adding
    items to the inventory.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习如何通过将两个 DOM API 集成到您的前端应用程序中来测试这些 DOM API：`localStorage` 和 `history`。通过使用
    `localStorage`，您将使您的应用程序在浏览器中持久化其数据，并在页面加载时恢复它。然后，使用历史 API，您将允许用户撤销向库存中添加项目。
- en: 6.4.1 Testing a localStorage integration
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 测试 localStorage 集成
- en: The `localStorage` is a mechanism that is part of the Web Storage API. It enables
    applications to store key-value pairs in the browser and retrieve them at a later
    date. You can find documentation for `localStorage` at [https://developer.mozilla.org/
    en-US/docs/Web/API/Web_Storage_API/Local_storage](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Local_storage).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage` 是 Web Storage API 的一部分机制。它允许应用程序在浏览器中存储键值对，并在稍后日期检索它们。您可以在 [https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Local_storage](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Local_storage)
    找到关于 `localStorage` 的文档。'
- en: By learning how to test APIs like `localStorage`, you will understand how they
    work within a test environment and how to validate your application’s integration
    with them.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习如何测试像 `localStorage` 这样的 API，您将了解它们在测试环境中的工作方式以及如何验证您的应用程序与它们的集成。
- en: In these examples, you’ll persist to `localStorage` the inventory used to update
    the page. Then, when the page loads, you’ll retrieve the inventory from `localStorage`
    and use it to populate the list again. This feature will cause your application
    to not lose data between sessions.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，您将持久化存储用于更新页面的库存到 `localStorage`。然后，当页面加载时，您将从 `localStorage` 中检索库存，并使用它再次填充列表。这个功能将使您的应用程序在会话之间不会丢失数据。
- en: Start by updating `updateItemList` so that it stores the object passed to it
    under the `inventory` key in `localStorage`. Because `localStorage` can’t store
    objects, you’ll need to serialize `inventory` with `JSON.stringify` before persisting
    the data.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更新 `updateItemList` 以使其在 `localStorage` 中的 `inventory` 键下存储传递给它的对象。因为 `localStorage`
    不能存储对象，所以在持久化数据之前，您需要使用 `JSON.stringify` 序列化 `inventory`。
- en: Listing 6.48 domController.js
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.48 domController.js
- en: '[PRE49]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ Stores the serialized inventory in the browser’s localStorage
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在浏览器本地存储中存储序列化的库存
- en: Now that you’re saving to `localStorage` the list of items used to populate
    the page, update `main.js`, and make it retrieve data under the `inventory` key
    when the page loads. Then, call `updateItemList` with it.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您正在将用于填充页面的项目列表保存到 `localStorage` 中，更新 `main.js`，使其在页面加载时检索 `inventory` 键下的数据。然后，用这个数据调用
    `updateItemList`。
- en: Listing 6.49 main.js
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.49 main.js
- en: '[PRE50]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ Retrieves and deserializes the inventory from localstorage when the page loads
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在页面加载时从本地存储检索并反序列化库存
- en: ❷ Updates the application’s state with the previously stored data
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用先前存储的数据更新应用程序的状态
- en: ❸ Updates the item list using the restored inventory
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用恢复的库存更新项目列表
- en: After this change, when you rebuild your application and refresh the page you’re
    serving, you’ll see that the data persists between sessions. If you add a few
    items to the inventory and refresh the page again, you’ll see that the items from
    the previous session will remain in the list.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改之后，当你重新构建你的应用程序并刷新你正在服务的页面时，你会看到数据在会话之间保持持久。如果你向库存中添加一些项目并再次刷新页面，你会看到之前会话中的项目将保留在列表中。
- en: To test these features, we’ll rely on JSDOM once again. In the same way that,
    in the browser, `localStorage` is a global available under `window`, in JSDOM,
    it is also available under the `window` property in your JSDOM instance. Thanks
    to Jest’s environment setup, this instance is available in the global namespace
    of each of your test files.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这些功能，我们将再次依赖JSDOM。与在浏览器中`localStorage`是全局的且在`window`下可用一样，在JSDOM中，它也在你的JSDOM实例的`window`属性下可用。多亏了Jest的环境设置，这个实例在每个测试文件的全球命名空间中都是可用的。
- en: Because of this infrastructure, you can test your application’s integration
    with `localStorage` using the same lines of code as you would in a browser’s console.
    By using JSDOM’s implementation instead of stubs, your tests will resemble a browser’s
    run time more closely and, therefore, will be way more valuable.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个基础设施，你可以使用与在浏览器控制台中相同的代码行来测试你的应用程序与`localStorage`的集成。通过使用JSDOM的实现而不是存根，你的测试将更接近浏览器的运行时，因此将更有价值。
- en: TIP As a rule of thumb, whenever JSDOM implements the browser API with which
    you integrate, use it. By avoiding test doubles, your tests will resemble what
    happens in run time more closely and, therefore, will become more reliable.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 作为一条经验法则，每当JSDOM实现了你想要集成的浏览器API时，就使用它。通过避免测试替身，你的测试将更接近运行时发生的情况，因此将变得更加可靠。
- en: Go ahead and add a test that validates `updateItemList` and its integration
    with `localStorage`. This test will follow the three As pattern. It will create
    an inventory, exercise the `updateItemList` function, and check whether `localStorage`’s
    `inventory` key contains the expected value.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 继续添加一个验证`updateItemList`及其与`localStorage`集成的测试。这个测试将遵循三个A模式。它将创建一个库存，执行`updateItemList`函数，并检查`localStorage`的`inventory`键是否包含预期的值。
- en: Additionally, you should add a `beforeEach` hook that clears the `localStorage`
    before each test runs. This hook will ensure that any other tests that use `localStorage`
    will not interfere in this test’s execution.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你应该添加一个`beforeEach`钩子，在每个测试运行之前清除`localStorage`。这个钩子将确保任何其他使用`localStorage`的测试不会干扰这个测试的执行。
- en: Listing 6.50 domController.test.js
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.50 domController.test.js
- en: '[PRE51]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As I’ve previously mentioned, thanks to JSDOM and Jest’s environment setup,
    you can use the `localStorage` available in the global namespace both in your
    test and in the unit under test, as shown in figure 6.6.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，多亏了JSDOM和Jest的环境设置，你可以在你的测试和被测试的单元中同时使用全局命名空间中的`localStorage`，如图6.6所示。
- en: '![](../Images/CH06_F06_DaCosta.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F06_DaCosta.png)'
- en: Figure 6.6 Both your test and the unit under test will have access to the same
    global `localStorage` provided by JSDOM.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 无论是你的测试还是被测试的单元，都将能够访问由JSDOM提供的相同全局`localStorage`。
- en: Notice that this test doesn’t create a very reliable quality guarantee. It doesn’t
    check whether the application uses `updateItemList` as a handler for any events
    or that it restores the inventory when the page reloads. Even though it doesn’t
    tell you much about the overall functioning of the application, it is a good test
    for iterating quickly, or obtaining granular feedback, especially given how easy
    it is to write.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个测试并没有提供一个非常可靠的质量保证。它并没有检查应用程序是否使用`updateItemList`作为任何事件的处理器，或者当页面重新加载时是否恢复库存。尽管它并没有告诉你关于应用程序整体功能太多信息，但它是一个快速迭代或获取细粒度反馈的好测试，尤其是在编写起来如此容易的情况下。
- en: From here onward, you could write many different kinds of tests in various levels
    of isolation. For example, you could write a test that fills the form, clicks
    the submit button, and checks the `localStorage` to see if it’s been updated.
    This test’s scope is broader than the previous one, and, therefore, it goes higher
    in the testing pyramid, but it still wouldn’t tell you whether the application
    reloads the data after the user refreshes the page.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，您可以在各种隔离级别上编写许多不同类型的测试。例如，您可以编写一个测试，填写表单，点击提交按钮，并检查`localStorage`是否已更新。这个测试的范围比之前的更广，因此它在测试金字塔中位置更高，但它仍然不会告诉您应用程序在用户刷新页面后是否会重新加载数据。
- en: Alternatively, you could go straight to a more complex end-to-end test, which
    would fill the form, click the submit button, check the content in `localStorage`,
    **and** refresh the page to see if the item list remains populated between sessions.
    Because this end-to-end test closely resembles what happens at run time, it creates
    more reliable guarantees. This test completely overlaps with the one I previously
    mentioned, so it saves you the effort of duplicating testing code. Essentially,
    it just packs more actions into a single test and helps you keep your testing
    codebase small and easier to maintain.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以直接进行更复杂的端到端测试，该测试将填写表单，点击提交按钮，检查`localStorage`中的内容，**并且**刷新页面以查看项目列表是否在会话之间保持填充。因为这个端到端测试与运行时发生的情况非常相似，它提供了更可靠的保证。这个测试与之前提到的测试完全重叠，因此它为您节省了重复测试代码的精力。本质上，它只是将更多的操作打包到一个测试中，并帮助您保持测试代码库小且易于维护。
- en: Because you won’t reload the page’s scripts, you can, instead, reassign your
    HTML’s content to `document.body.innerHTML` and execute `main.js` again, just
    like you did in the `beforeEach` hook in `main.test.js`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您不会重新加载页面的脚本，所以您可以重新分配HTML的内容到`document.body.innerHTML`，并再次执行`main.js`，就像您在`main.test.js`中的`beforeEach`钩子中做的那样。
- en: Even though, for now, this test will be the only one using `localStorage` in
    this file, it’s good to add a `beforeEach` hook to clear `localStorage` before
    each test. By adding this hook now, you won’t waste time in the future wondering
    why any other tests involving this API are failing.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管目前这个测试将是这个文件中唯一使用`localStorage`的测试，但添加一个在每次测试之前清除`localStorage`的`beforeEach`钩子是个好主意。通过现在添加这个钩子，您将来就不会浪费时间在思考为什么涉及此API的其他测试失败。
- en: Here’s what that test should look like.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个测试应该看起来像什么。
- en: Listing 6.51 main.test.js
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.51 main.test.js
- en: '[PRE52]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ❶ After having filled the form, submits it so that the application can store
    the inventory’s state
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在填写完表单后，提交它以便应用程序可以存储库存的状态
- en: ❷ In this case, this reassignment is equivalent to reloading the page.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在这种情况下，这个重新分配相当于重新加载页面。
- en: ❸ For main.js to run when importing it again, don’t forget that you must clear
    Jest’s cache.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为了在再次导入时运行main.js，别忘了您必须清除Jest的缓存。
- en: ❹ Executes main.js again for the application to restore the stored state
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 再次执行main.js以便应用程序恢复存储的状态
- en: ❺ Checks whether page’s state corresponds to the state stored before reloading
    it
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查页面的状态是否与重新加载之前存储的状态相匹配
- en: Now that you’ve learned where browser APIs come from, how they’re made available
    to your tests, and how you can use them to simulate a browser’s behavior, try
    adding a similar feature and test it yourself. As an exercise, you can try persisting
    the log of actions, too, so that it’s kept intact between sessions.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了浏览器API的来源，它们是如何提供给您的测试的，以及您如何使用它们来模拟浏览器行为，尝试添加一个类似的功能并自行测试。作为一个练习，您还可以尝试持久化操作日志，以便在会话之间保持完整。
- en: 6.4.2 Testing a History API integration
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 测试History API集成
- en: The History API enables developers to interface with the user’s navigation history
    within a specific tab or frame. Applications can push new states into `history`
    and unwind or rewind it. You can find documentation for the History API at [https://developer.mozilla.org/en-US/docs/Web/API/History](https://developer.mozilla.org/en-US/docs/Web/API/History).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: History API允许开发者与特定标签页或框架中的用户导航历史进行交互。应用程序可以将新状态推入`history`，并回滚或重放它。您可以在[https://developer.mozilla.org/en-US/docs/Web/API/History](https://developer.mozilla.org/en-US/docs/Web/API/History)找到关于History
    API的文档。
- en: By learning how to test the History API, you’ll learn how to manipulate event
    listeners with test doubles and how to execute assertions that depend on events
    triggered asynchronously. This knowledge is useful not only for testing features
    that involve the History API but also for whenever you need to interact with listeners
    to which you don’t necessarily have access by default.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习如何测试 History API，你将学习如何使用测试替身操作事件监听器，以及如何执行依赖于异步触发的事件的断言。这种知识不仅对测试涉及 History
    API 的功能很有用，而且在你需要与默认情况下可能无法访问的监听器交互时也很有用。
- en: Before getting to tests, you’ll implement the “undo” feature.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行测试之前，你将实现“撤销”功能。
- en: To allow users to undo an item to the inventory, update `handleAddItem` so that
    it pushes a new state to the inventory whenever users add items.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户将项目撤销到库存中，更新 `handleAddItem` 以便在用户添加项目时将新的状态推入库存。
- en: Listing 6.52 domController.js
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.52 domController.js
- en: '[PRE53]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ❶ Pushes into history a new frame containing the inventory’s content
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将包含库存内容的新的框架推入历史记录
- en: NOTE JSDOM’s `history` implementation has a bug in which the pushed state will
    *not* be cloned before being assigned to the state. Instead, JSDOM’s `history`
    will hold a reference to the object passed.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：JSDOM 的 `history` 实现存在一个错误，即在将状态分配之前，不会对推入的状态进行克隆。相反，JSDOM 的 `history` 将保留传递给它的对象的引用。
- en: Because you mutate `inventory` as users add items, the previous frame in JSDOM’s
    `history` will contain the latest version of the inventory, not the previous one.
    Therefore, reverting to the former state won’t work as it should.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你在用户添加项目时修改了 `inventory`，JSDOM 的 `history` 中的上一个框架将包含库存的最新版本，而不是上一个版本。因此，回滚到以前的状态将不会按预期工作。
- en: To avoid this problem, you can create a new `data.inventory` yourself by using
    `{ ... data.inventory }`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，你可以通过使用 `{ ... data.inventory }` 来自己创建一个新的 `data.inventory`。
- en: JSDOM’s implementation of DOM APIs should never differ from the ones in browsers,
    but, because it’s an entirely different piece of software, that can happen.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: JSDOM 的 DOM API 实现永远不应该与浏览器中的实现不同，但由于它是一个完全不同的软件，这种情况可能会发生。
- en: This issue is already being investigated at [https://github.com/jsdom/jsdom/issues/2970](https://github.com/jsdom/jsdom/issues/2970),
    but if you happen to find a JSDOM bug like this one, the quickest solution is
    to fix it yourself by updating your code to behave in JSDOM as it would in a browser.
    If you have the time, I’d highly recommend that you also file an issue against
    the upstream `jsdom` repository, and, if possible, create a pull request to fix
    it so that others won’t face the same problems in the future.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 此问题已在 [https://github.com/jsdom/jsdom/issues/2970](https://github.com/jsdom/jsdom/issues/2970)
    上进行调查，但如果你偶然发现类似这样的 JSDOM 错误，最快速的解决方案是自行修复，通过更新你的代码以在 JSDOM 中表现得像在浏览器中一样。如果你有时间，我强烈建议你也在上游
    `jsdom` 存储库中提交一个问题，如果可能的话，创建一个拉取请求来修复它，这样其他人就不会在未来遇到相同的问题。
- en: Now, create a function that will be triggered when users click an `undo` button.
    In case the user isn’t already in the very first item in history, this function
    should go back by calling `history.back`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个当用户点击“撤销”按钮时将被触发的函数。如果用户尚未处于历史记录中的第一个项目，此函数应通过调用 `history.back` 来回退。
- en: Listing 6.53 domController.js
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.53 domController.js
- en: '[PRE54]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ❶ If history.state is null, it means we’re already in the very beginning of
    history.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果 history.state 为 null，则意味着我们已经在历史记录的非常开始处。
- en: ❷ If history.state is not null, uses history.back to pop the history’s last
    frame
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果 history.state 不为 null，则使用 history.back 弹出历史记录的最后一个框架
- en: ❸ You’ll have to use handleUndo to handle events. Don’t forget to export it.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 你将不得不使用 handleUndo 来处理事件。别忘了导出它。
- en: Because `history.back` happens asynchronously, you must also create a handler
    you’ll use for the window’s `popstate` event, which is dispatched when `history.back`
    finishes.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `history.back` 是异步发生的，你还必须创建一个用于窗口 `popstate` 事件的处理器，该事件在 `history.back`
    完成时被触发。
- en: Listing 6.54 domController.js
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.54 domController.js
- en: '[PRE55]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ❶ Exports handlePopstate, too, so that you can attach it to the window’s popstate
    event in main.js later.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 也导出 handlePopstate，这样你就可以在 main.js 中稍后将其附加到窗口的 popstate 事件。
- en: To `index.html` you add an Undo button, which we’ll use to trigger `handleUndo`
    later.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.html` 中添加一个撤销按钮，我们将使用它来触发 `handleUndo`。
- en: Listing 6.55 index.html
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.55 index.html
- en: '[PRE56]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ❶ The button that will trigger “undo” actions
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将触发“撤销”操作的按钮
- en: Finally, let’s put everything together and update `main.js` for `handleUndo`
    to be called when users click the Undo button and so that the list gets updated
    when `popstate` events are triggered.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们把所有东西放在一起，更新 `main.js`，以便当用户点击撤销按钮时调用 `handleUndo`，并且当触发 `popstate` 事件时列表得到更新。
- en: NOTE The interesting thing about `popstate` events is that they’re also triggered
    when users press the browser’s back button. Because your handler for `popstate`
    is separate from `handleUndo`, the undo functionality is also going to work when
    users press the browser’s back button.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：关于 `popstate` 事件有趣的是，当用户按下浏览器的后退按钮时，它们也会被触发。因为你的 `popstate` 处理器与 `handleUndo`
    分开，所以当用户按下浏览器的后退按钮时，撤销功能也将工作。
- en: Listing 6.56 main.js
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.56 main.js
- en: '[PRE57]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ❶ Calls handleUndo whenever a user clicks the Undo button
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当用户点击撤销按钮时调用 handleUndo
- en: Just like you’ve done before, rebuild `bundle.js` by running Browserify, and
    serve it with `http-server` so that you can see it working at `localhost:8080`.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你之前做的那样，通过运行 Browserify 重新构建 `bundle.js`，并用 `http-server` 提供服务，这样你就可以在 `localhost:8080`
    上看到它的工作情况。
- en: With this feature implemented, it’s time to test it. Because this feature involves
    multiple functions, we’ll break its tests into a few different parts. First, you’ll
    learn how to test the `handleUndo` function, checking whether it goes back in
    history when it’s called. Then you’ll write a test to check whether `handlePopstate`
    integrates adequately with `updateItemList`. And, at last, you will write an end-to-end
    test that fills the form, submits an item, clicks the Undo button, and checks
    if the list updates as it should.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了这个功能后，是时候对其进行测试了。因为这个功能涉及多个函数，所以我们将它的测试分成几个不同的部分。首先，你将学习如何测试 `handleUndo`
    函数，检查它在被调用时是否返回历史。然后，你将编写一个测试来检查 `handlePopstate` 是否与 `updateItemList` 充分集成。最后，你将编写一个端到端测试，填写表单，提交一个项目，点击撤销按钮，并检查列表是否按预期更新。
- en: 'Start with a unit test for `handleUndo`. It should follow the three As pattern:
    arrange, act, assert. It will push a state into the global `history—`which is
    available thanks to JSDOM—call `handleUndo`, and check if the `history` is back
    to its initial state.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 从对 `handleUndo` 的单元测试开始。它应该遵循三个 A 的模式：arrange（准备）、act（行动）、assert（断言）。它将状态推入全局的
    `history`（由于 JSDOM 而可用），调用 `handleUndo`，并检查 `history` 是否回到了初始状态。
- en: NOTE Because `history.back` is asynchronous, as I have already mentioned, you
    must perform your assertions only *after* the `popstate` event is triggered.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：因为 `history.back` 是异步的，正如我已经提到的，你必须在 `popstate` 事件触发后执行你的断言。
- en: In this case, it might be simpler and clearer to use a `done` callback to indicate
    when your test should finish, instead of using asynchronous testing callbacks
    like we’ve done most of the time until now.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用 `done` 回调来指示测试何时完成可能更简单、更清晰，而不是像我们到目前为止大多数时候所做的那样使用异步测试回调。
- en: If you don’t remember how `done` works and how it compares to using promises,
    take another look at the examples in the “Integration tests” section of chapter
    2.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了 `done` 的工作原理以及它与使用承诺的比较，请再次查看第 2 章中“集成测试”部分的示例。
- en: Listing 6.57 domController.test.js
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.57 domController.test.js
- en: '[PRE58]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ❶ Checks whether the history is back to its initial state, and finishes the
    tests when a popstate event is triggered
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查历史是否回到初始状态，并在触发 popstate 事件时结束测试
- en: ❷ Pushes a new frame into the history
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将新的框架推入历史记录
- en: ❸ Exercises the handleUndo function for it to trigger a popstate event
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 练习 handleUndo 函数以触发 popstate 事件
- en: When running this test in isolation, it will pass, but, if it runs *after* the
    other tests in the same file, it will fail. Because the other tests have previously
    used `handleAddItem`, they’ve interfered with the initial state from which the
    test for `handleUndo` starts. To solve this, you must reset the history before
    each test.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 当单独运行这个测试时，它会通过，但如果它在同一文件中的其他测试之后运行，它将会失败。因为其他测试之前已经使用了 `handleAddItem`，它们已经干扰了
    `handleUndo` 测试开始的初始状态。为了解决这个问题，你必须在每次测试之前重置历史记录。
- en: Go ahead and create a `beforeEach` hook that keeps calling `history.back` until
    it gets back to the initial state. Once it reaches the initial state, it should
    detach its own listener so that it doesn’t interfere in the test.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建一个 `beforeEach` 钩子，不断调用 `history.back` 直到它回到初始状态。一旦它达到初始状态，它应该断开自己的监听器，这样它就不会干扰测试。
- en: Listing 6.58 domController.test.js
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.58 domController.test.js
- en: '[PRE59]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ❶ If you’re already at history’s initial, detaches itself from listening to
    popstate events and finishes the hook
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果你已经在历史的初始状态，则从监听 popstate 事件中断开连接并完成钩子
- en: ❷ If the history is not at its initial state yet, triggers another popstate
    event by calling the history.back function
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果历史状态尚未处于初始状态，通过调用`history.back`函数触发另一个`popstate`事件
- en: ❸ Uses the clearHistory function to handle popstate events
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用`clearHistory`函数处理`popstate`事件
- en: ❹ Calls clearHistory for the first time, causing the history to rewind
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 首次调用`clearHistory`，导致历史回滚
- en: Another problem with the test you’ve just written is that it attaches a listener
    to the global `window` and doesn’t remove it after the test finishes. Because
    the listener has not been removed, it will still be triggered every time a `popstate`
    event happens, even after that test has finished. These activations could cause
    other tests to fail because the assertions for the completed test would run again.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚编写的测试中还存在另一个问题，那就是它将一个监听器附加到全局`window`上，在测试完成后并没有移除它。由于监听器没有被移除，每次发生`popstate`事件时，它仍然会被触发，即使那个测试已经完成。这些激活可能会使其他测试失败，因为完成测试的断言会再次运行。
- en: To detach all the listeners for the `popstate` event after each test, we must
    spy on the `window`’s `addEventListener` method, so that we can retrieve the listeners
    added during tests and remove them, as illustrated in figure 6.7.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在每次测试后断开所有`popstate`事件的监听器，我们必须监视`window`的`addEventListener`方法，以便我们可以检索测试期间添加的监听器并将它们移除，如图6.7所示。
- en: '![](../Images/CH06_F07_DaCosta.png)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F07_DaCosta.png)'
- en: Figure 6.7 To find event handlers, you can spy on the `window`’s `addEventListener`
    function and filter its calls by the event name passed as the first argument.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 要查找事件处理器，你可以监视`window`的`addEventListener`函数，并通过传递给第一个参数的事件名称过滤其调用。
- en: To find and detach event listeners, add the following code to your tests.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找和断开事件监听器，请将以下代码添加到你的测试中。
- en: Listing 6.59 domController.test.js
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.59 domController.test.js
- en: '[PRE60]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ❶ Uses a spy to track every listener added to the window
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用间谍来跟踪添加到`window`上的每个监听器
- en: ❷ Finds all the listeners for the popstate event
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 查找所有`popstate`事件的监听器
- en: ❸ Removes from window all the listeners for the popstate event
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从`window`中移除所有`popstate`事件的监听器
- en: Next, we need to ensure that `handleUndo` will *not* call `history.back` if
    the user is already in the initial state. In this test, you can’t wait for a `popstate`
    event before performing your assertion because, if `handleUndo` does not call
    `history.back—`as expected—it will never happen. You also can’t write an assertion
    immediately after invoking `handleUndo` because by the time your assertion runs,
    `history.back` might have been called but may not have finished yet. To perform
    this assertion adequately, we’ll spy on `history.back` and assert that it’s *not*
    been called—one of the few situations in which a negated assertion is adequate,
    as we discussed in chapter 3.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保如果用户已经处于初始状态，`handleUndo`将不会调用`history.back`。在这个测试中，你无法在执行断言之前等待`popstate`事件，因为如果`handleUndo`没有调用`history.back`（如预期的那样），它将永远不会发生。你也不能在调用`handleUndo`后立即编写断言，因为当你的断言运行时，`history.back`可能已经被调用，但可能尚未完成。为了充分执行这个断言，我们将监视`history.back`并断言它没有被调用——这是我们讨论的第3章中讨论的少数几种否定断言足够的情况之一。
- en: Listing 6.60 domController.test.js
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.60 domController.test.js
- en: '[PRE61]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ❶ This assertion doesn’t care about whether history.back has finished unwinding
    the history stack. It checks only whether history.back has been called.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这个断言并不关心`history.back`是否已经完成历史栈的回滚。它只检查`history.back`是否被调用过。
- en: The tests you’ve just written cover only `handleUndo` and its interaction with
    `history.back`. In the testing pyramid, they’d be somewhere between a unit test
    and an integration test.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚编写的测试只覆盖了`handleUndo`及其与`history.back`的交互。在测试金字塔中，它们位于单元测试和集成测试之间。
- en: Now, write tests covering `handlePopstate`, which also uses `handleAddItem`.
    This test’s scope is broader, and, therefore, it’s placed higher in the testing
    pyramid than the previous one.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编写覆盖`handlePopstate`的测试，它也使用了`handleAddItem`。这个测试的范围更广，因此它在测试金字塔中的位置比之前的更高。
- en: These tests should push states into the history, call `handlePopstate`, and
    check whether the application updates the item list adequately. In this case,
    you’ll need to write DOM assertions, as we did in the previous section.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试应该将状态推入历史记录，调用`handlePopstate`，并检查应用程序是否适当地更新了项目列表。在这种情况下，你需要编写DOM断言，就像我们在上一节中所做的那样。
- en: Listing 6.61 domController.test.js
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.61 domController.test.js
- en: '[PRE62]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ❶ Pushes into history a new frame containing the inventory’s content
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将包含库存内容的新的帧推入历史记录
- en: ❷ Invokes handlePopstate so that the application updates itself using the state
    in the current history frame
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用 `handlePopstate` 以使应用程序使用当前历史帧中的状态更新自己
- en: ❸ Asserts that the item list has exactly two items
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言项目列表恰好有两个项目
- en: ❹ Finds an element indicating that there are 5 cheesecakes in the inventory
    and then asserting that it’s in the document
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 找到一个元素表明库存中有5个芝士蛋糕，然后断言它在文档中
- en: ❺ Finds an element indicating that there are 2 carrot cakes in the inventory
    and then asserting that it’s in the document
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 找到一个元素表明库存中有2个胡萝卜蛋糕，然后断言它在文档中
- en: NOTE If you wanted to test `handlePopstate` in complete isolation, you could
    find a way to create a stub for `updateItemList`, but, as we’ve previously discussed,
    the more test doubles you use, the less your tests resemble a run-time situation,
    and, therefore, the less reliable they become.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您想完全隔离地测试 `handlePopstate`，您可以找到一种为 `updateItemList` 创建存根的方法，但正如我们之前讨论的，您使用的测试替身越多，您的测试就越不像运行时的情况，因此它们就越不可靠。
- en: 'Here is what happens when running the test you’ve just written, including its
    hooks:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行您刚才编写的测试及其钩子时，会发生以下情况：
- en: The topmost `beforeEach` hook assigns the `initialHtml` to the document’s body
    `innerHTML`.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最顶层的 `beforeEach` 钩子将 `initialHtml` 赋值给文档的 `body` `innerHTML`。
- en: The first `beforeEach` hook within this test’s `describe` block spies on the
    `window`’s `addEventListener` method so that it can track all the listeners that
    will be attached to it.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此测试的 `describe` 块内的第一个 `beforeEach` 钩子监视 `window` 的 `addEventListener` 方法，以便它可以跟踪将要附加到它上的所有监听器。
- en: The second `beforeEach` hook within this test’s `describe` block resets the
    browser’s history back to its initial state. It does so by attaching to `window`
    an event listener that calls `history.back` for every `popstate` event until the
    state is `null`. Once the history is clear, it detaches the listener, which clears
    the `history`.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此测试的 `describe` 块内的第二个 `beforeEach` 钩子将浏览器的历史记录重置为其初始状态。它是通过将一个事件监听器附加到 `window`
    上来实现的，该监听器在状态为 `null` 之前为每个 `popstate` 事件调用 `history.back`。一旦历史记录被清除，它就断开监听器，从而清除
    `history`。
- en: The test itself runs. It pushes a state to the history, exercises `handlePopstate`,
    and checks whether the page contains the expected elements.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试本身运行。它将一个状态推送到历史记录中，执行 `handlePopstate`，并检查页面是否包含预期的元素。
- en: The test’s `afterEach` hook runs. It uses the records in `window.addEventListener.mock.calls`
    to discover the listeners that respond to the `window`’s `popstate` event and
    detaches them.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试的 `afterEach` 钩子运行。它使用 `window.addEventListener.mock.calls` 中的记录来发现响应 `window`
    的 `popstate` 事件的监听器，并将它们断开连接。
- en: As an exercise, try writing a test that covers the integration between `handleAddItem`
    and the History API. Create a test that invokes `handleAddItem` and checks whether
    the state has been updated with the items added to the inventory.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试编写一个测试，覆盖 `handleAddItem` 和 History API 之间的集成。创建一个调用 `handleAddItem`
    并检查状态是否已更新为库存中添加的项目。
- en: Now that you’ve learned how to test `handleUndo` isolation and `handlePopstate`
    and its integration with `updateItemList`, you’ll write an end-to-end test that
    puts everything together. This end-to-end test is the most reliable guarantee
    you can create. It will interact with the applications as a user would, firing
    events through the page’s elements and checking the final state of the DOM.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何测试 `handleUndo` 的隔离和 `handlePopstate` 以及它与 `updateItemList` 的集成，您将编写一个端到端测试，将所有内容组合在一起。这个端到端测试是您可以创建的最可靠的保证。它将以用户的方式与应用程序交互，通过页面元素触发事件，并检查
    DOM 的最终状态。
- en: To run this end-to-end test, you’ll also need to clear the global `history`
    stack. Otherwise, other tests that might have caused the history to change can
    cause it to fail. To avoid copying and pasting the same code among multiple tests,
    create a separate file with a function that clears the `history`, as shown next.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此端到端测试，您还需要清除全局 `history` 栈。否则，可能已导致历史记录发生变化的其他测试可能会使其失败。为了避免在多个测试中复制和粘贴相同的代码，创建一个包含清除
    `history` 的函数的单独文件，如下所示。
- en: Listing 6.62 testUtils.js
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.62 testUtils.js
- en: '[PRE63]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now that you have moved the function that clears the `history` stack to a separate
    file, you can import and use it in your hooks instead of rewriting the same inline
    function each time. You can, for example, go back to `domController.test.js` and
    use `clearHistoryHook` to replace the lengthy inline hook you’ve written there.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将清除 `history` 栈的函数移动到单独的文件中，你可以在钩子中导入和使用它，而不是每次都重写相同的内联函数。例如，你可以回到 `domController.test.js`
    并使用 `clearHistoryHook` 来替换你那里编写的冗长的内联钩子。
- en: Listing 6.63 domController.test.js
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.63 domController.test.js
- en: '[PRE64]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: ❶ Instead of an inline function, uses the separate clearHistoryHook to reset
    the history to its initial state
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 代替内联函数，使用单独的 clearHistoryHook 来重置历史状态到初始状态
- en: Finally, add the same hook to `main.test.js`, and write a test that adds items
    through the form, clicks the Undo button, and checks the list’s contents, just
    like a user would.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将相同的钩子添加到 `main.test.js` 中，并编写一个测试，通过表单添加项目，点击撤销按钮，并检查列表的内容，就像用户一样。
- en: Listing 6.64 main.test.js
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.64 main.test.js
- en: '[PRE65]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ❶ Fills the field for an item’s name
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 填写项目名称的字段
- en: ❷ Fills the field for an item’s quantity
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 填写项目数量的字段
- en: ❸ Submits the form
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 提交表单
- en: ❹ Checks whether the history is in the expected state
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查历史状态是否在期望的状态
- en: ❺ When a popstate event happens, checks whether the item list is empty, and
    finishes the test
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当发生 popstate 事件时，检查项目列表是否为空，并完成测试
- en: ❻ Triggers a popstate event by clicking the Undo button
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 通过点击撤销按钮触发 popstate 事件
- en: As happened previously, this test will always pass when executed in isolation,
    but if it runs alongside other tests in the same file that trigger a `popstate`
    event, it may cause them to fail. This failure occurs because it attaches to `window`
    a listener with assertions, which will continue to run even after the test has
    finished, just like before.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前发生的那样，当单独执行时，此测试将始终通过，但如果它与同一文件中的其他测试一起运行，这些测试会触发 `popstate` 事件，它可能会导致它们失败。这种失败发生是因为它将断言监听器附加到
    `window` 上，即使在测试完成后，这些断言也会继续运行，就像之前一样。
- en: If you want to see it failing, try adding a test that also triggers a `popstate`
    event right before this one. For example, you can write a new test that adds multiple
    items to the inventory and clicks the Undo button only once, as follows.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要看到它失败，尝试添加一个测试，在当前测试之前也触发一个 `popstate` 事件。例如，你可以编写一个新的测试，将多个项目添加到库存中，并只点击一次撤销按钮，如下所示。
- en: Listing 6.65 main.test.js
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.65 main.test.js
- en: '[PRE66]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: ❶ Submits the form, adding 6 cheesecakes to the inventory
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提交表单，将 6 个芝士蛋糕添加到库存中
- en: ❷ Submits the form again, adding 5 carrot cakes to the inventory
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 再次提交表单，将 5 个胡萝卜蛋糕添加到库存中
- en: ❸ When a popstate event happens, checks whether the item list contains the elements
    you expect and finishes the test
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当发生 popstate 事件时，检查项目列表是否包含你期望的元素，并完成测试
- en: ❹ Triggers a popstate event by clicking the Undo button
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通过点击撤销按钮触发 popstate 事件
- en: When running your tests, you will see that they fail because all the previously
    attached handlers for the window’s `popstate` events are executed, no matter whether
    the previous test finished.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行你的测试时，你会看到它们失败，因为所有之前附加到窗口 `popstate` 事件的处理器都会执行，无论之前的测试是否完成。
- en: 'You can solve this problem in the same way you’ve done for the tests in `domController.test.js`:
    by tracking the calls to `window.addEventListener` and detaching handlers after
    each test.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用与在 `domController.test.js` 中测试相同的方式解决这个问题：通过跟踪对 `window.addEventListener`
    的调用，并在每个测试后断开处理程序。
- en: Because you’ll reuse the hook you wrote at `domController.test.js`, move it
    to `testUtils.js`, too, as shown next.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你会重用你在 `domController.test.js` 中编写的钩子，所以也要将它移动到 `testUtils.js` 中，如下所示。
- en: Listing 6.66 testUtils.js
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.66 testUtils.js
- en: '[PRE67]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ❶ Finds all the listeners for the popstate event
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 查找 popstate 事件的全部监听器
- en: ❷ Detaches all popstate listeners
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 断开所有 popstate 监听器
- en: Now, you can use `detachPopstateHandlers` in `domController.test.js` instead
    of writing an inline function.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在 `domController.test.js` 中使用 `detachPopstateHandlers` 而不是编写内联函数。
- en: Listing 6.67 domController.test.js
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.67 domController.test.js
- en: '[PRE68]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: ❶ Uses a spy to track every event listener added to the window
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 spy 跟踪添加到窗口的每个事件监听器
- en: ❷ Instead of using an inline function to detach the listeners for the popstate
    event, uses detachPopstateHandlers
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 代替使用内联函数来断开 popstate 事件的监听器，使用 detachPopstateHandlers
- en: When using `detachPopstateHandlers` in `main.test.js`, you must be careful when
    detaching all of the window’s listeners after each test, because, otherwise, the
    listener attached by `main.js` can accidentally be detached, too. To avoid removing
    the listeners attached by `main.js`, make sure that you spy on `window.addEventListener`
    only after executing `main.js`, as shown in figure 6.8.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`main.test.js`中使用`detachPopstateHandlers`时，你必须小心在每个测试后断开窗口的所有监听器，否则，`main.js`附加的监听器可能会意外地被断开。为了避免移除`main.js`附加的监听器，确保你在执行`main.js`之后才对`window.addEventListener`进行间谍操作，如图6.8所示。
- en: '![](../Images/CH06_F08_DaCosta.png)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8](../Images/CH06_F08_DaCosta.png)'
- en: Figure 6.8 Your spy should capture the calls that happen only *after* executing
    `main.js`.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 你的间谍应该捕获在执行`main.js`之后发生的调用。
- en: Then, add the `afterEach` hook with `detachPopstateHandlers`.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加带有`detachPopstateHandlers`的`afterEach`钩子。
- en: Listing 6.68 main.test.js
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.68 main.test.js
- en: '[PRE69]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: ❶ You can spy on window.add-EventListener only after main.js has been executed.
    Otherwise, detachPopstateHandlers will also detach the handlers that main.js attached
    to the page.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 你只能在main.js执行之后对window.add-EventListener进行间谍操作。否则，detachPopstateHandlers也会断开main.js附加到页面上的处理程序。
- en: NOTE It’s important to notice that these tests have a high degree of overlap.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：重要的是要注意这些测试有很高的重叠度。
- en: Because you’ve written tests both for the individual functions that are part
    of this feature and for the whole feature, including interactions with the DOM,
    you’ll have somewhat redundant checks.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经为这个功能的一部分的各个函数以及包括与DOM交互在内的整个功能编写了测试，你将有一些冗余的检查。
- en: Depending on how granular you want your feedback to be, and the time you have
    available, you should consider writing *only* the end-to-end test, which provides
    the most prominent coverage of them all. If, on the other hand, you’ve got the
    time, and you want to have a quicker feedback loop as you write code, it will
    be useful to write the granular tests, too.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你希望反馈有多细粒度以及你有多少可用时间，你应该考虑只编写端到端测试，这提供了对所有测试的最全面覆盖。另一方面，如果你有时间，并且希望在编写代码时有一个更快的反馈循环，编写细粒度测试也将是有用的。
- en: As an exercise, try adding a “redo” functionality and writing tests for it.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试添加一个“重做”功能并为其编写测试。
- en: Now that you’ve tested integrations both with `localStorage` and the History
    API, you should know that JSDOM is responsible for simulating them within your
    test environment. Thanks to Jest, these values that JSDOM stores within its instance’s
    `window` property will be available to your tests through the global namespace.
    You can use them exactly as you would in a browser, without the necessity for
    stubs. Avoiding these stubs increases the reliability guarantees that your tests
    create because their implementation should mirror what happens in a browser’s
    run time.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经测试了与`localStorage`和History API的集成，你应该知道JSDOM负责在测试环境中模拟它们。多亏了Jest，这些JSDOM在其实例的`window`属性中存储的值将通过全局命名空间对测试可用。你可以像在浏览器中一样使用它们，无需使用存根。避免这些存根可以增加你的测试创建的可靠性保证，因为它们的实现应该反映浏览器运行时发生的情况。
- en: As we’ve done throughout this chapter, when testing your frontend applications,
    pay attention to how much your tests overlap and the granularity of feedback you
    want to achieve. Take those factors into account to decide which tests you should
    write, and which you shouldn’t, just like we’ve discussed in the previous chapter.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中一直所做的那样，在测试你的前端应用程序时，请注意你的测试重叠程度以及你想要达到的反馈粒度。考虑这些因素来决定你应该编写哪些测试，以及不应该编写哪些测试，就像我们在上一章中讨论的那样。
- en: 6.5 Dealing with WebSockets and HTTP requests
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 处理WebSocket和HTTP请求
- en: In this chapter’s previous sections, you’ve built a frontend application that
    stores data locally. Because your clients don’t share a backend, as multiple users
    update the inventory, each one will see a different item list.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几节中，你已经构建了一个前端应用程序，该程序将数据本地存储。由于你的客户端没有共享后端，当多个用户更新库存时，每个人都会看到不同的项目列表。
- en: In this section, to sync items among clients, you will integrate your frontend
    application with the backend from chapter 4 and learn how to test that integration.
    By the end of this section, you’ll have an application that can read, insert,
    and update database items. To avoid users having to refresh the page to see changes
    made by others, you’ll also implement live updates, which will happen through
    WebSockets.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，为了在客户端之间同步项目，您将集成前端应用程序与第 4 章中的后端，并学习如何测试该集成。到本节结束时，您将拥有一个可以读取、插入和更新数据库项的应用程序。为了避免用户需要刷新页面才能看到他人所做的更改，您还将实现实时更新，这些更新将通过
    WebSocket 完成。
- en: NOTE You can find the complete code for the previous chapter’s backend at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以在 [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)
    找到上一章后端代码的完整代码。
- en: This backend will handle requests from the web client, providing it with data
    and updating database entries.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这个后端将处理来自网络客户端的请求，向其提供数据并更新数据库条目。
- en: To keep this chapter focused on tests and make sure that the server will support
    the client we’re building, I highly recommend you to use the backend application
    I’ve pushed to GitHub. It already contains a few updates to support the following
    examples better, so that you don’t have to change the backend yourself.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本章专注于测试并确保服务器将支持我们正在构建的客户端，我强烈建议您使用我推送到 GitHub 的后端应用程序。它已经包含了一些更新，以更好地支持以下示例，这样您就不必自己更改后端。
- en: To run it, navigate to the folder called `server` within `chapter6/5_web_ sockets_and_http_requests`,
    install its dependencies with `npm` `install`, run `npm run migrate:dev` to ensure
    that your database has an up-to-date schema, and start it with `npm start`.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行它，请导航到 `chapter6/5_web_ sockets_and_http_requests` 中的 `server` 文件夹，使用 `npm
    install` 安装其依赖项，运行 `npm run migrate:dev` 以确保您的数据库具有最新的模式，然后使用 `npm start` 启动它。
- en: In case you want to update the backend yourself, within the `server` folder
    there’s a `README.md` file that details all the changes I’ve had to make to the
    application we built in chapter 4.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自己更新后端，在 `server` 文件夹中有一个 `README.md` 文件，其中详细说明了我必须对我们在第 4 章中构建的应用程序所做的所有更改。
- en: 6.5.1 Tests involving HTTP requests
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 涉及 HTTP 请求的测试
- en: Start your backend integration by saving to the database the items that users
    add to the inventory. To implement this feature, whenever users add an item, send
    a request to the new `POST` `/inventory/:itemName` route I’ve added to the server
    from chapter 4\. This request’s body should contain the `quantity` added.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 开始您的后端集成，通过将用户添加到库存中的项目保存到数据库中。为了实现此功能，每当用户添加项目时，向第 4 章中添加到服务器的新的 `POST` `/inventory/:itemName`
    路由发送请求。此请求的主体应包含添加的 `quantity`。
- en: Update the `addItem` function so that it will send a request to the backend
    whenever users add items, as shown next.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `addItem` 函数，使其在用户添加项目时向后端发送请求，如下所示。
- en: Listing 6.69 inventoryController.js
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.69 inventoryController.js
- en: '[PRE70]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: ❶ Sends a POST request to the inventory when adding an item
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在添加项目时向库存发送 POST 请求
- en: Before you get to write the request that retrieves items from the inventory,
    let’s discuss what the optimal way would be to test the functionality you’ve just
    implemented. How would you test whether the `addItem` function correctly interfaces
    with your backend?
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在您编写检索库存中项目的请求之前，让我们讨论一下测试您刚刚实现的功能的最佳方法。您会如何测试 `addItem` 函数是否正确与后端接口？
- en: A suboptimal way to test this integration would be to spin up your server and
    allow requests to reach it. At first, it may seem like the most straightforward
    option, but, in fact, it’s the one that requires more work and yields fewer benefits.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这种集成的一个次优方法是在服务器启动并允许请求到达它。起初，这可能看起来是最直接的选择，但实际上，这是需要更多工作且收益更少的方法。
- en: Having to run your backend for your client’s tests to pass adds complications
    to the test process because it involves too many steps and creates too much room
    for human error. It’s easy for developers to forget that they must have the server
    running, and it’s even easier for them to forget to which port the server should
    listen or in which state the database should be.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 由于必须运行后端以通过客户端的测试，这给测试过程增加了复杂性，因为它涉及太多步骤，并创造了太多人为错误的空间。开发者很容易忘记他们必须运行服务器，而且他们更容易忘记服务器应该监听哪个端口，或者数据库应该处于哪种状态。
- en: Even though you could automate these steps, it would be better to avoid them.
    It’s better to leave this kind of integration for end-to-end UI tests, which you’ll
    learn about in chapter 10\. By avoiding having to use a backend to run your client’s
    tests, you’ll also make it easier to set up continuous integration services that
    will execute your tests in a remote environment, which I’ll cover in chapter 12.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你可以自动化这些步骤，但最好避免这样做。更好的做法是将这种集成留给端到端 UI 测试，你将在第 10 章中学习到。通过避免使用后端来运行客户端测试，你也会使设置持续集成服务变得更容易，这些服务将在远程环境中执行你的测试，我将在第
    12 章中介绍。
- en: 'Considering you don’t want to involve your backend in these tests, you have
    only one option: use test doubles to control the responses to `fetch`. You could
    do that in two ways: you could stub `fetch` itself, write assertions to check
    whether it’s adequately used, and specify a hardcoded response. Or you could use
    `nock` to replace the necessity for a server. With `nock`, you’d determine which
    routes to match and which responses to give, making your tests even more decoupled
    from implementation details, such as which arguments you pass to `fetch` or even
    which libraries you’re using to perform requests. Because of these advantages,
    which I previously mentioned in chapter 4, I recommend you to go with the second
    option.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你不想将这些测试与后端关联起来，你只有一个选择：使用测试替身来控制对 `fetch` 的响应。你可以通过两种方式做到这一点：你可以模拟 `fetch`
    本身，编写断言来检查它是否被充分使用，并指定一个硬编码的响应。或者，你可以使用 `nock` 来替代对服务器的需求。使用 `nock`，你会确定要匹配哪些路由以及提供哪些响应，使你的测试与实现细节（例如你传递给
    `fetch` 的参数或你用于执行请求的库）的耦合度更低。由于这些优势，我在第 4 章中提到过，我建议你选择第二种方案。
- en: Because `nock` depends on requests reaching your interceptors, first, make sure
    that your tests can run within `node` and that they can dispatch requests. To
    do that, run your tests, and see what happens. When running them, you will notice
    that all the tests that call `handleAddItem` will fail because `"fetch is not
    defined"`.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `nock` 依赖于请求到达你的拦截器，首先，确保你的测试可以在 `node` 中运行，并且可以发出请求。为此，运行你的测试，看看会发生什么。在运行时，你会注意到所有调用
    `handleAddItem` 的测试都会失败，因为 `"fetch is not defined"`。
- en: Even though `fetch` is globally available on browsers, it’s *not* yet available
    through JSDOM, and, therefore, you need to find a way to replace it with an equivalent
    implementation. To override it, you can use a setup file, which will attach `isomorphic-fetch`—a
    fetch implementation that can run in Node.js—to the global namespace.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `fetch` 在浏览器中全局可用，它通过 JSDOM 还不可用，因此你需要找到一种方法来用等效的实现来替换它。要覆盖它，你可以使用一个设置文件，该文件将
    `isomorphic-fetch`（一个可以在 Node.js 中运行的 fetch 实现）附加到全局命名空间。
- en: Install `isomorphic-fetch` as a dev dependency with `npm install --save-dev
    isomorphic-fetch`, and create a `setupGlobalFetch.js` file, which will attach
    it to the global namespace.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `npm install --save-dev isomorphic-fetch` 将 `isomorphic-fetch` 安装为开发依赖项，并创建一个
    `setupGlobalFetch.js` 文件，它将将其附加到全局命名空间。
- en: Listing 6.70 setupGlobalFetch.js
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.70 setupGlobalFetch.js
- en: '[PRE71]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: ❶ Replaces the window’s original fetch with the fetch function from isomorphic-fetch
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用 isomorphic-fetch 的 fetch 函数替换 window 的原始 fetch
- en: Once you have created this file, add it to the list of scripts in the `setupFilesAfterEnv`
    property of your `jest.config.js`, as shown in the next code, so that Jest can
    run it before your tests, making `fetch` available to them.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了此文件，将其添加到 `jest.config.js` 文件的 `setupFilesAfterEnv` 属性中的脚本列表中，如下所示代码所示，这样
    Jest 就可以在测试之前运行它，使 `fetch` 对测试可用。
- en: Listing 6.71 jest.config.js
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.71 jest.config.js
- en: '[PRE72]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: After these changes, if you don’t have a server available, your tests should
    fail because the requests made by `fetch` couldn’t get a response.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改之后，如果你没有可用的服务器，你的测试应该会失败，因为 `fetch` 发出的请求无法得到响应。
- en: Finally, it’s time to use `nock` to intercept responses to these requests.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候使用 `nock` 来拦截这些请求的响应了。
- en: Install `nock` as a dev dependency (`npm install --save-dev nock`), and update
    your tests so that they have interceptor for the `/inventory` route.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `nock` 作为开发依赖项安装（`npm install --save-dev nock`），并更新你的测试，以便它们有 `/inventory`
    路由的拦截器。
- en: Listing 6.72 inventoryController.test.js
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.72 inventoryController.test.js
- en: '[PRE73]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: ❶ Responds to all post requests to POST /inventory/:itemName
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 响应所有对 POST /inventory/:itemName 的 POST 请求
- en: Try running the tests *only* for this file. To do that, pass its name as the
    first argument to Jest. You’ll see that the test passes.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试只为此文件运行测试。要做到这一点，将文件名作为 Jest 的第一个参数传递。你会看到测试通过了。
- en: Now, add a test that ensures that the interceptor for `POST /inventory/:itemName`
    has been reached.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加一个测试来确保 `POST /inventory/:itemName` 的拦截器已被触发。
- en: Listing 6.73 inventoryController.test.js
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.73 inventoryController.test.js
- en: '[PRE74]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ❶ If, after a test, not all interceptors have been reached, clears them and
    throws an error
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果测试后，并非所有拦截器都已触发，则清除它们并抛出错误
- en: As an exercise, go ahead and use `nock` to intercept requests to `POST` `/inventory/:itemName`
    in all other tests that reach this route. If you need help, check this book’s
    GitHub repository, at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，请继续使用 `nock` 来拦截所有到达此路由的其他测试中对 `/inventory/:itemName` 的 `POST` 请求。如果你需要帮助，请查看此书的
    GitHub 仓库，网址为 [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: As you update your other tests, don’t forget to check, at multiple levels of
    integration, whether specific actions call this route. I’d recommend, for example,
    adding a test to `main.test.js` to ensure that the correct route is reached when
    adding items through the UI.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更新其他测试时，不要忘记在多个集成级别上检查特定操作是否调用此路由。例如，我建议向 `main.test.js` 添加一个测试，以确保通过 UI 添加项目时能够到达正确的路由。
- en: TIP Interceptors are removed once they’re reached. To avoid tests failing because
    `fetch` can’t get a response, you must either create a new interceptor before
    *each* test or use nock’s `persist` method, as we saw in chapter 4.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：拦截器一旦被触发就会移除。为了避免测试因为 `fetch` 无法获取响应而失败，你必须在每次测试之前创建一个新的拦截器，或者使用第 4 章中提到的
    nock 的 `persist` 方法。
- en: For this feature to be complete, your frontend must ask the server for the inventory
    items when it loads. After this change, it should load the data in `localStorage`
    only if it *can’t* reach the server.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此功能完整，你的前端必须在加载时向服务器请求库存项目。在此更改之后，它应该只在无法到达服务器时才从 `localStorage` 加载数据。
- en: Listing 6.74 main.js
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.74 main.js
- en: '[PRE75]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: ❶ If the request succeeds, updates the item list using the server’s response
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果请求成功，则使用服务器的响应更新项目列表
- en: ❷ Restores the inventory from localStorage if the request fails
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果请求失败，则从 localStorage 中恢复库存
- en: Even though your application is working, the test in `main.test.js` that checks
    whether items persist between sessions should be failing. It fails because it
    needs the `GET` request to `/inventory` to fail before trying to load data from
    `localStorage`.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的应用程序正在运行，检查会话之间项目是否持久化的 `main.test.js` 中的测试应该失败。它失败是因为它需要在尝试从 `localStorage`
    加载数据之前，使对 `/inventory` 的 `GET` 请求失败。
- en: 'To make that test pass, you make do two changes: you must use `nock` to make
    `GET /inventory` to respond with an error, and you must wait until the initial
    data has loaded.'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 要使测试通过，你需要进行两个更改：你必须使用 `nock` 来使 `GET /inventory` 响应错误，并且你必须等待初始数据加载完成。
- en: Listing 6.75 main.test.js
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.75 main.test.js
- en: '[PRE76]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: ❶ Succesfully responds to requests to POST /inventory/:itemName
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 成功响应对 POST /inventory/:itemName 的请求
- en: ❷ Replies twice with an error requests to GET /inventory
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对 GET /inventory 的请求两次返回错误
- en: ❸ This is equivalent to reloading the page.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这相当于重新加载页面。
- en: ❹ Waits for the initial data to load
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 等待初始数据加载
- en: Don’t forget that those tests include a `beforeEach` hook, so, in it, you must
    also wait for `loadInitialData` to complete.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，那些测试包括一个 `beforeEach` 钩子，因此，在它里面，你也必须等待 `loadInitialData` 完成。
- en: Listing 6.76 main.test.js
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.76 main.test.js
- en: '[PRE77]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: ❶ Replies with an error requests to GET /inventory
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对 GET /inventory 的请求返回错误
- en: NOTE Here you are exposing the promise that will resolve once the application
    loads the initial data because you need to know what to wait for.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这里，你正在暴露一个将在应用程序加载初始数据后解决的承诺，因为你需要知道等待什么。
- en: Alternatively, you can wait for a fixed timeout in your test, or keep retrying
    until it either succeeds or times out. These alternatives won’t require you to
    export the promise that `loadInitialData` returns, but they can make your test
    flaky or slower than it should be.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在测试中等待一个固定的超时，或者持续重试，直到成功或超时。这些替代方案不需要你导出 `loadInitialData` 返回的承诺，但它们可以使测试变得不可靠或比应有的速度慢。
- en: You don’t have to worry about the assignment to `module.exports` in `main.js`
    because when running that file in a browser after building it with Browserify,
    it will not have any effect. Browserify will take care of all the `module.exports`
    assignments for you, packing all the dependencies into a single `bundle.js`.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必担心`main.js`中的`module.exports`赋值，因为当你使用Browserify构建该文件并在浏览器中运行时，它将没有任何效果。Browserify会为你处理所有的`module.exports`赋值，将所有依赖项打包成一个单一的`bundle.js`。
- en: Now that you’ve learned how to test features that involve HTTP requests by using
    `nock` interceptors, and, if necessary, overriding `fetch`, I’ll end the section
    with a challenge.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用`nock`拦截器测试涉及HTTP请求的功能，如果需要，还可以覆盖`fetch`，我将通过一个挑战来结束本节。
- en: Currently, when undoing actions, your application will *not* send a request
    to the server to update the inventory contents. As an exercise, try making the
    `undo` functionality sync with the server, and test this integration. For you
    to be able to implement this feature, I have added a new `DELETE /inventory/:itemName`
    route to the server in this chapter’s `server` folder on GitHub, which takes a
    body containing the `quantity` the user wants to delete.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当你撤销操作时，你的应用程序不会向服务器发送请求来更新库存内容。作为一个练习，尝试使`undo`功能与服务器同步，并测试这个集成。为了让你能够实现这个功能，我在GitHub上本章的`server`文件夹中添加了一个新的`DELETE
    /inventory/:itemName`路由，它接受包含用户想要删除的`quantity`的正文。
- en: By the end of this section, you should be capable of isolating your client’s
    tests from your backend by accurately simulating its behavior with `nock`. Thanks
    to `nock`, you can focus on specifying the responses your server would yield in
    which situation without having to spin up an entire backend. Creating isolated
    tests like this makes it much quicker and easier for everyone in your team to
    run tests. This improvement accelerates the feedback loop developers receive,
    and, therefore, incentivizes them to write better tests and to do it more often,
    which, in turn, tends to lead to more reliable software.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，你应该能够通过使用`nock`准确模拟其行为来将你的客户端测试从后端分离出来。多亏了`nock`，你可以在不需要启动整个后端的情况下，专注于指定服务器在何种情况下会产生的响应。创建这样的隔离测试可以让你的团队中的每个人都能更快、更轻松地运行测试。这种改进加速了开发者收到的反馈循环，因此激励他们编写更好的测试，并且更频繁地编写测试，这反过来又往往会导致更可靠的软件。
- en: 6.5.2 Tests involving WebSockets
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 涉及WebSockets的测试
- en: Up to now, if your application has a single user at a time, it works seamlessly.
    But what if multiple operators need to manage the stock simultaneously? If that’s
    the case, the inventory will easily get out of sync, causing each operator to
    see different items and quantities.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你的应用程序一次只有一个用户，它将无缝工作。但如果有多个操作员需要同时管理库存怎么办？如果是这种情况，库存很容易就会不同步，导致每个操作员看到不同的项目和数量。
- en: To solve that problem, you will implement support for live updates through WebSockets.
    These WebSockets will be responsible for updating each client as the inventory
    data changes so that it’s always in sync between the clients.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，你将实现通过WebSockets进行实时更新的支持。这些WebSockets将负责在库存数据更改时更新每个客户端，以确保客户端之间始终同步。
- en: Because this book is about tests, I’ve already implemented this functionality
    in the backend. If you don’t want to implement it yourself, you can use the `server`
    that you can find within the `chapter6` folder in this book’s GitHub repository
    at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这本书是关于测试的，所以我已经在后端实现了这个功能。如果你不想自己实现，你可以使用这本书的GitHub仓库中`chapter6`文件夹内的`server`。该仓库的网址为[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: When clients add items, the changes I’ve made to the server will cause it to
    emit an `add_item` event to all the connected clients except the one who sent
    the request.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端添加项目时，我对服务器所做的更改将导致它向所有连接的客户端（不包括发送请求的那个客户端）发出`add_item`事件。
- en: To connect to the server, you will use the `socket.io-client` module, so you
    must install it as a dependency by using `npm` `install` `socket.io-client`.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到服务器，你将使用`socket.io-client`模块，因此你必须使用`npm install socket.io-client`将其作为依赖项安装。
- en: Start implementing the live updates functionality by creating a module that
    will connect to the server and save the client’s ID once it’s connected.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个将连接到服务器并在连接后保存客户端ID的模块来开始实现实时更新功能。
- en: Listing 6.77 socket.js
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.77 socket.js
- en: '[PRE78]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: ❶ Creates a client instance that connects to API_ADDR
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个客户端实例，连接到 API_ADDR
- en: ❷ Once the client is connected, stores its id and resolves the promise
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一旦客户端连接，就存储其ID并解析承诺
- en: For each client to connect to the server, you must call in `main.js` the `connect`
    function exported by `socket.js`.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个连接到服务器的客户端，你必须在 `main.js` 中调用由 `socket.js` 导出的 `connect` 函数。
- en: Listing 6.78 main.js
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.78 main.js
- en: '[PRE79]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: ❶ Connects to the Socket.io server when the application loads
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当应用程序加载时连接到 Socket.io 服务器
- en: After the client connects to the server, whenever users add a new item, the
    client must send its Socket.io client ID to the server through the `x-socket-client-id`
    header. The server will use this header to identify which client added the item
    so that it can skip it, given that this client will have already updated itself.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端连接到服务器后，每当用户添加一个新项目时，客户端必须通过 `x-socket-client-id` 标头将它的 Socket.io 客户端 ID
    发送到服务器。服务器将使用此标头来识别哪个客户端添加了项目，以便在已知此客户端已经更新了自己的情况下跳过它。
- en: NOTE The route that enables clients to add items to the inventory will extract
    the value in the `x-socket-client-id` header to determine which client sent the
    request. Then, once it has added an item to the inventory, it will iterate through
    all the connected sockets and emit an `add_item` event to the clients whose `id`
    does *not* match the one in `x-socket-client-id`.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：允许客户端向库存添加项目的路由将提取 `x-socket-client-id` 标头中的值，以确定哪个客户端发送了请求。然后，一旦它向库存添加了一个项目，它将遍历所有连接的套接字，并向
    `id` 不匹配 `x-socket-client-id` 的客户端发出 `add_item` 事件。
- en: Listing 6.79 server.js
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.79 server.js
- en: '[PRE80]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Update `inventoryController.js`, so that it sends the client’s ID to the server,
    as shown next.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `inventoryController.js`，以便它将客户端的 ID 发送到服务器，如下所示。
- en: Listing 6.80 inventoryController.js
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.80 inventoryController.js
- en: '[PRE81]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: ❶ Includes an x-socket-client-id containing the Socket.io client’s ID when sending
    requests that add items
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在发送添加项目请求时包含一个包含 Socket.io 客户端 ID 的 x-socket-client-id
- en: Now that the server can identify the sender, the last step is to update the
    `socket.js` file so that the client can update itself when it receives the `add_item`
    messages the server sends when others add items. These messages contain an `itemName`
    and a `quantity` properties, which you will use to update the inventory data.
    Once the local state is up-to-date, you will use it to update the DOM.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务器可以识别发送者，最后一步是更新 `socket.js` 文件，以便客户端在接收到服务器发送的 `add_item` 消息（当其他人添加项目时）时可以更新自己。这些消息包含
    `itemName` 和 `quantity` 属性，你将使用这些属性来更新库存数据。一旦本地状态更新，你将使用它来更新 DOM。
- en: Listing 6.81 socket.js
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.81 socket.js
- en: '[PRE82]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: ❶ A function that updates the application’s state and the item list given an
    object containing an item’s name and quantity
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个函数，根据包含项目名称和数量的对象更新应用程序的状态和项目列表
- en: ❷ Invokes the handleAddItemMsg when the server emits an add_item event
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当服务器触发 add_item 事件时调用 handleAddItemMsg
- en: Give these changes a try by rebuilding your `bundle.js` with Browserify through
    `npm run build` and serving it with `npx http-server ./`. Don’t forget that your
    server must be running on the address specified in `API_ADDR`.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `npm run build` 使用 Browserify 重建你的 `bundle.js` 并通过 `npx http-server ./` 提供服务来尝试这些更改。别忘了你的服务器必须运行在
    `API_ADDR` 中指定的地址上。
- en: Testing this functionality can be done at multiple levels of integration. You
    could, for example, check your `handleAddItemMsg` function individually, without
    touching WebSockets at all.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在多个集成级别测试此功能。例如，你可以单独检查你的 `handleAddItemMsg` 函数，而完全不接触 WebSocket。
- en: To test `handleAddItemMsg` in isolation, first export it in `socket.js`.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 要单独测试 `handleAddItemMsg`，首先在 `socket.js` 中导出它。
- en: Listing 6.82 socket.js
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.82 socket.js
- en: '[PRE83]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Then, import it in a new `socket.test.js`, and invoke it directly, passing an
    object containing an `itemName` and `quantity`. Don’t forget that you’ll need
    hooks to make sure that both the document and the inventory states are reset before
    each test.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在新的 `socket.test.js` 中导入它，并直接调用它，传递一个包含 `itemName` 和 `quantity` 的对象。别忘了你需要钩子来确保在每个测试之前重置文档和库存状态。
- en: Listing 6.83 socket.test.js
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.83 socket.test.js
- en: '[PRE84]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: ❶ Directly tests the handleAddItemMsg function by invoking it
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 直接通过调用它测试 handleAddItemMsg 函数
- en: TIP Even though this test can be useful for you to get feedback as you iterate,
    it has a high degree of overlap with a test that sends `add_item` messages through
    WebSockets instead of invoking the `handleAddItemMsg` directly. Therefore, in
    a real-world scenario, consider your time and cost constraints before choosing
    whether you will keep it.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 尽管这个测试在你迭代时获取反馈可能很有用，但它与通过WebSockets发送`add_item`消息而不是直接调用`handleAddItemMsg`的测试有很高的重叠度。因此，在实际场景中，在选择是否保留它之前，请考虑你的时间和成本限制。
- en: As I’ve previously mentioned, accurately replicating run-time scenarios will
    cause your tests to generate more reliable guarantees. In this case, the closest
    you could get to simulating the updates your backend sends is to create a Socket.io
    server and dispatch updates yourself. You can then check whether those updates
    triggered the desired effects in your client.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，准确复制运行时场景会导致你的测试生成更可靠的保证。在这种情况下，你能够最接近模拟后端发送的更新的方法就是创建一个Socket.io服务器并自行派发更新。然后你可以检查这些更新是否在客户端触发了预期的效果。
- en: Because you will need a Socket.io server when running tests, install it as a
    dev dependency with `npm install` `--save-dev` `socket.io`.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在运行测试时你需要一个Socket.io服务器，所以使用`npm install` `--save-dev` `socket.io`将其作为开发依赖项安装。
- en: After installing Socket.io, create a file called `testSocketServer.js`, in which
    you will create your own Socket.io server. This file should export functions to
    start and stop the server and a function that sends messages to clients.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Socket.io后，创建一个名为`testSocketServer.js`的文件，你将在其中创建自己的Socket.io服务器。这个文件应该导出启动和停止服务器以及向客户端发送消息的函数。
- en: Listing 6.84 testSocketServer.js
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.84 testSocketServer.js
- en: '[PRE85]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: ❶ Creates a socket.io server
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个socket.io服务器
- en: ❷ A function that sends a message to the clients connected to the socket.io
    server
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个将消息发送到连接到socket.io服务器的客户端的函数
- en: ❸ Starts the socket.io server on port 3000, and resolves a promise once it’s
    up
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在端口3000上启动socket.io服务器，并在启动后解决一个承诺
- en: ❹ Closes the socket.io server, and resolves a promise once it’s stopped
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 关闭socket.io服务器，并在停止后解决一个承诺
- en: NOTE Ideally, you’d have a separate constant that determines the port to which
    your server should listen. If you want, you can separate `API_ADDR` into `API_HOST`
    and `API_PORT`. Because this book focuses on testing, here I’m hard-coding `3000`.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: NOTE 理想情况下，你应该有一个单独的常量来决定你的服务器应该监听的端口。如果你想，你可以将`API_ADDR`拆分为`API_HOST`和`API_PORT`。因为这本书专注于测试，所以我在这里硬编码为`3000`。
- en: Furthermore, to avoid not being able to run tests because a server is already
    bound to port `3000`, it could be useful to allow users to configure this port
    through an environment variable.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了避免因为服务器已经绑定到端口`3000`而无法运行测试，允许用户通过环境变量配置这个端口可能是有用的。
- en: It’s crucial to return promises that resolve when `start` and `stop` finish
    so that you can wait for them to complete when using them in your hooks. Otherwise,
    your tests can hang due to resources hanging.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当`start`和`stop`完成时解决的承诺非常重要，这样你就可以在钩子中使用它们时等待它们完成。否则，由于资源悬挂，你的测试可能会挂起。
- en: Finally, it’s time to write a test that sends messages through the Socket.io
    server and checks whether your application handles them appropriately.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候编写一个通过Socket.io服务器发送消息并检查你的应用程序是否适当处理它们的测试了。
- en: Start with the hooks that will start the server, connect your client to it,
    and then shut down the server after the tests finish.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 从启动服务器的钩子开始，连接你的客户端到它，然后在测试完成后关闭服务器。
- en: Listing 6.85 testSocketServer.js
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.85 testSocketServer.js
- en: '[PRE86]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: ❶ Before the tests run, starts your Socket.io testing server
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在测试运行之前，启动你的Socket.io测试服务器
- en: ❷ To avoid nock interfering with your connection to the Socket.io server, cleans
    all mocks before trying to connect
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为了避免nock干扰你的Socket.io服务器连接，在尝试连接之前清除所有模拟
- en: ❸ Before all tests, connects to the Socket.io testing server
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在所有测试之前，连接到Socket.io测试服务器
- en: ❹ After tests finish, stops the Socket.io testing server
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在测试完成后，停止Socket.io测试服务器
- en: Finally, write a test that sends an `add_item` message, waits for a second so
    that the client can receive and process it, and checks whether the new application
    state matches what you expect it to be.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，编写一个发送`add_item`消息的测试，等待一秒钟以便客户端可以接收和处理它，并检查新的应用程序状态是否符合你的预期。
- en: Listing 6.86 testSocketServer.js
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.86 testSocketServer.js
- en: '[PRE87]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: ❶ Sends a message through the Socket.io testing server
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过Socket.io测试服务器发送消息
- en: ❷ Waits for the message to be processed
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 等待消息被处理
- en: ❸ Checks whether the page’s state corresponds to the expected state
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查页面状态是否与预期状态相符
- en: Notice how much this test overlaps with the unit test for `handleAddItemMsg`.
    The advantage of having both is that, if there’s a problem with the connection
    setup, the test that uses real sockets will fail, but the unit test won’t. Therefore,
    you can quickly detect whether the problem is with your logic or with your server
    connection. The problem with having both is that they add extra costs to maintaining
    your test suite, especially given that you perform the same assertions in both
    tests.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个测试与`handleAddItemMsg`的单元测试重叠了多少。拥有两者的优点是，如果连接设置有问题，使用真实套接字的测试会失败，但单元测试不会。因此，你可以快速检测问题是否出在你的逻辑或服务器连接上。拥有两者的缺点是，它们会增加维护测试套件的成本，特别是考虑到你在两个测试中都执行了相同的断言。
- en: Now that you’ve checked whether your application can update when it receives
    messages, write a test to check whether the `handleAddItem` function in `inventoryController.js`
    includes the socket client’s ID into the `POST` requests it sends to the server.
    The communication between the different parts of this test are illustrated in
    figure 6.9.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经检查了你的应用程序在接收到消息时是否可以更新，请编写一个测试来检查`inventoryController.js`中的`handleAddItem`函数是否将套接字客户端的ID包含在它发送给服务器的`POST`请求中。本测试的不同部分之间的通信在图6.9中展示。
- en: '![](../Images/CH06_F09_DaCosta.png)'
  id: totrans-678
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F09_DaCosta.png)'
- en: Figure 6.9 How your tests communicate with your Socket.io server, causing it
    to update the document so that they can perform assertions
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 你的测试如何与你的Socket.io服务器通信，导致它更新文档以便它们可以执行断言
- en: For that, you must start your test server, connect to it, and exercise the `handleAddItem`
    function against a nock interceptor, which will match only requests containing
    the adequate `x-socket-client-id` header.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你必须启动你的测试服务器，连接到它，并使用一个nock拦截器来执行`handleAddItem`函数，该拦截器只会匹配包含适当的`x-socket-client-id`头部的请求。
- en: Listing 6.87 inventoryController.test.js
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.87 inventoryController.test.js
- en: '[PRE88]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: ❶ Only responds succesfully to requests to POST /inventory/:itemName that include
    the x-socket-client-id header
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 只对包含x-socket-client-id头部的POST /inventory/:itemName请求成功响应
- en: It’s important to see that, in these examples, we’re not trying to replicate
    our backend’s behavior in our tests. We’re separately checking both the request
    we send and whether we can handle the messages we receive. Checking whether the
    backend sends the right messages to the right clients is a validation that should
    happen within the server’s tests, not the client’s.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我们并不是试图在我们的测试中复制后端的行为。我们分别检查我们发送的请求以及我们是否可以处理接收到的消息。检查后端是否向正确的客户端发送正确的消息是应该在服务器测试中进行的验证，而不是客户端的。
- en: Now that you have learned how to set up a Socket.io server that you can use
    within your tests and how to validate your WebSockets integrations, try extending
    this application with new functionality and testing it. Remember that you write
    these tests at multiple different levels of integration, either by checking your
    handler functions individually or by pushing real messages through a test server.
    Try, for example, pushing live updates when clients click the `undo` button, or
    maybe try adding a test that checks whether `main.js` connects to the server when
    the page loads.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何设置一个可以在测试中使用并验证你的WebSocket集成的Socket.io服务器，尝试通过添加新功能并对其进行测试来扩展这个应用程序。记住，你可以在多个不同的集成级别上编写这些测试，无论是通过单独检查处理函数，还是通过通过测试服务器推送真实消息。例如，尝试在客户端点击`撤销`按钮时推送实时更新，或者尝试添加一个测试来检查当页面加载时`main.js`是否连接到服务器。
- en: By using WebSockets as an example, you must have learned how to mock other kinds
    of interactions that your frontend might have with other applications. If you
    have dependencies for which stubs would cause too much maintenance overhead, it
    may be better to implement your own instance of the dependency—one that you have
    full control over. In this case, for example, manually manipulating multiple different
    spies to access listeners and trigger events would cause too much maintenance
    overhead. Besides making your tests harder to read and maintain, it would also
    make them much more dissimilar to what happens at run time, causing your reliability
    guarantees to be much weaker. The downside of this approach is that your tests’
    scope will increase, making it longer for you to get feedback and making it more
    coarse. Therefore, you must be careful when deciding on the optimal technique
    for *your* situation.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 以 WebSockets 为例，你必须已经学会了如何模拟你的前端可能与其他应用程序交互的其他类型的交互。如果你有依赖项，使用存根会导致过多的维护开销，那么实现自己的依赖项实例可能更好——这样你可以完全控制它。例如，在这种情况下，手动操作多个不同的间谍来访问监听器和触发事件将导致过多的维护开销。除了使测试更难阅读和维护外，这也会使测试与运行时发生的情况差异很大，从而大大削弱你的可靠性保证。这种方法的缺点是，你的测试范围会增加，这会使你获得反馈的时间更长，并且使测试更加粗糙。因此，在决定最适合
    *你* 的情况的最佳技术时必须谨慎。
- en: Summary
  id: totrans-687
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The values and APIs to which JavaScript has access in the browser are different
    from the ones to which it has access in Node.js. Because Jest can run *only* within
    Node.js, you must accurately replicate a browser’s environment when running your
    tests with Jest.
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 在浏览器中可以访问的值和 API 与在 Node.js 中可以访问的值和 API 不同。因为 Jest 只能在 Node.js 中运行，所以使用
    Jest 运行测试时，你必须准确复制浏览器的环境。
- en: To simulate a browser’s environment, Jest uses JSDOM, which is an implementation
    of web standards written purely in JavaScript. JSDOM gives you access to browser
    APIs in other run-time environments, like Node.js.
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了模拟浏览器的环境，Jest 使用 JSDOM，这是一个完全用 JavaScript 编写的 Web 标准实现。JSDOM 允许你在其他运行时环境中访问浏览器
    API，例如 Node.js。
- en: Writing tests in multiple levels of integration requires you to organize your
    code into separate parts. To make it easy to manage different modules in your
    tests, you can still use `require`, but then you must use a bundler like Browserify
    or Webpack to pack your dependencies into a file that can run in a browser.
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个集成级别编写测试需要你将代码组织成独立的部分。为了使测试中管理不同的模块变得容易，你仍然可以使用 `require`，但此时你必须使用打包器如 Browserify
    或 Webpack 将依赖项打包成一个可以在浏览器中运行的文件。
- en: In your tests, thanks to JSDOM, you have access to APIs like `document.querySelector`
    and `document.getElementById`. Once you have exercised the function you want to
    test, use these APIs to find and assert on DOM nodes in the page.
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的测试中，得益于 JSDOM，你可以访问 `document.querySelector` 和 `document.getElementById`
    等API。一旦你测试了想要测试的功能，就可以使用这些API在页面中查找并断言 DOM 节点。
- en: Finding elements by their IDs or by their position in the DOM can cause your
    tests to become fragile and too tightly coupled to your markup. To avoid these
    problems, use a tool like `dom-testing-library` to find elements by their contents
    or other attributes that are an integral part of what an element should be, such
    as its `role` or `label`.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 ID 或 DOM 中的位置查找元素可能会导致你的测试变得脆弱，并且与你的标记紧密耦合。为了避免这些问题，可以使用像 `dom-testing-library`
    这样的工具通过内容或其他属性来查找元素，这些属性是元素应该具有的组成部分，例如其 `role` 或 `label`。
- en: To write more accurate and readable assertions, instead of manually accessing
    properties of DOM elements or writing elaborate code to perform certain checks,
    use a library like `jest-dom` to extend Jest with new assertions specifically
    for the DOM.
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了编写更准确和可读的断言，而不是手动访问 DOM 元素的属性或编写复杂的代码来执行某些检查，可以使用像 `jest-dom` 这样的库来扩展 Jest，并添加专门针对
    DOM 的新断言。
- en: Browsers react to complex user interactions, like typing, clicking, and scrolling.
    To deal with those interactions, browsers depend on events. Because tests are
    more reliable when they accurately simulate what happens at run time, your tests
    should simulate events as precisely as possible.
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器会响应复杂的用户交互，例如输入、点击和滚动。为了处理这些交互，浏览器依赖于事件。由于测试在准确模拟运行时发生的情况时更为可靠，因此你的测试应该尽可能精确地模拟事件。
- en: One way to accurately reproduce events is to use the `fireEvent` function from
    `dom-testing-library` or the utilities provided by `user-event`, another library
    under the `testing-library` organization.
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准确重现事件的一种方法是通过使用来自 `dom-testing-library` 的 `fireEvent` 函数或 `user-event` 库提供的工具，该库是
    `testing-library` 组织下的另一个库。
- en: You can test events and their handlers at different levels of integration. If
    you want more granular feedback as you write code, you can test your handlers
    by directly invoking them. If you would like to trade granular feedback for more
    reliable guarantees, you can dispatch real events instead.
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在不同级别的集成中测试事件及其处理程序。如果你在编写代码时想要更细粒度的反馈，可以直接调用处理程序来测试你的处理程序。如果你愿意以更可靠的保证来交换细粒度的反馈，可以发送真实的事件。
- en: If your application uses Web APIs like the History or Web Storage API, you can
    use their JSDOM implementations in your tests. Remember that you should *not*
    test these APIs themselves; you should test whether your application interacts
    adequately with them.
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的应用程序使用 Web API，如 History 或 Web Storage API，你可以在测试中使用它们的 JSDOM 实现。记住，你**不应该**测试这些
    API 本身；你应该测试你的应用程序是否与它们充分交互。
- en: To avoid making your test setup process more complex, and to get rid of the
    necessity to spin up a backend to run your frontend tests, use `nock` to intercept
    requests. With `nock`, you can determine which routes to intercept and which responses
    these interceptors will produce.
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免使你的测试设置过程更加复杂，并消除启动后端以运行前端测试的必要性，使用 `nock` 来拦截请求。使用 `nock`，你可以确定要拦截哪些路由以及这些拦截器将产生哪些响应。
- en: Similar to all other kinds of tests we’ve seen, WebSockets can be tested in
    varying levels of integration. You can write tests that directly invoke handler
    functions, or you can create a server through which you will dispatch real messages.
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与我们见过的所有其他类型的测试类似，WebSocket 可以在不同程度的集成中进行测试。你可以编写直接调用处理函数的测试，或者你可以创建一个服务器，通过该服务器发送真实消息。
