- en: Part 1\. Getting to know Vue.js
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1部分\. 了解Vue.js
- en: Before we can learn all the cool things Vue has to offer, we need to get to
    know it first. In these first two chapters, we’ll look at the philosophy behind
    Vue.js, the MVVM pattern, and how it relates to other frameworks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习Vue所能提供的所有酷炫功能之前，我们首先需要了解它。在前两章中，我们将探讨Vue.js背后的哲学、MVVM模式以及它与其他框架的关系。
- en: Once we understand where Vue is coming from, we’ll look deeper at the Vue instance.
    The root Vue instance is the heart of the application, and we’ll explore how it’s
    structured. Later, we’ll look at how we can bind data in our application to Vue.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了Vue的来源，我们将更深入地研究Vue实例。根Vue实例是应用程序的核心，我们将探讨其结构。稍后，我们将看看如何将我们的应用程序中的数据绑定到Vue。
- en: These chapters will give you a great start in Vue.js. You’ll learn how to create
    a simple app and how Vue works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些章节将为您在Vue.js中提供一个很好的起点。您将学习如何创建一个简单的应用程序以及Vue是如何工作的。
- en: Chapter 1\. Introducing Vue.js
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章\. 介绍Vue.js
- en: '*This chapter covers*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Exploring the MVC and MVVM design patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索MVC和MVVM设计模式
- en: Defining a reactive application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义响应式应用
- en: Describing the Vue lifecycle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述Vue的生命周期
- en: Evaluating the design of Vue.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估Vue.js的设计
- en: Interactive websites have been around for a long time. During the beginning
    of the Web 2.0 days in the mid-2000s, a much larger focus was put on interactivity
    and engaging users. Companies such as Twitter, Facebook, and YouTube were all
    created during this time. The rise of social media and user-generated content
    was changing the web for the better.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式网站已经存在很长时间了。在2000年代中期的Web 2.0初期，人们更加关注交互性和吸引用户。Twitter、Facebook和YouTube等公司都是在那时创立的。社交媒体和用户生成内容的兴起正在改善网络。
- en: Developers had to keep up with these changes to allow more interactivity for
    the end user and early on, libraries and frameworks started making interactive
    websites easier to build. In 2006, jQuery was released by John Resig, greatly
    simplifying the client-side scripting of HTML. As time progressed, client-side
    frameworks and libraries were created.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者必须跟上这些变化，以便为最终用户提供更多交互性，早期，库和框架开始使构建交互式网站变得更加容易。2006年，John Resig发布了jQuery，极大地简化了HTML的客户端脚本。随着时间的推移，客户端框架和库被创建出来。
- en: At first these frameworks and libraries were big, monolithic, and opinionated.
    Now, we’ve seen a shift to smaller, lighter-weight libraries that can be easily
    added to any project. This is where Vue.js comes in.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，这些框架和库很大、庞大且具有主观性。现在，我们已经看到了向更小、更轻量级的库的转变，这些库可以轻松地添加到任何项目中。这就是Vue.js的用武之地。
- en: Vue.js is a library that enables us to add that interactive behavior and functionality
    to any context where JavaScript can run. Vue can be used on individual webpages
    for simple tasks or it can provide the foundation for an entire enterprise application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js是一个库，使我们能够在JavaScript可以运行的任何上下文中添加交互行为和功能。Vue可以用于单个网页的简单任务，也可以为整个企业级应用程序提供基础。
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The terms Vue and Vue.js are used somewhat interchangeably around the web. Throughout
    the book, I use the more colloquial Vue for the most part, reserving Vue.js for
    when I’m referring specifically to the code or the library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上，Vue和Vue.js这两个术语被交替使用。在整个书中，我大部分时间使用更口语化的Vue，当我具体提到代码或库时，则保留Vue.js。
- en: '|  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: From the interface that visitors interact with to the database that provides
    our application with its data, we’ll explore how Vue and its supporting libraries
    enable us to build complete, sophisticated web applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从访客交互的界面到为我们应用程序提供数据的数据库，我们将探讨Vue及其支持库如何使我们能够构建完整、复杂的Web应用程序。
- en: Along the way, we’ll examine how each chapter’s code fits into the bigger picture,
    what industry best practices are applicable, and how you can incorporate what
    we’re working on into your own projects, both existing and new.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在旅途中，我们将检查每个章节的代码如何融入更大的图景，哪些行业最佳实践是适用的，以及如何将我们正在工作的内容融入您自己的项目，无论是现有的还是新的。
- en: This book is primarily written for web developers who have a moderate degree
    of JavaScript familiarity and a healthy understanding of HTML and CSS. That said,
    owing much to the versatility of its application programming interface (API),
    Vue is a library that grows with you as a developer as it grows with your project.
    Anyone who wants to build a prototype or an app for a personal side project should
    find this book a reliable guide on that journey.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书主要面向对JavaScript有一定熟悉程度且对HTML和CSS有良好理解的Web开发者。话虽如此，由于其应用编程接口（API）的通用性，Vue作为一个库，随着你的开发成长，也随着你的项目成长。任何想要为个人副项目构建原型或应用的人，都应该在这段旅程中找到这本书是一个可靠的指南。
- en: 1.1\. On the shoulders of giants
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1. 巨人的肩膀上
- en: Before we write any code for our first application, or even dig into Vue at
    a high level, it’s important to understand a little bit of software history. It’s
    difficult to truly appreciate what Vue does for us without knowledge of the problems
    and challenges that web applications have faced in the past and what advantages
    Vue brings to the table.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为我们的第一个应用程序编写任何代码之前，甚至在高层深入了解Vue之前，了解一点软件历史是很重要的。如果我们不了解过去Web应用程序面临的问题和挑战，以及Vue带来的优势，就很难真正欣赏Vue为我们所做的一切。
- en: 1.1.1\. The Model–View–Controller pattern
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1. 模型-视图-控制器模式
- en: A testament to its utility, the client-side Model–View–Controller (MVC) pattern
    provides the architectural blueprint used by many modern web application development
    frameworks. (If you’re familiar with MVC, feel free to skip ahead.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 证明其有用性的客户端模型-视图-控制器（MVC）模式提供了许多现代Web应用程序开发框架使用的架构蓝图。（如果你熟悉MVC，可以自由地跳过前面的内容。）
- en: It’s worth mentioning before we continue that the original MVC design pattern
    has changed throughout the years. Sometimes known as Classic MVC, it involved
    a separate set of rules on how the view, controller, and model interacted. For
    the sake of simplicity, we’ll discuss a simplified version of the client-side
    MVC pattern. This pattern is a more modern interpretation for the web.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，值得提一下，原始的MVC设计模式在多年中已经发生了变化。有时被称为经典MVC，它涉及一套关于视图、控制器和模型如何交互的独立规则。为了简化，我们将讨论客户端MVC模式的简化版本。这种模式是对Web的更现代的解释。
- en: As you can see in [figure 1.1](#ch01fig01), the pattern is used to separate
    the application’s concerns. The view is responsible for displaying information
    to the user. This represents the graphical user interface (GUI). The controller
    is in the middle. It helps transform events from the view to the model and data
    from the model to the view. Finally, the model holds business logic and could
    contain a kind of datastore.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[图1.1](#ch01fig01)中看到的，这种模式用于分离应用程序的关注点。视图负责向用户显示信息。这代表了图形用户界面（GUI）。控制器位于中间。它帮助将视图的事件转换为模型，并将模型的数据转换为视图。最后，模型包含业务逻辑，可能包含一种数据存储。
- en: Figure 1.1\. The roles of the model, view, and controller as described by the
    MVC pattern.
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1. MVC模式描述的模型、视图和控制器的作用。
- en: '![](01fig01_alt.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![01fig01_alt.jpg](01fig01_alt.jpg)'
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Info
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Info
- en: If you’re interested in learning more about the MVC pattern, start with Martin
    Fowler’s page on the evolution of MVC at [https://martinfowler.com/eaaDev/uiArchs.html](https://martinfowler.com/eaaDev/uiArchs.html).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于MVC模式的信息，可以从Martin Fowler关于MVC演变的页面开始，请访问[https://martinfowler.com/eaaDev/uiArchs.html](https://martinfowler.com/eaaDev/uiArchs.html)。
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Many web framework authors have used a variation of this MVC pattern because
    of its solid, time-tested architecture. If you want to know more about how modern
    web frameworks are designed and architected, check out *SPA Design and Architecture*
    by Emmitt A. Scott Jr. (Manning, 2015).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Web框架的作者都使用了这种MVC模式的变体，因为它具有坚实、经过时间考验的架构。如果你想了解更多关于现代Web框架的设计和架构，可以查看Emmitt
    A. Scott Jr.的《SPA设计和架构》（Manning，2015）。
- en: In modern software development, the MVC pattern is often used as a part of a
    single application and provides a great mechanism for separating the roles of
    application code. For websites using the MVC pattern, every request initiates
    a flow of information from the client to the server, then the database, and all
    the way back again. That process is time-consuming, resource-intensive, and doesn’t
    provide a responsive user experience.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代软件开发中，MVC模式通常作为单个应用程序的一部分，为分离应用程序代码的角色提供了一个很好的机制。对于使用MVC模式的网站，每个请求都会从客户端到服务器，再到数据库，然后又回到客户端的信息流。这个过程耗时、资源密集，并且不提供响应式的用户体验。
- en: Over the years, developers have increased the interactivity of web-based applications
    by using asynchronous web requests and client-side MVC so that requests sent to
    the server are non-blocking and execution continues without a reply. But as web
    applications begin to function more like their desktop counterparts, waiting for
    any client/server interaction can make an application feel sluggish or broken.
    That’s where our next pattern comes to the rescue.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，开发者通过使用异步Web请求和客户端MVC来提高基于Web应用程序的交互性，这样发送到服务器的请求就不会阻塞，执行可以继续而无需回复。但是，随着Web应用程序开始更像它们的桌面版本，等待任何客户端/服务器交互可能会使应用程序感觉迟钝或损坏。这就是我们下一个模式发挥作用的地方。
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A word about business logic**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于业务逻辑的一席话**'
- en: You’ll find a good degree of flexibility in the client-side MVC pattern when
    considering where business logic should be implemented. In [figure 1.1](#ch01fig01)
    we consolidated the business logic in the model for simplicity’s sake, but it
    may also exist in other tiers of the application, including the controller. The
    MVC pattern has changed since it was introduced by Trygve Reenskaug in 1979 for
    Smalltalk-76.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑业务逻辑应在何处实现时，你会在客户端MVC模式中找到相当程度的灵活性。在[图1.1](#ch01fig01)中，为了简单起见，我们将业务逻辑集中在模型中，但它也可能存在于应用程序的其他层级，包括控制器。自1979年Trygve
    Reenskaug为Smalltalk-76引入MVC模式以来，该模式已经发生了变化。
- en: 'Consider the validation of a ZIP Code provided by a user:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑用户提供的ZIP代码验证：
- en: The view might contain JavaScript that validates a ZIP Code as it’s entered
    or prior to submission.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图可能包含JavaScript，用于在输入ZIP代码时或提交前验证它。
- en: The model might validate the ZIP Code when it creates an address object to hold
    the incoming data.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型可能在创建用于存储传入数据的地址对象时验证ZIP代码。
- en: Database constraints on the ZIP Code field may mean that the model is also enforcing
    business logic, although this could be considered bad practice.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ZIP代码字段上的数据库约束可能意味着模型也在执行业务逻辑，尽管这可以被认为是不良实践。
- en: It can be difficult to define what constitutes actual business logic, and in
    many cases, all the previous constraints may come into play within a single request.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 定义构成实际业务逻辑的内容可能很困难，在许多情况下，所有先前的约束可能都在单个请求中发挥作用。
- en: As we build our application in this book, we’ll examine how and where we’re
    organizing our business logic, as well as how Vue and its supporting libraries
    can help keep functionality from bleeding across boundaries.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中构建我们的应用程序时，我们将探讨我们如何组织和安排业务逻辑，以及Vue及其支持库如何帮助保持功能不会跨越边界。
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 1.1.2\. The Model–View–ViewModel pattern
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2\. 模型-视图-视图模型模式
- en: When JavaScript frameworks began to support asynchronous programming techniques,
    web applications were no longer required to make requests for complete web pages.
    Websites and applications could respond faster with partial updates to the view,
    but doing so required a degree of duplicated effort. Presentation logic often
    mirrored business logic.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript框架开始支持异步编程技术时，Web应用程序不再需要请求完整的Web页面。网站和应用可以通过对视图的局部更新更快地响应，但这样做需要一定程度的重复工作。表示逻辑通常反映了业务逻辑。
- en: A refinement of MVC, the primary difference in the Model–View–ViewModel (MVVM)
    pattern is the introduction of the *view-model*, and its data bindings (collectively,
    the *binder*). MVVM provides a blueprint for us to build client-side applications
    with more responsive user interaction and feedback, while avoiding costly duplication
    of code and effort across the overall architecture. It’s also easier to unit test.
    With that said, MVVM may be overkill for simple UIs, so take that into consideration.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: MVC的改进，模型-视图-视图模型（MVVM）模式的主要区别在于引入了*视图模型*及其数据绑定（统称为*binder*）。MVVM为我们提供了一个蓝图，用于构建具有更多响应性用户交互和反馈的客户端应用程序，同时避免在整体架构中重复代码和努力。它也更容易进行单元测试。话虽如此，对于简单的UI，MVVM可能有些过度，所以请考虑这一点。
- en: 'For web applications, the design of MVVM allows us to write software that responds
    immediately to user interaction and allows users to move freely from one task
    to the next. As you can see from [figure 1.2](#ch01fig02), the view-model also
    wears different hats. This consolidation of responsibility has a single, profound
    implication for our application’s views: when data changes in the view-model,
    any view bound to it is automatically updated. The data binder exposes data and
    helps guarantee that when data changes, it’s reflected in the view.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Web 应用程序，MVVM 的设计允许我们编写能够立即响应用户交互的软件，并允许用户自由地从一项任务切换到另一项任务。正如你从 [图 1.2](#ch01fig02)
    中可以看到，视图模型也扮演着不同的角色。这种责任整合对我们的应用程序视图有一个单一、深刻的含义：当视图模型中的数据发生变化时，任何绑定到它的视图都会自动更新。数据绑定器暴露数据并帮助确保当数据发生变化时，它会在视图中得到反映。
- en: '|  |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Info
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Info
- en: You can find more information on the MVVM pattern on Martin Fowler’s page on
    the Presentation model at [https://martinfowler.com/eaaDev/PresentationModel.html](https://martinfowler.com/eaaDev/PresentationModel.html).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Martin Fowler 的演示模型页面上找到更多关于 MVVM 模式的信息：[https://martinfowler.com/eaaDev/PresentationModel.html](https://martinfowler.com/eaaDev/PresentationModel.html)。
- en: '|  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 1.2\. The components of the Model–View–ViewModel pattern.
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.2\. 模型-视图-视图模型模式的组件。
- en: '![](01fig02_alt.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig02_alt.jpg)'
- en: 1.1.3\. What’s a reactive application?
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3\. 什么是响应式应用程序？
- en: The reactive programming paradigm isn’t necessarily a new idea. Its adoption
    by web applications is relatively new and owes much to the availability of JavaScript
    frameworks such as Vue, React, and Angular.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程范式并不一定是一个新想法。它被 Web 应用程序采用相对较新，这很大程度上归功于 JavaScript 框架如 Vue、React 和 Angular
    的可用性。
- en: 'Many great resources on reactive theory are available on the web, but our needs
    are perhaps a bit more focused. For a web application to be thought of as reactive,
    it should do the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 网上有很多关于响应式理论的优秀资源，但我们的需求可能更加专注。一个 Web 应用程序要想被认为是响应式的，应该做到以下几点：
- en: Observe changes in application state
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察应用程序状态的变化
- en: Propagate change notification throughout the application
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个应用程序中传播更改通知
- en: Render views automatically in response to changes in state
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在状态变化时自动渲染视图
- en: Provide timely feedback for user interactions
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户交互提供及时反馈
- en: Reactive web applications accomplish these goals by employing MVVM design principles
    using asynchronous techniques to avoid blocking continued interaction and using
    functional programming idioms where possible.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式 Web 应用程序通过采用 MVVM 设计原则，使用异步技术避免阻塞持续交互，并在可能的情况下使用函数式编程惯例来实现这些目标。
- en: 'While the MVVM pattern doesn’t imply a reactive application and vice versa,
    they share a common intention: to provide a more responsive, reliable experience
    to the users of an application. Superman and Clark Kent may present themselves
    differently, but they both want to do right by humanity. (No, I won’t say which
    of MVVM and Reactive I think wears the cape and which the glasses.)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 MVVM 模式并不一定意味着响应式应用程序，反之亦然，但它们有一个共同的目标：为应用程序的用户提供更响应、更可靠的体验。超人克拉克·肯特可能以不同的方式呈现自己，但他们都希望为人类做好事。（不，我不会说
    MVVM 和响应式哪一个穿斗篷，哪一个戴眼镜。）
- en: '|  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Info
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Info
- en: If you’d like to learn more about Vue’s reactive programming paradigm, check
    out the *Reactivity in Depth* guide at [https://vuejs.org/v2/guide/reactivity.html](https://vuejs.org/v2/guide/reactivity.html).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于 Vue 的响应式编程范式，请查看 [https://vuejs.org/v2/guide/reactivity.html](https://vuejs.org/v2/guide/reactivity.html)
    上的 *Reactivity in Depth* 指南。
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 1.1.4\. A JavaScript calculator
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.4\. 一个 JavaScript 计算器
- en: To better understand the notions of data binding and reactivity, we’ll start
    by implementing a calculator in plain, vanilla JavaScript, as shown in this listing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解数据绑定和响应性的概念，我们将首先使用纯 JavaScript 实现一个计算器，如下所示。
- en: 'Listing 1.1\. The JavaScript calculator: chapter-01/calculator.html'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.1\. JavaScript 计算器：chapter-01/calculator.html
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Forms input to collect x and y that bind to the runCalc function**'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 表单输入用于收集与 runCalc 函数绑定的 x 和 y**'
- en: '***2* Shows results of x and y**'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 展示了 x 和 y 的结果**'
- en: '***3* Shows constructor to create calc instance**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 展示了创建 calc 实例的构造函数**'
- en: '***4* Shows constructor to create values for a calc instance**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 展示了创建 calc 实例值的构造函数**'
- en: '***5* Initializes calc component**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 初始化 calc 组件**'
- en: '***6* Shows the event handler**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 展示了事件处理器**'
- en: '***7* Sets the event listener on keyup**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 在 keyup 事件上设置事件监听器**'
- en: This is a calculator using ES5 JavaScript (we’ll use the more modern version
    of JavaScript ES6/2015 later in the book). We’re using an immediately invoked
    function expression that kicks off our JavaScript. A constructor is used to hold
    values and the `handleCalcEvent` event handler fires on any `keyup`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 ES5 JavaScript（我们将在本书后面使用更现代的 JavaScript 版本 ES6/2015）的计算器。我们使用立即调用的函数表达式来启动我们的
    JavaScript。构造函数用于存储值，而 `handleCalcEvent` 事件处理程序在任意 `keyup` 事件上触发。
- en: 1.1.5\. A Vue calculator
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.5. Vue 计算器
- en: Don’t worry too much about the syntax of the Vue example because our goal here
    isn’t to understand everything going on in the code, but to compare the two implementations.
    That said, if you have a good sense of how the JavaScript example works (as shown
    in the following listing), much of the Vue code should make sense at least on
    a theoretical level.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于担心 Vue 示例的语法，因为我们的目标不是理解代码中发生的所有事情，而是比较两种实现。话虽如此，如果你对 JavaScript 示例的工作方式有很好的理解（如下列所示），Vue
    代码的大部分内容至少在理论层面上应该是可以理解的。
- en: 'Listing 1.2\. The Vue calculator: chapter-01/calculatorvue.html'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.2. Vue 计算器：chapter-01/calculatorvue.html
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Shows the DOM anchor for our app**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示应用程序的 DOM 锚点**'
- en: '***2* Shows the form inputs for the application**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示应用程序的表单输入**'
- en: '***3* Results will show up in this span.**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 结果将显示在这个 span 中。**'
- en: '***4* Lists the script tag that adds the Vue.js library**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 列出了添加 Vue.js 库的脚本标签**'
- en: '***5* Initializes the application**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 初始化应用程序**'
- en: '***6* Connects to the DOM**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 连接到 DOM**'
- en: '***7* Shows the variables added to the app**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 显示添加到应用程序中的变量**'
- en: '***8* Calculation is done here using a computed property.**'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 使用计算属性在这里进行计算。**'
- en: 1.1.6\. Comparison of JavaScript and Vue
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.6. JavaScript 和 Vue 的比较
- en: The code for both calculator implementations is, for the most part, different.
    Each sample shown in [figure 1.3](#ch01fig03) is available in the repository that
    accompanies this chapter, so you can run each one and compare how they operate.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 两个计算器实现的代码在大多数情况下是不同的。图 1.3 中显示的每个示例都可以在本章附带的存储库中找到，因此你可以运行每个示例并比较它们的操作方式。
- en: Figure 1.3\. Side-by-side comparison of a reactive calculator written using
    vanilla JavaScript (on the left) and Vue (on the right).
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.3. 使用原生 JavaScript（在左侧）和 Vue（在右侧）编写的响应式计算器的并排比较。
- en: '![](01fig03_alt.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig03_alt.jpg)'
- en: The key difference between the two applications is how an update to the final
    calculation is triggered and how the result finds its way back to the page. In
    our Vue example, a single binding `v-model` takes care of all the updates and
    calculations on the page. When we instantiate our application with `new Vue({
    ... })`, Vue examines our JavaScript code and HTML markup, then creates all the
    data and event bindings needed for our application to run.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 两个应用程序之间的关键区别在于最终计算的更新是如何触发的，以及结果如何返回到页面。在我们的 Vue 示例中，单个绑定 `v-model` 负责页面上所有的更新和计算。当我们使用
    `new Vue({ ... })` 实例化应用程序时，Vue 会检查我们的 JavaScript 代码和 HTML 标记，然后创建应用程序运行所需的所有数据和事件绑定。
- en: 1.1.7\. How does Vue facilitate MVVM and reactivity?
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.7. Vue 如何促进 MVVM 和响应式？
- en: Vue is sometimes referred to as a *progressive framework*, which broadly means
    that it can be incorporated into an existing web page for simple tasks or that
    it can be used entirely as the basis for a large-scale web application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 有时被称为 *渐进式框架*，这大致意味着它可以被集成到现有的网页中用于简单任务，或者它可以完全作为大型 Web 应用的基础。
- en: Regardless of how you choose to incorporate Vue into your project, every Vue
    application has at least one *Vue instance*. The most basic application will have
    a single instance that provides bindings between designated markup and data stored
    in a view-model (see [figure 1.4](#ch01fig04)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择如何将 Vue 集成到你的项目中，每个 Vue 应用至少有一个 *Vue 实例*。最基本的应用将有一个实例，它提供指定标记和存储在视图模型中的数据之间的绑定（见
    [图 1.4](#ch01fig04)）。
- en: Figure 1.4\. A typical Vue instance binds HTML markup to data in a view-model
    by creating a data binding between them.
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.4. 典型的 Vue 实例通过在它们之间创建数据绑定，将 HTML 标记绑定到视图模型中的数据。
- en: '![](01fig04_alt.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig04_alt.jpg)'
- en: Being built entirely out of web technologies, a single Vue instance exists entirely
    in the web browser. Crucially, this means that we don’t depend on server-based
    page reloads for updated views, executing business logic, or any other task that
    falls under the domain of the view or view-model. Let’s revisit our form submission
    example with that in mind.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于完全由Web技术构建，单个Vue实例完全存在于Web浏览器中。关键的是，这意味着我们不需要依赖基于服务器的页面重新加载来更新视图、执行业务逻辑或任何属于视图或视图模型范畴的任务。让我们带着这个想法重新审视我们的表单提交示例。
- en: Perhaps the most striking change relative to the client-side MVC architecture
    is that the browser page needs to rarely, if ever, reload during the user’s entire
    session. Because the view, view-model, and data bindings are all implemented in
    HTML and JavaScript, our application can delegate tasks to the model asynchronously,
    leaving users free to continue with other tasks. When new data is returned from
    the model, the bindings established by Vue will trigger whatever updates need
    to happen in the view.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 相对于客户端MVC架构，最引人注目的变化可能是，在整个用户会话期间，浏览器页面很少需要，甚至根本不需要重新加载。因为视图、视图模型和数据绑定都是在HTML和JavaScript中实现的，我们的应用可以将任务异步地委托给模型，让用户可以自由地继续其他任务。当模型返回新数据时，Vue建立的绑定将触发视图需要发生的任何更新。
- en: Arguably, it’s Vue’s primary role to facilitate user interaction by creating
    and maintaining the binding between the views we create and the data in our view-model.
    In this capacity, as we’ll see in our first application, Vue provides a solid
    bedrock for any reactive web application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认，Vue的主要角色是通过创建和维护我们创建的视图与视图模型中的数据之间的绑定来促进用户交互。在这个角色中，正如我们将在第一个应用中看到的那样，Vue为任何响应式Web应用提供了一个坚实的基础。
- en: 1.2\. Why Vue.js?
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2. 为什么选择Vue.js？
- en: When starting a new project, there are many decisions to make. One of the most
    important is the framework or library that should be used. If you’re an agency
    or even a solo developer, picking the correct tool for the job is extremely important.
    Luckily, Vue.js is versatile and can handle many different situations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动一个新项目时，有许多决定需要做出。其中最重要的决定之一是应该使用哪个框架或库。如果你是一家代理机构或甚至是独立开发者，选择适合工作的正确工具至关重要。幸运的是，Vue.js非常灵活，可以处理许多不同的情况。
- en: What follows are several of the most commonly voiced concerns that you might
    have when starting a new project as a solo developer or agency, plus a description
    of how Vue helps to address them, either directly or as part of a larger movement
    toward reactive web applications.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在作为独立开发者或代理机构开始新项目时，你可能会表达的一些最常见的担忧，以及Vue如何直接或作为向响应式Web应用更大运动的一部分来帮助解决这些担忧的描述。
- en: '***Our team isn’t strong at working with web frameworks.*** One of the greatest
    advantages of using Vue for a project is that it doesn’t require any specialist
    knowledge. Every Vue application is built with HTML, CSS, and JavaScript—familiar
    tools that allow you to be productive right from the get-go. Even teams that have
    little experience developing any sort of frontend find a comfortable foothold
    in the MVVM pattern because of their familiarity with MVC in other contexts.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的团队在处理Web框架方面并不强大。** 使用Vue进行项目的最大优点之一是它不需要任何专业知识。每个Vue应用都是用HTML、CSS和JavaScript构建的——这些熟悉工具有助于你从一开始就提高生产力。即使是那些在其他环境中对MVC不太熟悉的团队，也会因为对MVC的熟悉而在MVVM模式中找到一个舒适的立足点。'
- en: '***We’ve got existing work we’d like to continue using.*** Don’t worry, there’s
    no need to scrap your carefully crafted CSS or that cool carousel you built. Whether
    you’re dropping Vue into an existing project with many dependencies, or you’re
    starting a new project and want to leverage other libraries you are already familiar
    with, Vue won’t get in the way. You can continue using tools such as Bootstrap
    or Bulma as a CSS framework, keep jQuery or Backbone components around, or incorporate
    your preferred library for making HTTP requests, handling Promises or other extended
    functionality.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们有一些现有的工作想要继续使用。** 别担心，没有必要丢弃你精心制作的CSS或你构建的那个酷炫的轮播图。无论是将Vue插入到具有许多依赖项的现有项目中，还是你正在启动一个新项目并希望利用你已熟悉的库，Vue都不会妨碍你。你可以继续使用Bootstrap或Bulma等CSS框架，保留jQuery或Backbone组件，或者集成你喜欢的用于发送HTTP请求、处理Promises或其他扩展功能的库。'
- en: '***We need to prototype quickly and gauge users’ reactions.*** As we saw in
    our first Vue application, all we need to do to start building with Vue is include
    Vue.js in any standalone webpage. No complicated build tools required! Getting
    a prototype in front of users can happen within a week or two of starting development,
    allowing you to gather feedback early and iterate often.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***我们需要快速原型设计和评估用户的反应。*** 正如我们在第一个Vue应用程序中看到的，要开始使用Vue构建，我们只需在任何独立网页中包含Vue.js即可。无需复杂的构建工具！将原型展示给用户可以在开发开始后的一个或两个星期内完成，这样您就可以尽早收集反馈并频繁迭代。'
- en: '***Our product is used almost exclusively on mobile devices.*** The minified
    and gzipped Vue.js file weighs in at around 24 KB, which is quite compact for
    a frontend framework. The library is easily delivered over cellular connections.
    New to Vue 2 is server-side rendering (SSR). Such a strategy means that an application’s
    initial load can be minimal, allowing you to pull in new views and resources only
    as required. Combining SSR with efficient caching of components reduces bandwidth
    consumption even further.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***我们的产品几乎仅在移动设备上使用。*** 最小化和压缩后的Vue.js文件大小约为24 KB，对于一个前端框架来说相当紧凑。该库可以通过蜂窝连接轻松传输。Vue
    2的新特性是服务器端渲染（SSR）。这种策略意味着应用程序的初始加载可以最小化，您只需在需要时才拉入新的视图和资源。将SSR与组件的高效缓存相结合，可以进一步减少带宽消耗。'
- en: '***Our product has unique and custom functionality.*** Architected from the
    ground up with modularity and extensibility in mind, Vue applications use reusable
    components. Vue also supports extending components through inheritance, incorporating
    functionality with mix-ins, and extending Vue’s functionality with plugins and
    custom directives.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***我们的产品具有独特和定制的功能。*** 从一开始就考虑到模块化和可扩展性，Vue应用程序使用可重用组件。Vue还支持通过继承扩展组件，通过混入（mix-ins）整合功能，以及通过插件和自定义指令扩展Vue的功能。'
- en: '***We have a large user base and performance is a concern.*** Recently rewritten
    for reliability, performance, and speed, Vue now uses a virtual DOM. What that
    means is that Vue first performs operations on a DOM representation that isn’t
    attached to the browser then “copies” those changes to the view we see. As a result,
    Vue routinely outperforms other frontend libraries. Because generalized tests
    are often too abstract, I always encourage clients to select several of their
    typical use cases and a few extreme ones, develop a testing scenario, and measure
    the results for themselves. You can learn more about the virtual DOM and how it
    compares to its competitors at [https://vuejs.org/v2/guide/comparison.html](https://vuejs.org/v2/guide/comparison.html).'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***我们拥有庞大的用户群，性能是一个关注点。*** 最近为了可靠性、性能和速度进行了重写，Vue现在使用虚拟DOM。这意味着Vue首先在未附加到浏览器的一个DOM表示上进行操作，然后“复制”这些更改到我们看到的视图中。因此，Vue通常优于其他前端库。由于通用测试通常过于抽象，我总是鼓励客户选择几个典型的用例和一些极端用例，开发一个测试场景，并自行测量结果。您可以在[https://vuejs.org/v2/guide/comparison.html](https://vuejs.org/v2/guide/comparison.html)了解更多关于虚拟DOM及其与竞争对手的比较信息。'
- en: '***We have an existing build, test, and/or deployment process.*** In the latter
    chapters of the book we’ll explore these topics in depth, but the takeaway is
    that Vue is easily integrated into many of the most popular build (Webpack, Browserify,
    and others) and test (Karma, Jasmine, and so on) frameworks. In many instances,
    unit tests are directly portable if you’ve already written them for an existing
    framework. And if you’re starting out but want to use these tools, Vue provides
    project templates that integrate these tools for you. In the simplest of terms,
    it’s easy to add and adapt Vue to existing projects.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***我们已经有现成的构建、测试和/或部署流程。*** 在本书的后几章中，我们将深入探讨这些主题，但关键信息是Vue可以轻松集成到许多最受欢迎的构建（Webpack、Browserify等）和测试（Karma、Jasmine等）框架中。在许多情况下，如果您已经为现有框架编写了单元测试，则可以直接移植。如果您是初学者但想使用这些工具，Vue提供了项目模板，这些模板为您集成了这些工具。简单来说，很容易将Vue添加到现有项目中。'
- en: '***What do we do if we need help during or after our engagement?*** Two of
    the immeasurable benefits of Vue are its community and support ecosystem. Vue
    is well-documented, both in online docs and within the code itself, and the core
    team is active and responsive. Perhaps even more crucial, the community of developers
    working with Vue is equally as strong. Resources such as Gitter and the Vue forums
    are full of helpful folks, and there’s a growing list of plugins, integrations,
    and library extensions that bring popular code to the platform nearly every day.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果我们需要在我们的合作期间或之后寻求帮助怎么办？** Vue的两个不可衡量的好处是其社区和支持生态系统。Vue有很好的文档，无论是在在线文档中还是在代码本身中，核心团队也是活跃和响应的。也许更重要的是，与Vue一起工作的开发者社区同样强大。Gitter和Vue论坛等资源充满了乐于助人的人，而且每天都有越来越多的插件、集成和库扩展将流行的代码带到这个平台上。'
- en: After asking many of these questions on my own projects, I now recommend Vue
    on almost all my projects. As you become confident in your mastery of Vue throughout
    this book, my hope is that you’ll feel comfortable advocating for Vue in your
    next project.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的项目中对这些问题进行了许多探讨后，我现在几乎推荐在所有我的项目中使用Vue。随着你在本书中逐渐对Vue的掌握变得自信，我希望你会在你的下一个项目中感到舒适地推荐Vue。
- en: 1.3\. Future thoughts
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3\. 未来思考
- en: We’ve covered much ground in this introductory chapter alone. If you’re new
    to web application development, this may be your first contact with the MVVM architecture
    or reactive programming, but we’ve seen that building a reactive application isn’t
    as intimidating as the jargon can make it feel.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在介绍性章节中，我们就已经覆盖了很多内容。如果你是Web应用开发的初学者，这可能是你第一次接触MVVM架构或响应式编程，但我们已经看到构建一个响应式应用并不像术语可能让人感觉的那样令人生畏。
- en: Perhaps the biggest takeaway from this chapter isn’t about Vue itself, but how
    reactive applications are easier to work with and easier to write with. It’s also
    nice that we have less boilerplate interface code to write. Not having to script
    all our user’s interactions frees us up to focus on how to model our data and
    design our interface. Wiring them up is something Vue makes effortless.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 也许本章最大的收获不是关于Vue本身，而是关于响应式应用更容易处理和编写。而且，我们还有更少的样板接口代码要写。不必编写所有用户的交互脚本让我们能够专注于如何建模我们的数据和设计我们的界面。将它们连接起来是Vue使它变得轻而易举的事情。
- en: 'If you’re like me, then you’re already thinking of the gazillion ways you can
    make our modest application better. This is a good thing, and you should absolutely
    experiment and play with the code. Here are a few things I think about when I
    look at the app:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，那么你已经在想无数种让我们的简单应用变得更好的方法。这是好事，你应该绝对地实验和玩弄代码。以下是我查看应用时考虑的一些事情：
- en: How would we eliminate the need to repeat text strings in so many places?
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何消除在许多地方重复文本字符串的需要？
- en: Can we clear the default input when a user focuses on an input? What about restoring
    it if they leave the field blank?
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户聚焦到输入时，我们能否清除默认输入？如果他们留空字段，我们能否恢复它？
- en: Is there a way to avoid hand-coding each input?
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有没有避免手动编码每个输入的方法？
- en: In [part 2](kindle_split_013.html#part02), we’ll find answers to all these questions
    and many more. Vue was designed to grow with us as developers, as much as with
    our code, so we’ll always make sure to look at different strategies, compare their
    strengths and weaknesses, and learn how to decide which is the best practice for
    a given situation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二部分](kindle_split_013.html#part02)中，我们将找到所有这些问题的答案以及更多。Vue被设计成随着我们作为开发者的成长而成长，就像与我们的代码一样，因此我们总会确保查看不同的策略，比较它们的优缺点，并学习如何决定在特定情况下哪种做法是最好的实践。
- en: All right, let’s see how we can improve on some of what we wrote!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们看看我们如何改进我们写的某些内容！
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: A brief history of how models, views, and controllers work, and how they’re
    tied into Vue.js.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型、视图和控制器的工作简史，以及它们如何与Vue.js结合。
- en: How Vue.js can save you time when creating an application.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue.js如何在创建应用程序时为你节省时间。
- en: Why you should consider Vue.js for your next project.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你应该考虑Vue.js作为你下一个项目的选择。
- en: Chapter 2\. The Vue instance
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章\. Vue实例
- en: '*This chapter covers*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Creating a Vue instance
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Vue实例
- en: Observing the Vue lifecycle
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察Vue的生命周期
- en: Adding data to a Vue instance
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Vue实例添加数据
- en: Binding data to markup
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据绑定到标记
- en: Formatting our output
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化我们的输出
- en: 'Over the course of this book we’re going to build a complete web application:
    a webstore with product listings, a checkout process, an administrative interface,
    and more. The completed webstore may seem like it’s a long way off, especially
    if you’re new to web application development, but Vue allows you to start small,
    build on what you learn, and ship a sophisticated product in one smooth progression.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将构建一个完整的Web应用：一个带有产品列表、结账流程、管理界面等功能的网上商店。完成的网上商店可能看起来还很遥远，尤其是如果你是Web应用开发的新手，但Vue允许你从小处着手，基于所学内容进行构建，并通过一次平滑的进展交付一个复杂的产品。
- en: The key to Vue’s consistency at every stage of an application’s growth is the
    Vue instance. A Vue application is a Vue instance, Vue components are all Vue
    instances, and you can even extend Vue by creating instances with your own custom
    properties.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Vue在应用成长过程中的每个阶段保持一致性的关键是Vue实例。Vue应用是一个Vue实例，Vue组件都是Vue实例，你甚至可以通过创建具有自定义属性的实例来扩展Vue。
- en: It’s impossible to touch on all the facets of the Vue instance in a single chapter,
    so we’ll build on the foundation we establish as our application evolves. As we
    explore new features in chapters to come, we’ll often refer to what we learn about
    the Vue instance and the Vue lifecycle in this chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个章节中不可能触及Vue实例的所有方面，因此我们将随着应用的发展在建立的基础之上进行构建。在我们接下来章节中探索新功能时，我们经常会参考本章中关于Vue实例和Vue生命周期的学习内容。
- en: 2.1\. Our first application
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 我们的第一个应用
- en: To begin our journey, we’re going to create the foundation of our webstore application,
    display its name, and create a single product listing. Our focus is on how we
    create a Vue application and the relationship of the data in our view-model to
    how it’s displayed in the view. [Figure 2.1](#ch02fig01) shows what our application
    should look like by the end of this chapter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的旅程，我们将创建网上商店应用的基础，显示其名称，并创建一个单一的产品列表。我们的重点是创建Vue应用的方式以及我们的视图模型中的数据与它在视图中显示的关系。[图2.1](#ch02fig01)展示了本章结束时我们的应用应该看起来是什么样子。
- en: Figure 2.1\. A preview of our humble webstore’s beginnings.
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1\. 我们谦逊的网上商店开端的预览。
- en: '![](02fig01_alt.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig01_alt.jpg)'
- en: '|  |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: BTW
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: BTW
- en: If you tried the simple calculator sample in [listing 1.2](kindle_split_011.html#ch01ex02),
    technically this will be your second Vue application. You’re a seasoned veteran
    already!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试了[列表1.2](kindle_split_011.html#ch01ex02)中的简单计算器示例，技术上这将是你第二个Vue应用。你已经是一位经验丰富的老兵了！
- en: '|  |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Before we begin, download the vue-devtools plugin for your browser. You can
    find more information on how to download this plugin in [appendix A](kindle_split_025.html#app01).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请下载浏览器上的vue-devtools插件。有关如何下载此插件的更多信息，请参阅[附录A](kindle_split_025.html#app01)。
- en: 2.1.1\. The root Vue instance
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1\. 根Vue实例
- en: At the heart of every Vue application, no matter how big or small, is the *root
    Vue instance,* Vue instance for short. Creating a root Vue instance is done by
    invoking the *Vue constructor*, `new Vue()`. The constructor bootstraps our application
    by compiling an HTML template for our app, initializing any instance data, and
    creating the data and event bindings that make our application interactive.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Vue应用的核心，无论大小，都是*根Vue实例*，简称Vue实例。创建根Vue实例是通过调用*Vue构造函数*，`new Vue()`来完成的。构造函数通过编译我们的应用HTML模板、初始化实例数据以及创建使应用交互的数据和事件绑定来启动我们的应用。
- en: The Vue constructor accepts a single JavaScript object, known as the *options
    object*, `new Vue({ /* options go here */ }).` It’s our job to populate that object
    with everything the Vue constructor needs to bootstrap our application, but to
    start off we’re focusing on a single option, the `el` option.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Vue构造函数接受一个单一的JavaScript对象，称为*选项对象*，`new Vue({ /* options go here */ })`。我们的任务是填充这个对象，使其包含Vue构造函数启动应用所需的一切，但为了开始，我们专注于一个单一选项，即`el`选项。
- en: The `el` option is used by Vue to specify a DOM element (hence `el`) where Vue
    will mount our application. Vue will locate the corresponding DOM element in our
    HTML and use it as the mount point for our application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`el`选项被Vue用来指定一个DOM元素（因此是`el`），Vue将在这个元素上挂载我们的应用。Vue将在我们的HTML中定位相应的DOM元素，并将其用作应用的挂载点。'
- en: This code is the beginning of our webstore application. To make things easier
    to follow, I’ve included each code listing in its own file that you can download
    for this chapter. But to run the application, you’ll need to combine each snippet
    of code from each file into a single index.html file. Yes, the index.html file
    will get rather large as we progress through the book, and that’s normal. In future
    chapters, we’ll discuss ways of splitting our application into separate files.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是我们 webstore 应用程序的开始。为了使内容更容易理解，我将每个代码列表包含在其自己的文件中，您可以为本章下载这些文件。但为了运行应用程序，您需要将每个文件中的代码片段组合成一个单一的
    index.html 文件。是的，随着我们通过本书的进展，index.html 文件会变得相当大，这是正常的。在未来的章节中，我们将讨论将我们的应用程序拆分为单独文件的方法。
- en: If you’d like to see the completed application from this chapter, look for the
    index.html file that’s included with the code in the chapter-02 folder. (If you
    haven’t downloaded the code that accompanies this chapter, learn how and where
    to get it in [appendix A](kindle_split_025.html#app01).) Let’s create our first
    Vue application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看到本章的完整应用程序，请查找 chapter-02 文件夹中包含的 index.html 文件。（如果您还没有下载与本章相关的代码，请参阅 [附录
    A](kindle_split_025.html#app01)，了解如何以及在哪里获取它。）让我们创建我们的第一个 Vue 应用程序。
- en: 'Listing 2.1\. Our first Vue application: chapter-02/first-vue.html'
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1\. 我们的第一个 Vue 应用程序：chapter-02/first-vue.html
- en: '[PRE2]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Lists the CDN version of Vue.js**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 列出了 Vue.js 的 CDN 版本**'
- en: '***2* Our internal app.css stylesheet as well as the Bootstrap stylesheet**'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 我们内部的 app.css 样式表以及 Bootstrap 样式表**'
- en: '***3* The element where Vue will mount our application**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Vue 将挂载我们的应用程序的元素**'
- en: '***4* The Vue constructor**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* Vue 构造函数**'
- en: '***5* Lists a CSS selector used to locate the DOM mounting point**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 列出了用于定位 DOM 挂载点的 CSS 选择器**'
- en: 'The markup contains a single `div` element with a CSS ID selector, #`app`.
    Vue uses that value to locate our `div` and mount the application to it. This
    selector matches the same syntax used by CSS (such as `#id, .class`).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 标记包含一个具有 CSS ID 选择器的单个 `div` 元素，#`app`。Vue 使用该值来定位我们的 `div` 并将应用程序挂载到它上。此选择器与
    CSS 使用的语法相同（例如 `#id, .class`）。
- en: '|  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this book we’ll use Bootstrap 3 for all layout and design. This works
    great and helps keep the focus on Vue.js. As of the time of writing, Bootstrap
    4 was recently released, but because the focus of this book isn’t on design, I
    decided to leave Bootstrap 3 in. These examples will work on Bootstrap 4; but
    you may need to swap out several of the classes to the newer Bootstrap 4 classes
    if you do switch over. Keep that in mind.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将使用 Bootstrap 3 进行所有布局和设计。这效果很好，有助于将重点放在 Vue.js 上。截至本书写作时，Bootstrap
    4 已经发布，但由于本书的重点不在于设计，我决定保留 Bootstrap 3。这些示例将在 Bootstrap 4 上工作；但如果您切换到 Bootstrap
    4，您可能需要将几个类替换为较新的 Bootstrap 4 类。请记住这一点。
- en: '|  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'If the CSS selector we provide resolves to more than one DOM element, Vue will
    mount the application to the first element that matches the selector. If we had
    an HTML document with three `div` elements, and we invoked the Vue constructor
    as `new Vue({ el: ''div'' })`, Vue would mount the application at the first `div`
    element of the three.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们提供的 CSS 选择器解析出多个 DOM 元素，Vue 将将应用程序挂载到匹配选择器的第一个元素上。如果我们有一个包含三个 `div` 元素的
    HTML 文档，并且我们以 `new Vue({ el: ''div'' })` 的方式调用 Vue 构造函数，Vue 将将应用程序挂载到三个 `div`
    元素的第一个上。'
- en: If you need to run multiple Vue instances on a single page, you could mount
    them to different DOM elements by using unique selectors. This may seem like an
    odd practice, but if you use Vue to build small components, such as an image carousel
    or a webform, it’s easy to see how you could have several root Vue instances all
    running on a single page.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在单个页面上运行多个 Vue 实例，您可以通过使用唯一的选择器将它们挂载到不同的 DOM 元素上。这可能看起来有些奇怪，但如果您使用 Vue
    来构建小型组件，例如图片轮播或网页表单，您就可以很容易地看到如何在单个页面上运行多个根 Vue 实例。
- en: 2.1.2\. Making sure our application is running
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2\. 确保我们的应用程序正在运行
- en: Let’s head over to Chrome and open the file you created for your first Vue application
    from [listing 2.1](#ch02ex01), though it won’t yet render anything you can see
    in the main browser window. (After all, there’s no visible HTML!)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到 Chrome 并打开您为第一个 Vue 应用程序创建的文件，从 [列表 2.1](#ch02ex01) 开始，尽管它还不会在主浏览器窗口中显示任何内容。（毕竟，没有可见的
    HTML！）
- en: Once the page loads, open the JavaScript console if it isn’t already open, and
    hopefully you’ll see . . . <drum roll> . . . absolutely nothing (or perhaps a
    note about downloading vue-devtools if you haven’t already done so, or a note
    that you’re running Vue in development mode). [Figure 2.2](#ch02fig02) shows what
    your console might look like.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载后，如果还没有打开，请打开 JavaScript 控制台，希望你会看到 . . . <鼓声> . . . 完全没有（或者如果你还没有这样做，可能会看到关于下载
    vue-devtools 的提示，或者说明你正在以开发模式运行 Vue）。[图 2.2](#ch02fig02) 展示了你的控制台可能的样子。
- en: Figure 2.2\. The JavaScript console with no errors or warnings.
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.2\. 没有错误或警告的 JavaScript 控制台。
- en: '![](02fig02_alt.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig02_alt.jpg)'
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Vue debugging 101**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vue 调试 101**'
- en: 'Even as simple as our application is so far, we can still run into trouble
    when we load our file in Chrome. Here are two common issues to look out for when
    things don’t go as planned:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的应用程序目前如此简单，我们在 Chrome 中加载文件时仍然会遇到麻烦。当事情没有按计划进行时，以下是一些需要留意的问题：
- en: '`Uncaught SyntaxError: Unexpected identifier` almost always indicates a typo
    in the JavaScript code and can usually be traced to a missing comma or curly brace.
    You can click the filename and line number displayed on the right of the error
    to jump to the corresponding code. Keep in mind that you may have to hunt a few
    lines up or down to find the offending typo.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Uncaught SyntaxError: Unexpected identifier` 通常表示 JavaScript 代码中存在拼写错误，通常可以追溯到缺少逗号或花括号。你可以点击错误右侧显示的文件名和行号来跳转到相应的代码。请注意，你可能需要向上或向下查找几行才能找到有问题的拼写错误。'
- en: '`[Vue warn]: Property or method "propertyname" is not defined . . .` lets you
    know something wasn’t defined in the options object when the instance was created.
    Check to see whether the property or method exists in your options object, and
    if it does, check for typos in its name. Also check to be sure the name is spelled
    correctly in the binding in your markup.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Vue warn]: Property or method "propertyname" is not defined . . .` 告诉你，在实例创建时选项对象中未定义某个属性或方法。检查你的选项对象中是否存在该属性或方法，如果存在，检查其名称是否有拼写错误。还要确保在标记中的名称拼写正确。'
- en: Tracking down errors the first few times can be frustrating, but after you’ve
    resolved a few errors the process will become more natural.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几次追踪错误时可能会感到沮丧，但一旦解决了一些错误，这个过程就会变得更加自然。
- en: If you run into something you can’t figure out, or you find a particularly nasty
    error, you can check out the Help section of the Vue forum at [https://forum.vuejs.org/c/help](https://forum.vuejs.org/c/help)
    or ask for help in the Vue Gitter chat at [https://gitter.im/vuejs/vue](https://gitter.im/vuejs/vue).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到无法解决的问题，或者发现一个特别棘手的错误，你可以在 Vue 论坛的帮助部分查看 [https://forum.vuejs.org/c/help](https://forum.vuejs.org/c/help)，或者在
    Vue Gitter 聊天中寻求帮助 [https://gitter.im/vuejs/vue](https://gitter.im/vuejs/vue)。
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: After Vue finishes initializing and mounting the application, it returns a reference
    to the root Vue instance, which we stored in the `webstore` variable. We can use
    that variable to inspect our application in the JavaScript console. Let’s use
    it now to make sure that our application is alive and well before continuing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue 完成初始化和挂载应用程序后，它返回对根 Vue 实例的引用，我们将它存储在 `webstore` 变量中。我们可以使用这个变量在 JavaScript
    控制台中检查我们的应用程序。现在让我们使用它来确保在继续之前我们的应用程序处于活跃和良好的状态。
- en: With the console open, enter `webstore` at the prompt. The result is a Vue object
    that we can inspect further in the console. For now, click the disclosure triangles
    (![](triangle.jpg)) to expand the object and look at the properties of our root
    Vue instance as seen in [figure 2.3](#ch02fig03).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台打开的情况下，在提示符中输入 `webstore`。结果是我们可以进一步在控制台中检查的 Vue 对象。现在，点击展开三角形 (![](triangle.jpg))
    来展开对象，查看根 Vue 实例的属性，如 [图 2.3](#ch02fig03) 所示。
- en: Figure 2.3\. Using the webstore variable to display a representation of the
    Vue instance and explore its properties.
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.3\. 使用 `webstore` 变量显示 Vue 实例的表示并探索其属性。
- en: '![](02fig03_alt.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig03_alt.jpg)'
- en: You may have to scroll around a bit, but you should be able to locate the `el`
    property we specified as part of our application’s options object. In future chapters,
    we’ll use the console to access our instance for debugging, manipulating data,
    and triggering behaviors in our application while it’s running, so we can validate
    that it behaves as expected. We can also use vue-devtools to peek inside our application
    while it’s running. (Again, if you don’t yet have vue-devtools installed, visit
    [appendix A](kindle_split_025.html#app01) to learn how to install it.) Let’s see
    how it compares with using the JavaScript console. [Figure 2.4](#ch02fig04) shows
    the different parts of the vue-devtools.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要滚动一下，但你应该能够找到我们作为应用程序选项对象的一部分指定的`el`属性。在未来的章节中，我们将使用控制台来访问我们的实例进行调试、操作数据以及在应用程序运行时触发行为，以便我们可以验证其是否按预期工作。我们还可以使用vue-devtools在应用程序运行时查看其内部情况。（再次提醒，如果你还没有安装vue-devtools，请访问[附录A](kindle_split_025.html#app01)了解如何安装它。）让我们看看它与使用JavaScript控制台相比如何。[图2.4](#ch02fig04)显示了vue-devtools的不同部分。
- en: Figure 2.4\. The vue-devtools window with nothing selected.
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4. 没有选择任何内容的vue-devtools窗口。
- en: '![](02fig04_alt.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5](02fig04_alt.jpg)'
- en: The vue-devtools extension provides big functionality for inspecting a Vue application,
    its data, and the relationship of its components. As an application grows in complexity,
    the searchable tree view in vue-devtools shows the relationship of components
    in a way the JavaScript console cannot. We’ll discuss more about Vue components
    and how they relate to the Vue instance in a later chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: vue-devtools扩展为检查Vue应用程序、其数据和组件之间的关系提供了强大的功能。随着应用程序复杂性的增加，vue-devtools中的可搜索树视图以JavaScript控制台无法实现的方式显示组件之间的关系。我们将在后面的章节中更详细地讨论Vue组件以及它们如何与Vue实例相关联。
- en: We’ll frequently use both tools to zero in on problems with our application
    as we build it. In fact, we can use vue-devtools to discover another way to access
    our application instance in the JavaScript console as seen in [figure 2.5](#ch02fig05).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的应用程序时，我们将频繁使用这两个工具来聚焦于应用程序中的问题。实际上，我们可以使用vue-devtools在JavaScript控制台中找到另一种访问应用程序实例的方法，如图2.5[图2.5](#ch02fig05)所示。
- en: Figure 2.5\. The root instance selected in vue-devtools with a variable dynamically
    assigned to the instance.
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.5. 在vue-devtools中选定的根实例，实例被动态分配了一个变量。
- en: '![](02fig05_alt.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5](02fig05_alt.jpg)'
- en: When you select an instance in the tree view, as in [figure 2.5](#ch02fig05),
    vue-devtools assigns a reference to the instance to the `$vm0` variable. We can
    use `$vm0` the same way we used our `webstore` variable. Try using `$vm0` in the
    JavaScript console to see if you can inspect the root Vue instance
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在树视图中选择一个实例，如图2.5[图2.5](#ch02fig05)所示，vue-devtools会将实例的引用分配给`$vm0`变量。我们可以像使用我们的`webstore`变量一样使用`$vm0`。尝试在JavaScript控制台中使用`$vm0`来查看你是否可以检查根Vue实例
- en: '|  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Why do we need more than one reference?**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么我们需要多个引用？**'
- en: Having multiple ways to access the same instance may appear redundant, but it’s
    helpful to have both.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有多个访问同一实例的方法可能看起来是多余的，但拥有这两种方法是有帮助的。
- en: When we assigned our root Vue instance to the global variable `webstore`, we
    gave ourselves a way to refer to the application in other JavaScript code on the
    page. Doing so allows us to integrate with other libraries, frameworks, or our
    own code that may require a reference back to our application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将根Vue实例分配给全局变量`webstore`时，我们为自己提供了一种在其他页面上的JavaScript代码中引用应用程序的方法。这样做允许我们与其他库、框架或我们的代码集成，这些代码可能需要回指我们的应用程序。
- en: The Vue instance assigned to the `$vm0` variable reflects the current selection
    made in vue-devtools. When an application is made up of hundreds, or even thousands
    of instances, it isn’t practical to declaratively assign each instance, so having
    a way to access specific instances that are created programmatically becomes indispensable
    when inspecting and debugging such a complex application.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给`$vm0`变量的Vue实例反映了在vue-devtools中做出的当前选择。当一个应用程序由数百个，甚至数千个实例组成时，声明性地为每个实例分配是不切实际的，因此，在检查和调试如此复杂的应用程序时，能够以编程方式访问特定实例的方法变得必不可少。
- en: '|  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.1.3\. Displaying something inside our view
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.3. 在视图中显示内容
- en: Until now, our application has been a real snoozefest. Let’s liven it up by
    displaying data from our application instance in our application’s template. Remember,
    our Vue instance uses the DOM element we provide as the basis for its template.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序一直是个沉闷的体验。让我们通过在应用程序的模板中显示应用程序实例的数据来让它变得生动起来。记住，我们的Vue实例使用我们提供的DOM元素作为其模板的基础。
- en: We’re going to start by adding the name of our webstore. This will show us how
    to pass data into the Vue constructor, and how to bind that data to a view. In
    this listing let’s update the application code from [listing 2.1](#ch02ex01).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加我们网店的名字。这将展示如何将数据传递给 Vue 构造函数，以及如何将数据绑定到视图上。在这个列表中，让我们更新应用程序代码，从 [列表
    2.1](#ch02ex01) 开始。
- en: 'Listing 2.2\. Adding data and a data binding: chapter-02/data-binding.html'
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. 添加数据和数据绑定：chapter-02/data-binding.html
- en: '[PRE3]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* A header element is added to the div.**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在 div 中添加一个页眉元素。**'
- en: '***2* Shows data binding for the sitename property**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示 sitename 属性的数据绑定**'
- en: '***3* Adds a data object to the Vue options**'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 向 Vue 选项中添加数据对象**'
- en: '***4* Shows the sitename property we bind to in the header**'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 显示我们在页眉中绑定的 sitename 属性**'
- en: We’ve added a data object to the options we pass into our Vue constructor. That
    data object contains a single property, `sitename`, which contains the name of
    our webstore.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向传递给 Vue 构造函数的选项中添加了一个数据对象。该数据对象包含一个名为 `sitename` 的单个属性，其中包含我们网店的名字。
- en: Our site’s name needs a home, so we’ve also added a header element to the markup
    inside of the application’s root `div` element. On the heading element `<h1>`,
    we use a data binding element directive, `v-text="sitename"`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们网站的名字需要一个家，所以我们还在应用程序根 `div` 元素内部的标记中添加了一个页眉元素。在标题元素 `<h1>` 上，我们使用数据绑定指令 `v-text="sitename"`。
- en: A `v-text` directive prints a string representation of the property it references.
    In this case, once our application is up and running we should see a header with
    the text “Vue.js Pet Depot” displayed inside it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-text` 指令打印它引用的属性的字符串表示形式。在这种情况下，一旦我们的应用程序启动并运行，我们应该看到一个包含文本“Vue.js Pet Depot”的页眉。 '
- en: If you need to display a property value in the middle of a larger string, you
    can use Mustache syntax—`{{ property-name }}`—to bind to a property. To include
    the name of our webstore in a sentence, you might write `<p>Welcome to {{ sitename
    }}</p>`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在较长的字符串中显示属性值，您可以使用 Mustache 语法—`{{ property-name }}`—来绑定属性。为了在句子中包含我们网店的名字，您可能写成
    `<p>欢迎来到 {{ sitename }}</p>`。
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Vue only borrows the {{ `...` }} syntax from Mustache for text interpolations,
    not from the entire Mustache specification. But if you’re curious where it comes
    from, visit the online manual at [https://mustache.github.io/mustache.5.html](https://mustache.github.io/mustache.5.html).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 只从 Mustache 中借用 {{ `...` }} 语法进行文本插值，而不是整个 Mustache 规范。但如果你好奇它从哪里来，可以访问在线手册
    [https://mustache.github.io/mustache.5.html](https://mustache.github.io/mustache.5.html)。
- en: '|  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: With our data binding in place, let’s go see how our new header looks in the
    browser.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置好数据绑定后，让我们看看我们的新页眉在浏览器中的样子。
- en: 2.1.4\. Inspecting properties in Vue
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.4\. 在 Vue 中检查属性
- en: When you reload the application in Chrome, you should see the header proudly
    displaying the value of our `sitename` property as seen in [figure 2.6](#ch02fig06).
    The visual appearance of our header is provided by the stylesheet in chapter-02/assets/css/app.css.
    We’ll use our stylesheet and Bootstrap to design our application. If you’d like
    to tinker with the appearance of the header, open that file and find the styles
    defined by `header h1.`
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Chrome 中重新加载应用程序时，你应该看到页眉自豪地显示了我们的 `sitename` 属性的值，如 [图 2.6](#ch02fig06)
    所示。页眉的视觉外观由第 2 章的 `assets/css/app.css` 中的样式表提供。我们将使用我们的样式表和 Bootstrap 来设计我们的应用程序。如果您想调整页眉的外观，请打开该文件并找到由
    `header h1` 定义的样式。
- en: Figure 2.6\. Our `sitename` property displayed in the header of our webstore.
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.6\. 我们 `sitename` 属性在网店页眉中的显示。
- en: '![](02fig06_alt.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig06_alt.jpg)'
- en: Vue automatically creates getter and setter functions for each property of the
    data object when it initializes our application. That gives us the ability to
    retrieve the current value of, or set a new value for, any of our instance’s properties
    without writing any additional code. To see these functions in action, let’s start
    by using the getter to print the value of the `sitename` property.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Vue 初始化我们的应用程序时，它会自动为数据对象的每个属性创建 getter 和 setter 函数。这使我们能够检索实例属性的当前值或设置新值，而无需编写任何额外的代码。为了看到这些函数的实际效果，让我们首先使用
    getter 打印 `sitename` 属性的值。
- en: As you can see in [figure 2.7](#ch02fig07), the getter and setter functions
    for our `sitename` property are exposed at the root level of our application instance.
    That lets us access the property from the JavaScript console, or from any other
    JavaScript that interacts with our application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图2.7](#ch02fig07)中看到的，我们的`sitename`属性的getter和setter函数在应用实例的根级别暴露。这让我们可以从JavaScript控制台或从任何与我们的应用交互的其他JavaScript中访问该属性。
- en: Figure 2.7\. Using the console and vue-devtools, we can check on our `sitename`
    property.
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.7\. 使用控制台和vue-devtools检查我们的`sitename`属性。
- en: '![](02fig07_alt.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig07_alt.jpg)'
- en: You can also see the property listed in vue-devtools when we select the `<root>`
    instance. Now let’s see what happens in [figure 2.8](#ch02fig08) when we use the
    setter to set the value of `sitename` in the JavaScript console.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择`<root>`实例时，你还可以在vue-devtools中看到该属性。现在让我们看看当我们使用setter在JavaScript控制台中设置`sitename`的值时[图2.8](#ch02fig08)会发生什么。
- en: Figure 2.8\. Using Vue’s property getter and setter to print and update the
    `sitename` property, respectively.
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.8\. 使用Vue的属性getter和setter分别打印和更新`sitename`属性。
- en: '![](02fig08_alt.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig08_alt.jpg)'
- en: Once we provide a new value for `sitename` and hit Enter, the output in our
    header element is automatically updated. This is Vue’s event loop in action. Let’s
    look at the Vue lifecycle to see how and when changes to our data trigger updates
    to the view.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为`sitename`提供新的值并按Enter键，我们头部元素中的输出会自动更新。这是Vue的事件循环在起作用。让我们看看Vue生命周期，看看我们的数据更改是如何以及何时触发视图更新的。
- en: 2.2\. The Vue lifecycle
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. Vue生命周期
- en: When a Vue application is first instantiated, it begins its journey through
    a sequence of events known collectively as the Vue lifecycle. Although a long-running
    Vue application will likely spend most of its time cycling within the event loop,
    much of the heavy lifting of the library itself occurs when an application is
    first created. Let’s take a high-level look at the lifecycle in [figure 2.9](#ch02fig09).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当Vue应用首次实例化时，它开始通过一系列称为Vue生命周期的共同事件序列。尽管长时间运行的Vue应用可能会在事件循环中花费大部分时间，但库本身的繁重工作大部分发生在应用首次创建时。让我们从[图2.9](#ch02fig09)中高屋建瓴地看看生命周期。
- en: Figure 2.9\. Diagram of the Vue lifecycle, divided into four phases.
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.9\. Vue生命周期的图示，分为四个阶段。
- en: '![](02fig09_alt.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig09_alt.jpg)'
- en: Each phase builds upon the previous phase to create the Vue lifecycle. You may
    wonder what the virtual DOM is and how the render function works. The *virtual
    DOM* is a lightweight abstraction that represents the DOM. It mimics the DOM tree
    that’s normally accessed by the browser. Vue can make updates to the virtual DOM
    much quicker than the browser-specific DOM. The render function is the way Vue
    can display information to the user. For more information on the Vue instance
    and lifecycle hooks, please check out the official guides at [https://vuejs.org/v2/guide/instance.html](https://vuejs.org/v2/guide/instance.html).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段都建立在之前阶段的基础上，以创建Vue生命周期。你可能想知道虚拟DOM是什么以及渲染函数是如何工作的。*虚拟DOM*是一个轻量级的抽象，代表DOM。它模仿了浏览器通常访问的DOM树。Vue可以比浏览器特定的DOM更快地对虚拟DOM进行更新。渲染函数是Vue向用户显示信息的方式。有关Vue实例和生命周期钩子的更多信息，请参阅官方指南[https://vuejs.org/v2/guide/instance.html](https://vuejs.org/v2/guide/instance.html)。
- en: 2.2.1\. Adding lifecycle hooks
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1\. 添加生命周期钩子
- en: To see when our application instance passes through the different phases of
    the lifecycle, we can write callback functions for Vue’s lifecycle hooks. Let’s
    update the code in our main application file (index.html) in [listing 2.3](#ch02ex03).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到我们的应用实例通过生命周期的不同阶段，我们可以为Vue的生命周期钩子编写回调函数。让我们更新我们的主应用文件（index.html）中的代码[列表2.3](#ch02ex03)。
- en: '|  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Info
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 信息
- en: A *hook* is a function that gets “hooked” onto a part of the Vue library’s code.
    Whenever Vue reaches that part of the code during execution, it calls the function
    you define or continues along if there’s nothing to do.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*钩子*是一个被“钩”到Vue库代码的一部分的函数。每当Vue在执行过程中到达该代码部分时，它会调用你定义的函数，如果没有事情要做，则继续执行。'
- en: '|  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Listing 2.3\. Adding lifecycle hooks to our instance: chapter-02/life-cycle-hooks.js'
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.3\. 向我们的实例添加生命周期钩子：chapter-02/life-cycle-hooks.js
- en: '[PRE4]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Shows a variable used to enable or disable our callbacks**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示一个用于启用或禁用我们的回调的变量**'
- en: '***2* Logs the beforeCreate event**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 记录beforeCreate事件**'
- en: '***3* Logs the created event**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 记录created事件**'
- en: '***4* Logs the beforeMount event**'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 记录beforeMount事件**'
- en: '***5* Logs the mounted event**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 记录mounted事件**'
- en: '***6* Logs the beforeUpdate event**'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 记录beforeUpdate事件**'
- en: '***7* Logs the updated event**'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 记录更新事件**'
- en: '***8* Logs the beforeDestroy event**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 记录销毁前事件**'
- en: '***9* Logs the destroyed event**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 记录销毁事件**'
- en: The first thing you’ll notice in [listing 2.3](#ch02ex03) is that we’ve defined
    a variable, `APP_LOG_LIFECYCLE_EVENTS`, that we can use to enable or disable logging
    of lifecycle events. We define our variable outside the Vue instance, so it can
    be used globally by the root instance or any child components we write later.
    Also, if we defined it inside our application instance, it wouldn’t be available
    in the `beforeCreate` callback because it hasn’t yet been created!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 2.3](#ch02ex03)中，你首先会注意到我们定义了一个变量，`APP_LOG_LIFECYCLE_EVENTS`，我们可以使用它来启用或禁用生命周期事件的记录。我们在
    Vue 实例外部定义我们的变量，这样它就可以被根实例或我们稍后编写的任何子组件全局使用。此外，如果我们将其定义在我们的应用程序实例内部，它将不可用于 `beforeCreate`
    回调，因为它尚未创建！
- en: '|  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`APP_LOG_LIFECYCLE_EVENTS` uses the uppercase syntax typically reserved for
    constant definition because, when we start using ECMAScript 6 later in the book,
    we’ll use the `const` feature to create constants. Planning ahead means we won’t
    have to do any find-and-replace to change the name in the rest of our code.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`APP_LOG_LIFECYCLE_EVENTS` 使用通常为常量定义保留的大写语法，因为，当我们稍后在书中开始使用 ECMAScript 6 时，我们将使用
    `const` 特性来创建常量。提前规划意味着我们不需要在代码的其他部分进行查找和替换来更改名称。'
- en: '|  |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The remainder of the code defines functions that log each lifecycle event as
    it’s encountered. Let’s revisit our console exploration of the `sitename` property
    to see what happens in the Vue lifecycle.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分定义了在遇到每个生命周期事件时记录这些事件的函数。让我们回顾一下我们对 `sitename` 属性的 console 探索，看看 Vue
    生命周期中会发生什么。
- en: 2.2.2\. Exploring the lifecycle code
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2\. 探索生命周期代码
- en: If you open the console in Chrome and reload the app, you should immediately
    see the output from several of our callbacks as seen in [figure 2.10](#ch02fig10).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开 Chrome 的控制台并重新加载应用，你应该会立即看到我们的一些回调函数的输出，就像在[图 2.10](#ch02fig10) 中看到的那样。
- en: Figure 2.10\. Output from some of our lifecycle functions can be seen in the
    console.
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.10\. 我们的一些生命周期函数的输出可以在控制台中看到。
- en: '![](02fig10_alt.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![02fig10_alt.jpg](02fig10_alt.jpg)'
- en: As you might expect, the first four lifecycle hooks get triggered as Vue creates
    and mounts our application. To test the other hooks, we’ll need to interact with
    the console a bit. First, let’s trigger the update callbacks by setting a new
    name for our site. [Figure 2.11](#ch02fig11) displays how this can be done.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，前四个生命周期钩子在 Vue 创建和挂载我们的应用程序时被触发。为了测试其他钩子，我们需要与控制台进行一些交互。首先，让我们通过为我们的站点设置一个新的名称来触发更新回调。[图
    2.11](#ch02fig11) 展示了如何做到这一点。
- en: Figure 2.11\. Setting the `sitename` property triggers the update lifecycle
    callbacks.
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.11\. 设置 `sitename` 属性会触发更新生命周期回调。
- en: '![](02fig11.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![02fig11.jpg](02fig11.jpg)'
- en: When you change the `sitename` property, the update cycle kicks off as the data
    binding in the application’s header is updated with the new value. Now let’s destroy
    our application! (Don’t worry, it’ll come right back with a reload.) To trigger
    the last two lifecycle hooks, we use our instance’s `$destroy` method.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更改 `sitename` 属性时，更新周期就会启动，因为应用程序标题中的数据绑定会更新为新值。现在让我们销毁我们的应用程序！（别担心，它会通过重新加载立即回来。）为了触发最后的两个生命周期钩子，我们使用实例的
    `$destroy` 方法。
- en: '|  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Special methods that Vue creates on our instance are available using the `$`
    prefix. For more information on Vue’s lifecycle instance methods, you can visit
    the API documentation at [https://vuejs.org/v2/api/#Instance-Methods-Lifecycle](https://vuejs.org/v2/api/#Instance-Methods-Lifecycle).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 在我们的实例上创建的特殊方法可以通过 `$` 前缀使用。有关 Vue 的生命周期实例方法的更多信息，您可以访问 API 文档[https://vuejs.org/v2/api/#Instance-Methods-Lifecycle](https://vuejs.org/v2/api/#Instance-Methods-Lifecycle)。
- en: '|  |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: These last two hooks are typically used for cleanup activities in an application
    or component. If our application created an instance of a third-party library,
    we should call that library’s teardown code, or de-allocate any references to
    it manually, so that we avoid leaking memory allocated to our application. [Figure
    2.12](#ch02fig12) shows how calling the `$destroy()` instance method will trigger
    the destroy hooks.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后两个钩子通常用于应用程序或组件中的清理活动。如果我们的应用程序创建了一个第三方库的实例，我们应该调用该库的拆解代码，或者手动取消对该实例的任何引用，以避免泄漏分配给我们的应用程序的内存。[图
    2.12](#ch02fig12) 展示了调用 `$destroy()` 实例方法将如何触发销毁钩子。
- en: Figure 2.12\. Calling the destroy instance method triggers the final pair of
    lifecycle callbacks.
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.12\. 调用销毁实例方法将触发最后的生命周期回调对。
- en: '![](02fig12.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![02fig12.jpg](02fig12.jpg)'
- en: 2.2.3\. Keeping the lifecycle code, or not
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3\. 保留生命周期代码，还是不保留
- en: The lifecycle hooks provide a great way to see what’s going on as an application
    runs, but I’m the first to admit that there’s repetitive, verbose code required
    to log messages to the console. Because they’re fairly bulky, I won’t include
    these debugging functions in code listings from here on, but we’ll occasionally
    use lifecycle hooks to explore new behavior or for functional reasons in the application
    itself.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期钩子提供了查看应用程序运行时发生情况的好方法，但我要首先承认，需要记录消息到控制台需要重复且冗长的代码。因为它们相当庞大，所以从现在起，我不会在代码列表中包含这些调试函数，但我们会偶尔使用生命周期钩子来探索新的行为或出于应用程序本身的功能原因。
- en: If you do keep these hooks around, and the console gets too noisy with output,
    you can disable the logging by setting `APP_LOG_LIFECYCLE_EVENTS` to `false`.
    Bear in mind that you can disable them completely by changing the value in the
    index.html, or you can temporarily toggle logging on and off by setting the value
    at runtime using the JavaScript console.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保留这些钩子，并且控制台输出变得过于嘈杂，你可以通过将 `APP_LOG_LIFECYCLE_EVENTS` 设置为 `false` 来禁用日志记录。请记住，你可以通过更改
    index.html 中的值来完全禁用它们，或者你可以通过在运行时使用JavaScript控制台设置值来临时切换日志记录的开和关。
- en: 2.3\. Displaying a product
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3\. 展示产品
- en: 'Displaying the name of our webstore is a good start, but there are a few more
    aspects of displaying data in our markup that we should cover before moving on.
    Our webstore will display products in one of several ways: in a list, in a grid,
    as a featured product, and on its own individual product page. As we design and
    mark up each view, we’ll continue to use the same data, but we’ll use Vue’s functionality
    to manipulate it differently for each display without altering the underlying
    values or structure.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 显示我们网店的名字是一个好的开始，但在继续之前，我们还需要涵盖显示数据的一些其他方面。我们的网店将以几种方式之一展示产品：列表形式、网格形式、特色产品，以及单独的产品页面。在设计并标记每个视图时，我们将继续使用相同的数据，但我们将使用Vue的功能以不同的方式来操作它，而不会改变其基本值或结构。
- en: 2.3.1\. Defining product data
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1\. 定义产品数据
- en: For now, we’re only going to display a single product, so let’s add a sample
    product to our `data` object.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只将展示单个产品，所以让我们向我们的 `data` 对象添加一个示例产品。
- en: 'Listing 2.4\. Adding product data to our Vue instance: chapter-02/product-data.js'
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.4\. 向我们的Vue实例添加产品数据：chapter-02/product-data.js
- en: '[PRE5]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* An object for our product data**'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 产品数据对象**'
- en: '***2* The product’s attributes are properties of our product object.**'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 产品属性是产品对象属性。**'
- en: 'Adding a `product` object to our `data` option is relatively straightforward:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的 `data` 选项添加 `product` 对象相对简单：
- en: '***The `id` property is used to uniquely identify a product.*** This property
    will increment if we add more products.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`id` 属性用于唯一标识一个产品。*** 如果我们添加更多产品，该属性将递增。'
- en: '***Although the title and description properties are both strings, the description
    contains HTML markup.*** We’ll look at what that means when we get around to displaying
    each of those values in our product markup.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***尽管标题和描述属性都是字符串，但描述包含HTML标记。*** 当我们展示产品标记中的每个值时，我们将探讨这意味着什么。'
- en: '***The price property represents the cost of our product as an integer.***
    This simplifies calculations we’ll do later, and this format avoids potentially
    destructive type casting that occurs when values are stored as floats or strings
    in a database.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***价格属性表示我们产品的成本，以整数形式。*** 这简化了我们将要进行的计算，并且这种格式避免了在数据库中将值存储为浮点数或字符串时可能发生的破坏性类型转换。'
- en: '***The image property provides a path to our product’s primary image file.***
    We’re going to iterate on this one quite a bit, so if seeing a hardcoded path
    here makes you nervous, breathe easy, because we’ll explore better options.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***图像属性提供了一个指向我们产品主图像文件的路径。*** 我们将在这方面进行很多迭代，所以如果你在这里看到硬编码的路径让你感到紧张，请放心，因为我们将会探索更好的选项。'
- en: With our data in place, let’s get our view up to speed.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据就绪后，让我们加快我们的视图。
- en: 2.3.2\. Marking up the product view
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 标记产品视图
- en: Now we can focus on adding the product markup to our HTML. Beneath the header
    element, we’ll add a main element that acts as the primary container for the content
    of our application. The main element, `<main>`, is a new addition to HTML5 and
    is meant to contain the primary content of a webpage or application.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以专注于向我们的HTML添加产品标记。在标题元素下方，我们将添加一个主元素，该元素作为我们应用程序内容的主体容器。主元素 `<main>` 是HTML5的新增内容，旨在包含网页或应用程序的主要内容。
- en: '|  |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Info
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 信息
- en: For more information about the main element (and others), start by visiting
    [www.quackit.com/html_5/tags/html_main_tag.cfm](http://www.quackit.com/html_5/tags/html_main_tag.cfm).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有关主要元素（以及其他元素）的更多信息，请首先访问 [www.quackit.com/html_5/tags/html_main_tag.cfm](http://www.quackit.com/html_5/tags/html_main_tag.cfm).
- en: '|  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The product layout uses two columns so that the product image is displayed to
    the side of the product information ([figure 2.13](#ch02fig13)). Our stylesheet
    (chapter-02/assets/css/app.css) already has all the column styles defined, so
    we only need to include the appropriate class names in our markup.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 产品布局使用两列，以便将产品图片显示在产品信息旁边（[图 2.13](#ch02fig13)）。我们的样式表（chapter-02/assets/css/app.css）已经定义了所有列样式，所以我们只需要在我们的标记中包含适当的类名。
- en: 'Listing 2.5\. Adding product markup: chapter-02/product-markup.html'
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 2.5\. 添加产品标记：chapter-02/product-markup.html
- en: '[PRE6]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* The product’s image path is bound to the src of the img tag using a v-bind
    directive.**'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 产品图片路径使用 v-bind 指令绑定到 img 标签的 src 属性。**'
- en: '***2* Other product properties are displayed using the v-text directive.**'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 其他产品属性使用 v-text 指令显示。**'
- en: One thing you’ll notice right away is the use of JavaScript dot notation in
    the data bindings. Because `product` is an object, we must provide each binding
    with the entire path to a property. Most of the properties of our product data—title,
    description and price—are bound using the `v-text` directives, the same way we
    bound the `sitename` property in the header.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你会立即注意到数据绑定中使用了 JavaScript 点表示法。因为 `product` 是一个对象，我们必须为每个绑定提供到属性的完整路径。我们产品数据的大多数属性（标题、描述和价格）都是使用
    `v-text` 指令绑定的，这与我们在页眉中绑定 `sitename` 属性的方式相同。
- en: The product’s image path introduces an *attribute binding.* We use the `v-bind`
    directive because element attributes cannot be bound using simple text interpolations.
    Any valid element attribute can be bound using the `v-bind` directive, but it’s
    important to note that there are special cases for styles, class names, and other
    scenarios that we’ll come to in future chapters.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 产品图片路径引入了一个 *属性绑定*。我们使用 `v-bind` 指令，因为元素属性不能使用简单的文本插值进行绑定。任何有效的元素属性都可以使用 `v-bind`
    指令进行绑定，但需要注意的是，对于样式、类名和其他场景有特殊案例，我们将在未来的章节中介绍。
- en: '|  |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can use a shorthand for the `v-bind` directive. Instead of typing out `v-bind`
    every time you need to use it, you can remove the `v-bind` and type `:`, so instead
    of using `v-bind:src=" ... "`, you can type `:src=" ... "`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为 `v-bind` 指令使用缩写。不需要每次使用时都输入 `v-bind`，你可以去掉 `v-bind` 并输入 `:`, 因此，你不需要使用
    `v-bind:src=" ... "`，而是可以输入 `:src=" ... "`.
- en: '|  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Using expressions in bindings**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**在绑定中使用表达式**'
- en: 'We don’t need to restrict our data bindings to properties of our data. Vue
    allows us to use any valid JavaScript expression inside any of our bindings. A
    few examples using the code from [listing 2.5](#ch02ex05) might be:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要将数据绑定限制在我们的数据属性上。Vue 允许我们在任何绑定中使用任何有效的 JavaScript 表达式。一些使用 [清单 2.5](#ch02ex05)
    中的代码的例子可能包括：
- en: '[PRE7]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Though using expressions in this way is convenient, it introduces logic into
    the view that’s almost always better off inside the JavaScript code of the application
    or component responsible for the view’s data. Additionally, expressions like this
    make it difficult to reason about where an application’s data gets manipulated,
    especially as an application’s complexity increases.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以这种方式使用表达式很方便，但它将逻辑引入了视图，而几乎总是更好的是将这种逻辑放在负责视图数据的应用程序或组件的 JavaScript 代码中。此外，这种表达式使得推理应用程序数据被操作的位置变得困难，尤其是在应用程序的复杂性增加时。
- en: In general, using an inline expression is a great way to test something before
    formalizing that functionality within an application.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用内联表达式是在应用程序中正式化该功能之前测试某事的好方法。
- en: The next section and upcoming chapters introduce the best practices for manipulating,
    filtering, and deriving data from existing values without compromising the integrity
    of our views or application data. For details on what’s considered an expression,
    please visit [https://vuejs.org/v2/guide/syntax.html#Using-JavaScript-Expressions](https://vuejs.org/v2/guide/syntax.html#Using-JavaScript-Expressions).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节和即将到来的章节介绍了在不损害我们视图或应用程序数据完整性的情况下，从现有值中操作、过滤和推导数据的最佳实践。有关表达式是什么的详细信息，请访问
    [https://vuejs.org/v2/guide/syntax.html#Using-JavaScript-Expressions](https://vuejs.org/v2/guide/syntax.html#Using-JavaScript-Expressions).
- en: '|  |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Let’s flip over to Chrome, reload the page, and confirm that the product information
    is displayed as designed.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到 Chrome，重新加载页面，并确认产品信息按设计显示。
- en: Figure 2.13\. Our product is displayed but has a few issues we need to clean
    up.
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.13\. 我们的产品已显示，但有一些我们需要清理的问题。
- en: '![](02fig13_alt.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig13_alt.jpg)'
- en: 'Uh oh, we’ve got a couple of things to work on:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，我们有一些事情要处理：
- en: The product description is being output as a string and isn’t interpreting the
    HTML embedded in the description’s value.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 产品描述正在以字符串形式输出，并且没有解释描述值中嵌入的 HTML。
- en: The product’s price is displayed as a string representation of the integer 2000,
    and not as a well-formatted dollar figure.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 产品价格以整数 2000 的字符串表示形式显示，而不是以良好的美元数字格式显示。
- en: Let’s solve that first issue first. What we need is an *HTML directive*, so
    let’s update the product markup using the `v-html` binding to output the product’s
    description as intended.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解决第一个问题。我们需要的是一个 *HTML 指令*，因此让我们使用 `v-html` 绑定更新产品标记，以输出预期的产品描述。
- en: 'Listing 2.6\. Adding product markup: chapter-02/product-markup-cont.html'
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.6\. 添加产品标记：chapter-02/product-markup-cont.html
- en: '[PRE8]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Uses an HTML directive to output the product description as HTML, not
    plain text**'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 HTML 指令以 HTML 格式输出产品描述，而不是纯文本**'
- en: Reloading the app in Chrome should now render the value of our product description
    as HTML and the emphasis tag should italicize the word “irresistible,” as shown
    in [figure 2.14](#ch02fig14).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chrome 中重新加载应用程序应现在将产品描述的值以 HTML 格式显示，并且强调标签应使“irresistible”一词斜体，如图 [2.14](#ch02fig14)
    所示。
- en: Figure 2.14\. Using the `v-html` binding allows us to display the description
    as raw HTML.
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.14\. 使用 `v-html` 绑定允许我们以原始 HTML 格式显示描述。
- en: '![](02fig14.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig14.jpg)'
- en: The `v-html` binding will render the bound property as raw HTML. This can be
    handy but should be used sparingly and only when the value is one you can trust.
    Now we need to fix the display of that pesky price value.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-html` 绑定将渲染绑定属性为原始 HTML。这可能很有用，但应谨慎使用，并且仅在值是您可以信任的情况下使用。现在我们需要修复那个讨厌的价格值显示。'
- en: '|  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Cross-site scripting attacks**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站脚本攻击**'
- en: When we write code that inserts HTML directly into a view, we open our applications
    up to cross-site scripting (XSS) attacks.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们直接将 HTML 代码插入到视图中编写代码时，我们使我们的应用程序容易受到跨站脚本（XSS）攻击。
- en: At a high level, if a bad actor visits our site and saves malicious JavaScript
    in our database by using a form we haven’t sanitized, we’re vulnerable when we
    output that code to our HTML.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，如果恶意行为者访问我们的网站，并使用我们未清理的表单在我们的数据库中保存恶意 JavaScript，那么当我们将该代码输出到 HTML 时，我们就容易受到攻击。
- en: 'In general, best practice dictates that we should, at a minimum, follow basic
    principles regarding HTML and content:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最佳实践规定，我们至少应遵循有关 HTML 和内容的基本原则：
- en: Only output trusted content when using HTML interpolations.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用 HTML 插值时，仅输出可信内容。
- en: Never output user-sourced content when using HTML interpolations, no matter
    how well-scrutinized the content is.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论内容审查得多仔细，在使用 HTML 插值时，永远不要输出用户生成的内容。
- en: If absolutely required, try to implement the feature using a component with
    its own template, rather than allow HTML elements in text inputs.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果绝对需要，尝试使用具有其自己的模板的组件来实现功能，而不是允许在文本输入中包含 HTML 元素。
- en: For a comprehensive, clear overview of XSS, start with this article at [https://excess-xss.com/](https://excess-xss.com/),
    and for a deeper understanding of attacks and sample code for each exploit, consult
    this OWASP wiki at [www.owasp.org/index.php/Cross-site_Scripting_(XSS)](http://www.owasp.org/index.php/Cross-site_Scripting_(XSS)).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得 XSS 的全面、清晰的概述，请从这篇文章开始[https://excess-xss.com/](https://excess-xss.com/)，要深入了解攻击和每个利用的示例代码，请参考
    OWASP 维基[www.owasp.org/index.php/Cross-site_Scripting_(XSS)](http://www.owasp.org/index.php/Cross-site_Scripting_(XSS))。
- en: '|  |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.4\. Applying output filters
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4\. 应用输出过滤器
- en: The last thing left to do is to display our product’s price in a familiar format,
    not as a raw integer. Output filters let us apply formatting to a value before
    it’s displayed in our markup. The general format of an output filter is `{{ property
    | filter }}`. In our case, we want to format the product’s price to look like
    $20.00, rather than 2000.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的就是以熟悉的格式显示我们的产品价格，而不是以原始整数的形式。输出过滤器让我们在值显示在我们的标记之前对其应用格式。输出过滤器的通用格式是 `{{
    property | filter }}`。在我们的情况下，我们希望将产品的价格格式化为 $20.00，而不是 2000。
- en: 2.4.1\. Write the filter function
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1\. 编写过滤器函数
- en: '*Output filters* are functions that receive a value, perform a formatting task,
    and return the formatted value for output. When used as part of a text interpolation,
    the value passed to the filter is the property we’re binding to.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*输出过滤器*是接收一个值、执行格式化任务并返回格式化值以供输出的函数。当作为文本插值的一部分使用时，传递给过滤器的值是我们绑定的属性。'
- en: All our output filters reside in the `filters` object of the options we pass
    to our Vue instance, so that’s where we’ll add our price formatter in the following
    listing.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的输出过滤器都位于传递给我们的 Vue 实例的选项中的`filters`对象中，因此我们将在以下列表中添加我们的价格格式化器。
- en: 'Listing 2.7\. Adding the formatPrice filter: chapter-02/format-price.js'
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.7\. 添加`formatPrice`过滤器：chapter-02/format-price.js
- en: '[PRE9]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* The filters option contains output filters.**'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 过滤器选项包含输出过滤器。**'
- en: '***2* formatPrice takes an integer and formats a price value.**'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* `formatPrice`函数接受一个整数并格式化价格值。**'
- en: '***3* If we can’t get an integer, return immediately.**'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果我们无法获取整数，则立即返回。**'
- en: '***4* Formats values $1,000 and up**'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 格式化$1,000及以上的值**'
- en: '***5* Converts the value to a decimal**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将值转换为十进制**'
- en: '***6* Adds commas every three places**'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 每三位数添加逗号**'
- en: '***7* Returns the formatted value**'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 返回格式化的值**'
- en: '***8* If less than $1,000, returns a formatted decimal value**'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 如果小于$1,000，则返回格式化的十进制值**'
- en: 'The `formatPrice` function takes an integer and returns a string formatted
    to look like a U.S. dollar value. Generically, it will return a value similar
    to $12,345.67\. Depending on the size of the integer provided, the function branches
    as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`formatPrice`函数接受一个整数，并返回一个格式化成类似美国美元价值的字符串。一般来说，它将返回类似$12,345.67的值。根据提供的整数值的大小，函数将按以下方式分支：'
- en: If the input is greater than 99,999 (the equivalent of $999.99), the output
    will require commas every three digits to the left of the decimal, so we need
    to process it accordingly.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入大于99,999（相当于$999.99），则输出需要在小数点左侧每三位数字添加逗号，因此我们需要相应地处理它。
- en: Otherwise, the input can be converted using `.toFixed`, and returned because
    no commas are required.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，可以使用`.toFixed`将输入转换为十进制，并返回，因为不需要逗号。
- en: '|  |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can find probably a gazillion ways to format a dollar figure that are more
    efficient, terse, or whatever quality you’re searching for. Here, I’ve tried to
    favor clarity over expediency. For an idea of how complex the issue is, and how
    many solutions there are, dive into this post at [http://mng.bz/qusZ](http://mng.bz/qusZ).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能能找到无数种格式化美元数字的方法，这些方法可能更高效、更简洁，或者满足你寻找的任何质量。在这里，我尽量在清晰和便捷之间做出选择。为了了解问题的复杂性和解决方案的数量，请查看这篇帖子[http://mng.bz/qusZ](http://mng.bz/qusZ)。
- en: '|  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.4.2\. Adding the filter to our markup and testing different values
  id: totrans-362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2\. 将过滤器添加到我们的标记中并测试不同的值
- en: To use our shiny new filter function, we need to add it to the binding for our
    product’s price. We also need to update our price binding to use the Mustache-style
    binding to apply the filter, as shown next. Filters cannot be used with the `v-text`
    binding syntax.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们全新的过滤器函数，我们需要将其添加到产品价格的绑定中。我们还需要更新我们的价格绑定，以使用 Mustache 风格的绑定来应用过滤器，如下所示。过滤器不能与`v-text`绑定语法一起使用。
- en: 'Listing 2.8\. Adding product markup: chapter-02/v-text-binding.html'
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.8\. 添加产品标记：chapter-02/v-text-binding.html
- en: '[PRE10]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Uses our new output filter to format the value of a product’s price**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用我们新的输出过滤器来格式化产品价格的值**'
- en: Remember, bindings with filters have the generic form `{{ property | filter
    }}`, so we’ve updated our price binding accordingly, `{{ product.price | formatPrice
    }}`. Flip back over to Chrome, refresh, and voilà, we’ve got a formatted price
    as seen in [figure 2.15](#ch02fig15).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，带有过滤器的绑定具有通用形式`{{ property | filter }}`，因此我们已经相应地更新了我们的价格绑定，`{{ product.price
    | formatPrice }}`。切换回 Chrome，刷新，哇，我们得到了如图 2.15 所示的格式化价格[图 2.15](#ch02fig15)。
- en: Figure 2.15\. Our price formatter adds a dollar sign and the appropriate punctuation
    to the display of our price property’s value.
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.15\. 我们的价格格式化器为我们的价格属性值的显示添加了美元符号和适当的标点符号。
- en: '![](02fig15.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig15.jpg)'
- en: We can see how our filter is applied to different product price values in real
    time if we tinker with our data in the console. To try different values, open
    the console and set the value of `product.price` with a statement such as `webstore.product.price
    = 150000000`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在控制台中调整我们的数据，我们可以实时看到我们的过滤器是如何应用于不同的产品价格值的。要尝试不同的值，请打开控制台，并使用如下语句设置`product.price`的值：`webstore.product.price
    = 150000000`。
- en: '[Figure 2.16](#ch02fig16) shows what will occur after the product price is
    updated. Be sure to try out small (< 100) and large (> 10000000) values to be
    sure each is formatted correctly.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.16](#ch02fig16)显示了更新产品价格后会发生什么。确保尝试小（< 100）和大（> 10000000）的值，以确保每个值都格式正确。'
- en: Figure 2.16\. Updating the product price triggers our lifecycle events (if you
    still have them enabled), as well as an update to the price, which is now run
    through our filter function.
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.16：更新产品价格会触发我们的生命周期事件（如果你仍然启用了它们），以及价格的更新，现在这个更新会通过我们的过滤器函数。
- en: '![](02fig16_alt.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig16_alt.jpg)'
- en: Exercise
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Use your knowledge from this chapter to answer this question:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章的知识来回答这个问题：
- en: In [section 2.4](#ch02lev1sec4) we created a filter for the price. Can you think
    of any other filters that might be helpful?
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2.4节](#ch02lev1sec4)中，我们为价格创建了一个过滤器。你能想到其他可能有助于的过滤器吗？
- en: '*See the solution in [appendix B](kindle_split_026.html#app02).*'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[附录B](kindle_split_026.html#app02)中的解决方案。*'
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Vue gives you the ability to add interactivity to your applications.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue为你提供了向你的应用程序添加交互性的能力。
- en: At any time, we can hook into the Vue lifecycle to help perform certain functions.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何时候，我们都可以挂钩到Vue的生命周期来帮助执行某些功能。
- en: Vue.js offers powerful filters to help display information in a certain way.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue.js提供了强大的过滤器来帮助以特定方式显示信息。
