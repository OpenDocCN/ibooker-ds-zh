- en: 10 Jenkins X
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 Jenkins X
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What is Jenkins X?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Jenkins X？
- en: Installing Jenkins X
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Jenkins X
- en: Importing projects into Jenkins X
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目导入 Jenkins X
- en: Promoting a release to production in Jenkins X
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Jenkins X 中将发布版本推送到生产环境
- en: '*This chapter was written with contributions from Viktor Farcic and Oscar Medina*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章由 Viktor Farcic 和 Oscar Medina 贡献。*'
- en: In this chapter, you will learn how to use Jenkins X to deploy our reference
    example application to Kubernetes. You will also learn how Prow, Jenkins X pipeline
    operator, and Tekton work together to build a CI/CD pipeline.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用 Jenkins X 将我们的参考示例应用程序部署到 Kubernetes。你还将了解 Prow、Jenkins X 管道操作员和
    Tekton 如何协同工作以构建 CI/CD 管道。
- en: We recommend you read chapters 1, 2, 3, and 5 before reading this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你在阅读本章之前先阅读第 1、2、3 和 5 章。
- en: 10.1 What is Jenkins X?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 什么是 Jenkins X？
- en: To understand the intricacies and inner workings of Jenkins X, we need to understand
    Kubernetes. However, we do not need to understand Kubernetes to use Jenkins X.
    That is one of the main contributions of the project. Jenkins X allows us to harness
    the power of Kubernetes without spending an eternity learning the ever-growing
    list of the things Kubernetes does. Jenkins X^([1](#pgfId-1098537)) is an open
    source tool that simplifies complex processes into concepts that can be adopted
    quickly and without spending months trying to figure out “the right way to do
    stuff.” It helps by removing and simplifying some of the problems caused by the
    overall complexity of Kubernetes and its ecosystem. If you are indeed a Kubernetes
    ninja, you will appreciate all the effort put into Jenkins X. If you’re not, you
    will be able to jump right in and harness the power of Kubernetes without ripping
    your hair out in frustration caused by Kubernetes complexity. In section 10.2,
    we will discuss Jenkins X patterns and tools in detail.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 Jenkins X 的复杂性和内部工作原理，我们需要了解 Kubernetes。然而，我们不需要了解 Kubernetes 就可以使用 Jenkins
    X。这是项目的主要贡献之一。Jenkins X 允许我们利用 Kubernetes 的力量，而无需花费无数的时间学习 Kubernetes 不断增长的“正确做事”的列表。Jenkins
    X[1](#pgfId-1098537) 是一个开源工具，它将复杂的过程简化为可以快速采用的概念，而无需花费数月时间试图弄清楚“正确做事的方式”。它通过移除和简化由
    Kubernetes 及其生态系统的整体复杂性引起的一些问题来帮助用户。如果你确实是一个 Kubernetes 大师，你会欣赏 Jenkins X 所投入的所有努力。如果你不是，你将能够直接进入并利用
    Kubernetes 的力量，而不会因为 Kubernetes 的复杂性而感到沮丧。在第 10.2 节中，我们将详细讨论 Jenkins X 的模式和工具。
- en: Note Jenkins X is a free, open source tool with enterprise support offered by
    CloudBees.^([2](#pgfId-1098542))
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Jenkins X 是一个由 CloudBees 提供企业支持的免费、开源工具。[2](#pgfId-1098542)
- en: Today, most software vendors are building their next generation of software
    to be Kubernetes-native or, at least, to work better inside it. A whole ecosystem
    is emerging and treating Kubernetes as a blank canvas. As a result, new tools
    are being added on a daily basis, and it is becoming evident that Kubernetes offers
    near-limitless possibilities. However, with that comes increased complexity. It
    is harder than ever to choose which tools to use. How are we going to develop
    our applications? How are we going to manage different environments? How are we
    going to package our applications? Which process are we going to apply for application
    life cycles? And so on and so forth. Assembling a Kubernetes cluster with all
    the tools and processes takes time, and learning how to use what we assembled
    feels like a never-ending story. Jenkins X aims to remove those and other obstacles.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数软件供应商都在构建下一代软件以使其成为 Kubernetes 原生的，或者至少在 Kubernetes 内运行得更好。一个完整的生态系统正在出现，并将
    Kubernetes 视为一个空白画布。因此，每天都有新的工具被添加，而且越来越明显，Kubernetes 提供了几乎无限的可能性。然而，这也带来了更高的复杂性。选择使用哪些工具比以往任何时候都更难。我们将如何开发我们的应用程序？我们将如何管理不同的环境？我们将如何打包我们的应用程序？我们将应用哪种流程来管理应用程序的生命周期？等等。组装一个包含所有工具和流程的
    Kubernetes 集群需要时间，而学习如何使用我们所组装的就像是一个永无止境的故事。Jenkins X 的目标就是移除这些以及其他障碍。
- en: Jenkins X is opinionated. It defines many aspects of the software development
    life cycle, and it makes decisions for us. It tells us what to do and how. It
    is like a tour guide on your vacation who shows you where to go, what to look
    at, when to take a photo, and when it’s time to take a break. At the same time,
    it is flexible and allows power users to tweak it to fit their own needs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X 有自己的观点。它定义了软件开发生命周期的许多方面，并为我们做出决策。它告诉我们该做什么以及如何做。它就像一个度假时的导游，告诉你去哪里，看什么，何时拍照，何时休息。同时，它也是灵活的，允许高级用户调整它以满足他们的需求。
- en: The real power behind Jenkins X is the process, the selection of tools, and
    the glue that wraps everything into one cohesive unit that is easy to learn and
    use. We (people working in the software industry) tend to reinvent the wheel all
    the time. We spend countless hours trying to figure out how to develop our applications
    faster and how to have a local environment that is as close to production as possible.
    We dedicate time searching for tools that will allow us to package and deploy
    our applications more efficiently. We design the steps that form a continuous
    delivery pipeline. We write scripts that automate repetitive tasks. And yet, we
    cannot escape the feeling that we are likely reinventing things that were already
    done by others. Jenkins X is designed to help us with those decisions, and it
    helps us to pick the right tools for a job. It is a collection of the industry’s
    best practices. In some cases, Jenkins X is the one defining those practices,
    while in others, it helps us in adopting those defined by others.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X 的真正力量在于流程、工具的选择以及将一切包裹成一个易于学习和使用的整体粘合剂。我们（在软件行业工作的人）倾向于不断重新发明轮子。我们花费无数小时试图弄清楚如何更快地开发我们的应用程序，以及如何拥有尽可能接近生产环境的本地环境。我们投入时间寻找能够让我们更有效地打包和部署应用程序的工具。我们设计构成持续交付管道的步骤。我们编写脚本来自动化重复性任务。然而，我们无法摆脱这种感觉，我们可能正在重新发明别人已经完成的事情。Jenkins
    X 设计来帮助我们做出这些决定，并帮助我们选择适合工作的正确工具。它是一系列行业最佳实践的集合。在某些情况下，Jenkins X 是定义这些实践的人，而在其他情况下，它帮助我们采用其他人定义的实践。
- en: If we are about to start working on a new project, Jenkins X will create the
    structure and the required files. If we need a Kubernetes cluster with all the
    tools selected, installed, and configured, Jenkins X will do that. If we need
    to create Git repositories, set webhooks,^([3](#pgfId-1098550)) and create continuous
    delivery pipelines, all we need to do is execute a single `jx` command. The list
    of what Jenkins X does is vast, and it grows every day.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们即将开始一个新的项目，Jenkins X 将创建结构和所需的文件。如果我们需要一个包含所有工具、已安装和配置好的 Kubernetes 集群，Jenkins
    X 会这样做。如果我们需要创建 Git 仓库、设置 webhooks^([3](#pgfId-1098550)) 和创建持续交付管道，我们只需要执行一个单一的
    `jx` 命令。Jenkins X 所做的事情列表非常庞大，并且每天都在增长。
- en: Jenkins vs. Jenkins X If you are familiar with Jenkins, you need to clear your
    mind of any Jenkins experience you might already have. Sure, Jenkins is there,
    but it is only a part of the package. Jenkins X is very different from the “traditional
    Jenkins.” The differences are so massive that the only way for you to embrace
    it is to forget what you know about Jenkins and start from scratch.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 与 Jenkins X 如果你对 Jenkins 很熟悉，你需要清除你可能已经拥有的任何 Jenkins 经验。当然，Jenkins 是存在的，但它只是整个包的一部分。Jenkins
    X 与“传统 Jenkins”非常不同。差异如此之大，你唯一接受它的方式就是忘记你所知道的 Jenkins 知识，从头开始。
- en: 10.2 Exploring Prow, Jenkins X pipeline operator, and Tekton
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 探索 Prow、Jenkins X 管道操作员和 Tekton
- en: The serverless flavor of Jenkins X or, as some call it, Jenkins X Next Generation,
    is an attempt to redefine how we do continuous delivery and GitOps inside Kubernetes
    clusters. It does that by combining quite a few tools into a single easy-to-use
    bundle. As a result, most people will not need to understand the intricacies of
    how the pieces work independently or how they are all integrated. Instead, many
    will merely push a change to Git and let the system do the rest. But, there are
    always those who would like to know what’s happening under the hood. To satisfy
    those craving for insight, we’ll explore the processes and components involved
    in the serverless Jenkins X platform. Understanding the flow of an event initiated
    by a Git webhook will give us insight into how the solution works and help us
    later when we go deeper into each of the new components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X 的无服务器版本，或者有些人称之为 Jenkins X 新一代，是试图重新定义我们在 Kubernetes 集群内如何进行持续交付和
    GitOps。它是通过将相当多的工具组合成一个易于使用的捆绑包来做到这一点的。因此，大多数人不需要理解各个部分独立工作或如何全部集成的复杂性。相反，许多人只需将更改推送到
    Git，然后让系统完成剩余的工作。但是，总有那些想了解引擎盖下发生什么的人。为了满足那些渴望洞察的人，我们将探索在无服务器 Jenkins X 平台上涉及的过程和组件。了解由
    Git webhook 启动的事件流将让我们了解解决方案是如何工作的，并有助于我们后来在深入研究每个新组件时。
- en: Everything starts with a push to a Git repository, which, in turn, sends a webhook
    request to the cluster. Where things differ from a traditional Jenkins setup is
    that there is no Jenkins to accept those requests. Instead, we have Prow.^([4](#pgfId-1098568))
    It does quite a few things, but, in the context of webhooks, its job is to receive
    requests and decide what to do next. Those requests are not limited to only push
    events, but also include slash commands (such as `/approve`) we can specify through
    pull request comments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一切从向Git仓库的推送开始，这反过来会向集群发送webhook请求。与传统Jenkins设置的不同之处在于，没有Jenkins来接受这些请求。相反，我们有Prow.^([4](#pgfId-1098568))
    它做很多事情，但在webhook的上下文中，它的任务是接收请求并决定下一步做什么。这些请求不仅限于推送事件，还包括我们可以通过拉取请求注释指定的斜杠命令（例如`/approve`）。
- en: Prow consists of a few distinct components (deck, hook, crier, tide, and more).
    However, we won’t go into the roles of each of them. For now, the vital thing
    to note is that Prow is the entry point to the cluster. It receives Git requests
    generated either by Git actions (such as push) or through slash commands in comments.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Prow由几个不同的组件（deck、hook、crier、tide等）组成。然而，我们不会深入探讨每个组件的角色。现在，重要的是要注意，Prow是集群的入口点。它接收由Git动作（如推送）或通过评论中的斜杠命令生成的Git请求。
- en: Prow might do quite a few things upon receiving a request. If the request comes
    from a command from a Git comment, it might rerun tests, merge a pull request,
    assign a person, or one of the many other Git-related actions. If a webhook informs
    it that a new push was made, it will send a request to the Jenkins X pipeline
    operator that will make sure that a build corresponding to a defined pipeline
    is run. Finally, Prow also reports the status of a build back to Git.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到请求后，Prow可能会做很多事情。如果请求来自Git评论中的命令，它可能会重新运行测试、合并拉取请求、分配给某个人，或者执行许多其他与Git相关的操作。如果webhook通知它有新的推送，它将向Jenkins
    X管道操作员发送请求，确保运行与定义的管道对应的构建。最后，Prow还将构建状态报告回Git。
- en: '![](Images/CH10_F01_Yuen.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH10_F01_Yuen.png)'
- en: Figure 10.1 Engineers push code and configurations to Git. A Prow hook listens
    for Git webhooks and dispatches them to plugins.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 工程师将代码和配置推送到Git。Prow钩子监听Git webhook并分发到插件。
- en: Those features are not the only types of actions Prow might perform but, for
    now, you’ve probably got the general gist. Prow is in charge of communication
    between Git and the processes inside our cluster.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能并不是Prow可能执行的所有动作类型，但到目前为止，你可能已经抓住了大概。Prow负责Git和集群内部进程之间的通信。
- en: '![](Images/CH10_F02_Yuen.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH10_F02_Yuen.png)'
- en: Figure 10.2 When a Prow hook receives a request from a Git webhook, it forwards
    it to Jenkins X pipeline operator.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 当Prow钩子收到Git webhook的请求时，它将其转发到Jenkins X管道操作员。
- en: The role of the operator is to fetch the jenkins-x.yml file from the repository
    that initiated the process and to transform it into Tekton tasks and pipelines.
    They, in turn, define the complete pipeline that should be executed as a result
    of pushing a change to Git.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员的角色是从启动过程的仓库中获取jenkins-x.yml文件，并将其转换为Tekton任务和管道。它们反过来定义了在向Git推送更改时应执行的整体管道。
- en: Tekton Tekton is a Kubernetes-native open source framework CI/CD systems.^([5](#pgfId-1098595))
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton Tekton是一个Kubernetes原生开源框架CI/CD系统.^([5](#pgfId-1098595))
- en: '![](Images/CH10_F03_Yuen.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH10_F03_Yuen.png)'
- en: Figure 10.3 The pipeline operator simplifies definitions of our continuous delivery
    processes, and Tekton does the heavy lifting to define pipelines for each project/repository.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 管道操作员简化了我们的持续交付流程的定义，而Tekton为每个项目/仓库定义管道时做繁重的工作。
- en: Tekton is a very low-level solution and is not meant to be used directly. Writing
    Tekton definitions can be quite painful and complicated. The pipeline operator
    simplifies that through easy-to-learn and -use YAML format for defining pipelines.
    Listing 10.1 is an example of what the base pipeline will provide.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton是一个非常底层的解决方案，并不打算直接使用。编写Tekton定义可能会非常痛苦且复杂。管道操作员通过易于学习和使用的YAML格式简化了定义管道的过程。列表10.1是基础管道将提供的内容示例。
- en: 'Note As you will discover in section 10.3, the pipeline file for your project
    will be called jenkins-x.yml, which includes the single line “`buildPack: go`”
    to reference the following pipeline file. If you’d like to learn more about how
    pipelines work, please refer to the Jenkins X documentation.^([6](#pgfId-1098608))'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '注意：正如您将在第 10.3 节中发现的那样，您项目的管道文件将被称为 jenkins-x.yml，其中包含单行“`buildPack: go`”，以引用以下管道文件。如果您想了解更多关于管道如何工作，请参阅
    Jenkins X 文档.^([6](#pgfId-1098608))'
- en: Listing 10.1 http://mng.bz/zx0a
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1 http://mng.bz/zx0a
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tekton creates a `PipelineRun` for each build initiated by each push to one
    of the associated branches (master branch, PRs). It performs all the steps we
    need to validate a push. It runs tests, stores binaries in registries (Docker
    registry, Nexus, and ChartMuseum), and deploys a release to a temporary (PR) or
    a permanent Stage or Prod environment.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton 为每个推送到相关分支（主分支、PRs）的构建创建一个 `PipelineRun`。它执行所有我们需要验证推送的步骤。它运行测试，将二进制文件存储在注册表中（Docker
    注册表、Nexus 和 ChartMuseum），并将发布部署到临时（PR）或永久阶段或生产环境。
- en: The complete flow can be seen in figure 10.4.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 完整流程可以在图 10.4 中看到。
- en: '![](Images/CH10_F04_Yuen.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH10_F04_Yuen.png)'
- en: Figure 10.4 The complete flow of events starts from PR, webhook in Prow, pipeline
    operator, to Tekton. Jenkins X will execute pipelines for each build/commit and
    deploy applications.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 事件完整流程从 PR 开始，经过 Prow 的 webhook，再到管道操作员，最后到 Tekton。Jenkins X 将为每个构建/提交执行管道并部署应用程序。
- en: Exercise 10.1
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.1
- en: Which component will receive the Git webhook request? Which component will orchestrate
    the deployment?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个组件将接收 Git webhook 请求？哪个组件将协调部署？
- en: 10.3 Importing projects into Jenkins X
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 将项目导入 Jenkins X
- en: You can see how we can fast-track the development and continuous delivery of
    new applications with Jenkins X quick starts. However, it is likely that your
    company was not formed yesterday. That means that you already have some apps,
    and hopefully, you’d like to move them to Jenkins X.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们如何使用 Jenkins X 快速入门来快速推进新应用程序的开发和持续交付。然而，您的公司可能不是昨天成立的。这意味着您已经有一些应用程序，并且您可能希望将它们迁移到
    Jenkins X。
- en: From a Jenkins X perspective, importing an existing project is relatively straightforward.
    All we have to do is execute `jx` `import`, and Jenkins X will do its magic. It
    will create the files we need. If we do not yet have skaffold.yml, it will be
    generated for us. If we do not create a Helm chart, it will create that as well.
    No Dockerfile? No problem. We’ll get that as well. Never wrote a Jenkins pipeline
    for that project? Again, that is not an issue. We’ll get a jenkins-x.yml file
    that is automatically generated. Jenkins X will reuse the things we already have,
    and create those that we’re missing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Jenkins X 的角度来看，导入现有项目相对简单。我们只需执行 `jx import` 命令，Jenkins X 就会施展其魔法。它会创建我们需要的文件。如果我们还没有
    skaffold.yml，它将为我们生成。如果我们不创建 Helm 图表，它也会创建。没有 Dockerfile？没问题。我们也会得到它。从未为该项目编写过
    Jenkins 管道？再次，这不是问题。我们将得到一个自动生成的 jenkins-x.yml 文件。Jenkins X 将重用我们已有的东西，并创建我们缺少的东西。
- en: The import process does not limit itself to creating missing files and pushing
    them to Git. It’ll also create a job in Jenkins, webhooks in GitHub, and quite
    a few other things.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 导入过程不仅限于创建缺失的文件并将它们推送到 Git。它还会在 Jenkins 中创建一个作业，在 GitHub 中创建钩子，以及许多其他事情。
- en: Note Please refer to appendix B for more information on how to install Jenkins
    X.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关如何安装 Jenkins X 的更多信息，请参阅附录 B。
- en: 10.3.1 Importing a project
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 导入项目
- en: We’ll import the application stored in the `gitopsbook/sample-app` repository.
    We’ll use it as a guinea pig for testing the import process as well as to flesh
    out potential problems we might encounter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入存储在 `gitopsbook/sample-app` 仓库中的应用程序。我们将用它作为测试导入过程以及解决可能遇到的问题的试验品。
- en: 'But, before we import the repository, you’ll have to fork the code. Otherwise,
    you won’t be able to push changes since you are not (yet) a collaborator on that
    specific repository:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在我们导入仓库之前，您必须先分叉代码。否则，由于您还不是该特定仓库的协作者（尚不是），您将无法推送更改：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Make sure that you are logged in, and click the Fork button located in the top-right
    corner. Follow the onscreen instructions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已登录，并点击位于右上角的 Fork 按钮。按照屏幕上的说明操作。
- en: 'Next, you need to clone the repository you just forked:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要克隆您刚刚分叉的仓库：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Replace [...] with your GitHub user before executing the commands that follow.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在执行后续命令之前，请将 [...] 替换为您的 GitHub 用户名。
- en: 'Now you should have the intended code in the master branch of the repository
    you forked. Feel free to take a look at what we have by opening the repository
    in a browser. Fortunately, there is a `jx` command that does just that:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该已经在你分叉的仓库的主分支中有了预期的代码。你可以自由地查看我们有什么，只需在浏览器中打开仓库即可。幸运的是，有一个`jx`命令可以做到这一点：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s quickly explore the files of the project, before we import it into Jenkins
    X:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将项目导入到Jenkins X之前，让我们快速探索一下项目的文件：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, there’s (almost) nothing in that repository but Go^([7](#pgfId-1098707))
    code (*.go).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，那个仓库中几乎什么都没有，只有Go^([7](#pgfId-1098707))代码 (*.go)。
- en: That project is one extreme of the possible spectrum of projects we might want
    to import to Jenkins X. It only has the code of the application. There is a `Dockerfile`.
    However, there is no Helm chart or even a script for building a binary, nor is
    there a mechanism to run tests, and there is definitely no jenkins-x.yml file
    that defines a continuous delivery pipeline for the application. There’s only
    code, and (almost) nothing else.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目是我们可能想要导入到Jenkins X中的可能项目范围的一个极端。它只有应用程序的代码。有一个`Dockerfile`。然而，没有Helm图表或构建二进制的脚本，也没有运行测试的机制，并且肯定没有定义应用程序持续交付管道的`jenkins-x.yml`文件。这里只有代码，几乎没有其他东西。
- en: Such a situation might not be your case. Maybe you do have scripts for running
    tests or building the code. Or perhaps you are already a heavy Kubernetes user,
    and you do have a Helm chart. You might have other files as well. We’ll discuss
    those situations later. For now, we’ll work on the case when there is nothing
    but the code of an application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可能并不适用于你。也许你确实有运行测试或构建代码的脚本。或者，你可能已经是Kubernetes的重度用户，并且已经有一个Helm图表。你可能还有其他文件。我们稍后会讨论这些情况。现在，我们将专注于没有任何东西，只有应用程序代码的情况。
- en: 'Let’s see what happens when we try to import that repository into Jenkins X:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们尝试将那个仓库导入到Jenkins X中会发生什么：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ GitHub username
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ GitHub用户名
- en: ❷ Generates anew token
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 生成新的令牌
- en: ❸ Default “No” for preview Namespace
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 预览命名空间默认为“否”
- en: We can see from the output that Jenkins X detected that the project is 100%
    written in Go, so it selected the Go build pack. It applied the build pack to
    the local repository and pushed the changes to GitHub. Furthermore, it created
    a Jenkins project as well as a GitHub webhook that will trigger builds whenever
    we push changes to one of the selected branches. Those branches are by default
    master, develop, PR-.*, and feature.*. We could have changed the pattern by adding
    the `--branches` flag. But, for our purposes, and many others, those branches
    are just what we need.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，Jenkins X检测到项目100%是用Go编写的，因此选择了Go构建包。它将构建包应用到本地仓库，并将更改推送到GitHub。此外，它还创建了一个Jenkins项目以及一个GitHub
    webhook，每当我们将更改推送到所选分支之一时，它都会触发构建。这些分支默认为主分支、develop、PR-.*和feature.*。我们可以通过添加`--branches`标志来更改模式。但是，就我们的目的而言，以及许多其他情况，这些分支正是我们所需要的。
- en: '![](Images/CH10_F05_Yuen.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH10_F05_Yuen.png)'
- en: Figure 10.5 Files added by `jx` `import`
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 `jx` `import` 添加的文件
- en: 'Now let’s take another look at the files in the local copy of the repository:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次查看本地仓库副本中的文件：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can see that quite a few new files were added to the project through the
    import process. We have a `Dockerfile` that will be used to build container images,
    and we have a jenkins-x.yml that defines all the steps of our pipeline.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，通过导入过程，项目添加了相当多的新文件。我们有一个`Dockerfile`，它将被用来构建容器镜像，我们还有一个jenkins-x.yml，它定义了我们管道的所有步骤。
- en: 'We also got a Makefile that defines targets to build, test, and install the
    application. There is also the charts directory that contains files in Helm format
    for packaging, installing, and upgrading our application. We also got watch.sh,
    which monitors build changes and invokes skaffold.yaml. skaffold.yaml contains
    the instruction to build and publish the container images. There are a few other
    new files (ex: OWNERS) added to the mix.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还得到了一个Makefile，它定义了构建、测试和安装应用程序的目标。还有一个包含用于打包、安装和升级我们应用程序的Helm格式的文件的charts目录。我们还得到了watch.sh，它监控构建更改并调用skaffold.yaml。skaffold.yaml包含构建和发布容器镜像的指令。还有一些其他新文件（例如：OWNERS）被添加到混合中。
- en: Now that the project is in Jenkins X, we should see it as one of the activities
    and observe the first build in action. You already know that we can limit the
    retrieval of Jenkins X activities to a specific project and that we can use `--watch`
    to watch the progress.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已经在Jenkins X中，我们应该将其视为一项活动，并观察第一次构建的实际操作。您已经知道我们可以限制Jenkins X活动的检索范围到特定的项目，并且可以使用`--watch`来监视进度。
- en: Note Wait until the `jx` `promote` and `PullRequest` complete before proceeding
    to the rest of the tutorial. If the process takes more than 60 minutes, the pull
    request will show a “Failed” status. If you check GitHub, the PR will still merge
    after `jx` `promote` completes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在继续教程的其余部分之前，请等待`jx` `promote`和`PullRequest`完成。如果过程超过60分钟，拉取请求将显示“失败”状态。如果您检查GitHub，PR将在`jx`
    `promote`完成后仍然合并。
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](Images/CH10_F06_Yuen.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH10_F06_Yuen.png)'
- en: Figure 10.6 Jenkins X will generate a pull request to add a new version of our
    app. This is GitOps at work!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 Jenkins X将生成一个拉取请求以添加我们应用程序的新版本。这就是GitOps在发挥作用！
- en: The pipeline activities give you a lot of detail on the pipeline stages and
    steps. However, one of the most important details is the PR that gets merged into
    the staging environment. This tells Jenkins X to add that new version of our app
    into the env/requirements.yaml file. This is GitOps at work!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 管道活动为您提供了关于管道阶段和步骤的大量详细信息。然而，其中最重要的细节之一是合并到预发布环境的PR。这告诉Jenkins X将我们的应用的新版本添加到env/requirements.yaml文件中。这就是GitOps在发挥作用！
- en: So far, Jenkins X created the files it needs, it created a GitHub webhook, it
    created a pipeline, and it pushed changes to GitHub. As a result, we got our first
    build, and by the look of it, it was successful. But let’s double-check that everything
    is OK.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Jenkins X创建了它需要的文件，它创建了一个GitHub webhook，它创建了一个管道，并将更改推送到GitHub。因此，我们得到了第一次构建，从外观上看，它是成功的。但让我们再次检查一切是否正常。
- en: Open the PullRequest link on your browser by clicking on the link from the activity
    output, as shown in Figure 10.5.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击活动输出中的链接，在浏览器中打开PullRequest链接，如图10.5所示。
- en: So far, so good. The `sample-app` job created a pull request to the environment-cluster-1-staging
    repository. As a result, the webhook from that repository should have initiated
    a pipeline activity, and the result should be a new release of the application
    in the staging environment. We won’t go through that part of the process just
    yet. For now, just note that the application should be running, and we’ll check
    that soon.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。`sample-app`作业向环境-cluster-1-staging仓库创建了一个拉取请求。因此，该仓库的webhook应该已经启动了一个管道活动，结果应该是在预发布环境中的应用程序的新版本。我们暂时不会深入这个过程。现在，只需注意应用程序应该正在运行，我们很快就会检查这一点。
- en: 'The information we need to confirm that the application is indeed running is
    in the list of the applications running in the staging environment. We’ll explore
    the environments later. For now, just run the command that follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确认应用程序确实正在运行的信息在预发布环境中运行的应用程序列表中。我们将在稍后探索环境。现在，只需运行以下命令：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see the address through which our application should be accessible in
    the URL column. Copy it and use it instead of [...] in the command that follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在URL列中看到我们的应用程序应该通过哪个地址访问。复制它，并在随后的命令中使用它代替[...]：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Staging URL address
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 预发布URL地址
- en: The output shows `Kubernetes ♡ Golang!`, thus confirming that the application
    is up and running and that we can reach it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示`Kubernetes ♡ Golang!`，从而确认应用程序正在运行，并且我们可以访问它。
- en: Before we proceed, we’ll go out of the sample-app directory. We have reached
    the final stage, at least from the application life cycle point of view.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们将离开sample-app目录。至少从应用程序生命周期角度来看，我们已经达到了最终阶段。
- en: Note For a complete application life cycle reference, please refer to figure
    4.6 in chapter 4 (pipelines).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关完整的应用程序生命周期参考，请参阅第4章（管道）中的图4.6。
- en: 'Actually, we skipped creating a pull request, which happens to be one of the
    most important features of Jenkins X. Nevertheless, we do not have enough space
    to cover all Jenkins X features, so we’ll leave PRs and others for you to discover
    on your own (PR can be found from output of the `jx` `get` `activities` command).
    For now, we’ll focus on the final stage of the application life cycle by exploring
    promotions to production. We’ve already covered the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们跳过了创建拉取请求，这恰好是 Jenkins X 最重要功能之一。尽管如此，我们没有足够的空间来涵盖所有 Jenkins X 功能，所以我们将把
    PR 和其他功能留给你自己探索（PR 可以从 `jx get activities` 命令的输出中找到）。现在，我们将通过探索推广到生产的过程来关注应用生命周期的最后阶段。我们已经涵盖了以下内容：
- en: We saw how to import an existing project and how to create a new one.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们看到了如何导入现有项目以及如何创建一个新项目。
- en: We saw how to develop build packs that will simplify those processes for the
    types of applications that are not covered with the existing build packs or for
    those that deviate from them.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们看到了如何开发构建包，这将简化那些现有构建包未涵盖或与之偏离的应用类型的流程。
- en: Once we added our app to Jenkins X, we explored how it implements GitOps processes
    through environments (such as staging and production).
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们将我们的应用添加到 Jenkins X 中，我们就探索了它是如何通过环境（如预发布和生产环境）实现 GitOps 流程的。
- en: Then we moved into the application development phase and explored how DevPods
    help us to set a personal application-specific environment that simplifies the
    “traditional” setup that forced us to spend countless hours setting it on our
    laptop and, at the same time, avoids the pitfalls of shared development environments.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们进入了应用开发阶段，并探讨了 DevPods 如何帮助我们设置一个个人专用的应用环境，这简化了“传统”的设置，迫使我们花费无数小时在笔记本电脑上设置它，同时，也避免了共享开发环境的陷阱。
- en: Once the development of a feature, a change, or a bug fix is finished, we created
    a pull request, we executed automatic validations, and we deployed the release
    candidate to a PR-specific preview environment so that we can check it manually
    as well. Once we were satisfied with the changes we made, we merged it to the
    master branch, and that resulted in deployment to the environments set to receive
    automatic promotions (such as staging) as well as in another round of testing.
    Now that we are comfortable with the changes we did, all that’s left is to promote
    our release to production.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦一个功能、变更或错误修复的开发完成，我们就创建了一个拉取请求，执行了自动验证，并将发布候选版本部署到了一个针对 PR 的特定预览环境中，以便我们可以手动检查它。一旦我们对所做的更改感到满意，我们就将其合并到主分支，这导致了部署到设置为接收自动推广的环境（如预发布环境）以及另一轮测试。现在，我们已经对我们的更改感到舒适，剩下要做的就是将我们的发布推广到生产环境。
- en: The critical thing to note is that promotion to production is not a technical
    decision. By the time we reach this last step in the software development life
    cycle, we should already know that the release is working as expected. We already
    gathered all the information we need to make a decision to go live. Therefore,
    the choice is business-related. “When do we want our users to see the new release?”
    We know that every release that passes all the steps of the pipeline is production-ready,
    but we do not know when to release it to our users. But, before we discuss when
    to release something to production, we should decide who does that. The actor
    will determine when is the right time. Does a person approve a pull request, or
    is it a machine?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的关键点是，将应用推广到生产并不是一个技术决策。当我们到达软件开发生命周期的最后一步时，我们应该已经知道发布是按预期工作的。我们已经收集了所有需要做出上线决策的信息。因此，这个选择与业务相关。“我们希望用户何时看到新版本？”我们知道每个通过管道所有步骤的发布都是生产就绪的，但我们不知道何时将其发布给用户。但是，在我们讨论何时将某个东西发布到生产之前，我们应该决定由谁来执行这个操作。执行者将决定何时是正确的时间。是一个人批准拉取请求，还是由机器来处理？
- en: Business, marketing, and management might be decision-makers in charge of promotion
    to production. In that case, we cannot initiate the process when the code is merged
    to the master branch (as with the staging environment), and that means that we
    need a mechanism to start the process manually through a command. If executing
    a command is too complicated and confusing, it should be trivial to add a button
    (we’ll explore that through the UI later). There can also be the case when no
    one makes a decision to promote something to production. Instead, we can promote
    each change to the master branch automatically. In both cases, the command that
    initiates the promotion is the same. The only difference is in the actor that
    executes it. Is it us (humans) or Jenkins X (machines)?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 商业、市场和管理工作可能是由负责将内容升级到生产环境的决策者。在这种情况下，我们不能在代码合并到主分支时（就像在预览环境中一样）启动这个过程，这意味着我们需要一个机制通过命令手动启动这个过程。如果执行命令过于复杂和令人困惑，添加一个按钮应该很简单（我们将在稍后通过
    UI 探索这一点）。也可能存在没有人决定将内容升级到生产环境的情况。相反，我们可以自动将每个更改升级到主分支。在这两种情况下，启动升级的命令是相同的。唯一的区别在于执行它的行为者。是我们（人类）还是
    Jenkins X（机器）？
- en: At the moment, our production environment is set to receive manual promotions.
    As such, we are employing continuous delivery that has the whole pipeline fully
    automated and requires a single manual action to promote a release to production.
    All that’s left is to click a button or, as is our case, to execute a single command.
    We could have added the step to promote production to `Jenkinsfile`, and in that
    case, we’d be practicing continuous deployment (not delivery). That would result
    in a deployment of every merge or push to the master branch. But, we aren’t practicing
    continuous deployment today, and we’ll stick with the current setup and jump into
    the last stage of continuous delivery. We’ll promote our latest release to production.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的生产环境设置为手动升级。因此，我们正在采用完全自动化的持续交付，只需要一个手动操作就可以将版本升级到生产环境。剩下要做的就是点击一个按钮，或者在我们这个案例中，执行一个单独的命令。我们本来可以将升级生产的步骤添加到
    `Jenkinsfile` 中，那样的话，我们就是在实践持续部署（而不是持续交付）。这将导致每次合并或推送到主分支时都会进行部署。但是，我们今天不实践持续部署，我们将坚持当前的设置，并跳到最后一个持续交付的阶段。我们将把我们的最新版本升级到生产环境。
- en: 10.3.2 Promoting a release to the production environment
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 将发布升级到生产环境
- en: 'Now that we feel that our new release is production-ready, we can promote it
    to production. But, before we do that, we’ll check whether we already have something
    running in production:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们觉得我们的新版本已经准备好投入生产，我们可以将其升级到生产环境。但在我们这样做之前，我们将检查是否已经在生产环境中运行了某些内容：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'How about staging? We must have the release of our `sample-app` application
    running there. Let’s double-check:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于预览环境呢？我们必须确保我们的 `sample-app` 应用程序的发布版本在那里运行。让我们再次检查：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For what we’re trying to do, the important piece of the information is the version
    displayed in the `STAGING` column.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们正在尝试做的事情，重要的信息是 `STAGING` 列中显示的版本。
- en: '![](Images/CH10_F07_Yuen.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH10_F07_Yuen.png)'
- en: Figure 10.7 The `jx` `promote` command will create a new branch in the production
    environment as well as deploy to preview. At the end of the command execution,
    the new release will be promoted to production.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 `jx` `promote` 命令将在生产环境中创建一个新的分支并部署到预览环境。在命令执行结束时，新版本将被升级到生产环境。
- en: 'Now we can promote the specific version of `sample-app` to the production environment:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将 `sample-app` 的特定版本升级到生产环境：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Before executing the command that follows, make sure to replace [...] with
    the version from the STAGING column from the output of the previous command.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在执行以下命令之前，请确保将 [...] 替换为上一个命令输出中的 `STAGING` 列中的版本。
- en: 'It’ll take a minute or two until the promotion process is finished. You can
    use the following command again to monitor the status:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 升级过程可能需要一分钟左右才能完成。您可以使用以下命令再次运行以监控状态：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The command we just executed will create a new branch in the production environment
    (environment-pisco-sour-production). Further on, it’ll follow the same practice
    based on pull requests as the one employed in anything else we did so far. It’ll
    create a pull request and wait until a Jenkins X build is finished and successful.
    You might see errors stating that it failed to query the pull request. That’s
    normal. The process is asynchronous, and `jx` is periodically querying the system
    until it receives the information that confirms that the pull request was processed
    successfully.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才执行的命令将在生产环境（environment-pisco-sour-production）中创建一个新的分支。接下来，它将遵循与之前所做任何事情相同的基于拉取请求的实践。它将创建一个拉取请求，并等待Jenkins
    X构建完成并成功。你可能会看到错误信息表明它无法查询拉取请求。这是正常的。该过程是异步的，`jx`会定期查询系统，直到收到确认拉取请求已成功处理的信
- en: Once the pull request is processed, it’ll be merged to the master branch, and
    that will initiate yet another Jenkins X build. It’ll run all the steps we defined
    in the repository’s `Jenkinsfile`. By default, those steps are only deploying
    the release to production, but we could have added additional validations in the
    form of integration or other types of tests. Once the build initiated by the merge
    to the master branch is finished, we’ll have the release running in production,
    and the final output will state that merge status checks all passed, so the promotion
    worked!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理完拉取请求，它将被合并到主分支，这将启动另一个Jenkins X构建。它将运行我们在仓库的`Jenkinsfile`中定义的所有步骤。默认情况下，这些步骤仅将发布版部署到生产环境，但我们可以添加额外的验证，例如集成或其他类型的测试。一旦合并到主分支的构建完成，我们将在生产环境中运行发布版，最终输出将表明合并状态检查全部通过，所以升级成功了！
- en: The process of manual promotion (production) is the same as the one we experienced
    through automated promotions (staging). The only difference is who executes promotions.
    Those that are automated are initiated by application pipelines pushing changes
    to Git. On the other hand, manual promotions are triggered by us (humans).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 手动推广（生产）的过程与我们在自动化推广（预发布）中经历的过程相同。唯一的区别是执行推广的人。自动化的推广是由应用程序管道将更改推送到Git中触发的。另一方面，手动推广是由我们（人类）触发的。
- en: 'Next, we’ll confirm that the release is indeed deployed to production by retrieving
    all the applications in that environment:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过检索该环境中所有应用程序来确认发布版确实已部署到生产环境：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In our case, the output states that there is only one application (`sample-app`)
    running in production and that the version is 0.0.1.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，输出状态表明生产环境中只有一个应用程序（`sample-app`）正在运行，并且版本号为0.0.1。
- en: 'To be on the safe side, we’ll send a request to the release of our application
    running in production:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，我们将向运行在生产环境中的应用程序的发布版发送请求：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Before executing the commands that follow, make sure to replace [...] with
    the URL column from the output of the previous command.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在执行以下命令之前，请确保将 [...] 替换为上一条命令输出的URL列。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Jenkins X defines the process, the selection of tools, and the glue that wraps
    everything into one cohesive unit that is easy to learn and use.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins X定义了过程、工具的选择以及将一切封装成一个易于学习和使用的统一单元的粘合剂。
- en: Prow provides GitHub automation in the form of policy enforcement and automatic
    PR merging.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prow以政策执行和自动PR合并的形式提供GitHub自动化。
- en: The pipeline operator is used to orchestrate and simplify definitions of our
    continuous delivery processes.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道操作员用于编排和简化我们持续交付过程的定义。
- en: Tekton is a Kubernetes-native open source framework for creating continuous
    integration and delivery (CI/CD) systems.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tekton是一个Kubernetes原生开源框架，用于创建持续集成和交付（CI/CD）系统。
- en: To import projects into Jenkins X, you just need to execute `jx` `import` which
    will add all the necessary files to your repo and create the pipelines and environments.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将项目导入Jenkins X，你只需执行`jx import`命令，它将为你的仓库添加所有必要的文件，并创建管道和环境。
- en: To promote release into production environments, you can simply execute the
    `jx` `promote` command, which will generate PR to add the new release, deploy
    to preview for testing, and promote (deploy) to production.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将发布版推广到生产环境，你可以简单地执行`jx promote`命令，该命令将生成PR以添加新发布版，部署到预览环境进行测试，并将（部署）到生产环境。
- en: '* * *'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1.[https://jenkins-x.io/](https://jenkins-x.io/).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 1.[https://jenkins-x.io/](https://jenkins-x.io/).
- en: 2.[https://www.cloudbees.com/](https://www.cloudbees.com/).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 2.[https://www.cloudbees.com/](https://www.cloudbees.com/).
- en: 3.[https://developer.github.com/webhooks/](https://developer.github.com/webhooks/).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 3.[https://developer.github.com/webhooks/](https://developer.github.com/webhooks/)
- en: 4.[https://github.com/kubernetes/test-infra/tree/master/prow](https://github.com/kubernetes/test-infra/tree/master/prow).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 4.[https://github.com/kubernetes/test-infra/tree/master/prow](https://github.com/kubernetes/test-infra/tree/master/prow)
- en: 5.[https://cloud.google.com/tekton](https://cloud.google.com/tekton).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 5.[https://cloud.google.com/tekton](https://cloud.google.com/tekton)
- en: 6.[https://jenkins-x.io/docs/reference/components/build-packs/](https://jenkins-x.io/docs/reference/components/build-packs/).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 6.[https://jenkins-x.io/docs/reference/components/build-packs/](https://jenkins-x.io/docs/reference/components/build-packs/)
- en: 7.[https://golang.org/](https://golang.org/).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 7.[https://golang.org/](https://golang.org/)
