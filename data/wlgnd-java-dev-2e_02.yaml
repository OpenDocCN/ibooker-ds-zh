- en: 1 Introducing modern Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 现代Java简介
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Java as a platform and a language
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java作为平台和语言
- en: The new Java release model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的Java发布模型
- en: Enhanced Type inference (var)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强类型推断（var）
- en: Incubating and preview features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 孵化和预览特性
- en: Changing the language
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改语言
- en: Small language changes in Java 11
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 11中的小语言变化
- en: Welcome to Java in 2022\. It is an exciting time. Java 17, the latest Long-Term-Support
    (LTS) release shipped in September 2021, and the first and most adventurous teams
    are starting to move to it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到2022年的Java。这是一个激动人心的时刻。Java 17，作为最新的长期支持（LTS）版本，于2021年9月发布，最早和最具冒险精神的团队开始转向它。
- en: At the time of writing, apart from a few trailblazers, Java applications are
    more or less evenly split between running on Java 11 (released September 2018)
    and the much older Java 8 (2014). Java 11 offers a lot to recommend, especially
    for teams that are deploying in the cloud, but some have been a little slow to
    adopt it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，除了少数先驱者外，Java应用程序在运行在Java 11（2018年9月发布）和远早的Java 8（2014年）之间大致均衡分布。Java
    11提供了很多值得推荐的地方，特别是对于在云中部署的团队来说，但有些人对它的采用速度有点慢。
- en: So, in the first part of this book, we are going to spend some time introducing
    some of the new features that have arrived in Java 11 and 17\. Hopefully, this
    discussion will help convince some teams and managers who may be reluctant to
    upgrade from Java 8 that things are better than ever in the newer versions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这本书的第一部分，我们将花一些时间介绍Java 11和17中出现的一些新特性。希望这次讨论能说服一些可能不愿意从Java 8升级的团队和经理们，新版本中的事物比以往任何时候都要好。
- en: Our focus for this chapter is going to be Java 11 because a) it’s the LTS version
    with the largest market share and b) no noticeable adoption of Java 17 has occurred
    yet. However, in chapter 3, we will introduce the new features in Java 17 to bring
    you all the way up to date.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章的重点将是Java 11，因为a)它是市场份额最大的LTS版本，b)目前还没有明显的Java 17采用。然而，在第3章中，我们将介绍Java 17的新特性，以便将您带到最新的版本。
- en: Let’s get underway by discussing the language-versus-platform duality that lies
    at the heart of modern Java. This is a critically important point that we’ll come
    back to several times throughout the book, so it’s essential to grasp it right
    at the start.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论现代Java核心的“语言-平台”二分法开始。这是一个至关重要的观点，我们将在本书的多个地方回到这一点，因此从一开始就掌握它是至关重要的。
- en: 1.1 The language and the platform
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 语言和平台
- en: '*Java* as a term can refer to one of several related concepts. In particular,
    it could mean either the human-readable programming language or the much broader
    “Java platform.”'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java*作为一个术语可以指代几个相关概念之一。特别是，它可能指的是人类可读的编程语言，或者是更广泛的“Java平台”。'
- en: Surprisingly, different authors sometimes give slightly different definitions
    of what constitutes a language and a platform. This can lead to a lack of clarity
    and some confusion about the differences between the two and about which provides
    the various programming features that application code uses.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，不同的作者有时会给出略微不同的定义，以确定构成语言和平台的内容。这可能导致对两者之间的差异以及哪个提供应用程序代码使用的各种编程功能缺乏清晰性，并产生一些混淆。
- en: 'Let’s make that distinction clear right now, because it cuts to the heart of
    a lot of the topics in this book. Here are our definitions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即明确这一点，因为它触及了本书中许多主题的核心。以下是我们的定义：
- en: '*The Java language*—The Java language is the statically typed, object-oriented
    language that we lightly lampooned in the “About this book” section. Hopefully,
    it’s already very familiar to you. One obvious point about source code written
    in the Java language is that it’s human-readable (or it should be!).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java语言*——Java语言是我们轻描淡写地讽刺过的静态类型、面向对象的编程语言。希望它已经非常熟悉了。关于用Java语言编写的源代码的一个明显观点是，它是人类可读的（或者应该是这样的！）。'
- en: '*The Java platform*—The platform is the software that provides a runtime environment.
    It’s the JVM that links and executes your code as provided to it in the form of
    (not human-readable) class files. It doesn’t directly interpret Java language
    source files but instead requires them to be converted to class files first.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java平台*——平台是提供运行时环境的软件。它是JVM，它将链接并执行以（非人类可读的）类文件形式提供给它的代码。它不直接解释Java语言源文件，而是要求它们首先转换为类文件。'
- en: One of the big reasons for the success of Java as a software system is that
    it’s a standard. This means that it has specifications that describe how it’s
    supposed to work. Standardization allows different vendors and project groups
    to produce implementations that should all, in theory, work the same way. The
    specs don’t make guarantees about how well different implementations will perform
    when handling the same task, but they can provide assurances about the correctness
    of the results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Java作为软件系统成功的一个主要原因是它是一个标准。这意味着它有描述其应该如何工作的规范。标准化允许不同的供应商和项目组产生实现，理论上它们都应该以相同的方式工作。规范并不保证不同实现处理相同任务时的性能如何，但它们可以提供关于结果正确性的保证。
- en: Several separate specs govern the Java system—the most important are the Java
    Language Specification (JLS) and the JVM Specification (VMSpec). This separation
    is taken very seriously in modern Java; in fact, the VMSpec no longer makes any
    reference whatsoever to the JLS directly. We’ll have a bit more to say about the
    differences between these two specs later in the book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 几个独立的规范管理着Java系统——其中最重要的是Java语言规范（JLS）和JVM规范（VMSpec）。在现代Java中，这种分离被非常认真地对待；事实上，VMSpec不再直接引用JLS。我们将在本书的后面部分更多地讨论这两个规范之间的差异。
- en: Note These days the JVM is actually quite a general-purpose and language-agnostic
    environment for running programs. This is one reason for the separation of the
    specs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如今，JVM实际上是一个相当通用的、与语言无关的运行程序的环境。这是规范分离的一个原因。
- en: One obvious question, when you’re faced with the described duality, is, “What’s
    the link between them?” If they’re now separate, how do they come together to
    make the Java system?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你面对所描述的双重性时，一个明显的问题就是，“它们之间的联系是什么？”如果它们现在是分开的，它们是如何结合在一起形成Java系统的？
- en: The link between the language and platform is the shared definition of the class
    file format (the .class files). A serious study of the class file definition will
    reward you (and we provide one in chapter 4)—in fact, it’s one of the ways a good
    Java programmer can start to become a great one. In figure 1.1, you can see the
    full process by which Java code is produced and used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 语言和平台之间的联系是共享的类文件格式定义（.class文件）。对类文件定义的深入研究会给你带来回报（我们将在第4章提供一份）——实际上，这是优秀Java程序员开始成为杰出程序员的一种方式。在图1.1中，你可以看到Java代码的产生和使用过程的完整流程。
- en: '![](../Images/CH01_F01_Evans2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F01_Evans2.png)'
- en: Figure 1.1 Java source code is transformed into .class files, then manipulated
    at load time before being JIT-compiled.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 Java源代码被转换成.class文件，然后在加载时进行操作，最后进行JIT编译。
- en: As you can see in the figure, Java code starts life as human-readable Java source,
    and it’s then compiled by `javac` into a .class file and loaded into a JVM. It’s
    common for classes to be manipulated and altered during the loading process. Many
    of the most popular Java frameworks transform classes as they’re loaded to inject
    dynamic behavior such as instrumentation or alternative lookups for classes to
    load.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，Java代码最初以人类可读的Java源代码形式存在，然后由`javac`编译成.class文件，并加载到JVM中。在加载过程中对类进行操作和修改是很常见的。许多流行的Java框架在加载类时会将其转换，以注入动态行为，例如代码插装或对要加载的类的替代查找。
- en: Note Class loading is an essential feature of the Java platform, and we will
    learn a lot more about it in chapter 4.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：类加载是Java平台的一个基本特性，我们将在第4章中了解更多关于它的内容。
- en: Is Java a compiled or interpreted language? The standard picture of Java is
    of a language that’s compiled into .class files before being run on a JVM. If
    pressed, many developers can also explain that bytecode starts off by being interpreted
    by the JVM but will undergo just-in-time (JIT) compilation at some later point.
    Here, however, many people’s understanding breaks down into a somewhat hazy conception
    of bytecode as basically being machine code for an imaginary or simplified CPU.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Java是编译型语言还是解释型语言？Java的标准形象是先编译成.class文件，然后在JVM上运行。如果被追问，许多开发者也可以解释说字节码最初是由JVM解释的，但会在某个后期点进行即时（JIT）编译。然而，在这里，许多人对于字节码的理解变得有些模糊，认为字节码基本上是针对一个想象中的或简化的CPU的机器代码。
- en: In fact, JVM bytecode is more like a halfway house between human-readable source
    and machine code. In the technical terms of compiler theory, bytecode is really
    a form of intermediate language (IL) rather than actual machine code. This means
    that the process of turning Java source into bytecode isn’t really compilation
    in the sense that a C++ or a Go programmer would understand it, and `javac` isn’t
    a compiler in the same sense as `gcc` is—it’s really a class file generator for
    Java source code. The real compiler in the Java ecosystem is the JIT compiler,
    as you can see in figure 1.1.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，JVM 字节码更像是人类可读源代码和机器代码之间的中间状态。在编译器理论的技术术语中，字节码实际上是一种中间语言（IL），而不是实际的机器代码。这意味着将
    Java 源代码转换为字节码的过程并不是像 C++ 或 Go 程序员理解的那种编译，`javac` 也不是像 `gcc` 那样的编译器——它实际上是为 Java
    源代码生成类文件的生成器。Java 生态系统中的真正编译器是 JIT 编译器，如图 1.1 所示。
- en: Some people describe the Java system as “dynamically compiled.” This emphasizes
    that the compilation that matters is the JIT compilation at runtime, not the creation
    of the class file during the build process.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人将 Java 系统描述为“动态编译”。这强调了真正重要的编译是在运行时的 JIT 编译，而不是在构建过程中的类文件创建。
- en: Note The existence of the source code compiler, `javac`, leads many developers
    to think of Java as a static, compiled language. One of the big secrets is that
    at runtime, the Java environment is actually very dynamic—it’s just hidden a bit
    below the surface.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：源代码编译器 `javac` 的存在让许多开发者认为 Java 是一种静态编译语言。一个巨大的秘密是，在运行时，Java 环境实际上非常动态——只是隐藏在表面之下一点。
- en: So, the real answer to “Is Java compiled or interpreted?” is “both.” With the
    distinction between language and platform now clearer, let’s move on to talk about
    the new Java release model.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，“Java 是编译还是解释？”的真正答案是“两者都是”。随着语言和平台之间的区别现在更加清晰，让我们继续谈谈新的 Java 发布模型。
- en: 1.2 The new Java release model
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 新的 Java 发布模型
- en: Java was not always an open source language, but following an announcement at
    the JavaOne conference in 2006, the source code for Java itself (minus a few bits
    that Sun didn’t own the source for) was released under the GPLv2+CE license ([https://openjdk.java.net/legal/gplv2+ce.html](https://openjdk.java.net/legal/gplv2+ce.html)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Java 并非一直是一个开源语言，但在 2006 年 JavaOne 大会上的一个公告之后，Java 本身的源代码（除了 Sun 没有源代码的几个部分）被发布在
    GPLv2+CE 许可证下 ([https://openjdk.java.net/legal/gplv2+ce.html](https://openjdk.java.net/legal/gplv2+ce.html))。
- en: This was around the time of the release of Java 6, so Java 7 was the first version
    of Java to be developed under an open source software (OSS) license. The primary
    focus for open source development of the Java platform since then has been the
    OpenJDK project ([https://openjdk.java.net](https://openjdk.java.net)), and that
    continues to this day.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这大约是在 Java 6 发布的时候，因此 Java 7 是第一个在开源软件（OSS）许可证下开发的 Java 版本。从那时起，Java 平台开源开发的主要重点是
    OpenJDK 项目 ([https://openjdk.java.net](https://openjdk.java.net))，并且这种情况一直持续到今天。
- en: A lot of the project discussion takes place on mailing lists that cover aspects
    of the overall codebase. There are “permanent” lists such as core-libs (core libraries),
    as well as more transient lists that are formed as part of specific OpenJDK projects
    such as lambda-dev (lambdas), which then become inactive when a particular project
    has been completed. In general, these lists have been the relevant forums for
    discussing possible future features, allowing developers from the wider community
    to participate in the process of producing new versions of Java.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分的项目讨论都在涵盖整体代码库方面的邮件列表上进行。有“永久性”列表，如 core-libs（核心库），以及更多短暂的列表，这些列表作为特定 OpenJDK
    项目（如 lambda-dev（lambda 表达式））的一部分形成，当特定项目完成后，这些列表就会变得不活跃。总的来说，这些列表一直是讨论可能未来功能的论坛，允许更广泛的社区的开发者参与到产生新的
    Java 版本的过程中。
- en: Note Sun Microsystems was acquired by Oracle shortly before Java 7 was released.
    Therefore, all of Oracle’s releases of Java have been based on the open source
    codebase.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Sun Microsystems 在 Java 7 发布前不久被 Oracle 收购。因此，Oracle 所有的 Java 发布版都是基于开源代码库的。
- en: The open source releases of Java had settled into a feature-driven release cycle,
    where a single marquee feature effectively defines the release (e.g., lambdas
    in Java 8 or modules in Java 9).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的开源发布已经形成了以功能驱动的发布周期，其中单个突出功能实际上定义了发布（例如，Java 8 中的 lambda 表达式或 Java 9 中的模块）。
- en: 'With the release of Java 9, however, the release model changed. From Java 10
    onward, Oracle decided that Java would be released on a strict, time-based model.
    This means that OpenJDK now uses a *mainline* development model, which includes
    the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着Java 9的发布，发布模式发生了变化。从Java 10开始，Oracle决定Java将按照严格的基于时间模型的发布。这意味着OpenJDK现在使用主线开发模型，包括以下内容：
- en: New features are developed on a branch and merged only when they are code complete.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新特性是在分支上开发的，只有当它们代码完成时才会合并。
- en: Releases can occur on a strict time cadence.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布可以在严格的时间周期内进行。
- en: Late features do not delay releases but are held over for the next release.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 晚期特性不会延迟发布，但会留到下一个版本。
- en: The current head of the trunk should always be releasable (in theory).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树干当前的头应该始终是可释放的（从理论上讲）。
- en: If necessary, an emergency fix can be prepared and pushed out at any point.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有必要，可以在任何时间点准备和推出紧急修复。
- en: Separate OpenJDK projects are used to explore and research longer-term, future
    directions.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用独立的OpenJDK项目来探索和研究长期、未来的方向。
- en: A new version of Java is released every six months (“feature releases”). The
    various providers (Oracle, Eclipse Adoptium, Amazon, Azul, et al.) can choose
    to make *any* of those releases a Long-Term Support (LTS) release. However, in
    practice, all of the vendors follow having one release every three years being
    named as the LTS release.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每隔六个月就会发布一个新的Java版本（“功能发布”）。各种提供商（Oracle、Eclipse Adoptium、Amazon、Azul等）可以选择将其中任何一个版本作为长期支持（LTS）版本。然而，在实践中，所有供应商都遵循每三年发布一个LTS版本的策略。
- en: Note As of late 2021, discussions are underway to reduce the LTS gap from three
    years to two years. We may well see the next LTS version as Java 21 in 2023 as
    opposed to Java 23 in 2024.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：截至2021年底，正在讨论将LTS间隔从三年缩短到两年。我们可能会在2023年看到下一个LTS版本Java 21，而不是在2024年的Java 23。
- en: The first LTS release was Java 11, with Java 8 retrospectively included in the
    set of LTS releases. Oracle’s intention was for the Java community to upgrade
    regularly and to take up the feature releases as they emerge. However, in practice,
    the community (and enterprise customers in particular) have proved to be resistant
    to this model, preferring instead to upgrade from one LTS release to the next.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个LTS版本是Java 11，Java 8被回顾性地包含在LTS版本集中。Oracle的意图是Java社区定期升级，并随着新特性的出现而采用它们。然而，在实践中，社区（尤其是企业客户）已经证明对这个模型持抵制态度，更愿意从一个LTS版本升级到下一个版本。
- en: This approach, of course, limits the uptake of new Java features and stifles
    innovation. However, the realities of enterprise software are what they are, and
    many people still view an upgrade of the Java version as a significant undertaking.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种方法限制了新Java特性的采用并抑制了创新。然而，企业软件的现实就是这样，许多人仍然将Java版本的升级视为一项重大任务。
- en: '![](../Images/CH01_F02_Evans2.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F02_Evans2.png)'
- en: Figure 1.2 The timescale of recent and future releases
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 近期和未来发布的时序
- en: This means that whereas the release road map shown in figure 1.2 contains a
    major release every six months, the only releases that have significant usage
    are the LTS versions—Java 17 (which was just released in September 2021), Java
    11 (which was released in September 2018), and the pre-modules release, Java 8,
    which is more than seven years old. Java 8 and Java 11 have roughly equal market
    share, with Java 11 recently having taken over 50% and rapidly accelerating. Java
    17 adoption is expected to be much quicker than the move from Java 8 to Java 11
    because the most difficult hurdles introduced by the module system and security
    restrictions will have already been overcome with the earlier migration.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，虽然图1.2所示的发布路线图每六个月有一个主要版本，但只有LTS版本具有显著的使用率——Java 17（刚刚在2021年9月发布），Java
    11（在2018年9月发布），以及超过七年的预模块版本Java 8。Java 8和Java 11的市场份额大致相等，Java 11最近已经占据了50%以上，并且正在迅速增长。预计Java
    17的采用速度将比从Java 8迁移到Java 11的速度快得多，因为早期迁移中引入的最困难的路障和安全性限制已经克服。
- en: 'The other significant change in the new release model is that Oracle has changed
    the license for their distribution. Although Oracle’s JDK is built from the OpenJDK
    sources, the binary is not licensed under an OSS license. Instead, Oracle’s JDK
    is proprietary software, and as of JDK 11, Oracle provides support and updates
    for only six months for each version. This means that many people who relied on
    Oracle’s free updates are now faced with a choice:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 新发布模型中的另一个重大变化是，Oracle更改了其分发的许可证。尽管Oracle的JDK是从OpenJDK源构建的，但二进制文件不是在OSS许可证下许可的。相反，Oracle的JDK是专有软件，并且从JDK
    11开始，Oracle为每个版本提供为期六个月的支持和更新。这意味着许多依赖Oracle免费更新的人现在面临着一个选择：
- en: Pay Oracle for support and updates, or
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为支持和服务向Oracle付费，或
- en: Use a different distribution that produces open source binaries.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用产生开源二进制文件的不同发行版。
- en: Alternative JDK vendors include Eclipse Adoptium (previously AdoptOpenJDK),
    Alibaba (Dragonwell), Amazon (Corretto), Azul Systems (Zulu), IBM, Microsoft,
    Red Hat, and SAP.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 替代JDK供应商包括Eclipse Adoptium（以前称为AdoptOpenJDK）、阿里巴巴（Dragonwell）、亚马逊（Corretto）、Azul
    Systems（Zulu）、IBM、Microsoft、Red Hat和SAP。
- en: Note Two of the authors (Martijn and Ben) helped found the AdoptOpenJDK project,
    which has evolved into the vendor-neutral Eclipse Adoptium community project to
    build and release a high-quality, free, and open source Java binary distribution.
    See [adoptium.net](https://adoptium.net/) for more details.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：两位作者（Martijn和Ben）帮助创立了AdoptOpenJDK项目，该项目已发展成为构建和发布高质量、免费和开源Java二进制分发的供应商中立Eclipse
    Adoptium社区项目。有关更多详细信息，请参阅[adoptium.net](https://adoptium.net/)。
- en: With the licensing changes and with so many providers, picking the correct Java
    for you and your team is a choice that you should make with care. Thankfully,
    leaders in the Java ecosystem have written some very detailed guides, and appendix
    A distills them down for you.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于许可证变更和如此多的提供商，为您和您的团队选择正确的Java是一个需要谨慎做出的选择。幸运的是，Java生态系统中的领导者已经编写了一些非常详细的指南，附录A为您总结了这些指南。
- en: 'Although the Java release model has changed to use timed releases, the vast
    majority of teams are still running on either JDK 8 or 11\. These LTS releases
    are being maintained by the community (including major vendors) and still receive
    regular security updates and bug fixes. The changes made to the LTS versions are
    deliberately small in scope and are “housekeeping updates.” Apart from security
    and small bug fixes, only a minimal set of changes are permitted. These include
    fixes needed to ensure that the LTS releases will continue to work correctly for
    their expected lifetime. This includes things like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Java发布模型已经改为使用定时发布，但绝大多数团队仍在使用JDK 8或11。这些长期支持（LTS）版本由社区（包括主要供应商）维护，并且仍然会定期接收安全更新和错误修复。对LTS版本所做的更改故意范围较小，是“维护更新”。除了安全和小的错误修复外，只允许进行最小限度的更改。这些包括确保LTS版本在其预期使用寿命内继续正确工作的必要修复。这包括以下内容：
- en: The addition of the new Japanese Era
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新增日本时代
- en: Time zone database updates
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时区数据库更新
- en: TLS 1.3
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLS 1.3
- en: Adding Shenandoah, a low-pause GC for large modern workloads
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加Shenandoah，适用于大型现代工作负载的低暂停垃圾回收器
- en: One other necessary change is that the build scripts for macOS needed to be
    updated to work with a recent version of Apple’s Xcode tool so that they will
    continue to work on new releases of Apple’s operating system.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个必要的更改是，macOS的构建脚本需要更新以与苹果最近版本的Xcode工具兼容，以便它们可以在苹果操作系统的最新版本上继续工作。
- en: Within the projects to maintain JDK 8 and 11 (sometimes called the “updates”
    projects), some potential scope still exists for new features to be backported,
    but it is minimal. As an example, one of the guiding rules is that newly ported
    features may not change program semantics. Examples of permissible changes could
    include the support for TLS 1.3 or the backport of Java Flight Recorder to Java
    8u272.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在维护JDK 8和11的项目（有时称为“更新”项目）中，仍然存在一些空间可以回滚新功能，但这个空间非常小。例如，一个指导原则是，新移植的功能不得改变程序语义。允许的更改示例可能包括对TLS
    1.3的支持或将Java Flight Recorder回滚到Java 8u272。
- en: Now that we’ve set the scene by clarifying the difference between the language
    and platform and explaining the new release model, let’s meet our first technical
    feature of modern Java. The new feature we’re going to meet is something that
    developers have been asking for since almost the first release of Java—a way to
    reduce the amount of typing that writing Java programs seems to involve.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过阐明语言和平台之间的区别以及解释新的发布模型来设定了场景，让我们来认识现代Java的第一个技术特性。我们将要遇到的新特性是自从Java的第一个版本发布以来开发者一直要求的功能——减少编写Java程序所需输入量的方法。
- en: 1.3 Enhanced type inference (var keyword)
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 增强类型推断（var关键字）
- en: Java has historically had a reputation as a verbose language. However, in recent
    versions, the language has evolved to make more and more use of *type inference*.
    This feature of the source code compiler enables the compiler to work out some
    of the type information in programs automatically. As a result, it doesn’t need
    to be told everything explicitly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Java在历史上一直以冗长著称。然而，在最近的版本中，语言已经发展，越来越多地使用*类型推断*。这个源代码编译器的特性使得编译器能够自动处理程序中的一些类型信息。因此，不需要显式地告诉所有信息。
- en: Note The aim of type inference is to reduce boilerplate content, remove duplication,
    and allow for more concise and readable code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：类型推断的目的是减少样板内容，消除重复，并允许代码更加简洁易读。
- en: 'This trend started with Java 5, when generic methods were introduced. Generic
    methods permit a very limited form of type inference of generic type arguments,
    so that instead of having to explicitly provide the exact type that is needed,
    like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种趋势始于Java 5，当时引入了泛型方法。泛型方法允许对泛型类型参数进行非常有限的形式的类型推断，因此，不需要显式提供所需的精确类型，如下所示：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'the generic type parameter can be omitted on the right-hand side, like so:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型参数可以在右侧省略，如下所示：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This way of writing a call to a generic method is so familiar that many developers
    will struggle to remember the form with explicit type arguments. This is a good
    thing—it means the type inference is doing its job and removing the superfluous
    boilerplate content so that the meaning of the code is clear.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式编写泛型方法的调用如此熟悉，以至于许多开发者会努力记住带有显式类型参数的形式。这是一个好事——这意味着类型推断正在做它的工作，移除多余的样板内容，从而使代码的意义清晰。
- en: 'The next significant enhancement to type inference in Java came with version
    7, which introduced a change when dealing with generics. Before Java 7, it was
    common to see code like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Java类型推断的下一个重大增强是在Java 7版本中实现的，它引入了处理泛型时的一个变化。在Java 7之前，常见的代码如下：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That is a really verbose way to declare that you have some users, whom you identify
    by `userid` (which is an integer), and each user has a set of properties (modeled
    as a map of string to strings) specific to that user.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常冗长的声明方式，表明你有一些用户，你通过`userid`（这是一个整数）来识别他们，每个用户都有一个特定的属性集（建模为字符串到字符串的映射），这些属性属于该用户。
- en: In fact, almost half of the source is duplicated characters, and they don’t
    tell us anything. So, from Java 7 onward, we can write
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，源代码中几乎有一半是重复的字符，它们并没有告诉我们任何信息。因此，从Java 7开始，我们可以这样写
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: and have the compiler work out the type information on the right side. The compiler
    is working out the correct type for the expression on the right side— it isn’t
    just substituting the text that defines the full type.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 并让编译器在右侧确定类型信息。编译器正在确定右侧表达式的正确类型——它不仅仅是替换定义完整类型的文本。
- en: Note Because the shortened type declaration looks like a diamond, this form
    is called “diamond syntax.”
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于简化的类型声明看起来像菱形，这种形式被称为“菱形语法”。
- en: 'In Java 8, more type inference was added to support the introduction of lambda
    expressions, like this example where the type inference algorithm can conclude
    that the type of `s` is a `String`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，为了支持lambda表达式的引入，增加了更多的类型推断功能，例如这个例子中类型推断算法可以推断出`s`的类型是`String`：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In modern Java, type inference has been taken one step further, with the arrival
    of *Local Variable Type Inference* (LVTI), otherwise known as `var`. This feature
    was added in Java 10 and allows the developer to infer the types of *variables*,
    instead of the types of *values*, like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Java中，随着*局部变量类型推断*（LVTI）的引入，也称为`var`，类型推断又前进了一步。这个特性是在Java 10中添加的，允许开发者推断*变量*的类型，而不是*值*的类型，如下所示：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is implemented by making `var` a reserved, “magic” type name rather than
    a language keyword. Developers can still in theory use `var` as the name of a
    variable, method, or package.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过将 `var` 实现为一个保留的、“魔法”类型名称而不是语言关键字来实现的。理论上，开发者仍然可以使用 `var` 作为变量、方法或包的名称。
- en: Note An important side effect of using `var` appropriately is that the domain
    of your code is once more front and center (as opposed to the type information).
    But with great power comes great responsibility! Make sure that you name your
    variables carefully to help future readers of your code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：适当地使用 `var` 的重要副作用是，你的代码域再次成为焦点（与类型信息相反）。但是，权力越大，责任越大！请确保你仔细命名变量，以帮助未来的代码阅读者。
- en: On the other hand, code that previously used `var` as the name of a type will
    have to be recompiled. However, virtually all Java developers follow the convention
    that type names should start with a capital letter, so the number of instances
    of preexisting types called `var` should be vanishing small. This means that it
    is entirely legal to write code like that shown in the next listing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，之前使用 `var` 作为类型名称的代码将需要重新编译。然而，几乎所有的 Java 开发者都遵循一个约定，即类型名称应该以大写字母开头，因此被称为
    `var` 的现有类型实例数量应该非常少。这意味着编写类似下一列表中所示代码是完全合法的。
- en: Listing 1.1 Bad code
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.1 恶劣的代码
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And then call it like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以这样调用它：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, just because something is *legal*, does not mean it is *sensible*.
    Writing code like the previous listing is not going to make you any friends and
    should not pass code reviews!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅因为某件事是 *合法的*，并不意味着它是 *合理的*。编写类似前述列表中的代码不会让你赢得任何朋友，并且不应该通过代码审查！
- en: The intention of `var` is to reduce verbosity in Java code and to be familiar
    to programmers coming to Java from other languages. It does not introduce dynamic
    typing, and all Java variables continue to have static types at all times—you
    just don’t need to write them down explicitly in all cases.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 的目的是减少 Java 代码的冗长性，并使从其他语言转向 Java 的程序员感到熟悉。它不引入动态类型，Java 中的所有变量在所有时候都继续具有静态类型——你只是不需要在所有情况下都明确写出它们。'
- en: Type inference in Java is *local*, and in the case of `var`, the algorithm examines
    only the declaration of the local variable. This means it cannot be used for fields,
    method arguments, or return types. The compiler applies a form of *constraint
    solving* to determine whether any type exists that could satisfy all the requirements
    of the code as written.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的类型推断是 *局部的*，在 `var` 的情况下，算法仅检查局部变量的声明。这意味着它不能用于字段、方法参数或返回类型。编译器应用一种 *约束求解*
    形式来确定是否存在任何类型可以满足代码中所有要求。
- en: Note `var` is implemented solely in the source code compiler (`javac`) and has
    no runtime or performance effect whatsoever.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`var` 仅在源代码编译器（`javac`）中实现，并且没有任何运行时或性能影响。
- en: For example, in the declaration of `lengthFn` in the previous code sample, the
    constraint solver can deduce that the type of the method parameter `s` must be
    compatible with `String` which is explicitly provided as the type of the parameter
    to `Function`. In Java, of course, the string type is `final`, so the compiler
    can conclude that the type of `s` is exactly `String`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上一个代码示例中 `lengthFn` 的声明中，约束求解器可以推断出方法参数 `s` 的类型必须与 `String` 兼容，这是作为 `Function`
    参数的类型显式提供的。当然，在 Java 中，字符串类型是 `final` 的，因此编译器可以得出结论，`s` 的类型正好是 `String`。
- en: For the compiler to be able to infer types, enough information must be provided
    by the programmer to allow the constraint equations to be solved. For example,
    code like this
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让编译器能够推断类型，程序员必须提供足够的信息，以便解决约束方程。例如，这样的代码
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: does not have enough type information for the compiler to deduce the type of
    `fn`, and so it will not compile. One important case of this is
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有提供足够的信息供编译器推断 `fn` 的类型，因此它将无法编译。这种情况的一个重要例子是
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: which cannot be resolved by the compiler because the null value can be assigned
    to a variable of any reference type, so there is no information about what types
    `n` could conceivably be. We say that the type constraint equations that the inferencer
    needs to solve are “underdetermined” in this case—a mathematical term that connects
    the number of equations to be solved with the number of variables.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这不能被编译器解决，因为空值可以被分配给任何引用类型的变量，因此没有关于 `n` 可能是什么类型的信息。我们说在这种情况下，推断器需要解决的类型约束方程是“欠确定的”——这是一个数学术语，它将需要解决的方程数量与变量的数量联系起来。
- en: 'You could imagine a scheme of type inference that goes beyond just the initial
    declaration of the local variable and examines more code to make inference decisions,
    like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象一种类型推断方案，它不仅限于局部变量的初始声明，还会检查更多代码以做出推断决策，如下所示：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A more complex inference algorithm (or a human) might be able to conclude that
    the type of `n` is actually `String`, because the `format()` method takes a string
    as the first argument.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的推断算法（或人类）可能能够得出结论，`n`的类型实际上是`String`，因为`format()`方法接受字符串作为第一个参数。
- en: This might seem appealing, but, as with everything else in software, it represents
    a trade-off. More complexity means longer compilation times and a wider variety
    of ways in which the inference can fail. This, in turn, means that the programmer
    must develop a more complicated intuition to use nonlocal type inference correctly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很有吸引力，但，就像软件中的其他一切一样，它代表了一种权衡。更多的复杂性意味着更长的编译时间和更多推断可能失败的方式。这反过来意味着程序员必须发展出更复杂的直觉，才能正确地使用非局部类型推断。
- en: 'Other languages may choose to make different trade-offs, but Java is clear:
    only the declaration is used to infer types. Local variable type inference is
    intended to be a beneficial technique to reduce boilerplate text and verbosity.
    However, it should be used only where necessary to make the code clearer, not
    as a blunt instrument to be used whenever possible (the “Golden Hammer” antipattern).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言可能会选择做出不同的权衡，但Java很明确：只有声明被用来推断类型。局部变量类型推断旨在是一种有益的技术，可以减少样板文本和冗余。然而，它只应在必要时使用，以使代码更清晰，而不是作为一种在任何可能的情况下都可以使用的钝工具（“黄金锤”反模式）。
- en: 'Some quick guidelines for when to use LVTI follow:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于何时使用LVTI的快速指南：
- en: In simple initializers, if the right-hand side is a call to a constructor or
    static factory method
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在简单的初始化器中，如果右侧是构造函数或静态工厂方法的调用
- en: If removing the explicit type deletes repeated or redundant information
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果删除显式类型可以删除重复或冗余信息
- en: If variables have names that already indicate their types
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果变量名已经表明了它们的类型
- en: If the scope and usage of the local variable is short and simple
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果局部变量的作用域和用途简短且简单
- en: A complete set of applicable rules of thumb is provided by Stuart Marks, one
    of the core developers of the Java language, in his style guides for LVTI usage
    at [http://mng.bz/RvPK](http://mng.bz/RvPK).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Java语言的核心开发者之一Stuart Marks在他的LVTI使用风格指南中提供了一套完整的适用规则，可以在[http://mng.bz/RvPK](http://mng.bz/RvPK)找到。
- en: 'To conclude this section, let’s look at another, more advanced, usage of `var`—the
    so-called *nondenotable types*. These are types that are legal in Java, but they
    cannot appear as the type of a variable. Instead, they must be inferred as the
    type of the expression that is being assigned. Let’s look at a simple example
    using the `jshell` interactive environment, which arrived in Java 9:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本节，让我们看看`var`的另一种更高级的使用——所谓的*不可表示的类型*。这些类型在Java中是合法的，但不能作为变量的类型出现。相反，它们必须被推断为被分配的表达式的类型。让我们通过使用Java
    9中引入的`jshell`交互式环境来举一个简单的例子：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The variable `duck` has an unusual type—it is effectively `Object` but extended
    with a method called `quack()`. Although the object may quack like a duck, its
    type lacks a name, so we can’t use the type as either a method parameter or return
    type.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`duck`有一个不寻常的类型——它实际上是`Object`，但扩展了一个名为`quack()`的方法。尽管这个对象可能像鸭子一样嘎嘎叫，但它的类型没有名称，所以我们不能将其用作方法参数或返回类型。
- en: With LVTI, we can use it as the inferred type of a local variable. This allows
    us to use the type within a method. Of course, the type can’t be used outside
    of this tight local scope, so the overall utility of this language feature is
    limited. It’s more of a curiosity than anything else.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LVTI，我们可以将其用作局部变量的推断类型。这允许我们在方法中使用该类型。当然，该类型不能在紧密的局部作用域之外使用，因此这种语言特性的整体效用有限。它更多的是一种好奇心，而不是其他。
- en: Despite these limitations, this does represent a glimpse at Java’s take on a
    feature that is present in some other languages—sometimes referred to as *structural
    typing* in statically typed languages and *duck typing* in dynamically typed languages
    (particularly Python).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些限制，这确实代表了Java对某些其他语言中存在的特性的看法——在静态类型语言中有时被称为*结构化类型*，在动态类型语言（尤其是Python）中称为*鸭子类型*。
- en: 1.4 Changing the language and the platform
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 更改语言和平台
- en: We think it’s essential to explain the “why” of language change as well as the
    “what.” During the development of new versions of Java, much interest around new
    language features often exists, but the community doesn’t always understand how
    much work is required to get changes fully engineered and ready for prime time.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为解释语言变化的“为什么”和“是什么”同样重要。在Java新版本的开发过程中，对新语言特性的兴趣通常很大，但社区并不总是理解要完全工程化并准备好投入使用的更改需要多少工作量。
- en: You may also have noticed that in a mature runtime such as Java, language features
    tend to evolve from other languages or libraries, make their way into popular
    frameworks, and only then get added to the language or runtime itself. We hope
    to shed a bit of light on this area and hopefully dispel a few myths along the
    way. But if you’re not very interested in how Java evolves, feel free to skip
    ahead to section 1.5 and jump right into the language changes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到，在成熟的运行时环境如Java中，语言特性往往是从其他语言或库中演变而来，进入流行的框架，然后才被添加到语言或运行时本身。我们希望在这个领域提供一些启示，并希望在这个过程中消除一些误解。但如果你对Java的演变不太感兴趣，可以自由地跳到1.5节，直接进入语言变化的讨论。
- en: There is an effort curve involved in changing the Java language—some possible
    implementations require less engineering effort than others. In figure 1.3, we’ve
    tried to represent the different routes and show the relative effort required
    for each.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改Java语言的过程中存在一个工作量曲线——一些可能的实现方式比其他方式需要更少的工程工作量。在图1.3中，我们试图表示不同的路径，并展示每个路径所需的相对工作量。
- en: '![](../Images/CH01_F03_Evans2.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F03_Evans2.png)'
- en: Figure 1.3 The relative effort involved in implementing new functionality in
    different ways
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 以不同方式实现新功能所涉及的相对工作量
- en: 'In general, it’s better to take the route that requires the least effort. This
    means that if it’s possible to implement a new feature as a library, you generally
    should. But not all features are easy, or even possible, to implement in a library
    or an IDE capability. Some features have to be implemented deeper inside the platform.
    Here’s how some recent features fit into our complexity scale for new language
    features:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，选择最省力的路线更好。这意味着如果可能的话，将新特性作为库来实现，你通常应该这样做。但并非所有特性都容易实现，或者甚至可能通过库或IDE功能来实现。一些特性必须在平台内部更深处实现。以下是一些最近特性如何适应我们新语言特性复杂度尺度的例子：
- en: '*Library change*—Collections factory methods (Java 9)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*库更改*—Collections工厂方法（Java 9）'
- en: '*Syntactic sugar*—Underscores in numbers (Java 7)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*语法糖*—数字中的下划线（Java 7）'
- en: '*Small new language feature*—try-with-resources (Java 7)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*小型新语言特性*—try-with-resources（Java 7）'
- en: '*Class file format change*—Annotations (Java 5)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类文件格式更改*—注解（Java 5）'
- en: '*New JVM feature*—Nestmates (Java 11)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*新的JVM特性*—Nestmates（Java 11）'
- en: '*Major new feature*—Lambda Expressions (Java 8)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主要新特性*—Lambda表达式（Java 8）'
- en: Let’s take a close look at how changes across the complexity scale are made.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看如何在复杂度尺度上做出变化。
- en: 1.4.1 Sprinkling some sugar
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.1 撒上一些糖
- en: A phrase that’s sometimes used to describe a language feature is “syntactic
    sugar.” That is, the syntactic sugar form is provided because it’s easier for
    humans to work with despite the functionality already existing in the language.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有时用来描述语言特性的短语是“语法糖”。也就是说，提供语法糖形式是因为它对人类来说更容易操作，尽管语言中已经存在该功能。
- en: As a rule of thumb, a feature referred to as syntactic sugar is removed from
    the compiler’s representation of the program early in the compilation process—it’s
    said to have been “desugared” into the basic representation of the same feature.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，被称为语法糖的特性在编译过程的早期就被从编译器对程序的表示中移除——它被说成是“去糖化”成了相同特性的基本表示。
- en: This makes syntactic sugar changes to a language easier to implement because
    they usually involve a relatively small amount of work and only involve changes
    to the compiler (`javac` in the case of Java).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得对语言进行语法糖（syntactic sugar）的更改更容易实现，因为它们通常涉及相对较少的工作量，并且仅涉及对编译器（在Java的情况下是`javac`）的更改。
- en: One question that might well be asked at this point is, “What constitutes a
    small change to the spec?” One of the most straightforward changes in Java 7 consisted
    of adding a single word—”String”—to section 14.11 of the JLS, which allowed strings
    in a switch statement. You can’t really get much smaller than that as a change,
    and yet even this change touches several other aspects of the spec. Any alteration
    produces consequences, and these have to be chased through the entire design of
    the language.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段可能会提出的一个问题是，“什么构成了对规范的微小更改？”Java 7 中最直接的一个更改是在 JLS 的第 14.11 节中添加了一个单词——“String”，这使得在
    switch 语句中可以使用字符串。作为一个更改，你实际上无法做得更小，然而即使是这个更改也触及了规范的几个其他方面。任何变更都会产生后果，并且这些后果必须在整个语言设计中追踪。
- en: 1.4.2 Changing the language
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.2 更改语言
- en: 'The full set of actions that must be performed (or at least investigated) for
    *any* change follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 必须执行（或至少调查）的完整操作集（或至少是任何更改）如下：
- en: Update the JLS.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 JLS。
- en: Implement a prototype in the source compiler.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源编译器中实现原型。
- en: Add library support essential for the change.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加对更改至关重要的库支持。
- en: Write tests and examples.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试和示例。
- en: Update documentation.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新文档。
- en: 'In addition, if the change touches the JVM or platform aspects, the following
    actions must occur:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果更改触及 JVM 或平台方面，必须执行以下操作：
- en: Update the VMSpec.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 VMSpec。
- en: Implement the JVM changes.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施 JVM 变更。
- en: Add support in the class file and JVM tools.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类文件和 JVM 工具中添加支持。
- en: Consider the impact on reflection.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑对反射的影响。
- en: Consider the impact on serialization.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑对序列化的影响。
- en: Think about any effects on native code components, such as Java Native Interface
    (JNI).
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑对原生代码组件（如 Java 原生接口（JNI））的影响。
- en: This isn’t a small amount of work, and that’s after the impact of the change
    across the whole language spec has been considered!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一项小工作量，而且在考虑了整个语言规范中更改的影响之后！
- en: An area of hairiness, when it comes to making changes, is the type system. That
    isn’t because Java’s type system is terrible. Instead, languages with rich static
    type systems are likely to have a lot of possible interaction points between different
    bits of those type systems. Making changes to them is prone to creating unexpected
    surprises.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行更改时，类型系统是一个棘手的问题区域。这并不是因为 Java 的类型系统很糟糕。相反，具有丰富静态类型系统的语言很可能在其类型系统的不同部分之间有许多可能的交互点。对这些交互点进行更改很容易产生意外的惊喜。
- en: 1.4.3 JSRs and JEPs
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.3 JSRs 和 JEPs
- en: Two main mechanisms are used to make changes to the Java platform. The first
    is the *Java Specification Request* (JSR), which is specified by the *Java Community
    Process* (JCP). This is used to determine standard APIs—both external libraries
    and major internal platform APIs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 用于更改 Java 平台的两个主要机制是 *Java 规范请求*（JSR），由 *Java 社区进程*（JCP）指定。这用于确定标准 API——既包括外部库也包括主要内部平台
    API。
- en: This was historically the only way of making changes to the Java platform and
    was best used to codify a consensus of already mature technology. However, in
    recent years, a desire to implement change faster (and in smaller units) led to
    the development of the *JDK Enhancement Proposal* (JEP) as a lighter-weight alternative.
    Platform (aka umbrella) JSRs are now made up of JEPs targeted for the next version
    of Java. The JSR process is used to grant extra intellectual property protections
    for the whole ecosystem.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这在历史上是更改 Java 平台的唯一方式，并且最好用于将已经成熟的技术的共识编码化。然而，在近年来，为了更快（并且以更小的单元）实施更改，导致了 *JDK
    增强提案*（JEP）作为一种更轻量级的替代方案的开发。平台（也称为伞状）JSR 现在由针对下一个 Java 版本的 JEP 组成。JSR 流程用于为整个生态系统提供额外的知识产权保护。
- en: When discussing new Java features, it is often useful to refer to an upcoming
    or recent feature by its JEP number. A complete list of all JEPs, including those
    that have been delivered or withdrawn, can be found at [https://openjdk.java.net/jeps/0](https://openjdk.java.net/jeps/0).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论新的 Java 功能时，通常很有用通过其 JEP 编号来引用即将推出或最近的功能。所有 JEP 的完整列表，包括已交付或撤回的，可以在 [https://openjdk.java.net/jeps/0](https://openjdk.java.net/jeps/0)
    找到。
- en: 1.4.4 Incubating and preview features
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.4 孵化和预览功能
- en: Within the new release model, Java has two mechanisms for trying out a proposed
    feature before finalizing it in a later release. The aim of these mechanisms is
    to provide better features by gathering feedback from a much wider pool of users
    and potentially changing or withdrawing the feature before it becomes a permanent
    part of Java.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的发布模型中，Java在最终确定功能之前，在后续版本中尝试一个提议的功能有两种机制。这些机制的目标是通过从更广泛的用户群体收集反馈，以及在它成为Java永久部分之前可能更改或撤回功能，来提供更好的功能。
- en: '*Incubating features* are new APIs and their implementation, which in their
    simplest form are effectively just a new API shipped as a self-contained module
    (we will meet the details of Java modules in chapter 2). The name of the module
    is chosen so that it makes it clear that the API is temporary and will change
    when the feature is finalized.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*孵化功能*是新API及其实现，它们在 simplest 形式下实际上只是作为一个自包含模块发布的新的API（我们将在第2章中遇到Java模块的详细信息）。模块的命名是为了使其清楚表明该API是临时的，并且将在功能最终确定时发生变化。'
- en: Note This means that any code that relies upon a nonfinalized version of an
    incubating feature will have to make changes when the feature becomes final.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这意味着任何依赖于孵化功能非最终版本的代码，在功能最终确定时将不得不进行更改。
- en: One very visible example of an incubating feature is the new support for version
    2 of the HTTP protocol, usually referred to as HTTP/2\. In Java 9, this was shipped
    as the incubator module `jdk.incubator.http`. The naming of this module, and the
    use of the `jdk.incubator` namespace rather than `java` clearly marked the feature
    as nonstandard and subject to change. The feature was standardized in Java 11
    when it was moved to the `java.net.http` module in the `java` part of the namespace.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 孵化功能的一个非常明显的例子是对HTTP协议第2版的新支持，通常称为HTTP/2。在Java 9中，它作为孵化器模块`jdk.incubator.http`发布。该模块的命名以及使用`jdk.incubator`命名空间而不是`java`命名空间，清楚地表明该功能是非标准的，并且将在功能最终确定时发生变化。该功能在Java
    11中标准化，当时它被移动到命名空间`java`部分的`java.net.http`模块中。
- en: Note We will meet another incubating feature in chapter 18 when we discuss the
    Foreign Access API, which is part of an OpenJDK project codenamed Panama.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当我们讨论Foreign Access API时，我们将在第18章遇到另一个孵化功能，它是OpenJDK项目中一个名为Panama的项目的一部分。
- en: The main advantage of this approach is that an incubating feature can be isolated
    to a single namespace. Developers can quickly try out the feature and even use
    it in production code, providing they are happy to modify some code and recompile
    and relink when the feature becomes standardized.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要优势是孵化功能可以被隔离到单个命名空间中。开发者可以快速尝试该功能，甚至可以在生产代码中使用它，前提是他们愿意修改一些代码，并在功能标准化时重新编译和重新链接。
- en: '*Preview features* are the other mechanism that recent Java versions provide
    for shipping nonfinalized features. They are more intrusive than incubating features
    because they are implemented as part of the language itself, at a deeper level.
    These features potentially require support from the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*预览功能*是近期Java版本提供的一种机制，用于发布尚未最终确定的功能。与孵化功能相比，它们更具侵入性，因为它们作为语言本身的一部分，在更深的层次上实现。这些功能可能需要以下方面的支持：'
- en: The `javac` compiler
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javac`编译器'
- en: Bytecode format
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节码格式
- en: Class file and class loading
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类文件和类加载
- en: They are available only if specific flags are passed to the compiler and runtime.
    Trying to use preview features without the flags enabled is an error, both at
    compile time and at runtime.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 它们仅在向编译器和运行时传递特定标志时才可用。在没有启用标志的情况下尝试使用预览功能是错误的，无论是在编译时还是在运行时。
- en: This makes them much more complex to handle (compared to incubating features).
    As a result, preview features can’t really be used in production. For one thing
    they are represented by a version of the classfile format that is not finalized
    and may never be supported by any production version of Java.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得它们处理起来更加复杂（与孵化功能相比）。因此，预览功能实际上不能用于生产。一方面，它们由一个尚未最终确定且可能永远不会由任何生产版本的Java支持的类文件格式表示。
- en: This means that preview features are suitable only for experimentation, developer
    testing, and familiarization. Unfortunately, in almost all deployments, only fully
    finalized features can be used in code that is destined for production.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着预览功能仅适用于实验、开发者测试和熟悉。不幸的是，在几乎所有部署中，只有完全最终确定的功能才能用于旨在生产使用的代码。
- en: Java 11 did not contain any preview features (although a first preview version
    of *switch expressions* arrived in Java 12), so it’s hard to give a good example
    of one in this section. We’ll dig more into preview versions in chapter 3 when
    we discuss Java 17, though.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Java 11 没有包含任何预览功能（尽管 Java 12 中出现了 *switch 表达式* 的第一个预览版本），因此很难在这个部分给出一个很好的例子。不过，当我们在第
    3 章讨论 Java 17 时，我们会更深入地探讨预览版本。
- en: 1.5 Small changes in Java 11
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 Java 11 的小改动
- en: Since Java 8, a relatively large number of new small features have appeared
    in successive releases. Let’s take a quick tour through some of the most important
    ones—although this is by no means all the changes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Java 8 以来，在连续的版本中出现了相当多的新小功能。让我们快速浏览一下其中一些最重要的功能——尽管这绝对不是所有变化。
- en: 1.5.1 Collections factories (JEP 213)
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.1 集合工厂（JEP 213）
- en: 'An often-requested enhancement is to extend Java to support a simple way to
    declare *collection literals*—a dumb collection of objects (such as a list or
    a map). This seems attractive because many other languages support some form of
    this, and Java itself has always had array literals, as shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 常被请求的功能增强之一是扩展 Java 以支持一种简单的声明 *集合字面量* 的方法——一个简单的对象集合（例如列表或映射）。这看起来很有吸引力，因为许多其他语言都支持这种形式，Java
    本身也一直有数组字面量，如下所示：
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, although it seems superficially attractive, adding this feature at
    the language level has some significant drawbacks. For example, although `ArrayList`,
    `HashMap`, and `HashSet` are the implementations that are most familiar to developers,
    a primary design principle of the Java Collections are that they are represented
    as interfaces, not classes. Other implementations are available and are widely
    used.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管表面上看起来很有吸引力，但在语言级别添加这个功能有一些显著的缺点。例如，尽管 `ArrayList`、`HashMap` 和 `HashSet`
    是开发者最熟悉的实现，但 Java 集合的一个主要设计原则是它们被表示为接口，而不是类。其他实现也是可用的，并且被广泛使用。
- en: 'This means that it would run counter to the design intent to have a new syntax
    that directly couples to specific implementations, no matter how common. Instead,
    the design decision was to add simple factory methods to the relevant interfaces,
    exploiting the fact that Java 8 added the ability to have static methods on interfaces.
    The resulting code looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果有一个新的语法直接与特定的实现耦合，无论多么常见，都将与设计意图相悖。相反，设计决策是在相关接口中添加简单的工厂方法，利用 Java 8
    添加了在接口上定义静态方法的能力。生成的代码如下所示：
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Although this method is a little more verbose than adding support at language
    level, the complexity cost in implementation terms is substantially less. These
    new methods are implemented as a set of overloads as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个方法在语言级别添加支持时稍微有点冗长，但在实现层面的复杂性成本却大大降低。这些新方法被实现为一组重载，如下所示：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The common cases (up to 10 elements) are provided, along with a varargs form
    for the unlikely use case that more than 10 elements are required in the collection.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了常见的案例（最多 10 个元素），以及一个 varargs 形式，用于不太可能的情况，即集合中需要超过 10 个元素。
- en: 'For maps, the situation is a little more complicated, because maps have two
    generic parameters (the key type and the value type) and so, although the simple
    cases can be written like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于映射，情况要复杂一些，因为映射有两个泛型参数（键类型和值类型），因此，尽管简单的案例可以写成这样：
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'there is no simple way of writing the equivalent of the varargs form for map.
    Instead, a different factory method, `ofEntries()`, is used in combination with
    a static helper method, `entry()`, to provide an equivalent of a varargs form,
    as shown next:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 没有简单的方法来编写映射的 varargs 形式的等价形式。相反，使用不同的工厂方法 `ofEntries()` 与静态辅助方法 `entry()` 结合使用，以提供
    varargs 形式的等价形式，如下所示：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'One final point that developers should be aware of: the factory methods produce
    instances of immutable types, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者应该注意的一个最后一点是：工厂方法产生不可变类型的实例，如下所示：
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These class are new implementations of the Java Collections interfaces that
    are immutable—they are not the familiar, mutable classes (such as `ArrayList`
    and `HashMap`). Attempts to modify instances of these types will result in an
    exception being thrown.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类是 Java 集合接口的新实现，它们是不可变的——它们不是熟悉的可变类（例如 `ArrayList` 和 `HashMap`）。尝试修改这些类型的实例将导致抛出异常。
- en: 1.5.2 Remove enterprise modules (JEP 320)
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.2 移除企业模块（JEP 320）
- en: Over time, Java Standard Edition (aka Java SE) had a few modules added to it
    that were really part of Java Enterprise Edition (Java EE) such as
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，Java 标准版（即 Java SE）增加了一些模块，这些模块实际上是 Java 企业版（Java EE）的一部分，例如
- en: JAXB
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAXB
- en: JAX-WS
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-WS
- en: CORBA
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CORBA
- en: JTA
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JTA
- en: 'In Java 9, the following packages that implemented these technologies were
    moved into noncore modules and deprecated for removal:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 中，以下实现这些技术的包被移动到非核心模块，并已弃用以供移除：
- en: java.activation (JAF)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.activation (JAF)
- en: java.corba (CORBA)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.corba (CORBA)
- en: java.transaction (JTA)
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.transaction (JTA)
- en: java.xml.bind (JAXB)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.xml.bind (JAXB)
- en: java.xml.ws (JAX-WS, plus some related technologies)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.xml.ws (JAX-WS，以及一些相关技术)
- en: java.xml.ws.annotation (Common Annotations)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.xml.ws.annotation (通用注解)
- en: 'As part of an effort to streamline the platform, in Java 11 these modules have
    been removed. The following three related modules used for tooling and aggregation
    have also been removed from the core SE distribution:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简化平台的一部分，在 Java 11 中，这些模块已被移除。以下三个用于工具和聚合的相关模块也已从核心 SE 分发中移除：
- en: java.se.ee (aggregator module for the six modules above)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.se.ee (上述六个模块的聚合模块)
- en: jdk.xml.ws (tools for JAX-WS)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jdk.xml.ws (JAX-WS 工具)
- en: jdk.xml.bind (tools for JAXB)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jdk.xml.bind (JAXB 工具)
- en: Projects built on Java 11 and later that want to use these capabilities now
    require the inclusion of an explicit external dependency. This means that some
    programs that relied upon these APIs built cleanly under Java 8 but require modifications
    to their build script to build under Java 11\. We will investigate this specific
    issue more fully in chapter 11\.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Java 11 及以后版本的项目，如果想要使用这些功能，现在需要包含一个显式的外部依赖项。这意味着一些依赖于这些 API 的程序在 Java 8
    下可以干净地构建，但在 Java 11 下构建需要修改其构建脚本。我们将在第 11 章中更全面地研究这个问题。
- en: 1.5.3 HTTP/2 (Java 11)
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.3 HTTP/2 (Java 11)
- en: In modern times, a new version of the HTTP standard has been released—HTTP/2\.
    We’re going to examine the reasons for finally updating the venerable HTTP 1.1
    specification (dating from 1997!). Then we’ll see how Java 11 gives the well-grounded
    developer access to the new features and performance of HTTP/2.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代时代，HTTP 标准的新版本已经发布——HTTP/2。我们将探讨最终更新这个自 1997 年以来一直受到尊敬的 HTTP 1.1 规范（！）的原因。然后我们将看到
    Java 11 如何为经验丰富的开发者提供对 HTTP/2 的新功能和性能的访问。
- en: 'As you might expect for technology from 1997, HTTP 1.1 has been showing its
    age, particularly around performance in modern web applications. Limitations include
    problems such as:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所料，对于 1997 年的技术，HTTP 1.1 已经显示出其年龄，尤其是在现代 Web 应用程序的性能方面。局限性包括如下问题：
- en: Head-of-line blocking
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首行阻塞
- en: Restricted connections to a single site
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制连接到单个站点
- en: Performance overhead of HTTP control headers
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 控制头部的性能开销
- en: HTTP/2 is a *transport*-level update to the protocol focused on fixing these
    sorts of fundamental performance issues that don’t fit how the web really works
    today. With its performance focus on how bytes flow between client and server,
    HTTP/2 actually doesn’t alter many of the familiar HTTP concepts—request/response,
    headers, status codes, response bodies—all of these remain semantically the same
    in HTTP/2 vs. HTTP 1.1.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2 是对协议的 *传输层* 更新，专注于修复这些类型的根本性能问题，这些问题不适合当今网络的实际工作方式。它对性能的关注在于客户端和服务器之间字节流的流动，HTTP/2
    实际上并没有改变许多熟悉的 HTTP 概念——请求/响应、头部、状态码、响应体——所有这些在 HTTP/2 与 HTTP 1.1 中在语义上保持相同。
- en: Head-of-line blocking
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首行阻塞
- en: Communication in HTTP takes place over TCP sockets. Although HTTP 1.1 defaulted
    to reusing individual sockets to avoid repeating unnecessary setup costs, the
    protocol dictated that requests be returned in order, even when multiple requests
    shared a socket (known as pipelining; see figure 1.4). This means that a slow
    response from the server blocked subsequent requests, which theoretically could
    have been returned sooner. These effects are readily visible in places like browser
    rendering stalling on downloading assets. The same one-response-per-connection-at-a-time
    behavior can also limit JVM applications talking to HTTP-based services.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 中的通信发生在 TCP 套接字上。尽管 HTTP 1.1 默认重用单个套接字以避免重复不必要的设置成本，但协议规定请求必须按顺序返回，即使多个请求共享一个套接字（称为流水线；见图
    1.4）。这意味着来自服务器的缓慢响应会阻塞后续请求，而理论上这些请求可以更早返回。这些影响在浏览器在下载资源时渲染停滞的地方很容易看到。每次一个响应-一次连接的行为也可以限制与基于
    HTTP 的服务通信的 JVM 应用程序。
- en: '![](../Images/CH01_F04_Evans2.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F04_Evans2.png)'
- en: Figure 1.4 HTTP 1.1 transfers
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 HTTP 1.1 传输
- en: HTTP/2 is designed from the ground up to multiplex requests over the same connection,
    as shown in figure 1.5\. Multiple *streams* between the client and server are
    always supported. It even allows for separately receiving the headers and the
    body of a single request.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2 从一开始就被设计为在相同的连接上多路复用请求，如图 1.5 所示。客户端和服务器之间的多个 *流* 总是得到支持。它甚至允许分别接收单个请求的头部和主体。
- en: '![](../Images/CH01_F05_Evans2.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F05_Evans2.png)'
- en: Figure 1.5 HTTP/2 transfers
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 HTTP/2 传输
- en: This fundamentally changes assumptions that decades of HTTP 1.1 have made second
    nature to many developers. For instance, it’s long been accepted that returning
    lots of small assets on a website performed worse than making larger bundles.
    JavaScript, CSS, and images all have common techniques and tooling for smashing
    many smaller files together to return more efficiently. In HTTP/2, multiplexed
    responses mean your resources don’t get blocked behind other slow requests, and
    smaller responses may be more accurately cached, yielding a better experience
    overall.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这从根本上改变了数十年来 HTTP 1.1 已经使许多开发者习以为常的假设。例如，长期以来人们普遍认为，在一个网站上返回大量的小资产比返回更大的包表现更差。JavaScript、CSS
    和图片都有共同的技巧和工具，可以将许多较小的文件合并在一起以更有效地返回。在 HTTP/2 中，多路复用响应意味着你的资源不会因为其他缓慢的请求而被阻塞，并且较小的响应可能被更准确地缓存，从而提供更好的整体体验。
- en: Restricted connections
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 受限连接
- en: The HTTP 1.1 specification recommends limiting to two connections to a server
    at a time. This is listed as a *should* rather than a *must*, and modern web browsers
    often allow between six and eight connections per domain. This limit to concurrent
    downloads from a site has often led developers to serve sites from multiple domains
    or implement the sort of bundling mentioned before.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 1.1 规范建议同时限制对服务器的连接数为两个。这被列为“应该”而不是“必须”，现代网络浏览器通常允许每个域名之间有六到八个连接。这种对网站并发下载的限制常常导致开发者从多个域名提供服务或实施前面提到的打包方式。
- en: 'HTTP/2 addresses this situation: each connection can effectively be used to
    make as many simultaneous requests as desired. Browsers open only one connection
    to a given domain but can perform many requests over that same connection at the
    same time.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2 解决了这种情况：每个连接可以有效地用于发送所需数量的并发请求。浏览器只对一个域名打开一个连接，但可以在同一连接上同时执行许多请求。
- en: In our JVM applications, where we might have pooled HTTP 1.1 connections to
    allow for more concurrent activity, HTTP/2 gives us another built-in way to squeeze
    out more requests.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 JVM 应用程序中，我们可能会池化 HTTP 1.1 连接以允许更多的并发活动，HTTP/2 给我们提供了另一种内置的方式来挤出更多的请求。
- en: HTTP header performance
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 头部性能
- en: A significant feature of HTTP is the ability to send *headers* alongside requests.
    Headers are a critical part of how the HTTP protocol itself is stateless, but
    our applications can maintain state between requests (such as the fact your user
    is logged in).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 的一个显著特性是能够在请求中发送 *头部*。头部是 HTTP 协议本身无状态的关键部分，但我们的应用程序可以在请求之间保持状态（例如，用户已经登录）。
- en: Although the body of HTTP 1.1 payloads may be compressed if the client and server
    can agree on the algorithm (typically gzip), headers don’t participate. As richer
    web applications make more and more requests, the repetition of increasingly large
    headers can be a problem, especially for larger websites.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如果客户端和服务器可以就算法达成一致（通常是 gzip），HTTP 1.1 有效载荷的主体可以被压缩，但头部并不参与。随着更丰富的网络应用程序发出越来越多的请求，越来越大的头部的重复可能会成为一个问题，特别是对于大型网站。
- en: HTTP/2 addresses this problem with a new binary format for headers. As a user
    of the protocol, you don’t have to think much about this—it’s simply built in
    to how headers are transmitted between client and server.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2 通过为头部引入一个新的二进制格式来解决此问题。作为协议的用户，你不必过多考虑这一点——它只是内置到客户端和服务器之间传输头部的方式中。
- en: TLS all the things
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 的一切
- en: In 1997, HTTP 1.1 entered a very different internet than we see today. Commerce
    on the internet was only starting to take off, and security wasn’t always a top
    concern in early protocol designs. Computing systems were also slow enough to
    make practices like encryption often far too expensive.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1997 年，HTTP 1.1 进入了一个与今天截然不同的互联网。互联网上的商业刚刚开始起飞，而在早期的协议设计中，安全性并不总是首要考虑。计算系统也足够慢，以至于加密等做法通常过于昂贵。
- en: HTTP/2 was officially accepted in 2015 into a world that was far more security
    conscious. In addition, the computing needs for ubiquitous encryption of web requests
    through TLS (known in earlier versions as SSL) are low enough to have removed
    most arguments over whether or not to encrypt. As such, in practice, HTTP/2 is
    supported only with TLS encryption (the protocol does, in theory, allow for transmission
    in cleartext, but none of the major implementations provide it).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2 于 2015 年正式被接纳到一个对安全性更加重视的世界。此外，通过 TLS（在早期版本中称为 SSL）对 Web 请求进行普遍加密的计算需求足够低，以至于消除了大多数关于是否加密的争论。因此，在实践中，HTTP/2
    仅支持 TLS 加密（该协议在理论上允许明文传输，但没有任何主要实现提供这种功能）。
- en: This has an operational impact on deploying HTTP/2, because it requires a certificate
    with a lifecycle of expiration and renewal. For enterprises, this increases the
    need for certificate management. Let’s Encrypt ([https://www.letsencrypt.org](https://www.letsencrypt.org)),
    and other private options have been growing in response to this need.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这对部署 HTTP/2 有实际影响，因为它需要一个具有过期和续订生命周期的证书。对于企业来说，这增加了对证书管理的需求。Let’s Encrypt ([https://www.letsencrypt.org](https://www.letsencrypt.org))
    和其他私人选项已经随着这种需求而增长。
- en: Other considerations
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 其他考虑因素
- en: 'Although the future is trending toward the uptake of HTTP/2, deployment of
    it across the web hasn’t been fast. In addition to the encryption requirement,
    which even impacts local development, this delay may be attributable to the following
    rough edges and extra complexity:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管未来趋势是采用 HTTP/2，但它在网络上的部署速度并不快。除了加密要求，这甚至影响了本地开发，这种延迟可能归因于以下粗糙边缘和额外复杂性：
- en: HTTP/2 is binary-only; working with an opaque format is challenging.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP/2 仅支持二进制格式；与不透明的格式一起工作具有挑战性。
- en: HTTP layer products such as load balancers, firewalls, and debugging tools require
    updates to support HTTP/2.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要更新以支持 HTTP/2 的 HTTP 层产品，如负载均衡器、防火墙和调试工具。
- en: Performance benefits are aimed mainly at the browser-based use of HTTP. Backend
    services working over HTTP may see less benefit to updating.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能优势主要针对基于浏览器的 HTTP 使用。通过 HTTP 工作的底层服务可能看到更新带来的好处较少。
- en: HTTP/2 in Java 11
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Java 11 中的 HTTP/2
- en: The arrival of a new HTTP version after so many years motivated JEP 110 to introduce
    an entirely new API. Within the JDK, this replaces (but doesn’t remove) `HttpURLConnection`
    while aiming to put a usable HTTP API “in the box,” as it were, because many developers
    have reached for external libraries to fulfill their HTTP-related needs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在多年之后出现新的 HTTP 版本激励了 JEP 110 引入一个全新的 API。在 JDK 中，这取代了（但未删除）`HttpURLConnection`，旨在将可用的
    HTTP API “打包”在一起，因为许多开发者已经转向外部库来满足他们的 HTTP 相关需求。
- en: The resulting HTTP/2- and web socket–compatible API came first to Java 9 as
    an Incubating feature. JEP 321 moved it to its permanent home in Java 11 under
    `java.net.http`. The new API supports HTTP 1.1 as well as HTTP/2 and can fall
    back to HTTP 1.1 when a server being called doesn’t support HTTP/2.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，HTTP/2 和 WebSocket 兼容的 API 首先作为 Java 9 的孵化特性出现。JEP 321 将其移至 Java 11 的永久位置，在
    `java.net.http` 下。新的 API 支持 HTTP/1.1 以及 HTTP/2，并且当被调用的服务器不支持 HTTP/2 时，可以回退到 HTTP/1.1。
- en: 'Interactions with the new API start from the `HttpRequest` and `HttpClient`
    types. These are instantiated via builders, setting configurations before issuing
    the actual HTTP call, as shown next:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 与新 API 的交互从 `HttpRequest` 和 `HttpClient` 类型开始。这些类型通过构建器实例化，在发出实际的 HTTP 调用之前设置配置，如下所示：
- en: '[PRE18]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Constructs an HttpClient instance we can use to make requests
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建一个我们可以用来发送请求的 HttpClient 实例
- en: ❷ Constructs a specific request to Google with an HttpRequest instance
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 HttpRequest 实例构建一个针对 Google 的特定请求
- en: ❸ Synchronously makes the HTTP request and saves its response. This line blocks
    until the entire request has completed.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 同步发送 HTTP 请求并保存其响应。此行会阻塞，直到整个请求完成。
- en: ❹ The send method needs a handler to tell it what to do with the response body.
    Here we use a standard handler to return the body as a String.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 发送方法需要一个处理程序来告诉它如何处理响应体。这里我们使用一个标准处理程序将体作为 String 返回。
- en: This demonstrates the synchronous use of the API. After building our request
    and client, we issue the HTTP call with the `send` method. We won’t receive the
    `response` object back until the full HTTP call has completed, much like the older
    HTTP APIs in the JDK.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了 API 的同步使用。在构建我们的请求和客户端之后，我们使用 `send` 方法发出 HTTP 调用。我们不会在完整的 HTTP 调用完成之前收到
    `response` 对象，这与 JDK 中较旧的 HTTP API 类似。
- en: The first parameter is the request we set up, but the second deserves a closer
    look. Rather than expecting to always return a single type, the `send` method
    expects us to provide an implementation of the `HttpResponse.BodyHandler<T>` interface
    to tell it how to handle the response. `HttpResponse.BodyHandlers` provides some
    useful basic handlers for receiving your response as a byte array, as a string,
    or as a file. But customizing this behavior is just an implementation of `BodyHandler`
    away. All of this plumbing is based on the `java.util.concurrent.Flow` publisher
    and subscriber mechanisms, a form of programming known as reactive streams.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们设置的请求，但第二个参数值得更仔细地观察。`send` 方法期望我们提供一个 `HttpResponse.BodyHandler<T>`
    接口的实现，以告诉它如何处理响应。`HttpResponse.BodyHandlers` 提供了一些有用的基本处理程序，可以将响应作为字节数组、字符串或文件接收。但自定义此行为只需实现
    `BodyHandler` 即可。所有这些管道都是基于 `java.util.concurrent.Flow` 发布者和订阅者机制，这是一种称为反应式流的编程形式。
- en: 'One of the most significant benefits of HTTP/2 is its built-in multiplexing.
    Only using a synchronous `send` doesn’t really gain those benefits, so it should
    come as no surprise that `HttpClient` also supports a `sendAsync` method. `sendAsync`
    returns a `CompletableFuture` wrapped around the `HttpResponse`, providing a rich
    set of capabilities that may be familiar from other parts of the platform, as
    shown here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2 最显著的优点之一是其内置的多路复用功能。仅使用同步的 `send` 真实情况下并不能获得这些好处，因此 `HttpClient` 也支持
    `sendAsync` 方法也就不足为奇了。`sendAsync` 返回一个包裹着 `HttpResponse` 的 `CompletableFuture`，提供了一组丰富的功能，这些功能在其他平台的部分中可能很熟悉，如下所示：
- en: '[PRE19]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Creates the client and request as before
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如前所述创建客户端和请求
- en: ❷ Uses CompletableFuture.allOf to wait for all the requests to finish
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 `CompletableFuture.allOf` 等待所有请求完成
- en: ❸ sendAsync starts an HTTP request but returns a future and does not block.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `sendAsync` 启动一个 HTTP 请求，但返回一个未来，并不阻塞。
- en: ❹ When the future completes, we use thenAccept to receive the response.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当未来完成时，我们使用 `thenAccept` 接收响应。
- en: ❺ We can reuse the same client to make multiple requests simultaneously.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 我们可以使用相同的客户端同时发出多个请求。
- en: Here we set up a request and client again, but then we asynchronously repeat
    the call three separate times. `CompletableFuture.allOf` combines these three
    futures, so we can wait on them all to finish with a single `join`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次设置请求和客户端，但随后异步地分别调用三次。`CompletableFuture.allOf` 结合这三个未来，因此我们可以通过单个 `join`
    等待它们全部完成。
- en: This only scratches the two main entry points to this API. It offers tons of
    features and customization, from the configuration of timeouts and TLS, all the
    way to advanced asynchronous features like receiving HTTP/2 server pushes via
    `HttpResponse .PushPromiseHandler`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是触及了此 API 的两个主要入口点。它提供了大量的功能和定制，从配置超时和 TLS，到接收 HTTP/2 服务器推送的高级异步功能，如通过 `HttpResponse.PushPromiseHandler`。
- en: Building off the futures and reactive streams, the new HTTP API in the JDK provides
    an attractive alternative to the large libraries that have dominated the ecosystem
    in the HTTP space. Designed with modern asynchronous programming at the forefront,
    `java.net.http` puts Java in an excellent place for wherever the web evolves to
    in the future.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的基础上，JDK 中的新 HTTP API 为 HTTP 空间中主导生态系统的庞大库提供了一个有吸引力的替代方案。设计时以现代异步编程为核心，`java.net.http`
    使 Java 处于一个极佳的位置，无论网络未来如何发展。
- en: 1.5.4 Single-file source-code programs (JEP 330)
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.4 单文件源代码程序（JEP 330）
- en: The usual way that Java programs are executed is by compiling source code to
    a class file and then starting up a virtual machine process that acts as an execution
    container to interpret the bytecode of the class.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Java 程序通常的执行方式是将源代码编译成类文件，然后启动一个充当执行容器的虚拟机进程来解释类的字节码。
- en: This is very different from languages like Python, Ruby, and Perl, where the
    source code of a program is interpreted directly. The Unix environment has a long
    history of these types of *scripting languages*, but Java has not traditionally
    been counted among them.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 Python、Ruby 和 Perl 等语言非常不同，在这些语言中，程序的源代码是直接被解释的。Unix 环境有这些类型 *脚本语言* 的悠久历史，但
    Java 传统上并不被认为属于这一类。
- en: With the arrival of JEP 330, Java 11 offers a new way to execute programs. Source
    code can be compiled in memory and then executed by the interpreter without ever
    producing a .class file on disk, as shown in figure 1.6.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 JEP 330 的到来，Java 11 提供了一种执行程序的新方法。源代码可以在内存中编译，然后由解释器执行，而无需在磁盘上产生 .class 文件，如图
    1.6 所示。
- en: '![](../Images/CH01_F06_Evans2.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F06_Evans2.png)'
- en: Figure 1.6 Single file execution
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 单文件执行
- en: This gives a user experience that is like Python and other scripting languages.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这为用户提供了类似于 Python 和其他脚本语言的用户体验。
- en: 'The feature has some limitations, including the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 该特性有一些限制，包括以下内容：
- en: It is limited to code that lives in a single source file.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仅限于存在于单个源文件中的代码。
- en: It cannot compile additional source files in the same run.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能在同一个运行中编译额外的源文件。
- en: It may contain any number of classes in the source file.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在源文件中包含任意数量的类。
- en: It must have the first class declared in the source file as the entry point.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须将源文件中声明的第一个类作为入口点。
- en: It must define the main method in the entry point class.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须在入口点类中定义主方法。
- en: The feature also uses a `--source` flag to indicate source code compatibility
    mode—essentially the language level of the script.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 该特性还使用 `--source` 标志来指示源代码兼容模式——本质上就是脚本的语言级别。
- en: Java file-naming conventions must be followed for execution, so the class name
    should match the filename. However, the .java extension should *not* be used because
    this can confuse the launcher.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Java 文件命名约定必须遵循以执行，因此类名应与文件名匹配。然而，不应使用 .java 扩展名，因为这可能会使启动器产生混淆。
- en: 'These types of Java scripts can also contain a shebang line, as shown next:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的 Java 脚本也可以包含一个 shebang 行，如下所示：
- en: '[PRE20]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Full code for HTTP2Check is provided in project resources.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ HTTP2Check 的完整代码在项目资源中提供。
- en: 'The shebang line provides the necessary parameters so that the file can be
    marked executable and directly invoked, like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: shebang 行提供了必要的参数，以便文件可以被标记为可执行，并直接调用，如下所示：
- en: '[PRE21]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although this feature does not bring the full experience of scripting languages
    to Java, it can be a useful way of writing simple, useful tools in the Unix tradition
    without introducing another programming language into the mix.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个特性并没有将脚本语言的全部体验带到 Java 中，但它可以是一种在 Unix 传统中编写简单、有用工具的有用方式，而无需引入另一种编程语言。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The Java language and platform are two separate (if strongly related) components
    of the Java ecosystem. The platform supports many languages beyond just Java.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 语言和平台是 Java 生态系统中的两个独立（尽管关系紧密）的组件。平台支持许多语言，而不仅仅是 Java。
- en: After Java 8, the Java platform has adopted a new timed-release process. New
    versions arrive every six months and a Long-Term-Support (LTS) release comes out
    every two or three years.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8 之后，Java 平台采用了新的定时发布流程。新版本每六个月发布一次，每两到三年发布一个长期支持（LTS）版本。
- en: The current LTS versions are 11 and 17, with Java 8 still being supported for
    now.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前长期支持版本为 11 和 17，Java 8 目前仍然得到支持。
- en: With its focus on backward compatibility, making changes to Java can often be
    difficult. Changes restricted to just the library or compiler are often much simpler
    than changes that also require updates in the virtual machine.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其关注向后兼容性，对 Java 进行更改通常很困难。仅限于库或编译器的更改通常比需要更新虚拟机的更改要简单得多。
- en: 'Java 11 introduced many useful features that are worth upgrading for:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 11 引入了许多值得升级的功能：
- en: The `var` keyword to streamline variable definitions
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `var` 关键字简化变量定义
- en: Factory methods to simplify creating lists, maps, and other collections
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法以简化创建列表、映射和其他集合
- en: A new `HttpClient` implementation with full HTTP/2 support
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个全新的 `HttpClient` 实现，支持完整的 HTTP/2
- en: Single-file programs that can be run directly without compiling to class files
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以直接运行而无需编译为类文件的单一文件程序
