- en: 11 Additional security considerations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 额外的安全考虑
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Securing running applications on different standalone servers, inside different
    VMs and containers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的独立服务器、不同的虚拟机（VM）和容器内安全运行应用程序
- en: Running a container via a service versus as a child of the container engine
    via fork and exec
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过服务运行容器与通过fork和exec作为容器引擎子进程运行容器的比较
- en: Linux security features used to keep containers isolated from each other
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于将容器彼此隔离的Linux安全功能
- en: Setting up container image trust
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置容器镜像信任
- en: Signing images and trusting them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签署镜像并信任它们
- en: In this chapter, I review and demonstrate some additional security considerations
    when using Podman to run containers. Some of the content was covered in other
    chapters, but I think it is useful to concentrate on these features from a security
    perspective.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我回顾并演示了使用Podman运行容器时的一些额外的安全考虑。其中一些内容在其他章节中已经介绍过，但我认为从安全角度集中关注这些功能是有用的。
- en: One of the most frequent problems I see with people running containers is that
    when the container process is denied some access, the user’s first reaction is
    to run the container in `--privileged` mode, which turns off all security separation
    for your container. Understanding how to deal with the security features discussed
    in this chapter helps you avoid this.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到人们在运行容器时最常见的一个问题是，当容器进程被拒绝某些访问时，用户的第一个反应是运行容器在`--privileged`模式下，这将关闭您容器的所有安全隔离。了解如何处理本章中讨论的安全功能可以帮助您避免这种情况。
- en: 11.1 Daemon versus the fork/exec model
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 守护进程与fork/exec模型
- en: Throughout the previous chapters, you have learned quite a bit about the problems
    of a daemon like Docker versus the fork/exec model employed by Podman.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您已经学到了很多关于像Docker这样的守护进程与Podman使用的fork/exec模型之间的问题。
- en: 11.1.1 Access to the docker.sock
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 对docker.sock的访问
- en: 'Recall that Docker, by default, runs a daemon owned by the root user. This
    means any user who has access to the daemon can launch processes with full root
    access on the system. Docker recommends some users put their accounts into the
    docker group in the /etc/group. On some distributions, this allows you to access
    the /run/docker.sock without being root:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Docker默认运行一个由root用户拥有的守护进程。这意味着任何可以访问守护进程的用户都可以在系统上以完全root权限启动进程。Docker建议一些用户将他们的账户添加到`/etc/group`中的docker组。在某些发行版中，这允许您无需root权限即可访问`/run/docker.sock`：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can run a Docker container similarly to how you have been running a Podman
    container:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像运行Podman容器一样运行Docker容器：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This excites a lot of users, until they understand they can also launch a root
    shell on their system with a simple Docker command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这让许多用户感到兴奋，直到他们意识到他们也可以通过简单的Docker命令在他们的系统上启动root shell：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, you have a fully privileged root shell on the host system, in
    which you can hack the machine all you want. Not only that, but Docker defaults
    all logging to being file based. When you are done hacking the system, you can
    remove the log files and all records of your activity:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您在主机系统上拥有一个完全特权的root shell，在其中您可以随意破解机器。不仅如此，Docker默认将所有日志记录为基于文件的。当您完成破解系统后，您可以删除日志文件和您所有活动的记录：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using rootless Podman, you cannot do this, since when you run the container,
    the container processes are run as your user UID and only have access to the same
    files as any process in your account. One way administrators figure out if they
    have been hacked is by examining the logging system, including the audit logs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无根Podman，您无法这样做，因为当您运行容器时，容器进程是以您的用户UID运行的，并且只能访问与您账户中任何进程相同的文件。管理员确定他们是否被黑客攻击的一种方法是通过检查日志系统，包括审计日志。
- en: 11.1.2 Auditing and logging
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 审计和日志记录
- en: 'One key feature of a Linux system is tracking what processes do when they are
    running on a system. When you log in to a Linux system, your UID is recorded by
    the kernel into the process data in /proc/self/loginuid. You can see this data
    by executing the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Linux系统的一个关键特性是跟踪当进程在系统上运行时它们做了什么。当您登录到Linux系统时，内核会将您的UID记录到/proc/self/loginuid中的进程数据中。您可以通过执行以下命令查看这些数据：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'All processes created by this first process after login maintain this field.
    Even if you use a `setuid` program, like `su` or `sudo`, your `loginuid` stays
    the same:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此第一个进程创建的所有进程在登录后都保持此字段。即使您使用`setuid`程序，如`su`或`sudo`，您的`loginuid`仍然保持不变：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Even when you launch a container, the `loginuid` stays the same. In this next
    example, you run a simple container in daemon mode that sleeps, then use `podman`
    `inspect` to get the PID of the sleep processes, and finally examine the `loginuid`
    of the containerized process:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您启动了一个容器，`loginuid` 仍然保持不变。在下一个例子中，您以守护进程模式运行一个简单的容器，然后使用 `podman inspect`
    获取睡眠进程的 PID，最后检查容器化进程的 `loginuid`：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice the containerized process is still running with your `loginuid`. This
    shows that the kernel can track which user launched a container process on the
    system via this field, as long as the container engine uses the fork/exec model.
    If you run this same test with Docker, you get very different results:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，容器化进程仍在使用您的 `loginuid` 运行。这表明只要容器引擎使用 fork/exec 模型，内核就可以通过此字段跟踪哪个用户在系统上启动了容器进程。如果您使用
    Docker 运行相同的测试，您会得到非常不同的结果：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Instead of showing your `loginuid`, you see `4294967295`, which is 2^(32) –
    1\. This is how the Linux kernel represents `-1`, the default `loginuid` for all
    processes started by the system, not by users who logged into the system. The
    reason for this is that Docker uses a client-server model, and the container process
    is a child of the Docker daemon as opposed to the Docker client. Since the Docker
    daemon was launched by systemd when the system booted up, all of its children
    processes have the `-1` `loginuid`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到的不是您的 `loginuid`，而是 `4294967295`，这是 2^(32) – 1。这是 Linux 内核表示 `-1` 的方式，这是系统启动的所有进程的默认
    `loginuid`，而不是登录系统的用户启动的进程。原因是 Docker 使用客户端-服务器模型，容器进程是 Docker 守护进程的子进程，而不是 Docker
    客户端。由于 Docker 守护进程是在系统启动时由 systemd 启动的，因此所有子进程都具有 `-1` 的 `loginuid`。
- en: The kernel’s audit subsystem records the `loginuid` of every process on the
    system when it completes an auditable event. For example, when a user logs in
    and out of a system, these events are logged. Modifying /etc/passwd and /etc/shadow
    are also loggable events.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的审计子系统在完成可审计事件时记录系统上每个进程的 `loginuid`。例如，当用户登录和注销系统时，这些事件会被记录下来。修改 /etc/passwd
    和 /etc/shadow 也是可记录的事件。
- en: 'Following is the `USER_START` audit log entry for when I logged into my system
    today. My UID `3267` is recorded along with my username:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我今天登录系统时的 `USER_START` 审计日志条目。我的 UID `3267` 被记录，以及我的用户名：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you launched the container by using a Podman command, then the audit subsystem
    records your UID in the audit logs. If the container was launched via Docker,
    it records `-1` as the `loginuid`. Imagine your system was hacked via a container.
    You need to go back and examine which user launched the container that hacked
    your system via the audit.log.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Podman 命令启动了容器，审计子系统会在审计日志中记录您的 UID。如果容器是通过 Docker 启动的，它将 `-1` 记录为 `loginuid`。想象一下，如果您的系统被容器攻击，您需要回溯并检查哪个用户通过
    audit.log 启动了攻击您系统的容器。
- en: 'Let’s show an example of this. First, become root, and set up a watch on the
    /etc/passwd file using `auditctl`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来展示这一点。首先，成为 root 用户，并使用 `auditctl` 在 /etc/passwd 文件上设置监视：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now run a `--privileged` container using Docker, which touches the host’s /etc/
    passwd file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行一个使用 Docker 的 `--privileged` 容器，它接触宿主的 /etc/passwd 文件：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This simulated what would happen if a Docker container escaped confinement
    and was able to modify the host’s /etc/passwd file. Now examine the audit.log,
    where there should be a record of the /etc/passwd modification. Notice that the
    audit log shows `auid=unset`. This is how the audit log represents the `loginuid`
    of the user that modified the /etc/passwd file. As you can see, because no user
    launched the Docker daemon directly, the audit log has no record of the user who
    launched the container:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这模拟了如果 Docker 容器逃离了限制并能够修改宿主的 /etc/passwd 文件会发生什么。现在检查 audit.log，其中应该有 /etc/passwd
    修改的记录。注意，审计日志显示 `auid=unset`。这就是审计日志表示修改 /etc/passwd 文件的用户 `loginuid` 的方式。如您所见，因为没有用户直接启动
    Docker 守护进程，审计日志没有记录启动容器的用户：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now run the same command with Podman:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用 Podman 运行相同的命令：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Examine the audit.log for the Podman container that modifies the /etc/passwd
    file, and you see that `auid=dwalsh`. Because Podman follows the fork/exec model
    and was launched by a user who logged into the system and had a record in the
    `loginuid`, the audit.log can record which user launched a container that hacked
    the system:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 检查修改 /etc/passwd 文件的 Podman 容器的 audit.log，您会看到 `auid=dwalsh`。因为 Podman 遵循 fork/exec
    模型，并且是由登录系统的用户启动的，该用户在 `loginuid` 中有记录，所以 audit.log 可以记录哪个用户启动了攻击系统的容器：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note On current Fedora, the audit subsystem is disabled. You can enable it by
    removing `/etc/audit/rules.d/audit.rules` and regenerating the audit rules with
    the `augenrules` `--load` command.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在当前的 Fedora 中，审计子系统已被禁用。您可以通过删除 `/etc/audit/rules.d/audit.rules` 并使用 `augenrules`
    `--load` 命令重新生成审计规则来启用它。
- en: This is one reason, back in 2014, I said access to the docker.sock via non-root
    processes is more dangerous than giving out the root process or sudo access, since
    both of those record the `loginuid`, meaning you can track what the user is doing
    on your system. When you give access to the root running docker.sock, you have
    no tracking data. Let’s look into how you can protect the kernel and the filesystem
    from processes running within a container in the next section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在 2014 年，我说通过非 root 进程访问 docker.sock 比提供 root 进程或 sudo 访问更危险，因为这两种情况都会记录
    `loginuid`，这意味着您可以跟踪用户在系统上的操作。当您提供对运行 docker.sock 的 root 的访问权限时，您没有任何跟踪数据。让我们在下一节中看看您如何保护内核和文件系统免受容器内进程的影响。
- en: 11.2 Podman secret handling
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 Podman 密钥处理
- en: Often, when running a container, you need to provide a secret to the service
    running within the container. An example of this is a database tool that requires
    an administrator and password to control access. Another example is a service
    that requires a password to reach another service.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行容器时，通常需要向容器内运行的服务提供密钥。例如，这是一个需要管理员和密码来控制访问的数据库工具。另一个例子是需要一个密码才能访问另一个服务的服务。
- en: Developers of these applications do not want to hardcode the secret information
    into the image. The user of the container application must provide the secret.
    You can just provide the secret to the application via environment variables,
    but this means if you commit the image, the secret gets committed to the image.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序的开发者不希望将密钥信息硬编码到镜像中。容器应用程序的用户必须提供密钥。您只需将密钥通过环境变量提供给应用程序即可，但这意味着如果您提交镜像，密钥也会被提交到镜像中。
- en: Podman provides a secret mechanism, `podman` `secret`, which allows you to either
    add files or environment variables to a container without these secrets getting
    saved when you commit the container to an image. First, let’s look at creating
    a secret.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 提供了一个密钥机制，`podman` `secret`，允许您在不将这些密钥保存在将容器提交到镜像时添加文件或环境变量。首先，让我们看看如何创建一个密钥。
- en: Listing 11.1 Using secrets within a Podman container
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 在 Podman 容器中使用密钥
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Add your secret data to a file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将您的密钥数据添加到文件中。
- en: ❷ Use podman secret create to name a secret based on the file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 podman secret create 命令根据文件命名一个密钥。
- en: ❸ Use the --secret option to leak the secret into the container.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 --secret 选项将密钥泄露到容器中。
- en: 'You can also leak the secret into the container as an environment variable
    by adding the `--secret` `my_secret,type=env` flag:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过添加 `--secret my_secret,type=env` 标志将密钥泄露到容器中作为环境变量：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you were to commit this container to an image, the secret would not be saved
    inside the image.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要将此容器提交到镜像，密钥将不会保存在镜像内部。
- en: Listing 11.2 The secret is not saved when the container is committed to the
    image.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 当容器提交到镜像时，密钥不会被保存。
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Commit the secret_ctr into the secret_img image.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 secret_ctr 提交到 secret_img 镜像中。
- en: ❷ Inspect the image to view the committed environment variables, and notice
    the my_secret environment is not committed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查镜像以查看提交的环境变量，并注意 my_secret 环境变量没有被提交。
- en: Table 11.1 lists all of the `podman` `secret` commands.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1 列出了所有 `podman` `secret` 命令。
- en: Table 11.1 `podman` `secret` commands
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1 `podman` `secret` 命令
- en: '| Command | Man page | Description |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 手册页 | 描述 |'
- en: '| `create` | `podman-secret-create(1)` | Create a new secret. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `create` | `podman-secret-create(1)` | 创建一个新的密钥。 |'
- en: '| `inspect` | `podman-secret-inspect(1)` | Display detailed information on
    one or more secrets. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `inspect` | `podman-secret-inspect(1)` | 显示一个或多个密钥的详细信息。 |'
- en: '| `ls` | `podman-secret-ls(1)` | List all available secrets. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `ls` | `podman-secret-ls(1)` | 列出所有可用的密钥。 |'
- en: '| `rm` | `podman-secret-rm(1)` | Remove one or more secrets. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `rm` | `podman-secret-rm(1)` | 删除一个或多个密钥。 |'
- en: 11.3 Podman image trust
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 Podman 镜像信任
- en: In many situations, users of container images want to specify which container
    image registries and images they trust. The `podman` `image` `trust` command allows
    you to specify which registries you trust. It also allows you to specify registries
    to block.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，容器镜像的用户希望指定他们信任哪些容器镜像仓库和镜像。`podman` `image` `trust` 命令允许您指定您信任的仓库。它还允许您指定要阻止的仓库。
- en: The location of the trusted registry is determined by the transport and the
    registry host of the image. Using this container image—docker://quay.io/podman/stable—as
    an example, Docker is the transport, and quay.io is the registry host.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 信任注册库的位置由图像的传输和注册库主机确定。以使用此容器图像—docker://quay.io/podman/stable—为例，Docker 是传输，quay.io
    是注册库主机。
- en: Note Podman image trust is not available in remote mode, for example, on a Mac
    or Windows box. You have to execute the commands documented here on a Linux box.
    If you are using the Podman machine, use the `podman` `machine` `ssh` command
    to enter the VM. See appendixes E and F for more information.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Podman 图像信任在远程模式下不可用，例如，在 Mac 或 Windows 箱子上。您必须在 Linux 箱子上执行此处记录的命令。如果您使用
    Podman 机器，请使用 `podman` `machine` `ssh` 命令进入虚拟机。有关更多信息，请参阅附录 E 和 F。
- en: The trust policy is defined in /etc/containers/policy.json, which describes
    a registry scope (registry and/or repository) for the trust. The trust policy
    can use public keys for signed images. The `podman` `image` `trust` command must
    be run as root.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 信任策略定义在 /etc/containers/policy.json 中，它描述了信任的注册库范围（注册库和/或存储库）。信任策略可以使用公钥为签名的图像。必须以
    root 用户运行 `podman` `image` `trust` 命令。
- en: The scope of the trust is evaluated from the most specific to the least specific.
    In other words, a policy may be defined for an entire registry. Or it can be defined
    for a particular repository in that registry or defined down to a specific signed
    image inside the registry. In the following example, you reject pulls from docker.io
    and then later specify only docker.io/library images are allowed for pulling.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 信任的范围从最具体到最不具体进行评估。换句话说，可以为整个注册库定义一个策略。或者，它可以为该注册库中的特定存储库定义策略，或者定义到注册库中特定签名的图像。在以下示例中，您拒绝从
    docker.io 拉取，然后后来仅指定允许拉取 docker.io/library 图像。
- en: 'The following list includes valid scope values that can be used in policy.json
    from most specific to the least specific:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包括在 policy.json 中可以使用的有效范围值，从最具体到最不具体：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If no configuration is found for any of these scopes, the default value (specified
    by using `default` instead of `REGISTRY[/REPOSITORY]`) is used, as shown in the
    following listing. Table 11.2 describes the valid trust values used for registries.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这些范围内没有找到任何配置，则使用默认值（使用 `default` 而不是 `REGISTRY[/REPOSITORY]` 指定），如下所示。表
    11.2 描述了用于注册库的有效信任值。
- en: Listing 11.3 Telling Podman to not pull images from a specific container registry
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 告诉 Podman 不要从特定的容器注册库拉取图像
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Use podman image trust to reject all images from the docker.io container registry.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 podman 图像信任拒绝来自 docker.io 容器注册库的所有图像。
- en: ❷ Attempt to pull the alpine image from the container registry, and see that
    Podman rejects the image.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 尝试从容器注册库中拉取 Alpine 图像，并查看 Podman 拒绝了该图像。
- en: ❸ Use Podman image trust to set a more specific registry/repository for docker.io/library.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 Podman 图像信任设置 docker.io/library 的更具体的注册库/存储库。
- en: ❹ Podman can pull the docker.io/library/alpine image.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ Podman 可以拉取 docker.io/library/alpine 图像。
- en: ❺ Images pulled from the rest of docker.io are rejected.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 从 docker.io 的其余部分拉取的图像被拒绝。
- en: Table 11.2 The trust type tells container engines like Podman which registries
    to trust.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.2 信任类型告诉容器引擎（如 Podman）信任哪些注册库。
- en: '| Types | Description |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| `accept` | Images from the specified registry are allowed to be pulled. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `accept` | 允许从指定的注册库拉取图像。 |'
- en: '| `reject` | Images from the specified registries are not allowed to be pulled.
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `reject` | 不允许从指定的注册库拉取图像。 |'
- en: '| `signBy` | Images from the specified registries must be signed by the specified
    name. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `signBy` | 来自指定注册库的图像必须由指定的名称签名。 |'
- en: 'If you examine the policy.json file, you see the entries added by the `podman`
    `image` `trust` command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检查 policy.json 文件，您会看到由 `podman` `image` `trust` 命令添加的条目：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can use the `podman` `image` `trust` `show` command to show the current
    settings in an easier-to-view form:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `podman` `image` `trust` `show` 命令以更易于查看的形式显示当前设置：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Through the `accep`t and `reject` flags, you can set up which registries you
    trust and which you reject. If you want to lock down where images on your production
    system come from, you can change the `default` policy for your system to `reject`
    images from any registry. All images you want to allow need to come from a specific
    registry:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `accep`t 和 `reject` 标志，您可以设置信任和拒绝哪些注册库。如果您想锁定生产系统中图像的来源，您可以更改系统的 `default`
    策略为 `reject` 来自任何注册库的图像。您想要允许的所有图像都必须来自特定的注册库：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With these settings on your system, Podman accepts images from docker.io/library
    and signed images from registry.redhat.io. All images from other registries are
    rejected. Podman allows pulling of images directly from the `docker-daemon` as
    well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的系统上设置这些设置后，Podman 接受来自 docker.io/library 的图像和来自 registry.redhat.io 的签名图像。来自其他注册表的图像都将被拒绝。Podman
    还允许直接从 `docker-daemon` 拉取图像。
- en: 'Don’t forget to restore the default policy.json:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记恢复默认的 policy.json：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Podman supports using signed images from container registries. Red Hat signs
    and ships its images. Let’s look at how you, too, can sign images.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 支持使用来自容器注册表的签名图像。红帽公司签名并分发其图像。让我们看看你如何也能签名图像。
- en: 11.3.1 Podman image signing
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 Podman 图像签名
- en: One way of signing images is utilizing a GNU Privacy Guard ([https://gnupg.org](https://gnupg.org))
    key. Podman can sign images before pushing them to remote registries, referred
    to as *simple signing*. You can configure Podman and other container engines to
    require images to be signed with a particular signature. All unsigned images are
    rejected.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 签名图像的一种方式是使用 GNU Privacy Guard ([https://gnupg.org](https://gnupg.org)) 密钥。Podman
    可以在将图像推送到远程注册表之前对其进行签名，这被称为 *简单签名*。你可以配置 Podman 和其他容器引擎，要求图像必须使用特定的签名进行签名。所有未签名的图像都将被拒绝。
- en: 'First, you need to create a GPG key pair or select a premade pair. You can
    generate new GPG keys by running `gpg` `--full-gen-key` and following the interactive
    dialog. Refer to the following web page for a description of creating keys: [http://mng.bz/JV9V](http://mng.bz/JV9V).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个 GPG 密钥对或选择一个预制的密钥对。你可以通过运行 `gpg` `--full-gen-key` 并遵循交互式对话框来生成新的
    GPG 密钥。有关创建密钥的说明，请参阅以下网页：[http://mng.bz/JV9V](http://mng.bz/JV9V)。
- en: 'Following is an example of creating a simple key with default params. Make
    sure to use your own email address:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用默认参数创建简单密钥的示例。请确保使用你自己的电子邮件地址：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Most container registries do not understand image signing; they just provide
    the remote storage for the container images. If you want to sign an image, you
    need to distribute the signatures yourself, usually using a web server. You can
    configure Podman and other container engines to retrieve signatures from this
    web service.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数容器注册表都不理解图像签名；它们只是为容器图像提供远程存储。如果你想签名一个图像，你需要自己分发签名，通常使用网络服务器。你可以配置 Podman
    和其他容器引擎从该网络服务检索签名。
- en: In the following examples, you will create a web service running on your local
    machine to demonstrate image signing. Podman is able to push and sign the image
    in a single command. Podman reads signature locations in the registries configuration
    file /etc/containers/registries.d/default.yaml.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，你将在本地机器上创建一个运行着的网络服务来演示图像签名。Podman 能够通过单个命令推送和签名图像。Podman 读取注册表配置文件 /etc/containers/registries.d/default.yaml
    中的签名位置。
- en: 'Examine the default.yaml file to find the `sigstore-staging` flag and see the
    default location where Podman stores signatures:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 default.yaml 文件以找到 `sigstore-staging` 标志并查看 Podman 存储签名的默认位置：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `sigstore-staging` flag tells Podman to store signatures in the /var/lib/containers/sigstore
    directory. When you want other users to use these signatures to verify your images,
    you need to put these images onto a web server. Now you are ready to test out
    simple signing, first signing the ubi8 image and then setting up Podman to pull
    the image using the signature to verify it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`sigstore-staging` 标志告诉 Podman 将签名存储在 /var/lib/containers/sigstore 目录中。当你想让其他用户使用这些签名来验证你的图像时，你需要将这些图像上传到网络服务器。现在你已经准备好测试简单的签名了，首先签名
    ubi8 图像，然后设置 Podman 使用签名来验证拉取的图像。'
- en: Signing and pushing the image
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 签名并推送图像
- en: 'Before starting this section, you should back up a couple of security files,
    so you can restore them later:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本节之前，你应该备份几个安全文件，以便稍后恢复：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s pull an image from a registry and add a signature, then push it back
    to the registry. Make sure to use your own registry account, image, and previously
    created GPG key:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从注册表中拉取一个图像并添加一个签名，然后将它推回注册表。请确保使用你自己的注册表账户、图像和之前创建的 GPG 密钥：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Look in the sigstore-staging directory /var/lib/containers/sigstore for the
    repository name rhatdan. You will see that there is a new signature available,
    created by the `podman` `push` command. Make sure to use your own registry account
    name:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 sigstore-staging 目录 /var/lib/containers/sigstore 中查找仓库名称 rhatdan。你会看到有一个新的签名可用，这是由
    `podman` `push` 命令创建的。请确保使用你自己的注册表账户名：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now that you have signed the image, you need to set up a web server to provide
    the signature and configure Podman and other container engines to use the signatures
    and signed images.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经签了镜像，你需要设置一个 Web 服务器来提供签名，并配置 Podman 和其他容器引擎以使用签名和已签名的镜像。
- en: Configuring Podman to pull signed images
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Podman 拉取已签名的镜像
- en: When configuring Podman to use signatures to verify images, you need to configure
    the system to retrieve the signatures. Usually, you share signatures on a web
    service. You can do this by configuring the `sigstore` flag in the /etc/containers/registries.d/default.yaml
    file to identify the website that stores signatures. Podman downloads these signatures
    from this website.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置 Podman 使用签名来验证镜像时，你需要配置系统以检索签名。通常，你会在 Web 服务上共享签名。你可以通过在`/etc/containers/registries.d/default.yaml`文件中配置`sigstore`标志来识别存储签名的网站。Podman
    从该网站下载这些签名。
- en: 'For this example, you will create a web service running on localhost at port
    `8000`. Add the `sigstore:` `http://localhost:8000` web server to the default.yaml
    file. This will tell Podman to retrieve signatures from this web server when pulling
    images. Podman looks for a signature based on the name of the image along with
    its digest:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，你将创建一个在本地主机`8000`端口上运行的 Web 服务。将`sigstore:` `http://localhost:8000` Web
    服务器添加到默认的`default.yaml`文件中。这将告诉 Podman 在拉取镜像时从该 Web 服务器检索签名。Podman 根据镜像的名称及其摘要查找签名：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For this example, start a new server using `python3` inside the local staging
    signature store /var/lib/containers/sigstore:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，在本地预演签名存储`/var/lib/containers/sigstore`中使用`python3`启动一个新的服务器：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In another window, remove quay.io/rhatdan/myimage from local storage, since
    you want to pull with the signatures:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个窗口中，从本地存储中删除 quay.io/rhatdan/myimage，因为你想要带签名的拉取：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You need to set up image trust for the quay.io/rhatdan repository and assign
    the publickey.gpg public key to use when verifying images signed by dwalsh@redhat.com:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为 quay.io/rhatdan 存储库设置镜像信任，并将 publickey.gpg 公钥分配给用于验证 dwalsh@redhat.com
    签名的镜像：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The previous Podman command adds the following stanza to the /etc/containers/
    policy.json file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 Podman 命令将以下段落添加到`/etc/containers/policy.json`文件中：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You have not created the `keyPath` file /tmp/publickey.gpg yet. Create it using
    the following GPG command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你还没有创建`keyPath`文件`/tmp/publickey.gpg`。使用以下 GPG 命令创建它：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now you can pull the signed image:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以拉取已签名的镜像：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It worked! Still, you are not really sure if it used signatures. Prove it to
    yourself by attempting to pull another image from the repository, which you don’t
    have signatures for, and it will fail:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这成功了！尽管如此，你仍然不确定它是否使用了签名。通过尝试从没有签名的仓库中拉取另一个镜像来证明给自己，这将失败：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Make sure to restore all settings back to default:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将所有设置恢复到默认值：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Also, stop the localhost web server started in another terminal. Table 11.3
    describes the infrastructure you need to set up to allow simple signing to be
    used within your environment.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，停止在另一个终端中启动的本地主机 Web 服务器。表 11.3 描述了你需要设置的必要基础设施，以允许在环境中使用简单的签名。
- en: Table 11.3 Infrastructure required for simple signing
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.3 简单签名所需的基础设施
- en: '| Requirements | Description |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 要求 | 描述 |'
- en: '| GPG private key | You need a GPG key pair, where the private key is used
    on the service that signs the images. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| GPG 私钥 | 你需要一个 GPG 密钥对，其中私钥用于签名镜像的服务。|'
- en: '| Signature web server | A web server has to run somewhere that has access
    to the signature storage. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 签名 Web 服务器 | Web 服务器必须运行在可以访问签名存储的地方。|'
- en: Once you have the infrastructure set up to use simple signing, you will need
    to know the requirements of each client that uses and verifies the signatures.
    Table 11.4 lists each of these requirements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了使用简单签名的必要基础设施，你将需要了解每个使用和验证签名的客户端的要求。表 11.4 列出了这些要求。
- en: Table 11.4 Client configuration required for simple signing
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.4 简单签名所需客户端配置
- en: '| Requirements | Description |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 要求 | 描述 |'
- en: '| GPG public key(/tmp/publickey.gpg) | The public GPG key used for signing
    must be present on any machine that pulls the signed images. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| GPG 公钥(/tmp/publickey.gpg) | 用于签名的公钥必须在拉取已签名镜像的任何机器上存在。|'
- en: '| Client’s sigstore configured | The signature web server has to be configured
    as a sigstore in a /etc/containers/registries.d/*.yaml file on all systems, which
    need to pull the signed images. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 客户端 sigstore 配置 | 签名 Web 服务器必须在所有需要拉取已签名镜像的系统的`/etc/containers/registries.d/*.yaml`文件中配置为
    sigstore。|'
- en: '| Client’s image trust configured | Image trust has to be configured on every
    container engine system that uses the images. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 客户端图像信任配置 | 图像信任必须在使用这些图像的每个容器引擎系统上进行配置。|'
- en: 11.4 Podman image scanning
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 Podman 图像扫描
- en: 'Podman is not an image scanner; it leaves this to other tools. But Podman does
    have a nice feature that makes it easier for a scanner to scan an image. Podman
    can directly mount an image that can be scanned. Scanners look at the mounted
    content of an image without having to execute any of the code in the image. Recall
    that you cannot mount containers or images in rootless mode, without first entering
    the user namespaces. Execute the `podman` `image` `mount` command to show the
    error:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 不是一个图像扫描器；它将这项任务留给了其他工具。但 Podman 确实有一个很好的功能，使得扫描器扫描图像变得更加容易。Podman 可以直接挂载可扫描的图像。扫描器查看图像挂载的内容，而无需执行图像中的任何代码。回想一下，您不能在没有首先进入用户命名空间的情况下以
    rootless 模式挂载容器或图像。执行 `podman image mount` 命令以显示错误：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this next example, you first use `podman` `unshare` to enter the user namespace,
    and then you mount the ubi8 image. Finally, change the directory to the mount
    directory, and run a `find` command to locate all of the `setuid` binaries in
    the image. Notice that you use tools from the host operating system to scan the
    image:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，您首先使用 `podman unshare` 进入用户命名空间，然后挂载 ubi8 图像。最后，更改目录到挂载目录，并运行一个 `find`
    命令以定位图像中的所有 `setuid` 二进制文件。注意，您使用来自主机操作系统的工具来扫描图像：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Scanning an image with tools within the image is not safe, since a hacker of
    the image can modify the scanning tools. Podman makes it easy for scanners to
    do their jobs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图像内部工具扫描图像是不安全的，因为图像的攻击者可以修改扫描工具。Podman 使得扫描器更容易完成他们的工作。
- en: 11.5.1 Read-only containers
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.1 只读容器
- en: I often talk about containers in production versus containers in development.
    When a containerized application is in development, it is useful to be able to
    write to the container image and potentially commit that image later. Although
    this is somewhat common, most people switch to using Containerfiles when it comes
    to actually building images. The bottom line is once developers hand off their
    software to quality engineering, they expect content to be treated as read only.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常谈论生产环境中的容器与开发环境中的容器。当容器化应用程序处于开发状态时，能够写入容器图像并在以后提交该图像是有用的。尽管这很常见，但大多数人会在实际构建图像时切换到使用
    Containerfiles。底线是，一旦开发人员将软件移交给质量工程团队，他们期望内容被视为只读。
- en: When running a container in production, I believe it makes sense to run the
    image in read-only mode. Imagine you are running an application that gets hacked.
    The first thing the hacker wants to do is to write the backdoor into the application;
    then, the next time the container or application starts, the container has the
    exploit in place. If the image was read only, the hacker is prevented from leaving
    a backdoor in place and is forced to start the cycle from the beginning.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当在生产环境中运行容器时，我认为以只读模式运行图像是有意义的。想象一下，您正在运行一个被黑客攻击的应用程序。黑客首先想要做的是将后门写入应用程序；然后，下一次容器或应用程序启动时，容器已经有了漏洞。如果图像是只读的，黑客将无法留下后门，并被迫从头开始循环。
- en: 'The `--read-only` option prevents applications from writing content to the
    image and forces applications to only write content to either tmpfs filesystems
    or volumes added to the container. Sometimes you might want to block the container
    from writing anywhere on your system and only read or execute code within the
    container. Another benefit of running containers in read-only mode is that you
    catch errors where you did not know the container was writing to the image. Finally,
    writing on top of a copy-on-write filesystem, like overlayfs, is almost always
    slower than writing to a volume or a tmpfs:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`--read-only` 选项阻止应用程序将内容写入图像，并强制应用程序只将内容写入 tmpfs 文件系统或添加到容器中的卷。有时您可能想要阻止容器在您的系统上的任何位置写入，并且只读取或执行容器内的代码。以只读模式运行容器的另一个好处是，您可以捕获到您不知道容器正在写入图像的错误。最后，在像
    overlayfs 这样的写时复制文件系统上写入，几乎总是比写入卷或 tmpfs 慢：'
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'One problem with running in rootless mode is that applications often expect
    to write to /run, /tmp, and /var/tmp. Podman manages this by automatically mounting
    tmpfs filesystems at those locations:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以 rootless 模式运行的一个问题是，应用程序通常期望写入 /run、/tmp 和 /var/tmp。Podman 通过在这些位置自动挂载 tmpfs
    文件系统来管理这个问题：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Because some users believe allowing any places for a containerized application
    to write, even on tmpfs mounts, is too insecure, Podman added a `--read-only-tmpfs`
    option. The `--read-only-tmpfs` option adds the /run, /tmp, and /var/tmp tmpfs
    when run in `--read-only` mode. If you want to disable this, you can use the `–-read-only-tmpfs=false`
    flag:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一些用户认为允许容器化应用程序在任何地方写入，即使在tmpfs挂载上，也太不安全了，Podman添加了`--read-only-tmpfs`选项。`--read-only-tmpfs`选项在`--read-only`模式下运行时添加了/run、/tmp和/var/tmp
    tmpfs。如果您想禁用此功能，可以使用`–-read-only-tmpfs=false`标志：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 11.5 Security in depth
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 深度安全
- en: In the security field, there is a common idea of *security in depth*. According
    to this notion, multiple layers or tools should be used to safeguard assets. The
    classic analogy for this is the security of an ancient castle, which would usually
    be built high on a hill, have multiple walls, have moats, and have even more security
    features. An attacker would need to break through all of these layers to get to
    the ruler.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全领域，有一个常见的想法，即*深度安全*。根据这一理念，应使用多层或工具来保护资产。这一理念的典型类比是古代城堡的安全，通常建在山顶上，有多个城墙，有护城河，甚至还有更多的安全功能。攻击者需要突破所有这些层才能到达统治者。
- en: Container security works in much the same way. Podman uses all of the security
    mechanisms provided by Linux, giving you security in depth.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 容器安全的工作方式与此类似。Podman使用Linux提供的所有安全机制，为您提供深度安全。
- en: 11.5.1 Podman uses all security mechanisms simultaneously
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.1 Podman同时使用所有安全机制
- en: Podman containers can run with all of the security mechanisms mentioned in this
    chapter. This means a hacked container needs to find a way to escape read-only
    filesystems, namespaces, dropped capabilities, SELinux, seccomp, and so on to
    gain access to your system.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Podman容器可以运行本章提到的所有安全机制。这意味着被黑客攻击的容器需要找到一种方法来逃离只读文件系统、命名空间、丢弃的能力、SELinux、seccomp等等，以获得对您系统的访问权限。
- en: In certain cases, you might need to loosen some security mechanisms to allow
    a container to run. Understanding how to deal with the security features discussed
    in this chapter is always better than just running your containers with the `--privileged`
    flag, which turns off all of your defenses.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能需要放宽一些安全机制，以便容器可以运行。理解如何处理本章讨论的安全功能总是比仅仅使用`--privileged`标志运行容器要好，这个标志会关闭您所有的防御。
- en: Podman shoots for a reasonable amount of security wrapping for containers, but
    it needs to allow general-purpose containers to succeed. Understanding your container
    application’s security requirements and the Podman security features allows you
    to ratchet up the security wrapping of your containers. If you know your container
    does not need to run as root, don’t start it as root. If your container does not
    need any Linux capabilities, drop them. Rootless containers are better than rootful
    containers. Consider also running containers in read-only mode or inside of separated
    user namespaces. You have the ability to make your castle walls thicker around
    your containerized applications by simply employing these measures.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Podman旨在为容器提供合理的安全包装，但它需要允许通用容器成功。了解您的容器应用程序的安全需求和Podman的安全功能，可以使您提高容器安全包装。如果您知道您的容器不需要以root身份运行，就不要以root身份启动它。如果您的容器不需要任何Linux能力，就丢弃它们。无root容器比有root容器更好。您还可以考虑以只读模式或在内部分离的用户命名空间中运行容器。通过简单地采用这些措施，您就有能力使您的容器化应用程序的城堡墙壁更加坚固。
- en: 11.5.2 Where should you run your containers?
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.2 您应该在何处运行您的容器？
- en: I’ll leave you with one final thought. At the beginning of this chapter, I talked
    about the three pigs living in different types of shelters—standalone houses,
    duplexes, and condominium buildings—each slightly less secure than the last. Container
    security can do better than the pigs living in individual housing units, in that
    the units can be stacked together.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我将留给您最后一个想法。在本章的开头，我谈到了住在不同类型庇护所中的三只猪——独立房屋、联排别墅和公寓楼——每个都比上一个稍微不安全一些。容器安全可以做得比住在单独住宅单元的猪更好，因为单元可以堆叠在一起。
- en: 'Imagine you had two different containers: a web frontend and a database with
    credit card data. If you wanted to make sure they were separate, you could put
    them together on the system inside containers or, better yet, put them in containers
    but put them into separate VMs, and then, finally, put the VMs on separate machines.
    You would be able to put your web frontend into a machine running a VM inside
    of a container inside of your DMZ exposed to the internet. You could do all this
    while putting your database inside of your private network, without limited network
    access to your web frontends. The possibilities are nearly endless.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你拥有两个不同的容器：一个用于网页前端的容器和一个包含信用卡数据的数据库容器。如果你想确保它们是隔离的，你可以在系统内部将它们放在同一个容器中，或者更好的做法是将它们放入容器中，但分别放入不同的虚拟机中，最后再将这些虚拟机放在不同的机器上。你将能够将你的网页前端放入一个运行在容器内部的虚拟机中，该虚拟机位于你的DMZ内部，面向互联网。你可以在将你的数据库放在你的私有网络内部的同时完成所有这些操作，而不会限制你的网页前端对网络的访问。可能性几乎是无限的。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Container security has many different facets, including separation of running
    containers, trusting the images and registries, scanning the images, and so on.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器安全有许多不同的方面，包括运行容器的隔离、信任镜像和注册表、扫描镜像等。
- en: Defense in depth means your container tooling takes advantage of as many security
    mechanisms as possible. If one security mechanism fails, the others might still
    protect your system.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度防御意味着你的容器工具利用尽可能多的安全机制。如果某个安全机制失效，其他机制可能仍然能保护你的系统。
- en: Container security is all about protecting the Linux kernel and host filesystem
    from hostile container processes.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器安全全部关乎保护Linux内核和宿主文件系统免受恶意容器进程的侵害。
- en: Setting up and controlling the container images you run on your systems is critical.
    Do not allow your users to run random applications from the internet.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和控制你在系统上运行的容器镜像至关重要。不要允许你的用户从互联网上运行随机应用程序。
