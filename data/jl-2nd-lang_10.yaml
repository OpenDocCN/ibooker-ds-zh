- en: 8 Building a rocket
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 构建火箭
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Building complex data structures made up of many different objects of different
    types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建由许多不同类型的对象组成的复杂数据结构
- en: Abstracting away differences between different but related types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象掉不同但相关的类型之间的差异
- en: In the last chapter, you made some simple composite types to represent different
    types of warriors. However, in more realistic applications, you will have to combine
    many different types of objects into more complex data structures.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你创建了一些简单的复合类型来表示不同类型的战士。然而，在更现实的应用中，你必须将许多不同类型的对象组合成更复杂的数据结构。
- en: To explore this topic, you will be building a rocket in code. Why a rocket?
    Because rockets are made up of many different parts. That gives you an opportunity
    to build composite types out of other composite types and show different ways
    in which abstract types can be used in Julia to facilitate the construction of
    complex data structures. This rocket example will be used to explore many other
    topics later in the book, such as how Julia represents collections of objects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这个主题，你将通过代码构建一枚火箭。为什么是火箭？因为火箭由许多不同的部分组成。这为你提供了从其他复合类型中构建复合类型的机会，并展示了在Julia中使用抽象类型以促进复杂数据结构构建的不同方式。这个火箭示例将在本书的后面部分用于探索许多其他主题，例如Julia如何表示对象的集合。
- en: The code example will start by defining a simple rocket of type Rocket, consisting
    of a Payload, a Tank, and an Engine object. Later you will modify the simple type
    definition to create a more complex multistage rocket made up of multiple StagedRocket
    objects. Next you will modify the code further to add a type Cluster, representing
    a cluster of rocket engines, which can be attached to any rocket stage. At the
    end you will define the function launch! to simulate the launch of a multistage
    rocket.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例将从定义一个简单的Rocket类型的火箭开始，它由一个有效载荷、一个油箱和一个引擎对象组成。稍后你将修改简单的类型定义以创建一个由多个StagedRocket对象组成的更复杂的多级火箭。接下来，你将进一步修改代码以添加一个表示火箭引擎集群的类型Cluster，它可以连接到任何火箭阶段。最后，你将定义一个名为launch!的函数来模拟多级火箭的发射。
- en: 8.1 Building a simple rocket
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 构建简单火箭
- en: 'Let’s start by modeling a simple space rocket in code. This is a single-stage
    rocket made up of the following parts from bottom to top (see figure 8.1):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在代码中模拟一个简单的太空火箭开始。这是一枚单级火箭，从底部到顶部由以下部分组成（见图8.1）：
- en: '*Rocket engine*—Providing propulsion'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*火箭引擎*—提供推进力'
- en: '*Propellant tank*—Containing matter expelled by the engine'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*推进剂油箱*—包含由引擎排出的物质'
- en: '*Payload*—Such as a capsule or satellite'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有效载荷*—例如舱段或卫星'
- en: '![08-01](../Images/08-01.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![08-01](../Images/08-01.png)'
- en: Figure 8.1 The parts a rocket is made of
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 火箭的组成部分
- en: The payload is the useful stuff you want to move around in space. It could be
    a crew module for astronauts or a probe with instruments to explore other planets.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有效载荷是你想在太空中移动的有用物品。它可能是一艘宇航员乘员舱或带有仪器以探索其他行星的探测器。
- en: Such a rocket could be defined by a composite type (listing 8.1). But don’t
    type this out yet; this is just to get you to think about the types you will need
    to define. You will implement different types for tanks and engines. Then you
    will add different attributes and behavior, such as refilling tanks and consuming
    propellant.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一枚火箭可以通过一个复合类型（列表8.1）来定义。但先不要把它打出来；这只是让你思考你需要定义的类型。你将为坦克和引擎实现不同的类型。然后你将添加不同的属性和行为，例如重新填充油箱和消耗推进剂。
- en: Listing 8.1 The first definition of a simple rocket
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 简单火箭的第一个定义
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Instead you will focus your attention on the propellant tank. Propellant is
    the matter a rocket engine expels to move forward. In its simplest form, it is
    a compressed gas being released. In real space rockets, however, it is a combination
    of a fuel such as kerosene or hydrogen and an oxidizer such as liquid oxygen (LOX).
    However, these are details you don’t have to include in your model. Instead, consider
    the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你将专注于推进剂油箱。推进剂是火箭引擎为了前进而排出的物质。在其最简单的形式中，它是一种被释放的压缩气体。然而，在现实空间火箭中，它是由像煤油或氢这样的燃料和像液氧（LOX）这样的氧化剂组成的混合物。然而，这些细节你不需要包含在你的模型中。相反，考虑以下内容：
- en: '*Dry mass*—Mass of an empty tank'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*干重*—空油箱的质量'
- en: '*Total mass*—Mass of a full tank'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*总质量*—满油箱的质量'
- en: '*Propellant mass*—Propellant currently left in the tank'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*推进剂质量*—油箱中目前剩余的推进剂'
- en: '*Mass*—Dry mass plus propellant currently left'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*质量*—干重加上目前剩余的推进剂'
- en: I will show some different way of modeling this in Julia and talk about pros
    and cons of these different approaches.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示一些在 Julia 中建模的不同方法，并讨论这些不同方法的优缺点。
- en: To make it easier to organize the code you write in this chapter, you can spread
    it over multiple files and then have one file (e.g., Rockets.jl), which includes
    all of them. That way, you can load just this file into your REPL to get all the
    code imported. Listing 8.2 assumes you have already made the tanks.jl, engines.jl,
    and payloads.jl files and want to load all of them in one go.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你在这章中编写的代码更容易组织，你可以将其分散到多个文件中，然后有一个文件（例如，Rockets.jl），它包含所有这些文件。这样，你只需将此文件加载到你的
    REPL 中即可导入所有代码。列表 8.2 假设你已经创建了 tanks.jl、engines.jl 和 payloads.jl 文件，并希望一次性加载它们。
- en: Listing 8.2 Rockets.jl
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 Rockets.jl
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is just a suggestion. You can dump all the code into one file if you find
    that more practical.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个建议。如果你发现将所有代码放入一个文件更实用，你可以这样做。
- en: Important When changing the definition of a type in your source code, you will
    need to restart your Julia REPL completely and load your code anew. Changing functions,
    however, only requires pasting the new code into the REPL to take effect.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要：当你在源代码中更改类型的定义时，你需要完全重新启动你的 Julia REPL 并重新加载你的代码。然而，更改函数只需要将新代码粘贴到 REPL 中即可生效。
- en: To allow a rocket to contain many different types of tanks, make Tank an abstract
    type. Since the medium and large tanks defined in the following listing are subtypes
    of Tank, they can be inserted into any field expecting a Tank object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许火箭包含许多不同类型的油箱，将 Tank 制作为一个抽象类型。由于以下列表中定义的中型和大型油箱是 Tank 的子类型，它们可以插入到任何期望
    Tank 对象的字段中。
- en: Listing 8.3 Defining different propellant tanks with fixed capacity
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 定义具有固定容量的不同推进剂油箱
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Make Tank an abstract type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 Tank 制作为一个抽象类型。
- en: ❷ Mutable to allow propellant mass to change
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 可变，允许推进剂质量改变
- en: ❸ drymass and totalmass are not stored.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 干重和总重不存储。
- en: The dry mass and total mass of these tanks is tied to their type. However, you
    could also make a flexible tank, where you can set dry mass and total mass to
    whatever you like, as in the following listing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些油箱的干重和总重与其类型相关联。然而，你也可以制作一个灵活的油箱，你可以设置干重和总重为你想要的任何值，如下所示。
- en: Listing 8.4 Propellant tank with flexible capacity
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.4 具有灵活容量的推进剂油箱
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At the moment, your tanks are just dumb containers of information. They don’t
    do anything useful, so let’s add useful behavior.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你的油箱只是信息化的哑容器。它们没有做任何有用的事情，所以让我们添加有用的行为。
- en: Listing 8.5 Adding propellant tank abilities and behavior
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.5 添加推进剂油箱功能和行为
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Accessors for the propellant field
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 接口用于推进剂字段
- en: ❷ Check if the tank is empty.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查油箱是否为空。
- en: ❸ Calculate the current total mass of a tank.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算油箱当前的总质量。
- en: ❹ Refill the tank with propellant.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 用推进剂重新填充油箱。
- en: ❺ Make the changed tank state available to the REPL.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将更改后的油箱状态提供给 REPL。
- en: ❻ Consume the propellant.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 消耗推进剂。
- en: 'Let’s make some tanks to demonstrate the behavior of these functions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些油箱来演示这些函数的行为：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Make a small tank with 50 kg of propellant.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 制作一个装有 50 kg 推进剂的微型油箱。
- en: ❷ Consume 10 kg of propellant.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 消耗 10 kg 推进剂。
- en: ❸ Check how much propellant is left.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查剩余多少推进剂。
- en: ❹ 5 kg dry mass, 50 kg total mass, and 0 kg propellant
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 5 kg 干重，50 kg 总重，和 0 kg 推进剂
- en: 'In the code example, you are using two different tanks: a small tank and a
    flexi tank. Although consume! and refill! have only been written to deal with
    the Tank type, you can use these functions for both SmallTank and FlexiTank because
    you have implemented drymass and totalmass for all concrete subtypes of Tank.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，你使用了两个不同的油箱：一个小型油箱和一个灵活油箱。尽管 consume! 和 refill! 只是为了处理 Tank 类型而编写的，但你仍然可以使用这些函数为
    SmallTank 和 FlexiTank，因为你已经为 Tank 的所有具体子类型实现了 drymass 和 totalmass。
- en: propellant and propellant! are implemented on the assumption that all Tank subtypes
    have a propellant field. That may not always be the case. However, this is not
    a problem. If you define propellant accessor functions for a concrete Tank subtype,
    these will always take precedence. When Julia searches through the method list
    of a function, it always looks for the methods with the most concrete argument
    types.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 推进剂和推进剂! 是基于所有 Tank 子类型都有推进剂字段的假设实现的。但这并不总是情况。然而，这并不是问题。如果你为具体的 Tank 子类型定义了推进剂访问器函数，这些函数将始终具有优先权。当
    Julia 搜索函数的方法列表时，它总是寻找具有最具体参数类型的函数。
- en: Note In object-oriented languages, accessor functions, also known as setters
    and getters, are important. For instance, in Java, if a type has the propellant
    field, you might write a GetPropellant and SetPropellant method. In Julia, the
    equivalent is propellant for getting a value and propellant! for setting a value.
    However, Julia is not an object-oriented language, so avoid overusing this pattern.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 在面向对象的语言中，访问器函数，也称为设置器和获取器，非常重要。例如，在Java中，如果一个类型有燃料字段，你可能会编写GetPropellant和SetPropellant方法。在Julia中，等效的是propellant用于获取值和propellant!用于设置值。然而，Julia不是面向对象的语言，所以避免过度使用这种模式。
- en: You can use the refill! methods to have tanks automatically filled to the max
    when constructed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用refill!方法在构造时自动将油箱填充到最大容量。
- en: Listing 8.6 Extra constructors, making it easy to create full tanks
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 额外的构造函数，便于创建满油箱
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code examples have shown there are different ways of modeling a propellant
    tank. How do you decide which approach to use in your own code? The first approach
    of having specific types for each capacity, such as having a SmallTank, MediumTank,
    and LargeTank, potentially saves memory if you are creating a lot of these objects.
    The number of bytes an object requires to be stored in memory is dependent on
    the number of fields it has and the size of each field. An Int8 field only consumes
    one byte, but an Int64 field would consume eight bytes. Each FlexiTank object
    consumes three times as much space in memory as the fixed tank objects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例已经展示了建模燃料油箱的不同方法。你如何在自己的代码中决定使用哪种方法？对于每个容量都有特定类型的第一种方法，例如拥有SmallTank、MediumTank和LargeTank，如果你创建了很多这样的对象，可能会节省内存。一个对象在内存中存储所需的字节数取决于它拥有的字段数量以及每个字段的大小。Int8字段仅消耗一个字节，但Int64字段将消耗八个字节。每个FlexiTank对象在内存中占用的空间是固定油箱对象的3倍。
- en: However, in the code you are writing, this is of no concern. You don’t have
    very many tanks, and even if you had thousands of tanks, it would not matter.
    The FlexiTank would be a better option, as it offers more flexibility in usage.
    So why does the book contain definitions of fixed tanks?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在你所编写的代码中，这并不重要。你并没有很多油箱，即使你有成千上万的油箱，这也不会有什么影响。FlexiTank将是一个更好的选择，因为它提供了更多的使用灵活性。那么，为什么这本书包含了固定油箱的定义呢？
- en: By contrasting these different approaches to modeling a tank, you get a better
    sense of what is possible with Julia’s type system. There will be cases where
    this kind of tradeoff is worth it. For example, imagine simulating a city of millions
    of people. Each person might have attributes such as position, hunger, tiredness,
    money in pocket, clothes, shoes, and so on. When dealing with that many objects,
    you might want to think harder about reducing the size of your objects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对比这些不同的建模油箱的方法，你可以更好地了解Julia的类型系统可以实现什么。有些情况下，这种权衡是值得的。例如，想象模拟一个拥有数百万人口的城市。每个人可能都有位置、饥饿、疲劳、口袋里的钱、衣服、鞋子等属性。当处理这么多对象时，你可能需要更深入地考虑减少对象的大小。
- en: 8.2 Maintaining invariants in your code
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 在代码中维护不变量
- en: An important concept to know when writing code is *invariants*. Invariants are
    things that must always be true during execution of your whole program or during
    some portion of it. This will probably sound very abstract, so let me motivate
    the need to express invariants by implementing a function, propellant!, which
    sets the quantity of propellant in a tank.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，了解一个重要概念是*不变量*。不变量是在你的整个程序执行期间或其某个部分执行期间必须始终为真的东西。这可能会听起来非常抽象，所以让我通过实现一个函数propellant!来设置油箱中的燃料量来阐述表达不变量的必要性。
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Dry mass 5 kg, total mass 50 kg, and 10 kg of propellant
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 干质量5公斤，总质量50公斤，和10公斤的燃料
- en: ❷ Set propellant mass to 100 kg.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将燃料质量设置为100公斤。
- en: 'What is wrong here? You set the mass of the propellant to be larger than the
    max total mass of the tank. That should not be possible. At any time, the following
    tank invariant should be true:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有什么问题？你将燃料的质量设置得大于油箱的最大总质量。这不应该可能。在任何时候，以下油箱的不变量应该是真实的：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: One way to make sure this remains true is modifying the propellant! setter method
    to throw an exception if the inputs are wrong.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 确保这一点始终成立的一种方法是将燃料设置器方法修改为，如果输入错误则抛出异常。
- en: Listing 8.7 Propellant setter maintaining the tank invariant
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 燃料设置器维护油箱的不变量
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Check if the new propellant amount breaks the tank invariant.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查新的燃料量是否破坏了油箱的不变量。
- en: ❷ Signal a domain error by throwing an exception.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过抛出异常来发出领域错误信号。
- en: DomainError is an exception type defined in Julia’s standard library. Domain
    refers to the set of legal input values for a function argument. Thus, providing
    an amount larger than the totalmass is a domain error.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: DomainError是Julia标准库中定义的一种异常类型。Domain指的是函数参数的合法输入值集合。因此，提供大于总质量的数值是一个域错误。
- en: 'However, this is not the only way you can end up breaking your tank invariant.
    Here you are making a tank with 90 kg of propellant, while the total mass can
    only be 50 kg:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是你唯一可能破坏你的坦克不变量的方法。这里你正在制作一个含有90公斤推进剂的坦克，而总质量只能为50公斤：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Dealing with these problems forces you to learn about how composite objects
    are created in Julia.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些问题迫使你了解Julia中复合对象是如何创建的。
- en: 8.3 Making objects with constructor functions
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 使用构造函数函数创建对象
- en: When you define a composite type, Julia creates a special function called a
    *constructor* with the same name as your type. A constructor is responsible for
    making an instance (object) of the type it is associated with. Julia adds two
    methods to the constructor function, which takes the same number of arguments
    as you have fields. One method uses type annotations for its arguments, as specified
    for each field in the struct. The other takes arguments of Any type.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个复合类型时，Julia会创建一个与你的类型同名的一个特殊函数，称为*构造函数*。构造函数负责创建与其关联的类型的一个实例（对象）。Julia向构造函数函数添加两个方法，这些方法的参数数量与你拥有的字段数量相同。一个方法使用类型注解为其参数，正如在结构中为每个字段指定的那样。另一个接受Any类型的参数。
- en: However, you can add methods to this constructor function in the same manner
    as any other function. You can add methods that create a full tank if the amount
    of propellant is not specified.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以像添加任何其他函数的方法一样，向这个构造函数函数添加方法。如果你未指定推进剂数量，你可以添加创建满油箱的方法。
- en: Listing 8.8 Creating full tanks when the amount of propellant is not specified
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.8 当未指定推进剂数量时创建满油箱
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you use methods, you can see that a third method has been added to the FlexiTank
    function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用方法，你可以看到FlexiTank函数已添加了第三个方法：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Existing methods defined by Julia
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Julia定义的现有方法
- en: ❷ New method you’ve added
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 你添加的新方法
- en: 'The following is an example of using these new methods to create full tanks:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用这些新方法创建满油箱的示例：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Automatically filled up with 45 kg of propellant
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 自动填充了45公斤的推进剂
- en: ❷ Filled up with 2,050 kg of propellant
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 填充了2,050公斤的推进剂
- en: But what do you do if you don’t want users of your types to set propellant mass
    independently? Perhaps you want to reduce the chance of breaking the important
    tank invariant discussed earlier. Is there, perhaps, a way of preventing Julia
    from making its own constructor methods?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你不想让你的类型的用户独立设置推进剂质量怎么办？也许你想要减少破坏之前讨论的重要坦克不变量的可能性。也许有一种方法可以防止Julia创建自己的构造函数方法？
- en: 8.4 Differences between outer and inner constructors
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 外部构造函数与内部构造函数之间的差异
- en: What you have just covered is called *outer constructors*, when using Julia
    terminology. The constructors are defined *outside* of the composite type definition.
    Outer constructors add methods to the built-in ones. If, instead, you want to
    replace Julia’s constructor methods with your own, you need to define the constructor
    functions inside the struct definition, as follows.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚所涉及的是Julia术语中的*外部构造函数*。构造函数是在复合类型定义外部定义的。外部构造函数向内置构造函数添加方法。如果你不想用你自己的方法替换Julia的构造函数方法，你需要在结构定义内部定义构造函数函数，如下所示。
- en: Listing 8.9 Defining an inner constructor for FlexiTank
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.9 为FlexiTank定义内部构造函数
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Notice new replaces FlexiTank
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注意新版本替换了FlexiTank
- en: Inner constructors introduce you to a special function called new. It is only
    available inside an inner constructor—nowhere else. You need it because creating
    an inner constructor removes all constructor methods created by Julia. In other
    words, you can no longer call any of them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 内部构造函数向你介绍了一个名为new的特殊函数。它仅在内部构造函数内部可用——其他任何地方都不可用。你需要它，因为创建内部构造函数会移除Julia创建的所有构造函数方法。换句话说，你不能再调用它们中的任何一个。
- en: 'new is very similar to the default constructor methods provided by Julia, with
    some important differences: you can supply new with zero or more arguments but
    never more arguments than the number of fields in your composite type. What happens
    to the fields you don’t provide a value for? They get a random value.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: new与Julia提供的默认构造函数方法非常相似，但有一些重要差异：你可以向new提供零个或多个参数，但参数数量不能超过你的复合类型中的字段数量。对于未提供值的字段会发生什么？它们会得到一个随机值。
- en: 'How do you know that your inner constructor replaces all Julia-provided constructor
    methods? You can reload your REPL environment and test:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道你的内部构造器替换了所有Julia提供的构造函数方法？你可以重新加载你的REPL环境并测试：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Julia can no longer find a method accepting a third argument.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Julia无法再找到接受第三个参数的方法。
- en: ❷ Check the number of methods attached to constructor.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查附加到构造函数的方法数量。
- en: You can now see that methods only reports a single method for the FlexiTank
    constructor.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到方法只报告FlexiTank构造函数的单个方法。
- en: 8.5 Modeling rocket engines and payloads
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 建模火箭发动机和有效载荷
- en: Let’s switch gears and talk about the payload you want to send into space and
    the rocket engines that will provide the rocket’s propulsion. The payload could
    be a probe; satellite; crew capsule; or, I suppose, a Tesla Roadster if you are
    Elon Musk.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转换话题，谈谈你想要送入太空的有效载荷以及提供火箭推进力的火箭发动机。有效载荷可能是一个探测器；卫星；乘员舱；或者，如果你是埃隆·马斯克，可能是一辆特斯拉Roadster。
- en: Listing 8.10 Defining rocket payload
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.10 定义火箭有效载荷
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This may seem simplistic, but remember you are creating models. Models only
    contain properties required to answer questions of interest. For example, an initial
    model of smartphone may just be a block of wood, with no buttons, screen, or color
    scheme. Why? Because, initially, the questions you want answered are, “Is this
    shape and size comfortable to carry in my pocket? How much space do you have available
    to create a screen and electronics inside?”
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很简单，但请记住你正在创建模型。模型只包含回答感兴趣问题所需的属性。例如，智能手机的初始模型可能只是一个木头块，没有任何按钮、屏幕或配色方案。为什么？因为，最初，你想回答的问题是，“这个形状和大小是否适合放入我的口袋里？你有多少空间可以用来创建屏幕和内部电子设备？”
- en: 'The same applies to designing and building a rocket. Initially, you are only
    interested in mass budgets. You want to know things such as the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，设计和建造火箭也是如此。最初，你只对质量预算感兴趣。你想知道以下内容：
- en: How much propellant do I need?
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我需要多少推进剂？
- en: How big of a payload can I launch into orbit?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我能将多大的有效载荷送入轨道？
- en: How far can a given rocket go?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定的火箭能飞多远？
- en: To answer such questions you *don’t* need to include what sort of instruments
    exist on the space probe or what kind of batteries or solar cells it has in your
    model. Important attributes of a rocket engine are mass, thrust, and Isp (specific
    impulse). You can think of thrust as how powerful the engine is and Isp as how
    fuel efficient it is.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这样的问题，你*不需要*在你的模型中包含空间探测器上存在的仪器类型或它所拥有的电池或太阳能电池的类型。火箭发动机的重要属性是质量、推力和Isp（比冲）。你可以把推力看作是发动机的强大程度，把Isp看作是它的燃油效率。
- en: Listing 8.11 Defining a custom rocket engine
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.11 定义自定义火箭发动机
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Mass of rocket engine in kg
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 火箭发动机质量（千克）
- en: ❷ Thrust exerted by rocket engines in Newtons
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 火箭发动机产生的推力（牛顿）
- en: ❸ Specific impulse (propellant efficiency)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 比冲（推进剂效率）
- en: You can also define types for specific engines with known properties, such as
    the Rutherford engine used in the Electron rocket and the Merlin engine used in
    the Falcon 9 rocket.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为具有已知属性的具体发动机定义类型，例如在Electron火箭中使用的Rutherford发动机和在Falcon 9火箭中使用的Merlin发动机。
- en: Listing 8.12 Defining the Rutherford and Merlin rocket engines
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.12 定义Rutherford和Merlin火箭发动机
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Engines are empty structs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 发动机是空的struct。
- en: ❷ Use accessor functions to get engine properties.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用访问器函数获取发动机属性。
- en: thrust is the force produced by the rocket engine. If you know the total mass
    of the rocket you can calculate how much the whole rocket accelerates once the
    rocket engines are fired up. You get this from Newton’s second law, which states
    that force *F* is proportional to mass *m* times acceleration *a*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 推力是火箭发动机产生的力。如果你知道火箭的总质量，你可以计算出火箭发动机启动后整个火箭的加速度是多少。这是通过牛顿第二定律得到的，该定律表明力 *F*
    与质量 *m* 乘以加速度 *a* 成正比。
- en: '![08-01-Equation_8-1](../Images/08-01-Equation_8-1.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![08-01-Equation_8-1](../Images/08-01-Equation_8-1.png)'
- en: However, to know how much mass you are pushing at any given time, you need to
    know how much propellant the engine consumes each second. Thrust alone cannot
    tell you that; you need specific impulse (Isp). A high-Isp engine is more propellant
    efficient, meaning it will consume less propellant for the same amount of thrust.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要知道你在任何给定时间推动的质量，你需要知道发动机每秒消耗多少推进剂。仅仅推力不能告诉你这一点；你需要比冲（Isp）。高比冲发动机更高效，意味着它将在相同的推力下消耗更少的推进剂。
- en: Note In physics, you usually denote impulse with an *I*. Thus *Isp* clarifies
    you are referring to *specific impulse*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在物理学中，你通常用*I*表示冲量。因此*Isp*明确表示你指的是*比冲*。
- en: '*Isp* is analogous to gas mileage for a car. However, unlike a car on the road,
    a rocket in outer space continues moving even without thrust, so you cannot measure
    fuel efficiency (or propellant efficiency) by how far one kg of propellant gets
    you. Instead, you measure it in terms of how many seconds a unit of propellant
    can sustain a force of 1 G (the force of gravity on Earth). This allows you to
    calculate mass flow (consumption of propellant per second):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*Isp*类似于汽车的油耗。然而，与在路上的汽车不同，在太空中的火箭即使在没有推力的情况下也会继续移动，因此你不能通过一公斤推进剂能走多远来衡量燃料效率（或推进剂效率）。相反，你通过衡量一单位推进剂能维持1
    G（地球上的重力）的力多少秒来衡量它。这允许你计算质量流量（每秒推进剂的消耗量）：'
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ m/s² acceleration of gravity on Earth
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 地球上的重力加速度为m/s²
- en: ❷ The amount of mass exiting the engine is measured in kg/s.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从发动机排出的质量以kg/s来衡量。
- en: 'You can, for example, use this to calculate the propellant consumed per second
    in a Falcon 9 rocket. It has nine Merlin 1D engines, each with a specific impulse
    of 282 s and thrust of 845 kN:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用这个来计算Falcon 9火箭每秒消耗的推进剂量。它有九个Merlin 1D发动机，每个发动机的比冲为282 s，推力为845 kN：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So you get that a Falcon 9 rocket consumes an estimated 2.7 tons of propellant
    each second.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你得到Falcon 9火箭每秒消耗大约2.7吨推进剂的估计值。
- en: 8.6 Assembling a simple rocket
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 组装一个简单的火箭
- en: Now you have all the pieces to assemble your rocket. So let the rocket building
    start!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了组装火箭的所有部件。那么，让我们开始火箭的建造吧！
- en: Listing 8.13 Rocket with payload, tank, and engine
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.13 带有载荷、储罐和发动机的火箭
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You will make a rocket resembling the Electron rocket manufactured by Rocket
    Lab.^([1](#pgfId-1016353)) It can put a payload into low Earth orbit weighing
    300 kg. You will make one stage of this rocket with a small tank and a Rutherford
    engine. The Rutherford engine, a small rocket engine, is used in the first and
    second stage of the Electron rocket.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你将制作一个类似Rocket Lab制造的Electron火箭的火箭。[^([1](#pgfId-1016353))] 它可以将重量为300千克的载荷送入近地轨道。你将用一个小储罐和一个Rutherford发动机制作这个火箭的一个阶段。Rutherford发动机是一种小型火箭发动机，用于Electron火箭的第一和第二阶段。
- en: 'For compactness I have instructed the REPL not to print the value of the first
    three assignments by tacking on a semicolon ;. You can remove the semicolon to
    see the difference:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了紧凑性，我指示REPL不要打印前三个赋值的值，通过附加分号;。你可以移除分号来查看差异：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you know a bit about rocketry, you may realize there are multiple problems
    with the previous rocket configuration:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你略知火箭学，你可能意识到之前的火箭配置存在多个问题：
- en: The real-world Electron rocket has nine Rutherford engines, not just one.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现实中的Electron火箭有九个Rutherford发动机，而不仅仅是一个。
- en: Space rockets have multiple stages, which separate as the rocket goes higher;
    your rocket only has a single stage.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太空火箭有多个阶段，随着火箭飞得更高，这些阶段会分离；你的火箭只有一个阶段。
- en: 8.7 Creating a rocket with multiple stages and engines
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7 创建多阶段和发动机的火箭
- en: Let’s fix these problems. An important insight is realizing that a multistage
    rocket is a bit like a Russian Matryoshka doll.^([2](#pgfId-1016489)) You could
    make the payload of rocket another rocket. The payload of this next rocket could
    be another rocket and so on. Figure 8.2 illustrates how a staged rocket is composed
    of multiple nested rockets.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决这些问题。一个重要的洞察是意识到多阶段火箭有点像俄罗斯套娃.^([2](#pgfId-1016489)) 你可以将火箭的载荷做成另一个火箭。下一个火箭的载荷可以是另一个火箭，以此类推。图8.2说明了阶段火箭是如何由多个嵌套火箭组成的。
- en: '![08-02](../Images/08-02.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![08-02](../Images/08-02.png)'
- en: Figure 8.2 Rocket stages
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 火箭阶段
- en: 'It shows a multistage rocket, where you keep popping off the top to expose
    the rocket’s payload. Let me cover each numbered stage:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 它展示了一个多阶段火箭，你不断地移除顶部以露出火箭的载荷。让我来解释每个编号的阶段：
- en: The whole multistage rocket with all parts is called a *space vehicle*. The
    first stage is called the *booster*.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个多阶段火箭及其所有部件统称为*航天器*。第一阶段被称为*助推器*。
- en: Pop open the space vehicle, and the *second stage* rocket is exposed.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开航天器，露出**第二阶段**火箭。
- en: The payload of the second stage is the *third stage*.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二阶段的有效载荷是**第三阶段**。
- en: The third stage is protected by a *fairing*, a protective shell for the payload
    (your model will ignore the fairing).
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三阶段由一个**整流罩**保护，这是用于保护有效载荷（你的模型将忽略整流罩）的防护壳。
- en: When the launch is finished, the final payload is delivered into space. This
    payload will be a *spacecraft*, such as a satellite, moon lander, or capsule.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发射完成时，最终的有效载荷被送入太空。这个有效载荷将是一艘*航天器*，例如卫星、月球着陆器或舱。
- en: To make it possible to put rockets inside rockets, you will change Rocket to
    an abstract type and define new concrete subtypes, as follows.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要使火箭内部可以放置火箭，你需要将Rocket改为抽象类型，并定义新的具体子类型，如下所示。
- en: Listing 8.14 Allowing a rocket to be the payload of another rocket
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.14 允许火箭成为另一枚火箭的有效载荷
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Make Rocket an abstract type.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将Rocket定义为抽象类型。
- en: ❷ Turn Payload into a subtype of Rocket.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将有效载荷转换为Rocket的子类型。
- en: ❸ Rename payload to next stage for clarity.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为了清晰起见，将有效载荷重命名为下一阶段。
- en: ❹ Allow use of the old constructor.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 允许使用旧的构造函数。
- en: But before you build a rocket, you need some more adjustments. The real-life
    Electron rocket has nine Rutherford engines in the first stage—what we call the
    booster. You currently have no way to add more than one engine. To solve this,
    you will define a new engine subtype called Cluster. This new type is designed
    to model a cluster of many identical engines.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但在你建造火箭之前，你需要做一些更多的调整。现实生活中的Electron火箭在第一阶段有九个Rutherford发动机——我们称之为助推器。你目前无法添加超过一个发动机。为了解决这个问题，你将定义一个新的发动机子类型，称为Cluster。这种新类型旨在模拟许多相同发动机的集群。
- en: Figure 8.3 doesn’t show every type. For instance, I could only get space for
    the MediumTank and FlexiTank under the abstract Tank type.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3没有显示每个类型。例如，我只能在抽象类型Tank下获得MediumTank和FlexiTank的空间。
- en: '![08-03](../Images/08-03.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![08-03](../Images/08-03.png)'
- en: Figure 8.3 A UML diagram of relations between different parts of a rocket
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 火箭不同部分之间的关系UML图
- en: Using hollow arrows, the diagram shows how StagedRocket and Payload are subtypes
    of the abstract type Rocket. The filled arrow shows that StagedRocket has a field,
    nextstage, that points to another Rocket object.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空心箭头，该图显示了StagedRocket和Payload是抽象类型Rocket的子类型。实心箭头显示StagedRocket有一个字段，nextstage，它指向另一个Rocket对象。
- en: Let’s look at how to implement the Cluster type (listing 8.15). The UML diagram
    says it is both a subtype of Engine and it points to another engine through the
    engine field.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现Cluster类型（列表8.15）。UML图说明它既是Engine的子类型，又通过engine字段指向另一个发动机。
- en: Listing 8.15 Defining a cluster of rocket engines
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.15 定义火箭发动机集群
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Number of identical engines in the cluster
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 集群中相同发动机的数量
- en: You will notice that the specific impulse does not change. Fuel efficiency does
    not change just because you add more engines. However, adding more engines will
    increase the mass of the cluster as well as the total thrust.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到比冲没有改变。燃料效率不会因为添加更多发动机而改变。然而，添加更多发动机会增加集群的质量以及总推力。
- en: What about a heterogenous engine cluster? Could you make a cluster of engines
    of different types? The challenge is deciding how to calculate the Isp of a cluster
    in which each engine has a different specific impulse. You will, however, make
    a heterogenous cluster of engines in chapter 12.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 那么一个异构的发动机集群呢？你能制作由不同类型的发动机组成的集群吗？挑战在于决定如何计算每个发动机具有不同比冲的集群的Isp。然而，你将在第12章中制作一个异构的发动机集群。
- en: You can use these abstractions to define a function, update!, that takes care
    of depleting propellant as you simulate your rocket flying. You simulate by performing
    small time steps Δt.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些抽象来定义一个函数，update!，它负责在模拟火箭飞行时消耗推进剂。你通过执行小的时间步Δt来进行模拟。
- en: This is a common strategy employed when writing simulations of real-time systems.
    When simulating something complex with many parts, it becomes too complicated
    to perform an analytical solution by solving a single math equation. Video games
    are made like this as well. Every object moving around in a game will have an
    update! function akin to the one shown in the following listing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在编写实时系统模拟时常用的一种策略。当模拟具有许多部件的复杂事物时，通过解一个单独的数学方程来进行分析解法会变得过于复杂。视频游戏也是这样制作的。游戏中移动的每个对象都将有一个更新！函数，类似于以下列表中所示。
- en: Listing 8.16 Updating the propellant mass after Δt time has elapsed
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.16 在经过Δt时间后更新推进剂质量
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Say you want to make a three-stage Electron rocket. The third stage is tiny
    and, thus, only needs a very tiny engine. The company developing the Electron
    rocket is making a tiny engine, named Curie, for this purpose. The full specifications
    for this engine are not yet known, so you will define this engine based on some
    guesswork.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想制作一个三阶段的电子火箭。第三阶段非常小，因此只需要一个非常小的发动机。开发电子火箭的公司正在为此目的制造一个名为Curie的小型发动机。这个发动机的完整规格尚不清楚，因此您将基于一些猜测来定义这个发动机。
- en: Listing 8.17 Defining a tiny engine for the third stage
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.17 定义第三阶段的小型发动机
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Mass and Isp had to be guessed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 质量（Mass）和比冲（Isp）需要猜测。
- en: ❷ The only known specification
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 唯一已知的规格
- en: 'You now have enough functionality to define an Electron rocket composed of
    multiple stages:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经有足够的功能来定义一个由多个阶段组成的电子火箭：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Later, when performing physics calculations, it is helpful to abstract away
    how a property, such as mass, is determined for a rocket or part of a rocket.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行物理计算时，抽象出火箭或火箭的一部分属性（如质量）是如何确定的，这很有帮助。
- en: Listing 8.18 Calculating the total mass of a staged rocket
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.18 计算分阶段火箭的总质量
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can see the benefits of abstraction of mass in how mass(r::StagedRocket)
    is defined. After implementing this function you don’t have to concern yourself
    with details about the payload (nextstage). It could be a payload or another staged
    rocket with 20 stages. You don’t have to know; the differences are abstracted
    away.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到在如何定义mass(r::StagedRocket)时质量抽象化的好处。在实现这个函数之后，您不必关心有关有效载荷（nextstage）的细节。它可能是一个有效载荷或另一个有20个阶段的分阶段火箭。您不必知道；这些差异被抽象化了。
- en: Likewise, you don’t have to concern yourself with whether you are getting the
    mass of a single engine or an engine cluster. Imagine you had implemented this
    function *before* creating the Cluster type. You would not need to change this
    implementation because as long as Cluster is of type Engine and has implemented
    mass, everything works.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您也不必关心您得到的是单个发动机的质量还是发动机集群的质量。想象一下，在创建Cluster类型之前您已经实现了这个函数。您不需要更改这个实现，因为只要Cluster是Engine类型并且实现了mass，一切都会正常工作。
- en: 8.8 Launching a rocket into space
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8 将火箭发射到太空
- en: The update! function allows you to keep track of propellant consumption. When
    called, it gives you the remaining propellant. When this quantity has reached
    zero, you know your rocket cannot fly much higher, as the velocity will steadily
    decline until it becomes negative. You will implement a new function, launch!,
    which figures out the altitude your rocket reaches before it runs out of propellant,
    as well as how much time has passed when that occurs.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: update!函数允许您跟踪推进剂的消耗。当调用时，它给您剩余的推进剂量。当这个数量达到零时，您知道您的火箭不能再飞得更高，因为速度将稳步下降，直到变为负值。您将实现一个新的函数launch!，该函数确定火箭在没有推进剂之前达到的高度，以及那时经过的时间。
- en: 'The rocket is pushed up with a certain force determined by the thrust of the
    engines *T*. However, this force has to work against the forces of gravity. Gravity
    exerts force on a rocket proportional to the mass *m* of the rocket and the acceleration
    *g* of gravity on Earth:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 火箭被发动机的推力T产生的某个力推上去。然而，这个力必须与重力作用力相抗衡。重力对火箭施加的力与火箭的质量m成正比，与地球上的重力加速度g成正比：
- en: '![08-03-Equation_8-2](../Images/08-03-Equation_8-2.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![08-03-Equation_8-2](../Images/08-03-Equation_8-2.png)'
- en: 'From this you can determine the acceleration of the rocket when it is launched:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里您可以确定火箭发射时的加速度：
- en: '![08-03-Equation_8-3](../Images/08-03-Equation_8-3.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![08-03-Equation_8-3](../Images/08-03-Equation_8-3.png)'
- en: During the discussion on update! I noted you are simulating the launch as a
    set of small time increments Δ*t*. For one small time increment you can find how
    much the velocity changes in that increment (figure 8.4).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论update!时，我注意到您正在将发射模拟为一系列小的时间增量Δ*t*。对于一个小的时间增量，您可以找到在这个增量中速度的变化量（图8.4）。
- en: '![08-04](../Images/08-04.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![08-04](../Images/08-04.png)'
- en: Figure 8.4 Velocity of rocket after launch. The x-axis shows number of seconds
    after launch.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 火箭发射后的速度。x轴表示发射后的秒数。
- en: These observations are the basis for implementing the launch! function. You
    add up changes in velocity, Δ*v*, over many small time increments. For every increment,
    you assume velocity is constant and use that to calculate distance traveled Δ*h
    = v ×* Δ*t*. Adding up all the distances traveled across every little increment
    you get the total distance traveled, *h*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些观察结果是实现 launch! 函数的基础。你将速度的变化 Δ*v* 在许多小的时间增量中累加起来。对于每一个增量，你假设速度是恒定的，并使用它来计算行驶的距离
    Δ*h = v × Δ*t*。将所有小增量中行驶的距离累加起来，得到总行驶距离 *h*。
- en: 'This calculation can be visualized with a plot. Every bar is equal to Δ*h*
    because each bar is Δ*t* wide and *v* tall. Thus, adding up the area of all the
    bars is equal to the distance traveled. The smaller you make the increments Δ*t*,
    the more accurate the calculation will become:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算可以用图表来可视化。每个条形的高度等于 Δ*h*，因为每个条形的宽度是 Δ*t*，高度是 *v*。因此，将所有条形的面积累加起来等于行驶的距离。你使增量
    Δ*t* 越小，计算就越准确：
- en: '![08-04-Equation_8-4](../Images/08-04-Equation_8-4.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![08-04-方程_8-4](../Images/08-04-方程_8-4.png)'
- en: In mathematical terms you are performing an approximation of the integral of
    the velocity. The code in listing 8.19 is an implementation of these ideas.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 用数学术语来说，你正在对速度的积分进行近似。列表 8.19 中的代码是实现这些想法的一个实现。
- en: Note The code uses a cutoff point of 1,000 seconds. The rocket may not have
    consumed all fuel within that time if you use large tanks. You could use a while
    loop instead, but you would risk an infinite loop.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：代码使用 1,000 秒的截止点。如果你使用大油箱，火箭可能不会在那么长时间内消耗完所有燃料。你可以使用一个 while 循环，但你会面临无限循环的风险。
- en: Listing 8.19 Simulating a rocket launch and determining the maximum altitude
    of the rocket
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.19 模拟火箭发射并确定火箭的最大高度
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Stop the simulation at 1,000 seconds.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 1,000 秒时停止模拟。
- en: ❷ Mass changes because propellant is consumed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 质量变化，因为推进剂被消耗了。
- en: ❸ Return time spent and distance traveled
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回花费的时间和行驶的距离
- en: ❹ Use velocity from the previous time increment.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用前一个时间增量中的速度。
- en: 'I put the launch! function into a file called simulate.jl, but you can just
    paste it into the REPL. You can then construct a rocket and launch it:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我将 launch! 函数放入了一个名为 simulate.jl 的文件中，但你也可以将其粘贴到 REPL 中。然后你可以构建一个火箭并发射它：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'From the output, you can see that your rocket spent 45 seconds getting to an
    altitude of about 31 kilometers. For real rockets this will be different because
    they have to deal with air resistance. You basically launched this rocket on an
    Earth without atmosphere. You can see that all the fuel in the tank has been spent:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，你可以看到你的火箭花费了 45 秒才达到大约 31 公里的高度。对于真正的火箭来说，这将是不同的，因为它们必须处理空气阻力。你基本上是在一个没有大气层的地球上发射了这枚火箭。你可以看到油箱中的所有燃料都已经用完了：
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As an exercise, you can try launching the rocket with different payload and
    tank sizes. Do you notice that larger tanks don’t always get you further? This
    is because they cause the gravitational pull on your rocket to increase. Thus
    the force of gravity may end up being stronger than the force of thrust from your
    rocket engine.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以尝试用不同的载荷和油箱大小来发射火箭。你注意到更大的油箱并不总是能让你飞得更远吗？这是因为它们会增加你的火箭所受的引力。因此，重力可能最终会大于火箭发动机的推力。
- en: This simulated launch has a number of limitations beyond not considering air
    resistance. The simulation is also unable to deal with staged rockets.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不考虑空气阻力之外，这个模拟还有许多限制。该模拟也无法处理分级火箭。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can define your own custom constructors to make sure objects are initialized
    with valid values.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以定义自己的自定义构造函数，以确保对象用有效的值初始化。
- en: An inner constructor replaces the default constructor provided by Julia. Outer
    constructors are just convenient constructors defined outside the composite type
    definition.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部构造函数替换了 Julia 提供的默认构造函数。外部构造函数只是在外部复合类型定义中定义的方便构造函数。
- en: An abstract type is defined with, for example, abstract type Payload end. Abstract
    types cannot have fields, and you cannot make objects of them (you cannot instantiate
    an abstract type).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类型是用例如抽象类型 Payload end 来定义的。抽象类型不能有字段，并且你不能创建它们的对象（你不能实例化一个抽象类型）。
- en: 'Both abstract and concrete types can be a subtype of another abstract type.
    However, no concrete type can be a subtype of another concrete type. <: is the
    subtype operator.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类型和具体类型都可以是另一个抽象类型的子类型。然而，没有具体类型可以是另一个具体类型的子类型。`<:` 是子类型运算符。
- en: Combining abstract types with multiple dispatch allows you to abstract away
    differences between related types, so they can be used interchangeably.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将抽象类型与多态结合使用，可以使你抽象掉相关类型之间的差异，因此它们可以互换使用。
- en: '* * *'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)Rocket Lab is a space company originating in New Zealand, which launches
    small satellites of a few hundred kg into orbit.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: (1.) Rocket Lab 是一家起源于新西兰的太空公司，该公司将重量为几百公斤的小型卫星送入轨道。
- en: ^(2.)A *matryoshka* is a Russian nesting doll. Each doll has a smaller wooden
    doll inside.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: (2.) **俄罗斯套娃**是一种俄罗斯嵌套娃娃。每个娃娃内部都嵌套着一个小木偶。
