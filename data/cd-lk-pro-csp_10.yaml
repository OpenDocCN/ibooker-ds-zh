- en: 6 Test-driven development and dependency injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 测试驱动开发和依赖注入
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using locks, mutexes, and semaphores
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锁、互斥锁和信号量
- en: Converting between synchronous and asynchronous methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同步和异步方法之间进行转换
- en: Using dependency injection with unit tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单元测试进行依赖注入
- en: In chapters 3 and 4, we looked at the codebase we inherited and discussed potential
    improvements. To solve the issues we found, we started a new version of the Flying
    Dutchman Airlines service and implemented the database access layer with Entity
    Framework Core in chapter 5\. In this chapter, we’ll start implementing the business
    logic by moving into the repository layer and creating the `CustomerRepository`
    class. Figure 6.1 shows where we are in the scheme of the book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章和第4章中，我们审查了继承的代码库并讨论了潜在的改进。为了解决我们发现的问题，我们在第5章启动了新的飞剪航空公司服务，并实现了使用Entity
    Framework Core的数据库访问层。在本章中，我们将开始通过进入仓库层并创建`CustomerRepository`类来实现业务逻辑。图6.1显示了我们在本书结构中的位置。
- en: '![](../Images/06_01.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1](../Images/06_01.png)'
- en: Figure 6.1 After having implemented the database access layer in chapter 5,
    we’ll move on to implementing the `CustomerRepository` in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 在第5章实现了数据库访问层之后，我们将继续在本章实现`CustomerRepository`。
- en: 'The repository layer is the meat and potatoes of our service. In the repository
    layer we do the following two things:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库层是我们服务的关键部分。在仓库层，我们做以下两件事：
- en: Query and manipulate the database by communicating with the database access
    layer
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过与数据库访问层通信查询和操作数据库
- en: Return the requested entities or information to the service layer
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求的实体或信息返回到服务层
- en: We want to create isolated, small, clean, and readable methods that follow the
    single-responsibility principle (SRP). Following the SRP makes it easier to test
    and maintain our code because we can quickly understand every method and fix any
    potential bugs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望创建独立、小巧、清洁且易于阅读的方法，这些方法遵循单一职责原则（SRP）。遵循SRP使得测试和维护我们的代码更加容易，因为我们能够快速理解每个方法并修复任何潜在的错误。
- en: '| ![](../Images/ThumbsUp.png)   |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| ![点赞](../Images/ThumbsUp.png)   |'
- en: The single-responsibility principle
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: 'One of the clean code tenets identified by Robert Martin, the single-responsibility
    principle (SRP) is the harmonica of clean code: easy to play, but mastery takes
    years of practice. The SRP builds on the concept of “separation of concerns” as
    evangelized (and coined) by Edsger Dijkstra in his paper “On the Role of Scientific
    Thought.”[^a](#pgfId-1191055) In practice, the SRP means that a method should
    do only one thing and do that well. This goes back to the monster methods we discussed
    earlier in the book. More formally, according to Martin in a blog post published
    in 2014 ([https://blog.cleancoder .com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html](https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html)),
    the SRP states that “each software module should have one and only one reason
    to change.”'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由罗伯特·马丁（Robert Martin）提出的清洁代码原则之一，单一职责原则（SRP）是清洁代码的和谐之音：容易演奏，但要精通则需要多年的实践。SRP建立在Edsger
    Dijkstra在其论文《论科学思维的作用》中宣扬（并创造）的“关注点分离”概念之上。[^a](#pgfId-1191055) 在实践中，SRP意味着一个方法应该只做一件事，并且要做好。这回到了我们在本书早期讨论的怪物方法。更正式地说，根据马丁在2014年发布的一篇博客文章（[https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html](https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html)），SRP声明“每个软件模块应该只有一个且仅有一个改变的理由。”
- en: Going back to practical terms, how do you know whether you violated the SRP?
    The easiest way I have found is to ask yourself if you are doing more than one
    thing in the method. If you need to use the word “and” in either your explanation
    of the method or in the method name, that usually means you are violating the
    SRP. The SRP is closely tied to the Liskov principle, which I discuss in chapter
    8.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 回到实际术语，你如何知道你是否违反了SRP？我发现最简单的方法是问问自己你是否在方法中做了多于一件事情。如果你需要在方法的解释或方法名称中使用“和”这个词，那通常意味着你违反了SRP。SRP与Liskov原则紧密相关，我将在第8章中讨论这一点。
- en: '* * *'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^a Edsger Dijkstra wrote his papers with a fountain pen and numbered them “EWD
    [*N*],” where *N* is the number of the paper (EWD stands for his full name: Edsger
    Wybe Dijkstra). “On the Role of Scientific Thought” is EWD 447 and can be found
    in Dijkstra’s *Selected Writings on Computing: A Personal Perspective* (Springer-Verlag,
    1982).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ^a 埃德加·迪杰斯特拉用钢笔写他的论文，并给它们编号“EWD [*N*]”，其中 *N* 是论文的编号（EWD 代表他的全名：Edsger Wybe
    Dijkstra）。《论科学思想的作用》是 EWD 447，可以在迪杰斯特拉的《关于计算的选择作品：个人视角》（Springer-Verlag，1982年）中找到。
- en: '|'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: When we consider the endpoints in the existing codebase we looked at in chapters
    3 and 4, we see that a lot of the methods do multiple things. They call multiple
    database tables and perform multiple processing tasks. We want to separate those
    operations into individual methods, so we can reuse the code and be confident
    in our code quality.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑第 3 章和第 4 章中查看的现有代码库中的端点时，我们发现许多方法执行了多项操作。它们调用多个数据库表并执行多项处理任务。我们希望将这些操作分离成独立的方法，以便重用代码并确保代码质量。
- en: 6.1 Test-driven development
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 测试驱动开发
- en: Using test-driven development (TDD) to implement your code sets you apart from
    a lot of developers. Your code will be more robust and better tested than that
    of your peers who don’t use TDD. If you have never used TDD, I’ll guide you through
    the process of actually using TDD practically. Test-driven development is, at
    its most fundamental level, the practice of writing unit tests before writing
    the code that implements what you are trying to test. You update your tests and
    code in tandem and build them up simultaneously, which promotes good design and
    solid code because the feedback loop is tight and you are acutely aware of any
    code that breaks your tests. In this section, we’ll use TDD to write unit tests
    for the `CustomerRepository`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用测试驱动开发（TDD）来实现你的代码，这使你与许多开发者区分开来。你的代码将比那些不使用 TDD 的同事的代码更健壮、测试更完善。如果你从未使用过
    TDD，我将指导你通过实际使用 TDD 的过程。测试驱动开发在最基本层面上，是在编写实现你试图测试的代码之前编写单元测试的实践。你同时更新测试和代码，并同步构建它们，这促进了良好的设计和坚实的代码，因为反馈循环紧密，你将敏锐地意识到任何破坏测试的代码。在本节中，我们将使用
    TDD 为 `CustomerRepository` 编写单元测试。
- en: NOTE In this book, I practice what I like to call TDD-light. In theory, you
    should write a test before any actual logic. In practice, however, people typically
    tend not to do that. You will see this approach throughout the book. It is not
    “pure TDD,” but it’s a practical solution to balancing the workload of TDD and
    quick iteration.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这本书中，我实践了我喜欢称之为 TDD-light 的方法。从理论上讲，你应该在编写任何实际逻辑之前编写测试。然而，在实践中，人们通常不太这样做。你将在整本书中看到这种方法。它不是“纯
    TDD”，但它是平衡 TDD 的工作量和快速迭代的一个实用解决方案。
- en: 'To do TDD (or any kind of testing), we should create a test project in our
    solution. We do that by using a template as we did in chapter 5 and adding a new
    reference to the solution that points to the new csproj file as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行 TDD（或任何类型的测试），我们应该在我们的解决方案中创建一个测试项目。我们通过使用第 5 章中使用的模板，并将新的引用添加到解决方案中，该引用指向新的
    csproj 文件来完成此操作，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We now have a testing project running on the MSTest platform in our solution.
    A variety of supported testing frameworks for C# exists besides MSTest, such as
    xUnit and NUnit. We’ll use MSTest in this book because MSTest comes supplied with
    .NET.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的解决方案中，有一个在 MSTest 平台上运行的测试项目。除了 MSTest 之外，C# 还存在许多支持的测试框架，例如 xUnit 和
    NUnit。本书中我们将使用 MSTest，因为 MSTest 是随 .NET 一起提供的。
- en: 'The new project also contains an autogenerated unit test file called UnitTest1.cs,
    shown next:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 新项目还包含一个自动生成的单元测试文件，名为 UnitTest1.cs，如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: NOTE If your test class does not have an access modifier of `public`, the MSTest
    runner cannot find the class, and, therefore, the tests inside the class are not
    run.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你的测试类没有`public`访问修饰符，MSTest 运行器将无法找到该类，因此类内的测试将不会运行。
- en: 'Throughout this chapter, we’ll use the UnitTest1.cs file and adapt it to suit
    our needs for the first repository: `CustomerRepository`. Why start with `CustomerRepository`
    as opposed to `FlightRepository` or `BookingRepository`? To refresh our memories,
    when we finish implementing them, we will have one repository per database model
    (Customer, Flight, Airport, and Booking). Within these repositories, we perform
    create, read, update, and delete (*CRUD*) operations that query or manipulate
    the database. The `Customer` entity does not have any outgoing foreign key constraints,
    so we are less likely to go down the rabbit hole of needing to create a repository
    for a different entity before we can finish the one we really want to work on.
    In my experience, it is easier working from the lowest (most nested/least foreign
    key constraints) entity up to the highest. By the time you reach the entity with
    the most constraints, you have all the dependencies already done. This is the
    same argument as to why we started (in chapter 5) with the database access layer
    and not the controller level for the implementation of our next-gen service.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用UnitTest1.cs文件，并根据我们对第一个仓库的需求对其进行修改：`CustomerRepository`。为什么从`CustomerRepository`开始，而不是从`FlightRepository`或`BookingRepository`开始呢？为了刷新我们的记忆，当我们完成它们后，我们将为每个数据库模型（客户、航班、机场和预订）有一个仓库。在这些仓库中，我们执行创建、读取、更新和删除（*CRUD*）操作，这些操作查询或操作数据库。`Customer`实体没有任何外键约束，所以我们不太可能陷入需要在我们完成真正想要工作的仓库之前创建不同实体的仓库的兔子洞。根据我的经验，从最低层（最嵌套/最少外键约束）的实体开始工作到最高层更容易。当你到达约束最多的实体时，你已经完成了所有的依赖。这与我们在第5章中为什么从数据库访问层而不是控制器层开始实现我们的下一代服务的原因相同。
- en: 'Before we write our first unit test, let’s create the repository class and
    the skeleton of our first method: `CreateCustomer`. The `CreateCustomer` method
    accepts an input of type `string` representing a customer’s name, validates that
    input, and inserts a new entity into the database. `CustomerRepository` lives
    in a new folder called RepositoryLayer in the FlyingDutchmanAirlines project,
    as shown next:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写第一个单元测试之前，让我们创建仓库类和第一个方法`CreateCustomer`的框架：`CreateCustomer`方法接受一个类型为`string`的输入，表示客户的姓名，验证该输入，并将新实体插入到数据库中。`CustomerRepository`位于FlyingDutchmanAirlines项目中的新文件夹RepositoryLayer中，如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `CustomerRepository` doesn’t look like much at this point—just a class declaration
    and one method, both with a `public` access modifier—but it is enough to get us
    started with our first unit test. In keeping with TDD tradition, we follow a binary
    strategy akin to a red-green traffic light pattern, as shown in figure 6.2.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 目前`CustomerRepository`看起来并不多——只是一个类声明和一个方法，两者都具有`public`访问修饰符——但这足以让我们开始我们的第一个单元测试。遵循TDD传统，我们遵循类似于图6.2中红色-绿色交通灯模式的二进制策略。
- en: '![](../Images/06_02.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06_02.png)'
- en: Figure 6.2 The test-driven-development traffic light. We go from red (compilation
    problems and test failures) to green (all tests pass and code compiles) back to
    red in a vicious cycle. This promotes an iterative development life cycle.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 测试驱动开发的交通灯。我们从红色（编译问题和测试失败）到绿色（所有测试通过且代码编译）再回到红色，形成一个恶性循环。这促进了迭代式开发生命周期。
- en: With the TDD traffic light, we continually go from the “red” stage, where our
    tests don’t compile or pass, to the “green” stage, where all is well and we can
    implement some more code. This workflow is the core strength of test-driven development.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD交通灯，我们不断地从“红色”阶段（我们的测试无法编译或通过）到“绿色”阶段（一切顺利，我们可以实现一些代码）。这种工作流程是测试驱动开发的核心优势。
- en: 'Let’s switch back to our test project. We need to add a reference to the `FlyingDutchmanAirlines`
    if we want to call any of the methods in there. We can run a command similar to
    how we added the FlyingDutchmanAirlines.csproj to the FlyingDutchmanAirlinesNextGen.sln
    in chapter 5 as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换回我们的测试项目。如果我们想在`FlyingDutchmanAirlines`中调用任何方法，我们需要添加对该项目的引用。我们可以运行一个类似于我们在第5章中将FlyingDutchmanAirlines.csproj添加到FlyingDutchmanAirlinesNextGen.sln的命令，如下所示：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we can rename UnitTest1.cs as CustomerRepositoryTests.cs and change the
    namespace and method name to something more appropriate. Now we can instantiate
    our `CustomerRepository` class and call our new `CreateCustomer` method, like
    so:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将UnitTest1.cs重命名为CustomerRepositoryTests.cs，并将命名空间和方法名更改为更合适的内容。现在我们可以实例化我们的`CustomerRepository`类，并调用我们新的`CreateCustomer`方法，如下所示：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This test actually tests nothing yet, so before we move on, let’s add the simplest
    assertion of all: that `repository` should not be `null`. You may say that is
    just verifying a language feature and not our code because we are just calling
    the default constructor, and, yes, you are right. In my mind, however, testing
    a constructor can still be valuable, because you never know when somebody changes
    the implementation to an explicit constructor with no arguments or does something
    else unexpected.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试实际上还没有测试任何东西，所以在我们继续之前，让我们添加所有断言中最简单的一个：即`repository`不应该为`null`。你可能会说这只是验证了一个语言特性，而不是我们的代码，因为我们只是调用默认构造函数，是的，你是正确的。然而，在我的想法中，测试构造函数仍然是有价值的，因为你永远不知道有人是否会将实现更改为没有参数的显式构造函数，或者做其他意想不到的事情。
- en: 'To add an assertion with the MSTest framework, use the pattern `Assert .[Assertion]([Arguments]).[TestMethod]`
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用MSTest框架添加断言，使用以下模式`Assert .[Assertion]([Arguments]).[TestMethod]`，如下所示：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To run our unit tests, we can either use Visual Studio’s Unit Test Explorer
    or we can invoke the testing framework through the command line. Either way, we
    need to compile the code first and then execute the tests. To run all tests in
    a solution, use the next command in the command line:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的单元测试，我们可以使用Visual Studio的单元测试资源管理器，或者我们可以通过命令行调用测试框架。无论如何，我们都需要先编译代码，然后执行测试。要在命令行中运行解决方案中的所有测试，请使用以下命令：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you ever have trouble running the tests in this book through Visual Studio
    (if you use Visual Studio), give `dotnet test` a try.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过Visual Studio（如果你使用Visual Studio）运行本书中的测试时遇到麻烦，请尝试使用`dotnet test`。
- en: Once the test run finishes, we see that our first test passed, as shown in figure
    6.3\. Note, though, that unit tests are meant to be isolated from other tests
    and test only individual methods. Therefore, the order in which the MSTest runner
    executes tests is not guaranteed to be sequential or the same from session to
    session.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试运行完成，我们看到我们的第一个测试通过了，如图6.3所示。然而，请注意，单元测试旨在与其他测试隔离，并且只测试单个方法。因此，MSTest运行器执行测试的顺序不保证是顺序的或会从会话到会话保持一致。
- en: '![](../Images/06_03.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06_03.png)'
- en: Figure 6.3 The MSTest framework runs our unit test, and it passes. Making sure
    our tests pass after every change helps catch bugs sooner rather than later.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 MSTest框架运行我们的单元测试，并且通过了。确保每次更改后测试都通过，有助于尽早而不是更晚地捕捉到错误。
- en: Exercises
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 6.1
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.1
- en: What does the single-responsibility principle advocate?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则倡导的是什么？
- en: a. All method names should be only one word long.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: a. 所有方法名应该只有一个单词长。
- en: b. Don’t perform the same logic in two separate places.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: b. 不要在两个不同的地方执行相同的逻辑。
- en: c. Make your methods only do one thing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: c. 让你的方法只做一件事。
- en: Exercise 6.2
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.2
- en: True or false? With test-driven development, you write tests before and during
    implementation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是假的？在使用测试驱动开发时，你会在实现前后编写测试。
- en: Exercise 6.3
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.3
- en: True or false? A test runner can see your test classes as long as they have
    an access modifier of `internal`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是假的？只要测试类有一个`internal`访问修饰符，测试运行器就可以看到你的测试类。
- en: 6.2 The CreateCustomer method
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 创建客户方法
- en: In this section, we’ll implement the `CreateCustomer` method in the `CustomerRepository`
    class. We want to accept an argument of type `string` representing the customer’s
    name and return a Boolean value indicating whether the customer was successfully
    added to the database.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现`CustomerRepository`类中的`CreateCustomer`方法。我们希望接受一个表示客户名称的`string`类型的参数，并返回一个布尔值，指示客户是否成功添加到数据库中。
- en: In the existing codebase (discussed in chapters 3 and 4), a massive method called
    `FlightController.Post` adds a `Customer` instance to the database. The `Post`
    method was about 80 lines long and also executed logic to get details on airports.
    It also retrieved and booked a flight. Doing more than one thing in a method violates
    the single-responsibility principle. The `FlightController.Post` method does not
    just do one thing (as the principle prescribes); instead, it does many things.
    The actual code concerning creating a customer is only eight lines long, as shown
    in the next listing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有的代码库（在第3章和第4章中讨论过），一个名为`FlightController.Post`的庞大方法将一个`Customer`实例添加到数据库中。`Post`方法大约有80行长，并且还执行了获取机场详情的逻辑。它还检索并预订了航班。在方法中做过多的事情违反了单一职责原则。`FlightController.Post`方法不仅仅做了一件事（正如原则所规定的那样）；相反，它做了很多事情。实际创建客户的代码只有八行长，如下一列表所示。
- en: Listing 6.1 How the old codebase dealt with creating a customer in the database
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 旧代码库处理在数据库中创建客户的方式
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ We should write code that is clear enough without comments.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们应该编写足够清晰的代码，无需注释。
- en: ❷ The connection variable is instantiated before this code snippet.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在此代码片段之前实例化了连接变量。
- en: ❸ A good use of the using statement, but uses an implicit type
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 using 语句是一个很好的用法，但使用了隐式类型
- en: ❹ Reads the return from the database into an ID variable
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将数据库的返回值读取到 ID 变量中
- en: 'The code snippet in listing 6.1 is not the worst we have seen, but we can definitely
    make the following improvements:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 中的代码片段并不是我们见过的最糟糕的，但我们确实可以做出以下改进：
- en: Our code should be self-documenting. Somebody unfamiliar with the logic should
    be able to read the code and understand, in broad strokes, what is going on. We
    should delete the comment.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码应该是自文档化的。对于不熟悉逻辑的人来说，应该能够阅读代码并大致了解正在发生的事情。我们应该删除注释。
- en: Using hardcoded SQL statements is a potential stumbling block for maintaining
    a service. If the database schema changes, we now need to change the SQL query
    as well. It is safer to use an ORM tool, like Entity Framework Core, to abstract
    away the SQL query.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用硬编码的 SQL 语句可能会成为维护服务的潜在障碍。如果数据库模式发生变化，我们现在需要更改 SQL 查询。使用 ORM 工具（如 Entity Framework
    Core）来抽象 SQL 查询更安全。
- en: 'With those improvements identified, let’s start with our new implementation
    by creating the method signature of the new `CreateCustomer` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了这些改进后，让我们从我们的新实现开始，创建新的 `CreateCustomer` 方法的签名：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our `CreateCustomer` method doesn’t have any actual logic implemented at this
    point, so let’s change that. To create a customer entry in our database, we need
    to do the following four things:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `CreateCustomer` 方法目前没有实现任何实际逻辑，所以让我们改变一下。要在我们的数据库中创建客户条目，我们需要做以下四件事：
- en: Validate the input argument of `name`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 `name` 的输入参数。
- en: Instantiate a new `Customer` object.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个新的 `Customer` 对象。
- en: Add the new `Customer` object to the Entity Framework Core’s internal `DbSet<Customer>`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的 `Customer` 对象添加到 Entity Framework Core 的内部 `DbSet<Customer>`。
- en: Tell Entity Framework Core that we want to commit our change.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉 Entity Framework Core 我们想要提交我们的更改。
- en: We follow this general pattern in all of our repository methods. Being consistent
    makes our codebase easier to read and maintain, because developers can come to
    rely on the expectation of seeing this pattern.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在所有仓库方法中都遵循这个通用模式。保持一致性使得我们的代码库更容易阅读和维护，因为开发者可以依赖看到这个模式的预期。
- en: 6.2.1 Why you should always validate input arguments
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 为什么你应该始终验证输入参数
- en: In an ideal world, people never pass `null` or invalid arguments into your methods.
    The unfortunate truth is that we don’t live in an ideal world. To counteract unreliability
    in other people, the best thing we can do is to lead by example. If we consider
    a method to be nothing more than a mathematical function, we can treat it as a
    black box into which we can input any information and return an acceptable outcome.
    If we pass into this black box an invalid value and we assumed that another developer
    handled the validation upstream, we are in trouble and heading for the land of
    runtime exceptions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，人们永远不会将 `null` 或无效参数传递到你的方法中。不幸的事实是，我们并不生活在一个理想的世界里。为了对抗他人的不可靠性，我们能做的最好的事情就是以身作则。如果我们认为一个方法不过是一个数学函数，我们可以将其视为一个黑盒，我们可以输入任何信息并返回一个可接受的输出。如果我们向这个黑盒中传递一个无效的值，并且假设另一个开发者已经在上游处理了验证，那么我们就麻烦了，正朝着运行时异常的领域迈进。
- en: 'Let’s validate our input by considering what criteria our `string` representing
    a customer name must adhere to. First, I think it is safe to assume that we never
    want our name string to be null. In the case of null, we should return out of
    the method with a `false` Boolean, indicating that we could not successfully add
    a new `Customer` object to the database with the given input parameters, as shown
    next:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑代表客户名称的 `string` 必须遵守哪些标准来验证我们的输入。首先，我认为我们可以安全地假设我们永远不会希望我们的名称字符串为 null。在
    null 的情况下，我们应该通过返回一个 `false` 布尔值退出方法，表示我们无法使用给定的输入参数成功将新的 `Customer` 对象添加到数据库中，如下所示：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '| ![](../Images/LightBulb.png)   | IsNullorempty As part of the `string` class,
    .NET exposes the `IsNullOrEmpty` method. This method returns a Boolean indicating
    whether the given string is null or empty. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| ![灯泡](../Images/LightBulb.png)   | IsNullorempty 作为 `string` 类的一部分，.NET 提供了
    `IsNullOrEmpty` 方法。此方法返回一个布尔值，指示给定的字符串是否为 null 或空。'
- en: 'We added the second return statement to satisfy the method signature. If we
    do not have the `return true` statement, the compiler throws an error saying that
    not all code paths in the `CreateCustomer` method return a value of type `bool`.
    If returning a `bool` type value based on input validation was the only thing
    we did in the `CreateCustomer` method, we could have just returned the resulting
    Boolean value of `string.IsNullOrEmpty``.` But, alas, we have other logic to include.
    Let’s update our existing unit test, which is the success scenario, to call the
    `CreateCustomer` method and pass along a valid name string, then check whether
    the method returned a true value, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加第二个返回语句是为了满足方法签名。如果我们没有`return true`语句，编译器会抛出一个错误，表示`CreateCustomer`方法中并非所有代码路径都返回`bool`类型的值。如果我们只是在`CreateCustomer`方法中根据输入验证返回`bool`类型值，我们就可以直接返回`string.IsNullOrEmpty`的结果布尔值。但是，唉，我们还有其他逻辑要包括。让我们更新现有的单元测试，即成功场景，调用`CreateCustomer`方法并传递一个有效的名字字符串，然后检查方法是否返回了true值，如下所示：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Go ahead and run the test; it should pass. We introduced the following two
    new return branches for our method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试；它应该通过。我们为我们的方法引入了以下两个新的返回分支：
- en: The `name` argument is null.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`参数为null。'
- en: The `name` argument is an empty string.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`参数是一个空字符串。'
- en: We should add unit tests that cover these possibilities.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该添加单元测试来覆盖这些可能性。
- en: 6.2.2 Using “arrange, act, assert” to write unit tests
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 使用“安排、行动、断言”编写单元测试
- en: 'In this section, we’ll dive deeper into test-driven development by examining
    its core testing philosophy. We’ll also continue writing the `CreateCustomer_Success`
    unit test by following the same pattern for tests we have followed in this book
    so far: instantiate an object, call it, and assert that the output is correct.
    This section examines the “three As” of testing: arrange, act, and assert, as
    shown in figure 6.4.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过检查其核心测试哲学来深入了解测试驱动开发。我们还将继续编写`CreateCustomer_Success`单元测试，遵循我们在本书中迄今为止遵循的相同测试模式：实例化一个对象，调用它，并断言输出是正确的。本节考察了测试的“三个A”：安排、行动和断言，如图6.4所示。
- en: '![](../Images/06_04.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06_04.png)'
- en: 'Figure 6.4 “The three As of testing”: arrange, act, and assert. Using them
    allows us to write tests in an organized and predictable manner.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 “测试的三个A”：安排、行动和断言。使用它们可以使我们以有组织和可预测的方式编写测试。
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '| ![](../Images/LightBulb.png)   | EMPTY STRINGS `""` and `string.Empty` are
    both valid ways to describe an empty string. In fact, `string.Empty` resolves
    to `""` under the hood. Use whichever one you want. I like to use `string.Empty`
    because it is more explicit. In this book, I use them both. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| ![灯泡](../Images/LightBulb.png)   | 空字符串`""`和`string.Empty`都是描述空字符串的有效方式。实际上，`string.Empty`在底层解析为`""`。你可以使用任何一个，我喜欢使用`string.Empty`因为它更明确。在这本书中，我两者都使用。| '
- en: And just like that, we are up to three tests. Now, when we make any further
    changes to the method, we can run these tests and be confident that the existing
    code did not break.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们已经有了三个测试。现在，当我们对方法进行任何进一步的更改时，我们可以运行这些测试，并确信现有的代码没有出错。
- en: 6.2.3 Validating against invalid characters
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 验证无效字符
- en: 'The second item on our to-do list for validating the input is checking the
    actual content of the `name` string for invalid characters. We don’t expect a
    name to contain special characters, such as the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证输入的任务清单中，第二项是检查`name`字符串的实际内容是否有无效字符。我们预计一个名字不会包含特殊字符，如下所示：
- en: 'Exclamation point: !'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感叹号：!
- en: 'At sign: @'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '脚标符号：@ '
- en: 'Pound sign: #'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英镑符号：#
- en: 'Dollar sign: $'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美元符号：$
- en: 'Percentage sign: %'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '百分比符号：% '
- en: 'Ampersand: &'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '和号：& '
- en: 'Asterisk: *'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星号：*
- en: We cannot possibly limit our allowed character set based on the characters we
    allow. The list of possible Unicode characters is gigantic, especially when you
    take into consideration the special notation of letters in a language such as
    Vietnamese and Armenian. So how do we check for special characters?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不可能仅基于允许的字符来限制我们的允许字符集。可能的Unicode字符列表是巨大的，尤其是当你考虑到像越南语和亚美尼亚语这样的语言中字母的特殊符号时。那么我们如何检查特殊字符呢？
- en: 'We could create a character array and loop over the string, then loop over
    the character array for every character in the string. That would both be many
    lines long and fairly inefficient.[¹](#pgfId-1190044) We could also use a regular
    expression (regex) to match against a regex string, but that would be overkill
    for our problem. The easiest and cleanest way to determine whether a string contains
    a given character is to specify an array with forbidden characters and then use
    the LINQ `Any` method to iterate over the source string, passing in an `Action`
    that checks whether any of the elements in the collection contain an element from
    the forbidden characters collection. The `Any` method checks whether an expression
    (through an `Action`) is valid for any of the elements in a collection. LINQ can
    be difficult to understand the first time you look at it, so let’s unpack our
    LINQ code step-by-step next:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个字符数组并遍历字符串，然后对字符串中的每个字符进行遍历。这样会占用很多行，而且效率也不高。[¹](#pgfId-1190044) 我们也可以使用正则表达式（regex）与正则字符串进行匹配，但这对于我们的问题来说可能有些过度。最容易且最干净的方法是确定一个字符串是否包含指定的字符，就是指定一个包含禁止字符的数组，然后使用
    LINQ 的 `Any` 方法遍历源字符串，传入一个 `Action` 来检查集合中的任何元素是否包含禁止字符集合中的元素。`Any` 方法检查一个表达式（通过
    `Action`）是否对集合中的任何元素有效。LINQ 在第一次查看时可能难以理解，所以让我们一步一步地分解我们的 LINQ 代码：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Although the runtime complexity of using the `Any` LINQ method and character
    array approach is the same as the nested `for` loop described earlier (since we
    are basically throwing some syntactical sugar on top of it), it is more readable
    and more idiomatic C#. LINQ (Language-Integrated Query) is a sort of programming
    language inside of C# that allows us to perform (and chain) operations to query
    and change collections. Here, we call a method (`Any`) in the LINQ library using
    normal C# syntax.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 `Any` LINQ 方法和字符数组方法的时间复杂度与前面描述的嵌套 `for` 循环相同（因为我们基本上是在其上添加了一些语法糖），但它更易于阅读，也更符合
    C# 的习惯用法。LINQ（Language-Integrated Query）是 C# 中的一种编程语言，允许我们执行（并链式）操作来查询和更改集合。在这里，我们使用正常的
    C# 语法调用 LINQ 库中的方法（`Any`）。
- en: 'First, we declare, initialize, and assign a variable of type array of `char`
    and call it `forbiddenCharacters``.` This array contains the characters we do
    not allow. Second, we initialize a Boolean variable called `containsInvalidCharacters`
    and assign it to the result of our LINQ query. We can read the LINQ query as a
    narrative: “If any element in the string called `name` contains a character from
    the `forbiddenCharacters` collection, return `false`, else return `true.`”'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明、初始化并分配一个类型为 `char` 数组的变量，并称它为 `forbiddenCharacters`。这个数组包含我们不允许的字符。其次，我们初始化一个名为
    `containsInvalidCharacters` 的布尔变量，并将其分配给我们的 LINQ 查询的结果。我们可以将 LINQ 查询读作一个叙述：“如果
    `name` 字符串中的任何元素包含 `forbiddenCharacters` 集合中的字符，则返回 `false`，否则返回 `true`。”
- en: The call to `Any` evaluates to `true` if the passed-in expression results to
    `true` for any of the values in the collection (in this case for any of the characters
    in the `name` string). We pass in an expression to be evaluated through a lambda
    expression. We use the `Contains` method on `forbiddenCharacters` to evaluate
    whether the `forbiddenCharacters` collection contains the passed-in value. Combined
    with the `Any` call, this means that if we evaluate the `Contains` call to be
    `true` (which it is for a character representing a forbidden character), it also
    means that the `Any` returns `true`, meaning that there was a forbidden character
    in the string.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any` 方法的调用如果传入的表达式对于集合中的任何值（在本例中为 `name` 字符串中的任何字符）结果为 `true`，则返回 `true`。我们通过
    lambda 表达式传入一个要评估的表达式。我们使用 `forbiddenCharacters` 上的 `Contains` 方法来评估 `forbiddenCharacters`
    集合是否包含传入的值。结合 `Any` 调用，这意味着如果我们评估 `Contains` 调用为 `true`（对于代表禁止字符的字符来说就是 `true`），这也意味着
    `Any` 返回 `true`，这意味着字符串中存在禁止字符。'
- en: We could just put the forbidden character code after our conditional to check
    whether the `name` string was `null` or empty, or even inline it into the conditional,
    but I vote for a different approach. If I tell you that those are implementation
    details, unnecessary for the casual reader to know intimately, where should we
    put the code? That’s right, in a separate `private` method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在我们的条件之后放置禁止字符代码来检查 `name` 字符串是否为 `null` 或空，甚至将其内联到条件中，但我倾向于采用不同的方法。如果我说这些是实现细节，对于普通读者来说没有必要深入了解，那么我们应该把代码放在哪里？没错，应该放在一个单独的
    `private` 方法中。
- en: We should extract the `IsNullOrEmpty` conditional into its own method and add
    the invalid character code. We can call the method `IsInvalidCustomerName` and
    have it return a Boolean (note that we also have to import the `System.Linq` namespace
    to use LINQ queries), as shown in the next listing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将`IsNullOrEmpty`条件提取到它自己的方法中，并添加无效字符代码。我们可以将此方法命名为`IsInvalidCustomerName`，并使其返回一个布尔值（注意，我们还需要导入`System.Linq`命名空间以使用LINQ查询），如下一列表所示。
- en: Listing 6.2 CustomerRepository.cs with extracted `IsInvalidCustomerName`
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列出 6.2 CustomerRepository.cs 中提取的 `IsInvalidCustomerName`
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see in listing 6.2, we extracted the code into its own separate method.
    We also immediately return based on the resulting Boolean value of combining the
    conditional and LINQ query.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表6.2所示，我们将代码提取到它自己的独立方法中。我们还根据组合条件和LINQ查询的结果立即返回基于布尔值。|
- en: '| ![](../Images/LightBulb.png)   | Short-circuiting and logical operators An
    alternative approach would be to use the “exclusive OR” operator (XOR, `^`) instead
    of the conditional logical OR operator (`&#124;&#124;`). The XOR operator evaluates
    to true if one, and only one, option is true. If both the `IsNullOrEmpty` and
    `Any Contains` checks are valid, something really strange is going on (a string
    cannot be both null or empty and contain an invalid character), so using an XOR
    operator could work for us. Because XOR is a “logical” operator, it evaluates
    both sides of the equation before returning a verdict on true or false. Logical
    operators can be less performant than conditional operators (such as `&#124;&#124;`)
    because logical operators do not evaluate the left-hand side of the equation if
    the right-hand side is false. This is also called “short-circuit evaluation.”
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| ![灯泡](../Images/LightBulb.png)   | 短路和逻辑运算符另一种方法是使用“排他或”运算符（XOR，`^`）而不是条件逻辑或运算符（`&#124;&#124;`）。XOR运算符在只有一个选项为真时返回true。如果`IsNullOrEmpty`和`Any
    Contains`检查都有效，那么就真的有些奇怪了（一个字符串不能既为null或空又包含无效字符），因此使用XOR运算符可能对我们有用。因为XOR是一个“逻辑”运算符，它在返回true或false的判断之前会评估等式的两边。逻辑运算符可能比条件运算符（如`&#124;&#124;`）性能低，因为如果等式的右边是false，逻辑运算符不会评估等式的左边。这也被称为“短路评估”。|'
- en: Coming back to the `forbiddenCharacters` array, a memory-conscious reader may
    object and say, “You’re allocating memory for the `forbiddenCharacters` array
    when there is a possibility that you never use it because of `name` potentially
    being `null`.” To that objection I would reply by agreeing with your factual statement
    but also counter by saying that it is a small price to pay for readability.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`forbiddenCharacters`数组，一个注重内存的读者可能会反对并说：“当`name`可能为`null`时，你有可能会分配内存给`forbiddenCharacters`数组，但你可能永远不会使用它。”对于这个反对意见，我会同意你的事实陈述，但也会反驳说，这是为了可读性而付出的微小代价。
- en: 'We almost fulfilled the first of our goals: validate the input argument of
    `name`. The logic is in place, but we don’t have any unit tests backing this new
    logic yet. That is not very TDD compliant of us. How do we go about writing a
    test for this new logic? Are we okay with testing only the new `private` method,
    or do we also want to test the remaining `CreateCustomer` method as it calls the
    `private` method?'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎实现了我们的第一个目标：验证`name`的输入参数。逻辑已经到位，但我们还没有为这个新的逻辑编写单元测试。这并不符合我们的TDD（测试驱动开发）原则。我们如何为这个新的逻辑编写测试？我们是否只测试新的`private`方法，还是我们也想测试调用`private`方法的剩余`CreateCustomer`方法？
- en: We do not want to directly test any `private` methods. In an ideal world, all
    `private` methods are called by a `public` method (this could be directly or indirectly
    through another `private` method(s)) and are tested through that `public` method.
    Because we are already testing the success case with our general `CreateCustomer`
    success case test, we don’t need to create another success case (or “happy path”)
    test. We do need a test for the failure case, however.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想直接测试任何`private`方法。在一个理想的世界里，所有`private`方法都是由一个`public`方法调用的（这可能是直接或通过另一个`private`方法间接调用）并且通过那个`public`方法进行测试。因为我们已经通过我们的通用`CreateCustomer`成功情况测试测试了成功情况，所以我们不需要创建另一个成功情况（或“happy
    path”）测试。然而，我们需要一个测试来测试失败情况。
- en: 6.2.4 In-lining test data with the [DataRow] attribute
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.4 使用 [DataRow] 属性内联测试数据
- en: We want to test for all invalid characters, which, if we had a unit test for
    every single character, would require us to write *N* tests, where *N* is the
    number of invalid characters. That would be a lot of work for little reward. Luckily,
    MSTest has the `[DataRow]` attribute that we can use with the MSTest platform.
    We can use `[DataRow]` to specify an input parameter for the test method, as shown
    in the next listing. This allows us to just add a bunch of `[DataRow]` attributes
    to one test.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望测试所有无效字符，如果我们为每个字符都编写一个单元测试，那么就需要我们编写*N*个测试，其中*N*是无效字符的数量。这将是一项大量工作，但回报甚微。幸运的是，MSTest有`[DataRow]`属性，我们可以与MSTest平台一起使用。我们可以使用`[DataRow]`来指定测试方法的输入参数，如下一列表所示。这允许我们只需添加大量`[DataRow]`属性到单个测试中。
- en: Listing 6.3 `CreateCustomer_Failure_NameContainsInvalidCharacters` with `[DataRow]`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 `CreateCustomer_Failure_NameContainsInvalidCharacters` 使用 `[DataRow]`
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The test in listing 6.3 passes in a string containing the full name “Donald
    Knuth” postfixed by one of the invalid characters (as dictated by the `[DataRow]`
    attribute), for example: `"Donald Knuth%"`. Using `"Donald Knuth%"` as an input
    argument to the `CreateCustomer` method returns a `false` Boolean on which we
    assert. If we now run the test, we can see that everything passes and we are back
    to great coverage of our codebase.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3中的测试在包含全名“Donald Knuth”后跟一个无效字符（如`[DataRow]`属性所规定的）的字符串中通过，例如：“Donald Knuth%”。将“Donald
    Knuth%”用作`CreateCustomer`方法的输入参数返回一个`false`布尔值，我们对它进行断言。如果我们现在运行测试，我们可以看到一切通过，我们回到了代码库的良好覆盖率。
- en: When I talk about coverage in the context of testing, I do not mean the percentage
    of your code covered by a test. For more information on code coverage and unit
    testing, see Vladimir Khorikov’s *Unit Testing Principles, Practices, and Patterns*
    (Manning, 2020)[²](#pgfId-1190138) and Roy Osherove’s *The Art of Unit Testing*
    (3rd edition; Manning, 2020).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在测试的上下文中谈论覆盖率时，我并不是指测试覆盖了你代码的百分比。有关代码覆盖和单元测试的更多信息，请参阅Vladimir Khorikov的《单元测试原则、实践和模式》（Manning，2020）[²](#pgfId-1190138)和Roy
    Osherove的《单元测试的艺术》（第3版；Manning，2020）。
- en: 6.2.5 Object initializers and autogenerated code
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.5 对象初始化器和自动生成代码
- en: 'Coming back to the `CreateCustomer` method in `CustomerRepository`, we are
    ready to tackle the next item on our list: “Instantiate a new `Customer` object,”
    shown in the next code listing.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`CustomerRepository`中的`CreateCustomer`方法，我们准备处理列表中的下一个项目：“实例化一个新的`Customer`对象”，如下一代码列表所示。
- en: Listing 6.4 CustomerRepository.cs `CreateCustomer` creates a new customer
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.4 CustomerRepository.cs `CreateCustomer` 创建新客户
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can clean up the code in listing 6.4 a little bit by using what we call
    an “object initializer.” Using an object initializer allows you to directly set
    field values of an instance at creation as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用所谓的“对象初始化器”来稍微清理列表6.4中的代码。使用对象初始化器允许你在创建实例时直接设置字段值，如下所示：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Object initializers are great for when you need to set values manually, but
    what happens if a new developer comes in and accidentally changes the code to
    not set that name value; or, perhaps, for whatever reason, somebody creates an
    instance of type `Customer` somewhere else in the code without knowing they should
    set that property to a valid value?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对象初始化器非常适合需要手动设置值的情况，但如果新来的开发者不小心将代码更改得没有设置该名称值；或者，也许出于某种原因，某人在代码的其他地方创建了一个类型为`Customer`的实例，而不知道他们应该将该属性设置为有效值呢？
- en: 'Perhaps it is better if we control how the object gets instantiated. We can
    define how `Customer` is instantiated by forcing the use of a constructor that
    takes in a parameter of type `string` for the name. But we first need to verify
    that we can add a new constructor with no issue by looking at the Customer.cs
    class, shown next:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们控制对象如何实例化会更好。我们可以通过强制使用一个接受类型为`string`的名称参数的构造函数来定义`Customer`的实例化方式。但首先我们需要通过查看下一个显示的`Customer.cs`类来验证我们是否可以无问题地添加一个新的构造函数：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Customer` class is completely autogenerated by Entity Framework Core. It
    maps to the Customer table in our database and holds a list of `Booking`s. Entity
    Framework Core created this list, having found the relative foreign key constraint
    in the database. In my ideal world, properties and fields come before constructors,
    so they are visible at first glance when browsing a class, but that is not the
    case in the Entity Framework Core autogenerated files. If you wish, you can reorganize
    your files to reflect that pattern. In this book, I rearranged all models to that
    style. We can see the result of the rearrangement in listing 6.5\. We also remove
    the `partial` keyword from the model’s respective class signature. We can do this
    because we are not going to use the `partial` feature, and it is safer to get
    into the habit of removing code you know you are not going to use. Removing unused
    code promotes cleanliness in your code, and somebody reading through your classes
    in the future will thank you. Many developers get into the trap of keeping code
    that “they may use/need later.” This only promotes a cluttered codebase in my
    opinion.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Customer`类完全由Entity Framework Core自动生成。它映射到我们数据库中的客户表，并包含一个`Booking`列表。Entity
    Framework Core创建了这个列表，因为它在数据库中找到了相关的外键约束。在我的理想世界中，属性和字段应该在构造函数之前，这样在浏览类时就可以一目了然，但在Entity
    Framework Core自动生成的文件中并非如此。如果您愿意，您可以重新组织您的文件以反映该模式。在这本书中，我将所有模型重新组织为那种风格。我们可以在列表6.5中看到重新组织的结果。我们还从模型的相应类签名中移除了`partial`关键字。我们可以这样做，因为我们不会使用`partial`功能，养成移除已知不会使用的代码的习惯更安全。移除未使用的代码可以提高代码的整洁性，并且将来阅读您类的人会感谢您。许多开发者陷入了保留“他们可能以后会使用/需要”的代码的陷阱。在我看来，这只会使代码库变得杂乱。'
- en: Listing 6.5 Customer.cs (EF Core–generated and reorganized)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5 Customer.cs（EF Core生成并重新组织）
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 6.2.6 Constructors, reflection, and asynchronous programming
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.6 构造函数、反射和异步编程
- en: We already have a constructor for the `Customer` class. It doesn’t take any
    arguments but assigns a new instance of a `HashSet` of `Booking` to the `Booking`
    property. We want to keep the assignment because a reference type does not default
    to a zero value (an empty collection in this case). Instead it defaults to null.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为`Customer`类提供了一个构造函数。它不接受任何参数，但将一个新的`HashSet`的`Booking`实例分配给`Booking`属性。我们想要保留这个分配，因为引用类型不会默认为零值（在这种情况下是空集合）。相反，它默认为`null`。
- en: NOTE You can assign the default value for any type explicitly by using the `default`
    keyword instead of a value. This can come in helpful when dealing with nonprimitive
    value types, where the default value can be unknown to you. Reference types always
    have a default value of null.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以通过使用`default`关键字而不是值来显式地为任何类型分配默认值。这在处理非原始值类型时可能很有用，其中默认值可能对您来说是未知的。引用类型始终具有`null`的默认值。
- en: 'We don’t want to pass in an argument of type `HashSet<Booking>`, however. We
    want to let Entity Framework Core deal with any key constraints. But we do want
    to have an argument of type `string` reflecting the customer’s name. Additionally,
    we also should make sure that nobody can inherit from our `Customer` object and
    consequently use polymorphism to add that to the database. So, we also seal our
    class by using the `sealed` keyword. Sealing a class means we need to remove the
    `virtual` keyword from the `Booking` property, because you cannot have virtual
    members or properties in a sealed class. We should also seal the other models
    in our codebase, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想传递一个类型为`HashSet<Booking>`的参数。我们希望让Entity Framework Core处理任何键约束。但是，我们确实希望有一个类型为`string`的参数，反映客户的姓名。此外，我们还应该确保没有人可以从我们的`Customer`对象继承，并因此使用多态将其添加到数据库中。因此，我们使用`sealed`关键字密封我们的类。密封一个类意味着我们需要从`Booking`属性中移除`virtual`关键字，因为在密封类中不能有虚拟成员或属性。我们还应该按照以下方式密封代码库中的其他模型：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we attempt to compile the code, we get a compilation error because we
    are not passing in the required parameter when we instantiate our `Customer` object
    in the `CustomerRepository`. In fact, we are still using the object initializer.
    Let’s fix that as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试编译代码时，我们得到一个编译错误，因为我们没有在`CustomerRepository`中实例化`Customer`对象时传递所需的参数。实际上，我们仍在使用对象初始化器。让我们按照以下方式修复它：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can now compile, and our tests still pass. The third item on our list is
    to add the new `Customer` object to the Entity Framework Core’s internal `DbSet<Customer>`.
    Why do we need to do this? As discussed earlier, Entity Framework Core operates
    under the assumption that any changes to the database are first made to the in-memory
    datasets. To add a new object of type `Customer` to the database, we first have
    to add it to the in-memory `DbSet<Customer>`. To access the `DbSet`, we need to
    create a new instance of the database context class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编译，而且我们的测试仍然通过。我们列表上的第三项是将新的`Customer`对象添加到Entity Framework Core的内部`DbSet<Customer>`。为什么我们需要这样做？如前所述，Entity
    Framework Core假设对数据库的任何更改首先是对内存数据集的更改。为了将类型为`Customer`的新对象添加到数据库，我们首先必须将其添加到内存中的`DbSet<Customer>`。要访问`DbSet`，我们需要创建数据库上下文类的新实例。
- en: 'We can use two methods on a `DbContext` to add models to a `DbSet`: `Add` and
    `[Entity].Add`. If we call the general `Add` method, C# uses reflection to determine
    the entity type and add it to the correct set. I prefer using the explicit `[Entity].Add`
    because it leaves no room for ambiguity and saves some overhead (reflection is
    very expensive!).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`DbContext`上的两个方法将模型添加到`DbSet`：`Add`和`[Entity].Add`。如果我们调用通用的`Add`方法，C#将使用反射来确定实体类型并将其添加到正确的集合中。我更喜欢使用显式的`[Entity].Add`，因为它消除了歧义并节省了一些开销（反射非常昂贵！）。
- en: Reflection
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 反射
- en: Reflection is a powerful technique in C# used to access information at run time
    about assemblies, types, and modules. In practice, this means that you can find
    out what the type is of an object or change some of its properties while executing
    your code. You can use reflection for much more than that, however. The opportunities
    are surprising.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是C#中一种强大的技术，用于在运行时访问有关程序集、类型和模块的信息。在实践中，这意味着你可以在执行代码时找出对象的类型或更改其一些属性。然而，你可以使用反射做更多的事情。机会是惊人的。
- en: For example, you can use reflection to create custom method attributes, create
    new types, or invoke code in a file you don’t know the name of yet, all at runtime.
    You can even access private fields from outside classes (but please do not do
    that; respect the developers’ access guidance).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用反射来创建自定义方法属性、创建新类型或在不知道文件名的情况下调用文件中的代码，所有这些都可以在运行时完成。你甚至可以访问外部类中的私有字段（但请勿这样做；尊重开发者的访问指南）。
- en: As you can imagine, reflection is not the cheapest thing to execute in terms
    of memory and CPU cycles. To perform some of its operations, it has to load in
    and keep track of a lot of metadata in memory. Imagine the amounts of processing
    needed to detect the type of an unknown object at run time. Libraries and frameworks
    often cannot make assumptions about the type of objects they operate on, so they
    use reflection to gather metadata and make decisions based on that data.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，反射在内存和CPU周期方面并不是最便宜的执行方式。为了执行其一些操作，它必须在内存中加载并跟踪大量的元数据。想象一下在运行时检测未知对象类型所需的处理量。库和框架通常不能对其操作的对象类型做出假设，因此它们使用反射来收集元数据并根据这些数据做出决策。
- en: Before using reflection, reflect on your use case.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用反射之前，先反思一下你的用例。
- en: 'Because the `DbContext` class implements the `IDisposable` interface, we need
    to dispose of it correctly. The `DbContext` class needs to be disposable because
    it can hold connection objects for infinite amounts of time. Finally, to commit
    and save our reference changes to the database, we call the `SaveChangesAsync`
    method in the context, as shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`DbContext`类实现了`IDisposable`接口，所以我们需要正确地处理它的释放。`DbContext`类需要是可释放的，因为它可以无限期地持有连接对象。最后，为了提交并保存我们对数据库的引用更改，我们在上下文中调用`SaveChangesAsync`方法，如下所示：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This little snippet is what Entity Framework Core is all about. If we did not
    have the abstraction of Entity Framework Core (or a different ORM tool), we would
    have to instantiate a SQL connection, open it, write actual SQL to insert the
    new customer, and then execute that query. The code to do that is more complex
    and longer than what we have written now.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这段小代码片段就是Entity Framework Core的核心所在。如果我们没有Entity Framework Core（或不同的ORM工具）的抽象，我们就必须实例化一个SQL连接，打开它，编写实际的SQL来插入新的客户，然后执行该查询。完成这个任务的代码比我们现在写的要复杂和长。
- en: 'There is one little snag with this code, however: we call an asynchronous method,
    yet execute the method synchronously. For this particular method, building the
    code does not throw a compile error because it saves the changes synchronously.
    To convert a synchronous method to an asynchronous method, we need to follow three
    steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码有一个小问题：我们调用了一个异步方法，但却是同步地执行它。对于这个特定的方法，构建代码时不会抛出编译错误，因为它同步地保存了更改。要将同步方法转换为异步方法，我们需要遵循三个步骤：
- en: Use the `await` keyword on method calls we execute asynchronously and wait for.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们执行并等待的方法调用上使用 `await` 关键字。
- en: Return an object of type `Task` from the method.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从方法中返回一个 `Task` 类型的对象。
- en: Add the `async` keyword to the method signature.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `async` 关键字添加到方法签名中。
- en: 'To not wait for (in other words, asynchronously execute) a method, C# uses
    the `await` keyword. People often confuse asynchronous programming with multithreaded
    programming. There is a big difference: asynchronous programming allows us to
    perform multiple things at the same time, coming back to something once it is
    done executing. Multithreaded programming typically refers to running multiple
    sets of logic in parallel, taking advantage of extra threads to speed up our code.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要不等待（换句话说，异步执行）一个方法，C# 使用 `await` 关键字。人们经常将异步编程与多线程编程混淆。它们之间有一个很大的区别：异步编程允许我们同时执行多项任务，一旦执行完成就返回。多线程编程通常指的是并行运行多组逻辑，利用额外的线程来加快我们的代码。
- en: 6.2.7 Locks, mutexes, and semaphores
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.7 锁、互斥锁和信号量
- en: 'Locking resources and controlling thread access are the bane of many software
    engineers’ existence. Code blows up in complexity once you deal with multiple
    threads because the number of places errors can crop up increases rapidly. To
    lessen the burden on developers, C# exposes one statement (`lock`) and two main
    types of synchronization primitives to save you: mutexes and semaphores.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定资源和控制线程访问是许多软件工程师存在的噩梦。一旦处理多个线程，代码的复杂性就会激增，因为错误可能出现的地点数量急剧增加。为了减轻开发者的负担，C#
    提供了一个语句（`lock`）和两种主要的同步原语类型来帮助你：互斥锁和信号量。
- en: 'What are their differences, and when would you use one over the other? The
    easiest to use is the standard `lock` statement. To lock a resource using the
    `lock` statement and allow only one thread at a time to operate on it, use the
    `lock([RESOURCE]){...}` syntax as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间有什么区别，你会在什么情况下使用一个而不是另一个？最容易使用的是标准的 `lock` 语句。要使用 `lock` 语句锁定资源并允许一次只有一个线程操作它，请使用以下语法
    `lock([RESOURCE]){...}`：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `netWorth` variable is locked for the duration of the lock code block (after
    the code leaves the code block, the lock is released) and can be accessed by only
    one thread at a time. It is also worth noting that the `lock` statement prohibits
    two threads to lock the same resource at the same moment. If two threads could
    instantiate a lock at the same time, a lock would not be able to fulfill its “one
    thread at a time” promise. This is what we call a *deadlock*: two threads holding
    onto the same resource, waiting for the other to release that resource. Belaboring
    the obvious, we try to avoid deadlocks in our code because they are notoriously
    hard to debug.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`netWorth` 变量在锁代码块期间（代码块离开后，锁被释放）被锁定，并且一次只能由一个线程访问。还值得注意的是，`lock` 语句禁止两个线程在相同时刻锁定相同的资源。如果两个线程能够在同一时刻实例化一个锁，那么锁将无法履行其“一次一个线程”的承诺。这就是我们所说的**死锁**：两个线程持有相同的资源，等待对方释放该资源。显然，我们试图在我们的代码中避免死锁，因为它们难以调试。'
- en: 'We can make an analogy to canal locks: to raise and lower boats across a canal’s
    elevation changes, we use canal locks. When a ship is second in line for the canal
    lock, a different ship uses the canal lock. Therefore, the initial ship “owns”
    and locks the canal lock. Only when the initial ship leaves the canal lock (the
    resource) is the canal lock freed and back in an available state. The second ship
    can now enter and use the canal lock. Programmatic locks come in handy when modeling
    queuing systems dealing with critical systems such as canal locks.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将水闸锁做一个类比：为了在运河的标高变化中提升和降低船只，我们使用运河锁。当一艘船排在运河锁的第二个位置时，另一艘船会使用运河锁。因此，初始船只“拥有”并锁定了运河锁。只有当初始船只离开运河锁（资源）时，运河锁才会被释放并回到可用状态。第二艘船现在可以进入并使用运河锁。当模拟处理像运河锁这样的关键系统队列系统时，程序锁非常有用。
- en: The `lock` statement works very well for locking properties within a specific
    process (e.g., a running program). If you want to lock a resource across multiple
    processes (e.g., multiple instances of your program running and interacting with
    your instance), use a mutex. When you finish using a mutex, you have to explicitly
    release it. This extra bit of verbosity makes a mutex easier to develop with than
    a lock.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock`语句在锁定特定进程内的属性（例如，正在运行的程序）方面工作得非常好。如果您想要锁定跨多个进程的资源（例如，您的程序多个实例运行并与其实例交互），请使用互斥锁。当您完成使用互斥锁后，您必须显式地释放它。这个额外的冗余使得互斥锁比锁更容易开发。'
- en: Using mutexes for cross-process thread control
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用互斥锁进行跨进程线程控制
- en: 'Unlike with a lock, we don’t need a keyword to use a mutex. Instead, we instantiate
    a static instance of the `Mutex` class. Why static? Mutexes are cross-process
    and cross-thread, so we want only one instance for the entire application. An
    important difference between locks and mutexes is that we don’t place mutexes
    on a property. Instead, we place mutexes within methods and use them to gate the
    execution of said methods. When a thread encounters a method with a mutex, the
    mutex tells the thread it must wait for its turn by using the `WaitOne` method.
    To release a mutex, use the `ReleaseMutex` method, as shown next:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与锁不同，我们不需要关键字来使用互斥锁。相反，我们实例化`Mutex`类的静态实例。为什么是静态的？互斥锁是跨进程和跨线程的，所以我们希望整个应用程序只有一个实例。锁和互斥锁之间的重要区别是我们不会在属性上放置互斥锁。相反，我们在方法中放置互斥锁，并使用它们来控制方法的执行。当一个线程遇到带有互斥锁的方法时，互斥锁会通过使用`WaitOne`方法告诉线程它必须等待它的轮次。要释放互斥锁，请使用`ReleaseMutex`方法，如下所示：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first thread that calls the `ImportantMethod` has no problems entering and
    passing the mutex gate. When the mutex lets the thread in, the thread takes ownership
    of the `Mutex` instance object. If a second thread tries to enter `ImportantMethod`
    while the first thread owns the mutex, the second has to wait until the first
    thread releases the mutex and relinquishes ownership. There is only one mutex
    to go around after all, because it is static. When the first thread no longer
    owns the mutex, the second thread takes ownership, and the cycle repeats itself.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个调用`ImportantMethod`的线程可以无问题地进入并通过互斥门。当互斥锁允许线程进入时，线程将拥有`Mutex`实例对象的所有权。如果第二个线程在第一个线程拥有互斥锁的情况下尝试进入`ImportantMethod`，则第二个线程必须等待直到第一个线程释放互斥锁并放弃所有权。毕竟只有一个互斥锁可用，因为它在程序中是静态的。当第一个线程不再拥有互斥锁时，第二个线程将获得所有权，循环重复进行。
- en: Using semaphores to allow access by multiple concurrent threads
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用信号量允许多个并发线程访问
- en: 'So, we can lock a resource (by using a lock) or gate the execution of a method
    (by using a mutex). But what if we want to gate the execution of a method but
    not create a bottleneck of a queue where only one thread at a time can execute
    the method? This is what a semaphore is for. People sometimes explain semaphores
    as “generalized mutexes” because semaphores offer functionality similar to mutexes
    but with an added twist: they allow for a specified number of threads to be in
    a gated method at the same time. To use a semaphore, we instantiate a static instance
    of the `Semaphore` class. The constructor for the `Semaphore` class takes in two
    arguments: the initial count of threads inside the method (usually `0`), and the
    maximum concurrent threads in the method, as shown next:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过使用锁来锁定资源，或者通过使用互斥锁来控制方法的执行。但如果我们想控制方法的执行，但又不想创建一个队列瓶颈，使得一次只有一个线程可以执行该方法，那该怎么办？这就是信号量的作用。人们有时将信号量解释为“广义的互斥锁”，因为信号量提供了类似于互斥锁的功能，但增加了一个额外的特性：它们允许指定数量的线程同时进入受控方法。要使用信号量，我们实例化`Semaphore`类的静态实例。`Semaphore`类的构造函数接受两个参数：方法内部线程的初始计数（通常为`0`）和方法中的最大并发线程数，如下所示：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When a thread wishes to execute the `VeryImportantMethod` method, the semaphore
    checks its internal thread counter and decides whether or not to let the thread
    in. In this example, the semaphore allows up to three concurrent threads in the
    method. A potential fourth thread has to wait until the semaphore’s internal thread
    counter returns to two. Releasing the semaphore decreases its internal counter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程希望执行`VeryImportantMethod`方法时，信号量会检查其内部的线程计数器并决定是否允许线程进入。在这个例子中，信号量允许最多三个并发线程进入该方法。潜在的第四个线程必须等待直到信号量的内部线程计数器回到两个。释放信号量会减少其内部计数器。
- en: 6.2.8 Synchronous to asynchronous execution . . . continued
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.8 同步到异步执行……继续
- en: 'The second step to convert a synchronous method to an asynchronous method is
    to change the return type of the method to be of type `Task<[type]>`, where `[type]`
    is the type you want to return (you can use `Task<void>` if you want to return
    no specific type). A `Task` is a wrapper around a unit of operation that we can
    wait on. We use the `Task` class with asynchronous methods so we can verify that
    a task is performed and return information along with task metadata. In the `CreateCustomer`
    method’s case, we returned `bool` when executing synchronously, so we should return
    `Task<bool>` when operating asynchronously. When returning a `Task<T>`, we only
    return the type we want to embed in the type. The compiler automatically converts
    the return to a `Task<T>`. For example, to return a `Task<bool>` from a method
    that has `Task<T>` as its return type, we just need to do the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将同步方法转换为异步方法的第二步是将方法的返回类型更改为 `Task<[type]>` 类型，其中 `[type]` 是你想要返回的类型（如果你想不返回任何特定类型，可以使用
    `Task<void>`）。`Task` 是围绕一个我们可以等待的操作单元的包装。我们使用 `Task` 类和异步方法，以便我们可以验证任务是否执行，并返回与任务元数据一起的信息。在
    `CreateCustomer` 方法的例子中，我们在同步执行时返回了 `bool` 类型，所以在异步操作时应该返回 `Task<bool>`。当返回 `Task<T>`
    时，我们只返回我们想要嵌入的类型。编译器会自动将返回值转换为 `Task<T>`。例如，要从返回类型为 `Task<T>` 的方法返回 `Task<bool>`，我们只需要做以下操作：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When a `Task` completes its duties, the Common Language Runtime returns the
    `Task` to the caller method with its `CompletedTask` property (of type `bool`)
    set to `true`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Task` 完成其任务时，公共语言运行时通过其 `CompletedTask` 属性（类型为 `bool`）将 `Task` 返回给调用方法，并将其设置为
    `true`。
- en: For the third step, we need to add the `async` keyword to the method signature,
    as shown in the next listing. The `async` keyword indicates that the method is
    asynchronous (and, therefore, should return a `Task<T>`). The compiler throws
    a warning if you have an asynchronous method with no `await` calls.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步，我们需要在方法签名中添加 `async` 关键字，如以下列表所示。`async` 关键字表示该方法是非阻塞的（因此应该返回 `Task<T>`）。如果你有一个没有
    `await` 调用的异步方法，编译器会抛出一个警告。
- en: Listing 6.6 CustomerRepository.cs `CreateCustomer` asynchronous
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 CustomerRepository.cs `CreateCustomer` 异步
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ The CreateCustomer method signature contains the async keyword and returns
    a type of Task<bool>.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `CreateCustomer` 方法的签名包含异步关键字，并返回 `Task<bool>` 类型。
- en: ❷ The context.SaveChangesAsync call is awaited, blocking the current thread
    until the changes have been saved.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `context.SaveChangesAsync` 调用被等待，直到更改被保存，当前线程被阻塞。
- en: ❸ The return of type bool is automatically converted to a type of Task<bool>.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回的 `bool` 类型会自动转换为 `Task<bool>` 类型。
- en: 'One final note: when you try to run your tests, you will encounter compiler
    errors in each of them. This is because they now call an asynchronous method without
    an `await` or them being asynchronous themselves. We need to fix this.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点需要注意：当你尝试运行你的测试时，你会在每个测试中遇到编译错误。这是因为它们现在调用了一个没有`await`或它们自身是异步的方法。我们需要修复这个问题。
- en: Use your newfound knowledge and convert the failing tests from executing synchronously
    to asynchronously and await the call to `CreateCustomer` method. Keep in mind
    that unit test methods return void when executing synchronously. If you get stuck,
    you can find the solution in appendix A.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你新获得的知识，将失败的测试从同步执行转换为异步执行，并等待 `CreateCustomer` 方法的调用。记住，单元测试方法在同步执行时返回 `void`。如果你遇到困难，可以在附录
    A 中找到解决方案。
- en: 6.2.9 Testing Entity Framework Core
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.9 测试 Entity Framework Core
- en: 'How would we go about testing that an object was added to the database? Sure,
    we can run the existing test, but that would interact with the database—a giant
    no-go for a unit test. But we want to verify that the tested method actually added
    an object to the database, and we do not have the code to route actual HTTP requests
    to the repository. Here is what I propose: we run the existing success case unit
    test once, check the database for the newly created entry, and then figure out
    a solution for the unit test’s connectivity issue.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何测试一个对象是否被添加到数据库中呢？当然，我们可以运行现有的测试，但这会与数据库交互——对于单元测试来说这是一个巨大的禁忌。但我们想验证测试的方法实际上是否向数据库添加了一个对象，我们没有代码来路由实际的
    HTTP 请求到存储库。以下是我的建议：我们运行现有的成功情况单元测试一次，检查数据库中新创建的条目，然后找出解决单元测试连接问题的方案。
- en: If we execute the `CreateCustomer_Success` unit test, we can query the actual
    deployed database for the created customer (`"SELECT * FROM [dbo].[Customer]"`)
    outside of our code using a database management tool such as SQL Server Manager.
    The resulting customer entry is shown in figure 6.5.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行`CreateCustomer_Success`单元测试，我们可以使用数据库管理工具（如SQL Server Manager）在我们的代码外部查询创建的客户实际部署的数据库（`"SELECT
    * FROM [dbo].[Customer]"`）。图6.5显示了结果客户条目。
- en: '![](../Images/06_05.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06_05.png)'
- en: Figure 6.5 The result of the query to select all the customers in the database.
    Your mileage may vary on the number of customers in the database due to the database
    being deployed online.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 查询数据库中所有客户的查询结果。由于数据库是在线部署的，数据库中客户的数量可能会有所不同。
- en: But we do not want to create a new entry in the actual database every time we
    run our unit test. Entity Framework Core has the concept of an in-memory database,
    which allows us to spin up a database (with the same structure as our cloud or
    locally deployed database) in memory on our machine whenever we run a test. To
    facilitate this, we need to install the `Microsoft.EntityFramework.Core.InMemory`
    package in the FlyingDutchmanAirlines_Tests project. We also need to import the
    namespaces of `Microsoft.EntityFrameworkCore` and `FlyingDutchmanAirlines.DatabaseLayer`
    into the test class.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不想在每次运行单元测试时在实际数据库中创建新的条目。Entity Framework Core有一个内存数据库的概念，它允许我们在运行测试时在我们的机器上内存中启动一个数据库（结构与我们的云或本地部署的数据库相同）。为了便于这样做，我们需要在FlyingDutchmanAirlines_Tests项目中安装`Microsoft.EntityFramework.Core.InMemory`包。我们还需要将`Microsoft.EntityFrameworkCore`和`FlyingDutchmanAirlines.DatabaseLayer`的命名空间导入到测试类中。
- en: Method attributes for unit testing and dependency injection
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试和依赖注入的方法属性
- en: Besides creating an in-memory database, it would be useful if we could create
    a new context with the appropriate in-memory options for every test with the same
    code block. What if I told you there is a method attribute that allows us to create
    a method and run it before every single test?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建内存数据库之外，如果我们能够为每个测试使用相同的代码块创建一个新的具有适当内存选项的上下文，那将非常有用。如果告诉你有一个方法属性允许我们在每个测试之前创建一个方法并运行它，你会怎么想？
- en: As shown in table 6.1, the method attribute that accomplishes this is `[TestInitialize]`.
    There are also method attributes to run a method *after* each test (`[TestCleanup]`),
    run a method before the test suite starts (`[ClassInitialize]`), and one for cleanup
    after the test suite is run (`[ClassCleanup]`). A test suite is all the tests
    in one class.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如表6.1所示，完成此操作的方法属性是`[TestInitialize]`。还有其他方法属性可以在每个测试之后运行一个方法（`[TestCleanup]`），在测试套件开始之前运行一个方法（`[ClassInitialize]`），以及在测试套件运行之后进行清理的一个方法属性。测试套件是一个类中所有测试的总和。
- en: Table 6.1 Test method attributes and when the method runs
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 测试方法属性和方法的运行时间
- en: '| Method attribute | When does the method run? |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 方法属性 | 方法何时运行？ |'
- en: '| `[ClassInitialize]` | Before any of the tests in a class |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `[ClassInitialize]` | 在类中的任何测试之前 |'
- en: '| `[TestInitialize]` | Before every test in a class |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `[TestInitialize]` | 在类中的每个测试之前 |'
- en: '| `[TestCleanup]` | After every test in a class |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `[TestCleanup]` | 在类中的每个测试之后 |'
- en: '| `[ClassCleanup]` | After all the tests in a class |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `[ClassCleanup]` | 在类中的所有测试之后 |'
- en: 'Let’s add a `TestInitialize` method using the `[TestInitialize]` method attribute
    in the `CustomerRepositoryTests` class as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`CustomerRepositoryTests`类中使用`[TestInitialize]`方法属性添加一个`TestInitialize`方法，如下所示：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We create a `private` field of type `FlyingDutchmanAirlinesContext` called `_context`
    to hold our database context so we can use it in our tests. Then we provide the
    initializer method (`TestInitialize`). In `TestInitialize` we first create an
    object of `DbContextOptions<FlyingDutchmanAirlinesContext>` that uses the Builder
    pattern to create a `DbContextBuilder`, specify that we want to use an in-memory
    database with the name `FlyingDutchman`, and return the options for setting up
    a context in memory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个类型为`FlyingDutchmanAirlinesContext`的`private`字段，名为`_context`，以存储我们的数据库上下文，这样我们就可以在测试中使用它。然后我们提供初始化方法（`TestInitialize`）。在`TestInitialize`中，我们首先创建一个`DbContextOptions<FlyingDutchmanAirlinesContext>`的对象，该对象使用Builder模式创建`DbContextBuilder`，指定我们想要使用名为`FlyingDutchman`的内存数据库，并返回设置内存上下文的选项。
- en: 'Then, we pass those options into our `FlyingDutchmanAirlinesContext` constructor
    (autogenerated by Entity Framework Core). `FlyingDutchmanAirlinesContext` has
    two constructors: one constructor with no arguments (we have used this one before)
    and one that takes in an argument of type `DbContextOptions<FlyingDutchmanAirlines>`
    and allows us to create the in-memory context in this case.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这些选项传递给我们的`FlyingDutchmanAirlinesContext`构造函数（由Entity Framework Core自动生成）。`FlyingDutchmanAirlinesContext`有两个构造函数：一个不带参数的构造函数（我们之前已经使用过）和一个接受类型为`DbContextOptions<FlyingDutchmanAirlines>`的参数的构造函数，它允许我们在这种情况下创建内存上下文。
- en: By using this context, we can run the unit tests against an in-memory database,
    rather than a real database. Entity Framework Core creates a perfect copy of the
    database schema (with no existing data) and acts as if we were acting against
    the deployed database. This allows us to perform unit tests without messing with
    an actual database.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个上下文，我们可以对内存数据库而不是真实数据库运行单元测试。Entity Framework Core创建了一个完美的数据库模式副本（没有现有数据）并模拟我们正在对已部署的数据库进行操作。这允许我们在不干扰实际数据库的情况下执行单元测试。
- en: But wait a second! How do we actually use the context? We are not passing in
    the context to the repository layer. In fact, it creates a new context in `CustomerRepository`.
    This is where dependency injection shows up again.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！我们实际上是如何使用上下文的？我们没有将上下文传递给仓库层。实际上，它在`CustomerRepository`中创建了一个新的上下文。这就是依赖注入再次出现的地方。
- en: 6.2.10 Controlling dependencies with dependency injection
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.10 使用依赖注入控制依赖
- en: 'Dependency injection (DI) is a term coined by Martin Fowler in a 2004 article
    called “*Inversion of Control Containers and the Dependency Injection Pattern*,”
    but it really is an evolution of the dependency injection technique as first written
    about by Robert Martin (of clean code fame) in a paper posted to the comp.lang.c++
    Usenet group in 1994 called *OO Design Quality Metrics: An Analysis of Dependencies.[³](#pgfId-1190451)*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）这个术语是由马丁·福勒在2004年的一篇文章中提出的，这篇文章名为“*控制反转容器和依赖注入模式*”，但实际上它是依赖注入技术的一种演变，这种技术最初是由罗伯特·马丁（以编写清洁代码而闻名）在1994年发布到comp.lang.c++
    Usenet论坛的一篇论文中描述的，这篇论文名为*面向对象设计质量度量：依赖性分析。[³](#pgfId-1190451)*
- en: Dependency injection, in its most basic terms, is a technique to provide classes
    with all the dependencies they need rather than instantiating them in the class
    themselves. This means that we can resolve dependencies at run time rather than
    at compile time. When used with interfaces, dependency injection also becomes
    a powerful tool for testing because we can pass in mocks as dependencies whenever
    we want.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入，在最基本的术语中，是一种提供类所需的所有依赖项的技术，而不是在类中自己实例化它们。这意味着我们可以在运行时而不是在编译时解决依赖项。当与接口一起使用时，依赖注入也成为了一个强大的测试工具，因为我们可以随时传递模拟作为依赖项。
- en: 'A traditional class without DI may have a dependency on an AWS (Amazon Web
    Services) client object (let’s call it `AwsClient` and also have it implement
    an interface called `IAwsClient`). This object is to be the communicator between
    AWS and our codebase. We can create this classwide object and assign it to a new
    instance of the `AwsClient` class in the class’s constructor as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有依赖注入的传统类可能依赖于一个AWS（亚马逊网络服务）客户端对象（让我们称它为`AwsClient`，并且让它实现一个名为`IAwsClient`的接口）。这个对象是AWS和我们的代码库之间的通信者。我们可以在类的构造函数中创建这个类级对象，并将其分配给`AwsClient`类的新实例，如下所示：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now imagine that we want to test this class. How do we test the `_awsClient`
    to control its returns? Because it is a private member, we cannot directly access
    it. We could use reflection to access the private member by doing some clever
    code magic, but that would be painful and computationally expensive as well as
    very unclean and complicated code. The alternative is to use dependency injection.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们想要测试这个类。我们如何测试`_awsClient`来控制其返回值？因为它是一个私有成员，所以我们不能直接访问它。我们可以使用反射通过一些聪明的代码魔法来访问私有成员，但这将是痛苦且计算成本高昂的，同时代码也非常不整洁且复杂。另一种选择是使用依赖注入。
- en: With dependency injection, instead of assigning the `_awsClient` to a new instance
    of `AwsClient` in the constructor, we pass in that new instance to the constructor.
    We need to ensure that the dependency is on an interface, in this case, `IAwsClient`,
    as shown in the next code example. That way, we can make new classes that inherit
    from `IAwSClient`, making testing much easier.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖注入，我们不是在构造函数中将`_awsClient`赋值给`AwsClient`的新实例，而是将这个新实例传递给构造函数。我们需要确保依赖是一个接口，在这种情况下，是`IAwsClient`，如下一个代码示例所示。这样，我们可以创建继承自`IAwSClient`的新类，这使得测试变得容易得多。
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Every class that wants to instantiate a new copy of `AwsConnector` now has to
    pass in an instance of a class that inherits from `IAwsClient`. To prevent `_awsClient`
    from being changed anywhere else, it is read only and private. The power of dependency
    injection is that it inverts the control of the dependency. Instead of the class
    having control of the dependency and how it is instantiated, now the calling class
    has this control. This is what we mean by “inversion of control.”
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每个想要实例化`AwsConnector`新副本的类现在都必须传递一个继承自`IAwsClient`的类的实例。为了防止`_awsClient`在别处被更改，它只能是只读的且私有的。依赖注入的力量在于它反转了依赖的控制权。不再是类控制依赖及其实例化方式，现在调用类拥有这种控制权。这就是我们所说的“控制反转”。
- en: 'Let’s change the `CustomerRepository` to use dependency injection for the `FlyingDutchmanAirlinesContext`.
    To do this, we need to do the following five things:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`CustomerRepository`改为使用`FlyingDutchmanAirlinesContext`的依赖注入。为此，我们需要做以下五件事：
- en: In `CustomerRepository`, add a `private readonly` member of type `FlyingDutchmanAirlinesContext`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CustomerRepository`中添加一个类型为`FlyingDutchmanAirlinesContext`的`private readonly`成员。
- en: Create a nondefault constructor for the `CustomerRepository` constructor that
    requires an argument of type `FlyingDutchmanAirlinesContext`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`CustomerRepository`构造函数创建一个非默认构造函数，该构造函数需要一个类型为`FlyingDutchmanAirlinesContext`的参数。
- en: In the new constructor, assign the private `FlyingDutchmanAirlinesContext` to
    the injected instance.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的构造函数中，将私有的`FlyingDutchmanAirlinesContext`赋值给注入的实例。
- en: Change the class to use the private member instead of creating a new `FlyingDutchmanAirlinesContext`
    in the `CreateCustomer` method.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类更改为使用私有成员，而不是在`CreateCustomer`方法中创建一个新的`FlyingDutchmanAirlinesContext`。
- en: Update our test to inject an instance of `FlyingDutchmanAirlinesContext` into
    the `CustomerRepository`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新我们的测试，将`FlyingDutchmanAirlinesContext`的实例注入到`CustomerRepository`中。
- en: We start by adding the `private readonly` member of type `FlyingDutchmanAirlinesContext`
    and the new `CustomerRepository` constructor. Currently, we only have the default
    (nonexplicit) constructor, so we have to create a new constructor that matches
    our needs, as shown in the following code snippet. This constructor takes the
    place of the default constructor, because we do not want to create an overloaded
    constructor without arguments. We want to force the use of our DI constructor.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加`private readonly`类型的`FlyingDutchmanAirlinesContext`成员和新的`CustomerRepository`构造函数。目前，我们只有一个默认（非显式）构造函数，因此我们必须创建一个新的构造函数来满足我们的需求，如下面的代码片段所示。这个构造函数取代了默认构造函数，因为我们不希望创建一个不带参数的重载构造函数。我们希望强制使用我们的DI构造函数。
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'That takes care of the first three items on our list. This code does contain
    a keyword that I haven’t used in this book before: the `this` keyword.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这就解决了我们列表上的前三个项目。这段代码确实包含了一个我在这本书中没有使用过的关键字：`this`关键字。
- en: Accessing a current instance’s data using the “this” keyword
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“this”关键字访问当前实例的数据
- en: 'Why did we have to use `this`? Imagine if we did not: we would have an assignment
    that assigns a variable called `_context` to another variable called `_context`.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么必须使用`this`？想象一下如果我们没有这样做：我们会有一个赋值操作，将一个名为`_context`的变量赋值给另一个名为`_context`的变量。
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But what are we assigning to what? The class field is called _`context` (incorrect
    naming convention notwithstanding), but so is the passed-in argument. There are
    two ways to resolve this conundrum: either we rename one of them (the likely candidate
    would be the constructor argument), or we find a way to specify which one we mean
    at what time. The `this` keyword refers to the current instance of a class. So
    what we are really saying when we do `this._context` is “the variable called _`context`
    in the current instance of the class.” And with that differentiator, we can safely
    assign the argument to the field. It is up to you to determine whether adding
    the `this` keyword is an acceptable alternative to renaming your variables, fields,
    or members.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们到底在给什么赋值？类字段被称为`_context`（尽管命名约定不正确），传入的参数也是如此。有两种方法可以解决这个难题：要么我们重命名其中一个（可能的候选者是构造函数参数），要么我们找到一种方法来指定在什么时间我们指的是哪一个。`this`关键字指的是类的当前实例。所以当我们使用`this._context`时，我们真正说的是“在类的当前实例中名为`_context`的变量。”有了这个区分符，我们可以安全地将参数赋给字段。是否添加`this`关键字作为重命名变量、字段或成员的可接受的替代方案，取决于你。
- en: 'My litmus test boils down to this: if you have to change the name to something
    that makes it less clear what you are trying to convey, use the `this` keyword.
    Otherwise, rename it.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我的试金石归结为以下几点：如果你必须更改名称，使其无法清楚地传达你的意图，请使用`this`关键字。否则，重命名它。
- en: '![](../Images/06_05_UN01.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![单元测试中的try-catch](../Images/06_05_UN01.png)'
- en: 'Now we have to make sure that the `CreateCustomer` method uses our newly initialized
    context instead of creating one within the method. To do this we strip the assignment
    of `context` to a new instance of `FlyingDutchmanAirlines` from the method and
    wrap the `context` member in the `using` statement as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须确保`CreateCustomer`方法使用我们新初始化的上下文，而不是在方法内部创建一个。为此，我们从方法中移除将`context`赋值给`FlyingDutchmanAirlines`新实例的赋值操作，并将`context`成员用`using`语句包裹，如下所示：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You’ve now changed an existing method to use dependency injection. But what
    happens if the `SaveChangesAsync` method throws an error? Perhaps we cannot connect
    to the database anymore. Or there is something wrong with the deployed schema?
    We can wrap the database access code in a `try-catch` block, catching any exception
    so we can handle the exception (by returning `false`) instead of crashing the
    service, as shown next:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经将一个现有方法更改为使用依赖注入。但如果`SaveChangesAsync`方法抛出错误怎么办？也许我们不能再连接到数据库了。或者部署的架构有问题？我们可以将数据库访问代码包裹在`try-catch`块中，捕获任何异常，这样我们就可以处理异常（通过返回`false`），而不是使服务崩溃，如下所示：
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The last thing that remains is to update our tests to injected dependency and
    create a unit test for the error case.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的就是更新我们的测试以注入依赖，并为错误情况创建一个单元测试。
- en: Unit testing with try-catches
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用try-catch进行单元测试
- en: 'To use dependency injection and asynchronous methods with our existing tests,
    we first have to make sure that all our test methods calling an asynchronous method
    (using `await`) return a type of `Task` and are asynchronous. Go ahead and update
    all tests. Then, we need to add the in-memory database context (`_context`) to
    the `CustomerRepository` instance creations, as shown here:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的现有测试中使用依赖注入和异步方法，我们首先必须确保所有调用异步方法（使用`await`）的测试方法都返回`Task`类型并且是异步的。继续更新所有测试。然后，我们需要将内存数据库上下文（`_context`）添加到`CustomerRepository`实例创建中，如下所示：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: All we did was add the `_context` instance to the new `CustomerRepository` constructor
    call. Do this for the other tests in the file, and you should be set on that front.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的只是将`_context`实例添加到新的`CustomerRepository`构造函数调用中。为文件中的其他测试执行此操作，你应该在这方面准备好。
- en: 'NOTE I like using the following template for my test names: {METHOD NAME} _{EXPECTED
    OUTCOME}. It uses snake casing to separate the method under test from the result:
    `CreateCustomer_Success`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我喜欢使用以下模板来命名我的测试：{方法名}_{预期结果}。它使用蛇形大小写来区分正在测试的方法和结果：`CreateCustomer_Success`。
- en: 'For the unit test, we can take two approaches to testing whether the method
    throws an `Exception` (by asserting that the method returned a Boolean with a
    value of false):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单元测试，我们可以采取两种方法来测试方法是否抛出`Exception`（通过断言方法返回了一个值为`false`的布尔值）：
- en: Pass in `null` instead of the correctly instantiated `_context`.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`null`代替正确实例化的`_context`。
- en: Stub `FlyingDutchmanAirlinesContext`, and have it throw an error based on a
    predefined condition.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟`FlyingDutchmanAirlinesContext`，并基于预定义的条件抛出错误。
- en: 'For this test, we are going with the first approach: passing in `null` instead
    of `_context` to the `CustomerRepository` constructor. We’ll discuss and use stubs
    in chapter 8\. Passing in a `null` value for the dependency in the `CustomerRepository`
    constructor means that `CustomerRepository._context` is set to `null` and, therefore,
    causes a null pointer exception when trying to add a new `Customer`. This is sufficient
    for us to test the `try-catch` failure case as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试，我们采用第一种方法：将 `null` 而不是 `_context` 传递给 `CustomerRepository` 构造函数。我们将在第
    8 章讨论并使用存根。在 `CustomerRepository` 构造函数中传递 `null` 值意味着 `CustomerRepository._context`
    被设置为 `null`，因此，在尝试添加新 `Customer` 时会导致空指针异常。这对我们来说足够测试 `try-catch` 失败情况，如下所示：
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we run all the tests, we see that they pass. We are now testing with a completely
    in-memory database. Is there anything we can clean up before we move on? Well,
    yes, there is. If we look at our unit tests, we notice the following two repeating
    lines of code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行所有测试，我们会看到它们都通过了。我们现在使用的是完全的内存数据库。在我们继续之前，我们能清理些什么吗？嗯，是的，我们可以。如果我们查看我们的单元测试，我们会注意到以下两行重复的代码：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is an excellent moment to apply the DRY principle. How about we extract
    the creation of the `CustomerRepository` into the `TestInitialize` method we created
    earlier, then expose it as a private member on the class for the tests to use,
    as shown next? It is updated before every test with a fresh instance of the `CustomerRepository`,
    so we are still guaranteed an isolated environment.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个应用 DRY 原则的绝佳时刻。我们是否可以将 `CustomerRepository` 的创建提取到我们之前创建的 `TestInitialize`
    方法中，然后将其作为类上的私有成员暴露出来，以便测试使用，如下所示？在每次测试之前，它都会使用 `CustomerRepository` 的新实例进行更新，所以我们仍然保证了一个隔离的环境。
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With the `CustomerRepository` creation now in the `TestInitialize` method, we
    can remove it for every test. For example, listing 6.7 shows how this impacts
    the `CreateCustomer_Failure_NameIsNull` unit test. Note, however, that we do not
    want to do the same for `CreateCustomer_Failure_DatabaseAccessError`, because
    it relies on instantiating the repository with a `null` value as its input argument.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将 `CustomerRepository` 的创建移至 `TestInitialize` 方法中，我们可以为每个测试移除它。例如，列表 6.7 展示了这对
    `CreateCustomer_Failure_NameIsNull` 单元测试的影响。然而，我们不想对 `CreateCustomer_Failure_DatabaseAccessError`
    做同样的事情，因为它依赖于使用 `null` 值作为输入参数来实例化存储库。
- en: Listing 6.7 CustomerRepositoryTest updated `CreateCustomer_Failure_NameIsNull`
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 客户存储库测试更新 `CreateCustomer_Failure_NameIsNull`
- en: '[PRE38]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, to recap: we created a `CreateCustomer` method in `CustomerRepository`
    (along with the appropriate unit tests). The `CreateCustomer` method allows us
    to add new `Customer` objects to the database. But we also want to return the
    `Customer` objects when given a `CustomerID`. So, why don’t we create a method
    that does that in the next chapter? By now you know the trick of TDD: we are going
    to create a unit test until we get stuck (that is, until we cannot compile or
    pass the test anymore), then we add the next piece of logic, then rinse and repeat.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下：我们在 `CustomerRepository` 中创建了一个 `CreateCustomer` 方法（以及相应的单元测试）。`CreateCustomer`
    方法允许我们将新的 `Customer` 对象添加到数据库中。但我们也想当给定 `CustomerID` 时返回 `Customer` 对象。那么，我们为什么不创建一个在下一章中执行此操作的方法呢？到现在为止，你知道
    TDD 的技巧：我们将创建一个单元测试，直到我们卡住（也就是说，直到我们不能再编译或通过测试为止），然后我们添加下一块逻辑，然后重复这个过程。
- en: Exercises
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 6.4
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.4
- en: 'Fill in the blanks: The three A’s of testing are 1\. __________, 2\. __________,
    and 3\. __________.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 填空：测试的三个 A 是 1. __________，2. __________，和 3. __________。
- en: a. affirm; assert; align
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: a. affirm; assert; align
- en: b. affix; advance; await
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: b. affix; advance; await
- en: c. arrange; act; assert
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: c. arrange; act; assert
- en: d. Iact; alter; answer
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: d. Iact; alter; answer
- en: Exercise 6.5
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.5
- en: True or false? With Language-Integrated Query, we can use query collections
    by passing in C++ code, which gets upgraded to C# and executed.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？使用语言集成查询，我们可以通过传递 C++ 代码来使用查询集合，该代码被升级为 C# 并执行。
- en: Exercise 6.6
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.6
- en: How many checks does a conditional logical OR operator (`||`) make if the first
    condition evaluates to `false`?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个条件评估为 `false`，条件逻辑或运算符 (`||`) 会进行多少次检查？
- en: a. One
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: a. 一个
- en: b. Two
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: b. 两个
- en: c. Three
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: c. 三个
- en: d. It depends.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: d. 取决于。
- en: Exercise 6.7
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.7
- en: How many checks does an exclusive OR operator (`^`) make if the first condition
    evaluates to `false`?
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个条件评估为 `false`，排他或运算符 (`^`) 会进行多少次检查？
- en: a. One
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: a. 一个
- en: b. Two
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: b. 两个
- en: c. Three
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: c. 三个
- en: d. It depends.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: d. 取决于。
- en: Exercise 6.8
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 6.8
- en: True or false? To convert a synchronous method to an asynchronous method, the
    method needs to return a type of `Task<[original return type]>` or `Task`, have
    the `async` keyword in the method signature, and `await` any asynchronous calls.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 真或假？要将同步方法转换为异步方法，方法需要返回类型为`Task<[original return type]>`或`Task`，在方法签名中包含`async`关键字，并且`await`任何异步调用。
- en: Exercise 6.9
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.9
- en: 'Fill in the blanks: When unit testing, we perform operations against __________
    database.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 填空：在单元测试时，我们针对_________数据库执行操作。
- en: a. an in-memory
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: a. 一个内存中的
- en: b. a deployed
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: b. 一个部署的
- en: c. a broken
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: c. 一个损坏的
- en: Exercise 6.10
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.10
- en: True or false? With dependency injection, we invert control over dependencies
    from the class to the caller.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 真或假？使用依赖注入，我们反转了依赖项的控制权，从类到调用者。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The single-responsibility principle tells us to do only one thing in a method
    and to do it well. If we heed this creed, we end up with code that is maintainable
    and extensible.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则告诉我们，在方法中只做一件事，并且要做好。如果我们遵循这个信条，最终我们会得到可维护和可扩展的代码。
- en: 'Test-driven development has two stages: red (tests failing or not compiling)
    and green (tests are passing). Switching between the two stages (red and green)
    allows us to write tests in conjunction with features. In the red stage, the tests
    don’t pass or the code does not compile. Our job in the red stage is to make the
    test pass and make the code compile. In the green stage, the code compiles and
    the tests pass. During the green stage, we write new code that implements the
    next step of our feature. This makes the tests fail, and, therefore, we are back
    in the red stage.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发有两个阶段：红色（测试失败或无法编译）和绿色（测试通过）。在两个阶段（红色和绿色）之间切换，使我们能够在编写功能的同时编写测试。在红色阶段，测试无法通过或代码无法编译。我们在红色阶段的任务是使测试通过并使代码编译。在绿色阶段，代码编译且测试通过。在绿色阶段，我们编写新的代码来实现我们功能的下一步。这使得测试失败，因此我们回到了红色阶段。
- en: Language-Integrated Query (LINQ) allows us to perform SQL-like queries against
    collections. We can use this to simplify our code tremendously when dealing with
    databases.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言集成查询（LINQ）允许我们对集合执行类似SQL的查询。我们可以使用它来极大地简化处理数据库时的代码。
- en: We can use dependency injection (DI) with unit tests to provide more granular
    control on calls to dependencies. When using DI, the data flow is reversed, and
    the calling method needs to provide dependencies, as opposed to having them instantiated
    on the spot.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用依赖注入（DI）与单元测试一起使用，以对依赖项的调用提供更细粒度的控制。在使用DI时，数据流是相反的，调用方法需要提供依赖项，而不是在原地实例化它们。
- en: '* * *'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^(1.)The runtime complexity of iterating over a set of *N* characters for every
    character in a given string is *O*(*n*²). This is calculated by taking the runtime
    of iterating over a set of *N* characters ({*N* }):*O*(*n*) and multiplying that
    by the runtime iterating over every character in a string, also {*N* }. This gives
    us *O*(*n*) * *O*(*n*), which we can further combine into *O*(*n* * *n*), and
    once more into the final runtime of *O*(*n*²). To summarize: *O*(*n*) * *O*(*n*)
    = *O*(*n* * *n*) = *O*(*n*²). There is a chance that the regex implementation
    does its processing with the same concepts and runtime complexity.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ^（1.）遍历给定字符串中每个字符的字符集的运行时间复杂度为*O*(*n*²)。这是通过将遍历字符集的运行时间*O*(*n*)（{*N*}）乘以遍历字符串中每个字符的运行时间，也是{*N*}来计算的。这给我们*O*(*n*)
    * *O*(*n*)，我们可以进一步将其组合为*O*(*n* * *n*)，然后再将其组合为最终的运行时间*O*(*n*²)。总结一下：*O*(*n*) *
    *O*(*n*) = *O*(*n* * *n*) = *O*(*n*²)。有可能正则表达式实现使用相同的概念和运行时间复杂度进行处理。
- en: ^(2.)The author was a tech reviewer for Vladimir Khorikov’s *Unit Testing Principles,
    Practices, and Patterns* (Manning, 2020).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ^（2.）作者曾是Vladimir Khorikov的《单元测试原则、实践和模式》（Manning，2020）的技术审稿人。
- en: '^(3.)The original post to the comp.lang.c++ usenet group can be found at [https://groups.google.com/forum/
    #!msg/comp.lang.c++/KU-LQ3hINks/ouRSXPUpybkJ](https://groups.google.com/forum/#!msg/comp.lang.c++/KU-LQ3hINks/ouRSXPUpybkJ).'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ^（3.）原始帖子可以在[https://groups.google.com/forum/#!msg/comp.lang.c++/KU-LQ3hINks/ouRSXPUpybkJ](https://groups.google.com/forum/#!msg/comp.lang.c++/KU-LQ3hINks/ouRSXPUpybkJ)找到。
