- en: Chapter 16\. Regular expressions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 16 章。正则表达式
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding regular expressions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解正则表达式
- en: Creating regular expressions with special characters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特殊字符创建正则表达式
- en: Using raw strings in regular expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在正则表达式中使用原始字符串
- en: Extracting matched text from strings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符串中提取匹配的文本
- en: Substituting text with regular expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式替换文本
- en: Some might wonder why I’m discussing regular expressions in this book at all.
    Regular expressions are implemented by a single Python module and are advanced
    enough that they don’t even come as part of the standard library in languages
    like C or Java. But if you’re using Python, you’re probably doing text parsing;
    if you’re doing that, regular expressions are too useful to be ignored. If you’ve
    used Perl, Tcl, or Linux/UNIX, you may be familiar with regular expressions; if
    not, this chapter goes into them in some detail.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会 wonder 为什么我会在本书中讨论正则表达式。正则表达式由一个单独的 Python 模块实现，足够高级，以至于它们甚至不是像 C 或 Java
    这样的语言的标准库的一部分。但是如果你使用 Python，你很可能会进行文本解析；如果你这样做，正则表达式非常有用，不容忽视。如果你使用过 Perl、Tcl
    或 Linux/UNIX，你可能熟悉正则表达式；如果不熟悉，本章将详细介绍它们。
- en: 16.1\. What is a regular expression?
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1. 什么是正则表达式？
- en: A *regular expression* (regex) is a way of recognizing and often extracting
    data from certain patterns of text. A regex that recognizes a piece of text or
    a string is said to *match* that text or string. A regex is defined by a string
    in which certain characters (the so-called *metacharacters*) can have a special
    meaning, which enables a single regex to match many different specific strings.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*正则表达式*（regex）是一种识别和通常从某些文本模式中提取数据的方法。一个识别文本或字符串的正则表达式被称为匹配那个文本或字符串。正则表达式由一个字符串定义，其中某些字符（所谓的
    *元字符*）可以具有特殊含义，这使得单个正则表达式可以匹配许多不同的特定字符串。'
- en: 'It’s easier to understand this through example than through explanation. Here’s
    a program with a regular expression that counts how many lines in a text file
    contain the word *hello*. A line that contains *hello* more than once is counted
    only once:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过示例比通过解释更容易理解这一点。以下是一个程序，它使用正则表达式来计算文本文件中有多少行包含单词 *hello*。包含 *hello* 一次以上的行只计算一次：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The program starts by importing the Python regular expression module, called
    `re`. Then it takes the text string `"hello"` as a *textual regular expression*
    and compiles it into a *compiled regular expression*, using the `re.compile` function.
    This compilation isn’t strictly necessary, but compiled regular expressions can
    significantly increase a program’s speed, so they’re almost always used in programs
    that process large amounts of text.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先导入 Python 正则表达式模块，称为 `re`。然后它将文本字符串 `"hello"` 作为 *文本正则表达式* 编译成一个 *编译后的正则表达式*，使用
    `re.compile` 函数。这种编译不是严格必要的，但编译后的正则表达式可以显著提高程序的速度，因此在处理大量文本的程序中几乎总是使用它们。
- en: What can the regex compiled from `"hello"` be used for? You can use it to recognize
    other instances of the word `"hello"` within another string; in other words, you
    can use it to determine whether another string contains `"hello"` as a substring.
    This task is accomplished by the `search` method, which returns `None` if the
    regular expression isn’t found in the string argument; Python interprets `None`
    as `false` in a Boolean context. If the regular expression is found in the string,
    Python returns a special object that you can use to determine various things about
    the match (such as where in the string it occurred). I discuss this topic later.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `"hello"` 编译的正则表达式能用来做什么？你可以用它来识别另一个字符串中 `"hello"` 的其他实例；换句话说，你可以用它来确定另一个字符串是否包含
    `"hello"` 作为子串。这个任务是通过 `search` 方法完成的，如果正则表达式在字符串参数中没有找到，则返回 `None`；Python 在布尔上下文中将
    `None` 解释为 `false`。如果正则表达式在字符串中找到，Python 返回一个特殊对象，你可以用它来确定匹配的各种信息（例如它在字符串中的位置）。我将在后面讨论这个话题。
- en: 16.2\. Regular expressions with special characters
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2. 带有特殊字符的正则表达式
- en: 'The previous example has a small flaw: It counts how many lines contain `"hello"`
    but ignores lines that contain `"Hello"` because it doesn’t take capitalization
    into account.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子有一个小缺陷：它计算包含 `"hello"` 的行数，但忽略了包含 `"Hello"` 的行，因为它没有考虑大小写。
- en: One way to solve this problem would be to use two regular expressions—one for
    `"hello"` and one for `"Hello"`—and test each against every line. A better way
    is to use the more advanced features of regular expressions. For the second line
    in the program, substitute
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的另一种方法可以是使用两个正则表达式——一个用于 `"hello"`，另一个用于 `"Hello"`——并对每一行进行测试。更好的方法是使用正则表达式的更高级功能。对于程序的第二行，替换为
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This regular expression uses the vertical-bar special character `|`. A *special
    character* is a character in a regex that isn’t interpreted as itself; it has
    some special meaning. `|` means *or*, so the regular expression matches `"hello"`
    *or* `"Hello"`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式使用了竖线特殊字符 `|`。特殊字符是指正则表达式中的一个字符，它不被解释为其自身；它具有某种特殊含义。`|` 表示 *或*，因此正则表达式匹配
    `"hello"` *或* `"Hello"`。
- en: Another way of solving this problem is to use
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的另一种方法是使用
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In addition to using `|`, this regular expression uses the *parentheses* special
    characters to group things, which in this case means that the `|` chooses between
    a small or capital *H*. The resulting regex matches either an *h* or an *H*, followed
    by *ello*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `|` 之外，这个正则表达式还使用了 *括号* 特殊字符来分组，在这种情况下意味着 `|` 在小写或大写 *H* 之间进行选择。结果正则表达式匹配一个
    *h* 或一个 *H*，后面跟着 *ello*。
- en: Another way to perform the match is
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种执行匹配的方法是
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The special characters `[` and `]` take a string of characters between them
    and match any single character in that string. There’s a special shorthand to
    denote ranges of characters in `[` and `]`; `[a-z]` match a single character between
    *a* and *z*, `[0-9A-Z]` match any digit or any uppercase character, and so forth.
    Sometimes, you may want to include a real hyphen in the `[]`, in which case you
    should put it as the first character to avoid defining a range; `[-012]` match
    a hyphen, a *0*, a *1*, or a *2*, and nothing else.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊字符 `[` 和 `]` 在它们之间匹配任何单个字符。在 `[` 和 `]` 中有一个特殊的缩写来表示字符范围；`[a-z]` 匹配 *a* 和 *z*
    之间的单个字符，`[0-9A-Z]` 匹配任何数字或任何大写字母，等等。有时，您可能想在 `[]` 中包含一个真正的连字符，在这种情况下，您应该将其作为第一个字符放置，以避免定义一个范围；`[-012]`
    匹配一个连字符、一个 *0*、一个 *1* 或一个 *2*，以及其他任何东西。
- en: Quite a few special characters are available in Python regular expressions,
    and describing all of the subtleties of using them in regular expressions is beyond
    the scope of this book. A complete list of the special characters available in
    Python regular expressions, as well as descriptions of what they mean, is in the
    online documentation of the regular expression `re` module in the standard library.
    For the remainder of this chapter, I describe the special characters I use as
    they appear.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python 正则表达式中有很多特殊字符可用，描述它们在正则表达式中的所有细微差别超出了本书的范围。Python 正则表达式中可用的特殊字符的完整列表，以及它们含义的描述，可以在标准库中正则表达式
    `re` 模块的在线文档中找到。在本章的剩余部分，我将按它们出现的顺序描述我使用的特殊字符。
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Special characters in regular expressions'
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：正则表达式中的特殊字符
- en: What regular expression would you use to match strings that represent the numbers
    -5 through 5?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您会使用什么正则表达式来匹配表示 -5 到 5 的数字的字符串？
- en: What regular expression would you use to match a hexadecimal digit? Assume that
    allowed hexadecimal digits are 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, A, a, B, b, C, c,
    D, d, E, e, F, and f.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您会使用什么正则表达式来匹配十六进制数字？假设允许的十六进制数字是 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, A, a, B, b,
    C, c, D, d, E, e, F, 和 f。
- en: '|  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 16.3\. Regular expressions and raw strings
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3\. 正则表达式和原始字符串
- en: The functions that compile regular expressions, or search for matches to regular
    expressions, understand that certain character sequences in strings have special
    meanings in the context of regular expressions. regex functions understand that
    `\n` represents a newline character, for example. But if you use normal Python
    strings as regular expressions, the regex functions typically never see such special
    sequences, because many of these sequences also possess a special meaning in normal
    strings. `\n`, for example, also means newline in the context of a normal Python
    string, and Python automatically replaces the string sequence `\n` with a newline
    character before the `regex` function ever sees that sequence. The `regex` function,
    as a result, compiles strings with embedded newline characters—not with embedded
    `\n` sequences.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 编译正则表达式或搜索正则表达式匹配的函数理解，字符串中的某些字符序列在正则表达式的上下文中具有特殊含义。例如，regex 函数理解 `\n` 表示换行字符。但是如果你使用正常的
    Python 字符串作为正则表达式，regex 函数通常永远不会看到这样的特殊序列，因为这些序列中的许多在正常字符串中也有特殊含义。例如，`\n` 在正常的
    Python 字符串上下文中也表示换行符，Python 在 `regex` 函数看到该序列之前自动将字符串序列 `\n` 替换为换行符。因此，`regex`
    函数编译包含嵌入换行符的字符串——而不是嵌入的 `\n` 序列。
- en: 'In the case of `\n`, this situation makes no difference because `regex` functions
    interpret a newline character as exactly that and do the expected thing: attempt
    to match the character with another newline character in the text being searched.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `\n` 的情况下，这种情况没有区别，因为 `regex` 函数将换行字符解释为正是那样，并执行预期的操作：尝试在搜索的文本中匹配另一个换行字符。
- en: Now look at another special sequence, `\\`, which represents a *single* backslash
    to regular expressions. Assume that you want to search text for an occurrence
    of the string `"\ten"`. Because you know that you have to represent a backslash
    as a double backslash, you might try
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看另一个特殊序列，`\\`，它代表正则表达式中的 *单个* 反斜杠。假设你想要在文本中搜索字符串 `"\ten"` 的出现。因为你知道你必须用双反斜杠来表示反斜杠，你可能会尝试
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example compiles without complaining, but it’s wrong. The problem is that
    `\\` also means a single backslash in Python strings. Before `re.compile` is invoked,
    Python interprets the string you typed as meaning `\ten`, which is what is passed
    to `re.compile`. In the context of regular expressions, `\t` means *tab*, so your
    compiled regular expression searches for a tab character followed by the two characters
    *en*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子编译时没有抱怨，但是它是错误的。问题在于在 Python 字符串中，`\\` 也表示一个单独的反斜杠。在调用 `re.compile` 之前，Python
    将你输入的字符串解释为 `\ten`，这就是传递给 `re.compile` 的内容。在正则表达式的上下文中，`\t` 表示 *制表符*，所以你编译的正则表达式搜索的是制表符字符后面跟着的两个字符
    *en*。
- en: 'To fix this problem while using regular Python strings, you need four backslashes.
    Python interprets the first two backslashes as a special sequence representing
    a single backslash, and likewise for the second pair of backslashes, resulting
    in two *actual* backslashes in the Python string. Then that string is passed in
    to `re.compile`, which interprets the two actual backslashes as a regex special
    sequence representing a single backslash. Your code looks like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用正常的 Python 字符串解决这个问题，你需要四个反斜杠。Python 将前两个反斜杠解释为表示单个反斜杠的特殊序列，同样对于第二对反斜杠也是如此，结果在
    Python 字符串中有两个 *实际* 的反斜杠。然后这个字符串被传递给 `re.compile`，它将这两个实际的反斜杠解释为正则表达式特殊序列，表示单个反斜杠。你的代码看起来像这样：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That seems confusing, and it’s why Python has a way of defining strings that
    doesn’t apply the normal Python rules to special characters. Strings defined this
    way are called *raw strings*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很令人困惑，这就是为什么 Python 有一种定义字符串的方法，它不会将正常的 Python 规则应用于特殊字符。以这种方式定义的字符串被称为
    *原始字符串*。
- en: 16.3.1\. Raw strings to the rescue
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.3.1\. 原始字符串的拯救
- en: 'A raw string looks similar to a normal string except that it has a leading
    *r* character immediately preceding the initial quotation mark of the string.
    Here are some raw strings:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串看起来与普通字符串相似，只是它有一个前导的 *r* 字符，紧接在字符串的第一个引号之前。以下是一些原始字符串：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, you can use raw strings with either the single or double quotation
    marks and with the regular or triple-quoting convention. You can also use a leading
    *R* instead of *r* if you want to. No matter how you do it, raw-string notation
    can be taken as an instruction to Python saying “Don’t process special sequences
    in this string.” In the previous examples, all the raw strings are equivalent
    to their normal string counterparts except the second example, in which the `\t`
    and `\n` sequences aren’t interpreted as tabs or newlines but are left as two-string
    character sequences beginning with a backslash.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以使用单引号、双引号或正则表达式或三引号约定来使用原始字符串。你也可以选择用 *R* 开头而不是 *r*。无论你如何做，原始字符串的表示法都可以被视为对Python的指令：“在这个字符串中不要处理特殊序列。”在之前的例子中，所有原始字符串都与它们的普通字符串对应物等效，除了第二个例子，其中`\t`和`\n`序列不被解释为制表符或换行符，而是作为以反斜杠开头的两个字符串字符序列。
- en: 'Raw strings aren’t different types of strings. They represent a different way
    of *defining* strings. It’s easy to see what’s happening by running a few examples
    interactively:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串并不是不同类型的字符串。它们代表了一种定义字符串的不同方式。通过运行几个交互式示例，你可以很容易地看到正在发生什么：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using raw strings with regular expressions means that you don’t need to worry
    about any funny interactions between string special sequences and regex special
    sequences. You use the regex special sequences. Then the previous regex example
    becomes
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原始字符串与正则表达式结合意味着你不需要担心字符串特殊序列和正则表达式特殊序列之间的任何奇怪交互。你使用正则表达式特殊序列。然后，之前的正则表达式示例变为
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: which works as expected. The compiled regex looks for a single backslash followed
    by the letters *ten*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式按预期工作。编译后的正则表达式寻找一个反斜杠后跟字母 *ten*。
- en: You should get into the habit of using raw strings whenever defining regular
    expressions, and you’ll do so for the remainder of this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该养成在定义正则表达式时使用原始字符串的习惯，并且你将在本章的剩余部分这样做。
- en: 16.4\. Extracting matched text from strings
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4. 从字符串中提取匹配的文本
- en: One of the most common uses of regular expressions is to perform simple pattern-based
    parsing on text. This task is something you should know how to do, and it’s also
    a good way to learn more regex special characters.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式最常见的一个用途是对文本进行基于简单模式的解析。这项任务你应该知道如何完成，这也是学习更多正则表达式特殊字符的好方法。
- en: 'Assume that you have a list of people and phone numbers in a text file. Each
    line of the file looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含人名和电话号码的文本文件列表。文件的每一行看起来像这样：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You have a surname followed by a comma and space, followed by a first name,
    followed by a space, followed by a middle name, followed by colon and a space,
    followed by a phone number.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个姓氏，后面跟着一个逗号和空格，然后是一个名字，后面跟着一个空格，然后是一个中间名，后面跟着冒号和空格，然后是一个电话号码。
- en: But to make things complicated, a middle name may not exist, and a phone number
    may not have an area code. (It might be 800-123-4567 or 123-4567.) You *could*
    write code to explicitly parse data out from such a line, but that job would be
    tedious and error-prone. Regular expressions provide a simpler answer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为了使事情复杂化，中间名可能不存在，电话号码可能没有区号。（它可能是800-123-4567或123-4567。）你可以编写代码来显式地从这样的行中解析数据，但这项工作将是乏味且容易出错的。正则表达式提供了一个更简单的解决方案。
- en: Start by coming up with a regex that matches lines of the given form. The next
    few paragraphs throw quite a few special characters at you. Don’t worry if you
    don’t get them all on the first read; as long as you understand the gist of things,
    that’s all right.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要想出一个正则表达式来匹配给定形式的行。接下来的几段会向你展示很多特殊字符。如果你第一次阅读时没有全部理解，不要担心；只要你能理解事情的大致内容，那就足够了。
- en: 'For simplicity’s sake, assume that first names, surnames, and middle names
    consist of letters and possibly hyphens. You can use the `[]` special characters
    discussed in the previous section to define a pattern that defines only name characters:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，假设名字、姓氏和中间名由字母和可能的连字符组成。你可以使用上一节中讨论的`[]`特殊字符来定义一个只定义名字字符的模式：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This pattern matches a single hyphen, a single lowercase letter, or a single
    uppercase letter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式匹配单个连字符、单个小写字母或单个大写字母。
- en: To match a full name (such as McDonald), you need to repeat this pattern. The
    `+` metacharacter repeats whatever comes before it one or more times as necessary
    to match the string being processed. So the pattern
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配全名（如McDonald），你需要重复这个模式。`+` 元字符会根据需要重复其前面的任何内容一次或多次，以匹配正在处理的字符串。所以这个模式
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: matches a single name, such as Kenneth or McDonald or Perkin-Elmer. It also
    matches some strings that aren’t names, such as --- or -a-b-c-, but that’s all
    right for purposes of this example.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配单个名字，如Kenneth、McDonald或Perkin-Elmer。它还匹配一些不是名字的字符串，如---或-a-b-c-，但对于这个例子来说这没关系。
- en: Now, what about the phone number? The special sequence `\d` matches any digit,
    and a hyphen outside `[]` is a normal hyphen. A good pattern to match the phone
    number is
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，电话号码怎么办呢？特殊序列`\d`匹配任何数字，而`[]`外的连字符是一个普通的连字符。匹配电话号码的一个好模式是
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That’s three digits followed by a hyphen, followed by three digits, followed
    by a hyphen, followed by four digits. This pattern matches only phone numbers
    with an area code, and your list may contain numbers that don’t have one. The
    best solution is to enclose the area-code part of the pattern in `()`; group it;
    and follow that group with a `?` special character, which says that the thing
    coming immediately before the `?` is optional:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由三个数字组成，后面跟着一个连字符，然后是三个数字，再跟着一个连字符，最后是四个数字。这个模式只匹配带有区号的电话号码，而你的列表中可能包含没有区号的号码。最好的解决方案是将模式中的区号部分用`()`括起来；将其分组；然后在该组后面跟着一个`?`特殊字符，这意味着紧跟在`?`前面的内容是可选的：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This pattern matches a phone number that may or may not contain an area code.
    You can use the same sort of trick to account for the fact that some of the people
    in your list have middle names (or initials) included and others don’t. (To do
    so, make the middle name optional by using grouping and the `?` special character.)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式匹配一个可能包含或不包含区号的电话号码。你可以使用类似的技巧来处理你列表中的一些人包含中间名（或首字母缩写）而另一些人没有的情况。（为此，通过分组和`?`特殊字符使中间名可选。）
- en: 'You can also use `{}` to indicate the number of times that a pattern should
    repeat, so for the phone-number examples above, you could use:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`{}`来表示模式应该重复的次数，所以对于上面的电话号码示例，你可以使用：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This pattern also means an optional group of three digits plus a hyphen, three
    digits followed by a hyphen, and then four digits.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式还意味着一个可选的三位数加连字符的组合，接着是三个数字跟着一个连字符，然后是四个数字。
- en: Commas, colons, and spaces don’t have any special meanings in regular expressions;
    they mean themselves.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号、冒号和空格在正则表达式中没有特殊含义；它们代表它们自己。
- en: 'Putting everything together, you come up with a pattern that looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，你得到的模式看起来像这样：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A real pattern probably would be a bit more complex, because you wouldn’t assume
    that there’s exactly one space after the comma, exactly one space after the first
    and middle names, and exactly one space after the colon. But that’s easy to add
    later.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真正的模式可能会更复杂一些，因为你不会假设逗号后面恰好有一个空格，第一个和中间名后面恰好有一个空格，冒号后面恰好有一个空格。但这很容易添加。
- en: 'The problem is that, whereas the above pattern lets you check to see whether
    a line has the anticipated format, you can’t extract any data yet. All you can
    do is write a program like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，虽然上述模式让你可以检查一行是否具有预期的格式，但你还不能提取任何数据。你所能做的就是编写一个像这样的程序：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Last name and comma**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 姓氏和逗号**'
- en: '***2* First name**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 名字**'
- en: '***3* Optional middle name**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 可选的中名**'
- en: '***4* Colon and phone number**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 冒号和电话号码**'
- en: Notice that you’ve split your regex pattern, using the fact that Python implicitly
    concatenates any set of strings separated by whitespace. As your pattern grows,
    this technique can be a great aid in keeping the pattern maintainable and understandable.
    It also solves the problem with the line length possibly increasing beyond the
    right edge of the screen.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到你已经拆分了正则表达式模式，利用了Python隐式地将由空白字符分隔的任何字符串连接起来的事实。随着模式的增长，这种技术可以在保持模式可维护和可理解方面发挥巨大的作用。它还解决了行长度可能超出屏幕右边缘的问题。
- en: 'Fortunately, you can use regular expressions to extract data from patterns,
    as well as to see whether the patterns exist. The first step is to group each
    subpattern corresponding to a piece of data you want to extract by using the `()`
    special characters. Then give each subpattern a unique name with the special sequence
    `?P<name>`, like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用正则表达式从模式中提取数据，以及查看模式是否存在。第一步是使用`()`特殊字符将每个子模式分组，这些子模式对应于你想要提取的数据。然后给每个子模式一个唯一的名称，使用特殊序列`?P<name>`，如下所示：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: (Please note that you should enter these lines as a single line, with no line
    breaks. Due to space constraints, the code can’t be represented here in that manner.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，你应该将这些行作为单行输入，不要有行中断。由于空间限制，代码不能以这种方式表示。）
- en: 'There’s an obvious point of confusion here: The question marks in `?P<...>`
    and the question-mark special characters indicating that the middle name and area
    code are optional have nothing to do with one another. It’s an unfortunate semi-coincidence
    that they happen to be the same character.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个明显的混淆点：`?P<...>`中的问号和表示中间名和区号可选的特殊字符问号没有任何关系。它们碰巧是同一个字符，这是一个不幸的半巧合。
- en: 'Now that you’ve named the elements of the pattern, you can extract the matches
    for those elements by using the `group` method. You can do so because when the
    `search` function returns a successful match, it doesn’t return just a truth value;
    it also returns a data structure that records what was matched. You can write
    a simple program to extract names and phone numbers from your list and print them
    out again, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经命名了模式的元素，你可以通过使用`group`方法来提取这些元素的匹配。你可以这样做，因为当`search`函数返回一个成功的匹配时，它不仅返回一个布尔值；它还返回一个记录了匹配内容的数据结构。你可以编写一个简单的程序来从你的列表中提取姓名和电话号码，并将它们再次打印出来，如下所示：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Last name and comma**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 姓氏和逗号**'
- en: '***2* First name**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 名字**'
- en: '***3* Optional middle name**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 可选的中间名**'
- en: '***4* Colon and phone number**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 冒号和电话号码**'
- en: 'There are some points of interest here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的地方：
- en: You can find out whether a match succeeded by checking the value returned by
    `search`. If the value is `None`, the match failed; otherwise, the match succeeded,
    and you can extract information from the object returned by `search`.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过检查`search`返回的值来找出匹配是否成功。如果值是`None`，则匹配失败；否则，匹配成功，你可以从`search`返回的对象中提取信息。
- en: '`group` is used to extract whatever data matched your named subpatterns. You
    pass in the name of the subpattern you’re interested in.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group`用于提取与你的命名子模式匹配的任何数据。你传入你感兴趣的子模式的名称。'
- en: Because the middle subpattern is optional, you can’t count on it to have a value,
    even if the match as a whole is successful. If the match succeeds, but the match
    for the middle name doesn’t, using `group` to access the data associated with
    the middle subpattern returns the value `None`.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为中间子模式是可选的，所以即使整个匹配成功，你也无法依赖它有一个值。如果匹配成功，但中间名的匹配失败，使用`group`访问与中间子模式关联的数据将返回`None`。
- en: Part of the phone number is optional, but part isn’t. If the match succeeds,
    the phone subpattern must have some associated text, so you don’t have to worry
    about it having a value of `None`.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码的一部分是可选的，但另一部分不是。如果匹配成功，电话子模式必须有一些相关的文本，所以你不必担心它有`None`的值。
- en: '|  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Extracting matched text'
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：提取匹配的文本
- en: Making international calls usually requires a + and the country code. Assuming
    that the country code is two digits, how would you modify the code above to extract
    the + and the country code as part of the number? (Again, not all numbers have
    a country code.) How would you make the code handle country codes of one to three
    digits?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 打国际电话通常需要一个加号和国家的代码。假设国家代码是两位数字，你将如何修改上面的代码来提取加号和国家代码作为号码的一部分？（再次强调，并非所有号码都有国家代码。）你将如何使代码处理一位到三位数字的国家代码？
- en: '|  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 16.5\. Substituting text with regular expressions
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.5\. 使用正则表达式替换文本
- en: 'In addition to extracting strings from text, you can use Python’s regex module
    to find strings in text and substitute other strings in place of those that were
    found. You accomplish this task by using the regular substitution method `sub`.
    The following example replaces instances of `"the the"` (presumably, a typo) with
    single instances of `"the"`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从文本中提取字符串外，你还可以使用Python的正则表达式模块在文本中查找字符串，并用其他字符串替换找到的字符串。你通过使用正则替换方法`sub`来完成此任务。以下示例将`"the
    the"`（可能是打字错误）替换为单个实例的`"the"`：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `sub` method uses the invoking regex (`regexp`, in this case) to scan its
    second argument (`string`, in the example) and produces a new string by replacing
    all matching substrings with the value of the first argument (`"the"`, in this
    example).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub`方法使用调用的正则表达式（在这个例子中是`regexp`）扫描其第二个参数（在这个例子中是`string`），并通过用第一个参数（在这个例子中是`"the"`）替换所有匹配的子字符串来产生一个新的字符串。'
- en: But what if you want to replace the matched substrings with new ones that reflect
    the value of those that matched? This is where the elegance of Python comes into
    play. The first argument to `sub`—the replacement substring, `"the"` in the example—doesn’t
    have to be a string at all. Instead, it can be a function. If it’s a function,
    Python calls it with the current match object; then it lets that function compute
    and return a replacement string.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想要用新的子串替换匹配的子串，这些新的子串反映了匹配的值，该怎么办？这正是Python优雅之处所在。`sub`函数的第一个参数——替换子串，在示例中为`"the"`——根本不必是字符串。相反，它可以是函数。如果是一个函数，Python会使用当前匹配对象调用它；然后它让该函数计算并返回一个替换字符串。
- en: 'To see this function in action, build an example that takes a string containing
    integer values (no decimal point or decimal part) and returns a string with the
    same numerical values but as floating numbers (with a trailing decimal point and
    zero):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此函数的实际效果，请构建一个示例，该示例接受一个包含整数值的字符串（没有小数点或小数部分），并返回一个具有相同数值但作为浮点数的字符串（带有尾随的小数点和零）：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, the pattern looks for a number consisting of one or more digits
    (the `[0-9]+` part). But it’s also given a name (the `?P<num>...` part) so that
    the replacement string function can extract any matched substring by referring
    to that name. Then the `sub` method scans down the argument string `"1 2 3 4 5"`,
    looking for anything that matches `[0-9]+`. When `sub` finds a substring that
    matches, it makes a match object defining exactly which substring matched the
    pattern, and it calls the `int_match_to_float` function with that match object
    as the sole argument. `int_match_to_float` uses `group` to extract the matching
    substring from the match object (by referring to the group name `num`) and produces
    a new string by concatenating the matched substring with a `".0"`. `sub` returns
    the new string and incorporates it as a substring into the overall result. Finally,
    `sub` starts scanning again right after the place where it found the last matching
    substring, and it keeps going like that until it can’t find any more matching
    substrings.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，模式查找由一个或多个数字组成的数字（`[0-9]+`部分）。但它还给出了一个名称（`?P<num>...`部分），这样替换字符串函数就可以通过引用该名称提取任何匹配的子串。然后`sub`方法扫描参数字符串`"1
    2 3 4 5"`，寻找任何匹配`[0-9]+`的内容。当`sub`找到一个匹配的子串时，它创建一个匹配对象，精确地定义了哪个子串与模式匹配，并使用该匹配对象作为唯一参数调用`int_match_to_float`函数。`int_match_to_float`使用`group`从匹配对象中提取匹配的子串（通过引用组名`num`）并通过连接匹配的子串和`".0"`生成一个新的字符串。`sub`返回新的字符串并将其作为子串合并到整体结果中。最后，`sub`从找到最后一个匹配子串的地方重新开始扫描，并继续这样做，直到找不到更多的匹配子串。
- en: '|  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Replacing text'
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这样做：替换文本
- en: In the checkpoint in [section 16.4](#ch16lev1sec4), you extended a phone-number
    regular expression to also recognize a country code. How would you use a function
    to make any numbers that didn’t have a country code now have +1 (the country code
    for the United States and Canada)?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第16.4节](#ch16lev1sec4)的检查点中，你扩展了电话号码正则表达式，使其也能识别国家代码。你将如何使用函数使现在没有国家代码的任何数字都带有+1（美国和加拿大的国家代码）？
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 16: Phone-Number normalizer'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室16：电话号码标准化器
- en: In the United States and Canada, phone numbers consist of ten digits, usually
    separated into a three-digit area code, a three-digit exchange code, and a four-digit
    station code. As mentioned in [section 16.4](#ch16lev1sec4), they may or may not
    be preceded by +1, the country code. In practice, however, you have many ways
    to format a phone number, such as (NNN) NNN-NNNN, NNN-NNN-NNNN, NNN NNN-NNNN,
    NNN.NNN.NNNN, and NNN NNN NNNN, to name a few. Also, the country code may not
    be present, may not have a +, and usually (not always) is separated from the number
    by a space or dash. Whew!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国和加拿大，电话号码由十个数字组成，通常分为三位区号、三位交换码和四位站点码。如[第16.4节](#ch16lev1sec4)所述，它们可能或可能不带有+1国家代码。然而，在实践中，你有许多种格式化电话号码的方法，例如（NNN）
    NNN-NNNN、NNN-NNN-NNNN、NNN NNN-NNNN、NNN.NNN.NNNN和NNN NNN NNNN，仅举几例。此外，国家代码可能不存在，可能没有加号，通常（但不总是）与号码之间由空格或破折号分隔。哇！
- en: In this lab, your task is to create a phone-number normalizer that takes any
    of the formats and returns a normalized phone number 1-NNN-NNN-NNNN.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，你的任务是创建一个电话号码标准化器，它接受任何格式并返回一个格式化的电话号码 1-NNN-NNN-NNNN。
- en: 'The following are all possible phone numbers:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下都是可能的电话号码：
- en: '| +1 223-456-7890 | 1-223-456-7890 | +1 223 456-7890 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| +1 223-456-7890 | 1-223-456-7890 | +1 223 456-7890 |'
- en: '| (223) 456-7890 | 1 223 456 7890 | 223.456.7890 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| (223) 456-7890 | 1 223 456 7890 | 223.456.7890 |'
- en: '*Bonus:* The first digit of the area code and the exchange code can only be
    2-9, and the second digit of an area code can’t be 9. Use this information to
    validate the input and return a `ValueError` exception of `invalid phone number`
    if the number is invalid.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*附加说明:* 区号和交换码的第一个数字只能是 2-9，区号的第二个数字不能是 9。使用这些信息来验证输入，如果号码无效，则返回一个 `ValueError`
    异常，异常信息为 `invalid phone number`。'
- en: '|  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: For a complete list and explanation of the regex special characters, refer to
    the Python documentation.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于正则表达式特殊字符的完整列表和解释，请参阅 Python 文档。
- en: In addition to the `search` and `sub` methods, many other methods can be used
    to split strings, extract more information from `match` objects, look for the
    positions of substrings in the main argument string, and precisely control the
    iteration of a regex search over an argument string.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了 `search` 和 `sub` 方法之外，还可以使用许多其他方法来分割字符串，从 `match` 对象中提取更多信息，在主参数字符串中查找子字符串的位置，以及精确控制正则表达式搜索在参数字符串上的迭代。
- en: Besides the `\d` special sequence, which can be used to indicate a digit character,
    many other special sequences are listed in the documentation.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了可以用来表示数字字符的 `\d` 特殊序列之外，文档中还列出了许多其他特殊序列。
- en: There are also regex flags, which you can use to control some of the more esoteric
    aspects of how extremely sophisticated matches are carried out.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有正则表达式标志，您可以使用它们来控制执行极其复杂的匹配操作的一些更神秘方面。
