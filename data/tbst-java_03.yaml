- en: 2 Understanding your app’s logic through debugging techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 通过调试技术理解你的应用程序逻辑
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: When to use a debugger and when to avoid it
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用调试器以及何时避免使用
- en: Using a debugger to investigate code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调试器调查代码
- en: Not long ago, during one of my piano lessons, I shared the sheet music of a
    song I wanted to learn with my piano teacher. I was so impressed when he just
    played the song while reading the music sheet for the first time. “How cool is
    that?” I thought. “How does someone gain this skill?”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不久前，在一次我的钢琴课上，我将我想学习的歌曲乐谱分享给了我的钢琴老师。当他第一次阅读乐谱时就演奏了这首歌，我感到非常震撼。“这太酷了！”我想。“一个人是如何获得这种技能的？”
- en: Then, I remembered some years ago I was in a peer-programming session with one
    of the newly hired juniors in the company I was working for. It was my turn at
    the keyboard, and we were investigating a relatively large and complex piece of
    code using a debugger. I started navigating through the code, pressing relatively
    quickly the keyboard keys that allowed me to step over, into, and out of specific
    lines of code. I was focused on the code but was quite calm and relaxed, almost
    forgetting I had someone near me (rude of me). I heard this person say, “Wow,
    stop a bit. You’re too fast. Can you even read that code?”
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我想起了几年前我在我工作的公司的一个同伴编程会议中与一位新聘的初级程序员一起。轮到我坐在键盘前，我们正在使用调试器调查一段相对较大且复杂的代码。我开始在代码中导航，相对快速地按键盘上的键，使我能够跳过、进入和退出特定的代码行。我专注于代码，但相当平静和放松，几乎忘记了我旁边有人（我太粗鲁了）。我听到这个人说：“哇，慢一点。你太快了。你能读懂那代码吗？”
- en: 'I realized that situation was similar to my experience with my piano teacher.
    How can you gain this skill? The answer is easier than you thought: work hard
    and gain experience. While practicing is invaluable and takes a lot of time, I
    have some tips to share with you that will help you to improve your technique
    much faster. In this chapter, we discuss one of the most important tools used
    in understanding code: the debugger.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到这种情况与我的钢琴老师经验相似。你如何获得这种技能？答案是比你想象的简单：努力工作和积累经验。虽然练习是宝贵的，并且需要花费大量时间，但我有一些可以帮助你更快提高技术的建议。在本章中，我们讨论了在理解代码时使用的重要工具之一：调试器。
- en: DEFINITION A debugger is a tool that allows you to pause the execution on specific
    lines and manually execute each instruction while observing how the data changes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 调试器是一种工具，它允许你在特定的行上暂停执行，并手动执行每条指令，同时观察数据如何变化。
- en: '![](../../OEBPS/Images/icon_girl2.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_girl2.png)'
- en: 'Using a debugger is like navigating with Google Maps: it helps you find your
    way through complex logic implemented in your code. It’s also the most used tool
    for understanding code.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器就像使用谷歌地图导航：它帮助你找到你代码中实现的复杂逻辑的路径。它也是理解代码时最常用的工具。
- en: A debugger is usually the first tool a developer learns to use to help them
    understand what code does. Fortunately, all IDEs come with a debugger, so you
    don’t have to do anything special to have one. In this book, I use IntelliJ IDEA
    Community in my examples, but any other IDE is quite similar and offers (sometimes
    with a different look) the same options we’ll discuss. Although a debugger seems
    to be a tool most developers know how to use, you may find, in this chapter and
    in chapter 3, some new techniques for using one.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器通常是开发者学习的第一个工具，以帮助他们理解代码的功能。幸运的是，所有IDE都自带调试器，因此你不需要做任何特别的事情就可以拥有它。在这本书中，我使用IntelliJ
    IDEA Community作为我的示例，但任何其他IDE都相当相似，并且提供了（有时外观不同）我们将讨论的相同选项。尽管调试器似乎是一个大多数开发者都知道如何使用的工具，但你可能会在本章和第3章中找到一些使用调试器的新技巧。
- en: We’ll start in section 2.1 by discussing how developers read code and why, in
    many cases, simply reading the code isn’t enough to understand it. Enter the debugger
    or a profiler (which we discuss later, in chapters 6–9). In section 2.2, we continue
    the discussion by applying the simplest techniques for using a debugger with an
    example.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在2.1节中开始讨论开发者如何阅读代码以及为什么在许多情况下，仅仅阅读代码并不足以理解它。进入调试器或分析器（我们将在第6章至第9章中讨论）。在2.2节中，我们将通过一个示例继续讨论使用调试器的最简单技术。
- en: '![](../../OEBPS/Images/CH02_UN02_Spilca3.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_UN02_Spilca3.png)'
- en: 2.1 When analyzing code is not enough
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 当分析代码不足以理解时
- en: Let’s start by discussing how to read code and why sometimes reading just the
    logic isn’t enough to understand it. In this section, I’ll explain how reading
    code works and how it is different from reading something else, like a story or
    a poem. To observe this difference and understand what causes the complexity in
    deciphering code, we’ll use a code snippet that implements a short piece of logic.
    Understanding what’s behind the way our brain interprets code helps you to realize
    the need for tools such as a debugger.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论如何阅读代码以及为什么仅仅阅读逻辑有时不足以理解它。在本节中，我将解释阅读代码的工作原理以及它与阅读其他事物（如故事或诗歌）的不同之处。为了观察这种差异并理解解码代码复杂性的原因，我们将使用一个实现简短逻辑片段的代码片段。了解我们的大脑如何解释代码背后的内容有助于你意识到需要像调试器这样的工具。
- en: Any code investigation scene starts with reading the code. But reading code
    is different from reading poetry. When reading a verse, you move through text
    line by line in a given linear order, letting your brain assemble and picture
    the meaning. If you read the same verse twice, you might understand different
    things.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 任何代码调查场景都是从阅读代码开始的。但是阅读代码与阅读诗歌不同。当你阅读一首诗时，你会按照给定的线性顺序逐行阅读文本，让你的大脑组装并想象其含义。如果你两次阅读同一首诗，你可能会理解不同的事情。
- en: With code, however, it’s the opposite. First, code is not linear. When reading
    code, you don’t simply go line by line. Instead, you jump in and out of instructions
    to understand how they affect the data being processed. Reading code is more like
    a maze than a straight road. And, if you’re not attentive, you might get lost
    and forget where you started. Second, unlike a poem, the code always and for everyone
    means the same thing. That meaning is the objective of your investigation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于代码来说，情况正好相反。首先，代码不是线性的。当你阅读代码时，你不会简单地逐行阅读。相反，你会跳进跳出指令，以理解它们如何影响正在处理的数据。阅读代码更像是一个迷宫，而不是一条直线。而且，如果你不专心，你可能会迷路并忘记你从哪里开始。其次，与诗歌不同，代码对每个人来说总是意味着相同的事情。这个含义是你的调查目标。
- en: Just like you’d use a compass to find your path, a debugger helps you more easily
    identify what your code does. As an example, we’ll use the `decode(List<Integer>
    input)` method. You can find this code in project da-ch2-ex1 provided with the
    book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你会用指南针找到你的路一样，调试器可以帮助你更容易地识别你的代码做了什么。例如，我们将使用 `decode(List<Integer> input)`
    方法。你可以在书中提供的项目 da-ch2-ex1 中找到这段代码。
- en: Listing 2.1 An example of a method to debug
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 调试方法的示例
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you read from the top line to the bottom line, you have to assume how some
    things work to understand it. Are those instructions really doing what you think
    they’re doing? When you are not sure, you have to dive deeper and observe what
    the code actually does—you have to analyze the logic behind it. Figure 2.1 points
    out two of the uncertainties in the given code snippet:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从顶部行读到底部行，你必须假设一些事情的工作方式来理解它。这些指令真的在执行你认为它们正在做的事情吗？当你不确定时，你必须深入挖掘并观察代码实际上做了什么——你必须分析其背后的逻辑。图2.1指出了给定代码片段中的两个不确定性：
- en: What does the `StringDigitExtractor()` constructor do? It might just create
    an object, or it might also do something else. It could be that it somehow changes
    the value of the given parameter.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringDigitExtractor()` 构造函数做什么？它可能只是创建一个对象，或者也可能做其他事情。它可能会以某种方式改变给定参数的值。'
- en: What is the result of calling the `extractDigits()` method? Does it return a
    list of digits? Does it also change the parameter inside the object we used when
    creating the `StringDigitsExtractor` constructor?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `extractDigits()` 方法的结果是什么？它返回一个数字列表吗？它也改变了我们在创建 `StringDigitsExtractor`
    构造函数时使用的对象内部的参数吗？
- en: '![](../../OEBPS/Images/CH02_F01_Spilca3.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1](../../OEBPS/Images/CH02_F01_Spilca3.png)'
- en: Figure 2.1 When reading a piece of code, you often need to figure out what happens
    behind the scenes in some of the instructions composing that logic. The method
    names are not always suggestive enough, and you can’t totally rely on them. Instead,
    you need to go deeper into what these methods do.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 当阅读一段代码时，你通常需要弄清楚组成该逻辑的一些指令背后发生了什么。方法名并不总是足够有暗示性，而且你不能完全依赖它们。相反，你需要深入了解这些方法做了什么。
- en: Even with a small piece of code, you may have to dive deeper into the instructions.
    Each new code instruction you examine creates a new investigation plan and adds
    to its cognitive complexity (figures 2.2 and 2.3). The deeper you go into the
    logic and the more plans you open, the more complex the process becomes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是小块代码，您可能也需要深入了解指令。您检查的每个新代码指令都会创建一个新的调查计划，并增加其认知复杂性（见图2.2和2.3）。您越深入逻辑，打开的计划越多，过程就越复杂。
- en: '![](../../OEBPS/Images/CH02_F02_Spilca3.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F02_Spilca3.png)'
- en: Figure 2.2  Compare how you read poetry with how you read code. You read poetry
    line by line, but when you read code, you jump around.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 比较您阅读诗歌的方式与您阅读代码的方式。您逐行阅读诗歌，但阅读代码时却四处跳跃。
- en: '![](../../OEBPS/Images/CH02_F03_Spilca3.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F03_Spilca3.png)'
- en: Figure 2.3 Reading code is different from reading poetry and is much more complex.
    You can imagine reading code as reading in two dimensions. One dimension is reading
    a piece of code top to bottom. The second dimension is going into a specific instruction
    to understand it in detail. Trying to remember how things work for each plan and
    how it assembles makes understanding code just by reading it very difficult.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 阅读代码与阅读诗歌不同，并且要复杂得多。您可以想象阅读代码就像在两个维度上阅读。一个维度是从上到下阅读一段代码。第二个维度是进入一个特定的指令以详细了解它。
- en: Reading poetry always has one path. Code analysis instead creates many paths
    through the same piece of logic. The fewer new plans you open, the less complex
    the process is. You must choose between skipping over a certain instruction, making
    the overall investigation process simpler, or going into detail to better understand
    each individual instruction and raise the process complexity.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读诗歌通常只有一条路径。代码分析则会在同一逻辑片段中创建许多路径。您打开的新计划越少，过程就越简单。您必须在跳过某些指令、使整体调查过程更简单或深入了解以更好地理解每个单独的指令并提高过程复杂性之间做出选择。
- en: TIP Always try to shorten the reading path by minimizing the number of plans
    you open for investigation. Use a debugger to help you more easily navigate the
    code, keep track of where you are, and observe how the app changes the data while
    executing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 总是尝试通过最小化您为调查而打开的计划数量来缩短阅读路径。使用调试器可以帮助您更轻松地导航代码，跟踪您的位置，并观察应用程序在执行过程中如何更改数据。
- en: '![](../../OEBPS/Images/icon_guy.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图标](../../OEBPS/Images/icon_guy.png)'
- en: 2.2 Investigating code with a debugger
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 使用调试器调查代码
- en: In this section, we discuss a tool that can help you to minimize the cognitive
    effort of reading code to understand how it works—a debugger. All IDEs provide
    a debugger, and even if the interface might look slightly different from one IDE
    to another, the options are generally the same. I’ll use IntelliJ IDEA Community
    in this book, but I encourage you to use your favorite IDE and compare it with
    the examples in the book. You’ll find they are pretty similar.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论一个可以帮助您最小化阅读代码时的认知努力，以理解其工作原理的工具——调试器。所有集成开发环境（IDE）都提供调试器，尽管不同IDE的界面可能略有不同，但选项通常是相同的。本书中，我将使用IntelliJ
    IDEA Community，但我鼓励您使用您最喜欢的IDE，并将其与书中的示例进行比较。您会发现它们非常相似。
- en: A debugger simplifies the investigation process by
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器通过以下方式简化调查过程：
- en: Providing you with a means to pause the execution at a particular step and execute
    each instruction manually at your own pace
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种在特定步骤暂停执行并按自己的节奏手动执行每个指令的方法。
- en: Showing you where you are and where you came from in the code’s reading path;
    this way, the debugger works as a map you can use, rather than trying to remember
    all the details
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码的阅读路径中显示您所在的位置和您从哪里来；这样，调试器就像一张您可以使用的地图，而不是试图记住所有细节。
- en: Showing you the values that variables hold, making the investigation easier
    to visualize and to process
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示变量所持有的值，使调查更容易可视化并处理。
- en: Allowing you to try things on the fly by using watchers and evaluating expressions
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许您通过使用监视器和评估表达式来即时尝试事物。
- en: Let’s take the example in project da-ch2-ex1 again and use the most straightforward
    debugger capabilities to understand the code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次以项目da-ch2-ex1中的示例为例，并使用最直接的调试器功能来理解代码。
- en: Listing 2.2 A piece of code we want to understand
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 我们想要理解的代码片段
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I’m sure you’re wondering, “How do I know when to use a debugger?” This is a
    fair question I want to answer before going any further. The main prerequisite
    is *knowing what piece of logic you want to investigate*. As you’ll learn in this
    section, the first step in using a debugger is selecting an instruction where
    you want the execution to pause.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢肯定你正在想，“我什么时候知道该使用调试器？”这是一个合理的问题，我想要在进一步讨论之前回答。主要前提是*知道你想要调查哪部分逻辑*。正如你将在本节中学到的，使用调试器的第一步是选择一个你想让执行暂停的指令。
- en: NOTE Unless you already know which instruction you need to start your investigation
    from, you can’t use a debugger.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：除非你已经知道你需要从哪个指令开始你的调查，否则你不能使用调试器。
- en: '![](../../OEBPS/Images/icon_girl2.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_girl2.png)'
- en: In the real world, you’ll find cases in which you don’t know up front the specific
    piece of logic you want to investigate. In this case, before you can use a debugger,
    you need to apply different techniques to find the part of the code you want to
    investigate using the debugger (which we’ll address in later chapters). In this
    chapter and chapter 3, we’ll focus only on using the debugger, so we’ll assume
    you somehow found the piece of code you want to understand.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，你会遇到你事先不知道想要调查的具体逻辑片段的情况。在这种情况下，在你能够使用调试器之前，你需要应用不同的技术来找到你想要使用调试器调查的代码部分（我们将在后面的章节中讨论）。在本章和第三章中，我们将只关注使用调试器，所以我们将假设你以某种方式找到了你想要理解的那段代码。
- en: Going back to our example, where do we start? First, we need to read the code
    and figure out what we do and don’t understand. Once we identify where the logic
    becomes unclear, we can execute the app and “tell” the debugger to pause the execution.
    We can pause the execution on those lines of code that are not clear to observe
    how they change the data. To “tell” the debugger where to pause the app’s execution,
    we use *breakpoints*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，我们应该从哪里开始？首先，我们需要阅读代码，弄清楚我们理解和不理解的部分。一旦我们确定了逻辑变得不清晰的地方，我们就可以执行应用程序，并“告诉”调试器暂停执行。我们可以在那些不清楚的代码行上暂停执行，以观察它们如何改变数据。为了“告诉”调试器在哪里暂停应用程序的执行，我们使用*断点*。
- en: DEFINITION A breakpoint is a marker we use on lines where we want the debugger
    to pause the execution so that we can investigate the implemented logic. The debugger
    will pause the execution before executing the line marked with the breakpoint.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：断点是我们用来标记的行，我们希望调试器在这里暂停执行，以便我们可以调查实现的逻辑。调试器将在执行带有断点的行之前暂停执行。
- en: '![](../../OEBPS/Images/icon_girl2.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_girl2.png)'
- en: In figure 2.4, I shaded the code that is pretty easy to understand (considering
    you know the language fundamentals). As you can see, this code takes a list as
    an input, parses the list, processes each item in it, and somehow calculates an
    integer that the method returns in the end. Moreover, the process the method implements
    is easy to ascertain without a debugger.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在图2.4中，我标记了那些相对容易理解的代码（考虑到你掌握了语言基础）。正如你所见，这段代码接受一个列表作为输入，解析列表，处理列表中的每个项目，并最终以某种方式计算出一个整数，这是方法返回的。此外，方法实现的过程在没有调试器的情况下也容易确定。
- en: '![](../../OEBPS/Images/CH02_F04_Spilca3.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F04_Spilca3.png)'
- en: Figure 2.4 Assuming you know the language fundamentals, you can easily see that
    this code takes a collection as an input and parses the collection to calculate
    an integer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 假设你掌握了语言基础，你很容易就能看出这段代码接受一个集合作为输入，并解析这个集合来计算一个整数。
- en: In figure 2.5, I shaded the lines that usually cause difficulties in understanding
    what the method does. These lines of code are more challenging to decipher because
    they hide their own implemented logic. You may recognize `digits.stream().collect
    (Collectors.summingInt(i` `->` `i))` as it’s been part of the Stream API provided
    with the JDK since Java 8\. But we can’t say the same thing about `new` `StringDigitExtractor(s).extractDigits()`.
    Because this is part of the app we are investigating, this instruction might do
    anything.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在图2.5中，我标记了通常在理解方法做什么时造成困难的那几行。这些代码行更难以解析，因为它们隐藏了自己的实现逻辑。你可能认识`digits.stream().collect
    (Collectors.summingInt(i -> i))`，因为它是从Java 8开始随JDK提供的Stream API的一部分。但关于`new StringDigitExtractor(s).extractDigits()`，我们无法说同样的话。因为这是我们要调查的应用程序的一部分，这条指令可能做任何事情。
- en: '![](../../OEBPS/Images/CH02_F05_Spilca3.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F05_Spilca3.png)'
- en: Figure 2.5 In this piece of code, I shaded the lines of code that are more difficult
    to understand. When you use a debugger, add the first breakpoint on the first
    line that makes the code more challenging to understand.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 在这段代码中，我阴影了更难以理解的代码行。当你使用调试器时，在使代码更具挑战性的第一行设置第一个断点。
- en: The way a developer chooses to write the code may also add additional complexity.
    For example, starting with Java 10, developers can infer the type of a local variable
    using `var`. Inferring the variable type is not always a wise choice because it
    can make the code even more difficult to read (figure 2.5), bringing one more
    scenario in which using the debugger would be useful.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者选择编写代码的方式也可能增加额外的复杂性。例如，从Java 10开始，开发者可以使用`var`来推断局部变量的类型。推断变量类型并不总是明智的选择，因为它可能会使代码更难以阅读（图2.5），从而增加一个使用调试器会很有用的场景。
- en: TIP When investigating code with a debugger, start from the first line of code
    that you can’t figure out.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在用调试器调查代码时，从你无法理解的代码的第一行开始。
- en: '![](../../OEBPS/Images/icon_guy.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_guy.png)'
- en: While training junior developers and students over the past many years, I have
    observed that in many cases they start debugging on the first line of a specific
    code block. While you certainly can do this, it’s more efficient if you first
    read the code without the debugger and try to figure out whether you can understand
    the code. Then, start debugging directly from the point that causes difficulties.
    This approach will save you time since you may find out you don’t need the debugger
    to understand what happens in a specific piece of logic. After all, even if you
    use the debugger, you only need to go over the code you don’t understand.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去许多年里，我在培训初级开发人员和学生的过程中观察到，在许多情况下，他们会在特定代码块的第一行开始调试。虽然你当然可以这样做，但如果你首先在不使用调试器的情况下阅读代码，并尝试弄清楚你是否能理解代码，则会更有效率。然后，直接从引起困难的地方开始调试。这种方法将为你节省时间，因为你可能会发现你不需要调试器就能理解特定逻辑中的发生情况。毕竟，即使你使用调试器，你也只需要查看你不理解的代码。
- en: 'In some scenarios, you add a breakpoint on a line because its intent is not
    obvious. Sometimes your app throws an exception; you see that in the logs, but
    you don’t know which previous line is causing the problem. In this case, you can
    add a breakpoint to pause the app’s execution just before it throws the exception.
    But the idea stays the same: avoid pausing the execution of the instructions you
    understand. Instead, use breakpoints for the lines of code you want to focus on.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你会在某一行添加断点，因为其意图并不明显。有时你的应用程序会抛出异常；你在日志中看到这一点，但不知道哪一行之前的代码导致了问题。在这种情况下，你可以在应用程序抛出异常之前添加一个断点来暂停应用程序的执行。但理念保持不变：避免暂停你理解的指令的执行。相反，使用断点来关注你想要关注的代码行。
- en: 'For this example, we will start by adding a breakpoint on line 11, presented
    in figure 2.6:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将从在图2.6中显示的第11行添加断点开始：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Generally, to add a breakpoint on a line in any IDE, you click on or near the
    line number (or even better, use a keyboard shortcut; for IntelliJ, you can use
    Ctrl-F8 for Windows/Linux, or Command-F8 for macOS). The breakpoint will be displayed
    with a circle, as presented in figure 2.6\. Make sure you run your application
    with the debugger. In IntelliJ, look for a button represented as a small bug icon
    near the one you use to start the app. You can also right-click the main class
    file and use the Debug button in the context menu. When the execution reaches
    the line you marked with a breakpoint, it pauses, allowing you to navigate further
    manually.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，要在任何IDE中的某一行添加断点，你可以在行号上或附近点击（或者更好的是，使用键盘快捷键；对于IntelliJ，你可以在Windows/Linux上使用Ctrl-F8，或者在macOS上使用Command-F8）。断点将以圆圈的形式显示，如图2.6所示。确保你使用调试器运行你的应用程序。在IntelliJ中，寻找一个表示为小虫子图标按钮，它靠近你用来启动应用程序的按钮。你也可以右键单击主类文件，并在上下文菜单中使用调试按钮。当执行到达你标记的断点所在的行时，它会暂停，允许你手动导航。
- en: '![](../../OEBPS/Images/CH02_F06_Spilca3.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F06_Spilca3.png)'
- en: Figure 2.6 Click near the line number to add a breakpoint on a specific line.
    Then, run the app with the debugger. The execution pauses on the line you marked
    with a breakpoint and allows you to control it manually.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 在行号附近点击以在特定行添加断点。然后，使用调试器运行应用程序。执行将在你标记的断点所在的行暂停，并允许你手动控制。
- en: Since the shortcuts can change and differ depending on the operating system
    you use (some developers even prefer to customize them), I’m not usually going
    to discuss them. However, I advise you to check your IDE’s manual and learn to
    use the keyboard shortcuts.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于快捷键可能会根据您使用的操作系统而改变和不同（一些开发者甚至更喜欢自定义它们），我通常不会讨论它们。然而，我建议您检查您的IDE手册，并学习如何使用键盘快捷键。
- en: Note Remember, you always need to execute the app using the Debug option to
    have an active debugger. If you use the Run option, the breakpoints won’t be considered
    since the IDE doesn’t attach the debugger to the running process. Some IDEs may
    run your app by default as well as attach the debugger, but if that’s not the
    case (like for IntelliJ or Eclipse), then the app execution won’t pause at the
    breakpoints you define.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 记住，您始终需要使用调试选项来执行应用程序，以便拥有一个活动的调试器。如果您使用运行选项，由于IDE没有将调试器附加到运行进程，断点将不会被考虑。某些IDE可能会默认运行您的应用程序并附加调试器，但如果不是这种情况（例如IntelliJ或Eclipse），则应用程序的执行将不会在您定义的断点上暂停。
- en: 'When the debugger pauses the code execution on a specific instruction from
    the line you mark with a breakpoint, you can use the valuable information the
    IDE displays. In figure 2.7, you can see that my IDE displays two essential pieces
    of information:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试器在您标记为断点的行上的特定指令处暂停代码执行时，您可以使用IDE显示的宝贵信息。在图2.7中，您可以看到我的IDE显示了两个基本的信息：
- en: '*The value of all the variables in scope*—Knowing all the variables in scope
    and their values helps you understand what data is being processed and how the
    logic affects the data. Remember that the execution is paused before the execution
    of the line marked with a breakpoint, so the data state remains the same.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*作用域内所有变量的值*——了解所有变量的值及其值有助于您理解正在处理哪些数据以及逻辑如何影响数据。记住，执行是在带有断点的行的执行之前暂停的，因此数据状态保持不变。'
- en: '*The execution stack trace*—This shows you how the app executes the line of
    code where the debugger paused the execution. Each line in the stack trace is
    a method involved in the calling chain. The execution stack trace helps you to
    visualize the execution path, without needing to remember how you got to a specific
    instruction when using the debugger to navigate through code.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*执行堆栈跟踪*——这显示了应用程序如何执行调试器暂停执行的那行代码。堆栈跟踪中的每一行都是调用链中涉及的方法。执行堆栈跟踪有助于您可视化执行路径，而无需记住在使用调试器通过代码导航时如何到达特定的指令。'
- en: TIP You can add as many breakpoints as you want, but it is best to use a limited
    number at a time and to focus only on those lines of code. I usually use no more
    than three breakpoints at the same time. I often see developers add too many breakpoints,
    forget them, and get lost in the investigated code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 您可以添加尽可能多的断点，但最好一次只使用有限数量的断点，并专注于那些代码行。我通常一次不会使用超过三个断点。我经常看到开发者添加过多的断点，忘记它们，并在调查的代码中迷失方向。
- en: '![](../../OEBPS/Images/icon_guy.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_guy.png)'
- en: Generally, observing the values of the variables in scope is easily understandable.
    But, depending on your experience, you may or may not be aware of what the execution
    stack trace is. Section 2.2.1 addresses the execution stack trace and why this
    tool is essential. We’ll then discuss how to navigate the code using essential
    operations such as step over, step into, and step out. You can skip section 2.2.1
    and go directly to 2.2.2 if you are already familiar with the execution stack
    trace.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，观察作用域内变量的值是容易理解的。但，根据您的经验，您可能或可能不知道执行堆栈跟踪是什么。第2.2.1节讨论了执行堆栈跟踪以及为什么这个工具是必不可少的。然后我们将讨论如何使用如步过、步入和步出等基本操作来导航代码。如果您已经熟悉执行堆栈跟踪，可以直接跳过2.2.1节，直接进入2.2.2节。
- en: '![](../../OEBPS/Images/CH02_F07_Spilca3.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F07_Spilca3.png)'
- en: Figure 2.7 When the execution is paused on a given line of code, you can see
    all the variables in scope and their values. You can also use the execution stack
    trace to remember where you are as you navigate through the lines of code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 当执行在给定的代码行上暂停时，您可以看到所有作用域内的变量及其值。您还可以使用执行堆栈跟踪来在通过代码行导航时记住您所在的位置。
- en: 2.2.1 What is the execution stack trace, and how do I use it?
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 执行堆栈跟踪是什么，我如何使用它？
- en: The execution stack trace is a valuable tool you use to understand the code
    while debugging it. Just like a map, the execution stack trace shows you the execution’s
    path to the specific line of code where the debugger paused it and helps you to
    decide where to navigate further.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 执行堆栈跟踪是在调试代码时使用的宝贵工具。就像一张地图一样，执行堆栈跟踪显示了执行路径到调试器暂停的具体代码行，并帮助你决定进一步导航的位置。
- en: '![](../../OEBPS/Images/CH02_F08_Spilca3.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH02_F08_Spilca3.png)'
- en: Figure 2.8 The top layer of the execution stack trace is where the debugger
    paused the execution. All other layers in the execution stack trace are where
    the methods represented by the above layers were called. The bottom layer of the
    stack trace (the first layer) is where the execution of the current thread began.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 执行堆栈跟踪的最顶层是调试器暂停执行的地方。执行堆栈跟踪中的所有其他层都是上述层所代表的方法被调用的地方。堆栈跟踪的底层（第一层）是当前线程执行开始的地方。
- en: Figure 2.8 provides a comparison of the execution stack trace and the execution
    in a tree format. The stack trace shows how methods called one another up to the
    point where the debugger paused the execution. In the stack trace, you can find
    the method names, the class names, and the lines that caused the calls.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8提供了执行堆栈跟踪和树形格式下执行的比较。堆栈跟踪显示了方法是如何相互调用，直到调试器暂停执行的地方。在堆栈跟踪中，你可以找到方法名、类名和导致调用的行。
- en: One of my favorite uses of the execution stack trace is finding hidden logic
    in the execution path. In most cases, developers use the execution stack trace
    simply to understand where a certain method has been called from. But you also
    need to consider that apps that use frameworks (such as Spring, Hibernate, etc.)
    sometimes alter the execution chain of the method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的执行堆栈跟踪的使用之一是找到执行路径中的隐藏逻辑。在大多数情况下，开发者使用执行堆栈跟踪仅仅是为了理解某个方法是从哪里被调用的。但你也需要考虑，使用框架（如Spring、Hibernate等）的应用有时会改变方法的执行链。
- en: For example, Spring apps often use code that is decoupled in what is called
    *aspects* (in Java/Jakarta EE terminology, they are named *interceptors*). These
    aspects implement logic that the framework uses to augment the execution of specific
    methods in certain conditions. Unfortunately, such logic is often difficult to
    observe since you can’t see the aspect code directly in the call chain when reading
    the code (figure 2.9). This characteristic makes it challenging to investigate
    a given capability.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Spring应用通常使用被称为*方面*（在Java/Jakarta EE术语中，它们被称为*拦截器*）的解耦代码。这些方面实现了框架在特定条件下增强特定方法执行的逻辑。不幸的是，这种逻辑通常很难观察，因为在阅读代码时你无法直接在调用链中看到方面代码（图2.9）。这种特性使得调查给定的功能变得具有挑战性。
- en: '![](../../OEBPS/Images/CH02_F09_Spilca3.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH02_F09_Spilca3.png)'
- en: Figure 2.9 An aspect logic is completely decoupled from the code. For this reason,
    when reading the code, it is difficult to see that there’s more logic that will
    execute. Such cases of hidden logic executing can be confusing when investigating
    a certain capability.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 一个方面逻辑完全与代码解耦。因此，在阅读代码时，很难看到还有更多将要执行的逻辑。在调查某个功能时，这种隐藏逻辑执行的情况可能会令人困惑。
- en: Let’s take a code example to examine this behavior and how the execution stack
    trace is helpful in such cases. You can find this example in project da-ch2-ex2
    provided with the book (appendix B provides a refresher for opening the project
    and starting the app). The project is a small Spring app that prints the value
    of the parameter in the console.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个代码示例来检查这种行为以及执行堆栈跟踪在这种情况下是如何有帮助的。你可以在书中提供的项目da-ch2-ex2中找到这个示例（附录B提供了打开项目和启动应用的重温内容）。该项目是一个小型Spring应用，它在控制台打印参数的值。
- en: Listings 2.3, 2.4, and 2.5 show the implementation of these three classes. As
    presented in listing 2.3, the `main()` method calls `ProductController`’s `saveProduct()`
    method, sending the parameter value `"Beer"`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3、2.4和2.5展示了这三个类的实现。正如列表2.3所示，`main()`方法调用`ProductController`的`saveProduct()`方法，发送参数值`"Beer"`。
- en: Listing 2.3 The main class calls the `ProductController`’s `saveProduct()` method
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 主类调用`ProductController`的`saveProduct()`方法
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ We call the saveProduct() method with the parameter value “Beer”.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们使用参数值“啤酒”调用saveProduct()方法。
- en: In listing 2.4, you can see that `ProductController`’s `saveProduct()` method
    simply calls the `ProductService`’s `saveProduct()` method with the received parameter
    value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表2.4中，你可以看到 `ProductController` 的 `saveProduct()` 方法只是用接收到的参数值调用 `ProductService`
    的 `saveProduct()` 方法。
- en: Listing 2.4 `ProductController` calling `ProductService`
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 `ProductController` 调用 `ProductService`
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ ProductController calls the service and sends the parameter value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ ProductController 调用服务并发送参数值。
- en: Listing 2.5 shows the `ProductService`’s `saveProduct()` method that prints
    the parameter value in the console.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5显示了 `ProductService` 的 `saveProduct()` 方法，它在控制台打印参数值。
- en: Listing 2.5 `ProductService` printing the value of the parameter
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 `ProductService` 打印参数值
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Prints the parameter value in the console
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在控制台打印参数值
- en: 'As presented in figure 2.10, the flow is quite simple:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如图2.10所示，流程相当简单：
- en: The `main()` method calls the `saveProduct()` method of a bean named `ProductController`,
    sending the value `"Beer"` as a parameter.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main()` 方法调用名为 `ProductController` 的实例的 `saveProduct()` 方法，将值 `"Beer"` 作为参数发送。'
- en: Then, the `ProductController`’s `saveProduct()` method calls the `saveProduct()`
    method of another bean, `ProductService`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`ProductController` 的 `saveProduct()` 方法调用另一个实例 `ProductService` 的 `saveProduct()`
    方法。
- en: The `ProductService` bean prints the value of the parameter in the console.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProductService` 实例在控制台打印参数值。'
- en: '![](../../OEBPS/Images/CH02_F10_Spilca3.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F10_Spilca3.png)'
- en: Figure 2.10 Method `main()` calls `saveProduct()` of bean `ProductController`,
    sending the value `"Beer"` as the parameter value. The `ProductController`’s `saveProduct()`
    method calls the `ProductService` bean, sending the same parameter value as the
    one it receives. The `Product-Service` bean prints the parameter value in the
    console. The expectation is that `"Beer"` will be printed in the console.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 方法 `main()` 调用 `ProductController` 的 `saveProduct()` 方法，将值 `"Beer"` 作为参数值发送。`ProductController`
    的 `saveProduct()` 方法调用 `ProductService` 实例，发送与接收到的相同的参数值。`Product-Service` 实例在控制台打印参数值。预期的是在控制台打印
    `"Beer"`。
- en: 'Naturally, you would assume the following message is printed when you run the
    app:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，你会假设当你运行应用程序时，会打印出以下消息：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, when you run the project, the message is different:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你运行项目时，消息是不同的：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How is that possible? To answer this question, the first thing to do is use
    the execution stack trace to find out who changed the parameter value. Add a breakpoint
    on the line that prints a different value than you expect, run the app with the
    debugger, and observe the execution stack trace (figure 2.11). Instead of having
    the `ProductService`’s `saveProduct()` method from the `ProductController` bean,
    you find that an aspect alters the execution. If you review the aspect class,
    you will, indeed, see that the aspect is responsible for replacing `"Beer"` with
    `"Chocolate"` (listing 2.6).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这怎么可能呢？为了回答这个问题，首先要做的是使用执行堆栈跟踪来找出谁改变了参数值。在打印出不同值的行上设置断点，以调试模式运行应用程序，并观察执行堆栈跟踪（图2.11）。你发现，不是
    `ProductController` 实例的 `ProductService` 的 `saveProduct()` 方法，而是有一个方面改变了执行。如果你查看方面类，你确实会看到方面负责将
    `"Beer"` 替换为 `"Chocolate"`（列表2.6）。
- en: '![](../../OEBPS/Images/CH02_F11_Spilca3.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F11_Spilca3.png)'
- en: Figure 2.11 The execution stack trace shows that an aspect has altered the execution.
    This aspect is the reason that the value of the parameter changes. Without using
    the stack trace, finding why the app has a different behavior than expected would
    be more difficult.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 执行堆栈跟踪显示方面已改变执行。这个方面是参数值改变的原因。如果不使用堆栈跟踪，找出应用程序为何与预期行为不同将会更困难。
- en: The following code shows the aspect that alters the execution by replacing the
    value `ProductController` sends to `ProductService`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了通过替换 `ProductController` 发送到 `ProductService` 的值来改变执行的方面。
- en: Listing 2.6 The aspect logic that alters the execution
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6 改变执行的方面逻辑
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Aspects are quite a fascinating and useful feature in Java application frameworks
    today. But if you don’t use them properly, they can make apps difficult to understand
    and maintain. Of course, in this book, we are discussing relevant techniques that
    can help you to identify and understand code even in such cases. But, trust me,
    if you need to use this technique for an application, it means the application
    is not easily maintainable. A clean-coded app (without technical debt) is always
    a better choice than an app in which you must invest effort to debug later. If
    you’re interested in better understanding how aspects work in Spring, I recommend
    you read chapter 6 of another book I wrote, *Spring Start Here* (Manning, 2021).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的Java应用程序框架中，方面（Aspects）是一个非常吸引人和有用的特性。但是，如果你没有正确使用它们，它们可能会使应用程序难以理解和维护。当然，在这本书中，我们正在讨论相关的技术，这些技术可以帮助你在这种情况下识别和理解代码。但是，相信我，如果你需要为应用程序使用这项技术，这意味着该应用程序不易维护。一个编写良好的应用程序（没有技术债务）总是比一个需要投入精力进行调试的应用程序更好。如果你对更好地理解Spring中方面的工作原理感兴趣，我建议你阅读我写的另一本书的第六章，*Spring
    Start Here*（Manning，2021）。
- en: 2.2.2 Navigating code with the debugger
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 使用调试器导航代码
- en: 'In this section, we discuss the basic ways you navigate code with a debugger.
    You’ll learn how to use three fundamental navigation operations:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论使用调试器导航代码的基本方法。你将学习如何使用三个基本导航操作：
- en: '*Step over*—Continue the execution with the next line of code in the same method.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*跳过*—继续执行同一方法中的下一行代码。'
- en: '*Step into*—Continue the execution inside one of the methods called on the
    current line.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*进入*—继续在当前行调用的方法中执行。'
- en: '*Step out*—Return the execution to the method that called the one you are investigating.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*退出*—将执行返回到调用你正在调查的方法的方法。'
- en: To start the investigation process, you must identify the first line of code
    where you want the debugger to pause the execution. To understand the logic, you
    need to navigate through the lines of code and observe how the data changes when
    different instructions execute.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始调查过程，你必须确定你想要调试器暂停执行的第一行代码。为了理解逻辑，你需要导航代码行并观察当不同的指令执行时数据如何变化。
- en: There are buttons on the GUI and keyboard shortcuts to use the navigation operations
    in any IDE. Figure 2.12 shows you how these buttons appear in the IntelliJ IDEA
    Community GUI, the IDE I use.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何IDE的GUI上都有按钮和键盘快捷键，可以用来执行导航操作。图2.12展示了这些按钮在IntelliJ IDEA Community GUI中的外观，这是我使用的IDE。
- en: '![](../../OEBPS/Images/CH02_F12_Spilca3.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F12_Spilca3.png)'
- en: Figure 2.12 The navigation operations help you “walk” through the app logic
    in a controlled way to identify how the code works. To navigate through code,
    you can use the buttons on the IDE’s GUI or use the keyboard shortcuts associated
    with these operations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 导航操作帮助你以受控的方式“遍历”应用程序逻辑，以确定代码的工作方式。要导航代码，你可以使用IDE的GUI上的按钮或使用与这些操作关联的键盘快捷键。
- en: TIP Even if at the beginning you find it easier to use the buttons on the IDE’s
    GUI, I recommend you use the keyboard shortcuts instead. If you get comfortable
    using the keyboard shortcuts, you’ll see they are much faster than a mouse.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 即使在开始时你发现使用IDE的GUI上的按钮更容易，我仍然建议你使用键盘快捷键。如果你习惯了使用键盘快捷键，你会发现它们比鼠标快得多。
- en: '![](../../OEBPS/Images/icon_guy.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_guy.png)'
- en: Figure 2.13 visually describes the navigation operations. You can use the step
    over operation to go to the next line in the same method. Generally, this is the
    most commonly used navigation operation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13直观地描述了导航操作。你可以使用跳过操作进入同一方法中的下一行。通常，这是最常用的导航操作。
- en: '![](../../OEBPS/Images/CH02_F13_Spilca3.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F13_Spilca3.png)'
- en: Figure 2.13 Navigation operations. Stepping over allows you to go to the next
    instruction in the same method. When you want to start a new investigation plan
    and go into detail in a specific instruction, you can use the step into operation.
    You can go back to the previous investigation plan with the step out operation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 导航操作。跳过操作允许你进入同一方法中的下一条指令。当你想要开始一个新的调查计划并深入了解特定指令时，你可以使用进入操作。你可以使用退出操作返回到上一个调查计划。
- en: Sometimes you need to better understand what happens with a particular instruction.
    In our example, you may need to enter the `extractDigits()` method to clearly
    understand what it does. For such a case, you use the step into operation. When
    you want to return to the `decode()` method, you can use step out.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要更好地理解特定指令发生了什么。在我们的例子中，你可能需要进入`extractDigits()`方法，以便清楚地了解它做什么。在这种情况下，你使用“进入”操作。当你想返回到`decode()`方法时，你可以使用“退出”操作。
- en: You can also visualize the operations on the execution stack trace, as presented
    in figure 2.14.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以可视化执行堆栈跟踪中的操作，如图2.14所示。
- en: '![](../../OEBPS/Images/CH02_F14_Spilca3.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F14_Spilca3.png)'
- en: Figure 2.14 The navigation operation as seen from the execution stack trace
    point of view. When you step out, you go down in the stack trace and close an
    investigation plan. When you step into, you open a new investigation plan, so
    you go up in the stack trace and it becomes bigger. When stepping over, you remain
    in the same investigation plan. If the method ends (returns or throws an exception),
    stepping over closes the investigation plan, and you go down in the stack trace
    just as you did when you stepped out.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 从执行堆栈跟踪的角度看导航操作。当你退出时，你向下进入堆栈跟踪并关闭一个调查计划。当你进入时，你打开一个新的调查计划，因此你在堆栈跟踪中向上移动，它变得更大。当你单步执行时，你保持在同一个调查计划中。如果方法结束（返回或抛出异常），单步执行将关闭调查计划，你就像退出时一样向下进入堆栈跟踪。
- en: Ideally, you start with using the step over operation as much as possible when
    trying to understand how a piece of code works. The more you step into, the more
    investigation plans you open, and thus the more complex the investigation process
    becomes (figure 2.15). In many cases, you can deduce what a specific line of code
    does only by stepping over it and observing the output.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，当你试图理解一段代码的工作原理时，尽可能多地使用“单步执行”操作。你进入得越多，你打开的调查计划就越多，因此调查过程就越复杂（图2.15）。在许多情况下，你只需通过单步执行并观察输出，就可以推断出特定代码行的作用。
- en: '![](../../OEBPS/Images/CH02_F15_Spilca3.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F15_Spilca3.png)'
- en: Figure 2.15 The movie Inception (2010) portrays the idea of dreaming in a dream.
    The more layers deep you dream, the longer you stay there. You can compare this
    idea with stepping into a method and opening a new investigation layer. The deeper
    you step in, the more time you’ll spend investigating the code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 电影《盗梦空间》（2010）描绘了在梦中做梦的想法。你梦得越深，你待在那里的时间就越长。你可以将这个想法与进入一个方法和打开一个新的调查层进行比较。你进入得越深，你花在调查代码上的时间就越多。
- en: Figure 2.16 shows you the result of using the step over navigation operation.
    The execution pauses on line 12, one line below where we initially paused the
    debugger with the breakpoint. The `digits` variable is now initialized as well,
    so you can see its value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 展示了使用“单步执行”导航操作的结果。执行在12行暂停，比我们最初使用断点暂停调试器的那一行低一行。`digits`变量现在也被初始化了，所以你可以看到它的值。
- en: '![](../../OEBPS/Images/CH02_F16_Spilca3.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F16_Spilca3.png)'
- en: Figure 2.16 When you step over a line, the execution continues in the same method.
    In our case, the execution paused on line 12, and you can see the value of the
    `digits` variable that was initialized by line 11\. You can use this value to
    deduce what line 11 does without having to go into more detail.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 当你单步执行一行时，执行将在同一方法中继续。在我们的例子中，执行在第12行暂停，你可以看到由第11行初始化的`digits`变量的值。你可以使用这个值来推断第11行做了什么，而无需深入了解。
- en: Try continuing the execution multiple times. You’ll observe that, on line 11,
    for each string input, the result is a list that contains all the digits in the
    given string. Often, the logic is easy enough to understand simply by analyzing
    the outputs for a few executions. But what if you can’t figure out what a line
    does just by executing it?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次继续执行。你会观察到，在第11行，对于每个字符串输入，结果是一个包含给定字符串中所有数字的列表。通常，逻辑足够简单，只需分析几次执行的输出就可以理解。但如果你不能仅通过执行就弄清楚一行代码的作用怎么办？
- en: '![](../../OEBPS/Images/CH02_F17_Spilca3.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F17_Spilca3.png)'
- en: Figure 2.17 Stepping into allows you to observe the entire execution of the
    current instruction. This opens a new investigation plan, allowing you to parse
    the logic behind that particular instruction. You can use the execution stack
    trace to retrace the execution flow.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 使用“进入”功能可以观察当前指令的整个执行过程。这开启了一个新的调查计划，允许你解析特定指令背后的逻辑。你可以使用执行堆栈跟踪来回溯执行流程。
- en: 'If you don’t understand what happens, you need to go into more detail on that
    line. This should be your last option since it requires that you open a new investigation
    plan, which complicates your process. But, when you have no other choice, you
    can step into an instruction to get more details on what the code does. Figure
    2.17 shows you the result of stepping into line 11 of the `Decoder` class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不理解发生了什么，您需要在该行上更详细地了解情况。这应该是您的最后选择，因为它要求您打开一个新的调查计划，这会使您的过程复杂化。但是，当您没有其他选择时，您可以进入指令以获取代码执行更多细节。图2.17显示了进入`Decoder`类第11行的结果：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you stepped into an instruction, take the time to first read what’s behind
    that code line. In many cases, looking at the code is enough to spot what happens,
    and then you can go back to where you were before stepping into. I often observe
    students rushing into debugging the method they stepped into without first taking
    a breath and reading that piece of code. Why is it important to read the code
    first? Because stepping into a method opens another investigation plan, so, if
    you want to be efficient, you have to redo the investigation steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您进入了指令，请先花时间阅读那行代码背后的内容。在许多情况下，查看代码就足以发现发生了什么，然后您可以回到之前进入的地方。我经常观察到学生急于调试他们进入的方法，而没有先深吸一口气阅读那段代码。为什么先阅读代码很重要？因为进入一个方法会打开另一个调查计划，所以，如果您想高效，您必须重新执行调查步骤：
- en: Read the method and find the first line of code you don’t understand.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读方法并找到您不理解的第一行代码。
- en: Add a breakpoint on that line of code, and start the investigation from there.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该代码行上设置一个断点，并从那里开始调查。
- en: '![](../../OEBPS/Images/CH02_F18_Spilca3.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F18_Spilca3.png](../../OEBPS/Images/CH02_F18_Spilca3.png)'
- en: Figure 2.18 The step out operation allows you to close an investigation plan
    and return to the previous one in the execution stack trace. Using step out is
    helpful to save time since you don’t have to step over each instruction until
    the current execution plan closes by itself. Stepping out offers you a shortcut
    to return to the previous execution plan you were investigating.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 步出操作允许您关闭一个调查计划并返回到执行堆栈跟踪中的上一个计划。使用步出操作可以节省时间，因为您不必逐条指令执行，直到当前执行计划自行关闭。步出操作为您提供了一条返回到之前调查的执行计划的捷径。
- en: 'Often, if you stop and read the code, you’ll find that you don’t need to continue
    that investigation plan. If you already understand what happens, you simply need
    to return to where you were previously. And you can do this using the step out
    operation. Figure 2.18 shows you what happens when using step out from the `extractDigits()`
    method: the execution returns to the previous investigation plan in the `decode(List
    <String>` `input)` method.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果您停下来阅读代码，您会发现您不需要继续那个调查计划。如果您已经理解了发生了什么，您只需简单地返回到之前的位置。您可以使用步出操作来完成这一点。图2.18显示了从`extractDigits()`方法使用步出操作时发生的情况：执行返回到`decode(List
    <String> input)`方法中的上一个调查计划。
- en: TIP The step out operation can save you time. When entering a new investigation
    plan (by stepping into a code line), first read the new piece of code. Step out
    of the new investigation plan once you understand what the code does.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：步出操作可以为您节省时间。在进入新的调查计划（通过进入代码行）时，首先阅读新的代码片段。一旦您理解了代码的功能，就退出新的调查计划。
- en: '![](../../OEBPS/Images/icon_guy.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![人物图标](../../OEBPS/Images/icon_guy.png)'
- en: Why is the next execution line not always the next line?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么下一执行行不总是下一行？
- en: When discussing code navigation with a debugger, I often talk about the “next
    execution line.” I want to make sure I’m clear about the difference between the
    “next line” and the “next execution line.”
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当与调试器讨论代码导航时，我经常提到“下一执行行”。我想确保我清楚“下一行”和“下一执行行”之间的区别。
- en: The next execution line is the line of code the app executes next. When we say
    the debugger paused the execution on line 12, the *next line* is always line 13,
    but the *next execution line* can be different. For example, if line 12 doesn’t
    throw an exception, as shown in the following figure, the next execution line
    will be 13, but if line 12 throws an exception, the next execution line is line
    18\. You find this example in project da-ch2-ex3.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一执行行是应用程序将要执行的代码行。当我们说调试器在第12行暂停执行时，*下一行*总是第13行，但*下一执行行*可能不同。例如，如果第12行没有抛出异常，如以下图所示，下一执行行将是第13行，但如果第12行抛出异常，下一执行行将是第18行。您可以在项目da-ch2-ex3中找到这个例子。
- en: When using the step over operation, the execution will continue to the *next
    execution line*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用单步执行操作时，执行将继续到*下一执行行*。
- en: '![](../../OEBPS/Images/CH02_UN10_Spilca3.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH02_UN10_Spilca3.png)'
- en: In this figure, we step over from line 12, and line 12 throws an exception;
    the execution continues on line 18, which is the next execution line. In other
    words, the next execution line is not always the next line.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们从第12行开始单步执行，第12行抛出异常；执行继续到第18行，这是下一执行行。换句话说，下一执行行不总是下一行。
- en: 2.3 When using the debugger might not be enough
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 当使用调试器可能不够时
- en: The debugger is an excellent tool that can help you to analyze code by navigating
    through the code to understand how it works with data. But not all code can be
    investigated with a debugger. In this section, we discuss some scenarios in which
    using a debugger is not possible or not enough. You need to be aware of these
    cases so that you don’t waste time using a debugger.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器是一个优秀的工具，可以帮助你通过在代码中导航来分析代码，理解它是如何与数据一起工作的。但并非所有代码都可以用调试器来调查。在本节中，我们讨论了一些使用调试器不可行或不充分的场景。你需要意识到这些情况，以免浪费时间使用调试器。
- en: 'Here are some of the most often encountered investigation scenarios when using
    a debugger (or only a debugger) is usually not the right approach:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用调试器（或仅使用调试器）通常不是正确方法时，以下是一些最常遇到的调查场景：
- en: Investigating output problems when you don’t know which part of the code creates
    the output
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你不知道代码的哪个部分创建了输出时，调查输出问题
- en: Investigating performance problems
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查性能问题
- en: Investigating crashes where the entire app fails
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查整个应用失败时的崩溃
- en: Investigating multithreaded implementations
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查多线程实现
- en: TIP Remember that a critical prerequisite for using a debugger is knowing where
    to pause the execution.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：记住，使用调试器的关键先决条件是知道在哪里暂停执行。
- en: '![](../../OEBPS/Images/icon_girl2.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/icon_girl2.png)'
- en: Before you start debugging, you need to find the part of the code that is generating
    the wrong output. Depending on the app, it may be easier to find where something
    happens in the implemented logic. If the app has a clean class design, it is relatively
    easy to find the part of the app responsible for the output. If the app lacks
    a class design, it may be more challenging to discover where things happen and
    thus where to use the debugger. In the upcoming chapters, you’ll learn several
    other techniques. Some of these techniques, such as profiling the app or using
    stubs, will help you to identify where to start the investigation with a debugger.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始调试之前，你需要找到生成错误输出的代码部分。根据应用的不同，可能更容易找到实现逻辑中发生某事的位置。如果应用有一个清晰的类设计，找到负责输出的应用部分相对容易。如果应用缺乏类设计，可能更难发现事情发生的地方，因此也就更难确定在哪里使用调试器。在接下来的章节中，你将学习到其他几种技术。其中一些技术，如分析应用或使用存根，将帮助你确定使用调试器开始调查的位置。
- en: '*Performance problems* are a particular set of issues you usually can’t investigate
    with a debugger. Slow applications or those that stick completely are frequent
    performance issues. In most cases, profiling and logging techniques (that we’ll
    discuss in chapters 5–9) will help you to troubleshoot such scenarios. For the
    particular instances in which the app blocks entirely, getting and analyzing a
    thread dump is usually the most straightforward investigation path. We’ll discuss
    analyzing thread dumps in chapter 10.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*性能问题*是一组通常无法用调试器调查的问题。慢速应用或完全卡住的应用是常见的性能问题。在大多数情况下，性能分析和对数技术（我们将在第5章到第9章中讨论）将帮助你解决此类场景。对于应用完全阻塞的特定实例，获取和分析线程转储通常是调查的最直接路径。我们将在第10章中讨论分析线程转储。'
- en: If the app encountered an issue and the execution stopped (the app crashed),
    you cannot use a debugger on the code. A debugger allows you to observe the app
    in execution. If the application no longer executes, a debugger clearly won’t
    help. Depending on what happened, you might need to audit logs, as we’ll discuss
    in chapter 5, or investigate thread or heap dumps, which you’ll learn about in
    chapters 10 and 11.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用遇到了问题并且执行停止（应用崩溃），你无法在代码上使用调试器。调试器允许你在执行过程中观察应用。如果应用不再执行，调试器显然无济于事。根据发生的情况，你可能需要审计日志，正如我们在第5章中将要讨论的，或者调查线程或堆转储，这些将在第10章和第11章中学习。
- en: 'Most developers find *multithreaded implementations* the most challenging to
    investigate. Such implementations can be easily influenced by your interference
    with tools such as a debugger. This interference creates a Heisenberg effect (discussed
    in chapter 1): the app behaves differently when you use the debugger than when
    you don’t interfere with it. As you’ll learn, you can sometimes isolate the investigation
    to one thread and use the debugger. But in most cases, you’ll have to apply a
    set of techniques that include debugging, mocking and stubbing, and profiling
    to understand the app’s behavior in the most complex scenarios.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者发现**多线程实现**是最具挑战性的调查对象。这样的实现很容易受到你使用调试器等工具的干扰。这种干扰会产生海森堡效应（在第1章中讨论）：当你使用调试器时，应用程序的行为与你不干扰它时不同。正如你将学到的，有时你可以将调查隔离到一条线程并使用调试器。但在大多数情况下，你将不得不应用一系列技术，包括调试、模拟和存根以及性能分析，以了解应用程序在最复杂场景中的行为。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Every time you open a new piece of logic (e.g., entering a new method that defines
    its own logic), you open a new investigation plan.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次你打开一个新的逻辑块（例如，进入一个定义其自身逻辑的新方法），你就打开了一个新的调查计划。
- en: Unlike a text paragraph, reading code is not linear. Each instruction might
    create a new plan you need to investigate. The more complex the logic you explore,
    the more plans you need to open. The more plans you open, the more complex the
    process becomes. One trick to speeding up a code investigation process is to open
    as few plans as possible.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与文本段落不同，阅读代码不是线性的。每条指令可能会创建一个你需要调查的新计划。你探索的逻辑越复杂，你需要打开的计划就越多。你打开的计划越多，过程就越复杂。加快代码调查过程的一个技巧是尽可能少地打开计划。
- en: A debugger is a tool that allows you to pause the app’s execution on a specific
    line so that you can observe the app’s execution, step by step, and the way it
    manages data. Using a debugger can help you to reduce some of the cognitive load
    of reading code.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试器是一个工具，它允许你在特定行暂停应用程序的执行，这样你就可以逐步观察应用程序的执行以及它管理数据的方式。使用调试器可以帮助你减少阅读代码时的认知负荷。
- en: You can use breakpoints to mark the specific lines of code where you want the
    debugger to pause an app's execution so you can evaluate the values of all the
    variables in the scope.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用断点标记你想要调试器暂停应用程序执行的特定代码行，以便你可以评估作用域内所有变量的值。
- en: You can step over a line, which means continuing to the next execution line
    in the same plan, or step into a line, which means going into detail on the instruction
    on which the debugger paused the execution. You should minimize the number of
    times you step into a line and rely more on stepping over. Every time you step
    into a line, the investigation path gets longer and the process more time consuming.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以跨过一行，这意味着继续执行同一计划中的下一行，或者进入一行，这意味着深入到调试器暂停执行的指令的细节。你应该尽量减少进入一行的次数，更多地依赖跨过。每次进入一行，调查路径都会变长，过程也会更加耗时。
- en: Even though using the mouse and the IDE’s GUI to navigate through the code is
    initially more comfortable, learning to use the keyboard shortcuts for these operations
    will help you debug faster. I recommend you learn the keyboard shortcuts of your
    favorite IDE and use them instead of triggering the navigation with the mouse.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管使用鼠标和IDE的GUI导航代码在最初可能更舒适，但学习使用这些操作的键盘快捷键将帮助你更快地调试。我建议你学习你最喜欢的IDE的键盘快捷键，并使用它们而不是用鼠标触发导航。
- en: After stepping into a line, first read the code and try to understand it. If
    you can figure out what happens, use the step out operation to return to the previous
    investigation plan. If you don’t understand what happens, identify the first unclear
    instruction, add a breakpoint, and start debugging from there.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入一行后，首先阅读代码并尝试理解它。如果你能弄清楚发生了什么，使用退出操作返回到之前的调查计划。如果你不理解发生了什么，确定第一条不清楚的指令，添加一个断点，并从那里开始调试。
