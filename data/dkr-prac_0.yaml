- en: Part 1\. Docker fundamentals
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1部分\. Docker基础知识
- en: '[Part 1](#part01) of this book consists of [chapters 1](kindle_split_010.xhtml#ch01)
    and [2](kindle_split_011.xhtml#ch02), which get you started using Docker and cover
    its fundamentals.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书[第1部分](#part01)由[第1章](kindle_split_010.xhtml#ch01)和[第2章](kindle_split_011.xhtml#ch02)组成，这些章节将帮助您开始使用Docker并涵盖其基础知识。
- en: '[Chapter 1](kindle_split_010.xhtml#ch01) explains the origin of Docker along
    with its core concepts, such as images, containers, and layering. Finally, you’ll
    get your hands dirty by creating your first image with a Dockerfile.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](kindle_split_010.xhtml#ch01)解释了Docker的起源及其核心概念，如镜像、容器和分层。最后，您将通过创建第一个Dockerfile来亲自动手。'
- en: '[Chapter 2](kindle_split_011.xhtml#ch02) introduces some useful techniques
    to give you a deeper understanding of Docker’s architecture. Taking each major
    component in turn, we’ll cover the relationship between the Docker daemon and
    its client, the Docker registry, and the Docker Hub.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](kindle_split_011.xhtml#ch02)介绍了一些有用的技术，以帮助您更深入地理解Docker的架构。依次介绍每个主要组件，我们将涵盖Docker守护进程与其客户端、Docker注册表和Docker
    Hub之间的关系。'
- en: By the end of [part 1](#part01) you’ll be comfortable with core Docker concepts
    and will be able to demonstrate some useful techniques, laying a firm foundation
    for the remainder of the book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到第1部分结束（[部分1](#part01)）时，您将熟悉核心Docker概念，并能够展示一些有用的技术，为本书的其余部分打下坚实的基础。
- en: 'Chapter 2\. Understanding Docker: Inside the engine room'
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2章\. 理解Docker：引擎室内部
- en: '|  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Docker’s architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker的架构
- en: Tracing the internals of Docker on your host
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪您主机上Docker的内部结构
- en: Using the Docker Hub to find and download images
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Hub查找和下载镜像
- en: Setting up your own Docker registry
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置您自己的Docker注册表
- en: Getting containers to communicate with each other
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器之间进行通信
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Grasping Docker’s architecture is key to understanding Docker more fully. In
    this chapter you’ll get an overview of Docker’s major components on your machine
    and on the network, and you’ll learn some techniques that will develop this understanding.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握Docker的架构是全面理解Docker的关键。在本章中，您将了解您机器和网络上的Docker主要组件的概述，并学习一些将有助于发展这种理解的技术。
- en: In the process, you’ll learn some nifty tricks that will help you use Docker
    (and Linux) more effectively. Many of the later and more advanced techniques in
    this book will be based on what you see here, so pay special attention to what
    follows.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，您将学习一些实用的技巧，这些技巧将帮助您更有效地使用Docker（和Linux）。本书中更晚和更高级的技术大多基于您在这里看到的内容，因此请特别注意以下内容。
- en: 2.1\. Docker’s architecture
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. Docker的架构
- en: '[Figure 2.1](#ch02fig01) lays out Docker’s architecture, and that will be the
    centerpiece of this chapter. We’re going to start with a high-level look and then
    focus on each part, with techniques designed to cement your understanding.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.1](#ch02fig01)展示了Docker的架构，这将是本章的核心。我们将从高层次的角度开始，然后专注于每个部分，使用旨在巩固您理解的技术。'
- en: Figure 2.1\. Overview of Docker’s architecture
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1\. Docker架构概述
- en: '![](Images/02fig01_alt.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig01_alt.jpg)'
- en: Docker on your host machine is (at the time of writing) split into two parts—a
    daemon with a RESTful API and a client that talks to the daemon. [Figure 2.1](#ch02fig01)
    shows your host machine running the Docker client and daemon.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，您的主机上的Docker分为两部分——一个带有RESTful API的守护进程和一个与守护进程通信的客户端。[图2.1](#ch02fig01)显示了运行Docker客户端和守护进程的主机。
- en: '|  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: A RESTful API uses standard HTTP request types such as `GET`, `POST`, `DELETE`,
    and others to represent resources and operations on them. In this case images,
    containers, volumes, and the like are the represented resources.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API使用标准的HTTP请求类型，如`GET`、`POST`、`DELETE`等，来表示资源和它们上的操作。在这种情况下，镜像、容器、卷等是表示的资源。
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You invoke the Docker client to get information from or give instructions to
    the daemon; the daemon is a server that receives requests and returns responses
    from the client using the HTTP protocol. In turn, it will make requests to other
    services to send and receive images, also using the HTTP protocol. The server
    will accept requests from the command-line client or anyone else authorized to
    connect. The daemon is also responsible for taking care of your images and containers
    behind the scenes, whereas the client acts as the intermediary between you and
    the RESTful API.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用 Docker 客户端来获取守护进程的信息或向其下达指令；守护进程是一个服务器，它通过 HTTP 协议接收来自客户端的请求并返回响应。反过来，它将向其他服务发出请求以发送和接收镜像，同样使用
    HTTP 协议。服务器将接受来自命令行客户端或任何被授权连接的人的请求。守护进程还负责在幕后处理您的镜像和容器，而客户端则作为您和 RESTful API
    之间的中介。
- en: The private Docker registry is a service that stores Docker images. These can
    be requested from any Docker daemon that has the relevant access. This registry
    is on an internal network and isn’t publicly accessible, so it’s considered private.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 私有 Docker 仓库是一个存储 Docker 镜像的服务。这些镜像可以从任何具有相关访问权限的 Docker 守护进程请求。此仓库位于内部网络中，不可公开访问，因此被认为是私有的。
- en: Your host machine will typically sit on a private network. The Docker daemon
    will call out to the internet to retrieve images if requested.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您的主机通常会位于一个私有网络中。如果需要，Docker 守护进程会调用互联网以检索镜像。
- en: The Docker Hub is a public registry run by Docker Inc. Other public registries
    can also exist on the internet, and your Docker daemon can interact with them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 是由 Docker Inc. 运营的公共仓库。互联网上还可以存在其他公共仓库，您的 Docker 守护进程可以与它们交互。
- en: In the first chapter we said that Docker containers can be shipped to anywhere
    you can run Docker—this isn’t strictly true. In fact, containers will run on the
    machine only if the *daemon* can be installed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中我们提到 Docker 容器可以被运送到任何可以运行 Docker 的地方——这并不完全正确。实际上，只有当 *守护进程* 可以安装时，容器才会在该机器上运行。
- en: The key point to take from [figure 2.1](#ch02fig01) is that when you run Docker
    on your machine, you may be interacting with other processes on your machine,
    or even services running on your network or the internet.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [图 2.1](#ch02fig01) 中可以得出的关键点是，当您在机器上运行 Docker 时，您可能正在与机器上的其他进程交互，甚至可能与网络或互联网上运行的服务交互。
- en: Now that you have a picture of how Docker is laid out, we’ll introduce various
    techniques relating to the different parts of the figure.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了 Docker 的布局，我们将介绍与图中不同部分相关的各种技术。
- en: 2.2\. The Docker daemon
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. Docker 守护进程
- en: The Docker daemon (see [figure 2.2](#ch02fig02)) is the hub of your interactions
    with Docker, and as such it’s the best place to start gaining an understanding
    of all the relevant pieces. It controls access to Docker on your machine, manages
    the state of your containers and images, and brokers interactions with the outside
    world.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程（见 [图 2.2](#ch02fig02)）是您与 Docker 交互的中心，因此它是开始了解所有相关部分的最佳起点。它控制您机器上
    Docker 的访问权限，管理容器和镜像的状态，并协调与外部世界的交互。
- en: Figure 2.2\. The Docker daemon
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.2\. Docker 守护进程
- en: '![](Images/02fig02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig02.jpg)'
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: A *daemon* is a process that runs in the background rather than under the direct
    control of the user. A *server* is a process that takes requests from a client
    and performs the actions required to fulfill the requests. Daemons are frequently
    also servers that accept requests from clients to perform actions for them. The
    `docker` command is a client, and the Docker daemon acts as the server doing the
    processing on your Docker containers and images.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*守护进程* 是一个在后台运行而不是直接受用户控制的进程。*服务器* 是一个接收来自客户端的请求并执行满足这些请求所需操作的进程。守护进程通常也是服务器，它们接受来自客户端的请求以执行这些操作。`docker`
    命令是一个客户端，而 Docker 守护进程则充当服务器，负责处理您的 Docker 容器和镜像。'
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s look at a couple of techniques that illustrate how Docker effectively
    runs as a daemon, and how your interactions with it using the `docker` command
    are limited to simple requests to perform actions, much like interactions with
    a web server. The first technique allows others to connect to your Docker daemon
    and perform the same actions you might on your host machine, and the second illustrates
    that Docker containers are managed by the daemon, not your shell session.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些技术，这些技术展示了Docker如何作为一个守护进程有效运行，以及你使用`docker`命令与之交互时，仅限于执行简单请求以执行操作，这与与Web服务器的交互非常相似。第一种技术允许其他人连接到你的Docker守护进程并执行你可能在主机机器上执行的操作，第二种技术说明了Docker容器是由守护进程管理的，而不是由你的shell会话管理。
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Open your Docker daemon to the world**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**将你的Docker守护进程向世界开放**'
- en: Although by default your Docker daemon is accessible only on your host, there
    can be good reason to allow others to access it. You might have a problem that
    you want someone to debug remotely, or you may want to allow another part of your
    DevOps workflow to kick off a process on a host machine.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管默认情况下你的Docker守护进程只能在你的主机上访问，但允许其他人访问它可能有很好的理由。你可能有一个需要远程调试的问题，或者你可能希望允许你的DevOps工作流程的另一个部分在主机机器上启动一个进程。
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Although this can be a powerful and useful technique, it’s considered insecure.
    A Docker socket can be exploited by anyone with access (including containers with
    a mounted Docker socket) to get root privileges.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能是一种强大且有用的技术，但它被认为是不安全的。任何有权访问的人（包括挂载了Docker套接字的容器）都可以利用Docker套接字获得root权限。
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**PROBLEM**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to open your Docker server up for others to access.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望向其他人开放你的Docker服务器。
- en: '**SOLUTION**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Start the Docker daemon with an open TCP address.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以开放的TCP地址启动Docker守护进程。
- en: '[Figure 2.3](#ch02fig03) gives an overview of how this technique works.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.3](#ch02fig03)概述了此技术的工作原理。'
- en: 'Figure 2.3\. Docker accessibility: normal and opened up'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3\. Docker可访问性：正常和开放
- en: '![](Images/02fig03_alt.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig03_alt.jpg)'
- en: 'Before you open up the Docker daemon, you must first shut the running one down.
    How you do this will vary depending on your operating system (non-Linux users
    should see [appendix A](kindle_split_030.xhtml#app01)). If you’re not sure how
    to do this, start with this command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开放Docker守护进程之前，你必须首先关闭正在运行的守护进程。你如何做到这一点将取决于你的操作系统（非Linux用户应参阅[附录A](kindle_split_030.xhtml#app01)）。如果你不确定如何操作，请从以下命令开始：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you get a message that looks like this,
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到如下消息，
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'then you have a systemctl-based startup system. Try this command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 则你有基于systemctl的启动系统。尝试以下命令：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If that works, you shouldn’t see any output from this command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此操作成功，你不应看到此命令的任何输出：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the Docker daemon has been stopped, you can restart it manually and open
    it up to outside users with the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Docker守护进程停止，你可以手动重新启动它，并使用以下命令将其向外部用户开放：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command starts as a daemon (`docker daemon`), defines the host server with
    the `-H` flag, uses the TCP protocol, opens up all IP interfaces (with `0.0.0.0`),
    and opens up the standard Docker server port (`2375`).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令以守护进程(`docker daemon`)启动，使用`-H`标志定义主机服务器，使用TCP协议，打开所有IP接口（使用`0.0.0.0`），并打开标准的Docker服务器端口（`2375`）。
- en: 'You can connect from outside with the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令从外部连接：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or you can export the `DOCKER_HOST` environment variable (this won’t work if
    you have to use `sudo` to run Docker—see [technique 41](kindle_split_016.xhtml#ch06sb02)
    to find out how to remove this requirement):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以导出`DOCKER_HOST`环境变量（如果你必须使用`sudo`来运行Docker，则此方法不可用——参见[技术41](kindle_split_016.xhtml#ch06sb02)以了解如何删除此要求）：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that you’ll also need to do one of these from inside your local machine
    as well, because Docker is no longer listening in the default location.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你还需要在本地机器上执行以下操作之一，因为Docker不再监听默认位置。
- en: If you want to make this change permanent on your host, you’ll need to configure
    your startup system. See [appendix B](kindle_split_035.xhtml#app02) for information
    on how to do this.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在你的主机上永久更改此设置，你需要配置你的启动系统。有关如何操作的更多信息，请参阅[附录B](kindle_split_035.xhtml#app02)。
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If you use this technique to make your Docker daemon listen on a port, be aware
    that specifying the IP as `0.0.0.0` gives access to users on all network interfaces
    (both public and private), which is generally considered insecure.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用此技术使Docker守护进程监听端口，请注意，将IP指定为`0.0.0.0`将允许所有网络接口（包括公共和私有）的用户访问，这通常被认为是不安全的。
- en: '|  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**DISCUSSION**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This is a great technique if you have a powerful machine dedicated to Docker
    inside a secure private local network, because everyone on the network can easily
    point Docker tools to the right place—`DOCKER_HOST` is a well-known environment
    variable that will inform most programs that access Docker where to look.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个强大的机器，在安全的私有本地网络内专门用于Docker，这是一个很好的技术，因为网络上的每个人都可以轻松地将Docker工具指向正确的位置——`DOCKER_HOST`是一个众所周知的环境变量，它将通知大多数访问Docker的程序在哪里查找。
- en: As an alternative to the somewhat cumbersome process of stopping the Docker
    service and running it manually, you could combine mounting the Docker socket
    as a volume (from [technique 45](kindle_split_016.xhtml#ch06sb06)) with using
    the socat tool to forward traffic from an external port—simply run `docker run
    -p 2375:2375 -v /var/run/docker.sock:/var/ run/docker.sock sequenceid/socat`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为停止Docker服务并手动运行它的相对繁琐过程的替代，你可以将挂载Docker套接字作为卷（从[技术45](kindle_split_016.xhtml#ch06sb06)）与使用socat工具从外部端口转发流量结合起来——只需运行`docker
    run -p 2375:2375 -v /var/run/docker.sock:/var/run/docker.sock sequenceid/socat`。
- en: You’ll see a specific example of something this technique allows later in the
    chapter, in [technique 5](#ch02sb06).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章后面的[技术5](#ch02sb06)中看到这个技术允许的特定示例。
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Running containers as daemons**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**以守护进程运行容器**'
- en: As you get familiar with Docker (and if you’re anything like us), you’ll start
    to think of other use cases for Docker, and one of the first of these is to run
    Docker containers as background services.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对Docker（如果你和我们一样）越来越熟悉，你可能会开始考虑Docker的其他用例，其中第一个就是将Docker容器作为后台服务运行。
- en: Running Docker containers as services with predictable behavior through software
    isolation is one of the principal use cases for Docker. This technique will allow
    you to manage services in a way that works for your operation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过软件隔离以可预测的行为运行Docker容器是Docker的主要用例之一。这项技术将允许你以适合你操作的方式管理服务。
- en: '**PROBLEM**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to run a Docker container in the background as a service.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在后台以服务形式运行一个Docker容器。
- en: '**SOLUTION**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the `-d` flag to the `docker run` command, and use related container-management
    flags to define the service characteristics.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker run`命令的`-d`标志，并使用相关的容器管理标志来定义服务特性。
- en: 'Docker containers—like most processes—will run by default in the foreground.
    The most obvious way to run a Docker container in the background is to use the
    standard `&` control operator. Although this works, you can run into problems
    if you log out of your terminal session, necessitating that you use the `nohup`
    flag, which creates a file in your local directory with output that you have to
    manage... You get the idea: it’s far neater to use the Docker daemon’s functionality
    for this.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器——就像大多数进程一样——默认情况下将在前台运行。将Docker容器在后台运行的最明显方法就是使用标准的`&`控制操作符。虽然这可行，但如果你在终端会话中注销，你可能会遇到问题，需要使用`nohup`标志，它会在你的本地目录中创建一个包含输出的文件，你需要管理这个文件...你明白了：使用Docker守护进程的功能来做这件事要整洁得多。
- en: To do this, you use the `-d` flag.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，你使用`-d`标志。
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `-d` flag, when used with `docker run`, runs the container as a daemon.
    The `-i` flag gives this container the ability to interact with your Telnet session.
    With `-p` you publish the 1234 port from the container to the host. The `--name`
    flag lets you give the container a name so you can refer to it later. Finally,
    you run a simple listening echo server on port 1234 with netcat (`nc`).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`docker run`一起使用时，`-d`标志将容器作为守护进程运行。`-i`标志使这个容器能够与你的Telnet会话交互。使用`-p`你可以将容器中的1234端口发布到主机。`--name`标志允许你给容器起一个名字，这样你以后就可以引用它了。最后，你使用netcat（`nc`）在1234端口上运行一个简单的监听回声服务器。
- en: You can now connect to it and send messages with Telnet. You’ll see that the
    container has received the message by using the `docker logs` command, as shown
    in the following listing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以连接到它，并通过Telnet发送消息。你会看到容器通过使用`docker logs`命令接收到了消息，如下所示。
- en: Listing 2.1\. Connecting to the container netcat server with Telnet
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.1\. 使用Telnet连接到容器netcat服务器
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1*** **Connects to the container’s netcat server with the telnet command**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用telnet命令连接到容器的netcat服务器**'
- en: '***2*** **Inputs a line of text to send to the netcat server**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **输入要发送到netcat服务器的文本行**'
- en: '***3*** **Presses Ctrl-] followed by the Return key to quit the Telnet session**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **按下Ctrl-]然后回车键退出Telnet会话**'
- en: '***4*** **Types q and then the Return key to quit the Telnet program**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **输入q然后回车键退出Telnet程序**'
- en: '***5*** **Runs the docker logs command to see the container’s output**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **运行docker logs命令以查看容器的输出**'
- en: '***6*** **Cleans up the container with the rm command**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **使用rm命令清理容器**'
- en: 'You can see that running a container as a daemon is simple enough, but operationally
    some questions remain to be answered:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，以守护进程模式运行容器很简单，但在操作上还有一些问题需要回答：
- en: What happens to the service if it fails?
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务失败会发生什么？
- en: What happens to the service when it terminates?
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务终止时会发生什么？
- en: What happens if the service keeps failing over and over?
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务反复失败会发生什么？
- en: Fortunately Docker provides flags for each of these questions!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Docker为这些问题中的每一个都提供了标志！
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Although restart flags are used most often with the daemon flag (`-d`), it’s
    not a requirement to run these flags with `-d`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然重启标志通常与守护进程标志（`-d`）一起使用，但使用`-d`运行这些标志不是必需的。
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The `docker run--restart` flag allows you to apply a set of rules to be followed
    (a so-called “restart policy”) when the container terminates (see [table 2.1](#ch02table01)).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run--restart`标志允许你在容器终止时应用一组规则（所谓的“重启策略”）（见[表2.1](#ch02table01)）。'
- en: Table 2.1\. Docker restart flag options
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.1\. Docker重启标志选项
- en: '| **Policy** | **Description** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **策略** | **描述** |'
- en: '| --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| no | Don’t restart when the container exits |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| no | 容器退出时不重启 |'
- en: '| always | Always restart when the container exits |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| always | 容器退出时总是重启 |'
- en: '| unless-stopped | Always restart, but remember explicitly stopping |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| unless-stopped | 总是重启，但会记住显式停止 |'
- en: '| on-failure[:max-retry] | Restart only on failure |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| on-failure[:max-retry] | 仅在失败时重启 |'
- en: 'The `no` policy is simple: when the container exits, it isn’t restarted. This
    is the default.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`no`策略很简单：当容器退出时，不会重启。这是默认设置。'
- en: 'The `always` policy is also simple, but it’s worth discussing briefly:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`always`策略也很简单，但值得简要讨论：'
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command runs the container as a daemon (`-d`) and always restarts the container
    on termination (`--restart=always`). It issues a simple `echo` command that completes
    quickly, exiting the container.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令以守护进程模式（`-d`）运行容器，并在终止时总是重启容器（`--restart=always`）。它发出一个简单的`echo`命令，快速完成，然后退出容器。
- en: 'If you run the preceding command and then run a `docker ps` command, you’ll
    see output similar to this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的命令，然后运行一个`docker ps`命令，你会看到类似以下的内容：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `docker ps` command lists all the running containers and information about
    them, including the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps`命令列出所有正在运行的容器及其信息，包括以下内容：'
- en: When the container was created (`CREATED`).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器创建的时间（`CREATED`）。
- en: The current status of the container—usually this will be `Restarting`, because
    it will only run for a short time (`STATUS`).
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的当前状态——通常这将会是`Restarting`，因为它只会运行很短的时间（`STATUS`）。
- en: The exit code of the container’s previous run (also under `STATUS`). `0` means
    the run was successful.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器上次运行的退出代码（也位于`STATUS`下）。`0`表示运行成功。
- en: The container name. By default, Docker names containers by concatenating two
    random words. Sometimes this produces odd results (which is why we typically recommend
    giving them a meaningful name).
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器名称。默认情况下，Docker通过连接两个随机单词来命名容器。有时这会产生奇怪的结果（这就是我们通常建议给它们一个有意义的名称的原因）。
- en: Note that the `STATUS` column also informed us that the container exited less
    than a second ago and is restarting. This is because the `echo done` command exits
    immediately, and Docker must continually restart the container.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`STATUS`列还告诉我们容器在不到一秒前退出并正在重启。这是因为`echo done`命令立即退出，而Docker必须不断地重启容器。
- en: It’s important to note that Docker reuses the container ID. It doesn’t change
    on restart, and there will only ever be one entry in the `ps` table for this Docker
    invocation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Docker会重用容器ID。重启时不会改变，并且对于这个Docker调用，`ps`表中只会有一条记录。
- en: Specifying `unless-stopped` is almost the same as `always`—both will cease restarting
    if you run `docker stop` on a container, but `unless-stopped` will make sure that
    this stopped status is remembered if the daemon restarts (perhaps if you restart
    your computer), whereas `always` will bring the container back up again.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 指定`unless-stopped`几乎等同于`always`——两者都会在运行`docker stop`命令停止容器时停止重启，但`unless-stopped`会确保如果守护进程重启（例如，如果你重启了电脑），则记住这个停止状态，而`always`将再次将容器启动起来。
- en: 'Finally, the `on-failure` policy restarts only when the container returns a
    non-zero exit code (which normally means failing) from its main process:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`on-failure` 策略仅在容器从其主进程返回非零退出代码（通常表示失败）时重启：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command runs the container as a daemon (`-d`) and sets a limit on the number
    of restart attempts (`--restart=on-failure:10`), exiting if this is exceeded.
    It runs a simple command (`/bin/false`) that completes quickly and will definitely
    fail.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令以守护进程模式（`-d`）运行容器，并设置重启尝试次数的限制（`--restart=on-failure:10`），如果超过此限制则退出。它运行一个简单的命令（`/bin/false`），该命令快速完成并肯定会失败。
- en: 'If you run the preceding command and wait a minute, and then run `docker ps
    -a`, you’ll see output similar to this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行前面的命令并等待一分钟，然后运行 `docker ps -a`，您将看到类似以下内容的输出：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**DISCUSSION**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Creating services to run in the background often comes with the difficulty of
    making sure the background service won’t crash in unusual environments. Because
    it’s not immediately visible, users may not notice that something isn’t working
    correctly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建在后台运行的服务往往伴随着确保在异常环境中后台服务不会崩溃的困难。因为它不是立即可见的，用户可能不会注意到某些东西没有正确工作。
- en: This technique lets you stop thinking about the incidental complexity of your
    service, caused by the environment and handling restarts. You can focus your thinking
    on the core functionality.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术让您不再需要考虑由环境和处理重启引起的服务的偶然复杂性。您可以专注于核心功能。
- en: As a concrete example, you and your team might use this technique to run multiple
    databases on the same machine and avoid having to write instructions for setting
    them up or to have terminals open to keep them running.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，您和您的团队可能会使用这项技术在同一台机器上运行多个数据库，并避免编写设置它们的说明或保持它们运行而需要打开终端。
- en: '|  |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Moving Docker to a different partition**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**将 Docker 移动到不同的分区**'
- en: Docker stores all the data relating to your containers and images under a folder.
    Because it can store a potentially large number of different images, this folder
    can get big fast!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 在一个文件夹下存储与您的容器和镜像相关的所有数据。因为它可以存储大量不同的镜像，所以这个文件夹可能会迅速变大！
- en: If your host machine has different partitions (as is common in enterprise Linux
    workstations), you may encounter space limitations more quickly. In these cases,
    you may want to move the directory from which Docker operates.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的宿主机有不同分区（在企业 Linux 工作站中很常见），您可能会更快地遇到空间限制。在这些情况下，您可能希望将 Docker 运行的目录移动。
- en: '**PROBLEM**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to move where Docker stores its data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您想移动 Docker 存储数据的位置。
- en: '**SOLUTION**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Stop and start the Docker daemon, specifying the new location with the `-g`
    flag.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-g` 标志指定新位置来停止和启动 Docker 守护进程。
- en: 'Imagine you want to run Docker from /home/dockeruser/mydocker. First, stop
    your Docker daemon (see [appendix B](kindle_split_035.xhtml#app02) for a discussion
    on how to do this). Then run this command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想从 /home/dockeruser/mydocker 运行 Docker。首先，停止您的 Docker 守护进程（参见附录 B [kindle_split_035.xhtml#app02]，讨论如何执行此操作）。然后运行此命令：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A new set of folders and files will be created in this directory. These folders
    are internal to Docker, so play with them at your peril (as we’ve discovered!).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在此目录下将创建一组新的文件夹和文件。这些文件夹是 Docker 内部的，因此请谨慎操作（正如我们所发现的！）。
- en: You should be aware that this command will appear to wipe the containers and
    images from your previous Docker daemon. Don’t despair. If you kill the Docker
    process you just ran, and restart your Docker service, your Docker client will
    be pointed back at its original location, and your containers and images will
    be returned to you. If you want to make this move permanent, you’ll need to configure
    your host system’s startup process accordingly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道，此命令看起来会从您之前的 Docker 守护进程中清除容器和镜像。不要绝望。如果您终止了您刚刚运行的 Docker 进程，并重新启动您的 Docker
    服务，您的 Docker 客户端将重新指向其原始位置，您的容器和镜像将返回给您。如果您想使这次移动永久化，您需要相应地配置主机的启动过程。
- en: '**DISCUSSION**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Aside from the obvious use case for this (reclaiming space on disks with limited
    disk space), you could also use this technique if you wanted to strictly partition
    sets of images and containers. For example, if you have access to multiple private
    Docker registries with different owners, it might be worth the extra effort to
    make sure you don’t accidentally give private data to the wrong person.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个明显的用例（在磁盘空间有限的情况下回收磁盘空间）之外，如果你想要严格划分图像和容器的集合，你也可以使用这个技术。例如，如果你可以访问多个由不同所有者拥有的私有Docker注册库，那么确保你不小心将私有数据给了错误的人可能值得额外的努力。
- en: '|  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.3\. The Docker client
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3\. Docker客户端
- en: The Docker client (see [figure 2.4](#ch02fig04)) is the simplest component in
    the Docker architecture. It’s what you run when you type commands like `docker
    run` or `docker pull` on your machine. Its job is to communicate with the Docker
    daemon via HTTP requests.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Docker客户端（见图2.4）是Docker架构中最简单的组件。这是你在机器上输入`docker run`或`docker pull`等命令时运行的。它的任务是通过对Docker守护进程的HTTP请求进行通信。
- en: Figure 2.4\. The Docker client
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4\. Docker客户端
- en: '![](Images/02fig04.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig04.jpg)'
- en: In this section you’re going to see how you can snoop on messages between the
    Docker client and server. You’ll also see a way of using your browser as a Docker
    client and a few basic techniques related to port mapping that represent baby
    steps toward orchestration, discussed in [part 4](kindle_split_022.xhtml#part04)
    of this book.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解如何窃听Docker客户端和服务器之间的消息。你还将看到一种使用浏览器作为Docker客户端的方法，以及一些与端口映射相关的基本技术，这些技术是向编排迈出的第一步，在本书的第4部分（kindle_split_022.xhtml#part04）中讨论。
- en: '|  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using socat to monitor Docker API traffic**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用socat监控Docker API流量**'
- en: Occasionally the `docker` command may not work as you expect. Most often, some
    aspect of the command-line arguments hasn’t been understood, but occasionally
    there are more serious setup problems, such as the Docker binary being out of
    date. In order to diagnose the problem, it can be useful to view the flow of data
    to and from the Docker daemon you’re communicating with.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有时`docker`命令可能不会按预期工作。大多数情况下，命令行参数的某个方面没有被理解，但偶尔会有更严重的问题，例如Docker二进制文件过时。为了诊断问题，查看你与Docker守护进程通信的数据流可能很有用。
- en: '|  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t panic! The presence of this technique doesn’t indicate that Docker needs
    to be debugged often, or that it’s in any way unstable! This technique is here
    primarily as a tool for understanding Docker’s architecture, and also to introduce
    you to socat, a powerful tool. If, like us, you use Docker in a lot of different
    locations, there will be differences in the Docker versions you use. As with any
    software, different versions will have different features and flags, which can
    catch you out.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 别慌！这个技术的存在并不意味着Docker需要经常调试，或者它在任何方面都不稳定！这个技术主要作为一个理解Docker架构的工具，同时也向你介绍socat，一个强大的工具。如果你像我们一样，在许多不同的位置使用Docker，你使用的Docker版本可能会有所不同。和任何软件一样，不同版本将会有不同的功能和标志，这可能会让你感到困惑。
- en: '|  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**PROBLEM**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to debug a problem with a Docker command.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你想调试一个与Docker命令相关的问题。
- en: '**SOLUTION**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use a traffic snooper to inspect the API calls and craft your own.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流量嗅探器检查API调用并构建自己的。
- en: In this technique you’ll insert a proxy Unix domain socket between your request
    and the server’s socket to see what passes through it (as shown in [figure 2.5](#ch02fig05)).
    Note that you’ll need root or sudo privileges to make this work.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，你将在你的请求和服务器套接字之间插入一个代理Unix域套接字，以查看通过它的内容（如图2.5所示）。请注意，你需要root或sudo权限才能使这个操作生效。
- en: Figure 2.5\. Docker’s client/server architecture on your host
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.5\. 主机上的Docker客户端/服务器架构
- en: '![](Images/02fig05_alt.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig05_alt.jpg)'
- en: To create this proxy, you’ll use socat.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个代理，你将使用socat。
- en: '|  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`socat` is a powerful command that allows you to relay data between two data
    channels of almost any type. If you’re familiar with netcat, you can think of
    it as netcat on steroids. To install it, use the standard package manager for
    your system.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`socat`是一个强大的命令，它允许你在几乎任何类型的数据通道之间中继数据。如果你熟悉netcat，你可以将其视为加强版的netcat。要安装它，请使用你系统的标准包管理器。'
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this command, `-v` makes the output readable, with indications of the flow
    of data. The `UNIX-LISTEN` part tells `socat` to listen on a Unix socket, `fork`
    ensures that `socat` doesn’t exit after the first request, and `UNIX-CONNECT`
    tells `socat` to connect to Docker’s Unix socket. The `&` specifies that the command
    runs in the background. If you usually run the Docker client with sudo, you’ll
    need to do the same thing here as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，`-v`使输出可读，并指示数据流。`UNIX-LISTEN`部分告诉`socat`监听Unix套接字，`fork`确保`socat`在第一个请求后不会退出，而`UNIX-CONNECT`告诉`socat`连接到Docker的Unix套接字。`&`指定命令在后台运行。如果你通常使用sudo运行Docker客户端，你在这里也需要这样做。
- en: The new route that your requests to the daemon will travel can be seen in [figure
    2.6](#ch02fig06). All traffic traveling in each direction will be seen by `socat`
    and logged to your terminal, in addition to any output that the Docker client
    provides.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你请求的守护进程将经过的新路由可以在[图2.6](#ch02fig06)中看到。每个方向的所有流量都将被`socat`看到并记录到你的终端，除了Docker客户端提供的任何输出。
- en: Figure 2.6\. Docker client and server with socat inserted as a proxy
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.6\. 在socat作为代理插入后的Docker客户端和服务器
- en: '![](Images/02fig06_alt.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig06_alt.jpg)'
- en: 'The output of a simple `docker` command will now look similar to this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 简单`docker`命令的输出现在看起来类似于这个：
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1*** **The command you issue to see the request and response**'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **你发出的查看请求和响应的命令**'
- en: '***2*** **The HTTP request begins here, with the right angle bracket on the
    left.**'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **HTTP请求从这里开始，左侧带有右尖括号。**'
- en: '***3*** **The HTTP response begins here, with the left angle bracket on the
    left.**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **HTTP响应从这里开始，左侧带有左尖括号。**'
- en: '***4*** **The JSON content of the response from the Docker server**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **Docker服务器响应的JSON内容**'
- en: '***5*** **The output as normally seen by the user, interpreted by the Docker
    client from the preceding JSON**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **用户通常看到的输出，由Docker客户端从前面的JSON中解释**'
- en: The specifics of the preceding output will change with the Docker API’s growth
    and development. When you run the preceding command, you’ll see later version
    numbers and different JSON output. You can check your client and server versions
    of the API by running the `docker version` command.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前面输出的具体内容将随着Docker API的增长和发展而变化。当你运行前面的命令时，你会看到更晚的版本号和不同的JSON输出。你可以通过运行`docker
    version`命令来检查你的客户端和服务器API版本。
- en: '|  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If you ran socat as root in the previous example, you’ll need to use sudo to
    run the `docker -H` command. This is because the dockerapi.sock file is owned
    by root.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前作为root运行了socat，你需要使用sudo来运行`docker -H`命令。这是因为dockerapi.sock文件属于root。
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Using socat is a powerful way to debug not only Docker, but any other network
    services you might come across in the course of your work.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用socat不仅是一种强大的调试Docker的方法，而且还可以调试你在工作中可能遇到的任何其他网络服务。
- en: '**DISCUSSION**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: 'It’s possible to come up with a number of other use cases for this technique:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这项技术，可以想出许多其他用例：
- en: Socat is quite a Swiss Army knife and can handle quite a number of different
    protocols. The preceding example shows it listening on a Unix socket, but you
    could also make it listen on an external port with `TCP-LISTEN:2375,fork` instead
    of the `UNIX-LISTEN:...` argument. This acts as a simpler version of [technique
    1](#ch02sb02). With this approach there’s no need to restart the Docker daemon
    (which would kill any running containers). You can just bring the socat listener
    up and down as you desire.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Socat就像瑞士军刀一样，可以处理相当多的不同协议。前面的例子显示了它正在监听Unix套接字，但你也可以使用`TCP-LISTEN:2375,fork`而不是`UNIX-LISTEN:...`参数来让它监听外部端口。这相当于[技术1](#ch02sb02)的一个更简单版本。采用这种方法，无需重新启动Docker守护进程（这将杀死所有正在运行的容器）。你可以根据需要随时启动和停止socat监听器。
- en: Because the preceding point is so simple to set up and is temporary, you can
    use it in combination with [technique 47](kindle_split_016.xhtml#ch06sb08) to
    join a colleague’s running container remotely and help them debug an issue. You
    can also employ the little-used `docker attach` command to join the same terminal
    they started with `docker run`, allowing you to collaborate directly.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于前面的点设置简单且临时，你可以将其与[技术47](kindle_split_016.xhtml#ch06sb08)结合使用，以远程连接同事的运行中的容器并帮助他们调试问题。你还可以使用不常用的`docker
    attach`命令连接到他们使用`docker run`启动的相同终端，这样你可以直接协作。
- en: If you have a shared Docker server (perhaps set up with [technique 1](#ch02sb02))
    you could use the ability to expose externals and set up socat as the broker between
    the outside world and the Docker socket to make it act as a primitive audit log,
    recording where all requests are coming from and what they’re doing.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个共享的Docker服务器（可能使用[技术1](#ch02sb02)设置），你可以使用暴露外部的能力，并在Docker套接字和外部世界之间设置socat作为代理，使其充当原始审计日志，记录所有请求的来源和它们所做的事情。
- en: '|  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Using Docker in your browser**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**在浏览器中使用Docker**'
- en: It can be difficult to sell new technologies, so simple and effective demonstrations
    are invaluable. Making the demo hands-on is even better, which is why we’ve found
    that creating a web page that allows users to interact with a container in a browser
    is a great technique. It gives newcomers their first taste of Docker in an easily
    accessible way, allowing them to create a container, use a container terminal
    in a browser, attach to someone else’s terminal, and share control. The significant
    “wow” factor doesn’t hurt either!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 推广新技术可能会很困难，所以简单有效的演示是无价的。使演示亲身体验甚至更好，这就是为什么我们发现创建一个允许用户在浏览器中与容器交互的网页是一个很好的技术。它以易于访问的方式让新用户第一次尝试Docker，允许他们创建容器，在浏览器中使用容器终端，连接到他人的终端，并共享控制。显著的“哇”效果也不无裨益！
- en: '**PROBLEM**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to demonstrate the power of Docker without requiring users to install
    it themselves or run commands they don’t understand.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望展示Docker的强大功能，而不需要用户自己安装它或运行他们不理解命令。
- en: '**SOLUTION**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Start the Docker daemon with an open port and Cross-Origin-Resource Sharing
    (CORS) enabled, and then serve the docker-terminal repository in your web server
    of choice.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用开放端口和启用跨源资源共享（CORS）的Docker守护进程启动，然后在你的选择中提供docker-terminal存储库。
- en: The most common use of a REST API is to expose it on a server and use JavaScript
    on a web page to make calls to it. Because Docker happens to perform all interaction
    via a REST API, you should be able to control Docker in the same way. Although
    it may initially seem surprising, this control extends all the way to being able
    to interact with a container via a terminal in your browser.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: REST API最常见的使用是在服务器上公开它，并在网页上使用JavaScript调用它。因为Docker恰好通过REST API执行所有交互，所以你应该能够以相同的方式控制Docker。尽管这最初可能看起来令人惊讶，但这种控制甚至可以扩展到通过浏览器中的终端与容器交互。
- en: We’ve already discussed how to start the daemon on port 2375 in [technique 1](#ch02sb02),
    so we won’t go into any detail on that. Additionally, CORS is too much to go into
    here. If you’re unfamiliar with it, refer to *CORS in Action* by Monsur Hossain
    (Manning, 2014). In short, CORS is a mechanism that carefully bypasses the usual
    restriction of Java-Script that limits you to only accessing the current domain.
    In this case, CORS allows the daemon to listen on a different port from where
    you serve your Docker terminal page. To enable CORS, you need to start the Docker
    daemon with the option `--api-enable-cors` alongside the option to make it listen
    on a port.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[技术1](#ch02sb02)中讨论了如何在2375端口启动守护进程，所以这里不会对此进行详细说明。此外，CORS的内容也太多，无法在这里展开。如果你不熟悉它，可以参考Monsur
    Hossain的《CORS in Action》（Manning, 2014）。简而言之，CORS是一种机制，它小心地绕过了Java-Script通常的限制，只允许访问当前域名。在这种情况下，CORS允许守护进程在不同于你提供Docker终端页面的端口上监听。要启用CORS，你需要使用带有`--api-enable-cors`选项启动Docker守护进程，并选择使其监听端口的选项。
- en: 'Now that the prerequisites are sorted, let’s get this running. First, you need
    to get the code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有先决条件都已解决，让我们开始运行。首先，你需要获取代码：
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then you need to serve the files:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要提供文件：
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding command uses a module built into Python to serve static files
    from a directory. Feel free to use any equivalent you prefer. Now visit http://localhost:8000
    in your browser and start a container.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令使用Python内置的模块从目录中提供静态文件。你可以自由使用你喜欢的任何等效方法。现在在你的浏览器中访问http://localhost:8000并启动一个容器。
- en: '[Figure 2.7](#ch02fig07) shows how the Docker terminal connects up. The page
    is hosted on your local computer and connects to the Docker daemon on your local
    computer to perform any operations.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.7](#ch02fig07)展示了Docker终端是如何连接的。页面托管在你的本地计算机上，并连接到本地计算机上的Docker守护进程以执行任何操作。'
- en: Figure 2.7\. How the Docker terminal works
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.7\. Docker终端的工作原理
- en: '![](Images/02fig07_alt.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig07_alt.jpg)'
- en: 'It’s worth being aware of the following points if you want to give this link
    to other people:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将此链接提供给其他人，请注意以下事项：
- en: The other person must not be using a proxy of any kind. This is the most common
    source of errors we’ve seen—Docker terminal uses WebSockets, which don’t currently
    work through proxies.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个人不得使用任何类型的代理。这是我们遇到的最常见的错误来源——Docker终端使用WebSockets，而目前它们无法通过代理工作。
- en: Giving a link to `localhost` obviously won’t work—you’ll need to give out the
    external IP address.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然，提供`localhost`的链接不会起作用——您需要提供外部IP地址。
- en: Docker terminal needs to know where to find the Docker API—it should do this
    automatically based on the address you’re visiting in the browser, but it’s something
    to be aware of.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker终端需要知道在哪里找到Docker API——它应该根据您在浏览器中访问的地址自动完成此操作，但这是需要注意的事项。
- en: '|  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you’re more experienced with Docker, you might wonder why we didn’t use a
    Docker image in this technique. The reason is that we’re still introducing Docker
    and didn’t want to add to the complexity for readers new to Docker. Dockerizing
    this technique is left as an exercise for the reader.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对Docker更熟悉，您可能会想知道为什么我们没有在这个技术中使用Docker镜像。原因是我们仍在介绍Docker，并且不想为Docker新手增加复杂性。将这项技术Docker化留作读者的练习。
- en: '|  |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Although we originally used this technique as an exciting demo for Docker (having
    multiple people easily share a terminal on disposable machines can be difficult
    to set up, even with terminal multiplexers), we’ve found some interesting applications
    in some unrelated areas. One example is using it to monitor a small group of trainees
    in some task at the command line. There’s no need for you or them to install anything;
    just open your browser and you can connect to their terminal to jump in and give
    them a hand at any time!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们最初使用这项技术作为Docker的一个令人兴奋的演示（在可丢弃的机器上轻松共享多个终端可能很难设置，即使使用终端复用器），但我们发现它在一些无关领域有一些有趣的应用。一个例子是使用它来监控命令行中的一些任务的小组训练员。您或他们无需安装任何东西；只需打开您的浏览器，您就可以连接到他们的终端，随时提供帮助！
- en: On a similar note, this has some strengths in collaboration. In the past, when
    we’ve wanted to share a bug with a coworker, we’ve reproduced the bug in a Docker
    container so we can track it down together. With this technique, there’s no need
    to go through a possible “but why do I want Docker?” discussion beforehand.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的情况下，这也有一些协作的优势。在过去，当我们想要与同事分享一个错误时，我们会在Docker容器中重现错误，以便我们可以一起追踪它。有了这项技术，就不需要事先进行可能的“但为什么我要用Docker？”讨论。
- en: '|  |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using ports to connect to containers**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过端口连接到容器**'
- en: Docker containers have been designed from the outset to run services. In the
    majority of cases, these will be HTTP services of one kind or another. A significant
    proportion of these will be web services accessible through the browser.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器从一开始就被设计为运行服务。在大多数情况下，这些将是一定类型的HTTP服务。其中相当一部分将通过浏览器访问的Web服务。
- en: This leads to a problem. If you have multiple Docker containers running on port
    80 in their internal environment, they can’t all be accessible on port 80 on your
    host machine. This technique shows how you can manage this common scenario by
    exposing and mapping a port from your container.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个问题。如果您在内部环境中在端口80上运行多个Docker容器，它们都无法在您的宿主机的端口80上访问。这项技术展示了您如何通过公开和映射容器中的端口来管理这种常见场景。
- en: '**PROBLEM**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to make multiple Docker container services available on a port from
    your host machine.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您想在宿主机的端口上提供多个Docker容器服务。
- en: '**SOLUTION**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use Docker’s `-p` flag to map a container’s port to your host machine.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker的`-p`标志将容器的端口映射到您的宿主机器。
- en: In this example we’re going to use the tutum-wordpress image. Let’s say you
    want to run two of these on your host machine to serve different blogs.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用tutum-wordpress镜像。假设您想在宿主机器上运行两个这样的镜像来提供不同的博客。
- en: 'Because a number of people have wanted to do this before, someone has prepared
    an image that anyone can acquire and start up. To obtain images from external
    locations, you can use the `docker pull` command. By default, images will be downloaded
    from the Docker Hub:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多人之前都想要这样做，有人已经准备了一个任何人都可以获取并启动的镜像。要从外部位置获取镜像，您可以使用`docker pull`命令。默认情况下，镜像将从Docker
    Hub下载：
- en: '[PRE18]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Images will also be retrieved automatically when you try to run them if they’re
    not already present on your machine.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试运行图片而它们尚未存在于您的机器上时，图片也会自动检索。
- en: 'To run the first blog, use the following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行第一个博客，请使用以下命令：
- en: '[PRE19]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This `docker run` command runs the container as a daemon (`-d`) with the publish
    flag (`-p`). It identifies the host port (`10001`) to map to the container port
    (`80`) and gives the container a name to identify it (`--name blog1 tutum/wordpress`).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `docker run` 命令以守护进程（`-d`）模式运行容器，并带有发布标志（`-p`）。它标识了要映射到容器端口（`80`）的宿主机端口（`10001`），并为容器指定一个名称以识别它（`--name
    blog1 tutum/wordpress`）。
- en: 'You can do the same for the second blog:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以对第二个博客做同样的操作：
- en: '[PRE20]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you now run this command,
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行此命令，
- en: '[PRE21]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'you’ll see the two blog containers listed, with their port mappings, looking
    something like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到两个博客容器被列出，它们的端口映射看起来像这样：
- en: '[PRE22]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You’ll now be able to access your containers by navigating to http://localhost:10001
    and http://localhost:10002.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过导航到 http://localhost:10001 和 http://localhost:10002 来访问您的容器。
- en: 'To remove the containers when you’re finished (assuming you don’t want to keep
    them—we’ll make use of them in the next technique), run this command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成时（假设您不想保留它们——我们将在下一个技术中使用它们），运行此命令：
- en: '[PRE23]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You should now be able to run multiple identical images and services on your
    host by managing the port allocations yourself, if necessary.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您现在应该能够通过自己管理端口分配来在您的宿主机上运行多个相同的镜像和服务。
- en: '|  |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: It can be easy to forget which port is the host’s and which port is the container’s
    when using the `-p` flag. We think of it as being like reading a sentence from
    left to right. The user connects to the host (`-p`) and that host port is passed
    to the container port (`host_port:container_port`). It’s also the same format
    as SSH’s port-forwarding commands, if you’re familiar with them.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `-p` 标志时，很容易忘记哪个端口是宿主机的，哪个端口是容器的。我们将其视为像从左到右阅读一句话。用户连接到宿主机（`-p`），然后该宿主机端口被传递到容器端口（`host_port:container_port`）。如果您熟悉
    SSH 的端口转发命令，这也是相同的格式。
- en: '|  |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**DISCUSSION**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Exposing ports is an incredibly important part of many use cases of Docker,
    and you’ll come across it a number of times throughout this book, especially in
    [part 4](kindle_split_022.xhtml#part04), where containers talking to each other
    is part of everyday life.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露端口是 Docker 许多用例中极其重要的部分，您将在本书的许多地方遇到它，尤其是在 [第 4 部分](kindle_split_022.xhtml#part04)
    中，容器之间的通信是日常生活的一部分。
- en: In [technique 80](kindle_split_021.xhtml#ch10sb06) we’ll introduce you to virtual
    networks and explain what they do behind the scenes and how they direct the host
    ports to the right container.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [技术 80](kindle_split_021.xhtml#ch10sb06) 中，我们将向您介绍虚拟网络，并解释它们在幕后做什么以及它们如何将宿主机端口导向正确的容器。
- en: '|  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Allowing container communication**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**允许容器通信**'
- en: The last technique showed how you can open up your containers to the host network
    by exposing ports. You won’t always want to expose your services to the host machine
    or the outside world, but you will want to connect containers to one another.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种技术展示了您如何通过暴露端口将容器打开到宿主机网络。您并不总是想将服务暴露给宿主机或外界，但您会想将容器连接到彼此。
- en: This technique shows how you can achieve this with Docker’s user-defined networks
    feature, ensuring outsiders can’t access your internal services.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此技术展示了您如何使用 Docker 的用户定义网络功能来实现这一点，确保外界无法访问您的内部服务。
- en: '**PROBLEM**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to allow communication between containers for internal purposes.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望允许容器之间进行内部通信。
- en: '**SOLUTION**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Employ user-defined networks to enable containers to communicate with each other.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用用户定义的网络来使容器能够相互通信。
- en: User-defined networks are simple and flexible. We have a couple of WordPress
    blogs running in containers from the previous technique, so let’s take a look
    at how we can reach them from another container (rather than from the outside
    world, which you’ve seen already).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的网络简单且灵活。我们使用之前的技术在容器中运行了几个 WordPress 博客，让我们看看我们如何从另一个容器（而不是从您已经看到的从外界）访问它们。
- en: 'First you’ll need to create a user-defined network:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要创建一个用户定义的网络：
- en: '[PRE24]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This command creates a new virtual network living on your machine that you can
    use to manage container communication. By default, all containers that you connect
    to this network will be able to see each other by their names.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建了一个新的虚拟网络，它存在于您的机器上，您可以使用它来管理容器通信。默认情况下，您连接到该网络的任何容器都可以通过其名称相互看到。
- en: Next, assuming that you still have the `blog1` and `blog2` containers running
    from the previous technique, you can connect one of them to your new network on
    the fly.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设你仍然使用前一种技术运行着 `blog1` 和 `blog2` 容器，你可以即时将其中一个连接到你的新网络。
- en: '[PRE25]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, you can start up a new container, explicitly specifying the network,
    and see if you can retrieve the first five lines of HTML from the landing page
    of the blog.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以启动一个新的容器，明确指定网络，并查看你是否能从博客的着陆页检索到前五行 HTML。
- en: '[PRE26]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|  |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Giving containers names is very useful for assigning memorable hostnames you
    can later refer to, but it’s not strictly necessary—if connections are only outgoing,
    then you probably won’t need to look up the container. If you find you *do* want
    to look up the host and haven’t assigned a name, you can resort to using the short
    image ID as listed in the terminal prompt (unless it has been overridden with
    a hostname) or in the `docker ps` output.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 给容器命名非常有用，可以分配易于记忆的主机名，稍后可以引用，但这不是严格必要的——如果只有出站连接，那么你可能不需要查找容器。如果你发现你确实想查找主机名但尚未分配名称，你可以求助于使用终端提示中列出的短镜像
    ID（除非它已被主机名覆盖）或在 `docker ps` 输出中。
- en: '|  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Our new container was successfully able to access the blog we connected to `my_network`,
    displaying some of the HTML of the page we’d see if we visited it in the browser.
    On the other hand, our new container couldn’t see the second blog. Because we
    never connected it to `my_network`, this makes sense.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新容器成功访问了我们连接到 `my_network` 的博客，显示了在浏览器中访问它时我们会看到的页面的一些 HTML。另一方面，我们的新容器看不到第二个博客。因为我们从未将其连接到
    `my_network`，这很合理。
- en: '**DISCUSSION**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: You can use this technique to set up any number of containers in a cluster on
    their own private network, only requiring that the containers have some way of
    discovering each other’s names. In [technique 80](kindle_split_021.xhtml#ch10sb06)
    you’ll see a method of doing this that integrates well with Docker networks. Meanwhile,
    the next technique will start much smaller, demonstrating some benefits of being
    able to make an explicit connection between a single container and the service
    it provides.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这种技术在一个集群上设置任意数量的容器，只要容器有某种方式可以发现彼此的名称。在 [技术 80](kindle_split_021.xhtml#ch10sb06)
    中，你将看到一种与 Docker 网络很好地集成的实现方法。同时，下一个技术将从更小的规模开始，展示能够明确连接单个容器及其提供的服务的一些好处。
- en: One additional point of note is the interesting final state of the `blog1` container.
    All containers are connected to the Docker `bridge` network by default, so when
    we asked for it to join `my_network`, it did so *in addition to* the network it
    was already on. In [technique 80](kindle_split_021.xhtml#ch10sb06) we’ll look
    at this in more detail to see how *network straddling* can be used as a model
    for some real-world situations.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得注意的额外点是 `blog1` 容器的有趣最终状态。默认情况下，所有容器都连接到 Docker `bridge` 网络，所以当我们要求它加入 `my_network`
    时，它除了已经连接的网络外，还加入了该网络。在 [技术 80](kindle_split_021.xhtml#ch10sb06) 中，我们将更详细地探讨这一点，看看如何使用
    *网络跨越* 作为某些实际场景的模型。
- en: '|  |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Linking containers for port isolation**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**为端口隔离链接容器**'
- en: In the previous technique you saw how to get containers to communicate with
    user-defined networks. But there’s an older method of declaring container communication—Docker’s
    link flag. This isn’t the recommended way of working anymore, but it has been
    part of Docker for a long time, and it’s worth being aware of in case you encounter
    it in the wild.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一种技术中，你看到了如何让容器与用户定义的网络通信。但还有一种更老的方法来声明容器通信——Docker 的链接标志。这不再是推荐的工作方式，但它已经存在于
    Docker 中很长时间了，如果你在野外遇到它，了解这一点是值得的。
- en: '**PROBLEM**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to allow communication between containers without using user-defined
    networks.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望在不使用用户定义网络的情况下允许容器之间通信。
- en: '**SOLUTION**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use Docker’s linking functionality to allow the containers to communicate with
    each other.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 的链接功能，允许容器之间相互通信。
- en: Taking up the torch of the WordPress example, we’re going to separate the MySQL
    database tier from the WordPress container, and link these to each other without
    port configuration or creating a network. [Figure 2.8](#ch02fig08) gives an overview
    of the final state.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以 WordPress 示例为背景，我们将把 MySQL 数据库层从 WordPress 容器中分离出来，并将它们相互链接，而不需要端口配置或创建网络。[图
    2.8](#ch02fig08) 展示了最终状态。
- en: Figure 2.8\. WordPress setup with linked containers
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.8\. WordPress 配置与链接容器
- en: '![](Images/02fig08_alt.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig08_alt.jpg)'
- en: '|  |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Why bother with linking if you can already expose ports to the host and use
    that? Linking allows you to encapsulate and define the relationships between containers
    without exposing services to the host’s network (and potentially, to the outside
    world). You might want to do this for security reasons, for example.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经可以暴露端口到主机并使用它，为什么还要使用链接呢？链接允许您封装并定义容器之间的关系，而无需将服务暴露给主机的网络（以及可能的外部世界）。例如，您可能出于安全原因想要这样做。
- en: '|  |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Run your containers in the following order, pausing for about a minute between
    the first and second commands:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下顺序运行您的容器，在第一个和第二个命令之间暂停大约一分钟：
- en: '[PRE27]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First you give the MySQL container the name `wp-mysql` so you can refer to it
    later. You also must supply an environment variable so the MySQL container can
    initialize the database (`-e MYSQL_ROOT_PASSWORD=yoursecretpassword`). You run
    both containers as daemons (`-d`) and use the Docker Hub reference for the official
    MySQL image.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要给 MySQL 容器命名为 `wp-mysql`，这样您以后就可以引用它了。您还必须提供一个环境变量，以便 MySQL 容器可以初始化数据库（`-e
    MYSQL_ROOT_PASSWORD=yoursecretpassword`）。您将以守护进程模式运行这两个容器（`-d`），并使用 Docker Hub
    的官方 MySQL 镜像引用。
- en: 'In the second command you give the WordPress image the name `wordpress` in
    case you want to refer to it later. You also link the wp-mysql container to the
    WordPress container (`--link wp-mysql:mysql`). References to a `mysql` server
    within the WordPress container will be sent to the container named `wp-mysql`.
    You also use a local port mapping (`-p 10003:80`), as discussed in [technique
    6](#ch02sb07), and add the Docker Hub reference for the official WordPress image
    (`wordpress`). Be aware that links won’t wait for services in linked containers
    to start; hence the instruction to pause between commands. A more precise way
    of doing this is to look for “mysqid: ready for connections” in the output of
    `docker logs wp-mysql` before running the WordPress container.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '在第二个命令中，您将 WordPress 镜像命名为 `wordpress`，以防您以后需要引用它。您还将 wp-mysql 容器链接到 WordPress
    容器（`--link wp-mysql:mysql`）。WordPress 容器内部对 `mysql` 服务器的引用将被发送到名为 `wp-mysql` 的容器。您还使用了本地端口映射（`-p
    10003:80`），如[技术 6](#ch02sb07)所述，并添加了 Docker Hub 的官方 WordPress 镜像引用（`wordpress`）。请注意，链接不会等待链接容器中的服务启动；因此，需要在命令之间暂停。更精确的做法是在运行
    WordPress 容器之前，在 `docker logs wp-mysql` 的输出中查找“mysqid: ready for connections”。'
- en: If you now navigate to http://localhost:10003, you’ll see the introductory WordPress
    screen and you can set up your WordPress instance.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在导航到 http://localhost:10003，您将看到 WordPress 的介绍屏幕，并可以设置您的 WordPress 实例。
- en: The meat of this example is the `--link` flag in the second command. This flag
    sets up the container’s host file so that the WordPress container can refer to
    a MySQL server, and this will be routed to whatever container has the name `wp-mysql`.
    This has the significant benefit that different MySQL containers can be swapped
    in without requiring any change at all to the WordPress container, making configuration
    management of these different services much easier.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的核心是第二个命令中的 `--link` 标志。此标志设置容器的宿主文件，以便 WordPress 容器可以引用 MySQL 服务器，并且这将路由到名为
    `wp-mysql` 的任何容器。这具有显著的好处，即可以无需对 WordPress 容器进行任何更改即可更换不同的 MySQL 容器，这使得不同服务的配置管理变得更加容易。
- en: '|  |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The containers must be started up in the correct order so that the mapping can
    take place on container names that are already in existence. Dynamic resolution
    of links is not (at the time of writing) a feature of Docker.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 容器必须按正确的顺序启动，以便可以在已存在的容器名称上进行映射。在撰写本文时，Docker 不支持动态解析链接。
- en: '|  |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In order for containers to be linked in this way, their ports must be specified
    as exposed when building the images. This is achieved using the `EXPOSE` command
    within the image build’s Dockerfile. The ports listed in `EXPOSE` directives in
    Dockerfiles are also used when using the `-P` flag (“publish all ports.” rather
    than `-p`, which publishes as a specific port) to the `docker run` command.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以这种方式链接容器，它们的端口必须在构建镜像时指定为暴露。这是通过在镜像构建的 Dockerfile 中使用 `EXPOSE` 命令来实现的。Dockerfile
    中 `EXPOSE` 指令中列出的端口也用于使用 `-P` 标志（“发布所有端口”而不是 `-p`，后者指定特定端口）到 `docker run` 命令。
- en: By starting up different containers in a specific order, you’ve seen a simple
    example of Docker orchestration. Docker orchestration is any process that coordinates
    the running of Docker containers. It’s a large and important subject that we’ll
    cover in depth in [part 4](kindle_split_022.xhtml#part04) of this book.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以特定顺序启动不同的容器，您已经看到了Docker编排的一个简单示例。Docker编排是任何协调Docker容器运行的过程。这是一个庞大且重要的主题，我们将在本书的第4部分（[part
    4](kindle_split_022.xhtml#part04)）中深入探讨。
- en: By splitting your workload into separate containers, you’ve taken a step toward
    creating a microservices architecture for your application. In this case you could
    perform work on the MySQL container while leaving the WordPress container untouched,
    or vice versa. This fine-grained control over running services is one of the key
    operational benefits of a microservices architecture.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将工作负载分割成独立的容器，您已经朝着为您的应用程序创建微服务架构迈出一步。在这种情况下，您可以在不触及WordPress容器的情况下在MySQL容器上执行工作，反之亦然。这种对运行服务的精细控制是微服务架构的关键操作优势之一。
- en: '**DISCUSSION**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This kind of precise control over a set of containers is not often needed, but
    it can be useful as a very straightforward and easy-to-reason-about way to swap
    out containers. Using the example from this technique, you might want to test
    a different MySQL version—the WordPress image doesn’t need to know anything about
    this, because it just looks for the `mysql` link.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 对一组容器进行这种精确控制并不常见，但它可以作为非常直接且易于推理的替换容器的简单方法。使用此技术示例，您可能想测试不同的MySQL版本——WordPress镜像不需要了解这一点，因为它只是查找`mysql`链接。
- en: '|  |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.4\. Docker registries
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4\. Docker注册服务器
- en: Once you’ve created your images, you may want to share them with other users.
    This is where the concept of the *Docker registry* comes in.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了您的镜像，您可能希望与其他用户共享它们。这就是Docker注册器概念出现的地方。
- en: The three registries in [figure 2.9](#ch02fig09) differ in their accessibility.
    One is on a private network, one is open on a public network, and another is public
    but accessible only to those registered with Docker. They all perform the same
    function with the same API, and this is how the Docker daemon knows how to communicate
    with them interchangeably.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.9](#ch02fig09) 中的三个注册服务器在可访问性方面有所不同。一个是私有网络上的，一个是公开在公共网络上的，另一个是公开的，但仅对注册了Docker的用户可访问。它们都使用相同的API执行相同的功能，这就是Docker守护进程如何能够相互交换地与它们通信。'
- en: Figure 2.9\. A Docker registry
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.9\. Docker注册服务器
- en: '![](Images/02fig09_alt.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig09_alt.jpg)'
- en: A Docker registry allows multiple users to push and pull images from a central
    store using a RESTful API.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Docker注册服务器允许多个用户通过RESTful API从中央存储库推送和拉取镜像。
- en: The registry code is, like Docker itself, open source. Many companies (such
    as ours) set up private registries to store and share their proprietary images
    internally. This is what we’ll discuss before we look more closely at Docker Inc.’s
    registry.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注册服务器代码，就像Docker本身一样，是开源的。许多公司（如我们公司）设置私有注册服务器以存储和共享其专有镜像。在我们更详细地了解Docker Inc.
    的注册服务器之前，我们将讨论这一点。
- en: '|  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Setting up a local Docker registry**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置本地Docker注册服务器**'
- en: You’ve seen that Docker Inc. has a service where people can share their images
    publicly (and you can pay if you want to do it privately). But there are a number
    of reasons you may want to share images without going via the Hub—some businesses
    like to keep as much in-house as possible, maybe your images are large and transferring
    them over the internet will be too slow, or perhaps you want to keep your images
    private while you experiment and don’t want to commit to paying. Whatever the
    reason, there’s a simple solution.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到Docker Inc. 提供了一个服务，人们可以公开分享他们的镜像（如果您想私下进行，您可以选择付费）。但是，您可能有多个原因希望在无需通过枢纽的情况下共享镜像——一些企业喜欢尽可能多地保留内部资源，也许您的镜像很大，通过互联网传输会太慢，或者您可能希望在实验期间保持镜像的私密性，而不想承诺付费。无论原因如何，都有一个简单的解决方案。
- en: '**PROBLEM**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want a way to host your images locally.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望有一种方式来本地托管您的镜像。
- en: '**SOLUTION**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Set up a registry server on your local network. Simply issue the following
    command on a machine with plenty of disk space:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的本地网络中设置一个注册服务器。只需在拥有大量磁盘空间的机器上执行以下命令：
- en: '[PRE28]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This command makes the registry available on port 5000 of the Docker host (`-p
    5000:5000`). With the `-v` flag, it makes the registry folder on your host (/var/lib/registry)
    available in the container as `$HOME/registry`. The registry’s files will therefore
    be stored on the host in the /var/lib/registry folder.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使注册表在 Docker 主机的 5000 端口上可用（`-p 5000:5000`）。使用 `-v` 标志，它使你的主机上的注册表文件夹（/var/lib/registry）在容器中作为
    `$HOME/registry` 可用。因此，注册表的文件将存储在主机上的 /var/lib/registry 文件夹中。
- en: 'On all of the machines that you want to access this registry, add the following
    to your daemon options (where `HOSTNAME` is the hostname or IP address of your
    new registry server): `--insecure-registry HOSTNAME` (see [appendix B](kindle_split_035.xhtml#app02)
    for details on how to do this). You can now issue the following command: `docker
    push HOSTNAME:5000/ image:tag`.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有你想访问此注册表的机器上，将以下内容添加到你的守护进程选项中（其中 `HOSTNAME` 是你的新注册表服务器的主机名或 IP 地址）：`--insecure-registry
    HOSTNAME`（有关如何操作的详细信息，请参阅[附录 B](kindle_split_035.xhtml#app02)）。你现在可以发出以下命令：`docker
    push HOSTNAME:5000/image:tag`。
- en: As you can see, the most basic level of configuration for a local registry,
    with all data stored in the $HOME/registry directory, is simple. If you wanted
    to scale up or make it more robust, the repository on GitHub ([https://github.com/docker/distribution/blob/v2.2.1/docs/storagedrivers.md](https://github.com/docker/distribution/blob/v2.2.1/docs/storagedrivers.md))
    outlines some options, like storing data in Amazon S3.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，本地注册表最基本的配置级别，所有数据都存储在 `$HOME/registry` 目录中，是简单的。如果你想扩展或使其更健壮，GitHub 上的存储库（[https://github.com/docker/distribution/blob/v2.2.1/docs/storagedrivers.md](https://github.com/docker/distribution/blob/v2.2.1/docs/storagedrivers.md)）概述了一些选项，例如在
    Amazon S3 中存储数据。
- en: You may be wondering about the `--insecure-registry` option. In order to help
    users remain secure, Docker will only allow you to pull from registries with a
    signed HTTPS certificate. We’ve overridden this because we’re fairly comfortable
    that we can trust our local network. It goes without saying, though, that you
    should be much more cautious about doing this over the internet.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道 `--insecure-registry` 选项。为了帮助用户保持安全，Docker 只允许你从具有签名 HTTPS 证书的注册表拉取。我们已经覆盖了这一点，因为我们相当确信我们可以信任我们的本地网络。不过，不用说，你在互联网上做这件事应该更加谨慎。
- en: '**DISCUSSION**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: With registries being so easy to set up, a number of possibilities arise. If
    your company has a number of teams, you might suggest that everyone start up and
    maintain a registry on a spare machine to permit some fluidity in storing images
    and moving them around.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 由于注册表设置起来非常简单，因此出现了许多可能性。如果你的公司有多个团队，你可能会建议每个人在备用机器上启动并维护一个注册表，以便在存储镜像和移动它们时具有一定的灵活性。
- en: This works particularly well if you have an internal IP address range—the `--insecure
    -registry` command will accept CIDR notation, like `10.1.0.0/16`, for specifying
    a range of IP addresses that are permitted to be insecure. If you’re not familiar
    with this, we highly recommend you get in touch with your network administrator.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个内部 IP 地址范围，这特别有效——`--insecure-registry` 命令将接受 CIDR 表示法，例如 `10.1.0.0/16`，用于指定允许不安全的
    IP 地址范围。如果你不熟悉这个，我们强烈建议你联系你的网络管理员。
- en: '|  |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.5\. The Docker Hub
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5\. Docker Hub
- en: The Docker Hub (see [figure 2.10](#ch02fig10)) is a registry maintained by Docker
    Inc. It has tens of thousands of images on it ready to download and run. Any Docker
    user can set up a free account and store public Docker images there. In addition
    to user-supplied images, official images are maintained for reference purposes.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub（见[图 2.10](#ch02fig10)）是由 Docker Inc. 维护的注册表。它上面有数万个可供下载和运行的镜像。任何
    Docker 用户都可以设置一个免费账户，并将公共 Docker 镜像存储在那里。除了用户提供的镜像外，还维护了官方镜像以供参考。
- en: Figure 2.10\. The Docker Hub
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.10\. Docker Hub
- en: '![](Images/02fig10_alt.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig10_alt.jpg)'
- en: Your images are protected by user authentication, and there’s a starring system
    for popularity, similar to GitHub’s. The official images can be representations
    of Linux distributions like Ubuntu or CentOS, preinstalled software packages like
    Node.js, or whole software stacks like WordPress.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你的镜像通过用户身份验证得到保护，还有一个类似 GitHub 的星级系统来衡量流行度。官方镜像可以是像 Ubuntu 或 CentOS 这样的 Linux
    发行版，预安装的软件包如 Node.js，或者像 WordPress 这样的完整软件栈。
- en: '|  |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Finding and running a Docker image**'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找和运行 Docker 镜像**'
- en: Docker registries enable a social coding culture similar to GitHub’s. If you’re
    interested in trying out a new software application, or looking for a new one
    that serves a particular purpose, Docker images can be an easy way to experiment
    without interfering with your host machine, provisioning a VM, or having to worry
    about installation steps.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 仓库支持类似于 GitHub 的社交编码文化。如果您想尝试新的软件应用程序，或者寻找一个特定目的的新应用程序，Docker 镜像可以是一个简单的方法来实验，而不会干扰您的宿主机，配置虚拟机，或者担心安装步骤。
- en: '**PROBLEM**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to find an application or tool as a Docker image and try it out.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要找到一个作为 Docker 镜像的应用程序或工具并尝试使用它。
- en: '**SOLUTION**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the `docker search` command to find the image to pull, and then run it.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker search` 命令查找要拉取的镜像，然后运行它。
- en: 'Let’s say you’re interested in playing with Node.js. In the following example
    we searched for images matching “node” with the `docker search` command:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您对 Node.js 感兴趣。在以下示例中，我们使用 `docker search` 命令搜索了匹配“node”的镜像：
- en: '[PRE29]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1*** **The output of docker search is ordered by the number of stars.**'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **`docker search` 的输出按星级数量排序。**'
- en: '***2*** **The description is the uploader’s explanation of the purpose of the
    image.**'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **描述是上传者对镜像目的的解释。**'
- en: '***3*** **Official images are those trusted by Docker Hub.**'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **官方镜像是指 Docker Hub 信任的镜像。**'
- en: '***4*** **Automated images are those built using Docker Hub’s automated build
    feature.**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **自动构建的镜像是指使用 Docker Hub 的自动构建功能构建的镜像。**'
- en: 'Once you’ve chosen an image, you can download it by performing a `docker pull`
    command on the name:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您选择了一个镜像，您可以通过在名称上执行 `docker pull` 命令来下载它：
- en: '[PRE30]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1*** **Pulls the image named `node` from the Docker Hub**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从 Docker Hub 拉取名为 `node` 的镜像**'
- en: '***2*** **This message is seen if Docker has pulled a new image (as opposed
    to identifying that there’s no newer image than the one you already have). Your
    output may be different.**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果 Docker 拉取了新的镜像（而不是确定您已经拥有的镜像没有更新的镜像），您将看到此消息。您的输出可能会有所不同。**'
- en: 'Then you can run it interactively using the `-t` and `-i` flags. The `-t` flag
    creates a TTY device (a terminal) for you, and the `-i` flag specifies that this
    Docker session is interactive:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用 `-t` 和 `-i` 标志交互式地运行它。`-t` 标志为您创建一个 TTY 设备（一个终端），而 `-i` 标志指定此 Docker
    会话是交互式的：
- en: '[PRE31]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You can save keystrokes by replacing `-t -i` with `-ti` or `-it` in the preceding
    call to `docker run`. You’ll see this throughout the book from here on.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在先前的 `docker run` 调用中将 `-t -i` 替换为 `-ti` 或 `-it` 来节省按键。从现在起，您将在本书中看到这一点。
- en: '|  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Often there will be specific advice from the image maintainers about how the
    image should be run. Searching for the image on the [http://hub.docker.com](http://hub.docker.com)
    website will take you to the page for the image. The Description tab may give
    you more information.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，镜像维护者会有关于如何运行镜像的具体建议。在 [http://hub.docker.com](http://hub.docker.com) 网站上搜索镜像将带您到镜像的页面。描述标签可能会提供更多信息。
- en: '|  |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**警告**'
- en: If you download an image and run it, you’re running code that you may not be
    able to fully verify. Although there is relative safety in using trusted images,
    nothing can guarantee 100% security when downloading and running software over
    the internet.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您下载了一个镜像并运行它，您正在运行可能无法完全验证的代码。尽管使用受信任的镜像相对安全，但在互联网上下载和运行软件时，没有任何东西可以保证100%的安全性。
- en: '|  |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Armed with this knowledge and experience, you can now tap the enormous resources
    available on Docker Hub. With literally tens of thousands of images to try out,
    there’s much to learn. Enjoy!
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识和经验，您现在可以充分利用 Docker Hub 上的丰富资源。实际上有成千上万的镜像可以尝试，有很多东西可以学习。享受吧！
- en: '**DISCUSSION**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Docker Hub is an excellent resource, but sometimes it can be slow—it’s worth
    pausing to decide how to best construct your Docker search command to get the
    best results. The ability to do searches without opening your browser offers you
    quick insight into possible items of interest in the ecosystem, so you can better
    target the documentation for images that are likely to fulfill your needs.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 是一个极好的资源，但有时它可能很慢——值得停下来决定如何最好地构建您的 Docker 搜索命令以获得最佳结果。无需打开浏览器即可进行搜索的能力，让您能够快速了解生态系统中可能感兴趣的项目，因此您可以更好地针对可能满足您需求的镜像的文档。
- en: When you’re rebuilding images, it can also be good to run a search every now
    and again to see if a stars count suggests that the Docker community has begun
    to gather around a different image than the one you’re currently using.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当您正在重建镜像时，偶尔运行一次搜索以查看星星数量是否表明 Docker 社区已经开始围绕您当前使用的不同镜像聚集也是有益的。
- en: '|  |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You can open up the Docker daemon API to outsiders, and all they need is some
    way to make a HTTP request—a web browser is enough.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将 Docker 守护进程 API 对外开放，他们只需要一种方式来发起 HTTP 请求——一个网页浏览器就足够了。
- en: Containers don’t have to take over your terminal. You can start them up in the
    background and come back to them later.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器不必接管您的终端。您可以在后台启动它们，稍后再回来处理。
- en: You can make containers communicate, either with user-defined networks (the
    recommended approach), or with links to very explicitly control inter-container
    communication.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使容器通过用户定义的网络（推荐方法）或通过链接进行通信，以非常明确地控制容器间的通信。
- en: Because the Docker daemon API is over HTTP, it’s fairly easy to debug it with
    network monitoring tools if you’re having issues.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 Docker 守护进程 API 通过 HTTP，如果您遇到问题，使用网络监控工具调试它相对容易。
- en: One particularly useful tool for debugging and tracing network calls is `socat`.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个特别有用的调试和跟踪网络调用的工具是 `socat`。
- en: Setting up registries isn’t just the domain of Docker Inc.; you can set up your
    own on a local network for free private image storage.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置注册表不仅仅是 Docker Inc. 的领域；您可以在本地网络上免费设置自己的注册表以存储私有镜像。
- en: Docker Hub is a great place to go to find and download ready-made images, particularly
    ones provided officially by Docker Inc.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Hub 是一个寻找和下载现成镜像的好地方，尤其是那些由 Docker Inc. 正式提供的镜像。
