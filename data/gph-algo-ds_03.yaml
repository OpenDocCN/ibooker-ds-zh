- en: '2 Representing network structure: Designing your first graph model'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 表示网络结构：设计你的第一个图模型
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing the learning path to mastering graph algorithms and data science
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍掌握图算法和数据科学的学习路径
- en: Getting familiar with basic graph terminology
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉基本的图术语
- en: Labeled-property graph model schema design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签属性图模型架构设计
- en: Extracting information from tweets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从推文中提取信息
- en: Figure 2.1 illustrates how I envision the learning path to becoming a versatile
    and experienced graph data practitioner and scientist. This book will take you
    along this exciting path.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1展示了我是如何设想成为一名多才多艺且经验丰富的图数据实践者和科学家的学习路径。这本书将带你沿着这条激动人心的道路前进。
- en: '![02-01](../../OEBPS/Images/02-01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![02-01](../../OEBPS/Images/02-01.png)'
- en: Figure 2.1 Learning path to mastering graph algorithms and data science
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 掌握图算法和数据科学的学习路径
- en: The path illustrated in figure 2.1 takes a bottom-up approach, where you will
    first learn to describe the data for your domain as a graph, encompassing modeling
    and constructing a graph. Next, you will learn to identify, retrieve, and aggregate
    various graph patterns. Once the basics are out of the way, you will dig into
    descriptive graph analytics, which can help you understand the current state of
    the graph. In the last couple of chapters, you will learn how to combine all the
    previous lessons and apply them to predict new patterns in the graph.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1中展示的路径采用自下而上的方法，你将首先学习如何将你领域的数据描述为图，包括建模和构建图。接下来，你将学习如何识别、检索和聚合各种图模式。一旦基础知识掌握，你将深入研究描述性图分析，这有助于你理解图当前的状态。在最后几章中，你将学习如何结合所有之前的课程并将其应用于预测图中的新模式。
- en: 'The learning path consists of four major milestones:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 学习路径包括四个主要里程碑：
- en: Graph modeling and construction
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图建模和构建
- en: Graph query language
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图查询语言
- en: Graph algorithms and inferred networks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图算法和推断网络
- en: Graph machine learning
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图机器学习
- en: The first step is to identify graph-shaped problems and represent your data
    as a graph. I have already touched on how to spot use cases that fit a graph-based
    approach in the previous chapter. In this chapter, you will begin by learning
    how to describe a particular graph structure and how it varies between different
    datasets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是识别图形化问题，并将你的数据表示为图。我在上一章已经提到了如何识别适合基于图的方法的使用案例。在本章中，你将首先学习如何描述特定的图结构以及它在不同的数据集中是如何变化的。
- en: The first milestone is understanding how to approach graph modeling and importing
    a dataset into a graph database. While various graph databases use different underlying
    graph models, I think it is best to focus on one and try to master it; otherwise,
    I could dedicate a couple of chapters to the differences between graph models.
    Since I want to get to practical applications and analysis quickly, you will learn
    how to model and import data only as a *labeled-property graph (LPG) model*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个里程碑是理解如何进行图建模并将数据集导入图数据库。虽然不同的图数据库使用不同的底层图模型，但我认为最好专注于一个并努力掌握它；否则，我可能需要用几章的篇幅来介绍图模型之间的差异。由于我希望快速进入实际应用和分析，你将学习如何仅作为*标签属性图（LPG）模型*来建模和导入数据。
- en: The most widely adopted graph query language to interact with the LPG model
    is *Cypher query language*. Cypher query language was developed by Neo4j and has
    been since adopted by Amazon Neptune, AgensGraph, Katana Graph, Memgraph, RedisGraph,
    and SAP HANA ([https://opencypher.org/projects/](https://opencypher.org/projects/)).
    Cypher query language can be used to read from the LPG database as well as import
    and transform data. In the third chapter, you will learn Cypher’s basics, allowing
    you to construct your first graph. Your first graph will represent the Twitter
    social network, which will be used in chapter 4 to teach you how to perform exploratory
    data analysis with Cypher query language. Learning about and understanding the
    syntax of Cypher query language will help you reach the second milestone of mastering
    graph algorithms and data science, where you will be able to identify and retrieve
    graph patterns, traverse connections, aggregate data, and perform exploratory
    data analysis.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与LPG模型交互的最广泛采用的图查询语言是*Cypher查询语言*。Cypher查询语言由Neo4j开发，并被Amazon Neptune、AgensGraph、Katana
    Graph、Memgraph、RedisGraph和SAP HANA采用([https://opencypher.org/projects/](https://opencypher.org/projects/))。Cypher查询语言可以用来从LPG数据库中读取数据，以及导入和转换数据。在第三章中，你将学习Cypher的基础知识，这将使你能够构建你的第一个图。你的第一个图将代表Twitter社交网络，它将在第四章中用来教你如何使用Cypher查询语言进行探索性数据分析。了解并理解Cypher查询语言的语法将帮助你达到掌握图算法和数据科学的第二个里程碑，届时你将能够识别和检索图模式，遍历连接，聚合数据，并执行探索性数据分析。
- en: The third milestone concerns introducing and understanding graph algorithms.
    In this section of the book, you will learn how to use graph algorithms to describe
    the current state of the graph and extract valuable insights. There are several
    categories of graph algorithms. For example, you can use centrality algorithms
    to identify the most important or influential nodes. On the other hand, you can
    use community detection or clustering algorithms to recognize highly interconnected
    groups of nodes. One interesting fact about graph algorithms is that most have
    a predetermined graph shape that works best as an input. In practice, you do not
    adjust graph algorithms to fit your data but, rather, transform your data to provide
    the correct algorithm input. You will learn that most centrality and community
    detection algorithms were designed to take a graph with a single node and relationship
    type as input; however, you will frequently deal with graphs with multiple node
    or relationship types. Therefore, you need to learn techniques that will help
    you transform various graphs into shapes expected by the graph algorithms.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个里程碑是介绍和理解图算法。在本书的这一部分，你将学习如何使用图算法来描述图的当前状态并提取有价值的见解。图算法有几个类别。例如，你可以使用中心性算法来识别最重要的或最有影响力的节点。另一方面，你可以使用社区检测或聚类算法来识别高度相互连接的节点组。关于图算法的一个有趣的事实是，大多数都有预定的最佳输入图形状。在实践中，你不会调整图算法以适应你的数据，而是将你的数据转换为提供正确的算法输入。你会发现，大多数中心性和社区检测算法都是设计用来接受一个包含单个节点和关系类型的图的；然而，你将经常处理包含多个节点或关系类型的图。因此，你需要学习帮助你将各种图转换为图算法期望的形状的技术。
- en: This idea is not unique to graph algorithms and is also true for most traditional
    machine learning and data science algorithms. Data science and machine learning
    practitioners know that feature engineering or data wrangling represents most
    of the workload in an analytical or machine learning workflow—and dealing with
    graphs and graph algorithms is no exception. Having to perform data transformations
    before executing algorithms is also one of the reasons I recommend using a graph
    database to store your data. Most graph databases have a graph query language
    or other built-in tools that can help you perform the required data transformations
    optimally. Chapters 5, 6, and 7 are dedicated to teaching you various techniques
    on how to transform or *infer* graph structures that best fit the graph algorithms
    you want to execute.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种想法不仅限于图算法，对于大多数传统的机器学习和数据科学算法也是正确的。数据科学和机器学习从业者知道，特征工程或数据处理代表了分析或机器学习工作流程中的大部分工作量——处理图和图算法也不例外。在执行算法之前必须进行数据转换也是我推荐使用图数据库存储数据的原因之一。大多数图数据库都有图查询语言或其他内置工具，可以帮助你以最佳方式执行所需的数据转换。第五章、第六章和第七章致力于教你各种技术，教你如何转换或*推断*最适合你想要执行的图算法的图结构。
- en: I have deliberately split graph algorithms and graph machine learning into the
    third and fourth milestones. In theory, some graph algorithms could also be referred
    to as *graph machine learning tools*. The term *graph machine learning* is used
    in this book to refer to workflows in which you predict or classify missing values
    or future behavior. On the other hand, the term *graph algorithms* is used to
    refer to descriptive analytics like community detection and centrality algorithms.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意将图算法和图机器学习分为第三和第四个里程碑。从理论上讲，一些图算法也可以被称为*图机器学习工具*。本书中使用的术语*图机器学习*指的是预测或分类缺失值或未来行为的流程。另一方面，术语*图算法*用于描述描述性分析，如社区检测和中心性算法。
- en: The workflow behind graph machine learning is very similar to traditional machine
    learning workflows, in which you train a model to help you solve the specified
    task. The major difference between the traditional and graph-based approaches
    is how to construct the machine learning model features. In general, there are
    two approaches to extracting machine learning model features from a graph. The
    first option is to take the manual approach and define the relevant and predictive
    features. For example, you could use Cypher query language to describe features
    or use the output of community detection or centrality graph algorithms. The second
    option is to utilize embedding models that “automagically” encode the network
    structure as a vector that can be fed into an machine learning model. In chapters
    8 through 11, you will learn how to extract and incorporate graph features in
    a downstream machine learning workflow.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图机器学习背后的工作流程与传统机器学习工作流程非常相似，其中你训练一个模型来帮助你解决指定的任务。传统方法与基于图的方法之间的主要区别在于如何构建机器学习模型特征。一般来说，从图中提取机器学习模型特征有两种方法。第一种方法是采取手动方法，定义相关和预测特征。例如，你可以使用Cypher查询语言来描述特征或使用社区检测或中心性图算法的输出。第二种方法是利用嵌入模型，这些模型“自动”将网络结构编码为可以输入到机器学习模型中的向量。在第8章到第11章中，你将学习如何从下游机器学习工作流程中提取和整合图特征。
- en: As a bonus, you will learn how to use Natural Language Processing (NLP) techniques
    to construct a graph in the final chapter. Specifically, you will use named entity
    recognition (NER) and relation extraction (RE) tools to extract relevant information
    from a text and store the output as a graph. Let’s take the first step on the
    path to mastering graph algorithms and data science.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外收获，你将在最后一章学习如何使用自然语言处理（NLP）技术构建一个图。具体来说，你将使用命名实体识别（NER）和关系抽取（RE）工具从文本中提取相关信息，并将输出存储为图。让我们迈出掌握图算法和数据科学道路的第一步。
- en: 2.1 Graph terminology
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 图术语
- en: We’ll start our journey by learning some basic graph theory terminology. This
    section aims to teach you the language required to describe a graph you have at
    hand.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从学习一些基本的图理论术语开始我们的旅程。本节旨在教你描述你手头上的图的所需语言。
- en: 2.1.1 Directed vs. undirected graph
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 有向图与无向图
- en: Figure 2.2(A) is an example of a directed graph, where the direction of the
    relationship plays an important role. A real-world example of a directed graph
    is Twitter, on which a user can follow other users that don’t necessarily follow
    them back. In this example, Mark’s post will show up on both Jane and Ingrid’s
    feed. On the other hand, Mark will see no posts from either Jane or Ingrid, as
    he does not follow them. Figure 2.2(B) shows an undirected graph, where the relationship
    direction is not essential. An *undirected* or a *bidirected relationship* represents
    a connection between two entities that can be traversed in both directions. This
    example could be used to represent Facebook, where a friendship relationship exists
    only if both parties agree to it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2（A）是一个有向图的例子，其中关系方向起着重要作用。有向图的真实世界例子是Twitter，用户可以关注其他用户，而这些用户不一定关注他们。在这个例子中，马克的帖子将出现在简和英格丽德的动态中。另一方面，马克将看不到简或英格丽德的任何帖子，因为他没有关注他们。图2.2（B）显示了一个无向图，其中关系方向不是必要的。一个*无向*或*双向关系*表示两个实体之间的连接，可以在两个方向上遍历。这个例子可以用来表示Facebook，其中只有当双方都同意时，才存在友谊关系。
- en: '![02-02](../../OEBPS/Images/02-02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![02-02](../../OEBPS/Images/02-02.png)'
- en: Figure 2.2 (A) represents a directed graph; (B) represents an undirected graph.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2（A）表示一个有向图；（B）表示一个无向图。
- en: The notion that every undirected graph can be represented as a directed graph
    is a crucial concept that will be relevant further down the line. You can simply
    replace every undirected connection with two directed links in opposite directions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个无向图都可以表示为有向图的观点是一个关键概念，它将在后续内容中变得相关。你可以简单地用两个方向相反的有向链接来替换每个无向连接。
- en: In the context of graph algorithms, an undirected relationship allows traversal
    in both directions, while a directed one allows traversal in only a single direction.
    For example, in figure 2.3(A), you can traverse the undirected connection from
    Mark to Jane and back. To mimic this functionality in a directed graph, you would
    create two relationships that point in opposite directions. In figure 2.3(B),
    having directed relationships in both directions allows you to traverse from Mark
    to Jane and back. This concept will be essential to understanding graph algorithms’
    input.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在图算法的上下文中，无向关系允许双向遍历，而有向关系只允许单向遍历。例如，在图2.3(A)中，你可以遍历从马克到简的无向连接并返回。要在有向图中模拟此功能，你需要创建两个指向相反方向的关系。在图2.3(B)中，双向有向关系允许你从马克到简并返回。这个概念对于理解图算法的输入至关重要。
- en: '![02-03](../../OEBPS/Images/02-03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![02-03](../../OEBPS/Images/02-03.png)'
- en: Figure 2.3 (A) represents an undirected graph; (B) represents a directed graph
    equivalent of the undirected graph.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 (A)表示一个无向图；(B)表示无向图的等价有向图。
- en: Note In the context of graph algorithms, the traversal of a directed relationship
    in the opposite direction is typically not permissible. However, in graph databases,
    the flexibility of Cypher query language allows for the traversal of directed
    relationships in both directions, making it a versatile tool for navigating complex
    relational data structures.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 在图算法的上下文中，通常不允许在相反方向上遍历有向关系。然而，在图数据库中，Cypher查询语言的灵活性允许遍历有向关系的两个方向，使其成为导航复杂关系数据结构的多功能工具。
- en: 2.1.2 Weighted vs. unweighted graphs
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 加权图与无权图
- en: In an unweighted graph, figure 2.4(A), all relationships have the same strength
    or associated cost of traversing assigned to them. The notion of stronger or weaker
    relationships does not exist within an unweighted graph. On the other hand, figure
    2.4(B) depicts a weighted graph, where the strength or the cost of traversing
    the relationships is stored as an attribute (the weight must be a number). In
    this example, the connection between Jane and Ingrid is stronger than the relationship
    between Ingrid and Mark. Depending on the domain, sometimes a higher weight value
    is better, while other times a smaller weight value is preferred. In the example
    in figure 2.4(B), a higher weight is preferred, as it indicates a stronger friendship
    relationship. On the other hand, a smaller weight value is preferred in a transportation
    network, which is a typical application for using a weighted graph, where you
    are searching for the shortest weighted path between a pair of nodes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在无权图中，如图2.4(A)所示，所有关系都具有相同的强度或关联的穿越成本。在无权图中不存在更强或更弱的关系的概念。另一方面，图2.4(B)展示了一个加权图，其中穿越关系的强度或成本被存储为属性（权重必须是数字）。在这个例子中，简和英格丽德的连接比英格丽德和马克的关系更强。根据领域不同，有时更高的权重值更好，而有时更小的权重值更受欢迎。在图2.4(B)的例子中，较高的权重更受欢迎，因为它表明了更强的友谊关系。另一方面，在交通网络中，较小的权重值更受欢迎，这是使用加权图的典型应用，你正在寻找一对节点之间的最短加权路径。
- en: '![02-04](../../OEBPS/Images/02-04.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![02-04](../../OEBPS/Images/02-04.png)'
- en: Figure 2.4 (A) represents an unweighted graph; (B) represents a weighted graph.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 (A)表示一个无权图；(B)表示一个加权图。
- en: 2.1.3 Bipartite vs. monopartite graphs
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 二部图与单部图
- en: A monopartite graph describes a graph that consists of a single type or class
    of nodes. In figure 2.5(A), you can observe a monopartite graph containing only
    a single class of nodes representing persons. As previously mentioned, most graph
    algorithms are designed to take monopartite graphs as input. The graph in figure
    2.5(B) contains two nodes representing persons and a single node representing
    an organization. As two sets of nodes are present, you can describe this graph
    as bipartite. Additionally, in a bipartite graph, the relationships always start
    from one set of nodes and end at the other.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 单部图描述的是由单个类型或类别的节点组成的图。在图2.5（A）中，你可以观察到只包含代表个人的单个类别的节点的单部图。如前所述，大多数图算法都是设计为以单部图为输入的。图2.5（B）包含代表个人和代表一个组织的两个节点。由于存在两组节点，你可以将此图描述为二部图。此外，在二部图中，关系总是从一组节点开始，并在另一组节点结束。
- en: '![02-05](../../OEBPS/Images/02-05.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![02-05](../../OEBPS/Images/02-05.png)'
- en: Figure 2.5 (A) represents a monopartite graph; (B) represents a bipartite graph.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5（A）表示一个单部图；（B）表示一个二部图。
- en: In the example in figure 2.5(B), there are only relationships from persons to
    organizations—not between persons or between organizations. Bipartite graphs are
    common in the real world; many user-item interactions can be represented as a
    graph. For example, on Netflix, a user can rate movies. Both users and movies
    are represented as nodes, and the rating is described as a relationship. Another
    example would be the Amazon Marketplace, in which customers can buy various items.
    Here, customers and products are represented as nodes, and the relationship indicates
    which items a customer purchased.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在图2.5（B）的示例中，只有从人到组织的关联关系——而不是人与人之间或组织与组织之间的关联。二部图在现实世界中很常见；许多用户-项目交互可以表示为图。例如，在Netflix上，用户可以对电影进行评分。用户和电影都表示为节点，评分被描述为一种关系。另一个例子是亚马逊市场，在这里，客户可以购买各种商品。在这里，客户和产品都表示为节点，关系表示客户购买了哪些商品。
- en: 2.1.4 Multigraph vs. simple graph
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 多重图与简单图
- en: A simple graph, as depicted in figure 2.6(A), permits only a single relationship
    between a pair of nodes in each direction. There are many use cases in which you
    want to permit multiple relationships between a pair of nodes. In those cases,
    you would be dealing with a multigraph. An example multigraph is shown in figure
    2.6(B).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 简单图，如图2.6（A）所示，在每个方向上只允许一对节点之间有一个关系。有许多用例中，你希望在一对节点之间允许多个关系。在这些情况下，你将处理多重图。图2.6（B）显示了多重图的一个例子。
- en: '![02-06](../../OEBPS/Images/02-06.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![02-06](../../OEBPS/Images/02-06.png)'
- en: Figure 2.6 (A) represents a simple graph; (B) represents a multigraph.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6（A）表示一个简单图；（B）表示一个多重图。
- en: 2.1.5 A complete graph
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.5 完全图
- en: A complete graph is a graph in which each node is connected to all the other
    nodes (figure 2.7).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完全图是一个图中每个节点都与其他所有节点相连的图（见图2.7）。
- en: '![02-07](../../OEBPS/Images/02-07.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![02-07](../../OEBPS/Images/02-07.png)'
- en: Figure 2.7 A complete graph
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 完全图
- en: 2.2 Network representations
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 网络表示
- en: 'Before you learn more about the LPG model, you will also look at the text representation
    of simple networks. The text representation of networks comes in handy when you
    want to communicate the network structure via text quickly. We will borrow the
    syntax from Cypher query language. Cypher’s syntax provides a visual way to match
    patterns of nodes and relationships in the graph using ASCII art syntax. Its syntax
    describing nodes and relationships is also the basis for the future Graph Query
    Language (GQL; [https://www.gqlstandards.org/home](https://www.gqlstandards.org/home)),
    which aims to unify the graph-pattern query language the same way SQL did for
    relational databases. An example node representation in Cypher looks like the
    following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在你学习更多关于LPG模型之前，你还将查看简单网络的文本表示。当你想要通过文本快速传达网络结构时，网络文本表示非常有用。我们将借鉴Cypher查询语言的语法。Cypher的语法提供了使用ASCII艺术语法匹配图中节点和关系模式的一种视觉方式。它描述节点和关系的语法也是未来图查询语言（GQL；[https://www.gqlstandards.org/home](https://www.gqlstandards.org/home)）的基础，该语言旨在统一图模式查询语言，就像SQL对关系数据库所做的那样。Cypher中节点表示的一个例子如下所示：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To depict nodes in Cypher, surround a node with parentheses—for example, `(node)`.
    The colon is used to describe the type or a label of a node. In the preceding
    example, the node label is defined as `Person`. Nodes can also have properties,
    which are depicted as key-value pairs inside the brackets of a node. There is
    a single key-value pair inside the curly brackets, `{name:"Thomas"}`, that represents
    the name property of the node.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cypher中描述节点时，用括号包围节点——例如，`(node)`。冒号用于描述节点类型或标签。在前面的例子中，节点标签被定义为`Person`。节点也可以有属性，这些属性以节点括号内的键值对表示。花括号内有一个键值对`{name:"Thomas"}`，它表示节点的名称属性。
- en: 'Relationships in Cypher are surrounded with a square bracket:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Cypher中的关系被方括号包围：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Like nodes, you describe the type of the relationship with a colon. Relationships
    can also have properties defined as key-value pairs inside curly brackets. A relationship
    can never exist in solitude without existing source and target nodes. For example,
    you can specify a simple friendship network with the following syntax:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与节点类似，您可以使用冒号来描述关系的类型。关系也可以在花括号内定义为键值对属性。一个关系不能在没有存在源节点和目标节点的情况下独立存在。例如，您可以使用以下语法指定一个简单的友谊网络：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This Cypher syntax describes a friendship relationship between Thomas and Elaine
    and can be visualized as the network shown in figure 2.8.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此Cypher语法描述了Thomas和Elaine之间的友谊关系，可以如图2.8所示的网络可视化。
- en: '![02-08](../../OEBPS/Images/02-08.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![02-08](../../OEBPS/Images/02-08.png)'
- en: Figure 2.8 Example friendship network between Thomas and Elaine
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 Thomas和Elaine之间的示例友谊网络
- en: 'Thomas and Elaine are people who have been friends since 2016\. If you look
    carefully, you can observe a direction indicator of the relationship at the end
    of the text representation. With it, you can differentiate between directed and
    undirected relationships. If you want to describe the friendship relationship
    as *undirected*, all you have to do is omit the relationship direction indicator:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Thomas和Elaine是自2016年以来一直是朋友的人。如果您仔细观察，您可以在文本表示的末尾观察到关系的方向指示符。有了它，您可以区分有向和无向关系。如果您想将友谊关系描述为*无向的*，您只需省略关系方向指示符即可：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I need to add a small disclaimer here. Many of the graph databases don’t directly
    support storing undirected relationships. However, Cypher query language supports
    undirected querying, meaning the direction of the relationships is ignored during
    query runtime. You will learn how to store undirected relationships in the next
    section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要在这里做一个小的声明。许多图数据库不支持直接存储无向关系。然而，Cypher查询语言支持无向查询，这意味着在查询运行时忽略关系的方向。您将在下一节中学习如何存储无向关系。
- en: Exercise 2.1
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.1
- en: 'Try to represent the relation between you and your employer using Cypher syntax.
    There are two types of nodes present in this graph pattern: a person and an organization
    or a business. You can also add additional node or relationship properties as
    you see fit.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用Cypher语法表示您与雇主之间的关系。此图模式中存在两种类型的节点：一个人和一个组织或企业。您还可以根据需要添加额外的节点或关系属性。
- en: 'I could describe my relationship with Manning Publications using the following
    Cypher syntax:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用以下Cypher语法描述我与Manning Publications的关系：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 2.2.1 Labeled-property graph model
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 标签属性图模型
- en: The *labeled-property graph model* (LPG) is one of the graph models used by
    graph databases. As mentioned, we will use only the LPG model in this book, as
    the focus is to teach you how to solve and analyze practical problems—not to compare
    different graph models. I have alluded to the LPG structure a bit in the previous
    section, where I introduced Cypher text representation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*标签属性图模型*（LPG）是图数据库使用的图模型之一。如前所述，我们将在这本书中仅使用LPG模型，因为重点是教授您如何解决和分析实际问题——而不是比较不同的图模型。在前一节中，我简要介绍了LPG结构，其中我介绍了Cypher文本表示。'
- en: Nodes have a special type of property called a *label*, which is used to represent
    node roles in your domain. For example, you could use the label to categorize
    whether a node represents a person or an organization. Both nodes and relationships
    can have properties stored as key-value pairs, such as the name of a person as
    a node property or starting date as relationship property in the previous Cypher
    text representation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 节点有一种特殊的属性类型，称为**标签**，用于表示你领域中的节点角色。例如，你可以使用标签来分类节点是否代表一个人或一个组织。节点和关系都可以存储为键值对属性，例如人的名字作为节点属性或起始日期作为之前Cypher文本表示中的关系属性。
- en: 'It is important to note that all relationships in the LPG model are directed
    and have a single type assigned to them. The type of relationship gives it semantic
    meaning. So far, the examples used `FRIEND` and `WRITES_FOR` as relationship types.
    Interestingly, with the `WRITES_FOR` relationship, the direction of the connection
    is crucial to accurately describe the semantics:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，LPG模型中的所有关系都是有向的，并且分配了单个类型。关系类型赋予它语义意义。到目前为止，使用的例子使用了`FRIEND`和`WRITES_FOR`作为关系类型。有趣的是，使用`WRITES_FOR`关系，连接的方向对于准确描述语义至关重要：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If I were to reverse the connection direction, my relationship with Manning
    Publications would have significantly different semantics. On the other hand,
    there are some scenarios where the relationship direction is not so important:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我反转连接方向，我与Manning Publications的关系的语义将显著不同。另一方面，有些场景中关系方向并不那么重要：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, where I reversed the relationship direction, the semantics
    are not as different, as the friendship is usually *bidirectional*. What do I
    mean by that? When I am friends with someone, that typically implies that they
    are also friends with me. A bidirectional relationship can also be regarded as
    *undirected*. I cannot speak for all graph databases but specifically for Neo4j:
    when storing relationships with bidirectional or undirected semantics, such as
    friendship, it is enough to create a single directed connection between the two
    persons, as the relationship also implies the connection in the opposite direction.
    With Cypher query language, you can ignore the direction of the relationship you
    want to traverse. You will learn more about this through practical examples.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我反转了关系方向，语义并没有那么不同，因为友谊通常是**双向的**。我这是什么意思呢？当我与某人成为朋友时，这通常意味着他们也是我的朋友。双向关系也可以被视为**无向的**。我无法代表所有图数据库，但具体来说对于Neo4j：当存储具有双向或无向语义的关系，如友谊时，只需要在两个人之间创建一个单一直接连接，因为这种关系也隐含了相反方向上的连接。使用Cypher查询语言，你可以忽略你想要遍历的关系的方向。你将通过实际示例了解更多关于这一点。
- en: 'To demonstrate a simple LPG graph model, let’s try to model the following information
    as a graph:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一个简单的LPG图模型，让我们尝试将以下信息建模为一个图：
- en: Thomas is 40 years old.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托马斯40岁。
- en: Thomas is friends with Elaine.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托马斯是埃莱恩的朋友。
- en: Thomas is a person.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托马斯是一个人。
- en: Elaine is a person.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 埃莱恩是一个人。
- en: In the example in figure 2.9, we use the node label to categorize the nodes
    as persons and store the age information as an internal node property. Since the
    friendship information indicates a real-world relationship between two persons,
    we also model it as a relationship in our graph.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在图2.9的例子中，我们使用节点标签来对节点进行分类，将年龄信息作为内部节点属性存储。由于友谊信息表明了两个人之间的现实世界关系，我们在我们的图中也将它建模为关系。
- en: '![02-09](../../OEBPS/Images/02-09.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![02-09](../../OEBPS/Images/02-09.png)'
- en: Figure 2.9 Labeled-property graph model representing the example data
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9表示示例数据的标签属性图模型
- en: Say you wanted to add information about their phone numbers, social security
    numbers, and addresses to the graph. Usually, you would store literal values like
    social security number as a node property; however, in some domains, you might
    want to represent information like social security numbers or phone numbers as
    separate nodes. A typical example is the fraud detection scenario, where you are
    interested in examining customers who share the same address, social security
    number, or phone number (figure 2.10).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要在图中添加关于他们的电话号码、社会保险号码和地址的信息。通常，你会将像社会保险号码这样的字面值作为节点属性存储；然而，在某些领域，你可能希望将像社会保险号码或电话号码这样的信息表示为单独的节点。一个典型的例子是欺诈检测场景，其中你感兴趣的是检查共享相同地址、社会保险号码或电话号码的客户（图2.10）。
- en: '![02-10](../../OEBPS/Images/02-10.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![02-10](../../OEBPS/Images/02-10.png)'
- en: Figure 2.10 Labeled-property graph model representing a fraud investigation
    domain
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 表示欺诈调查领域的标记属性图模型
- en: The graph model depends on your task, and with the LPG model, you can represent
    a literal value both as an internal node property (key-value pair) as well as
    a separate node. Similarly, you have the option to represent the label as a separate
    node as well. A classic example would be describing class hierarchy with the LPG
    model. In figure 2.11, the graph schema is modified to support class hierarchy
    representation that could, for example, be used in biological domains.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '图模型取决于你的任务，并且使用LPG模型，你可以将字面值既表示为内部节点属性（键值对）也可以表示为单独的节点。同样，你也可以选择将标签表示为单独的节点。一个经典的例子是使用LPG模型描述类层次结构。在图2.11中，图模式被修改以支持类层次结构的表示，这可以用于生物领域，例如。 '
- en: '![02-11](../../OEBPS/Images/02-11.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![02-11](../../OEBPS/Images/02-11.png)'
- en: Figure 2.11 Labeled-property graph model representing a class hierarchy domain
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 表示类层次结构领域的标记属性图模型
- en: As mentioned, the graph model depends on the task you are trying to solve. With
    labeled-property graphs, the abstraction level is nodes, relationships, labels,
    and properties.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，图模型取决于你试图解决的问题。在标记属性图中，抽象级别是节点、关系、标签和属性。
- en: In this book, you will be using an LPG graph database as a source of truth for
    graph analysis. It is completely fine if you want to use other graph models as
    the source of truth in your further graph analysis. However, I won’t go through
    the details of constructing other graph models to best fit your graph analysis
    task in this book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将使用LPG图数据库作为图分析的真相来源。如果你想在进一步的图分析中使用其他图模型作为真相来源，那完全没问题。然而，在这本书中，我不会详细介绍如何构建其他图模型以最佳地适应你的图分析任务。
- en: 2.3 Designing your first labeled-property graph model
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 设计你的第一个标记属性图模型
- en: Now, imagine a scenario in which a client asks you to perform a network analysis
    of Twitter. The client will provide all the relevant data; your task is to represent
    the data as a graph and gain various insights by performing network analysis.
    You will be using the LPG model to represent Twitter. A general approach to graph
    modeling is working backward and starting with the questions you want to answer.
    Here, unfortunately, no specific questions were posed in the assignment. It is
    your job as a network scientist to do your best and find as many insights as possible.
    You can start by trying to describe the domain you have at hand. In the Twitter
    example, the most basic specifications would be
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一个场景，客户要求你进行Twitter的网络分析。客户将提供所有相关数据；你的任务是代表这些数据为图，并通过执行网络分析获得各种见解。你将使用LPG模型来表示Twitter。图建模的一般方法是从你想回答的问题开始，逆向工作。不幸的是，在这个任务中并没有提出具体的问题。作为网络科学家，你的任务是尽你所能，找到尽可能多的见解。你可以从尝试描述你手头的领域开始。在Twitter的例子中，最基本的规定如下
- en: A user can follow other users (follower network).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以关注其他用户（关注者网络）。
- en: A user can publish tweets (user-tweet network).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以发布推文（用户-推文网络）。
- en: A user can retweet posts from other users (retweet network).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以从其他用户那里转发帖子（转发网络）。
- en: In this section, you will learn how to develop an LPG graph model.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何开发一个LPG图模型。
- en: 2.3.1 Follower network
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 跟随者网络
- en: 'On Twitter, you have the option to follow other users. By following users,
    you are subscribing to their activity and indicating that you would like to see
    their tweets on your feed. The follower-network specification is as follows: *A
    user can follow other users.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Twitter上，你有选择关注其他用户的选项。通过关注用户，你正在订阅他们的活动，并表明你希望在自己的信息流中看到他们的推文。关注者网络的规定如下：*用户可以关注其他用户*。
- en: Exercise 2.2
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.2
- en: As an exercise, try to design the follower graph model. As a rule of thumb,
    you would like the entities to be represented as nodes. You can also borrow some
    logic from English grammar. The subject and object of a sentence are often represented
    as nodes, and the verb describes the relationship. Adjectives can be translated
    into properties. When designing a graph model, take into consideration whether
    the direction of a relationship holds semantic value.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，尝试设计跟随者图模型。一般来说，你希望将实体表示为节点。你也可以借鉴一些英语语法中的逻辑。句子的主语和宾语通常表示为节点，而动词描述了它们之间的关系。形容词可以翻译为属性。在设计图模型时，要考虑关系的方向是否具有语义价值。
- en: 'There is no correct or perfect way to design a graph model, but some models
    can be useful for a specific scenario. When you are designing a graph model, try
    to answer the following questions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 设计图模型没有正确或完美的方式，但某些模型可以适用于特定场景。当你设计图模型时，尝试回答以下问题：
- en: How many different types of nodes are present?
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多少种不同的节点类型存在？
- en: What kind of properties do these nodes have?
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些节点有什么样的属性？
- en: Which property would you use to store the unique identifier of nodes?
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会使用哪个属性来存储节点的唯一标识符？
- en: What type of relationships are present?
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有哪些类型的关系存在？
- en: Is a single relationship type enough to accurately describe your domain?
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一的关系类型是否足够准确地描述你的领域？
- en: Does the relationship direction hold any semantic value?
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系的方向是否具有任何语义价值？
- en: How do properties qualify or quantify relationships?
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性是如何确定或量化关系的？
- en: 'In the follower-network specification, both the subject and the object of the
    sentence are users and can be represented as nodes. Relationships can be used
    to represent the verb of the specification sentence. Here, it makes sense to represent
    a follow interaction as a relationship between two users. A single relationship
    pattern from figure 2.12 can be represented with Cypher’s pattern syntax as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在关注网络规范中，句子的主语和宾语都是用户，可以表示为节点。关系可以用来表示规范句子的动词。在这里，将关注交互表示为两个用户之间的关系是有意义的。图2.12中的单个关系模式可以用Cypher的模式语法如下表示：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![02-12](../../OEBPS/Images/02-12.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![02-12](../../OEBPS/Images/02-12.png)'
- en: Figure 2.12 Twitter follower-network model
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 Twitter关注网络模型
- en: Each node in figure 2.12 has the label `User` attached to it. The node label
    is used to categorize nodes that represent users. As there is only a single label
    of nodes present, you are dealing with a monopartite network. A good practice
    is to have an *unique identifier* for node disambiguation in place for all the
    nodes of the network. On Twitter, you can use any user’s Twitter handle as their
    unique identifier. The data also contains the sign-up date for users, which you
    can store as the node’s `registeredAt` property.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12中的每个节点都附有标签`User`。节点标签用于对表示用户的节点进行分类。由于只有一个节点标签，你正在处理一个单部分网络。对于网络中的所有节点，有一个好的做法是有一个*唯一标识符*来区分节点。在Twitter上，你可以使用任何用户的Twitter昵称作为他们的唯一标识符。数据还包含用户的注册日期，你可以将其存储为节点的`registeredAt`属性。
- en: In figure 2.12, you can observe that Kim follows Vanessa, but Vanessa does not
    follow Kim. In other words, Kim will see Vanessa’s tweets on her feed, while Vanessa
    will not see anything from Kim. You can conclude that the direction of the relationships
    holds semantic value, and as a result, you are dealing with a directed network.
    The `FOLLOWS` relationship has no notion of strength assigned to it, which implies
    the Twitter follower network is unweighted. You do, however, know when the relationship
    was created. The information about the relationship creation date can be stored
    as a relationship property.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在图2.12中，你可以观察到Kim关注了Vanessa，但Vanessa没有关注Kim。换句话说，Kim会在她的动态中看到Vanessa的推文，而Vanessa将不会看到来自Kim的任何内容。你可以得出结论，关系的方向具有语义价值，因此你正在处理一个有向网络。`FOLLOWS`关系没有分配任何强度概念，这意味着Twitter关注网络是无权重的。然而，你知道关系的创建时间。关于关系创建日期的信息可以存储为关系属性。
- en: Before continuing, you can examine the types of questions or insights you could
    answer using this graph model. When examining a social network, you may want to
    try to identify influencers. A simple metric to evaluate influencers is a user’s
    direct follower count. The more followers a user has, the more widely their tweets
    will be distributed; however, whether your followers are also influential makes
    a difference. For example, a Fortune 500 CEO following you might be more influential
    than your neighbor.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可以检查使用此图模型可以回答的问题或洞察。在检查社交网络时，你可能想要尝试识别影响者。评估影响者的一个简单指标是用户的直接关注者数量。一个用户拥有的关注者越多，他们的推文传播得越广；然而，你的关注者是否也有影响力则很重要。例如，一个财富500强CEO的关注可能比你的邻居更有影响力。
- en: Likely, the most famous graph algorithm to evaluate the *transitive* influence
    of a node is PageRank. A transitive relationship is an indirect relationship between
    two nodes, where, for example, a node A is connected to node B and node B is connected
    to node C. In this example, node A is not directly related to node C but has an
    indirect relationship through node B, which implies they are transitively connected.
    Suppose a Fortune 500 CEO has more connections than your neighbor. In that case,
    you will gain more transitive relations and, consequently, network influence by
    having a Fortune 500 CEO follow you than by having your neighbor following you.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，用于评估节点*传递性*影响的著名图算法是PageRank。传递性关系是两个节点之间的间接关系，例如，节点A连接到节点B，节点B连接到节点C。在这个例子中，节点A与节点C没有直接关系，但通过节点B存在间接关系，这表明它们是传递性连接的。假设一位财富500强公司的CEO比你的邻居有更多的联系。在这种情况下，如果你有一位财富500强公司的CEO关注你，而不是你的邻居关注你，你将获得更多的传递性关系，从而获得更大的网络影响力。
- en: Another type of analysis often used for social networks is to deduce community
    structure. In the last couple of years, it has become increasingly popular to
    use graphs for predictive analytics. For example, the popular saying is that a
    person is the average of their five closest friends. You could use this assumption
    and try to predict a property of a person based on the users they follow. Since
    the follower’s graph contains the time component for both the nodes and relationships,
    you could also examine how the network evolved over time and use that information
    to predict how it will grow in the future.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 社交网络中常用的一种分析类型是推断社区结构。在过去的几年里，使用图进行预测分析变得越来越流行。例如，有一句流行的话是：一个人的平均水平等于他/她最亲近的五个朋友。你可以利用这个假设，尝试根据用户关注的用户来预测一个人的属性。由于关注者的图包含了节点和关系的时间成分，你也可以检查网络随时间的变化，并利用这些信息来预测它未来的增长。
- en: 2.3.2 User-tweet network
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 用户推文网络
- en: 'Tweets are the primary way to share content on Twitter. The simplest description
    of the user-tweet network is as follows: A user can publish a tweet.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 推文是分享Twitter上内容的初级方式。用户推文网络的简单描述如下：一个用户可以发布一条推文。
- en: Exercise 2.3
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.3
- en: To get into the flow of designing graph models, try to develop a graph model
    that describes the preceding specification. In the long run, it will be beneficial
    for you if you take a whiteboard or a sketchbook and draw some basic graph models.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入设计图模型的流程，尝试开发一个描述先前规范的图模型。从长远来看，如果你拿一块白板或一本素描本，画一些基本的图模型，这将对你有益。
- en: 'If you again try to develop a graph model from the specification, you might
    come up with the following graph pattern:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次尝试根据规范开发一个图模型，你可能会得到以下图模式：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For a more compact text representation of the model, you can usually leave
    the node and relationship properties out of the Cypher pattern syntax. There are
    two types of nodes present: users and tweets. All you need to add is a relationship
    between them to indicate the author of the tweet. A good practice is to describe
    your graph model as domain specifically as possible. For example, you could have
    also used a more generic label for tweets such as `Post`. With more generic labels,
    you might run into issues along the way if you are asked to add additional information
    about users from Facebook, LinkedIn, or Stack Overflow. Each social media platform
    is unique and generates distinct data. For instance, a tweet has different attributes
    than a Facebook post, LinkedIn update, or Stack Overflow question. This means
    a `Post` node could have numerous optional attributes and relationships, many
    of which remain unused, depending on the type of the post, leading to potential
    complications and inefficiencies. Therefore, it’s often beneficial to have specific
    node labels for different types of posts. This way, the graph database is modeled
    more closely to the domain-specific data it’s handling, allowing for more efficient
    and simpler querying If you follow the guideline to model the graph as close to
    the domain as possible, you will end up with node types `User` and `Tweet`, as
    shown in figure 2.13.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更紧凑的文本表示模型，您通常可以省略节点和关系属性。存在两种类型的节点：用户和推文。您需要添加的是它们之间的关系，以指示推文的作者。一个好的做法是尽可能具体地描述您的图模型。例如，您也可以使用更通用的标签来表示推文，如`Post`。使用更通用的标签，如果在路上被要求添加有关来自Facebook、LinkedIn或Stack
    Overflow的用户的信息，可能会遇到问题。每个社交媒体平台都是独特的，并生成不同的数据。例如，推文具有与Facebook帖子、LinkedIn更新或Stack
    Overflow问题不同的属性。这意味着`Post`节点可能有多个可选属性和关系，其中许多在特定类型的帖子中可能未被使用，导致潜在的复杂性和低效。因此，对于不同类型的帖子，拥有特定的节点标签通常是有益的。这样，图数据库的建模更接近于它处理的具体领域数据，从而允许更高效和简单的查询。如果您遵循将图模型尽可能接近领域的指南，您最终会得到如图2.13所示的`User`和`Tweet`节点类型。
- en: '![02-13](../../OEBPS/Images/02-13.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![02-13](../../OEBPS/Images/02-13.png)'
- en: Figure 2.13 User-tweet network
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 用户-推文网络
- en: You already established a unique identifier for users in the previous exercise.
    Now, you can do something similar and assume there is a unique ID created for
    each tweet when it is created. The tweet’s unique identifier, creation time, and
    text are stored as the properties of a `Tweet` node. As there are two distinct
    labels of nodes present, you are dealing with a bipartite network. In this example,
    the direction of the relationship is not very important. You could turn the relationship
    direction around and change the relationship type to something more appropriate
    like `PUBLISHED_BY`. Both approaches are correct; you need to pick one and stick
    to it. My preference is to define relationship types in active voice, which is
    `PUBLISH` in this example. What you don’t want to have is both modeling options
    present at the same time. You don’t have to worry about query performance, as
    there is no penalty for traversing a relationship in the opposite direction in
    a native graph database.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，您已经为用户建立了一个唯一的标识符。现在，您可以做类似的事情，并假设在创建推文时为每个推文创建了一个唯一的ID。推文的唯一标识符、创建时间和文本存储为`Tweet`节点的属性。由于存在两个不同的节点标签，您正在处理一个二分网络。在这个例子中，关系的方向并不很重要。您可以反转关系方向，并将关系类型更改为更合适的类型，如`PUBLISHED_BY`。两种方法都是正确的；您需要选择一种并坚持下去。我的偏好是使用主动语态定义关系类型，在这个例子中是`PUBLISH`。您不需要担心查询性能，因为在原生图数据库中，遍历关系的反方向没有惩罚。
- en: The right-side example in figure 2.14 demonstrates what you should avoid when
    you are developing a graph model. When the relationship in the opposite direction
    adds no semantic value, it is a good practice to avoid adding it to the model
    in a labeled-property graph database. You also don’t have to worry about getting
    from a `Tweet` to a `User` node. With Cypher query language syntax, you can traverse
    any relationship in the opposite direction, or you can completely ignore direction.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14右侧的示例展示了在开发图模型时应避免的情况。当反向关系不增加任何语义价值时，在标记属性图数据库中避免将其添加到模型中是一种良好的做法。您也不必担心从`Tweet`节点到`User`节点的转换。使用Cypher查询语言语法，您可以遍历任何反向关系，或者您可以完全忽略方向。
- en: '![02-14](../../OEBPS/Images/02-14.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![02-14](../../OEBPS/Images/02-14.png)'
- en: Figure 2.14 A comparison of two graph models, where the left model has a single
    relationship type to capture all the relevant information, and the right model
    uses a redundant relationship type in opposite direction
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14展示了两种图模型的比较，其中左侧模型使用单一的关系类型来捕捉所有相关信息，而右侧模型则使用相反方向上的冗余关系类型。
- en: Another question that might come up is why you store the tweet creation date
    as a property of the node and not the relationship. It is a valid question, and
    as always, it mostly depends on the domain you are dealing with. In the Twitter
    universe, a tweet can have only a single author. Having a single author implies
    that a tweet will have precisely one `PUBLISH` relationship pointing to it; therefore,
    a tweet is created only once. When you are making such decisions, you should always
    include the types of queries you want to execute on this graph model. If you think
    of the most basic use case, where you want to count the number of tweets per day,
    it is simpler to have the creation date stored as a property of the tweet node
    instead of the `PUBLISH` relationship. You will learn more about how graph-pattern
    query languages work in chapter 3.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还会出现的一个问题是，为什么将推文的创建日期存储为节点属性而不是关系属性。这是一个合理的问题，而且像往常一样，这主要取决于你处理的领域。在Twitter宇宙中，一条推文只能有一个作者。拥有单一作者意味着一条推文将恰好有一个指向它的`PUBLISH`关系；因此，推文只创建一次。当你做出这样的决定时，你应该始终包括你想要在这个图模型上执行的查询类型。如果你考虑最基本的使用案例，即你想按天计算推文数量，将创建日期存储为推文节点属性而不是`PUBLISH`关系会更简单。你将在第3章中了解更多关于图模式查询语言的工作方式。
- en: Users liking a tweet would be an example for which adding the creation date
    on the relationship makes more sense. While there can be only a single tweet author,
    many users can like a given tweet. To capture the creation time of a like from
    a particular user, it makes sense to store the creation time information as a
    relationship property, as shown in figure 2.15\. If you wanted to store the time
    information about the likes on the `Tweet` node in the form of an array of dates,
    you would lose the information about which users gave a like at that time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢推文的用户将是一个例子，在这种情况下，将创建日期存储为关系属性更有意义。虽然只有单一推文作者，但许多用户可以喜欢特定的推文。为了捕捉特定用户点赞的创建时间，将创建时间信息作为关系属性存储是合理的，如图2.15所示。如果你想要将关于点赞的时间信息以日期数组的格式存储在`Tweet`节点上，你将失去关于在那个时间点赞的用户的信息。
- en: '![02-15](../../OEBPS/Images/02-15.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![02-15](../../OEBPS/Images/02-15.png)'
- en: Figure 2.15 An example of a Twitter post `LIKE` relationship, when it makes
    sense to store the creation date as a property of the relationship
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15展示了Twitter帖子`LIKE`关系的一个例子，在这种情况下，将创建日期作为关系属性存储是有意义的。
- en: From the network science perspective, having only `PUBLISH` relationships between
    users and tweets is not so interesting. As each tweet has only a single relationship
    pointing to it, there are no overlaps or similarities between tweets you could
    try to analyze. However, if you added `LIKES` relationships to the model, you
    could analyze which users like the same or similar content and create segments
    of users based on the content they like.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络科学的角度来看，用户和推文之间只有`PUBLISH`关系并不那么有趣。因为每个推文只有一个指向它的关系，所以推文之间没有重叠或相似之处可以尝试分析。然而，如果你在模型中添加了`LIKES`关系，你可以分析哪些用户喜欢相同或相似的内容，并基于他们喜欢的内容创建用户段。
- en: 2.3.3 Retweet network
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 重新推文网络
- en: 'The only remaining task specification is the definition of a graph model for
    retweets. When users strongly react to a tweet, they might want to share it with
    their followers to amplify its reach. In this case, they have the option of retweeting
    the original tweet. Optionally, users can like the retweet, and those likes do
    not count toward the original tweet. The task specification is defined as follows:
    *A user can retweet posts from other users.*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一任务规范是定义一个用于重新推文的图模型。当用户对推文有强烈反应时，他们可能想要与他们的关注者分享以扩大其影响力。在这种情况下，他们可以选择重新推文原始推文。用户可以选择喜欢重新推文，而这些点赞不计入原始推文。任务规范定义如下：*用户可以从其他用户那里重新推文帖子。*
- en: This specification is a bit more complex than the previous two. You can’t just
    extract the subject and the object of the sentence and use that to describe the
    nodes. The user-tweet network is already defined, so you can expand on that and
    add the retweets in the graph model. There are several graph model variations
    you can choose from. A simple option is to add the `RETWEET` relationship between
    the user and the original tweet.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范比前两个要复杂一些。你无法只是提取句子的主语和宾语，然后使用它们来描述节点。用户-推文网络已经定义，因此你可以在该基础上扩展并添加图模型中的转发。你可以选择几种图模型变体。一个简单的选项是在用户和原始推文之间添加`RETWEET`关系。
- en: 'Cypher syntax to describe this pattern looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 描述此模式的Cypher语法看起来是这样的：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, you are using the `RETWEET` relationship between a user and the original
    tweet. This graph schema does not treat a retweet as an actual tweet. This is
    neither good nor bad—it all depends on your use case and what you want to achieve
    with the analysis. There is, however, a slight problem with this approach. On
    Twitter, a retweet can also have likes that are tied to the retweet and not the
    original post. With the LPG model, you can’t create a relationship pointing to
    another relationship. Using the graph model in figure 2.16, you lose the ability
    to attach likes to the retweet. Later in this chapter, you will extract information
    from retweets text, such as hashtags and mentions. There, you will again face
    the issue of not having the ability to attach hashtags and mention information
    to the retweet relationship. If the Twitter domain did not allow separate likes
    that are not counted separately, then having a retweet as a relationship would
    make sense. Unfortunately, that is not the case when dealing with the Twitter
    domain. To solve this issue, you can treat the retweet as a separate tweet that
    references the original tweet. This way, you keep the graph consistency while
    still being able to add additional information to retweets later on.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在使用用户和原始推文之间的`RETWEET`关系。这个图模式并不将转发视为实际的推文。这既不是好也不是坏——这完全取决于你的用例以及你希望通过分析实现的目标。然而，这种方法确实存在一个小问题。在Twitter上，转发也可能有与转发相关联的点赞，而不是与原始帖子相关联。使用LPG模型，你无法创建指向另一个关系的引用关系。使用图2.16中的图模型，你将失去将点赞附加到转发的功能。在本章的后面部分，你将从转发文本中提取信息，例如标签和提及。在那里，你将再次面临无法将标签和提及信息附加到转发关系的问题。如果Twitter域不允许单独的点赞（这些点赞不计入总数），那么将转发作为一个关系是有意义的。不幸的是，在处理Twitter域时情况并非如此。为了解决这个问题，你可以将转发视为一个单独的推文，该推文引用了原始推文。这样，你保持了图的一致性，同时仍然能够在以后添加额外的信息到转发中。
- en: '![02-16](../../OEBPS/Images/02-16.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![02-16](../../OEBPS/Images/02-16.png)'
- en: Figure 2.16 Graph model of the retweet network, where the `RETWEET` relationship
    is defined between the original tweet and the user who retweeted it
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16展示了转发网络图模型，其中定义了原始推文和转发该推文的用户之间的`RETWEET`关系
- en: You can still easily differentiate between tweets and retweets. For now, don’t
    worry about the underlying data and how you can retrieve it. You will learn more
    about the Twitter data source in the next chapter. When retweeting a tweet on
    Twitter, a user can optionally add their comment to the retweet. In this example,
    we have skipped this scenario because it was not a part of the specifications;
    however, we will examine how to model quote tweet interactions in the next chapter.
    A retweet has an outgoing `RETWEETS` relationship, and the original tweet can
    only have an incoming `RETWEETS` relationship. The graph model where you store
    the retweet as a separate node (shown in figure 2.17) also allows you to add other
    relationships to it later in the analysis, if needed. Again, you want to evaluate
    how you can use this graph to extract insights. Remember, most often, users retweet
    a tweet when they strongly react to its content and want to share it with their
    followers. You could count the retweets and try to identify the most popular tweet
    topics or their authors. You could also infer a new direct relationship between
    users based on the retweet pattern. Translating indirect graph patterns to direct
    relationships is a frequent intermediate step in the network analysis. In the
    retweet network case, you could infer a direct relationship between users based
    on how often they retweet other users.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以轻松地区分推文和转发。目前，不必担心底层数据和如何检索它。你将在下一章中了解更多关于Twitter数据源的信息。在Twitter上转发推文时，用户可以选择性地添加他们的评论。在这个例子中，我们跳过了这个场景，因为它不是规范的一部分；然而，我们将在下一章中探讨如何建模引用推文互动。转发有一个出向的`RETWEETS`关系，原始推文只能有一个入向的`RETWEETS`关系。将转发存储为单独节点的图模型（如图2.17所示）也允许你在分析过程中根据需要添加其他关系。再次强调，你想要评估如何使用这个图来提取洞察。记住，用户通常在强烈反应于推文内容并希望与他们的关注者分享时转发推文。你可以计算转发次数并尝试识别最受欢迎的推文主题或其作者。你也可以根据转发模式推断用户之间新的直接关系。将间接图模式转换为直接关系是网络分析中常见的中间步骤。在转发网络的情况下，你可以根据用户转发其他用户的频率推断用户之间的直接关系。
- en: '![02-17](../../OEBPS/Images/02-17.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![02-17](../../OEBPS/Images/02-17.png)'
- en: Figure 2.17 Graph model of the retweet network, where the retweet is treated
    as a tweet that references the original tweet
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 转发网络的图模型，其中转发被视为引用原始推文的推文
- en: Figure 2.17 demonstrates a scenario in which Vanessa just retweeted a tweet
    from Kim. If you assume a retweet is always a positive interaction, you could
    presume that Vanessa actively promotes Kim’s tweet and amplifies its reach. This
    indirect amplification pattern can be translated to a direct relationship between
    Kim and Vanessa, as shown in figure 2.18.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17演示了Vanessa刚刚转发了Kim的一条推文的情况。如果你假设转发总是积极的互动，你可能会认为Vanessa积极推广Kim的推文并扩大其影响力。这种间接的放大模式可以转化为Kim和Vanessa之间的直接关系，如图2.18所示。
- en: '![02-18](../../OEBPS/Images/02-18.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![02-18](../../OEBPS/Images/02-18.png)'
- en: Figure 2.18 Inferring a new network from an indirect pattern of retweet relationships
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 从间接的转发关系模式中推断新的网络
- en: 'You can use the text representation to show that you take the following graph
    pattern:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用文本表示来展示你采用了以下图模式：
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can then translate this indirect relationship pattern into a direct relationship
    between users:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将这种间接关系模式转换为用户之间的直接关系：
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By translating an indirect pattern to a direct relationship, you are creating
    a new inferred network. The type of the inferred relationship depends on your
    domain use case. Here, I have chosen the `AMPLIFY` type, as the retweet amplifies
    the reach of the original tweet. The new inferred `AMPLIFY` relationship is directed,
    as the direction of the relationship holds semantic value. It is also weighted,
    as you can quantify the strength of the `AMPLIFY` relationship by counting the
    number of retweets. If a user retweets a post from another user a single time,
    then the weight of the `AMPLIFY` relationships is `1`. However, if a user regularly
    retweets posts from another user, the weight would be equal to the number of retweets.
    You could, again, search for influencers within this inferred network or try to
    find communities of users who actively support each other by promoting their content.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将间接模式转换为直接关系，你正在创建一个新的推断网络。推断关系的类型取决于你的领域用例。在这里，我选择了`AMPLIFY`类型，因为转发放大了原始推文的传播范围。新的推断`AMPLIFY`关系是单向的，因为关系的方向具有语义价值。它也是加权的，因为你可以通过计算转发的数量来量化`AMPLIFY`关系的强度。如果一个用户单次转发另一个用户的帖子，那么`AMPLIFY`关系的权重是`1`。然而，如果一个用户经常转发另一个用户的帖子，那么权重将等于转发的数量。你可以在这个推断网络中再次搜索影响者，或者尝试找到通过推广他们的内容来积极支持彼此的用户社区。
- en: 2.3.4 Representing graph schema
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 表示图模式
- en: The beauty of the graph approach to data modeling is that you can always connect
    new information to an existing graph. You can now combine all the graph model
    decisions so far into a single graph model. Figure 2.19 visualizes the graph with
    combined data that follows your decision on how to model users, their followers,
    tweets, and retweets.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图形方法在数据建模中的美妙之处在于，你总是可以将新信息连接到现有图上。现在，你可以将迄今为止的所有图模型决策组合成一个单一的图模型。图2.19可视化了根据你对如何建模用户、他们的关注者、推文和转发的决策所遵循的合并数据。
- en: '![02-19](../../OEBPS/Images/02-19.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![02-19](../../OEBPS/Images/02-19.png)'
- en: Figure 2.19 Labeled-property graph representing a Twitter network, where users
    can follow one another as well as publish and retweet posts
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19表示Twitter网络的标记属性图，其中用户可以相互关注，也可以发布和转发帖子
- en: Over the years, people have come up with ways to represent an LPG graph schema.
    There is no official standard to present an LPG graph schema, but we will now
    discuss perhaps the most common approach.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，人们提出了表示LPG图模式的方法。目前还没有官方标准来展示LPG图模式，但我们将现在讨论可能最常见的方法。
- en: '![02-20](../../OEBPS/Images/02-20.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![02-20](../../OEBPS/Images/02-20.png)'
- en: Figure 2.20 Twitter social network graph model representation
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20 Twitter社交网络图模型表示
- en: Each node type or label is represented as a single node. There are two different
    labels of nodes present in the current Twitter network representation. You can
    describe them as two nodes in the graph schema representation as shown in figure
    2.20\. The node properties are then added to the node representing each label.
    Optionally, you can add example values to the node properties, but I prefer to
    add their data type as the value. For now, there is no agreed-upon way to visualize
    whether a node property is optional or whether it is used as a unique identifier.
    Relationships between the same label of nodes are represented as a self-loop.
    A self-loop is a relationship that has the same start and end node. On the right
    side of figure 2.20, there are two self-loops present. The `FOLLOWS` relationship
    starts and points to nodes with the `User` type. Additionally, the `RETWEETS`
    relationships starts and points to nodes with a type `Tweet`. Unfortunately, again,
    there is no agreed-upon way of representing when a relationship direction has
    semantic value (i.e., should be treated as directed or undirected) or not. For
    now, you must read the fine print that comes along with the graph schema visualization.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点类型或标签都表示为一个单独的节点。当前Twitter网络表示中存在两种不同的节点标签。你可以将它们描述为图模式表示中的两个节点，如图2.20所示。然后，将节点属性添加到代表每个标签的节点上。你可以选择性地添加节点属性的示例值，但我更喜欢添加它们的数据类型作为值。目前，还没有达成共识的方式来可视化节点属性是否为可选的，或者是否用作唯一标识符。具有相同标签的节点之间的关系表示为自环。自环是具有相同起始和结束节点的关联。在图2.20的右侧，存在两个自环。`FOLLOWS`关系从起始并指向具有`User`类型的节点。此外，`RETWEETS`关系从起始并指向具有类型`Tweet`的节点。不幸的是，再次，没有达成共识的方式来表示关系方向是否具有语义价值（即应被视为有向或无向）或不是。目前，你必须阅读随图模式可视化一起提供的详细说明。
- en: 2.4 Extracting knowledge from text
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 从文本中提取知识
- en: You have learned how to construct a graph model based on the graph-based features
    of the data. Next, you will learn how you can extract relevant information from
    the text and incorporate them into your knowledge graph model. To get a sense
    of what information you can extract from the tweet content, let’s look at an example
    tweet.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了如何根据数据的图特征构建图模型。接下来，你将学习如何从文本中提取相关信息并将它们纳入你的知识图谱模型。为了了解你可以从推文内容中提取哪些信息，让我们看看一个示例推文。
- en: '![02-21](../../OEBPS/Images/02-21.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![02-21](../../OEBPS/Images/02-21.png)'
- en: Figure 2.21 An example tweet, where mentions, links, and hashtags are present
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21 一个包含提及、链接和标签的示例推文
- en: 'The tweet in figure 2.21 incorporates several elements to maximize its reach
    and interactivity. The hashtags, such as #KnowledgeGraph, #NamedEntityLinking,
    #Wikipedia, #NLP, #DataScience, and #Graphs are tools for categorizing the content
    and making it discoverable to users interested in these specific topics, thereby
    increasing its visibility on Twitter’s platform. Links, like the Medium article
    URL, provide direct access to additional relevant content, allowing followers
    to explore the topic in depth. Mentions, represented by the @ symbol followed
    by a Twitter username (e.g., @tb_tomaz and @CatedraBOB), are used to directly
    address or reference specific individuals or organizations, creating a conversation
    and fostering engagement within the Twitter community.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21中的推文包含几个元素，以最大化其覆盖范围和互动性。例如，#KnowledgeGraph、#NamedEntityLinking、#Wikipedia、#NLP、#DataScience和#Graphs等标签是用于对内容进行分类并使其对感兴趣这些特定主题的用户可发现，从而增加其在Twitter平台上的可见性。链接，如Medium文章的URL，提供了直接访问相关内容的途径，允许关注者深入探索该主题。提及，由@符号后跟Twitter用户名（例如，@tb_tomaz和@CatedraBOB）表示，用于直接指向或引用特定个人或组织，从而在Twitter社区中创造对话并促进参与。
- en: 2.4.1 Links
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 链接
- en: The first information you could extract from tweet content is any links included
    in the tweet. It should be pretty straightforward to process any links from the
    text.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从推文内容中提取的第一条信息是推文中包含的任何链接。从文本中处理任何链接应该相当直接。
- en: Exercise 2.4
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.4
- en: Now that you have some experience developing a labeled-property graph (LPG)
    model, what do you think is the best approach to add the link information in the
    Twitter graph model? You have already defined the tweet in the model; now you
    only need to add the extracted links information to them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一些开发标记属性图（LPG）模型的经验了，你认为在Twitter图模型中添加链接信息最好的方法是什么？你已经在模型中定义了推文；现在你只需要将提取的链接信息添加到它们上面。
- en: I can think of two options. You could either store the URL as a tweet node property
    or store it as a separate node and add a relationship between the link and the
    tweet (figure 2.22).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以想到两种选择。你可以将URL存储为推文节点属性，或者将其存储为单独的节点，并在链接和推文之间添加一个关系（图2.22）。
- en: '![02-22](../../OEBPS/Images/02-22.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![02-22](../../OEBPS/Images/02-22.png)'
- en: Figure 2.22 Two options for storing the extracted link from the tweet
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22 从推文中提取链接的两种存储选项
- en: Which approach do you think is better? With both approaches, you have the option
    to store one or many links, as you can use a list of strings as a node property.
    The real answer depends on your queries. Do you want to group tweets with the
    same links in your analysis or not? If you store links as node properties, it
    will be computationally more expensive to find tweets with the same link, as you
    need to compare all elements in a list between all pairs of tweets. You can avoid
    that by storing links as separate nodes. By using separate nodes to represent
    links, you only need to traverse two relationships to get from one tweet to another
    or even all tweets with the same links. This approach will scale much better if
    you are interested in grouping nodes with the same links.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为哪种方法更好？在这两种方法中，你都有选择存储一个或多个链接的选项，因为你可以使用字符串列表作为节点属性。真正的答案取决于你的查询。你想要在分析中将具有相同链接的推文分组吗？如果你将链接作为节点属性存储，那么找到具有相同链接的推文将更加计算密集，因为你需要比较所有推文对之间的列表中的所有元素。你可以通过将链接作为单独的节点来避免这种情况。通过使用单独的节点来表示链接，你只需要遍历两个关系就可以从一个推文到达另一个推文，甚至到达具有相同链接的所有推文。如果你对将具有相同链接的节点分组感兴趣，这种方法将具有更好的可扩展性。
- en: Graph modeling considerations
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图模型考虑因素
- en: When considering whether you want to store information as separate nodes or
    node properties, it is important to examine whether the values are standardized.
    Take a look at the example of links in a tweet. When discrete values are not standardized,
    storing that information as separate nodes doesn’t make sense. The whole point
    of using separate nodes to store information is to allow faster traversals at
    query runtime. When values are not standardized, you lose the ability to traverse
    fast between persons that live in the same city. A rule of thumb is that a single
    real-world entity or concept should be represented as a single node in the graph.
    In the following figure, the Medium website is represented as three different
    nodes, which would return invalid information if you were trying to find tweets
    with the same links. While storing the link information as a node property does
    not solve the issue of finding tweets with the same links, at least you don’t
    represent a single real-world entity as multiple nodes in your graph. The solution
    is to either clean and standardize the link information so that you can model
    links as separate nodes or store the link information as a node property to avoid
    having a single entity represented as multiple nodes in the graph.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑是否要将信息存储为单独的节点或节点属性时，重要的是要检查这些值是否标准化。以推文中链接的例子来看。当离散值未标准化时，将信息存储为单独的节点是没有意义的。使用单独的节点来存储信息的整个目的就是为了在查询运行时允许更快的遍历。当值未标准化时，你将失去在居住在同一城市的人之间快速遍历的能力。一个经验法则是，一个现实世界的实体或概念应该作为图中的一个单独节点来表示。在下面的图中，Medium
    网站被表示为三个不同的节点，如果你试图查找具有相同链接的推文，这将返回无效信息。虽然将链接信息作为节点属性并不能解决查找具有相同链接的推文的问题，但至少你不会在图中将一个现实世界的实体表示为多个节点。解决方案是清理并标准化链接信息，以便你可以将链接作为单独的节点来建模，或者将链接信息作为节点属性存储，以避免在图中将单个实体表示为多个节点。
- en: Another topic to consider is how specific that information is. For example,
    suppose the information is very unspecific and doesn’t add much value from the
    information point of view, like the gender of a user. In that case, it is better
    to store that information as a node property. One reason for this is that you
    avoid having nodes that can be connected to large parts of the graph. With the
    gender example, you could have nodes connected to almost half of the users in
    the graph. Nodes connected to large parts of the graph are called *super nodes*,
    and you generally want to avoid them in your graph, as they can hinder query performance,
    due to the sheer number of relationships attached to them.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的话题是信息的具体性。例如，假设信息非常不具体，并且从信息的角度来看没有增加多少价值，比如用户的性别。在这种情况下，最好将此信息作为节点属性存储。一个原因是你避免了拥有可以连接到图的大部分部分的节点。以性别为例，你可以有连接到图中几乎一半用户的节点。连接到图的大部分部分的节点被称为*超级节点*，你通常希望避免在图中使用它们，因为它们由于附着的众多关系而可能阻碍查询性能。
- en: '![02-22-UN01](../../OEBPS/Images/02-22-UN01.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![02-22-UN01](../../OEBPS/Images/02-22-UN01.png)'
- en: An example graph, where links are not standardized
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个链接未标准化的示例图
- en: 2.4.2 Hashtags
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 标签
- en: The other information you can extract from tweet content is the hashtags. People
    use the hashtag symbol (#) before a relevant keyword or phrase in their tweet
    to categorize them. A tweet can contain many hashtags; it makes sense to store
    them as separate nodes and connect tweets to them, as shown in figure 2.23.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从推文内容中提取的其他信息是标签。人们在推文中使用井号(#)符号在相关关键词或短语之前来对它们进行分类。一条推文可以包含许多标签；将它们作为单独的节点存储并将推文连接到它们是有意义的，如图
    2.23 所示。
- en: '![02-23](../../OEBPS/Images/02-23.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![02-23](../../OEBPS/Images/02-23.png)'
- en: Figure 2.23 Graph model of tweet’s hashtags
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.23 推文标签的图模型
- en: An important consideration is that you want to avoid generic relationship types
    like `HAS`, where you could use it in many scenarios. You want your relationship
    types to have meaning (e.g., if you traverse a `LINKS_TO` relationship from a
    tweet, you will always land at a `Link` node). Similarly, if you traverse a `HAS_TAG`
    relationship from a tweet, you will always arrive at a `Tag` node. It’s important
    to keep in mind that you don’t want to end up with a single relationship type
    that can lead to many different node types. Using a generic relationship type
    can hinder the expressiveness of a graph model and negatively affect query processing
    times.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的考虑因素是，你想要避免使用像`HAS`这样的通用关系类型，你可以在许多场景中使用它。你希望你的关系类型具有意义（例如，如果你从一个推文遍历`LINKS_TO`关系，你将始终到达一个`Link`节点）。同样，如果你从一个推文遍历`HAS_TAG`关系，你将始终到达一个`Tag`节点。重要的是要记住，你不想最终得到一个可以导致许多不同节点类型的关系类型。使用通用关系类型可能会阻碍图模型的表达能力，并负面对查询处理时间产生影响。
- en: Avoiding generic relationship types
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用通用关系类型
- en: Suppose you were dealing with a graph model of Twitter that used a generic `HAS`
    relationship between various types of nodes. For example, say you want to retrieve
    all tweet hashtags. The engine must expand all outgoing `HAS` relationships of
    a `Tweet` node and check if the node at the end of the relationship is a `Tag`
    node. On the other hand, if you used a specific `HAS_TAG` relationship to connect
    tags to tweets, you would avoid traversing relationships that do not point to
    a `Tag` node. Additionally, the engine does not need to check the target node
    type, since it is guaranteed that the `HAS_TAG` relationship points to a `Tag`
    node. Therefore, using generic relationship types may result in slower query performance,
    as the database needs to search through a greater number of relationships to find
    the graph patterns that match the query.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在处理一个使用各种节点之间的通用`HAS`关系的Twitter图模型。例如，假设你想检索所有推文的标签。引擎必须扩展`Tweet`节点的所有出向`HAS`关系，并检查关系的末端节点是否为`Tag`节点。另一方面，如果你使用特定的`HAS_TAG`关系将标签连接到推文，你将避免遍历不指向`Tag`节点的关系。此外，引擎不需要检查目标节点类型，因为可以保证`HAS_TAG`关系指向`Tag`节点。因此，使用通用关系类型可能会导致查询性能变慢，因为数据库需要搜索更多的关系来找到与查询匹配的图模式。
- en: '![02-23-UN02](../../OEBPS/Images/02-23-UN02.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![02-23-UN02](../../OEBPS/Images/02-23-UN02.png)'
- en: An example of a graph with a generic `HAS` relationship
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 具有通用`HAS`关系的图示例
- en: Using a generic relationship type can also hinder the clarity and maintainability
    of a graph. In the example in the following figure, the `HAS` relationship is
    used to indicate
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通用关系类型也可能阻碍图的清晰性和可维护性。在以下图例中，使用`HAS`关系来表示
- en: the author of a tweet as well as its hashtags and links. Using a generic relationship
    type can lead to confusion or errors when querying or modifying the graph. Instead,
    defining specific relationship types that describe the nature of the relationship
    can make the graph easier to understand and work with and, consequently, help
    ensure the graph remains consistent and correct over time, due to a less error-prone
    schema.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 推文的作者以及其标签和链接。使用通用关系类型在查询或修改图时可能会导致混淆或错误。相反，定义描述关系本质的特定关系类型可以使图更容易理解和操作，从而有助于确保图随着时间的推移保持一致和正确，因为这种模式更不容易出错。
- en: The graph in figure 2.24 is a bipartite network consisting of tweet and hashtag
    nodes. When dealing with a bipartite network, it is a common analysis workflow
    step to project it to a monopartite network. For example, if a pair of tweets
    share the same hashtag, you could assume they are somehow connected. This is a
    process similar to the one you saw in the retweet network, where you translated
    indirect graph patterns to direct relationships. The transformation of a bipartite
    network of hashtags and tweets to a monopartite network is visualized in figure
    2.24.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24中的图是一个由推文和标签节点组成的二分网络。在处理二分网络时，将其投影到单边网络是一个常见的分析工作流程步骤。例如，如果一对推文共享相同的标签，你可以假设它们以某种方式相连。这个过程与你在转发网络中看到的过程类似，其中你将间接的图模式转换为直接关系。标签和推文的二分网络转换为单边网络的过程在图2.24中进行了可视化。
- en: '![02-24](../../OEBPS/Images/02-24.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![02-24](../../OEBPS/Images/02-24.png)'
- en: Figure 2.24 Monopartite network projection of a Twitter hashtag
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24 单边网络投影的Twitter标签
- en: 'You can observe that you always have the option to project a bipartite network
    to both types of nodes. In a bipartite network of tweets and their hashtags, you
    can project it to a monopartite network of tweets or hashtags. How you name the
    new inferred relationship depends on the domain. I have added a `SIMILAR` relationship
    between tweets, as I assume that tweets with more overlapping hashtags can be
    deemed more similar. On the other hand, hashtags can also be similar if they frequently
    co-occur. To put it in text representation of networks, you can transform the
    following indirect graph pattern:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以观察到，你总是可以选择将二分网络投影到两种类型的节点上。在一个包含推文及其标签的二分网络中，你可以将其投影为推文或标签的单分网络。新推断关系命名取决于领域。我添加了推文之间的`SIMILAR`关系，因为我假设具有更多重叠标签的推文可以被认为是更相似的。另一方面，如果标签经常共同出现，它们也可以被认为是相似的。用网络的文本表示来说，你可以将以下间接图模式转换为：
- en: '[PRE12]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can transform it to a more direct graph pattern:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其转换为更直接的图模式：
- en: '[PRE13]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You might have noticed that a common approach to network analysis is to reduce
    a complex graph pattern to a network with a single type of nodes and relationships.
    This is because most classical graph algorithms, like centrality or community
    detection algorithms, are designed to have a monopartite network as an input.
    With monopartite projections, the direction of the relationship often does not
    hold any semantic value. If tweet A is similar to tweet B, then tweet B is also
    similar to tweet A. You can quantify the strength of similarity between two tweets
    by counting the number of common hashtags they have. As a result, most inferred
    similarity networks are undirected and weighted, like in this example. On the
    other hand, a previously inferred amplification network based on retweets is directed
    as well as weighted. You could analyze the inferred similarity network of tweets
    and try to find users who publish similar content. Note that you could also combine
    information from other parts of the graph to infer a new monopartite network.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，网络分析的一个常见方法是将复杂的图模式简化为只有一种类型节点和关系的网络。这是因为大多数经典图算法，如中心性或社区检测算法，都是设计为以单分网络作为输入的。使用单分投影，关系的方向通常不包含任何语义价值。如果推文A与推文B相似，那么推文B也与推文A相似。你可以通过计算两个推文共有的标签数量来量化它们之间相似性的强度。因此，大多数推断的相似性网络都是无向和加权的，就像这个例子一样。另一方面，基于转发的先前推断的放大网络也是有向和加权的。你可以分析推文的推断相似性网络，试图找到发布相似内容的用户。请注意，你也可以结合图的其他部分的信息来推断一个新的单分网络。
- en: 2.4.3 Mentions
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 提及
- en: A user can mention other users in their tweet by using the mention symbol (@).
    A mention can be understood as an invitation to comment or a callout, while at
    other times, it can be used to notify users to look at specific content. You already
    have users defined in the graph schema, so it only makes sense to connect tweets
    to mentioned users, as shown in figure 2.25.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过使用提及符号（@）在其推文中提及其他用户。提及可以理解为邀请评论或召唤，而在其他时候，它可以用作通知用户查看特定内容。你已经在图模式中定义了用户，因此将推文连接到被提及的用户是有意义的，如图2.25所示。
- en: '![02-25](../../OEBPS/Images/02-25.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![02-25](../../OEBPS/Images/02-25.png)'
- en: Figure 2.25 Graph model of tweet’s mentions
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25 推文提及的图模型
- en: Like the hashtag network, the mention network is also a classic bipartite network.
    As such, you can project it to a monopartite network of users or tweets (figure
    2.26). For example, you could analyze which users are frequently co-mentioned
    and try to examine the community structure of the inferred co-mention network
    between users. Something else you could examine is whether the mentioned person
    interacted with the tweet. You could also combine mention information with other
    information in the graph and inspect the most common hashtags of tweets in which
    a user is mentioned. One strategy you could use is to take the mention information
    and integrate it into follower recommendations.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 就像标签网络一样，提及网络也是一个经典的二分网络。因此，你可以将其投影为用户或推文的单分网络（图2.26）。例如，你可以分析哪些用户经常被共同提及，并尝试检查推断的共同提及网络的用户社区结构。你还可以检查被提及的人是否与推文互动。你还可以将提及信息与其他图中的信息结合，并检查被提及的用户在推文中出现的最常见标签。你可以使用的一种策略是将提及信息整合到关注者推荐中。
- en: '![02-26](../../OEBPS/Images/02-26.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![02-26](../../OEBPS/Images/02-26.png)'
- en: Figure 2.26 Twitter mention network folding or monopartite projection
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.26 Twitter提及网络折叠或单分投影
- en: 2.4.4 Final Twitter social network schema
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.4 最终Twitter社交网络模式
- en: Designing a graph model schema is an iterative process. You have slowly added
    additional information to the graph model, and it has gradually become richer
    in knowledge. When adding new data to the graph model, designing a self-describing
    graph schema is recommended. With a self-describing graph model, you can avoid
    additional work to create a schema manual for others to learn about the information
    the graph stores and how to query it. Finally, the graph schema might change,
    depending on the queries you will be executing, as you might want to optimize
    the performance of specific queries. You can observe the following graph structure
    if you put all the graph model design considerations you have made so far into
    a single visualization.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 设计图模型模式是一个迭代的过程。你逐渐向图模型添加了额外的信息，它逐渐变得更加丰富。当向图模型添加新数据时，建议设计一个自描述的图模式。使用自描述的图模型，你可以避免创建一个用于其他人了解图存储的信息以及如何查询它的模式手册的额外工作。最后，图模式可能会根据你将要执行的查询而改变，因为你可能想要优化特定查询的性能。如果你将迄今为止所做的所有图模型设计考虑因素放入一个单独的可视化中，你可以观察到以下图结构。
- en: Figure 2.27 shows an example Twitter network, where there are four distinct
    types or labels of nodes present. There are users, tweets, hashtags, and link
    nodes in the final Twitter graph model. Along the way, you have also introduced
    six different types of relationships. If you sum it up, you can represent this
    example network with the graph schema shown in figure 2.28.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27显示了Twitter网络的一个示例，其中存在四种不同的节点类型或标签。在最终的Twitter图模型中，有用户、推文、标签和链接节点。在这个过程中，你也介绍了六种不同类型的关系。如果你总结一下，你可以用图2.28中显示的图模式来表示这个示例网络。
- en: '![02-27](../../OEBPS/Images/02-27.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![02-27](../../OEBPS/Images/02-27.png)'
- en: Figure 2.27 Twiter social network with knowledge extracted from text
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27 从文本中提取知识后的Twitter社交网络
- en: You only want to add the inferred relationships that will be instantiated to
    the graph schema. Inferred relationships and similarity networks are created based
    on assumptions you might make during the network analysis. You don’t know which
    inferred relationships will be instantiated yet, so it makes sense to leave them
    out of the graph schema for now. The final graph schema representation can be
    viewed in figure 2.28.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你只想将那些将被实例化的推断关系添加到图模式中。推断关系和相似性网络是基于你在网络分析期间可能做出的假设创建的。你还不知道哪些推断关系将被实例化，所以现在将它们排除在图模式之外是有意义的。最终的图模式表示可以在图2.28中查看。
- en: '![02-28](../../OEBPS/Images/02-28.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![02-28](../../OEBPS/Images/02-28.png)'
- en: Figure 2.28 Final Twitter social network graph schema representation
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.28 最终Twitter社交网络图模式表示
- en: You might have noticed that a common theme in network analysis is to translate
    indirect graph patterns and relationships to direct ones. Using a graph database
    with a dedicated graph-pattern query language makes it easier for you to instantiate
    those network transformations. For example, you can translate the retweet links
    between tweets to direct amplification relationships between users. Another frequent
    scenario is translating a bipartite network to a monopartite network. Monopartite
    projections are used because most graph algorithms are designed to work on networks
    with a single type of nodes and relationships. In the next chapter, you will learn
    the basics of Cypher and how to import a network based on the graph model you
    derived in this chapter.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，网络分析中的一个常见主题是将间接的图模式和关系转换为直接的。使用具有专用图模式查询语言的图数据库可以使你更容易实例化这些网络转换。例如，你可以将推文之间的转发链接转换为用户之间的直接放大关系。另一个常见的场景是将二分网络转换为单分网络。单分投影被使用，因为大多数图算法都是设计用来在具有单一类型节点和关系的网络上工作的。在下一章中，你将学习Cypher的基础知识以及如何根据本章中推导出的图模型导入网络。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The labeled-property graph model is represented by a set of nodes, relationships,
    node labels, and properties.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签属性图模型由一组节点、关系、节点标签和属性表示。
- en: An undirected relationship can be traversed in both directions.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无向关系可以从两个方向进行遍历。
- en: An undirected graph can be represented as a directed graph, where each relationship
    is replaced by two that point in the opposite direction.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无向图可以表示为有向图，其中每个关系都被两个指向相反方向的关系所取代。
- en: A relationship can be weighted, where the weight represents the strength or
    cost of traversing the relationship.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系可以被加权，其中权重表示遍历关系的强度或成本。
- en: A monopartite graph contains only a single node and relationship type.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单分图只包含一个节点和一种关系类型。
- en: A bipartite graph contains two sets of nodes, and no relationship exist between
    nodes in the same sets.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二分图包含两组节点，并且同一组内的节点之间不存在任何关系。
- en: A multigraph is a type of graph that allows multiple relationships between a
    single pair of nodes.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重图是一种允许单个节点对之间存在多个关系的图类型。
- en: A complete graph is a graph in which nodes are connected to all the other nodes.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全图是一种节点与其他所有节点都相连的图。
- en: 'Cypher syntax uses parentheses to represent nodes: `(:Node)`.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypher 语法使用括号来表示节点：`(:Node)`。
- en: 'Relationships in Cypher are represented with square brackets: `()-[:RELATIONSHIP]-()`.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypher 中的关系用方括号表示：`()-[:RELATIONSHIP]-()`。
- en: A relationship cannot exist or be represented without its adjacent nodes.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系不能存在或表示，如果没有其相邻节点。
- en: Depending on the domain, literal values can be represented as a separate node
    or a node property in a labeled-property graph model.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据领域，字面值可以表示为一个单独的节点或在标签属性图模型中的一个节点属性。
- en: When a relationship direction adds no semantic value, it is a good practice
    to only add a relationship in a single direction and avoid duplicating the relationship
    in the opposite direction when using a labeled-property graph database.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '当关系方向不增加任何语义价值时，在单方向添加关系是一种好的做法，并在使用标签属性图数据库时避免在相反方向重复添加关系。 '
- en: Graph modeling is an iterative process.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图建模是一个迭代的过程。
- en: The graph model can be represented with the graph model schema visualization.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图模型可以用图模型架构可视化来表示。
- en: Extracting structured information from unstructured text is valuable for most
    data analysis.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从非结构化文本中提取结构化信息对大多数数据分析来说非常有价值。
- en: Reducing indirect graph patterns to direct relationships (monopartite projection)
    is a frequent step in network analysis.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将间接图模式简化为直接关系（单分图投影）是网络分析中常见的步骤。
