- en: 2 Drawing with 2D vectors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 使用二维向量绘图
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Creating and manipulating 2D drawings as collections of vectors
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二维绘图作为向量的集合创建和操作
- en: Thinking of 2D vectors as arrows, locations, and ordered pairs of coordinates
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二维向量视为箭头、位置和坐标的有序对
- en: Using vector arithmetic to transform shapes in the plane
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用向量算术来变换平面上的形状
- en: Using trigonometry to measure distances and angles in the plane
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用三角学来测量平面上的距离和角度
- en: You probably already have some intuition for what it means to be two-dimensional
    or three-dimensional. A *two-dimensional*(2D) object is flat like an image on
    a piece of paper or a computer screen. It has only the dimensions of height and
    width. A *three-dimensional*(3D) object in our physical world, however, has not
    only height and width but also depth.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经对二维或三维的含义有一些直观的理解。一个*二维*(2D)对象就像一张纸上的图像或电脑屏幕上的图像一样平坦。它只有高度和宽度这两个维度。然而，在我们物理世界中，一个*三维*(3D)对象不仅有高度和宽度，还有深度。
- en: Models of 2D and 3D entities are important in programming. Anything that shows
    up on the screen of your phone, tablet, or PC is a 2D object, occupying some width
    and height of pixels. Any simulation, game, or animation that represents the physical
    world is stored as 3D data and eventually projected to the two dimensions of the
    screen. In virtual and augmented reality applications, the 3D models must be paired
    with real, measured 3D data about the user’s position and perspective.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 二维和三维实体的模型在编程中很重要。任何出现在你手机、平板电脑或电脑屏幕上的东西都是一个二维对象，占据一定的像素宽度和高度。任何代表物理世界的模拟、游戏或动画都存储为三维数据，并最终投影到屏幕的两个维度上。在虚拟和增强现实应用中，三维模型必须与关于用户位置和视角的真实、测量过的三维数据相匹配。
- en: Even though our everyday experience takes place in three dimensions, it's useful
    to think of some data as higher dimensional. In physics, it’s common to consider
    time as the fourth dimension. While an object exists at a location in 3D space,
    an event occurs at a 3D location and at a specified moment. In data science problems,
    it’s common for data sets to have far more dimensions. For instance, a user tracked
    on a website can have hundreds of measurable attributes, which describe usage
    patterns. Grappling with these problems in graphics, physics, and data analysis
    requires a framework for dealing with data in higher dimensions. This framework
    is *vector mathematics* .
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的日常经验发生在三维空间中，但将一些数据视为高维数据是有用的。在物理学中，通常将时间视为第四维度。当一个物体存在于三维空间中的某个位置时，一个事件发生在三维位置和指定的时间点。在数据科学问题中，数据集通常具有更多的维度。例如，一个在网站上追踪的用户可能有数百个可测量的属性，这些属性描述了使用模式。在图形学、物理学和数据分析中处理这些问题的框架需要处理高维数据的框架。这个框架是*向量数学*。
- en: Vectors are objects that live in multi-dimensional spaces. These have their
    own notions of arithmetic (adding, multiplying, and so on). We start by studying
    2D vectors, which are easy to visualize and compute with. We use a lot of 2D vectors
    in this book, and we also use them as a mental model when reasoning about higher-dimensional
    problems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是多维空间中的对象。它们有自己的算术概念（加法、乘法等）。我们首先研究二维向量，它们易于可视化和计算。在这本书中，我们使用了大量的二维向量，并且在推理更高维问题的时候，我们也把它们作为心理模型来使用。
- en: 2.1 Picturing 2D vectors
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 描绘二维向量
- en: 'The 2D world is flat like a piece of paper or a computer screen. In the language
    of math, a flat, 2D space is referred to as a *plane* . An object living in a
    2D plane has the two dimensions of height and width but no third dimension of
    depth. Likewise, you can describe locations in 2D by two pieces of information:
    their vertical and horizontal positions. To describe the location of points in
    the plane, you need a reference point. We call that special reference point the
    *origin* . Figure 2.1 shows this relationship.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 二维世界就像一张纸或电脑屏幕一样平坦。在数学语言中，一个平坦的二维空间被称为*平面*。生活在二维平面上的物体具有高度和宽度这两个维度，但没有深度这个第三维度。同样，你可以通过两个信息来描述二维中的位置：它们的垂直和水平位置。为了描述平面上的点的位置，你需要一个参考点。我们称这个特殊的参考点为*原点*。图2.1展示了这种关系。
- en: '![](../Images/CH02_F01_Orland.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F01_Orland.png)'
- en: Figure 2.1 Locating one of several points in the plane, relative to the origin
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 在原点相对于几个点定位
- en: There are many points to choose from, but we have to fix one of them as our
    origin. To distinguish it, we mark the origin with an *x* instead of with a dot
    as in figure 2.1\. From the origin, we can draw an arrow (like the solid one in
    figure 2.1) to show the relative location of another point.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多点可供选择，但我们必须将其中一个点固定为我们原点。为了区分它，我们用*x*而不是点标记原点，如图2.1所示。从原点出发，我们可以画一个箭头（如图2.1中的实心箭头）来显示另一个点的相对位置。
- en: A *two-dimensional vector* is a point in the plane relative to the origin. Equivalently,
    you can think of a vector as a straight arrow in the plane; any arrow can be placed
    to start at the origin, and it indicates a particular point (figure 2.2).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*二维向量*是相对于原点的平面上的一个点。等价地，你可以将向量视为平面上的直线箭头；任何箭头都可以放置在原点开始，并指示一个特定的点（见图2.2）。
- en: '![](../Images/CH02_F02_Orland.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F02_Orland.png)'
- en: Figure 2.2 Superimposing an arrow on the plane indicates a point relative to
    the origin.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 在平面上叠加箭头表示相对于原点的点。
- en: 'We’ll use both arrows and points to represent vectors in this chapter and beyond.
    Points are useful to work with because we can build more interesting drawings
    out of them. If I connect the points in figure 2.2 as in figure 2.3, I get a drawing
    of a dinosaur:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及之后的章节中，我们将使用箭头和点来表示向量。点很有用，因为我们可以用它们构建更有趣的图形。如果我像图2.3那样连接图2.2中的点，我就能得到一个恐龙的图形：
- en: '![](../Images/CH02_F03_Orland.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F03_Orland.png)'
- en: Figure 2.3 Connecting points in the plane to draw a shape
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 在平面上连接点以绘制形状
- en: Any time a 2D or 3D drawing is displayed by a computer, from my modest dinosaur
    to a feature-length Pixar movie, it is defined by points−or vectors−connected
    to show the desired shape. To create the drawing you want, you need to pick vectors
    in the right places, requiring careful measurement. Let’s take a look at how to
    measure vectors in the plane.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每当计算机显示2D或3D图形时，从我的简陋恐龙到一部完整的皮克斯电影，它都是由点或向量连接起来以显示所需形状定义的。要创建你想要的图形，你需要选择正确的位置向量，这需要仔细的测量。让我们看看如何在平面上测量向量。
- en: 2.1.1 Representing 2D vectors
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 表示2D向量
- en: With a ruler, we can measure one dimension such as the length of an object.
    To measure in two dimensions, we need two rulers *.* These rulers are called *axes*
    (the singular is *axis*), and we lay them out in the plane perpendicular to one
    another, intersecting at the origin. Drawn with axes, figure 2.4 shows that our
    dinosaur has the notions of up and down as well as left and right. The horizontal
    axis is called the *x-axis* and the vertical one is called the *y-axis*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用尺子，我们可以测量一个维度，例如物体的长度。要测量两个维度，我们需要两个尺子*.* 这些尺子被称为*坐标轴*（单数形式为*axis*），我们将它们布局在平面中相互垂直，并在原点相交。用坐标轴绘制的图2.4显示了我们的恐龙具有上下和左右的概念。水平轴被称为*x轴*，垂直轴被称为*y轴*。
- en: '![](../Images/CH02_F04_Orland.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F04_Orland.png)'
- en: Figure 2.4 The dinosaur drawn with an x-axis and a y-axis.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 使用x轴和y轴绘制的恐龙。
- en: With axes to orient us, we can say things like, “Four of the points are above
    and to the right of the origin.” But we’ll want to get more quantitative than
    that. A ruler has tick marks that show how many units along it we’ve measured.
    Likewise, in our 2D drawing, we can add grid lines perpendicular to the axes that
    show where points lie relative to them. By convention, we place the origin at
    tick 0 on both the x- and y-axes (figure 2.5).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标尺来定位，我们可以说，“四个点位于原点的上方和右侧。”但我们会希望比这更量化。尺子上带有刻度，显示我们沿着它测量的单位数。同样，在我们的二维图中，我们可以添加与坐标轴垂直的网格线，以显示点相对于它们的位置。按照惯例，我们在x轴和y轴的刻度0处放置原点（见图2.5）。
- en: In the context of this grid, we can measure vectors in the plane. For example,
    in figure 2.5, the tip of the dinosaur’s tail lines up with positive 6 on the
    x-axis and positive 4 on the y-axis. We could think of these distances as centimeters,
    inches, pixels, or any other unit of length, but usually we leave the units unspecified
    unless we have a particular application in mind.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个网格的背景下，我们可以测量平面中的向量。例如，在图2.5中，恐龙尾巴的尖端与x轴的正6和y轴的正4对齐。我们可以将这些距离视为厘米、英寸、像素或其他长度单位，但通常我们除非有特定的应用，否则不指定单位。
- en: '![](../Images/CH02_F05_Orland.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F05_Orland.png)'
- en: Figure 2.5 Grid lines let us measure the location of points relative to the
    axes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 网格线让我们能够测量点相对于坐标轴的位置。
- en: The numbers 6 and 4 are called the *x- and y-coordinates* of the point, and
    this is enough to tell us exactly what point we’re talking about. We typically
    write coordinates as an *ordered pair*(or *tuple* ) with the *x*-coordinate first
    and the *y*-coordinate second, for example, (6, 4). Figure 2.6 shows how we can
    now describe the same vector in three ways.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 数字6和4被称为该点的**x-和y坐标**，这足以告诉我们正在讨论哪个点。我们通常将坐标写成**有序对**（或**元组**），先写x坐标，再写y坐标，例如（6，4）。图2.6展示了我们现在可以用三种方式描述同一个向量。
- en: '![](../Images/CH02_F06_Orland.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F06_Orland.png)'
- en: Figure 2.6 Three mental models describing the same vector.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 描述相同向量的三个心智模型。
- en: From another pair of coordinates like (−3, 4.5), we can find the point in the
    plane or the arrow that represents them. To get to the point in the plane with
    these coordinates, start at the origin and then travel three grid lines to the
    left (because the *x*-coordinate is −3) and then four and a half grid lines up
    (where the *y*-coordinate is 4.5). The point won’t lie at the intersection of
    two grid lines, but that’s fine; any pair of real numbers gives us some point
    on the plane. The corresponding arrow will be the straight-line path from the
    origin to that location, which points up and to the left (northwest, if you prefer).
    Try drawing this example for yourself as practice!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一对坐标（-3，4.5）出发，我们可以找到平面上的点或表示它们的箭头。要到达具有这些坐标的平面上的点，从原点开始，然后向左移动三个网格线（因为x坐标是-3），然后向上移动四个半网格线（y坐标是4.5）。点不会位于两条网格线的交点处，但这没关系；任何一对实数都会给我们一个平面上的点。相应的箭头将是原点到该位置的直线路径，它指向上方和左方（如果你愿意，西北方）。试着自己画这个例子作为练习！
- en: 2.1.2 2D drawing in Python
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 Python中的2D绘图
- en: When you produce an image on a screen, you’re working in a 2D space. The pixels
    on the screen are the available points in that plane. These are labeled by whole
    number coordinates rather than real number coordinates, and you can’t illuminate
    the space between pixels. That said, most graphics libraries let you work with
    floating-point coordinates and automatically handle translating graphics to pixels
    on the screen.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在屏幕上生成图像时，你是在一个2D空间中工作。屏幕上的像素是该平面上的可用点。这些点用整数坐标而不是实数坐标标记，并且你不能照亮像素之间的空间。尽管如此，大多数图形库都允许你使用浮点坐标工作，并自动处理将图形转换为屏幕上的像素。
- en: 'We have plenty of language choices and libraries to specify graphics and to
    get them on the screen: OpenGL, CSS, SVG, and so on. Python has libraries like
    Pillow and Turtle that are well equipped for creating drawings with vector data.
    In this chapter, I use a small set of custom-built functions to create drawings,
    built on top of another Python library called Matplotlib. This lets us focus on
    using Python to build images with vector data. Once you understand this process,
    you’ll be able to pick up any of the other libraries easily.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多语言选择和库来指定图形并将它们显示在屏幕上：OpenGL、CSS、SVG等等。Python有像Pillow和Turtle这样的库，非常适合用矢量数据创建绘图。在本章中，我使用一组自定义构建的函数来创建绘图，这些函数建立在另一个名为Matplotlib的Python库之上。这使得我们可以专注于使用Python构建矢量数据的图像。一旦你理解了这个过程，你将能够轻松地掌握其他任何库。
- en: The most important function I’ve included, called `draw`, takes inputs representing
    geometric objects and keyword arguments specifying how you want your drawing to
    look. The Python classes listed in table 2.1 represent each kind of drawable geometric
    object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我包括的最重要函数是名为`draw`的函数，它接受表示几何对象的输入和指定你想要绘图外观的关键字参数。表2.1中列出的Python类代表每种可绘制的几何对象。
- en: Table 2.1 Some Python classes representing geometric figures, usable with the
    `draw` function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 一些表示几何图形的Python类，可用于`draw`函数。
- en: '| Class | Constructor example | Description |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 构造函数示例 | 描述 |'
- en: '| `Polygon` | `Polygon(*vectors)` | Draws a polygon whose vertices (corners)
    are represented by a list of vectors |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `Polygon` | `Polygon(*vectors)` | 绘制一个多边形，其顶点（角）由向量列表表示 |'
- en: '| `Points` | `Points(*vectors)` | Represents a list of points (dots) to draw,
    one at each of the input vectors |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `Points` | `Points(*vectors)` | 表示要绘制的点（圆点）的列表，每个输入向量对应一个点 |'
- en: '| `Arrow` | `Arrow(tip)``Arrow(tip, tail)` | Draws an arrow from the origin
    to the `tip` vector or from the `tail` vector to the `head` vector if a tail is
    specified |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `Arrow` | `Arrow(tip)``Arrow(tip, tail)` | 从原点绘制到`tip`向量的箭头，或者如果指定了尾部，则从`tail`向量绘制到`head`向量
    |'
- en: '| `Segment` | `Segment(start,end)` | Draws a line segment from the start to
    the vector end |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `Segment` | `Segment(start,end)` | 从起点到向量终点绘制线段 |'
- en: You can find these functions implemented in the file vector_drawing.py in the
    source code. At the end of the chapter, I’ll say a bit more about how these are
    implemented.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在源代码的`vector_drawing.py`文件中找到这些函数的实现。在章节末尾，我会简要说明这些是如何实现的。
- en: Note For this chapter (and each subsequent chapter), there is a Jupyter notebook
    in the source code folder showing how to run (in order) all of the code in the
    chapter, including importing the functions from the `vector_drawing` module. If
    you haven’t already, you can consult appendix A to get set up with Python and
    Jupyter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于本章（以及后续的每一章），源代码文件夹中都有一个Jupyter笔记本，展示了如何按顺序运行本章中的所有代码，包括从`vector_drawing`模块导入函数。如果您还没有设置，可以查阅附录A来配置Python和Jupyter。
- en: 'With these drawing functions in hand, we can draw the points outlining the
    dinosaur (figure 2.5):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些绘图函数后，我们可以绘制恐龙轮廓的点（图2.5）：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I didn’t write out the complete list of `dino_vectors`, but with the suitable
    collection of vectors, the code gives you the points shown in figure 2.7 (matching
    figure 2.5 as well).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有列出完整的`dino_vectors`列表，但有了合适的向量集合，代码会给出图2.7中显示的点（也匹配图2.5）。
- en: '![](../Images/CH02_F07_Orland.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F07_Orland.png)'
- en: Figure 2.7 Plotting the dinosaur’s points with the `draw` function in Python
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 使用Python的`draw`函数绘制恐龙的点
- en: 'As a next step in our drawing process, we can connect some dots. A first segment
    might connect the point (6, 4) with the point (3, 1) on the dinosaur’s tail. We
    can draw the points along with this new segment using this function call, and
    figure 2.8 shows the results:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的绘图过程中，下一步我们可以连接一些点。第一个线段可能连接恐龙尾巴上的点（6, 4）和点（3, 1）。我们可以使用这个函数调用绘制这些点以及新的线段，图2.8显示了结果：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](../Images/CH02_F08_Orland.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F08_Orland.png)'
- en: Figure 2.8 The dinosaur’s points with a line segment connecting the first two
    points (6, 4) and (3, 1)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 恐龙的两个点（6, 4）和（3, 1）之间的线段连接
- en: The line segment is actually the collection consisting of the points (6, 4)
    and (3, 1) as well as all of the points lying on the straight line between them.
    The `draw` function automatically colors all of the pixels at those points blue.
    The `Segment` class is a useful abstraction because we don’t have to build every
    segment from the points that make up our geometric object (in this case, the dinosaur).
    Drawing 20 more segments, we get the complete outline of the dinosaur (figure
    2.9).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 线段实际上是包含点（6, 4）和（3, 1）以及它们之间所有点的集合。`draw`函数自动将这些点的所有像素着色为蓝色。`Segment`类是一个有用的抽象，因为我们不需要从构成我们的几何对象（在这种情况下，是恐龙）的点构建每个线段。绘制20更多线段，我们得到恐龙的完整轮廓（图2.9）。
- en: '![](../Images/CH02_F09_Orland.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F09_Orland.png)'
- en: Figure 2.9 A total of 21 function calls give us 21 line segments, completing
    the outline of the dinosaur.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 总共21次函数调用产生了21条线段，完成了恐龙轮廓的绘制。
- en: In principle, we can now outline any kind of 2D shape we want, provided we have
    all of the vectors to specify it. Coming up with all of the coordinates by hand
    can be tedious, so we’ll start to look at ways to do computations with vectors
    to find their coordinates automatically.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从原则上讲，我们现在可以绘制任何我们想要的2D形状，只要我们拥有指定它的所有向量。手动计算所有坐标可能会很繁琐，所以我们将开始研究使用向量进行计算以自动找到它们的坐标的方法。
- en: 2.1.3 Exercises
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 练习
- en: '| **Exercise 2.1**: What are the x- and y-coordinates of the point at the tip
    of the dinosaur’s toe?**Solution**: (−1, −4) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **练习2.1**：恐龙脚尖的点的x和y坐标是什么？**解答**：（−1, −4）|'
- en: '| **Exercise 2.2**: Draw the point in the plane and the arrow corresponding
    to the point (2, −2).**Solution**: Represented as a point on the plane and an
    arrow, (2, −2) looks like this:![](../Images/CH02_F09_Orland_UN01.png)The point
    and arrow representing (2, −2) |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **练习2.2**：在平面上绘制点（2, −2）及其对应的箭头。**解答**：表示为平面上的点和箭头，（2, −2）看起来像这样：![图片](../Images/CH02_F09_Orland_UN01.png)表示（2,
    −2）的点和箭头|'
- en: '| **Exercise 2.3**: By looking at the locations of the dinosaur’s points, infer
    the remaining vectors not included in the `dino_vectors` list. For instance, I
    already included (6, 4), which is the tip of the dinosaur’s tail, but I didn’t
    include the point (−5, 3), which is a point on the dinosaur’s nose. When you’re
    done, `dino_vectors` should be a list of 21 vectors represented as coordinate
    pairs.**Solution**: The complete set of vectors outlining the dinosaur is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习2.3**：通过观察恐龙点的位置，推断出`dino_vectors`列表中未包含的剩余向量。例如，我已经包含了（6, 4），这是恐龙尾巴的尖端，但我没有包含点（-5,
    3），这是恐龙鼻尖上的一个点。当你完成时，`dino_vectors`应该是一个包含21个向量的列表，表示为坐标对。**解答**：恐龙轮廓的完整向量集如下：'
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 2.4**: Draw the dinosaur with the dots connected by constructing
    a `Polygon` object with the `dino_vectors` as its vertices.**Solution**:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习2.4**：通过构建一个以`dino_vectors`作为顶点的`Polygon`对象来连接点绘制恐龙。**解答**：'
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](../Images/CH02_F09_Orland_UN02.png)The dinosaur drawn as a polygon. |'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/CH02_F09_Orland_UN02.png)将恐龙绘制为多边形。|'
- en: '| **Exercise 2.5**: Draw the vectors `(x,x**2)` for *x* in the range from *x*
    = −10 to *x* = 11) as points (dots) using the `draw` function. What is the result?**Solution**:
    The pairs draw the graph for the function y = x², plotted for the integers from
    10 to 10:![](../Images/CH02_F09_Orland_UN03.png)Points on the graph for y = x²To
    make this graph, I used two keyword arguments for the `draw` function. The `grid`
    keyword argument of (1, 10) draws vertical grid lines every one unit and horizontal
    grid lines every ten units. The `nice_aspect_ratio` keyword argument set to `False`
    tells the graph it doesn’t have to keep the *x* -axis and the y-axis scales the
    same:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习2.5**：使用`draw`函数绘制*x*在从*x* = -10到*x* = 11范围内的`(x,x²)`向量作为点（圆点）。结果是什么？**解答**：这些点绘制了函数y
    = x²的图像，绘制了从10到10的整数：'
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 2.2 Plane vector arithmetic
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 平面向量算术
- en: 'Like numbers, vectors have their own kind of arithmetic; we can combine vectors
    with operations to make new vectors. The difference with vectors is that we can
    visualize the results. Operations from vector arithmetic all accomplish useful
    geometric transformations, not just algebraic ones. We’ll start with the most
    basic operation: *vector addition* .'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数字一样，向量也有它们自己的算术类型；我们可以通过操作来组合向量，从而得到新的向量。与向量不同的是，我们可以可视化结果。向量算术中的所有操作都完成了有用的几何变换，而不仅仅是代数变换。我们将从最基本操作开始：*向量加法*。
- en: 'Vector addition is simple to calculate: given two input vectors, you add their
    *x*-coordinates to get the resulting *x*-coordinate and then you add their *y*-coordinates
    to get the resulting *y*-coordinate. Creating a new vector with these summed coordinates
    gives you the *vector sum* of the original vectors. For instance, (4, 3) + (−1,
    1) = (3, 4) because 4 + (−1) = 3 and 3 + 1 = 4\. Vector addition is a one-liner
    to implement in Python:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 向量加法计算简单：给定两个输入向量，将它们的*x*坐标相加得到结果*x*坐标，然后将它们的*y*坐标相加得到结果*y*坐标。用这些相加的坐标创建一个新的向量，就得到了原始向量的*向量和*。例如，（4,
    3）+（-1, 1）=（3, 4），因为4 +（-1）= 3，3 + 1 = 4。在Python中实现向量加法是一行代码：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Because we can interpret vectors as arrows or as points in the plane, we can
    visualize the result of the addition in both ways (figure 2.10). As a point in
    the plane, you can reach (−1, 1) by starting at the origin, which is (0, 0), and
    move one unit to the left and one unit up. You reach the vector sum of (4, 3)
    + (−1, 1) by starting instead at (4, 3) and moving one unit to the left and one
    unit up. This is the same as saying you traverse one arrow and then traverse the
    second.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以将向量解释为箭头或平面上的点，因此我们可以用这两种方式可视化加法的结果（图2.10）。作为一个平面上的点，你可以从原点（0, 0）开始，向左移动一个单位，向上移动一个单位，就能到达点（-1,
    1）。通过从点（4, 3）开始，向左移动一个单位，向上移动一个单位，你可以得到向量之和（4, 3）+（-1, 1）。这也可以理解为先遍历一个箭头，然后遍历第二个箭头。
- en: '![](../Images/CH02_F10_Orland.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F10_Orland.png)'
- en: Figure 2.10 Picturing the vector sum of (4, 3) and (−1, 1)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 展示（4, 3）和（-1, 1）的向量和
- en: The rule for vector addition of arrows is sometimes called *tip-to-tail* addition.
    That’s because if you move the tail of the second arrow to the tip of the first
    (without changing its length or direction!), then the sum is the arrow from the
    start of the first to the end of the second (figure 2.11).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头向量加法的规则有时被称为*尾对尾*相加。这是因为如果你将第二个箭头的尾端移动到第一个箭头的尖端（不改变其长度或方向！），那么和就是从第一个箭头的起点到第二个箭头的终点的箭头（图2.11）。
- en: '![](../Images/CH02_F11_Orland.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F11_Orland.png)'
- en: Figure 2.11 Tip-to-tail addition of vectors
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 向量的尾对尾相加
- en: When we talk about arrows, we really mean “a specific distance in a specific
    direction.” If you walk one distance in one direction and another distance in
    another direction, the vector sum tells you the overall distance and direction
    you traveled (figure 2.12).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论箭头时，我们实际上是指“在特定方向上的特定距离。”如果你在一个方向上走一段距离，然后在另一个方向上走另一段距离，向量相加会告诉你你旅行的总距离和方向（图2.12）。
- en: '![](../Images/CH02_F12_Orland.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F12_Orland.png)'
- en: Figure 2.12 The vector sum as an overall distance and direction traveled in
    the plane.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 平面中旅行的总距离和方向向量和。
- en: 'Adding a vector has the effect of moving or *translating* an existing point
    or collection of points. If we add the vector (−1.5, −2.5) to every vector of
    `dino_vectors`, we get a new list of vectors, each of which is 1.5 units left
    and 2.5 units down from one of the original vectors. Here’s the code for that:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个向量会影响到移动或*平移*现有的点或点的集合。如果我们将向量（-1.5, -2.5）添加到`dino_vectors`中的每一个向量，我们就会得到一个新的向量列表，其中每个向量都相对于原始向量向左移动1.5个单位，向下移动2.5个单位。以下是相应的代码：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result is the same dinosaur shape shifted down and to the left by the vector
    (−1.5, −2.5). To see this (figure 2.13), we can draw both dinosaurs as polygons:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是相同的恐龙形状，通过向量（-1.5, -2.5）向下和向左移动。为了看到这一点（图2.13），我们可以将两个恐龙都画成多边形：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](../Images/CH02_F13_Orland.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F13_Orland.png)'
- en: Figure 2.13 The original dinosaur (blue) and the translated copy (red). Each
    point on the translated dinosaur is moved by (−1.5, −2.5) down and to the left
    from its location on the original dinosaur.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 原始恐龙（蓝色）和平移副本（红色）。平移后的恐龙上的每个点都从原始恐龙的位置向下和向左移动了（-1.5, -2.5）。
- en: 'The arrows in the copy on the right show that each point moved down and to
    the left by the same vector: (−1.5, −2.5). A translation like this is useful if,
    for instance, we want to make the dinosaur a moving character in a 2D computer
    game. Depending on the button pressed by the user, the dinosaur could translate
    in the corresponding direction on the screen. We’ll implement a real game like
    this with moving vector graphics in chapters 7 and 9.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧副本中的箭头显示每个点都通过相同的向量向下和向左移动：(-1.5, -2.5)。这种平移在例如，如果我们想将恐龙变成一个2D电脑游戏中的移动角色时很有用。根据用户按下的按钮，恐龙可以在屏幕上相应地平移。我们将在第7章和第9章中实现这样的真实游戏，使用移动向量图形。
- en: 2.2.1 Vector components and lengths
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 向量分量和长度
- en: Sometimes it’s useful to take a vector we already have and decompose it as a
    sum of smaller vectors. For example, if I were asking for walking directions in
    New York City, it would be much more useful to hear “go four blocks east and three
    blocks north” rather than “go 800 meters northeast.” Similarly, it can be useful
    to think of vectors as a sum of a vector pointing in the *x* direction and a vector
    pointing in the *y* direction.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将我们已有的向量分解为较小向量的和是有用的。例如，如果我需要纽约市的步行路线，听到“向东走四个街区，向北走三个街区”会比听到“向东北方向走800米”更有用。同样，将向量视为指向*x*方向的向量与指向*y*方向的向量的和也是有用的。
- en: As an example, figure 2.14 shows the vector (4, 3) rewritten as the sum (4,
    0) + (0, 3). Thinking of the vector (4, 3) as a navigation path in the plane,
    the sum (4, 0) + (0, 3) gets us to the same point along a different path.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，图2.14显示了向量（4, 3）被重写为和（4, 0）+（0, 3）。将向量（4, 3）视为平面上的导航路径，和（4, 0）+（0, 3）将我们带到相同的位置，但路径不同。
- en: '![](../Images/CH02_F14_Orland.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F14_Orland.png)'
- en: Figure 2.14 Breaking the vector (4, 3) into the sum (4, 0) + (0, 3)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 将向量（4, 3）分解为和（4, 0）+（0, 3）
- en: The two vectors (4, 0) and (0, 3) are called the *x and y components*, respectively.
    If you couldn’t walk diagonally in this plane (as if it were New York City), you
    would need to walk four units to the right and then three units up to get to the
    same destination, a total of seven units.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量(4, 0)和(0, 3)分别称为**x和y分量**。如果你不能在这个平面上斜着走（就像纽约市一样），你需要向右走四个单位，然后向上走三个单位才能到达同一个目的地，总共七个单位。
- en: 'The *length* of a vector is the length of the arrow that represents it, or
    equivalently, the distance from the origin to the point that represents it. In
    New York City, this could be the distance between two intersections “as the crow
    flies.” The length of a vector in the *x* or *y* direction can be measured immediately
    as a number of ticks passed on the corresponding axis: (4, 0) or (0, 4) are both
    vectors of the same length, 4, albeit in different directions. In general, though,
    vectors can lie diagonally, and we need to do a calculation to get their lengths.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的**长度**是表示它的箭头的长度，或者等价地，从原点到表示它的点的距离。在纽约市，这可能是两个交叉口的“飞鸟距离”。向量在**x**或**y**方向的长度可以立即作为对应轴上经过的刻度数来衡量：(4,
    0)或(0, 4)都是长度相同的向量，都是4，尽管方向不同。然而，一般来说，向量可以沿着对角线放置，我们需要进行计算来得到它们的长度。
- en: 'You may recall the relevant formula: the *Pythagorean theorem* . For a right
    triangle (a triangle having two sides meeting at a 90° angle), the Pythagorean
    theorem says that the square of the length of the longest side is the sum of squares
    of the lengths of the other two sides. The longest side is called the *hypotenuse*
    , and its length is denoted by *c* in the memorable formula *a*² + *b*² = *c*²,
    where *a* and *b* are the lengths of the other two sides. With *a* = 4 and *b*
    = 3, we can find *c* as the square root of 4² + 3² (figure 2.15).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得相关的公式：**勾股定理**。对于直角三角形（两个边在90°角相遇的三角形），勾股定理表明最长边的长度的平方是其他两边长度的平方和。最长边称为**斜边**，其长度用公式中的*c*表示，即*a*²
    + *b*² = *c*²，其中*a*和*b*是其他两边的长度。当*a* = 4且*b* = 3时，我们可以通过计算4² + 3²的平方根来找到*c*（如图2.15）。
- en: '![](../Images/CH02_F15_Orland.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F15_Orland.png)'
- en: Figure 2.15 Using the Pythagorean theorem to find the length of a vector from
    the lengths of its x- and y- components
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 使用勾股定理从x和y分量的长度找到向量的长度
- en: Breaking a vector into components is handy because it always gives us a right
    triangle. If we know the lengths of the components, we can compute the length
    of the hypotenuse, which is the length of the vector. Our vector (4, 3) is equal
    to (4, 0) + (0, 3), a sum of two perpendicular vectors whose sides are 4 and 3,
    respectively. The length of the vector (4, 3) is the square root of 4² + 3², which
    is the square root of 25, or 5\. In a city with perfectly square blocks, traveling
    4 blocks east and 3 blocks north would take us the equivalent of 5 blocks northeast.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将向量分解为分量是有用的，因为它总是给我们一个直角三角形。如果我们知道分量的长度，我们可以计算斜边的长度，即向量的长度。我们的向量(4, 3)等于(4,
    0) + (0, 3)，这是两个垂直向量的和，其边长分别为4和3。向量(4, 3)的长度是4² + 3²的平方根，即25的平方根，或5。在一个完美方形的街区中，向东走4个街区，向北走3个街区，相当于向东北方向走了5个街区。
- en: 'This is a special case where the distance turns out to be an integer, but typically,
    lengths that come out of the Pythagorean theorem are not whole numbers. The length
    of (−3, 7) is given in terms of the lengths of its components 3 and 7 by the following
    computation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特殊情况，其中距离结果是整数，但通常，来自勾股定理的长度不是整数。向量(−3, 7)的长度通过以下计算以其组成部分3和7的长度表示：
- en: '![](../Images/CH02_F15_Orland_EQ01.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F15_Orland_EQ01.png)'
- en: 'We can translate this formula into a `length` function in Python, which takes
    a 2D vector and returns its floating-point length:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个公式转换为Python中的`length`函数，它接受一个二维向量并返回其浮点长度：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 2.2.2 Multiplying vectors by numbers
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 向量乘以数字
- en: Repeated addition of vectors is unambiguous; you can keep stacking arrows tip-to-tail
    as long as you want. If a vector named ***v*** has coordinates (2, 1), then the
    fivefold sum ***v*** + ***v*** + ***v*** + ***v*** + ***v*** would look like that
    shown in figure 2.16.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的重复相加是不含糊的；你可以一直将箭头尾对尾堆叠，直到你想要为止。如果一个名为***v***的向量坐标为(2, 1)，那么五次相加***v*** +
    ***v*** + ***v*** + ***v*** + ***v***将看起来像图2.16所示的那样。
- en: '![](../Images/CH02_F16_Orland.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F16_Orland.png)'
- en: Figure 2.16 Repeated addition of the vector *v* = (2, 1) with itself
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 向量*v* = (2, 1)与其自身的重复相加
- en: If ***v*** were a number, we wouldn’t bother writing ***v*** + ***v*** + ***v***
    + ***v*** + ***v***. Instead, we’d write the simpler product 5 · ***v***. There’s
    no reason we can’t do the same for vectors. The result of
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ***v*** 是一个数，我们不会费心写出 ***v*** + ***v*** + ***v*** + ***v*** + ***v***。相反，我们会写更简单的乘积
    5 · ***v***。我们没有理由不能对向量做同样的事情。向量的结果
- en: adding ***v*** to itself 5 times is a vector in the same direction but with
    5 times the length. We can run with this definition, which lets us multiply a
    vector by any whole or fractional number.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ***v*** 加上自己5次是一个方向相同但长度增加5倍的向量。我们可以继续使用这个定义，它允许我们用任何整数或分数数乘以向量。
- en: The operation of multiplying a vector by a number is called *scalar multiplication*
    . When working with vectors, ordinary numbers are often called *scalars* . It’s
    also an appropriate term because the effect of this operation is *scaling* the
    target vector by the given factor. It doesn’t matter if the scalar is a whole
    number; we can easily draw a vector that is 2.5 times the length of another (figure
    2.17).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将向量乘以数字的操作称为 *标量乘法*。当处理向量时，普通数字通常称为 *标量*。这也是一个合适的术语，因为这种操作的效果是 *按给定因子缩放* 目标向量。标量是否为整数无关紧要；我们可以轻松地画出一个长度是另一个向量2.5倍的向量（图2.17）。
- en: '![](../Images/CH02_F17_Orland.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F17_Orland.png)'
- en: Figure 2.17 Scalar multi-plication of a vector *v* by 2.5
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 向量 *v* 的标量乘法为2.5
- en: The result on the vector components is that each component is scaled by the
    same factor. You can picture scalar multiplication as changing the size of the
    right triangle defined by a vector and its components, but not affecting its aspect
    ratio. Figure 2.18 superimposes a vector ***v*** and its scalar multiple 1.5 ·
    ***v***, where the scalar multiple is 1.5 times as long. Its components are also
    1.5 times the length of the original components of ***v***.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 向量分量的结果是每个分量都按相同的因子缩放。你可以将标量乘法想象成改变由向量及其分量定义的直角三角形的尺寸，但不会影响其纵横比。图2.18叠加了一个向量
    ***v*** 和其标量乘积1.5 · ***v***，其中标量乘积是1.5倍长。其分量也是 ***v*** 原始分量的1.5倍长。
- en: '![](../Images/CH02_F18_Orland.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F18_Orland.png)'
- en: Figure 2.18 Scalar multiplication of a vector scales both components by the
    same factor.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 向量的标量乘法按相同因子缩放两个分量。
- en: 'In coordinates, the scalar multiple of 1.5 times the vector ***v*** = (6, 4)
    gives us a new vector (9, 6), where each component is 1.5 times its original value.
    Computationally, we execute any scalar multiplication on a vector by multiplying
    each coordinate of the vector by the scalar. As a second example, scaling a vector
    ***w*** = (1.2, −3.1) by a factor 6.5 can be accomplished like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在坐标中，向量 ***v*** = (6, 4) 的1.5倍标量乘法给我们一个新的向量 (9, 6)，其中每个分量是其原始值的1.5倍。在计算上，我们通过将向量的每个坐标乘以标量来执行任何标量乘法。作为第二个例子，将向量
    ***w*** = (1.2, −3.1) 以因子6.5进行缩放可以这样做：
- en: 6.5 · *w* = 6.5 · (1.2, −3.1) = (6.5 · 1.2, 6.5 · −3.1) = (7.8, −20.15)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 6.5 · *w* = 6.5 · (1.2, −3.1) = (6.5 · 1.2, 6.5 · −3.1) = (7.8, −20.15)
- en: We tested this method for a fractional number as the scalar, but we should also
    test a negative number. If our original vector is (6, 4), what is −½ times that
    vector? Multiplying the coordinates, we expect the answer to be (−3, −2). Figure
    2.19 shows that this vector is half the length of the original and points in the
    opposite direction.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试了这个方法，将分数数作为标量，但我们也应该测试负数。如果我们的原始向量是 (6, 4)，那么该向量的−½倍是多少？乘以坐标，我们预计答案将是 (−3,
    −2)。图2.19显示这个向量是原始长度的一半，并且指向相反方向。
- en: '![](../Images/CH02_F19_Orland.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F19_Orland.png)'
- en: Figure 2.19 Scalar multiplication of a vector by a negative number, −½
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19 向量乘以负数，−½
- en: 2.2.3 Subtraction, displacement, and distance
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 减法、位移和距离
- en: Scalar multiplication agrees with our intuition for multiplying numbers. A whole
    number multiple of a number is the same as a repeated sum, and the same holds
    for vectors. We can make a similar argument for negative vectors and vector subtraction.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 标量乘法与我们对乘以数字的直觉一致。一个数的整数倍与重复求和相同，对于向量也是如此。我们可以对负向量和向量减法提出类似的论点。
- en: Given a vector ***v***, the *opposite* vector, -***v***, is the same as the
    scalar multiple −1 · ***v***. If ***v*** is (−4, 3), its opposite, -***v***, is
    (4, −3) as shown in figure 2.20\. We get this by multiplying each coordinate by
    −1, or in other words, changing the sign of each.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个向量 ***v***，其 *相反向量*，-***v***，与标量乘法 −1 · ***v*** 相同。如果 ***v*** 是 (−4, 3)，其相反向量，-***v***，是
    (4, −3)，如图2.20所示。我们通过将每个坐标乘以-1得到这个结果，换句话说，改变每个坐标的符号。
- en: '![](../Images/CH02_F20_Orland.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F20_Orland.png)'
- en: Figure 2.20 The vector *v* = (−4, 3) and its opposite −*v* = (4, −3).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 向量 *v* = (−4, 3) 和其相反向量 −*v* = (4, −3)。
- en: 'On the number line, there are only two directions from zero: positive and negative.
    In the plane, there are many directions (infinitely many, in fact), so we can’t
    say that one of ***v*** and -***v*** is positive while the other is negative.
    What we can say is that for any vector ***v***, the opposite vector -***v*** will
    have the same length, but it will point in the opposite direction.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在数轴上，从零只有两个方向：正方向和负方向。在平面上，有无数个方向（实际上确实如此），所以我们不能说 ***v*** 和 -***v*** 中的一个为正，另一个为负。我们可以说的是，对于任何向量
    ***v***，其相反向量 -***v*** 将具有相同的长度，但方向相反。
- en: Having a notion of negating a vector, we can define *vector subtraction* . For
    numbers, *x* − *y* is the same as *x* + (−*y*). We set the same convention for
    vectors. To subtract a vector ***w*** from a vector ***v***, you add the vector
    -***w*** to ***v***. Thinking of vectors ***v*** and ***w*** as points, ***v***
    − ***w*** is the position of ***v*** relative to ***w***. Thinking instead of
    ***v*** and ***w*** as arrows beginning at the origin, figure 2.21 shows that
    ***v*** − ***w*** is the arrow from the tip of ***w*** to the tip of ***v***.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有向量取反的概念后，我们可以定义 *向量减法*。对于数字，*x* − *y* 与 *x* + (−*y*) 相同。我们为向量设定相同的规则。要从向量 ***v***
    中减去向量 ***w***，你需要在 ***v*** 中加上向量 -***w***。将向量 ***v*** 和 ***w*** 视为点，***v*** −
    ***w*** 是 ***v*** 相对于 ***w*** 的位置。相反，将 ***v*** 和 ***w*** 视为从原点开始的箭头，图 2.21 显示
    ***v*** − ***w*** 是从 ***w*** 的尖端到 ***v*** 的尖端的箭头。
- en: '![](../Images/CH02_F21_Orland.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F21_Orland.png)'
- en: Figure 2.21 The result of subtracting *v* − *w* is an arrow from the tip of
    *w* to the tip of v.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21 减去 *v* − *w* 的结果是 *w* 的尖端到 *v* 的尖端的箭头。
- en: The coordinates of ***v*** − ***w*** are the differences of the coordinates
    ***v*** and ***w***. In figure 2.21, ***v***  = (−1, 3) and ***w*** = (2, 2).
    The difference for ***v*** − ***w*** has the coordinates (−1 − 2, 3 − 2) = (−3,
    1).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '***v*** − ***w*** 的坐标是 ***v*** 和 ***w*** 的坐标之差。在图 2.21 中，***v*** = (−1, 3)
    和 ***w*** = (2, 2)。***v*** − ***w*** 的差异坐标为 (−1 − 2, 3 − 2) = (−3, 1)。'
- en: 'Let’s look at the difference of the vectors ***v*** = (−1, 3) and ***w*** =
    (2, 2) again. You can use the `draw` function I gave you to plot the points ***v***
    and ***w*** and to draw a segment between them. The code looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看向量 ***v*** = (−1, 3) 和 ***w*** = (2, 2) 的差异。你可以使用我给你的 `draw` 函数来绘制点 ***v***
    和 ***w***，并在它们之间绘制线段。代码如下：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The difference for the vectors ***v*** − ***w*** = (−3, 1) tells us that if
    we start at point *w*, we need to go three units left and one unit up to get to
    point *v*. This vector is sometimes called the *displacement* from ***w*** to
    ***v***. The straight, red line segment from ***w*** to ***v*** in figure 2.22,
    drawn by this Python code, shows the *distance* between the two points.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 ***v*** − ***w*** = (−3, 1) 的差异告诉我们，如果我们从点 *w* 出发，我们需要向左移动三个单位，向上移动一个单位才能到达点
    *v*。这个向量有时被称为从 ***w*** 到 ***v*** 的 *位移*。图 2.22 中由这段 Python 代码绘制的从 ***w*** 到 ***v***
    的直线、红色线段显示了这两个点之间的 *距离*。
- en: '![](../Images/CH02_F22_Orland.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F22_Orland.png)'
- en: Figure 2.22 The distance between two points in the plane
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22 平面上两点之间的距离
- en: 'The length of the line segment is computed with the Pythagorean theorem as
    follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 线段长度的计算使用勾股定理如下：
- en: '![](../Images/CH02_F22_Orland_EQ02.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F22_Orland_EQ02.png)'
- en: While the displacement is a vector, the distance is a scalar (a single number).
    The distance on its own is not enough to specify how to get from ***w*** to ***v***
    ; there are plenty of points that have the same distance from ***w***. Figure
    2.23 shows a few others with whole number coordinates.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然位移是一个向量，但距离是一个标量（一个单一的数字）。仅距离本身不足以指定如何从 ***w*** 到 ***v***；有许多点与 ***w*** 的距离相同。图
    2.23 显示了一些具有整数坐标的其他点。
- en: '![](../Images/CH02_F23_Orland.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F23_Orland.png)'
- en: Figure 2.23 Several points equidistant from *w* = (2, 2)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.23 与 *w* = (2, 2) 等距离的几个点
- en: 2.2.4 Exercises
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.4 练习
- en: '| **Exercise 2.6**: If the vector *u* = (−2, 0), the vector *v* = (1.5, 1.5),
    and the vector *w* = (4, 1), what are the results of *u* + *v*, *v* + *w*, and
    u *+* *w*? What is the result of *u* + v *+* *w*?**Solution**: With the vector
    *z* = (−2, 0), the vector *v* = (1.5, 1.5), and the vector *w* = (4, 1), the results
    are as follows:*u + v* = (−0.5, 1.5)*v + w* = (5.5, 2.5)*u + w* = (2, 1)*u* +
    *v* + *w* = (3.5, 2.5) |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.6**: 如果向量 *u* = (−2, 0)，向量 *v* = (1.5, 1.5)，以及向量 *w* = (4, 1)，那么 *u*
    + *v*，*v* + *w*，以及 u *+* *w* 的结果是什么？*u* + v *+* *w* 的结果是什么？**解答**：给定向量 *z* = (−2,
    0)，向量 *v* = (1.5, 1.5)，以及向量 *w* = (4, 1)，结果如下：*u + v* = (−0.5, 1.5)*v + w* = (5.5,
    2.5)*u + w* = (2, 1)*u* + *v* + *w* = (3.5, 2.5) |'
- en: '| **Exercise 2.7-Mini Project**: You can add any number of vectors together
    by summing all of their *x*-coordinates and *all* of their *y*-coordinates. For
    instance, the fourfold sum (1, 2) + (2, 4) + (3, 6) + (4, 8) has *x* component
    1 + 2 + 3 + 4 = 10 and *y* component 2 + 4 + 6 + 8 = 20, making the result (10,
    20). Implement a revised `add` function that takes any number of vectors as arguments.**Solution**:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 2.7-迷你项目**：你可以通过将所有向量的 *x* 坐标和所有向量的 *y* 坐标相加来相加任意数量的向量。例如，四重和 (1, 2)
    + (2, 4) + (3, 6) + (4, 8) 的 *x* 分量为 1 + 2 + 3 + 4 = 10，*y* 分量为 2 + 4 + 6 + 8
    = 20，因此结果是 (10, 20)。实现一个修改后的 `add` 函数，该函数接受任意数量的向量作为参数。**解答**:'
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 2.8**: Write a function `translate(translation,` `vectors)` that
    takes a translation vector and a list of input vectors, and returns a list of
    the input vectors all translated by the translation vector. For instance, `translate
    ((1,1),` `[(0,0),` `(0,1,),` `(−3,−3)])` should return `[(1,1),(1,2),(−2, −2)]`.**Solution**:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 2.8**：编写一个函数 `translate(translation, vectors)`，该函数接受一个平移向量和输入向量的列表，并返回一个列表，其中所有输入向量都通过平移向量进行了平移。例如，`translate
    ((1,1), [(0,0), (0,1,), (−3,−3)])` 应返回 `[(1,1),(1,2),(−2, −2)]`。**解答**:'
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 2.9−Mini Project**: Any sum of vectors *v* + *w* gives the same
    result as *w* + v. Explain why this is true using the definition of the vector
    sum on coordinates. Also, draw a picture to show why it is true geometrically.**Solution**:
    If you add two vectors *z* = (*a, b*) and *v* = (*c*, *d*), the coordinates *a*,
    b, c, and d are all real numbers. The result of the vector addition is *z* + *v*
    = (a + c, b + d). The |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.9-迷你项目**：任意向量之和 *v* + *w* 给出的结果与 *w* + v 相同。使用坐标上的向量加法定义解释为什么这是真的。同时，画一个图来展示为什么在几何上这也是真的。**解答**：如果你将两个向量
    *z* = (*a, b*) 和 *v* = (*c*, *d*) 相加，坐标 *a*，*b*，*c*，和 *d* 都是实数。向量加法的结果是 *z* +
    *v* = (a + c, b + d)。结果 |'
- en: '| result of *v* + *z* is (c + a, d + b), which is the same pair of coordinates
    because order doesn’t matter when adding real numbers. Tip-to-tail addition in
    either order yields the same sum vector. Visually, we can see this by adding an
    example pair of vectors tip-to-tail:![](../Images/CH02_F23_Orland_UN04.png)Tip-to-tail
    addition in either order yields the same sum vector.It doesn’t matter whether
    you add *z* + *v* or *v* + *z*(dashed lines), you get the same result vector (solid
    line). In geometric terms, ***u*** and ***v*** define a parallelogram, and the
    vector sum is the length of the diagonal. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 结果为 *v* + *z* 是 (c + a, d + b)，这是一对相同的坐标，因为加实数时顺序无关。无论以何种顺序尾对尾加法，都会得到相同的和向量。从视觉上看，我们可以通过添加一个示例向量对尾对尾来看到这一点：![](../Images/CH02_F23_Orland_UN04.png)无论以何种顺序尾对尾加法，都会得到相同的和向量。无论你加
    *z* + *v* 还是 *v* + *z*（虚线），你都会得到相同的结果向量（实线）。在几何术语中，***u*** 和 ***v*** 定义了一个平行四边形，向量之和是对角线的长度。
    |'
- en: '| **Exercise 2.10**: Among the following three arrow vectors (labeled *u*,
    *v*, and w), which pair has the sum that gives the longest arrow? Which pair sums
    to give the shortest arrow?![](../Images/CH02_F23_Orland_UN05.png)Which pair sums
    to the longest or shortest arrow?**Solution**: We can measure each of the vector
    sums by placing the vectors tip-to-tail:![](../Images/CH02_F23_Orland_UN06.png)Tip-to-tail
    addition of the vectors in questionInspecting the results, we can see that *v*
    + *z* is the shortest vector (u and *v* are in nearly opposite directions and
    come close to canceling each other out). The longest vector is *v* + w. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.10**：在以下三个箭头向量（标记为 *u*，*v* 和 *w*）中，哪一对的和给出了最长的箭头？哪一对的和给出了最短的箭头？！[](../Images/CH02_F23_Orland_UN05.png)哪一对的和给出了最长或最短的箭头？**解答**：我们可以通过将向量尾对尾放置来测量每个向量之和：![](../Images/CH02_F23_Orland_UN06.png)尾对尾加法检查结果，我们可以看到
    *v* + *z* 是最短的向量（*u* 和 *v* 几乎在相反的方向上，几乎相互抵消）。最长的向量是 *v* + *w*。 |'
- en: '| **Exercise 2.11-Mini Project**: Write a Python function using vector addition
    to show 100 simultaneous and non-overlapping copies of the dinosaur. This shows
    the power of computer graphics; imagine how tedious it would be to specify all
    2,100 coordinate pairs by hand!**Solution**: With some trial and error, you can
    translate the dinosaurs in the vertical and horizontal direction so that they
    don’t overlap, and set the boundaries appropriately. I decided to leave out the
    grid lines, axes, origin, and points to make the drawing clearer. My code looks
    like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习2.11-迷你项目**：编写一个Python函数，使用向量加法来显示100个同时且不重叠的恐龙副本。这展示了计算机图形的强大功能；想象一下，如果用手动指定所有2,100个坐标对将多么繁琐！**解答**：通过一些尝试和错误，你可以将恐龙在垂直和水平方向上平移，使它们不重叠，并适当地设置边界。我决定省略网格线、坐标轴、原点和点，以使绘图更清晰。我的代码如下：'
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The result is as follows:![](../Images/CH02_F23_Orland_UN07.png)100 dinosaurs.
    Run for your life! |
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：![](../Images/CH02_F23_Orland_UN07.png)100只恐龙。快跑吧！ |
- en: '| **Exercise 2.12**: Which is longer, the *x* or y component of (3, −2) + (1,
    1) + (−2, −2)?**Solution**: The result of the vector sum (3, −2) + (1, 1) + (−2,
    −2) is (2, −3). The *x* component is (2, 0) and the *y* component is (0, −3).
    The *x* component has a length of 2 units (to the right), while the y component
    has a length of 3 units (downward because it is negative). This makes the *y*
    component longer. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **练习2.12**：在向量(3, −2) + (1, 1) + (−2, −2)中，*x*分量和*y*分量哪个更长？**解答**：向量(3, −2)
    + (1, 1) + (−2, −2)的和是(2, −3)。*x*分量是(2, 0)，*y*分量是(0, −3)。*x*分量的长度是2个单位（向右），而*y*分量的长度是3个单位（向下，因为它是负数）。这使得*y*分量更长。
    |'
- en: '| **Exercise 2.13**: What are the components and lengths of the vectors (−6,
    −6) and (5, −12)?**Solution**: The components of (−6, −6) are (−6, 0) and (0,
    −6), both having length 6\. The length of (−6, −6) is the square root of 6² +
    6², which is approximately 8.485.The components of (5, −12) are (5, 0) and (0,
    −12), having lengths of 5 and 12, respectively. The length of (5, −12) is given
    by the square root of 5² + 12² = 25 + 144 = 169\. The result of the square root
    is exactly 13. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **练习2.13**：向量(−6, −6)和(5, −12)的分量和长度是什么？**解答**：(−6, −6)的分量是(−6, 0)和(0, −6)，两者长度都是6。向量(−6,
    −6)的长度是6² + 6²的平方根，大约是8.485。向量(5, −12)的分量是(5, 0)和(0, −12)，长度分别为5和12。向量(5, −12)的长度由5²
    + 12² = 25 + 144 = 169的平方根给出。平方根的结果正好是13。 |'
- en: '| **Exercise 2.14**: Suppose I have a vector ***v*** that has a length of 6
    and an *x* component (1, 0). What are the possible coordinates of ***v*** ?**Solution**:
    The *x* component of (1, 0) has length 1 and the total length is 6, so the length
    b of the *y* component must satisfy the equation 1² + b² = 6², or 1 + b² = 36\.
    Then b² = 35 and the length of the *y* component is approximately 5.916\. This
    doesn’t tell us the direction of the *y* component, however. The vector ***v***
    could either be (1, 5.916) or (1, −5.916). |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **练习2.14**：假设我有一个向量***v***，其长度为6，*x*分量为(1, 0)。***v***的可能坐标是什么？**解答**：(1,
    0)的*x*分量长度为1，总长度为6，因此*y*分量的长度b必须满足方程1² + b² = 6²，即1 + b² = 36。然后b² = 35，*y*分量的长度大约为5.916。然而，这并没有告诉我们*y*分量的方向。向量***v***可以是(1,
    5.916)或(1, −5.916)。 |'
- en: '| **Exercise 2.15**: What vector in the `dino_vectors` list has the longest
    length? Use the `length` function we wrote to compute the answer quickly.**Solution**:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习2.15**：`dino_vectors`列表中的哪个向量长度最长？使用我们编写的`length`函数快速计算答案。**解答**：'
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 2.16**: Suppose a vector *w* has the coordinates (√2, √3). What
    are the approximate coordinates of the scalar multiple *π* · *w*? Draw an approximation
    of the original vector and the new vector.**Solution**: The value of (√2, √3)
    is approximately(1.4142135623730951, 1.7320508075688772)Scaling each coordinate
    by a factor of *π*(pi), we get(4.442882938158366, 5.441398092702653)The scaled
    vector is longer than the original as shown here:![](../Images/CH02_F23_Orland_UN08.png)The
    original vector (shorter) and its scaled version (longer) |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **练习2.16**：假设向量*w*的坐标是(√2, √3)。*π*乘以*w*的大致坐标是什么？画出原始向量和新向量的近似图。**解答**：(√2,
    √3)的值大约是(1.4142135623730951, 1.7320508075688772)。将每个坐标乘以*π*（pi）的因子，我们得到(4.442882938158366,
    5.441398092702653)。缩放后的向量比原始向量更长，如图所示：![](../Images/CH02_F23_Orland_UN08.png)原始向量（较短）及其缩放版本（较长）
    |'
- en: '| **Exercise 2.17**: Write a Python function `scale(s,v)` that multiplies the
    input vector ***v*** by the input scalar *s*.**Solution**:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习2.17**：编写一个Python函数`scale(s,v)`，该函数将输入向量***v***乘以输入标量*s*。**解答**：'
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 2.18−Mini Project**: Convince yourself algebraically that scaling
    the coordinates by a factor also scales the length of the vector by the same factor.
    Suppose a vector of length *c* has the coordinates (*a, b*). Show that for any
    non-negative real number *s*, the length of (*s *· *a, s* · *b*) is *s* · *c*.
    (This can’t work for a negative value of *s* because a vector can’t have a negative
    length.)**Solution**: We use the notation &#124;(*a, b*)&#124; to denote the length
    of a vector (*a, b*). So, the premise of the exercise tells us:![](../Images/CH02_F23_Orland_UN08_EQ03.png)From
    that, we can compute the length of (*sa*, *sb*):![](../Images/CH02_F23_Orland_UN08_EQ04.png)As
    long as s isn’t negative, it’s the same as its absolute value: *s* = &#124;*s*&#124;.
    Then the length of the scaled vector is sc as we hoped to show. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.18-迷你项目**：通过代数证明通过一个因子缩放坐标也会以相同的因子缩放向量的长度。假设一个长度为 *c* 的向量坐标为 (*a,
    b*). 证明对于任何非负实数 *s*，向量 (*s *· *a, s* · *b*) 的长度是 *s* · *c*。 (对于 *s* 的负值，这是不可能的，因为向量不能有负长度。)**解答**：我们使用符号
    &#124;(*a, b*)&#124; 表示向量 (*a, b*) 的长度。因此，练习的前提告诉我们：![](../Images/CH02_F23_Orland_UN08_EQ03.png)从那，我们可以计算
    (*sa*, *sb*) 的长度：![](../Images/CH02_F23_Orland_UN08_EQ04.png)只要 s 不是负数，它就与其绝对值相同：*s*
    = &#124;*s*&#124;。然后缩放向量的长度是 sc，正如我们希望证明的那样。|'
- en: '| **Exercise 2.19−Mini Project**: Suppose *z* = (−1, 1) and *v* = (1, 1), and
    suppose *r* and *s* are real numbers. Specifically, let’s assume −3 < r < 3 and
    −1 < s < 1\. Where are the possible points on the plane where the vector r · *z*
    + *s* · *v* could end up?Note that the order of operations is the same for vectors
    as it is for numbers. We assume scalar multiplication is carried out first and
    then vector addition (unless parentheses specify otherwise).**Solution**: If *r*
    = 0, the possibilities lie on the line segment from (−1, −1) to (1, 1). If r is
    not zero, the possibilities can leave that line segment in the direction of (−1,
    1) or −(−1, 1) by up to three units. The region of possible results is the parallelogram
    with vertices at (2, 4), (4, 2), (2, −4), and (4, −2). We can test many random,
    allowable values of **r** and **s** to validate this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 2.19-迷你项目**：假设 *z* = (−1, 1) 和 *v* = (1, 1)，并且假设 *r* 和 *s* 是实数。具体来说，让我们假设
    −3 < r < 3 和 −1 < s < 1\. 在平面上，哪些可能的点使得向量 r · *z* + *s* · *v* 可能结束？请注意，向量的运算顺序与数字相同。我们假设标量乘法先进行，然后是向量加法（除非括号有其他指定）。**解答**：如果
    *r* = 0，可能的位置在从 (−1, −1) 到 (1, 1) 的线段上。如果 r 不为零，可能的位置可以通过向 (−1, 1) 或 −(−1, 1)
    方向移动最多三个单位离开那条线段。可能结果的范围是顶点在 (2, 4)，(4, 2)，(2, −4)，和 (4, −2) 的平行四边形。我们可以测试许多随机、允许的
    **r** 和 **s** 的值来验证这一点：'
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you run this code, you get a picture like the following, showing the possible
    points where r • *z* + s • *v* could end up given the constraints:![](../Images/CH02_F23_Orland_UN09.png)Location
    of possible points for *r* ∙ *u* + s ∙ *v* given the constraints. |
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此代码，你会得到以下图片，显示了在给定约束条件下 r • *z* + s • *v* 可能结束的可能点：![图片](../Images/CH02_F23_Orland_UN09.png)给定约束条件下
    *r* ∙ *u* + s ∙ *v* 的可能点位置。|
- en: '| **Exercise 2.20**: Show algebraically why a vector and its opposite have
    the same length.**Hint**: Plug the coordinates and their opposites into the Pythagorean
    theorem.**Solution**: The opposite vector of (*a*, *b*) has coordinates (− *a*,
    − *b*), but this doesn’t affect the length:![](../Images/CH02_F23_Orland_UN09_EQ05.png)The
    vector (−*a*, −b) has the same length as (*a, b*). |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.20**：通过代数证明一个向量及其相反向量具有相同的长度。**提示**：将坐标及其相反数代入勾股定理。**解答**：向量 (*a*,
    *b*) 的相反向量坐标为 (− *a*, − *b*), 但这不会影响长度：![](../Images/CH02_F23_Orland_UN09_EQ05.png)向量
    (−*a*, −b) 与 (*a, b*) 具有相同的长度。|'
- en: '| **Exercise 2.21**: Of the following seven vectors, represented as arrows,
    which two are a pair of opposite vectors?![](../Images/CH02_F23_Orland_UN10.png)**Solution**:
    Vectors v3 and v7 are the pair of opposite vectors. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.21**：在以下七个向量中，哪些两个是相反向量的一对？！![图片](../Images/CH02_F23_Orland_UN10.png)**解答**：向量
    v3 和 v7 是一对相反向量。|'
- en: '| **Exercise 2.22**: Suppose *z* is any 2D vector. What are the coordinates
    of *z* + -u?**Solution**: A 2D vector *z* has some coordinates (*a*, *b*). Its
    opposite has coordinates (− *a*, − *b*), so:*u* + (−*u*) = (*a*, *b*) + (− *a*,
    − *b*) = (*a* − *a*, *b* − *b*) = (0, 0)The answer is (0, 0). Geometrically, this
    means that if you follow a vector and then its opposite, you end up back at the
    origin, (0, 0). |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **练习2.22**：假设*z*是任意二维向量。*z* + -u的坐标是什么？**解答**：二维向量*z*有一些坐标(*a*, *b*)。它的相反向量有坐标(−
    *a*, − *b*)，所以:*u* + (−*u*) = (*a*, *b*) + (− *a*, − *b*) = (*a* − *a*, *b* −
    *b*) = (0, 0)答案是(0, 0)。从几何学上来说，这意味着如果你跟随一个向量然后是其相反向量，你最终会回到原点，(0, 0)。|'
- en: '| **Exercise 2.23**: For vectors *u* = (−2, 0), *v* = (1.5, 1.5), and *w* =
    (4, 1), what are the results of the vector subtractions *v* − *w*, *z* − *v*,
    and *w* − v?**Solution**: With *z* = (−2, 0), *v* = (1.5, 1.5), and *w* = (4,
    1), we have*v* − *w* = (−2.5, 0.5)*u* − *v* = (−3.5, −1.5)*w* − *v* = (2.5, -0.5)
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **练习2.23**：对于向量*u* = (−2, 0)，*v* = (1.5, 1.5)，和*w* = (4, 1)，向量减法*v* − *w*，*z*
    − *v*，和*w* − v的结果是什么？**解答**：给定*z* = (−2, 0)，*v* = (1.5, 1.5)，和*w* = (4, 1)，我们有*v*
    − *w* = (−2.5, 0.5)*u* − *v* = (−3.5, −1.5)*w* − *v* = (2.5, -0.5) |'
- en: '| **Exercise 2.24**: Write a Python function `subtract(v1,v2)` that returns
    the result of `v1`  - `v2`, taking two 2D vectors as inputs and returning a 2D
    vector as an output.**Solution**:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习2.24**：编写一个Python函数`subtract(v1,v2)`，该函数返回`v1`  - `v2`的结果，接受两个二维向量作为输入，并返回一个二维向量作为输出。**解答**：'
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 2.25**: Write a Python function `distance(v1,v2)` that returns
    the distance between two input vectors. (Note that the `subtract` function from
    the previous exercise already gives the displacement.)Write another Python function
    `perimeter(vectors)` that takes a list of vectors as an argument and returns the
    sum of distances from each vector to the next, including the distance from the
    last vector to the first. What is the perimeter of the dinosaur defined by `dino_vectors`
    ?**Solution**: The distance is just the length of the difference of the two input
    vectors:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习2.25**：编写一个Python函数`distance(v1,v2)`，该函数返回两个输入向量之间的距离。（注意，前一个练习中的`subtract`函数已经给出了位移。）再编写另一个Python函数`perimeter(vectors)`，该函数接受一个向量列表作为参数，并返回每个向量到下一个向量的距离之和，包括最后一个向量到第一个向量的距离。由`dino_vectors`定义的恐龙的周长是多少？**解答**：距离只是两个输入向量之差的长度：'
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For the perimeter, we sum the distances of every pair of subsequent vectors
    in the list, as well as the pair of the first and the last vectors:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于周长，我们计算列表中每对后续向量的距离，以及第一对和最后一对向量的距离：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can use a square with side length of one as a sanity check:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用边长为1的正方形作为合理性检查：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we can calculate the perimeter of the dinosaur:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以计算恐龙的周长：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 2.26−Mini Project**: Let *z* be the vector (1, −1). Suppose there
    is another vector *v* with positive integer coordinates (*n*, *m*) such that *n*
    > xm and has a distance of 13 from u. What is the displacement from *z* to v?**Hint**:
    You can use Python to search for the vector v.**Solution**: We only need to search
    possible integer pairs (*n*, *m*) where *n* is within 13 units of 1 and *m* is
    within 13 units of −1:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习2.26-迷你项目**：设*z*为向量(1, −1)。假设存在另一个向量*v*，其坐标为正整数(*n*, *m*)，且*n* > xm，与u的距离为13。从*z*到*v*的位移是多少？**提示**：你可以使用Python来搜索向量v。**解答**：我们只需要搜索可能的整数对(*n*,
    *m*)，其中*n*在1的13个单位内，*m*在-1的13个单位内：'
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There is one result: (13, 4). It is 12 units to the right and 5 units up from
    (1, −1), so the displacement is (12, 5). |'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个结果：(13, 4)。它位于(1, −1)的右侧12个单位，上方5个单位，所以位移是(12, 5)。|
- en: The length of a vector is not enough to describe it, nor is the distance between
    two vectors enough information to get from one to the other. In both cases, the
    missing ingredient is *direction*. If you know how long a vector is and you know
    what direction it is pointing, you can identify it and find its coordinates. To
    a large extent, this is what *trigonometry* is about, and we’ll review that subject
    in the next section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的长度不足以描述它，两个向量之间的距离也不足以从其中一个向量得到另一个向量。在这两种情况下，缺少的成分是*方向*。如果你知道一个向量的长度以及它指向的方向，你就可以识别它并找到它的坐标。在很大程度上，这就是*三角学*所涉及的内容，我们将在下一节中回顾这个主题。
- en: 2.3 Angles and trigonometry in the plane
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 平面中的角度和三角学
- en: So far, we’ve used two “rulers” (called the x-axis and the y-axis) to measure
    vectors in the plane. An arrow from the origin covers some measurable displacement
    in the horizontal and vertical directions, and these values uniquely specify the
    vector. Instead of using two rulers, we could just as well use a ruler and a protractor.
    Starting with the vector (4, 3), we can measure or calculate its length to be
    5 units, and then use our protractor to identify the direction as shown in figure
    2.24.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了两个“尺子”（称为x轴和y轴）来测量平面上的向量。从原点发出的箭头在水平和垂直方向上覆盖了一些可测量的位移，这些值唯一地指定了向量。我们完全可以只用一把尺子和一个量角器。从向量（4，3）开始，我们可以测量或计算出它的长度为5个单位，然后使用我们的量角器来确定方向，如图2.24所示。
- en: '![](../Images/CH02_F24_Orland.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F24_Orland.png)'
- en: Figure 2.24 Using a protractor to measure the angle at which a vector points
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24 使用量角器测量向量指向的角度
- en: This vector has a length of 5 units, and it points in a direction approximately
    37° counterclockwise from the positive half of the x-axis. This gives us a new
    pair of numbers (5, 37°) that, like our original coordinates, uniquely specify
    the vector. These numbers are called *polar* *coordinates* and are just as good
    at describing points in the plane as the ones we’ve worked with so far, called
    *Cartesian coordinates* .
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个向量长度为5个单位，它指向从正x轴正半轴逆时针大约37°的方向。这给我们一组新的数字（5，37°），就像我们的原始坐标一样，唯一地指定了这个向量。这些数字被称为*极坐标*，和之前我们使用的*笛卡尔坐标*一样，可以很好地描述平面上的点。
- en: Sometimes, like when we’re adding vectors, it’s easier to use Cartesian coordinates.
    Other times, polar coordinates are more useful; for instance, when we want to
    look at vectors rotated by some angle. In code, we don’t have literal rulers or
    protractors available, so we use trigonometric functions to convert back and forth
    instead.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，比如当我们加向量时，使用笛卡尔坐标更容易；其他时候，极坐标更有用；例如，当我们想查看旋转了某个角度的向量时。在代码中，我们没有实际的尺子或量角器可用，所以我们使用三角函数来转换。
- en: 2.3.1 From angles to components
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 从角度到分量
- en: 'Let’s look at the reverse problem: imagine we already have an angle and a distance,
    say, 116.57° and 3\. These define a pair of polar coordinates (3, 116.57°). How
    can we find the Cartesian coordinates for this vector geometrically?'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看相反的问题：假设我们已经有了一个角度和距离，比如说116.57°和3。这些定义了一对极坐标（3，116.57°）。我们如何通过几何方法找到这个向量的笛卡尔坐标？
- en: First, we can position our protractor at the origin to find the right direction.
    We measure 116.57° counterclockwise from the positive x-axis and draw a line in
    that direction (figure 2.25). Our vector (3, 116.57°) lies somewhere on this line.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以将量角器放在原点以找到正确的方向。我们测量从正x轴逆时针116.57°，并沿着这个方向画一条线（图2.25）。我们的向量（3，116.57°）位于这条线上某处。
- en: '![](../Images/CH02_F25_Orland.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F25_Orland.png)'
- en: Figure 2.25 Measuring 116.57° from the positive x-axis using a protractor
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25 使用量角器从正x轴测量116.57°
- en: The next step is to take a ruler and measure a point that is three units from
    the origin in this direction. Once we’ve found it, as in figure 2.26, we can measure
    the components and get our approximate coordinates (−1.34, 2.68).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是拿一把尺子，测量从这个方向起距离原点三个单位的点。一旦我们找到了它，就像图2.26中所示，我们可以测量分量并得到我们的近似坐标（-1.34，2.68）。
- en: '![](../Images/CH02_F26_Orland.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F26_Orland.png)'
- en: Figure 2.26 Using a ruler to measure the coordinates of the point that is three
    units from the origin
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.26 使用尺子测量距离原点三个单位的点的坐标
- en: It may look like the angle 116.57° was a random choice, but it has a useful
    property. Starting from the origin and moving in that direction, you go up two
    units every time you go one unit to the left. Vectors that approximately lie along
    that line include (−1, 2), (−3, 6) and, of course, (−1.34, 2.68); the *y*-coordinates
    are −2 times their *x*-coordinates (figure 2.27).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来116.57°是一个随机选择的角度，但它有一个有用的性质。从原点开始并朝那个方向移动，每向左移动一个单位，就向上移动两个单位。大约沿着这条线的向量包括（-1，2），（-3，6）和当然还有（-1.34，2.68）；*y*坐标是*x*坐标的两倍（图2.27）。
- en: '![](../Images/CH02_F27_Orland.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F27_Orland.png)'
- en: Figure 2.27 Traveling in the direction of 116.57°, you travel two units up for
    every unit you travel to the left.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27 沿着116.57°的方向前进，每向左移动一个单位，就向上移动两个单位。
- en: The strange angle 116.57° happens to give us a nice round ratio of −2\. We won’t
    always be lucky enough to get a whole number ratio, but every angle does give
    us a *constant* ratio. The angle 45° gives us one vertical unit for every one
    horizontal unit or a ratio of 1\. Figure 2.28 shows another angle, 200°. This
    gives us a constant ratio of -0.36 vertical units for every −1 horizontal unit
    covered or a ratio of 0.36.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的角度116.57°恰好给出了一个很好的整数比率-2。我们并不总是这么幸运，能得到整数比率，但每个角度都给出一个*恒定*的比率。45°的角度给我们每个水平单位一个垂直单位，或者比率是1。图2.28显示了另一个角度，200°。这给我们每覆盖-1个水平单位0.36个垂直单位的恒定比率或0.36。
- en: '![](../Images/CH02_F28_Orland.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F28_Orland.png)'
- en: Figure 2.28 How much vertical distance is covered per unit of horizontal distance
    at different angles?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.28 在不同角度下，每单位水平距离覆盖的垂直距离是多少？
- en: 'Given an angle, the coordinates of vectors along that angle will have a constant
    ratio. This ratio is called the *tangent* of the angle, and the tangent function
    is written as *tan*. You’ve seen a few of its approximate values so far:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个角度，该角度上的向量的坐标将有一个恒定的比例。这个比例称为该角度的*正切*，正切函数写作*tan*。你之前已经看到了它的一些近似值：
- en: tan(37°) ≈ ¾
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: tan(37°) ≈ 3/4
- en: tan(116.57°) ≈ −2
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: tan(116.57°) ≈ -2
- en: tan(45°) = 1
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: tan(45°) = 1
- en: tan(200°) ≈ 0.36
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: tan(200°) ≈ 0.36
- en: Here, to denote *approximate* equality, I use the symbol ≈ as opposed to the
    symbol =. The tangent function is a *trigonometric* function because it helps
    us measure triangles. (The “trigon” in “trigonometry” means triangle and “metric”
    means measurement.) Note that I haven’t told you *how* to calculate the tangent
    yet, only what a few of its values are. Python has a built-in tangent function
    that I’ll show you how to use shortly. You almost never have to worry about calculating
    (or measuring) the tangent of an angle yourself.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为了表示*近似*相等，我使用符号≈而不是符号=。正切函数是一个*三角*函数，因为它帮助我们测量三角形。（“trigon”在“trigonometry”中的意思是三角形，“metric”的意思是测量。）请注意，我还没有告诉你*如何*计算正切，只是告诉你它的一些值。Python有一个内置的正切函数，我很快会向你展示如何使用它。你几乎永远不必担心自己计算（或测量）角度的正切。
- en: 'The tangent function is clearly related to our original problem of finding
    Cartesian coordinates for a vector given an angle and a distance. But it doesn’t
    actually provide the coordinates, only their ratio. For that, two other trigonometric
    functions are helpful: *sine* and *cosine*. If we measure some distance at some
    angle (figure 2.29), the tangent of the angle gives us the vertical distance covered
    divided by the horizontal distance.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正切函数显然与我们的原始问题有关，即给定一个角度和距离来找到一个向量的笛卡尔坐标。但它实际上并不提供坐标，只提供它们的比率。为此，其他两个三角函数是有帮助的：*正弦*和*余弦*。如果我们以某个角度测量一些距离（图2.29），该角度的正切给出了垂直距离除以水平距离。
- en: '![](../Images/CH02_F29_Orland.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F29_Orland.png)'
- en: Figure 2.29 Schematic of distances and angles for a given vector
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.29 给定向量的距离和角度示意图
- en: 'By comparison, the sine and cosine give us the vertical and horizontal distance
    covered relative to the overall distance. These are written *sin* and *cos* for
    short, and this equation shows the definitions for both:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较，正弦和余弦给出了相对于总距离的垂直和水平距离。这些简写为*sin*和*cos*，这个方程显示了它们的定义：
- en: '![](../Images/CH02_F29_Orland_UN11b.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F29_Orland_UN11b.png)'
- en: Let’s look at the angle 37° for a concrete example (figure 2.30). We saw that
    the point (4, 3) lies at a distance of 5 units from the origin at this angle.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以37°的角度来看一个具体的例子（图2.30）。我们看到了点（4，3）在这个角度下距离原点5个单位。
- en: '![](../Images/CH02_F30_Orland.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F30_Orland.png)'
- en: Figure 2.30 Measuring the angle to the point (4, 3) with a protractor
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.30 使用量角器测量到点（4，3）的角度
- en: 'For every 5 units you travel at 37°, you cover approximately 3 vertical units.
    Therefore, we can write:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每5个单位的37°行进，你大约覆盖3个垂直单位。因此，我们可以写成：
- en: sin(37°) ≈ 3/5
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: sin(37°) ≈ 3/5
- en: 'Similarly, for every 5 units you travel at 37°, you cover approximately 4 horizontal
    units, so we can write:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于每5个单位的37°行进，你大约覆盖4个水平单位，因此我们可以写成：
- en: cos(37°) ≈ 4/5
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: cos(37°) ≈ 4/5
- en: This is a general strategy for converting a vector in polar coordinates to corresponding
    Cartesian coordinates. If you know the sine and cosine of an angle θ (the Greek
    letter theta, commonly used for angles) and a distance *r* traveled in that direction,
    the Cartesian coordinates are given by (*r* · cos(θ), *r* · sin(θ)) and shown
    in figure 2.31.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将极坐标中的向量转换为相应笛卡尔坐标的一般策略。如果你知道角度 θ（希腊字母 theta，通常用于角度）的正弦和余弦以及在该方向上走过的距离 *r*，笛卡尔坐标由
    (*r* · cos(θ), *r* · sin(θ)) 给出，并在图 2.31 中展示。
- en: '![](../Images/CH02_F31_Orland.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F31_Orland.png](../Images/CH02_F31_Orland.png)'
- en: Figure 2.31 Picturing the conversion from polar coordinates to Cartesian coordinates
    for a right triangle
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.31 展示了从极坐标到直角坐标系转换的图像
- en: 2.3.2 Radians and trigonometry in Python
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 Python 中的弧度和三角学
- en: Let’s turn what we’ve reviewed about trigonometry into Python code. Specifically,
    let’s build a function that takes a pair of polar coordinates (a length and an
    angle) and outputs a pair of Cartesian coordinates (lengths of *x* and *y* components).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们关于三角学的复习内容转化为 Python 代码。具体来说，让我们构建一个函数，它接受一对极坐标（长度和角度）并输出一对笛卡尔坐标（*x* 和
    *y* 分量的长度）。
- en: 'The main hurdle is that Python’s built-in trigonometric functions use different
    units than the ones we’ve used. We expect tan(45°) = 1, for instance, but Python
    gives us a much different result:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的难点是 Python 的内置三角函数使用的单位与我们使用的不同。例如，我们期望 tan(45°) = 1，但 Python 给出的结果却大不相同：
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Python doesn’t use degrees, and neither do most mathematicians. Instead, they
    use units called *radians* to measure angles. The conversion factor is
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Python 不使用度数，大多数数学家也不使用。相反，他们使用称为 *弧度* 的单位来测量角度。转换系数是
- en: 1 radian ≈ 57.296°
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 1 弧度 ≈ 57.296°
- en: 'This may seem like an arbitrary conversion factor. Some more suggestive relationships
    between degrees and radians are given in terms of the special number *π*(pi),
    whose value is approximately 3.14159\. Here are a few examples:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个任意的转换系数。以下是一些关于度和弧度之间更具有启发性的关系，这些关系以特殊数字 *π*（pi）的形式给出，其值约为 3.14159。这里有一些例子：
- en: '*π* radians = 180°'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*π* 弧度 = 180°'
- en: 2*π* radians = 360°
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 2*π* 弧度 = 360°
- en: In radians, half a trip around a circle is an angle of *π* and a whole revolution
    is 2*π*. These respectively agree with the half and whole circumference of a circle
    of radius 1 (figure 2.32).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在弧度中，半圈是一个 *π* 弧度，整个旋转是 2*π*。这分别与半径为 1 的圆的半周和整个周长相对应（图 2.32）。
- en: '![](../Images/CH02_F32_Orland.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F32_Orland.png](../Images/CH02_F32_Orland.png)'
- en: Figure 2.32 A half revolution is *π* radians, while a whole revolution is 2*π*
    radians.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.32 半圈是 *π* 弧度，而整个旋转是 2*π* 弧度。
- en: 'You can think of radians as another kind of ratio: for a given angle, its measurement
    in radians tells you how many radiuses you’ve gone around the circle. Because
    of this special property, angle measurements without units are assumed to be radians.
    Noting that 45° = *π*/4 (radians), we can get the correct result for the tangent
    of this angle:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将弧度视为另一种比例：对于给定的角度，其弧度测量值告诉你围绕圆周走了多少半径。由于这个特殊性质，没有单位的角测量值被认为是弧度。注意到 45° =
    *π*/4 (弧度)，我们可以得到这个角度的正切值的正确结果：
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can now make use of Python’s trigonometric functions to write a `to_cartesian`
    function, taking a pair of polar coordinates and returning corresponding Cartesian
    coordinates:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以利用 Python 的三角函数编写一个 `to_cartesian` 函数，它接受一对极坐标并返回相应的笛卡尔坐标：
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using this, we can verify that 5 units at an angle of 37° gets us close to
    the point (4, 3):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们可以验证 5 个单位在 37° 的角度下可以接近点 (4, 3)：
- en: '[PRE25]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that we can convert from polar coordinates to Cartesian coordinates, let’s
    see how to convert in the other direction.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以从极坐标转换为笛卡尔坐标，让我们看看如何进行相反的转换。
- en: 2.3.3  From components back to angles
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 从分量回到角度
- en: Given a pair of Cartesian coordinates like (−2, 3), we know how to find the
    length with the Pythagorean theorem. In this case, it is![](../Images/w_gifs_99.gif),
    which is the first of the two polar coordinates we are looking for. The second
    is the angle, which we can call θ (theta), indicating the direction of this vector
    (figure 2.33).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一对笛卡尔坐标，例如 (−2, 3)，我们知道如何使用勾股定理来找到长度。在这种情况下，它确实是![w_gifs_99.gif](../Images/w_gifs_99.gif)，这是我们正在寻找的两个极坐标中的第一个。第二个是角度，我们可以称之为
    θ (theta)，表示这个向量的方向（图 2.33）。
- en: '![](../Images/CH02_F33_Orland.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F33_Orland.png](../Images/CH02_F33_Orland.png)'
- en: Figure 2.33 In what angle does the vector (−2, 3) point?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.33 向量 (−2, 3) 指向什么角度？
- en: We can say some facts about the angle θ that we’re looking for. Its tangent,
    tan(θ), is 3/2, while sin(θ) = 3/√13 and cos(θ) = −2/√13\. All that’s left is
    finding a value of θ that satisfies these. If you like, you can pause and try
    to approximate this angle yourself by guessing and checking.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对我们寻找的角度θ说一些事实。它的正切，tan(θ)，是3/2，而sin(θ) = 3/√13，cos(θ) = −2/√13。剩下要做的就是找到一个满足这些条件的θ值。如果你愿意，你可以暂停并尝试通过猜测和检查来近似这个角度。
- en: 'Ideally, we’d like a more efficient method than this. It would be great if
    there were a function that took the value of sin(θ), for instance, and gave you
    back θ. This turns out to be easier said than done, but Python’s `math.asin` function
    makes a good attempt. This is an implementation of the *inverse trigonometric
    function* called the *arcsine*, and it returns a satisfactory value of θ:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望有一个比这更有效的方法。如果有一个函数可以接受sin(θ)的值，例如，并返回θ，那将是极好的。这听起来比实际做起来容易，但Python的`math.asin`函数做出了良好的尝试。这是一个称为**反正弦函数**的反三角函数实现，并返回令人满意的θ值：
- en: '[PRE26]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So far, so good. But what about the sine of our angle 3/√13?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但我们的角度3/√13的正弦值是多少呢？
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This angle is roughly 56.3°, and as figure 2.34 shows, that’s the wrong direction!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角度大约是56.3°，如图2.34所示，这是错误的方向！
- en: '![](../Images/CH02_F34_Orland.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F34_Orland.png)'
- en: Figure 2.34 Python’s `math.asin` function appears to give us the wrong angle.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.34 Python的`math.asin`函数似乎给出了错误的角度。
- en: It’s not wrong that `math.asin` gives us this answer; another point (2, 3) *does*
    lie in this direction. It is at length![](../Images/w_gifs_105.gif)from the origin,
    so the sine of this angle is also 3![](../Images/w_gifs_106.gif). This is why
    `math.asin` is not a full solution for us. There are multiple angles that can
    have the same sine.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`math.asin`给出这个答案并不错误；另一个点（2，3）**确实**位于这个方向上。它距离原点有长度![图片](../Images/w_gifs_105.gif)。这就是为什么`math.asin`对我们来说不是完整的解决方案。存在多个角度可以有相同的正弦值。'
- en: 'The inverse trigonometric function, called *arccosine* and implemented in Python
    as `math.acos`, happens to give us the right value:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 反三角函数，称为**余弦反函数**，在Python中通过`math.acos`实现，恰好给出了正确的值：
- en: '[PRE28]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This many radians is about the same as 123.7°, which we can confirm to be correct
    using a protractor. But this is only by happenstance; there are other angles that
    could have given us the same cosine. For instance, (−2, −3) also has distance![](../Images/w_gifs_108.gif)from
    the origin, so it lies at an angle with the same cosine as θ: −2![](../Images/w_gifs_109.gif).
    To find the value of θ that we actually want, we’ll have to make sure the sine
    *and* cosine agree with our expectation. The angle returned by Python, which is
    approximately 2.159, satisfies this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这样多的弧度大约等于123.7°，我们可以用量角器来确认这是正确的。但这只是巧合；还有其他角度也可以给出相同的余弦值。例如，(−2，−3)也有![图片](../Images/w_gifs_108.gif)距离原点，因此它位于与θ相同余弦的角度上：−2![图片](../Images/w_gifs_109.gif)。为了找到我们真正想要的θ值，我们必须确保正弦和余弦都与我们的预期相符。Python返回的角度，大约是2.159，满足这个条件：
- en: '[PRE29]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: None of the arcsine, arccosine, or arctangent functions are sufficient to find
    the angle to a point in the plane. It *is* possible to find the correct angle
    by a tricky geometric argument you probably learned in high school trigonometry
    class. I’ll leave that as an exercise and cut to the chase−Python can do the work
    for you! The `math.atan2` function takes the Cartesian coordinates of a point
    in the plane (in reverse order!) and gives you back the angle at which it lies.
    For example,
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 任何反正弦、反余弦或反正切函数都不足以找到平面上的点到角度。通过你可能在上高中的三角学课程中学到的巧妙几何论证，确实可以找到正确角度。我将把它留作练习，直接切入正题−Python可以为你做这项工作！`math.atan2`函数接受平面内一个点的笛卡尔坐标（顺序相反！）并返回它所在的角度。例如，
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'I apologize for burying the lede, but I did so because it’s worth knowing the
    potential pitfalls of using inverse trigonometric functions. In summary, trigonometric
    functions are tricky to do in reverse; multiple different inputs can produce the
    same output, so an output can’t be traced back to a unique input. This lets us
    complete the function we set out to write: a converter from Cartesian to polar
    coordinates:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我为埋没了重点表示歉意，但我这样做是因为了解使用反正切函数的潜在陷阱是值得的。总的来说，反三角函数在逆向操作时很棘手；多个不同的输入可以产生相同的输出，因此输出不能追溯到唯一的输入。这使得我们可以完成我们最初设定的函数：一个从笛卡尔坐标系到极坐标系的转换器：
- en: '[PRE31]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can verify some simple examples: `to_polar((1,0))` should be one unit in
    the positive *x* direction or an angle of zero degrees. Indeed, the function gives
    us an angle of zero and a length of one:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证一些简单的例子：`to_polar((1,0))` 应该是正 x 方向的一个单位或者零度角。确实，这个函数给我们一个零度角和长度为 1：
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '(The fact that the input and the output are the same is coincidental; they
    have different geometric meanings.) Likewise, we get the expected answer for (−2,
    3):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: （输入和输出相同是巧合；它们有不同的几何意义。）同样，我们得到了预期的答案 (−2, 3)：
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 2.3.4  Exercises
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4  练习
- en: '| **Exercise 2.27**: Confirm that the vector given by Cartesian coordinates
    (−1.34, 2.68) has a length of approximately 3 as expected.**Solution**:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 2.27**: 确认由笛卡尔坐标 (−1.34, 2.68) 给出的向量长度约为 3，正如预期的那样。**解答**:'
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Close enough! |
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 差不多就是了！ |
- en: '| **Exercise 2.28**: The figure shows a line that makes a 22° angle in the
    counterclockwise direction from the positive x-axis. Based on the following picture,
    what is the approximate value of tan(22°)?![](../Images/CH02_F34_Orland_UN12.png)**Solution**:
    The line passes close to the point (10, 4), so 4 / 10 = 0.4 is a reasonable approximation
    of tan(22°) as shown here:![](../Images/CH02_F34_Orland_UN13.png) |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.28**: 图中显示了一条与正 x 轴逆时针形成 22° 角的直线。根据以下图片，tan(22°)的大致值是多少？！[](../Images/CH02_F34_Orland_UN12.png)**解答**:
    这条线接近点 (10, 4)，所以 4 / 10 = 0.4 是 tan(22°) 的一个合理的近似，如图所示：！[](../Images/CH02_F34_Orland_UN13.png)
    |'
- en: '| **Exercise 2.29**: Turning the question around, suppose we know the length
    and direction of a vector and want to find its components. What are the *x* and
    *y* components of a vector with length 15 pointing at a 37° angle?SolutionThe
    sine of 37° is roughly 3/5,which tells us that every 5 units of distance covered
    at this angle takes us 3 units upward. So, 15 units of distance give us a vertical
    component of 3/5· 15, or 9.The cosine of 37° is roughly 4/5,which tells us that
    each 5 units of distance in this direction take us 4 units to the right, so the
    horizontal component is 4/5· 15 or 12\. In summary, the polar coordinates (15,
    37°) correspond approximately to the Cartesian coordinates (12, 9). |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.29**: 反过来，如果我们知道一个向量的长度和方向，想要找到它的分量。长度为 15 且指向 37° 角的向量的 x 和 y 分量是什么？**解答**:
    37°的正弦值大约是 3/5，这告诉我们，在这个角度上，每 5 个单位的距离会向上移动 3 个单位。所以，15 个单位的距离给我们一个垂直分量是 3/5 ·
    15，即 9。37°的余弦值大约是 4/5，这告诉我们，在这个方向上，每 5 个单位的距离会向右移动 4 个单位，所以水平分量是 4/5 · 15 或 12。总之，极坐标
    (15, 37°) 大约对应于笛卡尔坐标 (12, 9)。 |'
- en: '| **Exercise 2.30**: Suppose I travel 8.5 units from the origin at an angle
    of 125°, measured counterclockwise from the positive x-axis. Given that sin(125°)
    = 0.819 and cos(125°) = -0.574, what are my final coordinates? Draw a picture
    to show the angle and path traveled.Solution*x* = *r* · cos(θ) = 8.5 · -0.574
    = −4.879*y* = *r* · sin(θ) = 8.5 · 0.819 = 6.962The following figure shows the
    final position, (−4.879, 6.962):![](../Images/CH02_F34_Orland_UN14.png) |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.30**: 假设我从原点出发，以逆时针从正 x 轴测量的 125° 角度移动了 8.5 个单位。已知 sin(125°) = 0.819
    和 cos(125°) = -0.574，我的最终坐标是什么？画一个图来显示角度和走过的路径。**解答**: x = r · cos(θ) = 8.5 ·
    -0.574 = −4.879，y = r · sin(θ) = 8.5 · 0.819 = 6.962。以下图显示了最终位置，(−4.879, 6.962)：！[](../Images/CH02_F34_Orland_UN14.png)
    |'
- en: '| **Exercise 2.31**: What are the sine and cosine of 0°? Of 90°? Of 180°? In
    other words, how many vertical and horizontal units are covered per unit distance
    in any of these directions?**Solution**: At 0°, no vertical distance is covered,
    so sin(0°) = 0; rather, every unit of distance traveled is a unit of horizontal
    distance, so cos(0°) = 1.For 90° (a quarter turn counterclockwise), every unit
    traveled is a positive vertical unit, so sin(90°) = 1, while cos(90°) = 0.Finally,
    at 180°, every unit of distance traveled is a negative unit in the *x* direction,
    so cos(180°) = −1 and sin(180°) = 0. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.31**: 0°、90°、180°的正弦和余弦值是多少？换句话说，在这些方向上，每单位距离覆盖了多少垂直和水平单位？**解答**:
    在 0° 时，没有覆盖垂直距离，所以 sin(0°) = 0；相反，每单位距离的移动都是水平距离的单位，所以 cos(0°) = 1。对于 90°（逆时针四分之一转），每单位移动都是正垂直单位，所以
    sin(90°) = 1，而 cos(90°) = 0。最后，在 180° 时，每单位距离的移动都是 x 方向的负单位，所以 cos(180°) = −1
    和 sin(180°) = 0。 |'
- en: '| **Exercise 2.32**: The following diagram gives some exact measurements for
    a right triangle:First, confirm that these lengths are valid for a right triangle
    because they satisfy the Pythagorean theorem. Then, calculate the values of sin(30°),
    cos(30°), and tan(30°) to three decimal places using the measurements in the diagram.![](../Images/CH02_F34_Orland_UN15.png)**Solution**:
    These side lengths indeed satisfy the Pythagorean theorem:![](../Images/CH02_F34_Orland_UN15_EQ06.png)Plugging
    the side lengths into the Pythagorean theoremThe trigonometric function values
    are given by the appropriate ratios of side lengths:![](../Images/CH02_F34_Orland_UN15_EQ07.png)Calculating
    the sine, cosine, and tangent by their definitions |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.32**: 下图给出了一些直角三角形的精确测量值：首先，确认这些长度对于直角三角形是有效的，因为它们满足勾股定理。然后，使用图中的测量值计算
    sin(30°)、cos(30°) 和 tan(30°) 的值，精确到小数点后三位！![图片](../Images/CH02_F34_Orland_UN15.png)**解答**：这些边长确实满足勾股定理！![图片](../Images/CH02_F34_Orland_UN15_EQ06.png)将边长代入勾股定理，三角函数的值由边长适当的比值给出！![图片](../Images/CH02_F34_Orland_UN15_EQ07.png)通过它们的定义计算正弦、余弦和正切值
    |'
- en: '| **Exercise 2.33**: Looking at the triangle from the previous exercise from
    a different perspective, use it to calculate the values of sin(60°), cos(60°),
    and tan(60°) to three decimal places.**Solution**: Rotating and reflecting the
    triangle from the previous exercise has no effect on its side lengths or angles.![](../Images/CH02_F34_Orland_UN16.png)A
    rotated copy of the triangle from the previous exerciseThe ratios of the side
    lengths give the trigonometric function values for 60°:![](../Images/CH02_F34_Orland_UN16_EQ08.png)Calculating
    the defining ratios when horizontal and vertical components have switched |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.33**: 从不同角度观察上一个练习中的三角形，使用它来计算 sin(60°)、cos(60°) 和 tan(60°) 的值，精确到小数点后三位。**解答**：旋转和反射上一个练习中的三角形不会影响其边长或角度！![图片](../Images/CH02_F34_Orland_UN16.png)上一个练习中三角形的旋转副本，边长的比值给出了
    60° 的三角函数值！![图片](../Images/CH02_F34_Orland_UN16_EQ08.png)当水平和垂直分量交换时，计算定义比值 |'
- en: '| **Exercise 2.34**: The cosine of 50° is 0.643\. What is sin(50°) and what
    is tan(50°)? Draw a picture to help you calculate the answer.**Solution**: Given
    that the cosine of 50° is 0.643, the following triangle is valid:![](../Images/CH02_F34_Orland_UN17.png)That
    is, it has the right ratio of the two known side lengths: 0.643 / 1 = 0.643\.
    To find the unknown side length, we can use the Pythagorean theorem:![](../Images/CH02_F34_Orland_UN17_EQ09.png)With
    the known side lengths, sin(50°) = 0.766/1 = 0.766\. Also, tan(50°) = 0.766/0.643
    = 1.192. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.34**: 50° 的余弦值是 0.643。sin(50°) 和 tan(50°) 是多少？画一个图来帮助你计算答案。**解答**：已知
    50° 的余弦值是 0.643，以下三角形是有效的！![图片](../Images/CH02_F34_Orland_UN17.png)也就是说，它具有两个已知边长的正确比例：0.643
    / 1 = 0.643。要找到未知边长，我们可以使用勾股定理！![图片](../Images/CH02_F34_Orland_UN17_EQ09.png)有了已知的边长，sin(50°)
    = 0.766/1 = 0.766。同样，tan(50°) = 0.766/0.643 = 1.192。 |'
- en: '| **Exercise 2.35**: What is 116.57° in radians? Use Python to compute the
    tangent of this angle and confirm that it is close to −2 as we saw previously.**Solution**:
    116.57° · (1 radian/57.296°) = 2.035 radians:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 2.35**: 116.57° 是多少弧度？使用 Python 计算这个角度的正切值，并确认它接近我们之前看到的 -2。**解答**：116.57°
    · (1 弧度/57.296°) = 2.035 弧度：'
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 2.36**: Locate the angle 10*π*/6\. Do you expect the values of
    cos(10*π*/6) and sin(10*π*/6) to be positive or negative? Use Python to calculate
    their values and confirm.**Solution**: A whole circle is 2*π* radians, so the
    angle *π*/6 is one twelfth of a circle. You can picture cutting a pizza in 12
    slices, and counting counterclockwise from the positive x-axis; the angle 10*π*/6
    is two slices short of a full rotation. This means that it points down and to
    the right. The cosine should be positive, and the sine should be negative because
    the distance in this direction corresponds with a positive horizontal displacement
    and a negative vertical displacement:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 2.36**: 找到角度 10π/6。你预计 cos(10π/6) 和 sin(10π/6) 的值是正还是负？使用 Python 计算它们的值并确认。**解答**：整个圆是
    2π 弧度，所以 π/6 是圆的十二分之一。你可以想象将披萨切成 12 片，并从正 x 轴逆时针计数；10π/6 的角度是离完整旋转两片。这意味着它指向下方和右侧。余弦应该是正的，而正弦应该是负的，因为在这个方向上的距离对应于正的水平位移和负的垂直位移：'
- en: '[PRE36]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 2.37**: The following list comprehension creates 1,000 points
    in polar coordinates:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 2.37**: 以下列表推导创建了 1,000 个极坐标点：'
- en: '[PRE37]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In Python code, convert these to Cartesian coordinates and connect them in
    a closed loop with line segments to draw a picture.**Solution**: Including the
    setup and the original list of data, the code is as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Python 代码中，将它们转换为笛卡尔坐标系，并用线段连接成闭合回路以绘制图形。**解答**: 包括设置和原始数据列表，代码如下：'
- en: '[PRE38]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: And the result is a five-leafed flower:![](../Images/CH02_F34_Orland_UN18.png)The
    plot of the 1,000 connected points is a flower shape. |
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个五瓣花：![](../Images/CH02_F34_Orland_UN18.png)1,000 个连接点的图是一个花形。|
- en: '| **Exercise 2.38**: Find the angle to get to the point (−2, 3) by “guess-and-check.”![](../Images/CH02_F34_Orland_UN19.png)What
    is the angle to get to the point (−2, 3)?**Hint**: We can tell visually that the
    answer is between *π*/2 and *π*. On that interval, the values of sine and cosine
    always decrease as the angle increases.**Solution**: Here’s an example of guessing
    and checking between *π*/2 and *π*, looking for an angle with tangent close to
    −3/2 = −1.5:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 2.38**: 通过“猜测和检查”找到到达点 (−2, 3) 的角度。![](../Images/CH02_F34_Orland_UN19.png)到达点
    (−2, 3) 的角度是多少？**提示**: 我们可以直观地看出答案在 π/2 和 π 之间。在这个区间内，正弦和余弦的值随着角度的增加而总是减少。**解答**:
    这是一个略小于顺时针方向四分之一转的例子。这里是在 π/2 和 π 之间猜测和检查，寻找切线接近 −3/2 = −1.5 的角度：'
- en: '[PRE39]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The value must be between 2.158 and 2.159. |
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 值必须在 2.158 和 2.159 之间。|
- en: '| **Exercise 2.39**: Find another point in the plane with the same tangent
    as θ, namely −3/2\. Use Python’s implementation of the arctangent function, `math.atan`,
    to find the value of this angle.**Solution**: Another point with tangent −3/2
    is (3, −2). Python’s `math.atan` finds the angle to this point:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 2.39**: 找到平面上与 θ 相同切线的另一点，即 −3/2。使用 Python 的反正切函数 `math.atan` 来找到这个角度的值。**解答**:
    切线为 −3/2 的另一点是 (3, −2)。Python 的 `math.atan` 找到这个点的角度：'
- en: '[PRE40]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is slightly less than a quarter turn in the clockwise direction. |
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这略小于顺时针方向的四分之一转。|
- en: '| **Exercise 2.40**: Without using Python, what are the polar coordinates corresponding
    to the Cartesian coordinates (1, 1) and (1, −1)? Once you’ve found the answers,
    use `to_polar` to check your work.**Solution**: In polar coordinates, (1, 1) becomes
    (√2, *π*/4) and (1, −1) becomes (√2, -*π*/4).With some care, you can find any
    angle on a shape made up of known vectors. The angle between two vectors is either
    a sum or difference of angles these make with the x-axis. You measure some trickier
    angles in the next mini-project. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.40**: 不使用 Python，对应于笛卡尔坐标系 (1, 1) 和 (1, −1) 的极坐标是什么？一旦找到答案，使用 `to_polar`
    来检查你的工作。**解答**: 在极坐标中，(1, 1) 变为 (√2, π/4) 和 (1, −1) 变为 (√2, −π/4)。通过一些小心，你可以找到由已知向量组成的形状上的任何角度。两个向量之间的角度是这些角度与
    x 轴的求和或差。你将在下一个迷你项目中测量一些更复杂的角度。|'
- en: '| **Exercise 2.41-Mini Project**: What is the angle of the Dinosaur’s mouth?
    What is the angle of the dinosaur’s toe? Of the point of its tail?![](../Images/CH02_F34_Orland_UN20.png)Some
    angles we can measure or calculate on our dinosaur. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.41-迷你项目**: 恐龙的嘴巴角度是多少？恐龙的脚趾角度是多少？它的尾巴尖端的角度是多少？！[](../Images/CH02_F34_Orland_UN20.png)我们可以在我们的恐龙上测量或计算一些角度。|'
- en: 2.4 Transforming collections of vectors
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 向量集合的转换
- en: 'Collections of vectors store spatial data like drawings of dinosaurs regardless
    of what coordinate system we use: polar or Cartesian. It turns out that when we
    want to manipulate vectors, one coordinate system can be better than another.
    We already saw that moving (or translating) a collection of vectors is easy with
    Cartesian coordinates. It turns out to be much less natural in polar coordinates.
    Because polar coordinates have angles built in, these make it simple to carry
    out rotations.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 向量集合存储空间数据，如恐龙的绘画，无论我们使用什么坐标系：极坐标或笛卡尔坐标系。结果是，当我们想要操作向量时，一个坐标系可能比另一个坐标系更好。我们已经看到，使用笛卡尔坐标系移动（或平移）向量集合很容易。在极坐标系中，这要困难得多。因为极坐标系内置了角度，这使得执行旋转变得简单。
- en: In polar coordinates, adding to the angle rotates a vector further counterclockwise,
    while subtracting from it rotates the vector clockwise. The polar coordinate (1,
    2) is at distance 1 and at an angle of 2 radians. (Remember that we are working
    in radians if there is no degree symbol!) Starting with the angle 2 and adding
    or subtracting 1 takes the vector either 1 radian counterclockwise or clockwise,
    respectively (figure 2.35).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在极坐标中，向角度增加会使向量进一步逆时针旋转，而从中减去会使向量顺时针旋转。极坐标 (1, 2) 距离为 1，角度为 2 弧度。（记住，如果没有度数符号，我们是在弧度下工作！）从角度
    2 开始，增加或减少 1 将使向量分别逆时针或顺时针旋转 1 弧度（见图 2.35）。
- en: '![](../Images/CH02_F35_Orland.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F35_Orland.png)'
- en: Figure 2.35 Adding or subtracting from the angle rotates the vector about the
    origin.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.35 从角度上添加或减去旋转会使向量绕原点旋转。
- en: 'Rotating a number of vectors simultaneously has the effect of rotating the
    figure these represent about the origin. The `draw` function only understands
    Cartesian coordinates, so we need to convert from polar to Cartesian before using
    it. Likewise, we have only seen how to rotate vectors in polar coordinates, so
    we need to convert Cartesian coordinates to polar coordinates before executing
    a rotation. Using this approach, we can rotate the dinosaur like this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 同时旋转多个向量会使这些向量所代表的图形绕原点旋转。`draw`函数只理解笛卡尔坐标，因此在使用之前我们需要将其从极坐标转换为笛卡尔坐标。同样，我们只看到了如何在极坐标中旋转向量，因此我们需要在执行旋转之前将笛卡尔坐标转换为极坐标。使用这种方法，我们可以这样旋转恐龙：
- en: '[PRE41]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The result of this code is a gray copy of the original dinosaur, plus a superimposed
    red copy that’s rotated by *π*/4, or an eighth of a full revolution counterclockwise
    (figure 2.36).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的结果是原始恐龙的灰色副本，加上一个叠加的红色副本，该副本旋转了π/4，即四分之一完整的逆时针旋转（见图2.36）。
- en: '![](../Images/CH02_F36_Orland.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F36_Orland.png)'
- en: Figure 2.36 The original dinosaur in gray and a rotated copy in red
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.36 原始恐龙以灰色呈现，以及一个旋转后的红色副本
- en: As an exercise at the end of this section, you can write a general-purpose `rotate`
    function that rotates a list of vectors by the same specified angle. I’m going
    to use such a function in the next few examples, and you can either use the implementation
    I provide in the source code or one you come up with yourself.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节末尾的一个练习，你可以编写一个通用的`rotate`函数，该函数将相同指定的角度旋转向量列表。我将在接下来的几个示例中使用这样的函数，你可以使用我在源代码中提供的实现，或者自己编写一个。
- en: 2.4.1  Combining vector transformations
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 组合向量变换
- en: So far, we’ve seen how to translate, rescale, and rotate vectors. Applying any
    of these transformations to a collection of vectors achieves the same effect on
    the shape that these define in the plane. The full power of these vector transformations
    comes when we apply them in sequence.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何平移、缩放和旋转向量。将这些变换应用于向量集合会在平面上定义的形状上产生相同的效果。这些向量变换的全部力量在于我们按顺序应用它们。
- en: 'For instance, we could first rotate and *then* translate the dinosaur. Using
    the `translate` function from the exercise in section 2.2.4 and the `rotate` function,
    we can write such a transformation concisely (see the result in figure 2.37):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们首先旋转恐龙，然后进行平移。使用2.2.4节中的`translate`函数和`rotate`函数，我们可以简洁地写出这样的变换（见图2.37的结果）：
- en: '[PRE42]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The rotation comes first, turning the dinosaur counterclockwise by 5*π*/3, which
    is most of a full counterclockwise revolution. Then the dinosaur is translated
    up and to the right by 8 units each. As you can imagine, combining rotations and
    translations appropriately can move the dinosaur (or any shape) to any desired
    location and orientation in the plane. Whether we’re animating our dinosaur in
    a movie or in a game, the flexibility to move it around with vector transformations
    lets us give it life programmatically.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转首先进行，将恐龙逆时针旋转5π/3，即大部分逆时针旋转。然后恐龙向上和向右平移8个单位。正如你所想象的那样，适当地组合旋转和平移可以将恐龙（或任何形状）移动到平面上的任何所需位置和方向。无论我们是在电影中还是在游戏中动画化我们的恐龙，使用向量变换来移动它的灵活性让我们能够通过编程赋予它生命。
- en: '![](../Images/CH02_F37_Orland.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F37_Orland.png)'
- en: Figure 2.37 The original dinosaur in gray and a red copy that’s rotated and
    then translated
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.37 原始恐龙以灰色呈现，以及一个旋转并平移后的红色副本
- en: Our applications will soon take us past cartoon dinosaurs; there are plenty
    of other operations on vectors and many generalize to higher dimensions. Real-world
    data sets often live in dozens or hundreds of dimensions, so we’ll apply the same
    kinds of transformations to these as well. It’s often useful to both translate
    and rotate data sets to make their important features clearer. We won’t be able
    to picture rotations in 100 dimensions, but we can always think of two dimensions
    as a trusty metaphor.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用很快就会超越卡通恐龙；还有许多其他对向量的操作，并且许多可以推广到更高维度。现实世界的数据集通常存在于数十或数百个维度中，因此我们也将对这些数据应用相同的变换。通常，对数据集进行平移和旋转可以使重要特征更加清晰。我们无法想象100维度的旋转，但我们总是可以将二维视为一个可靠的隐喻。
- en: 2.4.2 Exercises
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 练习
- en: '| **Exercise 2.42**: Create a `rotate(angle,` `vectors)` function that takes
    an array of input vectors in Cartesian coordinates and rotates those by the specified
    angle (counterclockwise or clockwise, according to whether the angle is positive
    or negative).Solution'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 2.42**：创建一个 `rotate(angle, vectors)` 函数，该函数接受一个输入向量的笛卡尔坐标数组，并按指定角度旋转这些向量（根据角度的正负，逆时针或顺时针旋转）。解决方案'
- en: '[PRE43]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 2.43**: Create a function `regular_polygon(n)` that returns Cartesian
    coordinates for the vertices of a regular *n* -sided polygon (that is, having
    all angles and side lengths equal). For instance, `polygon(7)` produces vectors
    defining the following heptagon:![](../Images/CH02_F37_Orland_UN21.png)A regular
    heptagon with points at seven evenly-spaced angles around the origin**Hint**:
    In this picture, I used the vector (1, 0) and copies that are rotated by seven
    evenly-spaced angles about the origin.Solution'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 2.43**：创建一个名为 `regular_polygon(n)` 的函数，该函数返回正 *n* 边形（即所有角度和边长都相等）的顶点的笛卡尔坐标。例如，`polygon(7)`
    生成定义以下七边形的向量：![](../Images/CH02_F37_Orland_UN21.png)一个具有七个均匀分布角度的点的正七边形**提示**：在这张图中，我使用了向量
    (1, 0) 和围绕原点旋转的七个均匀分布的角度的副本。解决方案'
- en: '[PRE44]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 2.44**: What is the result of first translating the dinosaur by
    the vector (8, 8) and then rotating it by 5*π*/3? Is the result the same as rotating
    and then translating?Solution![](../Images/CH02_F37_Orland_UN22.png)First translating
    and then rotating the dinosaurThe result is not the same. In general, applying
    rotations and translations in different orders yields different results. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| **练习 2.44**：首先将恐龙平移向量 (8, 8)，然后旋转 5π/3，结果是什么？结果与先旋转再平移相同吗？解决方案![](../Images/CH02_F37_Orland_UN22.png)先平移再旋转恐龙结果不同。一般来说，以不同的顺序应用旋转和平移会产生不同的结果。|'
- en: 2.5 Drawing with Matplotlib
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 使用 Matplotlib 绘图
- en: As promised, I’ll conclude by showing you how to build “from scratch” the drawing
    functions used in this chapter from the Matplotlib library. After installing Matplotlib
    with pip, you can import it (and some of its submodules); for example,
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，我将通过向你展示如何从 Matplotlib 库中构建本章使用的绘图函数“从头开始”来结束。在用 pip 安装 Matplotlib 后，你可以导入它（以及一些它的子模块）；例如，
- en: '[PRE45]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `Polygon` , `Points` , `Arrow` , and `Segment` classes are not that interesting;
    they simply hold the data passed to them in their constructors. For instance,
    the `Points` class contains only a constructor that receives and stores a list
    of vectors and a color keyword argument:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polygon`、`Points`、`Arrow` 和 `Segment` 类并不那么有趣；它们只是简单地在其构造函数中存储传递给它们的数据。例如，`Points`
    类只包含一个构造函数，该构造函数接收并存储一个向量列表和一个颜色关键字参数：'
- en: '[PRE46]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `draw` function starts by figuring out how big the plot should be and then
    draws each of the objects it is passed one-by-one. For instance, to draw dots
    on the plane represented by a `Points` object, `draw` uses Matplotlib’s scatter-plotting
    functionality:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw` 函数首先确定绘图的大小，然后逐个绘制传递给它的每个对象。例如，要在表示 `Points` 对象的平面上绘制点，`draw` 使用 Matplotlib
    的散点图功能：'
- en: '[PRE47]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Some setup happens here, which is not shown.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这里发生了一些设置，但未显示。
- en: ❷ Iterates over the objects passed in
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历传入的对象
- en: ❸ If the current object is an instance of the Points class, draws dots for all
    of its vectors using Matplotlib’s scatter function
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果当前对象是 Points 类的实例，则使用 Matplotlib 的 scatter 函数为其所有向量绘制点
- en: Arrows, segments, and polygons are handled in much the same way using different
    pre-built Matplotlib functions to make the geometric objects appear on the plot.
    You can find all of these implemented in the source code file vector_drawing.py.
    We’ll use Matplotlib throughout this book to plot data and mathematical functions,
    and I’ll provide periodic refreshers on its functionality as we use it.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头、线段和多边形以类似的方式处理，使用不同的预构建 Matplotlib 函数使几何对象出现在图上。你可以在源代码文件 vector_drawing.py
    中找到所有这些实现。我们将在这本书中使用 Matplotlib 绘制数据和数学函数，并且随着我们的使用，我会定期提供其功能的更新。
- en: Now that you’ve mastered two dimensions, you’re ready to add another one. With
    the third dimension, we can fully describe the world we live in. In the next chapter,
    you’ll see how to model three-dimensional objects in code.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了二维空间，你准备好添加另一个维度。有了第三个维度，我们可以完全描述我们所生活的世界。在下一章中，你将看到如何在代码中建模三维对象。
- en: Summary
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Vectors are mathematical objects that live in multi-dimensional spaces. These
    can be geometric spaces like the two-dimensional (2D) plane of a computer screen
    or the three-dimensional (3D) world we inhabit.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量是存在于多维空间中的数学对象。这些可以是几何空间，如计算机屏幕上的二维（2D）平面或我们居住的三维（3D）世界。
- en: You can think of vectors equivalently as arrows having a specified length and
    direction, or as points in the plane relative to a reference point called the
    *origin*. Given a point, there is a corresponding arrow that shows how to get
    to that point from the origin.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将向量等价地视为具有指定长度和方向的箭头，或者视为相对于称为*原点*的参考点的平面上的点。给定一个点，有一个相应的箭头显示如何从原点到达该点。
- en: You can connect collections of points in the plane to form interesting shapes
    like a dinosaur.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在平面上连接点集合，形成像恐龙这样的有趣形状。
- en: In 2D, coordinates are pairs of numbers that help us measure the location of
    points in the plane. Written as a tuple (*x*, *y*), the *x* and *y* values tell
    us how far horizontally and vertically to travel to get to the point.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在2D中，坐标是帮助我们测量平面上点位置的数字对。写成元组（*x*，*y*），*x*和*y*的值告诉我们水平方向和垂直方向要移动多远才能到达该点。
- en: We can store points as coordinate tuples in Python and choose from a number
    of libraries to draw the points on the screen.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在Python中将点存储为坐标元组，并从多个库中选择来在屏幕上绘制这些点。
- en: Vector addition has the effect of translating (or moving) a first vector in
    the direction of a second added vector. Thinking of a collection of vectors as
    paths to travel, their vector sum gives the overall direction and distance traveled.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量加法的效果是将第一个向量在第二个加向量方向上移动（或移动）。将向量集合视为旅行路径，它们的向量和给出了整体的方向和行进距离。
- en: Scalar multiplication of a vector by a numeric factor yields a vector that is
    longer by that factor and points in the same direction as the original.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量与一个数值因子进行标量乘法运算会产生一个新的向量，其长度增加该因子，且方向与原始向量相同。
- en: Subtracting one vector from a second gives the relative position of the second
    vector from the first.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从第二个向量中减去一个向量给出了第二个向量相对于第一个向量的相对位置。
- en: Vectors can be specified by their length and direction (as an angle). These
    two numbers define the polar coordinates of a given 2D vector.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量可以通过其长度和方向（作为一个角度）来指定。这两个数字定义了给定二维向量的极坐标。
- en: The trigonometric functions sine, cosine, and tangent are used to convert between
    ordinary (Cartesian) coordinates and polar coordinates.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正弦、余弦和正切等三角函数用于在普通（笛卡尔）坐标系和极坐标系之间进行转换。
- en: It’s easy to rotate shapes defined by collections of vectors in polar coordinates.
    You only need to add or subtract the given rotation angle from the angle of each
    vector. Rotating and translating shapes in the plane lets us place them anywhere
    and in any orientation.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在极坐标系中，通过向量集合定义的形状很容易旋转。你只需将给定的旋转角度加到或从每个向量的角度中减去。在平面上旋转和移动形状，使我们能够将它们放置在任何位置和任何方向。
