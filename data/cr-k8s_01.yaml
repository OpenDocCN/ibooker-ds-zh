- en: 1 Why Kubernetes exists
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 为什么存在 Kubernetes
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Why Kubernetes exists
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么存在 Kubernetes
- en: Commonly used Kubernetes terms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用 Kubernetes 术语
- en: Specific use cases for Kubernetes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 的具体用例
- en: High-level Kubernetes features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级 Kubernetes 功能
- en: When not to run Kubernetes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时不运行 Kubernetes
- en: '*Kubernetes* is an open source platform for hosting containers and defining
    application-centric APIs for managing cloud semantics around how these containers
    are provisioned with storage, networking, security, and other resources. Kubernetes
    enables continuous reconciliation of the entire state space of your application
    deployments, including how they are accessed from the outside world.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kubernetes* 是一个开源平台，用于托管容器并定义以应用程序为中心的 API，用于管理围绕这些容器如何配置存储、网络、安全和其他资源的云语义。Kubernetes
    使您应用程序部署的整个状态空间持续进行协调，包括它们如何从外部世界访问。'
- en: 'Why implement Kubernetes in your environment as opposed to manually provisioning
    these sorts of resources using a DevOps-related infrastructure tool? The answer
    lies in the way we define DevOps to be increasingly integrated into the overall
    application life cycle over time. DevOps has evolved increasingly to include processes,
    engineers, and tools that support a more automated administration of applications
    in a data center. One of the keys to doing this successfully is reproducibility
    of infrastructure: a change made to fix an incident on one component that’s not
    replicated perfectly across all other identical components means one or more components
    differ.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要在您的环境中实现 Kubernetes，而不是手动使用 DevOps 相关的基础设施工具来配置这些资源？答案在于我们定义 DevOps 的方式，随着时间的推移，它越来越多地集成到整体应用程序生命周期中。DevOps
    不断演变，包括支持数据中心中应用程序更自动化管理的流程、工程师和工具。成功完成此任务的关键之一是基础设施的可重复性：对某个组件进行更改以修复事件，但该更改没有完美地复制到所有其他相同组件，这意味着一个或多个组件不同。
- en: In this book, we will take a deep dive into the best practices for using Kubernetes
    with DevOps, so components are replicated as needed and your system fails less
    often. We will also explore the under-the-hood processes to better understand
    Kubernetes and get the most efficient system possible.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将深入探讨使用 Kubernetes 与 DevOps 的最佳实践，以便按需复制组件，并使您的系统故障更少。我们还将探索底层的流程，以更好地理解
    Kubernetes 并获得最有效的系统。
- en: 1.1 Reviewing a few key terms before we get started
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 在我们开始之前回顾几个关键术语
- en: 'In 2021, Kubernetes was one of the most commonly deployed cloud technologies.
    Because of this, we don’t always fully define new terms before referencing them.
    In case you’re new to Kubernetes or are unsure of a few terms, we provide some
    key definitions that you can refer back to throughout the first few chapters of
    this book as you ramp up on this new universe. We will redefine these concepts
    with more granularity and in greater context as we dig into them later in this
    book:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2021 年，Kubernetes 是最常部署的云技术之一。因此，在引用之前，我们并不总是完全定义新术语。如果您是 Kubernetes 的新手或者对一些术语不确定，我们提供了一些关键定义，您可以在本书的前几章中参考这些定义，随着您在这个新领域的学习，我们将更细致、更广泛地重新定义这些概念：
- en: '*CNI and CSI*—The container networking and storage interfaces, respectively,
    that allow for pluggable networking and storage for Pods (containers) that run
    in Kubernetes.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CNI 和 CSI*—容器网络和存储接口，分别允许为在 Kubernetes 中运行的 Pod（容器）提供可插拔的网络和存储。'
- en: '*Container*—A Docker or OCI image that typically runs an application.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Container*—通常运行应用程序的 Docker 或 OCI 镜像。'
- en: '*Control plane*—The brains of a Kubernetes cluster, where scheduling of containers
    and managing all Kubernetes objects takes place (sometimes referred to as Masters).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Control plane*—Kubernetes 集群的“大脑”，在这里进行容器的调度和管理所有 Kubernetes 对象（有时称为 Masters）。'
- en: '*DaemonSet*—Like a deployment, but it runs on every node of a cluster.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DaemonSet*—类似于部署，但它运行在集群的每个节点上。'
- en: '*Deployment*—A collection of Pods that is managed by Kubernetes.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Deployment*—由 Kubernetes 管理的 Pod 集合。'
- en: '*kubectl*—The command-line tool for talking to the Kubernetes control plane.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*kubectl*—与 Kubernetes 控制平面通信的命令行工具。'
- en: '*`kubelet`*—The Kubernetes agent that runs on your cluster nodes. It does what
    the control plane needs it to do.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`kubelet`*—在您的集群节点上运行的 Kubernetes 代理。它执行控制平面需要它执行的操作。'
- en: '*Node*—A machine that runs a kubelet process.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Node*—运行 kubelet 进程的机器。'
- en: '*OCI*—The common image format for building executable, self-contained applications.
    Also referred to as *Docker images*.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OCI*—构建可执行、自包含应用程序的通用镜像格式。也称为 *Docker 镜像*。'
- en: '*Pod*—The Kubernetes object that encapsulates a running container.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pod*——Kubernetes对象，封装了正在运行的容器。'
- en: 1.2 The infrastructure drift problem and Kubernetes
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 基础设施漂移问题与Kubernetes
- en: Managing infrastructure is a reproducible way of managing the “drift” of that
    infrastructure’s configuration as hardware, compliance, and other data-center
    requirements change over time. This applies to both the *definition* of applications
    as well as to the *management* of the hosts these apps run on. IT engineers are
    all too familiar with common toil such as
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 管理基础设施是以可重复的方式管理该基础设施配置的“漂移”，因为硬件、合规性和数据中心的其他要求随着时间的推移而变化。这既适用于应用程序的*定义*，也适用于这些应用程序运行的宿主机的*管理*。IT工程师对常见的繁琐工作如
- en: Updating the Java version on a fleet of servers
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器群上更新Java版本
- en: Making sure certain applications don’t run in specific places
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保某些应用程序不在特定位置运行
- en: Replacing or scaling old or broken hardware and migrating applications from
    it
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换或扩展旧或损坏的硬件，并将应用程序从其迁移
- en: Manually managing load-balancing routes
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动管理负载均衡路由
- en: Forgetting to document new infrastructure changes when lacking a common enforced
    configuration language
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在缺乏共同强制配置语言的情况下，忘记记录新的基础设施更改
- en: As we manage and update servers in a data center, or in the cloud, the odds
    that their original definitions “drift away” from the intended IT architecture
    increases. Applications might be running in the wrong places, with the wrong resource
    allotment, or with access to the wrong storage modules.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在数据中心或云中管理和更新服务器时，它们原始定义“漂移”出预期IT架构的可能性会增加。应用程序可能会在错误的位置运行，拥有错误的资源分配，或者访问错误的存储模块。
- en: 'Kubernetes gives us a way to centrally manage the entire state space of all
    applications with one handy tool: `kubectl` ([https://kubernetes.io/docs/tasks/tools/](https://kubernetes.io/docs/tasks/tools/)),
    a command-line client that makes REST API calls to the Kubernetes API server.
    We can also use Kubernetes API clients to do these tasks programmatically. It’s
    quite easy to install `kubectl` and to test it on a `kind` cluster, which we’ll
    do early on in this book.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes通过一个便捷的工具`kubectl` ([https://kubernetes.io/docs/tasks/tools/](https://kubernetes.io/docs/tasks/tools/))，为我们提供了一种集中管理所有应用程序整个状态空间的方式：`kubectl`是一个命令行客户端，它向Kubernetes
    API服务器发出REST API调用。我们还可以使用Kubernetes API客户端以编程方式执行这些任务。安装`kubectl`和在一个`kind`集群上测试它相当容易，我们将在本书的早期阶段这样做。
- en: Previous approaches to managing this complex application state space include
    technologies such as Puppet, Chef, Mesos, Ansible, and SaltStack. Kubernetes borrows
    from these different approaches by taking the state management capabilities of
    tools such as Puppet, while borrowing concepts from some of the application and
    scheduling primitives provided by software such as Mesos.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 管理这个复杂的应用状态空间之前的方法包括Puppet、Chef、Mesos、Ansible和SaltStack等技术。Kubernetes借鉴了这些不同的方法，通过采用Puppet等工具的状态管理能力，同时借鉴了Mesos等软件提供的一些应用和调度原语的概念。
- en: Ansible, SaltStack, and Terraform typically have played a major role in infrastructure
    configuration (paving OS-specific requirements such as firewalls or binary installations).
    Kubernetes manages this concept as well, but it uses *privileged containers* on
    a Linux environment (these are known as *HostProcess Pods* on Windows v1.22).
    For example, a privileged container in a Linux system can manage iptables rules
    for routing traffic to applications, and in fact, this is exactly what the Kubernetes
    Service proxy (known as the *kube-proxy*) does.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible、SaltStack和Terraform通常在基础设施配置中扮演着重要角色（铺平了特定操作系统的要求，如防火墙或二进制安装）。Kubernetes也管理这个概念，但在Linux环境中使用*特权容器*（在Windows
    v1.22上称为*HostProcess Pods*）。例如，Linux系统中的特权容器可以管理iptables规则，将流量路由到应用程序，实际上这正是Kubernetes服务代理（称为*kube-proxy*）所做的事情。
- en: Google, Microsoft, Amazon, VMware, and many companies have adopted containerization
    as a core and enabling strategy for their customers to run fleets of hundreds
    or thousands of applications on different cloud and bare metal environments. Containers
    are, thus, a fundamental primitive for both running apps *and* managing application
    infrastructure (such as providing containers with IP addresses) that run the services
    these apps depend on (such as the provisioning of bespoke storage and firewall
    requirements), and, most importantly, run the applications themselves.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Google、Microsoft、Amazon、VMware 以及许多公司已将容器化作为核心和启用策略，使客户能够在不同的云和裸机环境中运行数百或数千个应用程序。因此，容器是运行应用程序和管理工作基础设施（例如为容器提供
    IP 地址）的基本原语，这些基础设施运行着这些应用程序所依赖的服务（例如提供定制存储和防火墙需求），最重要的是运行应用程序本身。
- en: Kubernetes is (at the time of this writing) essentially undisputed as the modern
    standard for orchestrating and running containers in any cloud, server, or data
    center environment.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 在撰写本文时，基本上是任何云、服务器或数据中心环境中编排和运行容器的现代标准的无争议选择。
- en: 1.3 Containers and images
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 容器和镜像
- en: Apps have dependencies that must be fulfilled by the host on which they run.
    Developers in the pre-container era accomplished this task in an ad hoc manner
    (for example, a Java app would require a running JVM along with firewall rules
    to talk to a database).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有依赖项，必须由它们运行的主机来满足。在容器时代之前，开发者以临时方式完成这项任务（例如，Java 应用程序需要运行 JVM 以及与数据库通信的防火墙规则）。
- en: At its core, Docker can be thought of as a way to run containers, where a *container*
    is a running OCI image ([https://github.com/opencontainers/image-spec](https://github.com/opencontainers/image-spec)).
    The *OCI specification* is a standard way to define an image that can be executed
    by a program such as Docker, and it ultimately is a tarball with various layers.
    Each of the tarballs inside an image contains such things as Linux binaries and
    application files. Thus, when you run a container, the container runtime (such
    as Docker, containerd, or CRI-O) takes the image, unpacks it, and starts a process
    on the host system that runs the image contents.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Docker 可以被视为运行容器的途径，其中 *容器* 是一个正在运行的 OCI 镜像 ([https://github.com/opencontainers/image-spec](https://github.com/opencontainers/image-spec))。*OCI
    规范* 是一种标准方式来定义一个可以被 Docker 等程序执行的形象，它最终是一个包含多个层的 tarball。镜像内部的每个 tarball 包含诸如
    Linux 可执行文件和应用文件等东西。因此，当你运行一个容器时，容器运行时（如 Docker、containerd 或 CRI-O）会取镜像，解包它，并在主机系统上启动一个运行镜像内容的进程。
- en: Containers add a layer of isolation that obviates the need for managing libraries
    on a server or preloading infrastructure with other accidental application dependencies
    (figure 1.1). For instance, if you have two Ruby applications that require different
    versions of the same library, you can use two containers. Each Ruby application
    is isolated inside a running container and has the specific version of the library
    that it requires.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 容器增加了一层隔离，消除了在服务器上管理库或在预加载基础设施时与其他意外应用程序依赖项的需求（图 1.1）。例如，如果你有两个需要同一库不同版本的 Ruby
    应用程序，你可以使用两个容器。每个 Ruby 应用程序都在一个运行的容器内隔离，并具有它所需的特定版本的库。
- en: '![](../Images/CH01_F02_Love.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH01_F02_Love.png)'
- en: Figure 1.1 Applications running in containers
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 在容器中运行的应用程序
- en: 'There is a phase that is well known: “Well, it runs on my machine.” When installing
    software, it can often run in one environment or machine but not in another. Using
    images simplifies running the same software on different servers. We’ll talk more
    about images and containers in chapter 3.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个众所周知的过程：“嗯，它在我的机器上运行。”在安装软件时，它通常可以在一个环境或机器上运行，但不能在另一个环境中运行。使用镜像简化了在不同服务器上运行相同软件的过程。我们将在第
    3 章中更多地讨论镜像和容器。
- en: 'Combine using images with Kubernetes, allowing for running immutable servers,
    and you have a level of simplicity that is world-class. As containers are quickly
    becoming an industry standard for the deployment of software applications, a few
    data points are worth mentioning:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用镜像与 Kubernetes 结合起来，允许运行不可变的服务器，这将带来世界级的简单性。随着容器迅速成为软件应用程序部署的行业标准，以下是一些值得注意的数据点：
- en: '*Surveying over 88,000 developers, Docker and Kubernetes ranked third among
    the most loved development technologies of 2020.* This just behind Linux and Docker
    ([http://mng .bz/nY12](http://mng.bz/nY12)).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调查了 88,000 名开发者，Docker 和 Kubernetes 在 2020 年最受欢迎的开发技术中排名第三。* 这仅略低于 Linux 和
    Docker ([http://mng.bz/nY12](http://mng.bz/nY12))。'
- en: '*Datadog recently found that Docker encompasses 50% or more of the average
    developer’s workflow.* Likewise, company-wide adoption is over 25% of all businesses
    ([https:// www.datadoghq.com/docker-adoption/](https://www.datadoghq.com/docker-adoption/)).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Datadog 最近发现，Docker 占据了平均开发人员工作流程的 50% 或更多。* 同样，公司范围内的采用率也超过所有企业的 25% ([https://www.datadoghq.com/docker-adoption/](https://www.datadoghq.com/docker-adoption/))。'
- en: The bottom line is that we need automation for containers, and this is where
    Kubernetes fits in. Kubernetes dominates the space much like the Oracle database
    and the vSphere virtualization platform did during their heydays. Years later,
    Oracle databases and vSphere installations still exist; we predict the same longevity
    for Kubernetes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是我们需要容器自动化，这正是 Kubernetes 发挥作用的地方。Kubernetes 在这个领域的主导地位，就像 Oracle 数据库和 vSphere
    虚拟化平台在其鼎盛时期所做的那样。多年以后，Oracle 数据库和 vSphere 安装仍然存在；我们预测 Kubernetes 也将拥有同样的长寿。
- en: We’ll begin this book with a basic understanding of Kubernetes features. Its
    purpose is to take you beyond the basic principles to the lower-level core. Let’s
    dive in and look at an extremely over-simplified Kubernetes (also referred to
    as “K8s”) workflow that demonstrates some of the higher-order tenants of building
    and running microservices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从对 Kubernetes 功能的基本理解开始这本书。其目的是让您超越基本原理，深入到更底层的核心。让我们深入探讨，看看一个非常简化的 Kubernetes（也称为“K8s”）工作流程，该工作流程展示了构建和运行微服务的一些高级原则。
- en: 1.4 Core foundation of Kubernetes
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 Kubernetes 的核心基础
- en: At its core, we define everything in Kubernetes as plain text files, defined
    via YAML or JSON, and it runs your OCI images for you in a declarative way. We
    can use this same approach (YAML or JSON text files) to configure networking rules,
    role-based authentication and authorization (RBAC), and so on. By learning one
    syntax and how it is structured, any Kubernetes system can be configured, managed,
    and optimized.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，我们将 Kubernetes 中的所有内容定义为纯文本文件，通过 YAML 或 JSON 定义，并以声明式的方式为您运行 OCI 镜像。我们可以使用这种相同的方法（YAML
    或 JSON 文本文件）来配置网络规则、基于角色的身份验证和授权（RBAC）等。通过学习一种语法及其结构，任何 Kubernetes 系统都可以进行配置、管理和优化。
- en: 'Let’s look at a quick sample of how one might run Kubernetes for a simple app.
    Don’t worry; we’ll have plenty of real-world examples to walk you through the
    entire life cycle of an application later in the book. Consider this just a visual
    guide to our hand-waving we’ve done thus far. To start with a concrete example
    of a microservice, the following code snippet generates a Dockerfile that builds
    an image capable of running MySQL:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看看如何为简单的应用程序运行 Kubernetes 的一个示例。不用担心；我们将在本书的后面部分提供大量的真实世界示例，引导您了解应用程序的整个生命周期。请将此视为我们迄今为止所做的挥手的视觉指南。为了从具体的微服务示例开始，以下代码片段生成一个
    Dockerfile，该 Dockerfile 构建了一个能够运行 MySQL 的镜像：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'One would typically build this image (using `docker build`) and push it (using
    something like `docker` `push`) to an *OCI registry* (a place where such an image
    can be stored and retrieved by a container at run time). You can find a common
    open source registry to host on your own at [https://github.com/goharbor/harbor](https://github.com/goharbor/harbor).
    Another such registry that is also commonly used for millions of applications
    worldwide resides at [https://hub.docker.com/](https://hub.docker.com/). For this
    example, let’s say we pushed this image, and now we are running it, somewhere.
    We might also want to build a container to talk to this service (maybe we have
    a custom Python app that serves as a MySQL client). We might define its Docker
    image like so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，人们会构建这个镜像（使用 `docker build`），然后将其推送到一个 *OCI 仓库*（一个可以在运行时由容器存储和检索此类镜像的地方）。您可以在
    [https://github.com/goharbor/harbor](https://github.com/goharbor/harbor) 找到一个常见的开源仓库，您可以在自己的服务器上托管它。另一个这样的仓库，也是全球数百万应用程序常用的，位于
    [https://hub.docker.com/](https://hub.docker.com/)。对于这个例子，让我们假设我们已经推送了这个镜像，现在它在某个地方运行。我们可能还想要构建一个容器来与这个服务通信（也许我们有一个自定义的
    Python 应用程序作为 MySQL 客户端）。我们可能定义其 Docker 镜像如下：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, if we wanted to run our client and the MySQL server as containers in a
    Kubernetes environment, we could easily do so by creating two Pods. Each one of
    these Pods might run one of the respective containers like so:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想在 Kubernetes 环境中以容器形式运行我们的客户端和 MySQL 服务器，我们可以通过创建两个 Pod 来轻松实现。这些 Pod
    中的每一个都可能运行相应的容器，如下所示：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We would, typically, store the previous YAML snippet in a text file (for example,
    my-app.yaml) and execute it using the Kubernetes client tool (for example, `kubectl
    create` `-f` `my-app.yaml`). This tool connects to the Kubernetes API server and
    transfers the YAML definition to be stored. Kubernetes then automatically takes
    the definitions of the two Pods that we have on the API server and makes sure
    they are up and running somewhere.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会存储之前的 YAML 片段到一个文本文件中（例如，my-app.yaml），然后使用 Kubernetes 客户端工具（例如，`kubectl
    create` `-f` `my-app.yaml`）执行它。此工具连接到 Kubernetes API 服务器并将要存储的 YAML 定义传输过去。然后
    Kubernetes 自动获取 API 服务器上我们拥有的两个 Pod 的定义，并确保它们在某处运行。
- en: 'This doesn’t happen instantly: it requires the nodes in the cluster to respond
    to events that are constantly occurring and updates that state in their Node objects
    via the kubelet communicating to the API server. It also requires that the OCI
    images are present and accessible to the nodes in our Kubernetes cluster. Things
    can go wrong at any time, so we refer to Kubernetes as an *eventually consistent
    system*, wherein reconciliation of the desired state over time is a key design
    philosophy. This consistency model (compared with a guaranteed consistency model)
    ensures that we can continually request changes to the overall state space of
    all applications in our cluster and lets the underlying Kubernetes platform figure
    out the logistics of *how* these apps are set in motion over time.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是瞬间发生的：它需要集群中的节点响应不断发生的事件，并通过与 API 服务器通信的 kubelet 更新它们的 Node 对象中的状态。这也要求 OCI
    镜像存在于我们的 Kubernetes 集群中的节点上。任何时间都可能出错，因此我们将 Kubernetes 称为“最终一致系统”，其中随着时间的推移对期望状态的协调是一个关键设计理念。这种一致性模型（与保证一致性模型相比）确保我们可以持续请求更改集群中所有应用程序的整体状态空间，并让底层的
    Kubernetes 平台确定这些应用程序随时间启动的“如何”。
- en: This scales into real-world scenarios quite naturally. For example, if you tell
    Kubernetes, “I want five applications spread across three zones in a cloud,” this
    can be accomplished entirely by defining a few lines of YAML utilizing Kubernetes’
    scheduling primitives. Of course, you need to make sure that those three zones
    actually exist and that your scheduler is aware of them, but even if you haven’t
    done this, Kubernetes will at least schedule some of the workloads on the zones
    that are available.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这在现实世界的场景中自然地扩展。例如，如果您告诉 Kubernetes，“我想在云中的三个区域中分布五个应用程序”，这可以通过定义几行 YAML 并利用
    Kubernetes 的调度原语来完成。当然，您需要确保这三个区域确实存在，并且您的调度器知道它们，但即使您没有这样做，Kubernetes 至少会在可用的区域上调度一些工作负载。
- en: In short, Kubernetes allows you to define the desired state of all the apps
    in your cluster, how they are networked, where they run, what storage they use,
    and so on, while delegating the underlying implementation of these details to
    Kubernetes itself. Thus, you’ll rarely find the need to do a one-off Ansible or
    a Puppet update in a production Kubernetes scenario (unless you are reinstalling
    Kubernetes itself, and even then, there are tools such as the Cluster API that
    allow you to use Kubernetes to manage Kubernetes (now we’re getting in way over
    our heads).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Kubernetes 允许您定义集群中所有应用程序的期望状态，包括它们的网络连接方式、运行位置、使用的存储方式等等，同时将这些细节的实现委托给
    Kubernetes 本身。因此，在生产的 Kubernetes 环境中，您很少需要单独执行一次 Ansible 或 Puppet 更新（除非您正在重新安装
    Kubernetes 本身，即使在这种情况下，也有如 Cluster API 这样的工具允许您使用 Kubernetes 来管理 Kubernetes（现在我们真的有点超出我们的理解范围了）。
- en: 1.4.1 All infrastructure rules in Kubernetes are managed as plain YAML
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.1 Kubernetes 中的所有基础设施规则都作为纯 YAML 进行管理
- en: Kubernetes automates all of the aspects of the technology stack using the Kubernetes
    API, which can be entirely managed as YAML and JSON resources. This includes traditional
    IT infrastructure rules (which still apply in some manner or other to microservices)
    such as
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用 Kubernetes API 自动化技术栈的所有方面，这些方面可以完全作为 YAML 和 JSON 资源进行管理。这包括传统的
    IT 基础设施规则（这些规则以某种方式或形式适用于微服务），例如：
- en: Server configuration of ports or IP routes
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器配置端口或 IP 路由
- en: Persistent storage availability for applications
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的持久存储可用性
- en: Hosting of software on specific or arbitrary servers
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定或任意服务器上托管软件
- en: Security provisioning, such as RBAC or networking rules for applications to
    access one another
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全配置，例如 RBAC 或网络规则，以便应用程序相互访问
- en: DNS configuration on a per-application and global basis
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个应用程序和全局基础上进行 DNS 配置
- en: All of these components are defined within configuration files that are representations
    of objects within the Kubernetes API. Kubernetes uses these building blocks and
    containers by applying changes, monitoring those changes, and addressing momentary
    failures or disruptions until achieving the desired end state. When “things go
    bump in the night,” Kubernetes will handle a lot of scenarios automatically, and
    we do not have to fix the problems ourselves. Properly configuring more elaborate
    systems with automation permits the DevOps team to focus on solving complex problems,
    to plan for the future, and to find the best-in-class solutions for the business.
    Next, let’s review the features that Kubernetes provides and how they support
    the use of Pods.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些组件都在配置文件中定义，这些配置文件是Kubernetes API中对象的表示。Kubernetes通过应用更改、监控这些更改以及解决暂时性故障或中断，直到达到期望的最终状态来使用这些构建块和容器。当“夜晚有东西发出声响”时，Kubernetes将自动处理许多场景，我们不必亲自解决问题。通过自动化配置更复杂的系统，允许DevOps团队能够专注于解决复杂问题，规划未来，并为业务找到最佳解决方案。接下来，让我们回顾Kubernetes提供的功能以及它们如何支持Pod的使用。
- en: 1.5 Kubernetes features
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 Kubernetes特性
- en: '*Container orchestration platforms* allow developers to automate the process
    of running instances, provisioning hosts, linking containers to optimize orchestration
    procedures, and extending application life cycles. It’s time to dive into the
    core features within a container orchestration platform because, essentially,
    containers need Pods and Pods need Kubernetes to'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*容器编排平台*允许开发者自动化运行实例、配置主机、将容器链接起来以优化编排流程以及扩展应用程序的生命周期。现在是时候深入挖掘容器编排平台的核心特性了，因为本质上，容器需要Pods，而Pods需要Kubernetes来'
- en: Expose a cloud-neutral API for all functionality within the API server
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个云中立的API，用于API服务器中的所有功能
- en: Integrate with all major cloud and hypervisor platforms within the Kubernetes
    controller manager (also referred to as KCM)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes控制器管理器（也称为KCM）中与所有主要云和虚拟平台集成
- en: Provide a fault-tolerant framework for storing and defining the state of all
    Services, applications, and data center configurations or other Kubernetes-supported
    infrastructures
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个容错框架，用于存储和定义所有服务、应用程序、数据中心配置或Kubernetes支持的其他基础设施的状态
- en: Manage deployments while minimizing user-facing downtime, whether to an individual
    host, Service, or application
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最小化面向用户的中断的情况下管理部署，无论是针对单个主机、服务还是应用程序
- en: Automate scaling for hosts and hosted applications with rolling update awareness
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过滚动更新意识自动化主机和托管应用程序的扩展
- en: Create internal and external integrations (known as ClusterIP, NodePort, or
    LoadBalancer Service types) with load balancing
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有负载均衡的内联和外部集成（称为ClusterIP、NodePort或LoadBalancer服务类型）
- en: Provide the ability to schedule applications to run on specific virtualized
    hardware, based on its metadata, via node labeling and the Kubernetes scheduler
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供能力，根据其元数据在特定虚拟化硬件上调度应用程序运行，通过节点标签和Kubernetes调度器实现
- en: Deliver a highly available platform via DaemonSets and other technology infrastructures
    that prioritizes containers that run on all nodes in the cluster
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过DaemonSets和其他技术基础设施提供高度可用的平台，优先考虑在集群中所有节点上运行的容器
- en: Allow for service discovery via a domain name service (DNS), implemented previously
    by KubeDNS and, most recently, by CoreDNS, which integrates with the API server
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许通过域名服务（DNS）进行服务发现，之前由KubeDNS实现，最近则由CoreDNS实现，它与API服务器集成
- en: Run batch processes (known as Jobs) that use storage and containers in the same
    way persistent applications run
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行批处理过程（称为作业），它们使用存储和容器的方式与持久化应用程序运行方式相同
- en: Include API extensions and construct native API-driven programs using custom
    resource definitions, without building any port mappings or plumbing
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含API扩展，并使用自定义资源定义构建原生API驱动程序，无需构建任何端口映射或管道
- en: Enable inspection of failed cluster-wide processes including remote execution
    into any container at any time via `kubectl exec` and `kubectl describe`
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许检查失败的集群级过程，包括通过`kubectl exec`和`kubectl describe`在任何时间远程执行到任何容器
- en: Allow the mounting of local and/or remote storage to a container and manage
    declarative storage volumes for containers with the StorageClass API and PersistentVolumes
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许将本地和/或远程存储挂载到容器中，并使用StorageClass API和PersistentVolumes管理容器的声明性存储卷
- en: Figure 1.2 is a simple diagram of a Kubernetes cluster. What Kubernetes does
    is by no means trivial. It standardizes the life cycle management of multiple
    applications running in or on the same cluster. The foundation of Kubernetes is
    a cluster, consisting of nodes. The complexity of Kubernetes is, admittedly, one
    of the complaints that engineers have about Kubernetes. The community is working
    on making it easier, but Kubernetes is solving a complex problem that is hard
    to solve to begin with.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 是一个 Kubernetes 集群的简单示意图。Kubernetes 所做的工作绝非易事。它标准化了在同一集群中运行或运行的多个应用程序的生命周期管理。Kubernetes
    的基础是一个由节点组成的集群。诚然，Kubernetes 的复杂性是工程师对 Kubernetes 的一个抱怨。社区正在努力使其更容易使用，但 Kubernetes
    解决的是一个复杂的问题，一开始就很难解决。
- en: '![](../Images/CH01_F01_Love.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F01_Love.png)'
- en: Figure 1.2 An example Kubernetes cluster
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 一个示例 Kubernetes 集群
- en: 'If you don’t need high availability, scalability, and orchestration, then maybe
    you don’t need Kubernetes. Let’s now consider a typical failure scenario in a
    cluster:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不需要高可用性、可扩展性和编排，那么可能您不需要 Kubernetes。现在让我们考虑一个集群中的典型故障场景：
- en: A node stops responding to the control plane.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个节点停止响应控制平面。
- en: The control plane reschedules the Pods running on the unresponsive node to another
    node or nodes.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制平面将运行在无响应节点上的 Pods 重新调度到另一个或多个节点。
- en: When a user makes an API call into the API server via `kubectl`, the API server
    responds with the correct information about the unresponsive node and the new
    location of the Pods.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户通过 `kubectl` 向 API 服务器发出 API 调用时，API 服务器会响应关于无响应节点的正确信息以及 Pods 的新位置。
- en: All clients that communicate to the Pod’s Service are rerouted to its new location.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有与 Pod 的服务通信的客户端都被重定向到其新位置。
- en: Storage volumes attached to Pods on the failing node are moved to the new Pod
    location so that its old data is still readable.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到故障节点上 Pods 的存储卷被移动到新的 Pod 位置，以便其旧数据仍然可读。
- en: The purpose of this book is to give you deeper insight into how this all really
    works under the hood and how the underlying Linux primitives complement the high-level
    Kubernetes components to accomplish these tasks. Kubernetes relies heavily on
    hundreds of technologies in the Linux stack, which are often hard to learn and
    lack deep documentation. It is our hope that by reading this book, you’ll understand
    a lot of the subtleties of Kubernetes, which are often overlooked in the tutorials
    first used by engineers to get up and running with containers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目的在于让您深入了解这一切在底层是如何真正工作的，以及底层 Linux 基本原理如何补充高级 Kubernetes 组件以完成这些任务。Kubernetes
    严重依赖于 Linux 堆栈中的数百项技术，这些技术往往难以学习且缺乏深入文档。我们希望您通过阅读本书，能够理解 Kubernetes 的许多细微之处，这些细微之处往往在工程师首次使用教程启动容器时被忽视。
- en: It is natural to run Kubernetes on top of immutable operating systems. You have
    a base OS that only updates when you update the entire OS (and thus is immutable),
    and you install your Nodes/Kubernetes using that OS. There are many advantages
    to running an immutable OS that we will not cover here. You can run Kubernetes
    in the cloud, on bare metal servers, or even on a Raspberry Pi. In fact, the U.S.
    Department of Defense is currently researching how to run Kubernetes on some of
    its fighter jets. IBM even supports running clusters on its next generation mainframes,
    PowerPCs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在不可变操作系统上运行 Kubernetes 是很自然的。您有一个基础操作系统，只有在您更新整个操作系统时才会更新（因此是不可变的），您使用该操作系统安装您的节点/Kubernetes。运行不可变操作系统有许多优势，我们在此不一一介绍。您可以在云中、裸金属服务器上，甚至是在树莓派上运行
    Kubernetes。事实上，美国国防部目前正在研究如何在一些战斗机上运行 Kubernetes。IBM 甚至支持在其下一代大型机、PowerPC 上运行集群。
- en: As the cloud native ecosystem around Kubernetes continues to mature, it will
    continue to permit organizations to identify best practices, proactively make
    changes to prevent issues, and maintain environment consistency to avoid *drift*,
    where some machines behave slightly differently from others because patches were
    missed, not applied, or improperly applied.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 随着围绕 Kubernetes 的云原生生态系统不断成熟，它将继续允许组织识别最佳实践，积极采取措施预防问题，并保持环境一致性以避免*漂移*，即某些机器的行为与其他机器略有不同，因为错过了补丁、未应用或错误地应用了补丁。
- en: 1.6 Kubernetes components and architecture
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 Kubernetes 组件和架构
- en: 'Now, let’s take a moment to look at the Kubernetes architecture at a high level
    (fig-ure 1.3). In short, it consists of your hardware and the portion of your
    hardware that runs the Kubernetes control plane as well as the Kubernetes worker
    nodes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们花点时间从高层次上看看Kubernetes架构（图1.3）。简而言之，它包括你的硬件以及运行Kubernetes控制平面的硬件部分以及Kubernetes工作节点：
- en: '*Hardware infrastructure*—Includes computers, network infrastructure, storage
    infrastructure, and a container registry.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*硬件基础设施*——包括计算机、网络基础设施、存储基础设施和容器注册库。'
- en: '*Kubernetes worker nodes*—The base unit of compute in a Kubernetes cluster.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes工作节点*——Kubernetes集群中计算的基本单元。'
- en: '*Kubernetes control plane*—The mothership of Kubernetes. This covers the API
    server, scheduler, controller manager, and other controllers.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes控制平面*——Kubernetes的母船。这包括API服务器、调度器、控制器管理器和其它控制器。'
- en: '![](../Images/CH01_F03_Love.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH01_F03_Love.png)'
- en: Figure 1.3 The control plane and worker nodes
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 控制平面和工作节点
- en: 1.6.1 The Kubernetes API
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.1 Kubernetes API
- en: If there’s one important thing to take away from this chapter that will enable
    you to go forth on a deep journey through this book, it’s that administering microservices
    and other containerized software applications on a Kubernetes platform is just
    a matter of declaring Kubernetes API objects. For the most part, everything else
    is done for you.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从本章中提取一个重要的事情，这将使你能够深入阅读本书，那就是在Kubernetes平台上管理微服务和其它容器化软件应用，仅仅是声明Kubernetes
    API对象的问题。大部分的工作都会为你完成。
- en: This book will dive deeply into the API server and its datastore, etcd. Almost
    anything that you can ask `kubectl` to do results in reading, or writing, to a
    defined and versioned object in the API server. (The exceptions to this are things
    like using `kubectl` to grab logs for a running Pod, wherein this connection is
    proxied through to a node.) The `kube-apiserver` (Kubernetes API server) allows
    for CRUD (create, read, update, and delete) operations on all of the objects and
    provides a RESTful (REpresentational State Transfer) interface. Some `kubectl`
    commands like `describe` are a composite view of multiple objects. In general,
    all Kubernetes API objects have
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将深入探讨API服务器及其数据存储，etcd。几乎你可以要求`kubectl`执行的所有操作都会导致在API服务器中读取或写入一个定义和版本化的对象。（这个例外是使用`kubectl`获取正在运行的Pod的日志，其中此连接是通过代理转发到节点的。）`kube-apiserver`（Kubernetes
    API服务器）允许对所有对象进行CRUD（创建、读取、更新和删除）操作，并提供RESTful（表示状态传输）接口。一些`kubectl`命令，如`describe`，是多个对象的组合视图。一般来说，所有Kubernetes
    API对象都有
- en: A named API version (for instance, `v1` or `rbac.authorization.k8s.io/v1`)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名API版本（例如，`v1` 或 `rbac.authorization.k8s.io/v1`）
- en: 'A kind (for example, `kind: Deployment`)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一种类型（例如，`kind: Deployment`）'
- en: A metadata section
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据部分
- en: We can thank Brian Grant, one of the original Kubernetes founders, for the API
    versioning scheme that has proven to be robust over time. It may seem complicated,
    and, frankly, a bit of a pain at times, but it allows us to do things such as
    upgrades and contracts defining API changes. API changes and migration are often
    nontrivial, and Kubernetes provides a well-defined contract for API changes. Take
    a look at the API versioning documents on the Kubernetes website ([http://mng.bz/voP4](http://mng.bz/voP4)),
    and you can read through the contracts for Alpha, Beta, and GA API versions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以感谢Kubernetes的原始创始人之一Brian Grant，他提出的API版本化方案在经过时间的考验后已被证明是稳健的。它可能看起来很复杂，坦白说，有时有点痛苦，但它允许我们进行诸如升级和定义API变化的合同。API变化和迁移通常是相当复杂的，Kubernetes为API变化提供了一个明确的合同。查看Kubernetes网站上的API版本化文档（[http://mng.bz/voP4](http://mng.bz/voP4)），你可以阅读Alpha、Beta和GA
    API版本的合同。
- en: 'Throughout the chapters in this book, we will focus on Kubernetes but keep
    returning to the basic theme: virtually everything in Kubernetes exists to support
    the Pod. In this book, we’ll look at several API elements in detail including'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的各章节中，我们将专注于Kubernetes，但会不断回到基本主题：在Kubernetes中，几乎所有东西都是为了支持Pod而存在的。在这本书中，我们将详细探讨几个API元素，包括
- en: Runtime Pods and deployments
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时Pod和部署
- en: API implementation details
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API实现细节
- en: Ingress Services and load balancing
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入口服务与负载均衡
- en: PersistentVolumes and PersistentVolumeClaims storage
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久卷和持久卷声明存储
- en: NetworkPolicies and network security
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络策略和网络安全
- en: 'There are around 70 different API types that you can play with, create, edit,
    and delete in a standard Kubernetes cluster. You can view these by running `kubectl
    api-resources`. The output should look something like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的Kubernetes集群中，你可以操作大约70种不同的API类型，包括创建、编辑和删除。你可以通过运行`kubectl api-resources`来查看这些类型。输出应该看起来像这样：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can see that each of the API resources for Kubernetes itself has
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，Kubernetes本身的每个API资源都有
- en: A short name
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简短的名字
- en: A full name
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个全名
- en: An indication of whether it is bounded to a namespace
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示它是否绑定到命名空间的标志
- en: In Kubernetes, *Namespaces* allow certain objects to exist inside of a specific
    . . . well . . . Namespace. This gives developers a simple form of hierarchical
    grouping. For example, if you have an application that runs 10 different microservices,
    you commonly might create all of these Pods, Services, and PersistentVolumeClaims
    (also referred to as PVCs) inside the same Namespace. That way, when it’s time
    for you to delete the app, you can just delete the Namespace. In chapter 15, we’ll
    look at higher-level ways to analyze the life cycle of applications, which are
    more advanced than this simplistic approach. But for many cases, the namespace
    is the most obvious and intuitive solution for separating all the Kubernetes API
    objects associated with an app.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，*命名空间*允许某些对象存在于特定的……嗯……命名空间内。这为开发者提供了一种简单的分层分组形式。例如，如果你有一个运行10个不同微服务的应用程序，你可能会在同一个命名空间内创建所有这些Pod、服务以及持久卷声明（也称为PVC）。这样，当你需要删除应用程序时，你只需删除命名空间即可。在第15章中，我们将探讨分析应用程序生命周期的更高级方法，这些方法比这种简单的方法更先进。但就许多情况而言，命名空间是分离与应用程序相关的所有Kubernetes
    API对象的最明显和直观的解决方案。
- en: '1.6.2 Example one: An online retailer'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.2 示例一：在线零售商
- en: Imagine a major online retailer that needs to be able to quickly scale with
    demand seasonally, such as around the holidays. Scaling and predicting how to
    scale has been one of their biggest challenges—maybe the biggest. Kubernetes solves
    a multitude of problems that come with running a highly available, scalable distributed
    system. Imagine the possibilities of having the ability to scale, distribute,
    and make highly available systems at your fingertips. Not only is it a better
    way to run a business, but it is also the most efficient and effective platform
    for managing systems. When combining Kubernetes and cloud providers, you can run
    on someone else’s servers when you need extra resources instead of buying and
    maintaining extra hardware just in case.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个需要能够根据季节性需求快速扩展的大型在线零售商，比如在假日前后。扩展和预测如何扩展一直是他们最大的挑战——也许是最大的。Kubernetes解决了运行高度可用、可扩展的分布式系统所带来的众多问题。想象一下，如果你能够轻松地扩展、分配并使系统高度可用，那将会有多大的可能性。这不仅是一种更好的经营方式，而且也是管理系统的最有效和最有效的平台。当结合Kubernetes和云提供商时，当你需要额外资源时，你可以运行在别人的服务器上，而不是购买和维护额外的硬件以防万一。
- en: '1.6.3 Example two: An online giving solution'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.3 示例二：在线捐赠解决方案
- en: For a second real-world example of this transition that is worth mentioning,
    let’s consider an online donation website that enables contributions to a broad
    range of charities per a user’s choice. Let’s say this particular example started
    out as a WordPress site, but eventually, business transactions lead to a full-blown
    dependency on JVM frameworks (like Grails) with a customized UX, middle tier,
    and database layer. The requirements for this business tsunami included machine
    learning, ad serving, messaging, Python, Lua, NGINX, PHP, MySQL, Cassandra, Redis,
    Elastic, ActiveMQ, Spark, lions, tigers, and bears . . . and stop already.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个过渡的一个值得提及的现实世界例子，让我们考虑一个允许用户根据个人选择向广泛慈善机构捐款的在线捐赠网站。假设这个特定的例子最初是一个WordPress网站，但最终，商业交易导致完全依赖于JVM框架（如Grails）以及定制的UX、中间层和数据库层。这个商业巨浪的要求包括机器学习、广告服务、消息传递、Python、Lua、NGINX、PHP、MySQL、Cassandra、Redis、Elastic、ActiveMQ、Spark、狮子、老虎和熊……等等，别再说了。
- en: The initial infrastructure was a hand-built cloud virtual machine (VM), using
    Puppet to set everything up. As the company grew, they designed for scale, but
    this included more and more VMs that only hosted one or two applications. Then
    they decided to move to Kubernetes. The VM count was reduced from around 30 to
    5 and scaled more easily. They completely eliminated Puppet and the server setup,
    and thus the need to manually manage machine infrastructure by hand, thanks to
    their transition to heavy use of Kubernetes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 初始基础设施是一个手工构建的云虚拟机（VM），使用Puppet设置一切。随着公司的发展，他们设计了可扩展性，但这包括越来越多的仅托管一个或两个应用程序的VM。然后他们决定转向Kubernetes。虚拟机数量从大约30个减少到5个，并且更容易扩展。他们完全消除了Puppet和服务器设置，因此由于转向大量使用Kubernetes，他们不再需要手动管理机器基础设施。
- en: The transition to Kubernetes for this company resolved the entire class of VM
    administration problems, the burden of DNS for complex service publishing, and
    much more. Additionally, the recovery times in cases of catastrophic failures
    were much more predictable to manage from an infrastructure standpoint. When you
    experience the benefits of moving to a standardized API-driven methodology that
    works well and has the power to make massive changes quickly, you begin to appreciate
    the declarative nature of Kubernetes and its cloud-native approach to container
    orchestration.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该公司转向Kubernetes解决了整个类别的虚拟机管理问题，减轻了复杂服务发布的DNS负担，以及更多问题。此外，在灾难性故障的情况下，恢复时间从基础设施的角度来看更加可预测和管理。当你体验到迁移到标准化、API驱动的方法的好处时，这种方法运行良好且能够快速进行大规模变更，你开始欣赏Kubernetes的声明性特性和其云原生容器编排方法。
- en: 1.7 When not to use Kubernetes
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 不应使用Kubernetes的情况
- en: Admittedly, there are always use cases where Kubernetes might not be a good
    fit. Some of these include
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 承认，总有使用Kubernetes可能不是最佳选择的情况。其中一些包括
- en: '*High-performance computing (HPC)*—Using containers adds a layer of complexity
    and, with the new layer, a performance hit. The latency created by using a container
    is getting much smaller, but if your application is influenced by nano- or microseconds,
    using Kubernetes might not be the best option.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高性能计算（HPC）*——使用容器增加了一层复杂性，并且随着新层，性能受到影响。使用容器创建的延迟正在变得很小，但如果你的应用程序受纳诺秒或微秒的影响，使用Kubernetes可能不是最佳选择。'
- en: '*Legacy*—Some applications have hardware, software, and latency requirements
    that make it difficult to simply containerize. For example, you may have applications
    that you purchased from a software company that does not officially support running
    in a container or running their application within a Kubernetes cluster.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*遗留*——某些应用程序具有硬件、软件和延迟要求，这使得简单地容器化变得困难。例如，你可能购买了来自一个不正式支持在容器中运行或在其Kubernetes集群中运行其应用程序的软件公司的应用程序。'
- en: '*Migration*—Implementations of legacy systems may be so rigid that migrating
    them to Kubernetes offers little advantage other than “we are built on Kuber-netes.”
    But some of the most significant gains come after migrating, when monolithic applications
    are parsed up into logical components, which can then scale independently of each
    other.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迁移*——遗留系统的实现可能非常僵化，将其迁移到Kubernetes除了“我们建立在Kubernetes之上”之外几乎没有其他优势。但迁移之后，当单体应用程序被解析成逻辑组件时，这些组件可以独立扩展。'
- en: 'The important thing here is this: learn and master the basics. Kubernetes solves
    many of the problems presented in this chapter in a stable, cost-sensitive manner.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是这一点：学习和掌握基础知识。Kubernetes以稳定、成本敏感的方式解决了本章中提出的许多问题。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Kubernetes makes your life easier!
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes使你的生活更轻松！
- en: The Kubernetes platform can run on any type of infrastructure.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes平台可以在任何类型的基础设施上运行。
- en: Kubernetes builds an ecosystem of components that work together. Combining the
    components empowers companies to prevent, recover, and scale in real time when
    urgent changes are required.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes构建了一个协同工作的组件生态系统。结合这些组件，使公司能够在需要紧急变更时实时预防、恢复和扩展。
- en: 'Everything you do in Kubernetes can be done with one simple tool: `kubectl`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes中做的所有事情都可以用一款简单的工具来完成：`kubectl`。
- en: Kubernetes creates a cluster from one or more computers, and that cluster provides
    a platform to deploy and host containers. It offers container orchestration, storage
    management, and distributed networking.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes从一台或多台计算机创建一个集群，该集群提供了一个部署和托管容器的平台。它提供容器编排、存储管理和分布式网络。
- en: Kubernetes was born from previous configuration-driven, container-driven approaches.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 是从之前的配置驱动、容器驱动方法中诞生的。
- en: 'The Pod is the basic building block of Kubernetes. It supports the myriad of
    features that Kubernetes allows: scaling, failover, DNS lookup, and RBAC security
    rules.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod 是 Kubernetes 的基本构建块。它支持 Kubernetes 允许的众多功能：扩展、故障转移、DNS 查询和 RBAC 安全规则。
- en: Kubernetes applications are entirely managed by simply making API calls to the
    Kubernetes API server.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 应用程序完全通过向 Kubernetes API 服务器发出 API 调用来管理。
