- en: 14 Testing beyond JUnit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14 超越JUnit的测试
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Integration testing with Testcontainers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Testcontainers进行集成测试
- en: Specification-style testing with Spek and Kotlin
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spek和Kotlin进行规范式测试
- en: Property-based testing with Clojure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Clojure进行基于属性的测试
- en: 'In the previous chapter, we looked at the general principles that guide our
    testing. Now we’re going to dive deeper into specific approaches to improve our
    testing for different situations. Whether our goal is cleaner testing of dependencies,
    better communication in our testing code, or even discovery of edge cases we hadn’t
    considered, the JVM ecosystem provides many tools to help out, and we will highlight
    only a few. Let’s start with that ever-present struggle: how to deal with external
    dependencies effectively when writing integration tests.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们研究了指导我们测试的一般原则。现在我们将更深入地探讨针对不同情况的具体方法来改进我们的测试。无论我们的目标是更干净地测试依赖项、在测试代码中更好的沟通，还是甚至发现我们没有考虑到的边缘情况，JVM生态系统提供了许多工具来帮助我们，我们只突出其中的一些。让我们从那个始终存在的斗争开始：在编写集成测试时如何有效地处理外部依赖项。
- en: 14.1 Integration testing with Testcontainers
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 使用Testcontainers进行集成测试
- en: As we move up the pyramid from our isolated unit tests, we encounter a variety
    of obstacles. To integration test against a real database requires that we have
    a real database available to use! Getting the benefits of that realistic testing
    implies a huge increase in setup complexity. The statefulness of these external
    systems also increases the chances of our tests failing, not because of problems
    with our code but because of unexpected state lingering between tests.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从隔离的单元测试向上移动金字塔时，我们会遇到各种障碍。要针对真实数据库进行集成测试，我们需要一个可用的真实数据库！从现实测试中获得好处意味着设置复杂性的巨大增加。这些外部系统的状态性也增加了我们的测试失败的可能性，不是因为我们的代码有问题，而是因为测试之间意外保留的状态。
- en: Over the years, this has been tackled in many ways, from in-memory databases
    to frameworks for running tests fully within transactions that clean up after
    themselves. But these solutions often bring their own edge cases and difficulties.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，这已经以许多方式解决，从内存数据库到在事务中完全运行测试并自行清理的框架。但这些解决方案通常带来了自己的边缘情况和困难。
- en: Containerization technology, as discussed in chapter 12, provides an interesting
    new approach to the problem. Because containers are ephemeral, they are well suited
    to spinning up for a given test run. Because they encapsulate the real databases
    and other services we want to interact with, they avoid the subtle mismatches
    substitutes that in-memory databases are prone to.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如第12章所述的容器化技术，为解决该问题提供了一种有趣的新方法。因为容器是短暂的，非常适合为特定的测试运行启动。因为它们封装了我们想要与之交互的真实数据库和其他服务，所以避免了内存数据库容易出现的细微不匹配的替代品。
- en: 14.1.1 Installing testcontainers
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1 安装testcontainers
- en: 'One of the simplest ways to leverage containers in our testing is through the
    `testcontainers` library (see [https://www.testcontainers.org/](https://www.testcontainers.org/)).
    This provides an API to control containers directly from our test code, with a
    wide variety of supported modules for common dependencies. The core functionality
    is provided through the `org.testcontainers.testcontainers` JAR in Maven:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中利用容器的最简单方法之一是通过`testcontainers`库（见[https://www.testcontainers.org/](https://www.testcontainers.org/))）。这为我们提供了从测试代码中直接控制容器的API，以及广泛支持的模块，用于常见的依赖项。核心功能是通过Maven中的`org.testcontainers.testcontainers`
    JAR提供：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'or Gradle:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '或者 Gradle:'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 14.1.2 An example with Redis
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2 Redis示例
- en: If you recall, we left our theater application downloading prices from an HTTP
    service. We’d like to introduce a cache for those values. Although proper caching
    is a whole topic of its own, imagine we decided to externalize the cache rather
    than just putting the values in memory. A typical datastore for this is Redis
    ([https://redis.io/](https://redis.io/)). Redis exposes blazing fast access to
    get, set, and delete key-value pairs, along with other more complex data structures.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们留下了我们的剧院应用程序从HTTP服务下载价格。我们希望为这些值引入一个缓存。尽管适当的缓存是一个完整的主题，但想象一下，我们决定将缓存外部化，而不是仅仅将值放在内存中。这种数据存储的典型例子是Redis
    ([https://redis.io/](https://redis.io/))。Redis提供了快速访问以获取、设置和删除键值对，以及其他更复杂的数据结构。
- en: 'The `Price` interface that we already introduced for data lookups from an HTTP
    service, shown next, allows us the flexibility to add the caching as a separate
    concern:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为从HTTP服务中查找数据而引入的`Price`接口，如下所示，使我们能够将缓存作为单独的关注点添加：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The name of the key we will cache the price in Redis
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们将在Redis中缓存价格的关键字名称
- en: ❷ We use the Jedis ([https://github.com/redis/jedis](https://github.com/redis/jedis))
    library for access to Redis.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们使用Jedis ([https://github.com/redis/jedis](https://github.com/redis/jedis))库来访问Redis。
- en: ❸ Checks whether the cache has this price already
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查缓存中是否已有这个价格
- en: ❹ If we don’t have the price, uses the lookup provided
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果我们没有价格，则使用提供的查找
- en: ❺ Caches the value we just retrieved
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 缓存我们刚刚检索到的值
- en: 'At this point it’s worth pausing to consider what aspect of the system we want
    to test. The main point of the `CachedPrice` class is the interaction between
    Redis and our underlying price lookup. How we work with Redis is key, and Testcontainers
    lets us test against the real thing as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，值得停下来考虑我们想要测试系统的哪个方面。`CachedPrice`类的主要点是Redis与我们的底层价格查找之间的交互。我们如何与Redis交互是关键，Testcontainers允许我们按照以下方式对实际事物进行测试：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this beginning section of the test, we see the most basic form of wiring
    up with Testcontainers. We apply the `@Testcontainers` annotation to the test
    class as a whole, letting the library know that it should watch for containers
    we require during the test execution. The field marked with `@Container` then
    requests our specific container image `"redis:6.2.3-alpine"` to start, using the
    standard Redis port, 6379.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试的这个开始部分，我们看到与Testcontainers连接的最基本形式。我们将`@Testcontainers`注解应用于整个测试类，让库知道它应该在测试执行期间监视我们所需的容器。标记为`@Container`的字段请求启动特定的容器镜像`"redis:6.2.3-alpine"`，使用标准的Redis端口6379。
- en: When this test class executes, as shown in figure 14.1, Testcontainers starts
    up the container we’ve asked for. Testcontainers will wait for a default timeout
    (60 seconds) for the first mapped port to be available, so we can be confident
    the container is ready to talk to. The `redis` field then allows us to get information
    like the hostname and ports for use later in our test.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个测试类执行时，如图14.1所示，Testcontainers会启动我们请求的容器。Testcontainers将等待默认的超时时间（60秒），直到第一个映射端口可用，这样我们就可以确信容器已经准备好通信。`redis`字段然后允许我们获取主机名和端口等信息，以便在测试的后续部分使用。
- en: '![](../Images/CH14_F01_Evans2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 Testcontainers执行](../Images/CH14_F01_Evans2.png)'
- en: Figure 14.1 Testcontainers execution
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 测试容器执行
- en: 'With our containerized Redis running, we can get down to the actual tests.
    Because the key point is our interaction between Redis and the lookup—not how
    the underlying price lookup is actually implemented—we can reuse our prior `StubPrice`,
    which always returns 10 to simplify the testing, as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的容器化Redis运行时，我们可以开始实际的测试。因为关键点是Redis与查找之间的交互——而不是底层价格查找的实际实现——我们可以重用我们之前的`StubPrice`，它总是返回10以简化测试，如下所示：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Sets a price that differs from our stubbed price in Redis
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在Redis中设置一个与我们的stubbed price不同的价格
- en: ❷ Passes StubPrice as our lookup, which will return 10, not 20
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将StubPrice作为我们的查找传递，它将返回10而不是20
- en: ❸ Asserts that we received the cached value
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言我们收到了缓存的值
- en: ❹ Removes any previously cached value in Redis with the del call
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用del调用删除Redis中之前缓存的任何值
- en: ❺ Helper method for setting up our Jedis instance.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 设置我们的Jedis实例的辅助方法。
- en: It’s important to note how the `getJedisConnection` method uses the configuration
    from Testcontainers to connect to Redis. Although you may observe that `redis
    .getHost()` is a common value, such as `localhost`, this isn’t necessarily guaranteed
    in every environment. It’s better to ask Testcontainers for such values and protect
    ourselves from unexpected changes to those values in the future.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意`getJedisConnection`方法如何使用Testcontainers的配置来连接到Redis。尽管你可能观察到`redis.getHost()`是一个常见的值，例如`localhost`，但这并不一定在每种环境中都保证。最好向Testcontainers请求这样的值，并保护自己免受未来这些值意外变化的影响。
- en: Although the automated spinup of containers here is quite convenient, it’s worth
    understanding how to control it more directly. This is especially true if your
    containers require time to start up, as we’ll see with later examples like relational
    databases with required schemas.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这里自动启动容器非常方便，但了解如何更直接地控制它是有价值的。这尤其适用于你的容器需要时间来启动的情况，正如我们将在后续示例中看到的，例如需要模式的关系数据库。
- en: The `@Container` annotation recognizes when it’s being applied on a static field
    versus an instance field, as shown in figure 14.2\. When applied to a static field,
    the container will be spun up once for the duration of the test class’s execution.
    If you instead left the field at an instance level, then each individual test
    will start and stop the container instead.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Container` 注解识别它是在静态字段上应用还是在实例字段上应用，如图14.2所示。当应用于静态字段时，容器将在测试类执行期间启动一次。如果你将字段留在实例级别，那么每个单独的测试将启动和停止容器。'
- en: '![](../Images/CH14_F02_Evans2.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH14_F02_Evans2.png)'
- en: Figure 14.2 Fields and `@Container`
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 字段和 `@Container`
- en: 'This points to another potential way to manage our container life time: what
    if we wanted to run the container only once for our entire test suite? To accomplish
    this, we have to leave the `@Container` annotation behind and use the API directly
    exposed by the `GenericContainer` object itself as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这指向了管理我们的容器生命周期的另一种潜在方法：如果我们只想为整个测试套件运行一次容器怎么办？为了实现这一点，我们必须放弃 `@Container` 注解，并直接使用
    `GenericContainer` 对象本身公开的API，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ start may be safely called multiple times on an instance—it will begin the
    container only once for each object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在实例上安全地多次调用 `start` —— 它将为每个对象只开始一次容器。
- en: We aren’t required to provide a `tearDown` to explicitly stop the container,
    because the `testcontainers` library takes care of that automatically for us.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要提供 `tearDown` 来显式停止容器，因为 `testcontainers` 库会自动为我们处理。
- en: Although the previous example calls `start` for each test, the `redis` object
    could move to a location where it could be shared between multiple test classes
    safely.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的例子为每个测试调用 `start`，但 `redis` 对象可以移动到一个位置，在那里它可以安全地在多个测试类之间共享。
- en: 14.1.3 Gathering container logs
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.3 收集容器日志
- en: If you run these tests at the command line or in your IDE, you may notice that
    by default there is no output from the containers. For our simple Redis case,
    this isn’t a problem, but more complex setups or debugging may have you wishing
    for more visibility into those containers. To assist here, Testcontainers allows
    accessing `STDOUT` and `STDERR` from the containers it spins up.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过命令行或在你的集成开发环境中运行这些测试，你可能会注意到默认情况下容器没有输出。对于我们的简单Redis案例，这并不是问题，但对于更复杂的设置或调试，你可能希望有更多的容器可见性。为了帮助这里，Testcontainers
    允许访问它启动的容器的 `STDOUT` 和 `STDERR`。
- en: This support is based on the JDK’s `Consumer<>` interface, and several implementations
    ship with the library. You can connect to standard logging providers or, as we’ll
    demonstrate, get at the raw logging directly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种支持基于JDK的 `Consumer<>` 接口，库中包含几个实现。你可以连接到标准日志提供者，或者，如我们将要展示的，直接获取原始日志。
- en: 'You may find it inconvenient to have the container logs spewed into your main
    output, but it’s also a pain having to do something custom when you do want them.
    One solution is to plumb in support to always capture them to a separate location,
    such as a file in your build output, like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得将容器日志输出到主输出不方便，但当你确实需要它们时，进行自定义操作也很痛苦。一个解决方案是添加支持，始终将它们捕获到单独的位置，例如构建输出中的一个文件，如下所示：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ We’re using the @Container annotation for spinup again because it’s so easy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们再次使用 @Container 注解来启动，因为它非常简单。
- en: ❷ Our consumer instance will gather the logs during the course of our test run.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们的消费者实例将在测试运行过程中收集日志。
- en: ❸ Attaches the consumer to our container, asking for both STDOUT and STDERR
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将消费者附加到我们的容器，请求STDOUT和STDERR
- en: ❹ Writes to convenient location
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 写入方便的位置
- en: ❺ Uses java.nio.Files for easy writing of the file contents
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用java.nio.Files轻松写入文件内容
- en: 14.1.4 An example with Postgres
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.4 Postgres的示例
- en: 'Redis makes an easy example given its lack of dependencies, the temporary nature
    of data normally stored there, and the fast startup time on the container. But
    what about that sticking point in traditional integration testing: the relational
    database? Often the data we put in a relational store is the most critical to
    our application’s true functionality, but testing it is fraught with stale data,
    awkward mocking, and false positives.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Redis没有依赖关系，通常存储的数据是临时的，以及容器上的快速启动时间，它是一个容易的例子。但关于传统集成测试中的痛点：关系型数据库怎么办？我们放入关系型存储的数据通常是我们的应用程序真正功能的最关键部分，但测试它充满了陈旧数据、尴尬的模拟和假阳性。
- en: Testcontainers supports a wide variety of different datastores. These are packaged
    in separate modules, which must be pulled in. We’ll demonstrate using Postgres,
    but on the Testcontainers website ([https://www.testcontainers.org/modules/databases/](https://www.testcontainers.org/modules/databases/)),
    you’ll find a long list of other options.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Testcontainers 支持广泛的不同的数据存储。这些被包装在单独的模块中，必须将其引入。我们将使用 Postgres 进行演示，但在 Testcontainers
    网站 ([https://www.testcontainers.org/modules/databases/](https://www.testcontainers.org/modules/databases/))
    上，您将找到其他选项的长列表。
- en: 'We include the Postgres module as a test dependency and the main Postgres driver
    as well to be able to connect to our new database in Maven:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 Postgres 模块作为测试依赖项以及主要的 Postgres 驱动程序一起包含，以便能够在 Maven 中连接到我们的新数据库：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'or Gradle:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用 Gradle：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It’s important that this version match the base `org.testcontainers:testcontainers`
    library you’re using.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，这个版本需要与您使用的基 `org.testcontainers:testcontainers` 库相匹配。
- en: 'A specific class wraps our access to Postgres container. This has helpers for
    configuring information such as the database name and credentials, as shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特定的类封装了我们访问 Postgres 容器的操作。它提供了配置信息，如数据库名称和凭证的帮助器，如下所示：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All the same lifecycle management considerations apply here, with the added
    wrinkle that a relational database needs schema applied before it’s usable. Many
    common database migration projects can be run from code, but we’ll demonstrate
    just using JDBC directly to show that nothing magic is going on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里适用所有相同的生命周期管理考虑因素，额外的问题是关系数据库在使用之前需要应用模式。许多常见的数据库迁移项目都可以从代码中运行，但我们将仅使用 JDBC
    直接演示，以表明没有发生任何魔法。
- en: 'First off, we need a connection to our container instance. Using the JDBC classes,
    we set it up with parameters from our `postgres` Testcontainer object like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要连接到我们的容器实例。使用 JDBC 类，我们可以使用来自我们的 `postgres` Testcontainer 对象的参数来设置它，如下所示：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note Testcontainers includes a feature where you can modify your connection
    strings, and it will automatically start containers for your databases. Although
    convenient, it’s less direct to demonstrate. This may be especially valuable,
    though, when integrating Testcontainers into an existing test suite.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Testcontainers 包含一个功能，允许您修改您的连接字符串，并且它会自动启动数据库的容器。虽然很方便，但演示起来可能不太直接。然而，当将
    Testcontainers 集成到现有的测试套件中时，这可能特别有价值。
- en: 'With our connection, we want to ensure our schema is in place before any of
    our tests run. Within the scope of one test class, we’d accomplish this with a
    `@BeforeAll` as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的连接，我们希望在运行任何测试之前确保我们的模式已经就绪。在一个测试类的作用域内，我们可以通过以下方式使用 `@BeforeAll` 来完成：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ For our example, a SQL file has our schema definitions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于我们的示例，一个 SQL 文件包含我们的模式定义。
- en: ❷ Applies the SQL
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 应用 SQL
- en: 'With the schema in place, our tests can now run against this full-fledged,
    empty Postgres database as shown next:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式就绪后，我们的测试现在可以针对这个完整的、空的 Postgres 数据库运行，如下所示：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you have other abstractions such as DAO (data access objects), repositories,
    or other ways of reading from the database, they should all work fine with the
    connection to the container.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有其他抽象，如 DAO（数据访问对象）、仓库或其他从数据库读取的方式，它们都应该与容器的连接正常工作。
- en: 14.1.5 An example for end-to-end testing with Selenium
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.5 使用 Selenium 进行端到端测试的示例
- en: The move to using external resources in containers is a natural fit for integration
    testing. Similar techniques apply with end-to-end testing as well. Though it depends
    on your precise system, often an end-to-end test will want to exercise a browser
    to ensure that a web application is running as expected.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器中的外部资源进行集成测试是一个自然的选择。在端到端测试中，也适用类似的技术。尽管这取决于您的具体系统，但通常端到端测试会想要测试浏览器，以确保网络应用程序按预期运行。
- en: Historically, driving a web browser from code was a touchy proposition. The
    techniques remain fragile and slow, but Testcontainers takes away the installation
    and configuration pain by letting you spin up a browser inside a container and
    control it there remotely.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，从代码中驱动网络浏览器是一个有点棘手的问题。这些技术仍然很脆弱且速度慢，但 Testcontainers 通过让您在容器内启动浏览器并远程控制它来消除安装和配置的痛苦。
- en: 'As with our Postgres example, we’ll need to pull in dependencies. In this case,
    there’s a module for Testcontainers support alongside the libraries required for
    our tests to remote-control the browser instance in Maven:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的 Postgres 示例一样，我们需要引入依赖项。在这种情况下，有一个用于 Testcontainers 支持的模块，以及用于在 Maven
    中远程控制浏览器实例所需的库：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'or Gradle:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用 Gradle：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Support for other web browsers also exists in similarly named packages.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 类似名称的包中也存在对其他网络浏览器的支持。
- en: 'Specific classes configure the browser instances. We’ll pass in `ChromeOptions`
    here to indicate that we’re starting that particular browser:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的类配置浏览器实例。这里我们将传递 `ChromeOptions` 来表明我们正在启动那个特定的浏览器：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With this instance, we can now write tests that visit web pages and inspect
    the results as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个实例，我们现在可以编写测试，访问网页并检查结果，如下所示：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Navigates to the GitHub organization for well-grounded-java
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导航到 well-grounded-java 的 GitHub 组织
- en: ❷ Once the page loads, checks the first <h1> contents
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 页面加载后，检查第一个 <h1> 内容
- en: This simple example already shows the sort of fragility that end-to-end testing
    is prone to. What if GitHub redesigns and decides to add another `<h1>` in the
    page? What if they alter the title text in some subtle way? If you’re testing
    your own applications, this may be less of a problem, but the tight coupling to
    the presentation remains an issue.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子已经显示了端到端测试容易出现的脆弱性。如果 GitHub 重新设计并决定在页面上添加另一个 `<h1>`，或者他们以某种微妙的方式更改标题文本，会怎样？如果你正在测试自己的应用程序，这可能不是一个大问题，但与展示的紧密耦合仍然是一个问题。
- en: Running inside a container, if things aren’t what we expect, it can be difficult
    to understand why. Fortunately, we can get visual feedback in a couple of ways.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内运行时，如果事情不是我们预期的，理解原因可能会很困难。幸运的是，我们可以通过几种方式获得视觉反馈。
- en: 'First off, we can screenshot at specific points in time like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以像这样在特定时间点截图：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The file returned is temporary and will be removed at the end of the test, but
    you can copy it elsewhere in the code after it’s been created.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的文件是临时的，将在测试结束时被删除，但你可以在创建后将其复制到代码的其他地方。
- en: 'Seeing more than just a point in time is common enough. You can also just request
    a video of the session to be recorded automatically as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 只看到某个时间点的情况很常见。你还可以请求自动记录会议的视频，如下所示：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we did with container logs, this will make recordings in our build output
    any time the tests are run. Everything we need to debug is ready, right there
    already, should trouble arise.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对容器日志所做的那样，这将使我们的构建输出在测试运行时进行记录。我们需要调试的一切都准备好了，如果出现麻烦，一切都在那里。
- en: This just scratches the surface of what Testcontainers will allow you to accomplish.
    Now let’s take a look at leaving JUnit behind to write our tests in a different,
    potentially more readable form.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是触及了 Testcontainers 可以让你完成的表面。现在让我们看看如何放弃 JUnit，以不同的、可能更易读的形式编写我们的测试。
- en: 14.2 Specification-style testing with Spek and Kotlin
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 使用 Spek 和 Kotlin 进行规范式测试
- en: The way JUnit uses methods, classes, and annotations is very natural to a Java
    developer. But whether or not we’re aware of it, it shapes how we express and
    group our tests. Although not required, we often end up with one test class mapping
    to our production class and loose clusters of test methods for each implementation
    method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 使用方法、类和注解的方式对 Java 开发者来说非常自然。但无论我们是否意识到，它都塑造了我们表达和分组测试的方式。尽管不是必需的，我们通常最终会得到一个测试类映射到我们的生产类，以及为每个实现方法松散的测试方法集群。
- en: An alternative idea is what’s known as writing *specifications.* This grew out
    of frameworks such as RSpec and Cucumber, and rather than focusing on how our
    code is shaped, it aims to support specifying how the system works at a higher
    level, more aligned to how humans would discuss requirements.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个想法是所谓的编写 *规范*。这源于 RSpec 和 Cucumber 等框架，而不是关注我们的代码是如何被塑造的，它旨在在更高层次上支持指定系统的工作方式，更符合人类讨论需求的方式。
- en: An example of this sort of testing is available in Kotlin via the Spek framework
    (see [https://www.spekframework.org/](https://www.spekframework.org/)). As we’ll
    see, many of Kotlin’s built-in features allow for a very different organization
    and feel in our specs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试的一个例子可以通过 Kotlin 中的 Spek 框架获得（见 [https://www.spekframework.org/](https://www.spekframework.org/)）。正如我们将看到的，Kotlin
    的许多内置功能允许我们在规范中实现非常不同的组织和感觉。
- en: Installing Spek follows the typical process for dependencies. Spek focuses entirely
    on how we structure our specifications and leans on the ecosystem for functionality
    such as assertions and test running. For simplicity here, we’ll demonstrate with
    the assertions and test runner from JUnit 5, but you are not required to use these
    if you have other libraries you prefer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Spek遵循依赖项的典型过程。Spek完全关注我们如何构建规范，并依赖于生态系统中的功能，如断言和测试运行。为了简单起见，我们将使用JUnit 5中的断言和测试运行器进行演示，但如果你有其他你更喜欢的库，则不需要使用这些。
- en: 'In Maven, the `maven-surefire-plugin` from section 11.2.6 just needs to be
    informed about our specification files, which we’ll mark by including `Spek` in
    the filenames, as shown next. We’ll also need the Kotlin support described in
    section 11.2.5 (not repeated here for length):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Maven中，只需通知11.2.6节中的`maven-surefire-plugin`我们的规范文件，我们将通过在文件名中包含`Spek`来标记这些文件，如下所示。我们还需要11.2.5节中描述的Kotlin支持（此处未重复，以节省篇幅）：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Because of our custom file convention, we have to tell Maven what to run.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由于我们的自定义文件约定，我们必须告诉Maven要运行什么。
- en: ❷ Uses JUnit’s assertion API
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用JUnit的断言API
- en: ❸ Uses Spek’s integration with JUnit test runners
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用Spek与JUnit测试运行器的集成
- en: 'In Gradle, we plug into the standard `test` task and notify the JUnit platform
    of Spek’s engine, as shown in the next code snippet. You may find that command-line
    tests will see our specifications without the engine line, but other systems like
    our IDE may miss them:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gradle中，我们连接到标准的`test`任务，并通知JUnit平台Spek的引擎，如下面的代码片段所示。你可能发现命令行测试将看到我们的规范，而无需引擎行，但其他系统，如我们的IDE，可能错过它们：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Uses JUnit’s assertion API
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用JUnit的断言API
- en: ❷ Uses Spek’s integration with JUnit test runners
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用Spek与JUnit测试运行器的集成
- en: ❸ Looks up the test task, informing that it’s of type Test so we can access
    the useJUnitPlatform and following methods
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查找测试任务，通知它是Test类型，因此我们可以访问useJUnitPlatform和后续方法
- en: ❹ Notifies JUnit of our engine for better IDE integration
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通知JUnit我们的引擎以实现更好的IDE集成
- en: 'Now we can get down to writing our first specification. To examine this, we’ll
    take the prior testing we’ve done against the `InMemoryCachedPrice` class and
    see how Spek alters the structure and flow of our testing as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以着手编写我们的第一个规范。为了检查这一点，我们将查看针对`InMemoryCachedPrice`类所做的先前测试，并看看Spek如何改变我们的测试结构和流程，如下所示：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ === is Kotlin’s operator for reference equality, so this checks that we get
    the exact same object between calls, not just an identical value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `===`是Kotlin的引用相等运算符，因此这检查在调用之间我们是否得到完全相同的对象，而不仅仅是相同的值。
- en: Our first specification spells out behavior around an empty cache. We can see
    a number of Kotlin features at work. First off, our specification is declared
    as a singleton `object` instead of a class. This helps to clarify test lifetime
    issues that occasionally happen in JUnit, depending on whether the test runner
    constructs a single instance of the test per class or per individual test method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项规范详细说明了空缓存的行为。我们可以看到许多Kotlin特性正在发挥作用。首先，我们的规范被声明为一个单例`object`而不是一个类。这有助于阐明JUnit中偶尔发生的测试生命周期问题，这取决于测试运行器是按类还是按单个测试方法构造测试的单个实例。
- en: 'The main specification is declared within a lambda expression, passed as a
    parameter to the `Spek` class. In this lambda, two important functions are available:
    `group` and `test`. Each of these is given a full `String` description. No camel-casing,
    underscores, or other tricks are required to make the description readable. `group`
    is intended for you to put together various related `test` calls. The `group`
    constructs can also be nested, if desired.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 主要规范在lambda表达式中声明，作为`Spek`类的参数传递。在这个lambda中，有两个重要的函数可用：`group`和`test`。每个函数都提供了一个完整的`String`描述。不需要驼峰命名法、下划线或其他技巧来使描述可读。`group`用于将各种相关的`test`调用组合在一起。如果需要，`group`构造函数也可以嵌套。
- en: 'If this reformatting was all that specification-style testing brought to the
    table, it wouldn’t be very compelling. However, the grouping is more than just
    naming because we can declare *fixtures* that share the setup across multiple
    tests as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种重新格式化是规范式测试带来的唯一好处，那么它就不会很有吸引力。然而，分组不仅仅是命名，因为我们可以声明*固定装置*，以便在多个测试中共享设置，如下所示：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In our “empty cache” group, we declare two fixtures: a `stubbedPrice` for use
    in setting up the cache and the `cachedPrice` instance we’ll test. Any `test`
    call that’s a member of this `group` gets an identical view of these fixtures.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的“空缓存”组中，我们声明了两个 fixtures：一个 `stubbedPrice` 用于设置缓存，以及我们将要测试的 `cachedPrice`
    实例。任何属于这个 `group` 的 `test` 调用都会得到这些 fixtures 的相同视图。
- en: 'The recommended pattern for fixtures is to use `lateinit` and initialize them
    in `beforeEachTest`. This need for late initialization actually reflects that
    Spek runs our specification in two phases: discovery and then execution.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的 fixtures 模式是使用 `lateinit` 并在 `beforeEachTest` 中初始化它们。这种延迟初始化的需要实际上反映了 Spek
    以两个阶段运行我们的规范：发现和执行。
- en: 'During the discovery phase, the top-level lambda for our specification is run.
    `group` lambdas are eagerly evaluated, but `test` calls aren’t made yet; instead,
    they are noticed for later execution. After all of the specification’s groups
    have been evaluated, the `test` lambdas are executed. This separation, shown next,
    allows for tighter control over the context of each `group` before each individual
    `test` runs:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在发现阶段，我们的规范的最高级 lambda 被运行。`group` lambda 被急切地评估，但 `test` 调用尚未执行；相反，它们被注意到以供稍后执行。在评估完所有规范的组之后，`test`
    lambda 被执行。这种分离，如以下所示，允许在每次单个 `test` 运行之前更紧密地控制每个 `group` 的上下文：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Runs during the discovery phase
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在发现阶段运行
- en: ❷ Runs during the execution phase
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在执行阶段运行
- en: The use of `lateinit` is a little clunky, so Spek wraps that up using Kotlin’s
    *delegated properties*. Each fixture can be followed with a `by memoized` call
    and a lambda to provide the value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `lateinit` 有点笨拙，所以 Spek 使用 Kotlin 的 *委托属性* 来封装它。每个 fixture 都可以跟一个 `by memoized`
    调用和一个 lambda 来提供值。
- en: Note *memoized* (not memorized!) is a term for a value that’s calculated once
    and cached for later use.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 *memoized*（不是 memorized！）是一个表示计算一次并缓存以供以后使用的值的术语。
- en: 'Don’t use these for the result of actions you’re testing—those should be done
    within the `test` lambdas themselves, like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将这些用于你正在测试的动作的结果——那些应该在 `test` lambda 本身内完成，如下所示：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The test discovery phase happening via plain execution of our Kotlin code allows
    for much simpler parameterization than is available in JUnit. Rather than needing
    additional annotations and reflection-based lookups, we can just loop and repeat
    calls to `test` as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接执行我们的 Kotlin 代码来发生测试发现阶段，这允许比 JUnit 可用的参数化更简单。我们不需要额外的注解和基于反射的查找，我们只需循环并重复调用
    `test`，如下所示：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Use of it on each time through loop gives us the tests testing 1, testing
    2, and testing 3.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在循环的每次迭代中使用它为我们提供了测试 1、测试 2 和测试 3。
- en: 'For those who may have encountered specification-style testing in other ecosystems,
    such as RSpec in Ruby or Jasmine in JavaScript, you can substitute the `group`
    and `test` methods with `describe` and `it` instead for an even more natural narrative
    flow, like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能在其他生态系统（如 Ruby 中的 RSpec 或 JavaScript 中的 Jasmine）中遇到过规范式测试的人来说，你可以用 `describe`
    和 `it` 替换 `group` 和 `test` 方法，以获得更自然的叙述流程，如下所示：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Another common format for writing specifications is *Gherkin syntax* ([https://cucumber.io/docs/gherkin/reference/](https://cucumber.io/docs/gherkin/reference/)),
    popularized by the Cucumber testing tool. This syntax declares our specification
    in a series of given-when-then statements: *given* this setup, *when* this action
    happens, *then* we see these consequences. Enforcing this structure often makes
    specifications more readable as natural language, not just code.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 编写规范的另一常见格式是 *Gherkin 语法* ([https://cucumber.io/docs/gherkin/reference/](https://cucumber.io/docs/gherkin/reference/))，由
    Cucumber 测试工具普及。这种语法通过一系列的给定-当-然后语句来声明我们的规范：*given* 这个设置，*when* 这个动作发生，*then*
    我们看到这些后果。强制这种结构通常会使规范在自然语言中更易于阅读，而不仅仅是代码。
- en: 'Restating a prior test in Gherkin style could look like this: *Given* an empty
    cache, *when* calculating the price, *then* we look up the default value. Here’s
    how that translates to Spek’s Gherkin support:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以 Gherkin 风格重述先前的测试可能看起来像这样：*Given* 一个空缓存，*when* 计算价格，*then* 我们查找默认值。以下是它如何转换为
    Spek 的 Gherkin 支持：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You’ll notice this also brings additional grouping from Cucumber by dividing
    our specification by `Feature` and `Scenario` before we apply given-when-then
    organization.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这也带来了来自 Cucumber 的额外分组，我们在应用给定-当-然后组织之前，通过将规范分为 `Feature` 和 `Scenario`
    来实现。
- en: Specifications give us a different way to order our testing code to better communicate
    to later readers. But they still require that we write all of our cases out by
    hand. Clojure presents some different possibilities to explore how we choose our
    testing data.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 规范为我们提供了一种不同的方式来组织我们的测试代码，以便更好地与后来的读者沟通。但它们仍然要求我们手动编写所有案例。Clojure提供了一些不同的可能性来探索我们如何选择测试数据。
- en: 14.3 Property-based testing with Clojure
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 使用Clojure进行基于属性的测试
- en: Unlike Java and Kotlin, Clojure comes with a testing framework in its standard
    library, `clojure.test`. Although we won’t cover this library in depth, let’s
    get familiar with the basics before visiting other, more exotic parts of Clojure’s
    testing ecosystem.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java和Kotlin不同，Clojure的标准库中自带了一个测试框架`clojure.test`。虽然我们不会深入探讨这个库，但在访问Clojure测试生态系统的其他更复杂部分之前，让我们先熟悉一下基础知识。
- en: 14.3.1 clojure.test
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.1 clojure.test
- en: We’ll exercise our tests via the Clojure REPL, much like we did throughout chapter
    10\. If you skipped that chapter or it’s been a while, now’s a good time to review
    the basics of Clojure if any of these tests are hard to follow.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过Clojure REPL来练习我们的测试，就像我们在第10章中做的那样。如果你跳过了那一章或者已经有一段时间了，现在是复习Clojure基础知识的好时机，如果这些测试难以理解的话。
- en: 'Although it ships directly with Clojure, `clojure.test` isn’t automatically
    bundled with our code. We need to request the library via `require`. Entering
    the following in our REPL makes all of the functions in `clojure.test` available
    with the prefix `test` that we declare via `:as`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它直接与Clojure一起发货，但`clojure.test`并没有自动捆绑到我们的代码中。我们需要通过`require`请求这个库。在我们的REPL中输入以下内容将使`clojure.test`中的所有函数都可用，并带有我们通过`:as`声明的`test`前缀：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, we can pick specific functions via `:refer` to use without prefix
    like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过`:refer`选择特定的函数，以便不带前缀使用，如下所示：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `is` function represents the base of assertions in `clojure.test`. When
    the assertion passes, we see the function returns `true`. How about when it fails?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`函数代表`clojure.test`中断言的基础。当断言通过时，我们看到函数返回`true`。那么当它失败时呢？'
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Any predicate can be used with `is`. For example, here’s how we can confirm
    that a function will throw an exception we expect:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 任何谓词都可以与`is`一起使用。例如，以下是确认一个函数将抛出我们期望的异常的方法：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ A function to always throw a RuntimeException
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 总是抛出`RuntimeException`的函数
- en: '❷ We receive an #error value, not a FAIL message. This indicates that the assertion
    passed.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们收到的是一个#error值，而不是FAIL消息。这表明断言通过了。
- en: ❸ The error also contains a full stack trace, excluded here for space.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 错误信息还包含完整的堆栈跟踪，这里为了节省空间省略了。
- en: 'With our assertions, we’re now ready to start constructing tests. A primary
    method for this is the `deftest` function, shown next:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的断言，我们现在已经准备好开始构建测试。为此的主要方法是`deftest`函数，如下所示：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Having defined our test, we now need to execute it. We can do this via the
    `run-tests` function, which will find all defined tests in our current namespace.
    For the REPL, a default namespace called `user` exists automatically, and that’s
    where our `deftest` put our test, as shown here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了我们的测试后，我们现在需要执行它。我们可以通过`run-tests`函数来完成，该函数将在我们的当前命名空间中找到所有定义的测试。对于REPL，存在一个名为`user`的默认命名空间，它自动存在，并且我们的`deftest`将测试放在那里，如下所示：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Obviously writing and running tests in a REPL is good for learning but not
    supportable for any long-term use in a project. Eventually it’s worth setting
    up a test runner, although unlike the Java world where JUnit is the standout leader,
    a few competing options exist in Clojure. A few to consider follow:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在REPL中编写和运行测试对学习很有好处，但不适合在项目中长期使用。最终，设置一个测试运行器是值得的，尽管与Java世界中的JUnit是突出领导者不同，Clojure中存在一些竞争选项。以下是一些可以考虑的选项：
- en: Leiningen ([https://leiningen.org/](https://leiningen.org/)) is a popular Clojure
    build tool that includes support for testing, much like Maven and Gradle.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Leiningen ([https://leiningen.org/](https://leiningen.org/)) 是一个流行的Clojure构建工具，它包括对测试的支持，类似于Maven和Gradle。
- en: Cognitect Labs `test-runner` ([https://github.com/cognitect-labs/test-runner](https://github.com/cognitect-labs/test-runner))
    is a simple test runner built purely on Clojure’s native dependency support.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cognitect Labs的`test-runner` ([https://github.com/cognitect-labs/test-runner](https://github.com/cognitect-labs/test-runner))
    是一个仅基于Clojure原生依赖支持的简单测试运行器。
- en: Kaocha ([https://github.com/lambdaisland/kaocha](https://github.com/lambdaisland/kaocha))
    is a full-featured test runner with a focus on modular design to the testing process.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kaocha ([https://github.com/lambdaisland/kaocha](https://github.com/lambdaisland/kaocha))
    是一个功能齐全的测试运行器，它侧重于模块化设计测试过程。
- en: 'Having said that, we’ll continue in our REPL and look now at an interesting
    ability that comes along with Clojure: data specifications.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们将在我们的 REPL 中继续操作，现在来看看 Clojure 带来的一项有趣的能力：数据规范。
- en: 14.3.2 clojure.spec
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.2 clojure.spec
- en: Although Clojure’s integration with the JVM means you can naturally work with
    classes and objects, functional programming doesn’t couple behavior as tightly
    to data. It’s common to have functions that operate against data structures composed
    of basic primitives, particularly with maps fulfilling the data-carrying behavior
    we associate with classes in object-oriented programming.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Clojure 与 JVM 的集成意味着你可以自然地处理类和对象，但函数式编程并不像面向对象编程中那样紧密地将行为与数据耦合。常见的情况是函数操作由基本原始数据结构组成的数据结构，特别是当映射履行了我们与面向对象编程中的类相关联的数据携带行为时。
- en: 'This makes it attractive to have better facilities to test the shape and contents
    of built-in data structures. That’s provided in the standard library with `clojure.spec`.
    As with `clojure.test`, we need to require the library to get access to it, as
    follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得拥有更好的设施来测试内置数据结构的形状和内容变得很有吸引力。这由标准库中的 `clojure.spec` 提供。与 `clojure.test`
    一样，我们需要导入库才能访问它，如下所示：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note Although `clojure.spec` uses the term “specification,” this is an entirely
    different use of the term from specifications we saw with Spek in Kotlin. `clojure.spec`
    defines specifications for *data* rather than for *behavior*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：尽管 `clojure.spec` 使用了“specification”这个术语，但这与我们在 Kotlin 中的 Spek 所见到的“specification”是完全不同的用法。`clojure.spec`
    定义的是 *数据* 的规范，而不是 *行为* 的规范。
- en: 'With that library available, we can start making statements about different
    values with the function `valid?`. This executes the predicate function we pass
    it against the value and gives us a Boolean in return, as shown next:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了那个库之后，我们可以开始使用 `valid?` 函数对不同值做出声明。这个函数执行我们传递给它的谓词函数，并返回一个布尔值，如下所示：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `conform` function provides us with the next level of checking, shown in
    the next code sample. If the value passes the predicate, we receive back that
    value. Otherwise, the return is a keyword `:clojure.spec.alpha/invalid`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`conform` 函数为我们提供了下一级别的检查，如下一个代码示例所示。如果值通过了谓词，我们会收到该值。否则，返回的是一个关键字 `:clojure.spec.alpha/invalid`：'
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can combine different checks together using the `and` function. It’s possible
    to do this directly via writing our own predicate functions, but using the version
    from `clojure.spec`, illustrated in the next code snippet, means the library understands
    the combination we’re creating. We’ll see in a moment how that can give us more
    information:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `and` 函数将不同的检查组合在一起。这可以通过直接编写我们自己的谓词函数来实现，但使用 `clojure.spec` 中的版本，如下一个代码片段所示，意味着库理解我们创建的组合。我们很快就会看到这如何给我们带来更多信息：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After seeing `and`, it may come as no surprise that there’s an `or` function.
    But the plot thickens if we try to use `or` just like we did with `and`, as shown
    here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到 `and` 之后，可能会有所惊讶地发现存在一个 `or` 函数。但如果尝试像使用 `and` 一样使用 `or`，情况就会变得复杂，如下所示：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This error message tells us that `or` expects to include keywords between the
    predicates we pass it. This may seem like a strange requirement for a simple Boolean
    function. However, the reason becomes clearer when we look closer at the results
    from `conform` when given `or` conditions here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误信息告诉我们 `or` 期望在其传递给它的谓词之间包含关键字。这可能看起来像是一个简单的布尔函数的奇怪要求。然而，当我们更仔细地查看给定 `or`
    条件时 `conform` 的结果，原因就会变得 clearer：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The library tells us not just that the value matches our specification—it tells
    us which branch of our `or` condition fulfilled the spec. Our specification is
    bringing more than simple yes/no validity. We’re finding out *why* the value passed
    at the same time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 库不仅告诉我们值符合我们的规范，而且还告诉我们 `or` 条件中的哪个分支满足了规范。我们的规范不仅提供了简单的 yes/no 有效性，我们还找到了值通过的原因。
- en: 'Repeating our specifications is getting tedious, and in a real application,
    such repetition is an obvious code smell. `clojure.spec` allows registering specifications
    against a namespaced keyword. Then we just call `conform` with the keyword like
    this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 重复我们的规范变得越来越乏味，在实际应用中，这种重复显然是代码的坏味道。`clojure.spec` 允许我们使用命名空间关键字注册规范。然后我们只需像这样调用
    `conform`：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The Clojure REPL comes with a handy `doc` function, which integrates nicely
    with our specifications. When handed a registered keyword, we get a neatly formatted
    version of the spec as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure REPL 内置了一个方便的 `doc` 函数，它与我们的规范很好地集成。当我们传递一个已注册的关键字时，我们得到一个格式整洁的规范版本，如下所示：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Although `conform` provides feedback on how a successful match happened, the
    `:clojure.spec.alpha/invalid` keyword is rather opaque about failure. The `explain`
    function leans on the deeper knowledge our specs already have to tell us why a
    given value fails, shown next:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`conform`提供了关于成功匹配如何发生的反馈，但`:clojure.spec.alpha/invalid`关键字对失败的解释相当晦涩。`explain`函数依赖于我们的规范已经拥有的更深入的知识，告诉我们为什么给定的值失败，如下所示：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that we’ve defined reusable specifications for values, we can apply them
    in our unit tests directly like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为值定义了可重用的规范，我们可以在单元测试中直接应用它们，如下所示：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To this point our specifications have focused on checking individual values.
    When we work with maps, though, there’s an additional question: does the shape
    of the provided data match our expectations? We validate this with the `keys`
    function.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的规范主要集中在检查单个值。当我们与映射一起工作时，还有一个额外的问题：提供的数据形状是否符合我们的预期？我们用`keys`函数来验证这一点。
- en: 'Let’s imagine part of our theater ticketing system is being written in Clojure.
    We want to confirm any ticket we’re passed has an `id` and `amount`. Optionally,
    we allow `notes`. We can define a specification for this like so:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设想我们的剧院票务系统的一部分是用Clojure编写的。我们希望确认我们传递的任何票都有一个`id`和`amount`。可选地，我们允许`notes`。我们可以像这样定义一个规范：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that the keys here are all namespaced with `:ticket`. This is considered
    good form for Clojure map keys, because it allows us to maintain a distinction
    between, say, the `amount` a ticket costs and the `amount` of seats available
    in a given venue. Should you need to use non-namespaced keys, the various functions
    like `req` provide alternate versions by appending `-un`, such as, `req-un`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里的键都是用`:ticket`命名空间化的。这在Clojure的map键中被认为是良好的形式，因为它允许我们在票价和特定场所可用的座位数之间保持区分。如果您需要使用非命名空间化的键，各种函数如`req`会通过添加`-un`提供替代版本，例如，`req-un`。
- en: 'Calling `conform` on a map will validate the presence of the keys we’ve spelled
    out. It also allows unspecified keys alongside the required keys, as illustrated
    next:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个映射上调用`conform`将验证我们已明确指定的键的存在。它还允许在必需键旁边有未指定的键，如下所示：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Namespacing keys clearly shows its value, though, in how seamlessly it works
    with our prior value checking. If a key name has a registered spec, then that
    value will be validated when we `conform`, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间化键清楚地显示了它的价值，尤其是在它如何与我们的先前值检查无缝工作。如果一个键名有一个已注册的规范，那么在`conform`时，该值将被验证，如下所示：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`clojure.spec` provides a rich set of abilities for validating our data. But
    Clojure’s focus on how we interact with data doesn’t end there.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`clojure.spec`为我们提供了丰富的数据验证能力。但Clojure对如何与数据交互的关注并不仅限于此。'
- en: 14.3.3 test.check
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.3 test.check
- en: When we’re writing tests, a lot of our time is spent picking good data to exercise
    our code. Whether it’s building out representative objects or finding the values
    at the edges of our validation, much energy goes into this search for what to
    test.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写测试时，我们的大部分时间都花在挑选好的数据来测试我们的代码上。无论是构建代表性的对象还是找到验证的边缘值，我们在这个寻找要测试的内容上投入了大量的精力。
- en: Property-based testing turns this relationship on its head. Instead of constructing
    examples to execute, we instead define *properties* that should hold true for
    our functions and then feed in randomized data to ensure those properties are
    true.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试将这种关系颠倒过来。我们不是构建示例来执行，而是定义应该对我们函数成立的*属性*，然后输入随机数据来确保这些属性是真实的。
- en: Note Much of the recent buzz around property-based testing is credited to the
    Haskell library, QuickCheck ([https://hackage.haskell.org/package/ QuickCheck](https://hackage.haskell.org/package/QuickCheck)).
    Other languages have equivalents, such as Hypothesis ([https://hypothesis.readthedocs.io/en/latest/](https://hypothesis.readthedocs.io/en/latest/))
    in Python. In Clojure, this is provided by the `test.check` library.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：最近围绕基于属性的测试的热潮归功于Haskell库QuickCheck ([https://hackage.haskell.org/package/QuickCheck](https://hackage.haskell.org/package/QuickCheck))。其他语言也有等效的库，例如Python中的Hypothesis
    ([https://hypothesis.readthedocs.io/en/latest/](https://hypothesis.readthedocs.io/en/latest/))。在Clojure中，这由`test.check`库提供。
- en: This paradigm of testing is a significant change from the traditional unit testing
    most folks have experienced. In the sort of testing we’ve seen so far, you expect
    100% deterministic results. Any flakiness in running the tests is a sign of a
    poorly written test and should be eradicated.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试范式与传统单元测试相比是一个重大的变化。在我们迄今为止看到的测试中，你期望100%的确定性结果。测试运行中的任何波动都是测试编写不佳的迹象，应该被消除。
- en: Why is property-based testing different—not only allowing but relying on randomized
    data? For one, although the inputs are randomized, failure doesn’t indicate a
    faulty test—it reveals that our understanding of the system, as expressed by the
    properties we’ve defined, is wrong. In effect, property-based tests find edge
    cases our manually selected data might have missed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么基于属性的测试不同——不仅允许，而且依赖于随机数据？一方面，尽管输入是随机的，但失败并不表明测试有误——它揭示了我们对系统的理解，即通过我们定义的属性表达，是错误的。实际上，基于属性的测试发现了手动选择的数据可能遗漏的边缘情况。
- en: This isn’t an argument for entirely abandoning more traditional unit tests,
    either. It’s reasonable to supplement our typical testing with property-based
    tests, especially in areas where incoming data presents a lot of variety that
    could trip us up.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这也不是完全放弃更传统单元测试的论点。用基于属性的测试补充我们的典型测试是合理的，尤其是在输入数据种类繁多、可能让我们陷入困境的领域。
- en: 'Unlike `clojure.test` and `clojure.spec`, `test.check` is a separate package,
    not in Clojure’s standard library. To use it in our REPL, we’ll have to tell Clojure
    about this dependency. The simplest way to do this is to put a file called `deps.edn`
    in the same directory where we run `clj`. That file instructs Clojure to download
    the library from the Maven repository as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与`clojure.test`和`clojure.spec`不同，`test.check`是一个独立的包，不在Clojure的标准库中。要在我们的REPL中使用它，我们必须告诉Clojure这个依赖项。最简单的方法是在运行`clj`的同一目录中放置一个名为`deps.edn`的文件。该文件指示Clojure从Maven仓库下载库，如下所示：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You’ll need to restart the `clj` REPL after creating the `deps.edn` file. You
    should see messages the first time you start the REPL indicating it’s downloading
    the necessary JARs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`deps.edn`文件后，您需要重新启动`clj` REPL。您第一次启动REPL时应看到消息，表明它正在下载必要的JAR文件。
- en: 'Property-based testing has two big parts: how you define properties to check
    about your code, and how you generate the randomized data to test those. Let’s
    start off by configuring generators for our data, which may help inspire us for
    properties we could check.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试有两个主要部分：如何定义要检查代码的属性，以及如何生成随机数据来测试这些属性。让我们先从配置数据生成器开始，这可能会激发我们检查属性的想法。
- en: '`test.check` provides its main support for creating randomized data in the
    `generators` package. We’ll pull in the whole package and alias it to `gen` for
    a little less typing like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`test.check`在`generators`包中为主创建随机数据提供支持。我们将引入整个包，并将其别名为`gen`，以减少一些输入，如下所示：'
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Two main functions serve as our entry point into generating random data: `generate`
    and `sample`. `generate` get a single value, and `sample` gets a set of values
    instead. Each of these functions requires a generator, of which many are built-in.
    For instance, here we can simulate flipping a coin by generating randomized Boolean
    values:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 两个主要函数作为我们生成随机数据的入口点：`generate`和`sample`。`generate`获取单个值，而`sample`获取一组值。这些函数都需要一个生成器，其中许多是内置的。例如，我们可以通过生成随机的布尔值来模拟抛硬币：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The basic generators provided by `test.check` cover much of what you need for
    primitive types in Clojure. Here’s a sampling of their usage. You can see the
    docs at [http://mng.bz/6XoD](http://mng.bz/6XoD) for further details and additional,
    optional parameters that some of these generators take:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`test.check`提供的基本生成器涵盖了Clojure中原始类型的大部分需求。以下是一些使用示例。您可以在[http://mng.bz/6XoD](http://mng.bz/6XoD)上查看文档以获取更多详细信息以及一些生成器可能接受的附加可选参数：'
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ Small, natural (non-negative) integers
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 小的自然（非负）整数
- en: ❷ Small integers, including negatives
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 包括负数在内的小整数
- en: ❸ Larger integers, including negatives
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 包括负数在内的较大整数
- en: ❹ Choose from the provided integer range
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从提供的整数范围内选择
- en: ❺ Any Clojure value
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 任何Clojure值
- en: ❻ Any valid Clojure string
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 任何有效的Clojure字符串
- en: ❼ Any string of alphanumeric characters
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 任何字母数字字符串
- en: ❽ Choose from a list of elements
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 从元素列表中选择
- en: ❾ Create a list based on the provided generator
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 根据提供的生成器创建列表
- en: These generators can be useful for a type of testing referred to as *fuzzing*.
    The practice of fuzzing, frequently used in the security field, throws varied,
    and particularly invalid, data at a system to see where it breaks down. Often
    the examples we test against aren’t imaginative enough, particularly when it comes
    to input from the outside world. Generators allow us an easy way to strengthen
    our testing with data we wouldn’t have thought up.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些生成器对于一种称为 *fuzzing* 的测试类型非常有用。fuzzing的实践，在安全领域经常使用，向系统投掷各种数据，特别是无效数据，以查看它在哪里崩溃。通常，我们测试的例子并不够有创意，尤其是当涉及到来自外部世界的输入时。生成器为我们提供了一个简单的方法，用我们不会想到的数据来加强我们的测试。
- en: 'Imagine our ticketing application allows open text input for notes but would
    like to try to extract keywords. If our application is internet facing, we never
    want that function to throw unexpected exceptions. We could fuzz it like so:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们的票务应用程序允许开放文本输入备注，但希望尝试提取关键词。如果我们的应用程序面向互联网，我们绝对不希望该函数抛出意外异常。我们可以这样fuzz它：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ doall ensures Clojure doesn’t lazily ignore our map because its return value
    is unused.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `doall` 确保Clojure不会因为其返回值未使用而懒加载我们的map。
- en: Fuzzing can be a useful first step, but there are obviously more interesting
    properties for our functions than “doesn’t crash unexpectedly.”
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Fuzzing可以是一个有用的第一步，但显然，我们的函数比“不会意外崩溃”有更多有趣的属性。
- en: Revisiting our theater ticketing system, the owners are now interested in a
    new feature where people can bid on tickets. A complex algorithm has been purchased
    from a machine learning consultancy to maximize the number of people who will
    purchase in a given set of bid prices. The algorithm guarantees that it won’t
    offer a price outside of the ranges of the bids provided.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的剧院票务系统，所有者现在对一项新功能感兴趣，即人们可以竞标门票。已经从机器学习咨询公司购买了一个复杂的算法，以最大化在给定的一组竞标价格中购买的人数。该算法保证它不会提供超出提供的竞标价格范围的任何价格。
- en: 'We haven’t received the code yet, but we want to be prepared to check their
    claims when it does arrive. Until then, we’ve provided a stub implementation,
    shown next, which, given a list of bid prices, will randomly pick one:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有收到代码，但当我们收到时，我们想要准备好检查他们的声明。在此之前，我们已经提供了一个占位符实现，如下所示，它给定一个竞标价格列表，将随机选择一个：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let’s examine how we can use `test.check` to define the properties about our
    bidding function. In addition to the generators that we pulled in earlier, we’ll
    need to require the functions in both `clojure.test.check` and `clojure.test.check.properties`,
    as shown here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用 `test.check` 来定义关于我们的竞标函数的属性。除了我们之前拉入的生成器之外，我们还需要在 `clojure.test.check`
    和 `clojure.test.check.properties` 中引入函数，如下所示：
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The first property we’ll look to check—and most important to theater owners!—is
    that we’ll never return a bid smaller than what someone has offered:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的第一个属性——对剧院所有者来说最重要的是——是我们永远不会返回一个比有人提供的竞标价更低的竞标价：
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There’s a lot going on in this small snippet, so let’s break it down. First
    off, our `def bigger-than-minimum` is giving our property a name for referencing
    later. It’s important to remember that this is only defining the property, not
    actually checking it yet.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小片段中有很多内容，所以让我们来分解一下。首先，我们的 `def bigger-than-minimum` 给我们的属性起了一个名字，以便稍后引用。重要的是要记住，这只是在定义属性，还没有实际检查它。
- en: The next line declares `prop/for-all`, which is how we state a property we want
    to check. It’s followed by a list that determines how we’ll generate data and
    what to bind those values to. `[prices (gen/not-empty (gen/list gen/nat))]`. `prices`
    gets each generated value in turn from the generator statement following it. In
    this case we’re asking for a list of natural (non-negative) integers that is not
    empty.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条语句声明了 `prop/for-all`，这是我们声明想要检查的属性的方式。它后面跟着一个列表，确定了我们将如何生成数据以及将这些值绑定到什么上。`[prices
    (gen/not-empty (gen/list gen/nat))]`。`prices` 依次从随后的生成器语句中获取每个生成的值。在这种情况下，我们请求一个非空的自然（非负）整数列表。
- en: The final line finally expresses the actual logic of our property. `(<= (apply
    min prices) (bid-price prices))` finds the minimum value in our generated list,
    calls our bid function on that same list, and assures the bid isn’t smaller than
    the minimum.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句最终表达了我们的属性的实际逻辑。`(<= (apply min prices) (bid-price prices))` 找到我们生成的列表中的最小值，对同一列表调用我们的竞标函数，并确保竞标价格不低于最小值。
- en: 'With that, we can now ask `test.check` to run a set of generated values against
    the property as follows. The `quick-check` function requires a number of iterations
    to try and a property to check:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以要求`test.check`运行一组生成的值来检查属性，如下所示。`quick-check`函数需要一个迭代次数和一个要检查的属性：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Our property passed! The other condition that was requested—that we don’t offer
    a price larger than anyone bid—is an easy extension to make from what we’ve already
    written, shown next:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的属性通过了！另一个请求的条件——我们不提供比任何出价更高的价格——是从我们已编写的内容中轻松扩展出来的，如下所示：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Although it’s nice that our properties are passing, let’s break them and see
    what happens then. An easy way to do that is to sneak in a little increase to
    the bidding function and recheck our property, like so:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的属性通过测试是件好事，但让我们打破它们，看看会发生什么。一个简单的方法是在出价函数中悄悄增加一点，然后重新检查我们的属性，如下所示：
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, this looks different! Our check failed as we hoped that it would, and
    we’ve got all the information we need to know about the failing case here. In
    particular, the `:smallest [(0)]` key indicates the precise failing value seen
    during the run. We’ve seen the `:seed` in our prior results. If we want to run
    the property again with identical values generated, we can pass that seed into
    the call like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这看起来不同了！正如我们所希望的，检查失败了，我们在这里得到了关于失败案例的所有必要信息。特别是，`:smallest [(0)]`键指示了运行期间看到的精确失败值。我们之前的结果中看到了`:seed`。如果我们想用相同的值再次运行属性，我们可以将种子传递给调用，如下所示：
- en: '[PRE58]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ❶ Passing in the same seed value as before to get the same failure
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 传递与之前相同的种子值以获得相同的失败
- en: A point of interest in the response is the key `:shrunk`. When `test.check`
    finds a failure, it doesn’t just stop and report that. It goes through a process
    of *shrinking*—creating smaller permutations from the failing generated data to
    find a minimal case. This is incredibly useful, especially with more complex randomized
    data. Having the smallest, simplest input that will fail is a huge help for debugging.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 响应中的一个有趣点是键`:shrunk`。当`test.check`发现失败时，它不会只是停止并报告。它会通过一个过程进行*缩小*——从失败的生成数据创建更小的排列，以找到最小的情况。这对于调试非常有用，尤其是在更复杂的数据上。拥有将导致失败的最小、最简单的输入是一个巨大的帮助。
- en: '`test.check` integrates with the base `clojure.test` library. The `defspec`
    function both defines a test (as in `deftest`) and a property simultaneously,
    as shown next:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`test.check`与基础`clojure.test`库集成。`defspec`函数同时定义了一个测试（如`deftest`）和一个属性，如下所示：'
- en: '[PRE59]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The most difficult aspect of property-based testing often isn’t the coding but
    determining the properties themselves. Although our ticketing example and many
    basic algorithms, like sorting, lend themselves to obvious properties, many real-world
    scenarios aren’t as clear cut.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试最困难的部分通常不是编码，而是确定属性本身。虽然我们的票务示例和许多基本算法，如排序，适合明显的属性，但许多现实世界的情况并不那么明显。
- en: 'Here are some ideas where to look for properties in your systems:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些想法，可以在您的系统中寻找属性：
- en: '*Validation and boundaries*—If a function has a condition that you’d validate
    at runtime, such as the limits of a value, the length of a list, or the contents
    of a string, this is a ripe location for defining a property.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*验证和边界*—如果一个函数有一个在运行时需要验证的条件，例如值的限制、列表的长度或字符串的内容，那么这是一个定义属性的绝佳位置。'
- en: '*Round-tripping data*—A common operation in many systems is transforming data
    between various formats. Maybe we receive one type of data on our web request
    and need to convert it to a different shape before storing it in the database.
    For these cases, we can define properties showing that a value will round-trip
    successfully through our conversions and back to its original form without loss.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据往返*—在许多系统中，转换数据格式是一个常见的操作。也许我们在网络请求中收到一种类型的数据，需要将其转换为不同的形状才能存储到数据库中。对于这些情况，我们可以定义属性来显示值将成功通过我们的转换并返回其原始形式，而不会丢失。'
- en: '*Oracles*—Sometimes we end up writing replacements for existing functionality.
    This may be for performance, better readability, or any number of other reasons.
    If we have an alternative path that we consider to be the “right” answer, this
    can serve as a rich source of properties to compare, even if only during development
    of the replacements.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*预言机*—有时我们最终会编写替代现有功能的内容。这可能是因为性能、更好的可读性或其他许多原因。如果我们有一个我们认为的“正确”答案的替代路径，这可以作为一个丰富的属性比较来源，即使只是在开发替代品的过程中。'
- en: 14.3.4 clojure.spec and test.check
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.4 clojure.spec 和 test.check
- en: '`test.check` provides a rich set of generators for the primitives in Clojure,
    but we almost always end up working with richer structures. Writing out accurate
    generators for those more complex shapes can be tedious and difficult.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`test.check`为Clojure中的原始数据提供了丰富的生成器集，但我们几乎总是处理更丰富的结构。为这些更复杂的形状编写准确的生成器可能会很繁琐且困难。'
- en: Fortunately, `clojure.spec` helps close this gap. `clojure.spec` lets us describe
    our higher-level data structures generically, and it can automatically turn those
    into `test.check`-compatible generators that would be messy to define by hand.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`clojure.spec`有助于缩小这个差距。`clojure.spec`允许我们以通用方式描述我们的高级数据结构，并且它可以自动将这些转换为`test.check`兼容的生成器，这些生成器手动定义可能会很复杂。
- en: 'To refresh, here are the definitions for our ticketing structure—both the map
    requirements and the constraints on values:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了刷新，以下是我们的票据结构定义——包括映射要求和值上的约束：
- en: '[PRE60]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `gen` function in `clojure.spec.alpha` will convert a spec into a generator.
    We can then pass that generator to the same `test.check` functions methods we’ve
    used previously to create randomized data like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`clojure.spec.alpha`中的`gen`函数会将规范转换为生成器。然后我们可以将这个生成器传递给之前用于创建类似这种随机数据的相同`test.check`函数方法：'
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This random ticket already reveals corners we may not have considered in our
    spec: Do we really want negative IDs? Should we enforce a range on the amount
    for our tickets? Looks like we’ve got more specification and testing to do!'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这张随机票据已经揭示了我们在规范中可能没有考虑到的角落：我们真的想要负ID吗？我们应该对我们的票据金额实施范围限制吗？看起来我们还需要做更多的规范和测试工作！
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Testing isn’t one-size-fits-all. Different techniques have different strengths.
    Test code is an excellent spot to mix and match libraries and languages to enhance
    those strengths.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试并非一刀切。不同的技术有不同的优势。测试代码是混合和匹配库和语言的绝佳场所，以增强这些优势。
- en: Other languages, like Kotlin and Clojure, can open up styles of testing that
    are harder to accomplish in Java.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他语言，如Kotlin和Clojure，可以开启在Java中难以实现的测试风格。
- en: Integration testing—interacting with datastores and other services—can be finicky
    and error prone. Testcontainers provides smooth integration for approaching these
    external dependencies, leveraging the knowledge we have of containers from chapter
    12.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试——与数据存储和其他服务交互——可能会很棘手且容易出错。Testcontainers提供了平滑的集成方式来处理这些外部依赖，利用我们从第12章学到的容器知识。
- en: How we write our specification influences how we think about our systems. Spek
    in Kotlin, and similar specification-style testing frameworks elsewhere, provide
    an alternative to the code-focused JUnit type of tests. We saw how it can level
    up the communication in our testing.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何编写规范会影响我们对我们系统的思考方式。使用Kotlin编写的Spek，以及其他类似规范风格的测试框架，为以代码为中心的JUnit类型测试提供了一种替代方案。我们看到了它如何提升我们的测试沟通。
- en: Last, we took an entirely different approach to testing from “write an example
    and check the result” with property-based testing in Clojure. From generating
    random data, defining global properties of our system, all the way to shrinking
    failures to the smallest possible input, property-based testing opens new avenues
    to ensuring the quality of our systems.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们采用了与“编写示例并检查结果”完全不同的测试方法，即使用Clojure的基于属性的测试。从生成随机数据，定义我们系统的全局属性，到将失败缩小到可能的最小输入，基于属性的测试为确保我们系统的质量开辟了新的途径。
